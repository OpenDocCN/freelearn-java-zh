<html><head></head><body><div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Understanding Algebraic Structures</h1>
                </header>
            
            <article>
                
<p class="p1">In the previous chapter, we looked at some standard Scala effects and identified lots of similarities among them. We also promised to dive deeper and find out what principles underly these commonalities.</p>
<p class="p1">Before diving deep into the ocean of abstractions, let's fish for the simpler concepts first to gain some familiarity and skill working with them.</p>
<p class="p1">In this chapter, we’ll take a look at a few abstract algebraic structures—structures that are fully identified by the laws defining them. We will start with a simpler yet usable abstraction and advance to more complex topics.</p>
<p>In this chapter, we will take a look at the following topics:</p>
<ul>
<li>Semigroup</li>
<li>Monoid</li>
<li>Foldable</li>
<li>Group</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p>Before we begin, make sure you have the following installed:</p>
<ul>
<li>Java 1.8+</li>
<li><span>SBT 1.2+</span></li>
</ul>
<p><span>The source code for this chapter is available under our GitHub repository at: <a href="https://github.com/PacktPublishing/Learn-Scala-Programming/tree/master/Chapter07">https://github.com/PacktPublishing/Learn-Scala-Programming/tree/master/Chapter07</a>.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Introduction to abstract algebraic structures</h1>
                </header>
            
            <article>
                
<p>An abstract algebraic structure is something that is fully defined by a set of laws. Abstract algebraic structures have their roots in category theory, a branch of mathematics dedicated to studying them.</p>
<p>The "abstractness" of the topic has two consequences for us. First, we need to get into a specific state of mind and talk about things in general as opposed to the concrete implementations that we were discussing up until now. Second, the structures we'll be looking at, the semigroup, monoid, group, and foldable, are applicable to a wide spectrum of cases, and each case can lead to the implementation of the abstract concept at hand. If this sounds too theoretical, don't worry; we'll get practical in a moment with <kbd>Semigroup</kbd>.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Semigroup</h1>
                </header>
            
            <article>
                
<p><span><span>S</span></span>emigroup is probably the simplest yet most useful algebraic structure. It is fully defined by two qualities:</p>
<ul>
<li>It is defined for some (possibly infinite) set of elements</li>
<li>It has a binary operation defined for any pairs of elements in this set</li>
</ul>
<p>It also has the following two properties:</p>
<ul>
<li>The operation is closed, which means that the result of the operation belongs to the same set as its operands</li>
<li>The operation is associative, meaning that multiple operations should produce the same result, regardless of the order in which they are applied</li>
</ul>
<p>We can translate these definitions into the Scala code almost literally:</p>
<pre><span>trait </span>Semigroup[<span>S</span>] {<br/> <span>def </span>op(l: <span>S</span>, r: <span>S</span>): <span>S<br/></span>}</pre>
<p><kbd>S</kbd> denotes the type that the set elements belong to, and <kbd>op</kbd> denotes the operation. The result type is also <kbd>S</kbd>—we have defined the property of closeness of the operation on the type level. Formally, it is said that <kbd>S</kbd> <em>forms a semigroup under op</em>.</p>
<p>Readers that are familiar with <a href="dba6e932-4169-4b60-9bde-26ac2073a1ab.xhtml">Chapter 5</a>, <em>Property-Based Testing in Scala</em>, will also remember that we talked about associativity as one of the ways to formulate <kbd>ScalaCheck</kbd> properties. It is very easy to define this property to check the second semigroup law in the same way we mentioned earlier:</p>
<pre><span>import org.scalacheck._<br/>import org.scalacheck.Prop._<br/>def </span>associativity[<span>S </span>: Semigroup : Arbitrary]: Prop =<br/>  <span>forAll</span>((a: <span>S</span>, b: <span>S</span>, c: <span>S</span>) =&gt; {<br/>    <span>val </span>sg = <span>implicitly</span>[Semigroup[<span>S</span>]]<br/>    sg.op(sg.op(a, b), c) == sg.op(a, sg.op(b, c))<br/>  })</pre>
<p>We need the <kbd>S</kbd> type to have a <kbd>Semigroup</kbd> and <kbd>Arbitrary</kbd>, the former of which we need to get the implementation we want to check and the latter to be able to generate random data for <kbd>S</kbd>.</p>
<p>The property itself, <kbd>sg.op(sg.op(a, b), c) == sg.op(a, sg.op(b, c))</kbd>, just verify that operations that are applied in a different order produce the same result—exactly as specified verbally.</p>
<p><span>Please note that properties we define in this chapter can also be executed by running tests in SBT directly. To do this, it is enough to start the SBT session and type <span class="packt_screen">test</span> followed by the <em>Enter</em> key.</span></p>
<p>OK, we now have a definition of a semigroup for <kbd>S</kbd> and a way to check that the semigroup is properly implemented, but what are these <kbd>S</kbd>'s? Well, this is the beauty of the abstract algebraic data structure. The <kbd>S</kbd> can be absolutely anything as long as semigroup laws hold. As an example, we can stick to our figure of speech regarding fishing.</p>
<p>We can specify at least two <kbd>eat</kbd> operations for <kbd>S</kbd> that are defined on all of the fish. The <em><span>the big</span><em> fish eats the little fish</em></em><span> operation is defined on two fish with the result that the bigger fish has a volume equal to the sum of the volumes of both fish participating in the operation. Similarly,</span> <em>the heavy fish eats the light fish</em><span> is defined by the same principle but in terms of the fish's weight. It's easy to see that the first property of this semigroup holds by definition. The following diagrams represent the proof for the</span> second <span>property. The first diagram illustrates the associativity of the</span> <em>Big eats small/Heavy eats light</em><span> operation on the fish:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/8d9a645c-9ffa-49b2-9a8c-6ef69050c483.png" width="1950" height="650"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Figure 1: Big fish eats small fish/Heavy fish eats light fish</div>
<p>The following diagram illustrates the same property for the <em>More teeth win</em> rule:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/34508783-6cb4-417b-b87b-d0aec9c0d350.png" width="1950" height="456"/></div>
<div>
<div class="packt_figref CDPAlignCenter CDPAlign">Figure 2: More teeth win</div>
<p>This final illustration shows that <span>associativity also holds for the property of toxicity: </span></p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/90cab0be-a578-4c76-9789-90edfe538bc4.png" width="1950" height="472"/></div>
</div>
<div>
<div class="packt_figref CDPAlignCenter CDPAlign">Figure 3. Combinations of toxic fish</div>
</div>
<p>The semigroup operation does not need to be an addition. For instance, we can define it so that, from both participants, the most poisonous fish is on the left as a result. This book has no age restriction, so we should pretend that the second fish was scared away in the process. But experienced fishers know the creatures—instead, we have to constrain the semigroup for this operation to the set of all <em>living</em> fish, which allows us to avoid ambiguity for the result of the operation.</p>
<p>As per our analogy, we could define another operation in terms of teeth—the fish with the bigger teeth is on the left as a result of the operation. Again, to avoid ambiguity, our semigroup is formed by <em>solid</em>, living fish under this operation.</p>
<p>In order to implement the semigroups we just defined, we need a definition of fish. Let's have it represented as a case class:</p>
<pre><span>final case class </span>Fish(volume: Int, size: Int, teeth: Int, poisonousness: Int)</pre>
<p>The relevant properties are represented as fields.</p>
<p>Let's start with the big and small fish semigroup. The law checking property we defined previously requires an implicit semigroup in scope, so we'll mark our instance as <kbd>implicit</kbd>:</p>
<pre><span>implicit val </span><span>volumeSemigroup</span>: Semigroup[Fish] = (l: Fish, r: Fish) =&gt; {<br/>  <span>val </span>result = <span>if </span>(l.volume &gt;= r.volume) l <span>else </span>r<br/>  result.copy(volume = r.volume + l.volume)<br/>}</pre>
<p>We can check which fish wins by comparing their volumes. The bigger fish incorporates the volume of the fish eaten during the operation.</p>
<p>At the moment, some of you must be scratching your heads, trying to remember why this structure looks so familiar. The astute reader will have already recognized the <em>type class pattern</em> we talked about in <a href="20767c8e-f580-4760-9e64-371c8fc523c6.xhtml">Chapter 4</a>, <em>Getting to Know Implicits and Type</em> <em>Classes</em>. Good job, <span>astute</span> reader!</p>
<p>Our implementation is so simple that it cannot be incorrect, but for completeness' sake, let's define a property for it. First, we need a generator for <kbd>Fish</kbd>:</p>
<pre><span>val </span><span>fishGen</span>: Gen[Fish] = <span>for </span>{<br/>  weight &lt;- Gen.<span>posNum</span>[Int]<br/>  volume &lt;- Gen.<span>posNum</span>[Int]<br/>  poisonousness &lt;- Gen.<span>posNum</span>[Int]<br/>  teeth &lt;- Gen.<span>posNum</span>[Int]<br/>} <span>yield </span><span>Fish</span>(volume, weight, teeth, poisonousness)<br/><br/><span>implicit val </span><span>arbFish</span>: Arbitrary[Fish] = Arbitrary(<span>fishGen</span>)</pre>
<p>We implement it by combining generators for single properties, exactly as we did in <a href="20767c8e-f580-4760-9e64-371c8fc523c6.xhtml">Chapter 4</a><span>, </span><em>Getting to Know Implicits and Type</em><span> </span><em>Classes</em>. Now, defining the check itself boils down to importing the proper implicit and delegating to the property we defined previously:</p>
<pre><span>property</span>(<span>"associativity for fish semigroup under 'big eats little'"</span>) = {<br/><span>  </span><span>associativity</span>[Fish]<br/>}</pre>
<p>The definitions of the properties in this chapter cannot be pasted in REPL because they need to be placed in a test wrapper. Please see the accompanying code to see how it is done.</p>
<p>Running this property is also done in the same way as in <a href="20767c8e-f580-4760-9e64-371c8fc523c6.xhtml">Chapter 4</a><span>, </span><em>Getting to Know Implicits and Type</em><span> </span><em>Classes</em>, so there should be no surprises here:</p>
<pre>scala&gt; associativity[Fish]<br/>res1: org.scalacheck.Prop = Prop<br/>scala&gt; .check<br/>! Falsified after 3 passed tests.<br/>&gt; ARG_0: Fish(2,3,2,1)<br/>&gt; ARG_1: Fish(2,3,3,3)<br/>&gt; ARG_2: Fish(3,2,3,2)</pre>
<p>Ouch, it turns out there are surprises! Our implementation does not satisfy the associativity requirements for the case where the fish have the same volume!</p>
<p>This little case demonstrates how important it <span>is </span>to check that an implementation of an abstract algebraic structure obeys the laws defined for it for all possible input values. In our case, we don't actually have a proper semigroup implementation yet. Let's fix that by pretending that the bigger fish incorporates all of the properties of the eaten one. This might look strange for the number of teeth and venom, but we're talking about abstractions, after all:</p>
<pre><span>final case class </span>Fish(volume: Int, weight: Int, teeth: Int, poisonousness: Int) {<br/>  <span>def </span>eat(f: Fish): Fish = <span>Fish</span>(volume + f.volume, weight + f.weight, teeth + f.teeth, poisonousness + f.poisonousness)<br/>}</pre>
<p>This gives us a slightly <span>simpler</span> semigroup implementation:</p>
<pre><span>implicit val </span><span>volumeSemigroup</span>: Semigroup[Fish] = (l: Fish, r: Fish) =&gt;<br/>  if (l.volume &gt; r.volume) l.eat(r) else r.eat(l)</pre>
<p>In the case of the fish being of an equal volume, the right fish wins. This is a random choice, but this makes our semigroup right-biased.</p>
<p>Let's retry our check (if you're playing with the code in REPL, you'll need to paste the definition of <kbd>fishGen</kbd> and <kbd>arbFish</kbd> again to apply them to the new definition of the <kbd>Fish</kbd>):</p>
<pre>scala&gt; associativity[Fish]<br/>res10: org.scalacheck.Prop = Prop<br/>scala&gt; .check<br/>+ OK, passed 100 tests.</pre>
<p>This states that we are on the right track—it passes.</p>
<p>We can define and check other semigroups by analogy:</p>
<pre><span>implicit val </span><span>weightSemigroup</span>: Semigroup[Fish] = (l: Fish, r: Fish) =&gt;<br/>  <span>if </span>(l.weight &gt; r.weight) l.eat(r) <span>else </span>r.eat(l)<br/><br/><span>implicit val </span><span>poisonSemigroup</span>: Semigroup[Fish] = (l: Fish, r: Fish) =&gt;<br/> <span>if </span>(l.poisonousness &gt; r.poisonousness) l <span>else </span>r<br/><br/><span>implicit val </span><span>teethSemigroup</span>: Semigroup[Fish] = (l: Fish, r: Fish) =&gt;<br/> <span>if </span>(l.teeth &gt; r.teeth) l <span>else </span>r</pre>
<p>This code reflects our earlier discussion about how different attributes of the fish work during the operation. The definition is basically always the same; it just refers to the different properties of the fish! We omitted the definition of the <kbd>ScalaCheck</kbd> properties because they are identical to the ones we already looked at.</p>
<p>It would be a disappointment if semigroups were only useful in the realm of fishing. Let's take a look at another example—mixing colored shapes:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/e0429374-d3ba-44d6-8909-8994442e5541.png" style="width:27.75em;height:9.00em;" width="418" height="136"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Figure 3: Colored circles with different transparency levels</div>
<p>We can pick one of the following operations to work with:</p>
<ul>
<li>Combine transparency </li>
<li>Combine shapes</li>
<li>Combine colors (represented as textures on the image)</li>
</ul>
<p>These are represented in the following diagrams. The first addresses the transparency:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/61ba75dd-f89f-465b-8bfd-f9c3098f5890.png" style="width:39.08em;height:5.00em;" width="1993" height="255"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Figure 4: Combining transparencies</div>
<p>The second is about combining shapes in a consistent way:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/375c9416-1e59-4cd0-952d-41329bd02f4b.png" style="width:39.08em;height:5.00em;" width="1993" height="255"/></div>
<div>
<div class="packt_figref CDPAlignCenter CDPAlign">Figure 5: Combining shapes</div>
<p>This final diagram shows us that combining colors (fillings) produces the same result as well:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/0a3f80cc-3dc1-41c7-94d0-8e9c6a6e987c.png" style="width:38.42em;height:4.92em;" width="1993" height="255"/></div>
<div>
<div class="packt_figref CDPAlignCenter CDPAlign">Figure 6: Combining colors (fillings)</div>
</div>
</div>
<p>The preceding diagrams provide proof that the associative law holds and that the closure property<span> </span><span>again </span>holds by definition.</p>
<p>Have you noticed the commonality between both the fishing and shapes examples? We pick a numeric property of the entity and apply an operation to this property. For instance, all of our fishing examples can be reduced to just two cases: integer addition (for volume and weight<span>)</span> and integer comparison (for teeth and poisonousness).</p>
<p>Of course, we also can specify semigroups for these cases. The numbers form a semigroup under addition as well as under multiplication. We can demonstrate this with an example of the <kbd>Int</kbd> type:</p>
<pre><span>implicit val </span><span>intAddition</span>: Semigroup[Int] = (l: Int, r: Int) =&gt; l + r<br/><span>implicit val </span><span>intMultiplication</span>: Semigroup[Int] = (l: Int, r: Int) =&gt; l * r<br/><br/><span>property</span>(<span>"associativity for int under addition"</span>) = {<br/>  <span>import </span>Semigroup.<span>intAddition<br/></span><span>  </span><span>associativity</span>[Int]<br/>}<br/><span>property</span>(<span>"associativity for int under multiplication"</span>) = {<br/>  <span>import </span>Semigroup.<span>intMultiplication<br/></span><span>  </span><span>associativity</span>[Int]<br/>}</pre>
<p>This definition is completely analogous to what we had before, and so is the result of the execution of the test command in SBT:</p>
<pre>+ Semigroup.associativity for int under addition: OK, passed 100 tests.<br/>+ Semigroup.associativity for int under multiplication: OK, passed 100 tests.</pre>
<p>Strings form semigroups under concatenation:</p>
<pre><span>implicit val </span><span>stringConcatenation</span>: Semigroup[<span>String</span>] = <br/>  (l: <span>String</span>, r: <span>String</span>) =&gt; l + r<br/><br/>property("associativity for strings under concatenation") = {<br/>  import Semigroup.stringConcatenation<br/>  associativity[String]<br/>}</pre>
<p>This semigroup is implemented entirely like the others, but conceptually this is a bit different from what we had before. In the case of a <kbd>String</kbd>, the operation is defined not in terms of some property but in terms of content. In a sense, we're defining a semigroup for the container of chars and the operation is specified as bringing the contents of both containers together in an ordered fashion.</p>
<p>In our fishing realm, a similar example would be a combination of two fish: one with caviar and one with milk, which would spawn a number of smaller fish as a result. This can't be an example of a semigroup as long as we're talking about single fish because the operation is not closed—we expect a single fish as a result, but the operation returns many of them. We can turn the situation around if we start to talk about buckets of fish. Combining two buckets, each with a single fish, will produce a bucket full of small fish. This operation is closed and if we can prove that it is associative, this would be a valid example of a semigroup.</p>
<p>Switching perspectives from a single item to a container has another subtle effect: it is now possible to have an empty container (bucket) for any operation. In the situation where one of the operands is an empty container, the operation just returns another operand as a result. This makes our abstraction more powerful. It turns a semigroup into a monoid.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Monoid</h1>
                </header>
            
            <article>
                
<p>A monoid is a semigroup with an <em>identity</em> element. Formally, the identity element <kbd>z</kbd> is an element for which an equation, <kbd>z + x = x + z = x</kbd>, holds for any <kbd>x</kbd>. This equation is called identity property. Both closure and associativity properties that are defined for semigroups are also required to hold for a monoid.</p>
<p>The existence of the identity property requires us to implement the monoid, as follows:</p>
<pre><span>trait </span>Monoid[<span>S</span>] <span>extends </span>Semigroup[<span>S</span>] {<br/>  <span>def </span>identity: <span>S<br/></span>}</pre>
<p>The check we specified for the semigroup also needs to be augmented for the monoid to verify that the new property holds:</p>
<pre><span>def </span>identity[<span>S </span>: Monoid : Arbitrary]: Prop =<br/>  <span>forAll</span>((a: <span>S</span>) =&gt; {<br/>    <span>val </span>m = <span>implicitly</span>[Monoid[<span>S</span>]]<br/>    m.op(a, m.identity) == a &amp;&amp; m.op(m.identity, a) == a<br/>  })<br/><br/>def monoidProp[S : Monoid : Arbitrary]: Prop = associativity[S] &amp;&amp; identity[S]</pre>
<p>Now, we can define our first monoid, which will put all of the fish from the two buckets into a single bucket:</p>
<pre><span>type </span><span>Bucket</span>[<span>S</span>] = <span>List</span>[<span>S</span>]<br/><br/><span>implicit val </span><span>mergeBuckets</span>: Monoid[<span>Bucket</span>[Fish]] = <span>new </span>Monoid[<span>Bucket</span>[Fish]] {<br/>  <span>override def </span>identity: <span>Bucket</span>[Fish] = <span>List</span>.<span>empty</span>[Fish]<br/>  <span>override def </span>op(l: <span>Bucket</span>[Fish], r: <span>Bucket</span>[Fish]): <span>Bucket</span>[Fish] = l ++ r<br/>}</pre>
<p>Here, we represent a <kbd>Bucket</kbd> with a <kbd>List</kbd> and just merge two buckets to denote that the contents of both have been put together. Are you curious to check if this implementation is a monoid? The property definition is unspectacular as it just delegates to the <kbd>monoidProp</kbd> we defined before:</p>
<pre><span>implicit val </span><span>arbBucketOfFish</span>: Arbitrary[<span>Bucket</span>[Fish]] = Arbitrary(Gen.<span>listOf</span>(<span>fishGen</span>))<br/><br/><span>property</span>(<span>"bucket of fish monoid"</span>) = {<br/>  <span>import </span>Monoid.<span>mergeBuckets<br/></span><span>  monoidProp</span>[<span>Bucket</span>[Fish]]<br/>}</pre>
<p>But, there is a bit of machinery underneath. First, we need to define a generator for buckets of fish so that we can use it to formulate a combined property of associativity and identity. Luckily, the property holds:</p>
<pre>scala&gt; implicit val arbBucketOfFish: Arbitrary[Bucket[Fish]] = Arbitrary(Gen.listOf(fishGen))<br/>arbBucketOfFish: org.scalacheck.Arbitrary[Monoid.Bucket[Fish]] = org.scalacheck.ArbitraryLowPriority$$anon$1@3dd73a3d<br/>scala&gt; monoidProp[Bucket[Fish]]<br/>res13: org.scalacheck.Prop = Prop<br/>scala&gt; .check<br/>+ OK, passed 100 tests.</pre>
<p>Are monoids only defined for containers? No, they're definitely not. Containers are just a special, comfortable case, because, <span>in the majority of cases, </span>it is obvious what should be an identity element of the corresponding monoid.</p>
<p>Looking away from containers and back to the colors example from the previous section, we can also pick an identity element for the operations we defined there to extend semigroups to monoids:</p>
<ul>
<li>Combining transparency would require a fully transparent identity element</li>
<li>Combining shapes has an identity without a shape—a dot</li>
<li><span>Combining</span> colors might have a white color as an identity (this identity element will make the color less saturated, but it won't change the color itself)</li>
</ul>
<p>We could even be creative and specify an identity element that's suitable for all of these operations—a fully transparent white-colored dot.</p>
<p>How about the other semigroups we've defined so far? From math, we know that natural numbers have identity elements for addition and multiplication, that is, zero and one, respectively. This allows us to upgrade the semigroups we implemented for ints to monoids:</p>
<pre><span>implicit val </span><span>intAddition</span>: Monoid[Int] = <span>new </span>Monoid[Int] {<br/>  <span>override def </span>identity: Int = <span>0<br/></span><span>  </span><span>override def </span>op(l: Int, r: Int): Int = l + r<br/>}<br/><br/><span>implicit val </span><span>intMultiplication</span>: Monoid[Int] = <span>new </span>Monoid[Int] {<br/>  <span>override def </span>identity: Int = <span>1<br/></span><span>  </span><span>override def </span>op(l: Int, r: Int): Int = l * r<br/>}</pre>
<p>This definition is similar to the one we had for the semigroup—we've just added the identity element to it. The implementation of the property check is also identical to what we had before.</p>
<p>Obviously, strings also form a monoid under concatenation and, as we noticed before, the identity element would be an empty container—a blank <kbd>String</kbd>:</p>
<pre><span>implicit val </span><span>stringConcatenation</span>: Monoid[<span>String</span>] = <span>new </span>Monoid[<span>String</span>] {<br/>  <span>override def </span>identity: <span>String </span>= <span>""<br/></span><span>  </span><span>override def </span>op(l: <span>String</span>, r: <span>String</span>): <span>String </span>= l + r<br/>}</pre>
<p>Another nice thing about containers is that it is actually possible to not only define an algebraic structure in terms of the container as a whole, but to the reuse existing algebraic structures that have been defined for its elements.</p>
<p>This is the real power of abstract algebraic structures—they compose!</p>
<p>To demonstrate this, let's cheat a bit and define a weightless and toothless non-poisonousness fish with zero volume as an identity element for our fishing examples. Here is a definition for the <em>big fish eats little fish</em> monoid:</p>
<pre><span>val </span><span>ZeroFish </span>= <span>Fish</span>(<span>0</span>,<span>0</span>,<span>0</span>,<span>0</span>)<br/><br/><span>implicit val </span><span>weightMonoid</span>: Monoid[Fish] = <span>new </span>Monoid[Fish] {<br/>  <span>override def </span>identity: Fish = <span>ZeroFish<br/></span><span>  </span><span>override def </span>op(l: Fish, r: Fish): Fish =<br/>    <span>if </span>(l.weight &gt; r.weight) l.eat(r) <span>else </span>r.eat(l)<br/>}</pre>
<p><span>The monoids for the other three cases are implemented similarly by adding a <kbd>ZeroFish</kbd> as an identity element to all of them. </span></p>
<p>Having this definition in scope, we can now implement the survival logic for two buckets of fish. First, we'll form a pair of fish from both buckets, and then one fish from the pair should survive:</p>
<pre><span>implicit def </span>surviveInTheBucket(<span>implicit </span>m: Monoid[Fish]): Monoid[<span>Bucket</span>[Fish]] =<br/>  <span>new </span>Monoid[<span>Bucket</span>[Fish]] {<br/><span>    override def identity: Bucket[Fish] = List.fill(100)(ZeroFish)<br/></span><span>    </span><span>override def </span>op(l: <span>Bucket</span>[Fish], r: <span>Bucket</span>[Fish]): <span>Bucket</span>[Fish] = {<br/>      <span>val </span>operation = (m.op _).tupled<br/>      l zip r map operation<br/>    }<br/>  }</pre>
<p>Here, we define our monoid in terms of a simpler monoid. The operation itself is built from the original operation converted to the tuple form and is applied to the pairs of fish from both buckets. This is defined for buckets of size less or equal than <kbd>100</kbd> because the identity bucket for this operation needs to contain enough <kbd>ZeroFish</kbd> in the case that the buckets we're combining have a different number of elements.</p>
<p>Now, we can test out different survival strategies just by having an instance of the desired monoid in scope:</p>
<pre><span>property</span>(<span>"props for survival in the bucket for most poisonousness"</span>) = {<br/>  <span>import </span>Monoid.poisonMonoid<span><br/></span><span>  </span><span>import </span>Monoid.<span>surviveInTheBucket<br/></span><span>  monoidProps</span>[<span>Bucket</span>[Fish]]<br/>}</pre>
<p>We need to import both monoids in scope so that the implicit resolution works properly. In this example, from every pair of fish, the more toxic fish will survive. This can easily be changed by bringing a different monoid into scope, for example, the <kbd>weightMonoid</kbd> gives heavier fish a chance of survival:</p>
<pre>scala&gt; {<br/>     | import ch07.Monoid.weightMonoid<br/>     | import ch07.Monoid.surviveInTheBucket<br/>     | monoidProp[Bucket[Fish]]<br/>     | }<br/>res3: org.scalacheck.Prop = Prop<br/><br/>scala&gt; .check<br/>+ OK, passed 100 tests.</pre>
<p>We can check and see that the properties of the derived monoid hold. This can even be proved mathematically—by zipping two monoids, we created a product monoid, which has been proven to obey monoid laws.</p>
<p>Another interesting aspect of monoids and semigroups is their ability to be used to reduce any iterable collection to a single value.</p>
<p>For instance, the following is the <kbd>reduce</kbd> method that was defined for <kbd>IterableOnce</kbd> from the standard library:</p>
<pre><span>def </span>reduce[<span>B </span>&gt;: <span>A</span>](op: (<span>B</span>, <span>B</span>) =&gt; <span>B</span>): <span>B</span></pre>
<p>This takes an associative binary operator and applies it between all elements of the collection. The type signature tells us that it is a good application for a semigroup as its operation satisfies the requirements of this function:</p>
<pre>scala&gt; val bucketOfFishGen: Gen[List[Fish]] = Gen.listOf(fishGen)<br/>bucketOfFishGen: org.scalacheck.Gen[List[Fish]] = org.scalacheck.Gen$$anon$1@34d69633<br/><br/>scala&gt; val bucket = bucketOfFishGen.sample.get<br/>bucket: List[Fish] = List(Fish(98,44,11,22), Fish(69,15,57,18), ...<br/><br/>scala&gt; bucket.reduce(poisonSemigroup.op)<br/>res7: Fish = Fish(25,6,29,99)</pre>
<p>In the preceding snippet, we generated a random bucket of fish and then applied the <kbd>poisonSemigroup</kbd> to it by specifying its operation as an argument for the <kbd>reduce</kbd> method.</p>
<p>Obviously, any semigroup operation is a perfect fit as soon as types match.</p>
<p>Unfortunately, the implementation of <kbd>reduce</kbd> throws an <kbd>UnsupportedOperationException</kbd> for empty collections, which makes it unsuitable for real functional programming:</p>
<pre>scala&gt; List.empty[Fish].reduce(poisonSemigroup.op)<br/>java.lang.UnsupportedOperationException: empty.reduceLeft<br/>  at scala.collection.IterableOnceOps.reduceLeft(IterableOnce.scala:527)<br/>  at scala.collection.IterableOnceOps.reduceLeft$(IterableOnce.scala:524)<br/>  at scala.collection.AbstractIterable.reduceLeft(Iterable.scala:759)<br/>  at scala.collection.IterableOnceOps.reduce(IterableOnce.scala:496)<br/>  at scala.collection.IterableOnceOps.reduce$(IterableOnce.scala:496)<br/>  at scala.collection.AbstractIterable.reduce(Iterable.scala:759)<br/>  ... 40 elided</pre>
<p>There is a sibling of <kbd>reduce</kbd> called <kbd>reduceOption</kbd> that returns <kbd>None</kbd> <span>for empty collections </span>instead of throwing an exception, but this makes the whole result type optional.</p>
<p>There are a couple of similar methods defined on <kbd>IterableOnce</kbd>. Grouping them together would allow us to represent the "reducibility" property as a standalone concept:</p>
<pre><span>trait </span>Reducible[<span>A</span>] {<br/><br/>  <span>@throws</span>(<span>"UnsupportedOperationException "</span>)<br/>  <span>def </span>reduceLeft(op: (A, <span>A</span>) =&gt; <span>A</span>): <span>A<br/></span><span><br/></span><span>  </span><span>@throws</span>(<span>"UnsupportedOperationException "</span>)<br/>  <span>def </span>reduceRight(op: (<span>A</span>, <span>A</span>) =&gt; <span>A</span>): <span>A<br/></span><span><br/></span><span>  </span><span>@throws</span>(<span>"UnsupportedOperationException "</span>)<br/>  <span>def </span>reduce(op: (<span>A</span>, <span>A</span>) =&gt; <span>A</span>): <span>A </span>= reduceLeft(op)<br/><br/>  <span>def </span>reduceLeftOption(op: (<span>A</span>, <span>A</span>) =&gt; <span>A</span>): Option[<span>A</span>]<br/><br/>  <span>def </span>reduceRightOption(op: (<span>A</span>, A) =&gt; <span>A</span>): Option[<span>A</span>]<br/><br/>  <span>def </span>reduceOption(op: (<span>A</span>, <span>A</span>) =&gt; <span>A</span>): Option[<span>A</span>] = reduceLeftOption(op)<br/><br/>}</pre>
<p>This does not look very nice because, as we have already discussed, the methods either throw an exception or introduce an effect of optionality. How could we improve this implementation? We could make use of the monoids' identity property!</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Foldable</h1>
                </header>
            
            <article>
                
<p>The monoid identity property allows us to handle empty collections in a general way. So, instead of having the following: </p>
<pre>  <span>def </span>reduceLeft(op: (<span>A</span>, <span>A</span>) =&gt; <span>A</span>): <span>A<br/></span></pre>
<p>We'll have a definition that takes an identity element as another parameter. By convention, this approach is called <kbd>fold</kbd>:</p>
<pre>  <span>def </span>foldLeft(identity: A)(op: (<span>A</span>, <span>A</span>) =&gt; <span>A</span>): <span>A<br/></span></pre>
<p>The reason for the name <kbd>foldLeft</kbd> is that the identity element is used as an initial argument for reducing the collection, which leads to the following sequence of calls:</p>
<pre><span>op(</span><span>op(</span>op(op(identity, a1), a2), a3), a4), ...</pre>
<p>Optionally, it is represented in postfix-notation:</p>
<pre>(((identity op a1) op a2) op a3) ...</pre>
<p>Which is, well, kind of folding the collection, starting with the identity and the first element of it.</p>
<p>The associativity of the operation and the identity element tells us that another approach is also possible, starting from the identity and the last element of the collection and then moving toward its head:</p>
<pre>(a1 op (a2 op (a3 op identity))) ...</pre>
<p>Folding in this direction is naturally called <kbd>foldRight</kbd>:</p>
<pre> <span>def </span>foldRight(identity: A)(op: (<span>A</span>, <span>A</span>) =&gt; <span>A</span>): <span>A</span></pre>
<p>The same properties also give us the ability to fold the collection, starting from any place! This is particularly useful in a balanced fold, which works from both ends:</p>
<pre>(a1 op (a2 op identity)) op ((a3 op identity) op a4)</pre>
<p>Interestingly, both sides can be dealt with recursively, in that we can split each of them into two parts and use a balanced fold again. Even more interestingly, as the left and right sides are folded independently from each other, the folding can be done in parallel!</p>
<p>In the same way, as we did for <kbd>Reducible</kbd>, we can group these functions into yet another abstraction, <kbd>MonoidFoldable</kbd>:</p>
<pre><br/><span>trait </span>MonoidFoldable[<span>A</span>, <span>F</span>[_]] {<br/>  <span>def </span>foldRight(as: <span>F</span>[<span>A</span>])(i: <span>A</span>, op: (<span>A</span>,<span>A</span>) =&gt; <span>A</span>): <span>A<br/></span><span>  </span><span>def </span>foldLeft(as: <span>F</span>[<span>A</span>])(i: <span>A</span>, op: (<span>A</span>,<span>A</span>) =&gt; <span>A</span>): <span>A<br/></span><span>  </span><span>def </span>foldBalanced(as: <span>F</span>[<span>A</span>])(i: <span>A</span>, op: (<span>A</span>,<span>A</span>) =&gt; <span>A</span>): <span>A</span><span><br/></span>}</pre>
<p>This time, we define it as a type class that is capable of folding collections of type <kbd>F</kbd> with elements of type <kbd>A</kbd>. For most of the existing collections, instances of this type class should be able to delegate the <kbd>foldLeft</kbd> and <kbd>foldRight</kbd> implementations to the <kbd>F</kbd>. Let's demonstrate this with an instance of <kbd>ListMonoidFoldable</kbd>:</p>
<pre><span>implicit def </span>listMonoidFoldable[<span>A </span>: Monoid]: MonoidFoldable[<span>A</span>, <span>List</span>] = <span>new </span>MonoidFoldable[<span>A</span>, <span>List</span>] {<br/>  <span>private val </span><span>m </span>= <span>implicitly</span>[Monoid[<span>A</span>]]<br/>  <span>override def </span>foldRight(as: <span>List</span>[<span>A</span>])(i: <span>A</span>, op: (<span>A</span>, <span>A</span>) =&gt; <span>A</span>): <span>A </span>= as.foldRight(<span>m</span>.identity)(<span>m</span>.op)<br/><br/>  <span>override def </span>foldLeft(as: <span>List</span>[<span>A</span>])(i: <span>A</span>, op: (<span>A</span>, <span>A</span>) =&gt; <span>A</span>): <span>A </span>= as.foldLeft(<span>m</span>.identity)(<span>m</span>.op)<br/><br/>  <span>override def </span>foldBalanced(as: <span>List</span>[<span>A</span>])(i: <span>A</span>, op: (<span>A</span>, <span>A</span>) =&gt; <span>A</span>): <span>A </span>= as <span>match </span>{<br/>    <span>case </span><span>Nil </span>=&gt; <span>m</span>.identity<br/>    <span>case </span>List(one) =&gt; one<br/>    <span>case </span>_ =&gt; <span>val </span>(l, r) = as.splitAt(as.length/<span>2</span>)<br/>      <span>m</span>.op(foldBalanced(l)(<span>m</span>.identity, <span>m</span>.op), foldBalanced(r)(<span>m</span>.identity, <span>m</span>.op))<br/>  }<br/>}</pre>
<p>First of all, we require that type <kbd>A</kbd> is a monoid. Then, we get an instance of it by using the usual approach of calling implicitly. Then, we implement <kbd>foldRight</kbd> and <kbd>foldLeft</kbd> by calling the corresponding methods on the underlying <kbd>List</kbd>. Finally, we implement <kbd>foldBalanced</kbd> in a head-recursive manner. This implementation splits the list into two halves and folds them independently, exactly as we reasoned before. It is not done in parallel, though.</p>
<p>We can improve on that aspect by utilizing the <kbd>Future</kbd> we discussed in the previous chapter. We introduced a new method, <kbd>foldPar</kbd>, which takes an additional <kbd>implicit</kbd> <kbd>ExecutionContext</kbd>:</p>
<pre><span>def </span>foldPar(as: <span>F</span>[<span>A</span>])(i: <span>A</span>, op: (<span>A</span>,<span>A</span>) =&gt; <span>A</span>)(<span>implicit </span>ec: ExecutionContext): <span>A</span></pre>
<p>The execution context needs to pass over the moment we create a <kbd>Future</kbd> for our parallel computation. The structure of the method is similar to the <kbd>balancedFold</kbd>, since we have to split the collection into two parts and fold it recursively. This time, we limit the minimal number of items in the collection to be folded in parallel because it might be more computationally expensive to create a <kbd>Future</kbd> than to fold a handful of elements in a sequential manner:</p>
<pre><span>private val </span><span>parallelLimit </span>= <span>8<br/></span><span>override def </span>foldPar(as: <span>List</span>[<span>A</span>])(i: <span>A</span>, op: (<span>A</span>, <span>A</span>) =&gt; <span>A</span>)(<span>implicit </span>ec: ExecutionContext): Future[<span>A</span>] = {<br/>  <span>if </span>(as.length &lt; <span>parallelLimit</span>) <span>Future</span>(foldBalanced(as)(i, op))<br/>  <span>else </span>{<br/>    <span>val </span>(l, r) = as.splitAt(as.length/<span>2</span>)<br/>    Future.<span>reduceLeft</span>(<span>List</span>(foldPar(l)(<span>m</span>.identity, <span>m</span>.op), foldPar(r)(<span>m</span>.identity, <span>m</span>.op)))(<span>m</span>.op)<br/>  }<br/>}</pre>
<p>For simplicity, we've hardcoded the minimal number of elements eligible for parallel computation, but it can be passed over as a parameter. In the method itself, we either spawn a balanced fold in a separate thread if the collection is shorter than the limit or we initiate two parallel folds the same way we did before, but this time we use <kbd>Future.reduceLeft</kbd> to combine them together at the moment both computations are finished.</p>
<p>We expect <kbd>foldPar</kbd> to be quicker than other folds. Let's write a property for that. This endeavor will be more involved than before. The reason for this is that the monoids we've to build so far are very simple and, because of that, very fast. Because of this, we won't be able to see the advantages of parallelization—the price of spawning a <kbd>Future</kbd> will outweigh the folding itself. For our purposes, we'll make our monoid a bit slower by adding a small delay to it:</p>
<pre><span>implicit val </span><span>slowPoisonMonoid</span>: Monoid[Fish] = <span>new </span>Monoid[Fish] {<br/>  <span>override def </span>identity: Fish = <span>ZeroFish<br/></span><span>  </span><span>override def </span>op(l: Fish, r: Fish): Fish = {<br/>    Thread.<span>sleep</span>(<span>1</span>)<br/>    <span>if </span>(l.poisonousness &gt; r.poisonousness) l <span>else </span>r<br/>  }<br/>}</pre>
<p>Another point is that the list should be long enough, otherwise we won't be really testing the parallelization feature. We need to create a dedicated generator for lists between 100 and 1,000 in length:</p>
<pre><span>val </span><span>bucketOfFishGen</span>: Gen[<span>List</span>[Fish]] = <span>for </span>{<br/>  n &lt;- Gen.<span>choose</span>(<span>100</span>, <span>1000</span>)<br/>  gen &lt;- Gen.<span>listOfN</span>(n, <span>fishGen</span>)<br/>} <span>yield </span>gen<br/><br/><span>implicit val </span><span>arbBucketOfFish</span>: Arbitrary[<span>Bucket</span>[Fish]] = Arbitrary(<span>bucketOfFishGen</span>)</pre>
<p>We also need a <kbd>helper</kbd> method to measure the execution time of the code block:</p>
<pre><span>def </span>withTime(block: =&gt; Fish): (Fish, Long) = {<br/>  <span>val </span>start = System.<span>nanoTime</span>()<br/>  <span>val </span>result = block<br/>  (result, (System.<span>nanoTime</span>() - start) / <span>1000000</span>)<br/>}</pre>
<p>For <kbd>foldPar</kbd>, we also need an implicit execution context. We'll use the global one as it is good enough for our purposes:</p>
<pre><span>import </span>scala.concurrent.ExecutionContext.Implicits.<span>global<br/></span></pre>
<p>With all the preparations out of the way, we can formulate our property:</p>
<pre><span>property</span>(<span>"foldPar is the quickest way to fold a list"</span>) = {<br/>  <span>import </span>Monoid.<span>slowPoisonMonoid<br/></span><span>  </span><span>val </span>foldable = MonoidFoldable.<span>listMonoidFoldable</span>[Fish]<br/><br/>  <span>forAllNoShrink</span>((as: <span>Bucket</span>[Fish]) =&gt; {<br/>       ...<br/>    })<br/>  }</pre>
<p>In the body, we'll first measure the execution time of different folding approaches:</p>
<pre><span>val </span>(left, leftRuntime) = <span>withTime</span>(foldable.foldLeft(as))<br/><span>val </span>(right, rightRuntime) = <span>withTime</span>(foldable.foldRight(as))<br/><span>val </span>(balanced, balancedRuntime) = <span>withTime</span>(foldable.foldBalanced(as))<br/><span>val </span>(parallel, parallelRuntime) = <span>withTime</span>(Await.<span>result</span>(foldable.foldPar(as), <span>5</span>.seconds))</pre>
<p><kbd>foldPar</kbd> returns a <kbd>Future[Fish]</kbd> as the result, so we're waiting for it to complete. Finally, we check that the result of all of folds is the same and that the parallel folding does not take more time than the other approaches. We label these properties appropriately:</p>
<pre>  <span>s"</span><span>$</span>{as.size}<span> fishes: </span><span>$</span>leftRuntime<span>, </span><span>$</span>rightRuntime<span>, </span><span>$</span>balancedRuntime<span>, </span><span>$</span>parallelRuntime<span> millis" </span>|: <span>all</span>(<br/>    <span>"all results are equal" </span>|: <span>all</span>(left == right, left == balanced, left == parallel),<br/>    <span>"parallel is quickest" </span>|: parallelRuntime &lt;= <span>List</span>(leftRuntime, rightRuntime, balancedRuntime).min<br/>  )<br/>})</pre>
<p>Now, we can run our test and check that our implementation lives up to our expectations if tested in SBT session:</p>
<pre>+ MonoidFoldable.foldPar is the quickest way to fold a list: OK, passed 100 tests.</pre>
<p>It turns out that it does!</p>
<p>Needless to say that it is possible to define other instances of the <kbd>MonoidFoldable</kbd> type class. Moreover, the collection does not need to be linear. As soon as it is possible to iterate over its elements, any structure will do—a binary tree, a map, a bag, or anything even more sophisticated. This possibility of being able to abstract over different data structures and to parallelize computations is what makes monoids especially useful in big data and distributed scenarios.</p>
<p>Having said that, we need to emphasize that <kbd><span>MonoidFoldable</span></kbd> can be made even more flexible and general-purpose. To understand how this can be done, we need to look once again at the definition of the fold process we gave earlier:</p>
<pre>(((identity op a1) op a2) op a3) ...</pre>
<p>We can notice from this that the recursive operation takes two arguments and returns a result that becomes the first argument for the next iteration. This observation leads to the conclusion that the folding function does not need to have both arguments of the same type. As long as the return type is the same as the type of the first argument and the same as the type of the identity element, any function will be good for folding. This allows us to define a more generic <kbd>Foldable</kbd> abstraction that can convert elements of the collection and combine them at the same time:</p>
<pre><span>trait </span>Foldable[<span>F</span>[_]] {<br/>  <span>def </span><span>foldLeft</span>[<span>A</span><span>,</span><span>B</span>](as: <span>F</span>[<span>A</span>])(z: <span>B</span>)(f: (<span>B</span><span>, </span><span>A</span>) =&gt; <span>B</span>): <span>B<br/></span><span>  </span><span>def </span><span>foldRight</span>[<span>A</span><span>,</span><span>B</span>](as: <span>F</span>[<span>A</span>])(z: <span>B</span>)(f: (<span>A</span><span>, </span><span>B</span>) =&gt; <span>B</span>): <span>B<br/></span>}</pre>
<p>This approach allows us to use any function, not only monoids, for folding. Of course, it is still possible to use existing monoid definitions, for example, by defining a method that would accept a monoid as an implicit parameter:</p>
<pre><span>  </span><span>def </span><span>foldMap</span>[<span>A</span><span>,</span><span>B </span>: Monoid](as: <span>F</span>[<span>A</span>])(f: <span>A </span>=&gt; <span>B</span>): <span>B </span>= {<br/>    <span>val </span>m = <span>implicitly</span>[Monoid[<span>B</span>]]<br/>    foldLeft(as)(m.identity)((b<span>, </span>a) =&gt; m.op(f(a)<span>, </span>b))<br/>  }</pre>
<p>This definition relies on the existence of some complementary function, <kbd>f</kbd>, which converts elements of the collection into the appropriate type before they can be combined using the monoid operation.</p>
<p>Looking in the opposite direction, abstract algebraic structures do not end with monoids. In fact, there are a lot of more advanced definitions out there like the group, abelian group, and ring. </p>
<p>We'll take a short look at the implementation of the group just to reinforce our understanding of the topic of algebraic structures.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Group</h1>
                </header>
            
            <article>
                
<p>A group adds <span>an invertibility property </span>to the properties of the monoid, which means that for every element, <kbd>a</kbd>, from the set, <kbd>S</kbd>, on which the group is defined, there is an inverse element so that the result of the operation on both of them is an identity element.</p>
<p>Formalized in the code, it looks like the following:</p>
<pre><span>trait </span>Group[<span>S</span>] <span>extends </span>Monoid[<span>S</span>] {<br/>  <span>def </span>inverse(a: <span>S</span>): <span>S<br/></span>}</pre>
<p>The <kbd>ScalaCheck</kbd> property for this new law looks similar to the properties we defined for semigroup and monoid:</p>
<pre><span>def </span>invertibility[<span>S </span>: Group : Arbitrary]: Prop =<br/>  <span>forAll</span>((a: <span>S</span>) =&gt; {<br/>    <span>val </span>m = <span>implicitly</span>[Group[<span>S</span>]]<br/>    m.op(a, m.inverse(a)) == m.identity &amp;&amp; m.op(m.inverse(a), a) == m.identity<br/>  })</pre>
<p>Like we did previously, we can define an overarching check that aggregates single properties:</p>
<pre><span>def </span>groupProp[<span>S </span>: Group: Arbitrary]: Prop = <span>monoidProp</span>[<span>S</span>] &amp;&amp; <span>invertibility</span>[<span>S</span>]</pre>
<p>By adding a <kbd>commutative</kbd> <em>property</em> to the group, we'll get an abelian group. The <kbd>commutative</kbd> property states that for any two input elements, the order of arguments does not matter. For a group to be abelian, it does not need to implement anything; all it needs to do is satisfy this additional property! </p>
<p>We can extend our check definitions to incorporate this:</p>
<pre><span>def </span>commutativity[<span>S </span>: Group : Arbitrary]: Prop =<br/>  <span>forAll</span>((a: <span>S</span>, b: <span>S</span>) =&gt; {<br/>    <span>val </span>m = <span>implicitly</span>[Group[<span>S</span>]]<br/>    m.op(a, b) == m.op(b, a)<br/>  })<br/><br/><span>def </span>abelianGroupProp[<span>S </span>: Group: Arbitrary]: Prop = <br/><span>  groupProp</span>[<span>S</span>] &amp;&amp; <span>commutativity</span>[<span>S</span>]</pre>
<p>Again, we also define a single comprehensive property to check all of the laws of the abelian group at once.</p>
<p>One example of the abelian group is integer under addition. It can be implemented by extending the monoid we defined previously:</p>
<pre><span>implicit val </span><span>intAddition</span>: Group[Int] = <span>new </span>Group[Int] {<br/> <span>override def </span>identity: Int = <span>0<br/></span><span> </span><span>override def </span>op(l: Int, r: Int): Int = l + r<br/> <span>override def </span>inverse(a: Int): Int = identity - a<br/>}</pre>
<p>The properties we defined previously can help to ensure that this is indeed a valid abelian group implementation:</p>
<pre><span>property</span>(<span>"ints under addition form a group"</span>) = {<br/>  <span>import </span>Group.<span>intAddition<br/></span><span>  </span><span>groupProp</span>[Int]<br/>}<br/><br/><span>property</span>(<span>"ints under addition form an abelian group"</span>) = {<br/>  <span>import </span>Group.<span>intAddition<br/></span><span>  </span><span>groupProp</span>[Int]<br/>}</pre>
<p>We will leave the reader with the task of executing these properties to check that our implementation is correct.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p class="p1">The definition of the abelian group concludes our discussion of abstract algebraic structures; that is, the structures solely defined by the laws they satisfy.</p>
<p class="p1">We looked at three such structures: semigroup, monoid, and group. The semigroup is defined by a binary operation that is closed and associative. The monoid adds to this an identity element so that the operation applied to it and another argument returns the second argument unchanged. The group extends monoids with an invertibility law, stating that for each element there should be another element so that the operation applied on them returns an identity element. If the operation defined by the group is commutative, the group is called abelian.</p>
<p class="p1">We provided an example implementation for all these algebraic equations, along with <kbd>ScalaCheck</kbd> properties for verifying that our implementations are sane.</p>
<p class="p1">Needless to say, our code is for demonstration purposes only, and <span>because of this, it </span>is quite simplistic.</p>
<p class="p1">There are at least two major functional programming libraries in the Scala ecosystem in which the concepts we discussed are implemented more rigorously—cats (<a href="https://typelevel.org/cats/">https://typelevel.org/cats/</a>), and scalaz (<a href="https://github.com/scalaz/scalaz">https://github.com/scalaz/scalaz</a>). They are well-documented and regularly blogged and talked about, and provide a solid grounding for readers who are curious about using the notions we've talked about in real-life projects.</p>
<p class="p1">In the next chapter, we’ll work out our abstraction muscle by studying effects in general, extending the toolbox we started to fill in <a href="8ccc5685-2fbb-4bd4-9d9e-4560b625b00e.xhtml">Chapter 6</a>, <em>Exploring Built-In Effects</em>, with new concepts.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Questions</h1>
                </header>
            
            <article>
                
<ol>
<li>Why is the property of associativity that is essential for the monoid useful in a distributed setup?</li>
<li>Implement a monoid for a <kbd>Boolean</kbd> under <kbd>OR</kbd>.</li>
<li>Implement a monoid for a <kbd>Boolean</kbd> under <kbd>AND</kbd>.</li>
<li>Given a <kbd>Monoid[A]</kbd>, implement <kbd>Monoid[Option[A]]</kbd>.</li>
<li><span>Given a </span><kbd>Monoid[R]</kbd><span>, implement </span><kbd>Monoid[Either[L, R]].</kbd></li>
<li>Generalize two previous implementations for any effect parameterized by<span> </span><kbd>A</kbd><span>, or describe why this is not possible.</span></li>
</ol>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Further reading</h1>
                </header>
            
            <article>
                
<div class="page">
<div class="layoutArea">
<div class="column">
<p><span>Atul S. Khot, <em>Scala Functional Programming Patterns</em>: </span><span>Grok and performing effective functional programming in Scala</span></p>
<p><span>Ivan Nikolov, </span><em>Scala Design Patterns</em> - Second Edition: Learn how to write efficient, clean, and reusable code with Scala</p>
<p> </p>
<p> </p>
</div>
</div>
</div>


            </article>

            
        </section>
    </div>



  </body></html>