- en: Chapter 2. Extending Microservices
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章 扩展微服务
- en: We built a basic component offering a few services in Lesson 1, *Building Microservices
    with Spring Boot*. In this lesson, we will focus on adding more features to make
    our microservice production ready.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在第1课“使用Spring Boot构建微服务”中，我们构建了一个提供一些服务的基本组件。在本课中，我们将专注于添加更多功能，使我们的微服务准备好生产。
- en: 'We will discuss how to add these features to our microservice:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将讨论如何将这些功能添加到我们的微服务中：
- en: Exception handling
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异常处理
- en: HATEOAS
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HATEOAS
- en: Caching
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓存
- en: Internationalization
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 国际化
- en: We will also discuss how to document our microservice using Swagger. We will
    look at the basics of securing the microservice with Spring Security.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将讨论如何使用Swagger记录我们的微服务。我们将查看使用Spring Security保护微服务的基础知识。
- en: Exception Handling
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异常处理
- en: Exception handling is one of the important parts of developing web services.
    When something goes wrong, we would want to return a good description of what
    went wrong to the service consumer. You would not want the service to crash without
    returning anything useful to the service consumer.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 异常处理是开发网络服务的重要部分之一。当出现问题时，我们希望向服务消费者返回一个良好的错误描述。我们不希望服务崩溃而不向服务消费者提供任何有用的信息。
- en: Spring Boot provides good default exception handling. We will start with looking
    at the default exception handling features provided by Spring Boot before moving
    on to customizing them.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot提供了良好的默认异常处理。在继续自定义它们之前，我们将首先查看Spring Boot提供的默认异常处理功能。
- en: Spring Boot Default Exception Handling
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Spring Boot默认异常处理
- en: To understand the default exception handling provided by Spring Boot, let's
    start with firing a request to a nonexistent URL.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解Spring Boot提供的默认异常处理，让我们从一个不存在的URL开始发起请求。
- en: Non-Existent Resource
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不存在的资源
- en: Let's send a `GET` request to `http://localhost:8080/non-existing-resource`
    using a header (`Content-Type:application/json`).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用带有头信息（`Content-Type:application/json`）的`GET`请求向`http://localhost:8080/non-existing-resource`发送请求。
- en: 'The following screenshot shows the response when we execute the request:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了执行请求时的响应：
- en: '![Non-Existent Resource](img/02_01.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![不存在的资源](img/02_01.jpg)'
- en: 'The response is as shown in the following code snippet:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 响应如下所示：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Some important things to note are as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些需要注意的重要事项：
- en: The response header has an HTTP status of `404 - Resource Not Found`
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应头中的HTTP状态为`404 - 资源未找到`
- en: Spring Boot returns a valid JSON message as a response with the message stating
    that the resource is not found
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Boot返回一个有效的JSON消息作为响应，消息表明资源未找到
- en: Resource Throwing an Exception
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 抛出异常的资源
- en: Let's create a resource that throws an exception, and send a `GET` request to
    it in order to understand how the application reacts to runtime exceptions.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个会抛出异常的资源，并对其发送一个`GET`请求，以便了解应用程序如何响应运行时异常。
- en: 'Let''s create a dummy service that throws an exception. The following code
    snippet shows a simple service:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个会抛出异常的虚拟服务。以下代码片段显示了一个简单的服务：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Some important things to note are as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些需要注意的重要事项：
- en: We are creating a `GET` service with the URI `/users/dummy-service`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在创建一个URI为`/users/dummy-service`的`GET`服务。
- en: The service throws a `RuntimeException`. We chose `RuntimeException` to be able
    to create the exception easily. We can easily replace it with a custom exception;
    if needed.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 服务抛出一个`RuntimeException`。我们选择`RuntimeException`以便能够轻松创建异常。如果需要，我们可以轻松地将其替换为自定义异常。
- en: 'Let''s fire a `GET` request to the preceding service at `http://localhost:8080/users/dummy-service`
    using Postman. The response is as shown in the following code:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用Postman向`http://localhost:8080/users/dummy-service`服务发起一个`GET`请求。响应如下所示：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Some important things to note are as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些需要注意的重要事项：
- en: The response header has an HTTP status of `500`; `Internal server error`
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应头中的HTTP状态为`500`；`内部服务器错误`
- en: Spring Boot also returns the message with which the exception is thrown
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Boot还返回抛出异常的消息
- en: As we can see in the preceding two examples, Spring Boot provides good default
    exception handling. In the next section, we will focus on understanding how the
    application reacts to custom exceptions.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如前两个示例所示，Spring Boot提供了良好的默认异常处理。在下一节中，我们将专注于了解应用程序如何响应自定义异常。
- en: Throwing a Custom Exception
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 抛出自定义异常
- en: 'Let''s create a custom exception and throw it from a service. Take a look at
    the following code:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个自定义异常，并从服务中抛出它。看看下面的代码：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: It's a very simple piece of code that defines `TodoNotFoundException`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一段非常简单的代码，它定义了 `TodoNotFoundException`。
- en: 'Now let''s enhance our `TodoController` class to throw `TodoNotFoundException`
    when a `todo` with a given ID is not found:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们增强我们的 `TodoController` 类，以便在找不到具有给定 ID 的 `todo` 时抛出 `TodoNotFoundException`：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: If `todoService` returns a null `todo`, we throw; `TodoNotFoundException`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `todoService` 返回一个 null 的 `todo`，我们将抛出 `TodoNotFoundException`。
- en: 'When we execute the service with a `GET` request to a nonexistent: `todo`(`http://localhost:8080/users/Jack/todos/222`),
    we get the response shown in the following code snippet:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用 `GET` 请求对一个不存在的 `todo`（`http://localhost:8080/users/Jack/todos/222`）执行服务时，我们会得到以下代码片段中显示的响应：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As we can see, a clear exception response is sent back to the service consumer.
    However, there is one thing that can be improved further--the response status.
    When a resource is not found, it is recommended that you return a `404 - Resource
    Not Found` status. We will look at how to customize the response status in the
    next example.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，一个清晰的异常响应被发送回服务消费者。然而，还有一件事可以进一步改进——响应状态。当资源未找到时，建议您返回一个 `404 - 资源未找到`
    状态。我们将在下一个示例中查看如何自定义响应状态。
- en: Customizing the Exception Message
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自定义异常消息
- en: Let's look at how to customize the preceding exception and return the proper
    response status with a customized message.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何自定义前面的异常，并返回带有自定义消息的正确响应状态。
- en: 'Let''s create a bean to define the structure of our custom exception message:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个实体来定义我们自定义异常消息的结构：
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We have created a simple exception response bean with an auto-populated timestamp
    with a few additional properties namely messages and details.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个简单的异常响应实体，它具有自动填充的时间戳和一些额外的属性，即消息和详细信息。
- en: 'When; `TodoNotFoundException` is thrown, we would want to return a response
    using the `ExceptionResponse` bean. The following code shows how we can create
    a global exception handling for `TodoNotFoundException.class`:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `TodoNotFoundException` 被抛出时，我们希望使用 `ExceptionResponse` 实体返回一个响应。以下代码展示了我们如何为
    `TodoNotFoundException.class` 创建全局异常处理：
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Some important things to note are as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些需要注意的重要事项：
- en: '`RestResponseEntityExceptionHandler extends ResponseEntityExceptionHandler`:
    We are extending `ResponseEntityExceptionHandler`, which the base class is provided
    by Spring MVC for centralised exception handling `ControllerAdvice` classes.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`RestResponseEntityExceptionHandler extends ResponseEntityExceptionHandler`:
    我们正在扩展 `ResponseEntityExceptionHandler`，这是由 Spring MVC 为集中式异常处理 `ControllerAdvice`
    类提供的基类。'
- en: '`@ExceptionHandler(TodoNotFoundException.class)`: This defines that the method
    to follow will handle the specific exception `TodoNotFoundException.class`. Any
    other exceptions for which custom exception handling is not defined will follow
    the default exception handling provided by Spring Boot.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`@ExceptionHandler(TodoNotFoundException.class)`: 这定义了接下来的方法将处理特定的异常 `TodoNotFoundException.class`。对于没有定义自定义异常处理的任何其他异常，将遵循
    Spring Boot 提供的默认异常处理。'
- en: '`ExceptionResponse exceptionResponse = new ExceptionResponse(ex.getMessage(),
    "Any details you would want to add")`: This creates a custom exception response.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`ExceptionResponse exceptionResponse = new ExceptionResponse(ex.getMessage(),
    "Any details you would want to add")`: 这将创建一个自定义的异常响应。'
- en: '`new ResponseEntity<ExceptionResponse>(exceptionResponse,new HttpHeaders(),
    HttpStatus.NOT_FOUND)`: This is the definition to return a `404 Resource Not Found`
    response with the custom exception defined earlier.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`new ResponseEntity<ExceptionResponse>(exceptionResponse,new HttpHeaders(),
    HttpStatus.NOT_FOUND)`: 这是返回一个 `404 资源未找到` 响应并使用之前定义的自定义异常的定义。'
- en: 'When we execute the service with a `GET` request to a nonexistent; `todo`(`http://localhost:8080/users/Jack/todos/222`),
    we get the following response:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用 `GET` 请求对一个不存在的 `todo`（`http://localhost:8080/users/Jack/todos/222`）执行服务时，我们会得到以下响应：
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: If you want to create a generic exception message for all exceptions, we can
    add a method to `RestResponseEntityExceptionHandler` with the `@ExceptionHandler(Exception.class)`
    annotation.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想为所有异常创建一个通用的异常消息，我们可以在 `RestResponseEntityExceptionHandler` 中添加一个带有 `@ExceptionHandler(Exception.class)`
    注解的方法。
- en: 'The following code snippet shows how we can do this:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段展示了我们如何做到这一点：
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Any exception for which a custom exception handler is not defined; will be handled
    by the preceding method.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 对于没有定义自定义异常处理器的任何异常，将由前面的方法处理。
- en: Response Status
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 响应状态
- en: 'One of the important things to focus on with REST services is the response
    status of an error response. The following table shows the scenarios and the error
    response status to use:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在REST服务中，我们需要关注的一个重要问题是错误响应的状态码。以下表格显示了场景和应使用的错误响应状态码：
- en: '| Situation | Response Status |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| 情况 | 响应状态 |'
- en: '| --- | --- |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| The request body does not meet the API specification. It does not contain
    enough details or contains validation errors. | ;400 BAD REQUEST |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| 请求体不符合API规范。它不包含足够的细节或包含验证错误。 | 400 BAD REQUEST |'
- en: '| Authentication or authorization failure. | 401 UNAUTHORIZED |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| 认证或授权失败。 | 401 UNAUTHORIZED |'
- en: '| The user cannot perform the operation due to various factor, such as exceeding
    limits. | 403 FORBIDDEN |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| 由于各种因素，如超出限制，用户无法执行操作。 | 403 FORBIDDEN |'
- en: '| The resource does not exist. | 404 NOT FOUND |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| 资源不存在。 | 404 NOT FOUND |'
- en: '| Unsupported operation, for example, trying POST on a resource where only
    GET is allowed. | 405 METHOD NOT ALLOWED |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| 不支持的操作，例如，在只允许GET的资源上尝试POST。 | 405 METHOD NOT ALLOWED |'
- en: '| Error on a server. Ideally, this should not happen. The consumer; would not
    be able to fix this. | 500 INTERNAL SERVER ERROR |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| 服务器错误。理想情况下，这种情况不应该发生。消费者无法修复这个问题。 | 500 INTERNAL SERVER ERROR |'
- en: In this section, we looked at the default exception handling provided by Spring
    Boot and how we can customize it further to suit our needs.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们探讨了Spring Boot提供的默认异常处理以及如何进一步自定义以满足我们的需求。
- en: HATEOAS
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HATEOAS
- en: '**HATEOAS** (**Hypermedia as the Engine of Application State**) is one of the
    constraints of the REST application architecture.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '**HATEOAS**（**超媒体作为应用状态引擎**）是REST应用架构的约束之一。'
- en: Let's consider a situation where a service consumer is consuming numerous services
    from a service provider. The easiest way to develop this kind of system is to
    have the service consumer store the individual resource URIs of every resource
    they need from the service provider. However, this would create tight coupling
    between the service provider and the service consumer. Whenever any of the resource
    URIs change on the service provider, the service consumer needs to be updated.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个服务消费者从服务提供商消费众多服务的情况。开发这种系统的最简单方法是将服务消费者需要从服务提供商获取的每个资源的单个资源URI存储起来。然而，这将在服务提供者和服务消费者之间创建紧密耦合。每当服务提供商上的任何资源URI发生变化时，服务消费者都需要进行更新。
- en: Consider a; typical web application. Let's say I navigate to my bank account
    details page. Almost all banking websites would show links to all the transactions
    that are possible on my bank account on the screen so that I can easily navigate
    using the link.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个典型的Web应用。假设我导航到我的银行账户详情页面。几乎所有的银行网站都会在屏幕上显示我银行账户上所有可能的交易链接，以便我可以通过链接轻松导航。
- en: What if we can bring a; similar concept to RESTful services so that a service
    returns not only the data about the requested resource, but also provides details
    of other related resources?
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们能够将一个类似的概念引入RESTful服务中，使得服务不仅返回请求资源的有关数据，还提供其他相关资源的详细信息呢？
- en: HATEOAS brings this concept of displaying related links for a given resource
    to RESTful services. When we return the details of a specific resource, we also
    return links to operations that can be performed on the resource, as well as links
    to related resources. If a service consumer can use the links from the response
    to perform transactions, then it would not need to hardcode all links.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: HATEOAS将这种为给定资源显示相关链接的概念引入RESTful服务。当我们返回特定资源的详细信息时，我们也会返回可以对该资源执行的操作的链接，以及相关资源的链接。如果服务消费者可以使用响应中的链接执行交易，那么它就不需要硬编码所有链接。
- en: 'An extract of constraints related to HATEOAS presented by Roy Fielding ([http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven](http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven))
    is as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Roy Fielding（[http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven](http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven)）提出的与HATEOAS相关的约束摘录如下：
- en: '*A REST API must not define fixed resource names or hierarchies (an obvious
    coupling of client and server). Servers must have the freedom to control their
    own namespace. Instead, allow servers to instruct clients on how to construct
    appropriate URIs, such as is done in HTML forms and URI templates, by defining
    those instructions within media types and link relations.*'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '*REST API不得定义固定的资源名称或层次结构（客户端和服务器之间的明显耦合）。服务器必须拥有控制其自身命名空间的自由。相反，允许服务器指导客户端如何构造适当的URI，例如在HTML表单和URI模板中执行，通过在媒体类型和链接关系中定义这些说明。*'
- en: '*A REST API should be entered with no prior knowledge beyond the initial URI
    (bookmark) and set of standardized media types that are appropriate for the intended
    audience (i.e., expected to be understood by any client that might use the API).
    From that point on, all application state transitions must be driven by client
    selection of server-provided choices that are present in the received representations
    or implied by the user''s manipulation of those representations. The transitions
    may be determined (or limited by) the client''s knowledge of media types and resource
    communication mechanisms, both of which may be improved on-the-fly (e.g., code-on-demand).*'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '*REST API应该在没有超出初始URI（书签）和适用于目标受众的标准化媒体类型（即预期任何可能使用API的客户端都能理解）的先验知识的情况下进入。从那时起，所有应用程序状态转换都必须由客户端选择服务器提供的、在接收到的表示中存在或由用户对那些表示的操作暗示的选择来驱动。转换可能由客户端对媒体类型和资源通信机制的了解（两者都可以即时改进，例如按需代码）来确定（或限制）。*'
- en: 'An example response with HATEOAS link is shown here. This is the response to
    the `/todos` request in order to retrieve all todos:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这里展示了包含HATEOAS链接的示例响应。这是对`/todos`请求的响应，以检索所有待办事项：
- en: '[PRE10]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The preceding response includes links to the following:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的响应包括以下链接：
- en: Specific `todos` (`http://localhost:8080/todos/1`)
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特定的`todos`（`http://localhost:8080/todos/1`）
- en: Search resource (`http://localhost:8080/todos/search`)
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 搜索资源（`http://localhost:8080/todos/search`）
- en: If the service consumer wants to do a search, it has the option of taking the
    search URL from the response and sending the search request to it. This would
    reduce coupling between the service provider and the service consumer.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果服务消费者想要进行搜索，它可以选择从响应中获取搜索URL，并将搜索请求发送给它。这将减少服务提供者与服务消费者之间的耦合。
- en: Sending HATEOAS Links in Response
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在响应中发送HATEOAS链接
- en: Now that we understand what HATEOAS is, let's look at how we can send links
    related to a resource in the response.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了HATEOAS是什么，让我们看看我们如何在响应中发送与资源相关的链接。
- en: Spring Boot Starter HATEOAS
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Spring Boot Starter HATEOAS
- en: Spring Boot has a specific starter for HATEOAS called `spring-boot-starter-hateoas`.
    We need to add it to the `pom.xml` file.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot有一个特定的HATEOAS启动器，称为`spring-boot-starter-hateoas`。我们需要将其添加到`pom.xml`文件中。
- en: 'The following code snippet shows the dependency block:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段显示了依赖块：
- en: '[PRE11]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'One of the important dependencies of `spring-boot-starter-hateoas` is `spring-hateoas`,
    which provides the HATEOAS features:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`spring-boot-starter-hateoas`的重要依赖之一是`spring-hateoas`，它提供了HATEOAS功能：'
- en: '[PRE12]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Let''s enhance the `retrieveTodo` resource (`/users/{name}/todos/{id}`) to
    return a link to retrieve all `todos` (`/users/{name}/todos`) in the response:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们增强`retrieveTodo`资源（`/users/{name}/todos/{id}`），使其在响应中返回一个获取所有`todos`（`/users/{name}/todos`）的链接：
- en: '[PRE13]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Some important points to note are as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的一些重要点是：
- en: '`ControllerLinkBuilder linkTo = linkTo(methodOn(this.getClass()).retrieveTodos(name))`:
    We want to get a link to the `retrieveTodos` method on the current class'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ControllerLinkBuilder linkTo = linkTo(methodOn(this.getClass()).retrieveTodos(name))`：我们想要获取当前类中`retrieveTodos`方法的链接'
- en: '`linkTo.withRel("parent")`: Relationship with the current resource is parent'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`linkTo.withRel("parent")`：与当前资源的关系是父级'
- en: 'The following snippet shows the response when a `GET` request is sent to `http://localhost:8080/users/Jack/todos/1`:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 以下片段显示了向`http://localhost:8080/users/Jack/todos/1`发送`GET`请求时的响应：
- en: '[PRE14]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `_links` section will contain all the links. Currently, we have one link
    with the relation parent and `href` as `http://localhost:8080/users/Jack/todos`.:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`_links`部分将包含所有链接。目前，我们有一个带有关系parent和`href`为`http://localhost:8080/users/Jack/todos`的链接：'
- en: Note
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you have problems executing the preceding request, try executing using an
    Accept header--`application/json`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在执行前面的请求时遇到问题，请尝试使用Accept头--`application/json`来执行。
- en: HATEOAS is not something that is commonly used in most of the resources today.
    However, it has the potential to be really useful in reducing the coupling between
    the service provider and the consumer.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: HATEOAS不是今天大多数资源中常用的东西。然而，它有潜力在减少服务提供者和消费者之间的耦合方面真正有用。
- en: Validation
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证
- en: A good service always validates data before processing it. In this section,
    we will look at the Bean Validation API and use its reference implementation to
    implement validation in our services.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的服务总是在处理数据之前验证数据。在本节中，我们将查看Bean验证API并使用其参考实现来在我们的服务中实现验证。
- en: 'The Bean Validation API provides a number of annotations that can be used to
    validate beans. The **JSR 349** specification defines Bean Validation API 1.1\.
    Hibernate-validator is the reference implementation; both are already defined
    as dependencies in the `spring-boot-web-starter` project:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Bean验证API提供了一些注解，可以用来验证Bean。**JSR 349**规范定义了Bean验证API 1.1。Hibernate-validator是参考实现；两者都已定义为`spring-boot-web-starter`项目中的依赖项：
- en: '`hibernate-validator-5.2.4.Final.jar`'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hibernate-validator-5.2.4.Final.jar`'
- en: '`validation-api-1.1.0.Final.jar`'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`validation-api-1.1.0.Final.jar`'
- en: We will create a simple validation for the `createTodo` service method.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为`createTodo`服务方法创建一个简单的验证。
- en: 'Creating validations involves two steps:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 创建验证涉及两个步骤：
- en: Enabling validation on the controller method.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制器方法上启用验证。
- en: Adding validations on the bean.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Bean上添加验证
- en: Enabling Validation on the Controller Method
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在控制器方法上启用验证
- en: 'It''s very simple to enable validation on the controller method. The following
    snippet shows an example:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在控制器方法上启用验证非常简单。以下代码片段展示了示例：
- en: '[PRE15]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `@Valid(package javax.validation)` annotation is used to mark a parameter
    for validation. Any validation that is defined in the `Todo` bean is executed
    before the `add` method is executed.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`@Valid(package javax.validation)`注解来标记一个参数进行验证。在`add`方法执行之前，会执行在`Todo` Bean中定义的任何验证。
- en: Defining validations on the Bean
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Bean上定义验证
- en: 'Let''s define a few validations on the `Todo` bean:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为`Todo` Bean定义一些验证：
- en: '[PRE16]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Some important points to note are as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些需要注意的重要点：
- en: '`@NotNull`: Validates that the user field is not empty'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@NotNull`：验证用户字段不为空'
- en: '`@Size(min = 9, message = "Enter atleast 10 Characters.")`: Checks whether
    the `desc` field has at least nine characters'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Size(min = 9, message = "Enter atleast 10 Characters.")`：检查`desc`字段是否至少有九个字符'
- en: 'There are a number of other annotations that can be used to validate beans.
    The following are some of the Bean Validation annotations:'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有许多其他注解可以用来验证Bean。以下是一些Bean验证注解：
- en: '`@AssertFalse`, `@AssertTrue`: For Boolean elements. Checks the annotated element.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@AssertFalse`，`@AssertTrue`：对于布尔元素。检查被注解的元素。'
- en: '`@AssertFalse`: Checks for false. `@Assert` checks for true.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@AssertFalse`：检查是否为false。`@Assert`检查是否为true。'
- en: '`@Future`: The annotated element must be a date in the future.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Future`：被注解的元素必须是一个未来的日期。'
- en: '`@Past`: The annotated element must be a date in the past.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Past`：被注解的元素必须是一个过去的日期。'
- en: '`@Max`: The annotated element must be a number whose value must be lower or
    equal to the specified maximum.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Max`：被注解的元素必须是一个数值，其值必须小于或等于指定的最大值。'
- en: '`@Min`: The annotated element must be a number whose value must be higher or
    equal to the specified minimum.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Min`：被注解的元素必须是一个数值，其值必须大于或等于指定的最小值。'
- en: '`@NotNull`: The annotated element cannot be null.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@NotNull`：被注解的元素不能为null。'
- en: '`@Pattern`: The annotated `{@code CharSequence}` element must match the specified
    regular expression. The regular expression follows the Java regular expression
    conventions.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Pattern`：被注解的`{@code CharSequence}`元素必须匹配指定的正则表达式。正则表达式遵循Java正则表达式约定。'
- en: '`@Size`: The annotated element size must be within the specified boundaries.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Size`：被注解的元素大小必须在指定的范围内。'
- en: Unit Testing Validations
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单元测试验证
- en: 'The following example shows how we can unit test the validations we added in:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了我们如何对添加的验证进行单元测试：
- en: '[PRE17]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Some important points to note are as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些需要注意的重要点：
- en: '`"desc":"Learn"`: We are using a `desc` value of length `5`. This would cause
    a validation failure for the `@Size(min = 9, message = "Enter atleast 10 Characters.")`
    check.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"desc":"Learn"`：我们使用长度为`5`的`desc`值。这将导致`@Size(min = 9, message = "Enter atleast
    10 Characters.")`检查的验证失败。'
- en: '`.andExpect(status().is4xxClientError())`: Checks for validation error status.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.andExpect(status().is4xxClientError())`：检查验证错误状态。'
- en: Documenting REST Services
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 记录REST服务
- en: 'Before a service provider can consume a service, they need a service contract.
    A service contract defines all the; details about a service:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务提供者能够消费服务之前，他们需要一个服务契约。服务契约定义了关于服务的一切细节：
- en: How can I call a service? What is the URI of the service?
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我该如何调用服务？服务的URI是什么？
- en: What should be the request format?
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求格式应该是什么？
- en: What kind of response should I expect?
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我应该期待什么样的响应？
- en: There are multiple options to define a service contract for RESTful services.
    The most popular one in the last couple of years is **Swagger**. Swagger is gaining
    a lot of ground, with support from major vendors in the last couple of years.
    In this section, we will generate Swagger documentation for our services.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 定义RESTful服务的服务契约有多种选择。在过去几年中，最受欢迎的是**Swagger**。Swagger在过去几年中获得了很大的支持，得到了主要供应商的支持。在本节中，我们将为我们的服务生成Swagger文档。
- en: 'The following quote from the Swagger website ([http://swagger.io](http://swagger.io))
    defines the purpose of the Swagger specification:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是从Swagger网站（[http://swagger.io](http://swagger.io)）摘录的引言，定义了Swagger规范的目的：
- en: Swagger specification creates the RESTful contract for your API, detailing all
    of its resources and operations in a human and machine readable format for easy
    development, discovery, and integration.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: Swagger规范为您的API创建RESTful契约，详细说明了所有资源及其操作，以人类和机器可读的格式，便于开发、发现和集成。
- en: Generating a Swagger Specification
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成Swagger规范
- en: One of the interesting developments in the last few years of RESTful services
    development is the evolution of tools to generate service documentation (specification)
    from the code. This ensures that the code and documentation are always in sync.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去几年中，RESTful服务开发中一个有趣的发展趋势是生成服务文档（规范）的工具的演变。这确保了代码和文档始终保持同步。
- en: '**Springfox Swagger** can be used to generate Swagger documentation from the
    RESTful services code. What''s more, there is a wonderful tool called **Swagger
    UI**, which, when integrated into the application, provides human-readable documentation.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '**Springfox Swagger**可以用于从RESTful服务代码中生成Swagger文档。更有甚者，还有一个叫做**Swagger UI**的出色工具，当集成到应用程序中时，提供了人类可读的文档。'
- en: 'The following code snippet shows how we can add both these tools; to the; `pom.xml`
    file:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段展示了如何将这两个工具添加到`pom.xml`文件中：
- en: '[PRE18]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The next step is to add the configuration class to enable and generate Swagger
    documentation. The following snippet shows how to do it:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是添加配置类以启用和生成Swagger文档。以下片段展示了如何操作：
- en: '[PRE19]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Some important points to note are as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些需要注意的重要点：
- en: '`@Configuration`: Defines a Spring configuration file'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Configuration`: 定义一个Spring配置文件'
- en: '`@EnableSwagger2`: The annotation to enable Swagger support'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@EnableSwagger2`: 启用Swagger支持的注解'
- en: '`Docket`: A simple builder class to configure the generation of Swagger documentation
    using the Swagger Spring MVC framework'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Docket`: 一个简单的构建类，用于使用Swagger Spring MVC框架配置Swagger文档的生成'
- en: '`new Docket(DocumentationType.SWAGGER_2)`: Configures Swagger 2 as the Swagger
    version to be used'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`new Docket(DocumentationType.SWAGGER_2)`: 配置Swagger 2作为要使用的Swagger版本'
- en: '`.apis(RequestHandlerSelectors.any()).paths(PathSelectors.any())`: Includes
    all APIs and paths in the documentation'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.apis(RequestHandlerSelectors.any()).paths(PathSelectors.any())`: 在文档中包含所有API和路径'
- en: 'When we bring the server up, we can launch the API Docs URL (`http://localhost:8080/v2/api-docs`).
    The following screenshot shows some of the generated documentation:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们启动服务器时，我们可以启动API文档URL（`http://localhost:8080/v2/api-docs`）。以下截图显示了部分生成的文档：
- en: '![Generating a Swagger Specification](img/02_02.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![生成Swagger规范](img/02_02.jpg)'
- en: 'Let''s look at some of the generated documentation. Listed here is the documentation
    to retrieve the; `todos` service:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些生成的文档。以下是检索`todos`服务的文档：
- en: '[PRE20]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The service definition clearly defines the request; and response; of the service.
    Also defined are the different response statuses that the service can return in
    different situations.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 服务定义明确定义了服务的请求和响应。还定义了服务在不同情况下可以返回的不同响应状态。
- en: 'The following code snippet shows the definition of the `Todo` bean:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段展示了`Todo`实体的定义：
- en: '[PRE21]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: It defines all the elements in the `Todo` bean, along with their formats.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 它定义了`Todo`实体中的所有元素，以及它们的格式。
- en: Swagger UI
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Swagger UI
- en: Swagger UI (`http://localhost:8080/swagger-ui.html`) can also be used to look
    at the documentation. Swagger UI is enabled by the dependency (`io.springfox:springfox-swagger-ui`)
    that was added in our `pom.xml`, in the previous step.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: Swagger UI (`http://localhost:8080/swagger-ui.html`) 也可以用来查看文档。Swagger UI 通过在之前的步骤中添加的依赖项
    (`io.springfox:springfox-swagger-ui`) 启用。
- en: Swagger UI ([http://petstore.swagger.io](http://petstore.swagger.io)) is also
    available online. We can visualize any Swagger documentation (swagger JSON) using
    Swagger UI.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: Swagger UI ([http://petstore.swagger.io](http://petstore.swagger.io)) 也可在网上使用。我们可以使用
    Swagger UI 可视化任何 Swagger 文档（swagger JSON）。
- en: 'The following screenshot shows the list of controller-exposing services. When
    we click on any controller, it expands to show the list of request methods and
    URIs each controller supports:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了暴露控制器的服务列表。当我们点击任何控制器时，它会展开以显示每个控制器支持的请求方法和 URI：
- en: '![Swagger UI](img/02_03.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![Swagger UI](img/02_03.jpg)'
- en: 'The following screenshot shows the details for the POST service to create a
    `todo` for the user in Swagger UI:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了在 Swagger UI 中创建用户 `todo` 的 POST 服务的详细信息：
- en: '![Swagger UI](img/02_04.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![Swagger UI](img/02_04.jpg)'
- en: 'Some important things to note are as follows:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些需要注意的重要事项：
- en: '`Parameters` show all the important parameters including the request body'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Parameters` 显示了所有重要的参数，包括请求体'
- en: The `Parameter Type` body (for the `todo` parameter) shows the expected structure
    for the body of the request
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Parameter Type` 主体（对于 `todo` 参数）显示了请求主体的预期结构'
- en: The `Response Messages` sections show different HTTP status codes returned by
    the service
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Response Messages` 部分显示了服务返回的不同 HTTP 状态码'
- en: The Swagger UI provides an excellent way to expose service definitions for your
    API without a lot of additional effort.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Swagger UI 提供了一种无需额外努力即可公开 API 服务定义的出色方式。
- en: Customizing Swagger Documentation Using Annotations
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用注解自定义 Swagger 文档
- en: The Swagger UI also provides annotations to further customize your documentation.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: Swagger UI 还提供了注解来进一步自定义你的文档。
- en: 'Listed here is some of the documentation to retrieve the `todos` service:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这里列出了检索 `todos` 服务的部分文档：
- en: '[PRE22]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'As you can see, the documentation generated is very raw. There are a number
    of things we can improve in the documentation to describe the services better.
    Here are a couple of examples:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，生成的文档非常原始。我们可以在文档中改进许多地方来更好地描述服务。以下是一些示例：
- en: Provide a better summary
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供更好的摘要
- en: Add application/JSON to produces
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 application/JSON 添加到 produces
- en: 'Swagger provides annotations we can add to our RESTful services in order to
    customize the documentation. Let''s add a few annotations to the controller in
    order to improve the documentation:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: Swagger 提供了我们可以添加到我们的 RESTful 服务中以自定义文档的注解。让我们添加一些注解到控制器中，以改进文档：
- en: '[PRE23]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'A few important points to note are as follows:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些需要注意的重要点：
- en: '`@ApiOperation(value = "Retrieve all todos for a user by passing in his name")`:
    Produced in the documentation as a summary of the service'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@ApiOperation(value = "通过传递用户的名字检索所有待办事项")`: 在文档中作为服务的摘要生成'
- en: '`notes = "A list of matching todos is returned. Current pagination is not supported."`:
    Produced in the documentation as a description of the service'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`notes = "返回匹配的待办事项列表。当前不支持分页。"`: 在文档中作为服务的描述生成'
- en: '`produces = "application/json"`: Customizes the `produces` section of the service
    documentation'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`produces = "application/json"`: 自定义服务文档的 `produces` 部分'
- en: 'Here is an extract of the documentation after the update:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 更新后的文档摘录如下：
- en: '[PRE24]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Swagger provides a lot of other annotations to customize the documentation.
    Listed here are some of the important annotations:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: Swagger 提供了许多其他注解来自定义文档。以下是一些重要的注解：
- en: '`@Api`: Marks a class as a Swagger resource'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Api`: 将类标记为 Swagger 资源'
- en: '`@ApiModel`: Provides additional information about Swagger models'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@ApiModel`: 为 Swagger 模型提供更多信息'
- en: '`@ApiModelProperty`: Adds and manipulates the data of a model property'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@ApiModelProperty`: 添加并操作模型属性的数据'
- en: '`@ApiOperation`: Describes an operation or an HTTP method against a specific
    path'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@ApiOperation`: 描述对特定路径的操作或 HTTP 方法'
- en: '`@ApiParam`: Adds additional metadata for operation parameters'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@ApiParam`: 为操作参数添加额外的元数据'
- en: '`@ApiResponse`: Describes an example response of an operation'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@ApiResponse`: 描述操作的示例响应'
- en: '`@ApiResponses`: A wrapper to allow a list of multiple `ApiResponse` objects.'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@ApiResponses`: 一个包装器，允许列出多个 `ApiResponse` 对象。'
- en: '`@Authorization`: Declares an authorization scheme to be used on a resource
    or an operation'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Authorization`: 声明在资源或操作上使用的授权方案'
- en: '`@AuthorizationScope`: Describes an OAuth 2 authorization scope'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@AuthorizationScope`: 描述 OAuth 2 授权范围'
- en: '`@ResponseHeader`: Represents a header that can be provided as part of the
    response'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@ResponseHeader`: 表示可以作为响应的一部分提供的头'
- en: 'Swagger provides a few Swagger definition annotations that can be used to customize
    high-level information about a group of services--contacts, licensing, and other
    general information. Listed here are some of the important ones:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: Swagger 提供了一些 Swagger 定义注解，可以用来自定义一组服务的高级信息--联系人、许可和其他一般信息。以下列出了一些重要的注解：
- en: '`@SwaggerDefinition`: Definition-level properties to be added to the generated
    Swagger definition'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@SwaggerDefinition`: 要添加到生成的 Swagger 定义中的定义级属性'
- en: '`@Info`: General metadata for a Swagger definition'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Info`: Swagger 定义的一般元数据'
- en: '`@Contact`: Properties to describe the person to be contacted for a Swagger
    definition'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Contact`: 用于描述 Swagger 定义中要联系的人的属性'
- en: '`@License`: Properties to describe the license for a Swagger definition'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@License`: 用于描述 Swagger 定义许可的属性'
- en: Securing REST Services with Spring Security
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Spring Security 保护 REST 服务
- en: All the services we have created up until now are unsecured. A consumer does
    not need to provide any credentials to access these services. However, all services
    in the real world are usually secured.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们到目前为止创建的所有服务都是未受保护的。消费者不需要提供任何凭证来访问这些服务。然而，现实世界中的所有服务通常都是受保护的。
- en: 'In this section, we will discuss two ways of authenticating REST services:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论两种认证 REST 服务的方法：
- en: Basic authentication
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本认证
- en: OAuth 2.0 authentication
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OAuth 2.0 认证
- en: We will implement these two types of authentication with Spring Security.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 Spring Security 实现这两种类型的认证。
- en: Spring Boot provides a starter for Spring Security using `spring-boot-starter-security`.
    We will start with adding Spring Security starter to our `pom.xml` file.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot 使用 `spring-boot-starter-security` 提供了 Spring Security 的启动器。我们将从将
    Spring Security 启动器添加到我们的 `pom.xml` 文件开始。
- en: Adding Spring Security Starter
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加 Spring Security Starter
- en: 'Add the following dependency to your file `pom.xml`:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下依赖项添加到您的 `pom.xml` 文件中：
- en: '[PRE25]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `Spring-boot-starter-security` dependency brings in three important Spring
    Security dependencies:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '`Spring-boot-starter-security` 依赖项引入了三个重要的 Spring Security 依赖项：'
- en: '`spring-security-config`'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spring-security-config`'
- en: '`spring-security-core`'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spring-security-core`'
- en: '`spring-security-web`'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spring-security-web`'
- en: Basic Authentication
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本认证
- en: The `Spring-boot-starter-security` dependency also auto-configures basic authentication
    for all services by default.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`Spring-boot-starter-security` 依赖项默认情况下也会自动为所有服务配置基本认证。'
- en: If we try to access any of the services now, we would get `"Access Denied"`.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在尝试访问任何服务，我们会得到 `"访问被拒绝"`。
- en: 'The response when we send a request to `http://localhost:8080/users/Jack/todos`
    is shown as an example in the following code snippet:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码片段中，以示例的形式展示了向 `http://localhost:8080/users/Jack/todos` 发送请求时的响应：
- en: '[PRE26]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The response status is `401 - Unauthorized`.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 响应状态是 `401 - 未授权`。
- en: When a resource is secured with basic authentication, we would need to send
    a user ID and password to authenticate our request. Since we did not configure
    a user ID and password, Spring Boot auto-configures a default user ID and password.
    The default user ID is `user`. The default password is usually printed in the
    log.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用基本认证保护资源时，我们需要发送用户 ID 和密码来认证我们的请求。由于我们没有配置用户 ID 和密码，Spring Boot 会自动配置默认的用户
    ID 和密码。默认用户 ID 是 `user`。默认密码通常会在日志中打印出来。
- en: 'An example is shown in the following code snippet:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段展示了示例：
- en: '[PRE27]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Underlined in the preceding code snippet is the default security password printed
    in the log.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，下划线表示日志中打印的默认安全密码。
- en: 'We can use Postman to fire a request with basic authentication. The following
    screenshot shows how basic authentication details can be sent along with a request:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 Postman 发送带有基本认证的请求。以下截图显示了如何将基本认证详情与请求一起发送：
- en: '![Basic Authentication](img/02_05.jpg)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![基本认证](img/02_05.jpg)'
- en: As you can see, authentication succeeds and we get a proper response back.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，认证成功，我们得到了适当的响应。
- en: 'We can configure the user ID and password of our choice in `application.properties`,
    as shown here:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在 `application.properties` 中配置我们选择的用户 ID 和密码，如下所示：
- en: '[PRE28]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Spring Security also provides options to authenticate with LDAP or JDBC or any
    other data source with user credentials.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Security 还提供了使用 LDAP、JDBC 或任何其他数据源和用户凭证进行认证的选项。
- en: Integration Testing
  id: totrans-245
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 集成测试
- en: 'The integration test we wrote for the service earlier will start failing because
    of invalid credentials. We will now update the integration test to supply basic
    authentication credentials:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前为服务编写的集成测试将因凭证无效而开始失败。我们现在将更新集成测试以提供基本认证凭证：
- en: '[PRE29]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Some important things to note are as follows:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些需要注意的重要事项：
- en: '`createHeaders("user-name", "user-password")`: This method creates `Base64\.
    getEncoder().encode` basic authentication headers'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '`createHeaders("user-name", "user-password")`: 此方法创建`Base64\. getEncoder().encode`基本认证头'
- en: '`ResponseEntity<String> response = template.exchange(createUrl("/users/Jack/todos"),
    ;HttpMethod.GET,new HttpEntity<String>(null, headers), String.class)`: The key
    change is the use of `HttpEntity` to supply the headers that we created earlier
    to the REST template'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '`ResponseEntity<String> response = template.exchange(createUrl("/users/Jack/todos"),
    HttpMethod.GET, new HttpEntity<String>(null, headers), String.class)`: 关键变化是使用`HttpEntity`将我们之前创建的头部信息提供给REST模板'
- en: Unit Testing
  id: totrans-251
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 单元测试
- en: 'We would not want to use security for our unit tests. The following code snippet
    shows how we can disable security for the unit test:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不希望在我们的单元测试中使用安全设置。以下代码片段展示了我们如何禁用单元测试中的安全设置：
- en: '[PRE30]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The key part is the `secure = false` parameter on the `WebMvcTest` annotation.
    This will disable Spring Security for the unit test.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 关键部分是`WebMvcTest`注解上的`secure = false`参数。这将禁用单元测试中的Spring Security。
- en: OAuth 2 Authentication
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: OAuth 2认证
- en: OAuth is a protocol that provides flows in order to exchange authorization and
    authentication information between a range of web-enabled applications and services.
    It enables third-party applications to get restricted access to user information
    from a service, for example, Facebook, Twitter, or GitHub.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth是一种协议，它提供了一系列流程，以便在一系列启用Web的应用程序和服务之间交换授权和认证信息。它允许第三方应用程序从服务（例如Facebook、Twitter或GitHub）获取对用户信息的受限访问。
- en: Before we get into the details, it would be useful to review the terminology
    typically used with respect to OAuth 2 authentication.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入细节之前，回顾一下通常与OAuth 2认证相关的术语会有所帮助。
- en: Let's consider an example. Let's say we want to expose the `Todo` API to third-party
    applications on the internet.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个例子。假设我们想将`Todo` API暴露给互联网上的第三方应用程序。
- en: 'The following are the important players in a typical OAuth 2 exchange:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在典型的OAuth 2交换中的重要参与者：
- en: '**Resource owner**: This is the user of the third-party application that wants
    to use our Todo API. It decides how much of the information available with our
    API can be made available to the third-party application.'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源所有者**：这是想要使用我们的Todo API的第三方应用程序的用户。它决定可以提供给第三方应用程序的我们API中可用信息量。'
- en: '**Resource server**: This hosts the Todo API, the resource we want to secure.'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源服务器**：这是托管Todo API，我们想要保护的资源。'
- en: '**Client**: This is the third-party application that wants to consume our API.'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**客户端**：这是想要消费我们API的第三方应用程序。'
- en: '**Authorization server**: This is the server that provides the OAuth service.'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**授权服务器**：这是提供OAuth服务的服务器。'
- en: High-level flow
  id: totrans-264
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 高级流程
- en: 'The following steps show a; high-level flow of a typical OAuth authentication:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤展示了典型OAuth认证的高级别流程：
- en: The application requests that the user authorizes access to API resources.
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用请求用户授权访问API资源。
- en: When the user provides access, the application receives an authorization grant.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当用户提供访问权限时，应用程序会收到一个授权许可。
- en: The application provides user authorization grant and its own client credentials
    to the authorization server.
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用程序向授权服务器提供用户授权许可和其自身的客户端凭证。
- en: If the authentication is successful, the authorization server responds with
    an access token.
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果认证成功，授权服务器会响应一个访问令牌。
- en: The application calls the API (the resource server) that provides the access
    token for authentication.
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用程序调用提供访问令牌进行认证的API（资源服务器）。
- en: If the access token is valid, the resource server returns the details of the
    resource.
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果访问令牌有效，资源服务器将返回资源的详细信息。
- en: Implementing OAuth 2 authentication for Our Service
  id: totrans-272
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为我们的服务实现OAuth 2认证
- en: 'OAuth 2 for Spring Security (`spring-security-oauth2`) is the module to provide
    OAuth 2 support to Spring Security. We will add it as a dependency in our `pom.xml`
    file:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth 2 for Spring Security (`spring-security-oauth2`)是提供OAuth 2支持给Spring Security的模块。我们将将其作为依赖项添加到我们的`pom.xml`文件中：
- en: '[PRE31]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Setting up Authorization and Resource Servers:'
  id: totrans-275
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置授权和资源服务器：
- en: Note
  id: totrans-276
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The `spring-security-oauth2` has not yet been (June 2017) been updated with
    the changes for Spring Framework 5.x and Spring Boot 2.x. We will use Spring Boot
    1.5.x for examples related to OAuth 2 authentication. Code examples are here in
    the GitHub repository: [https://github.com/PacktPublishing/Mastering-Spring-5.0](https://github.com/PacktPublishing/Mastering-Spring-5.0).'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '`spring-security-oauth2` 还未更新以包含 Spring Framework 5.x 和 Spring Boot 2.x 的更改（截至
    2017 年 6 月）。我们将使用 Spring Boot 1.5.x 作为 OAuth 2 认证相关示例。代码示例在 GitHub 仓库中：[https://github.com/PacktPublishing/Mastering-Spring-5.0](https://github.com/PacktPublishing/Mastering-Spring-5.0)。'
- en: Typically, an authorization server would be a different server from the application
    where the API is exposed. To keep things simple, we will make our current API
    server act both as the resource server and as the authorization server.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，授权服务器将与应用程序中公开 API 的服务器不同。为了简化问题，我们将使我们的当前 API 服务器同时作为资源服务器和授权服务器。
- en: 'The following code snippet shows how we can enable our application to act as
    the resource and authorization server:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段显示了如何使我们的应用程序能够作为资源和授权服务器：
- en: '[PRE32]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Here are a couple of important things to note:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些需要注意的重要事项：
- en: '`@EnableResourceServer`: A convenient annotation for OAuth 2 resource servers,
    enabling a Spring Security filter that authenticates requests via an incoming
    OAuth 2 token'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '`@EnableResourceServer`：一个便利的注解，用于 OAuth 2 资源服务器，启用一个 Spring Security 过滤器，通过传入的
    OAuth 2 令牌进行请求认证'
- en: '`@EnableAuthorizationServer`: A convenience annotation to enable an authorization
    server with; `AuthorizationEndpoint` and; `TokenEndpoint` in the current application
    context, which must be a `DispatcherServlet` context'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '`@EnableAuthorizationServer`：一个便利的注解，用于在当前应用程序上下文中启用一个授权服务器，包括；`AuthorizationEndpoint`
    和；`TokenEndpoint`，该上下文必须是一个 `DispatcherServlet` 上下文'
- en: 'Now we can configure the access details in `application.properties`, as shown
    in the following code snippet:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在 `application.properties` 中配置访问详情，如下面的代码片段所示：
- en: '[PRE33]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'A few important details are as follows:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些重要的细节：
- en: '`security.user.name` and `security.user.password` are the authentication details
    of the resource owner that is an end user of a third-party application'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '`security.user.name` 和 `security.user.password` 是资源所有者的认证详情，该资源所有者是第三方应用程序的最终用户'
- en: '`security.oauth2.client.clientId` and `security.oauth2.client.clientSecret`
    are the authentication details of the client that is the third-party application
    (the service consumer)'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '`security.oauth2.client.clientId` 和 `security.oauth2.client.clientSecret` 是客户端的认证详情，该客户端是第三方应用程序（服务消费者）'
- en: Executing OAuth Requests
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 执行 OAuth 请求
- en: 'We need a two-step process to access the APIs:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要两步过程来访问 API：
- en: Obtain an access token.
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取访问令牌。
- en: Execute the request using the access token.
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用访问令牌执行请求。
- en: Obtaining an Access Token
  id: totrans-293
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 获取访问令牌
- en: 'To get an access token, we call the authorization server (`http://localhost:8080/oauth/token`),
    providing the client authentication details in the basic authentication mode and
    the user credentials as part of the form data. The following screenshot shows
    how we can configure the client authentication details in basic authentication:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取访问令牌，我们调用授权服务器（`http://localhost:8080/oauth/token`），在基本认证模式下提供客户端认证详情，并将用户凭证作为表单数据的一部分。以下截图显示了如何配置基本认证中的客户端认证详情：
- en: '![Obtaining an Access Token](img/02_06.jpg)'
  id: totrans-295
  prefs: []
  type: TYPE_IMG
  zh: '![获取访问令牌](img/02_06.jpg)'
- en: 'The following screenshot shows how to configure the user authentication details
    as part of the `POST` parameters:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了如何将用户认证详情作为 `POST` 参数的一部分进行配置：
- en: '![Obtaining an Access Token](img/02_07.jpg)'
  id: totrans-297
  prefs: []
  type: TYPE_IMG
  zh: '![获取访问令牌](img/02_07.jpg)'
- en: 'We are using `grant_type` as the password, indicating that we are sending the
    user authentication details to get the access token. When we execute the request,
    we get a response similar to the one shown in the following code snippet:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `grant_type` 作为密码，表示我们正在发送用户认证详情以获取访问令牌。当我们执行请求时，我们得到一个类似于以下代码片段的响应：
- en: '[PRE34]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Here are a couple of important details:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些重要的细节：
- en: '`access_token`: Client application can use the access token to authenticate
    further API calls. However, the access token will expire, typically in a very
    short time period.'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`access_token`：客户端应用程序可以使用访问令牌来验证进一步的 API 调用。然而，访问令牌将过期，通常在非常短的时间段内。'
- en: '`refresh_token`: Client application can submit a new request to the authentication
    server with the `refresh_token` to get a new `access_token`.'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`refresh_token`：客户端应用程序可以使用 `refresh_token` 向认证服务器提交新的请求，以获取新的 `access_token`。'
- en: Executing the Request Using the Access Token
  id: totrans-303
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用访问令牌执行请求
- en: 'Once we have `access_token`, we can execute the request using `access_token`,
    as shown in the following screenshot:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了`access_token`，我们可以使用`access_token`来执行请求，如下面的截图所示：
- en: '![Executing the Request Using the Access Token](img/02_08.jpg)'
  id: totrans-305
  prefs: []
  type: TYPE_IMG
  zh: '![使用访问令牌执行请求](img/02_08.jpg)'
- en: As you can see in the preceding screenshot, we provide the access token in the
    request header called `Authorization`. We use the value of the format `"Bearer
    {access_token}"`. Authentication succeeds and we get the expected resource details.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在前面的截图中所见，我们在名为`Authorization`的请求头中提供了访问令牌。我们使用格式`"Bearer {access_token}"`的值。认证成功，我们得到了预期的资源详情。
- en: Integration Test
  id: totrans-307
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 集成测试
- en: 'We will now update our integration test to provide the OAuth 2 credentials.
    The following test highlights the important details:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将更新我们的集成测试以提供OAuth 2凭证。以下测试突出了重要细节：
- en: '[PRE35]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Some important things to note are as follows:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些需要注意的重要事项：
- en: '`ResourceOwnerPasswordResourceDetails resource = new ResourceOwnerPasswordResourceDetails()`:
    We set up `ResourceOwnerPasswordResourceDetails` with the user credentials and
    the client credentials'
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ResourceOwnerPasswordResourceDetails resource = new ResourceOwnerPasswordResourceDetails()`：我们使用用户凭证和客户端凭证设置`ResourceOwnerPasswordResourceDetails`'
- en: '`resource.setAccessTokenUri(createUrl("/oauth/token"))`: Configures the URL
    of the authentication server'
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`resource.setAccessTokenUri(createUrl("/oauth/token"))`：配置认证服务器的URL'
- en: '`OAuth2RestTemplate oauthTemplate = new OAuth2RestTemplate(resource,new DefaultOAuth2ClientContext())`:
    The `OAuth2RestTemplate` is an extension of `RestTemplate`, which supports the
    OAuth 2 protocol'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OAuth2RestTemplate oauthTemplate = new OAuth2RestTemplate(resource,new DefaultOAuth2ClientContext())`：`OAuth2RestTemplate`是`RestTemplate`的扩展，支持OAuth
    2协议'
- en: In this section, we looked at how to enable OAuth 2 authentication in our resources.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们探讨了如何在我们的资源中启用OAuth 2认证。
- en: Internationalization
  id: totrans-315
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 国际化
- en: '**Internationalization** (**i18n**) is the process of developing applications
    and services so that they can be customized for different languages and cultures
    across the world. It is also called **localization**. The goal of internationalization
    or localization is to build applications that can offer content in multiple languages
    and formats.'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '**国际化**（**i18n**）是开发应用程序和服务的过程，以便它们可以针对世界各地的不同语言和文化进行定制。它也被称为**本地化**。国际化或本地化的目标是构建可以提供多种语言和格式的应用程序。'
- en: Spring Boot has built-in support for internationalization.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot内置了对国际化的支持。
- en: Let's build a simple service to understand how we can build internationalization
    in our APIs.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们构建一个简单的服务，以了解我们如何在我们的API中构建国际化。
- en: 'We would need to add a `LocaleResolver` and a message source to our Spring
    Boot application. The following code snippet should be included in `Application.java`:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在我们的Spring Boot应用程序中添加一个`LocaleResolver`和一个消息源。以下代码片段应包含在`Application.java`中：
- en: '[PRE36]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Some important things to note are as follows:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些需要注意的重要事项：
- en: '`sessionLocaleResolver.setDefaultLocale(Locale.US)`: We are a setting a default
    locale of `Locale.US`.'
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sessionLocaleResolver.setDefaultLocale(Locale.US)`：我们正在设置默认区域为`Locale.US`。'
- en: '`messageSource.setBasenames("messages")`: We''re setting the base name of the
    message source as `messages`. If we are in fr locale (France), we would use messages
    from `message_fr.properties`. If a message is not available in `message_fr.properties`,
    it would be searched for in the default `message.properties`.'
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`messageSource.setBasenames("messages")`：我们将消息源的基本名称设置为`messages`。如果我们处于fr区域（法国），我们将使用`message_fr.properties`中的消息。如果`message_fr.properties`中没有找到消息，它将在默认的`message.properties`中搜索。'
- en: '`messageSource.setUseCodeAsDefaultMessage(true)`: If a message is not found,
    then the code is returned as the default message.'
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`messageSource.setUseCodeAsDefaultMessage(true)`：如果找不到消息，则返回代码作为默认消息。'
- en: 'Let''s configure the messages in the respective files. Let''s start with the
    `messages` properties. The messages in this file would act as the defaults:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在各自的文件中配置消息。让我们从`messages`属性开始。这个文件中的消息将作为默认值：
- en: '[PRE37]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Let''s also configure `messages_fr.properties`. The messages in this file would
    be used for the locale. If a message is not present here, then the defaults from
    `messages.properties` will be used:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们也配置`messages_fr.properties`。这个文件中的消息将用于区域。如果这里没有消息，则将使用`messages.properties`中的默认值：
- en: '[PRE38]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Let''s create a service that returns a specific message using the locale specified
    in the `"Accept-Language"` header:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个服务，该服务使用`"Accept-Language"`头中指定的区域返回特定的消息：
- en: '[PRE39]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Here are a couple of things to note:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些需要注意的事项：
- en: '`@RequestHeader(value = "Accept-Language", required = false) Locale locale`:
    The locale is picked up from the request header `Accept-Language`. It is not required.
    If a locale is not specified, the default locale is used.'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '`@RequestHeader(value = "Accept-Language", required = false) Locale locale`:
    区域设置是从请求头 `Accept-Language` 中获取的。这不是必需的。如果没有指定区域设置，则使用默认区域设置。'
- en: '`messageSource.getMessage("welcome.message", null, locale)`: `messageSource`
    is autowired into the controller. We get the welcome message based on the given
    locale.'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '`messageSource.getMessage("welcome.message", null, locale)`: `messageSource`
    自动注入到控制器中。我们根据给定的区域设置获取欢迎消息。'
- en: 'The following screenshot shows the response when the preceding service is called
    without specifying a default `Accept-Language`:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了在未指定默认 `Accept-Language` 时调用先前服务时的响应：
- en: '![Internationalization](img/02_09.jpg)'
  id: totrans-335
  prefs: []
  type: TYPE_IMG
  zh: '![国际化](img/02_09.jpg)'
- en: The default message from `messages.properties` is returned.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `messages.properties` 返回默认消息。
- en: 'The following screenshot shows the response when the preceding service is called
    with `Accept-Language fr`:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了在调用先前服务时带有 `Accept-Language fr` 的响应：
- en: '![Internationalization](img/02_10.jpg)'
  id: totrans-338
  prefs: []
  type: TYPE_IMG
  zh: '![国际化](img/02_10.jpg)'
- en: The localized message from `messages_fr.properties` is returned.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `messages_fr.properties` 返回的本地化消息。
- en: In the preceding example, we customized the service to return localized messages
    based on the locale in the request. A similar approach can be used to internationalize
    all services in a component.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们定制了服务以根据请求中的区域设置返回本地化消息。类似的方法可以用来国际化组件中的所有服务。
- en: Caching
  id: totrans-341
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓存
- en: Caching data from services plays a crucial role in improving the performance
    and scalability of applications. In this section, we will look at the implementation
    options that Spring Boot provides.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 从服务中缓存数据在提高应用程序的性能和可伸缩性方面起着至关重要的作用。在本节中，我们将探讨 Spring Boot 提供的实现选项。
- en: Spring provides a caching abstraction based on annotations. We will start with
    using Spring caching annotations. Later, we will introduce **JSR-107** caching
    annotations and compare them with Spring abstractions.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: Spring 提供了一个基于注解的缓存抽象。我们将从使用 Spring 缓存注解开始。稍后，我们将介绍 **JSR-107** 缓存注解，并将它们与 Spring
    抽象进行比较。
- en: Spring-boot-starter-cache
  id: totrans-344
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Spring-boot-starter-cache
- en: 'Spring Boot provides a starter project for caching `spring-boot-starter-cache`.
    Adding this to an application brings in all the dependencies to enable **JSR-107**
    and Spring caching annotations. The following code snippet shows the dependency
    details for `spring-boot-starter-cache`. Let''s add this to our file `pom.xml`:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot 为缓存提供了一个启动项目 `spring-boot-starter-cache`。将此添加到应用程序中会引入所有依赖项以启用 **JSR-107**
    和 Spring 缓存注解。以下代码片段展示了 `spring-boot-starter-cache` 的依赖项细节。让我们将其添加到我们的 `pom.xml`
    文件中：
- en: '[PRE40]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Enabling Caching
  id: totrans-347
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启用缓存
- en: 'Before we can start using caching, we need to enable caching on the application.
    The following code snippet shows how we can enable caching:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始使用缓存之前，我们需要在应用程序上启用缓存。以下代码片段展示了我们如何启用缓存：
- en: '[PRE41]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '`@EnableCaching` would enable caching in a Spring Boot application.'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '`@EnableCaching` 将在 Spring Boot 应用程序中启用缓存。'
- en: Spring Boot automatically configures a suitable CacheManager framework to serve
    as a provider for the relevant cache. We will look at the details of how Spring
    Boot decides the CacheManager a little later.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot 自动配置了一个合适的 CacheManager 框架，作为相关缓存的提供者。我们稍后会看看 Spring Boot 如何决定 CacheManager
    的细节。
- en: Caching Data
  id: totrans-352
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缓存数据
- en: 'Now that we have enabled caching, we can add the `@Cacheable` annotation to
    the methods where we want to cache the data. The following code snippet shows
    how to enable caching on `retrieveTodos`:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经启用了缓存，我们可以在想要缓存数据的方法上添加 `@Cacheable` 注解。以下代码片段展示了如何在 `retrieveTodos` 上启用缓存：
- en: '[PRE42]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: In the preceding example, the `todos` for a specific user are cached. On the
    first call to the method for a specific user, the `todos` will be retrieved from
    the service. On subsequent calls for the same user, the data will be returned
    from the cache.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，特定用户的 `todos` 被缓存。在第一次调用特定用户的方法时，`todos` 将从服务中检索。在随后的对同一用户的调用中，数据将从缓存中返回。
- en: 'Spring also provides conditional caching. In the following snippet, caching
    is enabled only if the specified condition is satisfied:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: Spring 还提供了条件缓存。在以下代码片段中，只有当指定的条件满足时才启用缓存：
- en: '[PRE43]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Spring also provides additional annotations to evict data from the cache and
    add some custom data to cache. A few important ones are listed as follows:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: Spring 还提供了额外的注解来从缓存中驱逐数据并添加一些自定义数据到缓存。以下列出了一些重要的注解：
- en: '`@CachePut`: Used to explicitly add data to the cache'
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@CachePut`：用于显式地将数据添加到缓存中'
- en: '`@CacheEvict`: Used to remove stale data from the cache'
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@CacheEvict`：用于从缓存中删除过时数据'
- en: '`@Caching`: Allows multiple nested `@Cacheable`, `@CachePut`, and `@CacheEvict`
    annotations to be used on the same method'
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Caching`：允许在同一个方法上使用多个嵌套的 `@Cacheable`、`@CachePut` 和 `@CacheEvict` 注解'
- en: JSR-107 Caching Annotations
  id: totrans-362
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JSR-107 缓存注解
- en: '**JSR-107** aims to standardize caching annotations. Listed here are some of
    the important **JSR-107** annotations:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '**JSR-107** 旨在标准化缓存注解。以下列出了一些重要的 **JSR-107** 注解：'
- en: '`@CacheResult`: Similar to `@Cacheable`'
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@CacheResult`：类似于 `@Cacheable`'
- en: '`@CacheRemove`: Similar to `@CacheEvict` `@CacheRemove` supports conditional
    eviction if an exception occurs'
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@CacheRemove`：类似于 `@CacheEvict`，如果发生异常，`@CacheRemove` 支持条件删除'
- en: '`@CacheRemoveAll`: Similar to `@CacheEvict(allEntries=true)`; used to remove
    all entries from the cache'
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@CacheRemoveAll`：类似于 `@CacheEvict(allEntries=true)`；用于从缓存中删除所有条目'
- en: '**JSR-107** and Spring''s caching annotations are fairly similar in terms of
    the features they offer. Either of them is a good choice. We lean slightly toward
    **JSR-107** because it''s a standard. However, make sure you are not using both
    in the same project.'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '**JSR-107** 和 Spring 的缓存注解在提供的功能方面相当相似。两者都是不错的选择。我们稍微倾向于 **JSR-107**，因为它是一个标准。然而，请确保你不在同一个项目中使用两者。'
- en: Auto-Detection Order
  id: totrans-368
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自动检测顺序
- en: 'When caching is enabled, Spring Boot auto-configuration starts looking for
    a caching provider. The following list shows the order in which Spring Boot searches
    for caching providers. The list is in order of decreasing preference:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 当启用缓存时，Spring Boot 自动配置开始寻找缓存提供者。以下列表显示了 Spring Boot 搜索缓存提供者的顺序。列表按偏好递减的顺序排列：
- en: JCache (**JSR-107**) (EhCache 3, Hazelcast, Infinispan, and so on)
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JCache （**JSR-107**）（EhCache 3、Hazelcast、Infinispan 等）
- en: EhCache 2.x
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: EhCache 2.x
- en: Hazelcast
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Hazelcast
- en: 'Infinispan     Couchbase'
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Infinispan     Couchbase'
- en: Redis
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Redis
- en: Caffeine
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Caffeine
- en: Guava
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Guava
- en: Simple
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单
- en: Summary
  id: totrans-378
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Spring Boot makes developing Spring-based applications easy. It enables us to
    create production-ready applications very quickly.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot 使基于 Spring 的应用程序的开发变得简单。它使我们能够非常快速地创建生产就绪的应用程序。
- en: In this lesson, we covered how to add features such as exception handling, caching,
    and internationalization to our application. We discussed the best practices of
    documenting REST services using Swagger. We looked at the basics of securing our
    microservice with Spring Security.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 在本课中，我们介绍了如何将异常处理、缓存和国际化的功能添加到我们的应用程序中。我们讨论了使用 Swagger 记录 REST 服务的最佳实践。我们探讨了如何使用
    Spring Security 保护我们的微服务的基础知识。
- en: In the next lesson, we will shift our attention toward advanced features in
    Spring Boot. We will look at how to provide monitoring on top of our REST services,
    learn how to deploy the microservice to the Cloud, and understand how to become
    more productive when developing applications with Spring Boot.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一课中，我们将把注意力转向 Spring Boot 的高级功能。我们将探讨如何在我们的 REST 服务上提供监控，学习如何将微服务部署到云端，以及了解如何在使用
    Spring Boot 开发应用程序时提高生产力。
- en: Assessments
  id: totrans-382
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 评估
- en: The _________ provides a number of annotations that can be used to validate
    beans.
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: _________ 提供了一组可用于验证 Bean 的注解。
- en: Which of the following is an annotated element size that must be within the
    specified boundaries?
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪个是必须位于指定边界内的注解元素大小？
- en: '`@SizeOf`'
  id: totrans-385
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`@SizeOf`'
- en: '`@SizeBoundary`'
  id: totrans-386
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`@SizeBoundary`'
- en: '`@SizeTo`'
  id: totrans-387
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`@SizeTo`'
- en: '`@Size`'
  id: totrans-388
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`@Size`'
- en: 'State whether True or False: HATEOAS is one of the key features of the REST
    application architecture.'
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 判断对错：HATEOAS 是 REST 应用架构的关键特性之一。
- en: Which of the following is a simple builder class to configure the generation
    of Swagger documentation using the Swagger Spring MVC framework?
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪个是一个简单的构建器类，用于使用 Swagger Spring MVC 框架配置生成 Swagger 文档？
- en: Docket
  id: totrans-391
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: Docket
- en: Swagger
  id: totrans-392
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: Swagger
- en: REST
  id: totrans-393
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: REST
- en: QAuth
  id: totrans-394
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: QAuth
- en: Which of the following is a convenient annotation for OAuth 2 resource servers
    that enable a Spring Security filter which authenticates requests via an incoming
    OAuth 2 token?
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪个是 OAuth 2 资源服务器的一个方便的注解，它启用了一个通过传入的 OAuth 2 令牌进行请求认证的 Spring Security 过滤器？
- en: '`@enableResourceServer`'
  id: totrans-396
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`@enableResourceServer`'
- en: '`@enablesResourcesServer`'
  id: totrans-397
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`@enablesResourcesServer`'
- en: '`@EnableResourceServer`'
  id: totrans-398
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`@EnableResourceServer`'
- en: '`@EnableResourceServers`'
  id: totrans-399
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`@EnableResourceServers`'
