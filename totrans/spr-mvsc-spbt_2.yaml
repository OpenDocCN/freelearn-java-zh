- en: Chapter 2. Extending Microservices
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We built a basic component offering a few services in Lesson 1, *Building Microservices
    with Spring Boot*. In this lesson, we will focus on adding more features to make
    our microservice production ready.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'We will discuss how to add these features to our microservice:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Exception handling
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HATEOAS
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Caching
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Internationalization
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will also discuss how to document our microservice using Swagger. We will
    look at the basics of securing the microservice with Spring Security.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: Exception Handling
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Exception handling is one of the important parts of developing web services.
    When something goes wrong, we would want to return a good description of what
    went wrong to the service consumer. You would not want the service to crash without
    returning anything useful to the service consumer.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: Spring Boot provides good default exception handling. We will start with looking
    at the default exception handling features provided by Spring Boot before moving
    on to customizing them.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: Spring Boot Default Exception Handling
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To understand the default exception handling provided by Spring Boot, let's
    start with firing a request to a nonexistent URL.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: Non-Existent Resource
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let's send a `GET` request to `http://localhost:8080/non-existing-resource`
    using a header (`Content-Type:application/json`).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the response when we execute the request:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '![Non-Existent Resource](img/02_01.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
- en: 'The response is as shown in the following code snippet:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Some important things to note are as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: The response header has an HTTP status of `404 - Resource Not Found`
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring Boot returns a valid JSON message as a response with the message stating
    that the resource is not found
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resource Throwing an Exception
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let's create a resource that throws an exception, and send a `GET` request to
    it in order to understand how the application reacts to runtime exceptions.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a dummy service that throws an exception. The following code
    snippet shows a simple service:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Some important things to note are as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: We are creating a `GET` service with the URI `/users/dummy-service`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: The service throws a `RuntimeException`. We chose `RuntimeException` to be able
    to create the exception easily. We can easily replace it with a custom exception;
    if needed.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s fire a `GET` request to the preceding service at `http://localhost:8080/users/dummy-service`
    using Postman. The response is as shown in the following code:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Some important things to note are as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: The response header has an HTTP status of `500`; `Internal server error`
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring Boot also returns the message with which the exception is thrown
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we can see in the preceding two examples, Spring Boot provides good default
    exception handling. In the next section, we will focus on understanding how the
    application reacts to custom exceptions.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: Throwing a Custom Exception
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s create a custom exception and throw it from a service. Take a look at
    the following code:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: It's a very simple piece of code that defines `TodoNotFoundException`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一段非常简单的代码，它定义了 `TodoNotFoundException`。
- en: 'Now let''s enhance our `TodoController` class to throw `TodoNotFoundException`
    when a `todo` with a given ID is not found:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们增强我们的 `TodoController` 类，以便在找不到具有给定 ID 的 `todo` 时抛出 `TodoNotFoundException`：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: If `todoService` returns a null `todo`, we throw; `TodoNotFoundException`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `todoService` 返回一个 null 的 `todo`，我们将抛出 `TodoNotFoundException`。
- en: 'When we execute the service with a `GET` request to a nonexistent: `todo`(`http://localhost:8080/users/Jack/todos/222`),
    we get the response shown in the following code snippet:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用 `GET` 请求对一个不存在的 `todo`（`http://localhost:8080/users/Jack/todos/222`）执行服务时，我们会得到以下代码片段中显示的响应：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As we can see, a clear exception response is sent back to the service consumer.
    However, there is one thing that can be improved further--the response status.
    When a resource is not found, it is recommended that you return a `404 - Resource
    Not Found` status. We will look at how to customize the response status in the
    next example.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，一个清晰的异常响应被发送回服务消费者。然而，还有一件事可以进一步改进——响应状态。当资源未找到时，建议您返回一个 `404 - 资源未找到`
    状态。我们将在下一个示例中查看如何自定义响应状态。
- en: Customizing the Exception Message
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自定义异常消息
- en: Let's look at how to customize the preceding exception and return the proper
    response status with a customized message.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何自定义前面的异常，并返回带有自定义消息的正确响应状态。
- en: 'Let''s create a bean to define the structure of our custom exception message:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个实体来定义我们自定义异常消息的结构：
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We have created a simple exception response bean with an auto-populated timestamp
    with a few additional properties namely messages and details.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个简单的异常响应实体，它具有自动填充的时间戳和一些额外的属性，即消息和详细信息。
- en: 'When; `TodoNotFoundException` is thrown, we would want to return a response
    using the `ExceptionResponse` bean. The following code shows how we can create
    a global exception handling for `TodoNotFoundException.class`:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `TodoNotFoundException` 被抛出时，我们希望使用 `ExceptionResponse` 实体返回一个响应。以下代码展示了我们如何为
    `TodoNotFoundException.class` 创建全局异常处理：
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Some important things to note are as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些需要注意的重要事项：
- en: '`RestResponseEntityExceptionHandler extends ResponseEntityExceptionHandler`:
    We are extending `ResponseEntityExceptionHandler`, which the base class is provided
    by Spring MVC for centralised exception handling `ControllerAdvice` classes.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`RestResponseEntityExceptionHandler extends ResponseEntityExceptionHandler`:
    我们正在扩展 `ResponseEntityExceptionHandler`，这是由 Spring MVC 为集中式异常处理 `ControllerAdvice`
    类提供的基类。'
- en: '`@ExceptionHandler(TodoNotFoundException.class)`: This defines that the method
    to follow will handle the specific exception `TodoNotFoundException.class`. Any
    other exceptions for which custom exception handling is not defined will follow
    the default exception handling provided by Spring Boot.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`@ExceptionHandler(TodoNotFoundException.class)`: 这定义了接下来的方法将处理特定的异常 `TodoNotFoundException.class`。对于没有定义自定义异常处理的任何其他异常，将遵循
    Spring Boot 提供的默认异常处理。'
- en: '`ExceptionResponse exceptionResponse = new ExceptionResponse(ex.getMessage(),
    "Any details you would want to add")`: This creates a custom exception response.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`ExceptionResponse exceptionResponse = new ExceptionResponse(ex.getMessage(),
    "Any details you would want to add")`: 这将创建一个自定义的异常响应。'
- en: '`new ResponseEntity<ExceptionResponse>(exceptionResponse,new HttpHeaders(),
    HttpStatus.NOT_FOUND)`: This is the definition to return a `404 Resource Not Found`
    response with the custom exception defined earlier.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`new ResponseEntity<ExceptionResponse>(exceptionResponse,new HttpHeaders(),
    HttpStatus.NOT_FOUND)`: 这是返回一个 `404 资源未找到` 响应并使用之前定义的自定义异常的定义。'
- en: 'When we execute the service with a `GET` request to a nonexistent; `todo`(`http://localhost:8080/users/Jack/todos/222`),
    we get the following response:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用 `GET` 请求对一个不存在的 `todo`（`http://localhost:8080/users/Jack/todos/222`）执行服务时，我们会得到以下响应：
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: If you want to create a generic exception message for all exceptions, we can
    add a method to `RestResponseEntityExceptionHandler` with the `@ExceptionHandler(Exception.class)`
    annotation.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想为所有异常创建一个通用的异常消息，我们可以在 `RestResponseEntityExceptionHandler` 中添加一个带有 `@ExceptionHandler(Exception.class)`
    注解的方法。
- en: 'The following code snippet shows how we can do this:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段展示了我们如何做到这一点：
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Any exception for which a custom exception handler is not defined; will be handled
    by the preceding method.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 对于没有定义自定义异常处理器的任何异常，将由前面的方法处理。
- en: Response Status
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 响应状态
- en: 'One of the important things to focus on with REST services is the response
    status of an error response. The following table shows the scenarios and the error
    response status to use:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在REST服务中，我们需要关注的一个重要问题是错误响应的状态码。以下表格显示了场景和应使用的错误响应状态码：
- en: '| Situation | Response Status |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| 情况 | 响应状态 |'
- en: '| --- | --- |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| The request body does not meet the API specification. It does not contain
    enough details or contains validation errors. | ;400 BAD REQUEST |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| 请求体不符合API规范。它不包含足够的细节或包含验证错误。 | 400 BAD REQUEST |'
- en: '| Authentication or authorization failure. | 401 UNAUTHORIZED |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| 认证或授权失败。 | 401 UNAUTHORIZED |'
- en: '| The user cannot perform the operation due to various factor, such as exceeding
    limits. | 403 FORBIDDEN |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| 由于各种因素，如超出限制，用户无法执行操作。 | 403 FORBIDDEN |'
- en: '| The resource does not exist. | 404 NOT FOUND |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| 资源不存在。 | 404 NOT FOUND |'
- en: '| Unsupported operation, for example, trying POST on a resource where only
    GET is allowed. | 405 METHOD NOT ALLOWED |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| 不支持的操作，例如，在只允许GET的资源上尝试POST。 | 405 METHOD NOT ALLOWED |'
- en: '| Error on a server. Ideally, this should not happen. The consumer; would not
    be able to fix this. | 500 INTERNAL SERVER ERROR |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| 服务器错误。理想情况下，这种情况不应该发生。消费者无法修复这个问题。 | 500 INTERNAL SERVER ERROR |'
- en: In this section, we looked at the default exception handling provided by Spring
    Boot and how we can customize it further to suit our needs.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们探讨了Spring Boot提供的默认异常处理以及如何进一步自定义以满足我们的需求。
- en: HATEOAS
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HATEOAS
- en: '**HATEOAS** (**Hypermedia as the Engine of Application State**) is one of the
    constraints of the REST application architecture.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '**HATEOAS**（**超媒体作为应用状态引擎**）是REST应用架构的约束之一。'
- en: Let's consider a situation where a service consumer is consuming numerous services
    from a service provider. The easiest way to develop this kind of system is to
    have the service consumer store the individual resource URIs of every resource
    they need from the service provider. However, this would create tight coupling
    between the service provider and the service consumer. Whenever any of the resource
    URIs change on the service provider, the service consumer needs to be updated.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个服务消费者从服务提供商消费众多服务的情况。开发这种系统的最简单方法是将服务消费者需要从服务提供商获取的每个资源的单个资源URI存储起来。然而，这将在服务提供者和服务消费者之间创建紧密耦合。每当服务提供商上的任何资源URI发生变化时，服务消费者都需要进行更新。
- en: Consider a; typical web application. Let's say I navigate to my bank account
    details page. Almost all banking websites would show links to all the transactions
    that are possible on my bank account on the screen so that I can easily navigate
    using the link.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个典型的Web应用。假设我导航到我的银行账户详情页面。几乎所有的银行网站都会在屏幕上显示我银行账户上所有可能的交易链接，以便我可以通过链接轻松导航。
- en: What if we can bring a; similar concept to RESTful services so that a service
    returns not only the data about the requested resource, but also provides details
    of other related resources?
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们能够将一个类似的概念引入RESTful服务中，使得服务不仅返回请求资源的有关数据，还提供其他相关资源的详细信息呢？
- en: HATEOAS brings this concept of displaying related links for a given resource
    to RESTful services. When we return the details of a specific resource, we also
    return links to operations that can be performed on the resource, as well as links
    to related resources. If a service consumer can use the links from the response
    to perform transactions, then it would not need to hardcode all links.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: HATEOAS将这种为给定资源显示相关链接的概念引入RESTful服务。当我们返回特定资源的详细信息时，我们也会返回可以对该资源执行的操作的链接，以及相关资源的链接。如果服务消费者可以使用响应中的链接执行交易，那么它就不需要硬编码所有链接。
- en: 'An extract of constraints related to HATEOAS presented by Roy Fielding ([http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven](http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven))
    is as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Roy Fielding（[http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven](http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven)）提出的与HATEOAS相关的约束摘录如下：
- en: '*A REST API must not define fixed resource names or hierarchies (an obvious
    coupling of client and server). Servers must have the freedom to control their
    own namespace. Instead, allow servers to instruct clients on how to construct
    appropriate URIs, such as is done in HTML forms and URI templates, by defining
    those instructions within media types and link relations.*'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '*A REST API should be entered with no prior knowledge beyond the initial URI
    (bookmark) and set of standardized media types that are appropriate for the intended
    audience (i.e., expected to be understood by any client that might use the API).
    From that point on, all application state transitions must be driven by client
    selection of server-provided choices that are present in the received representations
    or implied by the user''s manipulation of those representations. The transitions
    may be determined (or limited by) the client''s knowledge of media types and resource
    communication mechanisms, both of which may be improved on-the-fly (e.g., code-on-demand).*'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: 'An example response with HATEOAS link is shown here. This is the response to
    the `/todos` request in order to retrieve all todos:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The preceding response includes links to the following:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: Specific `todos` (`http://localhost:8080/todos/1`)
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Search resource (`http://localhost:8080/todos/search`)
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the service consumer wants to do a search, it has the option of taking the
    search URL from the response and sending the search request to it. This would
    reduce coupling between the service provider and the service consumer.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: Sending HATEOAS Links in Response
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we understand what HATEOAS is, let's look at how we can send links
    related to a resource in the response.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: Spring Boot Starter HATEOAS
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Spring Boot has a specific starter for HATEOAS called `spring-boot-starter-hateoas`.
    We need to add it to the `pom.xml` file.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet shows the dependency block:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'One of the important dependencies of `spring-boot-starter-hateoas` is `spring-hateoas`,
    which provides the HATEOAS features:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Let''s enhance the `retrieveTodo` resource (`/users/{name}/todos/{id}`) to
    return a link to retrieve all `todos` (`/users/{name}/todos`) in the response:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Some important points to note are as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '`ControllerLinkBuilder linkTo = linkTo(methodOn(this.getClass()).retrieveTodos(name))`:
    We want to get a link to the `retrieveTodos` method on the current class'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`linkTo.withRel("parent")`: Relationship with the current resource is parent'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following snippet shows the response when a `GET` request is sent to `http://localhost:8080/users/Jack/todos/1`:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `_links` section will contain all the links. Currently, we have one link
    with the relation parent and `href` as `http://localhost:8080/users/Jack/todos`.:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you have problems executing the preceding request, try executing using an
    Accept header--`application/json`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: HATEOAS is not something that is commonly used in most of the resources today.
    However, it has the potential to be really useful in reducing the coupling between
    the service provider and the consumer.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: HATEOAS不是今天大多数资源中常用的东西。然而，它有潜力在减少服务提供者和消费者之间的耦合方面真正有用。
- en: Validation
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证
- en: A good service always validates data before processing it. In this section,
    we will look at the Bean Validation API and use its reference implementation to
    implement validation in our services.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的服务总是在处理数据之前验证数据。在本节中，我们将查看Bean验证API并使用其参考实现来在我们的服务中实现验证。
- en: 'The Bean Validation API provides a number of annotations that can be used to
    validate beans. The **JSR 349** specification defines Bean Validation API 1.1\.
    Hibernate-validator is the reference implementation; both are already defined
    as dependencies in the `spring-boot-web-starter` project:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Bean验证API提供了一些注解，可以用来验证Bean。**JSR 349**规范定义了Bean验证API 1.1。Hibernate-validator是参考实现；两者都已定义为`spring-boot-web-starter`项目中的依赖项：
- en: '`hibernate-validator-5.2.4.Final.jar`'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hibernate-validator-5.2.4.Final.jar`'
- en: '`validation-api-1.1.0.Final.jar`'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`validation-api-1.1.0.Final.jar`'
- en: We will create a simple validation for the `createTodo` service method.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为`createTodo`服务方法创建一个简单的验证。
- en: 'Creating validations involves two steps:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 创建验证涉及两个步骤：
- en: Enabling validation on the controller method.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制器方法上启用验证。
- en: Adding validations on the bean.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Bean上添加验证
- en: Enabling Validation on the Controller Method
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在控制器方法上启用验证
- en: 'It''s very simple to enable validation on the controller method. The following
    snippet shows an example:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在控制器方法上启用验证非常简单。以下代码片段展示了示例：
- en: '[PRE15]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `@Valid(package javax.validation)` annotation is used to mark a parameter
    for validation. Any validation that is defined in the `Todo` bean is executed
    before the `add` method is executed.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`@Valid(package javax.validation)`注解来标记一个参数进行验证。在`add`方法执行之前，会执行在`Todo` Bean中定义的任何验证。
- en: Defining validations on the Bean
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Bean上定义验证
- en: 'Let''s define a few validations on the `Todo` bean:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为`Todo` Bean定义一些验证：
- en: '[PRE16]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Some important points to note are as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些需要注意的重要点：
- en: '`@NotNull`: Validates that the user field is not empty'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@NotNull`：验证用户字段不为空'
- en: '`@Size(min = 9, message = "Enter atleast 10 Characters.")`: Checks whether
    the `desc` field has at least nine characters'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Size(min = 9, message = "Enter atleast 10 Characters.")`：检查`desc`字段是否至少有九个字符'
- en: 'There are a number of other annotations that can be used to validate beans.
    The following are some of the Bean Validation annotations:'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有许多其他注解可以用来验证Bean。以下是一些Bean验证注解：
- en: '`@AssertFalse`, `@AssertTrue`: For Boolean elements. Checks the annotated element.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@AssertFalse`，`@AssertTrue`：对于布尔元素。检查被注解的元素。'
- en: '`@AssertFalse`: Checks for false. `@Assert` checks for true.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@AssertFalse`：检查是否为false。`@Assert`检查是否为true。'
- en: '`@Future`: The annotated element must be a date in the future.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Future`：被注解的元素必须是一个未来的日期。'
- en: '`@Past`: The annotated element must be a date in the past.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Past`：被注解的元素必须是一个过去的日期。'
- en: '`@Max`: The annotated element must be a number whose value must be lower or
    equal to the specified maximum.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Max`：被注解的元素必须是一个数值，其值必须小于或等于指定的最大值。'
- en: '`@Min`: The annotated element must be a number whose value must be higher or
    equal to the specified minimum.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Min`：被注解的元素必须是一个数值，其值必须大于或等于指定的最小值。'
- en: '`@NotNull`: The annotated element cannot be null.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@NotNull`：被注解的元素不能为null。'
- en: '`@Pattern`: The annotated `{@code CharSequence}` element must match the specified
    regular expression. The regular expression follows the Java regular expression
    conventions.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Pattern`：被注解的`{@code CharSequence}`元素必须匹配指定的正则表达式。正则表达式遵循Java正则表达式约定。'
- en: '`@Size`: The annotated element size must be within the specified boundaries.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Size`：被注解的元素大小必须在指定的范围内。'
- en: Unit Testing Validations
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单元测试验证
- en: 'The following example shows how we can unit test the validations we added in:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了我们如何对添加的验证进行单元测试：
- en: '[PRE17]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Some important points to note are as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些需要注意的重要点：
- en: '`"desc":"Learn"`: We are using a `desc` value of length `5`. This would cause
    a validation failure for the `@Size(min = 9, message = "Enter atleast 10 Characters.")`
    check.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"desc":"Learn"`：我们使用长度为`5`的`desc`值。这将导致`@Size(min = 9, message = "Enter atleast
    10 Characters.")`检查的验证失败。'
- en: '`.andExpect(status().is4xxClientError())`: Checks for validation error status.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.andExpect(status().is4xxClientError())`：检查验证错误状态。'
- en: Documenting REST Services
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 记录REST服务
- en: 'Before a service provider can consume a service, they need a service contract.
    A service contract defines all the; details about a service:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务提供者能够消费服务之前，他们需要一个服务契约。服务契约定义了关于服务的一切细节：
- en: How can I call a service? What is the URI of the service?
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我该如何调用服务？服务的URI是什么？
- en: What should be the request format?
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求格式应该是什么？
- en: What kind of response should I expect?
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我应该期待什么样的响应？
- en: There are multiple options to define a service contract for RESTful services.
    The most popular one in the last couple of years is **Swagger**. Swagger is gaining
    a lot of ground, with support from major vendors in the last couple of years.
    In this section, we will generate Swagger documentation for our services.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 定义RESTful服务的服务契约有多种选择。在过去几年中，最受欢迎的是**Swagger**。Swagger在过去几年中获得了很大的支持，得到了主要供应商的支持。在本节中，我们将为我们的服务生成Swagger文档。
- en: 'The following quote from the Swagger website ([http://swagger.io](http://swagger.io))
    defines the purpose of the Swagger specification:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是从Swagger网站（[http://swagger.io](http://swagger.io)）摘录的引言，定义了Swagger规范的目的：
- en: Swagger specification creates the RESTful contract for your API, detailing all
    of its resources and operations in a human and machine readable format for easy
    development, discovery, and integration.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: Swagger规范为您的API创建RESTful契约，详细说明了所有资源及其操作，以人类和机器可读的格式，便于开发、发现和集成。
- en: Generating a Swagger Specification
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成Swagger规范
- en: One of the interesting developments in the last few years of RESTful services
    development is the evolution of tools to generate service documentation (specification)
    from the code. This ensures that the code and documentation are always in sync.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去几年中，RESTful服务开发中一个有趣的发展趋势是生成服务文档（规范）的工具的演变。这确保了代码和文档始终保持同步。
- en: '**Springfox Swagger** can be used to generate Swagger documentation from the
    RESTful services code. What''s more, there is a wonderful tool called **Swagger
    UI**, which, when integrated into the application, provides human-readable documentation.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '**Springfox Swagger**可以用于从RESTful服务代码中生成Swagger文档。更有甚者，还有一个叫做**Swagger UI**的出色工具，当集成到应用程序中时，提供了人类可读的文档。'
- en: 'The following code snippet shows how we can add both these tools; to the; `pom.xml`
    file:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段展示了如何将这两个工具添加到`pom.xml`文件中：
- en: '[PRE18]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The next step is to add the configuration class to enable and generate Swagger
    documentation. The following snippet shows how to do it:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是添加配置类以启用和生成Swagger文档。以下片段展示了如何操作：
- en: '[PRE19]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Some important points to note are as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些需要注意的重要点：
- en: '`@Configuration`: Defines a Spring configuration file'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Configuration`: 定义一个Spring配置文件'
- en: '`@EnableSwagger2`: The annotation to enable Swagger support'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@EnableSwagger2`: 启用Swagger支持的注解'
- en: '`Docket`: A simple builder class to configure the generation of Swagger documentation
    using the Swagger Spring MVC framework'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Docket`: 一个简单的构建类，用于使用Swagger Spring MVC框架配置Swagger文档的生成'
- en: '`new Docket(DocumentationType.SWAGGER_2)`: Configures Swagger 2 as the Swagger
    version to be used'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`new Docket(DocumentationType.SWAGGER_2)`: 配置Swagger 2作为要使用的Swagger版本'
- en: '`.apis(RequestHandlerSelectors.any()).paths(PathSelectors.any())`: Includes
    all APIs and paths in the documentation'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.apis(RequestHandlerSelectors.any()).paths(PathSelectors.any())`: 在文档中包含所有API和路径'
- en: 'When we bring the server up, we can launch the API Docs URL (`http://localhost:8080/v2/api-docs`).
    The following screenshot shows some of the generated documentation:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们启动服务器时，我们可以启动API文档URL（`http://localhost:8080/v2/api-docs`）。以下截图显示了部分生成的文档：
- en: '![Generating a Swagger Specification](img/02_02.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![生成Swagger规范](img/02_02.jpg)'
- en: 'Let''s look at some of the generated documentation. Listed here is the documentation
    to retrieve the; `todos` service:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些生成的文档。以下是检索`todos`服务的文档：
- en: '[PRE20]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The service definition clearly defines the request; and response; of the service.
    Also defined are the different response statuses that the service can return in
    different situations.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 服务定义明确定义了服务的请求和响应。还定义了服务在不同情况下可以返回的不同响应状态。
- en: 'The following code snippet shows the definition of the `Todo` bean:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段展示了`Todo`实体的定义：
- en: '[PRE21]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: It defines all the elements in the `Todo` bean, along with their formats.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 它定义了`Todo`实体中的所有元素，以及它们的格式。
- en: Swagger UI
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Swagger UI
- en: Swagger UI (`http://localhost:8080/swagger-ui.html`) can also be used to look
    at the documentation. Swagger UI is enabled by the dependency (`io.springfox:springfox-swagger-ui`)
    that was added in our `pom.xml`, in the previous step.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: Swagger UI (`http://localhost:8080/swagger-ui.html`) 也可以用来查看文档。Swagger UI 通过在之前的步骤中添加的依赖项
    (`io.springfox:springfox-swagger-ui`) 启用。
- en: Swagger UI ([http://petstore.swagger.io](http://petstore.swagger.io)) is also
    available online. We can visualize any Swagger documentation (swagger JSON) using
    Swagger UI.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: Swagger UI ([http://petstore.swagger.io](http://petstore.swagger.io)) 也可在网上使用。我们可以使用
    Swagger UI 可视化任何 Swagger 文档（swagger JSON）。
- en: 'The following screenshot shows the list of controller-exposing services. When
    we click on any controller, it expands to show the list of request methods and
    URIs each controller supports:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了暴露控制器的服务列表。当我们点击任何控制器时，它会展开以显示每个控制器支持的请求方法和 URI：
- en: '![Swagger UI](img/02_03.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![Swagger UI](img/02_03.jpg)'
- en: 'The following screenshot shows the details for the POST service to create a
    `todo` for the user in Swagger UI:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了在 Swagger UI 中创建用户 `todo` 的 POST 服务的详细信息：
- en: '![Swagger UI](img/02_04.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![Swagger UI](img/02_04.jpg)'
- en: 'Some important things to note are as follows:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些需要注意的重要事项：
- en: '`Parameters` show all the important parameters including the request body'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Parameters` 显示了所有重要的参数，包括请求体'
- en: The `Parameter Type` body (for the `todo` parameter) shows the expected structure
    for the body of the request
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Parameter Type` 主体（对于 `todo` 参数）显示了请求主体的预期结构'
- en: The `Response Messages` sections show different HTTP status codes returned by
    the service
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Response Messages` 部分显示了服务返回的不同 HTTP 状态码'
- en: The Swagger UI provides an excellent way to expose service definitions for your
    API without a lot of additional effort.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Swagger UI 提供了一种无需额外努力即可公开 API 服务定义的出色方式。
- en: Customizing Swagger Documentation Using Annotations
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用注解自定义 Swagger 文档
- en: The Swagger UI also provides annotations to further customize your documentation.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: Swagger UI 还提供了注解来进一步自定义你的文档。
- en: 'Listed here is some of the documentation to retrieve the `todos` service:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这里列出了检索 `todos` 服务的部分文档：
- en: '[PRE22]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'As you can see, the documentation generated is very raw. There are a number
    of things we can improve in the documentation to describe the services better.
    Here are a couple of examples:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，生成的文档非常原始。我们可以在文档中改进许多地方来更好地描述服务。以下是一些示例：
- en: Provide a better summary
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供更好的摘要
- en: Add application/JSON to produces
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 application/JSON 添加到 produces
- en: 'Swagger provides annotations we can add to our RESTful services in order to
    customize the documentation. Let''s add a few annotations to the controller in
    order to improve the documentation:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: Swagger 提供了我们可以添加到我们的 RESTful 服务中以自定义文档的注解。让我们添加一些注解到控制器中，以改进文档：
- en: '[PRE23]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'A few important points to note are as follows:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些需要注意的重要点：
- en: '`@ApiOperation(value = "Retrieve all todos for a user by passing in his name")`:
    Produced in the documentation as a summary of the service'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@ApiOperation(value = "通过传递用户的名字检索所有待办事项")`: 在文档中作为服务的摘要生成'
- en: '`notes = "A list of matching todos is returned. Current pagination is not supported."`:
    Produced in the documentation as a description of the service'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`notes = "返回匹配的待办事项列表。当前不支持分页。"`: 在文档中作为服务的描述生成'
- en: '`produces = "application/json"`: Customizes the `produces` section of the service
    documentation'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`produces = "application/json"`: 自定义服务文档的 `produces` 部分'
- en: 'Here is an extract of the documentation after the update:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 更新后的文档摘录如下：
- en: '[PRE24]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Swagger provides a lot of other annotations to customize the documentation.
    Listed here are some of the important annotations:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: Swagger 提供了许多其他注解来自定义文档。以下是一些重要的注解：
- en: '`@Api`: Marks a class as a Swagger resource'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Api`: 将类标记为 Swagger 资源'
- en: '`@ApiModel`: Provides additional information about Swagger models'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@ApiModel`: 为 Swagger 模型提供更多信息'
- en: '`@ApiModelProperty`: Adds and manipulates the data of a model property'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@ApiModelProperty`: 添加并操作模型属性的数据'
- en: '`@ApiOperation`: Describes an operation or an HTTP method against a specific
    path'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@ApiOperation`: 描述对特定路径的操作或 HTTP 方法'
- en: '`@ApiParam`: Adds additional metadata for operation parameters'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@ApiParam`: 为操作参数添加额外的元数据'
- en: '`@ApiResponse`: Describes an example response of an operation'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@ApiResponse`: 描述操作的示例响应'
- en: '`@ApiResponses`: A wrapper to allow a list of multiple `ApiResponse` objects.'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@ApiResponses`: 一个包装器，允许列出多个 `ApiResponse` 对象。'
- en: '`@Authorization`: Declares an authorization scheme to be used on a resource
    or an operation'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Authorization`: 声明在资源或操作上使用的授权方案'
- en: '`@AuthorizationScope`: Describes an OAuth 2 authorization scope'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@AuthorizationScope`: 描述 OAuth 2 授权范围'
- en: '`@ResponseHeader`: Represents a header that can be provided as part of the
    response'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@ResponseHeader`: 表示可以作为响应的一部分提供的头'
- en: 'Swagger provides a few Swagger definition annotations that can be used to customize
    high-level information about a group of services--contacts, licensing, and other
    general information. Listed here are some of the important ones:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: Swagger 提供了一些 Swagger 定义注解，可以用来自定义一组服务的高级信息--联系人、许可和其他一般信息。以下列出了一些重要的注解：
- en: '`@SwaggerDefinition`: Definition-level properties to be added to the generated
    Swagger definition'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@SwaggerDefinition`: 要添加到生成的 Swagger 定义中的定义级属性'
- en: '`@Info`: General metadata for a Swagger definition'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Info`: Swagger 定义的一般元数据'
- en: '`@Contact`: Properties to describe the person to be contacted for a Swagger
    definition'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Contact`: 用于描述 Swagger 定义中要联系的人的属性'
- en: '`@License`: Properties to describe the license for a Swagger definition'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@License`: 用于描述 Swagger 定义许可的属性'
- en: Securing REST Services with Spring Security
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Spring Security 保护 REST 服务
- en: All the services we have created up until now are unsecured. A consumer does
    not need to provide any credentials to access these services. However, all services
    in the real world are usually secured.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们到目前为止创建的所有服务都是未受保护的。消费者不需要提供任何凭证来访问这些服务。然而，现实世界中的所有服务通常都是受保护的。
- en: 'In this section, we will discuss two ways of authenticating REST services:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论两种认证 REST 服务的方法：
- en: Basic authentication
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本认证
- en: OAuth 2.0 authentication
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OAuth 2.0 认证
- en: We will implement these two types of authentication with Spring Security.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 Spring Security 实现这两种类型的认证。
- en: Spring Boot provides a starter for Spring Security using `spring-boot-starter-security`.
    We will start with adding Spring Security starter to our `pom.xml` file.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot 使用 `spring-boot-starter-security` 提供了 Spring Security 的启动器。我们将从将
    Spring Security 启动器添加到我们的 `pom.xml` 文件开始。
- en: Adding Spring Security Starter
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加 Spring Security Starter
- en: 'Add the following dependency to your file `pom.xml`:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下依赖项添加到您的 `pom.xml` 文件中：
- en: '[PRE25]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `Spring-boot-starter-security` dependency brings in three important Spring
    Security dependencies:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '`Spring-boot-starter-security` 依赖项引入了三个重要的 Spring Security 依赖项：'
- en: '`spring-security-config`'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spring-security-config`'
- en: '`spring-security-core`'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spring-security-core`'
- en: '`spring-security-web`'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spring-security-web`'
- en: Basic Authentication
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本认证
- en: The `Spring-boot-starter-security` dependency also auto-configures basic authentication
    for all services by default.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`Spring-boot-starter-security` 依赖项默认情况下也会自动为所有服务配置基本认证。'
- en: If we try to access any of the services now, we would get `"Access Denied"`.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在尝试访问任何服务，我们会得到 `"访问被拒绝"`。
- en: 'The response when we send a request to `http://localhost:8080/users/Jack/todos`
    is shown as an example in the following code snippet:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码片段中，以示例的形式展示了向 `http://localhost:8080/users/Jack/todos` 发送请求时的响应：
- en: '[PRE26]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The response status is `401 - Unauthorized`.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 响应状态是 `401 - 未授权`。
- en: When a resource is secured with basic authentication, we would need to send
    a user ID and password to authenticate our request. Since we did not configure
    a user ID and password, Spring Boot auto-configures a default user ID and password.
    The default user ID is `user`. The default password is usually printed in the
    log.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用基本认证保护资源时，我们需要发送用户 ID 和密码来认证我们的请求。由于我们没有配置用户 ID 和密码，Spring Boot 会自动配置默认的用户
    ID 和密码。默认用户 ID 是 `user`。默认密码通常会在日志中打印出来。
- en: 'An example is shown in the following code snippet:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段展示了示例：
- en: '[PRE27]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Underlined in the preceding code snippet is the default security password printed
    in the log.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，下划线表示日志中打印的默认安全密码。
- en: 'We can use Postman to fire a request with basic authentication. The following
    screenshot shows how basic authentication details can be sent along with a request:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 Postman 发送带有基本认证的请求。以下截图显示了如何将基本认证详情与请求一起发送：
- en: '![Basic Authentication](img/02_05.jpg)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![基本认证](img/02_05.jpg)'
- en: As you can see, authentication succeeds and we get a proper response back.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，认证成功，我们得到了适当的响应。
- en: 'We can configure the user ID and password of our choice in `application.properties`,
    as shown here:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在 `application.properties` 中配置我们选择的用户 ID 和密码，如下所示：
- en: '[PRE28]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Spring Security also provides options to authenticate with LDAP or JDBC or any
    other data source with user credentials.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Security 还提供了使用 LDAP、JDBC 或任何其他数据源和用户凭证进行认证的选项。
- en: Integration Testing
  id: totrans-245
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The integration test we wrote for the service earlier will start failing because
    of invalid credentials. We will now update the integration test to supply basic
    authentication credentials:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Some important things to note are as follows:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '`createHeaders("user-name", "user-password")`: This method creates `Base64\.
    getEncoder().encode` basic authentication headers'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '`ResponseEntity<String> response = template.exchange(createUrl("/users/Jack/todos"),
    ;HttpMethod.GET,new HttpEntity<String>(null, headers), String.class)`: The key
    change is the use of `HttpEntity` to supply the headers that we created earlier
    to the REST template'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: Unit Testing
  id: totrans-251
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We would not want to use security for our unit tests. The following code snippet
    shows how we can disable security for the unit test:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The key part is the `secure = false` parameter on the `WebMvcTest` annotation.
    This will disable Spring Security for the unit test.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: OAuth 2 Authentication
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: OAuth is a protocol that provides flows in order to exchange authorization and
    authentication information between a range of web-enabled applications and services.
    It enables third-party applications to get restricted access to user information
    from a service, for example, Facebook, Twitter, or GitHub.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: Before we get into the details, it would be useful to review the terminology
    typically used with respect to OAuth 2 authentication.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: Let's consider an example. Let's say we want to expose the `Todo` API to third-party
    applications on the internet.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the important players in a typical OAuth 2 exchange:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: '**Resource owner**: This is the user of the third-party application that wants
    to use our Todo API. It decides how much of the information available with our
    API can be made available to the third-party application.'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Resource server**: This hosts the Todo API, the resource we want to secure.'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Client**: This is the third-party application that wants to consume our API.'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Authorization server**: This is the server that provides the OAuth service.'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: High-level flow
  id: totrans-264
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following steps show a; high-level flow of a typical OAuth authentication:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: The application requests that the user authorizes access to API resources.
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the user provides access, the application receives an authorization grant.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The application provides user authorization grant and its own client credentials
    to the authorization server.
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the authentication is successful, the authorization server responds with
    an access token.
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The application calls the API (the resource server) that provides the access
    token for authentication.
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the access token is valid, the resource server returns the details of the
    resource.
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implementing OAuth 2 authentication for Our Service
  id: totrans-272
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'OAuth 2 for Spring Security (`spring-security-oauth2`) is the module to provide
    OAuth 2 support to Spring Security. We will add it as a dependency in our `pom.xml`
    file:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Setting up Authorization and Resource Servers:'
  id: totrans-275
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note
  id: totrans-276
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `spring-security-oauth2` has not yet been (June 2017) been updated with
    the changes for Spring Framework 5.x and Spring Boot 2.x. We will use Spring Boot
    1.5.x for examples related to OAuth 2 authentication. Code examples are here in
    the GitHub repository: [https://github.com/PacktPublishing/Mastering-Spring-5.0](https://github.com/PacktPublishing/Mastering-Spring-5.0).'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: Typically, an authorization server would be a different server from the application
    where the API is exposed. To keep things simple, we will make our current API
    server act both as the resource server and as the authorization server.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet shows how we can enable our application to act as
    the resource and authorization server:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Here are a couple of important things to note:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: '`@EnableResourceServer`: A convenient annotation for OAuth 2 resource servers,
    enabling a Spring Security filter that authenticates requests via an incoming
    OAuth 2 token'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: '`@EnableAuthorizationServer`: A convenience annotation to enable an authorization
    server with; `AuthorizationEndpoint` and; `TokenEndpoint` in the current application
    context, which must be a `DispatcherServlet` context'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can configure the access details in `application.properties`, as shown
    in the following code snippet:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'A few important details are as follows:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: '`security.user.name` and `security.user.password` are the authentication details
    of the resource owner that is an end user of a third-party application'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: '`security.oauth2.client.clientId` and `security.oauth2.client.clientSecret`
    are the authentication details of the client that is the third-party application
    (the service consumer)'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: Executing OAuth Requests
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We need a two-step process to access the APIs:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: Obtain an access token.
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Execute the request using the access token.
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Obtaining an Access Token
  id: totrans-293
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To get an access token, we call the authorization server (`http://localhost:8080/oauth/token`),
    providing the client authentication details in the basic authentication mode and
    the user credentials as part of the form data. The following screenshot shows
    how we can configure the client authentication details in basic authentication:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: '![Obtaining an Access Token](img/02_06.jpg)'
  id: totrans-295
  prefs: []
  type: TYPE_IMG
- en: 'The following screenshot shows how to configure the user authentication details
    as part of the `POST` parameters:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: '![Obtaining an Access Token](img/02_07.jpg)'
  id: totrans-297
  prefs: []
  type: TYPE_IMG
- en: 'We are using `grant_type` as the password, indicating that we are sending the
    user authentication details to get the access token. When we execute the request,
    we get a response similar to the one shown in the following code snippet:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Here are a couple of important details:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: '`access_token`: Client application can use the access token to authenticate
    further API calls. However, the access token will expire, typically in a very
    short time period.'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`refresh_token`: Client application can submit a new request to the authentication
    server with the `refresh_token` to get a new `access_token`.'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Executing the Request Using the Access Token
  id: totrans-303
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Once we have `access_token`, we can execute the request using `access_token`,
    as shown in the following screenshot:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: '![Executing the Request Using the Access Token](img/02_08.jpg)'
  id: totrans-305
  prefs: []
  type: TYPE_IMG
- en: As you can see in the preceding screenshot, we provide the access token in the
    request header called `Authorization`. We use the value of the format `"Bearer
    {access_token}"`. Authentication succeeds and we get the expected resource details.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: Integration Test
  id: totrans-307
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We will now update our integration test to provide the OAuth 2 credentials.
    The following test highlights the important details:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Some important things to note are as follows:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: '`ResourceOwnerPasswordResourceDetails resource = new ResourceOwnerPasswordResourceDetails()`:
    We set up `ResourceOwnerPasswordResourceDetails` with the user credentials and
    the client credentials'
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`resource.setAccessTokenUri(createUrl("/oauth/token"))`: Configures the URL
    of the authentication server'
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OAuth2RestTemplate oauthTemplate = new OAuth2RestTemplate(resource,new DefaultOAuth2ClientContext())`:
    The `OAuth2RestTemplate` is an extension of `RestTemplate`, which supports the
    OAuth 2 protocol'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this section, we looked at how to enable OAuth 2 authentication in our resources.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: Internationalization
  id: totrans-315
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Internationalization** (**i18n**) is the process of developing applications
    and services so that they can be customized for different languages and cultures
    across the world. It is also called **localization**. The goal of internationalization
    or localization is to build applications that can offer content in multiple languages
    and formats.'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: Spring Boot has built-in support for internationalization.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: Let's build a simple service to understand how we can build internationalization
    in our APIs.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: 'We would need to add a `LocaleResolver` and a message source to our Spring
    Boot application. The following code snippet should be included in `Application.java`:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Some important things to note are as follows:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: '`sessionLocaleResolver.setDefaultLocale(Locale.US)`: We are a setting a default
    locale of `Locale.US`.'
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`messageSource.setBasenames("messages")`: We''re setting the base name of the
    message source as `messages`. If we are in fr locale (France), we would use messages
    from `message_fr.properties`. If a message is not available in `message_fr.properties`,
    it would be searched for in the default `message.properties`.'
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`messageSource.setUseCodeAsDefaultMessage(true)`: If a message is not found,
    then the code is returned as the default message.'
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s configure the messages in the respective files. Let''s start with the
    `messages` properties. The messages in this file would act as the defaults:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Let''s also configure `messages_fr.properties`. The messages in this file would
    be used for the locale. If a message is not present here, then the defaults from
    `messages.properties` will be used:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Let''s create a service that returns a specific message using the locale specified
    in the `"Accept-Language"` header:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Here are a couple of things to note:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: '`@RequestHeader(value = "Accept-Language", required = false) Locale locale`:
    The locale is picked up from the request header `Accept-Language`. It is not required.
    If a locale is not specified, the default locale is used.'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: '`messageSource.getMessage("welcome.message", null, locale)`: `messageSource`
    is autowired into the controller. We get the welcome message based on the given
    locale.'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the response when the preceding service is called
    without specifying a default `Accept-Language`:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: '![Internationalization](img/02_09.jpg)'
  id: totrans-335
  prefs: []
  type: TYPE_IMG
- en: The default message from `messages.properties` is returned.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the response when the preceding service is called
    with `Accept-Language fr`:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: '![Internationalization](img/02_10.jpg)'
  id: totrans-338
  prefs: []
  type: TYPE_IMG
- en: The localized message from `messages_fr.properties` is returned.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, we customized the service to return localized messages
    based on the locale in the request. A similar approach can be used to internationalize
    all services in a component.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: Caching
  id: totrans-341
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Caching data from services plays a crucial role in improving the performance
    and scalability of applications. In this section, we will look at the implementation
    options that Spring Boot provides.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: Spring provides a caching abstraction based on annotations. We will start with
    using Spring caching annotations. Later, we will introduce **JSR-107** caching
    annotations and compare them with Spring abstractions.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: Spring-boot-starter-cache
  id: totrans-344
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Spring Boot provides a starter project for caching `spring-boot-starter-cache`.
    Adding this to an application brings in all the dependencies to enable **JSR-107**
    and Spring caching annotations. The following code snippet shows the dependency
    details for `spring-boot-starter-cache`. Let''s add this to our file `pom.xml`:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Enabling Caching
  id: totrans-347
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we can start using caching, we need to enable caching on the application.
    The following code snippet shows how we can enable caching:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '`@EnableCaching` would enable caching in a Spring Boot application.'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: Spring Boot automatically configures a suitable CacheManager framework to serve
    as a provider for the relevant cache. We will look at the details of how Spring
    Boot decides the CacheManager a little later.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: Caching Data
  id: totrans-352
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have enabled caching, we can add the `@Cacheable` annotation to
    the methods where we want to cache the data. The following code snippet shows
    how to enable caching on `retrieveTodos`:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: In the preceding example, the `todos` for a specific user are cached. On the
    first call to the method for a specific user, the `todos` will be retrieved from
    the service. On subsequent calls for the same user, the data will be returned
    from the cache.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: 'Spring also provides conditional caching. In the following snippet, caching
    is enabled only if the specified condition is satisfied:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Spring also provides additional annotations to evict data from the cache and
    add some custom data to cache. A few important ones are listed as follows:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: '`@CachePut`: Used to explicitly add data to the cache'
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@CacheEvict`: Used to remove stale data from the cache'
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@Caching`: Allows multiple nested `@Cacheable`, `@CachePut`, and `@CacheEvict`
    annotations to be used on the same method'
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JSR-107 Caching Annotations
  id: totrans-362
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**JSR-107** aims to standardize caching annotations. Listed here are some of
    the important **JSR-107** annotations:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: '`@CacheResult`: Similar to `@Cacheable`'
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@CacheRemove`: Similar to `@CacheEvict` `@CacheRemove` supports conditional
    eviction if an exception occurs'
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@CacheRemoveAll`: Similar to `@CacheEvict(allEntries=true)`; used to remove
    all entries from the cache'
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**JSR-107** and Spring''s caching annotations are fairly similar in terms of
    the features they offer. Either of them is a good choice. We lean slightly toward
    **JSR-107** because it''s a standard. However, make sure you are not using both
    in the same project.'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: Auto-Detection Order
  id: totrans-368
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When caching is enabled, Spring Boot auto-configuration starts looking for
    a caching provider. The following list shows the order in which Spring Boot searches
    for caching providers. The list is in order of decreasing preference:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: JCache (**JSR-107**) (EhCache 3, Hazelcast, Infinispan, and so on)
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: EhCache 2.x
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hazelcast
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Infinispan     Couchbase'
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Redis
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Caffeine
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Guava
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simple
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  id: totrans-378
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring Boot makes developing Spring-based applications easy. It enables us to
    create production-ready applications very quickly.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: In this lesson, we covered how to add features such as exception handling, caching,
    and internationalization to our application. We discussed the best practices of
    documenting REST services using Swagger. We looked at the basics of securing our
    microservice with Spring Security.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: In the next lesson, we will shift our attention toward advanced features in
    Spring Boot. We will look at how to provide monitoring on top of our REST services,
    learn how to deploy the microservice to the Cloud, and understand how to become
    more productive when developing applications with Spring Boot.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: Assessments
  id: totrans-382
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The _________ provides a number of annotations that can be used to validate
    beans.
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which of the following is an annotated element size that must be within the
    specified boundaries?
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`@SizeOf`'
  id: totrans-385
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`@SizeBoundary`'
  id: totrans-386
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`@SizeTo`'
  id: totrans-387
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`@Size`'
  id: totrans-388
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'State whether True or False: HATEOAS is one of the key features of the REST
    application architecture.'
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which of the following is a simple builder class to configure the generation
    of Swagger documentation using the Swagger Spring MVC framework?
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Docket
  id: totrans-391
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Swagger
  id: totrans-392
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: REST
  id: totrans-393
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: QAuth
  id: totrans-394
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which of the following is a convenient annotation for OAuth 2 resource servers
    that enable a Spring Security filter which authenticates requests via an incoming
    OAuth 2 token?
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`@enableResourceServer`'
  id: totrans-396
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`@enablesResourcesServer`'
  id: totrans-397
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`@EnableResourceServer`'
  id: totrans-398
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`@EnableResourceServers`'
  id: totrans-399
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
