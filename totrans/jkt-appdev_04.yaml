- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JSON Processing and JSON Binding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**JavaScript Object Notation** (**JSON**) is a human-readable data interchange
    format. As its name implies, JSON is derived from JavaScript. Jakarta EE provides
    support for two different APIs for JSON manipulation, namely **Jakarta JSON Processing**,
    which is a lower-level API allowing fine-grained control, and **Jakarta JSON Binding**,
    which is a higher-level API that allows us to easily populate Java objects from
    JSON data, as well as quickly generate JSON-formatted data from Java objects.
    In this chapter, we will cover both JSON Processing and JSON Binding.'
  prefs: []
  type: TYPE_NORMAL
- en: 'JSON Processing includes two APIs for processing JSON: the **Model API** and
    the **Streaming API**. Both of these APIs will be covered in this chapter. JSON
    Binding transparently populates Java objects from JSON strings, as well as easily
    generates JSON strings from Java objects.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Jakarta JSON Processing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Jakarta JSON binding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Example source code for this chapter can be found on GitHub at [https://github.com/PacktPublishing/Jakarta-EE-Application-Development/tree/main/ch04_src](https://github.com/PacktPublishing/Jakarta-EE-Application-Development/tree/main/ch04_src).
  prefs: []
  type: TYPE_NORMAL
- en: Jakarta JSON Processing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the following sections, we will discuss how to process JSON data using the
    two APIs provided by Jakarta JSON Processing, namely the Model and Streaming APIs.
    We will also discuss how to retrieve values from JSON data using JSON Pointer,
    as well as how to partially modify JSON data via JSON Patch.
  prefs: []
  type: TYPE_NORMAL
- en: The JSON Processing Model API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The JSON Processing Model API allows us to generate an in-memory representation
    of a JSON object. This API is more flexible than the Streaming API discussed later
    in this chapter. However, it is slower and requires more memory, which can be
    a concern when handling large volumes of data.
  prefs: []
  type: TYPE_NORMAL
- en: Generating JSON data with the Model API
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At the heart of the JSON Processing Model API is the `JsonObjectBuilder` class.
    This class has several overloaded `add()` methods that can be used to add properties
    and their corresponding values to the generated JSON data.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code sample illustrates how to generate JSON data using the Model
    API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As can be seen in the example, we generate an instance of `JsonObject` by invoking
    the `add()` method on an instance of `JsonObjectBuilder`. In our example, we see
    how we can add `String` values to our `JsonObject` by invoking the `add()` method
    on `JsonObjectBuilder`. The first parameter of the `add()` method is the property
    name of the generated JSON object, and the second parameter corresponds to the
    value of the said property. The return value of the `add()` method is another
    instance of `JsonObjectBuilder`; therefore, invocations to the `add()` method
    can be chained as shown in the example.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The preceding example is a RESTful web service corresponding to a larger Jakarta
    RESTful Web Services application. Other parts of the application are not shown
    since they are not relevant to the discussion. The complete sample application
    can be obtained from this book’s GitHub repository at [https://github.com/PacktPublishing/Jakarta-EE-Application-Development](https://github.com/PacktPublishing/Jakarta-EE-Application-Development).
  prefs: []
  type: TYPE_NORMAL
- en: Once we have added all the desired properties, we need to invoke the `build()`
    method of `JsonObjectBuilder`, which returns an instance of a class implementing
    the `JsonObject` interface.
  prefs: []
  type: TYPE_NORMAL
- en: In many cases, we will want to generate a `String` representation of the JSON
    object we created, so that it can be processed by another process or service.
    We can do this by creating an instance of a class implementing the `JsonWriter`
    interface, by invoking the static `createWriter()` method of the `Json` class,
    passing an instance of `StringWriter` as its sole parameter. Once we have an instance
    of the `JsonWriter` implementation, we need to invoke its `writeObject()` method,
    passing our `JsonObject` instance as its sole parameter.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, our `StringWriter` instance will have the `String` representation
    of our JSON object as its value, so invoking its `toString()` method will return
    a `String` containing our JSON object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our specific example will generate a JSON string that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Although in our example we added only `String` objects to our JSON object, we
    are not limited to this type of value; `JsonObjectBuilder` has several overloaded
    versions of its `add()` method, allowing us to add several different types of
    values to our JSON objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table summarizes all of the available versions of the `add()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **JsonObjectBuilder.add() method** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `add(String name,` `BigDecimal value)` | Adds a `BigDecimal` value to our
    JSON object. |'
  prefs: []
  type: TYPE_TB
- en: '| `add(String name,` `BigInteger value)` | Adds a `BigInteger` value to our
    JSON object. |'
  prefs: []
  type: TYPE_TB
- en: '| `add(String name,` `JsonArrayBuilder value)` | Adds an array to our JSON
    object. A `JsonArrayBuilder` implementation allows us to create JSON arrays. |'
  prefs: []
  type: TYPE_TB
- en: '| `add(String name,` `JsonObjectBuilder value)` | Adds another JSON object
    to our original JSON object (property values for JSON objects can be other JSON
    objects). The added `JsonObject` implementation is built from the provided `JsonObjectBuilder`
    parameter. |'
  prefs: []
  type: TYPE_TB
- en: '| `add(String name,` `JsonValue value)` | Adds another JSON object to our original
    JSON object (property values for JSON objects can be other JSON objects). |'
  prefs: []
  type: TYPE_TB
- en: '| `add(String name,` `String value)` | Adds a `String` value to our JSON object.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `add(String name,` `boolean value)` | Adds a `boolean` value to our JSON
    object. |'
  prefs: []
  type: TYPE_TB
- en: '| `add(String name,` `double value)` | Adds a `double` value to our JSON object.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `add(String name,` `int value)` | Adds an `int` value to our JSON object.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `add(String name,` `long value)` | Adds a `long` value to our JSON object.
    |'
  prefs: []
  type: TYPE_TB
- en: Table 4.1 – JsonObjectBuilder add() methods
  prefs: []
  type: TYPE_NORMAL
- en: In all cases, the first parameter of the `add()` method corresponds to the name
    of the property in our JSON object, and the second parameter corresponds to the
    value of the property.
  prefs: []
  type: TYPE_NORMAL
- en: Parsing JSON data with the Model API
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the last section, we saw how to generate JSON data from our Java code with
    the object model API. In this section, we will see how we can read and parse existing
    JSON data. The following code sample illustrates how to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: To parse an existing JSON string, we need to create a `StringReader` object,
    passing the `String` object containing the JSON to be parsed as a parameter. We
    then pass the resulting `StringReader` instance to the static `createReader()`
    method of the `Json` class. This method invocation will return an instance of
    `JsonReader`. We can then obtain an instance of `JsonObject` by invoking the `readObject()`
    method on it.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we use the `getString()` method to obtain the values for all
    properties in our JSON object. The first and only argument for this method is
    the name of the property we wish to retrieve; unsurprisingly, the return value
    is the value of the property.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to the `getString()` method, there are several other similar methods
    to obtain values of other types. The following table summarizes these methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `JsonObject method` | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `get(Object key)` | Retrieves an instance of a class implementing the `JsonValue`
    interface |'
  prefs: []
  type: TYPE_TB
- en: '| `getBoolean(String name)` | Retrieves a `boolean` value corresponding to
    the given key |'
  prefs: []
  type: TYPE_TB
- en: '| `getInt(String name)` | Retrieves an `int` value corresponding to the given
    key |'
  prefs: []
  type: TYPE_TB
- en: '| `getJsonArray(String name)` | Retrieves the instance of a class implementing
    the `JsonArray` interface corresponding to the given key |'
  prefs: []
  type: TYPE_TB
- en: '| `getJsonNumber(String name)` | Retrieves the instance of a class implementing
    the `JsonNumber` interface corresponding to the given key |'
  prefs: []
  type: TYPE_TB
- en: '| `getJsonObject(String name)` | Retrieves the instance of a class implementing
    the `JsonObject` interface corresponding to the given key |'
  prefs: []
  type: TYPE_TB
- en: '| `getJsonString(String name)` | Retrieves the instance of a class implementing
    the `JsonString` interface corresponding to the given key |'
  prefs: []
  type: TYPE_TB
- en: '| `getString(String Name)` | Retrieves a `String` corresponding to the given
    key |'
  prefs: []
  type: TYPE_TB
- en: Table 4.2 – JsonObject methods to retrieve values from JSON data
  prefs: []
  type: TYPE_NORMAL
- en: In all cases, the `String` parameter of the method corresponds to the key name,
    and the return value is the JSON property value we wish to retrieve.
  prefs: []
  type: TYPE_NORMAL
- en: The JSON Processing Streaming API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The JSON Processing Streaming API allows sequential reading of a JSON object
    from a stream (a subclass of `java.io.OutputStream` or a subclass of `java.io.Writer`).
    It is faster and more memory efficient than the Model API; however, the trade-off
    is that it is less straightforward to access specific JSON properties directly
    when compared to the Model API. When using the Streaming API, we need to use JSON
    Pointer and JSON Patch to retrieve or modify specific values from JSON data.
  prefs: []
  type: TYPE_NORMAL
- en: Generating JSON data with the streaming API
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The JSON Streaming API has a `JsonGenerator` class we can use to generate JSON
    data and write it to a stream. This class has several overloaded `write()` methods
    that can be used to add properties and their corresponding values to the generated
    JSON data.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code sample illustrates how to generate JSON data using the Streaming
    API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We create an instance of `JsonGenerator` by invoking the `createGenerator()`
    static method of the `Json` class. The JSON Processing API provides two overloaded
    versions of this method; one takes an instance of a class that extends `java.io.Writer`
    (such as `StringWriter`, which we used in our example), and the other one takes
    an instance of a class that extends `java.io.OutputStream`.
  prefs: []
  type: TYPE_NORMAL
- en: Before we can start adding properties to the generated JSON stream, we need
    to invoke the `writeStartObject()` method on `JsonGenerator`. This method writes
    the JSON start object character (represented by an opening curly brace ( { ) in
    JSON strings) and returns another instance of `JsonGenerator`, allowing us to
    chain `write()` invocations to add properties to our JSON stream.
  prefs: []
  type: TYPE_NORMAL
- en: The `write()` method on `JsonGenerator` allows us to add properties to the JSON
    stream we are generating; its first parameter is a `String` corresponding to the
    name of the property we are adding, and the second parameter is the value of the
    property.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our example, we are adding only `String` values to the JSON stream we are
    creating. However, we are not limited to strings; the Streaming API provides several
    overloaded `write()` methods that allow us to add several different types of data
    to our JSON stream. The following table summarizes all of the available versions
    of the `write()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `JsonGenerator.write() method` | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `write(String name,` `BigDecimal value)` | Writes a `BigDecimal` value to
    our JSON stream |'
  prefs: []
  type: TYPE_TB
- en: '| `write(String name,` `BigInteger value)` | Writes a `BigInteger` value to
    our JSON stream |'
  prefs: []
  type: TYPE_TB
- en: '| `write(String name,` `JsonValue value)` | Writes a JSON object to our JSON
    stream (property values for JSON streams can be other JSON objects) |'
  prefs: []
  type: TYPE_TB
- en: '| `write(String name,` `String value)` | Writes a `String` value to our JSON
    stream |'
  prefs: []
  type: TYPE_TB
- en: '| `write(String name,` `boolean value)` | Writes a `boolean` value to our JSON
    stream |'
  prefs: []
  type: TYPE_TB
- en: '| `write(String name,` `double value)` | Writes a `double` value to our JSON
    stream |'
  prefs: []
  type: TYPE_TB
- en: '| `write(String name,` `int value)` | Writes an `int` value to our JSON stream
    |'
  prefs: []
  type: TYPE_TB
- en: '| `write(String name,` `long value)` | Writes a `long` value to our JSON stream
    |'
  prefs: []
  type: TYPE_TB
- en: Table 4.3 – JsonGenerator write() method
  prefs: []
  type: TYPE_NORMAL
- en: In all cases, the first parameter of the `write()` method corresponds to the
    name of the property we are adding to our JSON stream, and the second parameter
    corresponds to the value of the property.
  prefs: []
  type: TYPE_NORMAL
- en: Once we are done adding properties to our JSON stream, we need to invoke the
    `writeEnd()` method on `JsonGenerator`; this method adds the JSON end object character
    (represented by a closing curly brace ( } ) in JSON strings).
  prefs: []
  type: TYPE_NORMAL
- en: At this point, our stream or reader is populated with the JSON data we generated.
    What we do with it depends on our application logic. In our example, we simply
    invoked the `toString()` method of our `StringReader` to obtain the `String` representation
    of the JSON data we created.
  prefs: []
  type: TYPE_NORMAL
- en: Parsing JSON data with the streaming API
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this section, we will cover how to parse JSON data we receive from a stream.
  prefs: []
  type: TYPE_NORMAL
- en: The following example illustrates how we can populate Java objects from JSON
    data using the streaming API.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The first thing we need to do to read JSON data using the Streaming API is
    to create an instance of `JsonParser` by invoking the static `createJsonParser()`
    method on the `Json` class. There are two overloaded versions of the `createJsonParser()`
    method: one takes an instance of a class that extends `java.io.InputStream`, and
    the other one takes an instance of a class that extends `java.io.Reader`. In our
    example, we use the latter, passing an instance of `java.io.StringReader`, which
    is a subclass of `java.io.Reader`.'
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to loop through the JSON data to obtain the data to be parsed.
    We can achieve this by invoking the `hasNext()` method on `JsonParser`, which
    returns true if there is more data to be read, and false otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: We then need to read the next piece of data in our stream, the `JsonParser.next()`
    method returns an instance of `JsonParser.Event` that indicates the type of data
    that we just read. In our example, we check only for key names (i.e., `firstName`,
    `lastName`, and `email`), and the corresponding string values. We check for the
    type of data we just read by comparing the event returned by `JsonParser.next()`
    against several values defined in `JsonParser.Event`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table summarizes all of the possible events that can be returned
    from `JsonParser.next()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `JsonParser Event` | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `Event.START_OBJECT` | Indicates the start of a JSON object |'
  prefs: []
  type: TYPE_TB
- en: '| `Event.END_OBJECT` | Indicates the end of a JSON object |'
  prefs: []
  type: TYPE_TB
- en: '| `Event.START_ARRAY` | Indicates the start of an array |'
  prefs: []
  type: TYPE_TB
- en: '| `Event.END_ARRAY` | Indicates the end of an array |'
  prefs: []
  type: TYPE_TB
- en: '| `Event.KEY_NAME` | Indicates the name of a JSON property was read; we can
    obtain the key name by invoking `getString()` on `JsonParser` |'
  prefs: []
  type: TYPE_TB
- en: '| `Event.VALUE_TRUE` | Indicates that a Boolean value of `true` was read |'
  prefs: []
  type: TYPE_TB
- en: '| `Event.VALUE_FALSE` | Indicates that a Boolean value of `false` was read
    |'
  prefs: []
  type: TYPE_TB
- en: '| `Event.VALUE_NULL` | Indicates that a null value was read |'
  prefs: []
  type: TYPE_TB
- en: '| `Event.VALUE_NUMBER` | Indicates that a numeric value was read |'
  prefs: []
  type: TYPE_TB
- en: '| `Event.VALUE_STRING` | Indicates that a string value was read |'
  prefs: []
  type: TYPE_TB
- en: Table 4.4 – JsonParser events
  prefs: []
  type: TYPE_NORMAL
- en: 'As shown in the example, `String` values can be retrieved by invoking `getString()`
    on `JsonParser`. Numeric values can be retrieved in several different formats.
    The following table summarizes the methods in `JsonParser` that can be used to
    retrieve numeric values:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `JsonParser method` | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `getInt()` | Retrieves the numeric value as an `int` |'
  prefs: []
  type: TYPE_TB
- en: '| `getLong()` | Retrieves the numeric value as a `long` |'
  prefs: []
  type: TYPE_TB
- en: '| `getBigDecimal()` | Retrieves the numeric value as an instance of `java.math.BigDecimal`
    |'
  prefs: []
  type: TYPE_TB
- en: Table 4.5 – JsonParser methods used to retrieve numeric values
  prefs: []
  type: TYPE_NORMAL
- en: '`JsonParser` also provides a convenient `isIntegralNumber()` method that returns
    `true` if the numeric value can be safely cast to an `int` or `long`.'
  prefs: []
  type: TYPE_NORMAL
- en: What we do with the values we obtain from the stream depends on our application
    logic; in our example, we place them in a `Map` and then use said `Map` to populate
    a Java class.
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving values from data with JSON Pointer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Jakarta JSON Processing supports JSON Pointer, an **Internet Engineering Task
    Force** (**IETF**) standard that defines a string syntax for identifying a specific
    value within a JSON document, similar to what XPath provides for XML documents.
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax for JSON Pointer is straightforward. For example, let us suppose
    that we have the following JSON document:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: If we would like to obtain the value of the `lastName` property of the document,
    the JSON Pointer expression to use would be `"/lastName"`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If our JSON document consisted of an array, then we would have to prefix the
    property with the index in the array; for example, say we want to obtain the `lastName`
    property of the second element in the following JSON array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The JSON Pointer expression to do so would be `"/1/lastName"`. The `"/1"` at
    the beginning of the expression refers to the element index in the array. Just
    like in Java, JSON arrays are 0 indexed; therefore, in this example, we are obtaining
    the value of the `lastName` property in the second element of the array. Let’s
    now look at an example of how we would use the JSON Pointer API to perform this
    task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code sample is a RESTful web service written using Jakarta RESTful
    Web Services. In order to read property values from a JSON document, we first
    need to create an instance of `jakarta.json.JsonReader` by invoking the static
    `createReader()` method on `jakarta.json.Json`. `createReader()`. This takes an
    instance of any class implementing the `java.io.Reader` interface as an argument.
    In our example, we are creating a new instance of `java.io.StringReader` on the
    fly and passing our JSON string as a parameter to its constructor.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: There is an overloaded version of `JSON.createReader()` that takes an instance
    of any class implementing `java.io.InputStream`.
  prefs: []
  type: TYPE_NORMAL
- en: In our example, our JSON document consists of an array of objects; therefore,
    we populate an instance of `jakarta.json.JsonArray` by invoking the `readArray()`
    method on the `JsonReader` object we created. (If our JSON document had consisted
    of a single JSON object, we would have invoked `JsonReader.readObject()` instead.)
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have populated our `JsonArray` variable, we create an instance of
    `jakarta.json.JsonPointer`, and initialize it with the JSON Pointer expression
    we want to use to obtain the value we are searching for. Recall we are looking
    for the value of the `lastName` property in the second element of the array; therefore,
    the appropriate JSON Pointer expression is `/1/lastName`.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have created an instance of `JsonPointer` with the appropriate JSON
    Pointer expression, we simply invoke its `getValue()` method, passing our `JsonArray`
    object as a parameter; then, we invoke `toString()` on the result, and the return
    value of this invocation will be the value of the `lastName` property on the JSON
    document `"Heffelfinger`, in our example).
  prefs: []
  type: TYPE_NORMAL
- en: Updating JSON data values with JSON Patch
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Jakarta JSON Processing includes support for JSON Patch, another IETF standard.
    This one provides a series of operations that can be applied to a JSON document.
    JSON Patch allows us to perform partial updates on a JSON object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following operations are supported by JSON Patch:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **JSON** **Patch Operation** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| add | Adds an element to a JSON document |'
  prefs: []
  type: TYPE_TB
- en: '| remove | Removes an element from a JSON document |'
  prefs: []
  type: TYPE_TB
- en: '| replace | Replaces a value in a JSON document with a new value |'
  prefs: []
  type: TYPE_TB
- en: '| move | Moves a value in a JSON document from its current location in the
    document to a new position |'
  prefs: []
  type: TYPE_TB
- en: '| copy | Copies a value in a JSON document to a new location in the document
    |'
  prefs: []
  type: TYPE_TB
- en: '| test | Verifies that the value in a specific location in a JSON document
    is equal to the specified value |'
  prefs: []
  type: TYPE_TB
- en: Table 4.6 – JSON Patch operations
  prefs: []
  type: TYPE_NORMAL
- en: Jakarta JSON Processing supports all of the preceding JSON Patch operations,
    which rely on JSON Pointer expressions to locate source and target locations in
    JSON documents.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example illustrates how we can use JSON Patch with Jakarta JSON
    Processing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In this example, let’s assume we are dealing with the same JSON document we
    used in our previous example, an array of two individual JSON objects, each with
    a `dateOfBirth` property (among other properties).
  prefs: []
  type: TYPE_NORMAL
- en: In our example, we create an instance of `JsonArray` as before and then modify
    the `dateOfBirth` of the second element in the array. In order to do this, we
    create an instance of `jakarta.json.JsonPatchBuilder` via the static `createPatchBuilder()`
    method in the `jakarta.json.Json` class. In our example, we are replacing the
    value of one of the properties with a new value; we use the `replace()` method
    of our `JsonPatch` instance to accomplish this. The first argument in the method
    is a JSON Pointer expression indicating the location of the property we are going
    to modify, and the second argument is the new value for the property. As its name
    implies, `JsonPatchBuilder` follows the `Builder` design pattern, meaning that
    most of its methods return another instance of `JsonPatchBuilder`; this allows
    us to chain method calls on the resulting instances of `JsonPatchBuilder` (in
    our example, we are performing only one operation, but this doesn’t have to be
    the case). Once we are done specifying the operation(s) to perform on our JSON
    object, we create an instance of `jakarta.json.JsonPatch` by invoking the `build()`
    method on `JsonPatchBuilder`.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have created the patch, we apply it to our JSON object (an instance
    of `JsonArray`, in our example) by invoking its `patch()` method and passing the
    JSON object as a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Our example shows how to replace the value of a JSON property with another via
    JSON Patch support in Jakarta JSON-Processing. All standard JSON Patch operations
    are supported by Jakarta JSONProcessing. For details on how to use other JSON
    Patch operations with JSON Processing, consult the Jakarta EE API documentation
    at [https://jakarta.ee/specifications/platform/10/apidocs/](https://jakarta.ee/specifications/platform/10/apidocs/).
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve seen how to directly manipulate JSON data with JSON Processing,
    we will focus our attention on how to bind JSON data with Jakarta JSON Binding,
    a higher-level API that allows us to do common tasks quickly and easily.
  prefs: []
  type: TYPE_NORMAL
- en: Jakarta JSON Binding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Jakarta JSON Binding is a high-level API that allows us to almost seamlessly
    populate Java objects from JSON data, as well as easily generate JSON-formatted
    data from Java objects.
  prefs: []
  type: TYPE_NORMAL
- en: Populating Java objects from JSON with JSON Binding
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A common programming task is to populate Java objects from JSON strings. It
    is such a common task that several libraries were created to transparently populate
    Java objects from JSON, freeing application developers from having to manually
    code this functionality. Several non-standard Java libraries that accomplish this
    task exist, such as Jackson ([https://github.com/FasterXML/jackson](https://github.com/FasterXML/jackson)),
    json-simple ([https://code.google.com/archive/p/json-simple/](https://code.google.com/archive/p/json-simple/)),
    or Gson ([https://github.com/google/gson](https://github.com/google/gson)). Jakarta
    EE includes a standard API providing this functionality, namely JSON Binding.
    In this section, we will cover how to transparently populate a Java object from
    a JSON string.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows a RESTful web service written using Jakarta RESTful
    Web Services. The service responds to HTTP POST requests in its `addCustomer()`
    method. The `addCustomer()` method takes a `String` as a parameter; it is expected
    for this string to contain valid JSON:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The JSON Binding implementation provided by our application server provides
    an instance of a class implementing the `JsonbBuilder` interface; this class provides
    a static `create()` method that we can use to obtain an instance of `Jsonb`.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have an instance of `Jsonb`, we can use it to parse a JSON string and
    automatically populate a Java object. This is done via its `fromJson()` method.
    The `fromJson()` method takes a `String` containing the JSON data we need to parse
    as its first parameter and the type of object we wish to populate as its second
    parameter. In our example, we are populating a simple `Customer` class containing
    fields such as `firstName`, `middleName`, `lastName`, and `dateOfBirth`. Jakarta
    JSON Binding will look for JSON property names matching the property names in
    the Java object, and automatically populate the Java object with the corresponding
    JSON properties. It couldn’t get more simple than that!
  prefs: []
  type: TYPE_NORMAL
- en: Once we have populated our Java object, we can do whatever we need to do with
    it. In our example, we simply return a `String` representation of our `Customer`
    object to the client.
  prefs: []
  type: TYPE_NORMAL
- en: Generating JSON data from Java objects with JSON Binding
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In addition to populating Java objects from JSON data, JSON Binding can also
    generate JSON strings from Java objects. The following example illustrates how
    to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we are generating JSON data from a `Customer` object.
  prefs: []
  type: TYPE_NORMAL
- en: Just like before, we create an instance of `jakarta.json.bind.Jsonb` by invoking
    the static `jakarta.json.bind.JsonbBuilder.create()` method. Once we have our
    `Jsonb` instance, we simply invoke its `toJson()` method to convert the list of
    objects to its equivalent JSON representation.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered how to process JSON data using two Jakarta EE APIs,
    JSON Processing and JSON Binding.
  prefs: []
  type: TYPE_NORMAL
- en: 'We covered the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: We saw how we can generate and parse JSON data with JSON Processing’s model
    API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We also explored how to generate and parse JSON data with JSON Processing’s
    streaming API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additionally, we covered how to extract values from JSON data with JSON Pointer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Also, we saw how to update specific values in JSON data with JSON Patch
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we covered how to use Jakarta JSON Binding to easily populate Java
    objects from JSON data, as well as easily generate JSON data from Java objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JSON-formatted data has become a de facto standard when working with RESTful
    web services and microservices. Jakarta JSON Processing and JSON Binding APIs
    provide excellent support for working with JSON-formatted data, as illustrated
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
