- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: JSON Processing and JSON Binding
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JSON处理和JSON绑定
- en: '**JavaScript Object Notation** (**JSON**) is a human-readable data interchange
    format. As its name implies, JSON is derived from JavaScript. Jakarta EE provides
    support for two different APIs for JSON manipulation, namely **Jakarta JSON Processing**,
    which is a lower-level API allowing fine-grained control, and **Jakarta JSON Binding**,
    which is a higher-level API that allows us to easily populate Java objects from
    JSON data, as well as quickly generate JSON-formatted data from Java objects.
    In this chapter, we will cover both JSON Processing and JSON Binding.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**JavaScript对象表示法**（**JSON**）是一种人类可读的数据交换格式。正如其名称所暗示的，JSON源自JavaScript。Jakarta
    EE提供了对两种不同的JSON操作API的支持，即**Jakarta JSON Processing**，这是一个低级API，允许细粒度控制，以及**Jakarta
    JSON Binding**，这是一个高级API，允许我们轻松地从JSON数据填充Java对象，以及快速从Java对象生成JSON格式的数据。在本章中，我们将介绍JSON处理和JSON绑定。'
- en: 'JSON Processing includes two APIs for processing JSON: the **Model API** and
    the **Streaming API**. Both of these APIs will be covered in this chapter. JSON
    Binding transparently populates Java objects from JSON strings, as well as easily
    generates JSON strings from Java objects.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: JSON处理包括两个用于处理JSON的API：**模型API**和**流式API**。这两个API都将在本章中介绍。JSON绑定透明地将Java对象从JSON字符串中填充，以及轻松地从Java对象生成JSON字符串。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Jakarta JSON Processing
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jakarta JSON处理
- en: Jakarta JSON binding
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jakarta JSON绑定
- en: Note
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Example source code for this chapter can be found on GitHub at [https://github.com/PacktPublishing/Jakarta-EE-Application-Development/tree/main/ch04_src](https://github.com/PacktPublishing/Jakarta-EE-Application-Development/tree/main/ch04_src).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的示例源代码可以在GitHub上找到，链接为[https://github.com/PacktPublishing/Jakarta-EE-Application-Development/tree/main/ch04_src](https://github.com/PacktPublishing/Jakarta-EE-Application-Development/tree/main/ch04_src)。
- en: Jakarta JSON Processing
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Jakarta JSON处理
- en: In the following sections, we will discuss how to process JSON data using the
    two APIs provided by Jakarta JSON Processing, namely the Model and Streaming APIs.
    We will also discuss how to retrieve values from JSON data using JSON Pointer,
    as well as how to partially modify JSON data via JSON Patch.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下章节中，我们将讨论如何使用Jakarta JSON Processing提供的两个API（即模型API和流式API）来处理JSON数据。我们还将讨论如何使用JSON指针从JSON数据中检索值，以及如何通过JSON补丁部分修改JSON数据。
- en: The JSON Processing Model API
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JSON处理模型API
- en: The JSON Processing Model API allows us to generate an in-memory representation
    of a JSON object. This API is more flexible than the Streaming API discussed later
    in this chapter. However, it is slower and requires more memory, which can be
    a concern when handling large volumes of data.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: JSON处理模型API允许我们生成JSON对象的内存表示。与本章后面讨论的流式API相比，此API更灵活。然而，它较慢且需要更多内存，这在处理大量数据时可能是一个问题。
- en: Generating JSON data with the Model API
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用模型API生成JSON数据
- en: At the heart of the JSON Processing Model API is the `JsonObjectBuilder` class.
    This class has several overloaded `add()` methods that can be used to add properties
    and their corresponding values to the generated JSON data.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: JSON处理模型API的核心是`JsonObjectBuilder`类。此类有几个重载的`add()`方法，可用于将属性及其对应值添加到生成的JSON数据中。
- en: 'The following code sample illustrates how to generate JSON data using the Model
    API:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例说明了如何使用模型API生成JSON数据：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As can be seen in the example, we generate an instance of `JsonObject` by invoking
    the `add()` method on an instance of `JsonObjectBuilder`. In our example, we see
    how we can add `String` values to our `JsonObject` by invoking the `add()` method
    on `JsonObjectBuilder`. The first parameter of the `add()` method is the property
    name of the generated JSON object, and the second parameter corresponds to the
    value of the said property. The return value of the `add()` method is another
    instance of `JsonObjectBuilder`; therefore, invocations to the `add()` method
    can be chained as shown in the example.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如示例所示，我们通过在`JsonObjectBuilder`实例上调用`add()`方法来生成`JsonObject`实例。在我们的示例中，我们看到如何通过在`JsonObjectBuilder`上调用`add()`方法将`String`值添加到我们的`JsonObject`中。`add()`方法的第一参数是生成的JSON对象的属性名，第二个参数对应于该属性的值。`add()`方法的返回值是另一个`JsonObjectBuilder`实例；因此，可以对`add()`方法进行链式调用，如示例所示。
- en: Note
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The preceding example is a RESTful web service corresponding to a larger Jakarta
    RESTful Web Services application. Other parts of the application are not shown
    since they are not relevant to the discussion. The complete sample application
    can be obtained from this book’s GitHub repository at [https://github.com/PacktPublishing/Jakarta-EE-Application-Development](https://github.com/PacktPublishing/Jakarta-EE-Application-Development).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例是对应于更大的 Jakarta RESTful Web Services 应用程序的 RESTful 网络服务。由于它们与讨论无关，因此未显示应用程序的其他部分。完整的示例应用程序可以从本书的
    GitHub 仓库中获取，网址为 [https://github.com/PacktPublishing/Jakarta-EE-Application-Development](https://github.com/PacktPublishing/Jakarta-EE-Application-Development)。
- en: Once we have added all the desired properties, we need to invoke the `build()`
    method of `JsonObjectBuilder`, which returns an instance of a class implementing
    the `JsonObject` interface.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们添加了所有所需的属性，我们需要调用 `JsonObjectBuilder` 的 `build()` 方法，它返回一个实现 `JsonObject`
    接口的类的实例。
- en: In many cases, we will want to generate a `String` representation of the JSON
    object we created, so that it can be processed by another process or service.
    We can do this by creating an instance of a class implementing the `JsonWriter`
    interface, by invoking the static `createWriter()` method of the `Json` class,
    passing an instance of `StringWriter` as its sole parameter. Once we have an instance
    of the `JsonWriter` implementation, we need to invoke its `writeObject()` method,
    passing our `JsonObject` instance as its sole parameter.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，我们可能希望生成我们创建的 JSON 对象的 `String` 表示形式，以便它可以被另一个进程或服务处理。我们可以通过创建一个实现 `JsonWriter`
    接口的类的实例，通过调用 `Json` 类的静态 `createWriter()` 方法，并将 `StringWriter` 的实例作为其唯一参数来实现这一点。一旦我们有了
    `JsonWriter` 实现的实例，我们需要调用其 `writeObject()` 方法，并将我们的 `JsonObject` 实例作为其唯一参数传递。
- en: At this point, our `StringWriter` instance will have the `String` representation
    of our JSON object as its value, so invoking its `toString()` method will return
    a `String` containing our JSON object.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们的 `StringWriter` 实例将包含我们 JSON 对象的字符串表示形式作为其值，因此调用其 `toString()` 方法将返回一个包含我们
    JSON 对象的 `String`。|
- en: 'Our specific example will generate a JSON string that looks like this:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的具体示例将生成一个看起来像这样的 JSON 字符串：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Although in our example we added only `String` objects to our JSON object, we
    are not limited to this type of value; `JsonObjectBuilder` has several overloaded
    versions of its `add()` method, allowing us to add several different types of
    values to our JSON objects.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在我们的示例中我们只向 JSON 对象添加了 `String` 对象，但我们并不局限于这种类型的值；`JsonObjectBuilder` 有几个重载的
    `add()` 方法版本，允许我们向 JSON 对象添加几种不同类型的值。|
- en: 'The following table summarizes all of the available versions of the `add()`
    method:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 下表总结了所有可用的 `add()` 方法版本：
- en: '| **JsonObjectBuilder.add() method** | **Description** |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| **JsonObjectBuilder.add() 方法** | **描述** |'
- en: '| --- | --- |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `add(String name,` `BigDecimal value)` | Adds a `BigDecimal` value to our
    JSON object. |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| `add(String name,` `BigDecimal value)` | 将 `BigDecimal` 值添加到我们的 JSON 对象中。|'
- en: '| `add(String name,` `BigInteger value)` | Adds a `BigInteger` value to our
    JSON object. |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| `add(String name,` `BigInteger value)` | 将 `BigInteger` 值添加到我们的 JSON 对象中。|'
- en: '| `add(String name,` `JsonArrayBuilder value)` | Adds an array to our JSON
    object. A `JsonArrayBuilder` implementation allows us to create JSON arrays. |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| `add(String name,` `JsonArrayBuilder value)` | 将数组添加到我们的 JSON 对象中。`JsonArrayBuilder`
    实现允许我们创建 JSON 数组。|'
- en: '| `add(String name,` `JsonObjectBuilder value)` | Adds another JSON object
    to our original JSON object (property values for JSON objects can be other JSON
    objects). The added `JsonObject` implementation is built from the provided `JsonObjectBuilder`
    parameter. |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| `add(String name,` `JsonObjectBuilder value)` | 将另一个 JSON 对象添加到我们的原始 JSON
    对象中（JSON 对象的属性值可以是其他 JSON 对象）。添加的 `JsonObject` 实现是从提供的 `JsonObjectBuilder` 参数构建的。|'
- en: '| `add(String name,` `JsonValue value)` | Adds another JSON object to our original
    JSON object (property values for JSON objects can be other JSON objects). |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| `add(String name,` `JsonValue value)` | 将另一个 JSON 对象添加到我们的原始 JSON 对象中（JSON
    对象的属性值可以是其他 JSON 对象）。|'
- en: '| `add(String name,` `String value)` | Adds a `String` value to our JSON object.
    |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| `add(String name,` `String value)` | 将 `String` 值添加到我们的 JSON 对象中。|'
- en: '| `add(String name,` `boolean value)` | Adds a `boolean` value to our JSON
    object. |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| `add(String name,` `boolean value)` | 将 `boolean` 值添加到我们的 JSON 对象中。|'
- en: '| `add(String name,` `double value)` | Adds a `double` value to our JSON object.
    |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| `add(String name,` `double value)` | 将 `double` 值添加到我们的 JSON 对象中。|'
- en: '| `add(String name,` `int value)` | Adds an `int` value to our JSON object.
    |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| `add(String name,` `int value)` | 将 `int` 值添加到我们的 JSON 对象中。|'
- en: '| `add(String name,` `long value)` | Adds a `long` value to our JSON object.
    |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| `add(String name, long value)` | 向我们的JSON对象添加一个`long`值。 |'
- en: Table 4.1 – JsonObjectBuilder add() methods
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 表4.1 – JsonObjectBuilder add()方法
- en: In all cases, the first parameter of the `add()` method corresponds to the name
    of the property in our JSON object, and the second parameter corresponds to the
    value of the property.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有情况下，`add()`方法的第一参数对应于我们JSON对象中的属性名称，第二个参数对应于属性的值。
- en: Parsing JSON data with the Model API
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Model API解析JSON数据
- en: 'In the last section, we saw how to generate JSON data from our Java code with
    the object model API. In this section, we will see how we can read and parse existing
    JSON data. The following code sample illustrates how to do this:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们看到了如何使用对象模型API从我们的Java代码中生成JSON数据。在本节中，我们将看到如何读取和解析现有的JSON数据。以下代码示例说明了如何进行此操作：
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: To parse an existing JSON string, we need to create a `StringReader` object,
    passing the `String` object containing the JSON to be parsed as a parameter. We
    then pass the resulting `StringReader` instance to the static `createReader()`
    method of the `Json` class. This method invocation will return an instance of
    `JsonReader`. We can then obtain an instance of `JsonObject` by invoking the `readObject()`
    method on it.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 要解析现有的JSON字符串，我们需要创建一个`StringReader`对象，将包含要解析的JSON的`String`对象作为参数传递。然后，我们将生成的`StringReader`实例传递给`Json`类的静态`createReader()`方法。此方法调用将返回一个`JsonReader`实例。然后，我们可以通过调用其上的`readObject()`方法来获取`JsonObject`实例。
- en: In this example, we use the `getString()` method to obtain the values for all
    properties in our JSON object. The first and only argument for this method is
    the name of the property we wish to retrieve; unsurprisingly, the return value
    is the value of the property.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用`getString()`方法来获取我们JSON对象中所有属性的值。此方法唯一的第一个参数是我们希望检索的属性的名称；不出所料，返回值是该属性的值。
- en: 'In addition to the `getString()` method, there are several other similar methods
    to obtain values of other types. The following table summarizes these methods:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`getString()`方法之外，还有其他几个类似的方法可以获取其他类型的数据值。以下表格总结了这些方法：
- en: '| `JsonObject method` | **Description** |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| JsonObject方法 | **描述** |'
- en: '| --- | --- |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `get(Object key)` | Retrieves an instance of a class implementing the `JsonValue`
    interface |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| `get(Object key)` | 获取实现`JsonValue`接口的类的实例 |'
- en: '| `getBoolean(String name)` | Retrieves a `boolean` value corresponding to
    the given key |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| `getBoolean(String name)` | 获取与给定键对应的`boolean`值 |'
- en: '| `getInt(String name)` | Retrieves an `int` value corresponding to the given
    key |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| `getInt(String name)` | 获取与给定键对应的`int`值 |'
- en: '| `getJsonArray(String name)` | Retrieves the instance of a class implementing
    the `JsonArray` interface corresponding to the given key |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| `getJsonArray(String name)` | 获取与给定键对应的实现`JsonArray`接口的类的实例 |'
- en: '| `getJsonNumber(String name)` | Retrieves the instance of a class implementing
    the `JsonNumber` interface corresponding to the given key |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| `getJsonNumber(String name)` | 获取与给定键对应的实现`JsonNumber`接口的类的实例 |'
- en: '| `getJsonObject(String name)` | Retrieves the instance of a class implementing
    the `JsonObject` interface corresponding to the given key |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| `getJsonObject(String name)` | 获取与给定键对应的实现`JsonObject`接口的类的实例 |'
- en: '| `getJsonString(String name)` | Retrieves the instance of a class implementing
    the `JsonString` interface corresponding to the given key |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| `getJsonString(String name)` | 获取与给定键对应的实现`JsonString`接口的类的实例 |'
- en: '| `getString(String Name)` | Retrieves a `String` corresponding to the given
    key |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| `getString(String Name)` | 获取与给定键对应的`String` |'
- en: Table 4.2 – JsonObject methods to retrieve values from JSON data
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 表4.2 – 从JSON数据中检索值的JsonObject方法
- en: In all cases, the `String` parameter of the method corresponds to the key name,
    and the return value is the JSON property value we wish to retrieve.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有情况下，方法的`String`参数对应于键名，返回值是我们希望检索的JSON属性值。
- en: The JSON Processing Streaming API
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JSON处理流式API
- en: The JSON Processing Streaming API allows sequential reading of a JSON object
    from a stream (a subclass of `java.io.OutputStream` or a subclass of `java.io.Writer`).
    It is faster and more memory efficient than the Model API; however, the trade-off
    is that it is less straightforward to access specific JSON properties directly
    when compared to the Model API. When using the Streaming API, we need to use JSON
    Pointer and JSON Patch to retrieve or modify specific values from JSON data.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: JSON 处理流式 API 允许从流（`java.io.OutputStream` 的子类或 `java.io.Writer` 的子类）中顺序读取 JSON
    对象。它比模型 API 更快、更节省内存；然而，与模型 API 相比，直接访问特定的 JSON 属性不那么直接。当使用流式 API 时，我们需要使用 JSON
    Pointer 和 JSON Patch 来检索或修改 JSON 数据中的特定值。
- en: Generating JSON data with the streaming API
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用流式 API 生成 JSON 数据
- en: The JSON Streaming API has a `JsonGenerator` class we can use to generate JSON
    data and write it to a stream. This class has several overloaded `write()` methods
    that can be used to add properties and their corresponding values to the generated
    JSON data.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: JSON 流式 API 有一个 `JsonGenerator` 类，我们可以使用它来生成 JSON 数据并将其写入流。此类有几个重载的 `write()`
    方法，可以用来向生成的 JSON 数据中添加属性及其对应的值。
- en: 'The following code sample illustrates how to generate JSON data using the Streaming
    API:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例说明了如何使用流式 API 生成 JSON 数据：
- en: '[PRE3]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We create an instance of `JsonGenerator` by invoking the `createGenerator()`
    static method of the `Json` class. The JSON Processing API provides two overloaded
    versions of this method; one takes an instance of a class that extends `java.io.Writer`
    (such as `StringWriter`, which we used in our example), and the other one takes
    an instance of a class that extends `java.io.OutputStream`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过调用 `Json` 类的 `createGenerator()` 静态方法来创建一个 `JsonGenerator` 实例。JSON 处理 API
    提供了此方法的两个重载版本；一个接受一个扩展 `java.io.Writer` 类（例如 `StringWriter`，我们在示例中使用）的类的实例，另一个接受一个扩展
    `java.io.OutputStream` 类的类的实例。
- en: Before we can start adding properties to the generated JSON stream, we need
    to invoke the `writeStartObject()` method on `JsonGenerator`. This method writes
    the JSON start object character (represented by an opening curly brace ( { ) in
    JSON strings) and returns another instance of `JsonGenerator`, allowing us to
    chain `write()` invocations to add properties to our JSON stream.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始向生成的 JSON 流添加属性之前，我们需要在 `JsonGenerator` 上调用 `writeStartObject()` 方法。此方法写入
    JSON 起始对象字符（在 JSON 字符串中表示为开括号 `{`）并返回另一个 `JsonGenerator` 实例，允许我们将 `write()` 调用链式添加到我们的
    JSON 流中。
- en: The `write()` method on `JsonGenerator` allows us to add properties to the JSON
    stream we are generating; its first parameter is a `String` corresponding to the
    name of the property we are adding, and the second parameter is the value of the
    property.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`JsonGenerator` 上的 `write()` 方法允许我们向正在生成的 JSON 流中添加属性；它的第一个参数是我们添加的属性的名称对应的
    `String`，第二个参数是属性的值。'
- en: 'In our example, we are adding only `String` values to the JSON stream we are
    creating. However, we are not limited to strings; the Streaming API provides several
    overloaded `write()` methods that allow us to add several different types of data
    to our JSON stream. The following table summarizes all of the available versions
    of the `write()` method:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们只向创建的 JSON 流添加 `String` 值。然而，我们并不局限于字符串；流式 API 提供了几个重载的 `write()`
    方法，允许我们向 JSON 流添加多种不同类型的数据。以下表格总结了所有可用的 `write()` 方法版本：
- en: '| `JsonGenerator.write() method` | **Description** |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| `JsonGenerator.write() 方法` | **描述** |'
- en: '| --- | --- |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `write(String name,` `BigDecimal value)` | Writes a `BigDecimal` value to
    our JSON stream |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| `write(String name,` `BigDecimal value)` | 将一个 `BigDecimal` 值写入我们的 JSON 流
    |'
- en: '| `write(String name,` `BigInteger value)` | Writes a `BigInteger` value to
    our JSON stream |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| `write(String name,` `BigInteger value)` | 将一个 `BigInteger` 值写入我们的 JSON 流
    |'
- en: '| `write(String name,` `JsonValue value)` | Writes a JSON object to our JSON
    stream (property values for JSON streams can be other JSON objects) |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| `write(String name,` `JsonValue value)` | 将一个 JSON 对象写入我们的 JSON 流（JSON 流的属性值可以是其他
    JSON 对象） |'
- en: '| `write(String name,` `String value)` | Writes a `String` value to our JSON
    stream |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| `write(String name,` `String value)` | 将一个 `String` 值写入我们的 JSON 流 |'
- en: '| `write(String name,` `boolean value)` | Writes a `boolean` value to our JSON
    stream |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| `write(String name,` `boolean value)` | 将一个 `boolean` 值写入我们的 JSON 流 |'
- en: '| `write(String name,` `double value)` | Writes a `double` value to our JSON
    stream |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| `write(String name,` `double value)` | 将一个 `double` 值写入我们的 JSON 流 |'
- en: '| `write(String name,` `int value)` | Writes an `int` value to our JSON stream
    |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| `write(String name,` `int value)` | 将一个 `int` 值写入我们的 JSON 流 |'
- en: '| `write(String name,` `long value)` | Writes a `long` value to our JSON stream
    |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| `write(String name,` `long value)` | 将 `long` 值写入我们的 JSON 流 |'
- en: Table 4.3 – JsonGenerator write() method
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4.3 – JsonGenerator write() 方法
- en: In all cases, the first parameter of the `write()` method corresponds to the
    name of the property we are adding to our JSON stream, and the second parameter
    corresponds to the value of the property.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有情况下，`write()` 方法的第一个参数对应于我们添加到 JSON 流中的属性名称，第二个参数对应于属性的值。
- en: Once we are done adding properties to our JSON stream, we need to invoke the
    `writeEnd()` method on `JsonGenerator`; this method adds the JSON end object character
    (represented by a closing curly brace ( } ) in JSON strings).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们完成向 JSON 流添加属性，我们需要在 `JsonGenerator` 上调用 `writeEnd()` 方法；此方法添加 JSON 结束对象字符（在
    JSON 字符串中由一个关闭花括号（}）表示）。
- en: At this point, our stream or reader is populated with the JSON data we generated.
    What we do with it depends on our application logic. In our example, we simply
    invoked the `toString()` method of our `StringReader` to obtain the `String` representation
    of the JSON data we created.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们的流或读取器被我们生成的 JSON 数据填充。我们如何处理它取决于我们的应用程序逻辑。在我们的例子中，我们简单地调用了 `StringReader`
    的 `toString()` 方法来获取我们创建的 JSON 数据的字符串表示。
- en: Parsing JSON data with the streaming API
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用流式 API 解析 JSON 数据
- en: In this section, we will cover how to parse JSON data we receive from a stream.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍如何解析从流中接收到的 JSON 数据。
- en: The following example illustrates how we can populate Java objects from JSON
    data using the streaming API.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例说明了我们如何使用流式 API 从 JSON 数据中填充 Java 对象。
- en: '[PRE4]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The first thing we need to do to read JSON data using the Streaming API is
    to create an instance of `JsonParser` by invoking the static `createJsonParser()`
    method on the `Json` class. There are two overloaded versions of the `createJsonParser()`
    method: one takes an instance of a class that extends `java.io.InputStream`, and
    the other one takes an instance of a class that extends `java.io.Reader`. In our
    example, we use the latter, passing an instance of `java.io.StringReader`, which
    is a subclass of `java.io.Reader`.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用流式 API 读取 JSON 数据，我们首先需要通过在 `Json` 类上调用静态 `createJsonParser()` 方法来创建一个 `JsonParser`
    实例。`createJsonParser()` 方法有两种重载版本：一个接受一个扩展 `java.io.InputStream` 的类的实例，另一个接受一个扩展
    `java.io.Reader` 的类的实例。在我们的例子中，我们使用后者，传递一个 `java.io.StringReader` 的实例，它是 `java.io.Reader`
    的一个子类。
- en: The next step is to loop through the JSON data to obtain the data to be parsed.
    We can achieve this by invoking the `hasNext()` method on `JsonParser`, which
    returns true if there is more data to be read, and false otherwise.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是遍历 JSON 数据以获取要解析的数据。我们可以通过在 `JsonParser` 上调用 `hasNext()` 方法来实现这一点，该方法在还有更多数据要读取时返回
    true，否则返回 false。
- en: We then need to read the next piece of data in our stream, the `JsonParser.next()`
    method returns an instance of `JsonParser.Event` that indicates the type of data
    that we just read. In our example, we check only for key names (i.e., `firstName`,
    `lastName`, and `email`), and the corresponding string values. We check for the
    type of data we just read by comparing the event returned by `JsonParser.next()`
    against several values defined in `JsonParser.Event`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要读取流中的下一份数据，`JsonParser.next()` 方法返回一个 `JsonParser.Event` 实例，该实例指示我们刚刚读取的数据类型。在我们的例子中，我们只检查键名称（即
    `firstName`、`lastName` 和 `email`），以及相应的字符串值。我们通过将 `JsonParser.next()` 返回的事件与 `JsonParser.Event`
    中定义的几个值进行比较来检查我们刚刚读取的数据类型。
- en: 'The following table summarizes all of the possible events that can be returned
    from `JsonParser.next()`:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 下表总结了 `JsonParser.next()` 可以返回的所有可能的事件：
- en: '| `JsonParser Event` | **Description** |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| `JsonParser Event` | **描述** |'
- en: '| --- | --- |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `Event.START_OBJECT` | Indicates the start of a JSON object |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| `Event.START_OBJECT` | 表示 JSON 对象的开始 |'
- en: '| `Event.END_OBJECT` | Indicates the end of a JSON object |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| `Event.END_OBJECT` | 表示 JSON 对象的结束 |'
- en: '| `Event.START_ARRAY` | Indicates the start of an array |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| `Event.START_ARRAY` | 表示数组的开始 |'
- en: '| `Event.END_ARRAY` | Indicates the end of an array |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| `Event.END_ARRAY` | 表示数组的结束 |'
- en: '| `Event.KEY_NAME` | Indicates the name of a JSON property was read; we can
    obtain the key name by invoking `getString()` on `JsonParser` |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| `Event.KEY_NAME` | 表示读取了 JSON 属性的名称；我们可以通过在 `JsonParser` 上调用 `getString()`
    来获取键名称 |'
- en: '| `Event.VALUE_TRUE` | Indicates that a Boolean value of `true` was read |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| `Event.VALUE_TRUE` | 表示读取了布尔值 `true` |'
- en: '| `Event.VALUE_FALSE` | Indicates that a Boolean value of `false` was read
    |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| `Event.VALUE_FALSE` | 表示读取了布尔值 `false` |'
- en: '| `Event.VALUE_NULL` | Indicates that a null value was read |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| `Event.VALUE_NULL` | 表示读取到了空值 |'
- en: '| `Event.VALUE_NUMBER` | Indicates that a numeric value was read |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| `Event.VALUE_NUMBER` | 表示读取到了数值 |'
- en: '| `Event.VALUE_STRING` | Indicates that a string value was read |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| `Event.VALUE_STRING` | 表示读取到了字符串值 |'
- en: Table 4.4 – JsonParser events
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4.4 – JsonParser 事件
- en: 'As shown in the example, `String` values can be retrieved by invoking `getString()`
    on `JsonParser`. Numeric values can be retrieved in several different formats.
    The following table summarizes the methods in `JsonParser` that can be used to
    retrieve numeric values:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如示例所示，可以通过在 `JsonParser` 上调用 `getString()` 来检索 `String` 类型的值。数值可以以几种不同的格式检索。以下表格总结了
    `JsonParser` 中可以用来检索数值的方法：
- en: '| `JsonParser method` | **Description** |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| `JsonParser method` | **描述** |'
- en: '| --- | --- |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `getInt()` | Retrieves the numeric value as an `int` |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| `getInt()` | 以 `int` 类型检索数值 |'
- en: '| `getLong()` | Retrieves the numeric value as a `long` |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| `getLong()` | 以 `long` 类型检索数值 |'
- en: '| `getBigDecimal()` | Retrieves the numeric value as an instance of `java.math.BigDecimal`
    |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| `getBigDecimal()` | 以 `java.math.BigDecimal` 实例的形式检索数值 |'
- en: Table 4.5 – JsonParser methods used to retrieve numeric values
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4.5 – 用于检索数值的 JsonParser 方法
- en: '`JsonParser` also provides a convenient `isIntegralNumber()` method that returns
    `true` if the numeric value can be safely cast to an `int` or `long`.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`JsonParser` 还提供了一个方便的 `isIntegralNumber()` 方法，如果数值可以安全地转换为 `int` 或 `long`
    类型，则返回 `true`。'
- en: What we do with the values we obtain from the stream depends on our application
    logic; in our example, we place them in a `Map` and then use said `Map` to populate
    a Java class.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对从流中获取的值所采取的操作取决于我们的应用程序逻辑；在我们的示例中，我们将它们放入一个 `Map` 中，然后使用该 `Map` 来填充一个 Java
    类。
- en: Retrieving values from data with JSON Pointer
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从数据中检索 JSON Pointer 值
- en: Jakarta JSON Processing supports JSON Pointer, an **Internet Engineering Task
    Force** (**IETF**) standard that defines a string syntax for identifying a specific
    value within a JSON document, similar to what XPath provides for XML documents.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: Jakarta JSON Processing 支持 JSON Pointer，这是一个 **互联网工程任务组** (**IETF**) 标准，它定义了一种字符串语法，用于在
    JSON 文档中标识特定的值，类似于 XPath 为 XML 文档提供的功能。
- en: 'The syntax for JSON Pointer is straightforward. For example, let us suppose
    that we have the following JSON document:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: JSON Pointer 的语法很简单。例如，假设我们有一个以下 JSON 文档：
- en: '[PRE5]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If we would like to obtain the value of the `lastName` property of the document,
    the JSON Pointer expression to use would be `"/lastName"`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要获取文档中 `lastName` 属性的值，所使用的 JSON Pointer 表达式应该是 `"/lastName"`。
- en: 'If our JSON document consisted of an array, then we would have to prefix the
    property with the index in the array; for example, say we want to obtain the `lastName`
    property of the second element in the following JSON array:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的 JSON 文档由一个数组组成，那么我们必须在属性前加上数组中的索引；例如，假设我们想要获取以下 JSON 数组中第二个元素的 `lastName`
    属性：
- en: '[PRE6]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The JSON Pointer expression to do so would be `"/1/lastName"`. The `"/1"` at
    the beginning of the expression refers to the element index in the array. Just
    like in Java, JSON arrays are 0 indexed; therefore, in this example, we are obtaining
    the value of the `lastName` property in the second element of the array. Let’s
    now look at an example of how we would use the JSON Pointer API to perform this
    task:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 要这样做，所使用的 JSON Pointer 表达式应该是 `"/1/lastName"`。表达式开头的 `"/1"` 指的是数组中的元素索引。就像在
    Java 中一样，JSON 数组是从 0 开始索引的；因此，在这个例子中，我们正在获取数组第二个元素中 `lastName` 属性的值。现在让我们看看如何使用
    JSON Pointer API 来执行此任务的示例：
- en: '[PRE7]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The preceding code sample is a RESTful web service written using Jakarta RESTful
    Web Services. In order to read property values from a JSON document, we first
    need to create an instance of `jakarta.json.JsonReader` by invoking the static
    `createReader()` method on `jakarta.json.Json`. `createReader()`. This takes an
    instance of any class implementing the `java.io.Reader` interface as an argument.
    In our example, we are creating a new instance of `java.io.StringReader` on the
    fly and passing our JSON string as a parameter to its constructor.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例是一个使用 Jakarta RESTful Web Services 编写的 RESTful 网络服务。为了从 JSON 文档中读取属性值，我们首先需要通过在
    `jakarta.json.Json` 上调用静态的 `createReader()` 方法来创建一个 `jakarta.json.JsonReader`
    实例。`createReader()` 方法接受任何实现 `java.io.Reader` 接口的对象实例作为参数。在我们的示例中，我们动态创建了一个新的
    `java.io.StringReader` 实例，并将我们的 JSON 字符串作为参数传递给其构造函数。
- en: Note
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: There is an overloaded version of `JSON.createReader()` that takes an instance
    of any class implementing `java.io.InputStream`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`JSON.createReader()` 有一个重载版本，它接受任何实现 `java.io.InputStream` 类的实例。'
- en: In our example, our JSON document consists of an array of objects; therefore,
    we populate an instance of `jakarta.json.JsonArray` by invoking the `readArray()`
    method on the `JsonReader` object we created. (If our JSON document had consisted
    of a single JSON object, we would have invoked `JsonReader.readObject()` instead.)
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们的JSON文档由一个对象数组组成；因此，我们通过在创建的 `JsonReader` 对象上调用 `readArray()` 方法来填充
    `jakarta.json.JsonArray` 实例。（如果我们的JSON文档由一个单独的JSON对象组成，我们将调用 `JsonReader.readObject()`
    而不是 `readArray()`。）
- en: Now that we have populated our `JsonArray` variable, we create an instance of
    `jakarta.json.JsonPointer`, and initialize it with the JSON Pointer expression
    we want to use to obtain the value we are searching for. Recall we are looking
    for the value of the `lastName` property in the second element of the array; therefore,
    the appropriate JSON Pointer expression is `/1/lastName`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经填充了 `JsonArray` 变量，我们创建了一个 `jakarta.json.JsonPointer` 实例，并用我们想要使用的JSON指针表达式初始化它。回想一下，我们正在寻找数组第二个元素中
    `lastName` 属性的值；因此，适当的JSON指针表达式是 `/1/lastName`。
- en: Now that we have created an instance of `JsonPointer` with the appropriate JSON
    Pointer expression, we simply invoke its `getValue()` method, passing our `JsonArray`
    object as a parameter; then, we invoke `toString()` on the result, and the return
    value of this invocation will be the value of the `lastName` property on the JSON
    document `"Heffelfinger`, in our example).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经使用适当的JSON指针表达式创建了一个 `JsonPointer` 实例，我们只需调用它的 `getValue()` 方法，并将我们的 `JsonArray`
    对象作为参数传递；然后，我们在结果上调用 `toString()`，这个调用的返回值将是JSON文档中 `"Heffelfinger"` 的 `lastName`
    属性的值（在我们的例子中）。
- en: Updating JSON data values with JSON Patch
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用JSON补丁更新JSON数据值
- en: Jakarta JSON Processing includes support for JSON Patch, another IETF standard.
    This one provides a series of operations that can be applied to a JSON document.
    JSON Patch allows us to perform partial updates on a JSON object.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: Jakarta JSON Processing 包括对JSON补丁的支持，这是另一个IETF标准。它提供了一系列可以应用于JSON文档的操作。JSON补丁允许我们对JSON对象执行部分更新。
- en: 'The following operations are supported by JSON Patch:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: JSON补丁支持以下操作：
- en: '| **JSON** **Patch Operation** | **Description** |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| **JSON** **补丁操作** | **描述** |'
- en: '| --- | --- |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| add | Adds an element to a JSON document |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| 添加 | 向JSON文档中添加一个元素 |'
- en: '| remove | Removes an element from a JSON document |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| 删除 | 从JSON文档中删除一个元素 |'
- en: '| replace | Replaces a value in a JSON document with a new value |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| 替换 | 将JSON文档中的一个值替换为新值 |'
- en: '| move | Moves a value in a JSON document from its current location in the
    document to a new position |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| 移动 | 将JSON文档中的一个值从其在文档中的当前位置移动到新位置 |'
- en: '| copy | Copies a value in a JSON document to a new location in the document
    |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| 复制 | 将JSON文档中的一个值复制到文档中的新位置 |'
- en: '| test | Verifies that the value in a specific location in a JSON document
    is equal to the specified value |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| 测试 | 验证JSON文档中特定位置的值是否等于指定的值 |'
- en: Table 4.6 – JSON Patch operations
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 表4.6 – JSON补丁操作
- en: Jakarta JSON Processing supports all of the preceding JSON Patch operations,
    which rely on JSON Pointer expressions to locate source and target locations in
    JSON documents.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: Jakarta JSON Processing 支持所有上述JSON补丁操作，这些操作依赖于JSON指针表达式来定位JSON文档中的源和目标位置。
- en: 'The following example illustrates how we can use JSON Patch with Jakarta JSON
    Processing:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例说明了我们如何使用Jakarta JSON Processing的JSON补丁：
- en: '[PRE8]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this example, let’s assume we are dealing with the same JSON document we
    used in our previous example, an array of two individual JSON objects, each with
    a `dateOfBirth` property (among other properties).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，让我们假设我们正在处理与上一个例子相同的JSON文档，一个包含两个单独JSON对象的数组，每个对象都有一个 `dateOfBirth` 属性（以及其他属性）。
- en: In our example, we create an instance of `JsonArray` as before and then modify
    the `dateOfBirth` of the second element in the array. In order to do this, we
    create an instance of `jakarta.json.JsonPatchBuilder` via the static `createPatchBuilder()`
    method in the `jakarta.json.Json` class. In our example, we are replacing the
    value of one of the properties with a new value; we use the `replace()` method
    of our `JsonPatch` instance to accomplish this. The first argument in the method
    is a JSON Pointer expression indicating the location of the property we are going
    to modify, and the second argument is the new value for the property. As its name
    implies, `JsonPatchBuilder` follows the `Builder` design pattern, meaning that
    most of its methods return another instance of `JsonPatchBuilder`; this allows
    us to chain method calls on the resulting instances of `JsonPatchBuilder` (in
    our example, we are performing only one operation, but this doesn’t have to be
    the case). Once we are done specifying the operation(s) to perform on our JSON
    object, we create an instance of `jakarta.json.JsonPatch` by invoking the `build()`
    method on `JsonPatchBuilder`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们像之前一样创建了一个 `JsonArray` 实例，然后修改了数组中第二个元素的 `dateOfBirth`。为了做到这一点，我们通过
    `jakarta.json.Json` 类中的静态 `createPatchBuilder()` 方法创建了一个 `jakarta.json.JsonPatchBuilder`
    实例。在我们的示例中，我们用新值替换了一个属性的值；我们使用 `JsonPatch` 实例的 `replace()` 方法来完成这个操作。方法中的第一个参数是一个
    JSON Pointer 表达式，指示我们要修改的属性的定位，第二个参数是属性的新值。正如其名称所暗示的，`JsonPatchBuilder` 遵循 `Builder`
    设计模式，这意味着其大多数方法返回另一个 `JsonPatchBuilder` 实例；这允许我们在 `JsonPatchBuilder` 的结果实例上链式调用方法（在我们的示例中，我们只执行了一个操作，但这不必是这种情况）。一旦我们指定了要在我们的
    JSON 对象上执行的操作，我们通过在 `JsonPatchBuilder` 上调用 `build()` 方法创建一个 `jakarta.json.JsonPatch`
    实例。
- en: Once we have created the patch, we apply it to our JSON object (an instance
    of `JsonArray`, in our example) by invoking its `patch()` method and passing the
    JSON object as a parameter.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们创建了补丁，我们通过调用其 `patch()` 方法并将 JSON 对象（在我们的示例中为 `JsonArray` 实例）作为参数传递，将其应用到我们的
    JSON 对象上。
- en: Our example shows how to replace the value of a JSON property with another via
    JSON Patch support in Jakarta JSON-Processing. All standard JSON Patch operations
    are supported by Jakarta JSONProcessing. For details on how to use other JSON
    Patch operations with JSON Processing, consult the Jakarta EE API documentation
    at [https://jakarta.ee/specifications/platform/10/apidocs/](https://jakarta.ee/specifications/platform/10/apidocs/).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的示例展示了如何在 Jakarta JSON-Processing 中通过 JSON Patch 支持，用另一个值替换 JSON 属性的值。Jakarta
    JSONProcessing 支持所有标准的 JSON Patch 操作。有关如何使用 JSON Processing 与其他 JSON Patch 操作的详细信息，请参阅
    [https://jakarta.ee/specifications/platform/10/apidocs/](https://jakarta.ee/specifications/platform/10/apidocs/)
    的 Jakarta EE API 文档。
- en: Now that we’ve seen how to directly manipulate JSON data with JSON Processing,
    we will focus our attention on how to bind JSON data with Jakarta JSON Binding,
    a higher-level API that allows us to do common tasks quickly and easily.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了如何直接使用 JSON Processing 操作 JSON 数据，我们将关注如何使用 Jakarta JSON Binding 将
    JSON 数据绑定，这是一个更高级的 API，它允许我们快速轻松地完成常见任务。
- en: Jakarta JSON Binding
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Jakarta JSON Binding
- en: Jakarta JSON Binding is a high-level API that allows us to almost seamlessly
    populate Java objects from JSON data, as well as easily generate JSON-formatted
    data from Java objects.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: Jakarta JSON Binding 是一个高级 API，它允许我们几乎无缝地从 JSON 数据填充 Java 对象，以及轻松地从 Java 对象生成
    JSON 格式的数据。
- en: Populating Java objects from JSON with JSON Binding
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 JSON Binding 从 JSON 填充 Java 对象
- en: A common programming task is to populate Java objects from JSON strings. It
    is such a common task that several libraries were created to transparently populate
    Java objects from JSON, freeing application developers from having to manually
    code this functionality. Several non-standard Java libraries that accomplish this
    task exist, such as Jackson ([https://github.com/FasterXML/jackson](https://github.com/FasterXML/jackson)),
    json-simple ([https://code.google.com/archive/p/json-simple/](https://code.google.com/archive/p/json-simple/)),
    or Gson ([https://github.com/google/gson](https://github.com/google/gson)). Jakarta
    EE includes a standard API providing this functionality, namely JSON Binding.
    In this section, we will cover how to transparently populate a Java object from
    a JSON string.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的编程任务是填充 Java 对象来自 JSON 字符串。这是一个如此常见的任务，以至于已经创建了几个库来透明地填充 Java 对象来自 JSON，从而让应用程序开发者免于手动编写此功能。存在几个完成此任务的非标准
    Java 库，例如 Jackson ([https://github.com/FasterXML/jackson](https://github.com/FasterXML/jackson))、json-simple
    ([https://code.google.com/archive/p/json-simple/](https://code.google.com/archive/p/json-simple/))
    或 Gson ([https://github.com/google/gson](https://github.com/google/gson))。Jakarta
    EE 包含一个提供此功能的标准化 API，即 JSON Binding。在本节中，我们将介绍如何从 JSON 字符串透明地填充 Java 对象。
- en: 'The following example shows a RESTful web service written using Jakarta RESTful
    Web Services. The service responds to HTTP POST requests in its `addCustomer()`
    method. The `addCustomer()` method takes a `String` as a parameter; it is expected
    for this string to contain valid JSON:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了使用 Jakarta RESTful Web Services 编写的 RESTful Web 服务。该服务在其 `addCustomer()`
    方法中响应 HTTP POST 请求。`addCustomer()` 方法接受一个 `String` 参数；预期此字符串包含有效的 JSON：
- en: '[PRE9]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The JSON Binding implementation provided by our application server provides
    an instance of a class implementing the `JsonbBuilder` interface; this class provides
    a static `create()` method that we can use to obtain an instance of `Jsonb`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用服务器提供的 JSON Binding 实现提供了一个实现 `JsonbBuilder` 接口的类的实例；这个类提供了一个静态的 `create()`
    方法，我们可以使用它来获取 `Jsonb` 的实例。
- en: Once we have an instance of `Jsonb`, we can use it to parse a JSON string and
    automatically populate a Java object. This is done via its `fromJson()` method.
    The `fromJson()` method takes a `String` containing the JSON data we need to parse
    as its first parameter and the type of object we wish to populate as its second
    parameter. In our example, we are populating a simple `Customer` class containing
    fields such as `firstName`, `middleName`, `lastName`, and `dateOfBirth`. Jakarta
    JSON Binding will look for JSON property names matching the property names in
    the Java object, and automatically populate the Java object with the corresponding
    JSON properties. It couldn’t get more simple than that!
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了 `Jsonb` 实例，我们可以用它来解析 JSON 字符串并自动填充 Java 对象。这是通过它的 `fromJson()` 方法完成的。`fromJson()`
    方法接受一个包含需要解析的 JSON 数据的 `String` 作为其第一个参数，以及我们希望填充的对象类型作为其第二个参数。在我们的例子中，我们正在填充一个包含
    `firstName`、`middleName`、`lastName` 和 `dateOfBirth` 等字段的简单 `Customer` 类。Jakarta
    JSON Binding 将寻找与 Java 对象中的属性名称匹配的 JSON 属性名称，并自动用相应的 JSON 属性填充 Java 对象。这再简单不过了！
- en: Once we have populated our Java object, we can do whatever we need to do with
    it. In our example, we simply return a `String` representation of our `Customer`
    object to the client.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们填充了我们的 Java 对象，我们就可以用它做任何我们需要做的事情。在我们的例子中，我们只是将 `Customer` 对象的 `String`
    表示形式返回给客户端。
- en: Generating JSON data from Java objects with JSON Binding
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 JSON Binding 从 Java 对象生成 JSON 数据
- en: 'In addition to populating Java objects from JSON data, JSON Binding can also
    generate JSON strings from Java objects. The following example illustrates how
    to do this:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 除了从 JSON 数据填充 Java 对象之外，JSON Binding 还可以从 Java 对象生成 JSON 字符串。以下示例说明了如何做到这一点：
- en: '[PRE10]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In this example, we are generating JSON data from a `Customer` object.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们正在从 `Customer` 对象生成 JSON 数据。
- en: Just like before, we create an instance of `jakarta.json.bind.Jsonb` by invoking
    the static `jakarta.json.bind.JsonbBuilder.create()` method. Once we have our
    `Jsonb` instance, we simply invoke its `toJson()` method to convert the list of
    objects to its equivalent JSON representation.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 就像之前一样，我们通过调用静态方法 `jakarta.json.bind.JsonbBuilder.create()` 来创建一个 `jakarta.json.bind.Jsonb`
    实例。一旦我们有了 `Jsonb` 实例，我们只需调用它的 `toJson()` 方法，将对象列表转换为等效的 JSON 表示形式。
- en: Summary
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered how to process JSON data using two Jakarta EE APIs,
    JSON Processing and JSON Binding.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了如何使用两个 Jakarta EE API（JSON Processing 和 JSON Binding）来处理 JSON 数据。
- en: 'We covered the following topics:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们涵盖了以下主题：
- en: We saw how we can generate and parse JSON data with JSON Processing’s model
    API
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们看到了如何使用JSON Processing的模型API生成和解析JSON数据
- en: We also explored how to generate and parse JSON data with JSON Processing’s
    streaming API
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还探讨了如何使用JSON Processing的流式API生成和解析JSON数据
- en: Additionally, we covered how to extract values from JSON data with JSON Pointer
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，我们还介绍了如何使用JSON Pointer从JSON数据中提取值
- en: Also, we saw how to update specific values in JSON data with JSON Patch
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同样，我们也看到了如何使用JSON Patch在JSON数据中更新特定值
- en: Finally, we covered how to use Jakarta JSON Binding to easily populate Java
    objects from JSON data, as well as easily generate JSON data from Java objects
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们介绍了如何使用Jakarta JSON Binding轻松地从JSON数据填充Java对象，以及如何轻松地从Java对象生成JSON数据
- en: JSON-formatted data has become a de facto standard when working with RESTful
    web services and microservices. Jakarta JSON Processing and JSON Binding APIs
    provide excellent support for working with JSON-formatted data, as illustrated
    in this chapter.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理RESTful Web服务和微服务时，JSON格式的数据已经成为一种事实上的标准。Jakarta JSON Processing和JSON Binding
    API为此提供了出色的支持，正如本章所示。
