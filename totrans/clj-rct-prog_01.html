<html><head></head><body>
<div id="page" style="height:0pt"/><div class="book" title="Chapter&#xA0;1.&#xA0;What is Reactive Programming?"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch01" class="calibre1"/>Chapter 1. What is Reactive Programming?</h1></div></div></div><p class="calibre7">Reactive Programming <a id="id0" class="calibre1"/>is both an overloaded term and a broad topic. As such, this book will focus on a specific formulation of Reactive Programming <a id="id1" class="calibre1"/>called <span class="strong"><strong class="calibre2">Compositional Event Systems</strong></span> (<span class="strong"><strong class="calibre2">CES</strong></span>).</p><p class="calibre7">Before covering some history and background behind Reactive Programming and CES, I would like to open with a working and hopefully compelling example: an animation in which we draw a sine wave onto a web page.</p><p class="calibre7">The sine wave is <a id="id2" class="calibre1"/>simply the graph representation of the sine function. It is a smooth, repetitive oscillation, and at the end of our animation it will look like the following screenshot:</p><div class="mediaobject"><img src="../images/00002.jpeg" alt="What is Reactive Programming?" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre7">This example will highlight how CES:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Urges us to think about <span class="strong"><em class="calibre8">what</em></span> we would like to do as opposed to <span class="strong"><em class="calibre8">how</em></span></li><li class="listitem">Encourages small, specific abstractions that can be composed together</li><li class="listitem">Produces terse and maintainable code that is easy to change</li></ul></div><p class="calibre7">The core of this program boils down to four lines of ClojureScript:</p><div class="informalexample"><pre class="programlisting">(-&gt; sine-wave
    (.take 600)
    (.subscribe (fn [{:keys [x y]}]
                  (fill-rect x y "orange"))))</pre></div><p class="calibre7">Simply by<a id="id3" class="calibre1"/> looking at this code it is impossible to determine precisely what it does. However, do take the time to read and imagine what it <span class="strong"><em class="calibre8">could</em></span> do.</p><p class="calibre7">First, we have a variable called <code class="email">sine-wave</code>, which represents the 2D coordinates we will draw onto the web page. The next line gives us the intuition that <code class="email">sine-wave</code> is some sort of collection-like abstraction: we use <code class="email">.take</code> to retrieve 600 coordinates from it.</p><p class="calibre7">Finally, we <code class="email">.subscribe</code> to this "collection" by passing it a callback. This callback will be called for each item in the sine-wave, finally drawing at the given <span class="strong"><em class="calibre8">x</em></span> and <span class="strong"><em class="calibre8">y</em></span> coordinates using the <code class="email">fill-rect</code> function.</p><p class="calibre7">This is quite a bit to take in for now as we haven't seen any other code yet—but that was the point of this little exercise: even though we know nothing about the specifics of this example, we are able to develop an intuition of how it might work.</p><p class="calibre7">Let's see what else is necessary to make this snippet animate a sine wave on our screen.</p></div>

<div class="book" title="Chapter&#xA0;1.&#xA0;What is Reactive Programming?">
<div class="book" title="A taste of Reactive Programming"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch01lvl1sec08" class="calibre1"/>A taste of Reactive Programming</h1></div></div></div><p class="calibre7">This example is built in ClojureScript and <a id="id4" class="calibre1"/>uses HTML 5 Canvas for rendering and RxJS (see <a class="calibre1" href="https://github.com/Reactive-Extensions/RxJS">https://github.com/Reactive-Extensions/RxJS</a>)—a framework <a id="id5" class="calibre1"/>for Reactive Programming in JavaScript.</p><p class="calibre7">Before we start, keep in mind that we will not go into the details of these frameworks yet—that will happen later in this book. This means I'll be asking you to take quite a few things at face value, so don't worry if you don't immediately grasp how things work. The purpose of this example is to simply get us started in the world of Reactive Programming.</p><p class="calibre7">For this project, we will be using <a id="id6" class="calibre1"/>Chestnut (see <a class="calibre1" href="https://github.com/plexus/chestnut">https://github.com/plexus/chestnut</a>)—a leiningen template for ClojureScript that gives us a sample working application we can use as a skeleton.</p><p class="calibre7">To create our new project, head over to the command line and invoke leiningen as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">lein new chestnut sin-wave</strong></span>
<span class="strong"><strong class="calibre2">cd sin-wave</strong></span>
</pre></div><p class="calibre7">Next, we<a id="id7" class="calibre1"/> need to modify a couple of things in the generated project. Open up <code class="email">sin-wave/resources/index.html</code> and update it to look like the following:</p><div class="informalexample"><pre class="programlisting">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;link href="css/style.css" rel="stylesheet" type="text/css"&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div id="app"&gt;&lt;/div&gt;
    &lt;script src="/js/rx.all.js" type="text/javascript"&gt;&lt;/script&gt;
    &lt;script src="/js/app.js" type="text/javascript"&gt;&lt;/script&gt;
    &lt;canvas id="myCanvas" width="650" height="200" style="border:1px solid #d3d3d3;"&gt;
  &lt;/body&gt;
&lt;/html&gt;</pre></div><p class="calibre7">This simply ensures that we import both our application code and RxJS. We haven't downloaded RxJS yet so let's do this now. Browse to <a class="calibre1" href="https://github.com/Reactive-Extensions/RxJS/blob/master/dist/rx.all.js">https://github.com/Reactive-Extensions/RxJS/blob/master/dist/rx.all.js</a> and save this file to <code class="email">sin-wave/resources/public</code>. The previous snippets also add an HTML 5 Canvas element onto which we will be drawing.</p><p class="calibre7">Now, open <code class="email">/src/cljs/sin_wave/core.cljs</code>. This is where our application code will live. You can ignore what is currently there. Make sure you have a clean slate like the following one:</p><div class="informalexample"><pre class="programlisting">(ns sin-wave.core)

(defn main [])</pre></div><p class="calibre7">Finally, go back to the command line—under the <code class="email">sin-wave</code> folder—and start up the following application:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">lein run -m sin-wave.server</strong></span>
<span class="strong"><strong class="calibre2">2015-01-02 19:52:34.116:INFO:oejs.Server:jetty-7.6.13.v20130916</strong></span>
<span class="strong"><strong class="calibre2">2015-01-02 19:52:34.158:INFO:oejs.AbstractConnector:Started SelectChannelConnector@0.0.0.0:10555</strong></span>
<span class="strong"><strong class="calibre2">Starting figwheel.</strong></span>
<span class="strong"><strong class="calibre2">Starting web server on port 10555 .</strong></span>
<span class="strong"><strong class="calibre2">Compiling ClojureScript.</strong></span>
<span class="strong"><strong class="calibre2">Figwheel: Starting server at http://localhost:3449</strong></span>
<span class="strong"><strong class="calibre2">Figwheel: Serving files from '(dev-resources|resources)/public'</strong></span>
</pre></div><p class="calibre7">Once the previous command finishes, the application will be available at <code class="email">http://localhost:10555</code>, where you will find a blank, rectangular canvas. We are now ready to begin.</p><p class="calibre7">The main<a id="id8" class="calibre1"/> reason we are using the Chestnut template for this example is that it performs hot-reloading of our application code via websockets. This means we can have the browser and the editor side by side, and as we update our code, we will see the results immediately in the browser without having to reload the page.</p><p class="calibre7">To validate that this is working, open your web browser's console so that you can see the output of the scripts in the page. Then add this to <code class="email">/src/cljs/sin_wave/core.cljs</code> as follows:</p><div class="informalexample"><pre class="programlisting">(.log js/console "hello clojurescript")</pre></div><p class="calibre7">You should have seen the <code class="email">hello clojurescript</code> message printed to your browser's console. Make sure you have a working environment up to this point as we will be relying on this workflow to interactively build our application.</p><p class="calibre7">It is also a good idea to make sure we clear the canvas every time Chestnut reloads our file. This is simple enough to do by adding the following snippet to our core namespace:</p><div class="informalexample"><pre class="programlisting">(def canvas (.getElementById js/document "myCanvas"))
(def ctx    (.getContext canvas "2d"))


;; Clear canvas before doing anything else
(.clearRect ctx 0 0 (.-width canvas) (.-height canvas))</pre></div></div></div>

<div class="book" title="Chapter&#xA0;1.&#xA0;What is Reactive Programming?">
<div class="book" title="A taste of Reactive Programming">
<div class="book" title="Creating time"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch01lvl2sec07" class="calibre1"/>Creating time</h2></div></div></div><p class="calibre7">Now that <a id="id9" class="calibre1"/>we have a working environment, we can progress with our animation. It is probably a good idea to specify how often we would like to have a new animation frame.</p><p class="calibre7">This effectively means adding the concept of <span class="strong"><em class="calibre8">time</em></span> to our application. You're free to play with different values, but let's start with a new frame every 10 milliseconds:</p><div class="informalexample"><pre class="programlisting">(def interval   js/Rx.Observable.interval)
(def time       (interval 10))</pre></div><p class="calibre7">As RxJS is a JavaScript library, we need to use ClojureScript's interoperability to call its functions. For convenience, we bind the <code class="email">interval</code> function of RxJS to a local var. We will use this approach throughout this book when appropriate.</p><p class="calibre7">Next, we create an infinite stream of numbers—starting at 0—that will have a new element every 10 milliseconds. Let's make sure this is working as expected:</p><div class="informalexample"><pre class="programlisting">(-&gt; time
    (.take 5)
    (.subscribe (fn [n]
                  (.log js/console n))))

;; 0
;; 1
;; 2
;; 3
;; 4</pre></div><div class="informalexample" title="Note"><h3 class="title2"><a id="tip02" class="calibre1"/>Tip</h3><p class="calibre7">I use the term <span class="strong"><em class="calibre8">stream</em></span> very loosely here. It will be defined more precisely later in this book.</p></div><p class="calibre7">Remember time<a id="id10" class="calibre1"/> is infinite, so we use <code class="email">.take</code> in order to avoid indefinitely printing out numbers to the console.</p><p class="calibre7">Our next step is to calculate the 2D coordinate representing a segment of the sine wave we can draw. This will be given by the following functions:</p><div class="informalexample"><pre class="programlisting">(defn deg-to-rad [n]
  (* (/ Math/PI 180) n))

(defn sine-coord [x]
  (let [sin (Math/sin (deg-to-rad x))
        y   (- 100 (* sin 90))]
    {:x   x
     :y   y
     :sin sin}))</pre></div><p class="calibre7">The <code class="email">sine-coord</code> function takes an <code class="email">x</code> point of our 2D Canvas and calculates the <code class="email">y</code> point based on the sine of <code class="email">x</code>. The constants <code class="email">100</code> and <code class="email">90</code> simply control how tall and sharp the slope should be. As an example, try calculating the sine coordinate when <code class="email">x</code> is 50:</p><div class="informalexample"><pre class="programlisting">(.log js/console (str (sine-coord 50)))
;;{:x 50, :y 31.05600011929198, :sin 0.766044443118978}</pre></div><p class="calibre7">We will be using <code class="email">time</code> as the source for the values of <code class="email">x</code>. Creating the sine wave now is only a matter of combining both <code class="email">time</code> and <code class="email">sine-coord</code>:</p><div class="informalexample"><pre class="programlisting">(def sine-wave
  (.map time sine-coord))</pre></div><p class="calibre7">Just like <code class="email">time</code>, <code class="email">sine-wave</code> is an infinite stream. The difference is that instead of just integers, we will now have the <code class="email">x</code> and <code class="email">y</code> coordinates of our sine wave, as demonstrated in the following:</p><div class="informalexample"><pre class="programlisting">(-&gt; sine-wave
    (.take 5)
    (.subscribe (fn [xysin]
                  (.log js/console (str xysin)))))

 ;; {:x 0, :y 100, :sin 0} 
 ;; {:x 1, :y 98.42928342064448, :sin 0.01745240643728351} 
 ;; {:x 2, :y 96.85904529677491, :sin 0.03489949670250097} 
 ;; {:x 3, :y 95.28976393813505, :sin 0.052335956242943835} 
 ;; {:x 4, :y 93.72191736302872, :sin 0.0697564737441253} </pre></div><p class="calibre7">This<a id="id11" class="calibre1"/> brings us to the original code snippet which piqued our interest, alongside a function to perform the actual drawing:</p><div class="informalexample"><pre class="programlisting">(defn fill-rect [x y colour]
  (set! (.-fillStyle ctx) colour)
  (.fillRect ctx x y 2 2))

(-&gt; sine-wave
    (.take 600)
    (.subscribe (fn [{:keys [x y]}]
                  (fill-rect x y "orange"))))</pre></div><p class="calibre7">As this point, we can save the file again and watch as the sine wave we have just created gracefully appears on the screen.</p></div></div></div>

<div class="book" title="Chapter&#xA0;1.&#xA0;What is Reactive Programming?">
<div class="book" title="A taste of Reactive Programming">
<div class="book" title="More colors"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch01lvl2sec08" class="calibre1"/>More colors</h2></div></div></div><p class="calibre7">One of the points this example sets out to illustrate is how thinking in terms of very simple abstractions and then building more complex ones on top of them make for code that is <a id="id12" class="calibre1"/>simpler to maintain and easier to modify.</p><p class="calibre7">As such, we will now update our animation to draw the sine wave in different colors. In this case, we would like to draw the wave in red if the sine of <code class="email">x</code> is negative and blue otherwise.</p><p class="calibre7">We already have the sine value coming through the <code class="email">sine-wave</code> stream, so all we need to do is to transform this stream into one that will give us the colors according to the preceding criteria:</p><div class="informalexample"><pre class="programlisting">(def colour (.map sine-wave
                  (fn [{:keys [sin]}]
                    (if (&lt; sin 0)
                      "red"
                      "blue"))))</pre></div><p class="calibre7">The next step is to add the new stream into the main drawing loop—remember to comment the<a id="id13" class="calibre1"/> previous one so that we don't end up with multiple waves being drawn at the same time:</p><div class="informalexample"><pre class="programlisting">(-&gt; (.zip sine-wave colour #(vector % %2))
    (.take 600)
    (.subscribe (fn [[{:keys [x y]} colour]]
                  (fill-rect x y colour))))</pre></div><p class="calibre7">Once we save the file, we should see a new sine wave alternating between red and blue as the sine of <code class="email">x</code> oscillates from –1 to 1.</p></div></div></div>

<div class="book" title="Chapter&#xA0;1.&#xA0;What is Reactive Programming?">
<div class="book" title="A taste of Reactive Programming">
<div class="book" title="Making it reactive"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch01lvl2sec09" class="calibre1"/>Making it reactive</h2></div></div></div><p class="calibre7">As fun as this has been so far, the animation we have created isn't really reactive. Sure, it does react to time itself, but that is the very nature of animation. As we will later see, Reactive Programming is so called because programs react to external inputs such as mouse or network<a id="id14" class="calibre1"/> events.</p><p class="calibre7">We will, therefore, update the animation so that the user is in control of when the color switch occurs: the wave will start red and switch to blue when the user clicks anywhere within the canvas area. Further clicks will simply alternate between red and blue.</p><p class="calibre7">We start by creating infinite—as per the definition of <code class="email">time</code>—streams for our color primitives as follows:</p><div class="informalexample"><pre class="programlisting">(def red  (.map time (fn [_] "red")))
(def blue (.map time (fn [_] "blue")))</pre></div><p class="calibre7">On their own, <code class="email">red</code> and <code class="email">blue</code> aren't that interesting as their values don't change. We can think of them as <span class="strong"><em class="calibre8">constant</em></span> streams. They become a lot more interesting when combined with another infinite stream that cycles between them based on user input:</p><div class="informalexample"><pre class="programlisting">(def concat     js/Rx.Observable.concat)
(def defer      js/Rx.Observable.defer)
(def from-event js/Rx.Observable.fromEvent)


(def mouse-click (from-event canvas "click"))

(def cycle-colour
  (concat (.takeUntil red mouse-click)
          (defer #(concat (.takeUntil blue mouse-click)
                          cycle-colour))))</pre></div><p class="calibre7">This is our most complex update so far. If you look closely, you will also notice that <code class="email">cycle-colour</code> is a recursive stream; that is, it is defined in terms of itself.</p><p class="calibre7">When we first saw code of this nature, we took a leap of faith in trying to understand what it<a id="id15" class="calibre1"/> does. After a quick read, however, we realized that <code class="email">cycle-colour</code> follows closely how we might have <span class="strong"><em class="calibre8">talked</em></span> about the problem: we will use red until a mouse click occurs, after which we will use blue until another mouse click occurs. Then, we start the recursion.</p><p class="calibre7">The change to our animation loop is minimal:</p><div class="informalexample"><pre class="programlisting">(-&gt; (.zip sine-wave cycle-colour #(vector % %2))
    (.take 600)
    (.subscribe (fn [[{:keys [x y]} colour]]
                  (fill-rect x y colour))))</pre></div><p class="calibre7">The purpose of this book is to help you develop the instinct required to model problems in the way demonstrated here. After each chapter, more and more of this example will make sense. Additionally, a number of frameworks will be used both in ClojureScript and Clojure to give you a wide range of tools to choose from.</p><p class="calibre7">Before we move on to that, we must take a little detour and understand how we got here.</p></div></div></div>

<div class="book" title="Chapter&#xA0;1.&#xA0;What is Reactive Programming?">
<div class="book" title="A taste of Reactive Programming">
<div class="book" title="Exercise 1.1"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_5"><a id="ch01lvl2sec10" class="calibre1"/>Exercise 1.1</h2></div></div></div><p class="calibre7">Modify the previous example in such a way that the sine wave is drawn using all rainbow colors. The <a id="id16" class="calibre1"/>drawing loop should look like the following:</p><div class="informalexample"><pre class="programlisting">(-&gt; (.zip sine-wave rainbow-colours #(vector % %2))
    (.take 600)
    (.subscribe (fn [[{:keys [x y]} colour]]
                  (fill-rect x y colour))))</pre></div><p class="calibre7">Your task is to implement the <code class="email">rainbow-colours</code> stream. As everything up until now has been very light on explanations, you might choose to come back to this exercise later, once we have covered more about CES.</p><p class="calibre7">The <code class="email">repeat</code>, <code class="email">scan</code>, and <code class="email">flatMap</code> functions may be useful in solving this exercise. Be sure to consult RxJs' API at <a class="calibre1" href="https://github.com/Reactive-Extensions/RxJS/blob/master/doc/libraries/rx.complete.md">https://github.com/Reactive-Extensions/RxJS/blob/master/doc/libraries/rx.complete.md</a>.</p></div></div></div>

<div id="page" style="height:0pt"/><div class="book" title="A bit of history"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch01lvl1sec09" class="calibre1"/>A bit of history</h1></div></div></div><p class="calibre7">Before we talk <a id="id17" class="calibre1"/>about what Reactive Programming is, it is important to understand how other relevant programming paradigms influenced how we develop software. This will also help us understand the motivations behind reactive programming.</p><p class="calibre7">With few <a id="id18" class="calibre1"/>exceptions most of us have been taught—either self-taught or at school/university—imperative programming languages such as C and Pascal or object-oriented languages such as Java and C++.</p><p class="calibre7">In both cases, the imperative programming paradigm—of which object-oriented languages are part—dictates we write programs as a series of statements that modify program state.</p><p class="calibre7">In order to understand what this means, let's look at a short program written in pseudo-code that calculates the sum and the mean value of a list of numbers:</p><div class="informalexample"><pre class="programlisting">numbers := [1, 2, 3, 4, 5, 6]
sum := 0
for each number in numbers
  sum := sum + number
end
mean := sum / count(numbers)</pre></div><div class="informalexample" title="Note"><h3 class="title2"><a id="tip03" class="calibre1"/>Tip</h3><p class="calibre7">The mean value is the average of the numbers in the list, obtained by dividing the sum by the number of elements.</p></div><p class="calibre7">First, we create a new array of integers, called <code class="email">numbers</code>, with numbers from 1 to 6, inclusive. Then, we initialize <code class="email">sum</code> to zero. Next, we iterate over the array of integers, one at a time, adding to <code class="email">sum</code> the value of each number.</p><p class="calibre7">Lastly, we calculate and assign the average of the numbers in the list to the <code class="email">mean</code> local variable. This concludes the program logic.</p><p class="calibre7">This program would print 21 for the sum and 3 for the mean, if executed.</p><p class="calibre7">Though a simple example, it highlights its imperative style: we set up an application state—<code class="email">sum</code>—and then explicitly tell the computer how to modify that state in order to calculate the result.</p></div>

<div class="book" title="A bit of history">
<div class="book" title="Dataflow programming"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch01lvl2sec11" class="calibre1"/>Dataflow programming</h2></div></div></div><p class="calibre7">The<a id="id19" class="calibre1"/> previous example has an interesting property: the value of <code class="email">mean</code> clearly has a dependency on the contents of <code class="email">sum</code>.</p><p class="calibre7">Dataflow programming<a id="id20" class="calibre1"/> makes this relationship explicit. It models applications as a dependency graph through which data flows—from operation to operation—and as values change, these changes are propagated to its dependencies.</p><p class="calibre7">Historically, dataflow programming has been supported by custom-built languages such as Lucid and BLODI, as such, leaving other general purpose programming languages out.</p><p class="calibre7">Let's see<a id="id21" class="calibre1"/> how this new insight would impact our previous example. We know that once the last line gets executed, the value of <code class="email">mean</code> is assigned<a id="id22" class="calibre1"/> and won't change unless we explicitly reassign the variable.</p><p class="calibre7">However, let's imagine for a second that the pseudo-language we used earlier does support dataflow programming. In that case, assigning <code class="email">mean</code> to an expression that refers to both <code class="email">sum</code> and <code class="email">count</code>, such as <code class="email">sum / count(numbers)</code>, would be enough to create the directed dependency graph in the following diagram:</p><div class="mediaobject"><img src="../images/00003.jpeg" alt="Dataflow programming" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre7">Note that a direct side effect of this relationship is that an implicit dependency from <code class="email">sum</code> to <code class="email">numbers</code> is also created. This means that if <code class="email">numbers</code> change, the change is propagated through the graph, first updating <code class="email">sum</code> and then finally updating <code class="email">mean</code>.</p><p class="calibre7">This is where Reactive Programming comes in. This paradigm builds on dataflow programming and change propagation to bring this style of programming to languages that don't have native support for it.</p><p class="calibre7">For imperative programming languages, Reactive Programming can be made available via libraries or language extensions. We don't cover this approach in this book, but should the reader <a id="id23" class="calibre1"/>want more information on the subject, please refer to <span class="strong"><em class="calibre8">dc-lib</em></span> (see <a class="calibre1" href="https://code.google.com/p/dc-lib/">https://code.google.com/p/dc-lib/</a>) for an example. It is a framework<a id="id24" class="calibre1"/> that adds Reactive Programming <a id="id25" class="calibre1"/>support to C++ via dataflow constraints.</p></div></div>

<div class="book" title="A bit of history">
<div class="book" title="Object-oriented Reactive Programming"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch01lvl2sec12" class="calibre1"/>Object-oriented Reactive Programming</h2></div></div></div><p class="calibre7">When designing interactive applications such as desktop <span class="strong"><strong class="calibre2">Graphical User Interfaces</strong></span> (<span class="strong"><strong class="calibre2">GUIs</strong></span>), we are essentially using an object-oriented approach to Reactive Programming. We will<a id="id26" class="calibre1"/> build a<a id="id27" class="calibre1"/> simple calculator application <a id="id28" class="calibre1"/>to demonstrate this style.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="tip04" class="calibre1"/>Tip</h3><p class="calibre7">Clojure isn't an object-oriented language, but we will be interacting with parts of the Java API to build user interfaces that were developed in an OO paradigm, hence the title of this section.</p></div><p class="calibre7">Let's start by creating a new leiningen project from the command line:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">lein new calculator</strong></span>
</pre></div><p class="calibre7">This will create a directory called <code class="email">calculator</code> in the current folder. Next, open the <code class="email">project.clj</code> file in your favorite text editor and add a dependency on Seesaw, a Clojure library for working with Java Swing:</p><div class="informalexample"><pre class="programlisting">(defproject calculator "0.1.0-SNAPSHOT"
  :description "FIXME: write description"
  :url "http://example.com/FIXME"
  :license {:name "Eclipse Public License"
            :url "http://www.eclipse.org/legal/epl-v10.html"}
  :dependencies [[org.clojure/clojure "1.5.1"]
<span class="strong"><strong class="calibre2">                 [seesaw "1.4.4"]</strong></span>]) </pre></div><p class="calibre7">At the time of this writing, the latest Seesaw version available is 1.4.4.</p><p class="calibre7">Next, in the <code class="email">src/calculator/core.clj</code> file, we'll start by requiring the Seesaw library and creating the visual components we'll be using:</p><div class="informalexample"><pre class="programlisting">(ns calculator.core
  (:require [seesaw.core :refer :all]))

(native!)

(def main-frame (frame :title "Calculator" :on-close :exit))

(def field-x (text "1"))
(def field-y (text "2"))

(def result-label (label "Type numbers in the boxes to add them up!"))</pre></div><p class="calibre7">The <a id="id29" class="calibre1"/>preceding snippet creates a window with the title <code class="email">Calculator</code> that ends the program when <a id="id30" class="calibre1"/>closed. We also create two text input fields, <code class="email">field-x</code> and <code class="email">field-y</code>, as well as a label that will be used to display the results, aptly named <code class="email">result-label</code>.</p><p class="calibre7">We would like the label to be updated automatically as soon as a user types a new number in any of the input fields. The following code does exactly that:</p><div class="informalexample"><pre class="programlisting">(defn update-sum [e]
  (try
    (text! result-label
         (str "Sum is " (+ (Integer/parseInt (text field-x))
                           (Integer/parseInt (text field-y)))))
    (catch Exception e
      (println "Error parsing input."))))

(listen field-x :key-released update-sum)
(listen field-y :key-released update-sum)</pre></div><p class="calibre7">The first function, <code class="email">update-sum</code>, is our event handler. It sets the text of <code class="email">result-label</code> to the sum of the values in <code class="email">field-x</code> and <code class="email">field-y</code>. We use try/catch here as a really basic way to handle errors since the key pressed might not have been a number. We then add the event handler to the <code class="email">:key-released</code> event of both input fields.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="tip05" class="calibre1"/>Tip</h3><p class="calibre7">In real applications, we never want a catch block such as the previous one. This is considered bad style, and the catch block should do something more useful such as logging the exception, firing a notification, or resuming the application if possible.</p></div><p class="calibre7">We are almost done. All we need to do now is add the components we have created so far to our <code class="email">main-frame</code> and finally display it as follows:</p><div class="informalexample"><pre class="programlisting">(config! main-frame :content
         (border-panel
          :north (horizontal-panel :items [field-x field-y])
          :center result-label
          :border 5))

(defn -main [&amp; args]
  (-&gt; main-frame pack! show!))</pre></div><p class="calibre7">Now we can save the file and run the program from the command line in the project's root directory:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">lein run -m calculator.core</strong></span>
</pre></div><p class="calibre7">You should see something like the following screenshot:</p><div class="mediaobject"><img src="../images/00004.jpeg" alt="Object-oriented Reactive Programming" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre7">Experiment by typing some numbers in either or both text input fields and watch how the value<a id="id31" class="calibre1"/> of the <a id="id32" class="calibre1"/>label changes automatically, displaying the sum of both numbers.</p><p class="calibre7">Congratulations! You have just created your first reactive application!</p><p class="calibre7">As alluded to previously, this application is reactive because the value of the result label <span class="strong"><em class="calibre8">reacts</em></span> to user input and is updated automatically. However, this isn't the whole story—it lacks in composability and requires us to specify the how, not the what of what we're trying to achieve.</p><p class="calibre7">As familiar as this style of programming may be, making applications reactive this way isn't always ideal.</p><p class="calibre7">Given previous discussions, we notice we still had to be fairly explicit in setting up the relationships between the various components as evidenced by having to write a custom handler and bind it to both input fields.</p><p class="calibre7">As we will see throughout the rest of this book, there is a much better way to handle similar scenarios.</p></div></div>

<div class="book" title="A bit of history">
<div class="book" title="The most widely used reactive program"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch01lvl2sec13" class="calibre1"/>The most widely used reactive program</h2></div></div></div><p class="calibre7">Both examples in the previous section will feel familiar to some readers. If we call the input <a id="id33" class="calibre1"/>text fields "cells" and the result label's handler a "formula", we now have<a id="id34" class="calibre1"/> the nomenclature used in modern spreadsheet applications such as Microsoft Excel.</p><p class="calibre7">The term Reactive Programming has only been in use in recent years, but the idea of a reactive application isn't new. The first electronic spreadsheet dates back to 1969 when Rene Pardo and Remy Landau, then recent graduates from Harvard University, created <span class="strong"><strong class="calibre2">LANPAR</strong></span> (<span class="strong"><strong class="calibre2">LANguage for Programming Arrays at Random</strong></span>) [1].</p><p class="calibre7">It was<a id="id35" class="calibre1"/> invented to solve a problem that Bell Canada and AT&amp;T had at the time: their <a id="id36" class="calibre1"/>budgeting forms had 2000 cells that, when modified, forced a software re-write taking anywhere from six months to two years.</p><p class="calibre7">To this day, electronic spreadsheets remain a powerful and useful tool for professionals of various fields.</p></div></div>

<div class="book" title="A bit of history">
<div class="book" title="The Observer design pattern"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch01lvl2sec14" class="calibre1"/>The Observer design pattern</h2></div></div></div><p class="calibre7">Another similarity the keen reader may have noticed is with the Observer design pattern. It is mainly used in object-oriented applications as a way for objects to communicate with each <a id="id37" class="calibre1"/>other without having <a id="id38" class="calibre1"/>any knowledge of who depends on its changes.</p><p class="calibre7">In Clojure, a simple version of the Observer pattern can be implemented using <span class="strong"><em class="calibre8">watches</em></span>:</p><div class="informalexample"><pre class="programlisting">(def numbers (atom []))

(defn adder [key ref old-state new-state]
  (print "Current sum is " (reduce + new-state)))

(add-watch numbers :adder adder)</pre></div><p class="calibre7">We start by creating our program state, in this case an atom holding an empty vector. Next, we create a watch function that knows how to sum all numbers in <code class="email">numbers</code>. Finally, we add our watch function to the numbers atom under the <code class="email">:adder</code> key (useful for removing watches).</p><p class="calibre7">The <code class="email">adder</code> key conforms with the API contract required by <code class="email">add-watch </code>and receives four arguments. In this example, we only care about <code class="email">new-state</code>.</p><p class="calibre7">Now, whenever we update the value of <code class="email">numbers</code>, its watch will be executed, as demonstrated in the following:</p><div class="informalexample"><pre class="programlisting">(swap! numbers conj 1)
<span class="strong"><strong class="calibre2">;; Current sum is  1</strong></span>

(swap! numbers conj 2)
<span class="strong"><strong class="calibre2">;; Current sum is  3</strong></span>

(swap! numbers conj 7)
<span class="strong"><strong class="calibre2">;; Current sum is  10</strong></span>
</pre></div><p class="calibre7">The highlighted lines above indicate the result that is printed on the screen each time we update the atom.</p><p class="calibre7">Though <a id="id39" class="calibre1"/>useful, the Observer <a id="id40" class="calibre1"/>pattern still requires some amount of work in setting up the dependencies and the required program state in addition to being hard to compose.</p><p class="calibre7">That being said, this pattern has been extended and is at the core of one of the Reactive Programming frameworks we will look at later in this book, Microsoft's <span class="strong"><strong class="calibre2">Reactive Extensions</strong></span> (<span class="strong"><strong class="calibre2">Rx</strong></span>).</p></div></div>

<div class="book" title="A bit of history">
<div class="book" title="Functional Reactive Programming"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_5"><a id="ch01lvl2sec15" class="calibre1"/>Functional Reactive Programming</h2></div></div></div><p class="calibre7">Just like <a id="id41" class="calibre1"/>Reactive Programming, <span class="strong"><strong class="calibre2">Functional Reactive Programming</strong></span>—<span class="strong"><strong class="calibre2">FRP</strong></span> for short—has unfortunately become an overloaded<a id="id42" class="calibre1"/> term.</p><p class="calibre7">Frameworks such as RxJava (see <a class="calibre1" href="https://github.com/ReactiveX/RxJava">https://github.com/ReactiveX/RxJava</a>), ReactiveCocoa (see <a class="calibre1" href="https://github.com/ReactiveCocoa/ReactiveCocoa">https://github.com/ReactiveCocoa/ReactiveCocoa</a>), and Bacon.js (see <a class="calibre1" href="https://baconjs.github.io/">https://baconjs.github.io/</a>) became extremely popular in recent years and had positioned<a id="id43" class="calibre1"/> themselves<a id="id44" class="calibre1"/> incorrectly as FRP libraries. This<a id="id45" class="calibre1"/> led to the confusion surrounding the terminology.</p><p class="calibre7">As we will see, these frameworks do not implement FRP but rather are inspired by it.</p><p class="calibre7">In the interest of using the correct terminology as well as understanding what "inspired by FRP" means, we will have a brief look at the different formulations of FRP.</p></div></div>

<div class="book" title="A bit of history">
<div class="book" title="Higher-order FRP"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_6"><a id="ch01lvl2sec16" class="calibre1"/>Higher-order FRP</h2></div></div></div><p class="calibre7">Higher-order FRP refers to the original research on FRP developed by Conal Elliott and Paul Hudak<a id="id46" class="calibre1"/> in their paper <span class="strong"><em class="calibre8">Functional Reactive Animation</em></span> [2] from 1997. This paper presents <span class="strong"><em class="calibre8">Fran</em></span>, a domain-specific language <a id="id47" class="calibre1"/>embedded in Haskell for creating reactive animations. It has since been implemented in several languages as a library as well as purpose built reactive languages.</p><p class="calibre7">If you recall the calculator example we created a few pages ago, we can see how that style of Reactive Programming requires us to manage state explicitly by directly reading and writing from/to the input fields. As Clojure developers, we know that avoiding state and mutable data is a good principle to keep in mind when building software. This principle is at the core of Functional Programming:</p><div class="informalexample"><pre class="programlisting">(-&gt;&gt; [1 2 3 4 5 6]
     (map inc)
     (filter even?)
     (reduce +))
;; 12</pre></div><p class="calibre7">This<a id="id48" class="calibre1"/> short program increments by one all<a id="id49" class="calibre1"/> elements in the original list, filters all even numbers, and adds them up using <code class="email">reduce</code>.</p><p class="calibre7">Note how we didn't have to explicitly manage local state through at each step of the computation.</p><p class="calibre7">Differently from imperative programming, we focus on what we want to do, for example iteration, and not how we want it to be done, for example using a <code class="email">for</code> loop. This is why the implementation matches our description of the program closely. This is known as declarative programming.</p><p class="calibre7">FRP brings the same philosophy to Reactive Programming. As the Haskell programming language wiki on the subject has wisely put it:</p><p class="calibre7"><span class="strong"><em class="calibre8">FRP is about handling time-varying values like they were regular values.</em></span></p><p class="calibre7">Put another way, FRP is a declarative way of modeling systems that respond to input over time.</p><p class="calibre7">Both statements touch on the concept of time. We'll be exploring that in the next section, where we introduce the key abstractions provided by FRP: signals (or behaviors) and events.</p></div></div>
<div class="book" title="Signals and events"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch01lvl1sec10" class="calibre1"/>Signals and events</h1></div></div></div><p class="calibre7">So far we <a id="id50" class="calibre1"/>have been dealing with the idea of programs that react to user input. This is<a id="id51" class="calibre1"/> of course only a small subset of reactive systems but is enough for the purposes of this discussion.</p><p class="calibre7">User input happens several times through the execution of a program: key presses, mouse drags, and clicks are but a few examples of how a user might interact with our system. All these interactions happen over a period of time. FRP recognizes that time is an important aspect of reactive programs and makes it a first-class citizen through its abstractions.</p><p class="calibre7">Both signals (also called behaviors) and events are related to time. Signals represent continuous, time-varying values. Events, on the other hand, represent discrete occurrences<a id="id52" class="calibre1"/> at <a id="id53" class="calibre1"/>a given point in time.</p><p class="calibre7">For example, time is itself a signal. It varies continuously and indefinitely. On the other hand, a key press by a user is an event, a discrete occurrence.</p><p class="calibre7">It is important to note, however, that the semantics of how a signal changes need not be continuous. Imagine a signal that represents the current (x,y) coordinates of your mouse pointer.</p><p class="calibre7">This signal is said to change discretely as it depends on the user moving the mouse pointer—an event—which isn't a continuous action.</p></div>

<div id="page" style="height:0pt"/><div class="book" title="Implementation challenges"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch01lvl1sec11" class="calibre1"/>Implementation challenges</h1></div></div></div><p class="calibre7">Perhaps the most defining characteristic of classical FRP is the use of continuous time.</p><p class="calibre7">This means FRP assumes that signals are changing all the time, even if their value is still the same, leading to needless recomputation. For example, the mouse position signal will trigger updates to the application dependency graph—like the one we saw previously for<a id="id54" class="calibre1"/> the mean program—even when the mouse is stationary.</p><p class="calibre7">Another problem is that classical FRP is synchronous by default: events are processed in order, one at a time. Harmless at first, this can cause delays, which would render an application unresponsive should an event take substantially longer to process.</p><p class="calibre7">Paul Hudak and others furthered research on higher-order FRP [7] [8] to address these issues, but that came at the cost of expressivity.</p><p class="calibre7">The other formulations of FRP aim to overcome these implementation challenges.</p><p class="calibre7">Throughout the rest of the chapter, I'll be using signals and behaviors interchangeably.</p></div>

<div class="book" title="Implementation challenges">
<div class="book" title="First-order FRP"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch01lvl2sec17" class="calibre1"/>First-order FRP</h2></div></div></div><p class="calibre7">The most <a id="id55" class="calibre1"/>well-known reactive language in this <a id="id56" class="calibre1"/>category<a id="id57" class="calibre1"/> is Elm (see <a class="calibre1" href="http://elm-lang.org/">http://elm-lang.org/</a>), an <a id="id58" class="calibre1"/>FRP language that compiles to JavaScript. It was created by Evan Czaplicki and presented in his paper <span class="strong"><em class="calibre8">Elm: Concurrent FRP for Functional GUIs</em></span> [3].</p><p class="calibre7">Elm makes some significant changes to higher-order FRP.</p><p class="calibre7">It abandons<a id="id59" class="calibre1"/> the idea of continuous time <a id="id60" class="calibre1"/>and is entirely event-driven. As a result, it solves the problem of needless recomputation highlighted earlier. First-order FRP combines both behaviors and events into signals which, in contrast to higher-order FRP, are discrete.</p><p class="calibre7">Additionally, first-order FRP allows the programmer to specify when synchronous processing of events isn't necessary, preventing unnecessary processing delays.</p><p class="calibre7">Finally, Elm is a strict programming language—meaning arguments to functions are evaluated eagerly—and that is a conscious decision as it prevents space and time leaks, which are possible in a lazy language such as Haskell.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="tip06" class="calibre1"/>Tip</h3><p class="calibre7">In an FRP library such as Fran, implemented in a lazy language, memory usage can grow unwieldy as computations are deferred to the absolutely last possible moment, therefore causing a space leak. These larger computations, accumulated over time due to laziness, can then cause unexpected delays when finally executed, causing time leaks.</p></div></div></div>

<div class="book" title="Implementation challenges">
<div class="book" title="Asynchronous data flow"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch01lvl2sec18" class="calibre1"/>Asynchronous data flow</h2></div></div></div><p class="calibre7">Asynchronous <a id="id61" class="calibre1"/>Data Flow generally refers to frameworks such <a id="id62" class="calibre1"/>as <span class="strong"><strong class="calibre2">Reactive Extensions</strong></span> (<span class="strong"><strong class="calibre2">Rx</strong></span>), <span class="strong"><strong class="calibre2">ReactiveCocoa</strong></span>, and <span class="strong"><strong class="calibre2">Bacon.js</strong></span>. It is <a id="id63" class="calibre1"/>called as such as it completely eliminates synchronous updates.</p><p class="calibre7">These <a id="id64" class="calibre1"/>frameworks introduce the concept of <span class="strong"><strong class="calibre2">Observable Sequences</strong></span> [4], sometimes <a id="id65" class="calibre1"/>called Event Streams.</p><p class="calibre7">This<a id="id66" class="calibre1"/> formulation of FRP has the advantage of not being confined to functional languages. Therefore, even imperative languages like Java can take advantage of this style of programming.</p><p class="calibre7">Arguably, these frameworks were responsible for the confusion around FRP terminology. Conal Elliott at some point suggested the term CES (see <a class="calibre1" href="https://twitter.com/conal/status/468875014461468677">https://twitter.com/conal/status/468875014461468677</a>).</p><p class="calibre7">I have since adopted this terminology (see <a class="calibre1" href="http://vimeo.com/100688924">http://vimeo.com/100688924</a>) as I believe it highlights two important factors:</p><div class="book"><ul class="itemizedlist"><li class="listitem">A fundamental <a id="id67" class="calibre1"/>difference between CES and FRP: CES is <a id="id68" class="calibre1"/>entirely event-driven</li><li class="listitem">CES is highly composable via combinators, taking inspiration from FRP</li></ul></div><p class="calibre7">CES <a id="id69" class="calibre1"/>is the main focus of this <a id="id70" class="calibre1"/>book.</p></div></div>

<div class="book" title="Implementation challenges">
<div class="book" title="Arrowized FRP"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch01lvl2sec19" class="calibre1"/>Arrowized FRP</h2></div></div></div><p class="calibre7">This is the last formulation we will look at. Arrowized FRP [5] introduces two main differences over <a id="id71" class="calibre1"/>higher-order FRP: it uses signal functions instead of <a id="id72" class="calibre1"/>signals and is built on top of John Hughes' Arrow combinators [6].</p><p class="calibre7">It is mostly about a different way of structuring code and can be implemented as a library. As an example, Elm <a id="id73" class="calibre1"/>supports Arrowized FRP via its Automaton (see <a class="calibre1" href="https://github.com/evancz/automaton">https://github.com/evancz/automaton</a>) library.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="tip07" class="calibre1"/>Tip</h3><p class="calibre7">The first draft of this chapter grouped the different formulations of FRP under the broad categories of <span class="strong"><em class="calibre8">Continuous and Discrete</em></span> FRP. Thanks to Evan Czaplicki's excellent talk <span class="strong"><em class="calibre8">Controlling Time and Space: understanding the many formulations of FRP</em></span> (see <a class="calibre1" href="https://www.youtube.com/watch?v=Agu6jipKfYw">https://www.youtube.com/watch?v=Agu6jipKfYw</a>), I was able to borrow the more specific categories used here. These come in handy when discussing the different approaches to FRP.</p></div></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Applications of FRP"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch01lvl1sec12" class="calibre1"/>Applications of FRP</h1></div></div></div><p class="calibre7">The different FRP formulations are being used today in several problem spaces by professionals and big organizations alike. Throughout this book, we'll look at several examples of how CES can be applied. Some of these are interrelated as most modern programs have several cross-cutting concerns, but we will highlight two main areas.</p></div>

<div class="book" title="Applications of FRP">
<div class="book" title="Asynchronous programming and networking"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch01lvl2sec20" class="calibre1"/>Asynchronous programming and networking</h2></div></div></div><p class="calibre7">GUIs are a<a id="id74" class="calibre1"/> great example of asynchronous<a id="id75" class="calibre1"/> programming. Once you open a web or a desktop application, it simply sits there, idle, waiting for user input.</p><p class="calibre7">This state is often called the event or main event loop. It is simply waiting for external stimuli, such as a key press, a mouse button click, new data from the network, or even a simple timer.</p><p class="calibre7">Each <a id="id76" class="calibre1"/>of these stimuli is associated with an <a id="id77" class="calibre1"/>event handler that gets called when one of these events happen, hence the asynchronous nature of GUI systems.</p><p class="calibre7">This is a style of programming we have been used to for many years, but as business and user needs grow, these applications grow in complexity as well, and better abstractions are needed to handle the dependencies between all the components of an application.</p><p class="calibre7">Another great example that deals with managing complexity around network traffic is Netflix, which <a id="id78" class="calibre1"/>uses CES to provide a reactive API to their backend services.</p></div></div>

<div class="book" title="Applications of FRP">
<div class="book" title="Complex GUIs and animations"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch01lvl2sec21" class="calibre1"/>Complex GUIs and animations</h2></div></div></div><p class="calibre7">Games <a id="id79" class="calibre1"/>are, perhaps, the best example of complex user interfaces<a id="id80" class="calibre1"/> as they have intricate requirements around user input and animations.</p><p class="calibre7">The Elm language we mentioned before is one of the most exciting efforts in building complex GUIs. Another example is <a id="id81" class="calibre1"/>Flapjax, also targeted at web applications, but is provided as a JavaScript library that can be integrated with existing JavaScript code bases.</p></div></div>
<div class="book" title="Summary"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch01lvl1sec13" class="calibre1"/>Summary</h1></div></div></div><p class="calibre7">Reactive Programming is all about building responsive applications. There are several ways in which we can make our applications reactive. Some are old ideas: dataflow programming, electronic spreadsheets, and the Observer pattern are all examples. But CES in particular has become popular in recent years.</p><p class="calibre7">CES aims to bring to Reactive Programming the declarative way of modeling problems that is at the core of Functional Programming. We should worry about what and not about how.</p><p class="calibre7">In next chapters, we will learn how we can apply CES to our own programs.</p></div></body></html>