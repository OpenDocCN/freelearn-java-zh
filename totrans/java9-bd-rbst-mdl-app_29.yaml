- en: DeskDroid - A Desktop Client for Your Android Phone
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've come at long last to our final project. To close our time together here,
    we're going to build a very practical application, one that lets us send and receive
    SMS messages from the comfort of our desktop. There are a number of products on
    the market that let you do this now, but they typically require a third-party
    service, meaning your message travels through someone else's servers. For the
    privacy-minded, that can be a real problem. We'll build a system that is 100%
    local.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'Building the app will cover several different topics, some familiar, some new.
    That list includes the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Android applications
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Android services
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: REST servers
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Server-sent events for event/data streaming
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data access using Content Providers
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There will also be a host of other, smaller tidbits along the way as we finish
    out our time together on a strong, high note.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: Getting started
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This project will have two parts:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: The Android application/server (not to be confused with application server,
    of course)
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The desktop/JavaFX application
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The desktop piece is somewhat useless without the **server** piece, so we'll
    start by building the Android side first.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Android project
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While we have been using NetBeans for most of our work so far, we will again
    use Android Studio for this piece of the project. While there is some semblance
    of Android support for NetBeans, as of this writing, the project seems to have
    stalled. Android Studio, on the other hand, is very actively developed by Google
    and is, in fact, the official IDE for Android development. I will leave it as
    an exercise for the reader, if needed, to install the IDE and the SDK.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a new project, we click on File | New Project, and specify Application
    name, Company domain, and Project location, as shown in the following screenshot:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/40d38df6-07a4-40e1-8936-599fc2cc81fc.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
- en: 'Next, we need to specify the API version we want to target. This can be a tricky
    choice. On the one hand, we''d like to be on the cutting edge and have all of
    the great new features that Android offers available to us, but on the other hand,
    we don''t want to target such a new API level that we make the application unusable
    (read uninstallable) for a larger number of Android users than is necessary. In
    this case, Android 6.0, or Marshmallow, seems like an acceptable trade-off:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3fcfe029-ebb7-40ca-9b03-abb856bc76b2.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
- en: Click on Next, select Blank Activity, Next, and Finish, and our project is ready
    for development.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: On the Android side, we are not going to do much in the way of user interface.
    Once we have finished the project, you will likely have all sorts of ideas of
    what could be done, which is great, but we won't spend the time here doing any
    of those. That said, the first thing we really need to do is ask the user for
    permission to access the text messages on their phone.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: Requesting permissions
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In earlier versions of Android, permissions were an all or nothing proposition.
    Starting with Android 6, though, the user is prompted for each permission that
    the application requests, allowing for the possibility of a user to grant some
    permissions while denying others. We will need to request some permissions--we
    need to be able to read and write SMS messages, and we''ll need access to the
    contacts (so we can try to figure out who sent us a given message). Android provides
    an API for requesting those permissions very easily, which we''ll put in our `onCreate()`
    method, as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Android 的早期版本中，权限是一个全有或全无的提议。然而，从 Android 6 开始，对于应用程序请求的每个权限，用户都会被提示，这允许用户授予一些权限同时拒绝其他权限。我们需要请求一些权限——我们需要能够读取和写入短信消息，并且我们需要访问联系人（这样我们就可以尝试找出谁给我们发送了特定的消息）。Android
    提供了一个非常容易请求这些权限的 API，我们将在 `onCreate()` 方法中实现，如下所示：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: When this preceding code runs, Android will prompt the user to grant or deny
    the requested permissions. This is done asynchronously, so, in your applications,
    you need to make sure you don't attempt any operation that requires any permission
    that you request until the user has had a chance to grant the permission (and,
    should the user deny the permission, the application should degrade, or fail,
    gracefully).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当这段前置代码运行时，Android 会提示用户授予或拒绝请求的权限。这是异步进行的，因此，在你的应用程序中，你需要确保在用户有机会授予权限之前，不要尝试任何需要你请求的权限的操作（如果用户拒绝权限，应用程序应该优雅地降级或失败）。
- en: 'To allow the application to respond to permission grants, Android provides
    a callback. In our callback, we want to make sure the user grants us both permissions:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 为了允许应用程序响应权限授予，Android 提供了一个回调。在我们的回调中，我们想要确保用户授予我们两个权限：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: When Android calls back in to our application, we need to make sure that the
    `requestCode` is what we specified-- `PERMISSION_REQUEST_CODE`--to make sure that
    we only respond to our own requests.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Android 回调到我们的应用程序时，我们需要确保 `requestCode` 是我们指定的——`PERMISSION_REQUEST_CODE`——以确保我们只响应我们自己的请求。
- en: Once we've identified an appropriate response, we make sure that `grantResults`
    is the correct length, and that each entry is `PERMISSION_GRANTED`. If the array
    is too short, or if either array element is not the correct type, we display a
    dialog informing the user that both permissions are required, and then exit the
    application.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们确定了适当的响应，我们确保 `grantResults` 的长度正确，并且每个条目都是 `PERMISSION_GRANTED`。如果数组太短，或者如果任一数组元素不是正确的类型，我们将显示一个对话框通知用户需要这两个权限，然后退出应用程序。
- en: In our example, we are requesting both permissions simultaneously, so we respond
    to both simultaneously. If you have a complex set of permissions, for example,
    if your application can work with only some of the requested permissions, you
    can make multiple calls to `ActivityCompat.requestPermissions`, providing a distinct
    `requestCode` for each. You would then need to expand your switch block in `onRequestPermissionsResult()`
    to cover each new `requestCode`.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们同时请求这两个权限，因此我们同时响应。如果你有一组复杂的权限，例如，如果你的应用程序只能使用请求的一些权限，你可以多次调用 `ActivityCompat.requestPermissions`，为每个提供不同的
    `requestCode`。然后你需要扩展 `onRequestPermissionsResult()` 中的 switch 块，以覆盖每个新的 `requestCode`。
- en: 'One final word on permissions. Typically, you should always check to make sure
    that you have the permission needed to perform a given task. You can do that with
    a method as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 最后关于权限的问题。通常情况下，你应该始终检查以确保你有执行特定任务所需的权限。你可以使用以下方法来完成：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In our case, we just don't allow the application to run if we aren't granted
    the required permissions, so we need not worry about additional permission checks.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，如果我们没有得到所需的权限，我们就不允许应用程序运行，因此我们不需要担心额外的权限检查。
- en: Creating the service
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建服务
- en: The heart of the Android portion of the project is our REST endpoints. We would
    like these endpoints to be available whenever the phone is on, so we can't use
    an `Activity` to host them. What we want is a `Service`. The Android documentation
    defines a `Service` as *an application component that can perform long-running
    operations in the background, and it does not provide a user interface*. There
    are three types of Services--`scheduled` (which runs on a schedule), `started`
    (which can be started explicitly by another application component), and `bound`
    (which is bound to an application component via the `bindService()` call, and
    runs until all the bound components are destroyed). Since we want this to be available
    all the time, we want a started service.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 项目中Android部分的精髓是我们的REST端点。我们希望这些端点在手机开启时始终可用，因此我们不能使用`Activity`来托管它们。我们想要的是一个`Service`。Android文档将`Service`定义为*一种可以在后台执行长时间运行操作的应用程序组件，并且它不提供用户界面*。有三种类型的Service--`计划`（按计划运行）、`启动`（可以被其他应用程序组件显式启动）和`绑定`（通过`bindService()`调用绑定到应用程序组件，直到所有绑定组件被销毁为止）。由于我们希望它始终可用，我们想要一个启动服务。
- en: 'To create the service, click on File | New | Service | Service. Enter `DeskDroidService`
    for the service, uncheck Exported, and click on Finish. That will get you the
    following stubbed code:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建服务，请点击文件 | 新建 | 服务 | 服务。为服务输入`DeskDroidService`，取消勾选导出，然后点击完成。这将生成以下示例代码：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The wizard also updates `AndroidManifest.xml` as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 向导还会按如下方式更新`AndroidManifest.xml`：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The method `onBind()` is abstract, so it must be implemented. We are not creating
    a bound service, so we can leave this unimplemented, although we will change it
    so that it returns `null` rather than throwing an `Exception`. We are, though,
    interested in when the service is started and stopped, so we need to override
    these two relevant lifecycle methods:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`onBind()`方法是抽象的，因此必须实现。我们不是创建一个绑定服务，所以我们可以将其留空不实现，尽管我们将更改它，使其返回`null`而不是抛出`Exception`。然而，我们对服务启动和停止的时间感兴趣，因此我们需要重写这两个相关生命周期方法：'
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'It''s in these methods that we''ll place our REST service code. We will once
    again use Jersey, the JAX-RS reference implementation, which provides a nice way
    of bootstrapping a server in a Java SE environment, such as what we find ourselves
    in here in our Android application. We''ll encapsulate that logic in a new method
    called `startServer()` as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在这些方法中放置我们的REST服务代码。我们再次使用Jersey，JAX-RS的参考实现，它为在Java SE环境中启动服务器提供了一种很好的方式，就像我们在Android应用程序中找到的那样。我们将把这个逻辑封装在一个名为`startServer()`的新方法中，如下所示：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The first thing we do is check to make sure that we're on Wi-Fi. This isn't
    strictly necessary, but it seemed to be a prudent precaution to prevent the application
    from listening for connections, regardless of the network state. If the phone
    is not on Wi-Fi, there's a good chance the intended laptop is not either. There
    may be legitimate use cases for allowing the endpoints to listen even on a cellular
    network, however. Making this restriction configurable is a great candidate for
    a preferences-driven option.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先确保我们正在使用Wi-Fi。这并不是绝对必要的，但似乎是一个谨慎的预防措施，以防止应用程序在无论网络状态如何的情况下监听连接。如果手机没有连接Wi-Fi，那么目标笔记本电脑很可能也没有。然而，可能存在允许端点在蜂窝网络上监听的有效用例。将此限制设置为可配置的是偏好驱动选项的一个很好的候选。
- en: 'For this code to work, we need to add this new permission to the manifest:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使此代码能够正常工作，我们需要在清单文件中添加这个新的权限：
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Once we're sure that we're on Wi-Fi, we look up our IP address, and bootstrap
    a Jetty-based Jersey server. With a nod to the Venerable Commodore 64, for those
    of us old enough to remember that computing pioneer, we listen on port `49152`
    on the Wi-Fi network interface.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们确定正在使用Wi-Fi，我们查找我们的IP地址，并启动一个基于Jetty的Jersey服务器。向那些还记得这位计算先驱的尊敬的指挥官64致敬，对于那些足够老的人来说，我们在Wi-Fi网络接口上监听端口`49152`。
- en: Next, we create a `ResourceConfig` instance, providing two feature references
    that we're interested in--`SseFeature` and `JacksonFeature`. We've already seen
    `JacksonFeature`; that's what lets us work with POJOs, leaving the JSON concerns
    to Jersey. What is `SseFeature`, though?
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个`ResourceConfig`实例，提供我们感兴趣的两种功能引用--`SseFeature`和`JacksonFeature`。我们已经看到了`JacksonFeature`；这正是让我们能够处理POJOs，将JSON问题留给Jersey的功能。那么，`SseFeature`是什么呢？
- en: Server-sent events
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务器端事件
- en: SSE, or server-sent events, is a means by which we can stream data from the
    server to the client. Typically, a REST request is very short-lived--make a connection,
    send the request, get a response, close the connection. Sometimes, though, the
    REST server may not have all of the data that the client wants at the time of
    the request (for example, reading data from another data source such as a log
    file or network socket). So, it would be nice to be able to push that data to
    the client as it becomes available. That's exactly what SSE allows us to do. We'll
    look into that in more detail later.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: SSE，或服务器发送事件，是我们可以从服务器向客户端流式传输数据的一种方式。通常，REST请求的生命周期非常短暂——建立连接，发送请求，获取响应，关闭连接。有时，尽管如此，REST服务器可能没有在请求时客户端所需的所有数据（例如，从另一个数据源读取数据，如日志文件或网络套接字）。因此，能够将那些数据在它们可用时推送到客户端将是非常好的。这正是SSE允许我们做到的。我们将在稍后更详细地探讨这一点。
- en: 'Finally, we start the server instance with a call to `JettyHttpContainerFactory.createServer()`.
    Since we need to be able to stop the server later, we capture the server instance,
    and store it in an instance variable. We call `startServer()` from `onStartCommand()`
    as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过调用`JettyHttpContainerFactory.createServer()`来启动服务器实例。由于我们需要能够在以后停止服务器，我们捕获服务器实例，并将其存储在一个实例变量中。我们从`onStartCommand()`中调用`startServer()`，如下所示：
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Notice that we've wrapped our call to `startServer()` in a `synchronized` block.
    For those that might be unaware, `synchronized` is one of the more basic approaches
    to concurrent code available to Java developers. The net effect of this keyword
    is that multiple threads that try to execute this block of code must do so synchronously,
    or one a time. We do this here so that if we have two different processes attempting
    to start the server, we can guarantee that at most one is running. Without this
    block, the first thread could start the server and store the instance in the variable,
    while a second thread could do the same thing, but its server instance, which
    gets stored in the variable, fails to start. We would now have a running server
    with no valid reference to it, so we would be unable to stop it.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们已经将`startServer()`的调用包裹在一个`synchronized`块中。对于那些可能不知道的人来说，`synchronized`是Java开发者可用的更基本的并发代码方法之一。这个关键字的效果是，尝试执行此代码块的多线程必须同步执行，或者一次一个。我们在这里这样做是为了确保如果有两个不同的进程试图启动服务器，我们可以保证最多只有一个正在运行。如果没有这个块，第一个线程可能会启动服务器并将实例存储在变量中，而第二个线程可能会做同样的事情，但它的服务器实例，存储在变量中的，无法启动。现在我们会有一个正在运行的服务器，但没有有效的引用，因此我们将无法停止它。
- en: We have also registered a `BroadcastReceiver` that listens for `CODE_GENERATED`.
    We'll come back and explain this later in the chapter, so don't worry about this
    for now.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还注册了一个监听`CODE_GENERATED`的`BroadcastReceiver`。我们将在本章稍后解释这一点，所以现在不用担心。
- en: Controlling the service state
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制服务状态
- en: 'If we run the application now, our service won''t run, so we need to make it
    such that it will run. We''ll do that in a couple of different ways. The first
    way will be from our application. We want to make sure the service is running
    when we open the application, especially after it is just installed. To do that,
    we need to add one line to `MainActivity.onCreate()` as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在运行应用程序，我们的服务将不会运行，因此我们需要确保它能够运行。我们将通过几种不同的方式来实现这一点。第一种方式将来自我们的应用程序。我们想要确保在打开应用程序时服务正在运行，尤其是在它刚刚安装之后。为此，我们需要在`MainActivity.onCreate()`中添加一行，如下所示：
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'When the application is started now, it will guarantee that the service is
    running. We don''t, though, want to require that the user open the application
    to run the service. Fortunately, we have a way to start the application when the
    phone starts. We can do that by installing a `BroadcastReceiver` that listens
    for boot events, as shown here:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序现在启动时，它将保证服务正在运行。但我们不希望用户打开应用程序来运行服务。幸运的是，我们有一种在手机启动时启动应用程序的方法。我们可以通过安装一个监听启动事件的`BroadcastReceiver`来实现这一点，如下所示：
- en: '[PRE10]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The body of the preceding method is identical to our recent addition to `MainActivity`.
    We do, though, need to register the service, and ask for permission. In `AndroidManifest.xml`,
    we need to add this:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 上述方法的主体与我们在`MainActivity`中最近添加的内容相同。不过，我们需要注册服务并请求权限。在`AndroidManifest.xml`中，我们需要添加以下内容：
- en: '[PRE11]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We now have a service that starts either at device boot or application startup.
    It does not, however, do anything of interest, so we need to add some endpoints
    to our server.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个在设备启动或应用程序启动时启动的服务。然而，它并没有做任何有趣的事情，因此我们需要向我们的服务器添加一些端点。
- en: Adding endpoints to the server
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As covered in [Chapter 25](0813704c-2f66-4efa-bbef-f0147dcfb059.xhtml), *Taking
    Notes with Monumentum*, a JAX-RS resource lives in a POJO with certain annotations.
    To stub out our endpoint class, we can start with this:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We will also need to register this class with JAX-RS, which we do with this
    line in `startServer()`:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Ordinarily, we would pass, say, `DeskDroidResource.class`, to the `ResourceConfig`
    constructor, like we did with `JacksonFeature.class`. We will be accessing Android
    resources, and to do that, we're going to need the `Service`'s `Context` instance.
    There are a number of resources on the internet that will suggest creating a custom
    `Application` class and storing it in a `public static`. While that does seem
    to work, it will also leak memory, so, Android Studio, for example, will complain
    if you try that. We can, however, avoid that by using nested classes. That approach
    can get a bit unwieldy, but our classes should be small enough that it remains
    manageable.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: Getting conversations
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start by adding an endpoint to get all of the conversations on the phone,
    as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Here is where we see the Android artifacts start to show up--we are going to
    use a `ContentProvider` to access the SMS data. A `ContentProvider` is a way for
    an application, or, in this case, an Android subsystem, to expose data to outside
    consumers in a portable, storage-agnostic manner. We don't care how the data is
    stored. We simply specify what fields we want, what filters or restrictions we
    want placed on that data, and `ContentProvider` does the rest.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: Using `ContentProvider`s, we specify the type of data not by a table name, like
    we would with SQL, but with a `Uri`. In this case, we specify `Telephony.Sms.Conversations.CONTENT_URI`.
    We pass several null values to `query()` as well. These represent the projection
    (or field list), the selection (or filter), the selection arguments, and the sort
    order. Since these are all `null`, we want every field and every row in the natural
    sort order for the provider. That gets us a `Cursor` object, which we then iterate
    over, creating `Conversation` objects, and add them to our `List`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: 'We create the `Conversation` instances with this method:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This method, and the processing logic, is mostly identical to that for conversations.
    The `Uri` for the `ContentProvider`, `Telephony.Sms.CONTENT_URI`, is different,
    of course, and we specify a filter for the query as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We do have a slight bit of data analysis here. We need to know which of the
    messages are the ones we sent and which are the ones we received so that we can
    display the thread more meaningfully. On the device, the messages we've sent have
    the type `Telephony.Sms.MESSAGE_TYPE_SENT`. The values for this field translate
    roughly to folders (sent, received, draft, and so on). Rather than leaking part
    of the Android API into ours by sharing the value of the constant, we have a `boolean`
    field, `isMine`, which is true if the message is of type `MESSAGE_TYPE_SENT`.
    It is, admittedly, a slightly clumsy alternative, but it works and should be clear
    enough.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: Once we return the list of messages, we iterate over the list, getting a list
    of the unique participants (which should be only one, since we are dealing with
    SMS messages).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we return this `List<Conversation>` to the client using Jersey''s
    POJO-mapping feature as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '![](img/8df486ff-1ee8-4e2d-a573-fa7d55e4e23c.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
- en: 'If we click either the run or debug buttons (the large triangle or the triangle-over-a-bug
    icons in the tool bar), you''ll be asked for the deployment target, as seen in
    this screenshot:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6a7f7e2a-55a8-4da0-a587-5bb8b4550558.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
- en: 'Since we require Wi-Fi, I select my physical device. If you want to configure
    an emulator with Wi-Fi, that would work as well. Click on OK, and after a few
    moments, the application should start on the device you have selected, and we
    can make our first REST request as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This preceding sample code shows a conversation I'm having with myself. Too
    many late nights, perhaps, but you can see where the first message, the oldest
    message, is marked as mine, which is the one I sent to myself, and the second
    is where I received it back. Pretty cool, but how do you send a message? It turns
    out that that's actually quite simple.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: Sending an SMS message
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To send a message, we will create a POST endpoint that takes a `Message` object,
    which we'll then pull apart and pass to Android's telephony APIs.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'There''s a lot going on this method. Here is the breakdown:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: We get a reference to the `SmsManager` class. This class will do all of the
    work for us.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We ask `SmsManager` to divide the message for us. Text messages are, typically,
    limited to 160 characters, so this will split the message as needed.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We create a `CountDownLatch` with a count that matches the number of parts in
    the message.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We create an `AtomicInteger` to store the status code. As we'll see in a moment,
    we need to change the value of this variable from inside an anonymous class. However,
    for an anonymous class to access variables from its enclosing scope, those variables
    must be `final`, which means that we can not have a `final int`, as then we would
    not be able to change the value. With `AtomicInteger`, though, we can call `set()`
    to change the value while leaving the instance reference, which is what the variable
    will hold, unchanged.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We create a new `BroadcastReceiver`, which will handle `Intent`s broadcast (as
    we'll see further) when the message is sent. In `onReceive()`, if the result code
    is not `ACTIVITY.RESULT_OK`, we call `AtomicInteger.set()` to reflect the failure.
    We then call `sentLatch.countDown()` to indicate that this message part has been
    processed.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the call to `registerReceiver()`, we let the operating system know about
    our new receiver. We provide an `IntentFilter` to restrict which `Intents` our
    receiver has to process.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We then create a new `PendingIntent` for each part our message has been split
    into. This will allow us to react to each part's send attempt individually.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We call `sendMultipartTextMessage()` to send the message part(s). Android handles
    the details of a multipart message for us, so there's no extra effort required.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We need to wait for all of the message parts to be sent, so we call `sentLatch.await()`
    to give the system time to send the message. We don't want to wait forever, though,
    so we give it a timeout of five seconds, which should be long enough. It is conceivable
    that some networks may be very slow about sending text messages, so this value
    may need to be adjusted.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once we pass the latch, we `unregister` our receiver, and return the status
    code.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Using curl again, we can now test sending a message (be sure to click on `Run`
    or `Debug` again to deploy your updated code):'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In the preceding `curl` we send some `lorem ipsum` text to our recipient, which
    gives us a nice, long message (482 total characters for the request payload),
    which is correctly chunked up and sent to the destination phone number, as indicated
    by the `201 Created` response status.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: We now have a working REST service on the phone, which lets us read the existing
    messages and send new ones. Interacting with the service with `curl` has worked
    well enough, but it's time to build our desktop client, and put a nice face on
    this project.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: Creating the desktop application
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To build our application, we''ll return to NetBeans and JavaFX. As in the previous
    chapters, we''ll create a new Maven-based JavaFX application by clicking on File
    | New Project:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/095f8c0e-ab8f-4125-9dbe-96ff4dbe62a5.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
- en: In the next step, call the project `deskdroid-desktop`, verify the package name,
    and click on Finish. While not strictly necessary, let's clean up the naming a
    bit, changing the controller to `DeskDroidController`, and the FXML file to `deskdroid.fxml`.
    We'll also need to modify the references to the FXML and the CSS in the controller,
    and the reference to the controller in the FXML. Click on Run | Run Project to
    make sure everything is wired up correctly. Once the app starts, we can immediately
    close it so we can start making changes.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: Defining the user interface
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start by building up the user interface. Here''s what the application
    will look like:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4278a3b2-cead-4ecd-ac27-f4a1989c87ef.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
- en: In the preceding screen, we'll have our list of conversations on the left, and
    we will display the selected conversation on the right. We will add a mechanism
    for auto-refreshing, but the Refresh Conversations will allow for a manual refresh,
    if needed. New Message should be self-explanatory.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use Gluon''s Scene Builder to build the user interface, of course, but
    let''s take a look at the FXML. We''ll start, as usual, with a `BorderPane`, as
    follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'For the `top` section, we''re going to add a menu bar as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We''ll have three `MenuItem`s in the `FileMenu`: `connectToPhone`, `disconnectFromPhone`,
    and `Exit`. Each menu item will have a mnemonic, as indicated by the underscores.
    The `ExitMenuItem` has an accelerator key, `ALT-F4`.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll put the bulk of the user interface in the `center` section. The vertical
    split allows us to resize the two sides of the user interface. For that, we use
    a `SplitPane` as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'With `dividerPositions`, we set the default split at the 25% mark along the
    horizontal rule. The `SplitPane` has a nested `items` element to hold its children
    to which we add the left element, `ListView`:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We wrap `ListView` in a `VBox` to make the `ListView` grow and shrink, as needed,
    more easily.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let''s build the right side of the user interface:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'On the right side, we also have a `VBox`, which we use to arrange our two user
    interface elements. The first is `HBox`, which holds two buttons: Refresh Conversation
    and New Message. The second is our `ListView` for displaying the selected conversation.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: Defining user interface behavior
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While we can define the structure of the user interface in FXML in all but
    the most trivial applications, the user interface still requires some Java code
    to finish defining its behavior. We''ll do that now in `DeskDroidController.initialize()`.
    We''ll start with the left side of the user interface, the conversation list,
    as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We declare an injectable variable to hold a reference to our `ListView`. JavaFX
    will set that value for us, thanks to the annotation `@FXML`. `ListView` will
    need a model to display, which we declare as `conversations`, and we declare `conversation`
    to hold the currently selected conversation.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: In the `initialize()` method, we wire everything together. Since `ListView`
    will be displaying our domain object, we need to declare a `CellFactory` for it,
    which we do with the lambda passed to `setCellFactory()`. We'll look at `ListCell`
    in a moment.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: Next, we associate `ListView` with its model, `conversations`, and define what
    is, in effect, an `onClick` listener. We achieve that, though, by adding a listener
    to `SelectionModel` on `ListView`. In that listener, we update the currently selected
    conversation, update the messages `ListView` to display the conversation, and
    scroll that `ListView` to the very bottom so that we see the most recent message.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: 'Initializing the message `ListView` is much simpler. We need these instance
    variables:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We also need these lines in `initialize()`:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'And the New Message button needs a handler:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '`ConversationCell` tells JavaFX how to display a `Conversation` instance. To
    do that, we create a new `ListCell` child as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Then we override `updateItem()`:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: If the cell is given a `Conversation`, we process it. If not, we set the cell's
    graphic to null. If we fail to do that, we'll have unpredictable results when
    scrolling through the lists.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: 'To build the cell contents, we start by getting the `Participant` and creating
    the wrapper component as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This is pretty standard JavaFX fare--create an `HBox`, and add to it an `ImageView`.
    We are, though, using a class we haven't looked at yet--`ConversationService`.
    We'll look at this later, but for now, it's enough to know that we will encapsulate
    our REST calls in this class. Here, we're calling an endpoint (that we haven't
    seen yet) to get the contact information for the phone number at the other end
    of this conversation.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need to create the conversation snippet as follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Using `VBox` to ensure vertical alignment, we create two labels, one with the
    participants' information, and the other with the snippet of the conversation.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: 'While that finishes the cell definition, if we were to run the application
    the way it is now, the `ListCell`''s contents would likely be cropped by the edge
    of `ListView` itself. For example, see the difference between the top list and
    the bottom list in the following screenshot:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3c21078d-c23b-4f6a-9700-2d0bf3b12872.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
- en: 'To make our `ListCell` behave as we see at the bottom of the last screen, we
    need to make one more change to our code, which is as follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In our preceding `CellFactory`, we pass in the reference to the enclosing `ListView`.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In the constructor, we then bind the preferred width of our cell to the actual
    width of the list (and subtract a small amount to adjust for the control borders).
    When rendered now, our cell will wrap just as we expected.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: 'The `MessageCell` definition is similar, and goes as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'For *my* message, we create the contents this way:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The *their* message is created this way:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This is similar to the *my* message, with the exception that we display the
    sender's profile picture, if there is one associated with the contact on the phone,
    which we retrieve from the phone via the `ConversationService` class.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: 'We have a bit more work to do, but this is what the application will look like
    with data:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2e658425-c23c-4c95-8cf0-843f21db6233.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
- en: 'To get the data, we need a REST client, and that is found in `ConversationService`:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Using the so-called *Initialize-on-Demand Holder* idiom, we create a sort of
    a poor man''s singleton. Since the constructor is private, it can''t be called
    from outside this class. The nested static class, `LazyHolder`, is initialized
    only when it is finally referenced, which happens on the first call to `getInstance()`.
    Once that method is called, `LazyHolder` is loaded and initialized, at which point,
    the constructor is run. The instance created is stored in the static variable,
    and lives as long as the JVM runs. Every subsequent call will return the same
    instance. This is important for us, as we have some objects that are expensive
    to create as well as some simple caching in the class:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: In the preceding code, we initialize our client instance, registering the `JacksonFeature`,
    which gets us the POJO mapping we've already discussed. We also register `SseFeature`,
    a more advanced feature of Jersey that we'll discuss in detail later.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ve already seen the conversation list. That is generated using data from
    this method:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '`WebTarget` is a JAX-RS class that represents the *resource target identified
    by the resource URI*. We''re pulling the address for the phone from preferences,
    which we''ll discuss later. Once we have our `WebTarget`, we complete building
    the URI by appending `conversations`, specify the request mime type, and issue
    the `GET` request. Note that our request here is somewhat optimistic, as we don''t
    do any status code checking. Should an `Exception` be thrown, we simply return
    an empty `List`.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: 'The other method we''ve seen is `getParticipant()`, which is as follows:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: In the last method, we see our cache come into play. When a `Participant` is
    requested, we look to see if this information has already been fetched. If so,
    we return the cached information. If not, we can make a request for it.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: Much like `getConversations(),` we build a request for the appropriate endpoint,
    and send the `GET` request. This time, though, we do check for the status code.
    Only if the status is `200 (OK)` do we continue processing the response. In this
    case, we ask JAX-RS for the `Participant` instance returned, which `JacksonFeature`
    happily builds for us from the JSON response body, and which we immediately add
    to our cache.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: If the server found a thumbnail for the contact, we need to process that. The
    server piece, which we will look at immediately after we finish discussing this
    method, sends the thumbnail as a base 64-encoded string in the body of the JSON
    object, so we convert it back to the binary representation, and save that to a
    file. Notice that we are using try-with-resources, so we need not worry about
    cleaning up after ourselves.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We haven''t seen the server side of this operation, so let''s look at that
    now. In our Android application in Android Studio, we have this method on `DeskDroidResource`:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: We attempt to build the `Participant` instance. If an Exception is thrown, we
    return a `500` (Server Error). If `null` is returned, we return a `404` (Not Found).
    If a participant is found, we return `200` (OK) and the participant.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: 'To build the participant, we need to query the phone contacts. This works in
    much the same way as the SMS queries:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The preceding is the same type of query and cursor management that we saw earlier
    with conversations, but there is one exception. If the contact has a thumbnail,
    the query returns a `Uri` to that image. We can use `ContentResolver` to open
    an `InputStream` using that `Uri` to read the contents, which we load into `ByteArrayOutputStream`.
    Using Android's `Base64` class, we encode this binary image into a `String`, and
    add that to our `Participant` model. We saw the decoding half of this operation
    previously.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: Sending messages
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we can see the conversations that we''ve been having, we need to add
    the ability to take part in those conversations--to send new text messages. We''ll
    start on the client. We''ve actually already seen the handler for the `New Message`
    button assigned. It is as follows:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'What we need to do now is to look at this `sendNewMessage()` method itself:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The actual dialog is displayed in another window, so we have a separate FXML
    file, `message_dialog.fxml`, and controller, `SendMessageDialogController`. When
    the dialog closes, we check the return `Optional` to see if the user entered a
    message. If so, process the message as follows:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: Get a reference to the selected `Conversation`.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new message, setting the conversation ID, recipient, and body.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Using `ConversationService`, we attempt to send the message:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If successful, we update the user interface with the new message.
  id: totrans-196
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: If unsuccessful, we display an error message.
  id: totrans-197
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`SendMessageController` works just like the other controllers we''ve looked
    at. The most interesting is the method `showAndWait()`. We''ll use that method
    to show the dialog, wait for it to close, and return any user response to the
    caller. The dialog looks as follows:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/aa10e162-71fb-425f-9087-69c8e4abe267.png)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
- en: 'The method looks as follows:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The first few lines in the preceding method are what we''ve normally seen,
    which is creating the loader and the `Stage`. Before showing the `Stage`, we set
    the modality, and pass in the current `Conversation`. Finally, we call `showAndWait()`,
    at which point the method blocks until the user closes the dialog, and then we
    return the entered message:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: A Java `Optional` is a *container object which may or may not contain a non-null
    value*. The value of `message` may or may not be set depending on which button
    is clicked in the dialog. Using the `Optional`, we can return a, possibly, null
    value, and handle it more safely in the caller--`if (result.isPresent())`.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: 'The sending of the message is a simple POST operation in the `ConversationService`,
    which is as follows:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The client side is simple, but what about the server side? Unsurprisingly,
    that''s where the complexity lies:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: To add the endpoint, we define a new method with the correct annotations. This
    method will listen on the path `conversations` for `POST` requests, and expect
    a `Message` as its payload. The actual work of sending a message is handled by
    `SmsManager`, so we acquire a reference to the default manager. The next step
    calls `divideMessage()`, but what's that all about?
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: Text messages are technically limited to 160 characters. Twitter users are probably
    somewhat familiar with that already. Twitter limits tweets to 140 characters,
    leaving 20 characters for the sender's name. While Twitter has stuck hard to that
    limit, regular SMS users have a better experience. If the message is longer than
    160 characters, most modern phones will chunk the message into 153 character segments
    when sending (with 7 characters for segmentation information used to piece the
    segments back together), which are merged back into one message on the receiving
    end if the phone supports it. The `SmsManager` API handles this complexity for
    us with `divideMessage()`.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the message is *chunked*, though, our job gets a little more difficult.
    We would like to be able to return a status code indicating whether or not the
    message was sent successfully. To do that, we need to check the status of each
    chunk of the message, be it one or ten. Sending a text message with `SmsManager`,
    Android broadcasts an `Intent` with the results. To react to that, we need to
    register a receiver. Put that all together, and we get this code:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: To make sure that we've received the `Intent` for each message chunk, we start
    by creating a `CountDownLatch` with a count matching the number of chunks in the
    message. We also create an `AtomicInteger` to hold the status code. The reason
    we do this is that we need a final variable which we can access from our `BroadcastReceiver`,
    but we also need to be able to change the value. `AtomicInteger` allows us to
    do that.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: We create and register a `BroadcastReceiver`, which analyzes the result code
    on `Intent`. If it's not `Activity.RESULT_OK`, we set `statusCode` to `INTERNAL_SERVER_ERROR`.
    Either way, we count down the latch.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: With our receiver ready, we create a `List` of `PendingIntent`s, one for each
    chunk, then we pass that, with our list of message chunks, to `SmsManager.sendMultipartTextMessage()`.
    Message sending is asynchronous, so we call `sentLatch.await()` to wait for the
    results to be returned. We limit the wait to five seconds so that we don't wait
    forever. Once the wait time expires or the latch is cleared, we unregister our
    receiver and return the status code.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: Getting updates
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we can see all of the conversations, view individual messages in a conversation,
    and send new messages. What we can't do yet is get updates when new messages arrive
    on the device, so let's implement that now, starting with the server piece this
    time.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: 'To get a constant stream of events, we''ll use a feature called Server-Sent
    Events, a W3C specification for receiving push notifications from the server.
    We enabled this feature in Jersey by registering the `SseFeature` in both the
    client and server setup steps. To create an SSE endpoint, we specify that the
    method returns the media type `SERVER_SENT_EVENTS`, and we return an `EventOutput`
    as the payload:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'From the Jersey documentation, we learn this:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: After the eventOutput is returned from the method, the Jersey runtime recognizes
    that this is a ChunkedOutput extension and does not close the client connection
    immediately. Instead, it writes the HTTP headers to the response stream and waits
    for more chunks (SSE events) to be sent. At this point the client can read headers
    and starts listening for individual events.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: 'The server, then, keeps the socket to the client open, and pushes data down
    it. But where does the data come from? The Server-sent Event endpoints create
    a `Thread` that writes data to the `EventOutput` instance we created earlier.
    When the `Thread` is finished, it calls `eventOutput.close()`, which signals to
    the runtime that it is appropriate to close the client connection. To stream updates,
    our `Thread` looks as follows:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: As we've seen before, we set up a `BroadcastReceiver`, which we register here
    and unregister before the `Thread` ends, but this time, we're listening for broadcasts
    that an SMS message has been received. To make sure our `Thread` isn't in a small,
    tight, fast loop, which would quickly kill the battery on the device, we use `LinkedBlockingQueue`.
    When a message is received, we pull the `SmsMessage`(s) from `Intent`, and add
    them to `queue`. In our while loop, we attempt to `take()` an item from `queue`.
    If we find one, we process it and any more that might either already be in the
    queue or be added while we are processing. Once `queue` is empty, we go back to
    waiting. We have a timeout on `take()` to make sure that the thread can respond
    to the exit criteria, most notably, the client disconnecting. This will run as
    long as the client remains connected. Let's look, then, at the client.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: 'We encapsulated the details in `ConversationService.subscribeToNewMessageEvents()`
    as follows:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: In the preceding code, we create a `Thread`, in which we make the call to the
    SSE endpoint. The return type on the client is `EventInput`. We loop to process
    each incoming event, which we get as an `InboundEvent`. If it is null, then the
    connection has been closed, so we break out of our processing loop. If it is not
    null, we make sure that the event name matches what we're waiting for--`new-message`.
    If found, we extract the event payload, a `Message`, and call our callback, which
    we pass in as `Consumer<Message>`.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: 'From the application proper, we subscribe to the status stream this way:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '`handleMessageReceived()` looks like this:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The first step in handling this new message is very important--we pass a `Runnable`
    to `Platform.runLater()`. If we don't do this, any attempts to modify the user
    interface will fail. You have been warned. In our `Runnable`, we create a `Stream`
    of `Conversation`s, `filter()` it, looking for a `Conversation` whose participant
    matches the `Message` sender, then grab the first (and only) match.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: If we don't find the `Conversation` in the list, we create a new one, and add
    it to the `ConversationObservable`, which results in the `List` automatically
    updating on the screen.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we attempt a couple of desktop integration tasks. If `Taskbar` supports
    the `USER_ATTENTION` feature, we request user attention. From the Javadocs we
    learn that, *depending on the platform, this may be visually indicated by a bouncing
    or flashing icon in the task area*. Regardless, we issue a beep to get the user's
    attention.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: Security
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There's one last major piece that we haven't discussed, and that's security.
    Currently, anybody with the desktop application can, in theory, connect to your
    phone, see your messages, send others, and so on. Let's fix that now.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: Securing the endpoints
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To secure the REST server, we will use a filter just like we used in [Chapter
    25](0813704c-2f66-4efa-bbef-f0147dcfb059.xhtml), *Taking Notes with Monumentum*.
    We''ll start by defining the annotation that will specify which endpoints need
    to be secured, as follows:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'We will apply this preceding annotation to each secured endpoint (annotations
    condensed to one line for brevity):'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'We will also need a filter to enforce security, which we add as follows:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Much like in [Chapter 25](0813704c-2f66-4efa-bbef-f0147dcfb059.xhtml), *Taking
    Notes with Monumentum*, we''ll be using **JSON Web Tokens** (**JWT**) to help
    authenticate and authorize clients. In this filter, we extract the JWT from the
    request headers and validate it through these steps:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: Get the signing key from `KeyGenerator`.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the `JwtParser` using the signing key.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Parse the claims in the JWT. For our purposes here, this is, basically, just
    a validation of the token itself.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Abort the request with `UNAUTHORIZED` (`401`) should the token be invalid.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `KeyGenerator` itself looks a bit like what we saw in [Chapter 25](0813704c-2f66-4efa-bbef-f0147dcfb059.xhtml),
    *Taking Notes with Monumentum*, but has been modified to use Android APIs in this
    manner:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Since we might possibly receive requests from multiple clients at a time, we
    need to be careful about how the key is generated. To make sure it's done once
    and only once, we'll use the same type of synchronization/locking we saw in the
    server startup.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: Once we've acquired the lock, we perform a null check to see if the process
    has already generated (or read) the key. If not, we then read the signing key
    from `SharedPreferences`. If it's null, we create a random string (here, just
    a UUID), and save it to `SharedPreferences` for reuse next time. Note that to
    save to Android preferences, we have to get an instance of `SharedPreferences.Editor`,
    write the string, then `commit()`. Once we have the signing key, we create the
    actual `SecretKeySpec` that we'll use to sign and verify our JWTs.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: Handling authorization requests
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With our endpoints now secured, we need a way for the clients to request authorization.
    To do that, we''ll expose a new endpoint, unsecured, of course, as follows:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Rather than require a more complicated authorization system that might require
    a username and password or an OAuth2 provider, what we''ll implement is a simple
    system that requires only a random number:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: On the phone, the user requests that a new client be added, and is presented
    with a random number.
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the desktop application, the user enters the number, which the desktop application
    then POSTs to the server.
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the numbers match, the client is given a JWT, which it will send with every
    request.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The JWT is verified each time to make sure the client is authorized to access
    the target resource.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this method, we get the number POSTed by the client (which we let JAX-RS
    extract from the request body), then compare it to the number generated on the
    phone. If they match, we create the JWT, and return it to the client. Before doing
    so, we broadcast an intent with the action `CODE_ACCEPTED`.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: 'Where does the number come from, and why are we broadcasting this intent? We
    haven''t looked at this in detail yet, but in the main layout, `activity_main.xml`,
    there is a `FloatingActionButton`. To this, we attach an `onClick` listener as
    follows:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'When the user taps on the button, the following screen will be shown:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6ee9cc7e-5b78-4b88-a9eb-da7ab9851a8e.png)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
- en: 'The client will use this information to connect and gain authorization. The
    `Activity` itself is fairly basic. It needs to present the IP address and code,
    and then respond to a client connecting. All of this is done in `onCreate()` in
    our new `AuthorizeClientActivity` class. We get the IP from `WifiManager`:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Remember that we require that the client be on a Wi-Fi network. The code is
    just a random, 6-digit number:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'To listen for the `Intent` we saw earlier, which indicates that a client has
    been authenticated (which, presumably, will happen shortly after this `Activity`
    has been displayed), we register another receiver as follows:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'We also need to tell the `Service` what this new code is so that it can verify
    it. To do that, we broadcast an `Intent` as follows:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: We've already seen the other half of this broadcast in `DeskDroidService.onStartCommand()`
    earlier, where the code is retrieved from the `Intent`, and stored in the service
    for use by `DeskDroidResource.getAuthorization()`.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, this method, which handles the authentication notice, simply cleans
    up the receiver and closes the `Activity`:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: With this, when a client connects and successfully authenticates, the `Activity`
    closes, and the user is returned to the main `Activity`.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: Authorizing the client
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up until this point, everything has assumed that the desktop is already connected
    to the phone. We have enough pieces in place now that we can talk about that in
    a meaningful manner.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: 'In the application''s main `Menu`, we have two `MenuItem`s: `Connect to Phone`
    and `Disconnect from Phone`. The `Connect to Phone` handler looks as follows:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'We''re going to use the now-familiar `showAndWait()` pattern to display a modal
    dialog, and to get the response using the new `ConnectToPhoneController`. The
    user interface is very simple, and is shown in this screenshot:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/195ad74a-3937-4595-980c-321fd1d35bec.png)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
- en: 'When the user clicks on OK, we save the address and the code in the application''s
    preferences, then attempt to authorize against the server, as follows:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Notice the use of `Optional<String>` as the return type for `ConversationService.getAuthorization()`.
    Using `Optional`, as we've discussed before, makes working with potentially `null`
    values much safer. In this case, if `Optional` has a value present, then we've
    successfully authenticated. So, we save the token to preferences, and close the
    dialog.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: 'The actual authentication is handled by `ConversationService`:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: This last method sends the code to the server via a `POST`, and if the status
    code is `200`, we create an `Optional` with the returned token. Otherwise, we
    return an empty `Optional`.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-291
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we built a different kind of project. We've had applications
    that run on Android, and some that run on the desktop. This one, though, runs
    on both platforms simultaneously. One is no good without the other. That requires
    that we build things a bit differently to make sure the two are synchronized.
    While there are a variety of ways to go about this, we chose to use a REST server
    on the phone, with the desktop acting as a REST client.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: By the end of the chapter, we built an Android application that provides not
    only a user interface, but a background process (called `Service`), and embedded
    our REST server in the Android application using Jersey and its Java SE deployment
    option. You also learned how to interact with text (SMS) messages on Android using
    the system-provided Content Providers and platform APIs, and streaming those messages
    to the client using Server-Sent Events. We demonstrated how to send messages between
    processes/threads in Android using `Intent`s, broadcasts, and `BroadcastReceiver`s.
    Finally, on the desktop side, we built a JavaFX client to display and send text
    messages, which connects to the REST server on the phone via the Jersey REST client,
    and we consumed the Server-sent Event stream, updating the user interface as appropriate.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: With all of the moving parts, this was probably the most complex of our projects.
    It was certainly a great way to round out our list of projects. In the next chapter,
    we'll take a look at what's next for Java, as well as some other technologies
    that might be good to have on your radar.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
