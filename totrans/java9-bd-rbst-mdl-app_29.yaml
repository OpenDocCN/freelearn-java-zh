- en: DeskDroid - A Desktop Client for Your Android Phone
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've come at long last to our final project. To close our time together here,
    we're going to build a very practical application, one that lets us send and receive
    SMS messages from the comfort of our desktop. There are a number of products on
    the market that let you do this now, but they typically require a third-party
    service, meaning your message travels through someone else's servers. For the
    privacy-minded, that can be a real problem. We'll build a system that is 100%
    local.
  prefs: []
  type: TYPE_NORMAL
- en: 'Building the app will cover several different topics, some familiar, some new.
    That list includes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Android applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Android services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: REST servers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Server-sent events for event/data streaming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data access using Content Providers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There will also be a host of other, smaller tidbits along the way as we finish
    out our time together on a strong, high note.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This project will have two parts:'
  prefs: []
  type: TYPE_NORMAL
- en: The Android application/server (not to be confused with application server,
    of course)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The desktop/JavaFX application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The desktop piece is somewhat useless without the **server** piece, so we'll
    start by building the Android side first.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Android project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While we have been using NetBeans for most of our work so far, we will again
    use Android Studio for this piece of the project. While there is some semblance
    of Android support for NetBeans, as of this writing, the project seems to have
    stalled. Android Studio, on the other hand, is very actively developed by Google
    and is, in fact, the official IDE for Android development. I will leave it as
    an exercise for the reader, if needed, to install the IDE and the SDK.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a new project, we click on File | New Project, and specify Application
    name, Company domain, and Project location, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/40d38df6-07a4-40e1-8936-599fc2cc81fc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, we need to specify the API version we want to target. This can be a tricky
    choice. On the one hand, we''d like to be on the cutting edge and have all of
    the great new features that Android offers available to us, but on the other hand,
    we don''t want to target such a new API level that we make the application unusable
    (read uninstallable) for a larger number of Android users than is necessary. In
    this case, Android 6.0, or Marshmallow, seems like an acceptable trade-off:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3fcfe029-ebb7-40ca-9b03-abb856bc76b2.png)'
  prefs: []
  type: TYPE_IMG
- en: Click on Next, select Blank Activity, Next, and Finish, and our project is ready
    for development.
  prefs: []
  type: TYPE_NORMAL
- en: On the Android side, we are not going to do much in the way of user interface.
    Once we have finished the project, you will likely have all sorts of ideas of
    what could be done, which is great, but we won't spend the time here doing any
    of those. That said, the first thing we really need to do is ask the user for
    permission to access the text messages on their phone.
  prefs: []
  type: TYPE_NORMAL
- en: Requesting permissions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In earlier versions of Android, permissions were an all or nothing proposition.
    Starting with Android 6, though, the user is prompted for each permission that
    the application requests, allowing for the possibility of a user to grant some
    permissions while denying others. We will need to request some permissions--we
    need to be able to read and write SMS messages, and we''ll need access to the
    contacts (so we can try to figure out who sent us a given message). Android provides
    an API for requesting those permissions very easily, which we''ll put in our `onCreate()`
    method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: When this preceding code runs, Android will prompt the user to grant or deny
    the requested permissions. This is done asynchronously, so, in your applications,
    you need to make sure you don't attempt any operation that requires any permission
    that you request until the user has had a chance to grant the permission (and,
    should the user deny the permission, the application should degrade, or fail,
    gracefully).
  prefs: []
  type: TYPE_NORMAL
- en: 'To allow the application to respond to permission grants, Android provides
    a callback. In our callback, we want to make sure the user grants us both permissions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: When Android calls back in to our application, we need to make sure that the
    `requestCode` is what we specified-- `PERMISSION_REQUEST_CODE`--to make sure that
    we only respond to our own requests.
  prefs: []
  type: TYPE_NORMAL
- en: Once we've identified an appropriate response, we make sure that `grantResults`
    is the correct length, and that each entry is `PERMISSION_GRANTED`. If the array
    is too short, or if either array element is not the correct type, we display a
    dialog informing the user that both permissions are required, and then exit the
    application.
  prefs: []
  type: TYPE_NORMAL
- en: In our example, we are requesting both permissions simultaneously, so we respond
    to both simultaneously. If you have a complex set of permissions, for example,
    if your application can work with only some of the requested permissions, you
    can make multiple calls to `ActivityCompat.requestPermissions`, providing a distinct
    `requestCode` for each. You would then need to expand your switch block in `onRequestPermissionsResult()`
    to cover each new `requestCode`.
  prefs: []
  type: TYPE_NORMAL
- en: 'One final word on permissions. Typically, you should always check to make sure
    that you have the permission needed to perform a given task. You can do that with
    a method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In our case, we just don't allow the application to run if we aren't granted
    the required permissions, so we need not worry about additional permission checks.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The heart of the Android portion of the project is our REST endpoints. We would
    like these endpoints to be available whenever the phone is on, so we can't use
    an `Activity` to host them. What we want is a `Service`. The Android documentation
    defines a `Service` as *an application component that can perform long-running
    operations in the background, and it does not provide a user interface*. There
    are three types of Services--`scheduled` (which runs on a schedule), `started`
    (which can be started explicitly by another application component), and `bound`
    (which is bound to an application component via the `bindService()` call, and
    runs until all the bound components are destroyed). Since we want this to be available
    all the time, we want a started service.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create the service, click on File | New | Service | Service. Enter `DeskDroidService`
    for the service, uncheck Exported, and click on Finish. That will get you the
    following stubbed code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The wizard also updates `AndroidManifest.xml` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The method `onBind()` is abstract, so it must be implemented. We are not creating
    a bound service, so we can leave this unimplemented, although we will change it
    so that it returns `null` rather than throwing an `Exception`. We are, though,
    interested in when the service is started and stopped, so we need to override
    these two relevant lifecycle methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s in these methods that we''ll place our REST service code. We will once
    again use Jersey, the JAX-RS reference implementation, which provides a nice way
    of bootstrapping a server in a Java SE environment, such as what we find ourselves
    in here in our Android application. We''ll encapsulate that logic in a new method
    called `startServer()` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The first thing we do is check to make sure that we're on Wi-Fi. This isn't
    strictly necessary, but it seemed to be a prudent precaution to prevent the application
    from listening for connections, regardless of the network state. If the phone
    is not on Wi-Fi, there's a good chance the intended laptop is not either. There
    may be legitimate use cases for allowing the endpoints to listen even on a cellular
    network, however. Making this restriction configurable is a great candidate for
    a preferences-driven option.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this code to work, we need to add this new permission to the manifest:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Once we're sure that we're on Wi-Fi, we look up our IP address, and bootstrap
    a Jetty-based Jersey server. With a nod to the Venerable Commodore 64, for those
    of us old enough to remember that computing pioneer, we listen on port `49152`
    on the Wi-Fi network interface.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create a `ResourceConfig` instance, providing two feature references
    that we're interested in--`SseFeature` and `JacksonFeature`. We've already seen
    `JacksonFeature`; that's what lets us work with POJOs, leaving the JSON concerns
    to Jersey. What is `SseFeature`, though?
  prefs: []
  type: TYPE_NORMAL
- en: Server-sent events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SSE, or server-sent events, is a means by which we can stream data from the
    server to the client. Typically, a REST request is very short-lived--make a connection,
    send the request, get a response, close the connection. Sometimes, though, the
    REST server may not have all of the data that the client wants at the time of
    the request (for example, reading data from another data source such as a log
    file or network socket). So, it would be nice to be able to push that data to
    the client as it becomes available. That's exactly what SSE allows us to do. We'll
    look into that in more detail later.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we start the server instance with a call to `JettyHttpContainerFactory.createServer()`.
    Since we need to be able to stop the server later, we capture the server instance,
    and store it in an instance variable. We call `startServer()` from `onStartCommand()`
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we've wrapped our call to `startServer()` in a `synchronized` block.
    For those that might be unaware, `synchronized` is one of the more basic approaches
    to concurrent code available to Java developers. The net effect of this keyword
    is that multiple threads that try to execute this block of code must do so synchronously,
    or one a time. We do this here so that if we have two different processes attempting
    to start the server, we can guarantee that at most one is running. Without this
    block, the first thread could start the server and store the instance in the variable,
    while a second thread could do the same thing, but its server instance, which
    gets stored in the variable, fails to start. We would now have a running server
    with no valid reference to it, so we would be unable to stop it.
  prefs: []
  type: TYPE_NORMAL
- en: We have also registered a `BroadcastReceiver` that listens for `CODE_GENERATED`.
    We'll come back and explain this later in the chapter, so don't worry about this
    for now.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling the service state
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If we run the application now, our service won''t run, so we need to make it
    such that it will run. We''ll do that in a couple of different ways. The first
    way will be from our application. We want to make sure the service is running
    when we open the application, especially after it is just installed. To do that,
    we need to add one line to `MainActivity.onCreate()` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'When the application is started now, it will guarantee that the service is
    running. We don''t, though, want to require that the user open the application
    to run the service. Fortunately, we have a way to start the application when the
    phone starts. We can do that by installing a `BroadcastReceiver` that listens
    for boot events, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The body of the preceding method is identical to our recent addition to `MainActivity`.
    We do, though, need to register the service, and ask for permission. In `AndroidManifest.xml`,
    we need to add this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We now have a service that starts either at device boot or application startup.
    It does not, however, do anything of interest, so we need to add some endpoints
    to our server.
  prefs: []
  type: TYPE_NORMAL
- en: Adding endpoints to the server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As covered in [Chapter 25](0813704c-2f66-4efa-bbef-f0147dcfb059.xhtml), *Taking
    Notes with Monumentum*, a JAX-RS resource lives in a POJO with certain annotations.
    To stub out our endpoint class, we can start with this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We will also need to register this class with JAX-RS, which we do with this
    line in `startServer()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Ordinarily, we would pass, say, `DeskDroidResource.class`, to the `ResourceConfig`
    constructor, like we did with `JacksonFeature.class`. We will be accessing Android
    resources, and to do that, we're going to need the `Service`'s `Context` instance.
    There are a number of resources on the internet that will suggest creating a custom
    `Application` class and storing it in a `public static`. While that does seem
    to work, it will also leak memory, so, Android Studio, for example, will complain
    if you try that. We can, however, avoid that by using nested classes. That approach
    can get a bit unwieldy, but our classes should be small enough that it remains
    manageable.
  prefs: []
  type: TYPE_NORMAL
- en: Getting conversations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start by adding an endpoint to get all of the conversations on the phone,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Here is where we see the Android artifacts start to show up--we are going to
    use a `ContentProvider` to access the SMS data. A `ContentProvider` is a way for
    an application, or, in this case, an Android subsystem, to expose data to outside
    consumers in a portable, storage-agnostic manner. We don't care how the data is
    stored. We simply specify what fields we want, what filters or restrictions we
    want placed on that data, and `ContentProvider` does the rest.
  prefs: []
  type: TYPE_NORMAL
- en: Using `ContentProvider`s, we specify the type of data not by a table name, like
    we would with SQL, but with a `Uri`. In this case, we specify `Telephony.Sms.Conversations.CONTENT_URI`.
    We pass several null values to `query()` as well. These represent the projection
    (or field list), the selection (or filter), the selection arguments, and the sort
    order. Since these are all `null`, we want every field and every row in the natural
    sort order for the provider. That gets us a `Cursor` object, which we then iterate
    over, creating `Conversation` objects, and add them to our `List`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We create the `Conversation` instances with this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This method, and the processing logic, is mostly identical to that for conversations.
    The `Uri` for the `ContentProvider`, `Telephony.Sms.CONTENT_URI`, is different,
    of course, and we specify a filter for the query as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We do have a slight bit of data analysis here. We need to know which of the
    messages are the ones we sent and which are the ones we received so that we can
    display the thread more meaningfully. On the device, the messages we've sent have
    the type `Telephony.Sms.MESSAGE_TYPE_SENT`. The values for this field translate
    roughly to folders (sent, received, draft, and so on). Rather than leaking part
    of the Android API into ours by sharing the value of the constant, we have a `boolean`
    field, `isMine`, which is true if the message is of type `MESSAGE_TYPE_SENT`.
    It is, admittedly, a slightly clumsy alternative, but it works and should be clear
    enough.
  prefs: []
  type: TYPE_NORMAL
- en: Once we return the list of messages, we iterate over the list, getting a list
    of the unique participants (which should be only one, since we are dealing with
    SMS messages).
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we return this `List<Conversation>` to the client using Jersey''s
    POJO-mapping feature as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/8df486ff-1ee8-4e2d-a573-fa7d55e4e23c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If we click either the run or debug buttons (the large triangle or the triangle-over-a-bug
    icons in the tool bar), you''ll be asked for the deployment target, as seen in
    this screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6a7f7e2a-55a8-4da0-a587-5bb8b4550558.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Since we require Wi-Fi, I select my physical device. If you want to configure
    an emulator with Wi-Fi, that would work as well. Click on OK, and after a few
    moments, the application should start on the device you have selected, and we
    can make our first REST request as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This preceding sample code shows a conversation I'm having with myself. Too
    many late nights, perhaps, but you can see where the first message, the oldest
    message, is marked as mine, which is the one I sent to myself, and the second
    is where I received it back. Pretty cool, but how do you send a message? It turns
    out that that's actually quite simple.
  prefs: []
  type: TYPE_NORMAL
- en: Sending an SMS message
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To send a message, we will create a POST endpoint that takes a `Message` object,
    which we'll then pull apart and pass to Android's telephony APIs.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'There''s a lot going on this method. Here is the breakdown:'
  prefs: []
  type: TYPE_NORMAL
- en: We get a reference to the `SmsManager` class. This class will do all of the
    work for us.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We ask `SmsManager` to divide the message for us. Text messages are, typically,
    limited to 160 characters, so this will split the message as needed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We create a `CountDownLatch` with a count that matches the number of parts in
    the message.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We create an `AtomicInteger` to store the status code. As we'll see in a moment,
    we need to change the value of this variable from inside an anonymous class. However,
    for an anonymous class to access variables from its enclosing scope, those variables
    must be `final`, which means that we can not have a `final int`, as then we would
    not be able to change the value. With `AtomicInteger`, though, we can call `set()`
    to change the value while leaving the instance reference, which is what the variable
    will hold, unchanged.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We create a new `BroadcastReceiver`, which will handle `Intent`s broadcast (as
    we'll see further) when the message is sent. In `onReceive()`, if the result code
    is not `ACTIVITY.RESULT_OK`, we call `AtomicInteger.set()` to reflect the failure.
    We then call `sentLatch.countDown()` to indicate that this message part has been
    processed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the call to `registerReceiver()`, we let the operating system know about
    our new receiver. We provide an `IntentFilter` to restrict which `Intents` our
    receiver has to process.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We then create a new `PendingIntent` for each part our message has been split
    into. This will allow us to react to each part's send attempt individually.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We call `sendMultipartTextMessage()` to send the message part(s). Android handles
    the details of a multipart message for us, so there's no extra effort required.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We need to wait for all of the message parts to be sent, so we call `sentLatch.await()`
    to give the system time to send the message. We don't want to wait forever, though,
    so we give it a timeout of five seconds, which should be long enough. It is conceivable
    that some networks may be very slow about sending text messages, so this value
    may need to be adjusted.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once we pass the latch, we `unregister` our receiver, and return the status
    code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Using curl again, we can now test sending a message (be sure to click on `Run`
    or `Debug` again to deploy your updated code):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding `curl` we send some `lorem ipsum` text to our recipient, which
    gives us a nice, long message (482 total characters for the request payload),
    which is correctly chunked up and sent to the destination phone number, as indicated
    by the `201 Created` response status.
  prefs: []
  type: TYPE_NORMAL
- en: We now have a working REST service on the phone, which lets us read the existing
    messages and send new ones. Interacting with the service with `curl` has worked
    well enough, but it's time to build our desktop client, and put a nice face on
    this project.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the desktop application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To build our application, we''ll return to NetBeans and JavaFX. As in the previous
    chapters, we''ll create a new Maven-based JavaFX application by clicking on File
    | New Project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/095f8c0e-ab8f-4125-9dbe-96ff4dbe62a5.png)'
  prefs: []
  type: TYPE_IMG
- en: In the next step, call the project `deskdroid-desktop`, verify the package name,
    and click on Finish. While not strictly necessary, let's clean up the naming a
    bit, changing the controller to `DeskDroidController`, and the FXML file to `deskdroid.fxml`.
    We'll also need to modify the references to the FXML and the CSS in the controller,
    and the reference to the controller in the FXML. Click on Run | Run Project to
    make sure everything is wired up correctly. Once the app starts, we can immediately
    close it so we can start making changes.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the user interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start by building up the user interface. Here''s what the application
    will look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4278a3b2-cead-4ecd-ac27-f4a1989c87ef.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding screen, we'll have our list of conversations on the left, and
    we will display the selected conversation on the right. We will add a mechanism
    for auto-refreshing, but the Refresh Conversations will allow for a manual refresh,
    if needed. New Message should be self-explanatory.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use Gluon''s Scene Builder to build the user interface, of course, but
    let''s take a look at the FXML. We''ll start, as usual, with a `BorderPane`, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'For the `top` section, we''re going to add a menu bar as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll have three `MenuItem`s in the `FileMenu`: `connectToPhone`, `disconnectFromPhone`,
    and `Exit`. Each menu item will have a mnemonic, as indicated by the underscores.
    The `ExitMenuItem` has an accelerator key, `ALT-F4`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll put the bulk of the user interface in the `center` section. The vertical
    split allows us to resize the two sides of the user interface. For that, we use
    a `SplitPane` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'With `dividerPositions`, we set the default split at the 25% mark along the
    horizontal rule. The `SplitPane` has a nested `items` element to hold its children
    to which we add the left element, `ListView`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We wrap `ListView` in a `VBox` to make the `ListView` grow and shrink, as needed,
    more easily.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let''s build the right side of the user interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'On the right side, we also have a `VBox`, which we use to arrange our two user
    interface elements. The first is `HBox`, which holds two buttons: Refresh Conversation
    and New Message. The second is our `ListView` for displaying the selected conversation.'
  prefs: []
  type: TYPE_NORMAL
- en: Defining user interface behavior
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While we can define the structure of the user interface in FXML in all but
    the most trivial applications, the user interface still requires some Java code
    to finish defining its behavior. We''ll do that now in `DeskDroidController.initialize()`.
    We''ll start with the left side of the user interface, the conversation list,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: We declare an injectable variable to hold a reference to our `ListView`. JavaFX
    will set that value for us, thanks to the annotation `@FXML`. `ListView` will
    need a model to display, which we declare as `conversations`, and we declare `conversation`
    to hold the currently selected conversation.
  prefs: []
  type: TYPE_NORMAL
- en: In the `initialize()` method, we wire everything together. Since `ListView`
    will be displaying our domain object, we need to declare a `CellFactory` for it,
    which we do with the lambda passed to `setCellFactory()`. We'll look at `ListCell`
    in a moment.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we associate `ListView` with its model, `conversations`, and define what
    is, in effect, an `onClick` listener. We achieve that, though, by adding a listener
    to `SelectionModel` on `ListView`. In that listener, we update the currently selected
    conversation, update the messages `ListView` to display the conversation, and
    scroll that `ListView` to the very bottom so that we see the most recent message.
  prefs: []
  type: TYPE_NORMAL
- en: 'Initializing the message `ListView` is much simpler. We need these instance
    variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need these lines in `initialize()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'And the New Message button needs a handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '`ConversationCell` tells JavaFX how to display a `Conversation` instance. To
    do that, we create a new `ListCell` child as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we override `updateItem()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: If the cell is given a `Conversation`, we process it. If not, we set the cell's
    graphic to null. If we fail to do that, we'll have unpredictable results when
    scrolling through the lists.
  prefs: []
  type: TYPE_NORMAL
- en: 'To build the cell contents, we start by getting the `Participant` and creating
    the wrapper component as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This is pretty standard JavaFX fare--create an `HBox`, and add to it an `ImageView`.
    We are, though, using a class we haven't looked at yet--`ConversationService`.
    We'll look at this later, but for now, it's enough to know that we will encapsulate
    our REST calls in this class. Here, we're calling an endpoint (that we haven't
    seen yet) to get the contact information for the phone number at the other end
    of this conversation.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need to create the conversation snippet as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Using `VBox` to ensure vertical alignment, we create two labels, one with the
    participants' information, and the other with the snippet of the conversation.
  prefs: []
  type: TYPE_NORMAL
- en: 'While that finishes the cell definition, if we were to run the application
    the way it is now, the `ListCell`''s contents would likely be cropped by the edge
    of `ListView` itself. For example, see the difference between the top list and
    the bottom list in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3c21078d-c23b-4f6a-9700-2d0bf3b12872.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To make our `ListCell` behave as we see at the bottom of the last screen, we
    need to make one more change to our code, which is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: In our preceding `CellFactory`, we pass in the reference to the enclosing `ListView`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: In the constructor, we then bind the preferred width of our cell to the actual
    width of the list (and subtract a small amount to adjust for the control borders).
    When rendered now, our cell will wrap just as we expected.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `MessageCell` definition is similar, and goes as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'For *my* message, we create the contents this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The *their* message is created this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: This is similar to the *my* message, with the exception that we display the
    sender's profile picture, if there is one associated with the contact on the phone,
    which we retrieve from the phone via the `ConversationService` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have a bit more work to do, but this is what the application will look like
    with data:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2e658425-c23c-4c95-8cf0-843f21db6233.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To get the data, we need a REST client, and that is found in `ConversationService`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the so-called *Initialize-on-Demand Holder* idiom, we create a sort of
    a poor man''s singleton. Since the constructor is private, it can''t be called
    from outside this class. The nested static class, `LazyHolder`, is initialized
    only when it is finally referenced, which happens on the first call to `getInstance()`.
    Once that method is called, `LazyHolder` is loaded and initialized, at which point,
    the constructor is run. The instance created is stored in the static variable,
    and lives as long as the JVM runs. Every subsequent call will return the same
    instance. This is important for us, as we have some objects that are expensive
    to create as well as some simple caching in the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we initialize our client instance, registering the `JacksonFeature`,
    which gets us the POJO mapping we've already discussed. We also register `SseFeature`,
    a more advanced feature of Jersey that we'll discuss in detail later.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ve already seen the conversation list. That is generated using data from
    this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '`WebTarget` is a JAX-RS class that represents the *resource target identified
    by the resource URI*. We''re pulling the address for the phone from preferences,
    which we''ll discuss later. Once we have our `WebTarget`, we complete building
    the URI by appending `conversations`, specify the request mime type, and issue
    the `GET` request. Note that our request here is somewhat optimistic, as we don''t
    do any status code checking. Should an `Exception` be thrown, we simply return
    an empty `List`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The other method we''ve seen is `getParticipant()`, which is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: In the last method, we see our cache come into play. When a `Participant` is
    requested, we look to see if this information has already been fetched. If so,
    we return the cached information. If not, we can make a request for it.
  prefs: []
  type: TYPE_NORMAL
- en: Much like `getConversations(),` we build a request for the appropriate endpoint,
    and send the `GET` request. This time, though, we do check for the status code.
    Only if the status is `200 (OK)` do we continue processing the response. In this
    case, we ask JAX-RS for the `Participant` instance returned, which `JacksonFeature`
    happily builds for us from the JSON response body, and which we immediately add
    to our cache.
  prefs: []
  type: TYPE_NORMAL
- en: If the server found a thumbnail for the contact, we need to process that. The
    server piece, which we will look at immediately after we finish discussing this
    method, sends the thumbnail as a base 64-encoded string in the body of the JSON
    object, so we convert it back to the binary representation, and save that to a
    file. Notice that we are using try-with-resources, so we need not worry about
    cleaning up after ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'We haven''t seen the server side of this operation, so let''s look at that
    now. In our Android application in Android Studio, we have this method on `DeskDroidResource`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: We attempt to build the `Participant` instance. If an Exception is thrown, we
    return a `500` (Server Error). If `null` is returned, we return a `404` (Not Found).
    If a participant is found, we return `200` (OK) and the participant.
  prefs: []
  type: TYPE_NORMAL
- en: 'To build the participant, we need to query the phone contacts. This works in
    much the same way as the SMS queries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The preceding is the same type of query and cursor management that we saw earlier
    with conversations, but there is one exception. If the contact has a thumbnail,
    the query returns a `Uri` to that image. We can use `ContentResolver` to open
    an `InputStream` using that `Uri` to read the contents, which we load into `ByteArrayOutputStream`.
    Using Android's `Base64` class, we encode this binary image into a `String`, and
    add that to our `Participant` model. We saw the decoding half of this operation
    previously.
  prefs: []
  type: TYPE_NORMAL
- en: Sending messages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we can see the conversations that we''ve been having, we need to add
    the ability to take part in those conversations--to send new text messages. We''ll
    start on the client. We''ve actually already seen the handler for the `New Message`
    button assigned. It is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'What we need to do now is to look at this `sendNewMessage()` method itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The actual dialog is displayed in another window, so we have a separate FXML
    file, `message_dialog.fxml`, and controller, `SendMessageDialogController`. When
    the dialog closes, we check the return `Optional` to see if the user entered a
    message. If so, process the message as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Get a reference to the selected `Conversation`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new message, setting the conversation ID, recipient, and body.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Using `ConversationService`, we attempt to send the message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If successful, we update the user interface with the new message.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: If unsuccessful, we display an error message.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`SendMessageController` works just like the other controllers we''ve looked
    at. The most interesting is the method `showAndWait()`. We''ll use that method
    to show the dialog, wait for it to close, and return any user response to the
    caller. The dialog looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/aa10e162-71fb-425f-9087-69c8e4abe267.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The method looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The first few lines in the preceding method are what we''ve normally seen,
    which is creating the loader and the `Stage`. Before showing the `Stage`, we set
    the modality, and pass in the current `Conversation`. Finally, we call `showAndWait()`,
    at which point the method blocks until the user closes the dialog, and then we
    return the entered message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: A Java `Optional` is a *container object which may or may not contain a non-null
    value*. The value of `message` may or may not be set depending on which button
    is clicked in the dialog. Using the `Optional`, we can return a, possibly, null
    value, and handle it more safely in the caller--`if (result.isPresent())`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The sending of the message is a simple POST operation in the `ConversationService`,
    which is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The client side is simple, but what about the server side? Unsurprisingly,
    that''s where the complexity lies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: To add the endpoint, we define a new method with the correct annotations. This
    method will listen on the path `conversations` for `POST` requests, and expect
    a `Message` as its payload. The actual work of sending a message is handled by
    `SmsManager`, so we acquire a reference to the default manager. The next step
    calls `divideMessage()`, but what's that all about?
  prefs: []
  type: TYPE_NORMAL
- en: Text messages are technically limited to 160 characters. Twitter users are probably
    somewhat familiar with that already. Twitter limits tweets to 140 characters,
    leaving 20 characters for the sender's name. While Twitter has stuck hard to that
    limit, regular SMS users have a better experience. If the message is longer than
    160 characters, most modern phones will chunk the message into 153 character segments
    when sending (with 7 characters for segmentation information used to piece the
    segments back together), which are merged back into one message on the receiving
    end if the phone supports it. The `SmsManager` API handles this complexity for
    us with `divideMessage()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the message is *chunked*, though, our job gets a little more difficult.
    We would like to be able to return a status code indicating whether or not the
    message was sent successfully. To do that, we need to check the status of each
    chunk of the message, be it one or ten. Sending a text message with `SmsManager`,
    Android broadcasts an `Intent` with the results. To react to that, we need to
    register a receiver. Put that all together, and we get this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: To make sure that we've received the `Intent` for each message chunk, we start
    by creating a `CountDownLatch` with a count matching the number of chunks in the
    message. We also create an `AtomicInteger` to hold the status code. The reason
    we do this is that we need a final variable which we can access from our `BroadcastReceiver`,
    but we also need to be able to change the value. `AtomicInteger` allows us to
    do that.
  prefs: []
  type: TYPE_NORMAL
- en: We create and register a `BroadcastReceiver`, which analyzes the result code
    on `Intent`. If it's not `Activity.RESULT_OK`, we set `statusCode` to `INTERNAL_SERVER_ERROR`.
    Either way, we count down the latch.
  prefs: []
  type: TYPE_NORMAL
- en: With our receiver ready, we create a `List` of `PendingIntent`s, one for each
    chunk, then we pass that, with our list of message chunks, to `SmsManager.sendMultipartTextMessage()`.
    Message sending is asynchronous, so we call `sentLatch.await()` to wait for the
    results to be returned. We limit the wait to five seconds so that we don't wait
    forever. Once the wait time expires or the latch is cleared, we unregister our
    receiver and return the status code.
  prefs: []
  type: TYPE_NORMAL
- en: Getting updates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we can see all of the conversations, view individual messages in a conversation,
    and send new messages. What we can't do yet is get updates when new messages arrive
    on the device, so let's implement that now, starting with the server piece this
    time.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get a constant stream of events, we''ll use a feature called Server-Sent
    Events, a W3C specification for receiving push notifications from the server.
    We enabled this feature in Jersey by registering the `SseFeature` in both the
    client and server setup steps. To create an SSE endpoint, we specify that the
    method returns the media type `SERVER_SENT_EVENTS`, and we return an `EventOutput`
    as the payload:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'From the Jersey documentation, we learn this:'
  prefs: []
  type: TYPE_NORMAL
- en: After the eventOutput is returned from the method, the Jersey runtime recognizes
    that this is a ChunkedOutput extension and does not close the client connection
    immediately. Instead, it writes the HTTP headers to the response stream and waits
    for more chunks (SSE events) to be sent. At this point the client can read headers
    and starts listening for individual events.
  prefs: []
  type: TYPE_NORMAL
- en: 'The server, then, keeps the socket to the client open, and pushes data down
    it. But where does the data come from? The Server-sent Event endpoints create
    a `Thread` that writes data to the `EventOutput` instance we created earlier.
    When the `Thread` is finished, it calls `eventOutput.close()`, which signals to
    the runtime that it is appropriate to close the client connection. To stream updates,
    our `Thread` looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: As we've seen before, we set up a `BroadcastReceiver`, which we register here
    and unregister before the `Thread` ends, but this time, we're listening for broadcasts
    that an SMS message has been received. To make sure our `Thread` isn't in a small,
    tight, fast loop, which would quickly kill the battery on the device, we use `LinkedBlockingQueue`.
    When a message is received, we pull the `SmsMessage`(s) from `Intent`, and add
    them to `queue`. In our while loop, we attempt to `take()` an item from `queue`.
    If we find one, we process it and any more that might either already be in the
    queue or be added while we are processing. Once `queue` is empty, we go back to
    waiting. We have a timeout on `take()` to make sure that the thread can respond
    to the exit criteria, most notably, the client disconnecting. This will run as
    long as the client remains connected. Let's look, then, at the client.
  prefs: []
  type: TYPE_NORMAL
- en: 'We encapsulated the details in `ConversationService.subscribeToNewMessageEvents()`
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we create a `Thread`, in which we make the call to the
    SSE endpoint. The return type on the client is `EventInput`. We loop to process
    each incoming event, which we get as an `InboundEvent`. If it is null, then the
    connection has been closed, so we break out of our processing loop. If it is not
    null, we make sure that the event name matches what we're waiting for--`new-message`.
    If found, we extract the event payload, a `Message`, and call our callback, which
    we pass in as `Consumer<Message>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'From the application proper, we subscribe to the status stream this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '`handleMessageReceived()` looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: The first step in handling this new message is very important--we pass a `Runnable`
    to `Platform.runLater()`. If we don't do this, any attempts to modify the user
    interface will fail. You have been warned. In our `Runnable`, we create a `Stream`
    of `Conversation`s, `filter()` it, looking for a `Conversation` whose participant
    matches the `Message` sender, then grab the first (and only) match.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: If we don't find the `Conversation` in the list, we create a new one, and add
    it to the `ConversationObservable`, which results in the `List` automatically
    updating on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we attempt a couple of desktop integration tasks. If `Taskbar` supports
    the `USER_ATTENTION` feature, we request user attention. From the Javadocs we
    learn that, *depending on the platform, this may be visually indicated by a bouncing
    or flashing icon in the task area*. Regardless, we issue a beep to get the user's
    attention.
  prefs: []
  type: TYPE_NORMAL
- en: Security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There's one last major piece that we haven't discussed, and that's security.
    Currently, anybody with the desktop application can, in theory, connect to your
    phone, see your messages, send others, and so on. Let's fix that now.
  prefs: []
  type: TYPE_NORMAL
- en: Securing the endpoints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To secure the REST server, we will use a filter just like we used in [Chapter
    25](0813704c-2f66-4efa-bbef-f0147dcfb059.xhtml), *Taking Notes with Monumentum*.
    We''ll start by defining the annotation that will specify which endpoints need
    to be secured, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'We will apply this preceding annotation to each secured endpoint (annotations
    condensed to one line for brevity):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'We will also need a filter to enforce security, which we add as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Much like in [Chapter 25](0813704c-2f66-4efa-bbef-f0147dcfb059.xhtml), *Taking
    Notes with Monumentum*, we''ll be using **JSON Web Tokens** (**JWT**) to help
    authenticate and authorize clients. In this filter, we extract the JWT from the
    request headers and validate it through these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Get the signing key from `KeyGenerator`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the `JwtParser` using the signing key.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Parse the claims in the JWT. For our purposes here, this is, basically, just
    a validation of the token itself.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Abort the request with `UNAUTHORIZED` (`401`) should the token be invalid.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `KeyGenerator` itself looks a bit like what we saw in [Chapter 25](0813704c-2f66-4efa-bbef-f0147dcfb059.xhtml),
    *Taking Notes with Monumentum*, but has been modified to use Android APIs in this
    manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Since we might possibly receive requests from multiple clients at a time, we
    need to be careful about how the key is generated. To make sure it's done once
    and only once, we'll use the same type of synchronization/locking we saw in the
    server startup.
  prefs: []
  type: TYPE_NORMAL
- en: Once we've acquired the lock, we perform a null check to see if the process
    has already generated (or read) the key. If not, we then read the signing key
    from `SharedPreferences`. If it's null, we create a random string (here, just
    a UUID), and save it to `SharedPreferences` for reuse next time. Note that to
    save to Android preferences, we have to get an instance of `SharedPreferences.Editor`,
    write the string, then `commit()`. Once we have the signing key, we create the
    actual `SecretKeySpec` that we'll use to sign and verify our JWTs.
  prefs: []
  type: TYPE_NORMAL
- en: Handling authorization requests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With our endpoints now secured, we need a way for the clients to request authorization.
    To do that, we''ll expose a new endpoint, unsecured, of course, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Rather than require a more complicated authorization system that might require
    a username and password or an OAuth2 provider, what we''ll implement is a simple
    system that requires only a random number:'
  prefs: []
  type: TYPE_NORMAL
- en: On the phone, the user requests that a new client be added, and is presented
    with a random number.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the desktop application, the user enters the number, which the desktop application
    then POSTs to the server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the numbers match, the client is given a JWT, which it will send with every
    request.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The JWT is verified each time to make sure the client is authorized to access
    the target resource.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this method, we get the number POSTed by the client (which we let JAX-RS
    extract from the request body), then compare it to the number generated on the
    phone. If they match, we create the JWT, and return it to the client. Before doing
    so, we broadcast an intent with the action `CODE_ACCEPTED`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Where does the number come from, and why are we broadcasting this intent? We
    haven''t looked at this in detail yet, but in the main layout, `activity_main.xml`,
    there is a `FloatingActionButton`. To this, we attach an `onClick` listener as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'When the user taps on the button, the following screen will be shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6ee9cc7e-5b78-4b88-a9eb-da7ab9851a8e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The client will use this information to connect and gain authorization. The
    `Activity` itself is fairly basic. It needs to present the IP address and code,
    and then respond to a client connecting. All of this is done in `onCreate()` in
    our new `AuthorizeClientActivity` class. We get the IP from `WifiManager`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Remember that we require that the client be on a Wi-Fi network. The code is
    just a random, 6-digit number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'To listen for the `Intent` we saw earlier, which indicates that a client has
    been authenticated (which, presumably, will happen shortly after this `Activity`
    has been displayed), we register another receiver as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to tell the `Service` what this new code is so that it can verify
    it. To do that, we broadcast an `Intent` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: We've already seen the other half of this broadcast in `DeskDroidService.onStartCommand()`
    earlier, where the code is retrieved from the `Intent`, and stored in the service
    for use by `DeskDroidResource.getAuthorization()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, this method, which handles the authentication notice, simply cleans
    up the receiver and closes the `Activity`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: With this, when a client connects and successfully authenticates, the `Activity`
    closes, and the user is returned to the main `Activity`.
  prefs: []
  type: TYPE_NORMAL
- en: Authorizing the client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up until this point, everything has assumed that the desktop is already connected
    to the phone. We have enough pieces in place now that we can talk about that in
    a meaningful manner.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the application''s main `Menu`, we have two `MenuItem`s: `Connect to Phone`
    and `Disconnect from Phone`. The `Connect to Phone` handler looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'We''re going to use the now-familiar `showAndWait()` pattern to display a modal
    dialog, and to get the response using the new `ConnectToPhoneController`. The
    user interface is very simple, and is shown in this screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/195ad74a-3937-4595-980c-321fd1d35bec.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When the user clicks on OK, we save the address and the code in the application''s
    preferences, then attempt to authorize against the server, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Notice the use of `Optional<String>` as the return type for `ConversationService.getAuthorization()`.
    Using `Optional`, as we've discussed before, makes working with potentially `null`
    values much safer. In this case, if `Optional` has a value present, then we've
    successfully authenticated. So, we save the token to preferences, and close the
    dialog.
  prefs: []
  type: TYPE_NORMAL
- en: 'The actual authentication is handled by `ConversationService`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: This last method sends the code to the server via a `POST`, and if the status
    code is `200`, we create an `Optional` with the returned token. Otherwise, we
    return an empty `Optional`.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we built a different kind of project. We've had applications
    that run on Android, and some that run on the desktop. This one, though, runs
    on both platforms simultaneously. One is no good without the other. That requires
    that we build things a bit differently to make sure the two are synchronized.
    While there are a variety of ways to go about this, we chose to use a REST server
    on the phone, with the desktop acting as a REST client.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of the chapter, we built an Android application that provides not
    only a user interface, but a background process (called `Service`), and embedded
    our REST server in the Android application using Jersey and its Java SE deployment
    option. You also learned how to interact with text (SMS) messages on Android using
    the system-provided Content Providers and platform APIs, and streaming those messages
    to the client using Server-Sent Events. We demonstrated how to send messages between
    processes/threads in Android using `Intent`s, broadcasts, and `BroadcastReceiver`s.
    Finally, on the desktop side, we built a JavaFX client to display and send text
    messages, which connects to the REST server on the phone via the Jersey REST client,
    and we consumed the Server-sent Event stream, updating the user interface as appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: With all of the moving parts, this was probably the most complex of our projects.
    It was certainly a great way to round out our list of projects. In the next chapter,
    we'll take a look at what's next for Java, as well as some other technologies
    that might be good to have on your radar.
  prefs: []
  type: TYPE_NORMAL
