<html><head></head><body><div class="chapter" title="Chapter&#xA0;6.&#xA0;GUI with Nifty GUI"><div class="titlepage"><div><div><h1 class="title"><a id="ch06"/>Chapter 6. GUI with Nifty GUI</h1></div></div></div><p>First of all, what is <span class="strong"><strong>Nifty GUI</strong></span>? It's not the only GUI available in jMonkeyEngine, but it is the one <a id="id417" class="indexterm"/>that is officially supported. It is not developed by the jMonkeyEngine team but is an independent open source effort that has implementations in other engines as well.</p><p>In this chapter, we'll cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Initializing Nifty and managing an options menu</li><li class="listitem" style="list-style-type: disc">Loading the screen</li><li class="listitem" style="list-style-type: disc">Creating an RPG dialog screen</li><li class="listitem" style="list-style-type: disc">Implementing a game console</li><li class="listitem" style="list-style-type: disc">Handling a game message queue</li><li class="listitem" style="list-style-type: disc">Creating an inventory screen</li><li class="listitem" style="list-style-type: disc">Customizing the input and settings page</li><li class="listitem" style="list-style-type: disc">Using offscreen rendering for a minimap</li></ul></div><div class="section" title="Introduction"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec62"/>Introduction</h1></div></div></div><p>Nifty GUI is operated using screens. A screen could be, for example, an in-game (<span class="strong"><strong>HUD)</strong></span> <span class="strong"><strong>heads-up display</strong></span><a id="id418" class="indexterm"/> or the same game's main menu. Screens are built using XML and Nifty's own set of tags. On each screen, there can be layers that are<a id="id419" class="indexterm"/> drawn on top of each other according to their order.</p><p>On a screen, objects cascade similarly as on a web page, that is, from top to bottom or left to right, depending on the settings. The following code is an example of what a simple screen might look like:</p><div class="informalexample"><pre class="programlisting">&lt;nifty 
        
        xsi:schemaLocation="http://nifty-gui.sourceforge.net/nifty-1.3.xsd http://nifty-gui.sourceforge.net/nifty-1.3.xsd"&gt;
  &lt;useStyles filename="nifty-default-styles.xml" /&gt;
  &lt;useControls filename="nifty-default-controls.xml" /&gt;
    
  &lt;registerSound id="showWindow" filename="Sound/Effects/Beep.ogg" /&gt;
    
  &lt;screen id="main" controller="gui.controller.MainScreenController"&gt;
    &lt;layer id="layer0" childLayout="absolute" backgroundColor="#000f"&gt;
      &lt;!-- add more content --&gt;
    &lt;/layer&gt;
  &lt;/screen&gt;
&lt;/nifty&gt;</pre></div><p>Each screen has a <code class="literal">Controller</code> class tied to it. This is the link between the XML and Java that allows Nifty to control functions in the code and the other way around.</p><p>Another important concept is <code class="literal">Controls</code> (not to be confused with <code class="literal">Controller</code> classes or jMonkeyEngine's Control interface). Using <code class="literal">Controls</code> is a very convenient way to make screen files smaller and create reusable components. Anyone familiar with, for example, components in JSF will see the similarities. It's highly recommended that you become accustomed to using these early on, or screen files will quickly become unmanageable.</p><p>A UI's implementation is often very specific to the game in question. This chapter will try to show and explain the different functions and effects available in Nifty GUI. Even if the title of a recipe does not appeal to you, it could still be worth to glance through the content to see whether it covers some features that could be suitable for your project.</p></div></div>
<div class="section" title="Initializing Nifty and managing an options menu"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec63"/>Initializing Nifty and managing an options menu</h1></div></div></div><p>To start <a id="id420" class="indexterm"/>things off, let's begin with a simple recipe that will provide<a id="id421" class="indexterm"/> us with the basics of setting up the application to use Nifty GUI and tell us how to manage the options menu. An options menu is usually found in games; it acts as a link between different screens. For this reason, it's suitable to create it using the control pattern so it can be easily handled across screens.</p><p>We'll initialize Nifty GUI inside <code class="literal">AppState</code> to offset it from the main application code and then access the application from Nifty and control Nifty through code.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec152"/>Getting ready</h2></div></div></div><p>Let's look at how to initialize Nifty in an application. We start off by defining a new <code class="literal">AppState</code> to handle our Nifty functions. We can call it <code class="literal">NiftyAppState</code> and have it extend <code class="literal">AbstractAppState</code>.</p><p>In the <code class="literal">initialize</code> method, we need to create the Nifty display with the following line of code, giving Nifty access to various functionalities within the application and telling it to render <code class="literal">o</code> in the GUI view:</p><div class="informalexample"><pre class="programlisting">NiftyJmeDisplay niftyDisplay = new NiftyJmeDisplay(app.getAssetManager(),
                app.getInputManager(),
                app.getAudioRenderer(),
                app.getRenderManager().getPostView("Gui Default"));</pre></div><p>We should also store the Nifty instance in the class for use later, using <code class="literal">niftyDisplay.getNifty()</code>. With this done, we need to add <code class="literal">niftyDisplay</code> as a processor to the same view we just specified, using the following code:</p><div class="informalexample"><pre class="programlisting">app.getRenderManager().getPostView("Gui Default").addProcessor(niftyDisplay);</pre></div><p>The last<a id="id422" class="indexterm"/> thing that needs to be done before Nifty could show <a id="id423" class="indexterm"/>anything is to tell it what to draw. We do this with <code class="literal">nifty.fromXml</code> and pass the XML file to be used as well as the name of the screen (if several screens are stored in the same XML).</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec153"/>How to do it...</h2></div></div></div><p>We start by defining the XML files for our options menu and the screen that will contain it. Perform the following steps to do this:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">First of all, we should create a new file called <code class="literal">optionsMenu.xml</code>. It should reside in the <code class="literal">Interface</code>/<code class="literal">Controls</code> folder.</li><li class="listitem">The first tag we need to have is a <code class="literal">&lt;nifty-controls&gt;</code> tag to let Nifty know that the elements inside should be parsed as controls.</li><li class="listitem">Then, we add <code class="literal">&lt;controlDefinition name="options"&gt;</code>, which is the actual options menu instance.</li><li class="listitem">This is where the actual layout starts, and it does so with a <code class="literal">&lt;panel&gt;</code> element, as shown in the following code:<div class="informalexample"><pre class="programlisting">&lt;panel id="optionsPanel" childLayout="vertical" width="40%" height="60%" align="center" valign="center" backgroundColor="#333f"&gt;</pre></div></li><li class="listitem">At the top, we'll have <code class="literal">&lt;panel&gt;</code> that will include <code class="literal">&lt;control name="label"&gt; element with text="Options"</code>.</li><li class="listitem">To the right of this panel, there should be a small button with the familiar <span class="strong"><strong>x</strong></span> to close the menu and an interact element to call a method in the <code class="literal">Controller</code> class, as shown in the following code:<div class="informalexample"><pre class="programlisting">&lt;control name="button" id="closeButton" align="right" label="x" height="30px" width="30px" &gt;
  &lt;interact onClick="toggleOptionsMenu()"/&gt;
&lt;/control&gt;</pre></div></li><li class="listitem">After this, we<a id="id424" class="indexterm"/> can have as many <code class="literal">&lt;control name="button"&gt;</code> elements we want for our options menu to work. There should at <a id="id425" class="indexterm"/>least be one that calls <code class="literal">quit()</code> in the <code class="literal">Controller</code> class to stop the application.</li><li class="listitem">Now, we can define a screen to contain our options menu. If we right-click on the <span class="strong"><strong>Projects</strong></span> window and select <span class="strong"><strong>New/Empty Nifty GUI file</strong></span>, we will get a basic setup for a screen.</li><li class="listitem">Clean out everything between the <code class="literal">&lt;layer&gt;</code> tags, and change the controller of the <code class="literal">&lt;screen&gt;</code> element to <code class="literal">gui.controls.NiftyController</code>.</li><li class="listitem">Next, we need to define what styles to include using the <code class="literal">&lt;useStyles&gt;</code> tag, which should appear before the <code class="literal">&lt;screen&gt;</code> element.</li><li class="listitem">We add <code class="literal">&lt;useControls filename="nifty-default-controls.xml" /&gt;</code> to include access to basic nifty controls such as buttons, and we should add another <code class="literal">&lt;useControls&gt;</code> tag for our options menu. These should also be added before the <code class="literal">&lt;screen&gt;</code> element.</li></ol></div><p>Now, we can start looking at the <code class="literal">Controller</code> code for this. Perform the following five steps to do this:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We should define a class that implements the <code class="literal">ScreenController</code> interface, which will become the link between the GUI and the code. We can make it abstract and call it <code class="literal">NiftyController</code>.</li><li class="listitem">It should have two protected fields, namely, <code class="literal">Nifty nifty</code> and <code class="literal">Screen screen</code>, which will be set from the values provided in the <code class="literal">bind</code> method.</li><li class="listitem">We also need a Boolean field called <code class="literal">optionsMenuVisible</code>.</li><li class="listitem">We need to add methods for each of the methods specified in the <code class="literal">optionsMenu.xml</code> file, and <code class="literal">toggleOptionsMenu()</code> should either show or hide the menu depending on whether <code class="literal">optionsMenuVisible</code> is true or not. A handy way to get hold of an element is by using the following code:<div class="informalexample"><pre class="programlisting">nifty.getCurrentScreen().findElementByName("options");</pre></div></li><li class="listitem">Then, we <a id="id426" class="indexterm"/>can call either <code class="literal">hide()</code> or <code class="literal">show()</code> on the element to control visibility.</li></ol></div><p>Normally, the <a id="id427" class="indexterm"/>application is shut down when <span class="emphasis"><em>Esc</em></span> is pressed. Let's make the options menu handle this instead; this consists of the following four steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Start by deleting the related mapping by adding the following line to the <code class="literal">NiftyAppState</code> initialization method:<div class="informalexample"><pre class="programlisting">app.getInputManager().deleteMapping(SimpleApplication.INPUT_MAPPING_EXIT);</pre></div></li><li class="listitem">Now, we need to add our own mapping for the Esc key, as shown in the following code:<div class="informalexample"><pre class="programlisting">app.getInputManager().addMapping("TOGGLE_OPTIONS", new KeyTrigger(KeyInput.KEY_ESCAPE));
app.getInputManager().addListener(this, "TOGGLE_OPTIONS");</pre></div></li><li class="listitem">The <code class="literal">NiftyAppState</code> method also needs to implement <code class="literal">ActionListener</code> and handle the key press:<div class="informalexample"><pre class="programlisting">public void onAction(String name, boolean isPressed, float tpf) {
  if(name.equals(TOGGLE_OPTIONS) &amp;&amp; isPressed){
 ((NiftyController)nifty.getCurrentScreen().getScreenController()).toggleOptionsMenu();
  }
}</pre></div></li><li class="listitem">With the normal shut down routine removed, we need to add functionality inside <code class="literal">NiftyController</code> to handle this instead. Since this class will be shared by the screens, we provide the application with static access and a setter method. The <code class="literal">quit</code> method just has to call <code class="literal">app.stop()</code> to shut it down.</li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec154"/>How it works...</h2></div></div></div><p>Nifty<a id="id428" class="indexterm"/> was initialized inside <code class="literal">AppState</code> to offset the code from the<a id="id429" class="indexterm"/> main application and make it more modular. This also made it easier to add some more general functionalities related to controlling the GUI.</p><p>Every nifty <code class="literal">Controller</code> class must implement the <code class="literal">ScreenController</code> interface for Nifty to be able to find it. Since some functions will be shared across the screens, we created an abstract class called <code class="literal">NiftyController</code> to avoid duplicating the code. Apart from handling the generic Options menu, it was also given access to the application itself.</p><p>The link between the XML file and the <code class="literal">Controller</code> class doesn't need to be specified beyond providing the qualified name of the controller in the screen. Likewise, Nifty will find methods automatically using the name provided in the <code class="literal">interact</code> tag of <code class="literal">ButtonControl</code>.</p><p>The <code class="literal">&lt;panel&gt;</code> elements are versatile objects that can be used for many parts of the layout and can contain most other types of layout items.</p><p>It's OK to contain several <code class="literal">&lt;controlDefinition&gt;</code> elements within a <code class="literal">&lt;nifty-controls&gt;</code> tag.</p></div><div class="section" title="There's more…"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec155"/>There's more…</h2></div></div></div><p>It's very easy to use a <code class="literal">properties</code> file to back a Nifty file for localization purposes, as given in the following points:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">First <a id="id430" class="indexterm"/>of all, the following tag needs to be present<a id="id431" class="indexterm"/> to link the properties file:<div class="informalexample"><pre class="programlisting">&lt;resourceBundle id="localization" filename="packagename.filename" /&gt;</pre></div></li><li class="listitem" style="list-style-type: disc">It can be called, for example, from a <code class="literal">label</code> control:<div class="informalexample"><pre class="programlisting">&lt;control name="label" text="${localization.STR_HELLO_WORLD}"/&gt;</pre></div></li></ul></div></div></div>
<div class="section" title="Loading the screen"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec64"/>Loading the screen</h1></div></div></div><p>In this<a id="id432" class="indexterm"/> recipe, we'll develop a loading screen along with a controller for the game. It'll cover the most important aspects of the loading screen, such as showing a text and image for what it's loading and an indicator that shows the system is working.</p><p>Before starting this, it's recommended that you have a basic understanding of how to set up Nifty in an application and how to create screens and controllers. Have a look at the previous recipe, <span class="emphasis"><em>Initializing Nifty managing an options menu</em></span>, if you are unsure about this.</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec156"/>How to do it...</h2></div></div></div><p>We begin by creating the XML for the loading screen. Perform the following nine steps to do this:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Create a new file called <code class="literal">loadingScreen.xml</code> and load <code class="literal">Nifty-default-styles</code> and <code class="literal">Nifty-default-controls</code>. Optionally, we can also include <code class="literal">optionsMenu</code> from the previous recipe.</li><li class="listitem">The first element we need is a <code class="literal">&lt;screen&gt;</code> element:<div class="informalexample"><pre class="programlisting">&lt;screen id="loadingScreen" controller="gui.controller.LoadingScreenController"&gt;</pre></div></li><li class="listitem">Inside this, we <a id="id433" class="indexterm"/>define a <code class="literal">&lt;layer&gt;</code> element:<div class="informalexample"><pre class="programlisting">&lt;layer id="layer0" childLayout="center" backgroundColor="#000f"&gt;</pre></div></li><li class="listitem">Inside this <code class="literal">&lt;layer&gt;</code> element, we define <code class="literal">&lt;panel&gt;</code> that will contain our layout. Note that we set <code class="literal">visible</code> to <code class="literal">false</code>:<div class="informalexample"><pre class="programlisting">&lt;panel id="loadingPanel" childLayout="vertical" visible="false"&gt;</pre></div></li><li class="listitem">Since we want a smooth transition to the screen, we'll add a fade effect to this panel:<div class="informalexample"><pre class="programlisting">&lt;effect&gt;
  &lt;onShow name="fade" start="#00" end="#ff" length="500" inherit="true"/&gt;
  &lt;onEndScreen name="fade" start="#ff" end="#00" length="200" inherit="true"/&gt;
&lt;/effect&gt;</pre></div></li><li class="listitem">To add a movie-style and non-interactive feel to it, we will have three <code class="literal">&lt;panel&gt;</code> elements inside this file. At the top and bottom, there will be two black bars captioning the loading image, which will appear in the central panel.</li><li class="listitem">Inside the <code class="literal">topPanel</code> element, we define <code class="literal">&lt;control name="label"&gt;</code> that will contain the name of the scene that is being loaded.</li><li class="listitem">The <code class="literal">bottomPanel</code> element will have an animated indicator that will show the system hasn't frozen. We will define another panel inside this, aligned to the right of the screen. We will use an <code class="literal">imageSizePulsate</code> effect to animate this and have it fade in as well, as shown in the following code:<div class="informalexample"><pre class="programlisting">&lt;effect&gt;
  &lt;onShow name="fade" start="#00" end="#ff" length="1000"/&gt;
  &lt;onShow name="imageSizePulsate" startSize="100%" endSize="50%" pulsator="SinusPulsator" activated="true" timeType="infinite"/&gt;
&lt;/effect&gt;</pre></div></li><li class="listitem">Optionally, we<a id="id434" class="indexterm"/> can also add another <code class="literal">&lt;layer&gt;</code> tag beside the previous one that will contain the <code class="literal">options</code> control from the previous recipe.</li></ol></div><p>Now, we have a complete XML. Let's have a look at the controller for this. We will create it by performing the following seven steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We begin by creating a new class called <code class="literal">LoadingScreenController</code> that extends the <code class="literal">NiftyController</code> class we created in the previous recipe.</li><li class="listitem">We define two strings, <code class="literal">loadingText</code> and <code class="literal">loadingScreen</code>, and setters for these as well.</li><li class="listitem">Next, we override the <code class="literal">onStartScreen()</code> method and add the following three lines to it:<div class="informalexample"><pre class="programlisting">screen.findNiftyControl("caption", Label.class).setText(loadingText); screen.findElementByName("centralPanel").getRenderer(ImageRenderer.class).setImage(nifty.createImage(loadingScreen, true));
screen.findElementByName("loadingPanel").setVisible(true);</pre></div></li><li class="listitem">The controller is now done. However, there are some more things we need to do before we can look at it.</li><li class="listitem">First, we need to add the screen to Nifty. If we have the <code class="literal">NiftyAppState</code> method from the previous recipe, we should add the following line just after the <code class="literal">nifty.fromXml</code> call:<div class="informalexample"><pre class="programlisting">nifty.addXml("Interface/Screens/loadingScreen.xml");</pre></div></li><li class="listitem">We can also add a <code class="literal">convenience</code> class to access <code class="literal">nifty.gotoScreen()</code>.</li><li class="listitem">Now, before calling <code class="literal">gotoScreen("loadingScreen")</code> from our main class, we can add the following lines to set <code class="literal">lodingText</code> and <code class="literal">loadingImage</code>:<div class="informalexample"><pre class="programlisting">((LoadingScreenController)niftyState.getNifty().getScreen("loadingScreen").getScreenController()).setLoadingText("Loading Test Scene"); ((LoadingScreenController)niftyState.getNifty().getScreen("loadingScreen").getScreenController()).setLoadingImage("Interface/Image/loadingScreen.png");</pre></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec157"/>How it works...</h2></div></div></div><p>Most of the <a id="id435" class="indexterm"/>work in this recipe consists of getting the XML layout right. It's a good idea to sketch it on paper first and visualize the flow of the elements.</p><p>The reason the fade effect is shorter is because by the time it fades out, the game is ready to be played and the player doesn't need to wait longer than necessary. When the loading screen is first shown, the player has to wait for the game to load.</p><p>There is a reason why we set <code class="literal">loadingPanel</code> to <code class="literal">visible="false"</code> at the beginning and used <code class="literal">onShow</code> rather than <code class="literal">onScreenStart</code> effects. The <code class="literal">onStartScreen</code> method in the controller is called after the screen has been started and <code class="literal">onScreenStart</code> effects have been fired (and completed). This means that any fading will occur before we set the images, and they would pop into existence after some time has passed. Since the <code class="literal">onShow</code> effects are called once the element becomes visible, we get around that problem this way.</p><p>Another possible gotcha here, especially if we use a test case to show the screen, is that we can't call <code class="literal">nifty.gotoScreen</code> just after initializing <code class="literal">NiftyAppState</code>. Since the <code class="literal">AppState</code> initialization method is called in a thread-safe way, it doesn't run until the next update <a id="id436" class="indexterm"/>cycle. This means that if we try to change the screens on the next line, we will get <code class="literal">NullPointerException</code>.</p></div></div>
<div class="section" title="Creating an RPG dialog screen"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec65"/>Creating an RPG dialog screen</h1></div></div></div><p>As the title implies, we'll explore a method to create a dialog screen, similar to those found in <a id="id437" class="indexterm"/>many RPGs. It'll display an image of the character being talked to, but this could be replaced by using some clever camera work to zoom in on a character instead.</p><p>It will <a id="id438" class="indexterm"/>use a Nifty <code class="literal">ListBox</code> to display the player's available dialog options and a listener to find out the result of the player's choice.</p><p>There most likely has to be some dialog tree system that backs the implementation. For this example, we'll use a template class called <code class="literal">DialogNode</code>. This will have information about a character's name, image, and what it says. It also contains the player's options as a string array, as shown in the following screenshot. What's missing from it is the callbacks for each option. It will, however, be possible to call it from the controller's listener method.</p><div class="mediaobject"><img src="graphics/6478OS_06_01.jpg" alt="Creating an RPG dialog screen"/></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec158"/>How to do it...</h2></div></div></div><p>Before we work on the screen, we should define a new reusable Nifty control to contain the character information of the character the player is talking to; perform the following steps to do this:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Create a new file called <code class="literal">characterDialogControls.xml</code> with the <code class="literal">&lt;nifty-controls&gt;</code> tag, and inside it, create a new <code class="literal">&lt;controlDefinition name="characterControl"&gt;</code> class.</li><li class="listitem">The layout<a id="id439" class="indexterm"/> for this is fairly simple; it needs one <code class="literal">&lt;panel&gt;</code> element that contains another <code class="literal">&lt;panel&gt;</code> for the character image and a <code class="literal">&lt;control name="label"&gt;</code> element for the name.</li></ol></div><p>Now, let's build the dialog screen. We do this by performing the following nine steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Create a new file called <code class="literal">dialogScreen.xml</code> and load <code class="literal">nifty-default-styles</code> and <code class="literal">nifty-default-controls</code>. It should also load the <code class="literal">characterDialogControls.xml</code> file. We can also include <code class="literal">optionsMenu</code> from the previous recipe.</li><li class="listitem">The first element we need is a <code class="literal">&lt;screen&gt;</code> element:<div class="informalexample"><pre class="programlisting">&lt;screen id="dialogScreen" controller="gui.controller.DialogScreenController"&gt;</pre></div></li><li class="listitem">Inside<a id="id440" class="indexterm"/> this, we define a <code class="literal">&lt;layer&gt;</code> element:<div class="informalexample"><pre class="programlisting">&lt;layer id="layer0" childLayout="center" backgroundColor="#0000"&gt;</pre></div></li><li class="listitem">Inside the <code class="literal">&lt;layer&gt;</code> element, we define <code class="literal">&lt;panel&gt;</code>, which will contain the rest of our layout:<div class="informalexample"><pre class="programlisting">&lt;panel id="dialogPanel" childLayout="vertical" visible="false"&gt;</pre></div></li><li class="listitem">We'll add a short fade effect to this panel as well:<div class="informalexample"><pre class="programlisting">&lt;effect&gt;
  &lt;onShow name="fade" start="#00" end="#ff" length="200" inherit="true"/&gt;
  &lt;onEndScreen name="fade" start="#ff" end="#00" length="200" inherit="true"/&gt;
&lt;/effect&gt;</pre></div></li><li class="listitem">The dialog panel will have four <code class="literal">&lt;panel&gt;</code> elements inside it. At the top and bottom, we should add two thin panels with black background to give it a cinematic feel.</li><li class="listitem">The upper part of the two central panels will contain the <code class="literal">characterControl</code> we just created:<div class="informalexample"><pre class="programlisting">&lt;control name="characterControl" id="character"/&gt;</pre></div></li><li class="listitem">The lower one will have a listbox that contains the player's dialog options:<div class="informalexample"><pre class="programlisting">&lt;control id="dialogOptions" name="listBox" vertical="off" horizontal="off" displayItems="3" selection="Single"/&gt;</pre></div></li><li class="listitem">If we also want support for the options menu, it should go in a separate layer to make it show on top of the rest of the GUI.</li></ol></div><p>The controller <a id="id441" class="indexterm"/>code for it can be created by performing the following 12 steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Begin by defining a new class called <code class="literal">DialogScreenController</code> that extends <code class="literal">NiftyController</code> or implements <code class="literal">ScreenController</code> if an abstract <code class="literal">Controller</code> class is not available.</li><li class="listitem">Next, we add two fields: one for the current <code class="literal">DialogNode</code>, <code class="literal">dialogNode</code>, and a reference to <code class="literal">ListBox</code> in the XML called <code class="literal">dialogOptions</code>.</li><li class="listitem">The <code class="literal">onStartScreen()</code> method should be overridden; here, it should set <code class="literal">dialogOptions</code> by calling <code class="literal">screen.findNiftyControl</code>:<div class="informalexample"><pre class="programlisting">dialogOptions = screen.findNiftyControl("dialogOptions", ListBox.class);</pre></div></li><li class="listitem">Finally, <code class="literal">onStartScreen</code> should also call <code class="literal">onDialogNodeChanged()</code> if <code class="literal">dialogNode</code> is set.</li><li class="listitem">Now, we need to define the method called <code class="literal">onDialogNodeChanged</code> that will apply the dialog information to the layout.</li><li class="listitem">We should begin this by setting the name of the character; again, we will use <code class="literal">screen.findNiftyControl</code> to do this:<div class="informalexample"><pre class="programlisting">screen.findNiftyControl("characterName", Label.class).setText(dialogNode.getCharacterName());</pre></div><p>Likewise, the dialog text is set in the same manner.</p></li><li class="listitem">To set <a id="id442" class="indexterm"/>the image, we need to create <code class="literal">NiftyImage</code> and pass it on to <code class="literal">ImageRenderer</code> of an element using the following code:<div class="informalexample"><pre class="programlisting">screen.findElementByName("characterImage").getRenderer(ImageRenderer.class).setImage(nifty.createImage(dialogNode.getCharacterImage(), true));</pre></div></li><li class="listitem">Next, we clear <code class="literal">dialogOptions</code> and use <code class="literal">dialogOptions.addItem</code> to apply the values available in <code class="literal">DialogNode</code>.</li><li class="listitem">Finally, we call <code class="literal">dialogOptions.refresh()</code> and <code class="literal">screen.layoutLayers()</code> and set the <code class="literal">dialogPanel</code> element to be visible.</li><li class="listitem">To find out which item is pressed in <code class="literal">dialogOptions</code>, we add a listener method to the class:<div class="informalexample"><pre class="programlisting">public void onDialogOptionSelected(final String id, final ListBoxSelectionChangedEvent event)</pre></div></li><li class="listitem">Then, we add an annotation to let it know which element to listen to:<div class="informalexample"><pre class="programlisting">@NiftyEventSubscriber(id="dialogOptions")</pre></div></li><li class="listitem">Using <code class="literal">event.getSelectionIndices()</code>, we can find out which item the player has pressed.</li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec159"/>How it works...</h2></div></div></div><p>Getting the layout exactly as we want can be tricky sometimes, but in general, it's important to know that Nifty really likes the width and height to be defined.</p><p>Using the ListBox here gives us a lot for free since it handles a dynamic number of options, and callbacks to the code are easily handled with the <code class="literal">listener</code> method. By default, it has<a id="id443" class="indexterm"/> scrollbars and handles multiple selection, which is why we explicitly defined it to be <code class="literal">selection="Single"</code> and used <code class="literal">vertical="off"</code> and <code class="literal">horizontal="off"</code> to turn off the scrollbars. It also supports item selection by using the up, down, and <span class="emphasis"><em>Enter</em></span> keys.</p><p>The listener method in the controller can be referred to as anything; what Nifty looks for is the annotation and the method's parameters. From here, we can call the next <code class="literal">DialogNode</code> or other code based on the player's choices.</p></div></div>
<div class="section" title="Implementing a game console"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec66"/>Implementing a game console</h1></div></div></div><p>A console <a id="id444" class="indexterm"/>can be a very powerful tool that allows a player to have control over game functions that might either not have a functional UI yet, or where setting up a UI is simply not be feasible due to its complexity.</p><p>This recipe will implement a console in the main screen from the first recipe in this chapter and also use the <code class="literal">Move</code> effect to slide it in and out of view. Moreover, it will describe how to use console commands to let the player control the game functions.</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec160"/>How to do it...</h2></div></div></div><p>Just as before, we begin by defining a control that will host the console. It can be done by performing the following four steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Inside the <code class="literal">&lt;nifty-controls&gt;</code> tags, we add a new <code class="literal">&lt;controlDefinition name="consoleControl"&gt;</code> class.</li><li class="listitem">Then, we add a small console, aligning it with the bottom of the screen:<div class="informalexample"><pre class="programlisting">&lt;control id="console" name="nifty-console" lines="10" width="100%" valign="bottom" backgroundColor="#6874" visible="true"&gt;</pre></div></li><li class="listitem">To spice up the simple console, we give it a <code class="literal">Move</code> effect when it's being shown or hidden:<div class="informalexample"><pre class="programlisting">&lt;effect&gt;
  &lt;onShow name="move" mode="fromOffset" offsetY="100" length="300" inherit="true"/&gt;
  &lt;onHide name="move" mode="toOffset" offsetY="100" length="200" inherit="true"/&gt;
&lt;/effect&gt;</pre></div></li><li class="listitem">In <code class="literal">mainScreen.xml</code>, we add <code class="literal">controlDefinition</code> inside a new layer:<div class="informalexample"><pre class="programlisting">&lt;layer id="consoleLayer" childLayout="center" backgroundColor="#0000"&gt;
  &lt;control name="consoleControl"/&gt;
&lt;/layer&gt;</pre></div></li></ol></div><p>That's it for XML hacking. Now, we can turn our attention to the <code class="literal">NiftyController</code> class from the <span class="emphasis"><em>Initializing Nifty and managing an options menu</em></span> recipe and add a console to handle to it. This can be done by performing the following 10 steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We need to add a new field, <code class="literal">Console console</code>, and bind it using the following code:<div class="informalexample"><pre class="programlisting">nifty.getScreen("main").findNiftyControl("console", Console.class);</pre></div></li><li class="listitem">Next, we add a method about the output text to the console from external sources. We <a id="id445" class="indexterm"/>call it <code class="literal">outputToConsole</code>, and it takes a string as an input. It then calls <code class="literal">console.output</code> to display the message.</li><li class="listitem">Another <a id="id446" class="indexterm"/>new method is <code class="literal">toggleConsole()</code>. It should check whether <code class="literal">console.getElement()</code> is visible or not and then hide or show it accordingly.</li><li class="listitem">Then, we add a <code class="literal">subscriber</code> method that will receive anything entered in the console. It needs the <code class="literal">@NiftyEventSubscriber</code> annotation with the console as its ID. It also needs a method declaration that looks like the following code:<div class="informalexample"><pre class="programlisting">public void onConsoleCommand(final String id, final ConsoleExecuteCommandEvent command)</pre></div></li><li class="listitem">Define<a id="id447" class="indexterm"/> a new class called <code class="literal">HideCommand</code> that implements <code class="literal">ConsoleCommand</code>.</li><li class="listitem">Add a field <code class="literal">NiftyController</code> controller together with a setter method to the <code class="literal">HideCommand</code> class.</li><li class="listitem">In the implemented <code class="literal">execute</code> method, we call <code class="literal">controller.toggleConsole()</code>.</li><li class="listitem">Going back to <code class="literal">NiftyController</code>, we instantiate a new <code class="literal">HideCommand</code> method and set the controller.</li><li class="listitem">We then create a new <code class="literal">ConsoleCommands</code> instance and call <code class="literal">registerCommand</code>; thereafter, we supply/hide the instance and call <code class="literal">commandText</code>, and <code class="literal">HideCommand</code> as <code class="literal">ConsoleCommand</code>.</li><li class="listitem">Finally, we call <code class="literal">enableCommandCompletion(true)</code> in the <code class="literal">ConsoleCommands</code> instance.</li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec161"/>How it works...</h2></div></div></div><p>In this<a id="id448" class="indexterm"/> recipe, we implemented two ways of handling the input in the console. The most straightforward way is the <code class="literal">onConsoleCommand</code> method where we get the raw input and can do whatever we want with it.</p><p>The more intricate way of doing this is using <code class="literal">ConsoleCommands</code>. With this, we get a nice layered pattern to handle the input. Once the console is shown or hidden, it will quickly slide in or out of the screen with the move effect. It will move the <code class="literal">offsetY</code> distance, and based on the mode, it will either move to that offset or from it. The <code class="literal">inherit="true"</code> value ensures that child elements move together with the component in question.</p></div></div>
<div class="section" title="Handling a game message queue"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec67"/>Handling a game message queue</h1></div></div></div><p>It is possible to relay most game-related information to the player using a console. However, it's a<a id="id449" class="indexterm"/> very basic form of communication. Modern players often expect more graphical ways of receiving information. In this recipe, we'll explore one way of doing this using Nifty. We'll create a dynamic message queue with messages moving in from the right of the screen and fading out once clicked.</p><p>It actually doesn't require that many lines of code.</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec162"/>How to do it...</h2></div></div></div><p>The XML for this recipe can be completed by performing the following five steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We start by defining a new <code class="literal">&lt;controlDefinition name="gameMessage"&gt;</code>.</li><li class="listitem">Inside this, we should add a <code class="literal">panel</code> element, and inside this <code class="literal">panel</code> element, add two <code class="literal">&lt;control name="label"&gt;</code> elements with the ID <code class="literal">#title</code> and other contents.</li><li class="listitem">The panel should also have two effects, one <code class="literal">onShow</code> trigger and one <code class="literal">onHide</code> trigger with move and fade effects respectively, as shown in the following code:<div class="informalexample"><pre class="programlisting">&lt;onShow name="move" mode="fromOffset" offsetX="1500" length="100" inherit="true"/&gt;
&lt;onHide name="fade" start="#ff" end="#00" length="100" inherit="true"/&gt;</pre></div></li><li class="listitem">In <a id="id450" class="indexterm"/>addition to the <code class="literal">gameMessage</code> control, we can define another control to be our <code class="literal">messageQueue</code> element. It just needs a horizontally aligned panel, spanning the whole screen.</li><li class="listitem">To make them align with each other, the <code class="literal">messageQueue</code> control is added to the <code class="literal">mainScreen.xml</code> file inside the same layer as the console.<p>Inside <code class="literal">MainScreenController</code>, we need to do the following changes:</p></li><li class="listitem">First, add a new <code class="literal">int</code> field called <code class="literal">messageIndex</code>.</li><li class="listitem">Then, we need two methods. One of these is called <code class="literal">addMessage</code> that should take a string as an input.</li><li class="listitem">Inside the <code class="literal">addMessage</code> method, we define a <code class="literal">ControlBuilder</code> method called <code class="literal">messageBuilder</code>. This will create <code class="literal">gameMessage</code> controls:<div class="informalexample"><pre class="programlisting">messageBuilder = new ControlBuilder("gameMessage") {{
  id("message"+messageIndex);
  interactOnClick("removeMessage("+messageIndex+")");
}};</pre></div></li><li class="listitem">After calling the <code class="literal">build</code> method on this and supplying the <code class="literal">messageQueue</code> element as the parent, we can call <code class="literal">element.findNiftyControl</code> to set the title and the text on the labels inside the <code class="literal">gameMessage</code> control.</li><li class="listitem">Then, we call <code class="literal">element.show()</code> and increase <code class="literal">messageIndex</code> for the next message.</li><li class="listitem">The second method we create is <code class="literal">removeMessage</code>. It takes a string called <code class="literal">id</code> as the input.</li><li class="listitem">Inside this, we use <code class="literal">screen.findElementByName</code> to find the message, and call <code class="literal">hide</code>.</li><li class="listitem">While doing this, we supply a new <code class="literal">EndNotify</code> object, which in its <code class="literal">perform</code> message should call <code class="literal">markForRemoval()</code> on the message and also <code class="literal">layoutElements()</code> on the parent <code class="literal">messageQueue</code> control.</li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec163"/>How it works...</h2></div></div></div><p>Once the <code class="literal">addMessage</code> method is called in the <code class="literal">Controller</code> class, <code class="literal">ControlBuilder</code> creates a new <code class="literal">gameMessage</code> instance. The <code class="literal">interactOnClick</code> element tells <code class="literal">gameMessage</code> to call <code class="literal">removeMessage</code> when clicked, supplying its index as <code class="literal">id</code>.</p><p>After its built and added to <code class="literal">messageQueue</code>, we populate the title and content elements of the<a id="id451" class="indexterm"/> message. Using <code class="literal">#</code> in the ID of these elements is preferred by Nifty for non-unique IDs.</p><p>The <code class="literal">gameMessage</code> instance is not visible upon creation, and we call <code class="literal">show()</code> to make it play the <code class="literal">onShow</code> effect we defined.</p><p>The <code class="literal">Move</code> effect is set up to have <code class="literal">offsetX</code>, which is outside of the screen. If it's too low, there will be a pop effect as it comes into existence. It's set to reach the target position in 100 ms. Messages will stack up nicely without any additional work when they are added.</p><p>The messages are set to disappear when clicked, as defined in the builder, through the <code class="literal">interactOnClick</code> method. Instead of just removing them, we want to play a short fade effect to make the transition smoother. Simply hiding them won't be enough in this case either. Since they still occupy a position in the <code class="literal">messageQueue</code> panel, the remaining messages won't align properly.</p><p>Hence, we want to call <code class="literal">markForRemoval</code> on the <code class="literal">gameMessage</code> element. Doing this instantly, however, would remove it before our hide effect is played. This why we supply an <code class="literal">EndNotify</code> object that is handled once the hide effect is done with playing; then, we add the <code class="literal">markForRemoval</code> call in here instead.</p></div><div class="section" title="There's more…"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec164"/>There's more…</h2></div></div></div><p>Let's say we would like to be able to show messages in a window, either when clicking the message in the queue, or any time. In that case, we can use Nifty's window control.</p><p>We can define a new <code class="literal">controlDefinition</code> in our <code class="literal">gameMessageControls.xml</code> file and call it <code class="literal">messageWindow</code>. Inside this, we'll add <code class="literal">&lt;control name="window"&gt;</code>, inside which we can add any content we'd like. For now, we can settle with <code class="literal">&lt;control name="label"&gt;</code> for text content and a short fade effect when showing or hiding the window.</p><p>Then, we can copy the <code class="literal">addMessage</code> method to <code class="literal">MainScreenController</code>, and instead of having <code class="literal">ControlBuilder</code> make <code class="literal">gameMessage</code>, we can tell it to build a <code class="literal">messageWindow</code> window instead.</p><p>We don't need <a id="id452" class="indexterm"/>an <code class="literal">interactOnClick</code> element, as the window can be closed by default. Instead, we can use it to set the title of the window:</p><div class="informalexample"><pre class="programlisting">set("title", "Window"+windowIndex);</pre></div><p>Windows are also draggable by default, but the parent element must have <code class="literal">childLayout="absolute"</code> for it to work, as it lets the element decide its position itself.</p></div></div>
<div class="section" title="Creating an inventory screen"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec68"/>Creating an inventory screen</h1></div></div></div><p>In this recipe, we'll <a id="id453" class="indexterm"/>create an inventory screen, which is very common, mostly in RPGs. To do this, we'll use the <code class="literal">Droppable</code> and <code class="literal">Draggable</code> components in Nifty and create an <code class="literal">InventoryItem</code> class to help us differentiate different the types of items (and hence, where they can be attached). This time, we'll use both XML to create the static components and the Java Builder interface to build the inventory (or backpack) slots. The reason is that in many games, the amount of inventory a character has varies.</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec165"/>How to do it...</h2></div></div></div><p>We begin by creating the controls, which are the key components of this method. This can be done by performing the following four steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">First, we create a new controls file, <code class="literal">inventoryControls.xml</code>, with the <code class="literal">&lt;nifty-controls&gt;</code> tag.</li><li class="listitem">Inside this, we first define <code class="literal">&lt;controlDefinition name="itemSlot"&gt;</code> with the following content:<div class="informalexample"><pre class="programlisting">&lt;control name="droppable" backgroundColor="#fff5" width="64px" height="64px" margin="1px" childLayout="center"/&gt;</pre></div></li><li class="listitem">Then similarly, we create a draggable control to be the item, and name it <code class="literal">&lt;controlDefinition name="item" &gt;</code>.</li><li class="listitem">This item contains both the draggable component and a label with the item's name:<div class="informalexample"><pre class="programlisting">&lt;control name="draggable" backgroundColor="#aaaf" width="64px" height="64px" childLayout="center" valign="top"&gt;
  &lt;text id="#itemLabel" text="" color="#000f" valign="center" width="100%" style="nifty-label"/&gt;
&lt;/control&gt;</pre></div></li></ol></div><p>Next, we can turn our attention to the screen itself. It can be created by performing the following five steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">First, we make sure that the styles we want to use are loaded, and add our <code class="literal">inventoryControls.xml</code> file is loaded with <code class="literal">&lt;useControls&gt;</code>.</li><li class="listitem">Then, we add a <code class="literal">&lt;screen&gt;</code> element with a link to our controller file:<div class="informalexample"><pre class="programlisting">&lt;screen id="inventoryScreen" controller="gui.controller.InventoryScreenController"&gt;</pre></div></li><li class="listitem">Inside this, we need a <code class="literal">&lt;layer&gt;</code> element:<div class="informalexample"><pre class="programlisting">&lt;layer id="layer0" childLayout="center" backgroundColor="#0000"&gt;</pre></div></li><li class="listitem">Inside the <code class="literal">&lt;layer&gt;</code> element, we need a <code class="literal">&lt;panel&gt;</code> element that will contain the rest of our layout:<div class="informalexample"><pre class="programlisting">&lt;panel id="inventoryPanel" childLayout="horizontal"&gt;</pre></div></li><li class="listitem">The next element is a panel that will keep our dynamically created <code class="literal">itemSlots</code>:<div class="informalexample"><pre class="programlisting">&lt;panel id="inventorySlots" childLayout="horizontal"/&gt;</pre></div><p>The following screenshot shows us the dynamically created item slots:</p><div class="mediaobject"><img src="graphics/6478OS_06_02.jpg" alt="How to do it..."/></div><p>After this, we create a simple representation of a humanoid with two hands and feet, using the <code class="literal">itemSlot</code> control. We use <code class="literal">align</code> and <code class="literal">childLayout</code> to make the components appear where we want them to.</p></li><li class="listitem">First, add a<a id="id454" class="indexterm"/> panel to contain the components:<div class="informalexample"><pre class="programlisting">&lt;panel id="characterPanel" childLayout="vertical"&gt;</pre></div></li><li class="listitem">Then, add the head using the following command:<div class="informalexample"><pre class="programlisting">&lt;panel id="character" backgroundColor="#000f" childLayout="center" align="center" valign="top"&gt;
  &lt;control name="itemSlot" id="Head"/&gt;
&lt;/panel&gt;</pre></div></li><li class="listitem">Add one left and right hand using the following command:<div class="informalexample"><pre class="programlisting">&lt;panel id="hands" backgroundColor="#000f" childLayout="horizontal" width="25%" align="center" valign="bottom"&gt;
  &lt;control name="itemSlot" id="HandLeft" align="left" /&gt;
  &lt;panel width="*" height="1px"/&gt;
  &lt;control name="itemSlot" id="HandRight" align="right" /&gt;
&lt;/panel&gt;</pre></div></li><li class="listitem">Finally, we have one <code class="literal">itemSlot</code> for the legs/feet:<div class="informalexample"><pre class="programlisting">&lt;panel id="legs" backgroundColor="#000f" childLayout="horizontal" align="center" valign="bottom"&gt;
  &lt;control name="itemSlot" id="Foot"/&gt;
&lt;/panel&gt;</pre></div></li></ol></div><p>With the XML elements done, we can turn to the Java code. The following nine steps are necessary:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We create a class called <code class="literal">InventoryItem</code>. This has an enum (enumeration) for different body parts: head, hand, foot, and a name.</li><li class="listitem">Next, we'll create the <code class="literal">Controller</code> class, <code class="literal">InventoryScreenController</code>, and have it extend <code class="literal">NiftyController</code>; also, implement <code class="literal">DroppableDropFilter</code>.</li><li class="listitem">We need<a id="id455" class="indexterm"/> to add a map to contain our <code class="literal">InventoryItems</code>, with the name as the key. It can be called <code class="literal">itemMap</code>.</li><li class="listitem">The <code class="literal">bind</code> method should be overridden, and in here, we should find different <code class="literal">DropControls</code> in the <code class="literal">InventoryScreen</code> and add this class as a filter using the following code:<div class="informalexample"><pre class="programlisting">screen.findNiftyControl("HandLeft", Droppable.class).addFilter(this);</pre></div><p>Now, we can generate the item slots in the inventory in a 5 x 5 grid.</p></li><li class="listitem">We define two builders: <code class="literal">ControlBuilder</code> for the itemSlot controls and <code class="literal">PanelBuilder</code> to make columns that will contain five itemSlots each.</li><li class="listitem">We can use a <code class="literal">for</code> loop to iterate five times over the following block:<div class="informalexample"><pre class="programlisting">panelBuilder = new PanelBuilder("") {{
  id("inventoryColumn"+posX);
  childLayoutVertical();
}};
panelBuilder.build(nifty, screen, screen.findElementByName("inventorySlots"));</pre></div></li><li class="listitem">While still inside this <code class="literal">for</code> loop, we run another <code class="literal">for</code> loop, generating the five item slots for that column:<div class="informalexample"><pre class="programlisting">slotBuilder = new ControlBuilder("itemSlot") {{
  id("itemSlot"+index);
}};
Element e = slotBuilder.build(nifty, screen, screen.findElementByName("inventoryColumn"+posY));</pre></div></li><li class="listitem">For each of the item slots, we also need to add the following class as a DropFilter:<div class="informalexample"><pre class="programlisting">e.findNiftyControl("itemSlot"+index, Droppable.class).addFilter(this);</pre></div></li><li class="listitem">The implemented method that is accepted needs some logic. Once an item has been dropped on an <code class="literal">itemSlot</code>, we should check whether it's allowed, and we can do it with the following lines of code:<div class="informalexample"><pre class="programlisting">InventoryItem item = itemMap.get(drgbl.getId());
if(drpbl1.getId().startsWith(item.getType().name()) || drpbl1.getId().startsWith("itemSlot")){
  return true;</pre></div><p>With the item slots done, we can generate some items for testing.</p></li><li class="listitem">First we<a id="id456" class="indexterm"/> use a <code class="literal">for</code> loop to create 10 <code class="literal">InventoryItems</code> with different types and names.</li><li class="listitem">For each of these, we create a Nifty control using <code class="literal">ControlBuilder</code> and the item control we defined earlier, as shown in the following code:<div class="informalexample"><pre class="programlisting">itemBuilder = new ControlBuilder("item") {{
  id("item"+index);
  visibleToMouse(true);
}};
Element e = itemBuilder.build(nifty, screen, screen.findElementByName("itemSlot"+index)); e.findElementByName("#itemLabel").getRenderer(TextRenderer.class).setText(item.getName());</pre></div></li><li class="listitem">Then, we put each of the inventory items in the itemMap with the ID of the control as the key. This ensures we can easily find out the link to the inventory item where a nifty item has been dragged or dropped.</li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec166"/>How it works...</h2></div></div></div><p>The <a id="id457" class="indexterm"/>Java Builder interface we use to create item slots takes a while to get used to, but it's a really powerful tool when we have the need to create nifty elements dynamically. In this case, we still use a predefined control. This saves us a couple of lines of code and allows someone else than a coder to edit the layout and style of the component since it's exposed in the XML file.</p><p>By default, a <code class="literal">Droppable</code> control will always accept the <code class="literal">Draggable</code> control that is being dropped. The <code class="literal">accept</code> method in <code class="literal">DroppableDropFilter</code> enables us to define what should be<a id="id458" class="indexterm"/> accepted or not. It's illustrated in this recipe by only accepting <code class="literal">InventoryItems</code> of a certain type. The method parameters for the accept method can be described, as the first <code class="literal">Droppable</code> is the control that the <code class="literal">draggable</code> control is being picked up from. The <code class="literal">Draggable</code> control is the item that is being moved. The second <code class="literal">Droppable</code> control is the target where <code class="literal">Draggable</code> has been dropped.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip16"/>Tip</h3><p>At the time of writing this, the first <code class="literal">Droppable</code> control tends to be null the first time a <code class="literal">Draggable</code> control is being moved.</p></div></div></div></div>
<div class="section" title="Customizing the input and settings page"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec69"/>Customizing the input and settings page</h1></div></div></div><p>Just <a id="id459" class="indexterm"/>about every modern game lets the player customize the input according to<a id="id460" class="indexterm"/> their own preferences. This recipe will rely on jMonkeyEngine to do the work for us, and we will use Nifty GUI as a visual aid. We'll use <code class="literal">RawInputListener</code> to work out which keys have been pressed and divide them between key codes and characters using the <code class="literal">Keyboard</code> class.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec167"/>Getting ready</h2></div></div></div><p>The recipe will depend on there being some bindings in <code class="literal">InputManager</code>. If you already have a game, this would not be a problem. If not, it will describe how to add a couple of bindings for the example to work.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec168"/>How to do it...</h2></div></div></div><p>Following<a id="id461" class="indexterm"/> the pattern from previous recipes, we'll start defining the <a id="id462" class="indexterm"/>controls, then move on to the screen, and finally work on the controller. Adding the controls and screen will consist of the following eight steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Inside a <code class="literal">&lt;nifty-control&gt;</code> tag, we define a new <code class="literal">&lt;controlDefinition name="keyBindingControl"&gt;</code>.</li><li class="listitem">Here, we'll add a horizontal spanning panel with some margin to the edges of its container and enough height to contain text:<div class="informalexample"><pre class="programlisting">&lt;panel childLayout="horizontal" width="80%" height="25px" backgroundColor="#666f" marginLeft="10px" marginRight="10px" marginTop="4px" align="center" &gt;</pre></div></li><li class="listitem">This panel will have three elements. The first is a label control that contains the text for the key binding, as shown in the following code:<div class="informalexample"><pre class="programlisting">&lt;control name="label" id="#command" width="150px" text=""/&gt;</pre></div></li><li class="listitem">Then, it will have a button to change the binding, displaying the current key:<div class="informalexample"><pre class="programlisting">&lt;control name="button" id="#key" width="100px" valign="center"/&gt;</pre></div></li><li class="listitem">In between them, it will have a simple panel with <code class="literal">width="*"</code>.</li><li class="listitem">Now, we can define another <code class="literal">&lt;controlDefinition name="settingsControl"&gt;</code> that will contain a number of our <code class="literal">keyBindingControls</code>.</li><li class="listitem">This <a id="id463" class="indexterm"/>will contain a panel, and inside this, four <code class="literal">keyBindingControls</code> for each moving direction. The IDs of these controls should be <a id="id464" class="indexterm"/>representative of the direction and end with a key as follows:<div class="informalexample"><pre class="programlisting">&lt;control name="keyBindingControl" id="forwardKey"/&gt;</pre></div></li><li class="listitem">The following points are needed for the screen:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The ID should be settings, and controller should be <code class="literal">gui.controller.SettingsController</code></li><li class="listitem" style="list-style-type: disc">The <code class="literal">settingsControl</code> class we just created should be added inside a layer element</li></ul></div></li></ol></div><p>That's all with regards to XML. To <a id="id465" class="indexterm"/>create the <code class="literal">Controller</code> class, perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">As usual, we create a new class that extends <code class="literal">NiftyController</code>. We call it <code class="literal">SettingsController</code>.</li><li class="listitem">We'll have <code class="literal">Element</code> fields for each of the key bindings we would like to track and one <code class="literal">Element</code> field for the current <code class="literal">selectedElement</code>.</li><li class="listitem">In addition, we should add <code class="literal">Map&lt;Integer, String&gt;</code> called <code class="literal">mappings</code> where we can keep the relations between key inputs and input bindings.</li><li class="listitem">From here, we should call a <code class="literal">bindElements</code> method, which we'll define as well.</li><li class="listitem">Inside this, we'll add the current key bindings to the <code class="literal">mappings</code> map using the key code as key and the actual binding as the value. This can usually be found in the class that handles the input.</li><li class="listitem">Next, for each of the keys we would like to handle, we find the reference in the settings screen and populate their values accordingly. For example, for the forward key use the following code:<div class="informalexample"><pre class="programlisting">forwardMapping = screen.findElementByName("forwardKey");
forwardMapping.findNiftyControl("#command", Label.class).setText("MoveForward");
forwardMapping.findNiftyControl("#key", Button.class).setText(Keyboard.getKeyName(KeyInput.KEY_W));</pre></div></li><li class="listitem">Next, we <a id="id466" class="indexterm"/>define a new inner class called <code class="literal">KeyEventListener</code> that implements <code class="literal">RawInputListener</code>.</li><li class="listitem">In <code class="literal">onKeyEvent</code>, add an <code class="literal">if</code> statement for if the incoming <code class="literal">KeyInputEvent</code> is pressed and <code class="literal">selectedElement</code> is not null.</li><li class="listitem">Here, we<a id="id467" class="indexterm"/> add a reference to the yet-to-be-created <code class="literal">changeMapping</code> method and add the following line:<div class="informalexample"><pre class="programlisting">selectedElement.findNiftyControl("#key", Button.class).setText(Keyboard.getKeyName(evt.getKeyCode()));</pre></div></li><li class="listitem">Finally, we should set <code class="literal">selectedElement</code> to <code class="literal">null</code>.<p>Now, we can turn our attention to the <code class="literal">changeMapping</code> method.</p></li><li class="listitem">This method has the pressed key code as an input parameter, and we use this to see whether we already have a binding in our <code class="literal">mappings</code> map. If <code class="literal">inputManager</code> of the application also has this, we should delete the old binding.</li><li class="listitem">Next, we need to iterate through all the values in our <code class="literal">mappings</code> map and check whether any of the bindings match the one that the selected element is handling. If you find a match, it should be deleted.</li><li class="listitem">Finally, we create a new <code class="literal">KeyTrigger</code> class using <code class="literal">keyCode</code> and add it to <code class="literal">inputManager</code> using <code class="literal">addMapping</code>.<p>The last thing we need to do in this class is add an event subscriber to the buttons in <code class="literal">keyBindingControls</code>.</p></li><li class="listitem">We define a new method, <code class="literal">keyClicked(String id, ButtonClickedEvent event)</code>, and give it the following annotation:<div class="informalexample"><pre class="programlisting">@NiftyEventSubscriber(pattern=".*Key#key")</pre></div></li><li class="listitem">When the button is clicked, the corresponding element should be selected, so we use <code class="literal">event.getButton().getElement().getParent()</code> to find out which one that is.</li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec169"/>How it works...</h2></div></div></div><a id="id468" class="indexterm"/><p>This recipe explains that when a button that represents a<a id="id469" class="indexterm"/> key binding is clicked, the corresponding element is selected. By using a pattern in the annotation for the <code class="literal">keyClicked</code> method, rather than an ID, we can capture all the keys using the wildcard<code class="literal">.*</code>. This is also why the naming of the elements is important.</p><p>Once an element is selected, <code class="literal">KeyEventListener</code> will start to listen for a key to be pressed on the keyboard. We set the text of the button to be the text representation of the key. In many cases, we can use the <code class="literal">getKeyChar</code> method of <code class="literal">KeyInputEvent</code> for this; however, not all the methods have a character like representation, hence the use of the <code class="literal">Keyboard</code> class and <code class="literal">getKeyName</code> method instead. This method tends to output a string representation instead.</p><p>The <code class="literal">changeMapping</code> method first sees whether there is a current binding for the key pressed <a id="id470" class="indexterm"/>and deletes it if that is the case. This is not enough, however, since we also need to delete any previous bindings for that input. This is why we also iterate over the current mappings to see whether any of them match the binding that this key press was for; if yes, it deletes them too.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec170"/>There's more...</h2></div></div></div><p>This recipe uses a static representation of the different input bindings. This would most likely be fine for many games, but modern first person shooters for example, can have 20 and more key bindings; adding all of these manually to the XML can be cumbersome and not good from a maintenance perspective. In this case, it might be better to use the Java Builder interface described in<a id="id471" class="indexterm"/> the <span class="emphasis"><em>Creating an inventory screen</em></span> recipe <a id="id472" class="indexterm"/>to let Java do the repetitious work.</p></div></div>
<div class="section" title="Using offscreen rendering for a minimap"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec70"/>Using offscreen rendering for a minimap</h1></div></div></div><p>There <a id="id473" class="indexterm"/>are generally two ways of creating minimaps. One <a id="id474" class="indexterm"/>way is to let an artist draw a representation of the map, as shown in the following screenshot. This usually ends up beautifully as it gives considerable freedom to the artist when it comes to style. The method is not that viable during development when scenes might be changing a lot, or for games with procedural content where the end result is not known beforehand.</p><div class="mediaobject"><img src="graphics/6478OS_06_03.jpg" alt="Using offscreen rendering for a minimap"/><div class="caption"><p>Minimap with unit marker</p></div></div><p>In those cases, taking a snapshot of the actual scene can be very helpful. The resulting image can then be run through various filters (or shaders during rendering) to get a less raw look.</p><p>In this recipe, we'll achieve this by creating a new <code class="literal">ViewPort</code> port, and <code class="literal">FrameBuffer</code> to store a snapshot of a camera. Finally, we'll create <code class="literal">NiftyImage</code> out of it and display it as a GUI element.</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec171"/>How to do it...</h2></div></div></div><p>We're going to <a id="id475" class="indexterm"/>start by creating a <code class="literal">Util</code> class to handle the rendering of our minimap. This will consist of the following 15 steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Define a new class called <code class="literal">MinimapUtil</code>.</li><li class="listitem">It will only have one static method, <code class="literal">createMiniMap</code>, with the following declaration:<div class="informalexample"><pre class="programlisting">public static void createMiniMap(final SimpleApplication app, final Spatial scene, int width, int height)</pre></div></li><li class="listitem">The first<a id="id476" class="indexterm"/> thing we do is create a new <a id="id477" class="indexterm"/>camera called <code class="literal">offScreenCamera</code> with the same width and height that were supplied to the method.</li><li class="listitem">The camera should have the parallel projection set to true, and a frustrum that spans between <code class="literal">1</code> and <code class="literal">1000</code> in depth, <code class="literal">-width</code> to <code class="literal">width</code>, and <code class="literal">-height</code> to <code class="literal">height</code>, as shown in the following code:<div class="informalexample"><pre class="programlisting">offScreenCamera.setParallelProjection(true);
offScreenCamera.setFrustum(1, 1000, -width, width, height, -height);</pre></div></li><li class="listitem">It should be located at some distance above the scene and rotated downwards, as shown in the following code:<div class="informalexample"><pre class="programlisting">offScreenCamera.setLocation(new Vector3f(0, 100f, 0));
offScreenCamera.setRotation(new Quaternion().fromAngles(new float[]{FastMath.HALF_PI,FastMath.PI,0}));</pre></div></li><li class="listitem">Next, we create a new <code class="literal">ViewPort</code> by calling the application's <code class="literal">RenderManager</code> and its <code class="literal">createPreView</code> method using <code class="literal">offScreenCamera</code>:<div class="informalexample"><pre class="programlisting">final ViewPort offScreenView = app.getRenderManager().createPreView(scene.getName() + "_View", offScreenCamera);
offScreenView.setClearFlags(true, true, true);
offScreenView.setBackgroundColor(ColorRGBA.DarkGray.mult(ColorRGBA.Blue).mult(0.3f));</pre></div></li><li class="listitem">Now, we<a id="id478" class="indexterm"/> need a <code class="literal">Texture2D</code> class to<a id="id479" class="indexterm"/> store the data in, so we create a class called <code class="literal">offScreenTexture</code> with the same width and height as before and set <code class="literal">MinFilter</code> to <code class="literal">Trilinear</code>:<div class="informalexample"><pre class="programlisting">final Texture2D offScreenTexture = new Texture2D(width, height, Image.Format.RGB8);
offScreenTexture.setMinFilter(Texture.MinFilter.Trilinear);</pre></div></li><li class="listitem">A <code class="literal">FrameBuffer</code> class is needed as a medium for the data, so we create one with the same width and height, and <code class="literal">1</code> sample, as shown in the following code:<div class="informalexample"><pre class="programlisting">FrameBuffer offScreenBuffer = new FrameBuffer(width, height, 1);</pre></div></li><li class="listitem">We set <code class="literal">DepthBuffer</code> to be <code class="literal">Image.Format.Depth</code> and <code class="literal">offScreenTexture</code> to be <code class="literal">ColorTexture</code>:<div class="informalexample"><pre class="programlisting">offScreenBuffer.setDepthBuffer(Image.Format.Depth);
offScreenBuffer.setColorTexture(offScreenTexture);</pre></div></li><li class="listitem">Then, we set <code class="literal">outPutFrameBuffer</code> of <code class="literal">offScreenView</code> to be <code class="literal">offScreenBuffer</code>:<div class="informalexample"><pre class="programlisting">offScreenView.setOutputFrameBuffer(offScreenBuffer);</pre></div></li><li class="listitem">Unless the scene we supplied already has some lights, we should add at least one <code class="literal">Light</code> class to it.</li><li class="listitem">Then, we attach the scene to <code class="literal">offScreenView</code>:<div class="informalexample"><pre class="programlisting">offScreenView.attachScene(scene);</pre></div></li><li class="listitem">To store the texture, we can add it to <code class="literal">AssetManager</code> with the following line:<div class="informalexample"><pre class="programlisting">((DesktopAssetManager)app.getAssetManager()).addToCache( new TextureKey(scene.getName()+"_mini.png", true), offScreenTexture);</pre></div></li><li class="listitem">Now, we<a id="id480" class="indexterm"/> can do the actual rendering by<a id="id481" class="indexterm"/> calling the application's <code class="literal">renderManager</code> and <code class="literal">renderViewPort</code> methods:<div class="informalexample"><pre class="programlisting">app.getRenderManager().renderViewPort(offScreenView, 0);</pre></div></li><li class="listitem">After this, we're done and can call <code class="literal">removePreview</code> to discard <code class="literal">offScreeenView</code>:<div class="informalexample"><pre class="programlisting">app.getRenderManager().removePreView(offScreenView);</pre></div></li></ol></div><p>With the <code class="literal">Util</code> class done, we can create a screen <code class="literal">Controller</code> class. Perform the following additional six steps to do this:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Create a new class called <code class="literal">GameScreenController</code> that extends <code class="literal">NiftyController</code>.</li><li class="listitem">For now, it only needs one public method called <code class="literal">createMinimap</code> that takes a scene as the input.</li><li class="listitem">The first thing the <code class="literal">createMinimap</code> method should do is call <code class="literal">MiniMapUtil.createMinimap</code>.</li><li class="listitem">With the scene rendered, we can create <code class="literal">NiftyImage</code> with the <code class="literal">nifty.createImage</code> method.</li><li class="listitem">Then, we can apply the image to our minimap element in the Nifty screen with the following line:<div class="informalexample"><pre class="programlisting">screen.findElementByName("minimap").getRenderer(ImageRenderer.class).setImage(image);</pre></div></li><li class="listitem">Now, all we need to do is add a panel element called <code class="literal">minimap</code> to a screen that uses <code class="literal">GameScreenController</code> as the controller.</li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec172"/>How it works...</h2></div></div></div><p>Offscreen rendering is just what it sounds like. We render something in a view that is not related to <a id="id482" class="indexterm"/>the main view that the player sees. To<a id="id483" class="indexterm"/> do this, we set up a new viewport <a id="id484" class="indexterm"/>and camera. It's not possible to render something directly to a texture, which is why <code class="literal">FrameBuffer</code> is used as the medium.</p><p>Once the texture object is created and added to the asset manager, it's possible to keep changing it if we would like to at a later stage. It's even possible to have a live view of the scene in the minimap, although this would probably cost unnecessary resources. In this case, we remove the view as soon as we've rendered it once.</p><p>The example is limited in some sense, like it expects that there is a correlation between the size of the scene and the size of the minimap.</p><p>Nifty uses its own image format, <code class="literal">NiftyImage</code>, so we need to convert the image we saved; however, Nifty's <code class="literal">createImage</code> will automatically find the texture in the asset manager based on the name (key).</p></div><div class="section" title="There's more…"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec173"/>There's more…</h2></div></div></div><p>Usually, on a minimap, players will want some kind of indication about their (and others) whereabouts. Let's implement that in the minimap we just created:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">First of all, we need to change the <code class="literal">minimap</code> element in our screen a bit. We set <code class="literal">childLayout</code> to <code class="literal">absolute</code> and add another panel inside it called <code class="literal">playerIcon</code> with a small width and height.</li><li class="listitem">Next, we add a new <code class="literal">Element</code> field called <code class="literal">playerIcon</code> to the <code class="literal">GameScreenController</code> and use <code class="literal">findElementByName</code> in the <code class="literal">bind</code> method to set it.</li><li class="listitem">Then, we add another method called <code class="literal">updatePlayerPosition</code> with two integers, <code class="literal">x</code> and <code class="literal">y</code>, as the input.</li><li class="listitem">This<a id="id485" class="indexterm"/> method should use <code class="literal">setConstraintX</code> and <code class="literal">setConstraintY</code> on the <code class="literal">playerIcon</code> element to set the position. Those <a id="id486" class="indexterm"/>methods take <code class="literal">SizeValue</code> as the input, and we supply the <code class="literal">x</code> and <code class="literal">y</code> values with the <code class="literal">"px"</code> definition.</li><li class="listitem">Finally, in the same method, we need to call <code class="literal">layoutElements()</code> on the <code class="literal">minimap</code> element to make it update its child elements.</li></ol></div><p>For other things, such as visible enemies, we can use the builder interface to create them as and when we need them and then use <code class="literal">markForRemoval</code> to remove them when they're not needed anymore. An example of this process can be seen in the <span class="emphasis"><em>Handling a game message queue</em></span> recipe.</p></div></div></body></html>