<html><head></head><body>
<div id="page" style="height:0pt"/><div class="book" title="Chapter&#xA0;8.&#xA0;Adding WebSockets"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch08" class="calibre1"/>Chapter 8. Adding WebSockets</h1></div></div></div><p class="calibre8"><span class="strong"><strong class="calibre9">WebSockets</strong></span> are<a id="id874" class="calibre1"/> one of the biggest additions in Java EE 7. In this chapter, we will explore the new possibilities that they provide to a developer. In our ticket booking applications, we already used a wide variety of approaches to inform the clients about events occurring on the server side. These include the following:</p><div class="book"><ul class="itemizedlist"><li class="listitem">JSF polling</li><li class="listitem">Java Messaging Service (JMS) messages</li><li class="listitem">REST requests</li><li class="listitem">Remote EJB requests</li></ul></div><p class="calibre8">All of them, besides JMS, were based on the assumption that the client will be responsible for asking the server about the state of the application. In some cases, such as checking whether someone else has not booked a ticket during our interaction with the application, this is a wasteful strategy; the server is in the position to inform clients when it is needed. What's more, it feels like the developer must hack the HTTP protocol to get a notification from a server to the client. This is a requirement that has to be implemented in most web applications, and therefore, deserves a standardized solution that can be applied by the developers in multiple projects without much effort.</p><p class="calibre8">WebSockets are changing the game for developers. They replace the request-response paradigm in which the client always initiates the communication with a two-point bidirectional messaging system. After the initial connection, both sides can send independent messages to each other as long as the session is alive. This means that we can easily create web applications that will automatically refresh their state with up-to-date data from the server. You probably have already seen this kind of behavior in Google Docs or live broadcasts on news sites. Now we can achieve the same effect in a simpler and more efficient way than in earlier versions of Java Enterprise Edition. In this chapter, we will try to leverage these new, exciting features that come with WebSockets in Java EE 7 thanks to<a id="id875" class="calibre1"/> JSR 356 (<a class="calibre1" href="https://jcp.org/en/jsr/detail?id=356">https://jcp.org/en/jsr/detail?id=356</a>) and HTML5.</p><p class="calibre8">In this chapter, you will learn the following topics:</p><div class="book"><ul class="itemizedlist"><li class="listitem">How WebSockets work</li><li class="listitem">How to create a WebSocket endpoint in Java EE 7</li><li class="listitem">How to create an HTML5/AngularJS client that will accept push notifications from an application deployed on WildFly</li></ul></div></div>

<div class="book" title="Chapter&#xA0;8.&#xA0;Adding WebSockets">
<div class="book" title="An overview of WebSockets"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch08lvl1sec37" class="calibre1"/>An overview of WebSockets</h1></div></div></div><p class="calibre8">A WebSocket <a id="id876" class="calibre1"/>session between the client and server is built upon a standard TCP connection. Although the WebSocket protocol has its own control frames (mainly to create and sustain the connection) coded by the Internet Engineering<a id="id877" class="calibre1"/> Task Force in the RFC 6455 (<a class="calibre1" href="http://tools.ietf.org/html/rfc6455">http://tools.ietf.org/html/rfc6455</a>), the peers are not obliged to use any specific format to exchange application data. You may use plaintext, XML, JSON, or anything else to transmit your data. As you probably remember, this is quite different from SOAP-based WebServices, which had bloated specifications of the exchange protocol. The same goes for RESTful architectures; we no longer have the predefined verb methods from HTTP (GET, PUT, POST, and DELETE), status codes, and the whole semantics of an HTTP request.</p><p class="calibre8">This liberty means that WebSockets are pretty low level compared to the technologies that we have used up to this point, but thanks to this, the communication overhead is minimal. The protocol is less verbose than SOAP or RESTful HTTP, which allows us to achieve higher performance. This, however, comes with a price. We usually like to use the features of higher-level protocols (such as horizontal scaling and rich URL semantics), and with WebSockets, we would need to write them by hand. For standard CRUD-like operations, it would be easier to use a REST endpoint than create everything from scratch.</p><p class="calibre8">What do we get from WebSockets compared to the standard HTTP communication? First of all, a direct connection between two peers. Normally, when you connect to a web server (which can, for instance, handle a REST endpoint), every subsequent call is a new TCP connection, and your machine is treated like it is a different one every time you make a request. You can, of course, simulate a stateful behavior (so that the server will recognize your machine between different requests) using cookies and increase the performance by reusing the same connection in a short period of time for a specific client, but basically, it is a workaround to overcome the limitations of the HTTP protocol.</p><p class="calibre8">Once you establish a WebSocket connection between a server and client, you can use the same session (and underlying TCP connection) during the whole communication. Both sides are aware of it and can send data independently in a full-duplex manner (both sides can send and receive data simultaneously). Using plain HTTP, there is no way for the server to spontaneously start sending data to the client without any request from its side. What's more, the server is aware of all of its connected WebSocket clients, and can even send data between them!</p><p class="calibre8">The current solution that includes trying to simulate real-time data delivery using HTTP protocol can put a lot of stress on the web server. Polling (asking the server about updates), long polling (delaying the completion of a request to the moment when an update is ready), and streaming (a Comet-based solution with a constantly open HTTP response) are all ways to hack the protocol to do things that it wasn't designed for and have their <a id="id878" class="calibre1"/>own limitations. Thanks to the elimination of unnecessary checks, WebSockets can heavily reduce the number of HTTP requests that have to be handled by the web server. The updates are delivered to the user with a smaller latency because we only need one round-trip through the network to get the desired information (it is pushed by the server immediately).</p><p class="calibre8">All of these <a id="id879" class="calibre1"/>features make WebSockets a great addition to the Java EE platform, which fills the gaps needed to easily finish specific tasks, such as sending updates, notifications, and orchestrating multiple client interactions. Despite these advantages, WebSockets are not intended to replace REST or SOAP WebServices. They do not scale so well horizontally (they are hard to distribute because of their stateful nature), and they lack most of the features that are utilized in web applications. URL semantics, complex security, compression, and many other features are still better realized using other technologies.</p></div></div>
<div class="book" title="How do WebSockets work"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch08lvl1sec38" class="calibre1"/>How do WebSockets work</h1></div></div></div><p class="calibre8">To initiate<a id="id880" class="calibre1"/> a WebSocket session, the client must send an HTTP request with an <code class="email">Upgrade: websocket</code> header field. This informs the server that the peer client has asked the server to switch to the WebSocket protocol.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="note41" class="calibre1"/>Note</h3><p class="calibre8">You may notice that the same happens in WildFly for Remote EJBs; the initial connection is made using an HTTP request, and is later switched to the remote protocol thanks to the <code class="email">Upgrade</code> mechanism. The standard <code class="email">Upgrade</code> header field can be used to handle any protocol, other than HTTP, which is accepted by both sides (the client and server). In WildFly, this allows you to reuse the HTTP port (<code class="email">80</code>/<code class="email">8080</code>) for other protocols and therefore minimise the number of required ports that should be configured.</p></div><p class="calibre8">If the server can "understand" the WebSocket protocol, the client and server then proceed with the handshaking phase. They negotiate the version of the protocol, exchange security keys, and if everything goes well, the peers can go to the data transfer phase. From now on, the communication is only done using the WebSocket protocol. It is not possible to exchange any HTTP frames using the current connection. The whole life cycle of a connection can be summarized in the following diagram:</p><div class="mediaobject"><img src="../images/00072.jpeg" alt="How do WebSockets work" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre8">A sample <a id="id881" class="calibre1"/>HTTP request from a JavaScript application to a WildFly server would look similar to this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">GET /ticket-agency-websockets/tickets HTTP/1.1</strong></span>
<span class="strong"><strong class="calibre9">Upgrade: websocket</strong></span>
<span class="strong"><strong class="calibre9">Connection: Upgrade</strong></span>
<span class="strong"><strong class="calibre9">Host: localhost:8080</strong></span>
<span class="strong"><strong class="calibre9">Origin: http://localhost:8080Pragma: no-cache</strong></span>
<span class="strong"><strong class="calibre9">Cache-Control: no-cache</strong></span>
<span class="strong"><strong class="calibre9">Sec-WebSocket-Key: TrjgyVjzLK4Lt5s8GzlFhA==</strong></span>
<span class="strong"><strong class="calibre9">Sec-WebSocket-Version: 13</strong></span>
<span class="strong"><strong class="calibre9">Sec-WebSocket-Extensions: permessage-deflate; client_max_window_bits, x-webkit-deflate-frame</strong></span>
<span class="strong"><strong class="calibre9">User-Agent: Mozilla/5.0 (Windows NT 6.3; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/34.0.1847.116 Safari/537.36</strong></span>
<span class="strong"><strong class="calibre9">Cookie: [45 bytes were stripped]</strong></span>
</pre></div><p class="calibre8">We can see that the client requests an upgrade connection with WebSocket as the target protocol on the URL <code class="email">/ticket-agency-websockets/tickets</code>. It additionally passes information about the requested version and key.</p><p class="calibre8">If the server supports the request protocol and all the required data is passed by the client, then it would<a id="id882" class="calibre1"/> respond with the following frame:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">HTTP/1.1 101 Switching Protocols</strong></span>
<span class="strong"><strong class="calibre9">X-Powered-By: Undertow 1</strong></span>
<span class="strong"><strong class="calibre9">Server: Wildfly 8</strong></span>
<span class="strong"><strong class="calibre9">Origin: http://localhost:8080</strong></span>
<span class="strong"><strong class="calibre9">Upgrade: WebSocket</strong></span>
<span class="strong"><strong class="calibre9">Sec-WebSocket-Accept: ZEAab1TcSQCmv8RsLHg4RL/TpHw=</strong></span>
<span class="strong"><strong class="calibre9">Date: Sun, 13 Apr 2014 17:04:00 GMT</strong></span>
<span class="strong"><strong class="calibre9">Connection: Upgrade</strong></span>
<span class="strong"><strong class="calibre9">Sec-WebSocket-Location: ws://localhost:8080/ticket-agency-websockets/tickets</strong></span>
<span class="strong"><strong class="calibre9">Content-Length: 0</strong></span>
</pre></div><p class="calibre8">The status code of the response is <code class="email">101</code> (switching protocols) and we can see that the server is now going to start using the WebSocket protocol. The TCP connection initially used for the HTTP request is now the base of the WebSocket session and can be used for transmissions. If the client tries to access a URL, which is only handled by another protocol, then the server can ask the client to do an upgrade request. The server uses the <code class="email">426</code> (upgrade required) status code in such cases.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="note42" class="calibre1"/>Note</h3><p class="calibre8">The initial connection creation has some overhead (because of the HTTP frames that are exchanged between the peers), but after it is completed, new messages have only 2 bytes of additional headers. This means that when we have a large number of small messages, WebSocket will be an order of magnitude faster than REST protocols simply because there is less data to transmit!</p></div><p class="calibre8">If you <a id="id883" class="calibre1"/>are wondering about the browser support of WebSockets, you can look it up at <a class="calibre1" href="http://caniuse.com/websockets">http://caniuse.com/websockets</a>. All new versions of major browsers currently support WebSockets; the total coverage is estimated (at the time of writing) at 74 percent. You can see this in the following screenshot:</p><div class="mediaobject"><img src="../images/00073.jpeg" alt="How do WebSockets work" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre8">After this<a id="id884" class="calibre1"/> theoretical introduction, we are ready to jump into action. We can now create our first WebSocket endpoint!</p></div>
<div class="book" title="Creating our first endpoint"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch08lvl1sec39" class="calibre1"/>Creating our first endpoint</h1></div></div></div><p class="calibre8">Let's start<a id="id885" class="calibre1"/> with a simple example:</p><div class="informalexample"><pre class="programlisting">package com.packtpub.wflydevelopment.chapter8.boundary;

import javax.websocket.EndpointConfig;
import javax.websocket.OnOpen;
import javax.websocket.Session;
import javax.websocket.server.ServerEndpoint;
import java.io.IOException;

<span class="strong"><strong class="calibre9">@ServerEndpoint("/hello")</strong></span>
public class HelloEndpoint {

    <span class="strong"><strong class="calibre9">@OnOpen</strong></span>
    public void open(<span class="strong"><strong class="calibre9">Session</strong></span> session, <span class="strong"><strong class="calibre9">EndpointConfig</strong></span> conf) throws IOException {
        <span class="strong"><strong class="calibre9">session.getBasicRemote().sendText("Hi!");</strong></span>
    }
}</pre></div><p class="calibre8">Java EE 7<a id="id886" class="calibre1"/> specification has taken into account developer friendliness, which can be clearly seen in the given example. In order to define your WebSocket endpoint, you just need a few annotations on a <span class="strong"><strong class="calibre9">Plain Old Java Object</strong></span> (<span class="strong"><strong class="calibre9">POJO</strong></span>). The <a id="id887" class="calibre1"/>first annotation <code class="email">@ServerEndpoint("/hello")</code> defines a path to your endpoint. It's a good time to discuss the endpoint's full address. We placed this sample in the application named <code class="email">ticket-agency-websockets</code>. During the deployment of application, you can spot information in the WildFly log about endpoints creation, as shown in the following command line:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">02:21:35,182 INFO  [io.undertow.websockets.jsr] (MSC service thread 1-7) UT026003: Adding annotated server endpoint class com.packtpub.wflydevelopment.chapter8.boundary.FirstEndpoint for path /hello</strong></span>
<span class="strong"><strong class="calibre9">02:21:35,401 INFO  [org.jboss.resteasy.spi.ResteasyDeployment] (MSC service thread 1-7) Deploying javax.ws.rs.core.Application: class com.packtpub.wflydevelopment.chapter8.webservice.JaxRsActivator$Proxy$_$$_WeldClientProxy</strong></span>
<span class="strong"><strong class="calibre9">02:21:35,437 INFO  [org.wildfly.extension.undertow] (MSC service thread 1-7) JBAS017534: Registered web context: /ticket-agency-websockets</strong></span>
</pre></div><p class="calibre8">The full<a id="id888" class="calibre1"/> URL of the endpoint is <code class="email">ws://localhost:8080/ticket-agency-websockets/hello</code>, which is just a concatenation of the server and application address with an endpoint path on an appropriate protocol.</p><p class="calibre8">The second <a id="id889" class="calibre1"/>used annotation <code class="email">@OnOpen</code> defines the endpoint behavior when the connection from the client is opened. It's not the only behavior-related annotation of the WebSocket endpoint. Let's look to the following table:</p><div class="informalexample"><table border="1" class="calibre17"><colgroup class="calibre18"><col class="calibre19"/><col class="calibre19"/></colgroup><thead class="calibre20"><tr class="calibre21"><th valign="bottom" class="calibre22">
<p class="calibre23">Annotation</p>
</th><th valign="bottom" class="calibre22">
<p class="calibre23">Description</p>
</th></tr></thead><tbody class="calibre24"><tr class="calibre21"><td valign="top" class="calibre25">
<p class="calibre23"><code class="literal">@OnOpen</code></p>
</td><td valign="top" class="calibre25">
<p class="calibre23">The connection is open. With<a id="id890" class="indexterm"/> this annotation, we can use the <code class="literal">Session</code> and <code class="literal">EndpointConfig</code> parameters. The<a id="id891" class="indexterm"/> first<a id="id892" class="indexterm"/> parameter represents the connection to the user and allows further communication. The second one provides some client-related information.</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre25">
<p class="calibre23"><code class="literal">@OnMessage</code></p>
</td><td valign="top" class="calibre25">
<p class="calibre23">This annotation<a id="id893" class="indexterm"/> is executed when a message from the client is being received. In such a method, you can just have <code class="literal">Session</code> and for example, the<a id="id894" class="indexterm"/> <code class="literal">String</code> parameter, where the <code class="literal">String</code> parameter represents the received message.</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre25">
<p class="calibre23"><code class="literal">@OnError</code></p>
</td><td valign="top" class="calibre25">
<p class="calibre23">There are<a id="id895" class="indexterm"/> bad times when an error occurs. With this annotation, you can retrieve a <code class="literal">Throwable</code> object apart from standard <code class="literal">Session</code>.</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre25">
<p class="calibre23"><code class="literal">@OnClose</code></p>
</td><td valign="top" class="calibre25">
<p class="calibre23">When<a id="id896" class="indexterm"/> the connection is closed, it is possible to get some data concerning this event in the form of the <code class="literal">CloseReason</code> type object.</p>
</td></tr></tbody></table></div><p class="calibre8">There is<a id="id897" class="calibre1"/> one more interesting line in our <code class="email">HelloEndpoint</code>. Using the <code class="email">Session</code> object, it is possible to communicate with the client. This clearly shows that in WebSockets, two-directional communication is easily possible. In this example, we decided to respond to a connected user synchronously (<code class="email">getBasicRemote()</code>) with just a text message <span class="strong"><em class="calibre10">Hi!</em></span> (<code class="email">sendText (String)</code>). Of course, it's also possible to communicate asynchronously and send, for example, sending binary messages using your own binary bandwidth saving protocol. We will present some of these processes in the next example.</p></div>

<div id="page" style="height:0pt"/><div class="book" title="Expanding our client application"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch08lvl1sec40" class="calibre1"/>Expanding our client application</h1></div></div></div><p class="calibre8">It's time<a id="id898" class="calibre1"/> to show how you can leverage the WebSocket features in real life. In the previous chapter, <a class="calibre1" title="Chapter 7. Adding Web Services to Your Applications" href="part0038_split_000.html#page">Chapter 7</a>, <span class="strong"><em class="calibre10">Adding Web Services to Your Applications</em></span>, we created the ticket booking application based on the REST API and AngularJS framework. It was clearly missing one important feature: the application did not show information concerning ticket purchases of other users. This is a perfect use case for WebSockets!</p><p class="calibre8">Since we're just adding a feature to our previous app, we will only describe the changes we will introduce to it.</p><p class="calibre8">In this example, we would like to be able to inform all current users about other purchases. This means that we have to store information about active sessions. Let's start with the registry type object, which will serve this purpose. We can use a <code class="email">Singleton</code> session bean for this task, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">@Singleton
public class SessionRegistry {

    private final Set&lt;Session&gt; sessions = new HashSet&lt;&gt;();

    @Lock(LockType.READ)
    public Set&lt;Session&gt; getAll() {
        return Collections.unmodifiableSet(sessions);
    }

    @Lock(LockType.WRITE)
    public void add(Session session) {
        sessions.add(session);
    }

    @Lock(LockType.WRITE)
    public void remove(Session session) {
        sessions.remove(session);
    }
}</pre></div><p class="calibre8">We could <a id="id899" class="calibre1"/>use <code class="email">Collections.synchronizedSet</code> from standard Java libraries but it's a great chance to remember what we described in <a class="calibre1" title="Chapter 3. Introducing Java EE 7 – EJBs" href="part0023_split_000.html#page">Chapter 3</a>, <span class="strong"><em class="calibre10">Introducing Java EE 7 – EJBs</em></span>, about container-based concurrency. In <code class="email">SessionRegistry</code>, we defined some basic methods to add, get, and remove sessions. For the sake of collection thread safety during retrieval, we return an unmodifiable view.</p><p class="calibre8">We defined the registry, so now we can move to the endpoint definition. We will need a POJO, which will use our newly defined registry as shown:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">@ServerEndpoint("/tickets")</strong></span>
public class TicketEndpoint {

<span class="strong"><strong class="calibre9">    @Inject</strong></span>
<span class="strong"><strong class="calibre9">    private SessionRegistry sessionRegistry;</strong></span>

<span class="strong"><strong class="calibre9">    @OnOpen</strong></span>
    public void open(Session session, EndpointConfig conf) {
        sessionRegistry.add(session);
    }

<span class="strong"><strong class="calibre9">    @OnClose</strong></span>
    public void close(Session session, CloseReason reason) {
        sessionRegistry.remove(session);
    }

    public void send<span class="strong"><strong class="calibre9">(@Observes</strong></span> Seat seat) {
<span class="strong"><strong class="calibre9">        sessionRegistry.getAll().forEach(session -&gt; session.getAsyncRemote().sendText(toJson(seat)));</strong></span>
    }

    private String toJson(Seat seat) {
<span class="strong"><strong class="calibre9">        final JsonObject jsonObject = Json.createObjectBuilder()</strong></span>
<span class="strong"><strong class="calibre9">                .add("id", seat.getId())</strong></span>
<span class="strong"><strong class="calibre9">                .add("booked", seat.isBooked())</strong></span>
<span class="strong"><strong class="calibre9">                .build();</strong></span>
        return jsonObject.toString();
    }
}</pre></div><p class="calibre8">Our endpoint <a id="id900" class="calibre1"/>is defined in the <code class="email">/tickets</code> address. We injected a <code class="email">SessionRepository</code> to our endpoint. During <code class="email">@OnOpen</code>, we add <code class="email">Sessions</code> to the registry, and during <code class="email">@OnClose</code>, we just remove them. Message sending is performed on the CDI event (the <code class="email">@Observers</code> annotation), which is already fired in our code during <code class="email">TheatreBox.buyTicket(int)</code>. In our <code class="email">send</code> method, we retrieve all sessions <a id="id901" class="calibre1"/>from <code class="email">SessionRepository</code>, and for each of them, we asynchronously send information about booked seats. We don't really need information about all the <code class="email">Seat</code> fields to realize this feature. That's the reason why we don't use the automatic JSON serialization we know from the last chapter here. Instead, we decided to use a minimalistic <code class="email">JSON</code> object, which provides only the required data. To do this, we used the new Java API for JSON Processing (JSR-353). Using a fluent-like API, we're able to create a <code class="email">JSON</code> object and add two fields to it. Then, we just convert JSON to the string, which is sent in a text message.</p><p class="calibre8">Because in our example we send messages in response to a CDI event, we don't have (in the event handler) an out-of-the-box reference to any of the sessions. We have to use our <code class="email">sessionRegistry</code> object to access the active ones. However, if we would like to do the same thing but, for example, in the <code class="email">@OnMessage</code> method, then it is possible to get all active sessions just by executing the <code class="email">session.getOpenSessions()</code> method.</p><p class="calibre8">These are all the changes required to perform on the backend side. Now, we have to modify our AngularJS frontend to leverage the added feature. The good news is that JavaScript already includes classes that can be used to perform WebSocket communication! There are a few lines of code we have to add inside the module defined in the <code class="email">seat.js</code> file, which are as follows:</p><div class="informalexample"><pre class="programlisting">var ws = new WebSocket("ws://localhost:8080/ticket-agency-websockets/tickets");
ws.onmessage = function (message) {
    var receivedData = message.data;
    var bookedSeat = JSON.parse(receivedData);

    $scope.$apply(function () {
        for (var i = 0; i &lt; $scope.seats.length; i++) {
            if ($scope.seats[i].id === bookedSeat.id) {
                $scope.seats[i].booked = bookedSeat.booked;
                break;
            }
        }
    });
};</pre></div><p class="calibre8">The code is <a id="id902" class="calibre1"/>very simple. We just create the <code class="email">WebSocket</code> object using the URL to our endpoint, and then we define the <code class="email">onmessage</code> function in that object. During the function execution, the received message is automatically parsed from the JSON to JavaScript object. Then, in <code class="email">$scope.$apply</code>, we just iterate through our seats, and if the ID matches, we update the booked state. We have to use <code class="email">$scope.$apply</code> because we are touching an Angular object from outside the Angular world (the <code class="email">onmessage</code> function). Modifications performed on <code class="email">$scope.seats</code> are automatically visible on the website. With this, we can just open our ticket booking website in two browser sessions, and see that when one user buys a ticket, the second users sees almost instantly that the seat state is changed to <span class="strong"><em class="calibre10">booked</em></span>.</p><p class="calibre8">We can enhance our application a little to inform users if the WebSocket connection is really working. Let's just define <code class="email">onopen</code> and <code class="email">onclose</code> functions for this purpose:</p><div class="informalexample"><pre class="programlisting">ws.onopen = function (event) {
    $scope.$apply(function () {
        $scope.alerts.push({
            type: 'info',
            msg: 'Push connection from server is working'
        });
    });
};
ws.onclose = function (event) {
    $scope.$apply(function () {
        $scope.alerts.push({
            type: 'warning',
            msg: 'Error on push connection from server '
        });
    });
};</pre></div><p class="calibre8">To inform users about a connection's state, we push different types of alerts. Of course, again we're touching the Angular world from the outside, so we have to perform all operations on Angular from the <code class="email">$scope.$apply</code> function.</p><p class="calibre8">Running the <a id="id903" class="calibre1"/>described code results in the notification, which is visible in the following screenshot:</p><div class="mediaobject"><img src="../images/00074.jpeg" alt="Expanding our client application" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre8">However, if the server fails after opening the website, you might get an error as shown in the following screenshot:</p><div class="mediaobject"><img src="../images/00075.jpeg" alt="Expanding our client application" class="calibre11"/></div><p class="calibre12"> </p></div>

<div class="book" title="Expanding our client application">
<div class="book" title="Transforming POJOs to JSON"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch08lvl2sec61" class="calibre1"/>Transforming POJOs to JSON</h2></div></div></div><p class="calibre8">In our<a id="id904" class="calibre1"/> current example, we transformed <a id="id905" class="calibre1"/>our <code class="email">Seat</code> object to JSON manually. Normally, we <a id="id906" class="calibre1"/>don't want to do it this way; there are many libraries that will do the transformation for us. One of them is GSON from Google. Additionally, we can register an <code class="email">encoder/decoder</code> class for a WebSocket endpoint that will do the transformation automatically. Let's look at how we can refactor our current solution to use an encoder.</p><p class="calibre8">First of all, we must add <code class="email">GSON</code> to our classpath. The required Maven dependency is as follows:</p><div class="informalexample"><pre class="programlisting">&lt;dependency&gt;
    &lt;groupId&gt;com.google.code.gson&lt;/groupId&gt;
    &lt;artifactId&gt;gson&lt;/artifactId&gt;
    &lt;version&gt;2.3&lt;/version&gt;
&lt;/dependency&gt;</pre></div><p class="calibre8">Next, we need to provide an implementation of the <code class="email">javax.websocket.Encoder.Text</code> interface. There are also versions of the <code class="email">javax.websocket.Encoder.Text</code> interface for binary <a id="id907" class="calibre1"/>and streamed data (for both binary<a id="id908" class="calibre1"/> and text formats). A corresponding hierarchy <a id="id909" class="calibre1"/>of interfaces is also available for decoders (<code class="email">javax.websocket.Decoder</code>). Our implementation is rather simple. This is shown in the following code snippet:</p><div class="informalexample"><pre class="programlisting">public class JSONEncoder implements Encoder.Text&lt;Object&gt; {

    private Gson gson;

    @Override
    public void init(EndpointConfig config) {
<span class="strong"><strong class="calibre9">        gson = new Gson(); [1]</strong></span>
    }

    @Override
    public void destroy() {
        // do nothing
    }

    @Override
    public String encode(Object object) throws EncodeException {
<span class="strong"><strong class="calibre9">        return gson.toJson(object); [2]</strong></span>
    }
}</pre></div><p class="calibre8">First, we create an instance of GSON in the <code class="email">init</code> method; this action will be executed when the endpoint is created. Next, in the <code class="email">encode</code> method, which is called every time, we send an object through an endpoint. We use JSON command to create JSON from an object. This is quite concise when we think how reusable this little class is. If you want more control on the JSON generation process, you can use the <code class="email">GsonBuilder</code> class to configure the <code class="email">Gson</code> object before creation. We have the encoder in place. Now it's time to alter our endpoint:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">@ServerEndpoint(value = "/tickets", encoders={JSONEncoder.class})[1]</strong></span>
public class TicketEndpoint {

    @Inject
    private SessionRegistry sessionRegistry;

    @OnOpen
    public void open(Session session, EndpointConfig conf) {
        sessionRegistry.add(session);
    }

    @OnClose
    public void close(Session session, CloseReason reason) {
        sessionRegistry.remove(session);
    }

    public void send(@Observes Seat seat) {
        sessionRegistry.getAll().forEach(session -&gt; session.getAsyncRemote().sendObject(seat)); [2]
    }
}</pre></div><p class="calibre8">The first<a id="id910" class="calibre1"/> change is done on the <code class="email">@ServerEndpoint</code> annotation. We have to define a list of supported encoders; we simply pass <a id="id911" class="calibre1"/>our <code class="email">JSONEncoder.class</code> wrapped in an array. Additionally, we have to pass the endpoint name using the <code class="email">value</code> attribute.</p><p class="calibre8">Earlier, we <a id="id912" class="calibre1"/>used the <code class="email">sendText</code> method to pass a string<a id="id913" class="calibre1"/> containing a manually created JSON. Now, we want to send an object and let the encoder handle the JSON generation; therefore, we'll use the <code class="email">getAsyncRemote().sendObject()</code> method. And that's all. Our endpoint is ready to be used. It will work the same as the earlier version, but now our objects will be fully serialized to JSON, so they will contain every field, not only <code class="email">id</code> and <code class="email">booked</code>.</p><p class="calibre8">After deploying the server, you can connect to the WebSocket endpoint using one of the Chrome extensions, for instance, the <code class="email">Dark WebSocket</code> terminal from the Chrome store (use the <code class="email">ws://localhost:8080/ticket-agency-websockets/tickets</code> address). When you book tickets using the web application, the WebSocket terminal should show something similar to the output shown in the following screenshot:</p><div class="mediaobject"><img src="../images/00076.jpeg" alt="Transforming POJOs to JSON" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre8">Of course, it is possible to use different formats other than JSON. If you want to achieve better performance (when it comes to the serialization time and payload size), you may want to try out binary<a id="id914" class="calibre1"/> serializers such as <span class="strong"><strong class="calibre9">Kryo</strong></span> (<a class="calibre1" href="https://github.com/EsotericSoftware/kryo">https://github.com/EsotericSoftware/kryo</a>). They may not be supported by JavaScript, but may come in handy if you would like to use WebSockets for other clients too. <span class="strong"><strong class="calibre9">Tyrus</strong></span> (<a class="calibre1" href="https://tyrus.java.net/">https://tyrus.java.net/</a>) is a reference implementation of the WebSocket <a id="id915" class="calibre1"/>standard for Java; you can<a id="id916" class="calibre1"/> use it in your standalone desktop applications. In <a id="id917" class="calibre1"/>that case, besides the encoder (which <a id="id918" class="calibre1"/>is used to send messages), you would also need to create a decoder, which can automatically transform incoming messages.</p></div></div>
<div class="book" title="An alternative to WebSockets"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch08lvl1sec41" class="calibre1"/>An alternative to WebSockets</h1></div></div></div><p class="calibre8">The example <a id="id919" class="calibre1"/>we presented in this chapter is possible to be implemented using an older, lesser-known technology named <span class="strong"><strong class="calibre9">Server-Sent Events</strong></span> (<span class="strong"><strong class="calibre9">SSE</strong></span>). SSE <a id="id920" class="calibre1"/>allows for one-way communication from the server to client over HTTP. It is much simpler than WebSockets but has a built-in support for things such as automatic reconnection and event identifiers. WebSockets are definitely more powerful, but are not the only way to pass events, so when you need to implement some notifications from the server side, remember about SSE.</p><p class="calibre8">Another option is to explore the mechanisms oriented around the Comet techniques. Multiple implementations are available and most of them use different methods of transportation to achieve their goals. A comprehensive comparison is available at <a class="calibre1" href="http://cometdaily.com/maturity.html">http://cometdaily.com/maturity.html</a>.</p></div>
<div class="book" title="Summary"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch08lvl1sec42" class="calibre1"/>Summary</h1></div></div></div><p class="calibre8">In this chapter, we managed to introduce the new low-level type of communication. We presented how it works underneath and compares to SOAP and REST introduced in the previous chapter. We also discussed how the new approach changes the development of web applications.</p><p class="calibre8">Our ticket booking application was further enhanced to show users the changing state of the seats using push-like notifications. The new additions required very little code changes in our existing project when we take into account how much we are able to achieve with them. The fluent integration of WebSockets from Java EE 7 with the AngularJS application is another great showcase of flexibility, which comes with the new version of the Java EE platform.</p><p class="calibre8">In the next chapter, you will learn more about WildFly administration and management, so that we can explore more system-wide features of Java EE 7 in the following chapters.</p></div></body></html>