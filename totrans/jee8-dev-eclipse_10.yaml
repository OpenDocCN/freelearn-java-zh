- en: Java CPU Profiling and Memory Tracking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we learned how to use the JMS (Java Messaging Service)
    APIs to write asynchronous applications. In this chapter, we will learn about
    some of the techniques and tools used to profile Java applications. Enterprise
    applications tend to be quite complex and big. There could be situations where
    the application does not perform as per your requirements or expectations. For
    example, some of the operations performed in the application might be taking too
    long or consuming more memory than you expected. Furthermore, debugging performance
    and memory issues can sometimes become very difficult.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, there are tools available, both in JDK and Eclipse, to help us
    debug these issues. JDK 6 (update 7) and above are bundled with the **jVisualVM**
    application that can connect to remote or local applications. You can find this
    tool in the `<JDK_HOME>/bin` folder. jVisualVM can help you profile memory and
    CPU usage. It can also be configured to launch from Eclipse when an application
    is run from Eclipse. We will learn how to use VisualVM to profile Java applications
    in this chapter. You can find detailed information about jVisualVM/VisualVM at [https://visualvm.github.io/](https://visualvm.github.io/).
  prefs: []
  type: TYPE_NORMAL
- en: We will create a small standalone Java application to simulate performance and
    memory issues, and will see how to use VisualVM for troubleshooting. Although
    the real applications that you may want to troubleshoot will be a lot more complex,
    the techniques that we will learn in this chapter can be used for complex applications
    too.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: CPU and memory profiling using VisualVM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Techniques to detect memory leaks and deadlocks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the Eclipse Memory Analyzer to analyze heap dumps created from VisualVM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a sample Java project for profiling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will create a simple standalone Java application so that it is easy for you
    to learn how to profile using VisualVM. Although it will be a standalone application,
    we will create classes that are similar to those we created for the `CourseManagement`
    web application in some of the previous chapters, particularly `CourseDTO`, `CourseBean`
    (JSP bean), `CourseService` (service bean), and `CourseDAO` (for database access).
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a standard Java project in Eclipse, named `CourseManagementStandalone`.
    Create the `CourseDTO` class in the `packt.jee.eclipse.profile.dto` package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the `CourseDAO` class in the `packt.jee.eclopse.profile.dao` package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We have simulated a long-running database operation in the `getCourses` method
    by making the thread sleep for a few seconds.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the `CourseService` class in the `packt.jee.eclipse.profile.service`
    package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '`CourseService.getCourses` delegates the call to `CourseDAO`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the `CourseBean` class in the `packt.jee.eclipse.profile.bean` package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '`CourseBean.getcourses` delegates to `CourseService`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, create the `CourseManagement` class in the `packt.jee.eclipse.profile`
    package. This class contains the `main` method and starts the loop to call the `getCourses`
    method repeatedly after reading any character from the standard input:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Run the application (right-click on the file and select Run As | Java Application).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the console window, type any character and press *Enter*. You should see
    the Getting courses and Got courses messages.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Profiling the Java application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Run jvisualvm from the `<JDK_HOME>/bin` folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00210.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.1: Java VisualVM profiler'
  prefs: []
  type: TYPE_NORMAL
- en: VisualVM lists all the Java processes that can be profiled by it on the local
    machine under the Local node. You can see VisualVM itself listed along with Eclipse.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you run the `CourseManagement` application, the process should also show
    up under Local:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00211.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.2: The CourseManagement application available for profiling'
  prefs: []
  type: TYPE_NORMAL
- en: 'Double-click on the process (or right-click and select Open). Then, go to the
    Profile tab and click on the CPU button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00212.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.3: VisualVM Profiler tab'
  prefs: []
  type: TYPE_NORMAL
- en: You should see the status set as profiling running.
  prefs: []
  type: TYPE_NORMAL
- en: After starting CPU profiling, if you get an error such as Redefinition failed
    with error 62, try running the application with the `-XVerify:none` parameter.
    In Eclipse, select the Run | Run Configurations menu and then select the CourseManagement
    application under the Java Application group. Go to the Arguments tab and add `-Xverify:none`
    to VM arguments. Run the application again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the VisualVM Profiler page, click on the Settings checkbox to see the packages
    included for profiling. Note that VisualVM selects these packages automatically:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00213.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.4: VisualVM Profiler settings'
  prefs: []
  type: TYPE_NORMAL
- en: You must stop CPU profiling to edit the settings. However, we will retain the
    default settings. Uncheck the Settings box to hide the settings.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click on the Monitor table for the overview of profiling activities:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00214.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.5: Overview of profiling activities'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s execute the `getCourse` method in our application. Go to the console
    view of Eclipse in which our application is running, type a character (other than
    `q`), and hit *Enter*. Go to the Profiler tab of VisualVM to view the profiled
    data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00215.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.6: CPU profiling of CourseManagement'
  prefs: []
  type: TYPE_NORMAL
- en: Observe the Self time column. This indicates the CPU time or the elapsed time
    to execute the corresponding method, excluding the time taken to execute other
    methods called from this method. In our case, `CourseDAO.getCourses` took the
    maximum time, so it is at the top of the list. This report could help you identify
    the bottlenecks in your application.
  prefs: []
  type: TYPE_NORMAL
- en: Identifying resource contention
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In a multithreaded application, it is typical for threads to lock or wait for
    a lock. The thread dump can be used for identifying resource contentions. Let''s
    simulate this scenario in our application by modifying the main method of the `CourseManagement`
    class to call `courseBean.getCourses` in separate threads:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Note that we create a new `Thread` object in the `while` loop and call `courseBean.getCourses`
    in the `run` method of the thread. The `while` loop does not wait for `getCourses`
    to return results and can process the next user input immediately. This will allow
    us to simulate resource contention.
  prefs: []
  type: TYPE_NORMAL
- en: 'To actually cause resource contention, let''s synchronize `CourseService.getCourses`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The synchronized `getCourses` method will result in only one thread executing
    this method in an instance of the `CourseService` class. We can now trigger multiple
    `getCourses` calls simultaneously by typing characters in the console without
    waiting for the previous calls to the `getCourse` method to return. To give us
    more time to get the thread dump, let''s increase the thread sleep time in `CourseDAO.getCourses`
    to, say, 30 seconds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the application and let''s start monitoring this process in VisualVM. In
    the console window where the application is running in Eclipse, type a character
    and press *Enter*. Repeat this one more time. Now, two calls to `getCourses` will
    be triggered. In VisualVM, go to the Threads tab and click on the ThreadDump button.
    A new thread dump will be saved under the process node and will be displayed in
    a new tab. Look for threads starting with the `getCourseThread` prefix. Here is
    a sample thread dump of two `getCourseThreads`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: From the preceding thread dumps, it is clear that `getCourseThread2` is waiting
    (`to lock <0x00000007aaf57a80>`) and that `getCourseThread1` is holding lock on
    the same object (`locked <0x00000007aaf57a80>`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the same technique (of inspecting locks), you can also detect deadlocks
    in the application. In fact, VisualVM can detect deadlocks and explicitly point
    to threads that are deadlocked. Let''s modify the `main` method in the `CourseManagement`
    class to cause a deadlock. We will create two threads and make them lock two objects
    in the reverse order:'
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: The following code will cause the application to hang. You will have to kill
    the process to exit.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '`MyThread1` first locks `obj1` and then it tries to lock `obj2`, whereas `MyThread2`'
  prefs: []
  type: TYPE_NORMAL
- en: 'locks `obj2` first and then tries to lock `obj1`. When you monitor this application
    using VisualVM and switch to the Threads tab, you will see the Deadlock detected!
    message:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00216.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.7: Detecting deadlock with VisualVM'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you take the thread dump, it will specifically show you where the deadlock
    is caused:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Memory tracking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'VisualVM can be used to monitor memory allocations and detect possible memory
    leaks. Let''s modify our application to simulate a large memory allocation that
    has not been released. We will modify the `CourseService` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `getCourses` method, we will create a large byte array and store it
    in a member variable. The memory allocated to the array will not be released until
    the instance of `CourseService` is not garbage collected. Now, let''s see how
    this memory allocation shows up in VisualVM. Start monitoring the process and
    go to the Profiler tab. Click on the Memory button to start monitoring memory.
    Now, go back to the console window in Eclipse and enter a character to trigger
    the `getCourses` method. Go to VisualVM to inspect the memory profiling report:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00217.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.8: Memory monitoring with VisualVM'
  prefs: []
  type: TYPE_NORMAL
- en: 'This report shows the live status of the memory consumed by different objects
    in the application. However, if you want to analyze and find where exactly the
    allocation is made, then take a heap dump. Go to the Monitor tab and click on
    the Heap Dump button. The heap dump report is saved under the process node. Click
    on the Classes button in the heap dump report, and then click on the Size column
    to sort objects in descending order of the amount of memory consumed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00218.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.9: Classes in the heap dump report'
  prefs: []
  type: TYPE_NORMAL
- en: 'According to the report, `byte[]` takes up the maximum memory in our application.
    To find where the memory is allocated, double-click on the row containing `byte[]`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00219.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.10: Object instance report in heap dump'
  prefs: []
  type: TYPE_NORMAL
- en: The references window at the bottom-right shows objects holding a reference
    to the selected instance in the top-left window. As you can see, a reference to
    `byte[]` is held by the `cachedData` field of `CourseServe`. Furthermore, a reference
    to `CourseService` is held by `CourseBean`.
  prefs: []
  type: TYPE_NORMAL
- en: Large memory allocation does not necessarily mean a memory leak. You may want
    to keep a reference to a large object in your application. However, the heap dump
    can help you find where the memory was allocated and if that instance is intended
    to be in the memory. If not, you could find where the memory was allocated and
    release it at the appropriate place.
  prefs: []
  type: TYPE_NORMAL
- en: The heap dump that we have taken will be lost if we restart VisualVM. Therefore,
    save it to the disk; to do so, right-click on the Heap Dump node and select Save
    As. We will use this heap dump in the Eclipse Memory Analyzer in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Eclipse plugins for profiling memory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Eclipse Memory Analyzer ([https://eclipse.org/mat/](https://eclipse.org/mat/))
    can be used to analyze heap dumps created by VisualVM. It provides additional
    features such as auto memory leak detection. Furthermore, by using it as an Eclipse
    plugin, you can quickly jump to the source code from the heap dump reports. You
    can use this tool either as a standalone application or as an Eclipse plugin.
    We will see how to use it as an Eclipse plugin in this section.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install the Memory Analyzer plugin and analyze the memory dump, perform
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open Eclipse Marketplace (select the Help | Eclipse Marketplace menu). Search
    for `Memory Analyzer` and install the plugin:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00220.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.11: Searching for the Memory Analyzer plugin in Eclipse Marketplace'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the heap dump that you saved in the previous section. Select the File
    | Open File menu and select the `.hprof` file that has been saved by VisualVM.
    Memory Analyzer will prompt you to select a report type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00221.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.12: Eclipse Memory Analyzer: Getting Started Wizard'
  prefs: []
  type: TYPE_NORMAL
- en: 'Select Leak Suspects Report and click on Finish. The Eclipse Memory Analyzer
    creates the Leak Suspects report with a couple of Problem Suspects:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00222.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.13: Eclipse Memory Analyzer: Leak Suspect report'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the Details link in the first Problem Suspect:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00223.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.14: Eclipse Memory Analyzer: Details of Problem Suspect'
  prefs: []
  type: TYPE_NORMAL
- en: The report clearly identifies `cachedData` in `CourseService` as a leak suspect.
    To open the source file, click on the node and select the Open Source File option.
  prefs: []
  type: TYPE_NORMAL
- en: Memory Analyzer also provides many other useful reports. Refer to [http://help.eclipse.org/oxygen/index.jsp?topic=/org.eclipse.mat.ui.help/welcome.html](http://help.eclipse.org/oxygen/index.jsp?topic=/org.eclipse.mat.ui.help/welcome.html) for
    more details.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The VisualVM tool that is shipped with JDK 6 and above is useful for detecting
    performance bottlenecks and memory leaks.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we learned how to use this tool in a simple Java application.
    However, the technique can be used in large applications too. The Eclipse Memory
    Analyzer can be used to quickly detect memory leaks from a heap dump. In the next
    chapter we will learn how to develop Microservices in JEE.
  prefs: []
  type: TYPE_NORMAL
