<html><head></head><body>
        <section>

                            <header class="header-title chapter-title">
                    Message Routing
                </header>
            
            <article>
                
<p>Thus far, all message interaction in this book has been unidirectional, flowing from message publishers to consumers. What if a consumer wants to alert a publisher that processing is complete and send a reply, or a taxi driver wants to acknowledge a taxi booking request?</p>
<p>This chapter covers steps 5 to 10 in the taxi application system architecture, where a taxi driver responds to the customer and confirms a booking request. The taxi publishes its current location to a queue. The customer's application connects to the broker through WebSockets and subscribes to location updates, delivered directly from the taxi. </p>
<p>The <strong>Remote Procedure Call</strong> (<strong>RPC</strong>) <span>request-response concept </span>will be introduced, along with how to route a response back to the consumer. Since <strong>Advanced Message Queuing Protocol</strong> (<strong>AMQP</strong>) 0-9-1 , brokers provide four exchange types. This chapter also shows how to implement the last one, headers exchange.</p>
<p>Let's dive into the following topics:</p>
<ul>
<li>Sending responses to the publisher</li>
<li>Reply-to queues and RPC</li>
<li>Creating a data analysis service</li>
</ul>
<h1 id="uuid-95cbc85c-6a6f-48a1-a34e-039b8fe88a9f"><span class="fontstyle0">Technical requirements</span></h1>
<p class="mce-root">The code files of this chapter can be found on GitHub at<span> <a href="https://github.com/PacktPublishing/RabbitMQ-Essentials-Second-Edition/tree/master/Chapter05">https://github.com/PacktPublishing/RabbitMQ-Essentials-Second-Edition/tree/master/Chapter05</a></span>.</p>
<h1 id="uuid-fba5853a-867d-4ce7-9980-3500cc69b1bb">Sending responses to the publisher</h1>
<p>It is true that all of our interactions with RabbitMQ so far have been one way and asynchronous. It is also true that clients interacting with a service usually expect to receive a response. Reversing the publisher and consumer roles in the response phase requires the client to act as a publisher and the service as a consumer.</p>
<p>Different queues are used for requests and responses, as demonstrated in <a href="377ec533-342d-4a08-9011-7176de197886.xhtml">Chapter <em>2</em></a>, <em>Creating a Taxi Application</em>, and illustrated in the following diagram:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-656 image-border" src="assets/df52094d-f1e9-4f0a-a789-08d0dc4c2553.png" style="width:35.17em;height:19.50em;"/></p>
<div class="caption packt_figref CDPAlignCenter CDPAlign">Fig 5.1: A request-response interaction performed with message queues</div>
<p>In the following diagram, <em>Fig 5.2</em>, we can see the following:</p>
<ul>
<li>When a taxi driver confirms a booking request, a message is sent to the message broker with information about the driver (<span class="packt_screen">5</span>).</li>
<li>The application service receives the message (<span class="packt_screen">6</span>), stores the information in the database (<span class="packt_screen">7</span>), and confirms the booking with the mobile application, which is ultimately shown to the customer (<span class="packt_screen">8</span>).</li>
<li>At this point, the taxi needs to continuously share its current location with the customer. This is accomplished by sending the car's latitude and longitude to a location queue every minute (<span class="packt_screen">9</span><span>). The customer side of the app uses a WebSocket connection over RabbitMQ to subscribe to the current location queue (</span><span class="packt_screen">10</span><span>).</span></li>
</ul>
<p><strong>Complete Car</strong>'s (<strong>CC</strong>'s) architecture is shown in the following diagram, as a reminder:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-655 image-border" src="assets/af043c33-805f-4566-9920-8d1dc2fc470d.png" style="width:37.33em;height:17.08em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Fig 5.2: CC's main application architecture</div>
<p>Let's see how WebSockets is implemented.</p>
<h2 id="uuid-603aff0e-ce7a-4346-ab9a-8af2abe7a9b3">WebSockets in RabbitMQ</h2>
<p>RabbitMQ is a multi-protocol message broker. This section explores the <strong>Single Text-Oriented Message Protocol</strong> (<strong>STOMP</strong>) and how to use it with RabbitMQ to build interactive web applications. The Web STOMP RabbitMQ plugin makes it possible to use STOMP over the internet, by using WebSockets to send real-time data between a client—such as a web browser—and a broker via a web server. The plugin allows for highly interactive user experiences with data stored or processed on a server.</p>
<p>Start by enabling the Web STOMP plugin.</p>
<h3 id="uuid-91a6688a-2b6d-4a41-b735-b2d667092b2f">Enabling the Web STOMP plugin</h3>
<p>As with the RabbitMQ management plugin, RabbitMQ does not embed the Web STOMP plugin by default but offers it as an option. The appropriate RabbitMQ plugin must be enabled as well as installed, and a <strong>virtual host</strong> (<strong>vhost</strong>) has to be created with the appropriate permissions.</p>
<p>Run the following Debian package script to install the Web STOMP plugin:</p>
<pre class="lang-bash hljs">rabbitmq-plugins <span class="hljs-built_in">enable</span> rabbitmq_web_stomp</pre>
<p>For security purposes, create at least one user, with limited permissions, on a publicly exposed vhost. Run the following code to create the new vhost:</p>
<pre><strong>$ sudo rabbitmqctl add_vhost cc-dev-ws</strong><br/>Adding vhost "cc-dev-ws" ...</pre>
<p class="mce-root"><span>Next, add user permissions for the</span> <kbd>cc-dev</kbd> <span>user and the</span> <kbd>cc-dev-ws</kbd> <span>vhost:</span></p>
<pre><strong>$ sudo rabbitmqctl set_permissions -p cc-dev-ws cc-dev ".*" ".*" ".*"</strong><br/>Setting permissions for user "cc-dev" in vhost "cc-dev-ws" ..</pre>
<p>The new vhost is now created and is accessible to the <kbd>cc-dev</kbd> user. Some basic security options should be configured before setting up a new queue for the taxis to publish their current locations.</p>
<h3 id="uuid-e8486b40-81af-45f1-82e2-c57d7a7c2b1d">Securing Web STOMP with SSL </h3>
<p>Web STOMP uses the internet, which, in CC's application, leaves information vulnerable to snooping unless properly secured. Since most clients send the broker <strong>Uniform Resource Locator</strong> (<strong>URL</strong>), username, and password information, an additional level of security is necessary.</p>
<p>Luckily, it is possible to tell RabbitMQ to use <strong>Secure Sockets Layer</strong> (<strong>SSL</strong>) through the configuration file. For security, the CC team will add the following lines to the configuration to set up a certificate:</p>
<pre>ssl_options.cacertfile = /path/to/tls/ca_certificate.pem<br/><br/>ssl_options.certfile = /path/to/tls/server_certificate.pem<br/><br/>ssl_options.keyfile = /path/to/tls/server_key.pem<br/><br/>ssl_options.verify = verify_peer<br/><br/>ssl_options.fail_if_no_peer_cert = true <br/><br/>stomp.default_user = guest<br/><br/>stomp.default_pass = guest<br/><br/>stomp.implicit_connect = true</pre>
<p>For the settings to take effect, the broker must be restarted and the default username and password changed. The scripts contain the broker URL, which could give unwanted easy access to the server.</p>
<h3 id="uuid-140c6174-6107-4e7c-a03b-9b85d8c4e41c">Creating and publishing GPS data to the queue</h3>
<p>Now, the CC team will create a queue where the taxi sends the current location, this time by using <kbd>rabbitmqadmin</kbd> and running the following commands to create a queue called <kbd>taxi_information</kbd>:</p>
<pre>rabbitmqadmin declare queue name=taxi_information durable=true vhost=cc-dev-ws</pre>
<p>Add an exchange called <kbd>taxi_exchange</kbd>, like this:</p>
<pre>rabbitmqadmin declare exchange name=taxi_exchange type=direct vhost=cc-dev-ws</pre>
<p>Since the command-line tools do not allow the action to bind queues to exchanges, use the RabbitMQ management interface to bind the <kbd>taxi_information</kbd> queue to the <kbd>taxi_exchange</kbd> exchange using the <kbd>taxi_information</kbd> routing key.</p>
<p>The CC team will log in, head to the <span class="packt_screen">Queues</span> section, and add this information to the <span class="packt_screen">Bindings</span> section, as shown in the following diagram:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-657 image-border" src="assets/87070943-e468-4e28-994b-8ccbc3c86988.png" style="width:51.67em;height:51.00em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Fig 5.3: Add binding to the queue via RabbitMQ management</div>
<p><span>With a queue established, the taxi application can communicate with the broker. The code for this is not provided since it would be almost the same code as in <a href="377ec533-342d-4a08-9011-7176de197886.xhtml">Chapter 2</a>, <em>Creating a Taxi Application</em>. Instead, the following diagram shows how a message can be published via the management console, which is usually used for testing purposes:</span></p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-658 image-border" src="assets/6edb8a77-9336-496d-985d-ad30f26448bf.png" style="width:74.17em;height:31.00em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Fig 5.4: Send GPS coordinates to RabbitMQ</div>
<p>The consumer can now subscribe to <strong>Global Positioning System</strong> (<strong>GPS</strong>) data from the <kbd>taxi_information</kbd> queue.</p>
<h3 id="uuid-763986ad-a75d-4454-b29a-952f4d00d1c7">Subscribing to GPS and driver information via WebSockets</h3>
<p>The customer can use the mobile clients to receive location data through WebSockets, as shown in <em>Fig 5.2</em>.</p>
<p>The customer mobile application uses JavaScript and HTML, made possible with tools such as React Native or Angular NativeScript, which are two cross-platform frameworks that continue to gain traction. </p>
<p>The CC team imports the StompJs library (<a href="https://stomp-js.github.io/guide/stompjs/using-stompjs-v5.html">stomp.umd.min.js</a>) into the application using a content delivery network, as follows:</p>
<pre>&lt;script src=”https://cdn.jsdelivr.net/npm/@stomp/stompjs@5.0.0/bundles/stomp.umd.min.js”&gt;&lt;/script&gt;</pre>
<p>Then, CC includes some code, in order to receive updates from the queue.</p>
<p>First of all, the <kbd>stompClient</kbd> <span class="st">variable is declared and configured. The brok</span>er URL s<span class="st">hould start with <kbd>ws://</kbd> or <kbd>wss://</kbd>. The <kbd>reconnectDelay</kbd> variable in the example is set to <kbd>200</kbd> ms, which means that a retry will happen 200 ms after a disconnect, as follows:</span></p>
<pre>let stompClient;<br/><br/>const stompConfig = {<br/>  connectHeaders: {<br/>   login: username,<br/>    passcode: password,<br/>    host: 'cc-dev-ws' <br/>  },<br/>  brokerURL: brokerURL,<br/>  debug: function (str) {<br/>    console.log('STOMP: ' + str);<br/>  },<br/>  reconnectDelay: 200,<br/>  onConnect: function (frame) {<br/>    const subscription =<br/>stompClient.subscribe('/queue/taxi_information',       <br/>    function (message) {<br/>      const body = JSON.parse(message.body);<br/>      const latitude = body.latitude;<br/>      const longitude = body.longitude;<br/>    });<br/>  }<br/>};</pre>
<p>After that, the instance is created and connected to, as follows:</p>
<pre>stompClient = new StompJs.Client(stompConfig);<br/>stompClient.activate();</pre>
<p>The CC team will create a callback to handle incoming messages and subscribe directly to the <kbd>taxi_information</kbd> queue. The username, password, and broker URL must be changed.</p>
<div class="packt_infobox">The broker URL must include the Web STOMP port, defaulting to <kbd>15674</kbd>.</div>
<p>Happy times! The customer will now know approximately where the taxi is located, both before and during the ride.</p>
<p>Now, let's look at another option to receive a reply from the consumer.</p>
<h1 id="uuid-5e42b57b-0ad6-4fed-ae5d-bc49871ef7e2">Reply-to queues and RPC</h1>
<p>The CC application can now communicate in a good way between the publisher and the consumer, but what if a function has to run on a remote computer and wait for the result? Hardcoding an exchange and routing key in the service to publish responses isn't possible as it would be too inflexible. The solution is to have the request message carry the coordinates of the location where the response should be sent, a pattern commonly known as RPC.</p>
<p>The application service calls a specific function residing on the taxi application, and the taxi sends the result to the end user. The request message carries the name of the queue where the response should be sent. The AMQP protocol supports this mechanism out of the box. The client can store the queue name of the location where the response must be sent.</p>
<p>When RabbitMQ delivers a message to the consumer, it will change the <kbd>reply-to</kbd> property. The server can reply to the message from the publisher by sending a message to the default exchange with the routing key of the <kbd>reply-to</kbd> property.</p>
<p>Any type of queue can be used for the <kbd>reply-to</kbd> mechanism, but in practice, the following two approaches are used:</p>
<ul>
<li><strong>Create a short-lived queue for each request-response interaction</strong>. This approach uses an exclusive, auto-deleted, nondurable, server-side named queue created by the client with the following benefits:</li>
<li style="padding-left: 60px">No other consumer can get messages from it since it is exclusive.</li>
<li style="padding-left: 60px">It can be auto-deleted; once the reply has been consumed, there is no longer a use for it. </li>
<li style="padding-left: 60px">No need for it to be durable; request-response interactions are not meant to be long-lived.</li>
<li style="padding-left: 60px">The server generates a unique name, which relieves the client from having to figure out a unique naming scheme.</li>
</ul>
<ul>
<li><strong>Use a permanent reply-to queue specific to the client</strong>. This approach uses a nonexclusive, non-automatically deleted, nondurable, client-side named queue with the following benefits:</li>
<li style="padding-left: 60px">No need for it to be durable, for the same reason explained previously.</li>
<li style="padding-left: 60px">No need for it to be exclusive—a different consumer will be used for each request-response interaction.</li>
</ul>
<p>The difficulty in using a permanent queue is in correlating responses with requests. This is done through the <kbd>CorrelationId</kbd> message property, carried from the request message to the response message. This property allows the client to identify the correct request to process.</p>
<p>A permanent queue is more efficient than using short-lived queues with each request since creation and deletion are expensive operations.</p>
<div class="packt_infobox">RabbitMQ client libraries offer primitives that simplify responses correlated with requests.</div>
<p>That completes the information on routing back options to response queues through <kbd>reply-to</kbd>. To continue, the CC team will discover the fourth type of exchange offered by RabbitMQ by connecting a data analysis service.</p>
<h1 id="uuid-dab7d51b-ecf6-4e26-9b8e-f7621b5a5cda">Creating a data analysis service</h1>
<p>CC wants to be able to analyze incoming data. This system analyses requests for taxis in different areas, discovers important patterns, and finds peak request times. The project manager assigned the team to build a system capable of running several versions of the same service in parallel, allowing the graceful evolution of the service during updates.</p>
<p>A member of the team stated that it is possible to use a topic exchange and structure the routing key as <kbd>{service_name}{version}</kbd>. Their idea works within the current system; however, RabbitMQ offers a more elegant solution to this problem through the headers exchange.</p>
<p>The headers exchange allows the routing of messages based on their headers, which are custom key-value pairs stored in the message properties. The custom key-value pairs guide messages to the correct queue or queues. With this approach, the message and its routing information are all self-contained, remain consistent, and are therefore easier to inspect as a whole.</p>
<p>This addition works flawlessly within CC's architecture, merely requiring the team to bind the queues to a headers exchange and send messages with the appropriate headers. Start by opening a command-line shell and executing the following commands:</p>
<ol>
<li>Create a new headers exchange called <kbd>taxi_headers_exchange</kbd>, as follows:</li>
</ol>
<pre style="padding-left: 60px">rabbitmqadmin declare exchange name=taxi_header_exchange type=headers --vhost cc-dev</pre>
<p style="padding-left: 60px">The CC team will set up a queue to receive information from the taxis.</p>
<ol start="2">
<li>Create a new queue called <kbd>taxi_information_with_headers</kbd>, as follows:</li>
</ol>
<pre style="padding-left: 60px">rabbitmqadmin declare queue --name=taxi_information_with_headers durable=true --vhost cc-dev</pre>
<p>Bind the new queue to the <kbd>taxi_header_exchange</kbd> headers exchange in the management console, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-659 image-border" src="assets/4461780b-78c2-47b2-9f8f-ba96b9bdd10c.png" style="width:35.42em;height:23.17em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Fig 5.5: Bind a queue to an exchange in the management console</div>
<p>By setting <span class="packt_screen">x-match</span> to <span class="packt_screen">all</span>, this means that RabbitMQ will route messages sent to <span class="packt_screen">taxi_header_exchange</span> to the <span class="packt_screen">taxi_information_with_headers</span> queue only when <span class="packt_screen">system</span> <span class="packt_screen">=</span> <span class="packt_screen">taxi</span> and <span class="packt_screen">version </span><span class="packt_screen">= 0.1b</span>. Otherwise, the system drops the message. Header values to match on may be of the <span class="packt_screen">String</span>, <span class="packt_screen">Number</span>, <span class="packt_screen">Boolean</span>, or <span class="packt_screen">List</span> types. Routing keys aren't required since the key-value pairs serve as the key.</p>
<p>The <span class="packt_screen">x-match</span> parameter specifies whether all headers must match or just one. The property can have two different values—<span class="packt_screen">any</span> or <span class="packt_screen">all</span>, described as follows:</p>
<ul>
<li><span class="packt_screen">all </span>is the default value, which means that all header pairs (key, value) must match.</li>
<li><span class="packt_screen">any</span> means at least one of the header pairs must match.</li>
</ul>
<p>Because the data analysis service is written in Python, we will switch away from Ruby for the moment. Luckily, connecting and publishing messages in Python is very much the same as it is in Ruby, so there is no big learning curve to get through.</p>
<p class="mce-root">Note that the RabbitMQ recommended library for Python is <kbd>pika</kbd> (<a href="https://pypi.org/project/pika/">https://pypi. org/project/pika/</a>). Information can be sent to the new queue as follows:</p>
<ol>
<li>Start to import the client library <kbd>pika</kbd> and <kbd>json</kbd>:</li>
</ol>
<pre style="padding-left: 60px">import pika<br/>import json</pre>
<ol start="2">
<li>Set credentials to connect to RabbitMQ:</li>
</ol>
<pre style="padding-left: 60px">credentials = pika.PlainCredentials("cc-dev", "taxi123")<br/>parameters = pika.ConnectionParameters(<br/>  host="127.0.0.1",<br/>  port=5672,<br/>  virtual_host="cc-dev-ws", <br/>  credentials=credentials)</pre>
<ol start="3">
<li>Assert that the connection is established, and try to open a channel on the connection. Set the header version value to <kbd>0.1b</kbd> and the system value to <kbd>taxi</kbd>. A message is published to the <kbd>taxi_header_exchange</kbd> with the given GPS positions:</li>
</ol>
<pre style="padding-left: 60px">conn = pika.BlockingConnection(parameters)<br/>assert conn.is_open<br/>try:<br/>  ch = conn.channel()<br/>  assert ch.is_open<br/>  headers = {"version": "0.1b", "system": "taxi"}<br/>  properties = pika.BasicProperties(content_type='application/json',<br/>headers=headers)<br/>  message = {"latitude": 0.0, "longitude": -1.0}<br/>  message = json.dumps(message)<br/>  ch.basic_publish(<br/>    exchange="taxi_header_exchange",  <br/>    body=message,<br/>    properties=properties, routing_key="")<br/>finally:<br/>  conn.close()</pre>
<p>Because <kbd>x-match=all</kbd>, both header values must be embedded in the message properties. The exchange ensures that the system and version match the values specified in the management console before routing the message to the <kbd>taxi_information_with_headers</kbd> queue.</p>
<h1 id="uuid-7e41340b-b520-4eca-9364-aa13b3242ffa">Summary</h1>
<p>As CC's users and customers become more familiar with the system, they begin to ask for more functionality. The CC application is now able to connect to the broker through WebSockets and subscribes to location updates delivered directly from the taxi. Location messages are flowing and CC's app is working great and offering more complex features.</p>
<p>This chapter further demonstrated how to use RPC in RabbitMQ via reply-to queues. The header exchange was introduced to build a system capable of running several versions of the same service in parallel, allowing graceful evolution during updates. Another exciting addition to the CC system took place in this chapter, which was the ability to incorporate data analysis into the system to discover important user patterns and other insights. Header exchanges were thereby explained.</p>
<p>The next chapter covers the all-important production realities that CC must understand going forward. Important topics such as federation features and clustering, along with health checks and alerts, are coming up.</p>


            </article>

            
        </section>
    </body></html>