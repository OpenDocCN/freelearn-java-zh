- en: 'Chapter 10: Implementing User Interaction'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**User interaction** constitutes a very important layer in software architecture.
    This layer comprises all the ways, such as web interfaces and mobile applications,
    that end users can approach and use our applications.'
  prefs: []
  type: TYPE_NORMAL
- en: For this reason, user interaction needs to be implemented with very high attention
    to detail. A badly designed, poorly performing user interface will compromise
    the overall user experience, even if the rest of the application is well written
    and performs really well. And indeed, the user interface can use a number of different
    tricks to hide issues (such as performance issues) in other layers of the software
    architecture (that is, *the backend*).
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we are going to explore the most widely used technologies for
    Java applications, both for cloud-native and traditional applications.
  prefs: []
  type: TYPE_NORMAL
- en: This will include frameworks built using the **Java Enterprise Edition** platform
    (such as **Jakarta Server Pages** and **Jakarta Server Faces**) and more modern
    JavaScript frameworks for single-page applications (React, in our case).
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn about the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: User interface architecture – backend versus frontend
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Web user interfaces using Jakarta Server Faces and Jakarta Server Pages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing single-page applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning about mobile application development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring IVR, chatbots, and voice assistants
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Omnichannel strategy in enterprise applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's start by concentrating on the architecture of the user interaction layer,
    or rather, where to put each component and functionality. We will touch on the
    architectural aspects of building frontend layers for our applications.
  prefs: []
  type: TYPE_NORMAL
- en: User interface architecture – backend versus frontend
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It may seem silly to discuss where a **User Interface** (**UI**) must live.
    After all, it's almost a given – the UI is the forefront of our software architecture,
    providing the interaction with end users, and for this reason, it must stay at
    the front, hence the term *frontend*, which is used as a synonym for UI. And everybody
    agrees on that, without a doubt.
  prefs: []
  type: TYPE_NORMAL
- en: 'Except that it''s not that easy to draw a line as to where a UI starts and
    where it ends. And, depending on the particular implementation, a number of different
    components may provide the functionalities needed to build the experience we want
    to eventually present to our customers. The UI will be made of, more or less,
    the following components:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Assets, also referred to as static files**: These are the pieces of the web
    application that must be sent (where relevant) to our clients. They include, usually,
    HTML files, JavaScript scripts, other graphical artifacts (images, CSS files,
    and movie clips), and even fully built, self-contained applications (as in the
    case of mobile apps).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data**: This is the content shown using the assets. This implies having a
    way to retrieve updates (usually involving web services or similar technology).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Behavior**: This refers to how the UI reacts to user inputs and other events.
    This is a broader area that includes *interactivity* (what changes, and how, when
    our user does something), *validation* (checking user inputs for formal and substantial
    consistency), *navigation* (how different views, or pages, must be shown one after
    the other to implement the features requested by the user), and *security* (how
    to be sure that each user is properly identified and profiled, able to do only
    what they are allowed to do, and able to access only the appropriate set of data).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The point is more or less this – different implementations will have different
    ways of providing assets to end users, different ways of providing (and collecting)
    data, and different implementations of behavior (such as navigation or validation
    being implemented on the client side or the server side). In this chapter, we
    will look at the most common ways to arrange all of those components to provide
    a good user experience. Our next section will be about the most traditional ways
    to implement this in Java Enterprise Edition – Jakarta Server Faces and Jakarta
    Server Pages.
  prefs: []
  type: TYPE_NORMAL
- en: Web user interface using Jakarta Server Pages and Jakarta Server Faces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have ever worked with Java Enterprise applications developed from 2000
    to 2015, chances are you have seen **Java Server Pages** (**JSP**) and **Java
    Server Faces** (**JSF**) in action. Now widely considered legacy, these two technologies
    still appear widely in existing Java deployments and are worth knowing about,
    at least for historical reasons.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing basic Java web technology – Jakarta Server Pages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Jakarta Server Pages** (formerly Java Server Pages) is, in essence, a templating
    technology, allowing you to mix dynamic content written in Java with static content
    (usually written in HTML). By using JSP, an application server can build a web
    page to provide to a client (and visualize in a web browser). We already talked
    about JSP in [*Chapter 6*](B16354_06_Final_JM_ePUB.xhtml#_idTextAnchor141), *Exploring
    Essential Java Architectural Patterns*, when talking about server-side **Model
    View Controller** (**MVC**). If you remember, JSP plays the role of the *View*
    in the MVC pattern. In the same context, we mentioned servlets as another core
    component, taking care of the *Controller* part of MVC.'
  prefs: []
  type: TYPE_NORMAL
- en: It's now time to clarify the relationship between servlets and JSP. Assuming
    that most of you know what a servlet is, I will provide just a very brief description.
  prefs: []
  type: TYPE_NORMAL
- en: A `init()`, called when the servlet is loaded, and `destroy()`, called before
    the servlet is unloaded), while others are called when HTTP actions are performed
    against the servlet (such as `doPost(...)`, to handle an HTTP `POST` request,
    and `doGet(...)`, to do the same with a `GET` request).
  prefs: []
  type: TYPE_NORMAL
- en: So far so good! Servlets are specialized components, able to handle HTTP conversations,
    and for this reason, they are used to complement views (such as JSP files) in
    providing user experience features (such as form submission and page navigation).
    As we have discussed, it is common for a servlet to be the *controller*, whereas
    a JSP file is used as the *view*, although more sophisticated frameworks have
    been developed to deal with JSP, such as Struts and the Spring MVC.
  prefs: []
  type: TYPE_NORMAL
- en: But there is another point worth noting – JSP files are basically servlets themselves.
  prefs: []
  type: TYPE_NORMAL
- en: A JSP file, indeed, is just a different way to implement a servlet. Each JSP
    file, at runtime, is translated into a servlet by the application server running
    our code. As we discussed in [*Chapter 7*](B16354_07_Final_JM_ePUB.xhtml#_idTextAnchor164),
    *Exploring Middleware and Frameworks*, we need an application server fully or
    partially compliant with the JEE specification in order to run each JEE API (including
    the servlet and JSP APIs).
  prefs: []
  type: TYPE_NORMAL
- en: So, now that we know that JSP is a templating technology and that each JSP file
    is translated to a servlet, which outputs to the client what we have modeled in
    the template, it is time to see what a JSP file looks like.
  prefs: []
  type: TYPE_NORMAL
- en: A JSP file is somewhat similar to a `<% ... %>`, which is called a **scriptlet**
    and contains arbitrary Java code. A scriptlet is executed when a client requests
    a page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another tag used in JSP is marked using `<%= %>` and is called an `<%@ ...
    %>` and used to configure page metadata. A very basic JSP page might look like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Some things worth noticing are listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: At the top of the files, directives are used. They define some metadata (the
    page content type and the language used) and the Java packages to be imported
    and used on the page.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is some HTML code interleaved with the scripts. The code inside the script
    delimiters is largely recognizable to Java developers, as it simply formats a
    date.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the first scriptlet, we define the `date` variable. We can then access it
    in the expression inside the `<h1>` HTML tag. The expression simply refers to
    the variable. The engine will then replace the variable value in that spot in
    the generated HTML page.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In a real-world application, we can imagine some useful ways to use such syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: We could use scriptlets to retrieve useful data by calling external services
    or using database connections.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By using Java code in the scriptlets, it is easy to implement iterations (usually
    to display tabular data) and format data in a preferred way (both in scriptlets
    and expressions).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Java code in scriptlets can be used to get and validate data provided by the
    user (usually using HTML forms). Moreover, user sessions and security can be managed
    in different ways (usually by leveraging cookies).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's also worth noticing that JSP directives can be used to include other JSP
    files. In this way, the logic can be modularized and reused.
  prefs: []
  type: TYPE_NORMAL
- en: 'Moreover, JSP allows defining custom tag libraries. Such libraries are collections
    of personalized tags that embed custom logic that is executed when a tag is used.
    A widely used tag library is the one provided by default by the JSP implementation,
    which is the **Jakarta Standard Tag Library** (**JSTL**). In order to use a tag
    library (JSTL core, in this case), we need to use a directive to import it like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The JSTL provides a set of tags that offer the following functionalities:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Core` provides basic functionalities such as flow control (loops and conditional
    blocks) and exception handling.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`JSTL` is used mostly for string manipulation and variable access.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SQL` implements basic database connection handling and data access.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`XML` is used for XML document manipulation and parsing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Formatting` is a set of functions useful for formatting variables (such as
    dates and strings), according to character encodings and locale.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, the date formatting that we did in our previous example can be summarized
    with the appropriate JSTL tags (included from the `Core` and `Formatting` collections)
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: But even if JSTL tags are supposed to reduce the amount of Java code in JSP
    files, it's very hard to entirely remove *all* Java code. Java code mixed with
    presentation code is considered an antipattern to avoid, and it's not the only
    consideration to be made. In the next section, we will see why JSP is considered
    a legacy technology and almost every Java project today relies on different options
    for frontend development.
  prefs: []
  type: TYPE_NORMAL
- en: JSP – the downsides
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, it''s time to look at the bad news. There are a number of reasons why
    JSP is nowadays widely considered unsuitable for modern applications. I can summarize
    some of those reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: JSP allows for Java code to be interleaved with HTML code. For this reason,
    it becomes very easy to mix presentation logic with business logic. The result
    is often an ugly mess (especially in big applications), as it becomes tempting
    to have presentation logic slip into Java code (such as conditional formatting
    and complex loops), with the final result being JSP pages that are both hard to
    read and maintain.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For similar reasons, a collaboration between different teams with different
    skills is very difficult. Frontend teams (such as graphic designers) are supposed
    to work on the HTML sections of a JSP file, while the same file could be being
    worked on by the backend team for adding business logic-related functionalities.
    This leads to a resource contention that is hard to solve, as each team may break
    the other team's implementations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Focusing on frontend development, the development cycle is cumbersome and has
    a slow turnaround. Frontend developers and graphic designers are used to editing
    an HTML file, refreshing the browser, and immediately seeing the result. With
    JSP, this is just not possible; usually, the project has to be rebuilt into an
    artifact (such as a `.war` file) and redeployed to an application server. There
    can be solutions to this particular issue (such as exploded deployments, where
    a `.war` file is deployed as an extracted folder), but they are usually implemented
    differently depending on the application server and may have some downsides (such
    as not covering all the different kinds of modifications to the file or incurring
    out-of-memory exceptions if performed too many times).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This leads to another very important point – JSP files require an application
    server that is fully or partially implementing the JEE specification. **Apache
    Tomcat** is a common choice here. Indeed, instead of a basic web server serving
    static content (which is what is used with modern client-side frameworks, as we
    will see in a couple of sections), you will need a **Java Virtual Machine** (**JVM**)
    and an application server (such as Tomcat) running on top. This will mean slightly
    more powerful machines are needed, and fine-tuning and security testing must be
    performed more thoroughly (simply because Java application servers are more complex
    than static files serving web servers, not because Java is less secure per se).
    Furthermore, frontend developers will need to use this server (maybe on their
    local workstation) for development purposes (and that may not be the simplest
    thing to manage).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JSP also lacks a simple way of sharing components between different pages and
    applications. Also, the JSP tags are usually a bit cumbersome to use, especially
    in complex applications.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Moreover, the performance in JSP applications is overall worse when compared
    to single-page applications. Modern JavaScript frameworks for single-page applications
    are indeed designed to keep the data exchange with the server at a minimum – after
    you download the HTML files and assets for the first time, and only then, the
    data is exchanged. This is not so easy to achieve with just JSP, which, in general,
    is designed to render the server-side page and download it as a whole.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, the intrinsic nature of JSP makes things more complex from an architectural
    point of view. Since, in a JSP file, you can use Java code, which entails calling
    backend services and doing SQL queries, the flow of calls may become complex and
    convoluted. *Are you supposed to have connections from the frontend directly to
    the database?* *What about services exposed by the backend?* Instead of having
    a thin, simple frontend layer used mostly for visualization and interactivity,
    you will have business logic and data manipulation sprawling all over the frontend
    layer. Not the best situation from an architectural standpoint.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, now we have seen the basics of JSP, which is a complete template engine
    that's useful for defining HTML websites and providing some dynamic content written
    in Java. We've also understood what the limitations of the technology are. It
    is now worth noticing that JEE provides a more complex and complete framework
    for building web apps, which is Jakarta Server Faces.
  prefs: []
  type: TYPE_NORMAL
- en: Jakarta Server Faces – a complex JEE web technology
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Jakarta Server Faces** (**JSF**) is a much more complete (and complex) framework
    compared to JSP. It implements the MVC pattern, and it is much more prescriptive
    and opinionated. This means that concepts such as variable binding, page navigation,
    security, and session handling are core concepts of the framework. It also provides
    a component-centric view, meaning that it provides reusable components, which
    include complex view functionalities such as tables, forms, inputs, and validation.'
  prefs: []
  type: TYPE_NORMAL
- en: As per the *view* component of the MVC pattern, JSF used to rely on JSP templating.
    In more recent implementations, this has been switched by default to **Facelets**,
    which is an XML-based templating technology.
  prefs: []
  type: TYPE_NORMAL
- en: The *controller* part of JSF is implemented by a special servlet, **FacesServlet**,
    which takes care of things such as resources initialization, life cycle, and request
    processing.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the *model* part of JSF is implemented using so-called *managed beans*,
    which are simply Java classes with a set of properties, getters, and setters.
    Managed beans are used to bind to pages and components in pages, containing values
    to be displayed, validating the user input, and handling events. Managed beans
    can be configured to live within different scopes, including a session (attached
    to an HTTP session), a request (the same, but with an HTTP request), and an application
    (living as long as the entire web application does).
  prefs: []
  type: TYPE_NORMAL
- en: There are a number of different JSF implementations, with the most famous being
    the **Mojarra JSF** (backed by Oracle). Other projects extend such implementation,
    also providing a suite of reusable components. The most famous ones are **RichFaces**
    (backed by Red Hat and discontinued for many years), **IceFaces**, and **PrimeFaces**.
  prefs: []
  type: TYPE_NORMAL
- en: This is an overview of the internal architecture and basics of JSF. Without
    going into too much detail, let's analyze, as we have done for JSP, the downsides
    of JSF.
  prefs: []
  type: TYPE_NORMAL
- en: JSF – the downsides
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s start by saying that, whereas JSP is currently considered legacy but
    sometimes still used here and there for basic tasks (for simple internal web interfaces
    such as administration panels), JSF is today avoided wherever possible. The reason
    for this is that, on top of the JSP''s downsides, JSF adds some more. This is
    what I can say about it:'
  prefs: []
  type: TYPE_NORMAL
- en: '**JSF is very hard to learn**: While basic tasks are easy to perform, JSF does
    a lot of things behind the scenes, such as managing the life cycle of pages and
    building stateful sessions, that are very hard to master. For this reason, it''s
    common to use it in the wrong way or take advantage of only a small subset of
    all the features provided, making it overkill and difficult to manage for most
    web applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**JSF is difficult to test**: Unit tests can be written for some components
    (such as managed beans) but it is very hard to automate all the tests, especially
    on the *view* side (Facelets), mostly because it''s almost impossible to remove
    logic from that layer (and, as we know, having logic in the *view* layer is a
    terrible idea).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**JSF is hard to troubleshoot**: Since, as we said, JSF manages many things
    behind the scenes (above all, the binding of variables handled by the browser
    with the values contained in the managed beans), it''s really hard to understand
    the cause of things going wrong (such as variables not being updated and performance
    issues).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**JSF lacks a proper implementation for some small but very useful features**:
    The first things here that come to mind are AJAX communication (where some values
    on a web page are updated without the need of a full-page reload) and friendly
    URLs (when the URL of a page can be customized, which is helpful because it makes
    it easily readable and favored by search engines). For both of those features,
    there are some workarounds, but they are incomplete, not standard, and in general
    have been added late to the framework. Those are just two examples, but there
    are many; it''s all down to a general inflexibility of the framework.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The preceding points are enough to understand why, as of today, almost everybody
    agrees with JSF being a legacy technology that must not be adopted in new projects.
  prefs: []
  type: TYPE_NORMAL
- en: For this reason, it is not worth providing code samples of JSF.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have looked at the two major web technologies built using
    the JEE framework. As we have seen, these technologies, even if they are still
    widely used, have some big limitations (especially JSF), mostly coming from their
    *monolithic* approach, meaning that they are tightly coupled with backend implementation,
    and their limited flexibility.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will look at the widely used alternative to JEE native
    web technology – the single-page application.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing single-page applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Single-Page Applications** (or **SPAs**) is a broad term that came about
    to simply describe the behavior of some solutions meant to create web UIs in a
    lighter, more modern way. The first characteristic of the SPA is the one that
    it relates to the name. An SPA, in general, bundles all the assets necessary to
    start user interaction into a single HTML document and sends it to the client.'
  prefs: []
  type: TYPE_NORMAL
- en: All the following interactions between the client and the server, including
    loading data, sending data back, and loading other assets (as images or CSS files),
    are performed within the page using JavaScript. For this reason, SPAs minimize
    the communication between the client and server (improving performances), avoid
    the full-page refresh, and allow for a simpler architectural model.
  prefs: []
  type: TYPE_NORMAL
- en: Indeed, a basic, static file-serving web server (such as **Apache HTTPD** or
    **NGINX**) is all you need on the frontend (no Java application server is needed).
    Moreover, the interaction between client and server is almost exclusively limited
    to web service calls (usually JSON over REST), hence mixing backend and frontend
    logic (such as doing SQL queries from the frontend layer) is highly discouraged.
    The most significant downside that I see with SPAs is that there is no standardization
    of them. Unlike JEE technologies, each framework here provides its own different
    approach.
  prefs: []
  type: TYPE_NORMAL
- en: For this reason, there are a number of different, well-written, but incompatible
    implementations of frameworks for building SPAs. Most (if not all) heavily rely
    on JavaScript and are independent of what's used in the backend (provided that
    the backend can expose a compatible services layer, such as JSON over REST). In
    this context, we take for granted that a Java backend (JEE or something more modern,
    exposing a REST service) is provided.
  prefs: []
  type: TYPE_NORMAL
- en: But it is not uncommon for simpler projects to go for a full-stack approach
    (using JavaScript also on the backend, usually running on a server such as **Node.js**)
    or using different backend technology (such as Python or PHP). For the sake of
    brevity in this chapter, we will explore just one SPA framework, **React**, which
    is backed by Facebook and widely used for building web applications, from small
    websites to large and popular platforms such as social networks. But it is worth
    noting that there are a number of similarly powerful alternatives (such as Angular,
    Vue, and Svelte), and since no standard is provided, there is no guarantee of
    the life cycle of any such technology, nor is it possible to easily move code
    written in one implementation to another. In order to start playing with SPAs,
    a preamble on the JavaScript ecosystem will be needed.
  prefs: []
  type: TYPE_NORMAL
- en: Basics of the JavaScript ecosystem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I suppose that most of the readers of this book are beginners or experienced
    Java developers and junior architects, with little or no exposure to JavaScript.
    Of course, JavaScript is a huge and interesting world that cannot be completely
    described in just a few paragraphs, so the goal of this section is just to give
    you the basics, enough for the next couple of sections, which will focus on React.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript was born in 1995, mostly for programming inside a web browser. Originally
    designed for Netscape, it was of course then implemented as part of most major
    web browsers. Even if the name looks very similar, JavaScript doesn't share that
    much with the Java language, being interpreted (whereas Java is compiled into
    bytecode) and dynamically typed (so it checks for type safety at runtime, while
    Java is statically typed, checking for type safety at build time). And there are
    a number of other differences, including the object model, APIs, and dependency
    management. JavaScript has been standardized into a technical specification called
    **ECMAScript**.
  prefs: []
  type: TYPE_NORMAL
- en: Another important topic is Node.js. While, as mentioned, JavaScript was initially
    executed by engines embedded into web browsers, Node.js is a standalone engine,
    able to execute JavaScript code outside of a web browser. Node.js is used for
    server-side development, whereas JavaScript is used for developing server-side
    logic by implementing web services and integrating with other components such
    as databases.
  prefs: []
  type: TYPE_NORMAL
- en: The reason I'm mentioning Node.js is not for its use as a backend server (or
    at least, this is not relevant in this particular context) but because it has
    evolved as a complete toolbox for JavaScript development. Indeed, it includes
    **Node Package Manager** (**npm**), which is a utility for dependency management
    in JavaScript (conceptually similar to Maven in the Java world).
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, it's very often used as a local server for JavaScript development,
    being very lightweight and supporting the hot reloading of updates. Last but not
    least, a lot of client-side SPA frameworks (including React) distribute utilities
    for Node.js, such as command-line interfaces, useful for creating the skeleton
    of a new application, packaging it for distribution, and so on. Now that we have
    seen the basics of current JavaScript development, is time to have a look at the
    framework that we have selected for this chapter, React, in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the React framework
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**React** (also known as **ReactJS**) is a JavaScript framework for building
    SPAs. A very interesting feature of React is that as well as being used to build
    web applications to be accessed using a web browser, React can be used (through
    the React Native project) to build native applications to be executed on mobile
    platforms (Android and iOS) and desktop (Windows and macOS).'
  prefs: []
  type: TYPE_NORMAL
- en: React is very simple in its approach, which is based on the concept of components
    (more about that soon). Moreover, it's also very efficient because it uses the
    concept of the **virtual DOM**.
  prefs: []
  type: TYPE_NORMAL
- en: Many JavaScript frameworks create web pages and interactions by directly accessing
    and modifying the **Document Object Model** (**DOM**). The DOM is basically the
    standard object representing the HTML document rendered by the browser, in the
    form of a tree starting with an HTML tag.
  prefs: []
  type: TYPE_NORMAL
- en: React uses this alternative approach of building a custom object (called the
    virtual DOM) that is a partial representation of the DOM, modeling the desired
    state of the DOM itself (hence the appearance and behavior of the web application).
    React applications act on this representation. It is then the framework that compares
    the DOM to the virtual DOM and makes only the necessary updates to the DOM, changing
    it in an effective and efficient way.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript syntax extension
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**JavaScript Syntax Extension** (**JSX**) is a technology that''s widely used
    with React. It looks similar to HTML and offers the ability to mix JavaScript
    code with HTML tags. With this in mind, it can be seen as a template technology,
    not so different from JSP, which we saw a couple of sections ago. It''s also worth
    noting that, just as JSP transforms everything we write to Java code (and, specifically,
    to a servlet that uses Java code to output HTML), JSX does exactly the same, transforming
    JSX code into JavaScript code, producing the right HTML.'
  prefs: []
  type: TYPE_NORMAL
- en: It's worth noting that in the JSX world, mixing JavaScript and HTML is not considered
    an antipattern but is instead encouraged (and often done). This is because even
    if you implement complex logic with JavaScript, such logic mostly entails frontend-related
    behaviors (such as when to show one component and optional formatting), so you
    are less likely to pollute frontend code with things that don't belong in the
    frontend (such as business logic).
  prefs: []
  type: TYPE_NORMAL
- en: 'The reason JSX is so popular is that can be used to define React components
    with a very compact and understandable syntax. This is what a basic React component
    might look like without using JSX:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'And this is how to implement the same component with JSX:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: So, the advantage in terms of readability and effectiveness is evident. And
    it would become more evident with more complex cases, such as with tags that include
    other tags (such as HTML lists or other nested tags).
  prefs: []
  type: TYPE_NORMAL
- en: Readability and ease of use are not the only qualities of JSX. It's important
    to note that JSX will also prevent, by default, injection attacks. An **injection
    attack** is when, using various techniques, a malicious user injects into your
    page custom code (such as JavaScript code or arbitrary HTML content). JSX, by
    default, sanitizes the output, hence neutralizing such attacks with no efforts
    on the development side. Moreover, JSX is a pretty complete language that can
    embed conditions and loops, call other functions, and so on. It's a very powerful
    tool for building UIs in React.
  prefs: []
  type: TYPE_NORMAL
- en: Since we have mentioned React components, it's important now to explain what
    they are and how they work.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing React components
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **component** is a core concept of React. It is basically a small, embeddable
    piece of UI that includes structure, appearance, and behavior logic that can be
    reused.
  prefs: []
  type: TYPE_NORMAL
- en: 'From a technical point of view, React components are JavaScript functions or
    classes. Components take, by default, a `props` argument, which is basically an
    object encapsulating the (optional) properties to be passed to the component.
    So, this is a component modeled using `function` (and JSX):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'And this is the same component, using a class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As you see, the component, whether defined as a function or a class, basically
    wraps around a JSX template representing the HTML code to be rendered. Whatever
    way you define it, you can then use it as a tag, in this case `<HelloWorld/>`,
    which will be replaced with what is evaluated by executing the component logic.
    It's worth knowing that to pass properties, you can simply use tag attributes,
    which will be passed as part of the `props` object. So, in our case, to pass `fullName`,
    it's enough to use the component as `<HelloWorld fullName="Giuseppe Bonocore"/>`.
  prefs: []
  type: TYPE_NORMAL
- en: You may have noticed that when defined as a class, we are adding our presentation
    using the `render` method. By default, it is also possible to use the `constructor`
    method, which takes `props` as a parameter. Such a method can be used to initialize
    the component. If you need to manage a state in the component (such as when saving
    local variables), you can do so by accessing the `this.state` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Such an object can be, of course, modified too, for which it is worth using
    the `this.setState` method, which will notify React that something in the state
    of the component has changed (and that maybe something in the view must be updated).
    This can be particularly useful when associated with UI events, such as the click
    of a button. The following code snippet represents a component with a button.
    Every time a user clicks on the button, a counter is incremented and saved into
    the local state of the component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: From here, of course, more complex combinations of event handling and internal
    state management can be designed. Last but not least, there are a number of other
    callbacks associated with the life cycle steps of the React component, such as
    `componentDidMount`, called after the component is rendered on the web page (but
    there are many other similar life cycle hooks).
  prefs: []
  type: TYPE_NORMAL
- en: React app structure
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now, we have some basic information on how to create a component and where to
    place our presentation markup and business logic. *But how should we start to
    create a basic React application and apply the concepts we have just learned about?*
  prefs: []
  type: TYPE_NORMAL
- en: The most common and easy way is to use the `npm` utility, which, as we saw a
    couple of sections ago, comes with the Node.js server. In order to download and
    install the Node.js server, you can refer to the official website at [https://nodejs.org/it/download/](https://nodejs.org/it/download/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have a working setup of Node, it is enough to run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: You'll need to change `myAppName` as needed, of course. Node.js (and `npm`)
    will then download all the necessary dependencies and create the folder structure
    and scaffolding for a basic React application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Such a structure might look as follows (some files are omitted):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The most important files are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`README.md` is the autogenerated *readme* file associated with your project
    and is used for documentation purposes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`node_modules` contains the JavaScript dependencies.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Package.json` contains the project metadata, including the dependencies needed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public/index.html` is the page template.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`src/index.js` is the JavaScript file executed as the first file (the entry
    point).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`src/App.js` is a de facto standard generated by the `create app` utility.
    It is basically a macro component that includes all the components and references
    in an `index.js` file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, that is the standard empty folder structure. In order to add our custom
    components, as per our previous example, we can create a `components` subfolder
    in `src`.
  prefs: []
  type: TYPE_NORMAL
- en: Each file containing a component will be a `.js` file named using the name of
    the component (*with a capital initial letter*). For our previous component example,
    that would be `Counter.js`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The file should declare the imported dependencies (at least React):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, make this component available to other components (the last line in the
    file):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to use such components in our app, we will need to import them into
    our `App.js` file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We can then use them as a tag (`<Counter/>`) in our JSX content.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, in order to test our React application, you can execute this command
    from inside the project folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This will execute the `node.js` server and launch your browser to the right
    page (`http://localhost:3000/`) to see your application running. Another important
    aspect of a React application is how to interact with the backend APIs. We will
    look at this in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Interacting with REST APIs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What we have looked at so far is basically presentation and behavior. A very
    important feature to consider, in order to implement a real application, is making
    requests to a backend. A common way to do that is to call REST APIs.
  prefs: []
  type: TYPE_NORMAL
- en: The standard way to call a REST API from a React application is by using the
    `axios` library.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install the `axios` dependency in React, you can use the `npm` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'You will then need to import the library into the component that is going to
    make REST requests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'And you can then use `axios` to make the usual REST calls (`GET`, `POST`, and
    so on). This is a quick snippet of a REST `get` call reading from an API and saving
    data to the local state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Of course, this example can be extended to make use of other REST verbs.
  prefs: []
  type: TYPE_NORMAL
- en: React – where to go from here
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The goal of the previous sections was to give you a taste of what it''s like
    to program a web interface using a client-side JavaScript framework. React is
    one of the most popular choices at the time of writing, so I think it''s a good
    investment to learn at least the basics of it. However, what we have just learned
    is far from being complete. Here are a few more topics that I suggest exploring
    in more depth:'
  prefs: []
  type: TYPE_NORMAL
- en: Forms and event handling, in order to implement rich user interaction, including
    validation and file uploads
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advanced visualizations, such as lists, tables, and conditional formatting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Packaging and deploying to production, with considerations about file size optimization,
    progressive web apps, and best practices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: React Native, or how to target alternative platforms to web browsers, such as
    Android, iPhone, and desktop apps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Routing (provided by the React Router dependency), which provides a way to implement
    navigation between different views
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In some cases, React provides a solution, while other times third-party plugins
    are required. There are a number of resources online; I suggest starting with
    the official React website and the other resources listed in the *Further reading*
    section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s quickly recap the evolution of frontend development in Java over time:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.1 – The evolution of frontend development in Java'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.1_B16354.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.1 – The evolution of frontend development in Java
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, **Servlet** was the first approach and is still somewhat used,
    regardless of its limitations, for basic use cases and as a supporting technology
    for more complex frameworks. The same is true for **JSP** (introduced shortly
    after **Servlet**), which provides some advantages (such as having a markup language
    that allows for development without directly using Java code).
  prefs: []
  type: TYPE_NORMAL
- en: The usage of JSP has slowed down over time, but it's still used for some use
    cases. **JSF** started getting traction after **JSP** but stopped gaining popularity
    soon after, and it is now almost completely abandoned and basically only used
    in legacy applications. SPAs (based on frameworks such as React) have since emerged
    and are now very popular and widely used.
  prefs: []
  type: TYPE_NORMAL
- en: With this section, we have completed our overview of web frameworks. In the
    next section, we are going to take a look at mobile application development.
  prefs: []
  type: TYPE_NORMAL
- en: Learning about mobile application development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mobile application development shares a lot of concepts (and challenges) with
    web application development. However, there are also some core differences. In
    this section, we are going to analyze some core concepts to keep in mind when
    designing the architecture of a mobile application.
  prefs: []
  type: TYPE_NORMAL
- en: In this context, we are mostly referring to mobile applications as a further
    channel to access the functionalities offered by a more complex ecosystem that
    is also accessible in other ways (via a web frontend, at least). Also, most of
    the considerations made in this section should be seen from an enterprise perspective.
    So, of course, if you are working in a different environment (such as in a start-up),
    your mileage may vary. First of all, let's start by looking at why we should consider
    developing a mobile application as a way to enable interaction with our features
    and functionalities.
  prefs: []
  type: TYPE_NORMAL
- en: The importance of mobile applications
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In today's world, it's trivial to point out that a mobile application is often
    our first point of contact with many services, such as banking, shopping, and
    entertainment.
  prefs: []
  type: TYPE_NORMAL
- en: There are around 7 billion mobile users in the world, and it's more and more
    common for people to possess one or more mobile devices (smartphones and tablets)
    rather than a laptop or desktop PC.
  prefs: []
  type: TYPE_NORMAL
- en: Mobile devices offer a regulated environment through application permission
    settings and app stores that, while being a bit more restrictive, highly improve
    stability and performance standards. That's often a key reason for choosing app
    interaction over web interaction – it often offers a more standardized user experience
    and simpler access.
  prefs: []
  type: TYPE_NORMAL
- en: Then, of course, there is convenience – it's way easier to complete a task,
    whether it's purchasing something or just accessing some information, using a
    device that you have in your pocket compared to having to use a laptop or desktop
    PC.
  prefs: []
  type: TYPE_NORMAL
- en: Last but not least, mobile devices are equipped with sensors and functionalities
    that are key for offering an integrated experience. I can search for a restaurant
    and immediately call them to book a table or ask for directions while driving
    there.
  prefs: []
  type: TYPE_NORMAL
- en: Given all that, it's nowadays the default position to think about a *mobile-first*
    user experience when developing user interactions. But there are a number of challenges
    to think about.
  prefs: []
  type: TYPE_NORMAL
- en: The challenges of mobile application development
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When it comes to the development of mobile applications, the first issue that
    comes to mind is **fragmentation**. In web applications, modern browsers have
    almost eliminated incompatibilities between devices, and indeed today you will
    get the same user experience whether you are using Firefox, Chrome, or Edge on
    a Macintosh, Windows, or Linux machine. And modern frameworks (such as React,
    which we saw earlier) make it almost effortless to create such a unified experience.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is unfortunately not true for mobile devices:'
  prefs: []
  type: TYPE_NORMAL
- en: First of all, you have the form factor to consider. Different models of smartphones
    have different screen sizes and ratios. They can be used in landscape or portrait
    mode. Tablet devices add even more variants to the mix.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The hardware resources may be limited. The rendering of complex animations or
    heavily interactive features may slow down some low-end devices.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connectivity can be unstable. You have to manage what happens to your application
    when the bandwidth is low or there is a network interruption.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Devices often offer additional hardware, such as sensors, cameras, and GPS.
    However, you have to manage what happens when you have permissions to access such
    devices and what happens when they are denied.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Last but not least, there are, at the time of writing, at least two ecosystems
    to consider, Google and Apple, which have different distribution channels, different
    supporting services (such as notifications and updates), and different programming
    languages and frameworks. This last point we are going to discuss in more detail
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Mobile application development options
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since the inception of mobile application development, a common topic has been
    how to manage different platforms (or, at least, Google and Apple) and whether
    there is a way to partially reuse the effort spent on development for other platforms
    (such as the web).
  prefs: []
  type: TYPE_NORMAL
- en: The first viable option for reducing fragmentation and leveraging web development
    efforts is to completely ditch mobile application development and instead go for
    mobile-optimized web applications. This is a smart option, as with modern web
    development frameworks and languages (such as HTML5 and CSS3), it's easy to target
    mobile devices.
  prefs: []
  type: TYPE_NORMAL
- en: These technologies, other than making it easy to create responsive designs that
    fit nicely in a mobile-optimized layout, create a standard for accessing the most
    common mobile features, such as position tracking (via GPS), cameras, and microphones.
  prefs: []
  type: TYPE_NORMAL
- en: The most important benefit of this approach is that we can manage a single code
    base. Even if we want to differentiate between the mobile and web versions of
    our user interface (it's our choice – we could even just have one single version),
    at least we can have a single version across all mobile devices, regardless of
    the underlying technology. The second benefit is that we can keep our publishing
    process outside app stores, so we are not subject to the timing and regulations
    that are typically enforced by such distribution channels.
  prefs: []
  type: TYPE_NORMAL
- en: However, there are of course some limitations, with the most significant one
    being performance. Mobile web applications generally perform worse than their
    native counterparts. That is particularly true for heavily interactive experiences,
    such as games or very visual user interfaces. Moreover, mobile web applications
    have more limited options (if any) to run in an offline or limited-connectivity
    scenario.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, mobile web applications are usually less *ergonomic* to access, meaning
    that the user needs to access the browser and load the application. Even if it's
    possible to use shortcuts, it's still a more uncomfortable experience than directly
    finding an app icon in an application list (which is also better from a branding
    perspective). Last but not least, mobile web applications do not benefit from
    the visibility that can come from app stores.
  prefs: []
  type: TYPE_NORMAL
- en: A possible alternative to mobile web applications is hybrid applications. In
    this approach, a mobile web application is enclosed into a native *shell*, which
    basically is just a slimmed-down, full-screen browser used to act as a bridge
    between a mobile web application and a device. In such a setup, our application
    can be published to app stores and can access more native features of the host
    device. Moreover, it is possible to implement unique code bases, or at least that's
    the case with the two main technologies of Apple and Google. The downside is that
    performance and access to native hardware devices will still be limited compared
    to a fully native application. A notable framework to develop hybrid apps is React
    Native, which we mentioned previously.
  prefs: []
  type: TYPE_NORMAL
- en: The last option is, obviously, to develop a fully native application. To do
    that, you will have to use the languages and tools provided for your specific
    target platform.
  prefs: []
  type: TYPE_NORMAL
- en: Such languages are commonly Swift or Objective-C for Apple devices, and Java
    or Kotlin for Android ones. The vendors also distribute development environments
    and tools for building and distributing the applications.
  prefs: []
  type: TYPE_NORMAL
- en: In this way, you will have full control over the device's capabilities and can
    exploit all the available resources, which can be crucial for some applications.
    The obvious downside is that you will have to manage two completely different
    development lines, which means having different skills on the team, dedicated
    build pipelines, and in general, a duplicated effort.
  prefs: []
  type: TYPE_NORMAL
- en: Regardless of your development choice, you will still have to face a challenge
    in testing, as checking the application's behavior for all the available platforms
    properly can be very expensive. In order to partially solve this challenge, it
    is possible to rely on simulators, which emulate the major mobile devices for
    testing purposes. Another viable alternative is to use specialized services. There
    are a number of companies offering a range of mobile devices for testing purposes,
    which can be rented (as cloud resources) and remotely controlled in order to execute
    test suites.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have looked at web and mobile applications, which are the
    two most common channels for enterprise services nowadays. But there are some
    other options that are being used more and more. We are going to learn about them
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring IVR, chatbots, and voice assistants
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Providing more channels for customer interaction is often a very smart investment.
    It means reaching more people, having a high customer satisfaction rate, and a
    reduced need for manual interaction (such as assistance provided by a human operator),
    which can be expensive and also less effective. These goals are important to achieve,
    and in this section, we'll look at some ways to do so.
  prefs: []
  type: TYPE_NORMAL
- en: Interactive voice response
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Interactive Voice Response** (**IVR**) is one kind of technology that helps
    us achieve the aforementioned goals. It provides a way for a human user to interact
    with services over a phone call. I think that pretty much every one of us has
    first-hand experience of interacting with an IVR system, as they are pretty common
    in helpdesk hotlines. The system offers a number of options to choose from. The
    user can then choose one of the options using a **Dual-Tone Multi-Frequency**
    (**DTMF**) tone (a tone generated by pressing a button on the phone''s number
    pad) or via voice recognition (which can be harder and more expensive to implement
    than the DTMF method, as it requires speech-to-text capabilities).'
  prefs: []
  type: TYPE_NORMAL
- en: Every option can lead to another set of options. At some point, the customer
    gets to the desired information, provided by text-to-speech or a recorded message.
    Another option is to have the call ultimately dispatched to a human operator.
    While still requiring a human, the presence of the IVR system will most likely
    filter the most common requests, reducing the number of human operators required,
    and can provide the operator with data collected from the automatic interactions,
    such as the user's identity or the problem to resolve.
  prefs: []
  type: TYPE_NORMAL
- en: Algorithmically, an IVR system basically involves *tree traversing*. The customer
    starts at the root node. At each interaction, the customer is provided with a
    set of options (the child nodes). The customer can then pick one of the nodes
    or step back a level (but no further than the root node, of course). At some point,
    the customer will reach a leaf (the desired information or a human operator).
  prefs: []
  type: TYPE_NORMAL
- en: IVR systems, as we have seen, involve a lot of different technologies, starting
    with integrating phone calls (both inbound and outbound) and spanning media handling
    (recorded voice playback), speech-to-text, and text-to-speech. In other words,
    they are rarely implemented from scratch. In almost every case, in order to implement
    an IVR system, it is common to rely on packaged solutions. Asterisk, which is
    a piece of open source PBX software, is used as a common choice for implementing
    these kinds of systems. Nowadays, however, SaaS solutions are commonly used, requiring
    just configuration tweaks in order to implement the desired behavior. And since
    the interaction is so standardized with packaged solutions, and in terms of branding
    you're limited to the provided recorded voices, a custom IVR implementation is
    not worth the effort.
  prefs: []
  type: TYPE_NORMAL
- en: Chatbots
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Chatbots** are basically the same concept transposed to text chats. They
    achieve the same goal (providing a customized user experience while reducing pressure
    on human operators), but they don''t require text-to-speech, speech-to-text, or
    recorded voice messages.'
  prefs: []
  type: TYPE_NORMAL
- en: The interaction can still be modeled as a tree by providing multiple options
    to the customer. However, it is common for most chatbot platforms to provide freeform
    input to customers and try to interpret what the customer is looking for, by parsing
    the messages and doing what is called **Natural Language Processing** (**NLP**).
    This process can be complex, involving looking for keywords to analyze the customer's
    request or even decoding the meaning of the customer's entire message.
  prefs: []
  type: TYPE_NORMAL
- en: Chatbots are less *invasive* than IVR, as they don't require integration with
    phone infrastructures. There are a number of frameworks available for implementing
    such solutions, and they are often identified as a perfect use case for the serverless
    deployment model (see [*Chapter 9*](B16354_09_Final_JM_ePUB.xhtml#_idTextAnchor230),
    *Designing Cloud-Native Architectures*). However, as with IVR technology, it is
    unusual to implement such solutions from scratch nowadays, and it's more common
    to rely on packaged applications or SaaS solutions.
  prefs: []
  type: TYPE_NORMAL
- en: Voice assistants
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Voice assistants** are one of the most modern takes on the same issue. Conceptually,
    voice assistants are kind of a mix between the user experience provided by an
    IVR system and the one provided by a chatbot. From a user''s perspective, voice
    assistants are consumed from a proprietary hardware and software stack, implemented
    by what is commonly called a *smart speaker*. The most widespread implementations
    at the time of writing are Google Home and Amazon Alexa.'
  prefs: []
  type: TYPE_NORMAL
- en: This topic is particularly hot, as currently voice assistant applications are
    still in their infancy, and implementing one is a really unique feature. However,
    to do so, you will require specific skills, and each vendor relies on proprietary
    SDKs to build their platforms, which are usually hosted and powered by the cloud
    provider behind them (AWS and Google Cloud Platform).
  prefs: []
  type: TYPE_NORMAL
- en: Omnichannel strategy in enterprise applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored a number of different options for user interaction,
    from web applications (which are the most common channel for user interaction),
    through mobile applications, to some alternative channels, such as IVR, chatbots,
    and voice assistants.
  prefs: []
  type: TYPE_NORMAL
- en: This opens up a big consideration as to which is the best strategy to go for.
    Indeed, it is pretty common for enterprise applications to provide many, if not
    all, of these channels at once. And as a user, we want to interact with applications
    and get the same information and the same user experience regardless of the channel
    used.
  prefs: []
  type: TYPE_NORMAL
- en: This poses some serious challenges, from user identity to state management.
  prefs: []
  type: TYPE_NORMAL
- en: There are a number of ways to face such challenges.
  prefs: []
  type: TYPE_NORMAL
- en: The most important thing is to provide a unified backend for all channels. To
    do so, it is common to use the same services (for example, for identifying a user
    or searching for saved information) and wrap things using a mediation layer (also
    known as a *backend for frontend*) in order to optimize the inputs and outputs
    for a specific device (such as a phone call, a mobile application, or a web user
    interface). In this way, we can make sure that we provide the same results regardless
    of what channel is used for interaction.
  prefs: []
  type: TYPE_NORMAL
- en: In doing so, we will provide what is called **multichannel** functionality –
    the same features are available on different channels and devices (of course,
    with minor modifications due to the limitations of each device). But there is
    a further step that can be taken for a more complete user experience, and this
    is called **omnichannel** functionality. With an omnichannel experience, the user
    can switch channels during a complex transaction and continue an operation started
    on a different kind of device with limited or no impact on the user experience
    and the final result.
  prefs: []
  type: TYPE_NORMAL
- en: The classical example is a mortgage application. A user can call an IVR system
    asking for information to start a mortgage application. This mortgage application
    can then be continued using a web application, where the customer can more comfortably
    provide personal information. After an asynchronous approval process, the customer
    can then be notified on a mobile app of the mortgage application outcome and complete
    the process in the mobile app itself.
  prefs: []
  type: TYPE_NORMAL
- en: In order to implement an omnichannel approach, our enterprise application must
    be capable of storing the state and details of multi-step transactions (such as
    the mortgage application in our example) in a so-called *state machine*, commonly
    implemented as a business workflow (as seen in [*Chapter 8*](B16354_08_Final_JM_ePUB.xhtml#_idTextAnchor200),
    *Designing Application Integration and Business Automation*). It will then be
    necessary to implement some services to interact with the workflow from the desired
    channel (as previously mentioned, using a mediator or backend-for-frontend pattern).
  prefs: []
  type: TYPE_NORMAL
- en: A common strategy is also to *codify* some checks (possibly by using a business
    rule) in order to identify which step can be implemented by which specific channel
    (and device), as due to the specificity of each channel, it may be impossible
    (or at least not advisable) to perform certain steps on certain devices. A typical
    example is IVR. It is usually difficult to properly identify a customer over a
    phone call. It is possible to check the phone number and to ask for a PIN, but
    this may be not enough for some operations that are better suited to a mobile
    device (where we can ask for biometric authentication) or a web application (where
    we can enforce **Two-Factor Authentication** (**2FA**)).
  prefs: []
  type: TYPE_NORMAL
- en: With this section, we have completed our overview of the most common interaction
    channels for our users.
  prefs: []
  type: TYPE_NORMAL
- en: Let's summarize what we have learned in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have explored the core server-side web technologies provided
    by the JEE platform (JSP and JSF). We explored the pros and cons of these technologies
    and the main ideas behind them, including interaction with other JEE technologies
    and standards.
  prefs: []
  type: TYPE_NORMAL
- en: We then moved on to client-side frameworks for building SPAs. We saw how simple
    and powerful the React framework is and how it can be used to implement componentized
    interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: We also studied the basics of mobile application development, which is now essential
    to provide a complete customer experience and can leverage some of the concepts
    of web application development.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, we had a look at other interaction channels, such as phone calls (using
    IVR systems), text chats (using chatbots), and voice assistants. Lastly, we looked
    at some considerations on how to harmonize all those technologies into a multichannel
    and omnichannel user experience.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to focus on the data layer. This will include
    coverage of relational databases as well as alternatives, such as key-value stores
    and NoSQL. This will represent another fundamental layer of application architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Eclipse Foundation – the JSP specification([https://projects.eclipse.org/projects/ee4j.jsp](https://projects.eclipse.org/projects/ee4j.jsp))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*The Problems with JSP*, *Jason Hunter* ([http://servlets.com/soapbox/problems-jsp.html](http://servlets.com/soapbox/problems-jsp.html))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Jakarta EE – the JSF specification ([https://jakarta.ee/specifications/faces/](https://jakarta.ee/specifications/faces/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Why You Should Avoid JSF*, *Jens Schauder* ([https://dzone.com/articles/why-you-should-avoid-jsf](https://dzone.com/articles/why-you-should-avoid-jsf))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Meta Platforms, Inc. – the official React website ([https://reactjs.org/](https://reactjs.org/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: W3Schools – *React Tutorial* ([https://www.w3schools.com/react/](https://www.w3schools.com/react/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
