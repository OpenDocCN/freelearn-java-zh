["```java\ndocker run -itd -e POSTGRES_USER=packt -e POSTGRES_PASSWORD=packt -p 5432:5432 --name postgresql postgres\n```", "```java\nsudo apt install postgresql-client\n```", "```java\n    psql -h localhost -U packt -f db-creation.sql\n    psql -h localhost -U packt -f insert-data.sql\n    ```", "```java\n    spring:\n        datasource:\n            url: jdbc:postgresql://localhost:5432/football\n            username: packt\n            password: packt\n    ```", "```java\n    @Service\n    public class TeamsService {\n        private JdbcTemplate jdbcTemplate;\n        public TeamsService(JdbcTemplate jdbcTemplate) {\n            this.jdbcTemplate = jdbcTemplate;\n        }\n    }\n    ```", "```java\n    public int getTeamCount() {\n        return jdbcTemplate.queryForObject(\"SELECT COUNT(*) FROM teams\", Integer.class);\n    }\n    ```", "```java\npublic List<Team> getTeams() {\n  return jdbcTemplate.query(\"SELECT * FROM teams\", (rs, rowNum) -> {\n    Team team = new Team();\n    team.setId(rs.getInt(\"id\"));\n    team.setName(rs.getString(\"name\"));\n    return team;\n });\n}\n```", "```java\npublic Team getTeam(int id) {\n    return jdbcTemplate.queryForObject(\n       \"SELECT * FROM teams WHERE id = ?\",\n       new BeanPropertyRowMapper<>(Team.class),\n       id);\n}\n```", "```java\n    @Service\n    public class PlayersService {\n        private JdbcClient jdbcClient;\n        public PlayersService(JdbcClient jdbcClient) {\n            this.jdbcClient = jdbcClient;\n        }\n    }\n    ```", "```java\n        public List<Player> getPlayers() {\n            return jdbcClient.sql(\"SELECT * FROM players\")\n                    .query(Player.class)\n                    .list();\n        }\n        ```", "```java\n        Public Player getPlayer(int id) {\n            return jdbcClient.sql(\"SELECT * FROM players WHERE id = :id\")\n                    .param(\"id\", id)\n                    .query(Player.class)\n                    .single();\n        }\n        ```", "```java\n        public Player createPlayer(Player player) {\n            GeneratedKeyHolder keyHolder = new GeneratedKeyHolder();\n           jdbcClient.sql(\"\"\"\n             INSERT INTO players (jersey_number, name, position, date_of_birth, team_id)\n             VALUES (:jersey_number, :name, :position, :date_of_birth, :team_id)\n                          \"\"\")\n                   .param(\"name\", player.getName())\n                   .param(\"jersey_number\", player.getJerseyNumber())\n                   .param(\"position\", player.getPosition())\n                   .param(\"date_of_birth\", player.getDateOfBirth())\n                   .param(\"team_id\", player.getTeamId())\n                   .update(keyHolder, \"id\");\n            player.setId(keyHolder.getKey().intValue());\n            return player;\n        }\n        ```", "```java\n        @Table(name = \"teams\")\n        @Entity\n        public class TeamEntity {\n            @Id\n            private Integer id;\n            private String name;\n            @OneToMany(cascade = CascadeType.ALL, mappedBy = \"team\")\n            private List<PlayerEntity> players;\n        }\n        ```", "```java\n        @Table(name = \"players\")\n        @Entity\n        public class PlayerEntity {\n            @Id\n            private Integer id;\n            private Integer jerseyNumber;\n            private String name;\n            private String position;\n            private LocalDate dateOfBirth;\n            @ManyToOne(fetch = FetchType.LAZY)\n            @JoinColumn(name = \"team_id\")\n            private TeamEntity team;\n        }\n        ```", "```java\n        public interface TeamRepository extends CrudRepository<TeamEntity, Integer>{\n        }\n        ```", "```java\n        public interface PlayerRepository extends JpaRepository<PlayerEntity, Integer>{\n            List<PlayerEntity> findByDateOfBirth(LocalDate dateOfBirth);\n            List<PlayerEntity> findByNameContaining(String name);\n        }\n        ```", "```java\n    @Service\n    public class FootballService {\n        private PlayerRepository playerRepository;\n        private TeamRepository teamRepository;\n        public FootballService(PlayerRepository playerRepository, TeamRepository teamRepository) {\n            this.playerRepository = playerRepository;\n            this.teamRepository = teamRepository;\n        }\n    }\n    ```", "```java\n        public record Team(Integer id, String name, List<Player> players) {\n        }\n        ```", "```java\n        public record Player(String name, Integer jerseyNumber, String position, LocalDate dateOfBirth) {\n        }\n        ```", "```java\n        public List<Player> searchPlayers(String name) {\n                return playerRepository.findByNameContaining(name)\n                        .stream()\n                        .map(player -> new Player(player.getName(), player.getJerseyNumber(), player.getPosition(), player.getDateOfBirth()))\n                        .toList();\n            }\n        ```", "```java\n        public List<Player> searchPlayersByBirthDate(LocalDate date) {\n                return playerRepository.findByDateOfBirth(date)\n                        .stream()\n                        .map(player -> new Player(player.getName(), player.getJerseyNumber(), player.getPosition(), player.getDateOfBirth()))\n                        .toList();\n            }\n        ```", "```java\n    @Transactional(readOnly=true)\n    public Team getTeam(Integer id) {\n        TeamEntity team = teamRepository.findById(id).orElse(null);\n       if (team == null) {\n           return null;\n       } else {\n           return new Team(team.getId(),\n                   team.getName(),\n                   team.getPlayers()\n                   .stream()\n                   .map(player -> new Player(player.getName(), player.getJerseyNumber(), player.getPosition(),\n                                        player.getDateOfBirth()))\n                   .toList());\n       }\n    }\n    ```", "```java\n    public Team createTeam(String name) {\n       Random random = new Random();\n       TeamEntity team = new TeamEntity();\n       Integer randomId = random.nextInt();\n       if (randomId < 0) {\n             randomId = random.nextInt();\n       }\n       team.setId(randomId);\n       team.setName(name);\n       team = teamRepository.save(team);\n       return new Team(team.getId(), team.getName(), List.of());\n    }\n    ```", "```java\n    public Player updatePlayerPosition(Integer id, String position) {\n        PlayerEntity player = playerRepository.findById(id).orElse(null);\n       if (player == null) {\n           return null;\n       } else {\n           player.setPosition(position);\n           player = playerRepository.save(player);\n           return new Player(player.getName(), player.getJerseyNumber(), player.getPosition(),\n                        player.getDateOfBirth());\n       }\n    }\n    ```", "```java\n    spring:\n        jpa:\n            database-platform: org.hibernate.dialect.PostgreSQLDialect\n            open-in-view: false\n        datasource:\n            url: jdbc:postgresql://localhost:5432/football\n            username: packtd\n            password: packtd\n    ```", "```java\n        psql -h localhost -U packtd\n        ```", "```java\n        CREATE DATABASE football2;\n        ```", "```java\n        @Id\n        @GeneratedValue(strategy = GenerationType.IDENTITY)\n        private Integer id;\n        ```", "```java\n    spring:\n        jpa:\n            database-platform: org.hibernate.dialect.PostgreSQLDialect\n            open-in-view: false\n            generate-ddl: true\n        sql:\n            init:\n                mode: always\n        datasource:\n            url: jdbc:postgresql://localhost:5432/football2\n            username: packtd\n            password: packtd\n    ```", "```java\n    public Team createTeam(String name) {\n        TeamEntity team = new TeamEntity();\n        team.setName(name);\n        team = teamRepository.save(team);\n        return new Team(team.getId(), team.getName(), List.of());\n    }\n    ```", "```java\nCREATE TABLE IF NOT EXISTS public.teams\n(\n    id integer NOT NULL DEFAULT nextval('teams_id_seq'::regclass),\n    name character varying(255) COLLATE pg_catalog.\"default\",\n    CONSTRAINT teams_pkey PRIMARY KEY (id)\n)\nCREATE SEQUENCE IF NOT EXISTS public.teams_id_seq\n    INCREMENT 1\n    START 1\n    MINVALUE 1\n    MAXVALUE 2147483647\n    CACHE 1\n    OWNED BY teams.id;\n```", "```java\n    <dependency>\n        <groupId>org.testcontainers</groupId>\n        <artifactId>junit-jupiter</artifactId>\n        <scope>test</scope>\n    </dependency>\n    <dependency>\n        <groupId>org.testcontainers</groupId>\n        <artifactId>postgresql</artifactId>\n        <scope>test</scope>\n    </dependency>\n    ```", "```java\n    @SpringBootTest\n    @Testcontainers\n    @ContextConfiguration(initializers = FootballServiceTest.Initializer.class)\n    public class FootballServiceTest\n    ```", "```java\n    static PostgreSQLContainer<?> postgreSQLContainer = new PostgreSQLContainer<>(\"postgres:latest\")\n            .withDatabaseName(\"football\")\n            .withUsername(\"football\")\n            .withPassword(\"football\");\n    ```", "```java\n    static class Initializer\n                implements ApplicationContextInitializer<ConfigurableApplicationContext> {\n        public void initialize(ConfigurableApplicationContext configurableApplicationContext) {\n            TestPropertyValues.of(\n                        \"spring.datasource.url=\" + postgreSQLContainer.getJdbcUrl(),\n                        \"spring.datasource.username=\" + postgreSQLContainer.getUsername(),\n                        \"spring.datasource.password=\" + postgreSQLContainer.getPassword())\n        .applyTo(configurableApplicationContext.getEnvironment());\n         }\n    }\n    ```", "```java\n    @BeforeAll\n    public static void startContainer() {\n        postgreSQLContainer.start();\n    }\n    ```", "```java\n    @Autowired\n    FootballService footballService;\n    @Test\n    public void createTeamTest() {\n        Team team = footballService.createTeam(\"Jamaica\");\n        assertThat(team, notNullValue());\n        Team team2 = footballService.getTeam(team.id());\n        assertThat(team2, notNullValue());\n        assertThat(team2, is(team));\n    }\n    ```", "```java\n        psql -h localhost -U packtd\n        ```", "```java\n        CREATE DATABASE football3;\n        ```", "```java\n    <dependency>\n        <groupId>org.flywaydb</groupId>\n        <artifactId>flyway-core</artifactId>\n    </dependency>\n    ```", "```java\n    CREATE TABLE teams (\n        id SERIAL PRIMARY KEY,\n        name VARCHAR(255)\n    );\n    CREATE TABLE players (\n        id SERIAL PRIMARY KEY,\n        jersey_number INT,\n        name VARCHAR(255),\n        position VARCHAR(255),\n        date_of_birth DATE,\n        team_id INT REFERENCES teams(id)\n    );\n    ```", "```java\n    INSERT INTO teams(id, name) VALUES (1884881, 'Argentina');\n    INSERT INTO players(id, jersey_number, name, \"position\", date_of_birth, team_id)\n    VALUES\n    (357669, 2, 'Adriana SACHS', 'Defender', '1993-12-25', 1884881)\n    ```", "```java\n        @Entity\n        @Table(name = \"matches\")\n        public class MatchEntity {\n            @Id\n            @GeneratedValue(strategy = GenerationType.IDENTITY)\n            private Integer id;\n            private LocalDate matchDate;\n            @ManyToOne\n            @JoinColumn(name = \"team1_id\", nullable = false)\n            private TeamEntity team1;\n            @ManyToOne\n            @JoinColumn(name = \"team2_id\", nullable = false)\n            private TeamEntity team2;\n            @Column(name = \"team1_goals\", columnDefinition = \"integer default 0\")\n            private Integer team1Goals;\n            @Column(name = \"team2_goals\", columnDefinition = \"integer default 0\")\n            private Integer team2Goals;\n        }\n        ```", "```java\n        private Integer height;\n        private Integer weight;\n        ```", "```java\n        CREATE TABLE matches(\n            id SERIAL PRIMARY KEY,\n            match_date DATE,\n            team1_id INT NOT NULL REFERENCES teams(id),\n            team2_id INT NOT NULL REFERENCES teams(id),\n            team1_goals INT default 0,\n            team2_goals INT default 0\n        );\n        ```", "```java\n        ALTER TABLE players ADD COLUMN height INT;\n        ALTER TABLE players ADD COLUMN weight INT;\n        ```", "```java\n        UPDATE players SET height = 175, weight = 70;\n        ```", "```java\n        @Table(name = \"albums\")\n        @Entity\n        public class AlbumEntity {\n            @Id\n            @GeneratedValue(strategy = GenerationType.IDENTITY)\n            private Integer id;\n            private String title;\n            private LocalDate expireDate;\n            @OneToMany\n            private List<CardEntity> cards;\n        }\n        ```", "```java\n        @Table(name = \"cards\")\n        @Entity\n        public class CardEntity {\n            @Id\n            @GeneratedValue(strategy = GenerationType.IDENTITY)\n            private Integer id;\n            @ManyToOne\n            @JoinColumn(name = \"album_id\")\n            private AlbumEntity album;\n            @ManyToOne\n            @JoinColumn(name = \"player_id\")\n            private PlayerEntity player;\n        }\n        ```", "```java\n        public interface AlbumRepository extends JpaRepository<AlbumEntity, Integer> {\n        }\n        ```", "```java\n    CREATE TABLE albums (\n        id SERIAL PRIMARY KEY,\n        title VARCHAR(255),\n        expire_date DATE\n    );\n    CREATE TABLE cards (\n        id SERIAL PRIMARY KEY,\n        album_id INTEGER REFERENCES albums(id),\n        player_id INTEGER REFERENCES players(id)\n    );\n    ```", "```java\n    @Query(\"SELECT p FROM PlayerEntity p JOIN p.cards c WHERE c.album.id = :id AND p.team.id = :teamId\")\n    public List<PlayerEntity> findByIdAndTeam(Integer id, Integer teamId);\n    ```", "```java\n    @Query(\"SELECT p FROM PlayerEntity p WHERE p NOT IN (SELECT c.player FROM CardEntity c WHERE c.album.id=:id)\")\n    public List<PlayerEntity> findByIdMissingPlayers(Integer id);\n    ```", "```java\n    @Query(\"SELECT p1 FROM MatchEntity m JOIN m.team1 t1 JOIN t1.players p1 WHERE m.id = ?1 UNION SELECT p2 FROM MatchEntity m JOIN m.team2 t2 JOIN t2.players p2 WHERE m.id = ?1\")\n    public List<PlayerEntity> findPlayersByMatchId(Integer matchId);\n    ```", "```java\n    @Query(\"SELECT t FROM TeamEntity t JOIN FETCH t.players WHERE t.id = ?1\")\n    public Optional<TeamEntity> findByIdWithPlayers(Integer id);\n    ```", "```java\n    public Team getTeam(Integer id) {\n        TeamEntity team = teamRepository.findByIdWithPlayers(id).orElse(null);\n        if (team == null) {\n            return null;\n        } else {\n        return new Team(team.getId(),\n                        team.getName(),\n                        team.getPlayers()\n                                .stream()\n                                .map(player -> new Player(player.getName(), player.getJerseyNumber(), player.getPosition(),\n                                        player.getDateOfBirth()))\n                                .toList());\n        }\n     }\n    ```", "```java\n    @Query(\"SELECT p FROM PlayerEntity p WHERE p.id IN (?1)\")\n    List<PlayerEntity> findListOfPlayers(List<Integer> players);\n    ```", "```java\n    List<PlayerEntity> findByIdInList(List<Integer> players);\n    ```", "```java\n    List<PlayerEntity> findByNameLike(String name);\n    ```", "```java\n    List<PlayerEntity> findByNameStartingWith(String name);\n    ```", "```java\n    List<PlayerEntity> findByTeamId(Integer teamId, Sort sort);\n    playerRepository.findByTeamId(id, Sort.by(\"name\").ascending())\n    ```", "```java\n    Page<PlayerEntity> page = playerRepository.findAll(Pageable.ofSize(size).withPage(pageNumber));\n    ```", "```java\n    @Query(\"SELECT p FROM PlayerEntity p JOIN p.cards c WHERE c.album.id = :id\")\n    public List<PlayerEntity> findByIdPlayers(Integer id, Pageable page);\n    ```", "```java\n    @Query(\"SELECT p.team.name as name, count(p.id) as playersCount FROM PlayerEntity p WHERE p.position = ?1 GROUP BY p.team ORDER BY playersCount DESC\")\n    public List<TeamPlayers> getNumberOfPlayersByPosition(String position);\n    ```", "```java\n    public interface TeamPlayers {\n        String getName();\n        Integer getPlayersCount();\n    }\n    ```", "```java\n    CREATE TABLE match_events (\n        id BIGSERIAL PRIMARY KEY,\n        match_id INTEGER NOT NULL,\n        event_time TIMESTAMP NOT NULL,\n        details JSONB,\n        FOREIGN KEY (match_id) REFERENCES matches (id)\n    );\n    CREATE PROCEDURE FIND_PLAYERS_WITH_MORE_THAN_N_MATCHES(IN num_matches INT, OUT count_out INT)\n    LANGUAGE plpgsql\n    AS $$\n    BEGIN\n        WITH PLAYERS_WITH_MATCHES AS\n            (SELECT p.id, count(m.id) AS match_count FROM players p, matches m WHERE p.team_id = m.team1_id OR p.team_id = m.team2_id\n            GROUP BY p.id HAVING count(m.id) > num_matches)\n        SELECT COUNT(1) INTO count_out FROM PLAYERS_WITH_MATCHES;\n    END;\n    $$;\n    ```", "```java\n    {\n       \"type\": 24,\n       \"description\": \"Throw In\",\n       \"players\": [\n         467653,\n         338971\n       ],\n       \"mediaFiles\": [\n         \"/media/93050144.mp4\",\n         \"/media/6013333.mp4\",\n         \"/media/56559214.mp4\"\n        ]\n    }\n    ```", "```java\n    @Table(name = \"match_events\")\n    @Entity\n    public class MatchEventEntity {\n        @Id\n        @GeneratedValue(strategy = GenerationType.IDENTITY)\n        private Long id;\n        @Column(name = \"event_time\")\n        private LocalDateTime time;\n        @JdbcTypeCode(SqlTypes.JSON)\n        private MatchEventDetails details;\n        @ManyToOne(fetch = FetchType.LAZY)\n        @JoinColumn(name = \"match_id\", nullable = false)\n        private MatchEntity match;\n    }\n    ```", "```java\n    public class MatchEventDetails {\n        private Integer type;\n        private String description;\n        private List<Integer> players;\n        private List<String> mediaFiles;\n    }\n    ```", "```java\n    public interface MatchEventRepository extends JpaRepository<MatchEventEntity, Long> {\n    }\n    ```", "```java\n    @Query(nativeQuery = true, value = \"SELECT me.* FROM match_events me  WHERE me.match_id = ?1 AND CAST(me.details -> 'type' as INT) = ?2\")\n    public List<MatchEventEntity> findByIdIncludeEventsOfType(Integer matchId, Integer eventType);\n    ```", "```java\n    @Query(nativeQuery = true,\n      value = \"SELECT me.id, me.match_id, me.event_time, \" + me.details FROM match_events me CROSS JOIN LATERAL \" + jsonb_array_elements(me.details->'players') AS player_id \" +\n    \"WHERE me.match_id = ?1 AND CAST(player_id as INT) = ?2\")\n    List<MatchEventEntity> findByMatchIdAndPlayer(Integer matchId, Integer playerId);\n    ```", "```java\n    @Procedure(\"FIND_PLAYERS_WITH_MORE_THAN_N_MATCHES\")\n    int getTotalPlayersWithMoreThanNMatches(int num_matches);\n    ```", "```java\nSELECT me.id, me.match_id, me.event_time, me.details FROM match_events me CROSS JOIN LATERAL  jsonb_array_elements(me.details->'players') AS player_id\nWHERE me.match_id = ?1 AND CAST(player_id as INT) = ?2)\n```", "```java\nSELECT me.id @Procedure annotation, Spring Data JPA and Hibernate can invoke the stored procedure. As it happens with Native Queries, you are responsible to make sure that the incoming parameters and results match with the method invocation. If you change any of them, it can cause errors in runtime.\n\t\t\tThere’s more...\n\t\t\tAn important difference seen in Native queries compared to JPQL queries is that the queries cannot be validated against your entities, hence you need to be careful as it can fail at runtime. I recommend checking all queries first in tools such as `PgAdmin` for PostgreSQL, or a similar tool for the database you choose. I also recommend preparing a good set of tests using the native queries. In the book’s GitHub repository I created some tests to validate the queries used in this recipe.\n\t\t\tSee also\n\t\t\tIf your solution is more dependent on JSON documents, with schema flexibility, rather than well-defined schemas with complex relationships and transactional integrity needs that PostgreSQL and other relational databases can offer, then you may want to consider other database technologies, such as Document databases. There are many solutions in the market, like MongoDB, Azure CosmosDB, AWS DocumentDb. We will cover MongoDB in the following chapter.\n\t\t\tUpdating Operations\n\t\t\tIn previous recipes, we just performed queries against the database. In this recipe, we will use Spring Data JPA to modify the data of our database.\n\t\t\tWe will continue with our football sample. In this recipe, we will create operations to manage the trading card albums. A user may have albums, an album has cards, and the card references a player. To complete an album, the user needs to have cards with all players. So, they need to know what cards are missing. Users can buy albums and cards, but they cannot choose the cards. They can have repeated players. Users can trade cards. So, they can exchange all unused cards with another user.\n\t\t\tGetting ready\n\t\t\tFor this recipe, we don’t need additional tools compared to previous recipes. As a starting point of this exercise, we will use the completed version of the previous recipe. If you didn’t complete it, you can find it in the book’s repository at [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/).\n\t\t\tHow to do it...\n\t\t\tTo complete this recipe, we will add a new Entity to manage the users. We will modify Albums and Cards as they have an owner now. Later we will create some operations that involve data modification to manage the cards and trading operations.\n\n\t\t\t\t1.  We will first create a new database migration using Flyway. To do that, create a file named `V5__AddUsers.sql` `in src/main/resources/db/migration`.\n\n    Then, we will create a table for users, and we’ll update the cards and albums to reference the user.\n\n    ```", "```java\n\n    Note the constraint in the table cards to avoid repeating players in the same album.\n\n    \t\t\t\t2.  Add a new entity named `UserEntity` to map with the new table:\n\n    ```", "```java\n\n    \t\t\t\t3.  Modify `CardEntity` and `AlbumEntity` to reference an owner user.\n\n    ```", "```java\n\n    \t\t\t\t4.  `CardEntity` can be modified to reflect the unique constraint that a player can be only once in an album:\n\n    ```", "```java\n\n    \t\t\t\t5.  Let’s start managing the data. We will start with just using the methods already provided by `JpaRepository`.\n\n    Let’s create a `UserRepository`:\n\n    ```", "```java\n\n    `JpaRepository` provides a method named `save`. This method creates or updates the entity provided. We can use it in this way:\n\n    ```", "```java\n\n    In the same way, we can create an album that references a user:\n\n    ```", "```java\n\n    We can also save multiple entities at the same time by calling the method `saveAll`. As an example, let’s define a method to buy cards:\n\n    ```", "```java\n\n    Our users will buy batches of cards. We need to generate the cards; we will generate the cards selecting a random player for each card, then we’ll save them in a single `saveAll` operation.\n\n    \t\t\t\t6.  Once we have the cards, we want to use them in our albums. Using them constitutes assigning them to an album. If we want to use just the method provided by JpaRepository, we should perform the following steps:\n    1.  Get all the available cards, that is the ones that have not been assigned to an album.\n    2.  Get all missing players. That is all players that are not in the cards assigned to an album.\n    3.  Take all available cards that are in the missing players. These are the cards to be assigned to albums.\n    4.  Verify that you only use a player in an album once.\n    5.  Save the cards.\n\n    All these steps involve requests to the database.\n\n    Or we can obtain the same result with just one request to the database by using an `UPDATE` `SQL` command:\n\n    ```", "```java\n\n    We can use this command in our `CardRepository`:\n\n    ```", "```java\n\n    Remember to include `@Modifying` annotation. As this is a PostgreSQL command, it requires `nativeQuery=true` in the `@``Query` annotation.\n\n    \t\t\t\t7.  We can transfer a card to another user. If the card was used in an album, it should be unlinked. This can be done in different ways, we will implement the same using a JPQL Query:\n\n    ```", "```java\n\n    In this case, we need to ensure that this method is executed in the context of a transaction. We can do it decorating the calling method with a `@``Transactional` annotation:\n\n    ```", "```java\n\n    \t\t\t\t8.  Next, we’ll learn how to exchange cards from user to another. Again, we can do it in our business logic using the methods provided by `JpaRepository` by performing the following actions:\n    1.  Get the available cards from one user, these are the ones not assigned to an album usually because they are repeated players.\n    2.  Get the missing players on the albums of the other user.\n    3.  Change the owner of the cards of the first user that are in the list of the missing players of the other user.\n\n    Or we can do it in a single `SQL` `UPDATE` statement:\n\n    ```", "```java\n\n\t\t\tI created a service class and a dedicated RESTful controller to perform all the operations above. The code, including a script to call the RESTful controller, is in the GitHub repository.\n\t\t\tHow it works...\n\t\t\tIn JPA, there is the concept of *Persistence* *Context* or just *Persistence Context*. The Context is mostly managed by *EntityManager*, which is responsible for managing the lifecycle of the JPA entities. It covers the following aspects:\n\n\t\t\t\t*   **Entity Management**: The persistence context is responsible for managing the entities. When you retrieve data from the database using Spring Data JPA, the resulting entities are managed by the persistence context. This means that changes to these entities are tracked, and you can use the persistence context to synchronize these changes with the database.\n\t\t\t\t*   **Identity Management**: The persistence context ensures that there is a single in-memory representation of an entity for a given database row. If you load the same entity multiple times, you will get the same Java object instance, ensuring consistency and avoiding duplicate data.\n\t\t\t\t*   `flush` method of `JpaRepository`, or implicitly, for instance at the end of a transaction.\n\t\t\t\t*   **Caching**: The persistence context provides a first-level cache. It stores managed entities in memory, which can improve application performance by reducing the number of database queries required for entity retrieval during a transaction.\n\t\t\t\t*   **Lazy Loading**: The persistence context can enable lazy loading of related entities. When you access a property representing a related entity, Spring Data JPA can automatically fetch that related entity from the database, if it’s not already in the persistence context.\n\t\t\t\t*   **Transaction Synchronization**: The persistence context is typically bound to the scope of a transaction. This ensures that changes to entities are persisted to the database when the transaction is committed. If the transaction is rolled back, the changes are discarded.\n\n\t\t\tIn Spring Data JPA, the `EntityManager` is the central component for managing the persistence context. It provides methods for persisting, retrieving, and managing entities.\n\t\t\tIn addition to the methods already provided by the `JpaRepository` like `save` and `saveAll`, you can use `@Modifying` annotation. In Spring Data JPA, the `@Modifying` annotation is used to indicate that a method in a Spring Data JPA repository interface is a modifying query method. Modifying query methods are used to perform data modification operations like INSERT, UPDATE, or DELETE in the database.\n\t\t\tWhen you mark a method in a Spring Data JPA repository with the `@Modifying` annotation, it changes the behavior of that method in the following ways:\n\n\t\t\t\t*   `@Modifying` annotation indicates that the method is intended to execute a non-select query, such as an `UPDATE` or `DELETE` statement.\n\t\t\t\t*   `@Modifying` annotation, the return type is not inferred automatically. Instead, you should explicitly specify the return type. Typically, the return type is `int` or `void`. For example, in the example above, `transferCard` returns an Integer. That number represents the number of rows affected. With Native Queries it is possible to return data, as shown in method `tradeCardsBetweenUsers`. PostgreSQL can return the rows impacted using the keyword `RETURNING` in the `UPDATE` command. This behavior can change depending on the Database engine.\n\t\t\t\t*   `@Modifying`, it will trigger a flush of the persistence context to synchronize the changes with the database.\n\t\t\t\t*   **Transaction Requirement**: Modifying query methods should be executed within a transaction context. If the method is called without an active transaction, it will typically result in an exception when using JPQL queries. For Native Queries, this behavior does not apply. We will cover in more detail transaction management in another recipe of this chapter.\n\n\t\t\tIn this recipe, we used JPQL queries and native queries. As mentioned in previous recipes, JPQL has the primary advantage of using your Entities, being able to make a type-safety check, and abstracting the complexities of accessing the underlying database.\n\t\t\tNative Queries can be necessary when you need to fine tune your queries and optimize the access to the database. Taking the example of `assignCardsToUserAlbums`, the same operation using just JPQL and business logic in your Java application will require several calls to the database, transferring data from the database and to the database. This communication overhead is not a negligible cost for large-scale applications. In the implementation of `assignCardsToUserAlbums`, it is just one single call to PostgreSQL that performs all the updates and returns just the cards updated to be returned to the caller component.\n\t\t\tSee also\n\t\t\tCheck the *Using Dynamic Queries* and *Using Transactions* recipes to deeper dive into `EntityManager` and transactions management in Spring Data JPA.\n\t\t\tUsing Dynamic Queries\n\t\t\tIn Spring Data JPA, a dynamic query refers to a type of query that is constructed at runtime based on various conditions or parameters. Dynamic queries are particularly useful when you need to build and execute queries that can vary based on user input or changing criteria. Instead of writing a static query with fixed criteria, you create a query that adapts to different scenarios.\n\t\t\tDynamic queries can be constructed using the Criteria API, or by creating the query statement dynamically using JPQL or Native SQL. The Criteria API provides a programmatic and type-safe way to define queries to the database.\n\t\t\tIn previous recipes, we used the naming convention of the `JpaRepositories` when creating the repository methods. Spring Data JPA generates the queries dynamically using the same mechanism we will explain in this recipe.\n\t\t\tIn this recipe, we will implement the following functionalities:\n\n\t\t\t\t*   Search players using different criteria, for instance by name, height, or weight.\n\t\t\t\t*   Search match events in a time range.\n\t\t\t\t*   Delete match events in a time range.\n\t\t\t\t*   Search the missing players that a user of the card trading game does not have yet.\n\n\t\t\tGetting ready\n\t\t\tFor this recipe, we don’t need additional tools compared to previous recipes. As the starting point of this exercise, we will use the completed version of *Updating Operations* recipe. If you didn’t complete it, you can find it in the book repository at https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/.\n\t\t\tHow to do it...\n\t\t\tFor this recipe, we will create a new service component to perform all dynamic queries.\n\n\t\t\t\t1.  To do that, first create a new `Service` named `DynamicQueriesService`. The service requires an `EntityManager`. For that reason, we need to declare a parameter in the constructor to ensure that the IoC container injects it.\n\n    ```", "```java\n\n    \t\t\t\t2.  In this service, we can create a method to search players using different criteria. Each criteria are optional, so we need to construct the query dynamically depending on the parameters provided. We will use the `CriteriaBuilder` class for that purpose.\n\n    ```", "```java\n\n    In this example, we used the criteria query as a parameter for the `EntityManager` method `createQuery`, then we used the query to retrieve the results.\n\n    \t\t\t\t3.  Let’s implement another example, this time using JPQL statements. We will search events of a match in a time range:\n\n    ```", "```java\n\n    Now the query is created using a String that is passed again to the `createQuery` method of the `EntityManager`.\n\n    As you can see, the command contains named parameters that must be passed to the query.\n\n    \t\t\t\t4.  We can use Native SQL commands as well. Let’s search for the players that a user doesn’t have yet for his or her album.\n\n    ```", "```java\n\n    To execute the native query, we now pass the String containing the native SQL command to the `createNativeQuery` method.\n\n    \t\t\t\t5.  Now we will create a method to perform a delete operation. We will delete the events of a match in a certain time range. We will use JPQL to perform this functionality.\n\n    ```", "```java\n\n    To perform an update, we need to call the `executeUpdate` method. Note that this type of modifying operation requires an active transaction.\n\n\t\t\tHow it works...\n\t\t\tAs explained in the previous recipe, in Spring Data JPA, the `EntityManager` is the central component for managing the persistence context. It provides methods for persisting, retrieving, and managing entities.\n\t\t\tWhen using JPQL, the `EntityManager` compiles the query, not only to validate the syntax but also to check the consistency with the Entities of our project, then translates the query to native SQL and binds the parameters. After executing the query, `EntityManager` maps the results into the managed entities. The resulting entities are tracked by the `EntityManager` for any change or further persistence operation.\n\t\t\tIf you have a query that will be executed multiple times, you can use a Named Query, as it is precompiled and cached for better performance. For that, you can call the `createNamedQuery` method.\n\t\t\tFor Native queries, it is a bit simpler as it doesn’t compile nor validates the consistency, and it directly executes the query, mapping the results to the Entity specified. As discussed in previous recipes, it has advantages and trade-offs that you will need to evaluate depending on the needs of your application.\n\t\t\tIn the examples, we used Criteria Query and just a String containing the command. In general, I prefer Criteria Query because using it helps you avoid typos while building your query. In addition, Criteria Query is protected against SQL Injection attacks. If you build your query just concatenating Strings, be sure that you don’t use parameters provided by the user directly as it will make your query vulnerable to SQL Injection attacks. When using parameters provided by the user, be sure that they are always passed as query parameters and never directly concatenated to the command string. See for example the method `searchMatchEventsRange`. In it, the parameters influence the SQL command generated, but they are always passed as query parameters.\n\t\t\tThere’s more...\n\t\t\tI created a controller to use the methods created in this recipe. You can find it in the book’s GitHub repository. In that project I enabled swagger UI, so you can use it to test the methods.\n\t\t\tSee also\n\t\t\tThere is a lot of literature about SQL Injection. If you are not familiar with it, you can check the Wikipedia page: [https://en.wikipedia.org/wiki/SQL_injection](https://en.wikipedia.org/wiki/SQL_injection).\n\t\t\tUsing Transactions\n\t\t\tTransactions play a crucial role when working with databases to ensure data consistency and integrity. In Spring Data JPA, you can manage transactions using the Spring Framework’s transaction management capabilities.\n\t\t\tIn previous recipes, we implicitly used transactions, as some features require its usage; for instance, using `@Modifiying` annotation creates a transaction behind the scenes. In this recipe, we will learn more about transactions and how to use them in Spring Boot applications.\n\t\t\tAs an example of using transactions in Spring Boot applications, we will use them to manage the trading card operations between users. In a high-concurrency scenario, we want to ensure that users can exchange their cards with consistency and integrity.\n\t\t\tGetting ready\n\t\t\tFor this recipe, we don’t need additional tools compared to previous recipes. As a starting point of this exercise, you can use a project that I prepared with the previous recipes in this chapter. You can find it in the book’s repository at https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/.\n\t\t\tHow to do it...\n\t\t\tTo implement the card trading scenario, we will enhance the `AlbumsService` to manage the card exchange between users consistently.\n\n\t\t\t\t1.  Open the service `AlbumsService` and find the method `tradeAllCards`. The functionality we want to achieve with this method is the following:\n    *   Users can have repeated cards.\n    *   They can exchange cards between them.\n    *   They want to exchange the cards necessary to complete the albums.\n    *   A trading operation involves the same number of cards from each user. If Sara gives three cards to Paul, Paul should give three cards to Sara in return.\n\n    To implement this functionality, first we need to know how many cards two users can exchange:\n\n    ```", "```java\n\n    If both users have cards that can be exchanged, then they exchange a number of cards from one user to another, and then the same in the other direction. To avoid the same cards being exchanged in both directions, once a user receives the cards, they are used. Therefore these cards are not available for exchange.\n\n    ```", "```java\n\n    \t\t\t\t2.  We want to perform all actions described in step 1consistently, and in case of an error, we want users to have the same cards they had before starting the trading operation. For this, we only need to annotate the method with `@Transactional`. The full method should look like this:\n\n    ```", "```java\n\n    There is some boilerplate code used to return data to be consumed by the RESTful API. It has been omitted for brevity, but you can find the full method in the GitHub repository.\n\n    If there is an exception during the execution of this method, the transaction will be automatically rolled-back, keeping the state as it was before starting the transaction. Let’s modify this method to add some validations.\n\n    We will check that the number of cards traded are the same. For that, change the invocation to `tradeCardsBetweenUsers` as follows:\n\n    ```", "```java\n\n    \t\t\t\t3.  We can achieve a similar functionality by controlling the isolation of the transaction. You can do it by changing `@Transactional` annotation properties. If you set the transaction isolation level to `Serializable`, you ensure that the data used in your transaction is not read by any other transaction.\n\n    ```", "```java\n\n    This solution may seem more convenient as it simplifies the code and ensures consistency. However, in most scenarios, it can be an overkill. This kind of isolation is very costly for the database engine and can cause database locks and contention, degrading the performance of our application. It is a powerful mechanism but should be used wisely. We will explain in more detail in *How it* *works* section.\n\n\t\t\tHow it works...\n\t\t\tWhen we use the `@Transactional` annotation in a method, Spring Data JPA creates a transaction when the method is invoked. If the method completes without errors, it commits the transaction and changes are confirmed. If an exception is thrown, Spring Data JPA rollbacks the transaction, setting the data to its previous state.\n\t\t\tThe `@Transactional` annotation can be applied at the class level. Then, Spring Data JPA applies the same behavior to all methods in that class.\n\t\t\tAn important concept to understand is transaction isolation. Why do we need to care about it? The key concept is concurrency. In concurrent systems, such as web applications, there are multiple operations simultaneously. Taking our card trading example, let’s figure something out. During special events, there can be thousands or millions of users exchanging their cards. What happens if, for example, while trading between Sara and Paul, it turns out that Paul has already exchanged his cards with Joanna? If we don’t control this scenario, it can happen that Sara gives her cards to Paul and Paul gives nothing to Sara. As we saw in the exercise, we can use some business logic to control this situation, or we can use higher isolation levels in the transaction. I recommend using higher isolation levels only when strictly required, as it hurts performance in high concurrent transactions.\n\t\t\tIn the example above we used `Serializable` isolation, which is the highest level of isolation. There are more in Spring Data JPA:\n\n\t\t\t\t*   `Isolation.DEFAULT`: The default isolation level is determined by the underlying database.\n\t\t\t\t*   `Isolation.READ_UNCOMMITTED`: Allows dirty reads, non-repeatable reads, and phantom reads.\n\t\t\t\t*   `Isolation.READ_COMMITTED`: Prevents dirty reads but allows non-repeatable reads and phantom reads.\n\t\t\t\t*   `Isolation.REPEATABLE_READ`: Prevents dirty reads and non-repeatable reads but allows phantom reads.\n\t\t\t\t*   `Isolation.SERIALIZABLE`: Provides the highest level of isolation, preventing dirty reads, non-repeatable reads, and phantom reads.\n\n\t\t\tKeep in mind that the implementation of the isolation level relies on the underlying database engine, and there are some levels that may not be supported.\n\t\t\tTo define the Isolation levels, I used some terms that is worth explaining in detail:\n\n\t\t\t\t*   **Dirty Reads**: A dirty read occurs when one transaction reads data that has been modified by another transaction but not yet committed. In our example, it could be cards that were available for one user, that are no longer available once they have been exchanged.\n\t\t\t\t*   **Non-Repeatable Reads** (Uncommitted Data): Non-repeatable reads (or uncommitted data) occur when a transaction reads the same data multiple times during its execution, but the data changes between reads due to updates by other transactions.\n\t\t\t\t*   **Phantom Reads**: Phantom reads occur when a transaction reads a set of records that satisfy a certain condition, and then, in a subsequent read of the same records, additional records match the condition due to inserts by other transactions.\n\n\t\t\tThere is another concept that we haven’t used in the example but is a core part of the Spring Data JPA. It is transaction propagation. What happens if a method annotated as `@Transactional` calls another `@Transactional` method? Are they executed in the same transaction or different ones? This behavior can be configured using the propagation attribute of `@Transactional` annotation. For instance:\n\n```", "```java\n\n\t\t\tThese are propagation possible values:\n\n\t\t\t\t*   REQUIRED (Default): If an existing transaction doesn’t exist, a new transaction is started. If an existing transaction does exist, the method participates in that transaction.\n\t\t\t\t*   REQUIRES_NEW: A new transaction is always started, suspending any existing transactions. The method always runs in a new transaction, even if there was an ongoing transaction before.\n\t\t\t\t*   NESTED: Creates a “nested” transaction within the existing transaction, allowing for savepoints. If the nested transaction fails, it can roll back to the savepoint without affecting the outer transaction.\n\t\t\t\t*   NOT_SUPPORTED: The method runs without a transaction context. If an existing transaction exists, it’s suspended while the method runs.\n\t\t\t\t*   MANDATORY: Requires an existing transaction to be present. If no transaction exists, an exception is thrown.\n\t\t\t\t*   NEVER: The method must not be run within a transaction context. If a transaction exists, an exception is thrown.\n\n\t\t\tWith propagation options, you can decide if you want to commit or rollback all changes, or you want to allow that some parts of the changes can be committed or rolled-back independently.\n\t\t\tAs you can see there many options related to transactions. I tend to use the default behavior and keep everything as simple as possible and use the available options when they are necessary.\n\t\t\tThere’s more...\n\t\t\tHere, we have used a declarative approach to implement transactions, but you can execute transactions with `EntityManager`, for instance when using Dynamic Queries.\n\n```", "```java\n\n\t\t\tKeep in mind that this way is more manual, so you need to properly manage the exceptions to rollback the transaction when needed. Usually, you will begin and commit your transaction inside a `try` block and you will rollback the transaction when an exception happens. That will look like this:\n\n```", "```java\n\n\t\t\tIt is important to close the transactions as soon as possible, as depending on the level of isolation, they can lock data in the database and cause unwanted contention.\n\t\t\tSee also\n\t\t\tIt is possible to create distributed transactions involving more than one microservice, but doing so can be complex and comes with challenges. Distributed transactions that span multiple microservices require careful design and consideration of the distributed nature of microservices architectures. Traditional **two-phase commit** (**2PC**) is one way to achieve distributed transactions, but it’s often avoided due to its complexity and potential for blocking and performance issues. Instead, many microservices architectures favor patterns like the Saga pattern or compensation-based transactions.\n\t\t\tHere are some approaches for handling distributed transactions across multiple microservices:\n\n\t\t\t\t*   **Saga Pattern**: It is a way to maintain data consistency in a microservices architecture without relying on distributed transactions. In a saga, each microservice performs its part of the transaction and publishes events to inform other services about their actions. If an error occurs, compensating transactions are executed to revert previous actions. This pattern allows for eventual consistency and is often preferred in microservices.\n\t\t\t\t*   **Asynchronous Messaging**: Instead of tightly coupling microservices in a distributed transaction, you can use asynchronous messaging (e.g., with message queues) to communicate between services. Microservices can publish events when they complete their part of the work, and other services can consume these events and act accordingly.\n\t\t\t\t*   **Compensating Transactions**: In cases where something goes wrong, compensating transactions can be used to undo the changes made by a microservice. This is part of the Saga pattern and can help maintain data consistency.\n\t\t\t\t*   **API Gateway**: An API gateway can be used to orchestrate requests to multiple microservices as part of a single transaction. It can provide an API endpoint that aggregates multiple requests and enforces transactional semantics.\n\t\t\t\t*   **Distributed Transaction Coordinator** (**DTC**): While not commonly used in microservices architectures, you can implement a DTC that spans multiple microservices. However, this approach can introduce complexity and potential performance bottlenecks.\n\n```"]