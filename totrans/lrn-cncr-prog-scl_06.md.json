["```java\nlibraryDependencies += \n  \"com.netflix.rxjava\" % \"rxjava-scala\" % \"0.19.1\" \n\n```", "```java\nimport rx.lang.scala._ \nobject ObservablesItems extends App { \n  val o = Observable.items(\"Pascal\", \"Java\", \"Scala\") \n  o.subscribe(name => log(s\"learned the $name language\")) \n  o.subscribe(name => log(s\"forgot the $name language\")) \n} \n\n```", "```java\nrun-main-0: learned the Pascal language \nrun-main-0: learned the Java language \nrun-main-0: learned the Scala language \nrun-main-0: forgot the Pascal language \nrun-main-0: forgot the Java language \nrun-main-0: forgot the Scala language \n\n```", "```java\nimport scala.concurrent.duration._ \nobject ObservablesTimer extends App { \n  val o = Observable.timer(1.second) \n  o.subscribe(_ => log(\"Timeout!\")) \n  o.subscribe(_ => log(\"Another timeout!\")) \n  Thread.sleep(2000) \n} \n\n```", "```java\nRxComputationThreadPool-2: Another timeout! \nRxComputationThreadPool-1: Timeout! \n\n```", "```java\nobject ObservablesExceptions extends App { \n  val exc = new RuntimeException \n  val o = Observable.items(1, 2) ++ Observable.error(exc) \n  o.subscribe( \n    x => log(s\"number $x\"), \n    t => log(s\"an error occurred: $t\") \n  ) \n} \n\n```", "```java\nimport Observable._ \nval o = items(1, 2) ++ error(exc) ++ items(3, 4) \n\n```", "```java\ntrait Observer[T] { \n  def onNext(event: T): Unit \n  def onError(error: Throwable): Unit \n  def onCompleted(): Unit \n} \n\n```", "```java\nobject ObservablesLifetime extends App { \n  val classics = List(\"Good, bad, ugly\", \"Titanic\", \"Die Hard\") \n  val movies = Observable.from(classics) \n  movies.subscribe(new Observer[String] { \n    override def onNext(m: String) = log(s\"Movies Watchlist - $m\") \n    override def onError(e: Throwable) = log(s\"Ooops - $e!\") \n    override def onCompleted() = log(s\"No more movies.\") \n  }) \n} \n\n```", "```java\ndef create(f: Observer[T] => Subscription): Observable[T] \n\n```", "```java\ntrait Subscription { \n  def unsubscribe(): Unit \n} \n\n```", "```java\nobject ObservablesCreate extends App { \n  val vms = Observable.apply[String] { obs => \n    obs.onNext(\"JVM\") \n    obs.onNext(\"DartVM\") \n    obs.onNext(\"V8\") \n    obs.onCompleted() \n    Subscription() \n  } \n  vms.subscribe(log _, e => log(s\"oops - $e\"), () => log(\"Done!\")) \n} \n\n```", "```java\nimport scala.concurrent._ \nimport ExecutionContext.Implicits.global \n\n```", "```java\nobject ObservablesCreateFuture extends App { \n  val f = Future { \"Back to the Future(s)\" } \n  val o = Observable.create[String] { obs => \n    f foreach { case s => obs.onNext(s); obs.onCompleted() } \n    f.failed foreach { case t => obs.onError(t) } \n    Subscription() \n  } \n  o.subscribe(log _) \n} \n\n```", "```java\nval o = Observable.from(Future { \"Back to the Future(s)\" }) \n\n```", "```java\nimport org.apache.commons.io.monitor._ \n\n```", "```java\ndef modified(directory: String): Observable[String] = { \n  Observable.create { observer => \n    val fileMonitor = new FileAlterationMonitor(1000) \n    val fileObs = new FileAlterationObserver(directory) \n    val fileLis = new FileAlterationListenerAdaptor { \n      override def onFileChange(file: java.io.File) { \n        observer.onNext(file.getName) \n      } \n    } \n    fileObs.addListener(fileLis) \n    fileMonitor.addObserver(fileObs) \n    fileMonitor.start() \n    Subscription { fileMonitor.stop() } \n  } \n} \n\n```", "```java\nobject ObservablesSubscriptions extends App { \n  log(s\"starting to monitor files\") \n  val sub = modified(\".\").subscribe(n => log(s\"$n modified!\")) \n  log(s\"please modify and save a file\") \n  Thread.sleep(10000) \n  sub.unsubscribe() \n  log(s\"monitoring done\") \n} \n\n```", "```java\nval fileMonitor = new FileAlterationMonitor(1000) \nfileMonitor.start() \n\n```", "```java\ndef hotModified(directory: String): Observable[String] = { \n  val fileObs = new FileAlterationObserver(directory) \n  fileMonitor.addObserver(fileObs) \n  Observable.create { observer => \n    val fileLis = new FileAlterationListenerAdaptor { \n      override def onFileChange(file: java.io.File) { \n        observer.onNext(file.getName) \n      } \n    } \n    fileObs.addListener(fileLis) \n    Subscription { fileObs.removeListener(fileLis) } \n  } \n} \n\n```", "```java\nobject CompositionMapAndFilter extends App { \n  val odds = Observable.interval(0.5.seconds) \n    .filter(_ % 2 == 1).map(n => s\"num $n\").take(5) \n  odds.subscribe( \n    log _, e => log(s\"unexpected $e\"), () => log(\"no more odds\")) \n  Thread.sleep(4000) \n} \n\n```", "```java\nval evens = for (n <- Observable.from(0 until 9); if n % 2 == 0) \nyield s\"even number $n\" \nevens.subscribe(log _) \n\n```", "```java\nimport scala.io.Source \ndef fetchQuote(): Future[String] = Future { \n  blocking { \n    val url = \"http://quotes.stormconsultancy.co.uk/random.json\" + \n      \"show_permalink=false&show_source=false\" \n    Source.fromURL(url).getLines.mkString \n  } \n} \n\n```", "```java\ndef fetchQuoteObservable(): Observable[String] = { \n  Observable.from(fetchQuote()) \n} \n\n```", "```java\ndef quotes: Observable[Observable[String]] = \n  Observable.interval(0.5 seconds).take(4).map { \n    n => fetchQuoteObservable().map(txt => s\"$n) $txt\") \n  } \n\n```", "```java\nobject CompositionConcatAndFlatten extends App { \n  log(s\"Using concat\") \n  quotes.concat.subscribe(log _) \n  Thread.sleep(6000) \n  log(s\"Now using flatten\") \n  quotes.flatten.subscribe(log _) \n  Thread.sleep(6000) \n} \n\n```", "```java\nObservable.interval(0.5 seconds).take(5).flatMap({ \n  n => fetchQuoteObservable().map(txt => s\"$n) $txt\") \n}).subscribe(log _) \n\n```", "```java\nval qs = for { \n  n   <- Observable.interval(0.5 seconds).take(5) \n  txt <- fetchQuoteObservable() \n} yield s\"$n) $txt\" \nqs.subscribe(log _) \n\n```", "```java\ndef randomQuote = Observable.create[String] { obs => \n  val url = \"http://www.iheartquotes.com/api/v1/random?\" + \n    \"show_permalink=false&show_source=false\" \n  obs.onNext(Source.fromURL(url).getLines.mkString) \n  obs.onCompleted() \n  Subscription() \n} \n\n```", "```java\nobject CompositionRetry extends App { \n  import Observable._ \n  def errorMessage = items(\"Retrying...\") ++ error(new Exception) \n  def quoteMessage = for { \n    text    <- randomQuote \n    message <- if (text.size < 100) items(text) else errorMessage \n  } yield message \n  quoteMessage.retry(5).subscribe(log _) \n  Thread.sleep(2500) \n} \n\n```", "```java\nobject CompositionScan extends App { \n  CompositionRetry.quoteMessage.retry.repeat.take(100).scan(0) { \n    (n, q) => if (q == \"Retrying...\") n + 1 else n \n  } subscribe(n => log(s\"$n / 100\")) \n} \n\n```", "```java\nobject CompositionErrors extends App { \n  val status = items(\"ok\", \"still ok\") ++ error(new Exception) \n  val fixedStatus = \n    status.onErrorReturn(e => \"exception occurred.\") \n  fixedStatus.subscribe(log _) \n  val continuedStatus = \n    status.onErrorResumeNext(e => items(\"better\", \"much better\")) \n  continuedStatus.subscribe(log _) \n} \n\n```", "```java\nobject SchedulersComputation extends App { \n  val scheduler = schedulers.ComputationScheduler() \n  val numbers = Observable.from(0 until 20) \n  numbers.subscribe(n => log(s\"num $n\")) \n  numbers.observeOn(scheduler).subscribe(n => log(s\"num $n\")) \n  Thread.sleep(2000) \n} \n\n```", "```java\nrun-main-42: num 0 \n... \nrun-main-42: num 19 \nRxComputationThreadPool-1: num 0 \n... \nRxComputationThreadPool-1: num 19 \n\n```", "```java\nlibraryDependencies +=  \n  \"org.scala-lang.modules\" %% \"scala-swing\" % \"1.0.1\" \n\n```", "```java\nimport scala.swing._ \nimport scala.swing.event._ \n\n```", "```java\nobject SchedulersSwing extends SimpleSwingApplication { \n  def top = new MainFrame { \n    title = \"Swing Observables\" \n    val button = new Button { \n      text = \"Click\" \n    } \n    contents = button \n    val buttonClicks = Observable.create[Button] { obs => \n      button.reactions += { \n        case ButtonClicked(_) => obs.onNext(button) \n      } \n      Subscription() \n    } \n    buttonClicks.subscribe(_ => log(\"button clicked\")) \n  } \n} \n\n```", "```java\nimport java.util.concurrent.Executor \nimport rx.schedulers.Schedulers.{from => fromExecutor} \nimport javax.swing.SwingUtilities.invokeLater \nval swingScheduler = new Scheduler { \n  val asJavaScheduler = fromExecutor(new Executor { \n    def execute(r: Runnable) = invokeLater(r) \n  }) \n} \n\n```", "```java\nabstract class BrowserFrame extends MainFrame { \n  title = \"MiniBrowser\" \n  val specUrl = \"http://www.w3.org/Addressing/URL/url-spec.txt\" \n  val urlfield = new TextField(specUrl) \n  val pagefield = new TextArea \n  val button = new Button { \n    text = \"Feeling Lucky\" \n  } \n  contents = new BorderPanel { \n    import BorderPanel.Position._ \n    layout(new BorderPanel { \n      layout(new Label(\"URL:\")) = West \n      layout(urlfield) = Center \n      layout(button) = East \n    }) = North \n    layout(pagefield) = Center \n  } \n  size = new Dimension(1024, 768) \n} \n\n```", "```java\nimplicit class ButtonOps(val self: Button) { \n  def clicks = Observable.create[Unit] { obs => \n    self.reactions += { \n      case ButtonClicked(_) => obs.onNext(()) \n    } \n    Subscription() \n  } \n} \nimplicit class TextFieldOps(val self: TextField) { \n  def texts = Observable.create[String] { obs => \n    self.reactions += { \n      case ValueChanged(_) => obs.onNext(self.text) \n    } \n    Subscription() \n  } \n} \n\n```", "```java\ntrait BrowserLogic { \n  self: BrowserFrame => \n  def suggestRequest(term: String): Observable[String] = { \n    val url = \"http://suggestqueries.google.com/\" + \n      s\"complete/search?client=firefox&q=$term\" \n    val request = Future { Source.fromURL(url).mkString } \n    Observable.from(request) \n              .timeout(0.5.seconds) \n              .onErrorReturn(e => \"(no suggestion)\") \n  } \n  def pageRequest(url: String): Observable[String] = { \n    val request = Future { Source.fromURL(url).mkString } \n    Observable.from(request) \n              .timeout(4.seconds) \n              .onErrorReturn(e => s\"Could not load page: $e\") \n  } \n  urlfield.texts.map(suggestRequest).concat \n                .observeOn(swingScheduler) \n                .subscribe(response => pagefield.text = response) \n  button.clicks.map(_ => pageRequest(urlfield.text)).concat \n               .observeOn(swingScheduler) \n               .subscribe(response => pagefield.text = response) \n} \n\n```", "```java\nobject SchedulersBrowser extends SimpleSwingApplication { \n  def top = new BrowserFrame with BrowserLogic \n} \n\n```", "```java\nobject TimeModule { \n  import Observable._ \n  val systemClock = interval(1.seconds).map(t => s\"systime: $t\") \n} \n\n```", "```java\nobject RxOS { \n  val messageBus = TimeModule.systemClock.subscribe(log _) \n} \n\n```", "```java\nobject FileSystemModule { \n  val fileModifications = modified(\".\") \n} \n\n```", "```java\nobject RxOS { \n  val messageBus = Observable.items( \n    TimeModule.systemClock, \n    FileSystemModule.fileModifications \n  ).flatten.subscribe(log _) \n} \n\n```", "```java\nobject RxOS { \n  val messageBus = Subject[String]() \n  messageBus.subscribe(log _) \n} \n\n```", "```java\nobject SubjectsOS extends App { \n  log(s\"RxOS boot sequence starting...\") \n  val loadedModules = List( \n    TimeModule.systemClock, \n    FileSystemModule.fileModifications \n  ).map(_.subscribe(RxOS.messageBus)) \n  log(s\"RxOS boot sequence finished!\") \n  Thread.sleep(10000) \n  for (mod <- loadedModules) mod.unsubscribe() \n  log(s\"RxOS going for shutdown\") \n} \n\n```", "```java\nobject RxOS { \n  val messageBus = Subject[String]() \n  val messageLog = subjects.ReplaySubject[String]() \n  messageBus.subscribe(log _) \n  messageBus.subscribe(messageLog) \n} \n\n```", "```java\nlog(s\"RxOS dumping the complete system event log\") \nRxOS.messageLog.subscribe(logToFile) \nlog(s\"RxOS going for shutdown\") \n\n```", "```java\n                class Signal[T] { \n                  def apply(): T = ??? \n                  def map(f: T => S): Signal[S] = ??? \n                  def zip[S](that: Signal[S]): Signal[(T, S)] = ??? \n                  def scan[S](z: S)(f: (S, T) => S) = ??? \n                } \n\n    ```", "```java\n                def toSignal: Signal[T] = ??? \n\n    ```", "```java\n                class RCell[T] extends Signal[T] { \n                  def :=(x: T): Unit = ???  \n                } \n\n    ```", "```java\n                class RMap[K, V] { \n                  def update(k: K, v: V): Unit \n                  def apply(k: K): Observable[V] \n                }  \n\n    ```", "```java\n                class RPriorityQueue[T] { \n                  def add(x: T): Unit = ??? \n                  def pop(): T = ??? \n                  def popped: Observable[T] = ??? \n                } \n\n    ```", "```java\n                def copyFile(src: String, dest: String): Observable[Double] \n\n    ```", "```java\n                class RxCanvas extends Component { \n                  def mouseMoves: Observable[(Int, Int)] \n                  def mousePresses: Observable[(Int, Int)] \n                  def mouseReleases: Observable[(Int, Int)] \n                } \n\n    ```", "```java\n                def scatterGather[S](f: T => S): Observable[S] \n\n    ```"]