<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer128">
<h1 class="chapter-number" id="_idParaDest-365"><a id="_idTextAnchor537"/>17</h1>
<h1 id="_idParaDest-366"><a id="_idTextAnchor538"/>Microservice Security with OAuth 2 and JSON Web Tokens</h1>
<p>In this chapter, we will look at microservices-based architectures and look at how <strong class="bold">OAuth 2</strong> with <strong class="bold">JSON Web Tokens</strong> (<strong class="bold">JWT</strong>) plays a role in securing microservices in a Spring- <span class="No-Break">based application.</span></p>
<p>The following is a list of topics that will be covered in <span class="No-Break">this chapter:</span></p>
<ul>
<li>The general difference between <strong class="bold">monolithic applications</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="bold">microservices</strong></span></li>
<li>Comparing <strong class="bold">Service-Oriented Architectures</strong> (<strong class="bold">SOA</strong>) <span class="No-Break">with microservices</span></li>
<li>The conceptual architecture of <strong class="bold">OAuth 2</strong> and how it provides your services with trustworthy <span class="No-Break">client access</span></li>
<li>Types of <strong class="bold">OAuth 2</strong> <span class="No-Break">access tokens</span></li>
<li>Types of <strong class="bold">OAuth 2</strong> <span class="No-Break">grant types</span></li>
<li>Examining JWT and their <span class="No-Break">general structure</span></li>
<li>Implementing a resource server and authentication server used to grant access rights to clients in order to access <strong class="bold">OAuth </strong><span class="No-Break"><strong class="bold">2</strong></span><span class="No-Break"> resources</span></li>
<li>Implementing a <strong class="bold">RESTful</strong> client to gain access to resources through an <strong class="bold">OAuth 2</strong> <span class="No-Break">grant flow</span></li>
</ul>
<p>We have quite a few items to cover in this chapter, but before we dig into the details of how to start leveraging <strong class="source-inline">Spring Security</strong> to implement <strong class="bold">OAuth 2</strong> and <strong class="bold">JWT</strong>, we first want to create a baseline of the calendar application that does not have <strong class="bold">Thymeleaf</strong> or any other browser- based <span class="No-Break">user interface.</span></p>
<p>After removing all <strong class="bold">Thymeleaf</strong> configuration and resources, the various controllers have been converted to <strong class="bold">JAX-RS </strong><span class="No-Break"><strong class="bold">REST</strong></span><span class="No-Break"> controllers.</span></p>
<p>This chapter’s code in action link is <span class="No-Break">here: </span><a href="https://packt.link/zEHBU"><span class="No-Break">https://packt.link/zEHBU</span></a><span class="No-Break">.</span></p>
<p class="callout-heading">Important note</p>
<p class="callout">You should start with the code <span class="No-Break">from </span><span class="No-Break"><strong class="source-inline">chapter17.00-calendar</strong></span><span class="No-Break">.</span></p>
<h1 id="_idParaDest-367"><a id="_idTextAnchor539"/>What are microservices?</h1>
<p><strong class="bold">Microservices</strong> are an <a id="_idIndexMarker1224"/>architectural approach that allows the development of physically separated modular applications which are autonomous, enabling agility, rapid development, continuous deployment, <span class="No-Break">and scaling.</span></p>
<p>An application is built as a set of <a id="_idIndexMarker1225"/>services, like <strong class="bold">SOA</strong>, such that services communicate through<a id="_idIndexMarker1226"/> standard <strong class="bold">APIs</strong>, for example, <strong class="source-inline">JSON</strong> or <strong class="source-inline">XML</strong>, and this allows the aggregation of language-agnostic services. Basically, a service can be written in the best language for the task the service is being <span class="No-Break">created for.</span></p>
<p>Each service runs in its own process and is location neutral, thus it can be located anywhe<a id="_idTextAnchor540"/>re on the <span class="No-Break">access network.</span></p>
<p>In the next sections, we will explore Monoliths, Microservices, and Service-oriented architectures and discern their variances. Then, we can delve into Microservices Security <span class="No-Break">using spring-securit<a id="_idTextAnchor541"/>y.</span></p>
<h2 id="_idParaDest-368"><a id="_idTextAnchor542"/>Monoliths</h2>
<p>The microservices <a id="_idIndexMarker1227"/>approach is the opposite of the traditional monolithic software approach, which consists of tightly integrated modules that ship infrequently and have to scale as a single unit. Traditional <strong class="bold">Java EE</strong> applications<a id="_idIndexMarker1228"/> and the <strong class="source-inline">JBCP calendar</strong> application in this book are examples of monolithic applications. Look at the following diagram which depicts the <span class="No-Break">monolithic architecture:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer125">
<img alt="Figure 17.1 – Monolithic architecture" height="1045" src="image/B21757_17_1.jpg" width="694"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 17.1 – Monolithic architecture</p>
<p>Although the<a id="_idIndexMarker1229"/> monolithic approach fits well for some organizations and some applications, microservices is becoming popular with companies that need more options for agility and scalability in <span class="No-Break">their ecosystem.</span></p>
<h2 id="_idParaDest-369"><a id="_idTextAnchor543"/>Microservices</h2>
<p>A microservice<a id="_idIndexMarker1230"/> architecture is a collection of small discrete services where each service implements a specific business capability. These services run their own process and communicate via<a id="_idIndexMarker1231"/> an <strong class="bold">HTTP API</strong> usually using a <strong class="bold">RESTful</strong> service<a id="_idIndexMarker1232"/> approach. These services are created to serve only one specific business function, such as user management, administrative roles, an e-commerce cart, a search engine, social media integration, and many others. Look at the following diagram which depicts the <span class="No-Break">microservices architecture:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer126">
<img alt="Figure 17.2 – Microservices architecture" height="963" src="image/B21757_17_2.jpg" width="1051"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 17.2 – Microservices architecture</p>
<p>Each service <a id="_idIndexMarker1233"/>can be deployed, upgraded, scaled, restarted, and removed independently of other services in the application and other systems in <span class="No-Break">the enterprise.</span></p>
<p>Because each service is created independently of the other, they can each be written in different programming languages and use different data storage. Centralized service management is virtually non-existent, and these services use<a id="_idIndexMarker1234"/> lightweight <strong class="bold">HTTP</strong>, <strong class="bold">REST</strong> communicating <a id="_idIndexMarker1235"/><span class="No-Break">among themselves.</span></p>
<h1 id="_idParaDest-370"><a id="_idTextAnchor544"/>Service-oriented architectures</h1>
<p>You<a id="_idIndexMarker1236"/> might be asking yourself, “Isn’t this the same as SOA?” Not exactly, you could say <strong class="bold">microservices</strong> achieve <a id="_idIndexMarker1237"/>what <strong class="bold">SOA</strong> promised in the <span class="No-Break">first place.</span></p>
<p>An <strong class="bold">SOA</strong> is a<a id="_idIndexMarker1238"/> style of software design where services are exposed to other components through a language-agnostic, communication protocol over a <span class="No-Break">computer network.</span></p>
<p>The basic principle of <strong class="bold">SOA</strong> is to be independent of vendors, products, <span class="No-Break">and technologies.</span></p>
<p>The definition of a service is a discrete unit of functionality that can be accessed remotely and acted upon and updated independently, such as retrieving a credit card <span class="No-Break">statement online.</span></p>
<p>Although similar, <strong class="bold">SOA</strong> and microservices are still different types <span class="No-Break">of architectures.</span></p>
<p>A typical <strong class="bold">SOA</strong> is often implemented inside deployment monoliths and is more platform driven, while microservices can be independently deployable and, therefore, offer more flexibility in <span class="No-Break">all dimensions.</span></p>
<p>The key difference, of course, is the size; the word micro says it all. Microservices tend to be significantly smaller than regular <strong class="bold">SOA</strong> services. As <em class="italic">Martin </em><span class="No-Break"><em class="italic">Fowler</em></span><span class="No-Break"> said:</span></p>
<p class="author-quote">We should think about SOA as a superset of microservices.</p>
<h1 id="_idParaDest-371"><a id="_idTextAnchor545"/>Microservice security</h1>
<p>Microservices can provide great flexibility but also introduce challenges <a id="_idTextAnchor546"/>that must <span class="No-Break">b<a id="_idTextAnchor547"/>e addressed.</span></p>
<ul>
<li><strong class="bold">Service communication</strong>: Monolithic<a id="_idIndexMarker1239"/> applications use in-memory communication between processes, while microservices communicate over the network. The move to network communi<a id="_idTextAnchor548"/>cation raises issues of not only speed but <span class="No-Break">a<a id="_idTextAnchor549"/>lso security.</span></li>
<li><strong class="bold">Tight coupling</strong>: Microservices use many datastores rather than a few. This creates the op<a id="_idTextAnchor550"/>portunity for <a id="_idIndexMarker1240"/>implicit service contracts between microservices and services that are <span class="No-Break">ti<a id="_idTextAnchor551"/>ghtly coupled.</span></li>
<li><strong class="bold">Technical complexity</strong>: Microservices can create additional complexity, which can create security gaps. If the team<a id="_idIndexMarker1241"/> does not have the correct experience, then managing these complexities can<a id="_idTextAnchor552"/> quickly <span class="No-Break">becom<a id="_idTextAnchor553"/>e unmanageable.</span></li>
</ul>
<h1 id="_idParaDest-372"><a id="_idTextAnchor554"/>The OAuth 2 specification</h1>
<p>There is<a id="_idIndexMarker1242"/> sometimes a misconception that <strong class="bold">OAuth 2</strong> is an evolution <a id="_idIndexMarker1243"/>from <strong class="bold">OAuth 1</strong>, but it is a completely different approach. <strong class="bold">OAuth 1</strong> specification requires signatures, so you would have to use cryptographic algorithms to create generate and validate those signatures that are no longer required for <strong class="bold">OAuth 2</strong>. The <strong class="bold">OAuth 2</strong> encryption is now handled by <strong class="bold">TLS</strong>, which <span class="No-Break">is require<a id="_idTextAnchor555"/>d.</span></p>
<p class="callout-heading">Important note</p>
<p class="callout"><strong class="bold">OAuth 2 RFC-6749</strong>, <em class="italic">The OAuth 2.0 Authorization </em><span class="No-Break"><em class="italic">Framework</em></span><span class="No-Break"> (</span><a href="https://tools.ietf.org/html/rfc6749"><span class="No-Break">https://tools.ietf.org/html/rfc6749</span></a><span class="No-Break">):</span></p>
<p class="callout">The <strong class="bold">OAuth 2.0</strong> authorization framework<a id="_idIndexMarker1244"/> enables a third-party application to obtain limited access to an HTTP service, either on behalf of a resource owner by orchestrating an approval interaction between the resource owner and the HTTP service, or by allowing the third-party application to obtain access on its <span class="No-Break">own behalf.</span></p>
<p class="callout">This specification replaces and makes obsolete the <strong class="bold">OAuth 1.0</strong> protocol<a id="_idIndexMarker1245"/> described in <strong class="bold">RFC 5849</strong>, The <strong class="bold">OAuth 1.0</strong> <span class="No-Break">Protocol (</span><a href="https://tools.ietf.org/html/rfc5849"><span class="No-Break">https://tools.ietf.org/html/rfc5849</span></a><span class="No-Break">).</span></p>
<p>To properly understand how to utilize <strong class="bold">OAuth 2</strong>, we need to identify certain roles and the collaboration between these roles. Let’s define each of the roles that are participating in the <strong class="bold">OAuth 2</strong> <span class="No-Break">authorization process:</span></p>
<ul>
<li><strong class="bold">Resource owner</strong>: The resource owner<a id="_idIndexMarker1246"/> is the entity <a id="_idIndexMarker1247"/>capable of granting access to a protected resource that is located on a <span class="No-Break">resource server</span></li>
<li><strong class="bold">Authorization server</strong>: The authorization server<a id="_idIndexMarker1248"/> is a <a id="_idIndexMarker1249"/>centralized security gateway for issuing access tokens to the client after successfully authenticating the resource owner and <span class="No-Break">obtaining authorization</span></li>
<li><strong class="bold">Resource server</strong>: The resource server<a id="_idIndexMarker1250"/> is the server <a id="_idIndexMarker1251"/>hosting the protected resources and is capable of dissecting and responding to protected resource requests using<a id="_idIndexMarker1252"/> the <strong class="bold">OAuth 2</strong> <span class="No-Break">access token</span></li>
<li><strong class="bold">Microservice client</strong>: The client is the application making resource requests that are protected on behalf of<a id="_idIndexMarker1253"/> the<a id="_idIndexMarker1254"/> resource owner, but with <span class="No-Break">their authorization</span></li>
</ul>
<h2 id="_idParaDest-373"><a id="_idTextAnchor556"/>Access tokens</h2>
<p>An <strong class="bold">OAuth 2</strong> access token, commonly <a id="_idIndexMarker1255"/>referred to as <a id="_idTextAnchor557"/><strong class="source-inline">access_token</strong> in code samples, represents a credential that can be used by a client to access an <strong class="bold">API</strong>. We hav<a id="_idTextAnchor558"/>e two types of <span class="No-Break">access tokens:</span></p>
<ul>
<li><strong class="bold">Access token</strong>: An access token<a id="_idIndexMarker1256"/> usually has a limited lifetime and is used to enable the client to access protected resources when including this token in the HTTP request header for <span class="No-Break">each request.</span></li>
<li><strong class="bold">Refresh token</strong>: A refresh token<a id="_idIndexMarker1257"/> has a longer lifetime and is used to get a n<a id="_idTextAnchor559"/>ew access token once the access token has expired, but without the need to send credentials to the <span class="No-Break">server again.</span></li>
</ul>
<h2 id="_idParaDest-374"><a id="_idTextAnchor560"/>Grant types</h2>
<p>Grant types<a id="_idIndexMarker1258"/> are methods that a client can use to gain an access token that represents the permissions granted. There are different grant types that allow different types of access based on the needs of your application. Each grant type<a id="_idTextAnchor561"/> can support a different <strong class="bold">OAuth 2</strong> flow without worrying about the technical aspects of the implementation. We have f<a id="_idTextAnchor562"/>our main grant types<a id="_idIndexMarker1259"/> in <span class="No-Break"><strong class="bold">OAuth 2</strong></span><span class="No-Break">:</span></p>
<ul>
<li><strong class="bold">Authorization code</strong>: The <strong class="bold">authorization code grant type</strong>, defined in <strong class="bold">RFC 6749, Section 4.1</strong> (<a href="https://tools.ietf.org/html/rfc6749">https://tools.ietf.org/html/rfc6749</a>), is a redirection-based flow where the browser <a id="_idIndexMarker1260"/>receives an<a id="_idIndexMarker1261"/> authorization code from an authorization server and sends this to the client. The client will then interact with the authorization server and exchange the authorization code for <strong class="source-inline">access_token</strong> and, optionally, <strong class="source-inline">id_token</strong> and <strong class="source-inline">refresh_token</strong>. The clie<a id="_idTextAnchor563"/>nt can now use this <strong class="source-inline">access_token</strong> to call the protec<a id="_idTextAnchor564"/>ted resource on behalf of <span class="No-Break">the user.</span></li>
<li><strong class="bold">Implicit</strong>: The <strong class="bold">implicit grant type</strong>, defined<a id="_idIndexMarker1262"/> in <strong class="bold">RFC 6749, Section 4.1</strong> (<a href="https://tools.ietf.org/html/rfc6749">https://tools.ietf.org/html/rfc6749</a>), is similar to the authorization code grant type, but the client application receives <strong class="source-inline">access_token</strong> directly, without<a id="_idIndexMarker1263"/> the need for <strong class="source-inline">authorization_code</strong>. This happens because the client application, which is usually a JavaScript application running within a browser and is less trusted than a client application running on the server, cannot be trusted with <strong class="source-inline">client_secret</strong> (which is required in the authorization code grant type). The implicit grant type does not send a refresh token to the application due to <span class="No-Break">limited trust.</span></li>
<li><strong class="bold">Password credentials</strong>: The <strong class="bold">resource owner password grant type</strong>, defined <a id="_idIndexMarker1264"/>in <strong class="bold">RFC 6749, Section 4.3</strong> (<a href="https://tools.ietf.org/html/rfc6749">https://tools.ietf.org/html/rfc6749</a>), can be used directly as <a id="_idIndexMarker1265"/>an authorization grant to obtain <strong class="source-inline">access_token</strong> and, optionally, <strong class="source-inline">refresh_token</strong>. This grant is used when there is a high degree of trust between the user and the client and when other authorization grant flows are not available. This grant type eliminates the need for the client to store the user credentials by exchanging the credentials with a lo<a id="_idTextAnchor565"/><a id="_idTextAnchor566"/>ng-lived <strong class="source-inline">access_token</strong> <span class="No-Break">or </span><span class="No-Break"><strong class="source-inline">refresh_token</strong></span><span class="No-Break">.</span></li>
<li><strong class="bold">Client credentials</strong>: The <strong class="bold">Client Credentials Grant’s</strong>, defined in <strong class="bold">RFC 6749, Section 4.4</strong> (<a href="https://authors.ietf.org/#section-4.4">https://tools.ietf.org/html/rfc6749#section-4.4</a>), is for a non-interactive client (CLI), a <a id="_idIndexMarker1266"/>daemon, or another service <a id="_idIndexMarker1267"/>running. The client can directly ask the<a id="_idTextAnchor567"/> authorization server for <strong class="source-inline">access_token</strong> by using client-provided credentials (client id and client secret) <span class="No-Break">to authenticate.</span></li>
</ul>
<p>After covering the main OAuth 2 access tokens and grant types, in the next section will deep div<a id="_idTextAnchor568"/>e into the JSON Web <span class="No-Break">Tokens specification.</span></p>
<h1 id="_idParaDest-375"><a id="_idTextAnchor569"/>JSON Web Tokens</h1>
<p><strong class="bold">JWT</strong> is an <a id="_idIndexMarker1268"/>open standard, <strong class="bold">RFC 7519</strong> (<a href="https://tools.ietf.org/html/rfc7519">https://tools.ietf.org/html/rfc7519</a>) that defines a compact and self-contained format for securely transmitting information between parties in the form of a <strong class="bold">JSON</strong> object. This information can be verified and trusted because it is digitally signed. JWTs can be signed using a secret (with<a id="_idIndexMarker1269"/> the <strong class="bold">hash-based message authentication code</strong> (<strong class="bold">HMAC</strong>) algorithm) or a public/private key pair using<a id="_idIndexMarker1270"/> the <strong class="bold">Rivest–Shamir–Adleman</strong> (<strong class="bold">RSA</strong>) <span class="No-Break">encryption algorithm.</span></p>
<p class="callout-heading">Important note</p>
<p class="callout"><strong class="bold">JWT RFC- </strong><span class="No-Break"><strong class="bold">7519</strong></span><span class="No-Break"> (</span><a href="https://tools.ietf.org/html/rfc7519"><span class="No-Break">https://tools.ietf.org/html/rfc7519</span></a><span class="No-Break">):</span></p>
<p class="callout"><strong class="bold">JWT</strong> is a<a id="_idIndexMarker1271"/> compact, URL-safe means of representing claims to be transferred between two parties. The claims in a <strong class="bold">JWT</strong> are encoded as a <strong class="bold">JSON</strong> object that is used as the payload of a <strong class="bold">JSON Web Signature</strong> (<strong class="bold">JWS</strong>) structure <a id="_idIndexMarker1272"/>or as the plaintext of <a id="_idIndexMarker1273"/>a <strong class="bold">JSON Web Encryption</strong> (<strong class="bold">JWE</strong>) structure, enabling the claims to be digitally signed or integrity protected with <a id="_idIndexMarker1274"/>a <strong class="bold">Message Authentication Code</strong> (<strong class="bold">MAC</strong>) <span class="No-Break">and/or encrypted.</span></p>
<p><strong class="bold">JWT</strong> is used to <a id="_idIndexMarker1275"/>carry information related to the identity and characteristics (<strong class="bold">claims</strong>) of the<a id="_idIndexMarker1276"/> client bearing the token. JWT is a container and is signed by the server to avoid client tampering. This token is created during the authentication process and is verified by the authorization server before any processing. It is used by a resource server to allow a client to present a token representing its <em class="italic">identity card</em> to the resource server and allows the resource server to verify the validity<a id="_idTextAnchor570"/> and integrity of the token in a stateless, <span class="No-Break">secure manner.</span></p>
<h2 id="_idParaDest-376"><a id="_idTextAnchor571"/>Token structure</h2>
<p>The structure of a JWT adheres to the following three-part structure including a header, payload, <span class="No-Break">and signature:</span></p>
<pre class="source-code">
[Base64Encoded(HEADER)] . [Base64Encoded (PAYLOAD)] . [encoded(SIGNATURE)]</pre> <h3>Encoded JWT</h3>
<p>The following code <a id="_idIndexMarker1277"/>snippet is the complete encoded <strong class="source-inline">access_token</strong> that is returned based on the <span class="No-Break">client request:</span></p>
<pre class="source-code">
eyJraWQiOiJlOTllMzEyYS0yMDJmLTRmNDItOWExNi1h ZmE2NDA5Mzg0N2QiLCJhbGciOiJSUzI1NiJ9.eyJzdWIiOiJqYmNwLWNhbGVuZGFyIiwiYXVkIjoiamJjcC1jYWxlbmRhciIsIm5iZiI6MT cwODU0ODUzMCwic2NvcGUiOlsiZXZlbnRzLnJlYWQiXSwiaXNzIjoiaHR0cDovL2xvY2Fs aG9zdDo5MDAwIiwiZXhwIjoxNzA4NTQ4ODMwLCJpYXQiOjE3MDg1NDg1MzAsImp0aSI6I jRhMzVjZmNmLTE5YWItNDZjZC05OWI4LWQxNWM5ZmZlNjQ1MiJ9.WNJTwQwHA4TVE1BYuizQUo88Dnf0K2by0awxVo_mSq_8n5KWkQMuKESFQwQHT32VExn7qHW6JoD6sfxrLK5q2o-KKIYDpL1CACtfjK0mUCWjfpLfpeyXg0FpYPw6s4allS3zUfOSrFf53wP8k4XCNaPxU9yVQ8s2TB064Sanl7W0VwSbxoz4B-VgPQwEob1cxhAXrBBy5WmM8rk7WsvPXYvMLdo ISpkP4n66hCzdmmFiBWFhgsfRsOVG8mNmIWgeJVgLXY BiLrbR2FuFK5KxU7Ls7IMZcWiHd95yAgA6TQ46yBiJErclNVr8Xr5M2SnzFR7HWJY 2OHCNJxnjRpbwEQ</pre> <h3>Header</h3>
<p>The encoded <a id="_idIndexMarker1278"/>header for our <strong class="source-inline">access_token</strong> JWT is <strong class="source-inline">base64</strong> encoded, as shown in the <span class="No-Break">following code:</span></p>
<pre class="source-code">
eyJraWQiOiJlOTllMzEyYS0yMDJmLTRmNDItOWExNi1hZmE2NDA5Mzg0N2QiLCJhbGciOi JSUzI1NiJ9</pre> <p>By decoding the<a id="_idIndexMarker1279"/> encoded header, we have the <span class="No-Break">following payload:</span></p>
<pre class="source-code">
{
  "kid": "e99e312a-202f-4f42-9a16-afa64093847d",
  "alg": "RS256"
}</pre> <h3>Payload</h3>
<p>The encoded payload<a id="_idIndexMarker1280"/> for our <strong class="source-inline">access_token</strong> JWT is <strong class="source-inline">base64</strong> encoded, as <span class="No-Break">shown here:</span></p>
<pre class="source-code">
eyJzdWIiOiJqYmNwLWNhbGVuZGFyIiwiYXVkIjoia mJjcC1jYWxlbmRhciIsIm5iZiI6MTc wODU0ODUzMCwic2NvcGUiOlsiZXZlbnRzL nJlYWQiXSwiaXNzIjoiaHR0cDovL2xvY2FsaG 9zdDo5MDAwIiwiZXhwIjoxNzA4NTQ4ODMwL CJpYXQiOjE3MDg1NDg1MzAsImp0aSI6IjRhM zVjZmNmLTE5YWItNDZjZC05OWI4LWQxNWM5ZmZlNjQ1MiJ9</pre> <p>By decoding the <a id="_idTextAnchor572"/><a id="_idTextAnchor573"/>encoded payload, we have the following <span class="No-Break">payload claims:</span></p>
<pre class="source-code">
{
  "sub": "jbcp-calendar",
  "aud": "jbcp-calendar",
  "nbf": 1708548530,
  "scope": [
    "events.read"
  ],
  "iss": "http://localhost:9000",
  "exp": 1708548830,
  "iat": 1708548530,
  "jti": "4a35cfcf-19ab-46cd-99b8-d15c9ffe6452"
}</pre> <h3>Signature</h3>
<p>The encoded payload<a id="_idIndexMarker1281"/> for our <strong class="source-inline">access_token</strong> has been encoded with a private key by the authorization server, as seen in the <span class="No-Break">following code:</span></p>
<pre class="source-code">
WNJTwQwHA4TVE1BYuizQUo88Dnf0K2by0awxVo _mSq_8n5KWkQMuKESFQwQHT32VExn7qHW 6JoD6sfxrLK5q2o-KKIYDpL1CACtfjK0mUCW jfpLfpeyXg0FpYPw6s4allS3zUfOSrFf53 wP8k4XCNaPxU9yVQ8s2TB064Sanl7W0VwSbxoz4B-VgPQwEob1cxhAXrBBy5WmM8rk7Ws vPXYvMLdoISpkP4n66hCzdmmFiBWFhgsfRsOV G8mNmIWgeJVgLXYBiLrbR2FuFK5KxU7Ls 7IMZcWiHd95yAgA6TQ46yBiJErclNVr8Xr5M2SnzFR7HWJY2OHCNJxnjRpbwEQ</pre> <p>The following is pseudo code for the creation of a <span class="No-Break">JWT signature:</span></p>
<pre class="source-code">
var encodedString = base64UrlEncode(header) + "."; encodedString += base64UrlEncode(payload);
var privateKey = "[-----PRIVATE KEY
]";
var signature = SHA256withRSA(encodedString, privateKey); var JWT = encodedString + "." + base64UrlEncode(signature);</pre> <h1 id="_idParaDest-377"><a id="_idTextAnchor574"/>JWT Authentication in Spring Security</h1>
<p>Moving forward, let’s examine the architectural elements employed by <strong class="source-inline">Spring Security</strong> to facilitate <strong class="bold">JWT</strong> Authentication<a id="_idIndexMarker1282"/> in servlet-based applications, similar to the one we <span class="No-Break">previously discussed.</span></p>
<p>The <strong class="source-inline">JwtAuthenticationProvider</strong> serves as an implementation of <strong class="source-inline">AuthenticationProvider</strong>, utilizing a <strong class="source-inline">JwtDecoder</strong> and <strong class="source-inline">JwtAuthenticationConverter</strong> to validate a <strong class="bold">JWT</strong> <span class="No-Break">during authentication.</span></p>
<p>Now, let’s delve into the workings of <strong class="source-inline">JwtAuthenticationProvider</strong> within the context of <strong class="source-inline">Spring Security</strong>. The accompanying figure elucidates the intricacies of the <strong class="source-inline">AuthenticationManager</strong>, as illustrated in the figures depicting the process of reading the <span class="No-Break"><strong class="bold">Bearer Token</strong></span><span class="No-Break">.</span></p>
<div>
<div class="IMG---Figure" id="_idContainer127">
<img alt="Figure 17.3 – JWT Authentication in Spring Security" height="584" src="image/B21757_17_3.jpg" width="932"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 17.3 – JWT Authentication in Spring Security</p>
<p>The JWT <a id="_idIndexMarker1283"/>authentication in spring-security entails the <span class="No-Break">following steps:</span></p>
<ol>
<li>The Authentication Filter, as part of the process outlined in reading the <strong class="bold">Bearer Token</strong>, transfers a <strong class="source-inline">BearerTokenAuthenticationToken</strong> to the <strong class="source-inline">AuthenticationManager</strong>, which is implemented <span class="No-Break">by </span><span class="No-Break"><strong class="source-inline">ProviderManager</strong></span><span class="No-Break">.</span></li>
<li>The <strong class="source-inline">ProviderManager</strong> is set up to utilize an <strong class="source-inline">AuthenticationProvider</strong> of the <span class="No-Break"><strong class="source-inline">JwtAuthenticationProvider</strong></span><span class="No-Break"> type.</span></li>
<li><strong class="source-inline">JwtAuthenticationProvider</strong> undertakes the tasks of decoding, verifying, and validating the <strong class="source-inline">Jwt</strong> through <span class="No-Break">a </span><span class="No-Break"><strong class="source-inline">JwtDecoder</strong></span><span class="No-Break">.</span></li>
<li>Subsequently, <strong class="source-inline">JwtAuthenticationProvider</strong> employs <span class="No-Break">the </span><span class="No-Break"><strong class="source-inline">JwtAuthentication</strong></span><strong class="source-inline">
Converter</strong> to transform the <strong class="bold">JWT</strong> into a Collection of <span class="No-Break">granted authorities.</span></li>
<li>Upon successful authentication, the returned Authentication takes the form of <strong class="source-inline">JwtAuthenticationToken</strong>, featuring a principal representing the <strong class="bold">JWT</strong> obtained from the configured <strong class="source-inline">JwtDecoder</strong>. Eventually, the <strong class="source-inline">JwtAuthenticationToken</strong> returned will be placed in the <strong class="source-inline">SecurityContextHolder</strong> by the <a id="_idIndexMarker1284"/><span class="No-Break">Authentication Filter.</span></li>
</ol>
<p>After covering the <strong class="bold">OAuth 2</strong> and <strong class="bold">JWT</strong> specifications we’ll take a closer look at how they’re implemented <span class="No-Break">within spring-security.</span></p>
<h1 id="_idParaDest-378"><a id="_idTextAnchor575"/>OAuth 2 support in Spring Security</h1>
<p><strong class="source-inline">Spring Security</strong> provides <strong class="bold">OAuth 2</strong> aut<a id="_idTextAnchor576"/>horization<a id="_idIndexMarker1285"/> support following <strong class="source-inline">Spring Framework</strong> programming models and <span class="No-Break">configuration idioms.</span></p>
<p>In the following section we will identify the main components involved in <strong class="bold">OAuth </strong><span class="No-Break"><strong class="bold">2</strong></span><span class="No-Break"> flow.</span></p>
<h2 id="_idParaDest-379"><a id="_idTextAnchor577"/>Resource owner</h2>
<p>The resource owner<a id="_idIndexMarker1286"/> can be one or multiple sources, and in the context of the <strong class="bold">JBCP calendar</strong>, it is going to <a id="_idIndexMarker1287"/>have the calendar application as the resource owner. The <strong class="bold">JBCP calendar</strong> will not have any specific con<a id="_idTextAnchor578"/>figuration that is needed to deno<a id="_idTextAnchor579"/>te its ownership aside from configuring the <span class="No-Break">resource server.</span></p>
<h2 id="_idParaDest-380"><a id="_idTextAnchor580"/>Resource server</h2>
<p>Most of the <a id="_idIndexMarker1288"/>resource server support is consolidated in <strong class="source-inline">spring-security-oauth2-resource-server</strong>. However, the decoding and verification of <strong class="bold">JWT</strong>s are handled by <strong class="source-inline">spring-security-oauth2-jose</strong>. Therefore, both components are essential for a functional resource server that can<a id="_idIndexMarker1289"/> handle <strong class="bold">JWT-encoded </strong><span class="No-Break"><strong class="bold">Bearer Tokens</strong></span><span class="No-Break">.</span></p>
<p>In Spring Boot, setting up an application as a resource server involves two <span class="No-Break">fundamental steps:</span></p>
<ol>
<li>Firstly, include the <span class="No-Break">necessary dependencies</span></li>
<li>Secondly, specify the location of the <span class="No-Break">authorization server.</span></li>
</ol>
<h2 id="_idParaDest-381"><a id="_idTextAnchor581"/>Authorization server</h2>
<p>To enable the authorization server<a id="_idIndexMarker1290"/> capability, we will use <strong class="source-inline">Spring Authorization Server</strong> that offers implementations of the <strong class="bold">OAuth 2.1</strong> and <strong class="bold">OpenID Connect 1.0</strong> specifications, along with other related specifications. Leveraging Spring Security, it establishes a secure, nimble, and adaptable foundation for constructing Identity Providers compliant with <strong class="bold">OpenID Connect 1.0</strong> and <strong class="bold">OAuth2</strong> <strong class="source-inline">Authorization </strong><span class="No-Break"><strong class="source-inline">Server</strong></span><span class="No-Break"> products.</span></p>
<p>To initiate the utilization of <strong class="source-inline">Spring Authorization Server</strong>, the most straightforward approach is to build a <strong class="bold">Spring Boot</strong>-based application. You can employ <a href="http://start.spring.io">start.spring.io</a> to generate a foundational project or refer to the default authorization server sample for guidance. Subsequently, include Spring Boot’s starter for <strong class="source-inline">Spring Authorization Server</strong> as a dependency <span class="No-Break">as follow.</span></p>
<pre class="source-code">
//build.gradle
dependencies {
...
    // Spring Authorization Server
    implementation org.springframework.boot:spring-boot-starter-oauth2-authorization-server'
...
}</pre> <p class="callout-heading">Important note</p>
<p class="callout">Your code should now look <span class="No-Break">like </span><span class="No-Break"><strong class="source-inline">chapter17.00-authorization-server</strong></span><span class="No-Break">.</span></p>
<h2 id="_idParaDest-382"><a id="_idTextAnchor582"/>OAuth 2 resource minimal configuration properties</h2>
<p>Note that in<a id="_idIndexMarker1291"/> the project <strong class="source-inline">chapter17.00-calendar</strong>, we already<a id="_idIndexMarker1292"/> have added <strong class="source-inline">spring-boot-starter-oauth2-resource-server</strong> dependency, in addition to spring-security. This is important for our application in order to behave as a <span class="No-Break">resource server.</span></p>
<pre class="source-code">
//build.gradle
dependencies {
...
    // Spring Authorization Server
    implementation "org.springframework.boot:spring-boot-starter-oauth2-resource-server"
...
}</pre> <p>In a Spring Boot application, you can easily designate the authorization server to be used by following <span class="No-Break">these steps:</span></p>
<pre class="source-code">
//src/main/resources/application.yml
spring:
  security:
    oauth2:
      resourceserver:
        jwt:
          issuer-uri: http://localhost:9000</pre> <p class="callout-heading">Important note</p>
<p class="callout">The <strong class="source-inline">issuer-uri</strong> property to be effective, it’s essential that one of the following endpoints is a supported endpoint for the authorization server: <strong class="source-inline">idp.example.com/issuer/.well-known/openid-configuration</strong>, <strong class="source-inline">idp.example.com/.well-known/openid-configuration/issuer</strong>, or <strong class="source-inline">idp.example.com/.well-known/oauth-authorization-server/issuer</strong>. This endpoint is commonly referred to as either a Provider Configuration endpoint or an Authorization Server <span class="No-Break">Metadata endpoint.</span></p>
<h3>Expectations at startup</h3>
<p>When<a id="_idIndexMarker1293"/> employing this property and its associated dependencies, the Resource Server will autonomously set up its configuration to validate Bearer Tokens encoded in <span class="No-Break">JWT format.</span></p>
<p>This is accomplished through a predictable <span class="No-Break">startup sequence:</span></p>
<ol>
<li>Interrogate the Provider Configuration or Authorization Server Metadata endpoint for the <span class="No-Break"><strong class="source-inline">jwks_url</strong></span><span class="No-Break"> property.</span></li>
<li>Examine the <strong class="source-inline">jwks_url</strong> endpoint for the <span class="No-Break">supported algorithms.</span></li>
<li>Configure the validation strategy to query the <strong class="source-inline">jwks_url</strong> for valid <strong class="bold">public keys</strong> corresponding to the <span class="No-Break">identified algorithms.</span></li>
<li>Configure the validation strategy to verify the <strong class="source-inline">"iss"</strong> claim of each <strong class="bold">JWT</strong> <span class="No-Break">against </span><span class="No-Break"><strong class="source-inline">idp.example.com</strong></span><span class="No-Break">.</span></li>
</ol>
<p>An implication of this process is that the authorization server must be operational and capable of receiving requests for the Resource Server to <span class="No-Break">initialize successfully.</span></p>
<h3>Expectations during Runtime</h3>
<p>After the <a id="_idIndexMarker1294"/>application has been initiated, the <strong class="source-inline">Resource Server</strong> will endeavor to handle any request that includes an <strong class="source-inline">Authorization:</strong> <span class="No-Break"><strong class="source-inline">Bearer</strong></span><span class="No-Break"> header.</span></p>
<pre class="source-code">
GET / HTTP/1.1
Authorization: Bearer some-token-value # Resource Server will process this</pre> <p>As long as this scheme is specified, the resource server will strive to handle the request in accordance with the Bearer <span class="No-Break">Token specification.</span></p>
<p>For a properly structured <strong class="bold">JWT</strong>, the resource <span class="No-Break">server will:</span></p>
<ol>
<li>Validate its signature using a public key obtained from the <strong class="source-inline">jwks_url</strong> endpoint during startup, ensuring a match with <span class="No-Break">the </span><span class="No-Break"><strong class="bold">JWT</strong></span><span class="No-Break">.</span></li>
<li>Verify the <strong class="bold">JWT</strong>’s <strong class="bold">exp</strong> and <strong class="bold">nbf</strong> timestamps, along with the <strong class="bold">JWT</strong>’s <span class="No-Break"><strong class="bold">iss</strong></span><span class="No-Break"> claim.</span></li>
<li>Associate each scope with an authority, using the <span class="No-Break">prefix </span><span class="No-Break"><strong class="bold">SCOPE_</strong></span><span class="No-Break">.</span></li>
</ol>
<p>Spring Security will automatically update and rotate the keys used to validate <strong class="bold">JWT</strong>s as the authorization server introduces <span class="No-Break">new keys.</span></p>
<p class="callout-heading">Important note</p>
<p class="callout">Your code should now look <span class="No-Break">like </span><span class="No-Break"><strong class="source-inline">chapter17.01-calendar</strong></span><span class="No-Break">.</span></p>
<p>By default, the<a id="_idIndexMarker1295"/> resulting <strong class="source-inline">Authentication#getPrincipal</strong> is a <strong class="source-inline">Spring Security Jwt</strong> object, and if available, <strong class="source-inline">Authentication#getName</strong> corresponds to the sub property of <span class="No-Break">the </span><span class="No-Break"><strong class="bold">JWT</strong></span><span class="No-Break">.</span></p>
<p>After defining <strong class="bold">OAuth 2</strong> minimal configuration properties, we’ll elevate our configuration by examining explicit methods for defining <span class="No-Break">the </span><span class="No-Break"><strong class="source-inline">jwk-set-uri</strong></span><span class="No-Break">.</span></p>
<h2 id="_idParaDest-383"><a id="_idTextAnchor583"/>Defining the JWK Set URI for the authorization server</h2>
<p>If the <strong class="bold">authorization server</strong> lacks <a id="_idIndexMarker1296"/>support for configuration endpoints or if the <strong class="bold">r</strong><strong class="bold">esource server</strong> needs the capability to initiate startup independently of the authorization server, you can provide the <strong class="source-inline">jwk-set-uri</strong> <span class="No-Break">as follows:</span></p>
<pre class="source-code">
//src/main/resources/application.yml
spring:
  security:
    oauth2:
      resourceserver:
        jwt:
          issuer-uri: http://localhost:9000
          jwk-set-uri: http://localhost:9000/.well-known/jwks.json</pre> <p>As a <a id="_idIndexMarker1297"/>result, the <strong class="bold">resource server</strong> will refrain from contacting the authorization server during startup. Nevertheless, we continue to specify the <strong class="source-inline">issuer-uri</strong> to ensure that the resource server validates the <strong class="source-inline">"iss"</strong> claim within <span class="No-Break">incoming </span><span class="No-Break"><strong class="bold">JWT</strong></span><span class="No-Break">s.</span></p>
<h2 id="_idParaDest-384"><a id="_idTextAnchor584"/>Providing Audience Information</h2>
<p>As<a id="_idIndexMarker1298"/> demonstrated earlier, the <strong class="source-inline">issuer-uri</strong> property verifies the <strong class="source-inline">"iss"</strong> claim, identifying the entity that sent <span class="No-Break">the </span><span class="No-Break"><strong class="bold">JWT</strong></span><span class="No-Break">.</span></p>
<p>Additionally, <strong class="bold">Spring Boot</strong> includes the <strong class="source-inline">audiences</strong> property for validating the <strong class="source-inline">"aud"</strong> claim, determining the intended recipients of <span class="No-Break">the </span><span class="No-Break"><strong class="bold">JWT</strong></span><span class="No-Break">.</span></p>
<p>You can specify a resource server’s audience <span class="No-Break">as follows:</span></p>
<pre class="source-code">
//src/main/resources/application.yml
spring:
  security:
    oauth2:
      resourceserver:
        jwt:
          issuer-uri: http://localhost:9000
          audiences: https://my-org.audience</pre> <p>The outcome will be that if the <strong class="source-inline">"iss"</strong> claim of the <strong class="bold">JWT</strong> is not idp.example.com, and its <strong class="source-inline">"aud"</strong> claim does not include <strong class="source-inline">my-resource-server.example.com</strong> in its list, the validation will <span class="No-Break">not succeed.</span></p>
<h2 id="_idParaDest-385"><a id="_idTextAnchor585"/>Configuring Authorization using SecurityFilterChain</h2>
<p>A <strong class="bold">JWT</strong> generated by an <strong class="bold">OAuth 2.0</strong> <strong class="source-inline">Authorization Server</strong> will usually <a id="_idIndexMarker1299"/>contain a <strong class="source-inline">scope</strong> or <strong class="source-inline">scp</strong> attribute, signifying the granted scopes <span class="No-Break">or authorities.</span></p>
<p>In such instances, the resource server will endeavor to transform these scopes into a roster of authorized authorities, adding the <strong class="source-inline">SCOPE_</strong> string as a prefix to each scope. Consequently, to secure an endpoint or method with a scope obtained from a <strong class="bold">JWT</strong>, the associated expressions should incorporate this prefix. <span class="No-Break">For example:</span></p>
<pre class="source-code">
//src/main/java/com/packtpub/springsecurity/configuration/ SecurityConfig.java
@Bean
SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
    http
          .securityMatcher("/events/**")
          .authorizeHttpRequests(authorize -&gt; authorize
                .requestMatchers("/events/**").hasAuthority("SCOPE_events.read"))
          .oauth2ResourceServer(oauth2 -&gt; oauth2.jwt(Customizer.withDefaults()));
    return http.build();
}</pre> <p class="callout-heading">Important note</p>
<p class="callout">Your code should now look <span class="No-Break">like </span><span class="No-Break"><strong class="source-inline">chapter17.02-calendar</strong></span><span class="No-Break">.</span></p>
<p>At this point, we can start the <strong class="source-inline">chapter17.00-authorization-server</strong> and <strong class="source-inline">chapter17.02-calendar</strong> and we will be ready to send <strong class="bold">OAuth </strong><span class="No-Break"><strong class="bold">2</strong></span><span class="No-Break"> requests.</span></p>
<h2 id="_idParaDest-386"><a id="_idTextAnchor586"/>Token requests</h2>
<p>When we make the initial <a id="_idIndexMarker1300"/>token request, we should get a successful response similar to <span class="No-Break">the following:</span></p>
<pre class="source-code">
curl -i -X POST \
  http://localhost:9000/oauth2/token \
  -H 'Content-Type: application/x-www-form-urlencoded' \
  -d 'grant_type=client_credentials&amp;client_id=jbcp-calendar&amp;&amp;client_secret=secret&amp;scope=events.read'</pre> <p>And this is a <span class="No-Break">sample response:</span></p>
<pre class="source-code">
HTTP/1.1 200
Vary: Origin
Vary: Access-Control-Request-Method
Vary: Access-Control-Request-Headers
X-Content-Type-Options: nosniff
X-XSS-Protection: 0
Cache-Control: no-cache, no-store, max-age=0, must-revalidate
Pragma: no-cache
Expires: 0
X-Frame-Options: DENY
Content-Type: application/json;charset=UTF-8
Transfer-Encoding: chunked
Date: Wed, 21 Feb 2024 17:51:02 GMT
{
  "access_token": "eyJraWQiOiJjMzJjNmVlNy0yYTM5LTQ0NDY tOWQzZS02NzA2ZWJjMWM5MGUiLCJhbGciOiJSUzI1NiJ9.eyJzdWI iOiJqYmNwLWNhbGVuZGFyIiwiYXVkIjoiamJjcC1j YWxlbmRhciIsIm5iZiI6MTcwODUzNzg2Miwic2NvcGUiOlsiZX ZlbnRzLnJlYWQiXSwiaXNzIjoiaHR0cDovL2xvY2FsaG9zdDo5MD AwIiwiZXhwIjoxNzA4NTM4MTYyLCJpYXQiOjE3MDg1Mzc4NjIsImp 0aSI6ImVkNjc1YzcwLTg4MGItNDYxYy1hMDk0LTFmMTA1ZTk3OTk0 NCJ9.OWMHZC_cRqUsshwTCIIdo6oGK_KU39hY25U5YhTUU7QTi-Sm F7wy9QdDxJnl9brIXgjq7NpIeC9zZyi l81S4p7HwFP3_3iCN1NQA54vTZ0-UBfT8q6H1aEQzeEdZUDnhoYK2c oOihbYcNH_Dfn13POMcEwBhFwIsul6tJHN_lLVFBA-CTMxSHoBWBDNq NvU-gIdadOxFPDpWV86No8DfYgDGWKLP18k3KggLC37ebMbNkIMgK24gYxM_5f_g2nR_ueiV6ZQO5fyGq960nYWzePoQtdYVcvHwkQk_FG_B75rcSrITuTTgDrcA8FWrZrOoitvEOnglHmieUguoYVG2BA",
  "scope": "events.read",
  "token_type": "Bearer",
  "expires_in": 299
}</pre> <p>Specifically, we <a id="_idIndexMarker1301"/>have been granted an access token that can be used in subsequent requests. The <strong class="source-inline">access_token</strong> that will be used as <span class="No-Break">our bearer.</span></p>
<h2 id="_idParaDest-387"><a id="_idTextAnchor587"/>Endpoints requests</h2>
<p>Now we will take<a id="_idIndexMarker1302"/> the <strong class="source-inline">access_token</strong> and use that token to initiate additional requests to the server with the <span class="No-Break">following format:</span></p>
<pre class="source-code">
curl -k -i http://localhost:8080/events/  \
-H "Authorization: Bearer eyJraWQiOiJjMzJjNmVl Ny0yYTM5LTQ0NDYtOWQzZS02NzA2ZWJjMWM5MGUiLCJhbG ciOiJSUzI1NiJ9.eyJzdWIiOiJqYmNwLWNhbGVuZGFyIiwiYXVkIjoiamJjcC 1jYWxlbmRhciIsIm5iZiI6MTcwODUzNzg2Miwic2NvcGUi OlsiZXZlbnRzLnJlYWQiXSwiaXNzIjoiaHR0cDovL2xvY2 FsaG9zdDo5MDAwIiwiZXhwIjoxNzA4NTM4MTYyLCJpYXQi OjE3MDg1Mzc4NjIsImp0aSI6ImVkNjc1YzcwLTg4MGItNDY xYy1hMDk0LTFmMTA1ZTk3OTk0NCJ9.OWMHZC_cRqUsshwT CIIdo6oGK_KU39hY25U5YhTUU7QTi-SmF7wy9QdDxJnl9br IXgjq7NpIeC9zZyil81S4p7HwFP3_3iCN1NQA54vTZ0-UBf T8q6H1aEQzeEdZUDnhoYK2coOihbYcNH_Dfn13POMcEwBhF wIsul6tJHN_lLVFBA-CTMxSHoBWBDNqNvU-gIdadOxFPDpW V86No8DfYgDGWKLP18k3KggLC37ebMbNkIMgK24gYxM_5f_g2nR_ueiV6ZQO5fyGq960nYWzePoQtdYVcvHwkQk_FG_B75 rcSrITuTTgDrcA8FWrZrOoitvEOnglHmieUguoYVG2BA"</pre> <p>We should get the <span class="No-Break">following response:</span></p>
<pre class="source-code">
HTTP/1.1 200
Vary: Origin
Vary: Access-Control-Request-Method
Vary: Access-Control-Request-Headers
X-Content-Type-Options: nosniff
X-XSS-Protection: 0
Cache-Control: no-cache, no-store, max-age=0, must-revalidate
Pragma: no-cache
Expires: 0
Strict-Transport-Security: max-age=31536000 ; includeSubDomains
X-Frame-Options: DENY
Content-Type: application/json
Transfer-Encoding: chunked
Date: Wed, 21 Feb 2024 17:55:32 GMT
[
  {
    "id": 100,
    "summary": "Birthday Party",
    "description": "This is going to be a great birthday",
    "dateWhen": "2023-07-03T18:30:00.000+00:00"
  },
  {
    "id": 101,
    "summary": "Conference Call",
    "description": "Call with the client",
    "dateWhen": "2023-12-23T12:00:00.000+00:00"
  },
  {
    "id": 102,
    "summary": "Vacation",
    "description": "Paragliding in Greece",
    "dateWhen": "2023-09-14T09:30:00.000+00:00"
  }
]</pre> <h2 id="_idParaDest-388"><a id="_idTextAnchor588"/>Configuring Authorization using @PreAuthorize annotation</h2>
<p>Another way to<a id="_idIndexMarker1303"/> configure authorization can be done using <strong class="source-inline">@</strong><span class="No-Break"><strong class="source-inline">PreAuthorize</strong></span><span class="No-Break"> annotation.</span></p>
<p>First step is to enable method security <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">SecurityConfig.java</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
//src/main/java/com/packtpub/springsecurity/configuration/ SecurityConfig.java
@Configuration
@EnableWebSecurity
@EnableMethodSecurity
public class SecurityConfig {
    @Bean
    SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
       http
             .securityMatcher("/events/**")
             .oauth2ResourceServer(oauth2 -&gt; oauth2.jwt(Customizer.withDefaults()));
       return http.build();
    }
}</pre> <p>The next <a id="_idIndexMarker1304"/>step is to secure <strong class="source-inline">CalendarService.getEvents()</strong> that is invoked by the <strong class="source-inline">/</strong><span class="No-Break"><strong class="source-inline">events</strong></span><span class="No-Break"> endpoint.</span></p>
<pre class="source-code">
//src/main/java/com/packtpub/springsecurity/service/ CalendarService.java
public interface CalendarService {
...omitted for brevity
    @PreAuthorize("hasAuthority('SCOPE_events.read')")
    List&lt;Event&gt; getEvents();
...
}</pre> <p class="callout-heading">Important note</p>
<p class="callout">Your code should now look <span class="No-Break">like </span><span class="No-Break"><strong class="source-inline">chapter17.03-calendar</strong></span><span class="No-Break">.</span></p>
<p>At this point, we can start the <strong class="source-inline">chapter17.00-authorization-server</strong> and <strong class="source-inline">chapter17.03-calendar</strong> and we will be ready to send <strong class="bold">OAuth </strong><span class="No-Break"><strong class="bold">2</strong></span><span class="No-Break"> requests.</span></p>
<p>You can <a id="_idIndexMarker1305"/>try again, the same previous steps for the <strong class="source-inline">/token</strong> and <strong class="source-inline">/events</strong> <span class="No-Break">endpoints requests.</span></p>
<p>No<a id="_idTextAnchor589"/>w that we have our <strong class="source-inline">OAuth 2 server</strong> ready to issue <strong class="source-inline">access_tokens</strong> for clients, we now can create a microservices client to interact with <span class="No-Break">our system.</span></p>
<h3>Configuring the OAuth 2 client</h3>
<p>Now that we have configured our <a id="_idIndexMarker1306"/>resource server, you can create REST client to consume the <strong class="bold">OAuth2</strong> <span class="No-Break">protected resources.</span></p>
<ol>
<li>You can use https://start.spring.io/<span class="P---Regular-Char"> to initialize you project by choosing the </span><span class="No-Break"><span class="P---Regular-Char">following dependencies:</span></span></li>
</ol>
<pre class="source-code">
//build.gradle
dependencies {
...
    implementation 'org.springframework.boot:spring-boot-starter-web'
    implementation 'org.springframework.boot:spring-boot-starter-oauth2-client'
...
}</pre> <ol>
<li value="2">Next, you will need to configure your application with the client configuration <span class="No-Break">as follow:</span></li>
</ol>
<pre class="source-code">
//src/main/resources/application.yml
jbcp-calendar:
  events:
    api: http://localhost:8080/events/
spring:
## Chapter 17 Authorization Server
  security:
    oauth2:
      client:
        registration:
          calendar-client:
            client-id: jbcp-calendar
            client-secret: secret
            scope: events.read
            authorization-grant-type: client_credentials
            client-name: Calendar Client
        provider:
          calendar-client:
            token-uri: http://localhost:9000/oauth2/token
server:
  port: 8888</pre> <ol>
<li value="3">For this<a id="_idIndexMarker1307"/> example we will use <strong class="source-inline">RestTemplate</strong> and <strong class="source-inline">ClientHttpRequestInterceptor</strong><span class="P---Regular-Char"> to </span>bind the <strong class="source-inline">OAuth2AccessToken</strong><span class="P---Regular-Char"> </span>for our <span class="No-Break">REST Client.</span><p class="list-inset">Making requests to a third-party <strong class="bold">API</strong> secured with <strong class="bold">OAuth2</strong> is a fundamental scenario for <strong class="bold">OAuth2 Client</strong> usage. This involves authorizing a client, represented by the <strong class="source-inline">OAuth2AuthorizedClient</strong> class in Spring Security, and gaining access to protected resources by inserting a Bearer token into the Authorization header of an <span class="No-Break">outgoing request.</span></p><p class="list-inset">The <a id="_idIndexMarker1308"/>provided example sets up the application to function as an <strong class="bold">OAuth2</strong> Client with the ability to request protected resources from a <span class="No-Break">third-party </span><span class="No-Break"><strong class="bold">API</strong></span><span class="No-Break">.</span></p></li>
</ol>
<pre class="source-code">
//src/main/java/com/packtpub/springsecurity/config/SecurityConfig.java
@Configuration
public class SecurityConfig {
    @Bean
    SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
       http
             .oauth2Client(withDefaults());
       return http.build();
    }
    @Bean
    public RestTemplate oauth2RestTemplate(OAuth2HttpRequestInterceptor oAuth2HttpRequestInterceptor) {
       RestTemplate restTemplate = new RestTemplate();
       List&lt;ClientHttpRequestInterceptor&gt; interceptors = restTemplate.getInterceptors();
       if (CollectionUtils.isEmpty(interceptors)) {
          interceptors = new ArrayList&lt;&gt;();
       }
       interceptors.add(oAuth2HttpRequestInterceptor);
       restTemplate.setInterceptors(interceptors);
       return restTemplate;
    }
}</pre> <ol>
<li value="4">The <a id="_idIndexMarker1309"/>following <strong class="source-inline">OAuth2HttpRequestInterceptor</strong><span class="P---Regular-Char"> can be defined as described in the </span><span class="No-Break"><span class="P---Regular-Char">sample code:</span></span></li>
</ol>
<pre class="source-code">
//src/main/java/com/packtpub/springsecurity/config/OAuth2HttpRequestInterceptor.java
@Component
public class OAuth2HttpRequestInterceptor implements ClientHttpRequestInterceptor {
    private final OAuth2AuthorizedClientManager authorizedClientManager;
    private final ClientRegistrationRepository clientRegistrationRepository;
    public OAuth2HttpRequestInterceptor(OAuth2AuthorizedClientManager authorizedClientManager, ClientRegistrationRepository clientRegistrationRepository) {
       this.authorizedClientManager = authorizedClientManager;
       this.clientRegistrationRepository = clientRegistrationRepository;
    }
    @Override
    public ClientHttpResponse intercept(HttpRequest request, byte[] body, ClientHttpRequestExecution execution) throws IOException {
       ClientRegistration clientRegistration = clientRegistrationRepository.findByRegistrationId("calendar-client");
       OAuth2AuthorizeRequest oAuth2AuthorizeRequest = OAuth2AuthorizeRequest
             .withClientRegistrationId(clientRegistration.getRegistrationId())
             .principal(clientRegistration.getClientId())
             .build();
       OAuth2AuthorizedClient client = authorizedClientManager.authorize(oAuth2AuthorizeRequest);
       String accessToken = client.getAccessToken().getTokenValue();
       request.getHeaders().setBearerAuth(accessToken);
       return execution.execute(request, body);
    }
}</pre> <ol>
<li value="5">The <a id="_idIndexMarker1310"/>last step is to make the <strong class="bold">REST API</strong> call using the configured <strong class="bold">OAuth2</strong> <span class="No-Break"><strong class="source-inline">RestTemplate</strong></span><span class="No-Break"> Bean:</span></li>
</ol>
<pre class="source-code">
//src/main/java/com/packtpub/springsecurity/web/controllers/OAuth2RestClient.java
@RestController
public class OAuth2RestClient {
    private final RestTemplate oauth2RestTemplate  ;
    public OAuth2RestClient(RestTemplate oauth2RestTemplate) {
       this.oauth2RestTemplate = oauth2RestTemplate;
    }
    @Value("${jbcp-calendar.events.api}")
    private String eventsApi;
    @GetMapping("/")
    public  String apiCheck() {
       return oauth2RestTemplate.getForObject(eventsApi, String.class);
    }
}</pre> <p>We now <a id="_idIndexMarker1311"/>should have the same codebase for a <span class="No-Break">client application.</span></p>
<p class="callout-heading">Important note</p>
<p class="callout">Your code should now look <span class="No-Break">like </span><span class="No-Break"><strong class="source-inline">chapter17.03-calendar-client</strong></span><span class="No-Break">.</span></p>
<p>We need to ensure that the <strong class="source-inline">chapter17.03-calendar</strong> and <strong class="source-inline">chapter17.00-authorization-server</strong> applications are running and ready to take <strong class="bold">OAuth 2</strong><strong class="bold"> </strong>requests <span class="No-Break">from clients.</span></p>
<p>We can<a id="_idIndexMarker1312"/> then start the <strong class="source-inline">chapter17.03-calendar-client</strong> application, which will expose a RESTful endpoint that will call our resource server to access the configured events located at <strong class="source-inline">/events</strong> on the remote resource, and will return the following result by <span class="No-Break">running </span><span class="No-Break"><strong class="source-inline">http://localhost:8888/</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
[
  {
    "id":100,
    "summary":"Birthday Party",
    "description":"This is going to be a great birthday",
    "dateWhen":"2023-07-03T18:30:00.000+00:00"
  },
  {
    "id":101,
    "summary":"Conference Call",
    "description":"Call with the client",
    "dateWhen":"2023-12-23T12:00:00.000+00:00"
  },
  {
    "id":102,
    "summary":"Vacation",
    "description":"Paragliding in Greece",
    "dateWhen":"2023-09-14T09:30:00.000+00:00"
  }
]</pre> <h1 id="_idParaDest-389"><a id="_idTextAnchor590"/>Summary</h1>
<p>In this chapter, you learned the general difference between monolithic applications and <strong class="bold">microservices</strong> and compared <strong class="bold">SOA</strong> with <strong class="bold">microservices</strong>. You also learned the conceptual architecture of <strong class="bold">OAuth 2</strong> and how it provides your services with trustworthy client access, and learned about the types of <strong class="bold">OAuth 2</strong> access tokens and the types of <strong class="bold">OAuth 2 client </strong><span class="No-Break"><strong class="bold">credentials</strong></span><span class="No-Break"> types.</span></p>
<p>We examined the <strong class="bold">JWT</strong> and their general structure, implemented a <strong class="bold">resource server</strong> and <strong class="bold">authorization server</strong> used to grant access rights to clients to access <strong class="bold">OAuth 2</strong><strong class="bold"> </strong>resources, and implemented a <strong class="bold">RESTful</strong> client to gain access to resources through an <strong class="bold">OAuth 2 </strong><span class="No-Break"><strong class="bold">grant flow</strong></span><span class="No-Break">.</span></p>
<p>We’ve concluded by demonstrating a practical <strong class="bold">OAuth 2</strong> example implementation using spring-security. Moving forward, the next chapter will explore the integration with <strong class="bold">Central Authentication Service</strong> (<strong class="bold">CAS</strong>) to enable <strong class="bold">Single Sign-On</strong> (<strong class="bold">SSO</strong>) and <strong class="bold">Single Logout</strong> (<strong class="bold">SLO</strong>) functionalities for your Spring <span class="No-Break">Security-enabled applications.</span></p>
</div>
</div></body></html>