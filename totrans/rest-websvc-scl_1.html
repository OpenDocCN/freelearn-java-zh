<html><head></head><body>
<div id="page" style="height:0pt"/><div class="book" title="Chapter&#xA0;1.&#xA0;Getting Started with RESTful Web Services"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch01" class="calibre1"/>Chapter 1. Getting Started with RESTful Web Services</h1></div></div></div><p class="calibre7">Welcome to this book on how to create REST services with Scala. In this book, I'll introduce a couple of different Scala-based frameworks and show you how to create a RESTful service with them. Each of these frameworks has its own specific way of creating REST services; some are more functional, while others provide a rich <span class="strong"><strong class="calibre8">domain-specific language</strong></span> (<span class="strong"><strong class="calibre8">DSL</strong></span>). After reading this book and working through the examples, you'll be<a id="id0" class="calibre1"/> able to choose the approach that best suits you and your specific problem.</p><p class="calibre7">In this book, the following Scala frameworks will be discussed:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong class="calibre8">Akka HTTP / DSL</strong></span>: Akka HTTP is a new REST framework built on top of Akka Streams. It<a id="id1" class="calibre1"/> provides a DSL-based approach based on Spray. Spray is one of the best-known REST frameworks in the Scala world, and the newest version will run on top of Akka HTTP. We'll explore the features of this DSL and show you how it can be used to create a REST service.</li><li class="listitem"><span class="strong"><strong class="calibre8">Unfiltered</strong></span>: Unfiltered is a little REST framework which provides a very structured<a id="id2" class="calibre1"/> approach of creating REST services. This framework provides direct access to all parts of the HTTP request, and doesn't make assumptions on how you want to process REST services. This gives you complete control of how the request is processed and the response is produced.</li><li class="listitem"><span class="strong"><strong class="calibre8">Play 2</strong></span>: Play 2 is<a id="id3" class="calibre1"/> one of the most popular Scala frameworks, which provides functionality to create complete web applications. Play 2 also provides great support for creating standard REST services. We'll focus on the REST-specific features of Play 2.</li><li class="listitem"><span class="strong"><strong class="calibre8">Finagle</strong></span> and <span class="strong"><strong class="calibre8">Finch</strong></span>: Finagle and Finch both come from the people at Twitter. With <a id="id4" class="calibre1"/>Finagle and Finch, it is possible to create REST services using a clean, functional programming approach.</li><li class="listitem"><span class="strong"><strong class="calibre8">Scalatra</strong></span>: The <a id="id5" class="calibre1"/>last framework we'll discuss is the Scalatra framework. Scalatra is a lightweight framework, based on the better-known Sinatra framework, with which it is very easy to create REST services.</li></ul></div><p class="calibre7">Besides these frameworks, in the last chapter of this book we'll also provide some guidelines on how to work with advanced topics such as HATEOAS, linking, and JSON processing.</p><p class="calibre7">In this first chapter, we are not going to explore a framework, but we'll use this chapter to introduce some concepts and set up some tools:</p><div class="book"><ul class="itemizedlist"><li class="listitem">We'll first have to make sure you can run all the examples provided with this book, so we'll show you how to get the code and setup SBT and an IDE</li><li class="listitem">We'll also do a short introduction into what RESTful services are</li><li class="listitem">And finally, we'll have a look at the API of the service that we'll implement using the different Scala frameworks</li></ul></div><p class="calibre7">There are many different definitions of REST, so before we look into the technical details, let's first look at the definition of REST we'll use in this book.</p></div>

<div class="book" title="Chapter&#xA0;1.&#xA0;Getting Started with RESTful Web Services">
<div class="book" title="Introduction to the REST framework"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch01lvl1sec08" class="calibre1"/>Introduction to the REST framework</h1></div></div></div><p class="calibre7">In<a id="id6" class="calibre1"/> this book, when we talk about REST, we talk about REST as<a id="id7" class="calibre1"/> described in the dissertation of Roy Fielding (<a class="calibre1" href="https://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm">https://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm</a>). Basically, REST is a software architecture style, which, when following the guidelines, can be used to create performant, reliable, and maintainable services. To better understand what REST is, it is a good idea to start with the constraints a service must follow to be RESTful. In <a id="id8" class="calibre1"/>his dissertation, Roy Fielding defines the following set of constraints:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong class="calibre8">Client-server</strong></span>: This constraint means that clients and servers are separated from each <a id="id9" class="calibre1"/>other through a standardized interface. The advantage of this approach is that clients don't need to worry about persistency, databases, messaging, scalability, and other server-side concepts; instead, they can focus on user-oriented functionality. Another advantage is that clients and servers can be developed independently since the only dependency between them is the standardized contract. Note that if you require a very strict contract between the client and the server, a WSDL/SOAP-based service might be a better option than going for a RESTful approach.</li><li class="listitem"><span class="strong"><strong class="calibre8">Stateless</strong></span>: Besides having a separate client and server, communication between<a id="id10" class="calibre1"/> these two components will have to be stateless. This means that each request the client sends should contain all the information necessary for the server. Note that for authentication, the server can temporarily store some session/user information in a persistent store, but all the real application state should be stored at the client. The big advantage of this approach is that this way it is very easy to scale out the servers horizontally by just adding more instances.</li><li class="listitem"><span class="strong"><strong class="calibre8">Cacheable</strong></span>: In a RESTful architecture, clients are allowed to cache responses. It is up to the server side to indicate which responses might be cached and for how long. The goal of this constraint is to minimize interactions <a id="id11" class="calibre1"/>between the client and the server by <a id="id12" class="calibre1"/>avoiding sending requests, whose response will stay the same. This, of course, improves performance at the client side and reduces bandwidth.</li><li class="listitem"><span class="strong"><strong class="calibre8">Layered system</strong></span>: This constraint describes that in a RESTful architecture, it is possible<a id="id13" class="calibre1"/> to create a layered system, where each layer has its own specific functionality. For instance, in between the client and the server, there might be a firewall, a load balancer, a reverse proxy, and so on. The client, however, doesn't notice these different layers.</li><li class="listitem"><span class="strong"><strong class="calibre8">Uniform interface</strong></span>: From all the constraints, this is perhaps the most interesting <a id="id14" class="calibre1"/>one. This constraint defines what a uniform interface (the contract between the client and the server) should look similar to. This constraint itself consists of the following four sections:<div class="book"><ul class="itemizedlist1"><li class="listitem"><span class="strong"><strong class="calibre8">Identification of resources</strong></span>: In requests, each resource should be uniquely identified. Most often, this is done through a form of URI. Note that the technical representation of a resource doesn't matter. A resource, identified through a URI, can be represented in JSON, CSV, XML, and PDF while still remaining the same resource.</li><li class="listitem"><span class="strong"><strong class="calibre8">Manipulation of resources through these representations</strong></span>: When a client has a representation of a resource (for example, a JSON message), the client can modify this resource by updating the representation and sending it to the server.</li><li class="listitem"><span class="strong"><strong class="calibre8">Self-descriptive messages</strong></span>: Each message sent between the client and the server should be self-descriptive. The client need not know anything else to be able to parse and process the message. It should be able to learn from the message exactly what it can do with the resource.</li><li class="listitem"><span class="strong"><strong class="calibre8">Hypermedia as the engine of application state</strong></span>: This constraint, also called <span class="strong"><strong class="calibre8">HATEOAS</strong></span>, implies that a user of an API doesn't <a id="id15" class="calibre1"/>need to know beforehand what it can do with a specific resource. Through the use of links in the resource and the definition of media-types, a client can explore and learn the actions it can take on a resource.</li><li class="listitem"><span class="strong"><strong class="calibre8">Code on demand</strong></span>: Code on demand is the only constraint that is optional. When comparing this constraint with the others, it is also <a id="id16" class="calibre1"/>one that is a bit different than the others. The idea behind this constraint is that servers could temporarily extend the functionality of clients by transferring executable code. In practice, this constraint is not seen that often though; most RESTful services deal with sending static responses, not executable code.</li></ul></div></li></ul></div><p class="calibre7">It's important to note that these constraints don't say anything about an implementation technology.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="tip02" class="calibre1"/>Tip</h3><p class="calibre7">Often, when talking about REST, people immediately focus on HTTP and JSON. A RESTful architecture doesn't force you to adopt these technologies. On the other hand, most often, RESTful architectures are implemented on top of HTTP and currently use JSON as the message format. In this book, we will also focus on using HTTP and JSON to implement RESTful services.</p></div><p class="calibre7">The constraints mentioned here give an overview of how a service should act to be considered RESTful. However, when creating a service, it is often very hard to comply with all these constraints, and in some cases, not all the constraints might be that useful, or might be very hard to implement. Many people noticed this, and a couple of years ago, a more<a id="id17" class="calibre1"/> pragmatic view on REST was presented by Richardson's Maturity Model (<a class="calibre1" href="http://martinfowler.com/articles/richardsonMaturityModel.html">http://martinfowler.com/articles/richardsonMaturityModel.html</a>).</p><p class="calibre7">In Richardson's Maturity Model, you don't have to follow all the constraints to be considered RESTful; instead, a number of levels of maturity are defined that indicate how RESTful your service is. The higher the level, the more mature your service is, which will result in a more maintainable, more scalable, and easier-to-use service. This model defines the following levels:</p><div class="mediaobject"><img src="../images/00002.jpeg" alt="Introduction to the REST framework" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre7">The levels<a id="id18" class="calibre1"/> are described like this:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Level 0 describes the situation where you just send XML or JSON objects to a single HTTP endpoint. Basically, you're not doing REST, but you're doing RPC over HTTP.</li><li class="listitem">Level 1 tackles the question of handling complexity by using divide and conquer, breaking a large service endpoint down into multiple resources</li><li class="listitem">Level 2 introduces a standard set of verbs so that we can handle similar situations in the same way, removing unnecessary variation</li><li class="listitem">Level 3 introduces discoverability, providing a way of making a protocol more self-documenting</li></ul></div><p class="calibre7">In this book, we'll mostly focus on supporting REST at Level 2. So, we'll work with well-defined resources and use the appropriate HTTP verbs to indicate what we want to do with a resource.</p><p class="calibre7">In <a class="calibre1" title="Chapter 7. JSON, HATEOAS, and Documentation" href="part0053_split_000.html#page">Chapter 7</a>, <span class="strong"><em class="calibre9">JSON, HATEOAS, and Documentation</em></span>, of this book, we'll address HATEOAS, which can help us reach maturity Level 3.</p><p class="calibre7">Now that we've got the theory out of the way, let's get the code, set up your favorite IDE, and define the API for the REST service we'll implement.</p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Getting the source code"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch01lvl1sec09" class="calibre1"/>Getting the source code</h1></div></div></div><p class="calibre7">There <a id="id19" class="calibre1"/>are a couple of different ways of getting the code for this<a id="id20" class="calibre1"/> book. We provide a download link at the book's website (<a class="calibre1" href="https://www.packtpub.com/books/content/support/23321">https://www.packtpub.com/books/content/support/23321</a>) from where you can download a ZIP file with the latest sources from GitHub (<a class="calibre1" href="https://github.com/josdirksen/rest-with-scala/archive/master.zip">https://github.com/josdirksen/rest-with-scala/archive/master.zip</a>), or even better, just<a id="id21" class="calibre1"/> use Git to clone the source repository.</p></div>

<div class="book" title="Getting the source code">
<div class="book" title="Downloading the ZIP file"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch01lvl2sec07" class="calibre1"/>Downloading the ZIP file</h2></div></div></div><p class="calibre7">If you've <a id="id22" class="calibre1"/>downloaded the ZIP file, just unzip it to a directory of your choice:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre8">Joss-MacBook-Pro:Downloads jos$ unzip rest-with-scala-master.zip</strong></span>
</pre></div></div></div>

<div class="book" title="Getting the source code">
<div class="book" title="Using Git to clone the repository"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch01lvl2sec08" class="calibre1"/>Using Git to clone the repository</h2></div></div></div><p class="calibre7">Cloning <a id="id23" class="calibre1"/>the repository is also very easy if you've already <a id="id24" class="calibre1"/>got Git installed. If you haven't got Git installed, follow<a id="id25" class="calibre1"/> the instructions at <a class="calibre1" href="https://git-scm.com/book/en/v2/Getting-Started-Installing-Git">https://git-scm.com/book/en/v2/Getting-Started-Installing-Git</a>.</p><p class="calibre7">Once Git is installed, just run the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre8">Joss-MacBook-Pro:git jos$ git clone https://github.com/josdirksen/rest-with-scala</strong></span>
<span class="strong"><strong class="calibre8">Cloning into 'rest-with-scala'...</strong></span>
<span class="strong"><strong class="calibre8">remote: Counting objects: 4, done.</strong></span>
<span class="strong"><strong class="calibre8">remote: Compressing objects: 100% (3/3), done.</strong></span>
<span class="strong"><strong class="calibre8">remote: Total 4 (delta 0), reused 0 (delta 0), pack-reused 0</strong></span>
<span class="strong"><strong class="calibre8">Unpacking objects: 100% (4/4), done.</strong></span>
<span class="strong"><strong class="calibre8">Checking connectivity... done.</strong></span>
</pre></div><p class="calibre7">At this point, you've got the sources in a directory of your choice. Next, we need to make sure we can download all the frameworks' dependencies and run the samples. For this, we'll use SBT (more information can be found at <a class="calibre1" href="http://www.scala-sbt.org/">http://www.scala-sbt.org/</a>), which is the most common build tool for Scala-based projects.</p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Setting up Scala and SBT to run the examples"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch01lvl1sec10" class="calibre1"/>Setting up Scala and SBT to run the examples</h1></div></div></div><p class="calibre7">To<a id="id26" class="calibre1"/> run the examples provided in this book, we need to install Scala and SBT. Depending on your operating system, different steps need to be taken.</p></div>

<div class="book" title="Setting up Scala and SBT to run the examples">
<div class="book" title="Installing Java"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch01lvl2sec09" class="calibre1"/>Installing Java</h2></div></div></div><p class="calibre7">Before<a id="id27" class="calibre1"/> we can install SBT and Scala, we first need to install Java. Scala requires at least a Java Runtime version of 1.6 or higher. If you haven't installed Java on<a id="id28" class="calibre1"/> your system yet, follow the instructions at <a class="calibre1" href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html">http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html</a>.</p></div></div>

<div class="book" title="Setting up Scala and SBT to run the examples">
<div class="book" title="Installing Scala and SBT"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch01lvl2sec10" class="calibre1"/>Installing Scala and SBT</h2></div></div></div><p class="calibre7">Once <a id="id29" class="calibre1"/>you have Java installed, installing Scala and SBT is just as easy. To install Scala, just go to <a class="calibre1" href="http://www.scala-lang.org/download/">http://www.scala-lang.org/download/</a> and download <a id="id30" class="calibre1"/>the binaries for your system. To install SBT, you can follow the instructions at <a class="calibre1" href="http://www.scala-sbt.org/download.html">http://www.scala-sbt.org/download.html</a>.</p><p class="calibre7">To check whether everything is installed, run the following commands in a terminal:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre8">Joss-MacBook-Pro:~ jos$ java -version</strong></span>
<span class="strong"><strong class="calibre8">java version "1.8.0_40"</strong></span>
<span class="strong"><strong class="calibre8">Java(TM) SE Runtime Environment (build 1.8.0_40-b27)</strong></span>
<span class="strong"><strong class="calibre8">Java HotSpot(TM) 64-Bit Server VM (build 25.40-b25, mixed mode)</strong></span>
<span class="strong"><strong class="calibre8">Joss-MacBook-Pro:~ jos$ scala -version</strong></span>
<span class="strong"><strong class="calibre8">Scala code runner version 2.11.6 -- Copyright 2002-2013, LAMP/EPFL</strong></span>
<span class="strong"><strong class="calibre8">Joss-MacBook-Pro:~ jos$ sbt -v</strong></span>
<span class="strong"><strong class="calibre8">[process_args] java_version = '1.8.0_40'</strong></span>
<span class="strong"><strong class="calibre8"># Executing command line:</strong></span>
<span class="strong"><strong class="calibre8">java</strong></span>
<span class="strong"><strong class="calibre8">-Xms1024m</strong></span>
<span class="strong"><strong class="calibre8">-Xmx1024m</strong></span>
<span class="strong"><strong class="calibre8">-XX:ReservedCodeCacheSize=128m</strong></span>
<span class="strong"><strong class="calibre8">-XX:MaxMetaspaceSize=256m</strong></span>
<span class="strong"><strong class="calibre8">-jar</strong></span>
<span class="strong"><strong class="calibre8">/usr/local/Cellar/sbt/0.13.8/libexec/sbt-launch.jar</strong></span>

<span class="strong"><strong class="calibre8">[info] Set current project to jos (in build file:/Users/jos/)</strong></span>
</pre></div><p class="calibre7">To exit SBT, hit <span class="strong"><em class="calibre9">Ctrl</em></span> + <span class="strong"><em class="calibre9">C</em></span>.</p></div></div>

<div class="book" title="Setting up Scala and SBT to run the examples">
<div class="book" title="Running the examples"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch01lvl2sec11" class="calibre1"/>Running the examples</h2></div></div></div><p class="calibre7">Now<a id="id31" class="calibre1"/> that you've got Java, Scala, and SBT installed, we can run the examples. You can, of course, run the examples from your IDE (see the next section on how to set up IntelliJ IDEA and Eclipse), but often, using SBT directly is just as easy. To run the examples, take the following steps:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Open a terminal and go to the directory where you've extracted the source ZIP file or cloned the repository.</li><li class="listitem" value="2">To test the configuration, we've created a simple <code class="email">HelloWorld</code> example. From the console, execute <code class="email">sbt runCH01-HelloWorld</code>:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre8">Joss-MacBook-Pro:rest-with-scala jos$ sbt runCH01-HelloWorld</strong></span>
<span class="strong"><strong class="calibre8">[info] Loading project definition from /Users/jos/dev/git/rest-with-scala/project</strong></span>
<span class="strong"><strong class="calibre8">[info] Set current project to rest-with-scala (in build file:/Users/jos/dev/git/rest-with-scala/)</strong></span>
<span class="strong"><strong class="calibre8">[info] Compiling 2 Scala sources to /Users/jos/dev/git/rest-with-scala/chapter-01/target/scala-2.11/classes...</strong></span>
<span class="strong"><strong class="calibre8">[info] Running org.restwithscala.chapter1.HelloWorld</strong></span>
<span class="strong"><strong class="calibre8">SBT successfully ran HelloWorld, configuration seems ok!</strong></span>
<span class="strong"><strong class="calibre8">Press &lt;enter&gt; to exit.</strong></span>

<span class="strong"><strong class="calibre8">[success] Total time: 18 s, completed Jun 13, 2015 2:34:41 PM</strong></span>
<span class="strong"><strong class="calibre8">Joss-MacBook-Pro:rest-with-scala jos$</strong></span>
</pre></div></li><li class="listitem" value="3">You<a id="id32" class="calibre1"/> might see a lot of output when the various dependencies are loaded, but after a while, you should see the message, <code class="email">SBT successfully ran HelloWorld, configuration seems ok!</code>.</li><li class="listitem" value="4">All the examples in this book wait for user input to terminate. So, once you're done playing around with the example, just hit <span class="strong"><em class="calibre9">Enter</em></span> to terminate the running program.</li></ol><div class="calibre13"/></div><p class="calibre7">In each chapter, we'll see the <code class="email">sbt</code> command we need to execute. If you want to know all the examples you can run, you can also run the <code class="email">sbt</code> <code class="email">alias</code> command, which generates the following output:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre8">Joss-MacBook-Pro:rest-with-scala jos$ sbt alias</strong></span>
<span class="strong"><strong class="calibre8">[info] Loading project definition from /Users/jos/dev/git/rest-with-scala/project</strong></span>
<span class="strong"><strong class="calibre8">[info] Set current project to rest-with-scala (in build file:/Users/jos/dev/git/rest-with-scala/)</strong></span>
<span class="strong"><strong class="calibre8">        runCH01-HelloWorld = ; chapter01/runCH01HelloWorld</strong></span>
<span class="strong"><strong class="calibre8">        runCH01-EchoServer = ; chapter01/runCH01EchoServer</strong></span>
</pre></div><p class="calibre7">Besides running the examples directly from the command line, it is also possible to run them from an IDE. In the following section, we'll see how to import the examples in IntelliJ IDEA and Eclipse.</p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Setting up the IDE"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch01lvl1sec11" class="calibre1"/>Setting up the IDE</h1></div></div></div><p class="calibre7">With <a id="id33" class="calibre1"/>SBT and Scala installed, you have everything you need to run the examples. Sometimes, however, it is easier to play around and experiment with the examples directly from an IDE. The two most popular IDEs for working with Scala are IntelliJ IDEA and Eclipse. Both have great Scala plugins and excellent support for SBT.</p></div>

<div class="book" title="Setting up the IDE">
<div class="book" title="Setting up IntelliJ IDEA"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch01lvl2sec12" class="calibre1"/>Setting up IntelliJ IDEA</h2></div></div></div><p class="calibre7">IntelliJ provides<a id="id34" class="calibre1"/> a community and a commercial version of its IDE, both of which can be used to run and play around with the examples in this book. The following steps are shown for the community edition, but can be applied in the same manner<a id="id35" class="calibre1"/> for the commercial variant:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">The first thing to do is download the IDE. You can download a version for your OS from <a class="calibre1" href="https://www.jetbrains.com/idea/download/">https://www.jetbrains.com/idea/download/</a>. Once downloaded, run the installer and start the IDE. When you run IntelliJ for the first time, you're asked whether you want to install the featured plugins. Scala is one of them:<div class="mediaobject"><img src="../images/00003.jpeg" alt="Setting up IntelliJ IDEA" class="calibre10"/></div><p class="calibre14"> </p></li><li class="listitem" value="2">From here, click on <span class="strong"><strong class="calibre8">Install</strong></span> below the <span class="strong"><strong class="calibre8">Scala</strong></span> column to install Scala support in IntelliJ. After installing, click on <span class="strong"><strong class="calibre8">Start using IntelliJ IDEA</strong></span>. After IntelliJ is started, you're shown a screen where you can import an existing project:<div class="mediaobject"><img src="../images/00004.jpeg" alt="Setting up IntelliJ IDEA" class="calibre10"/></div><p class="calibre14"> </p></li><li class="listitem" value="3">From <a id="id36" class="calibre1"/>here, select <span class="strong"><strong class="calibre8">Import Project</strong></span>, and on the screen that opens, navigate to the directory where we extracted the downloaded sources, select that directory, and click on <span class="strong"><strong class="calibre8">OK</strong></span>. On the screen that opens, select the <span class="strong"><strong class="calibre8">Import Project from external model</strong></span> radio button and next, select <span class="strong"><strong class="calibre8">SBT</strong></span>.<div class="mediaobject"><img src="../images/00005.jpeg" alt="Setting up IntelliJ IDEA" class="calibre10"/></div><p class="calibre14"> </p></li><li class="listitem" value="4">Now <a id="id37" class="calibre1"/>click on <span class="strong"><strong class="calibre8">Next</strong></span> and fill in the screen that opens:<div class="book"><ol class="orderedlist1"><li class="listitem" value="1">Check the <span class="strong"><strong class="calibre8">Download sources and docs</strong></span> checkbox.</li><li class="listitem" value="2">For <span class="strong"><strong class="calibre8">Project SDK</strong></span>, click on <span class="strong"><strong class="calibre8">New</strong></span>, select <span class="strong"><strong class="calibre8">JDK</strong></span>, and navigate to the directory where you installed the JDK 1.8.</li><li class="listitem" value="3">And finally, click on <span class="strong"><strong class="calibre8">Finish</strong></span>.</li></ol><div class="calibre13"/></div></li></ol><div class="calibre13"/></div><p class="calibre7">IntelliJ will now import all the projects and download all the required dependencies. Once done, you're shown a screen like this, where you see all the projects and can run the examples directly from the IDE:</p><div class="mediaobject"><img src="../images/00006.jpeg" alt="Setting up IntelliJ IDEA" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre7">An <a id="id38" class="calibre1"/>alternative to using IntelliJ IDEA with great Scala support is Eclipse.</p></div></div>

<div class="book" title="Setting up the IDE">
<div class="book" title="Setting up Eclipse"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch01lvl2sec13" class="calibre1"/>Setting up Eclipse</h2></div></div></div><p class="calibre7">The Scala <a id="id39" class="calibre1"/>community provides a packaged version of Eclipse that contains everything you need for developing Scala.</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">To<a id="id40" class="calibre1"/> install this version of Eclipse, first download the version for your OS from their download site at <a class="calibre1" href="http://scala-ide.org/download/sdk.html">http://scala-ide.org/download/sdk.html</a>.</li><li class="listitem" value="2">Once downloaded, extract the archive to a directory of your choice, start Eclipse, and select a location to store your file. Once started, you'll see an empty editor:<div class="mediaobject"><img src="../images/00007.jpeg" alt="Setting up Eclipse" class="calibre10"/></div><p class="calibre14"> </p></li><li class="listitem" value="3">Before <a id="id41" class="calibre1"/>we can import the project, we must first create the required Eclipse project configuration. To do this, open a terminal and navigate to the directory where you extracted or cloned the sources. From that directory, run <code class="email">sbt eclipse</code>:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre8">Joss-MacBook-Pro:rest-with-scala jos$ sbt eclipse</strong></span>
<span class="strong"><strong class="calibre8">[info] Loading project definition from /Users/jos/dev/git/rest-with-scala/project</strong></span>
<span class="strong"><strong class="calibre8">[info] Updating {file:/Users/jos/dev/git/rest-with-scala/project/}rest-with-scala-build...</strong></span>
<span class="strong"><strong class="calibre8">[info] Resolving org.fusesource.jansi#jansi;1.4 ...</strong></span>
<span class="strong"><strong class="calibre8">[info] Done updating.</strong></span>
<span class="strong"><strong class="calibre8">[info] Set current project to rest-with-scala (in build file:/Users/jos/dev/git/rest-with-scala/)</strong></span>
<span class="strong"><strong class="calibre8">[info] About to create Eclipse project files for your project(s).</strong></span>
<span class="strong"><strong class="calibre8">[info] Successfully created Eclipse project files for project(s):</strong></span>
<span class="strong"><strong class="calibre8">[info] chapter-01</strong></span>
</pre></div></li><li class="listitem" value="4">Now we<a id="id42" class="calibre1"/> can import the project. Go to <span class="strong"><strong class="calibre8">File</strong></span> | <span class="strong"><strong class="calibre8">Import</strong></span> from the menu and choose to import <span class="strong"><strong class="calibre8">Existing projects into Workspace</strong></span>. On the next screen, select the directory with the sources as the root directory, and Eclipse should show you all the projects:<div class="mediaobject"><img src="../images/00008.jpeg" alt="Setting up Eclipse" class="calibre10"/></div><p class="calibre14"> </p></li><li class="listitem" value="5">Now click on <span class="strong"><strong class="calibre8">Finish</strong></span>, and the projects will be imported. Now you can edit and run the samples directly from Eclipse.<div class="mediaobject"><img src="../images/00009.jpeg" alt="Setting up Eclipse" class="calibre10"/></div><p class="calibre14"> </p></li></ol><div class="calibre13"/></div></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Testing the REST API"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch01lvl1sec12" class="calibre1"/>Testing the REST API</h1></div></div></div><p class="calibre7">Before <a id="id43" class="calibre1"/>we look at the API of the service we're going to create, we'll have a quick look at how to test your REST API. We can, of course, create a REST client in Scala and use that, but since a big advantage of REST services is that they can be read and understood by humans, we'll use a simple browser-based (Chrome in this case) REST client <a id="id44" class="calibre1"/>called <span class="strong"><strong class="calibre8">Postman</strong></span>. Note that you can, of course, also use different REST clients. The reason we chose Postman is that with Postman, it is easy to create different kinds of <a id="id45" class="calibre1"/>request; it has HATEOAS support and also allows us to share requests, so you don't have to make them by hand.</p></div>

<div class="book" title="Testing the REST API">
<div class="book" title="Installing Postman"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch01lvl2sec14" class="calibre1"/>Installing Postman</h2></div></div></div><p class="calibre7">Postman <a id="id46" class="calibre1"/>runs as a Chrome plugin, so to use this REST client, you need to <a id="id47" class="calibre1"/>use Chrome. Once you've started Chrome, open the URL, <a class="calibre1" href="https://chrome.google.com/webstore/detail/postman-rest-client/fdmmgilgnpjigdojojpjoooidkmcomcm?hl=en">https://chrome.google.com/webstore/detail/postman-rest-client/fdmmgilgnpjigdojojpjoooidkmcomcm?hl=en</a> in your browser (or just search on Google for Chrome Postman).</p><div class="informalexample" title="Note"><h3 class="title2"><a id="tip03" class="calibre1"/>Tip</h3><p class="calibre7">Note that there are two versions of Postman: a simple Chrome plugin, which, at the time of writing, is version 0.8.4.14, and a Chrome app, which currently is at version 3.0.0.6. For this book, we'll use the simpler Chrome plugin, so make sure you install 0.8.4.14 in your browser.</p></div><p class="calibre7">Once installed, open up this app by going to <code class="email">chrome://apps</code> and selecting the application or clicking on the newly added button at the top-right of your screen. When you open this plugin, you should see the following window:</p><div class="mediaobject"><img src="../images/00010.jpeg" alt="Installing Postman" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre7">One <a id="id48" class="calibre1"/>interesting aspect of Postman is that you can very easily share REST queries. In the sources for this chapter, you can find a directory called <code class="email">common</code>.</p></div></div>

<div class="book" title="Testing the REST API">
<div class="book" title="Importing request collection"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch01lvl2sec15" class="calibre1"/>Importing request collection</h2></div></div></div><p class="calibre7">In this <a id="id49" class="calibre1"/>directory, there are a number of files which contain the <a id="id50" class="calibre1"/>requests for each individual chapter. For instance, for this chapter, these are contained in the file, <code class="email">ch01_requests.json</code>. Each file contains a number of requests that you can use to test the REST frameworks in this book. To import all these requests, take the following steps:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1"> On the left-hand side of the screen, click on the <span class="strong"><strong class="calibre8">Collections</strong></span> tab.</li><li class="listitem" value="2">To the right of this tab, two icons pop up. Click on the right icon, which is called <span class="strong"><strong class="calibre8">import collection</strong></span>.</li><li class="listitem" value="3">On the screen that pops up, click on choose files, navigate to the <code class="email">common</code> directory, and select all the <code class="email">ch0#_requests.json</code> files and open them.</li></ol><div class="calibre13"/></div><p class="calibre7">Now, you'll have<a id="id51" class="calibre1"/> a number of collections, one for each<a id="id52" class="calibre1"/> chapter, where you can find sample requests for the different chapters.</p><div class="mediaobject"><img src="../images/00011.jpeg" alt="Importing request collection" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre7">To run a request, just click on a collection. This will show all the requests for that chapter. Click on a request. Now clicking on the <span class="strong"><strong class="calibre8">Send</strong></span> button will send the request to the server. In the upcoming chapters, we will see which request you can use to test the functionality of a specific Scala REST framework.</p></div></div>

<div class="book" title="Testing the REST API">
<div class="book" title="Testing the REST service"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch01lvl2sec16" class="calibre1"/>Testing the REST service</h2></div></div></div><p class="calibre7">At this<a id="id53" class="calibre1"/> point, we've got Scala and SBT installed, and can use Postman as the REST client. The final step is to see whether everything is working correctly. For this, we'll start a very simple HTTP service, which echoes back a specific request parameter.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="tip04" class="calibre1"/>Tip</h3><p class="calibre7">For this example, we've <a id="id54" class="calibre1"/>used HTTP4S. This is a basic HTTP server that allows you to quickly create HTTP services. If you're interested, you can find more information about this library at <a class="calibre1" href="http://http4s.org/">http://http4s.org/</a>. The source code for our simple echo service can be found in the <code class="email">chapter-01/src/main/scala</code> directory.</p></div><p class="calibre7">To run this<a id="id55" class="calibre1"/> example, we need to take a couple of steps:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">First, open a console window and go to the directory where you downloaded and extracted the sources or cloned the Git repository.</li><li class="listitem" value="2">From that directory, run the <code class="email">sbt runCH01-EchoServer</code> command. This will start up the echo service:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre8">Joss-MacBook-Pro:rest-with-scala jos$ sbt runCH01-EchoServer</strong></span>
<span class="strong"><strong class="calibre8">[info] Loading project definition from /Users/jos/dev/git/rest-with-scala/project</strong></span>
<span class="strong"><strong class="calibre8">[info] Set current project to rest-with-scala (in build file:/Users/jos/dev/git/rest-with-scala/)</strong></span>
<span class="strong"><strong class="calibre8">[info] Running org.restwithscala.chapter1.EchoService</strong></span>
<span class="strong"><strong class="calibre8">11:31:24.624 [run-main-0] DEBUG o.http4s.blaze.channel.ServerChannel - Starting server loop on new thread</strong></span>
<span class="strong"><strong class="calibre8">Server available on port 8080</strong></span>
</pre></div><div class="note" title="Note"><h3 class="title2"><a id="tip05" class="calibre1"/>Tip</h3><p class="calibre7"><span class="strong"><strong class="calibre8">Downloading the example code</strong></span></p><p class="calibre7">You can download the example code files from your account at <a class="calibre1" href="http://www.packtpub.com">http://www.packtpub.com</a> for all the Packt Publishing books you have purchased. If you purchased this book elsewhere, you can visit <a class="calibre1" href="http://www.packtpub.com/support">http://www.packtpub.com/support</a> and register to have the files e-mailed directly to you.</p></div></li><li class="listitem" value="3">Now that we've got a server running, open up your Chrome browser, and from there, open Postman (remember, either use the added button or the <code class="email">chrome://apps</code> URL). In the list of collections, click on the request labeled <span class="strong"><strong class="calibre8">Echo 'hello'</strong></span>. This will open the request. You can now run this request by clicking on the <span class="strong"><strong class="calibre8">Send</strong></span> button. The result, if everything is configured correctly, will be something like this:<div class="mediaobject"><img src="../images/00012.jpeg" alt="Testing the REST service" class="calibre10"/></div><p class="calibre14"> </p></li><li class="listitem" value="4">By <a id="id56" class="calibre1"/>changing the value of the <code class="email">msg request</code> parameter, you can test that the server is really echoing the user's input.</li><li class="listitem" value="5">There are a couple of other requests in this collection that show some features of our current server. You can check what happens when the request parameter is omitted and when a call is made to an unknown URL.</li></ol><div class="calibre13"/></div><p class="calibre7">At this point, the only thing left to do in this chapter is to look at the API we'll create using the different frameworks outlined in the upcoming chapters.</p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="The REST service and model"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch01lvl1sec13" class="calibre1"/>The REST service and model</h1></div></div></div><p class="calibre7">To show <a id="id57" class="calibre1"/>the features of the various frameworks in this book and how they solve problems in a different manner, we'll define a simple API, which we'll implement with the REST frameworks. For this book, we'll implement a simple to-do list API.</p></div>

<div class="book" title="The REST service and model">
<div class="book" title="API description"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch01lvl2sec17" class="calibre1"/>API description</h2></div></div></div><p class="calibre7">We want to create a RESTful API, so the most important part is to start with the description<a id="id58" class="calibre1"/> of the resources that can be managed through this API. For this API, we define the following resources:</p><div class="informalexample"><table border="1" class="calibre15"><colgroup class="calibre16"><col class="calibre17"/><col class="calibre17"/></colgroup><thead class="calibre18"><tr class="calibre19"><th valign="bottom" class="calibre20">
<p class="calibre21">Entity</p>
</th><th valign="bottom" class="calibre20">
<p class="calibre21">Description</p>
</th></tr></thead><tbody class="calibre22"><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21">Task</p>
</td><td valign="top" class="calibre23">
<p class="calibre21">A task is something that needs to be done. The JSON for a task looks similar to this:</p>
<div class="informalexample1"><pre class="programlisting1">{
  "id": long,
  "title": string,
  "content": string,
  "notes": [noteList],
  "status": Status,
     "assignedTo": Person,
}</pre></div>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21">Project</p>
</td><td valign="top" class="calibre23">
<p class="calibre21">A project will allow us to group tasks together, and by assigning persons to a project, we can determine who can work on a specific task:</p>
<div class="informalexample1"><pre class="programlisting1">{
  "id": string,
  "title": string,
  "tasks": [task],
  "members": [person],
  "updated": datetime
}</pre></div>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21">Person</p>
</td><td valign="top" class="calibre23">
 <p class="calibre21">A person is someone who can work on a task and when done, close the task. A person can only work on those tasks to which he is assigned, or when he is part of the project to which a task belongs:</p>
<div class="informalexample1"><pre class="programlisting1">{
  "id": string,
  "name": string
}</pre></div>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21">Note</p>
</td><td valign="top" class="calibre23">
<p class="calibre21">Notes can be added to tasks to provide additional information on how the task should be performed:</p>
<div class="informalexample1"><pre class="programlisting1">{
  "id": string,
  "text": string,
}</pre></div>
</td></tr></tbody></table></div><p class="calibre7">Without going into too much detail here, we want to support approximately the following functionality in our API:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong class="calibre8">CRUD functionality</strong></span>: We want to support some basic CRUD operations. It should be <a id="id59" class="calibre1"/>possible to perform the following actions:<div class="book"><ul class="itemizedlist1"><li class="listitem">Create, update, and delete a new task, project, person, and note.</li><li class="listitem">Get a<a id="id60" class="calibre1"/> list of tasks, projects, persons, and notes.</li><li class="listitem">Search through a list of tasks.</li><li class="listitem">Add a note to a task. It should also be possible to update and delete the existing notes.</li></ul></div></li><li class="listitem"><span class="strong"><strong class="calibre8">Advanced functions</strong></span>: Besides the standard CRUD-like functionality, we also want to<a id="id61" class="calibre1"/> provide some more advanced features:<div class="book"><ul class="itemizedlist1"><li class="listitem">Assign a task to a specific project</li><li class="listitem">Assign a person to a task</li><li class="listitem">Assign a person to a project</li><li class="listitem">Move a task from one project to another</li></ul></div></li></ul></div><p class="calibre7">Note that we won't implement all the functionality for each framework. We'll mainly use this API to explain how we can use the various REST frameworks.</p></div></div>
<div class="book" title="Summary"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch01lvl1sec14" class="calibre1"/>Summary</h1></div></div></div><p class="calibre7">That's it for the first chapter. In this chapter, we introduced what REST is, and which level of the Robertsons Maturity Model we'll be aiming at (Level 2). We'll explain HATEOAS in the final chapter. At this point, you should have Scala and SBT installed, and should be able to run all the examples in this book using SBT and test them using the supplied requests in Postman. We also saw how to use IDEs to play around with the code. And finally, we introduced the high-level API that we'll implement in the upcoming chapters.</p><p class="calibre7">In the next chapter, we'll dive into the first of the Scala frameworks we'll explore. The first one is Finch, which is a REST library on top of the networking library, Finagle. Both of these were initially created by Twitter.</p></div></body></html>