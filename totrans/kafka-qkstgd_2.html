<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Message Validation</h1>
                </header>
            
            <article>
                
<p><a href="0bde3875-cd30-435c-9b32-b96fccb2e6d0.xhtml" target="_blank">Chapter 1</a>, <em>Configuring Kafka</em>, focused on how to set up a Kafka cluster and run a command-line producer and a consumer. Having the event producer, we now have to process those events.</p>
<p>Before going into detail, let's present our case study. We need to model the systems of Monedero, a fictional company whose core business is cryptocurrency exchange. Monedero wants to base its IT infrastructure on an <strong>enterprise service bus</strong> (<strong>ESB</strong>) built with Apache Kafka. The Monedero IT department wants to unify the service backbone across the organization. Monedero also has worldwide, web-based, and mobile-app-based <span>clients</span>, so a real-time response is fundamental.</p>
<p>Online customers w<span>orldwide </span>browse the Monedero website to exchange their cryptocurrencies. There are a lot of use cases that customers can perform in Monedero, but this example is focused on the part of the exchange workflow specifically from the web application.</p>
<p>This chapter covers the following topics:</p>
<ul>
<li>Modeling the messages in JSON format</li>
<li>Setting up a Kafka project with Gradle</li>
<li>Reading from Kafka with a Java client</li>
<li>Writing to Kafka with a Java client</li>
<li>Running a processing engine pipeline</li>
<li>Coding a <kbd>Validator</kbd> in Java</li>
<li>Running the validation</li>
</ul>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Enterprise service bus in a nutshell</h1>
                </header>
            
            <article>
                
<p>Event processing consists of taking one or more events from an event stream and applying actions over those events. In general, in an enterprise service bus, there are commodity services; the most common are the following:</p>
<ul>
<li>Data transformation</li>
<li>Event handling</li>
<li>Protocol conversion</li>
<li>Data mapping</li>
</ul>
<p>Message processing in the majority of cases involves the following:</p>
<ul>
<li>Message structure validation against a message schema</li>
<li>Given an event stream, filtering the messages from the stream</li>
<li>Message enrichment with additional data</li>
<li>Message aggregation (composition) from two or more message to produce a new message</li>
</ul>
<p>This chapter is about event validation. The chapters that follow are about composition and enrichment.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Event modeling</h1>
                </header>
            
            <article>
                
<p>The first step in event modeling is to express the event in English in the following form:</p>
<p>Subject-verb-direct object</p>
<p>For this example, we are modeling the event <em>customer consults the ETH price</em>:</p>
<ul>
<li>The subject in this sentence is <em>customer</em>, a noun in nominative case. The subject is the entity performing the action.</li>
<li>The verb in this sentence is <em>consults</em>; it describes the action performed by the subject.</li>
<li>The direct object in this sentence is <em>ETH price</em>. The object is the entity in which the action is being done.</li>
</ul>
<p class="mce-root"/>
<p class="mce-root"/>
<p>We can represent our message in several message formats (<span>covered in other sections of this book)</span>:</p>
<ul>
<li><strong><span>JavaScript Object Notation</span></strong> (<strong><span>JSON</span></strong>)</li>
<li>Apache Avro</li>
<li>Apache Thrift</li>
<li>Protocol Buffers</li>
</ul>
<p>JSON is easily read and written by both humans and machines. For example, we could chose binary as the representation, but it has a rigid format and it was not designed for humans to read it; as counterweight, binary representation is very fast and lightweight in processing.</p>
<p class="mce-root"><em>Listing 2.1</em>, shows the representation of the <kbd>CUSTOMER_CONSULTS_ETHPRICE</kbd> event in JSON format:</p>
<pre>{<br/>  "event": "CUSTOMER_CONSULTS_ETHPRICE",<br/>   "customer": {<br/>         "id": "14862768",<br/>         "name": "Snowden, Edward",<br/>         "ipAddress": "95.31.18.111"<br/>   },<br/>   "currency": {<br/>         "name": "ethereum",<br/>         "price": "RUB"<br/>   },<br/>   "timestamp": "2018-09-28T09:09:09Z"<br/>}</pre>
<div class="packt_figref CDPAlignCenter CDPAlign">Listing 2.1: <span>customer_consults_ETHprice.json</span></div>
<p>For this example, the <strong>Ethereum</strong> (<strong>ETH</strong>) currency price is expressed in <strong><span>Russian rouble</span></strong> (<strong><span>RUB</span></strong>). This JSON message has four sections:</p>
<ul>
<li><kbd>event</kbd>: This is a string with the event's name.</li>
<li><kbd>customer</kbd>: This represents the person (in this case its <kbd>id</kbd> is <kbd>14862768</kbd>) consulting the Ethereum price. In this representation, there is a unique id for the customer, the name, and the browser <kbd>ipAddress</kbd>, which is the IP address of the computer the customer is logged on.</li>
<li><kbd>currency</kbd>: This contains the cryptocurrency name and the currency in which the price is expressed.</li>
<li><kbd>timestamp</kbd>: The timestamp in which the customer made the request (UTC).</li>
</ul>
<p class="mce-root"/>
<p>From another perspective, the message has two parts: the metadataâ€”this is the event name and the timestamp and two business entities, the customer and the currency. As we can see, this message can be read and understood by a human.</p>
<p>Other messages from the same use case in JSON format could be as follows:</p>
<pre>{ "event": "CUSTOMER_CONSULTS_ETHPRICE",<br/>   "customer": {<br/>         "id": "13548310",<br/>         "name": "Assange, Julian",<br/>         "ipAddress": "185.86.151.11"<br/>   },<br/>   "currency": {<br/>         "name": "ethereum",<br/>         "price": "EUR"<br/>   },<br/>   "timestamp": "2018-09-28T08:08:14Z"<br/>}</pre>
<p>This is another example:</p>
<pre>{ "event": "CUSTOMER_CONSULTS_ETHPRICE",<br/>   "customer": {<br/>         "id": "15887564",<br/>         "name": "Mills, Lindsay",<br/>         "ipAddress": "186.46.129.15"<br/>   },<br/>   "currency": {<br/>         "name": "ethereum",<br/>         "price": "USD"<br/>   },<br/>   "timestamp": "2018-09-28T19:51:35Z"<br/>}</pre>
<p>What happens if we want to represent our message in the Avro schema? Yes, the Avro schema of our message (note that it's not the message, but the schema) is in <em>Listing 2.2</em>:</p>
<pre>{ "name": "customer_consults_ethprice",<br/>  "namespace": "monedero.avro",<br/>  "type": "record",<br/>  "fields": [<br/>    { "name": "event", "type": "string" },<br/>    { "name": "customer",<br/>      "type": {<br/>          "name": "id", "type": "long",<br/>          "name": "name", "type": "string",<br/>          "name": "ipAddress", "type": "string"<br/>      }<br/>    },<br/>    { "name": "currency",<br/>      "type": {<br/>          "name": "name", "type": "string",<br/>          "name": "price", "type": {<br/>          "type": "enum", "namespace": "monedero.avro",<br/>            "name": "priceEnum", "symbols": ["USD", "EUR", "RUB"]}<br/>      }<br/>    },<br/>    { "name": "timestamp", "type": "long",<br/>      "logicalType": "timestamp-millis"<br/>    }<br/>  ]<br/>}</pre>
<div class="packt_figref CDPAlignCenter CDPAlign"><span>Listing 2.2: customer_consults_ethprice.avsc</span></div>
<p>For more information about the Avro schema, check the Apache Avro specification:</p>
<p><a href="https://avro.apache.org/docs/1.8.2/spec.html">https://avro.apache.org/docs/1.8.2/spec.html</a></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Setting up the project</h1>
                </header>
            
            <article>
                
<p>This time, we are going to build our project with Gradle. The first step is to download and install Gradle from <a href="http://www.gradle.org/downloads">http://www.gradle.org/downloads</a>.</p>
<p>Gradle only requires a Java JDK (version 7 or higher).</p>
<p>macOS users can install Gradle with the <kbd>brew</kbd> command, as follows:</p>
<pre><strong>$ brew update &amp;&amp; brew install gradle</strong></pre>
<p>The output is something like the following:</p>
<pre><strong>==&gt; Downloading https://services.gradle.org/distributions/gradle-4.10.2-all.zip</strong><br/><strong>==&gt; Downloading from https://downloads.gradle.org/distributions/gradle-4.10.2-al</strong><br/><strong>######################################################################## 100.0%</strong><br/><strong>  /usr/local/Cellar/gradle/4.10.2: 203 files, 83.7MB, built in 59 seconds</strong></pre>
<p>Linux users can install Gradle with the <kbd>apt-get</kbd> command, as follows:</p>
<pre><strong>$ apt-get install gradle</strong></pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Unix users can install with sdkman, a tool for managing parallel versions of most Unix-based systems, as follows:</p>
<pre><strong>$ sdk install gradle 4.3</strong></pre>
<p>To check that Gradle is installed correctly, type the following:</p>
<pre><strong>$ gradle -v</strong></pre>
<p>The output is something like the following:</p>
<pre><strong>------------------------------------------------------------</strong><br/><strong>Gradle 4.10.2</strong><br/><strong>------------------------------------------------------------</strong></pre>
<p>The first step is to create a directory called <kbd>monedero</kbd> and, from that directory, execute the following:</p>
<pre><strong>$ gradle init --type java-library</strong></pre>
<p>The output is something like the following:</p>
<pre><strong>...</strong><br/><strong>BUILD SUCCESSFUL</strong><br/><strong>...</strong></pre>
<p>Gradle generates a skeleton project inside the directory. The directory should be similar to the following:</p>
<ul>
<li><kbd>- build.gradle</kbd></li>
<li><kbd>- gradle</kbd></li>
<li><kbd>-- wrapper</kbd></li>
<li><kbd>--- gradle-wrapper.jar</kbd></li>
<li><kbd>--- gradle-vreapper.properties</kbd></li>
<li><kbd>- gradlew</kbd></li>
<li><kbd>- gradle.bat</kbd></li>
<li><kbd>- settings.gradle</kbd></li>
<li><kbd>- src</kbd></li>
<li><kbd>-- main</kbd></li>
<li><kbd>--- java</kbd></li>
<li><kbd>----- Library.java</kbd></li>
<li><kbd>-- test</kbd></li>
<li><kbd>--- java</kbd></li>
<li><kbd>----- LibraryTest.java</kbd></li>
</ul>
<p>The two Java files, <kbd>Library.java</kbd> and <kbd>LibraryTest.java</kbd>, can be deleted.</p>
<p>Now, modify the Gradle build file called <kbd>build.gradle</kbd>, and replace it with <em>Listing 2.3</em>:</p>
<pre>apply plugin: 'java'<br/>apply plugin: 'application'<br/>sourceCompatibility = '1.8'<br/>mainClassName = 'monedero.ProcessingEngine'<br/>repositories {<br/> mavenCentral()<br/>}<br/>version = '0.1.0'<br/>dependencies {<br/> compile group: 'org.apache.kafka', name: 'kafka_2.12', version: '2.0.0'<br/> compile group: 'com.fasterxml.jackson.core', name: 'jackson-core', version: '2.9.7'<br/>}<br/>jar {<br/> manifest {<br/> attributes 'Main-Class': mainClassName<br/> } from {<br/> configurations.compile.collect {<br/> it.isDirectory() ? it : zipTree(it)<br/> }<br/> }<br/> exclude "META-INF/*.SF"<br/> exclude "META-INF/*.DSA"<br/> exclude "META-INF/*.RSA"<br/>}</pre>
<div class="packt_figref CDPAlignCenter CDPAlign"><span>Listing 2.3: </span>ProcessingEngine<span> Gradle build file</span></div>
<p>This file shows the library dependencies for the engine:</p>
<ul>
<li><kbd>kafka_2.12</kbd>, are the dependencies for Apache Kafka</li>
<li><kbd>jackson-databind</kbd> is the library for JSON parsing and manipulation</li>
</ul>
<p>To compile the sources and download the required libraries, type the command:</p>
<pre><strong>$ gradle compileJava</strong></pre>
<p>The output is something like the following:</p>
<pre><strong>...</strong><br/><strong>BUILD SUCCESSFUL</strong><br/><strong>...</strong></pre>
<p>The project can be created with Maven or SBT, even from an IDE (IntelliJ, Eclipse, Netbeans). But for simplicity here, it was created with Gradle.</p>
<p>For more information about the build tools, visit the following links:</p>
<ul>
<li>Gradle's main page: <a href="http://www.gradle.org">http://www.gradle.org</a></li>
<li>Maven's main page: <a href="http://maven.apache.org">http://maven.apache.org</a></li>
<li>SBT's main page: <a href="http://www.scala-sbt.org/">http://www.scala-sbt.org/</a></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Reading from Kafka</h1>
                </header>
            
            <article>
                
<p>Now that we have our project skeleton, let's recall the project requirements for the stream processing engine. Remember that our event customer consults ETH price occurs outside Monedero and that these messages may not be well formed, that is, they may have defects. The first step in our pipeline is to validate that the input events have the correct data and the correct structure. Our project will be called <kbd>ProcessingEngine</kbd>.</p>
<p>The <kbd>ProcessingEngine</kbd> specification shall create a pipeline application that does the following:</p>
<ul>
<li>Reads each message from a Kafka topic called <strong>input-messages</strong></li>
<li>Validates each message, sending any invalid event to a specific Kafka topic called <strong>invalid-messages</strong></li>
<li>Writes the correct messages in a Kafka topic called <strong>valid-messages</strong></li>
</ul>
<p>These steps are detailed in <em>Figure 2.1</em>, the first sketch for the pipeline processing engine:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/aa921a59-34d9-4f98-9348-28e924f796e0.png" style=""/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 2.1: The processing engine reads events from the input-messages topic, validates the messages, and routes the defective ones to invalid-messages topic and the correct ones to valid-messages topic</div>
<p>The processing engine stream construction has two phases:</p>
<ul>
<li>Create a simple Kafka worker that reads from the <strong>input-messages</strong> topic in Kafka and writes the events to another topic</li>
<li>Modify the Kafka worker to make the validation</li>
</ul>
<p>So, let's proceed with the first step. Build a Kafka worker that reads individual raw messages from the  <strong>input-messages</strong> <span>topic</span>. We say in the Kafka jargon that a consumer is needed. If you recall, in the first chapter we built a command-line producer to write events to a topic and a command-line consumer to read the events from that topic. Now, we will code the same consumer in Java.</p>
<p>For our project, a consumer is a Java interface that contains all of the necessary behavior for all classes that implement consumers.</p>
<p class="mce-root"/>
<p>Create a file called <kbd>Consumer.java</kbd> in the <kbd>src/main/java/monedero/</kbd> <span>directory </span>with the content of <em>Listing 2.4</em>:<span><br/></span></p>
<pre>package monedero;<br/>import java.util.Properties;<br/>public interface Consumer {<br/>  static Properties createConfig(String servers, String groupId) {<br/>    Properties config = new Properties();<br/>    config.put("bootstrap.servers", servers);<br/>    config.put("group.id", groupId);<br/>    config.put("enable.auto.commit", "true");<br/>    config.put("auto.commit.interval.ms", "1000");<br/>    config.put("auto.offset.reset", "earliest");<br/>    config.put("session.timeout.ms", "30000");<br/>    config.put("key.deserializer",<br/>        "org.apache.kafka.common.serialization.StringDeserializer");<br/>    config.put("value.deserializer",<br/>        "org.apache.kafka.common.serialization.StringDeserializer");<br/>    return config;<br/>  }<br/>}</pre>
<div class="CDPAlignCenter CDPAlign packt_figref"><span>Listing 2.4: Consumer.java</span></div>
<p>The consumer interface encapsulates the common behavior of the Kafka consumers. The consumer interface has the <kbd>createConfig</kbd><span> method </span>that sets all of the properties needed by all of the Kafka consumers. Note that the deserializers are of the <kbd>StringDeserializer</kbd> <span>type </span>because the Kafka consumer reads Kafka key-value records where the value are of the type string.</p>
<p>Now, create a file called <kbd>Reader.java</kbd> in the <kbd>src/main/java/monedero/</kbd> <span>directory </span>with the content of <em>Listing 2.5</em>:</p>
<pre>package monedero;<br/>import org.apache.kafka.clients.consumer.ConsumerRecord;<br/>import org.apache.kafka.clients.consumer.ConsumerRecords;<br/>import org.apache.kafka.clients.consumer.KafkaConsumer;<br/>import java.time.Duration;<br/>import java.util.Collections;<br/>class Reader implements Consumer {<br/>  private final KafkaConsumer&lt;String, String&gt; consumer;//1<br/>  private final String topic;<br/>  Reader(String servers, String groupId, String topic) {<br/>    this.consumer =<br/>        new KafkaConsumer&lt;&gt;(Consumer.createConfig(servers, groupId));<br/>    this.topic = topic;<br/>  }<br/>  void run(Producer producer) {<br/>    this.consumer.subscribe(Collections.singletonList(this.topic));//2<br/><em>   </em> while (true) {//3<br/>      ConsumerRecords&lt;String, String&gt; records = consumer.poll(Duration.ofMillis(100));  //4<br/>      for (ConsumerRecord&lt;String, String&gt; record : records) {<br/>producer.process(record.value());//5<br/>      }<br/>    }<br/>  }<br/>}</pre>
<div class="CDPAlignCenter CDPAlign packt_figref"><span>Listing 2.5: Reader.java</span></div>
<p>The <kbd>Reader</kbd> class implements the consumer interface. So, <kbd>Reader</kbd> is a Kafka consumer:</p>
<ul>
<li>In line <kbd>//1</kbd>, <kbd>&lt;String, String&gt;</kbd> says that <kbd>KafkaConsumer</kbd> reads Kafka records where the key and value are both of the type string</li>
<li>In line <kbd>//2</kbd>, the consumer subscribes to the Kafka topic specified in its constructor</li>
<li>In line <kbd>//3</kbd>, there is a <kbd>while(true)</kbd> infinite loop for demonstrative purposes; in practice, we need to deal with more robust code maybe, implementing <kbd>Runnable</kbd></li>
<li>In line <kbd>//4</kbd>, this consumer will be pooling data from the specified topics every 100 milliseconds</li>
<li>In line <kbd>//5</kbd>, the consumer sends the message to be processed by the producer</li>
</ul>
<p>This consumer reads all of the messages from the specified Kafka topic and sends them to the process method of the specified producer. All of the configuration properties are specified in the consumer interface, but specifically the <kbd>groupId</kbd> property is important because it associates the consumer with a specific consumer group.</p>
<p>The consumer group is useful when we need to share the topic's events across all of the group's members. Consumer groups are also used to group or isolate different instances.</p>
<p>To read more about the Kafka Consumer API, follow this link: <a href="https://kafka.apache.org/20/javadoc/org/apache/kafka/clients/consumer/KafkaConsumer.html">https://kafka.apache.org/20/javadoc/org/apache/kafka/clients/consumer/KafkaConsumer.html/</a></p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Writing to Kafka</h1>
                </header>
            
            <article>
                
<p>Our <kbd>Reader</kbd> invokes the <kbd>process()</kbd> <span>method; </span>this method belonging to the <kbd>Producer</kbd> class. As with the consumer interface, the producer interface encapsulates all of the common behavior of the <span>Kafka producers</span>. The two producers in this chapter implement this producer interface.</p>
<p>In a file called <kbd>Producer.java</kbd>, located in the <kbd>src/main/java/monedero</kbd> directory, copy the content of <em>Listing 2.6</em>:</p>
<pre>package monedero;<br/>import java.util.Properties;<br/>import org.apache.kafka.clients.producer.KafkaProducer;<br/>import org.apache.kafka.clients.producer.ProducerRecord;<br/>public interface Producer {<br/>  void process(String message);                                 //1<br/>  static void write(KafkaProducer&lt;String, String&gt; producer,<br/>                    String topic, String message) {             //2<br/>    ProducerRecord&lt;String, String&gt; pr = new ProducerRecord&lt;&gt;(topic, message);<br/>    producer.send(pr);<br/>  }<br/>  static Properties createConfig(String servers) {              //3<br/>    Properties config = new Properties();<br/>    config.put("bootstrap.servers", servers);<br/>    config.put("acks", "all");<br/>    config.put("retries", 0);<br/>    config.put("batch.size", 1000);<br/>    config.put("linger.ms", 1);<br/>    config.put("key.serializer",<br/>"org.apache.kafka.common.serialization.StringSerializer");<br/>config.put("value.serializer",<br/>        "org.apache.kafka.common.serialization.StringSerializer"); <br/>         return config;<br/>}<br/>}</pre>
<div class="CDPAlignCenter CDPAlign packt_figref"> <span><span>Listing 2.6: Producer.java</span></span></div>
<p>The producer interface has the following observations:</p>
<ul>
<li>An abstract method called process invoked in the <kbd>Reader</kbd> class</li>
<li>A static method called write that sends a message to the producer in the specified topic</li>
<li>A static method called <kbd>createConfig</kbd>, where it sets all of the properties required for a generic producer</li>
</ul>
<p>As with the consumer interface, an implementation of the producer interface is needed. In this first version, we just pass the incoming messages to another topic without modifying the messages. The implementation code is in <em>Listing 2.7</em> and should be saved in a file called <kbd>Writer.java</kbd> in the <kbd>src/main/java/m</kbd><span> directory.</span></p>
<p>The following is the content of <em>Listing 2.7</em>, <span> </span><kbd>Writer.java</kbd><span>:</span></p>
<pre>package monedero;<br/>import org.apache.kafka.clients.producer.KafkaProducer;<br/>public class Writer implements Producer {<br/>  private final KafkaProducer&lt;String, String&gt; producer;<br/>  private final String topic;<br/>  Writer(String servers, String topic) {<br/>    this.producer = new KafkaProducer&lt;&gt;(<br/>        Producer.createConfig(servers));//1<br/>    this.topic = topic;<br/>  }<br/>  @Override<br/>  public void process(String message) {<br/>    Producer.write(this.producer, this.topic, message);//2<br/>  }<br/>}</pre>
<div class="CDPAlignCenter CDPAlign packt_figref"><span>Listing 2.7: Writer.java</span></div>
<p>In this implementation of the <kbd>Producer</kbd> <span>class, we see the following: </span></p>
<ul>
<li>The <kbd>createConfig</kbd> method is invoked to set the necessary properties from the producer interface</li>
<li>The process method writes each incoming message in the output topic. As the message arrives from the topic, it is sent to the target topic</li>
</ul>
<p>This producer implementation is very simple; it doesn't modify, validate, or enrich the messages. It just writes them to the output topic.</p>
<p class="mce-root"/>
<p>To read more about the Kafka producer API, follow this link:</p>
<p><a href="https://kafka.apache.org/0110/javadoc/index.html?org/apache/kafka/clients/consumer/KafkaProducer.html">https://kafka.apache.org/0110/javadoc/index.html?org/apache/kafka/clients/consumer/KafkaProducer.html</a></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Running the processing engine</h1>
                </header>
            
            <article>
                
<p>The <kbd>ProcessingEngine</kbd> class coordinates the <kbd>Reader</kbd> and <kbd>Writer</kbd> classes. It contains the main method to coordinate them. Create a new file called <kbd>ProcessingEngine.java</kbd> in the <kbd>src/main/java/monedero/</kbd> <span>directory </span>and copy therein the code in <em>Listing 2.8</em>.</p>
<p><span>The following is the content of <em>Listing 2.8</em>, </span><kbd>ProcessingEngine.java</kbd><span>:</span></p>
<pre>package monedero;<br/>public class ProcessingEngine {<br/>  public static void main(String[] args) {<br/>    String servers = args[0];<br/>    String groupId = args[1];<br/>    String sourceTopic = args[2];<br/>    String targetTopic = args[3];<br/>    Reader reader = new Reader(servers, groupId, sourceTopic);<br/>    Writer writer = new Writer(servers, targetTopic);<br/>    reader.run(writer);<br/>  }<br/>}</pre>
<div class="CDPAlignCenter CDPAlign packt_figref"><span>Listing 2.8: ProcessingEngine.java</span></div>
<p><kbd>ProcessingEngine</kbd> receives four arguments from the command line:</p>
<ul>
<li><kbd>args[0]</kbd> <kbd>servers</kbd>, the host and port of the Kafka broker</li>
<li><kbd>args[1]</kbd> <kbd>groupId</kbd>, the consumer group of the consumer</li>
<li><kbd>args[2]</kbd> <kbd>sourceTopic</kbd>, <kbd>inputTopic</kbd> where <kbd>Reader</kbd> reads from</li>
<li><kbd>args[3]</kbd> <kbd>targetTopic</kbd>, <kbd>outputTopic</kbd> where <kbd>Writer</kbd> writes to</li>
</ul>
<p>To build the project, run this command from the <kbd>monedero</kbd> directory:</p>
<pre><strong>$ gradle jar</strong></pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>If everything is OK, the output is something like the following:</p>
<pre><strong>...</strong><br/><strong>BUILD SUCCESSFUL</strong><br/><strong>...</strong></pre>
<p>To run the project, we need to open three different <span>command-line</span> windows. <em>Figure 2.2</em> shows what the <span>command-line</span> windows should look:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/3a54e6f9-9d05-4ca0-9b0d-1d65736f1f7c.jpg" style=""/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 2.2: The three terminal windows to test the processing engine including message producer, message consumer, and the application itself</div>
<ol>
<li>In the first <span>command-line</span> terminal, move to the <kbd>Confluent</kbd> directory and start it, as follows:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ bin/confluent start</strong></pre>
<ol start="2">
<li>Once the control center (Zookeeper and Kafka included) is running in the same <span>command-line</span> terminal, generate the two necessary topics, as follows:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ bin/kafka-topics --create --zookeeper localhost:2181 --replication-factor 1 --</strong><strong>partitions 1 --topic input-topic</strong><br/><br/><span><strong>$ bin/kafka-topics --create --zookeeper localhost:2181 --replication-factor 1 --</strong><strong>partitions 1 --topic output-topic</strong></span></pre>
<p style="padding-left: 60px">Recall, to display the topics running in our cluster type, use the following:</p>
<pre style="padding-left: 60px"><strong>$ bin/kafka-topics --list --zookeeper localhost:2181</strong></pre>
<p style="padding-left: 60px">If you had a mistyping error, to delete some topic (just in case), type the following:</p>
<pre style="padding-left: 60px"><strong>$ bin/kafka-topics --delete --zookeeper localhost:2181 --topic <br/>unWantedTopic</strong></pre>
<ol start="3">
<li>In the same command-line terminal, start the console producer running the <kbd>input-topic</kbd> topic, as follows:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ bin/kafka-console-producer --broker-list localhost:9092 --topic <br/>input-topic</strong></pre>
<p style="padding-left: 60px">This window is where the input messages are typed.</p>
<ol start="4">
<li>In the second command-line terminal, start a console consumer listening to<span> <kbd>output-topic</kbd></span><span> by typing the following: </span></li>
</ol>
<pre style="padding-left: 60px"><strong>$ bin/kafka-console-consumer --bootstrap-server localhost:9092 --<br/>from-beginning --topic output-topic</strong></pre>
<ol start="5">
<li>In the third command-line terminal, start the processing engine. Go to the project root directory where the <kbd>gradle jar</kbd> command was executed and run, as follows:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ java -jar ./build/libs/monedero-0.1.0.jar localhost:9092 foo <br/>input-topic output-topic</strong></pre>
<p>Now, the show consists in reading all of the events from <kbd>input-topic</kbd> and writing them in <kbd>output-topic</kbd>.</p>
<p>Go to the first command-line terminal (the message producer) and send the following three messages (remember to type enter between messages and execute each one in just one line):</p>
<pre><strong>{"event": "CUSTOMER_CONSULTS_ETHPRICE", "customer": {"id": "14862768", "name": "Snowden, Edward", "ipAddress": "95.31.18.111"}, "currency": {"name": "ethereum", "price": "RUB"}, "timestamp": "2018-09-28T09:09:09Z"}</strong><br/><br/><strong>{"event": "CUSTOMER_CONSULTS_ETHPRICE", "customer": {"id": "13548310", "name": "Assange, Julian", "ipAddress": "185.86.151.11"}, "currency": {"name": "ethereum", "price": "EUR"}, "timestamp": "2018-09-28T08:08:14Z"}</strong><br/><br/><strong>{"event": "CUSTOMER_CONSULTS_ETHPRICE", "customer": {"id": "15887564", "name": "Mills, Lindsay", "ipAddress": "186.46.129.15"}, "currency": {"name": "ethereum", "price": "USD"}, "timestamp": "2018-09-28T19:51:35Z"}</strong></pre>
<p>If everything is working fine, the messages typed in the console-producer should be appearing in the console-consumer window, because the processing engine is copying from <kbd>input-topic</kbd> to <kbd>output-topic</kbd>.</p>
<p>The next step is to move onto a more complex version involving message validation (this current chapter), <span>m</span>essage enrichment<em> </em>(<a href="fa29d3d4-38ab-49c0-9e81-08bc59944488.xhtml" target="_blank">Chapter 3</a>, <em>Message Enrichment</em>), and message transformation (<a href="b444c6b4-4a8f-478c-9d3f-93a432d168b8.xhtml" target="_blank">Chapter 4</a>, <em>Serialization</em>).</p>
<p class="mce-root"/>
<p>Using the same suggestion made in the <a href="0bde3875-cd30-435c-9b32-b96fccb2e6d0.xhtml" target="_blank">Chapter 1</a>, <em>Configuring Kafka</em>, the replication-factor and partitions parameters where set to 1; try setting different values and see what happens when you stop one server.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Coding a validator in Java</h1>
                </header>
            
            <article>
                
<p>The <kbd>Writer</kbd> class implements the producer interface. The idea is to modify that <kbd>Writer</kbd> and build a validation class with minimum effort. The <kbd>Validator</kbd> process is as follows:</p>
<ul>
<li>Read the Kafka messages from the <strong>input-messages</strong> topic</li>
<li>Validate the messages, sending defective messages to the <strong>invalid-messages</strong> topic</li>
<li>Write the well-formed messages to <strong>valid-messages</strong> topic</li>
</ul>
<p>At the moment, for this example, the definition of a valid message is a message t0 which the following applies:</p>
<ul>
<li>It is in JSON format</li>
<li>It contains the four required fields: event, customer, currency, and timestamp</li>
</ul>
<p>If these conditions are not met, a new error message in JSON format is generated, sending it to the invalid-messages Kafka topic. The schema of this error message is very simple:</p>
<pre>{"error": "Failure description" }</pre>
<p>The first step is create a new <kbd>Validator.java</kbd> <span>file </span>in the <kbd>src/main/java/monedero/</kbd> directory, and copy therein the content of <em>Listing 2.9</em>.</p>
<p><span>The following is the content of <em>Listing 2.9</em></span>, <kbd>Validator.java</kbd><span>:</span><span><br/></span></p>
<pre>package monedero;<br/>import com.fasterxml.jackson.databind.JsonNode;<br/>import com.fasterxml.jackson.databind.ObjectMapper;<br/>import org.apache.kafka.clients.producer.KafkaProducer;<br/>import java.io.IOException;<br/><br/>public class Validator implements Producer {<br/>  private final KafkaProducer&lt;String, String&gt; producer;<br/>  private final String validMessages;<br/>  private final String invalidMessages;<br/>  private static final ObjectMapper MAPPER = new ObjectMapper();<br/>  <br/>  public Validator(String servers, String validMessages, String invalidMessages) { //1<br/>    this.producer = new KafkaProducer&lt;&gt;(Producer.createConfig(servers));<br/>    this.validMessages = validMessages;<br/>    this.invalidMessages = invalidMessages;<br/>  }<br/>  <br/>  @Override<br/>  public void process(String message) {<br/>    try {<br/>      JsonNode root = MAPPER.readTree(message);<br/>      String error = "";<br/>      error = error.concat(validate(root, "event")); //2<br/>      error = error.concat(validate(root, "customer"));<br/>      error = error.concat(validate(root, "currency"));<br/>      error = error.concat(validate(root, "timestamp"));<br/>      if (error.length() &gt; 0) {<br/>        Producer.write(this.producer, this.invalidMessages, //3<br/>        "{\"error\": \" " + error + "\"}");<br/>      } else {<br/>        Producer.write(this.producer, this.validMessages, //4<br/>        MAPPER.writeValueAsString(root));<br/>      }<br/>    } catch (IOException e) {<br/>      Producer.write(this.producer, this.invalidMessages, "{\"error\": \""<br/>      + e.getClass().getSimpleName() + ": " + e.getMessage() + "\"}");//5 <br/>    }<br/>  }<br/>  private String validate(JsonNode root, String path) {<br/>    if (!root.has(path)) {<br/>      return path.concat(" is missing. ");<br/>    }<br/>    JsonNode node = root.path(path);<br/>    if (node.isMissingNode()) {<br/>      return path.concat(" is missing. ");<br/>    }<br/>    return "";<br/>  }<br/>}</pre>
<div class="CDPAlignCenter CDPAlign packt_figref"><span>Listing 2.9: Validator.java</span></div>
<p>As with <kbd>Writer</kbd>, the <kbd>Validator</kbd> class also implements the <kbd>Producer</kbd> class, but with the following:</p>
<ul>
<li>In line <kbd>//1</kbd>, its constructor takes two topics: the valid and the invalid-messages topic</li>
<li>In line <kbd>//2</kbd>, the process method validates the fact that the message is in JSON format along with the existence of the fields: event, customer, currency, and timestamp</li>
<li>In line <kbd>//3</kbd>, in case the message doesn't have any required field, an error message is sent to the invalid-messages topic</li>
<li>In line <kbd>//4</kbd>, in case the message is valid, the message is sent to the valid-messages topic</li>
<li>In line <kbd>//5</kbd>, in case the message is not in JSON format, an error message is sent to the invalid-messages topic</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Running the validation</h1>
                </header>
            
            <article>
                
<p>At the moment, the <kbd>ProcessingEngine</kbd> class coordinates the <kbd>Reader</kbd> and <kbd>Writer</kbd> classes. It contains the main method to coordinate them. We have to edit the <kbd>ProcessingEngine</kbd> class located in the <kbd>src/main/java/monedero/</kbd> directory and change <kbd>Writer</kbd> with <kbd>Validator</kbd>, as in <em>Listing 2.10</em>.</p>
<p><span>The following is the content of <em>Listing 2.10</em></span>, <kbd>ProcessingEngine.java</kbd><span>:</span></p>
<pre>package monedero;<br/>public class ProcessingEngine {<br/>  public static void main(String[] args) {<br/>    String servers = args[0];<br/>    String groupId = args[1];<br/>    String inputTopic = args[2];<br/>    String validTopic = args[3];<br/>    String invalidTopic = args[4];<br/>    Reader reader = new Reader(servers, groupId, inputTopic);<br/>    Validator validator = new Validator(servers, validTopic, invalidTopic);<br/>    reader.run(validator);<br/>  }<br/>}</pre>
<div class="packt_figref CDPAlignCenter CDPAlign">Listing 2.10: <span>ProcessingEngine.java</span></div>
<p><kbd>ProcessingEngine</kbd> receives five arguments from the command line:</p>
<ul>
<li><kbd>args[0]</kbd> <kbd>servers</kbd>, indicates the host and port of the Kafka broker</li>
<li><kbd>args[1]</kbd> <kbd>groupId</kbd>, indicates that the consumer is part of this Kafka consumer group</li>
<li><kbd>args[2]</kbd> <kbd>inputTopic</kbd>, the topic where <kbd>Reader</kbd> reads from</li>
<li><kbd>args[3]</kbd> <kbd>validTopic</kbd>, the topic where valid messages are sent</li>
<li><kbd>args[4]</kbd> <kbd>invalidTopic</kbd>, the topic where invalid messages are sent</li>
</ul>
<p class="mce-root"/>
<p><span>To rebuild the project from the <kbd>monedero</kbd> directory, run the following command:</span></p>
<pre><strong>$ gradle jar</strong></pre>
<p>If everything is OK, the output should be similar to the following:</p>
<pre><strong>...</strong><br/><strong>BUILD SUCCESSFUL</strong><br/><strong>...</strong></pre>
<p>To run the project, we need four different command-line windows. <em>Figure 2.3</em> shows the command-line windows arrangement:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/ee505494-9d3a-4107-8adb-6d2780afa3cf.jpg" style=""/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 2.3: The four terminal windows to test the processing engine including: message producer, valid-message consumer, invalid-message consumer, and the processing engine itself</div>
<ol start="1">
<li>In the first command-line terminal, go to the Kafka installation directory and generate the two necessary topics:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ bin/kafka-topics --create --zookeeper localhost:2181 --<br/>replication-factor 1 --</strong><strong>partitions 1 --topic valid-messages</strong><br/><br/><strong>$ bin/kafka-topics --create --zookeeper localhost:2181 --<br/>replication-factor 1 --</strong><strong>partitions 1 --topic invalid-messages</strong></pre>
<p style="padding-left: 60px">Then, start a console producer to the <kbd>input-topic</kbd> topic, as follows:</p>
<pre style="padding-left: 60px"><strong>$ bin/kafka-console-producer --broker-list localhost:9092 --topic <br/>input-topic</strong></pre>
<p style="padding-left: 60px">This window is where the input messages are produced (typed).</p>
<p class="mce-root"/>
<ol start="2">
<li>In the second command-line window, start a command-line consumer listening to the valid-messages topic, as follows:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ bin/kafka-console-consumer --bootstrap-server localhost:9092 --<br/>from-beginning --topic valid-messages</strong></pre>
<ol start="3">
<li>In the third command-line window, start a command-line consumer listening to invalid-messages topic, as follows:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ bin/kafka-console-consumer --bootstrap-server localhost:9092 --<br/>from-beginning --topic invalid-messages</strong></pre>
<ol start="4">
<li>In the fourth command-line terminal, start up the processing engine. From the project root directory (where the <kbd>gradle jar</kbd> command were executed), run the following command:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ java -jar ./build/libs/monedero-0.1.0.jar localhost:9092 foo <br/>input-topic valid-messages invalid-messages</strong></pre>
<p>From the first command-line terminal (the console producer), send the following three messages (remember to type enter between messages and execute each one in just one line):</p>
<pre><strong>{"event": "CUSTOMER_CONSULTS_ETHPRICE", "customer": {"id": "14862768", "name": "Snowden, Edward", "ipAddress": "95.31.18.111"}, "currency": {"name": "ethereum", "price": "RUB"}, "timestamp": "2018-09-28T09:09:09Z"}</strong><br/><br/><strong>{"event": "CUSTOMER_CONSULTS_ETHPRICE", "customer": {"id": "13548310", "name": "Assange, Julian", "ipAddress": "185.86.151.11"}, "currency": {"name": "ethereum", "price": "EUR"}, "timestamp": "2018-09-28T08:08:14Z"}</strong><br/><br/><strong>{"event": "CUSTOMER_CONSULTS_ETHPRICE", "customer": {"id": "15887564", "name": "Mills, Lindsay", "ipAddress": "186.46.129.15"}, "currency": {"name": "ethereum", "price": "USD"}, "timestamp": "2018-09-28T19:51:35Z"}</strong></pre>
<p>As these are valid messages, the messages typed in the producer console should appear in the valid-messages consumer console window.</p>
<p>Now try sending defective messages; first, try messages that are not in JSON format:</p>
<pre><strong>I am not JSON, I am Freedy.</strong> [enter]<br/><strong>I am a Kafkeeter!</strong> [enter]</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>This message should be received in the invalid messages topic (and displayed in the window), as in the following example:</p>
<pre><strong>{"error": "JsonParseException: Unrecognized token ' I am not JSON, I am Freedy.': was expecting 'null','true', 'false' or NaN</strong><br/><strong>at [Source: I am not JSON, I am Freedy.; line: 1, column: 4]"}</strong></pre>
<p>Then, let's try something more complex, the first message but without a timestamp, as in the example:</p>
<pre><strong>{"event": "CUSTOMER_CONSULTS_ETHPRICE", "customer": {"id": "14862768", "name": "Snowden, Edward", "ipAddress": "95.31.18.111"}, "currency": {"name": "ethereum", "price": "RUB"}}</strong></pre>
<p>This message should be received in the invalid messages topic, as follows:</p>
<pre><strong>{"error": "timestamp is missing."}</strong></pre>
<p>The message validation is complete and, as you can see, there is a lot more validation to do, for example, validation against JSON schemas, but this is covered in <a href="f7fa5729-8bf7-41c8-aba6-aa5f8663394f.xhtml" target="_blank">Chapter 5</a>, <em>Schema Registry</em>.</p>
<p>The architecture detailed in <em>Figure 2.1</em> of this chapter will be used in <a href="fa29d3d4-38ab-49c0-9e81-08bc59944488.xhtml" target="_blank">Chapter 3</a>, <em>Message Enrichment</em>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter we learned how to model the messages in JSON format and how to set up a Kafka project with Gradle.</p>
<p>Also, we learned how to write to and read from Kafka with a Java client, how to run the processing engine, how to code a validator in Java, and how to run the message validation.</p>
<p>In <a href="fa29d3d4-38ab-49c0-9e81-08bc59944488.xhtml" target="_blank">Chapter 3</a>, <em>Message Enrichment</em>, the architecture of this chapter will be redesigned to incorporate message enrichment.</p>


            </article>

            
        </section>
    </body></html>