["```java\n@Test\nvoid testFlux() {\n  List<Integer> list = Flux.just(1, 2, 3, 4)\n    .filter(n -> n % 2 == 0)\n    .map(n -> n * 2)\n    .log()\n    .collectList().block();\n  assertThat(list).containsExactly(4, 8);\n} \n```", "```java\npublic interface ProductRepository extends ReactiveCrudRepository <ProductEntity, String> {\n    Mono<ProductEntity> findByProductId(int productId);\n}\npublic interface RecommendationRepository extends ReactiveCrudRepository<RecommendationEntity, String> {\n    Flux<RecommendationEntity> findByProductId(int productId);\n} \n```", "```java\nProductEntity foundEntity = repository.findById(newEntity.getId()).get();\nassertEqualsProduct(newEntity, foundEntity); \n```", "```java\nProductEntity foundEntity = repository.findById(newEntity.getId()).**block();**\nassertEqualsProduct(newEntity, foundEntity); \n```", "```java\n**StepVerifier**.create(repository.findById(newEntity.getId()))\n  .expectNextMatches(foundEntity -> areProductEqual(newEntity, foundEntity))\n  .**verifyComplete**(); \n```", "```java\nMono<Product> getProduct(@PathVariable int productId); \n```", "```java\npublic **Mono**<Product> getProduct(int productId) {\n    if (productId < 1) {\n      throw new InvalidInputException(\"Invalid productId: \" + productId);\n    }\n    return repository.**findByProductId(productId)**\n        .switchIfEmpty(Mono.error(new **NotFoundException**(\"No product found\n         for productId: \" + productId)))\n        .log(LOG.getName(), FINE)\n        .map(e -> **mapper.entityToApi**(e))\n        .map(e -> **setServiceAddress**(e));\n} \n```", "```java\n    @Autowired\n    public ReviewServiceApplication(\n      @Value(\"${**app.threadPoolSize:10**}\") Integer threadPoolSize,\n      @Value(\"${**app.taskQueueSize:100**}\") Integer taskQueueSize\n    ) {\n      this.threadPoolSize = threadPoolSize;\n      this.taskQueueSize = taskQueueSize;\n    }\n    @Bean\n    public Scheduler **jdbcScheduler**() {\n      return Schedulers.newBoundedElastic(threadPoolSize,\n        taskQueueSize, \"jdbc-pool\");\n    } \n    ```", "```java\n    @RestController\n    public class ReviewServiceImpl implements ReviewService {\n      private final Scheduler jdbcScheduler;\n      @Autowired\n      public ReviewServiceImpl(\n        **@Qualifier(\"jdbcScheduler\")**\n        **Scheduler jdbcScheduler**, ...) {\n        this.jdbcScheduler = jdbcScheduler;\n      } \n    ```", "```java\n    @Override\n    public Flux<Review> getReviews(int productId) {\n      if (productId < 1) {\n        throw new InvalidInputException(\"Invalid productId: \" + \n          productId);\n      }\n      LOG.info(\"Will get reviews for product with id={}\", \n        productId);\n      return Mono.fromCallable(() -> internalGetReviews(productId))\n        .flatMapMany(Flux::fromIterable)\n        .log(LOG.getName(), FINE)\n        .subscribeOn(jdbcScheduler);\n    }\n    private List<Review> internalGetReviews(int productId) {\n      List<ReviewEntity> entityList = repository.\n        findByProductId(productId);\n      List<Review> list = mapper.entityListToApiList(entityList);\n      list.forEach(e -> e.setServiceAddress(serviceUtil.\n        getServiceAddress()));\n      LOG.debug(\"Response size: {}\", list.size());\n      return list;\n    } \n    ```", "```java\n@Override\npublic Mono<ProductAggregate> getProduct(int productId) {\n  return **Mono.zip**(\n\n    **values** -> **createProductAggregate**(\n      (Product) values[0], \n      (List<Recommendation>) values[1], \n      (List<Review>) values[2], \n      serviceUtil.getServiceAddress()),\n\n    integration.getProduct(productId),\n    integration.getRecommendations(productId).collectList(),\n    integration.getReviews(productId).collectList())\n\n    .doOnError(ex -> \n      LOG.warn(\"getCompositeProduct failed: {}\", \n      ex.toString()))\n    .log(LOG.getName(), FINE);\n} \n```", "```java\n    public class ProductCompositeIntegration implements ProductService, RecommendationService, ReviewService {\n        private final WebClient webClient;\n        @Autowired\n        public ProductCompositeIntegration(\n            **WebClient.Builder webClient**, ...\n        ) {\n            this.webClient = webClient.build();\n        } \n    ```", "```java\n    @Override\n    public Mono<Product> getProduct(int productId) {\n      String url = productServiceUrl + \"/product/\" + productId;\n      return **webClient**.get().uri(url).retrieve()\n        .bodyToMono(Product.class)\n        .log(LOG.getName(), FINE)\n        .**onErrorMap**(WebClientResponseException.class, \n          ex -> handleException(ex)\n        );\n    } \n    ```", "```java\n@Override\npublic Flux<Recommendation> getRecommendations(int productId) {\n  String url = recommendationServiceUrl + \"/recommendation?\n  productId=\" + productId;\n  // Return an empty result if something goes wrong to make it \n  // possible for the composite service to return partial responses\n  return webClient.get().uri(url).retrieve()\n    .bodyToFlux(Recommendation.class)\n    .log(LOG.getName(), FINE)\n    .**onErrorResume(error -> empty());**\n} \n```", "```java\nclass ProductCompositeServiceApplicationTests {\n    @BeforeEach\n    void setUp() {\n        when(compositeIntegration.getProduct(PRODUCT_ID_OK)).\n            thenReturn(**Mono.just**(new Product(PRODUCT_ID_OK, \"name\", 1,\n             \"mock-address\")));\n        when(compositeIntegration.getRecommendations(PRODUCT_ID_OK)).\n            thenReturn(**Flux.fromIterable**(singletonList(new \n             Recommendation(PRODUCT_ID_OK, 1, \"author\", 1, \"content\",\n             \"mock address\"))));\n        when(compositeIntegration.getReviews(PRODUCT_ID_OK)).\n            thenReturn(**Flux.fromIterable**(singletonList(new\n             Review(PRODUCT_ID_OK, 1, \"author\", \"subject\", \"content\",\n             \"mock address\")))); \n```", "```java\n@Autowired\nprivate StreamBridge streamBridge;\n@PostMapping\nvoid sampleCreateAPI(@RequestBody String body) {\n  **streamBridge.send**(\"topic\", body);\n} \n```", "```java\n@Bean\npublic Consumer<String> mySubscriber() {\n   return s -> System.out.println(\"ML RECEIVED: \" + s);\n} \n```", "```java\nspring.cloud.stream:\n  bindings.messageProcessor-in-0:\n    destination: products\n    group: productsGroup \n```", "```java\nspring.cloud.stream.bindings.messageProcessor-in-0.consumer:\n  **maxAttempts:**3\n  **backOffInitialInterval:**500\n  **backOffMaxInterval:**1000\n  backOffMultiplier: 2.0\nspring.cloud.stream.rabbit.bindings.messageProcessor-in-0.consumer:\n  autoBindDlq: true\n  republishToDlq: true\nspring.cloud.stream.kafka.bindings.messageProcessor-in-0.consumer:\n  enableDlq: true \n```", "```java\nspring.cloud.stream.bindings.products-out-0.producer:\n  partition-key-expression: headers[**'partitionKey'**]\n  partition-count: 2 \n```", "```java\nspring.cloud.stream.bindings.messageProcessor-in-0:\n  destination: products\n  group:productsGroup\n  consumer:\n    partitioned: true\n    **instance-index:****0** \n```", "```java\npublic class **Event****<K, T>** {\n    public enum Type {**CREATE, DELETE**}\n    private Event.Type eventType;\n    private K key;\n    private T data;\n    private ZonedDateTime eventCreatedAt;\n    public Event() {\n        this.eventType = null;\n        this.key = null;\n        this.data = null;\n        this.eventCreatedAt = null;\n    }\n    public Event(Type eventType, K key, T data) {\n        this.eventType = eventType;\n        this.key = key;\n        this.data = data;\n        this.eventCreatedAt = now();\n    }\n    public Type getEventType() {\n        return eventType;\n    }\n    public K getKey() {\n        return key;\n    }\n    public T getData() {\n        return data;\n    }\n    public ZonedDateTime getEventCreatedAt() {\n        return eventCreatedAt;\n    }\n} \n```", "```java\ndependencies {\n  implementation 'org.springframework.cloud:spring-cloud-starter-stream-rabbit'\n  implementation 'org.springframework.cloud:spring-cloud-starter-stream-kafka'\n  testImplementation 'org.springframework.cloud:spring-cloud-stream::test-binder'\n} \n```", "```java\next {\n    springCloudVersion = \"2022.0.1\"\n} \n```", "```java\ndependencyManagement {\n    imports {\n        mavenBom \"org.springframework.cloud:spring-cloud-\n        dependencies:${springCloudVersion}\"\n    }\n} \n```", "```java\n**@Configuration**\npublic class MessageProcessorConfig {\n  private final ProductService productService;\n  @Autowired\n  public MessageProcessorConfig(**ProductService productService**) \n  {\n    this.productService = productService;\n  }\n  @Bean\n  public Consumer<Event<Integer,Product>> **messageProcessor**() {\n    ... \n```", "```java\nreturn **event** -> {\n  switch (event.getEventType()) {\n    case CREATE:\n      Product product = event.getData();\n      **productService.createProduct**(product).block();\n      break;\n    case DELETE:\n      int productId = event.getKey();\n      **productService.deleteProduct**(productId).block();\n      break;\n    default:\n      String errorMessage = \"Incorrect event type: \" + \n        event.getEventType() + \n        \", expected a CREATE or DELETE event\";\n      **throw****new****EventProcessingException**(errorMessage);\n  }\n}; \n```", "```java\n@Override\npublic Mono<Product> createProduct(Product body) {\n  if (body.getProductId() < 1) {\n    throw new InvalidInputException(\"Invalid productId: \" + \n      body.getProductId());\n  }\n  ProductEntity entity = mapper.apiToEntity(body);\n  Mono<Product> newEntity = repository.save(entity)\n    .log(LOG.getName(), FINE)\n    .**onErrorMap**(\n      DuplicateKeyException.class,\n      ex -> new InvalidInputException\n        (\"Duplicate key, Product Id: \" + body.getProductId()))\n    .map(e -> mapper.entityToApi(e));\n  return newEntity;\n} \n```", "```java\n    spring.cloud.stream:\n      defaultBinder: rabbit\n      default.contentType: application/json \n    ```", "```java\n    spring.cloud.stream:\n      bindings.messageProcessor-in-0:\n        destination: products \n    ```", "```java\n    spring.cloud.stream.kafka.binder:\n      brokers: 127.0.0.1\n      defaultBrokerPort: 9092\n    spring.rabbitmq:\n      host: 127.0.0.1\n      port: 5672\n      username: guest\n      password: guest\n    ---\n    spring.config.activate.on-profile: docker\n    spring.rabbitmq.host: rabbitmq\n    spring.cloud.stream.kafka.binder.brokers: kafka \n    ```", "```java\n@SpringBootTest\nclass ProductServiceApplicationTests {\n  @Autowired\n  **@Qualifier(\"messageProcessor\")**\n  private Consumer<Event<Integer, Product>> messageProcessor; \n```", "```java\n private void **sendCreateProductEvent**(int productId) {\n    Product product = new Product(productId, \"Name \" + productId, productId, \"SA\");\n    Event<Integer, Product> event = new Event(CREATE, productId, product);\n    messageProcessor.**accept**(event);\n  }\n  private void **sendDeleteProductEvent**(int productId) {\n    Event<Integer, Product> event = new Event(DELETE, productId, null);\n    messageProcessor.**accept**(event);\n  } \n```", "```java\n @Override\n  public Mono<Product> createProduct(Product body) {\n    return Mono.fromCallable(() -> {\n      sendMessage(\"products-out-0\", \n        new Event(CREATE, body.getProductId(), body));\n      return body;\n    }).subscribeOn(publishEventScheduler);\n  }\n  private void sendMessage(String bindingName, Event event) {\n    Message message = MessageBuilder.withPayload(event)\n      .setHeader(\"partitionKey\", event.getKey())\n      .build();\n    **streamBridge**.send(bindingName, message);\n  } \n```", "```java\nspring.cloud.stream:\n  bindings:\n    products-out-0:\n      destination: products\n    recommendations-out-0:\n      destination: recommendations\n    reviews-out-0:\n      destination: reviews \n```", "```java\nspring.cloud.stream.bindings.**products-out-**0.producer:\n  partition-key-expression: headers[**'partitionKey'**]\n  partition-count: 2 \n```", "```java\n    @SpringBootTest\n    **@Import({TestChannelBinderConfiguration.class})**\n    class MessagingTests {\n      @Autowired\n      private **OutputDestination target**; \n    ```", "```java\n    private void **purgeMessages**(String bindingName) {\n      getMessages(bindingName);\n    }\n    private List<String> **getMessages**(String bindingName){\n      List<String> messages = new ArrayList<>();\n      boolean anyMoreMessages = true;\n      while (anyMoreMessages) {\n        Message<byte[]> message = \n          getMessage(bindingName);\n        if (message == null) {\n          anyMoreMessages = false;\n        } else {\n          messages.add(new String(message.getPayload()));\n        }\n      }\n      return messages;\n    }\n    private Message<byte[]> **getMessage**(String bindingName){\n      try {\n        return target.receive(0, bindingName);\n      } catch (NullPointerException npe) {\n        LOG.error(\"getMessage() received a NPE with binding = {}\", bindingName);\n        return null;\n      }\n    } \n    ```", "```java\n     @BeforeEach\n      void setUp() {\n        purgeMessages(\"products\");\n        purgeMessages(\"recommendations\");\n        purgeMessages(\"reviews\");\n      } \n    ```", "```java\n    @Test\n    void createCompositeProduct1() {\n      ProductAggregate composite = new ProductAggregate(1, \"name\", 1, null, null, null);\n      **postAndVerifyProduct**(composite, ACCEPTED);\n      final List<String> productMessages = **getMessages**(\"products\");\n      final List<String> recommendationMessages = **getMessages**(\"recommendations\");\n      final List<String> reviewMessages = **getMessages**(\"reviews\");\n      // Assert one expected new product event queued up\n      **assertEquals(**1, productMessages.size());\n      Event<Integer, Product> expectedEvent =\n        new Event(CREATE, composite.getProductId(), new Product(composite.getProductId(), composite.getName(), composite.getWeight(), null));\n      assertThat(productMessages.get(0), is(**sameEventExceptCreatedAt**(expectedEvent)));\n      // Assert no recommendation and review events\n      **assertEquals(****0**, recommendationMessages.size());\n      **assertEquals(****0**, reviewMessages.size());\n    } \n    ```", "```java\nspring.cloud.stream:\n  bindings:\n    products-out-0:\n      destination: products\n      producer:\n        **required-groups:****auditGroup** \n```", "```java\npublic Mono<Health> getProductHealth() {\n    return getHealth(productServiceUrl);\n}\npublic Mono<Health> getRecommendationHealth() {\n    return getHealth(recommendationServiceUrl);\n}\npublic Mono<Health> getReviewHealth() {\n    return getHealth(reviewServiceUrl);\n}\nprivate Mono<Health> getHealth(String url) {\n    url += \"/actuator/health\";\n    LOG.debug(\"Will call the Health API on URL: {}\", url);\n    return webClient.get().uri(url).retrieve().bodyToMono(String.class)\n        .map(s -> new Health.Builder().up().build())\n        .onErrorResume(ex -> Mono.just(new \n         Health.Builder().down(ex).build()))\n        .log(LOG.getName(), FINE);\n} \n```", "```java\n@Configuration\npublic class HealthCheckConfiguration {\n  @Autowired\n  ProductCompositeIntegration integration; \n  @Bean\n  ReactiveHealthContributor coreServices() {\n    final Map<String, ReactiveHealthIndicator> registry = new LinkedHashMap<>();\n    registry.put(\"product\", () -> integration.getProductHealth());\n    registry.put(\"recommendation\", () -> integration.getRecommendationHealth());\n    registry.put(\"review\", () -> integration.getReviewHealth());\n    return CompositeReactiveHealthContributor.fromMap(registry);\n  }\n} \n```", "```java\nmanagement.endpoint.health.show-details: \"ALWAYS\"\nmanagement.endpoints.web.exposure.include: \"*\" \n```", "```java\ncurl localhost:8080/actuator/health -s | jq . \n```", "```java\n     rabbitmq:\n        image: **rabbitmq:3.11.8-management**\n        mem_limit: 512m\n        ports:\n          **-****5672****:5672**\n          **-****15672****:15672**\n        **healthcheck**:\n          test: [\"CMD\", \"rabbitmqctl\", \"status\"]\n          interval: 5s\n          timeout: 2s\n          retries: 60 \n    ```", "```java\n    depends_on:\n      rabbitmq:\n        condition: service_healthy \n    ```", "```java\n    cd $BOOK_HOME/Chapter07\n    ./gradlew build && docker-compose build && docker-compose up -d \n    ```", "```java\n    curl -s localhost:8080/actuator/health | jq -r .status \n    ```", "```java\n    body='{\"productId\":1,\"name\":\"product name C\",\"weight\":300, \"recommendations\":[\n    {\"recommendationId\":1,\"author\":\"author 1\",\"rate\":1,\"content\":\"content 1\"},\n     {\"recommendationId\":2,\"author\":\"author 2\",\"rate\":2,\"content\":\"content 2\"},\n     {\"recommendationId\":3,\"author\":\"author 3\",\"rate\":3,\"content\":\"content 3\"}\n    ], \"reviews\":[\n     {\"reviewId\":1,\"author\":\"author 1\",\"subject\":\"subject 1\",\"content\":\"content 1\"},\n     {\"reviewId\":2,\"author\":\"author 2\",\"subject\":\"subject 2\",\"content\":\"content 2\"},\n     {\"reviewId\":3,\"author\":\"author 3\",\"subject\":\"subject 3\",\"content\":\"content 3\"}\n    ]}'\n    curl -X POST localhost:8080/product-composite -H \"Content-Type: application/json\" --data \"$body\" \n    ```", "```java\n    curl -s localhost:8080/product-composite/1 | jq \n    ```", "```java\n    curl -X DELETE localhost:8080/product-composite/1 \n    ```", "```java\n    docker-compose down \n    ```", "```java\n product-p1:\n    build: microservices/product-service\n    mem_limit: 512m\n    environment:\n      - SPRING_PROFILES_ACTIVE=docker,**streaming_partitioned**,**streaming_instance_1**\n    depends_on:\n      mongodb:\n        condition: service_healthy\n      rabbitmq:\n        condition: service_healthy \n```", "```java\nexport COMPOSE_FILE=docker-compose-partitions.yml\ndocker-compose build && docker-compose up -d \n```", "```java\ndocker-compose down\nunset COMPOSE_FILE \n```", "```java\nkafka:\n  image: confluentinc/cp-kafka:7.3.1\n  restart: always\n  mem_limit: 1024m\n  ports:\n    - \"9092:9092\"\n  environment:\n    - KAFKA_ZOOKEEPER_CONNECT=zookeeper:2181\n    - KAFKA_ADVERTISED_LISTENERS=PLAINTEXT://kafka:9092\n    - KAFKA_BROKER_ID=1\n    - KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR=1\n  depends_on:\n    - zookeeper\nzookeeper:\n  image: confluentinc/cp-zookeeper:7.3.1\n  restart: always\n  mem_limit: 512m\n  ports:\n    - \"2181:2181\"\n  environment:\n    - ZOOKEEPER_CLIENT_PORT=2181 \n```", "```java\nexport COMPOSE_FILE=docker-compose-kafka.yml\ndocker-compose build && docker-compose up -d \n```", "```java\ndocker-compose exec kafka kafka-topics --bootstrap-server localhost:9092 --list \n```", "```java\ndocker-compose exec kafka kafka-topics --bootstrap-server localhost:9092 --describe --topic products \n```", "```java\ndocker-compose exec kafka kafka-console-consumer --bootstrap-server localhost:9092 --topic products --from-beginning --timeout-ms 1000 --partition 1 \n```", "```java\ndocker-compose down\nunset COMPOSE_FILE \n```", "```java\n    waitForService curl http://$HOST:$PORT/actuator/health \n    ```", "```java\n    unset COMPOSE_FILE\n    ./test-em-all.bash start stop \n    ```", "```java\n    export COMPOSE_FILE=docker-compose-partitions.yml \n    ./test-em-all.bash start stop\n    unset COMPOSE_FILE \n    ```", "```java\n    export COMPOSE_FILE=docker-compose-kafka.yml \n    ./test-em-all.bash start stop\n    unset COMPOSE_FILE \n    ```", "```java\n    @Test\n    void testStepVerifier() {\n      StepVerifier.create(Flux.just(1, 2, 3, 4)\n        .filter(n -> n % 2 == 0)\n        .map(n -> n * 2)\n        .log())\n        .expectNext(4, 8, 12);\n    } \n    ```"]