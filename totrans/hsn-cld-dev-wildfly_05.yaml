- en: Testing Your Services with Arquillian
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you will learn how to test your microservices. For this purpose,
    we will use Arquillian, a test framework designed to test software components
    using their dedicated runtime, instead of creating mock-based unit tests. This
    is the framework developer to work seamlessly WildFly Swarm and, effectively,
    a framework of choice for it.
  prefs: []
  type: TYPE_NORMAL
- en: We will introduce Arquillian and present the purpose of the project and its
    main features. Later, you will learn how to develop, write, and configure tests
    for your services based on practical examples.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Arquillian
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We all know the benefits of unit testing. They are simple and run immediately.
    They isolate the components of your application and allow you to test them one
    by one, providing the coverage of each component's usage scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, unit tests have their shortcomings too. When you cover your application
    with unit tests, they will confirm that each component of your application works
    correctly. Obviously, based only on that information, you cannot deduce that your
    whole application works correctly—that is a reason to have integration tests.
    You have to test your components inside the environment in which they will operate
    to ensure that the application works correctly as a whole.
  prefs: []
  type: TYPE_NORMAL
- en: The problem with integration tests so far has been that they tend to be complicated
    to configure and took a long time to execute. Here is where Arquillian steps in.
    The aim of the project is to make integration tests as fast and simple to configure
    as unit tests.
  prefs: []
  type: TYPE_NORMAL
- en: As you may recall, in [Chapter 2](c00cfc93-f395-446e-9132-242f02216783.xhtml),
    *Getting Familiar with WildFly Swarm*, we emphasized how fast modern runtimes
    are. Arquillian takes advantage of that and lets you easily configure the tests
    that run on the same runtime your application will run. If, for example, you are
    developing a Java EE application, you can configure Arquillian to run the test
    on the application server of your choice. Since modern applications servers are
    very fast, the test will run immediately. On the other hand, you will be able
    to test your application in its real environment with all its dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: In our case, a runtime for each service is assembled by WildFly Swarm (as described
    in [Chapter 3](dd01a81c-3ad7-4b3b-80fa-a8af1b89581c.xhtml), *Right-Sizing Your
    Applications*). Arquillian allows you to configure the tests for such cases too.
    Let's find out how.
  prefs: []
  type: TYPE_NORMAL
- en: Testing Swarm microservices with Arquillian
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you will learn how Arquillian can be used to test microservices
    created with Swarm. As you learned in previous chapters, Swarm builds a runtime
    containing only fractions needed by a given service, starts it, and then deploys
    an archive on it, creating the microservice.
  prefs: []
  type: TYPE_NORMAL
- en: Arquillian, as we have just learned, tests an application on its dedicated runtime.
    It starts the runtime, deploys the tested code on it, and performs the test. Let's
    configure such a test for our JAX-RS and the CDI catalog service example, and
    explain what we are doing step by step.
  prefs: []
  type: TYPE_NORMAL
- en: 'For examples: refer to `chapter 5/catalog-service-simple-test`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, we have to provide all the necessary dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Firstly, we added Arquillian to `dependencyManagement` (1).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Secondly, Arquillian can be integrated with various testing libraries. As we
    are going to use JUnit, we have to provide the dependency to it (2).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To run the Arquillian test with JUnit, we have to provide JUnit integration
    artifact (3).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Thirdly, we have to tell Arquillian which runtime to use—we are doing this by
    providing a dependency to an adapter library. In our case, this obviously is a
    Swarm adapter (3).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now we are ready to take a look at the code. To recall, the service in this
    example contains only one item, which is added manually:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now it is time to write a `test` class. An Arquillian-based test runs in the
    following way: Arquillian looks for the static method annotated with the `org.jboss.arquillian.container.test.api.Deployment`
    annotation. The method has to return the `ShrinkWrap` archive.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Arquillian will start the container and deploy the returned archive on it.
    After that, the methods are annotated with `org.junit`. A test runs inside the
    container. Let''s look at all this in our sample test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the beginning, we told JUnit to run the test using Arquillian test controller.
    To do that, we annotated the test with the `@RunWith` annotation, specifying `Arquillian.class`
    as the test runner (1).
  prefs: []
  type: TYPE_NORMAL
- en: The `createDeployment` (2) method, as its name suggests, is responsible for
    creating the deployment archive, which will be deployed on the configured container.
    To inform Arquillian about it, we have to annotate this method with the `@Deployment`
    annotation. The method is static and returns the `ShrinkWrap` archive. As the
    test method is being run inside the container, we are able to inject its resources.
    In our example, we have to inject the `CatalogService` class that we are going
    to test (3) and the `Item` class on which it depends.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the `Test` method checks whether the `searchById` method works correctly
    (4).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s run the test now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'You will note that the test has been deployed inside the Swarm container:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/727118a6-1419-4f5c-bdcd-f7c758baad20.png)'
  prefs: []
  type: TYPE_IMG
- en: 'It finishes successfully:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f9321cdb-a3c4-4d01-934e-35c20afb1006.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Finally, the Swarm microservice starts (because we used the `wildfly-swarm:run`
    command):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d03f92fc-a1b1-436f-8982-d1585fc913bf.png)'
  prefs: []
  type: TYPE_IMG
- en: Note that Swarm, as in examples from the previous chapters, used the when-missing
    discovery mechanism and created the container with all the necessary fractions.
    That container was used for both testing and running the resulting microservices.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you could notice in the preceding screenshot, the only file that we changed
    was the `pom.xml` file, so the switch from AS to Swarm was again very simple.
    However, this had drawbacks too: not changing the `CatalogTest` class meant that
    we were again creating the archive manually—Swarm can do it for us when the service
    is created so can''t it create the deployment test too? It can—let''s learn how.'
  prefs: []
  type: TYPE_NORMAL
- en: The default deployment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have just hinted, Swarm can create the default test deployment.
  prefs: []
  type: TYPE_NORMAL
- en: For example, refer to `chapter 5/catalog-service-test-default-deployment`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will modify the `Test` class so that the archive is created automatically:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In order to tell Swarm to create the test deployment automatically, we have
    to annotate the class with the `org.wildfly.swarm.arquillian.DefaultDeployment`
    annotation (1). That's just it. If you run the test now, you will see the same
    result as in the preceding paragraph. Note that we didn't use the `@Deployment`
    annotated static method as we did in the preceding example.
  prefs: []
  type: TYPE_NORMAL
- en: Swarm configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the preceding chapter, we showed you how to modify the Swarm configuration.
    The example that we used to present that was a database configuration. In this
    section, we will show you how to provide analogous configuration for a Swarm test
    using the same example.
  prefs: []
  type: TYPE_NORMAL
- en: For examples, refer to `chapter 5/catalog-service-database-test`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you would like to create the Swarm container manually, you have to implement
    the static method annotated with the `org.wildfly.swarm.arquillian.CreateSwarm`
    annotation and return the instance of the `org.wildfly.swarm.Swarm` class from
    it. As you probably recall, we have already created a lot of Swarm containers
    inside the `main` functions that we created in [Chapter 4](d76eaa85-5053-41f6-bcd1-307db5a17f60.xhtml),
    *Tuning the Configuration of Your Services*. Swarm-creating methods that we will
    use in the tests work the same way. Let''s take a look at the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In the beginning, we created the deployment with all the necessary classes and
    configurations.
  prefs: []
  type: TYPE_NORMAL
- en: We have to add the datasource configuration, the persistence configuration,
    and the load file (1) so that they can be read from within the test.
  prefs: []
  type: TYPE_NORMAL
- en: The key part is the `createSwarm` method (2) mentioned previously. It creates
    the Swarm instance, reads the datasources configuration (3), and configures Swarm
    with it (4).
  prefs: []
  type: TYPE_NORMAL
- en: When the container and deployment are ready, we can start writing the test logic.
    We start by injecting the `CatalogService` to the test (4). Recall that this test
    runs inside the Swarm container, and as a result, the service can be injected
    into it. Finally, to ensure that our service indeed works correctly, we check
    whether the returned data is correct (5).
  prefs: []
  type: TYPE_NORMAL
- en: If you run the test now, you will see that it passes correctly.
  prefs: []
  type: TYPE_NORMAL
- en: However, currently, we are creating the microservices without any endpoints
    and testing them from inside the container. That's OK, but we would also like
    to test the whole microservice, using its external interface. Let's take a look
    at how to do it.
  prefs: []
  type: TYPE_NORMAL
- en: Testing from a standalone client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This time, we would like to test the application from a standalone client. Let's
    learn how to do it.
  prefs: []
  type: TYPE_NORMAL
- en: For examples, refer to `chapter 5/catalog-service-database-test-standalone`.
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, we have to add a bunch of dependencies to the `pom.xml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We have to add a dependency to the JAX-RS client that we will use to make REST
    invocations on our service. As we will use the `resteasy` implementation, we will
    add its client (1). We would also need a library to parse the JSON response, hence
    the `resteasy-jackson-provider` is added (2).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the code of the test that does it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: There is quite a bit of stuff that we had to implement. Let's analyze it one
    by one.
  prefs: []
  type: TYPE_NORMAL
- en: As we are going to test the REST endpoint, we have to add classes that will
    expose it, that is, `CatalogResource` and `CatalogApplication` (1).
  prefs: []
  type: TYPE_NORMAL
- en: Arquillian is able to find out the URL of a created service and inject it into
    the test. To obtain such an object, we have to annotate the URL field with the
    `org.jboss.arquillian.test.api.ArquillianResource` annotation (4).
  prefs: []
  type: TYPE_NORMAL
- en: We have implemented the convenience test method, which makes invocations to
    the service and obtains item instances, based on the ID (5).
  prefs: []
  type: TYPE_NORMAL
- en: The most important addition to the test is annotating the `test` methods with
    the `org.jboss.arquillian.container.test.api.RunAsClient`annotation. As a result,
    the test will run from Maven's JVM as a standalone client. We are using the test
    annotated in this way in order to create a test that will assert the correct behavior
    of our service, based on invocations from the test JVM (6).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned what Arquillian is and how you can use it to test
    Swarm microservices. You also learned how to configure Arquillian to automatically
    create a Swarm container, how to modify the container configuration, and how to
    test the created microservice from within the container and from a standalone
    client.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[http://arquillian.org/](http://arquillian.org/)'
  prefs: []
  type: TYPE_NORMAL
