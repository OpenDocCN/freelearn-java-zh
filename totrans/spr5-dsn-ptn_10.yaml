- en: Implementing the MVC Pattern in a Web Application using Spring
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Spring 中使用 MVC 模式实现 Web 应用程序
- en: In the last couple of chapters in the book, we have seen that all examples were
    based on a standalone application using the Spring Framework. We have seen how
    Spring works to provide important features, such as the dependency injection pattern,
    bean life cycle management, AOP, cache management, and Spring, in the backend
    using the JDBC and ORM modules. In this chapter, we will see how Spring works
    in the web environment to address some common problems of any web application,
    such as workflow, validations, and state management.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的最后一两个章节中，我们看到了所有示例都是基于使用 Spring 框架的独立应用程序。我们看到了 Spring 如何工作以提供重要功能，例如依赖注入模式、bean
    生命周期管理、AOP、缓存管理，以及使用 JDBC 和 ORM 模块在后台的 Spring。在本章中，我们将看到 Spring 在网络环境中是如何工作的，以解决任何
    Web 应用程序的一些常见问题，如工作流程、验证和状态管理。
- en: Like other modules in the Spring Framework, Spring has introduced its own web
    framework, known as Spring Web MVC. It is based on the **Model-View-Controller**
    (**MVC**) pattern. Spring Web MVC supports the presentation tier, and helps you
    to build a flexible and loosely coupled web-based application. The Spring MVC
    module addresses the problem of testing the web components in the enterprise application.
    It allows you to write the test case without using request and response objects
    in the application. Here, we will discuss more about it.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Spring 框架中的其他模块一样，Spring 引入了它自己的网络框架，称为 Spring Web MVC。它基于 **模型-视图-控制器**（**MVC**）模式。Spring
    Web MVC 支持表示层，并帮助您构建灵活且松散耦合的基于 Web 的应用程序。Spring MVC 模块解决了企业应用程序中测试 Web 组件的问题。它允许您在不使用应用程序中的请求和响应对象的情况下编写测试用例。在这里，我们将进一步讨论它。
- en: 'In this chapter, we will not only discuss the internals of Spring MVC, but
    also about the different layers of a web application. We will see here the implementation
    of the MVC pattern including what it is, and why we should use it. We will explore
    the following topics in this chapter about Spring''s MVC web framework:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们不仅将讨论 Spring MVC 的内部结构，还将讨论 Web 应用程序的不同层。我们将在这里看到 MVC 模式的实现，包括它是什么，以及为什么我们应该使用它。在本章中，我们将探讨关于
    Spring MVC 网络框架的以下主题：
- en: Implementing MVC patterns on a web application
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Web 应用程序上实现 MVC 模式
- en: Implementing controllers patterns
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现 MVC 模式
- en: Configuring `DispatcherServlet` as the Front Controller pattern
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `DispatcherServlet` 配置为前端控制器模式
- en: Enabling Spring MVC and proxying
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启用 Spring MVC 和代理
- en: Accepting request parameters
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接受请求参数
- en: Processing the forms of a web page
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理网页的表单
- en: Implementing a view in the MVC pattern
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 MVC 模式中实现视图
- en: Creating JSP views in a web application
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Web 应用程序中创建 JSP 视图
- en: The View Helper pattern
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视图助手模式
- en: The Composite View pattern with Apache Tiled ViewResolver
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Apache Tiled ViewResolver 的组合视图模式
- en: Let's look at all the aforementioned topics in detail.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细看看上述所有主题。
- en: Implementing the MVC pattern in a web application
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Web 应用程序中实现 MVC 模式
- en: 'The **Model View Controller pattern** (**MVC pattern**) is a J2EE design pattern.
    It was first introduced by Trygve Reenskaug in his own project to separate the
    different components of the application. That time, he used this pattern on a
    desktop-based application. The main approach of this pattern is to promote the
    separation of concerns principle of the software industry. The MVC pattern divides
    the system into three kinds of components. Each component in the system has specific
    responsibilities. Let''s see these three components of this pattern:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**模型视图控制器模式**（**MVC 模式**）是一个 J2EE 设计模式。它最初由 Trygve Reenskaug 在他自己的项目中引入，以分离应用程序的不同组件。当时，他在基于桌面的应用程序上使用了这种模式。这种模式的主要方法是促进软件行业关注点分离的原则。MVC
    模式将系统划分为三种类型的组件。系统中的每个组件都有特定的职责。让我们看看这个模式中的这三个组件：'
- en: '**Model**: The model in the MVC pattern is responsible for maintaining data
    for the view so that it can be rendered in any view template. In short, we can
    say that the model is a data object, such as a `SavingAccount` in the banking
    system, and list of accounts of a branch of any bank.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模型**：在 MVC 模式中，模型负责维护视图所需的数据，以便在任何视图模板中渲染。简而言之，我们可以这样说，模型是一个数据对象，例如银行系统中的
    `SavingAccount`，或者任何银行分支的账户列表。'
- en: '**View**: The view in the MVC pattern is responsible for rendering the model
    to itself in a web application for representation of a page. It presents the data
    of the model in a readable format to the user. There are several technologies
    that provide the view, such as JSP, JSF page, PDF, XML, and so on.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**视图**：在MVC模式中，视图负责在Web应用程序中将模型渲染到自身，以表示页面。它以可读的格式向用户展示模型数据。有几种技术可以提供视图，例如JSP、JSF页面、PDF、XML等。'
- en: '**Controller**: This is an actual actionable component in the MVC pattern.
    In Software, the controller code controls the interaction between the view and
    model. Interactions such as form submission or clicking a link are part of the
    controller in an enterprise application. The controller is also responsible for
    creating and updating the model, and forwarding this model to the view for rendering.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**控制器**：这是MVC模式中的一个实际可操作的组件。在软件中，控制器代码控制视图和模型之间的交互。例如，表单提交或点击链接等交互都是企业应用程序中控制器的一部分。控制器还负责创建和更新模型，并将此模型转发到视图进行渲染。'
- en: 'Take a look at the following diagram to understand more about the MVC pattern:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 看看下面的图，以了解更多关于MVC模式的信息：
- en: '![](img/6ba5f771-d7c8-414e-9d30-a4a4234e7074.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6ba5f771-d7c8-414e-9d30-a4a4234e7074.png)'
- en: As you can see in the preceding diagram, there are three components in an application,
    and each component has its own responsibility. As we've already said, the MVC
    pattern is all about separation of concerns. In a software system, separation
    of concerns is very important to make the components flexible and easy to test
    with a clean code structure. In the MVC pattern, the **User** interacts with the
    **Controller** component through the **View** component, and the **Controller**
    component triggers the actual action to prepare the **Model** component. That
    **Model** component propagates the changes to the **View**, and finally, the **View**
    component renders the model in front of the **User**. This is the whole idea behind
    the implementation of the MVC pattern. This approach of MVC pattern properly fits
    most of the applications, especially, desktop applications. This MVC pattern is
    also known as Model 1 architecture.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可以在前面的图中看到的那样，应用程序中有三个组件，每个组件都有自己的职责。正如我们之前所说的，MVC模式就是关注点的分离。在软件系统中，关注点的分离对于使组件灵活且易于通过干净的代码结构进行测试非常重要。在MVC模式中，**用户**通过**视图**组件与**控制器**组件交互，而**控制器**组件触发实际操作以准备**模型**组件。那个**模型**组件将更改传播到**视图**，最终，**视图**组件在**用户**面前渲染模型。这就是MVC模式实现背后的整个理念。这种MVC模式的方法非常适合大多数应用程序，尤其是桌面应用程序。这种MVC模式也被称为Model
    1架构。
- en: But in case you are working with an enterprise web application, things will
    be slightly different from a desktop application, because keeping a model across
    the request life cycle can be quite difficult due to the stateless nature of an
    HTTP protocol. Let's see another modified version of the MVC pattern in the following
    section, and how the Spring framework adopts it to create the enterprise web application.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果你正在使用企业级Web应用程序，事情将略不同于桌面应用程序，因为由于HTTP协议的无状态特性，在请求生命周期中保持模型可能会相当困难。让我们在下一节中看看MVC模式的另一个修改版本，以及Spring框架如何采用它来创建企业级Web应用程序。
- en: Model 2 architecture MVC pattern with Spring
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 带有Spring的Model 2架构MVC模式
- en: The Model 1 architecture is not very straightforward for a web application.
    Model 1 also has decentralized navigation control, because in this architecture,
    each user contains a separate controller and also different logic to determine
    the next page. That time for web application, Model 1 architecture has Servlet
    and JSP as the main technologies to develop the web applications.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Model 1架构对于Web应用程序来说并不非常直接。Model 1也有分散的导航控制，因为在这个架构中，每个用户都有一个单独的控制器，以及不同的逻辑来确定下一页。那时对于Web应用程序，Model
    1架构使用Servlet和JSP作为开发Web应用程序的主要技术。
- en: 'For a web application, the MVC pattern is implemented as a Model 2 architecture.
    This pattern provides centralized navigation control logics to easily test and
    maintain the web application, and it also provides better separation of concerns
    than Model 1 architecture for web applications. The difference between the MVC
    pattern based on Model 1 Architecture and the modified MVC pattern based on Model
    2 architecture is that the latter incorporates a front controller that dispatches
    all incoming requests to other controllers. These controllers handle the incoming
    request, return the model, and select the view. take a look at the following diagram
    to better understand the Model 2 architecture MVC pattern:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Web应用程序，MVC模式作为模型2架构实现。这个模式提供了集中的导航控制逻辑，以便轻松测试和维护Web应用程序，并且它还比模型1架构的Web应用程序提供了更好的关注点分离。基于模型1架构的MVC模式和基于模型2架构修改的MVC模式之间的区别在于后者包含一个前端控制器，该控制器将所有传入的请求委派给其他控制器。这些控制器处理传入的请求，返回模型，并选择视图。查看以下图示以更好地理解模型2架构的MVC模式：
- en: '![](img/e6d0343e-df2f-4f7e-91fd-8c64d9f3a48e.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e6d0343e-df2f-4f7e-91fd-8c64d9f3a48e.png)'
- en: As you can see in the preceding diagram, a new component is introduced for the
    MVC pattern, that is, the front controller. It is implemented as a `javax.servlet.Servlet`
    servlet such as `ActionServlet` in struts, `FacesServlet` in JSF, and `DispatcherServlet`
    in Spring MVC. It handles the incoming requests, and delegates the requests to
    the specific application controller. That application controller creates and updates
    the model, and delegates it to the front controller for rendering. Finally, the
    **Front Controller** determines the specific view, and renders that model data.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，为MVC模式引入了一个新的组件，即前端控制器。它实现为一个`javax.servlet.Servlet`，例如struts中的`ActionServlet`，JSF中的`FacesServlet`和Spring
    MVC中的`DispatcherServlet`。它处理传入的请求，并将请求委派给特定的应用程序控制器。该应用程序控制器创建和更新模型，并将其委派给前端控制器进行渲染。最后，**前端控制器**确定特定的视图，并渲染该模型数据。
- en: The Front Controller design pattern
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 前端控制器设计模式
- en: 'The Front Controller design pattern is a J2EE pattern; it provides solutions
    for the following application design problems:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 前端控制器设计模式是一个J2EE模式；它为以下应用程序设计问题提供了解决方案：
- en: In a web application based on the Model 1 architecture, too many controllers
    are required to handle too many requests. It is difficult to maintain and reuse
    them.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在基于模型1架构的Web应用程序中，需要太多的控制器来处理太多的请求。维护和重用它们都很困难。
- en: Each request has its own point of entry in the web application; it should be
    a single point of entry for each request.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个请求在Web应用程序中都有自己的入口点；每个请求应该有一个单一的入口点。
- en: JSP and Servlet are the main components of the Model 1 MVC pattern, so, these
    components handle both action and view, violating the *Single Responsibility*
    principle.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSP和Servlet是模型1 MVC模式的主要组件，因此，这些组件处理动作和视图，违反了*单一职责*原则。
- en: 'The Front Controller provides the solution to the aforementioned design problems
    of the web application. In a web application, it works as the main component which
    routes all requests into framework control. This means that too many requests
    land on a single controller (Front Controller), and then, these requests are delegated
    to the specific controllers. Front Controller provides centralized control, and
    improves the reusability and manageability, because, typically, only the resource
    is registered with the web container. This controller not only handles too many
    requests, but also has following responsibilities:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 前端控制器为Web应用程序上述的设计问题提供了解决方案。在Web应用程序中，它作为主组件，将所有请求路由到框架控制。这意味着太多的请求都落在单个控制器（前端控制器）上，然后，这些请求被委派给特定的控制器。前端控制器提供集中控制，提高了可重用性和可管理性，因为通常只有资源注册在Web容器中。这个控制器不仅处理太多的请求，还有以下职责：
- en: It initializes the framework to cater to the requests
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它初始化框架以适应请求
- en: It loads the map of all URLs and the components responsible for handling the
    request
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它加载所有URL的映射以及处理请求的组件
- en: It prepares the map for the views
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它为视图准备映射
- en: 'Let''s see the following diagram for **Front Controller**:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下关于**前端控制器**的图示：
- en: '![](img/699d8a8c-7cdb-402f-8a07-9b072be15c68.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](img/699d8a8c-7cdb-402f-8a07-9b072be15c68.jpg)'
- en: As you can see in the preceding diagram, all application requests land at the
    **Front Controller**, and it delegates these requests to the configured application
    controllers.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在前面的图中可以看到的，所有应用请求都落在**前端控制器**上，并且它将这些请求委派给配置的应用控制器。
- en: The Spring Framework provides a module based on the MVC pattern, that is, Model
    2 architecture implementation. The Spring MVC module provides out-of-the-box front
    controller pattern implementation by introducing the `org.springframework.web.servlet.DispatcherServlet`
    class. This is a simple `servlet` class, and the backbone of the Spring MVC framework.
    And this Servlet is integrated with the Spring IoC container to benefit the Spring's
    dependency pattern. Spring's web framework uses Spring for its own configuration,
    and all controllers are Spring beans; these controllers are testable artifacts.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Spring框架提供了一个基于MVC模式的模块，即Model 2架构实现。Spring MVC模块通过引入`org.springframework.web.servlet.DispatcherServlet`类提供了开箱即用的前端控制器模式实现。这是一个简单的`servlet`类，是Spring
    MVC框架的骨干。而且这个Servlet与Spring IoC容器集成，以利用Spring的依赖注入模式。Spring的Web框架使用Spring进行其自身的配置，所有控制器都是Spring
    Bean；这些控制器是可测试的工件。
- en: Let's dive into the internals of Spring MVC in this Chapter, and have a closer
    look at `org.springframework.web.servlet.DispatcherServlet` in the Spring MVC
    framework, and how it handles all incoming requests to the web application.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，让我们深入Spring MVC的内部，并更仔细地观察Spring MVC框架中的`org.springframework.web.servlet.DispatcherServlet`，以及它是如何处理Web应用的所有传入请求的。
- en: Processing the life of a request
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理请求的生命周期
- en: 'Have you ever played a *wooden labyrinth board game, a maze puzzle with a steel
    ball bearing*? You might have played it in your childhood. It was a very crazy
    game. The goal of this game is to send all the steel ball bearings to the center
    of the wooden labyrinth board through interlinked curvy paths, and these curvy
    paths have cuts leading to a second curve near the center. All the balls need
    to navigate to the center of the wooden labyrinth board through these cuts between
    the curvy paths. If one steel ball reaches the center, then we have to be careful
    about this ball so that it does not move away from the center when trying to move
    another ball to the center. You can see this in the following diagram:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 您是否曾经玩过一款*木质迷宫棋盘游戏，一种带有钢球轴承的迷宫谜题*？您可能在童年时玩过。这是一款非常疯狂的游戏。这个游戏的目标是通过相互连接的弯曲路径将所有钢球轴承发送到木质迷宫棋盘的中心，这些弯曲路径在中心附近有切口，通向第二个弯曲路径。所有球都需要通过这些弯曲路径之间的切口导航到木质迷宫棋盘的中心。如果一个钢球到达中心，那么我们必须小心这个球，以确保在尝试将另一个球移动到中心时，它不会离开中心。您可以在以下图中看到这一点：
- en: '![](img/5c9421b7-9fbb-4547-909c-fd02a540e216.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5c9421b7-9fbb-4547-909c-fd02a540e216.png)'
- en: The Spring MVC framework is similar to this Wooden Labyrinth board game at first
    glance. Instead of the moving the steel ball bearings through various curvy paths
    and cuts, the Spring MVC framework moves web application requests through various
    components such as the Front Controller, that is, the dispatcher Servlet, handler
    mappings, controllers, and view resolvers.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 从直观上看，Spring MVC框架与这款木质迷宫棋盘游戏相似。Spring MVC框架不是通过移动钢球轴承通过各种弯曲路径和切口，而是通过各种组件如前端控制器（即分发Servlet）、处理器映射、控制器和视图解析器来移动Web应用请求。
- en: 'Let''s see the request processing flow in the Spring MVC Framework for a web
    application. The request processing workflow of the Spring Web MVC `DispatcherServlet`
    is illustrated in the following diagram:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看Spring MVC框架中Web应用的请求处理流程。Spring Web MVC的`DispatcherServlet`的请求处理工作流程在以下图中展示：
- en: '![](img/5a0220b4-5457-4167-b2ac-809ee99cb479.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5a0220b4-5457-4167-b2ac-809ee99cb479.png)'
- en: 'As you already know, the front controller plays a very important role in the
    Model 2 MVC pattern, because it has the responsibility to handle all incoming
    requests to the web application, and prepare the response to the browser. In the
    Spring MVC framework, `org.springframework.web.servlet.DispatcherServlet` plays
    the role of the Front Controller of the Model 2 MVC pattern. As you can see in
    the last diagram, this `DispatcherServlet` uses many other components to fulfill
    its own role. Let''s see the step-by-step request processing in the Spring MVC
    framework:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所知，前端控制器在Model 2 MVC模式中扮演着非常重要的角色，因为它负责处理所有传入的Web应用请求，并为浏览器准备响应。在Spring MVC框架中，`org.springframework.web.servlet.DispatcherServlet`
    扮演着Model 2 MVC模式的前端控制器角色。正如您在最后一张图中可以看到的，这个`DispatcherServlet` 使用了许多其他组件来履行其自身角色。让我们看看Spring
    MVC框架中逐步的请求处理过程：
- en: A user clicks on the browser or submits a web form of the application. The request
    leaves the browser, either with some additional information or with common information.
    This request lands at Spring's `DispatcherServlet`, which is a simple `servlet`
    class as other java-based web applications. It is a Front Controller of the Spring
    MVC framework, and funnels all the incoming requests through the single point.
    The Spring MVC framework centralizes the request flow control by using this Front
    Controller.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户点击浏览器或提交应用程序的Web表单。请求离开浏览器，可能带有一些附加信息或常见信息。这个请求到达Spring的`DispatcherServlet`，它是一个简单的`servlet`类，与其他基于Java的Web应用程序类似。它是Spring
    MVC框架的前端控制器，将所有传入的请求通过单一点进行集中处理。Spring MVC框架通过使用这个前端控制器来集中控制请求流程。
- en: After landing a request at Spring's `DispatcherServlet`, it delegates that request
    to the Spring MVC controller, that is, application controller. Although, , there
    may be several controllers in a Spring web application, but each request must
    be delegated to the specific controller. For that, Spring's `DispatcherServlet`
    takes help of the handler mappings configured in the web application. Handler
    mapping decides the particular controller by using the URL and request parameters.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请求到达Spring的`DispatcherServlet`后，它将请求委托给Spring MVC控制器，即应用程序控制器。尽管在一个Spring Web应用程序中可能有多个控制器，但每个请求都必须委托给特定的控制器。为此，Spring的`DispatcherServlet`借助在Web应用程序中配置的处理映射来提供帮助。处理映射通过使用URL和请求参数来确定特定的控制器。
- en: Once a particular application controller is decided by Spring's `DispatcherServlet`
    with the help of the handler mapping configuration, `DispatcherServlet` dispatches
    that request to the selected controller. This is the actual controller responsible
    for processing information according to the user's request and its parameters.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦Spring的`DispatcherServlet`借助处理映射配置确定了特定的应用程序控制器，`DispatcherServlet`将请求调度到所选控制器。这是负责根据用户的请求及其参数处理信息的实际控制器。
- en: Spring MVC's controller executes the business logic by using business services
    of the application, and it creates the model which wraps the information to be
    carried back to the user, and is displayed in the browser. This model carries
    information according to the user's request. But this model is not formatted,
    and we can use any view template technology to render the model information in
    the browser. That is why Spring MVC's controller also returns a logic view name
    along with the model. Why does it return a logic view name? This is because Spring
    MVC's controller is not tied to any specific view technology such as JSP, JSF,
    Thymeleaf, and so on.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Spring MVC的控制器通过使用应用程序的业务服务来执行业务逻辑，并创建一个模型，该模型封装了要返回给用户并显示在浏览器中的信息。这个模型根据用户的请求携带信息。但是，这个模型尚未格式化，我们可以使用任何视图模板技术来在浏览器中渲染模型信息。这就是为什么Spring
    MVC的控制器还返回一个逻辑视图名称以及模型。为什么它返回一个逻辑视图名称？这是因为Spring MVC的控制器并未绑定到任何特定的视图技术，如JSP、JSF、Thymeleaf等。
- en: Once again, Spring MVC's `DispatcherServlet` takes the help of the view resolver;
    it is configured in the web application to resolve the view. According to the
    configured `ViewResolver`, it resolves the actual view name instead of the logic
    view name. Now `DispatcherServlet` has the view as well to render the model information.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次强调，Spring MVC的`DispatcherServlet`借助视图解析器；该解析器在Web应用程序中配置，用于解析视图。根据配置的`ViewResolver`，它解析实际的视图名称，而不是逻辑视图名称。现在`DispatcherServlet`也有了视图，可以渲染模型信息。
- en: Spring MVC's `DispatcherServlet` renders the model to the view, and generates
    a user-readable format of the model's information.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Spring MVC的`DispatcherServlet`将模型渲染到视图中，并生成用户可读的模型信息格式。
- en: Finally, that information creates a response, and returns it to the user's browser
    by `DispatcherServlet`.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，这些信息生成一个响应，并通过`DispatcherServlet`返回给用户的浏览器。
- en: As you can see, there are several steps and components involved in serving a
    request of the application. Most of these components are related to the Spring
    MVC framework, and these components have their own specific responsibility to
    serve a request.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，处理应用程序请求涉及多个步骤和组件。其中大部分组件与Spring MVC框架相关，并且每个组件都有其特定的职责来处理请求。
- en: 'Till now, you have learned that `DispatcherServlet` is a key component in processing
    requests with Spring MVC. It is the heart of the Spring Web MVC. It is a front
    controller that coordinates all request handling activities analogous to Struts
    `ActionServlet` / JSF `FacesServlet`. It delegates to the web infrastructure beans,
    and invokes user web components. It is also highly flexible, configurable, and
    fully customizable. It is very flexible, because all the components used by this
    servlet are interfaces for all the infrastructure beans. The following table lists
    some of the involved interfaces provided by the Spring MVC Framework:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经了解到`DispatcherServlet`是使用Spring MVC处理请求的关键组件。它是Spring Web MVC的核心。它是一个前端控制器，类似于Struts的`ActionServlet`
    / JSF的`FacesServlet`，协调所有请求处理活动。它委托给Web基础设施bean，并调用用户Web组件。它也非常灵活、可配置和完全可定制。它非常灵活，因为该servlet使用的所有组件都是所有基础设施bean的接口。以下表格列出了Spring
    MVC框架提供的部分涉及接口：
- en: '| **Spring MVC Component** | **Role in request processing** |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| **Spring MVC 组件** | **在请求处理中的作用** |'
- en: '| `org.springframework.web.multipart.MultipartResolver` | It handles multipart
    requests such as file uploads |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| `org.springframework.web.multipart.MultipartResolver` | 它处理多部分请求，例如文件上传 |'
- en: '| `org.springframework.web.servlet.LocaleResolver` | It handles locale resolution
    and modification |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| `org.springframework.web.servlet.LocaleResolver` | 它处理区域解析和修改 |'
- en: '| `org.springframework.web.servlet.ThemeResolver` | It handles theming resolution
    and modification |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| `org.springframework.web.servlet.ThemeResolver` | 它处理主题解析和修改 |'
- en: '| `org.springframework.web.servlet.HandlerMapping` | It maps all incoming requests
    to the handler objects. |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| `org.springframework.web.servlet.HandlerMapping` | 它将所有传入请求映射到处理器对象。 |'
- en: '| `org.springframework.web.servlet.HandlerAdapter` | It is based on the Adapter
    pattern, and is used for the handler object type to execute the handler |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| `org.springframework.web.servlet.HandlerAdapter` | 它基于适配器模式，用于执行处理器对象 |'
- en: '| `org.springframework.web.servlet.HandlerExceptionResolver` | It handles the
    exceptions thrown during handler execution |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| `org.springframework.web.servlet.HandlerExceptionResolver` | 它处理处理器执行过程中抛出的异常
    |'
- en: '| `org.springframework.web.servlet.ViewResolver` | It translates the logical
    view name to an actual view implementation |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| `org.springframework.web.servlet.ViewResolver` | 它将逻辑视图名称转换为实际的视图实现 |'
- en: The components listed in the preceding table work on the Spring MVC Framework
    for the request processing life cycle in a web application. In the upcoming section,
    we'll see how to configure the Spring MVC's main component, that is, `DispatcherServlet`.
    We'll also take a closer look at the different ways of implementation and configuration
    based on either Java or XML.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 上述表格中列出的组件在Web应用程序的请求处理生命周期中工作于Spring MVC框架。在下一节中，我们将看到如何配置Spring MVC的主要组件，即`DispatcherServlet`。我们还将更详细地了解基于Java或XML的不同实现和配置方式。
- en: Configuring DispatcherServlet as the Front Controller
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将DispatcherServlet配置为前端控制器
- en: In a Java-based web application, all servlets are defined in the `web.xml` file.
    It is loaded in a web container at the bootstrap, and maps each servlet to a particular
    URL pattern. Similarly, the `org.springframework.web.servlet.DispatcherServlet`
    is the centerpiece of the Spring MVC; it needs to be configured in the same file--`web.xml`,
    and it is loaded at the bootstrap of the web application. At the time of bootstrapping,
    `DispatcherServlet` is invoked to create Spring's `org.springframework.web.context.WebApplicationContext`
    by loading the beans' configuration through Java, XML, or annotation-based. The
    servlet tries to fetch all the required components from this web application context.
    It has the responsibility to route the request through all the other components.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于Java的Web应用程序中，所有servlet都在`web.xml`文件中定义。它在启动时由Web容器加载，并将每个servlet映射到特定的URL模式。同样，`org.springframework.web.servlet.DispatcherServlet`是Spring
    MVC的核心；它需要在同一文件`web.xml`中进行配置，并在Web应用的启动时加载。在启动时，`DispatcherServlet`被调用以通过Java、XML或基于注解的方式加载bean的配置来创建Spring的`org.springframework.web.context.WebApplicationContext`。servlet试图从这个Web应用程序上下文中获取所有必需的组件。它有责任通过所有其他组件路由请求。
- en: '`WebApplicationContext` is a web version of the `ApplicationContext`, as discussed
    in previous chapters of this book. It has some additional capabilities necessary
    for web applications other than the `ApplicationContext`, such as servlet-specific
    scope request, session, and so on. The `WebApplicationContext` is bound in the
    `ServletContext`; you can also access it by using the static method of the `RequestContextUtils`
    class. Let''s see the following code snippet for this:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`WebApplicationContext` 是 `ApplicationContext` 的Web版本，如本书前几章所述。它具有一些额外的能力，对于Web应用来说，除了
    `ApplicationContext` 之外，如特定于servlet的作用域请求、会话等。`WebApplicationContext` 绑定在 `ServletContext`
    中；你也可以通过使用 `RequestContextUtils` 类的静态方法来访问它。让我们看看以下代码片段：'
- en: '`ApplicationContext webApplicationContext = RequestContextUtils.findWebApplicationContext(request);`'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`ApplicationContext webApplicationContext = RequestContextUtils.findWebApplicationContext(request);`'
- en: Defined by XML configuration
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 由XML配置定义
- en: 'As you know, `web.xml` is the root file of any web application, placed in the
    `WEB-INF` directory. It has a servlet specification, and contains all the servlet
    configuration to be bootstrapped. Let''s see the required code of the `DispatcherServlet`
    configuration in the web application, which is as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所知，`web.xml` 是任何Web应用的根文件，位于 `WEB-INF` 目录中。它包含一个servlet规范，并包含所有需要启动的servlet配置。让我们看看Web应用中
    `DispatcherServlet` 配置所需的代码，如下所示：
- en: '[PRE0]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The preceding code is the minimum required code to configure the `DispatcherServlet`
    in a Spring web application using XML-based configuration.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 前述代码是使用基于XML的配置在Spring Web应用中配置 `DispatcherServlet` 所需的最小代码。
- en: There is nothing is special in the `web.xml` file; typically, it defines only
    one servlet configuration very similar to the traditional Java web application.
    But DispatcherServlet loads a file which contains the spring beans configuration
    for the application. By default, it loads a file named `[servletname]-servlet.xml`
    from the WEB-INF directory. In our case, the file name should be `bankapp-servlet.xml`
    in the WEB-INF directory.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `web.xml` 文件中没有什么特别之处；通常，它只定义一个与传统的Java Web应用非常相似的servlet配置。但是，DispatcherServlet会加载一个包含应用spring
    beans配置的文件。默认情况下，它会从 `WEB-INF` 目录加载一个名为 `[servletname]-servlet.xml` 的文件。在我们的例子中，文件名应该是
    `bankapp-servlet.xml`，位于 `WEB-INF` 目录中。
- en: Defined by Java configuration
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 由Java配置定义
- en: 'In this chapter, instead of the XML configuration, we will use Java to configure
    `DispatcherServlet` in the servlet container for our web application. Servlet
    3.0 and later supports java-based bootstrapping, so, we can avoid using the web.xml
    file. Instead of this, we can create a java class that implements the `javax.servlet.ServletContainerInitializer`
    interface. Spring MVC provides the `WebApplicationInitializer` interface to ensure
    that your spring configuration is loaded and initialized in any Servlet 3 container.
    But the Spring MVC framework makes it even easier by providing an abstract class
    implementation of the `WebApplicationInitializer` interface. By using this abstract
    class, you just map your servlet mapping, and provide the root and MVC configuration
    classes. I, personally, prefer this way of configuration in my web application.
    The following is the code for this configuration class:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用Java而不是XML来配置我们的Web应用在servlet容器中的 `DispatcherServlet`。Servlet 3.0及以后的版本支持基于Java的启动，因此，我们可以避免使用
    `web.xml` 文件。相反，我们可以创建一个实现 `javax.servlet.ServletContainerInitializer` 接口的Java类。Spring
    MVC提供了一个 `WebApplicationInitializer` 接口，以确保你的Spring配置在任何Servlet 3容器中都被加载和初始化。但是，Spring
    MVC框架通过提供一个 `WebApplicationInitializer` 接口的抽象类实现，使这个过程变得更加简单。通过使用这个抽象类，你只需映射你的servlet映射，并提供根和MVC配置类。我个人更喜欢在我的Web应用中使用这种方式进行配置。以下是这个配置类的代码：
- en: '[PRE1]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'As seen in the preceding code, the `SpringApplicationInitializer` class extends
    the `AbstractAnnotationConfigDispatcherServletInitializer` class. It asks only
    the required information from the developer, and all configurations related to
    the `DispatcherServlet` are configured by this class using the servlet container
    interfaces. Take a look at the following diagram to understand more about the
    `AbstractAnnotationConfigDispatcherServletInitializer` class and its implementation
    to configure the `DispatcherServlet` in the application:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码所示，`SpringApplicationInitializer` 类扩展了 `AbstractAnnotationConfigDispatcherServletInitializer`
    类。它只从开发者那里获取所需的信息，并且所有与 `DispatcherServlet` 相关的配置都由这个类使用Servlet容器接口来配置。请查看以下图表，以了解更多关于
    `AbstractAnnotationConfigDispatcherServletInitializer` 类及其在应用程序中配置 `DispatcherServlet`
    的实现：
- en: '![](img/523eec9d-ebde-4091-84cc-2153ce838e82.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/523eec9d-ebde-4091-84cc-2153ce838e82.png)'
- en: You have seen that the `SpringApplicationInitilizer` class overrides three methods
    of the `AbstractAnnotationConfigDispatcherServletInitializer` class, that is,
    `getServletMappings()`, `getServletConfigClasses()`, and `getRootConfigClasses()`.
    The method `getServletMappings()` defines the servlet mapping-in our application,
    it's mapped to "`/`"**.** The method `getServletConfigClasses()` asks `DispatcherServlet`
    to load its application context with the beans defined in the `SpringMvcConfig`
    configuration class. This configuration file has bean definitions related to the
    web components such as controllers, view resolvers, and handler mappings. A Spring
    web application has another application context, and it is created by `ContextLoaderListener`.
    So, another method, `getRootConfigClasses()`, loads the other beans such as services,
    repositories, data-source, and other application beans typically required in the
    middle-tier and data-tier of the application defined in the `AppConfig` configuration
    class.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到 `SpringApplicationInitilizer` 类覆盖了 `AbstractAnnotationConfigDispatcherServletInitializer`
    类的三个方法，即 `getServletMappings()`、`getServletConfigClasses()` 和 `getRootConfigClasses()`。`getServletMappings()`
    方法定义了 servlet 映射--在我们的应用程序中，它映射到 "`/`"**。**`getServletConfigClasses()` 方法要求 `DispatcherServlet`
    使用在 `SpringMvcConfig` 配置类中定义的 bean 加载其应用程序上下文。此配置文件包含与 Web 组件（如控制器、视图解析器和处理器映射）相关的
    bean 定义。Spring Web 应用程序还有一个应用程序上下文，它是由 `ContextLoaderListener` 创建的。因此，另一个方法 `getRootConfigClasses()`
    加载了其他 bean，如服务、存储库、数据源以及其他在 `AppConfig` 配置类中定义的应用程序中间层和数据层所需的 bean。
- en: The Spring Framework provides a listener class--`ContextLoaderListener`. It
    is responsible for bootstrapping the backend application context.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: Spring 框架提供了一个监听器类--`ContextLoaderListener`。它负责启动后端应用程序上下文。
- en: 'Let''s see the following diagram to understand more about the Spring web application
    design after starting up the servlet container:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们查看以下图表，以了解在启动 servlet 容器后关于 Spring Web 应用程序设计的更多信息：
- en: '![](img/6f968668-e514-4a7e-bcdd-ca0f6ae6629c.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6f968668-e514-4a7e-bcdd-ca0f6ae6629c.png)'
- en: As you can see in the last diagram, the web component beans definitions configuration
    classes returned by the `getServletConfigClasses()` method are loaded by the `DispatcherServlet`,
    and the other application beans definition configuration classes returned by the
    `getRootConfigClasses()` method are loaded by the `ContextLoaderListener`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如你在最后一张图中看到的，`getServletConfigClasses()` 方法返回的 Web 组件 bean 定义配置类由 `DispatcherServlet`
    加载，而 `getRootConfigClasses()` 方法返回的其他应用程序 bean 定义配置类由 `ContextLoaderListener`
    加载。
- en: A Java-based web configuration will only work when deploying to a server that
    supports **Servlet 3.0**, such as **Apache Tomcat 7 or higher.**
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 基于 Java 的 Web 配置仅在部署到支持 **Servlet 3.0** 的服务器上时才有效，例如 **Apache Tomcat 7 或更高版本**。
- en: Let's see how to enable more features of the Spring MVC Framework in the coming
    section.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看在下一节中如何启用 Spring MVC 框架的更多功能。
- en: Enabling the Spring MVC
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启用 Spring MVC
- en: There are many ways to configure the `DispatcherServlet` and other web components.
    There are many features of the Spring MVC framework which are not enabled by default,
    such as `HttpMessageConverter`, Support for validating `@Controller` inputs with
    `@Valid`, and so on. So, we can enable these features by using either a Java-based
    configuration or XML configuration.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多方法可以配置 `DispatcherServlet` 以及其他 Web 组件。Spring MVC 框架有许多默认未启用的功能，例如 `HttpMessageConverter`，支持使用
    `@Valid` 验证 `@Controller` 输入，等等。因此，我们可以通过使用基于 Java 的配置或 XML 配置来启用这些功能。
- en: 'To enable the MVC Java config, add the annotation `@EnableWebMvc` to one of
    your `@Configuration` classes, as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用 MVC Java 配置，将注解 `@EnableWebMvc` 添加到你的 `@Configuration` 类之一，如下所示：
- en: '[PRE2]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In XML configuration, we can use MVC namespace, there is an `<mvc:annotation-driven>`
    element that you can use to enable the annotation-driven Spring MVC.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在 XML 配置中，我们可以使用 MVC 命名空间，其中有一个 `<mvc:annotation-driven>` 元素，你可以使用它来启用基于注解的
    Spring MVC。
- en: '[PRE3]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The Spring MVC advanced feature can be enabled in a Spring web application
    either by using the `@EnableWebMvc` annotation, or by using the XML namespace
    `<mvc:annotation-driven/>`. The Spring MVC Framework also allows you to customize
    the default configuration in Java by extending the `WebMvcConfigurerAdapter` class,
    or by implementing the `WebMvcConfigurer` interface. Let''s see the modified configuration
    file after adding a bit more configuration:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As seen in the preceding code, the configuration class `SpringMvcConfig` is
    annotated with `@Configuration`, `@ComponentScan`, and `@EnableWebMvc`. Here,
    the `com.packt.patterninspring.chapter10.bankapp.web.controller` package will
    be scanned for components. This class extends the `WebMvcConfigurerAdapter` class,
    and overrides the `configureDefaultServletHandling()` method. We have also configured
    a `ViewResolver` bean.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: Till now, you have learned what is the MVC pattern and architecture, and how
    to set up `DispatcherServlet` and enable the essential Spring MVC components for
    a Spring web application. In the upcoming section, we'll discuss how to implement
    controllers in a Spring application, and how these controllers handle web requests.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: Implementing controllers
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have seen in the MVC pattern, controllers are also one of the crucial
    components of the MVC pattern. They are responsible for executing the actual request,
    preparing the model, and sending this model along with logical view name to the
    front controller. In a web application, the controllers work between the web layer
    and the core application layer. In the Spring MVC framework, controllers are also
    more like POJO classes with methods; these methods are known as handlers, because
    these are annotated with the `@RequestMapping` annotation. Let's see how to define
    controller classes in a Spring web application.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: Defining a controller with @Controller
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s create a controller class for our bank application. `HomeController`
    is a controller class that handles requests for `/` and renders the homepage of
    the bank application:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As you can see in the preceding code, the `HomeController` class contains the
    `home()` method. It is a handler method, because it is annotated with the `@RequestMapping`
    annotation. It specifies that this method handles all the requests that are mapped
    to the `/` URL. Another thing to notice is that our controller class, `HomeController`,
    is also annotated with the `@Controller` annotation. As we know, `@Controller`
    is a stereotype annotation, and it is also used to create the bean in the Spring
    IoC container similar to the other Meta annotations of the `@Component` annotation
    such as `@Service` and `@Repository.` Yes, this annotation specifies any class
    as the controller, and adds some more capability of Spring MVC to that class.
    You could also use the `@Component` annotation instead of `@Controller` to create
    Spring beans in a web application, but in this case, that bean does not have the
    capability of the Spring MVC framework such as exception handling at web layer,
    handler mapping, and so on.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a closer look at the `@RequestMapping` annotation, and also the composed
    variants of the `@RequestMapping` annotation.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: Mapping requests with @RequestMapping
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The previously defined `HomeController` class has only one handler method,
    and this method is annotated with the `@RequestMapping` annotation. Here, I have
    used two attributes of this annotation--one is value to map the HTTP request to
    the `/` pattern, and the other attribute is a method for supporting the HTTP `GET`
    method. We can define multiple URL mappings with one handler method. Let''s see
    this in the following code snippet:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In the preceding code, the `@RequestMapping` annotation has an array of string
    values for the value attribute of this annotation. Now, this handler method is
    mapped with two URL patterns, such as `/` and `/index`. The Spring MVC''s `@RequestMapping`
    annotation supports several HTTP methods such as `GET`, `POST`, `PUT`, `DELETE`,
    and so on. As of version 4.3, Spring composed `@RequestMapping` variants, and
    now provides simple methods for the mapping of common HTTP methods, as shown in
    the following expressions:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This is the modified version of `HomeController` with composed annotation mappings:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We can use the `@RequestMapping` annotation at both locations: at the class
    level, and at the method level. Let''s see examples for this:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '@RequestMapping at method level'
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Spring MVC allows you to use the `@RequestMapping` annotation at the method
    level to make this method as handler method in the Spring web application. Let''s
    see how to use it in the following class:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'As you can see in the preceding code, I have used the `@RequestMapping` annotation
    with three methods `home()`, `create()`, and `saveUser()`. Here I have also used
    the attributes "value" and "method" of this annotation. The "value" attribute
    has the request mapping with request URL and "method" attribute is used to define
    the HTTP request methods such GET or POST. Mapping rules are, typically, URL-based,
    and, optionally, use wild cards, as shown here:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the preceding example, the handler methods have some arguments as well, so
    we can pass any number of arguments of any type. The Spring MVC will handle these
    arguments as request parameters. Let's see first how to define `@RequestMapping`
    at the class level, then we will discuss the request parameters.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '@RequestMapping at the class level'
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Spring MVC allows you to use the `@RequestMapping` annotation at the class
    level. This means we can annotate the controller class with `@RequestMapping`,
    as shown in the following code snippet:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As you have seen in the preceding code, the `HomeController` class is annotated
    with the `@RequestMapping` and `@Controller` annotations. But the HTTP method
    is still defined above the handler methods. Class-level mapping is applied with
    all the handler methods defined under this controller.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: 'After the Spring MVC configuration, we created a controller class with the
    handler methods. Let''s test this controller before moving ahead with more details.
    In this book, I haven''t use any JUnit test cases, so here, I will just run this
    web application on the Tomcat container. You can see the output on the browser
    as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f4c6014d-f22c-4a85-91a5-0799fb2c7d8b.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
- en: The last image is the homepage of our **Bank Management System** web application.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: Before Spring 3.1, the Spring MVC mapped the requests to handler methods using
    two steps. First, the controller was selected by `DefaultAnnotationHandlerMapping`,
    and then, the actual method was mapped with the incoming requests by the `AnnotationMethodHandlerAdapter`.
    But as of Spring 3.1, Spring MVC maps the requests, in one step, directly to the
    handler methods by using `RequestMappingHandlerMapping`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we'll see how to define the handler methods, and the return
    type and parameters allowed for the handler methods in Spring MVC.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: Defining @RequestMapping handler methods
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the Spring MVC Framework, the `@RequestMapping` handler methods are very
    flexible in defining signatures. You can pass any number of arguments in any order.
    These methods support most type of arguments, and are also very flexible in the
    return type as well. It can have several return types, some of which are listed
    next:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: Supported method argument types
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Request or response objects (Servlet API)
  id: totrans-132
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Session object (Servlet API)
  id: totrans-133
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.util.Locale`'
  id: totrans-134
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.util.TimeZone`'
  id: totrans-135
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.io.InputStream` / `java.io.Reader`'
  id: totrans-136
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.io.OutputStream` / `java.io.Writer`'
  id: totrans-137
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.security.Principal`'
  id: totrans-138
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@PathVariable`'
  id: totrans-139
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@RequestParam`'
  id: totrans-140
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@RequestBody`'
  id: totrans-141
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@RequestPart`'
  id: totrans-142
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.util.Map` / `org.springframework.ui.Model` / `org.springframework.ui.ModelMap`'
  id: totrans-143
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`org.springframework.validation.Errors` / `org.springframework.validation.BindingResult`'
  id: totrans-144
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Supported method return types:'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ModelAndView`'
  id: totrans-146
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Model`'
  id: totrans-147
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Map`'
  id: totrans-148
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`View`'
  id: totrans-149
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`String`'
  id: totrans-150
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void`'
  id: totrans-151
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HttpEntity<?>` or `ResponseEntity<?>`'
  id: totrans-152
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HttpHeaders`'
  id: totrans-153
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Callable<?>`'
  id: totrans-154
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DeferredResult<?>`'
  id: totrans-155
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: I have listed some of the supported return types and method argument types.
    It seems that Spring MVC is very flexible and customizable in the nature of defining
    the request handler methods unlike other MVC frameworks.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Spring MVC framework, even the handler method can have any ordering
    of the arguments, but in case of Errors or `BindingResult` parameters, we have
    to put these parameters first, followed by the model object for being bound immediately,
    because the handler method might have any number of model objects, and Spring
    MVC creates separate instances of the Errors or `BindingResult` for each of them.
    For example:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '**Invalid location** `@PostMapping`'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '`public String saveUser(@ModelAttribute ("user") User user, ModelMap model,
    BindingResult result){...}`'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '**Valid location** `@PostMapping`'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '`public String saveUser(@ModelAttribute ("user") User user, BindingResult result,
    ModelMap model){...}`'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: Let's see how to pass model data to the view layer in the upcoming section.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: Passing model data to the view
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As of now, we have implemented a very simple `HomeCotroller`, and tested it.
    But in the web application, we have also passed model data to the view layer.
    That model data we passed in the model (in a simple word, it is `Map`), and that
    model is returned by the controller along with logical view name. As you already
    know, Spring MVC supports several return types of the handler method. Let''s see
    the following example:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As you can see in the preceding example, the `AccountController` class has three
    handler methods. Two handler methods return the model data along with the logical
    view name. But in this example, I am using Spring MVC's `ModelMap`, so, we don't
    need to forcefully return as logical view, it binds automatically with the response.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: Next you'll learn how to accept request parameters.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: Accepting request parameters
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In a Spring web application, sometimes, we just read the data from the server
    side like in our example. Reading data for all the accounts was a simple read
    call, and no request parameter was required. But in case you want to fetch data
    for a particular account, then you have to pass the account ID with the request
    parameters. Similarly, for creating a new Account in the bank, you have to pass
    an account object as a parameter. In Spring MVC, we can accept the request parameters
    in the following ways:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: Taking query parameters
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Taking request parameters via path variables
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Taking form parameters
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's look at each of these ways one by one.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: Taking query parameters
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In a web application, we can fetch the request parameters from the request-the
    account ID in our example if you want to access the details of a particular account.
    Let''s fetch the account ID from the request parameter using the following code:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In the preceding code snippet, I have used the traditional way to access the
    request parameters. The Spring MVC framework provides an annotation, `@RequestParam`,
    to access the request parameters. Let''s use the `@RequestParam` annotation to
    bind the request parameters to a method parameter in your controller. The following
    code snippet shows the usage of the `@RequestParam` annotation. It extracts the
    parameter from the request, and performs type conversion as well:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the preceding code, we access the request parameter by using the `@RequestParam`
    annotation, and you can also notice that I didn't use the type conversion from
    `String` to `Long`, it will be done automatically by this annotation. One more
    thing to note here is that parameters using this annotation are required by default,
    but Spring allows you to override this behavior by using the `required` attribute
    of the `@RequestParam` annotation.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now let's see how to use path variables to take input as part of the request
    path.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: Taking request parameters via path variables
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Spring MVC allows you to pass parameters in the URI instead of passing them
    through request parameters. The passed values can be extracted from the request
    URLs. It is based on URI templates. It is not a Spring-specific concept, and is
    used in many frameworks by using `{...}` placeholders and the `@PathVariable`
    annotation. It allows clean URLs without request parameters. The following is
    an example:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In the previous handler, the method can handle the request like this:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '![](img/ea3b22a3-5441-481c-aed4-8f39359f9b3c.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
- en: 'But in the preceding example, the handler method can handle the request such
    as:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '![](img/788b5f14-6d7c-4ad5-9af7-c6d175d5155a.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
- en: We have seen in the preceding code and images how to pass a value either by
    using request parameters or using path parameters. Both ways are fine if you are
    passing small amounts of data on a request. But in some cases, we have to pass
    a lot of data to the server, such as form submission. Let's see how to write controller
    methods that handle form submissions.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: Processing forms of a web page
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you know, in any web application, we can send and receive data from the server.
    In a web application, we send the data by filling out forms, and submitting this
    form to the server. Spring MVC also provides support for form handling of the
    client end by displaying the form, validating the form data, and submitting this
    form data.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: 'Basically, Spring MVC handles the form displaying and form processing first.
    In the Bank management application, you will need to create a new user, and open
    a new account in the bank, so, let''s create a controller class, AccountController,
    with a single request-handling method for displaying the account open form, as
    follows:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `openAccountForm()` method's `@GetMapping` annotation declares that it will
    handle the HTTP GET requests for /open-account. It's a simple method, taking no
    input and only returning a logical view named `accountForm`. We have configured
    `InternalResourceViewResolver`, which means that the JSP at `/WEB-INF/views/accountForm.jsp`
    will be called on to render the open account form.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the JSP you''ll use for now:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'As you can see in the preceding code, we have an open account form. It has
    some fields such as `AccountId`, `Account Name`, and `Initial Balance`. This JSP
    page has the `<form>` tag for the form, and this `<form>` tag doesn''t have any
    action parameter. This means that when we submit this form, it will post the form
    data to the same URI `/open-account` with the `POST` HTTP method call. The following
    screenshot displays the account form:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/22c32b1b-53cf-4171-8577-146ea46a1bf5.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
- en: Let's add another method to handle the call for the HTTP `POST` method with
    the same URI, `/open-account`.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a form handling controller
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s see the same `AccountController` class by adding another handler method
    to handle the HTTP `POST` request for the URI `/open-account` in the web application:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'As you can see in the preceding code, we have added two more handler methods
    in the `AccountController` method, and also injected the service `AccountService`
    with this controller to save the account details in the database. Whenever we
    process the `POST` request from the open account form, the controller accepts
    the account form data, and saves it to the database by using the injected account
    service. It will accept the account form data as an Account object. You may also
    notice here that after processing the form data using the HTTP `POST` method,
    the handler method redirects to the account details page. It is also a better
    practice to redirect after `POST` submission to prevent accidentally submitting
    the form twice. The following screen is displayed after submission of the request:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ba094c31-5de1-41f8-a501-baf17624c557.png)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
- en: 'As you can see in the preceding output on the browser, this page is rendered
    after submitting the account form. Because we have added one request handler method,
    this handler method handles the request, and renders another web page including
    the account details. The following JSP page is rendered as the view of the preceding
    output:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In this last code, the handler method sends the `Account` object to the model,
    and also returns the logical view name. This JSP page renders the `Account` object
    taken from the response.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: One thing to be noticed here is that the Account object has ID, name, and balance
    properties, which will be populated from the request parameters of the same name
    as the field name in the account form. If any object property name matches the
    field name of the HTML form, then this property will be initialized with a NULL
    value.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: Data binding with Command Design pattern
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Encapsulate a request as an object, thereby letting you parameterize clients
    with different requests, queue or log requests, and support undoable operations.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '- GOF Design Pattern'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: You learned about the Command Design pattern in [Chapter 3](bd05acbb-a42a-4070-9e01-54a8ce049e41.xhtml),
    *Consideration of Structural and Behavioral Patterns*. It is a part of the Behavioral
    pattern family of the GOF pattern. It is a very simple data-driven pattern. It
    allows you to encapsulate your request data into an object, and pass that object
    as a command to the invoker method, and that method returns the command as another
    object to the caller.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: 'Spring MVC implements the Command Design pattern to bind the request data from
    the web form as an Object, and passes that object to the request handler method
    in the controller class. Here, we will explore how to use this pattern to bind
    the request data to the Object, and also explore the benefits and possibilities
    of using data binding. In the following class, the `Account` java bean is a simple
    object with three properties--`id`, `name`, and `balance`:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Either we submit the web form with the input text fields' names the same as
    the Object properties' name, or we receive the request as `http://localhost:8080/Chapter-10-Spring-MVC-pattern/account?id=10000`.
    In both cases, behind the scenes, Spring calls the setter methods of the Account
    class to bind the request data or web form data to the object. Spring also allows
    you to bind indexed collections such as List, Map, and others.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also customize data binding. Spring provides these two ways to customize
    data binding:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '**Global Customization**: It customizes the data-binding behavior across the
    web application for a particular Command Object'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Per Controller Customization**: It customizes the data-binding behavior per
    controller class for a particular Command Object'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here, I will discuss only the per controller customization. Let''s see the
    following code snippet for customizing data binding for the `Account` object:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As you can see in the preceding code, `AccountController` has a `initBinder(WebDataBinder
    binder)` annotated with the `@InitBinder` annotation. This method must have a
    void return type, and have an `org.springframework.web.bind.WebDataBinder` as
    a method argument. The `WebDataBinder` object has several methods; we have used
    some them in the preceding code. `WebDataBinder` is used to customize the data
    binding.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: Using @ModelAttributes for customizing data binding
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Spring MVC provides one more annotation, `@ModelAttributes`, for binding data
    to the `Command` object. It is another way to bind the data and to customize the
    data binding. This annotation allows you to control the creation of the `Command`
    object. In a Spring MVC application, this annotation can be used on a method and
    on method arguments. Let''s see the following examples:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: Using `@ModelAttribute` on methods
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can use the `ModelAttribute` annotation on methods to create an object to
    be used in our form, as follows:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Using `@ModelAttribute` on method arguments
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can also use this annotation on a method argument. In this case, the handler
    method''s arguments are looked up from the model object. If these are not available
    in the model, then they are created by using the default constructor:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As you can see in the last code snippet, the `@ModelAttribute` annotation is
    used on the method argument. This means that the `Account` object fetches from
    the model object. If it is not there, it will be created by using the default
    constructor.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: When the `@ModelAttribute` annotation is put on a method, this method will be
    called before the request handling method is called.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: Till now, we have seen how Spring MVC handles requests and request parameters
    either in the traditional way or by using the `@RequestParam`, `@PathVariable`
    annotations. We have also seen how to process the form web page and handle the
    `POST` request with the form data binding to an object in the controller layers.
    Now let's move to see how to validate if the submitted form data is valid or invalid
    for the business.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: Validating forms input parameters
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a web application, validation of the web form data is very important, because
    end users can submit any thing. Suppose in an application, a user submits the
    account form by filling in the account name, then it could create the new account
    in the bank with account holder name. So, we have to ensure the validity of the
    form data before creating the new record in the database. You do not need to handle
    the validation logic in the handler method. Spring provides support for the JSR-303
    API. As of Spring 3.0, Spring MVC supports this Java Validation API. There isn't
    much configuration required to configure the Java Validation API in your Spring
    web application-you just add the implementation of this API in your application
    class path such as Hibernate Validator.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: 'The Java Validation API has several annotations to validate the properties
    of the `Command` object. We can place constraints on the value of the properties
    of the `Command` object. In this chapter, I have not explored all these annotations,
    but let''s see the following examples with some of these annotations:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: As you can see in the preceding code, the properties of the Account class are
    now annotated with `@NotNull` to ensure that the value must not be null, and some
    properties are also annotated with the `@Size` annotation to ensure the count
    of characters between the minimum and maximum lengths.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: 'Only annotating the properties of the `Account` object is not enough. We have
    to annotate the save() method argument of the `AccountController` class as follows:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'As you can see in the preceding code, the `Account` parameter is now annotated
    with `@Valid` to indicate to Spring that the command object has validation constraints
    that should be enforced. Let''s see the output when we submit the web open account
    form while filling invalid data:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/de979414-1011-4428-bd1d-f2e349800dc7.png)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
- en: As I had submitted this form without data, it has been redirected to the same
    page with validation errors. Spring also allows you to customize these validation
    messages by configuring these messages into the properties file.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: As of now, in this chapter, you have learned about the controller component
    of the MVC pattern. You also learned how to create and configure in a web application.
    Let's explore another component of the MVC pattern, view, in the upcoming section.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: Implementing View in the MVC pattern
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'View is the most important component of the MVC pattern. The controller returns
    the model to the front controller along with the logical view name. The front
    controller resolves to the actual view by using the configured view resolver.
    Spring MVC provides several view resolvers to support multiple view technologies,
    such as JSP, Velocity, FreeMarker, JSF, Tiles, Thymeleaf, and so on. You have
    to configure the view resolver according to the view technology that you use in
    your web application. Take a look at the following figure to understand more about
    the view pattern in Spring MVC:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a948ab9b-14a7-4fc2-9647-eea78f448711.jpg)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
- en: As you can see in the diagram, Spring MVC's Front Controller has several view
    resolvers according to the different view technologies. But in this chapter, we
    will use only JSP as the view technology, and so, we will explore only the JSP-related
    view resolver, `InternalResourveViewResolver`.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: A View renders the web output. There are many built-in views available for JSPs,
    XSLT, templating approaches (Velocity, FreeMarker), and others. Spring MVC also
    has view support classes for creating PDFs, Excel spreadsheets, and so on.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: Controllers, typically, return a *logical view name* in String MVC, but Spring's
    `ViewResolvers` select a View based on the view name. Let's see how to configure
    the `ViewResolver` in a Spring MVC application.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: Defining ViewResolver in the Spring MVC
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Spring MVC, the `DispatcherServlet` delegates to a `ViewResolver` to obtain
    the View implementation based on the view name. The default `ViewResolver` treats
    the view name as a web application-relative file path, that is, a JSP--`/WEB-INF/views/account.jsp`.
    We can override this default by registering a `ViewResolver` bean with the `DispatcherServlet`.
    In our web application, we have used `InternalResourceViewResolver`, because it
    is related to the JSP view, but there are several other options available in Spring
    MVC, as mentioned in the previous section.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: Implement the View
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following code renders the view in the MVC pattern:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: '`accountDetails.jsp`:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: As you can see in the preceding code, Spring MVC renders this view when the
    controller will be returned `accountDetails` as the logical view name. But how
    is it resolved by Spring MVC? Let's see the configuration of the `ViewResolver`
    in the Spring configuration file.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: Register ViewResolver with Spring MVC
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s register the JSP-related `ViewResolver`, that is, configure `InternalResourceViewResolver`
    in the Spring web application, as follows:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'As in the preceding code, suppose the controller returns with the logical view
    name, `accountDetails`. All the JSP files for views are placed in the `/WEB-INF/views/`
    directory of the web application. The `accountDetails.jsp` view file for account
    details. As per the preceding configuration file, the actual view name is derived
    by adding the prefix `/WEB-INF/views/` and the postfix `.jsp` to the logical view
    name returned by the application controller. If the application controller returns
    `accountDetails` as the logical view name, then `ViewResolver` changes it to the
    physical by adding a prefix and postfix to the logical view name; finally, it
    is changed to `/WEB-INF/views/accountDetails.jsp` in the our application. The
    following diagram illustrates how Spring MVC''s Front Controller resolves the
    view in a Spring web application:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/51101b57-a465-4d07-b31e-943299cc7c69.png)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
- en: This last diagram illustrates the whole picture of the Spring MVC request flow
    with all the components (**Model**, **View**, and **Controllers**) of the MVC
    pattern, and the Front controller pattern. Any request, either HTTP `GET` or `POST`,
    lands at the Front Controller first, which is, actually, the `DispatcherServlet`
    in Spring MVC. The controllers in a Spring web application are responsible for
    generating and updating the **Model**, and the **Model** is another component
    of the MVC pattern. Finally, the controller returns that model along with the
    logical view name to the `DispatcherServlet`. It consults with the configured
    view resolver, and resolves the physical path of the view. The **View** is another
    component of the MVC pattern.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we'll elaborate on the View Helper pattern, and how Spring
    support the pattern in a Spring web application.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: The View Helper pattern
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The View Helper pattern separates the static view, such as JSP, from the processing
    of the business model data. The View Helper pattern is used in the presentation
    layer by adapting the model data and the View components. The View Helper can
    format the model data according to the business requirement, but it cannot generate
    model data for the business. The following diagram illustrates the View Helper
    pattern:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/386581b5-f6f4-479c-b017-501fd2e43358.png)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
- en: 'We know that View is the a static and formatted component of the MVC pattern,
    but sometimes, we need some business processing the presentation layer. If you
    are using JSPs, then you could use a scriptlet for the business processing at
    the the view layer, but using a scriptlet is not a best practice, because it promotes
    tight coupling between the view and business logic. But some View Helper classes
    based on the View Helper pattern take over that responsibility of business processing
    at the presentation layer. Some of the technologies based on the View Helper pattern
    areas follows:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: The JavaBeans `View` helper
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The tag `LibraryView` helper
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using JSTL tags
  id: totrans-272
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Using spring tags
  id: totrans-273
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Using third-party tag Library
  id: totrans-274
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following tag libraries are used in our web application in this chapter:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: As you can see in the preceding code, I have used the JSTL tag library for the
    check not empty account in the model, and the Spring tag library to create the
    open account form in the web application.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, you'll learn about the Composite View pattern, and how
    Spring MVC supports it to implement it in the web application.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: Composite View pattern using Apache tile view resolver
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In a web application, the View is one of the most important components. Developing
    this component is not as easy as seems. It is very complicated to maintain, and
    a daunting task. Whenever we create the view for a web application, we always
    focus on the reusability of the view components. We can define some static templates
    that can be reused in other view pages in the same web application. According
    to the Composite Design pattern of the GOF pattern, we compose sub-view components
    for a particular view component. The Composite View pattern promotes reusability
    of views, and is easy to maintain due to the multiple sub-views instead of creating
    a large and complicated view. The following diagram illustrates the Composite
    View pattern:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: '>![](img/003641b6-a597-4d9d-91f0-269c14dc2824.png)'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the previous diagram, we can create multiple sub-views to
    create the view in a web application, and these sub-views will be reused across
    the web application.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: Spring MVC provides support for implementation of the Composite View pattern
    through frameworks such as SiteMesh and Apache tiles. Here we will explore Apache
    Tiles with a Spring MVC application. Let's see how to configure the Apache Tiles
    `ViewResolver`.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: Configuring a Tiles ViewResolver
  id: totrans-284
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s configure Apache Tiles in the Spring MVC application. In order to configure
    it, we have to configure two beans in the Spring configuration file as follows:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In the preceding configuration file, we configured two beans, `TilesConfigurer`
    and the `TilesViewResolver` bean. The first bean, `TilesConfigurer`, has the responsibility
    to locate and load tile definitions, and, generally, coordinate Tiles. The second
    bean, `TilesViewResolver`, is responsible for resolving logical view names to
    tile definitions. The XML file `tiles.xml` has the tile definitions in the application.
    Let''s see the following code for the tiles configuration file:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In the preceding code, the `<tiles-definitions>` element has multiple `<definition>`
    elements. Each `<definition>` element defines a tile, and each tile references
    a JSP template. Some `<definition>` elements extend the base tile definition,
    because the base tile definition has the common layout for all the views in the
    web application.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see the base definition template, that is, `mainTemplate.jsp`:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In this preceding JSP file, I have used the `<tiles:insertAttribute>` JSP tag
    from the `tiles` tag library to insert other templates.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: Let's now see some best practices used to design and develop a web application.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: Best practices for web application design
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following are some of the best practices that must be considered while
    designing and developing a web application:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: Spring MVC is the best choice to design and develop a web application because
    of the Spring DI pattern and the very flexible MVC pattern with Spring. Spring's
    `DispatcherServlet`, too, is very flexible and customizable.
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In any web application using the MVC pattern, the front controller should be
    generic and as lightweight as possible.
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is important to maintain a clear separation of concerns across the layers
    of the web application. Separating layers improves the clean design of the application.
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If an application layer has too many dependencies with the other layers, as
    a best approach, introduce another layer to reduce the dependency of that layer.
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Never inject a DAO object to the controllers in the web application; always
    inject a services object to the controller. The DAO objects must be injected with
    the service layers so that the service layer talks to the data access layer, and
    the presentation layer talks to the service layer.
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Application layers such service, DAO, and presentation layers must be pluggable,
    and must not be bound with the implementation, that is, using interfaces reduces
    the actual coupling to concrete implementations, as we know that loosely coupled
    layered applications are easier to test and maintain.
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is strongly recommended to place JSP files in the WEB-INF directory, because
    this location is not accessed by any client.
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Always specify the name of the command object in the JSP file.
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JSP files must not have any business logic and business processing. For such
    a requirement, we strongly recommend the use of View helper classes such as tags,
    libraries, JSTL, and so on.
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remove the programming logic from template-based views like JSP.
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create reusable components that can be used to combine model data across views.
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each component of the MVC pattern must have a consistent behavior for which
    the MVC introduced it. This means that the controller should follow the Single
    Responsibility Principle. Controllers are responsible only for delegating business
    logic invocation and view selection.
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, be consistent with naming of the configuration files. For example,
    web beans such as controllers, interceptors, and view resolvers must be defined
    in separate configuration files. Other application beans such as services, repositories,
    and so on must be defined into another, separate file. Similarly for security
    concerns.
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  id: totrans-309
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you've seen how the Spring Framework allows you to develop
    a flexible and loosely coupled web-based application. Spring employs annotations
    for near-POJO development model in your web application. You learned that with
    Spring MVC, you can create a web-based application by developing controllers that
    handle requests, and these controllers are very easy to test. In this chapter,
    we covered the MVC pattern, including its origins and what problems it solves.
    The Spring Framework has implemented MVC patterns, which means that for any web
    application, there are three components--Model, View, and Controller.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: Spring MVC implements the Application Controller and Front Controller patterns.
    Spring's dispatcher servlet (`org.springframework.web.servlet.DispatcherServlet`)
    works as a Front Controller in a web-based application. This dispatcher or front
    controller routes all requests to the application controller by using handler
    mapping. In Spring MVC, the controller classes have extremely flexible request
    handler methods. And these handler methods handle all the requests of a web application.
    There several ways, as we explained in this chapter, to handle request parameters.
    The `@RequestParam` annotation is one of the ways to handle request parameters,
    and it is also very easy to test without using the http request object in test
    cases.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we explored the request processing workflow, and discussed
    all the components which play a role in this workflow. The `DispatcherServlet`
    can be considered the main component in Spring MVC; it plays the role of a front
    controller in Spring MVC. Another main component is the view resolver, which has
    the responsibility to render the model data to any view template such JSP, Thymeleaf,
    FreeMarker, velocity, pdf, xml and so on depending om the configured view resolver
    in the web application. Spring MVC provides support for several view technologies,
    but, in this chapter, we briefly looked at how to write views for your controllers
    using JSPs. We can also add consistent layouts to your views using Apache tiles.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: And finally, we covered the web application architecture, and discussed the
    different layers in a web application such as domain, user interface, web, service,
    and data access. We created a small bank management web application, and deployed
    it to the tomcat server.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
