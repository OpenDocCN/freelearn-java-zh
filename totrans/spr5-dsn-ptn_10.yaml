- en: Implementing the MVC Pattern in a Web Application using Spring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last couple of chapters in the book, we have seen that all examples were
    based on a standalone application using the Spring Framework. We have seen how
    Spring works to provide important features, such as the dependency injection pattern,
    bean life cycle management, AOP, cache management, and Spring, in the backend
    using the JDBC and ORM modules. In this chapter, we will see how Spring works
    in the web environment to address some common problems of any web application,
    such as workflow, validations, and state management.
  prefs: []
  type: TYPE_NORMAL
- en: Like other modules in the Spring Framework, Spring has introduced its own web
    framework, known as Spring Web MVC. It is based on the **Model-View-Controller**
    (**MVC**) pattern. Spring Web MVC supports the presentation tier, and helps you
    to build a flexible and loosely coupled web-based application. The Spring MVC
    module addresses the problem of testing the web components in the enterprise application.
    It allows you to write the test case without using request and response objects
    in the application. Here, we will discuss more about it.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will not only discuss the internals of Spring MVC, but
    also about the different layers of a web application. We will see here the implementation
    of the MVC pattern including what it is, and why we should use it. We will explore
    the following topics in this chapter about Spring''s MVC web framework:'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing MVC patterns on a web application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing controllers patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring `DispatcherServlet` as the Front Controller pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enabling Spring MVC and proxying
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accepting request parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Processing the forms of a web page
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a view in the MVC pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating JSP views in a web application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The View Helper pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Composite View pattern with Apache Tiled ViewResolver
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's look at all the aforementioned topics in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the MVC pattern in a web application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The **Model View Controller pattern** (**MVC pattern**) is a J2EE design pattern.
    It was first introduced by Trygve Reenskaug in his own project to separate the
    different components of the application. That time, he used this pattern on a
    desktop-based application. The main approach of this pattern is to promote the
    separation of concerns principle of the software industry. The MVC pattern divides
    the system into three kinds of components. Each component in the system has specific
    responsibilities. Let''s see these three components of this pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Model**: The model in the MVC pattern is responsible for maintaining data
    for the view so that it can be rendered in any view template. In short, we can
    say that the model is a data object, such as a `SavingAccount` in the banking
    system, and list of accounts of a branch of any bank.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**View**: The view in the MVC pattern is responsible for rendering the model
    to itself in a web application for representation of a page. It presents the data
    of the model in a readable format to the user. There are several technologies
    that provide the view, such as JSP, JSF page, PDF, XML, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Controller**: This is an actual actionable component in the MVC pattern.
    In Software, the controller code controls the interaction between the view and
    model. Interactions such as form submission or clicking a link are part of the
    controller in an enterprise application. The controller is also responsible for
    creating and updating the model, and forwarding this model to the view for rendering.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Take a look at the following diagram to understand more about the MVC pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6ba5f771-d7c8-414e-9d30-a4a4234e7074.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see in the preceding diagram, there are three components in an application,
    and each component has its own responsibility. As we've already said, the MVC
    pattern is all about separation of concerns. In a software system, separation
    of concerns is very important to make the components flexible and easy to test
    with a clean code structure. In the MVC pattern, the **User** interacts with the
    **Controller** component through the **View** component, and the **Controller**
    component triggers the actual action to prepare the **Model** component. That
    **Model** component propagates the changes to the **View**, and finally, the **View**
    component renders the model in front of the **User**. This is the whole idea behind
    the implementation of the MVC pattern. This approach of MVC pattern properly fits
    most of the applications, especially, desktop applications. This MVC pattern is
    also known as Model 1 architecture.
  prefs: []
  type: TYPE_NORMAL
- en: But in case you are working with an enterprise web application, things will
    be slightly different from a desktop application, because keeping a model across
    the request life cycle can be quite difficult due to the stateless nature of an
    HTTP protocol. Let's see another modified version of the MVC pattern in the following
    section, and how the Spring framework adopts it to create the enterprise web application.
  prefs: []
  type: TYPE_NORMAL
- en: Model 2 architecture MVC pattern with Spring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Model 1 architecture is not very straightforward for a web application.
    Model 1 also has decentralized navigation control, because in this architecture,
    each user contains a separate controller and also different logic to determine
    the next page. That time for web application, Model 1 architecture has Servlet
    and JSP as the main technologies to develop the web applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'For a web application, the MVC pattern is implemented as a Model 2 architecture.
    This pattern provides centralized navigation control logics to easily test and
    maintain the web application, and it also provides better separation of concerns
    than Model 1 architecture for web applications. The difference between the MVC
    pattern based on Model 1 Architecture and the modified MVC pattern based on Model
    2 architecture is that the latter incorporates a front controller that dispatches
    all incoming requests to other controllers. These controllers handle the incoming
    request, return the model, and select the view. take a look at the following diagram
    to better understand the Model 2 architecture MVC pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e6d0343e-df2f-4f7e-91fd-8c64d9f3a48e.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see in the preceding diagram, a new component is introduced for the
    MVC pattern, that is, the front controller. It is implemented as a `javax.servlet.Servlet`
    servlet such as `ActionServlet` in struts, `FacesServlet` in JSF, and `DispatcherServlet`
    in Spring MVC. It handles the incoming requests, and delegates the requests to
    the specific application controller. That application controller creates and updates
    the model, and delegates it to the front controller for rendering. Finally, the
    **Front Controller** determines the specific view, and renders that model data.
  prefs: []
  type: TYPE_NORMAL
- en: The Front Controller design pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Front Controller design pattern is a J2EE pattern; it provides solutions
    for the following application design problems:'
  prefs: []
  type: TYPE_NORMAL
- en: In a web application based on the Model 1 architecture, too many controllers
    are required to handle too many requests. It is difficult to maintain and reuse
    them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each request has its own point of entry in the web application; it should be
    a single point of entry for each request.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JSP and Servlet are the main components of the Model 1 MVC pattern, so, these
    components handle both action and view, violating the *Single Responsibility*
    principle.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Front Controller provides the solution to the aforementioned design problems
    of the web application. In a web application, it works as the main component which
    routes all requests into framework control. This means that too many requests
    land on a single controller (Front Controller), and then, these requests are delegated
    to the specific controllers. Front Controller provides centralized control, and
    improves the reusability and manageability, because, typically, only the resource
    is registered with the web container. This controller not only handles too many
    requests, but also has following responsibilities:'
  prefs: []
  type: TYPE_NORMAL
- en: It initializes the framework to cater to the requests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It loads the map of all URLs and the components responsible for handling the
    request
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It prepares the map for the views
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s see the following diagram for **Front Controller**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/699d8a8c-7cdb-402f-8a07-9b072be15c68.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see in the preceding diagram, all application requests land at the
    **Front Controller**, and it delegates these requests to the configured application
    controllers.
  prefs: []
  type: TYPE_NORMAL
- en: The Spring Framework provides a module based on the MVC pattern, that is, Model
    2 architecture implementation. The Spring MVC module provides out-of-the-box front
    controller pattern implementation by introducing the `org.springframework.web.servlet.DispatcherServlet`
    class. This is a simple `servlet` class, and the backbone of the Spring MVC framework.
    And this Servlet is integrated with the Spring IoC container to benefit the Spring's
    dependency pattern. Spring's web framework uses Spring for its own configuration,
    and all controllers are Spring beans; these controllers are testable artifacts.
  prefs: []
  type: TYPE_NORMAL
- en: Let's dive into the internals of Spring MVC in this Chapter, and have a closer
    look at `org.springframework.web.servlet.DispatcherServlet` in the Spring MVC
    framework, and how it handles all incoming requests to the web application.
  prefs: []
  type: TYPE_NORMAL
- en: Processing the life of a request
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Have you ever played a *wooden labyrinth board game, a maze puzzle with a steel
    ball bearing*? You might have played it in your childhood. It was a very crazy
    game. The goal of this game is to send all the steel ball bearings to the center
    of the wooden labyrinth board through interlinked curvy paths, and these curvy
    paths have cuts leading to a second curve near the center. All the balls need
    to navigate to the center of the wooden labyrinth board through these cuts between
    the curvy paths. If one steel ball reaches the center, then we have to be careful
    about this ball so that it does not move away from the center when trying to move
    another ball to the center. You can see this in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5c9421b7-9fbb-4547-909c-fd02a540e216.png)'
  prefs: []
  type: TYPE_IMG
- en: The Spring MVC framework is similar to this Wooden Labyrinth board game at first
    glance. Instead of the moving the steel ball bearings through various curvy paths
    and cuts, the Spring MVC framework moves web application requests through various
    components such as the Front Controller, that is, the dispatcher Servlet, handler
    mappings, controllers, and view resolvers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see the request processing flow in the Spring MVC Framework for a web
    application. The request processing workflow of the Spring Web MVC `DispatcherServlet`
    is illustrated in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5a0220b4-5457-4167-b2ac-809ee99cb479.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As you already know, the front controller plays a very important role in the
    Model 2 MVC pattern, because it has the responsibility to handle all incoming
    requests to the web application, and prepare the response to the browser. In the
    Spring MVC framework, `org.springframework.web.servlet.DispatcherServlet` plays
    the role of the Front Controller of the Model 2 MVC pattern. As you can see in
    the last diagram, this `DispatcherServlet` uses many other components to fulfill
    its own role. Let''s see the step-by-step request processing in the Spring MVC
    framework:'
  prefs: []
  type: TYPE_NORMAL
- en: A user clicks on the browser or submits a web form of the application. The request
    leaves the browser, either with some additional information or with common information.
    This request lands at Spring's `DispatcherServlet`, which is a simple `servlet`
    class as other java-based web applications. It is a Front Controller of the Spring
    MVC framework, and funnels all the incoming requests through the single point.
    The Spring MVC framework centralizes the request flow control by using this Front
    Controller.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After landing a request at Spring's `DispatcherServlet`, it delegates that request
    to the Spring MVC controller, that is, application controller. Although, , there
    may be several controllers in a Spring web application, but each request must
    be delegated to the specific controller. For that, Spring's `DispatcherServlet`
    takes help of the handler mappings configured in the web application. Handler
    mapping decides the particular controller by using the URL and request parameters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once a particular application controller is decided by Spring's `DispatcherServlet`
    with the help of the handler mapping configuration, `DispatcherServlet` dispatches
    that request to the selected controller. This is the actual controller responsible
    for processing information according to the user's request and its parameters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Spring MVC's controller executes the business logic by using business services
    of the application, and it creates the model which wraps the information to be
    carried back to the user, and is displayed in the browser. This model carries
    information according to the user's request. But this model is not formatted,
    and we can use any view template technology to render the model information in
    the browser. That is why Spring MVC's controller also returns a logic view name
    along with the model. Why does it return a logic view name? This is because Spring
    MVC's controller is not tied to any specific view technology such as JSP, JSF,
    Thymeleaf, and so on.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once again, Spring MVC's `DispatcherServlet` takes the help of the view resolver;
    it is configured in the web application to resolve the view. According to the
    configured `ViewResolver`, it resolves the actual view name instead of the logic
    view name. Now `DispatcherServlet` has the view as well to render the model information.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Spring MVC's `DispatcherServlet` renders the model to the view, and generates
    a user-readable format of the model's information.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, that information creates a response, and returns it to the user's browser
    by `DispatcherServlet`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As you can see, there are several steps and components involved in serving a
    request of the application. Most of these components are related to the Spring
    MVC framework, and these components have their own specific responsibility to
    serve a request.
  prefs: []
  type: TYPE_NORMAL
- en: 'Till now, you have learned that `DispatcherServlet` is a key component in processing
    requests with Spring MVC. It is the heart of the Spring Web MVC. It is a front
    controller that coordinates all request handling activities analogous to Struts
    `ActionServlet` / JSF `FacesServlet`. It delegates to the web infrastructure beans,
    and invokes user web components. It is also highly flexible, configurable, and
    fully customizable. It is very flexible, because all the components used by this
    servlet are interfaces for all the infrastructure beans. The following table lists
    some of the involved interfaces provided by the Spring MVC Framework:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Spring MVC Component** | **Role in request processing** |'
  prefs: []
  type: TYPE_TB
- en: '| `org.springframework.web.multipart.MultipartResolver` | It handles multipart
    requests such as file uploads |'
  prefs: []
  type: TYPE_TB
- en: '| `org.springframework.web.servlet.LocaleResolver` | It handles locale resolution
    and modification |'
  prefs: []
  type: TYPE_TB
- en: '| `org.springframework.web.servlet.ThemeResolver` | It handles theming resolution
    and modification |'
  prefs: []
  type: TYPE_TB
- en: '| `org.springframework.web.servlet.HandlerMapping` | It maps all incoming requests
    to the handler objects. |'
  prefs: []
  type: TYPE_TB
- en: '| `org.springframework.web.servlet.HandlerAdapter` | It is based on the Adapter
    pattern, and is used for the handler object type to execute the handler |'
  prefs: []
  type: TYPE_TB
- en: '| `org.springframework.web.servlet.HandlerExceptionResolver` | It handles the
    exceptions thrown during handler execution |'
  prefs: []
  type: TYPE_TB
- en: '| `org.springframework.web.servlet.ViewResolver` | It translates the logical
    view name to an actual view implementation |'
  prefs: []
  type: TYPE_TB
- en: The components listed in the preceding table work on the Spring MVC Framework
    for the request processing life cycle in a web application. In the upcoming section,
    we'll see how to configure the Spring MVC's main component, that is, `DispatcherServlet`.
    We'll also take a closer look at the different ways of implementation and configuration
    based on either Java or XML.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring DispatcherServlet as the Front Controller
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a Java-based web application, all servlets are defined in the `web.xml` file.
    It is loaded in a web container at the bootstrap, and maps each servlet to a particular
    URL pattern. Similarly, the `org.springframework.web.servlet.DispatcherServlet`
    is the centerpiece of the Spring MVC; it needs to be configured in the same file--`web.xml`,
    and it is loaded at the bootstrap of the web application. At the time of bootstrapping,
    `DispatcherServlet` is invoked to create Spring's `org.springframework.web.context.WebApplicationContext`
    by loading the beans' configuration through Java, XML, or annotation-based. The
    servlet tries to fetch all the required components from this web application context.
    It has the responsibility to route the request through all the other components.
  prefs: []
  type: TYPE_NORMAL
- en: '`WebApplicationContext` is a web version of the `ApplicationContext`, as discussed
    in previous chapters of this book. It has some additional capabilities necessary
    for web applications other than the `ApplicationContext`, such as servlet-specific
    scope request, session, and so on. The `WebApplicationContext` is bound in the
    `ServletContext`; you can also access it by using the static method of the `RequestContextUtils`
    class. Let''s see the following code snippet for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ApplicationContext webApplicationContext = RequestContextUtils.findWebApplicationContext(request);`'
  prefs: []
  type: TYPE_NORMAL
- en: Defined by XML configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As you know, `web.xml` is the root file of any web application, placed in the
    `WEB-INF` directory. It has a servlet specification, and contains all the servlet
    configuration to be bootstrapped. Let''s see the required code of the `DispatcherServlet`
    configuration in the web application, which is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code is the minimum required code to configure the `DispatcherServlet`
    in a Spring web application using XML-based configuration.
  prefs: []
  type: TYPE_NORMAL
- en: There is nothing is special in the `web.xml` file; typically, it defines only
    one servlet configuration very similar to the traditional Java web application.
    But DispatcherServlet loads a file which contains the spring beans configuration
    for the application. By default, it loads a file named `[servletname]-servlet.xml`
    from the WEB-INF directory. In our case, the file name should be `bankapp-servlet.xml`
    in the WEB-INF directory.
  prefs: []
  type: TYPE_NORMAL
- en: Defined by Java configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, instead of the XML configuration, we will use Java to configure
    `DispatcherServlet` in the servlet container for our web application. Servlet
    3.0 and later supports java-based bootstrapping, so, we can avoid using the web.xml
    file. Instead of this, we can create a java class that implements the `javax.servlet.ServletContainerInitializer`
    interface. Spring MVC provides the `WebApplicationInitializer` interface to ensure
    that your spring configuration is loaded and initialized in any Servlet 3 container.
    But the Spring MVC framework makes it even easier by providing an abstract class
    implementation of the `WebApplicationInitializer` interface. By using this abstract
    class, you just map your servlet mapping, and provide the root and MVC configuration
    classes. I, personally, prefer this way of configuration in my web application.
    The following is the code for this configuration class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'As seen in the preceding code, the `SpringApplicationInitializer` class extends
    the `AbstractAnnotationConfigDispatcherServletInitializer` class. It asks only
    the required information from the developer, and all configurations related to
    the `DispatcherServlet` are configured by this class using the servlet container
    interfaces. Take a look at the following diagram to understand more about the
    `AbstractAnnotationConfigDispatcherServletInitializer` class and its implementation
    to configure the `DispatcherServlet` in the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/523eec9d-ebde-4091-84cc-2153ce838e82.png)'
  prefs: []
  type: TYPE_IMG
- en: You have seen that the `SpringApplicationInitilizer` class overrides three methods
    of the `AbstractAnnotationConfigDispatcherServletInitializer` class, that is,
    `getServletMappings()`, `getServletConfigClasses()`, and `getRootConfigClasses()`.
    The method `getServletMappings()` defines the servlet mapping-in our application,
    it's mapped to "`/`"**.** The method `getServletConfigClasses()` asks `DispatcherServlet`
    to load its application context with the beans defined in the `SpringMvcConfig`
    configuration class. This configuration file has bean definitions related to the
    web components such as controllers, view resolvers, and handler mappings. A Spring
    web application has another application context, and it is created by `ContextLoaderListener`.
    So, another method, `getRootConfigClasses()`, loads the other beans such as services,
    repositories, data-source, and other application beans typically required in the
    middle-tier and data-tier of the application defined in the `AppConfig` configuration
    class.
  prefs: []
  type: TYPE_NORMAL
- en: The Spring Framework provides a listener class--`ContextLoaderListener`. It
    is responsible for bootstrapping the backend application context.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see the following diagram to understand more about the Spring web application
    design after starting up the servlet container:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6f968668-e514-4a7e-bcdd-ca0f6ae6629c.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see in the last diagram, the web component beans definitions configuration
    classes returned by the `getServletConfigClasses()` method are loaded by the `DispatcherServlet`,
    and the other application beans definition configuration classes returned by the
    `getRootConfigClasses()` method are loaded by the `ContextLoaderListener`.
  prefs: []
  type: TYPE_NORMAL
- en: A Java-based web configuration will only work when deploying to a server that
    supports **Servlet 3.0**, such as **Apache Tomcat 7 or higher.**
  prefs: []
  type: TYPE_NORMAL
- en: Let's see how to enable more features of the Spring MVC Framework in the coming
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling the Spring MVC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many ways to configure the `DispatcherServlet` and other web components.
    There are many features of the Spring MVC framework which are not enabled by default,
    such as `HttpMessageConverter`, Support for validating `@Controller` inputs with
    `@Valid`, and so on. So, we can enable these features by using either a Java-based
    configuration or XML configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'To enable the MVC Java config, add the annotation `@EnableWebMvc` to one of
    your `@Configuration` classes, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In XML configuration, we can use MVC namespace, there is an `<mvc:annotation-driven>`
    element that you can use to enable the annotation-driven Spring MVC.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The Spring MVC advanced feature can be enabled in a Spring web application
    either by using the `@EnableWebMvc` annotation, or by using the XML namespace
    `<mvc:annotation-driven/>`. The Spring MVC Framework also allows you to customize
    the default configuration in Java by extending the `WebMvcConfigurerAdapter` class,
    or by implementing the `WebMvcConfigurer` interface. Let''s see the modified configuration
    file after adding a bit more configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As seen in the preceding code, the configuration class `SpringMvcConfig` is
    annotated with `@Configuration`, `@ComponentScan`, and `@EnableWebMvc`. Here,
    the `com.packt.patterninspring.chapter10.bankapp.web.controller` package will
    be scanned for components. This class extends the `WebMvcConfigurerAdapter` class,
    and overrides the `configureDefaultServletHandling()` method. We have also configured
    a `ViewResolver` bean.
  prefs: []
  type: TYPE_NORMAL
- en: Till now, you have learned what is the MVC pattern and architecture, and how
    to set up `DispatcherServlet` and enable the essential Spring MVC components for
    a Spring web application. In the upcoming section, we'll discuss how to implement
    controllers in a Spring application, and how these controllers handle web requests.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing controllers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have seen in the MVC pattern, controllers are also one of the crucial
    components of the MVC pattern. They are responsible for executing the actual request,
    preparing the model, and sending this model along with logical view name to the
    front controller. In a web application, the controllers work between the web layer
    and the core application layer. In the Spring MVC framework, controllers are also
    more like POJO classes with methods; these methods are known as handlers, because
    these are annotated with the `@RequestMapping` annotation. Let's see how to define
    controller classes in a Spring web application.
  prefs: []
  type: TYPE_NORMAL
- en: Defining a controller with @Controller
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s create a controller class for our bank application. `HomeController`
    is a controller class that handles requests for `/` and renders the homepage of
    the bank application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the preceding code, the `HomeController` class contains the
    `home()` method. It is a handler method, because it is annotated with the `@RequestMapping`
    annotation. It specifies that this method handles all the requests that are mapped
    to the `/` URL. Another thing to notice is that our controller class, `HomeController`,
    is also annotated with the `@Controller` annotation. As we know, `@Controller`
    is a stereotype annotation, and it is also used to create the bean in the Spring
    IoC container similar to the other Meta annotations of the `@Component` annotation
    such as `@Service` and `@Repository.` Yes, this annotation specifies any class
    as the controller, and adds some more capability of Spring MVC to that class.
    You could also use the `@Component` annotation instead of `@Controller` to create
    Spring beans in a web application, but in this case, that bean does not have the
    capability of the Spring MVC framework such as exception handling at web layer,
    handler mapping, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a closer look at the `@RequestMapping` annotation, and also the composed
    variants of the `@RequestMapping` annotation.
  prefs: []
  type: TYPE_NORMAL
- en: Mapping requests with @RequestMapping
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The previously defined `HomeController` class has only one handler method,
    and this method is annotated with the `@RequestMapping` annotation. Here, I have
    used two attributes of this annotation--one is value to map the HTTP request to
    the `/` pattern, and the other attribute is a method for supporting the HTTP `GET`
    method. We can define multiple URL mappings with one handler method. Let''s see
    this in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, the `@RequestMapping` annotation has an array of string
    values for the value attribute of this annotation. Now, this handler method is
    mapped with two URL patterns, such as `/` and `/index`. The Spring MVC''s `@RequestMapping`
    annotation supports several HTTP methods such as `GET`, `POST`, `PUT`, `DELETE`,
    and so on. As of version 4.3, Spring composed `@RequestMapping` variants, and
    now provides simple methods for the mapping of common HTTP methods, as shown in
    the following expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the modified version of `HomeController` with composed annotation mappings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use the `@RequestMapping` annotation at both locations: at the class
    level, and at the method level. Let''s see examples for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '@RequestMapping at method level'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Spring MVC allows you to use the `@RequestMapping` annotation at the method
    level to make this method as handler method in the Spring web application. Let''s
    see how to use it in the following class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see in the preceding code, I have used the `@RequestMapping` annotation
    with three methods `home()`, `create()`, and `saveUser()`. Here I have also used
    the attributes "value" and "method" of this annotation. The "value" attribute
    has the request mapping with request URL and "method" attribute is used to define
    the HTTP request methods such GET or POST. Mapping rules are, typically, URL-based,
    and, optionally, use wild cards, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, the handler methods have some arguments as well, so
    we can pass any number of arguments of any type. The Spring MVC will handle these
    arguments as request parameters. Let's see first how to define `@RequestMapping`
    at the class level, then we will discuss the request parameters.
  prefs: []
  type: TYPE_NORMAL
- en: '@RequestMapping at the class level'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Spring MVC allows you to use the `@RequestMapping` annotation at the class
    level. This means we can annotate the controller class with `@RequestMapping`,
    as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: As you have seen in the preceding code, the `HomeController` class is annotated
    with the `@RequestMapping` and `@Controller` annotations. But the HTTP method
    is still defined above the handler methods. Class-level mapping is applied with
    all the handler methods defined under this controller.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the Spring MVC configuration, we created a controller class with the
    handler methods. Let''s test this controller before moving ahead with more details.
    In this book, I haven''t use any JUnit test cases, so here, I will just run this
    web application on the Tomcat container. You can see the output on the browser
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f4c6014d-f22c-4a85-91a5-0799fb2c7d8b.png)'
  prefs: []
  type: TYPE_IMG
- en: The last image is the homepage of our **Bank Management System** web application.
  prefs: []
  type: TYPE_NORMAL
- en: Before Spring 3.1, the Spring MVC mapped the requests to handler methods using
    two steps. First, the controller was selected by `DefaultAnnotationHandlerMapping`,
    and then, the actual method was mapped with the incoming requests by the `AnnotationMethodHandlerAdapter`.
    But as of Spring 3.1, Spring MVC maps the requests, in one step, directly to the
    handler methods by using `RequestMappingHandlerMapping`.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we'll see how to define the handler methods, and the return
    type and parameters allowed for the handler methods in Spring MVC.
  prefs: []
  type: TYPE_NORMAL
- en: Defining @RequestMapping handler methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the Spring MVC Framework, the `@RequestMapping` handler methods are very
    flexible in defining signatures. You can pass any number of arguments in any order.
    These methods support most type of arguments, and are also very flexible in the
    return type as well. It can have several return types, some of which are listed
    next:'
  prefs: []
  type: TYPE_NORMAL
- en: Supported method argument types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Request or response objects (Servlet API)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Session object (Servlet API)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.util.Locale`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.util.TimeZone`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.io.InputStream` / `java.io.Reader`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.io.OutputStream` / `java.io.Writer`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.security.Principal`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@PathVariable`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@RequestParam`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@RequestBody`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@RequestPart`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.util.Map` / `org.springframework.ui.Model` / `org.springframework.ui.ModelMap`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`org.springframework.validation.Errors` / `org.springframework.validation.BindingResult`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Supported method return types:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ModelAndView`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Model`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Map`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`View`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`String`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HttpEntity<?>` or `ResponseEntity<?>`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HttpHeaders`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Callable<?>`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DeferredResult<?>`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: I have listed some of the supported return types and method argument types.
    It seems that Spring MVC is very flexible and customizable in the nature of defining
    the request handler methods unlike other MVC frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Spring MVC framework, even the handler method can have any ordering
    of the arguments, but in case of Errors or `BindingResult` parameters, we have
    to put these parameters first, followed by the model object for being bound immediately,
    because the handler method might have any number of model objects, and Spring
    MVC creates separate instances of the Errors or `BindingResult` for each of them.
    For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Invalid location** `@PostMapping`'
  prefs: []
  type: TYPE_NORMAL
- en: '`public String saveUser(@ModelAttribute ("user") User user, ModelMap model,
    BindingResult result){...}`'
  prefs: []
  type: TYPE_NORMAL
- en: '**Valid location** `@PostMapping`'
  prefs: []
  type: TYPE_NORMAL
- en: '`public String saveUser(@ModelAttribute ("user") User user, BindingResult result,
    ModelMap model){...}`'
  prefs: []
  type: TYPE_NORMAL
- en: Let's see how to pass model data to the view layer in the upcoming section.
  prefs: []
  type: TYPE_NORMAL
- en: Passing model data to the view
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As of now, we have implemented a very simple `HomeCotroller`, and tested it.
    But in the web application, we have also passed model data to the view layer.
    That model data we passed in the model (in a simple word, it is `Map`), and that
    model is returned by the controller along with logical view name. As you already
    know, Spring MVC supports several return types of the handler method. Let''s see
    the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the preceding example, the `AccountController` class has three
    handler methods. Two handler methods return the model data along with the logical
    view name. But in this example, I am using Spring MVC's `ModelMap`, so, we don't
    need to forcefully return as logical view, it binds automatically with the response.
  prefs: []
  type: TYPE_NORMAL
- en: Next you'll learn how to accept request parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Accepting request parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In a Spring web application, sometimes, we just read the data from the server
    side like in our example. Reading data for all the accounts was a simple read
    call, and no request parameter was required. But in case you want to fetch data
    for a particular account, then you have to pass the account ID with the request
    parameters. Similarly, for creating a new Account in the bank, you have to pass
    an account object as a parameter. In Spring MVC, we can accept the request parameters
    in the following ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Taking query parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Taking request parameters via path variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Taking form parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's look at each of these ways one by one.
  prefs: []
  type: TYPE_NORMAL
- en: Taking query parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In a web application, we can fetch the request parameters from the request-the
    account ID in our example if you want to access the details of a particular account.
    Let''s fetch the account ID from the request parameter using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code snippet, I have used the traditional way to access the
    request parameters. The Spring MVC framework provides an annotation, `@RequestParam`,
    to access the request parameters. Let''s use the `@RequestParam` annotation to
    bind the request parameters to a method parameter in your controller. The following
    code snippet shows the usage of the `@RequestParam` annotation. It extracts the
    parameter from the request, and performs type conversion as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we access the request parameter by using the `@RequestParam`
    annotation, and you can also notice that I didn't use the type conversion from
    `String` to `Long`, it will be done automatically by this annotation. One more
    thing to note here is that parameters using this annotation are required by default,
    but Spring allows you to override this behavior by using the `required` attribute
    of the `@RequestParam` annotation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Now let's see how to use path variables to take input as part of the request
    path.
  prefs: []
  type: TYPE_NORMAL
- en: Taking request parameters via path variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Spring MVC allows you to pass parameters in the URI instead of passing them
    through request parameters. The passed values can be extracted from the request
    URLs. It is based on URI templates. It is not a Spring-specific concept, and is
    used in many frameworks by using `{...}` placeholders and the `@PathVariable`
    annotation. It allows clean URLs without request parameters. The following is
    an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous handler, the method can handle the request like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/ea3b22a3-5441-481c-aed4-8f39359f9b3c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'But in the preceding example, the handler method can handle the request such
    as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/788b5f14-6d7c-4ad5-9af7-c6d175d5155a.png)'
  prefs: []
  type: TYPE_IMG
- en: We have seen in the preceding code and images how to pass a value either by
    using request parameters or using path parameters. Both ways are fine if you are
    passing small amounts of data on a request. But in some cases, we have to pass
    a lot of data to the server, such as form submission. Let's see how to write controller
    methods that handle form submissions.
  prefs: []
  type: TYPE_NORMAL
- en: Processing forms of a web page
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you know, in any web application, we can send and receive data from the server.
    In a web application, we send the data by filling out forms, and submitting this
    form to the server. Spring MVC also provides support for form handling of the
    client end by displaying the form, validating the form data, and submitting this
    form data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Basically, Spring MVC handles the form displaying and form processing first.
    In the Bank management application, you will need to create a new user, and open
    a new account in the bank, so, let''s create a controller class, AccountController,
    with a single request-handling method for displaying the account open form, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The `openAccountForm()` method's `@GetMapping` annotation declares that it will
    handle the HTTP GET requests for /open-account. It's a simple method, taking no
    input and only returning a logical view named `accountForm`. We have configured
    `InternalResourceViewResolver`, which means that the JSP at `/WEB-INF/views/accountForm.jsp`
    will be called on to render the open account form.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the JSP you''ll use for now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see in the preceding code, we have an open account form. It has
    some fields such as `AccountId`, `Account Name`, and `Initial Balance`. This JSP
    page has the `<form>` tag for the form, and this `<form>` tag doesn''t have any
    action parameter. This means that when we submit this form, it will post the form
    data to the same URI `/open-account` with the `POST` HTTP method call. The following
    screenshot displays the account form:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/22c32b1b-53cf-4171-8577-146ea46a1bf5.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's add another method to handle the call for the HTTP `POST` method with
    the same URI, `/open-account`.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a form handling controller
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s see the same `AccountController` class by adding another handler method
    to handle the HTTP `POST` request for the URI `/open-account` in the web application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see in the preceding code, we have added two more handler methods
    in the `AccountController` method, and also injected the service `AccountService`
    with this controller to save the account details in the database. Whenever we
    process the `POST` request from the open account form, the controller accepts
    the account form data, and saves it to the database by using the injected account
    service. It will accept the account form data as an Account object. You may also
    notice here that after processing the form data using the HTTP `POST` method,
    the handler method redirects to the account details page. It is also a better
    practice to redirect after `POST` submission to prevent accidentally submitting
    the form twice. The following screen is displayed after submission of the request:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ba094c31-5de1-41f8-a501-baf17624c557.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see in the preceding output on the browser, this page is rendered
    after submitting the account form. Because we have added one request handler method,
    this handler method handles the request, and renders another web page including
    the account details. The following JSP page is rendered as the view of the preceding
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In this last code, the handler method sends the `Account` object to the model,
    and also returns the logical view name. This JSP page renders the `Account` object
    taken from the response.
  prefs: []
  type: TYPE_NORMAL
- en: One thing to be noticed here is that the Account object has ID, name, and balance
    properties, which will be populated from the request parameters of the same name
    as the field name in the account form. If any object property name matches the
    field name of the HTML form, then this property will be initialized with a NULL
    value.
  prefs: []
  type: TYPE_NORMAL
- en: Data binding with Command Design pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Encapsulate a request as an object, thereby letting you parameterize clients
    with different requests, queue or log requests, and support undoable operations.
  prefs: []
  type: TYPE_NORMAL
- en: '- GOF Design Pattern'
  prefs: []
  type: TYPE_NORMAL
- en: You learned about the Command Design pattern in [Chapter 3](bd05acbb-a42a-4070-9e01-54a8ce049e41.xhtml),
    *Consideration of Structural and Behavioral Patterns*. It is a part of the Behavioral
    pattern family of the GOF pattern. It is a very simple data-driven pattern. It
    allows you to encapsulate your request data into an object, and pass that object
    as a command to the invoker method, and that method returns the command as another
    object to the caller.
  prefs: []
  type: TYPE_NORMAL
- en: 'Spring MVC implements the Command Design pattern to bind the request data from
    the web form as an Object, and passes that object to the request handler method
    in the controller class. Here, we will explore how to use this pattern to bind
    the request data to the Object, and also explore the benefits and possibilities
    of using data binding. In the following class, the `Account` java bean is a simple
    object with three properties--`id`, `name`, and `balance`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Either we submit the web form with the input text fields' names the same as
    the Object properties' name, or we receive the request as `http://localhost:8080/Chapter-10-Spring-MVC-pattern/account?id=10000`.
    In both cases, behind the scenes, Spring calls the setter methods of the Account
    class to bind the request data or web form data to the object. Spring also allows
    you to bind indexed collections such as List, Map, and others.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also customize data binding. Spring provides these two ways to customize
    data binding:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Global Customization**: It customizes the data-binding behavior across the
    web application for a particular Command Object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Per Controller Customization**: It customizes the data-binding behavior per
    controller class for a particular Command Object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here, I will discuss only the per controller customization. Let''s see the
    following code snippet for customizing data binding for the `Account` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the preceding code, `AccountController` has a `initBinder(WebDataBinder
    binder)` annotated with the `@InitBinder` annotation. This method must have a
    void return type, and have an `org.springframework.web.bind.WebDataBinder` as
    a method argument. The `WebDataBinder` object has several methods; we have used
    some them in the preceding code. `WebDataBinder` is used to customize the data
    binding.
  prefs: []
  type: TYPE_NORMAL
- en: Using @ModelAttributes for customizing data binding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Spring MVC provides one more annotation, `@ModelAttributes`, for binding data
    to the `Command` object. It is another way to bind the data and to customize the
    data binding. This annotation allows you to control the creation of the `Command`
    object. In a Spring MVC application, this annotation can be used on a method and
    on method arguments. Let''s see the following examples:'
  prefs: []
  type: TYPE_NORMAL
- en: Using `@ModelAttribute` on methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can use the `ModelAttribute` annotation on methods to create an object to
    be used in our form, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Using `@ModelAttribute` on method arguments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can also use this annotation on a method argument. In this case, the handler
    method''s arguments are looked up from the model object. If these are not available
    in the model, then they are created by using the default constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the last code snippet, the `@ModelAttribute` annotation is
    used on the method argument. This means that the `Account` object fetches from
    the model object. If it is not there, it will be created by using the default
    constructor.
  prefs: []
  type: TYPE_NORMAL
- en: When the `@ModelAttribute` annotation is put on a method, this method will be
    called before the request handling method is called.
  prefs: []
  type: TYPE_NORMAL
- en: Till now, we have seen how Spring MVC handles requests and request parameters
    either in the traditional way or by using the `@RequestParam`, `@PathVariable`
    annotations. We have also seen how to process the form web page and handle the
    `POST` request with the form data binding to an object in the controller layers.
    Now let's move to see how to validate if the submitted form data is valid or invalid
    for the business.
  prefs: []
  type: TYPE_NORMAL
- en: Validating forms input parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a web application, validation of the web form data is very important, because
    end users can submit any thing. Suppose in an application, a user submits the
    account form by filling in the account name, then it could create the new account
    in the bank with account holder name. So, we have to ensure the validity of the
    form data before creating the new record in the database. You do not need to handle
    the validation logic in the handler method. Spring provides support for the JSR-303
    API. As of Spring 3.0, Spring MVC supports this Java Validation API. There isn't
    much configuration required to configure the Java Validation API in your Spring
    web application-you just add the implementation of this API in your application
    class path such as Hibernate Validator.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Java Validation API has several annotations to validate the properties
    of the `Command` object. We can place constraints on the value of the properties
    of the `Command` object. In this chapter, I have not explored all these annotations,
    but let''s see the following examples with some of these annotations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the preceding code, the properties of the Account class are
    now annotated with `@NotNull` to ensure that the value must not be null, and some
    properties are also annotated with the `@Size` annotation to ensure the count
    of characters between the minimum and maximum lengths.
  prefs: []
  type: TYPE_NORMAL
- en: 'Only annotating the properties of the `Account` object is not enough. We have
    to annotate the save() method argument of the `AccountController` class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see in the preceding code, the `Account` parameter is now annotated
    with `@Valid` to indicate to Spring that the command object has validation constraints
    that should be enforced. Let''s see the output when we submit the web open account
    form while filling invalid data:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/de979414-1011-4428-bd1d-f2e349800dc7.png)'
  prefs: []
  type: TYPE_IMG
- en: As I had submitted this form without data, it has been redirected to the same
    page with validation errors. Spring also allows you to customize these validation
    messages by configuring these messages into the properties file.
  prefs: []
  type: TYPE_NORMAL
- en: As of now, in this chapter, you have learned about the controller component
    of the MVC pattern. You also learned how to create and configure in a web application.
    Let's explore another component of the MVC pattern, view, in the upcoming section.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing View in the MVC pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'View is the most important component of the MVC pattern. The controller returns
    the model to the front controller along with the logical view name. The front
    controller resolves to the actual view by using the configured view resolver.
    Spring MVC provides several view resolvers to support multiple view technologies,
    such as JSP, Velocity, FreeMarker, JSF, Tiles, Thymeleaf, and so on. You have
    to configure the view resolver according to the view technology that you use in
    your web application. Take a look at the following figure to understand more about
    the view pattern in Spring MVC:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a948ab9b-14a7-4fc2-9647-eea78f448711.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see in the diagram, Spring MVC's Front Controller has several view
    resolvers according to the different view technologies. But in this chapter, we
    will use only JSP as the view technology, and so, we will explore only the JSP-related
    view resolver, `InternalResourveViewResolver`.
  prefs: []
  type: TYPE_NORMAL
- en: A View renders the web output. There are many built-in views available for JSPs,
    XSLT, templating approaches (Velocity, FreeMarker), and others. Spring MVC also
    has view support classes for creating PDFs, Excel spreadsheets, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Controllers, typically, return a *logical view name* in String MVC, but Spring's
    `ViewResolvers` select a View based on the view name. Let's see how to configure
    the `ViewResolver` in a Spring MVC application.
  prefs: []
  type: TYPE_NORMAL
- en: Defining ViewResolver in the Spring MVC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Spring MVC, the `DispatcherServlet` delegates to a `ViewResolver` to obtain
    the View implementation based on the view name. The default `ViewResolver` treats
    the view name as a web application-relative file path, that is, a JSP--`/WEB-INF/views/account.jsp`.
    We can override this default by registering a `ViewResolver` bean with the `DispatcherServlet`.
    In our web application, we have used `InternalResourceViewResolver`, because it
    is related to the JSP view, but there are several other options available in Spring
    MVC, as mentioned in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: Implement the View
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following code renders the view in the MVC pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '`accountDetails.jsp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the preceding code, Spring MVC renders this view when the
    controller will be returned `accountDetails` as the logical view name. But how
    is it resolved by Spring MVC? Let's see the configuration of the `ViewResolver`
    in the Spring configuration file.
  prefs: []
  type: TYPE_NORMAL
- en: Register ViewResolver with Spring MVC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s register the JSP-related `ViewResolver`, that is, configure `InternalResourceViewResolver`
    in the Spring web application, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'As in the preceding code, suppose the controller returns with the logical view
    name, `accountDetails`. All the JSP files for views are placed in the `/WEB-INF/views/`
    directory of the web application. The `accountDetails.jsp` view file for account
    details. As per the preceding configuration file, the actual view name is derived
    by adding the prefix `/WEB-INF/views/` and the postfix `.jsp` to the logical view
    name returned by the application controller. If the application controller returns
    `accountDetails` as the logical view name, then `ViewResolver` changes it to the
    physical by adding a prefix and postfix to the logical view name; finally, it
    is changed to `/WEB-INF/views/accountDetails.jsp` in the our application. The
    following diagram illustrates how Spring MVC''s Front Controller resolves the
    view in a Spring web application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/51101b57-a465-4d07-b31e-943299cc7c69.png)'
  prefs: []
  type: TYPE_IMG
- en: This last diagram illustrates the whole picture of the Spring MVC request flow
    with all the components (**Model**, **View**, and **Controllers**) of the MVC
    pattern, and the Front controller pattern. Any request, either HTTP `GET` or `POST`,
    lands at the Front Controller first, which is, actually, the `DispatcherServlet`
    in Spring MVC. The controllers in a Spring web application are responsible for
    generating and updating the **Model**, and the **Model** is another component
    of the MVC pattern. Finally, the controller returns that model along with the
    logical view name to the `DispatcherServlet`. It consults with the configured
    view resolver, and resolves the physical path of the view. The **View** is another
    component of the MVC pattern.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we'll elaborate on the View Helper pattern, and how Spring
    support the pattern in a Spring web application.
  prefs: []
  type: TYPE_NORMAL
- en: The View Helper pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The View Helper pattern separates the static view, such as JSP, from the processing
    of the business model data. The View Helper pattern is used in the presentation
    layer by adapting the model data and the View components. The View Helper can
    format the model data according to the business requirement, but it cannot generate
    model data for the business. The following diagram illustrates the View Helper
    pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/386581b5-f6f4-479c-b017-501fd2e43358.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We know that View is the a static and formatted component of the MVC pattern,
    but sometimes, we need some business processing the presentation layer. If you
    are using JSPs, then you could use a scriptlet for the business processing at
    the the view layer, but using a scriptlet is not a best practice, because it promotes
    tight coupling between the view and business logic. But some View Helper classes
    based on the View Helper pattern take over that responsibility of business processing
    at the presentation layer. Some of the technologies based on the View Helper pattern
    areas follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The JavaBeans `View` helper
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The tag `LibraryView` helper
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using JSTL tags
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Using spring tags
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Using third-party tag Library
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following tag libraries are used in our web application in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the preceding code, I have used the JSTL tag library for the
    check not empty account in the model, and the Spring tag library to create the
    open account form in the web application.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, you'll learn about the Composite View pattern, and how
    Spring MVC supports it to implement it in the web application.
  prefs: []
  type: TYPE_NORMAL
- en: Composite View pattern using Apache tile view resolver
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In a web application, the View is one of the most important components. Developing
    this component is not as easy as seems. It is very complicated to maintain, and
    a daunting task. Whenever we create the view for a web application, we always
    focus on the reusability of the view components. We can define some static templates
    that can be reused in other view pages in the same web application. According
    to the Composite Design pattern of the GOF pattern, we compose sub-view components
    for a particular view component. The Composite View pattern promotes reusability
    of views, and is easy to maintain due to the multiple sub-views instead of creating
    a large and complicated view. The following diagram illustrates the Composite
    View pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '>![](img/003641b6-a597-4d9d-91f0-269c14dc2824.png)'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the previous diagram, we can create multiple sub-views to
    create the view in a web application, and these sub-views will be reused across
    the web application.
  prefs: []
  type: TYPE_NORMAL
- en: Spring MVC provides support for implementation of the Composite View pattern
    through frameworks such as SiteMesh and Apache tiles. Here we will explore Apache
    Tiles with a Spring MVC application. Let's see how to configure the Apache Tiles
    `ViewResolver`.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring a Tiles ViewResolver
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s configure Apache Tiles in the Spring MVC application. In order to configure
    it, we have to configure two beans in the Spring configuration file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding configuration file, we configured two beans, `TilesConfigurer`
    and the `TilesViewResolver` bean. The first bean, `TilesConfigurer`, has the responsibility
    to locate and load tile definitions, and, generally, coordinate Tiles. The second
    bean, `TilesViewResolver`, is responsible for resolving logical view names to
    tile definitions. The XML file `tiles.xml` has the tile definitions in the application.
    Let''s see the following code for the tiles configuration file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the `<tiles-definitions>` element has multiple `<definition>`
    elements. Each `<definition>` element defines a tile, and each tile references
    a JSP template. Some `<definition>` elements extend the base tile definition,
    because the base tile definition has the common layout for all the views in the
    web application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see the base definition template, that is, `mainTemplate.jsp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: In this preceding JSP file, I have used the `<tiles:insertAttribute>` JSP tag
    from the `tiles` tag library to insert other templates.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now see some best practices used to design and develop a web application.
  prefs: []
  type: TYPE_NORMAL
- en: Best practices for web application design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following are some of the best practices that must be considered while
    designing and developing a web application:'
  prefs: []
  type: TYPE_NORMAL
- en: Spring MVC is the best choice to design and develop a web application because
    of the Spring DI pattern and the very flexible MVC pattern with Spring. Spring's
    `DispatcherServlet`, too, is very flexible and customizable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In any web application using the MVC pattern, the front controller should be
    generic and as lightweight as possible.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is important to maintain a clear separation of concerns across the layers
    of the web application. Separating layers improves the clean design of the application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If an application layer has too many dependencies with the other layers, as
    a best approach, introduce another layer to reduce the dependency of that layer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Never inject a DAO object to the controllers in the web application; always
    inject a services object to the controller. The DAO objects must be injected with
    the service layers so that the service layer talks to the data access layer, and
    the presentation layer talks to the service layer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Application layers such service, DAO, and presentation layers must be pluggable,
    and must not be bound with the implementation, that is, using interfaces reduces
    the actual coupling to concrete implementations, as we know that loosely coupled
    layered applications are easier to test and maintain.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is strongly recommended to place JSP files in the WEB-INF directory, because
    this location is not accessed by any client.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Always specify the name of the command object in the JSP file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JSP files must not have any business logic and business processing. For such
    a requirement, we strongly recommend the use of View helper classes such as tags,
    libraries, JSTL, and so on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remove the programming logic from template-based views like JSP.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create reusable components that can be used to combine model data across views.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each component of the MVC pattern must have a consistent behavior for which
    the MVC introduced it. This means that the controller should follow the Single
    Responsibility Principle. Controllers are responsible only for delegating business
    logic invocation and view selection.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, be consistent with naming of the configuration files. For example,
    web beans such as controllers, interceptors, and view resolvers must be defined
    in separate configuration files. Other application beans such as services, repositories,
    and so on must be defined into another, separate file. Similarly for security
    concerns.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you've seen how the Spring Framework allows you to develop
    a flexible and loosely coupled web-based application. Spring employs annotations
    for near-POJO development model in your web application. You learned that with
    Spring MVC, you can create a web-based application by developing controllers that
    handle requests, and these controllers are very easy to test. In this chapter,
    we covered the MVC pattern, including its origins and what problems it solves.
    The Spring Framework has implemented MVC patterns, which means that for any web
    application, there are three components--Model, View, and Controller.
  prefs: []
  type: TYPE_NORMAL
- en: Spring MVC implements the Application Controller and Front Controller patterns.
    Spring's dispatcher servlet (`org.springframework.web.servlet.DispatcherServlet`)
    works as a Front Controller in a web-based application. This dispatcher or front
    controller routes all requests to the application controller by using handler
    mapping. In Spring MVC, the controller classes have extremely flexible request
    handler methods. And these handler methods handle all the requests of a web application.
    There several ways, as we explained in this chapter, to handle request parameters.
    The `@RequestParam` annotation is one of the ways to handle request parameters,
    and it is also very easy to test without using the http request object in test
    cases.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we explored the request processing workflow, and discussed
    all the components which play a role in this workflow. The `DispatcherServlet`
    can be considered the main component in Spring MVC; it plays the role of a front
    controller in Spring MVC. Another main component is the view resolver, which has
    the responsibility to render the model data to any view template such JSP, Thymeleaf,
    FreeMarker, velocity, pdf, xml and so on depending om the configured view resolver
    in the web application. Spring MVC provides support for several view technologies,
    but, in this chapter, we briefly looked at how to write views for your controllers
    using JSPs. We can also add consistent layouts to your views using Apache tiles.
  prefs: []
  type: TYPE_NORMAL
- en: And finally, we covered the web application architecture, and discussed the
    different layers in a web application such as domain, user interface, web, service,
    and data access. We created a small bank management web application, and deployed
    it to the tomcat server.
  prefs: []
  type: TYPE_NORMAL
