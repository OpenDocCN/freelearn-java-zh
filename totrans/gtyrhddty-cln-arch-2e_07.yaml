- en: '7'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Implementing a Persistence Adapter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 2*](B19916_07.xhtml), *What's Wrong with Layers?* I complained
    about a traditional layered architecture and claimed that it promotes *database-driven
    design* because, ultimately, everything depends on the persistence layer. In this
    chapter, we’ll have a look at how to make the persistence layer a plugin to the
    application layer to invert this dependency.
  prefs: []
  type: TYPE_NORMAL
- en: Dependency inversion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Instead of a persistence layer, we’ll talk about a persistence adapter that
    provides persistence functionality to the domain services. *Figure 7**.1* shows
    how we can apply the Dependency Inversion Principle to do just that:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.1 – The services from the core use ports to access the persistence
    adapter](img/Figure_07.1._B19916.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.1 – The services from the core use ports to access the persistence
    adapter
  prefs: []
  type: TYPE_NORMAL
- en: Our domain services call port interfaces to access persistence functionality.
    These ports are implemented by a persistence adapter class that does the actual
    persistence work and is responsible for talking to the database.
  prefs: []
  type: TYPE_NORMAL
- en: In Hexagonal Architecture lingo, the persistence adapter is a *driven* or *outgoing*
    adapter because it’s called by our application and not the other way around.
  prefs: []
  type: TYPE_NORMAL
- en: The ports are effectively a layer of indirection between the domain services
    and the persistence code. Let’s remind ourselves that we’re adding this layer
    of indirection in order to be able to evolve the domain code without having to
    think about persistence problems, meaning without code dependencies on the persistence
    layer. Refactoring in persistence code will not lead to a code change in the core.
  prefs: []
  type: TYPE_NORMAL
- en: Naturally, at runtime, we still have a dependency from our application core
    to the persistence adapter. If we modify the code in the persistence layer and
    introduce a bug, for example, we may still break the functionality in the application
    core. However, as long as the contracts of the ports are fulfilled, we’re free
    to do what we want in the persistence adapter without affecting the core.
  prefs: []
  type: TYPE_NORMAL
- en: Responsibilities of a persistence adapter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let’s have a look at what a persistence adapter usually does:'
  prefs: []
  type: TYPE_NORMAL
- en: Takes the input.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Maps the input into database format.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Sends the input to the database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Maps the database output into application format.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Returns the output.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The persistence adapter takes input through a port interface. The input model
    may be a domain entity or an object dedicated to a specific database operation,
    as specified by the interface.
  prefs: []
  type: TYPE_NORMAL
- en: It then maps the input model to a format it can work with to modify or query
    the database. In Java projects, we commonly use the **Java Persistence API** (**JPA**)
    to talk to a database, so we might map the input into JPA entity objects that
    reflect the structure of the database tables. Depending on the context, mapping
    the input model into JPA entities may be a lot of work for little gain, so we’ll
    talk about strategies without mapping in [*Chapter 9*](B19916_09.xhtml#_idTextAnchor081),
    *Mapping* *between Boundaries*.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of using JPA or another object-relational mapping framework, we might
    use any other technique to talk to the database. We might map the input model
    into plain SQL statements and send these statements to the database, or we might
    serialize incoming data into files and read them back from there.
  prefs: []
  type: TYPE_NORMAL
- en: The important part is that the input model to the persistence adapter lies within
    the application core, and not within the persistence adapter itself, so that changes
    in the persistence adapter don’t affect the core.
  prefs: []
  type: TYPE_NORMAL
- en: Next, the persistence adapter queries the database and receives the query results.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, it maps the database answer into the output model expected by the port
    and returns it. Again, it’s important that the output model lies within the application
    core and not within the persistence adapter to have the dependencies point in
    the right direction.
  prefs: []
  type: TYPE_NORMAL
- en: Aside from the fact that the input and output models lie in the application
    core instead of the persistence adapter itself, the responsibilities are not really
    different from those of a traditional persistence layer.
  prefs: []
  type: TYPE_NORMAL
- en: However, implementing a persistence adapter as described here will inevitably
    raise some questions that we probably wouldn’t ask when implementing a traditional
    persistence layer, as we’re so used to the traditional way that we don’t think
    about them.
  prefs: []
  type: TYPE_NORMAL
- en: Slicing port interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One question that comes to mind when implementing services is how to slice the
    port interfaces that define the database operations available to the application
    core.
  prefs: []
  type: TYPE_NORMAL
- en: It’s a common practice to create a single repository interface that provides
    all database operations for a certain entity, as outlined in *Figure 7**.2*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.2 – Centralizing all database operations into a single outgoing
    port interface makes all services depend on methods they don’t need](img/Figure_07.2._B19916.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.2 – Centralizing all database operations into a single outgoing port
    interface makes all services depend on methods they don’t need
  prefs: []
  type: TYPE_NORMAL
- en: Each service that relies on database operations will then have a dependency
    on this single “broad” port interface, even if it uses only a single method from
    the interface. This means we have unnecessary dependencies in our code base.
  prefs: []
  type: TYPE_NORMAL
- en: Dependencies on methods that we don’t need in our context make the code harder
    to understand and test. Imagine that we’re writing a unit test for `RegisterAccountService`
    from the preceding figure. Which of the methods of the `AccountRepository` interface
    do we have to create a mock for? We have to first find out which of the `AccountRepository`
    methods the service actually calls. Having mocked only part of the interface may
    lead to other problems, as the next person working on that test might expect the
    interface to be completely mocked and run into errors. So, they again have to
    do some research.
  prefs: []
  type: TYPE_NORMAL
- en: To put it in the words of Robert C. Martin, “*Depending on something that carries
    baggage that you don’t need can cause you troubles that you* *didn’t expect.*”[1](#footnote-025)
  prefs: []
  type: TYPE_NORMAL
- en: '[1](#footnote-025-backlink). Interface Segregation Principle*: Clean Architecture*
    by Robert C. Martin, page 86.'
  prefs: []
  type: TYPE_NORMAL
- en: The **Interface Segregation Principle** provides an answer to this problem.
    It states that broad interfaces should be split into specific ones so that clients
    only know the methods they need. If we apply this to our outgoing ports, we might
    get a result as shown in *Figure 7**.3*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.3 – Applying the Interface Segregation Principle removes unnecessary
    dependencies and makes the existing dependencies more visible](img/Figure_07.3._B19916.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.3 – Applying the Interface Segregation Principle removes unnecessary
    dependencies and makes the existing dependencies more visible
  prefs: []
  type: TYPE_NORMAL
- en: Each service now only depends on the methods it actually needs. What’s more,
    the names of the ports clearly state what they’re about. In a test, we no longer
    have to think about which methods to mock since most of the time, there is only
    one method per port.
  prefs: []
  type: TYPE_NORMAL
- en: Having very narrow ports such as these makes coding a plug-and-play experience.
    When working on a service, we just “plug in” the ports we need. There is no baggage
    to carry around.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, the “one method per port” approach may not be applicable in all circumstances.
    There may be groups of database operations that are so cohesive and often used
    together that we may want to bundle them together in a single interface.
  prefs: []
  type: TYPE_NORMAL
- en: Slicing persistence adapters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the preceding figures, we saw a single persistence adapter class that implements
    all persistence ports. There is no rule, however, that forbids us to create more
    than one persistence adapter, as long as all persistence ports are implemented.
  prefs: []
  type: TYPE_NORMAL
- en: We might choose, for instance, to implement one persistence adapter per group
    of domain entities for which we need persistence operations (or aggregate in Domain-Driven
    Design lingo), as shown in *Figure 7**.4*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.4 – We can create multiple persistence adapters, one for each aggregate](img/Figure_07.4._B19916.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.4 – We can create multiple persistence adapters, one for each aggregate
  prefs: []
  type: TYPE_NORMAL
- en: This way, our persistence adapters are automatically sliced along the seams
    of the domain that we support with persistence functionality.
  prefs: []
  type: TYPE_NORMAL
- en: We might split our persistence adapters into even more classes – for instance,
    when we want to implement a couple of persistence ports using JPA (or another
    object-relational mapper) and some other ports using plain SQL for better performance.
    We might then create one JPA adapter and one plain SQL adapter, each implementing
    a subset of the persistence ports.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that our domain code doesn’t care about which class ultimately fulfills
    the contracts defined by the persistence ports. We’re free to do as we see fit
    in the persistence layer, as long as all ports are implemented.
  prefs: []
  type: TYPE_NORMAL
- en: The *one persistence adapter per aggregate* approach is also a good foundation
    to separate the persistence needs for multiple bounded contexts in the future.
    Say, after a time, we identify a bounded context responsible for use cases around
    billing. *Figure 7**.5* adds that new domain to the application.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.5 – If we want to create hard boundaries between bounded contexts,
    each bounded context should have its own persistence adapter(s)](img/Figure_07.5._B19916.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.5 – If we want to create hard boundaries between bounded contexts,
    each bounded context should have its own persistence adapter(s)
  prefs: []
  type: TYPE_NORMAL
- en: Each `account` context may not access persistence adapters of the `billing`
    context, and vice versa. If one context needs something of the other, they can
    call each other’s domain services, or we can introduce an application service
    as a coordinator between the bounded contexts. We will talk more about this topic
    in [*Chapter 13*](B19916_13.xhtml#_idTextAnchor112), *Managing Multiple* *Bounded
    Contexts*.
  prefs: []
  type: TYPE_NORMAL
- en: An example with Spring Data JPA
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let’s have a look at a code example that implements `AccountPersistenceAdapter`
    from the preceding figures. This adapter will have to save and load accounts to
    and from the database. We already saw the `Account` entity in [*Chapter 5*](B19916_05.xhtml#_idTextAnchor044),
    *Implementing a Use Case*, but here is its skeleton again for reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/code-7.1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The `Account` class is not a simple data class with getters and setters but
    instead tries to be as immutable as possible. It only provides factory methods
    that create an account in a valid state, and all mutating methods do some validation,
    such as checking the account balance before withdrawing money, so that we cannot
    create an invalid domain model.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll use Spring Data JPA to talk to the database, so we also need `@Entity`-annotated
    classes to represent the database state of an account:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/code-7.2.jpg)![](img/code-7.3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The state of an account consists merely of an ID at this stage. Later, additional
    fields such as a user ID may be added. More interesting is `ActivityJpaEntity`,
    which contains all the activities of a specific account. We could have connected
    `ActivitiyJpaEntity` with `AccountJpaEntity` via JPA’s `@ManyToOne` or `@OneToMany`
    annotations to mark the relation between them, but we have opted to leave this
    out for now, as it adds side effects to the database queries. In fact, at this
    stage, it would probably be easier to use a simpler object-relational mapper than
    JPA to implement the persistence adapter, but we will use it anyway because we
    think we might need it in the future.[2](#footnote-024)
  prefs: []
  type: TYPE_NORMAL
- en: '[2](#footnote-024-backlink). Java Persistence API: does that sound familiar
    to you? You choose JPA as an OR mapper because it’s the thing people use for this
    problem. A couple of months into development, you curse eager and lazy loading
    and the caching features, wishing for something simpler. JPA is a great tool,
    but for many problems, simpler solutions may be, well, simpler. Take a look at
    Spring Data JDBC or jOOQ as an alternative.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will use Spring Data to create repository interfaces that provide
    basic **C****reate**, **Read**, **Update**, and **Delete** (CRUD) functionality
    out of the box, as well as custom queries to load certain activities from the
    database:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/code-7.4.jpg)![](img/code-7.5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Spring Boot will automatically find these repositories, and Spring Data will
    do its magic to provide an implementation behind the repository interface that
    will actually talk to the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Having JPA entities and repositories in place, we can implement the persistence
    adapter that provides the persistence functionality to our application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/code-7.6a.jpg)![](img/code-7.6b.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The persistence adapter implements two ports that are needed by the application,
    `LoadAccountPort` and `UpdateAccountStatePort`.
  prefs: []
  type: TYPE_NORMAL
- en: To load an account from the database, we load it from `AccountRepository` and
    then load the activities of this account for a certain time window through `ActivityRepository`.
  prefs: []
  type: TYPE_NORMAL
- en: To create a valid `Account` domain entity, we also need the balance the account
    had before the start of this activity window, so we get the sum of all withdrawals
    and deposits of this account from the database.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we map all this data to an `Account` domain entity and return it to
    the caller.
  prefs: []
  type: TYPE_NORMAL
- en: To update the state of an account, we iterate over all activities of the `Account`
    entity and check whether they have IDs. If they don’t, they are new activities,
    which we then persist through `ActivityRepository`.
  prefs: []
  type: TYPE_NORMAL
- en: In the scenario described previously, we have a two-way mapping between the
    `Account` and `Activity` domain models and the `AccountJpaEntity` and `ActivityJpaEntity`
    database models. Why do we make the effort to map back and forth? Couldn’t we
    just move the JPA annotations to the `Account` and `Activity` classes and directly
    store them as entities in the database?
  prefs: []
  type: TYPE_NORMAL
- en: Such a *no-mapping* strategy may be a valid choice, as we’ll see in [*Chapter
    9*](B19916_09.xhtml#_idTextAnchor081), *Mapping between Boundaries*, when we talk
    about mapping strategies. However, JPA then forces us to make compromises in the
    domain model. For instance, JPA requires entities to have a no-args constructor.
    Alternatively, it might be that in the persistence layer, a “many-to-one” relationship
    makes sense from a performance point of view, but in the domain model, we want
    this relationship to be the other way around.
  prefs: []
  type: TYPE_NORMAL
- en: So, if we want to create a rich domain model without making compromises to the
    persistence layer, we’ll have to map between the domain model and the persistence
    model.
  prefs: []
  type: TYPE_NORMAL
- en: What about database transactions?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have not touched on the topic of database transactions yet. Where do we put
    our transaction boundaries?
  prefs: []
  type: TYPE_NORMAL
- en: A transaction should span all write operations to the database that are performed
    within a certain use case, ensuring that all those operations can be rolled back
    together if one of them fails.
  prefs: []
  type: TYPE_NORMAL
- en: Since the persistence adapter doesn’t know which other database operations are
    part of the same use case, it cannot decide when to open and close a transaction.
    We have to delegate this responsibility to the services that orchestrate the calls
    to the persistence adapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The easiest way to do this with Java and Spring is to add the `@Transactional`
    annotation to the domain service classes so that Spring will wrap all public methods
    with a transaction:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/code-7.7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: But doesn’t the `@Transactional` annotation introduce a dependency on a framework
    that we don’t want to have in our precious domain code? Well, yes, we have a dependency
    on the annotation, but we get transaction handling for that dependency! We wouldn’t
    want to build our own transaction mechanism just for the code to stay “pure.”
  prefs: []
  type: TYPE_NORMAL
- en: How does this help me build maintainable software?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building a persistence adapter that acts as a plugin to the domain code frees
    the domain code from persistence details so that we can build a rich domain model.
  prefs: []
  type: TYPE_NORMAL
- en: Using narrow port interfaces, we’re flexible to implement one port in one way
    and another port in another way, perhaps even with a different persistence technology,
    without the application noticing. We can even switch out the complete persistence
    layer, as long as the port contracts are obeyed.[3](#footnote-023)
  prefs: []
  type: TYPE_NORMAL
- en: '[3](#footnote-023-backlink). Switching out the persistence layer: while I have
    seen it happen a few times (and for good reasons), the probability of having to
    switch out the whole persistence layer is usually rather low. Even then, having
    dedicated persistence ports is still worthwhile, because it increases testability.
    We can easily implement an in-memory persistence adapter to be used in tests,
    for example.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve built a domain model and some adapters, let’s take a look at
    how we can test that they’re really doing what we expect them to do.
  prefs: []
  type: TYPE_NORMAL
