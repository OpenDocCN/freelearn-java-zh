- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: Text Blocks, Locales, Numbers, and Math
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文本块、区域设置、数字和数学
- en: 'This chapter includes 37 problems covering 4 main topics: text blocks, locales,
    numbers, and mathematical operations. We will start with text blocks (elegant
    multiline strings introduced in JDK 13 (JEP 355, preview)/ JDK 15 (JEP 378, final)),
    continue with problems for creating a Java `Locale`, including localized locales
    (JDK 19’s `ofLocalizedPattern()`), and finish with problems about numbers and
    math, such as the Babylonian method for computing the square root and different
    corner cases of results overflows. The last part of the chapter is dedicated to
    JDK 17’s (JEP 356, final) new API for pseudo-random generators.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包括37个问题，涵盖4个主要主题：文本块、区域设置、数字和数学运算。我们将从文本块开始（JDK 13（JEP 355，预览）/ JDK 15（JEP
    378，最终）中引入的优雅的多行字符串），继续创建Java `Locale`的问题，包括本地化区域（JDK 19的`ofLocalizedPattern()`），并以关于数字和数学的问题结束，例如计算平方根的巴比伦方法和结果溢出的不同边界情况。本章的最后部分是关于JDK
    17（JEP 356，最终）的新伪随机生成器API。
- en: By the end of this chapter, you’ll be up to date with all the new and cool JDK
    features added that relate to these four topics.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将了解所有与这四个主题相关的新酷JDK功能。
- en: Throughout this book you will find references to the first edition. The role
    of these references is to provide you with the best resources for further reading
    related to certain topics. You can successfully go through this edition even if
    you haven’t read the first one and don’t intend to.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，您将找到对第一版的引用。这些引用的作用是为您提供与某些主题相关的最佳进一步阅读资源。即使您没有阅读第一版，也不打算阅读，您也可以成功通过这一版。
- en: Problems
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Use the following problems to test your string manipulation, Java locales,
    and mathematical corner case programming prowess. I strongly encourage you to
    give each problem a try before you turn to the solutions and download the example
    programs:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下问题来测试您的字符串操作、Java 区域设置和数学边界情况编程能力。我强烈建议您在查看解决方案并下载示例程序之前尝试每个问题：
- en: '**Creating a multiline SQL, JSON, and HTML string**: Write a program that declares
    a multiline string (for instance, SQL, JSON, and HTML strings).'
  id: totrans-7
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**创建多行 SQL、JSON 和 HTML 字符串**：编写一个程序，声明一个多行字符串（例如，SQL、JSON 和 HTML 字符串）。'
- en: '**Exemplifying the usage of text block delimiters**: Write a program that exemplifies
    step-by-step how the delimiters of a text block affect the resulting string.'
  id: totrans-8
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**演示文本块定界符的使用**：编写一个程序，逐步演示文本块的定界符如何影响结果字符串。'
- en: '**Working with indentation in text blocks**: Write a program that exemplifies
    different techniques to indent a text block. Explain the meaning of *incidental*
    and *essential* white spaces.'
  id: totrans-9
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**在文本块中使用缩进**：编写一个程序，演示不同的技术来缩进文本块。解释*偶然*和*必要*空白的意义。'
- en: '**Removing incidental white spaces in text blocks**: Highlight the main steps
    of the algorithm used by the compiler to remove the *incidental* white spaces
    of a text block.'
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**在文本块中移除偶然的空白**：突出显示编译器用于移除文本块*偶然*空白的算法的主要步骤。'
- en: '**Using text blocks just for readability**: Write a program that creates a
    string looking like a text block (multiline string) but acts as a single-line
    string literal.'
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**仅为了可读性使用文本块**：编写一个程序，创建一个看起来像文本块（多行字符串）但作为单行字符串字面量的字符串。'
- en: '**Escaping quotes and line terminators in text blocks**: Write a program that
    exemplifies how to handle Java escape sequences (including quotes, `\"`, and line
    terminators, `\n` and `\r`) in a text block.'
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**在文本块中转义引号和行终止符**：编写一个程序，说明如何在文本块中处理Java转义序列（包括引号`\"`和行终止符`\\n`和`\\r`）。'
- en: '**Translating escape sequences programmatically**: Write a program that has
    programmatic access for translating escape sequences in a text block. Consider
    that you have a text block containing embedded escape sequences, and you have
    to pass it to a function that gets a string that must not contain such sequences.'
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**程序化地转换转义序列**：编写一个程序，具有对文本块中转义序列进行程序化访问的功能。考虑您有一个包含嵌入转义序列的文本块，并且您必须将其传递给一个必须不包含此类序列的函数。'
- en: '**Formatting text blocks with variables/expressions**: Write a program that
    exposes several techniques for formatting text blocks with variables/expressions.
    Comment on each technique from the readability perspective. Also, provide a **Java
    Microbenchmark Harness** (**JMH**) benchmark for these techniques.'
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**使用变量/表达式格式化文本块**：编写一个程序，展示格式化文本块使用变量/表达式的几种技术。从可读性的角度对每种技术进行评论。同时，为这些技术提供**Java
    Microbenchmark Harness**（**JMH**）基准测试。'
- en: '**Adding comments in text blocks**: Explain how we can add comments in a text
    block.'
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**在文本块中添加注释**：解释我们如何在文本块中添加注释。'
- en: '**Mixing ordinary string literals with text blocks**: Write a program that
    mixes ordinary string literals with text blocks – for instance, via concatenation.
    Also, is an ordinary string literal and a text block equal if they have the same
    content?'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**混合普通字符串字面量和文本块**：编写一个程序，混合普通字符串字面量和文本块——例如，通过连接。此外，如果它们的内容相同，普通字符串字面量和文本块是否相等？'
- en: '**Mixing regular expression with text blocks**: Write an example of mixing
    regular expressions that have named groups with text blocks.'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**将正则表达式与文本块混合**：编写一个示例，展示将具有命名组的正则表达式与文本块混合。'
- en: '**Checking if two text blocks are isomorphic**: Write a program that checks
    if two text blocks are isomorphic. Two strings are considered isomorphic if we
    can map every character of the first string to every character of the second string
    in a one-to-one fashion (for instance, “xxyznnxiz” and “aavurraqu” are isomorphic).'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**检查两个文本块是否同构**：编写一个程序，检查两个文本块是否同构。如果我们可以将第一个字符串的每个字符一对一地映射到第二个字符串的每个字符，则认为两个字符串是同构的（例如，“xxyznnxiz”和“aavurraqu”是同构的）。'
- en: '**Concatenating strings vs. StringBuilder**: Write a JMH benchmark for comparing
    string concatenation (via the “`+`" operator) with the `StringBuilder` approach.'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**字符串连接与StringBuilder**：编写一个JMH基准测试，比较通过“`+`”运算符进行的字符串连接与`StringBuilder`方法。'
- en: '**Converting int to String**: Write a program that provides several common
    techniques for converting an `int` to a `String`. Also, for the proposed solutions,
    provide a JMH benchmark.'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**将int转换为String**：编写一个程序，提供将`int`转换为`String`的几种常见技术。同时，为提出的解决方案提供JMH基准测试。'
- en: '**Introducing string templates**: Explain and exemplify the usage of JDK 21’s
    (JEP 430, preview) string templates feature.'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**介绍字符串模板**：解释并举例说明JDK 21的（JEP 430，预览）字符串模板功能的用法。'
- en: '**Writing a custom template processor**: Introduce an API for writing a user-defined
    template processor. Next, provide a few examples of custom template processors.'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**编写自定义模板处理器**：介绍编写用户定义模板处理器的API。接下来，提供一些自定义模板处理器的示例。'
- en: '**Creating a Locale**: Write a program that reveals different approaches for
    creating a `Locale`. Also, create *language ranges* and *language priority lists*.'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**创建Locale**：编写一个程序，展示创建`Locale`的不同方法。同时，创建*语言范围*和*语言优先级列表*。'
- en: '**Customizing localized date-time formats**: Write a program that exemplifies
    the usage of custom localized date-time formats.'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**自定义本地化日期时间格式**：编写一个程序，展示使用自定义本地化日期时间格式的用法。'
- en: '**Restoring always-strict floating-point semantics**: Explain what the `strictfp`
    modifier is and how/where to use it in a Java application.'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**恢复始终严格的浮点语义**：解释`strictfp`修饰符是什么，以及在Java应用程序中如何/在哪里使用它。'
- en: '**Computing mathematical absolute value for int/long and a result overflow**:
    Write a program that exemplifies a corner case where applying the mathematical
    absolute value to an `int`/`long` leads to a result overflow. Also, provide a
    solution to this problem.'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**计算int/long的数学绝对值及其结果溢出**：编写一个程序，展示应用数学绝对值到`int`/`long`导致结果溢出的边界情况。同时，提供解决这个问题的方法。'
- en: '**Computing the quotient of the arguments and result overflow**: Write a program
    that exemplifies a corner case where computing the quotient of the arguments leads
    to a result overflow. Also, provide a solution to this problem.'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**计算参数商及其结果溢出**：编写一个程序，展示计算参数商导致结果溢出的边界情况。同时，提供解决这个问题的方法。'
- en: '**Computing the largest/smallest value that is less/greater than or equal to
    the algebraic quotient**: Write a program that relies on `java.util.Math` methods
    to compute the largest/smallest value that is less/greater than or equal to the
    algebraic quotient. Don’t forget to cover the result overflow corner case as well.'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**计算小于/大于或等于代数商的最大/最小值**：编写一个程序，该程序依赖于`java.util.Math`方法来计算小于/大于或等于代数商的最大/最小值。别忘了也要涵盖结果溢出的边界情况。'
- en: '**Getting integral and fractional parts from a double**: Write a program that
    exposes several techniques for getting the integral and fractional parts of a
    `double`.'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**从double中获取整数和分数部分**：编写一个程序，展示获取`double`的整数和分数部分的几种技术。'
- en: '**Testing if a double number is an integer**: Write a program that shows several
    approaches for testing if a `double` number is an integer. In addition, provide
    a JMH benchmark for the proposed solutions.'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**测试一个double数是否为整数**：编写一个程序，展示测试`double`数是否为整数的几种方法。此外，提供针对所提解决方案的JMH基准测试。'
- en: '**Hooking Java (un)signed integers in a nutshell**: Explain and exemplify in
    code the usage of signed/unsigned integers in Java.'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**简要说明Java（无）符号整数的使用**：解释并举例说明Java中符号/无符号整数的用法。'
- en: '**Returning the flooring/ceiling modulus**: Define the *floor*/*ceil* modulus
    based on the *floor* and *ceil* operations, and exemplify the result in code lines.'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**返回地板/天花板模数**：基于地板和天花板操作定义*floor*/*ceil*模数，并在代码行中举例说明结果。'
- en: '**Collecting all prime factors of a given number**: A prime number is a number
    divisible by itself and 1 (for instance, 2, 3, and 5 are prime numbers). Write
    a program that collects all prime factors of a given positive number.'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**收集给定数的所有质因数**：质数是只能被自己和1整除的数（例如，2、3和5是质数）。编写一个程序，收集给定正数的所有质因数。'
- en: '**Computing the square root of a number using the Babylonian method**: Explain
    the Babylonian method for computing the square root, elaborate a step-by-step
    algorithm for this method, and write the code based on this algorithm.'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**使用巴比伦方法计算一个数的平方根**：解释计算平方根的巴比伦方法，详细阐述该方法的逐步算法，并基于此算法编写代码。'
- en: '**Rounding a float number to specified decimals**: Write a program that contains
    several approaches for rounding a given `float` number to specified decimals.'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**将浮点数四舍五入到指定的小数位数**：编写一个程序，包含将给定的`float`数四舍五入到指定小数位数的几种方法。'
- en: '**Clamping a value between min and max**: Provide a solution for clamping a
    given value between a given minimum and maximum.'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**将值夹在最小值和最大值之间**：提供一个解决方案，将给定的值夹在给定的最小值和最大值之间。'
- en: '**Multiply two integers without using loops, multiplication, bitwise, division,
    and operators:** Write a program that multiplies two integers without using loops,
    multiplication, bitwise, division, and operators. For instance, start from the
    *special binomial product formula*.'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**不使用循环、乘法、位运算、除法和运算符来乘以两个整数**：编写一个程序，在不使用循环、乘法、位运算、除法和运算符的情况下乘以两个整数。例如，从*特殊二项式乘积公式*开始。'
- en: '**Using TAU**: Explain the meaning of TAU in geometry/trigonometry, and write
    a program that solves the following problem: A circle has a circumference of 21.33
    cm. What is the radius of the circle?'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**使用TAU**：解释几何/三角学中TAU的含义，并编写一个程序解决以下问题：一个圆的周长为21.33厘米。圆的半径是多少？'
- en: '**Selecting a pseudo-random number generator**: Provide a short dissertation
    about the new API for generating pseudo-random numbers introduced in JDK 17 (JEP
    356, final). Moreover, exemplify different techniques for selecting a pseudo-random
    number generator.'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**选择伪随机数生成器**：简要论述在JDK 17中引入的新API（JEP 356，最终版）用于生成伪随机数。此外，举例说明选择伪随机数生成器的不同技术。'
- en: '**Filling a long array with pseudo-random numbers**: Write a program that fills
    an array of long arrays with pseudo-random numbers in a parallel and non-parallel
    fashion.'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**用伪随机数填充长数组**：编写一个程序，以并行和非并行方式填充长数组的伪随机数。'
- en: '**Creating a stream of pseudo-random generators**: Write a program that creates
    a stream of pseudo-random numbers and a stream of pseudo-random generators.'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**创建伪随机数生成器的流**：编写一个程序，创建一个伪随机数流和一个伪随机数生成器流。'
- en: '**Getting a legacy pseudo-random generator from new ones of JDK 17**: Write
    a program that instantiates a legacy pseudo-random generator (for instance, `Random`)
    that can delegate method calls to a JDK 17 `RandomGenerator`.'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**从JDK 17的新伪随机生成器获取遗留的伪随机生成器**：编写一个程序，实例化一个遗留的伪随机生成器（例如，`Random`），它可以委托方法调用到JDK
    17的`RandomGenerator`。'
- en: '**Using pseudo-random generators in a thread-safe fashion (multithreaded environments)**:
    Explain and exemplify the usage of pseudo-random generators in a multithreaded
    environment (for instance, using an `ExecutorService`).'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**在多线程环境中安全地使用伪随机生成器**：解释并举例说明在多线程环境中（例如，使用`ExecutorService`）使用伪随机生成器的方法。'
- en: The following sections describe solutions to the preceding problems. Remember
    that there usually isn’t a single correct way to solve a particular problem. Also,
    remember that the explanations shown here include only the most interesting and
    important details needed to solve the problems. Download the example solutions
    to see additional details and to experiment with the programs at [https://github.com/PacktPublishing/Java-Coding-Problems-Second-Edition/tree/main/Chapter01](https://github.com/PacktPublishing/Java-Coding-Problems-Second-Edition/tree/main/Chapter01).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 以下各节描述了解决上述问题的方法。请记住，通常没有解决特定问题的唯一正确方法。此外，请记住，这里所示的解释仅包括解决这些问题所需的最有趣和最重要的细节。下载示例解决方案以查看更多细节，并实验程序，请访问
    [https://github.com/PacktPublishing/Java-Coding-Problems-Second-Edition/tree/main/Chapter01](https://github.com/PacktPublishing/Java-Coding-Problems-Second-Edition/tree/main/Chapter01)。
- en: 1\. Creating a multiline SQL, JSON, and HTML string
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1. 创建多行 SQL、JSON 和 HTML 字符串
- en: 'Let’s consider the following SQL multiline string:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑以下多行 SQL 字符串：
- en: '[PRE0]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As is common knowledge, before JDK 8, we could wrap this SQL as a Java `String`
    (string literal) in several ways.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如常识所知，在 JDK 8 之前，我们可以以几种方式将此 SQL 包装为 Java `String`（字符串字面量）。
- en: Before JDK 8
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 JDK 8 之前
- en: 'Probably the most common approach relies on straightforward concatenation via
    the well-known “`+`" operator. This way, we obtain a multiline string representation,
    as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 可能最常见的方法是直接通过众所周知的“`+`"运算符进行简单的连接。这样，我们得到一个多行字符串表示，如下所示：
- en: '[PRE1]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The compiler should be (and usually is) smart enough to internally transform
    the “`+`" operations into a `StringBuilder`/`StringBuffer` instance and use the
    `append()` method to build the final string. However, we can use `StringBuilder`
    (not thread-safe) or `StringBuffer` (thread-safe) directly, as in the following
    example:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器应该（并且通常确实如此）足够智能，能够将“`+`"操作内部转换为 `StringBuilder`/`StringBuffer` 实例，并使用 `append()`
    方法构建最终的字符串。然而，我们可以直接使用 `StringBuilder`（非线程安全）或 `StringBuffer`（线程安全），如下例所示：
- en: '[PRE2]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Another approach (typically not so popular as the previous two) consists of
    using the `String.concat()` method. This is an immutable operation that basically
    appends a given string at the end of the current one. Finally, it returns the
    new combined string. Trying to append `null` values results in `NullPointerException`
    (in the previous two examples, we can append `null` values without getting any
    exceptions). Chaining `concat()` calls allows us to express multiline strings,
    as in the following example:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法（通常不如前两种流行）是使用 `String.concat()` 方法。这是一个不可变操作，基本上是将给定的字符串追加到当前字符串的末尾。最后，它返回新的组合字符串。尝试追加
    `null` 值会导致 `NullPointerException`（在前两个例子中，我们可以追加 `null` 值而不会抛出任何异常）。链式调用 `concat()`
    允许我们表达多行字符串，如下例所示：
- en: '[PRE3]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Furthermore, we have the `String.format()` method. By simply using the `%s`
    format specifier, we can concatenate multiple strings (including `null` values)
    in a multiline string, as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还有 `String.format()` 方法。通过简单地使用 `%s` 格式说明符，我们可以在多行字符串中连接多个字符串（包括 `null`
    值），如下所示：
- en: '[PRE4]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: While these approaches are still popular these days, let’s see what JDK 8 has
    to say about this topic.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这些方法在当今仍然很流行，但让我们看看 JDK 8 对这个话题有什么看法。
- en: Starting with JDK 8
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从 JDK 8 开始
- en: 'Starting with JDK 8, we can use the `String.join()` method to represent multiline
    strings. This method is also specialized in string concatenation, and it allows
    us to have easy readability in our example. How so? This method takes as the first
    argument a delimiter, and it uses this between the strings that will be concatenated.
    So, if we consider that `\n` is our line delimiter, then it can be specified only
    once, as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 从 JDK 8 开始，我们可以使用 `String.join()` 方法来表示多行字符串。此方法也专门用于字符串连接，并允许我们在示例中具有易于阅读的格式。如何做到这一点？此方法将分隔符作为第一个参数，并在将要连接的字符串之间使用它。因此，如果我们考虑
    `\n` 是我们的行分隔符，那么它只能指定一次，如下所示：
- en: '[PRE5]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Beside the `String.join()` method, JDK 8 also comes with `java.util.StringJoiner`.
    A `StringJoiner` supports a delimiter (as `String.join()`) but also supports a
    prefix and a suffix. Expressing our multiline SQL string doesn’t require a prefix/suffix;
    therefore, the delimiter remains our favorite feature:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `String.join()` 方法之外，JDK 8 还提供了 `java.util.StringJoiner`。`StringJoiner` 支持分隔符（如
    `String.join()`），但也支持前缀和后缀。表达我们的多行 SQL 字符串不需要前缀/后缀；因此，分隔符仍然是我们的最爱功能：
- en: '[PRE6]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Finally, we cannot mention JDK 8 without touching on its mighty Stream API.
    More precisely, we are interested in the `Collectors.joining()` collector. This
    collector works as `String.join()`, and in our case, it looks as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们无法提及JDK 8而不提及其强大的Stream API。更确切地说，我们感兴趣的是`Collectors.joining()`收集器。这个收集器的作用类似于`String.join()`，在我们的情况下，它看起来如下：
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: All the previous examples have a bunch of shortcomings in common. The most important
    of these is that none of these examples represents a truly multiline string literal,
    and the degree of readability is seriously affected by the escaping characters
    and extra quotes needed for each line demarcation. Fortunately, starting with
    JDK 13 (as a future preview) and ending with JDK 15 (as a final feature), the
    new text blocks have become the standard for representing multiline string literals.
    Let’s see how.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的前例都有一些共同的缺点。其中最重要的是，这些示例中没有哪一个真正表示了多行字符串字面量，而且可读性严重受到转义字符和每行分隔所需的额外引号的影响。幸运的是，从JDK
    13（作为一个未来预览）到JDK 15（作为一个最终特性），新的文本块已经成为表示多行字符串字面量的标准。让我们看看它是如何做到的。
- en: Introducing text blocks (JDK 13/15)
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍文本块（JDK 13/15）
- en: 'JDK 13 (JEP 355) offers a preview feature that aims to add support for multiline
    string literals. Over two versions, in JDK 15 (JEP 378), the text block feature
    has become final and permanent for use. But that’s enough history; let’s quickly
    see how text blocks shape our multiline SQL string:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: JDK 13（JEP 355）提供了一个预览功能，旨在添加对多行字符串字面量的支持。经过两个版本，在JDK 15（JEP 378）中，文本块功能已成为最终和永久的使用特性。但历史就到这里；让我们快速看看文本块是如何塑造我们的多行SQL字符串的：
- en: '[PRE8]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This is so cool, right?! We immediately see that the readability of our SQL
    has been restored, and we didn’t mess it up with delimiters, line terminators,
    and concatenations. The text block is concise, easy to update, and easy to understand.
    The footprint of extra code in our SQL string is zero, and the Java compiler will
    do the best to create a `String` in the most predictable way possible. Here is
    another example that embeds a piece of JSON information:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这真是太酷了，对吧？！我们立即看到我们的SQL的可读性已经恢复，我们没有用分隔符、行终止符和连接操作破坏它。文本块简洁、易于更新、易于理解。在SQL字符串中的额外代码的足迹为零，Java编译器将尽最大努力以最可预测的方式创建一个`String`。这里还有一个例子，它嵌入了一段JSON信息：
- en: '[PRE9]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'How about representing a piece of HTML as a text block? Sure, here it is:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如何将一段HTML表示为一个文本块？当然可以，下面就是例子：
- en: '[PRE10]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: So what is the syntax of a text block?
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 那文本块的语法是什么呢？
- en: Hooking text blocks syntax
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 钩子文本块语法
- en: 'The syntax of text blocks is quite simple. No bells and whistles, no complicated
    things – there are just two aspects to keep in mind:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 文本块的语法相当简单。没有花哨的东西，没有复杂的事情——只需记住两个方面：
- en: A text block must start with `"""` (that is, three double quotation marks) and
    a newline. We refer to this construction as the *opening delimiter*.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个文本块必须以`"""`（即三个双引号）和一个换行符开始。我们称这种构造为*开头分隔符*。
- en: A text block must end with `"""` (that is, three double quotation marks). The
    `"""` can be on its own line (as a new line) or at the end of the last line of
    text (as in our example). We refer to this construction as the *closing delimiter.*
    However, there is a semantic difference between these two approaches (dissected
    in the next problem).
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个文本块必须以`"""`（即三个双引号）结束。`"""`可以单独在一行（作为一个新行）或者位于文本最后一行的末尾（就像我们的例子一样）。我们称这种构造为*结尾分隔符*。然而，这两种方法在语义上存在差异（将在下一个问题中分析）。
- en: 'In this context, the following examples are syntactically correct:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个上下文中，以下示例在语法上是正确的：
- en: '[PRE11]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'On the other hand, the following examples are incorrect and lead to compiler
    errors:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，以下示例是错误的，会导致编译器错误：
- en: '[PRE12]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: However, please consider the following best practice.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，请考虑以下最佳实践。
- en: '**Important note**'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '**重要提示**'
- en: 'By looking on the previous snippets of code, we can shape a best practice for
    text blocks: use text blocks only when you have a multiline string; if the string
    fits a single line of code (as in the previous snippets), then use an ordinary
    string literal, since using text blocks doesn’t add any significant value.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看之前的代码片段，我们可以为文本块制定一个最佳实践：只有在你有一个多行字符串时才使用文本块；如果字符串适合单行代码（就像之前的片段一样），那么使用普通的字符串字面量，因为使用文本块不会增加任何显著的价值。
- en: In the bundled code, you can practice all the examples from this problem on
    a piece of SQL, JSON, and HTML.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在捆绑的代码中，你可以在SQL、JSON和HTML上练习这个问题的所有示例。
- en: '**Important note**'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '**重要提示**'
- en: For third-party library support, please consider Apache Commons, `StringUtils.join()`,
    and Guava’s `Joiner.on()`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第三方库支持，请考虑 Apache Commons、`StringUtils.join()` 和 Guava 的 `Joiner.on()`。
- en: Next, let’s focus on working with text block delimiters.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们专注于使用文本块分隔符。
- en: 2\. Exemplifying the usage of text block delimiters
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2. 示例化文本块分隔符的使用
- en: Remember from the previous problem, *Creating a multiline SQL, JSON, and HTML
    string*, that a text block is syntactically delimited by an opening and a closing
    delimiter, represented by three double quotation marks, `"""`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 记住从上一个问题，*创建多行 SQL、JSON 和 HTML 字符串*，一个文本块在语法上由一个开头分隔符和一个结尾分隔符界定，分别由三个双引号表示，`"""`。
- en: 'The best approach for exemplifying the usage of these delimiters consists of
    three simple steps: consider an example, inspect the output, and provide a conclusion.
    This being said, let’s start with an example that imitates some of the JEP’s examples:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些分隔符的最佳方法包括三个简单的步骤：考虑一个示例，检查输出，并提供结论。话虽如此，让我们从一个模仿一些 JEP 示例的示例开始：
- en: '[PRE13]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'So by following the JEP examples, we have to align the content with the opening
    delimiter. It’s probable that this alignment style is not consistent with the
    rest of our code and is not such a good practice. What will happen with the text
    block content if we rename the `sql` variable `updateSql`, `updateOfficeByEmployeeJobTitle`,
    or something else? Obviously, in order to preserve the alignment, this will push
    our content to the right even more. Fortunately, we can shift-left the content
    without affecting the final result, as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，通过遵循 JEP 示例，我们必须将内容与开头分隔符对齐。很可能会发现这种对齐风格与我们的代码的其他部分不一致，并且并不是一个好的实践。如果我们重命名
    `sql` 变量为 `updateSql`、`updateOfficeByEmployeeJobTitle` 或其他名称，文本块内容会发生什么？显然，为了保持对齐，这将使我们的内容进一步向右移动。幸运的是，我们可以将内容向左移动，而不会影响最终结果，如下所示：
- en: '[PRE14]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Shifting right the opening/closing delimiters themselves will not affect the
    resulting `String`. It is unlikely that you’ll have a good reason to do this,
    but just for the sake of completion, the following example produces the same result
    as the previous two examples:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 将开头/关闭分隔符本身向右移动不会影响生成的 `String`。你不太可能有很好的理由这样做，但为了完整性，以下示例产生的结果与前面的两个示例相同：
- en: '[PRE15]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now, let’s see something more interesting. The opening delimiter doesn’t accept
    content on the same line, while the closing delimiter sits to the right at the
    end of the content. However, what happens if we move the closing delimiter to
    its own line, as in the following two examples?
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看一些更有趣的东西。开头分隔符不接受同一行上的内容，而结尾分隔符位于内容末尾的右侧。然而，如果我们像以下两个示例那样将结尾分隔符移动到自己的行，会发生什么？
- en: '[PRE16]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This time, the resulting string contains a new line at the end of the content.
    Check the following figure (the text `-- BEFORE TEXT BLOCK –` and `-- AFTER TEXT
    BLOCK --` are just guidelines added via `System.out.println()` to help you delimit
    the text block itself; they are not necessary and not part of the text block):'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，生成的字符串在内容末尾包含一个新行。检查以下图（文本 `-- TEXT BLOCK 之前 --` 和 `-- TEXT BLOCK 之后 --`
    是通过 `System.out.println()` 添加的指南，以帮助您界定文本块本身；它们不是必需的，也不属于文本块的一部分）：
- en: '![Figure 1.1.png](img/B19665_01_01.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.1.png](img/B19665_01_01.png)'
- en: 'Figure 1.1: Move the closing delimiter to its own line, vertically aligned
    with the opening delimiter'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.1：将关闭分隔符移动到自己的行，垂直对齐到开头分隔符
- en: In the left figure (*A*) the closing delimiter is at the end of the content.
    However, in the right figure (*B*), we moved the closing delimiter to its own
    line, and as you can see, the resulting `String` was enriched with a new line
    at the end.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在左边的图（*A*）中，关闭分隔符位于内容末尾。然而，在右边的图（*B*）中，我们将关闭分隔符移动到了自己的行，如您所见，生成的 `String` 在末尾增加了一个新行。
- en: '**Important note**'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '**重要提示**'
- en: Placing the closing delimiter on its own line will append a new line to the
    final `String`. Also, pay attention that vertically aligning the opening delimiter,
    the content, and the closing delimiter to the left margin may result later in
    extra work. If the variable name is modified, then manual re-indentation is needed
    to maintain this alignment.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 将结尾分隔符放在自己的行上将在最终的 `String` 中追加一个新行。同时，请注意，将开头分隔符、内容和结尾分隔符垂直对齐到左边界可能会在以后导致额外的工作。如果变量名被修改，则需要手动重新缩进以保持这种对齐。
- en: So pay attention to how you place the closing delimiter.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，请注意您放置结尾分隔符的方式。
- en: 'Do you find this weird? Well, that’s not all! In the previous example, the
    closing delimiter was placed on its own line but vertically aligned with the opening
    delimiter. Let’s take a step forward and let’s shift-left the end delimiter, as
    in the following example:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 你觉得这很奇怪吗？好吧，这还不是全部！在前面的例子中，结尾分隔符被放在了其自己的行，但垂直对齐于开分隔符。让我们再向前迈一步，让我们将结束分隔符向左移动，如下面的例子所示：
- en: '[PRE17]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The following figure reveals the effect of this action:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图显示了此动作的效果：
- en: '![Figure 1.2.png](img/B19665_01_02.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![图1.2.png](img/B19665_01_02.png)'
- en: 'Figure 1.2: Moving the closing delimiter to its own line and shifting it to
    the left'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.2：将结尾分隔符移到其自己的行并将它向左移动
- en: In the left figure (*A*), we have the closing delimiter on its own line and
    aligned with the opening delimiter. In the right figure (*B*), we have the effect
    of the previous code. Moving the closing delimiter to the left results in an additional
    indentation of the content to the right. The additional indentation depends on
    how much we shift-left the closing delimiter.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在左边的图（*A*）中，我们有一个单独的行上的结尾分隔符，并且与开分隔符对齐。在右边的图（*B*）中，我们看到了前面代码的效果。将结尾分隔符向左移动会导致内容向右的额外缩进。额外的缩进取决于我们向左移动结尾分隔符的程度。
- en: '**Important note**'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '**重要提示**'
- en: Placing the closing delimiter on its own line and shifting it to the left will
    append a new line and additional indentation to the final `String`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 将结尾分隔符放在其自己的行并将它向左移动将在最终的`String`后追加一个新行和额外的缩进。
- en: 'On the other hand, if we move the closing delimiter to its own line and shift
    it to the right, it doesn’t affect the final `String`:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果我们将结尾分隔符移到其自己的行并将它向右移动，它不会影响最终的`String`：
- en: '[PRE18]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This code appends a new line to the final `String` but doesn’t affect indentation.
    In order to better understand the behavior of opening/closing delimiters, you
    have to explore the next problem.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码向最终的`String`追加一个新行，但不会影响缩进。为了更好地理解开/闭分隔符的行为，你必须探索下一个问题。
- en: 3\. Working with indentation in text blocks
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3. 在文本块中处理缩进
- en: 'Indentation in text blocks is easy to understand if we have a clear picture
    of two terms:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们对文本块中的缩进有一个清晰的了解，那么理解文本块中的缩进就很容易：
- en: '*Incidental* (or *unessential*) white spaces – represent the meaningless white
    spaces that result from code formatting (*leading* white spaces commonly added
    by the IDE) or are added intentionally/accidentally at the end of the text (*trailing*
    white spaces)'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*偶然*（或*非必要*）空白 – 代表由代码格式化（通常由IDE添加的*行首*空白）或故意/意外地添加到文本末尾的空白（*尾随*空白）'
- en: '*Essential* white spaces – represent the white spaces that we explicitly add,
    which are meaningful for the final string'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*必要*空白 – 代表我们明确添加的空白，这对最终字符串是有意义的'
- en: 'In *Figure 1.3*, you can see the incidental versus essential white spaces in
    a JSON text block:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图1.3*中，你可以看到JSON文本块中的偶然空白与必要空白：
- en: '![Figure 1.3.png](img/B19665_01_03.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![图1.3.png](img/B19665_01_03.png)'
- en: 'Figure 1.3: Incidental versus essential white spaces in a JSON text block'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.3：JSON文本块中的偶然空白与必要空白
- en: In the left figure, you can see the incidental versus essential white spaces
    when the closing delimiter is placed at the end of the content. In the middle
    figure, the closing delimiter was moved to its own line, while in the right figure,
    we also shifted to the left.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在左边的图中，你可以看到当结尾分隔符放置在内容末尾时的偶然空白与必要空白。在中间的图中，结尾分隔符被移到了其自己的行，而在右边的图中，我们也将其向左移动。
- en: The incidental (unessential) white spaces are automatically removed by the Java
    compiler. The compiler removes all incidental trailing spaces (to enforce the
    same look in different text editors, which may automatically remove trailing white
    spaces) and uses a special internal algorithm (dissected in the next problem)
    to determine and remove the incidental leading white spaces. Also, it is important
    to mention that the line containing the closing delimiter is always part of this
    check (this is known as the *significant trailing line policy*).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 偶然（非必要）空白将由Java编译器自动删除。编译器会删除所有偶然的尾随空白（以确保在不同文本编辑器中的外观一致，这些编辑器可能会自动删除尾随空白），并使用一个特殊的内部算法（在下一个问题中会详细说明）来确定并删除偶然的行首空白。此外，重要的是要提到，包含结尾分隔符的行始终是此检查的一部分（这被称为*重要尾行策略*）。
- en: 'The essential white spaces are preserved in the final string. Basically, as
    you can intuit from the previous figures, the essential white spaces can be added
    in two ways, as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 本质空白在最终字符串中得以保留。基本上，正如你可以从之前的图中直观地看出，本质空白可以通过以下两种方式添加：
- en: By shifting the closing delimiter left (when this delimiter is on its own line)
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过将关闭定界符左移（当此定界符在其自己的行上时）
- en: By shifting the content right (by explicitly adding white spaces or by using
    helper methods dedicated to controlling indentation)
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过将内容右移（通过显式添加空白或使用专门用于控制缩进的辅助方法）
- en: Shifting the closing delimiter and/or the content
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 移动关闭定界符和/或内容
- en: 'Let’s start with the following code:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从以下代码开始：
- en: '[PRE19]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The white spaces highlighted with the “`–`" sign represent incidental leading
    white spaces (there are no incidental trailing white spaces), while the white
    spaces highlighted with the “`+`" sign represent essential white spaces that you’ll
    see in the resulting `String`. If we shift-right the whole content while the closing
    delimiter is at the end of the content, then the explicitly added white spaces
    are considered incidental and are removed by the compiler:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 用“`–`”符号突出显示的空白表示偶然的行首空白（没有偶然的行尾空白），而用“`+`”符号突出显示的空白表示在结果 `String` 中会看到的本质空白。如果我们整个内容右移，而关闭定界符位于内容末尾，那么显式添加的空白被视为偶然的，并且会被编译器移除：
- en: '[PRE20]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'However, if we move the closing delimiter to its own line (vertically aligned
    with the opening delimiter) and shift-right only the content, then we obtain essential
    white spaces that remain in the final string:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们将关闭定界符移动到其自己的行（垂直对齐于打开定界符），并且仅将内容右移，那么我们就能获得在最终字符串中保留的基本空白：
- en: '[PRE21]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Of course, we can add the same essential white spaces by left shifting the
    closing delimiter:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们可以通过左移关闭定界符来添加相同的本质空白：
- en: '[PRE22]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Moreover, we can adjust each line of text by manually adding white spaces,
    as in the following example:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可以通过手动添加空白来调整每一行文本，如下例所示：
- en: '[PRE23]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Next, let’s see some helper methods useful for indentation purposes.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看一些有用的辅助方法，这些方法对于缩进目的很有用。
- en: Using indentation methods
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用缩进方法
- en: 'Starting with JDK 12, we can add essential white spaces to a literal string
    via the `String.indent(int n)` method, where `n` represents the number of white
    spaces. This method can also be applied to indent the whole content of a text
    block, as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 从 JDK 12 开始，我们可以通过 `String.indent(int n)` 方法向字面量字符串添加本质空白，其中 `n` 表示空白字符的数量。此方法还可以用于缩进文本块的全部内容，如下所示：
- en: '[PRE24]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Obviously, the white spaces added via `indent()` are not visible in the code
    editor of the IDE, but they are highlighted here via the “`*`" sign, just to illustrate
    the effect on the final string. However, when `indent()` is used, a new line is
    also appended, even if the closing delimiter is at the end of the content. In
    this context, moving the closing delimiter to its own line results in the same
    effect, so don’t expect to see two new lines appended. Of course, feel free to
    practice the bundled code for the real experience.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，通过 `indent()` 添加的空白在 IDE 的代码编辑器中是不可见的，但在这里通过“`*`”符号突出显示，只是为了说明对最终字符串的影响。然而，当使用
    `indent()` 时，也会添加一个新行，即使关闭定界符位于内容末尾。在这种情况下，将关闭定界符移动到其自己的行会产生相同的效果，所以不要期望添加两个新行。当然，请随意练习捆绑的代码以获得真实体验。
- en: 'The `indent()` method may be useful to align a block of content that contains
    lines of text placed at the same level of indentation, like the poem that follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`indent()` 方法可能对对齐包含放置在同一缩进级别的文本行的内容块很有用，如下面的诗歌所示：'
- en: '[PRE25]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'If we manually add white spaces in front of each line of the poem, then the
    compiler will remove them, so no essential white spaces could be added globally.
    We can move the closing delimiter to its own line and shift it to the left, or
    shift-right the content to obtain the desired essential white spaces. However,
    in such a case, you still need to remove the new line that is added (as a result
    of moving the closing delimiter to its own line). The easiest way to do this is
    via the JDK 14 new escape sequence, `\`. By adding this escape sequence at the
    end of a line, we instruct the compiler to suppress appending a new line character
    to that line:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在诗的每一行前面手动添加空格，编译器将删除它们，因此无法全局添加任何必要的空格。我们可以将关闭分隔符移动到自己的行并将其向左移动，或者将内容向右移动以获得所需的必要空格。然而，在这种情况下，你仍然需要删除由于将关闭分隔符移动到自己的行而添加的新行。最简单的方法是通过
    JDK 14 的新转义序列`\`。通过在行尾添加此转义序列，我们指示编译器不要将该行的新行字符添加到该行：
- en: '[PRE26]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: While this escape sequence (`\`) is dissected in Problem 5, *Using text block
    just for readability*, let’s see a few approaches based on a string API.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`Problem 5`中已经分析了这个转义序列（`\`），*仅使用文本块以提高可读性*，让我们看看基于字符串API的几种方法。
- en: 'Before JDK 11, we can remove this line via a simple regular expression such
    as `replaceFirst("\\s++$", "")`, or rely on a third-party helper such as the Apache
    Commons `StringUtils.stripEnd()` method. However, starting with JDK 11, we can
    achieve this goal via `String.stripTrailing()`, as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JDK 11 之前，我们可以通过简单的正则表达式如`replaceFirst("\\s++$", "")`来删除此行，或者依赖于第三方辅助工具，如Apache
    Commons的`StringUtils.stripEnd()`方法。然而，从 JDK 11 开始，我们可以通过`String.stripTrailing()`来实现这一目标，如下所示：
- en: '[PRE27]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Now, the content block is indented as a result of shifting the closing delimiter
    left, and the automatically added new line is removed thanks to the `stripTrailing()`
    method.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，由于将关闭分隔符向左移动，内容块被缩进，并且由于`stripTrailing()`方法，自动添加的新行被删除。
- en: '**Important note**'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '**重要提示**'
- en: As well as `stripTrailing()`, JDK 11 also comes with `stripLeading()` and `strip()`.
    Also, starting with JDK 15, we have `stripIndent()`, which removes the leading
    and trailing white spaces exactly as the compiler does.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`stripTrailing()`之外，JDK 11 还提供了`stripLeading()`和`strip()`。从 JDK 15 开始，我们还有`stripIndent()`，它正好像编译器那样删除首尾空格。
- en: 'However, starting with JDK 12, we can use `String.indent(int n)`, which saves
    us from adding white spaces manually:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，从 JDK 12 开始，我们可以使用`String.indent(int n)`，这使我们免去了手动添加空格的需要：
- en: '[PRE28]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Now, it is time to move forward and dissect the algorithm for removing incidental
    white spaces.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候向前推进并分析删除意外空格的算法了。
- en: 4\. Removing incidental white spaces in text blocks
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4. 删除文本块中的意外空格
- en: 'Removing incidental white spaces in text blocks is typically a job accomplished
    by the compiler via a special algorithm. To understand the main aspects of this
    algorithm, let’s go over it with the following example:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 删除文本块中的意外空格通常是编译器通过特殊算法完成的任务。为了理解这个算法的主要方面，让我们通过以下示例来回顾一下：
- en: '[PRE29]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: To remove the incidental leading white spaces, the compiler has to inspect all
    non-blank lines (lines containing only white spaces), so in our case, it will
    inspect 17 lines. There are 16 lines of JSON code and the closing delimiter line.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 为了删除意外的首行空格，编译器必须检查所有非空白行（仅包含空白的行），因此在我们的例子中，它将检查17行。其中有16行JSON代码和关闭分隔符行。
- en: The compiler scans each of these 17 lines and counts the number of leading white
    spaces. The character used to represent the white space is not relevant in this
    count – it could be simple space, tab, and so on. They all have the same weight
    of 1, so a single white space is the same as a single tab. This is needed because
    the compiler can’t know how tab characters will be displayed in different text
    editors (for instance, a tab could be made of four or eight characters). Once
    this step of the algorithm is done, the compiler knows the exact number of leading
    white spaces for each of the inspected lines. For instance, line 1 has 4 **leading
    white spaces** (**lws**), line 2 has 6 lws, line 3 has 8 lws, and so on (check
    the previous snippet of code to see all the numbers).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器扫描这些17行中的每一行，并计算前导空格的数量。用于表示空格的字符在此计数中并不重要——它可以是简单的空格、制表符等等。它们都具有相同的权重1，因此单个空格与单个制表符相同。这是必要的，因为编译器不知道制表符将在不同的文本编辑器中如何显示（例如，一个制表符可能是四个或八个字符）。一旦这个算法步骤完成，编译器就知道检查的每一行的确切前导空格数量。例如，第1行有4个**前导空格**（**lws**），第2行有6个lws，第3行有8个lws，依此类推（查看之前的代码片段以查看所有数字）。
- en: '**Important note**'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '**重要提示**'
- en: 'Let’s quickly look at another text block best practice: Don’t mix white spaces
    and tabs in the same text block. This way, you enforce indentation consistency
    and avoid any potential irregular indentation.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速看一下另一个文本块的最佳实践：不要在同一个文本块中混合空格和制表符。这样，你可以确保缩进的一致性，并避免任何潜在的缩进不规则性。
- en: At this point, the compiler computes the minimum value of those numbers, and
    the result (in this case, 4) represents the number of incidental leading white
    spaces that should be removed from each of the 17 lines. So in the final result,
    at least one of the lines has no leading white space. Of course, the essential
    white space (an additional indentation represented via the “`+`" sign) remains
    untouched. For instance, in line 5, we have 10 lws – 4 incidental lws = 6 essential
    lws that remain untouched.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，编译器计算这些数字的最小值，结果（在这种情况下，4）表示应该从每17行中移除的意外前导空格的数量。因此，在最终结果中，至少有一行没有前导空格。当然，必要的空格（通过“`+`”符号表示的额外缩进）保持不变。例如，在第5行，我们有10个lws（leading
    white spaces，前导空格）- 4个意外lws = 6个必要的lws保持不变。
- en: In the bundled code, you can find three more JSON examples that you can use
    to practice this algorithm. Now, we will tackle some text block readability aspects.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在捆绑的代码中，你可以找到三个更多的JSON示例，你可以使用这些示例来练习这个算法。现在，我们将解决一些文本块可读性的方面。
- en: 5\. Using text blocks just for readability
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5. 仅使用文本块以提高可读性
- en: 'Using text blocks just for readability can be translated as making a string
    look like a text block but act as a single-line string literal. This is especially
    useful for formatting long lines of text. For instance, we may want to have the
    following SQL string look like a text block (for readability purposes) but act
    as a single-line string literal (in the sense of being compact when we pass it
    to the database):'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 仅使用文本块以提高可读性可以翻译为将字符串看起来像文本块，但作为单行字符串字面量。这对于格式化长文本行特别有用。例如，我们可能希望以下SQL字符串看起来像文本块（为了可读性），但作为单行字符串字面量（在传递给数据库时紧凑的意义上）：
- en: '[PRE30]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Starting with JDK 14, we can accomplish this goal via the new escape sequence,
    `\` (a single backslash). By adding this escape sequence at the end of a line,
    we instruct the compiler to suppress appending a new line character to that line.
    So in our case, we can express the SQL as a single-line string literal, as follows:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 从JDK 14开始，我们可以通过新的转义序列`\`（一个单独的反斜杠）来实现这个目标。通过在行尾添加这个转义序列，我们指示编译器抑制向该行追加换行符。因此，在我们的情况下，我们可以将SQL表达为单行字符串字面量，如下所示：
- en: '[PRE31]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Pay attention to not adding any white spaces after `\` because you’ll get an
    error.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 注意不要在`\`后添加任何空格，否则你会得到一个错误。
- en: 'If we throw this text block in a `System.out.println()`, then the output reveals
    the single-line string literal, as follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将这个文本块放入`System.out.println()`中，那么输出将揭示单行字符串字面量，如下所示：
- en: '[PRE32]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Next, let’s check out another example, as follows:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们检查另一个示例，如下所示：
- en: '[PRE33]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This time, the resulting string is not exactly what we want because the essential
    white space is preserved. This means that the single-line string is sprinkled
    with sequences of spaces that we should reduce to a single space. This is where
    a regular expression can help:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，结果字符串并不是我们想要的，因为必要的空格被保留了。这意味着单行字符串被散布着一系列空格，我们应该将其缩减为单个空格。这正是正则表达式可以发挥作用的地方：
- en: '[PRE34]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Done! Now, we have a single-line SQL string that looks like a text block in
    an IDE.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 完成！现在，我们有一个看起来像 IDE 中文本块的单一行的 SQL 字符串。
- en: 'Next, let’s assume that we want to print on a nice background the following
    poem wrapped in a text block:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，假设我们想在文本块中打印以下诗歌，并添加一个漂亮的背景：
- en: '[PRE35]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Adding a background to this poem will result in something like the following
    figure:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 为这首诗添加背景将得到如下所示的图形：
- en: '![Figure 1.4.png](img/B19665_01_04.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.4.png](img/B19665_01_04.png)'
- en: 'Figure 1.4: Adding a background to the poem'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.4：为诗歌添加背景
- en: '**Important note**'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '**重要提示**'
- en: The colored background is just a guideline for alignment, as white on white
    would not be legible.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 彩色背景仅作为对齐的指南，因为白色背景上的白色将无法辨认。
- en: Since the compiler removes the trailing white space, we will obtain something
    as shown in the left figure. Obviously, we want something as shown in the right
    figure, so we need to find a way to preserve the trailing white space as essential.
    Starting with JDK 14, we can do that via the new escape sequence, `\s`.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 由于编译器删除了尾随空格，我们将得到如图左侧所示的内容。显然，我们想要如图右侧所示的内容，因此我们需要找到一种方法来保留尾随空格作为必要部分。从 JDK
    14 开始，我们可以通过新的转义序列 `\s` 来做到这一点。
- en: 'We can repeat this escape sequence for every space as follows (we add three
    white spaces to the first line and two white spaces to the last line; this way,
    we obtain a symmetrical text block):'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以为每个空格重复这个转义序列，如下所示（我们在第一行添加了三个空格，在最后一行添加了两个空格；这样，我们得到了一个对称的文本块）：
- en: '[PRE36]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Alternatively, we can manually add white spaces and a single `\s` at the end
    of the line. This is possible because the compiler preserves any white spaces
    in front of `\s`:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以在行尾手动添加空格和一个单个 `\s`。这是可能的，因为编译器会保留 `\s` 前面的任何空格：
- en: '[PRE37]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Done! Now, we have preserved white spaces, so when the background color is applied,
    we will obtain something as shown on the right side of *Figure 1.4*.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 完成！现在，我们已经保留了空格，所以当应用背景颜色时，我们将获得如图 1.4 右侧所示的内容。
- en: Next, let’s focus on escaping characters.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们专注于转义字符。
- en: 6\. Escaping quotes and line terminators in text blocks
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6. 在文本块中转义引号和行终止符
- en: 'Escaping double quotes is necessary only when we want to embed, in the text
    block, the sequence of three double quotes (`"""`), as follows:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在我们想在文本块中嵌入三个双引号（`"""`）序列时，转义双引号才是必要的，如下所示：
- en: '[PRE38]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Escaping `"""` can be done with `\"""`. There is no need to write `\"\"\"`.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `\"""` 可以转义 `"""`。没有必要写 `\"\"\"`。
- en: 'The resulting string will look like this:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的字符串将看起来像这样：
- en: '[PRE39]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Whenever you need to embed `"` or `""`, simply do it as follows:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 无论何时需要嵌入 `"` 或 `""`，只需按照以下方式操作：
- en: '[PRE40]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'So even if it works, don’t do this, since is not necessary:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 即使它可行，也不要这样做，因为这不是必要的：
- en: '[PRE41]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: However, a construction such as `""""` (where the first `"` represents a double
    quote and the last `"""` represents the closing delimiter of the text block) will
    raise an error. In such a case, you can place a space as `" """` or escape the
    double quote as `\""""`.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，像 `""""`（其中第一个 `"` 表示一个双引号，最后的 `"""` 表示文本块的结束分隔符）这样的结构将引发错误。在这种情况下，你可以放置一个空格作为
    `" """` 或将双引号转义为 `\""""`。
- en: 'By definition, a text block represents string literals spanning multiple lines,
    so there is no need to explicitly escape line terminators (new lines), such as
    `\n`, `\r`, or `\f`. Just add new lines of text in the text block, and the compiler
    will take care of line terminators. Of course, this doesn’t mean that using them
    doesn’t work. For instance, obtaining a text block that has interleaved blank
    lines can be done via `\n`, as follows:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 根据定义，文本块表示跨越多行的字符串字面量，因此不需要显式转义行终止符（换行符），如 `\n`、`\r` 或 `\f`。只需在文本块中添加新行文本，编译器就会处理行终止符。当然，这并不意味着使用它们不起作用。例如，可以通过
    `\n` 获得交错空白行的文本块，如下所示：
- en: '[PRE42]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Using escape sequences (for example, `\b`, `\t`, `\r`, `\n`, `\f`, and so on)
    in text blocks can be done exactly like they would be done in old-school string
    literals. For instance, there is nothing wrong here:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在文本块中使用转义序列（例如，`\b`、`\t`、`\r`、`\n`、`\f`等）与在旧式字符串字面量中的使用方式完全相同。例如，这里没有问题：
- en: '[PRE43]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'However, the same thing can be obtained without escape sequences (consider
    `\t` (tab) as eight white spaces):'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，无需转义序列（例如，将 `\t`（制表符）视为八个空格）也可以得到相同的结果：
- en: '[PRE44]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: You can practice all these examples in the bundled code.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在捆绑的代码中练习所有这些示例。
- en: '**Important note**'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '**重要提示**'
- en: 'Let’s quickly look at another text block best practice: Adding escape sequences
    explicitly may negatively affect the readability of the text block, so use them
    carefully and only when they are really needed. For instance, explicit `\n` and
    `\"` are rarely necessary for text blocks.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速看一下另一个文本块最佳实践：显式添加转义序列可能会负面影响文本块的可读性，因此请谨慎使用，并且仅在真正需要时使用。例如，显式的 `\n` 和
    `\"` 对于文本块来说很少是必要的。
- en: Speaking about the `\n` line terminator (new line), it is important to be aware
    of the following note.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 讨论到 `\n` 行终止符（换行符），重要的是要注意以下注意事项。
- en: '**Important note**'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '**重要提示**'
- en: Probably the most used line terminator in Java is `\n` (Unix, **Line Feed**
    (**LF**)), but we can also use `\r` (Windows, **Carriage Return** (**CR**)) or
    `\n\r` (Windows, **Carriage Return Line Feed** (**CRLF**)). No matter which of
    these we prefer, Java text blocks always use `\n` (LF). First, the compiler normalizes
    all line breaks that are not added explicitly via escape sequences to `\n` (LF).
    Second, after the normalization of line terminators and managed indentation, the
    compiler handles all the explicit escape sequences (`\n` (LF), `\f` (FF), `\r`(CR),
    and so on), as in any string literal. Practically, this allows us to copy into
    a text block a legacy Java string containing escape sequences, obtaining the expected
    result without further modifications.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，最常用的行终止符可能是 `\n`（Unix，**换行**（**LF**）），但我们也可以使用 `\r`（Windows，**回车**（**CR**））或
    `\n\r`（Windows，**回车换行**（**CRLF**））。无论我们更喜欢哪一个，Java文本块始终使用 `\n`（LF）。首先，编译器将所有未通过转义序列显式添加的行终止符规范化为
    `\n`（LF）。其次，在行终止符规范化和管理的缩进之后，编译器将处理所有显式转义序列（`\n`（LF），`\f`（FF），`\r`（CR）等），就像任何字符串字面量一样。实际上，这允许我们将包含转义序列的旧版Java字符串复制到文本块中，无需进一步修改即可获得预期结果。
- en: If you ever need to use the line terminator specific to your operating system,
    then you have to explicitly replace it after text block normalization via `String.replaceAll()`,
    as `String::replaceAll("\n", System.lineSeparator()`).
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要使用特定于操作系统的行终止符，那么你必须通过 `String.replaceAll()` 显式替换文本块规范化后的行终止符，例如 `String::replaceAll("\n",
    System.lineSeparator())`。
- en: 'Embedding in a text block an escape sequence can be done as usual via the `\\`
    construction. Here is an example of embedding the `\"` escape sequence as `\\"`:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在文本块中嵌入转义序列可以通过通常的 `\\` 构造来完成。以下是将 `\"` 转义序列嵌入为 `\\"` 的示例：
- en: '[PRE45]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: You can check the output in the bundled code. Now, let’s see how we can translate
    escape sequences programmatically.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在捆绑的代码中检查输出。现在，让我们看看如何程序化地转换转义序列。
- en: 7\. Translating escape sequences programmatically
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7. 程序化转换转义序列
- en: We already know that the compiler is responsible for the translation of escape
    sequences, and most of the time, there is no need to explicitly interfere in this
    process. But there are cases when we may need programmatic access to this process
    (for instance, to explicitly un-escape a string before passing it to a function).
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道编译器负责转义序列的转换，大多数时候，我们不需要显式地干预这个过程。但是，有些情况下我们可能需要以编程方式访问这个过程（例如，在将字符串传递给函数之前显式取消转义字符串）。
- en: Starting with JDK 15, we can accomplish this via `String.translateEscapes()`,
    which is capable of un-escape sequences such as `\t`, `\n`, `\b`, and so on, and
    octal numbers (`\0`–`\377`). However, this method doesn’t translate Unicode escapes
    (`\uXXXX`).
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 从JDK 15开始，我们可以通过 `String.translateEscapes()` 来完成这项任务，该方法能够取消转义序列，如 `\t`，`\n`，`\b`
    等，以及八进制数（`\0`–`\377`）。然而，此方法不翻译Unicode转义序列（`\uXXXX`）。
- en: 'We can perform an equality test in order to reveal how `translateEscapes()`
    works:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过进行等式测试来揭示 `translateEscapes()` 的工作方式：
- en: '[PRE46]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: As you can already intuit, the result is *yes*.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所预料的，结果是**是的**。
- en: 'Next, let’s assume that we want to use an external service that prints addresses
    on parcels. The function responsible for this task gets a string representing
    the address without containing escape sequences. The problem is that our customer’s
    addresses pass through a formatting process that patches them with escape sequences,
    as in the following example:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，假设我们想要使用一个外部服务，该服务在包裹上打印地址。负责此任务的功能接收一个不包含转义序列的地址表示字符串。问题是我们的客户的地址在通过一个格式化过程时会被修补上转义序列，如下例所示：
- en: '[PRE47]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The following figure reveals how the resulting string will look if we don’t
    translate escapes of the address (left side) and how it will look if we do (right
    side). Of course, our goal is to obtain the address from the right side and send
    it to print:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 下图揭示了如果我们不翻译地址的转义字符（左侧）和如果我们翻译它们（右侧）时生成的字符串将如何看起来。当然，我们的目标是获取右侧的地址并将其发送到打印：
- en: '![Figure 1.5.png](img/B19665_01_05.png)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![Figure 1.5.png](img/B19665_01_05.png)'
- en: 'Figure 1.5: We want the string from the right side'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.5：我们想要右侧的字符串
- en: 'Translation of escapes can be done programmatically via `String.translateEscapes()`,
    right before sending the result to the external service. Here is the code:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过 `String.translateEscapes()` 方法程序化地翻译转义字符，在将结果发送到外部服务之前。以下是代码：
- en: '[PRE48]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Now, `translatedAddress` can be passed to the external printing service. As
    an exercise, you can think about how to exploit this method to write a parser
    of source code, provided via Java or another programming language.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`translatedAddress` 可以传递给外部打印服务。作为一个练习，你可以思考如何利用这种方法编写一个通过 Java 或其他编程语言提供的源代码解析器。
- en: '**Important note**'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '**重要提示**'
- en: Similar results (of course, read the documentation to obtain the fine-grained
    information) can be obtained via Apache Commons’ Lang third-party library support.
    Please consider `StringEscapeUtils.unescapeJava(String)`.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过 Apache Commons’ Lang 第三方库支持获得类似的结果（当然，阅读文档以获取更详细的信息）。请考虑使用 `StringEscapeUtils.unescapeJava(String)`。
- en: Next, let’s talk about embedding expressions in text blocks.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们谈谈在文本块中嵌入表达式。
- en: 8\. Formatting text blocks with variables/expressions
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8. 使用变量/表达式格式化文本块
- en: 'In Java, it is a common practice to format string literals with variables/expressions
    to obtain dynamic strings. For instance, we can create a dynamic piece of XML
    string via the following well-known concatenation:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 中，使用变量/表达式格式化字符串字面量以获取动态字符串是一种常见的做法。例如，我们可以通过以下众所周知的连接创建一个动态的 XML 字符串：
- en: '[PRE49]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Of course, this tiny construction has serious issues from a readability perspective.
    XML code is human-readable if it is formatted and indented accordingly; otherwise,
    is really hard to follow its hierarchy. So, can we express this XML to look like
    the following figure?
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这个微小的结构在可读性方面存在严重问题。如果 XML 代码经过适当的格式化和缩进，它是可读的；否则，很难跟随其层次结构。那么，我们能否将这个 XML
    表达得像以下图示一样？
- en: '![Figure 1.6.png](img/B19665_01_06.png)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![Figure 1.6.png](img/B19665_01_06.png)'
- en: 'Figure 1.6: Formatted XML'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.6：格式化的 XML
- en: 'Sure we can! By using some escape sequences (for instance, `\n`, `\t`, and
    `\s`), white spaces, and so on, we can construct a `String` to look like *Figure
    1.6*. However, it would be better to express this concatenation via a text block.
    Maybe we can achieve the same readability in the IDE’s code editor and console
    (at runtime). A possible approach looks like this:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 当然可以！通过使用一些转义序列（例如，`\n`、`\t` 和 `\s`）、空白字符等，我们可以构建一个看起来像 *Figure 1.6* 的 `String`。然而，通过文本块表达这种连接可能更好。也许我们可以在
    IDE 的代码编辑器和控制台（在运行时）中达到相同的可读性。一种可能的方法如下：
- en: '[PRE51]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'So we can concatenate text blocks exactly like string literals via the “`+`"
    operator. Cool! The output of this code corresponds to the left side of *Figure
    1.6*. On the other hand, the right side of *Figure 1.6* can be achieved as follows:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以通过“`+`”运算符精确地连接文本块，就像字符串字面量一样。酷！这段代码的输出对应于 *Figure 1.6* 的左侧。另一方面，*Figure
    1.6* 的右侧可以通过以下方式实现：
- en: '[PRE52]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Well, while the resulting string looks good in both cases, we cannot say the
    same thing about the code itself. It still has a low readability rate.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，虽然在这两种情况下生成的字符串看起来都很好，但我们不能对代码本身说同样的话。它的可读性仍然很低。
- en: '**Important note**'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '**重要提示**'
- en: 'By looking at the previous two snippets of code, we can easily conclude a best
    practice for text blocks: use them only when they significantly contribute to
    code clarity and the readability of multiline strings. Also, avoid declaring text
    blocks in complex expressions (for instance, in lambda expressions), since they
    may affect the readability of the entire expression. It is better to extract text
    blocks separately in static variables and refer to them in complex expressions.'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看前面的两个代码片段，我们可以很容易地得出文本块的最佳实践：仅在它们显著提高代码清晰度和多行字符串的可读性时使用它们。此外，避免在复杂表达式（例如
    lambda 表达式）中声明文本块，因为它们可能会影响整个表达式的可读性。最好将文本块单独提取到静态变量中，并在复杂表达式中引用它们。
- en: 'Let’s try another approach. This time, let’s use a `StringBuilder` to obtain
    the result from the left side of *Figure 1.6*:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试另一种方法。这次，让我们使用`StringBuilder`来获取*图1.6*左侧的结果：
- en: '[PRE53]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Then, obtaining the result from the right side of *Figure 1.6* can be done
    as follows:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，从*图1.6*的右侧获取结果可以这样做：
- en: '[PRE54]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: So we can use text blocks in `StringBuilder`/`StringBuffer` exactly as we use
    string literals. While the resulting string corresponds to the examples from *Figure
    1.6*, the code itself is still unsatisfactory from the readability perspective.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以在`StringBuilder`/`StringBuffer`中使用文本块，就像我们使用字符串字面量一样。虽然生成的字符串对应于*图1.6*中的示例，但从可读性的角度来看，代码本身仍然不尽如人意。
- en: 'Let’s give it another try via the JDK 1.4, `MessageFormat.format()`. First,
    let’s shape the example from *Figure 1.6*, left side:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次尝试使用JDK 1.4的`MessageFormat.format()`。首先，让我们塑造*图1.6*中的示例，左侧：
- en: '[PRE55]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'And obtaining the result from *Figure 1.6* (right side) can be done as follows:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 从*图1.6*（右侧）获取结果可以这样做：
- en: '[PRE56]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The text blocks and `MessageFormat.format()` combo is a winning approach. The
    code readability is obviously better. But, let’s go further, and let’s give it
    a try in JDK 5 `String.format()`. As usual, *Figure 1.6* (left side) is first:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 文本块和`MessageFormat.format()`的组合是一个成功的方案。代码的可读性显然更好。但是，让我们更进一步，让我们在JDK 5 `String.format()`中尝试一下。像往常一样，*图1.6*（左侧）是首先：
- en: '[PRE57]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'And obtaining the result from *Figure 1.6* (right side) can be done as follows:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 从*图1.6*（右侧）获取结果可以这样做：
- en: '[PRE58]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The text blocks and `String.format()` combo is another winning approach but
    is not the latest feature that we can exploit. Starting with JDK 15, `String.format()`
    has a more convenient companion named `formatted()`. Here is `String.formatted()`
    at work to reproduce *Figure 1.6* (left side):'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 文本块和`String.format()`的组合是另一种成功的方案，但不是我们可以利用的最新特性。从JDK 15开始，`String.format()`有一个更方便的伴侣，名为`formatted()`。以下是`String.formatted()`的工作原理，用于重现*图1.6*（左侧）：
- en: '[PRE59]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'And obtaining the result from *Figure 1.6* (right side) can be done as follows:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 从*图1.6*（右侧）获取结果可以这样做：
- en: '[PRE60]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: That is the best we can do. We managed to achieve the same level of readability
    in the IDE’s code editor and runtime for a text block containing dynamic parts
    (variables). Cool, isn’t it?!
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们能做的最好的了。我们成功地在IDE的代码编辑器和运行时中实现了包含动态部分（变量）的文本块的可读性水平。酷，不是吗?!
- en: From the performance perspective, you can find a benchmark of these approaches
    in the bundled code. In the following figure, you can see the results of this
    benchmark on an Intel^® Core^™ i7-3612QM CPU @ 2.10GHz machine with Windows 10,
    but feel free to test it on different machines, since the results are highly dependent
    on the machine.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 从性能角度来看，你可以在捆绑的代码中找到一个这些方法的基准。在下面的图中，你可以看到在Intel^® Core^™ i7-3612QM CPU @ 2.10GHz机器上（Windows
    10）这个基准的结果，但你可以自由地在不同的机器上测试它，因为结果高度依赖于机器。
- en: '![Figure 1.7.png](img/B19665_01_07.png)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
  zh: '![图1.7.png](img/B19665_01_07.png)'
- en: 'Figure 1.7: Benchmark results'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.7：基准结果
- en: Conforming to these results, concatenation via the “`+`" operator is the fastest,
    while the `MessageFormat.format()` is the slowest.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 符合这些结果，通过“`+`”运算符的连接是最快的，而`MessageFormat.format()`是最慢的。
- en: 9\. Adding comments in text blocks
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9. 在文本块中添加注释
- en: 'Question: Can we add comments in text blocks?'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 问题：我们能否在文本块中添加注释？
- en: 'Official answer (according to the Java Language Specification): The lexical
    grammar implies that comments do not occur within character literals, string literals,
    or text blocks.'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 官方答案（根据Java语言规范）：词法语法暗示注释不会出现在字符字面量、字符串字面量或文本块中。
- en: 'You might be tempted to try something like this, thinking it’s a quick hack,
    but I really don’t recommend it:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想尝试一些类似的方法，认为这是一种快速的方法，但我真的不推荐这样做：
- en: '[PRE61]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Short answer: No, we cannot have comments in text blocks.'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 简短回答：不，我们不能在文本块中添加注释。
- en: Let’s move on and talk about mixing ordinary string literals with text blocks.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续，谈谈混合普通字符串字面量和文本块。
- en: 10\. Mixing ordinary string literals with text blocks
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10. 混合普通字符串字面量和文本块
- en: 'Before mixing ordinary string literals with text blocks, let’s consider the
    following statement: How different is an ordinary string literal from a text block?
    We can answer this question via the following snippet of code:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在混合普通字符串字面量和文本块之前，让我们考虑以下声明：普通字符串字面量和文本块有多大的不同？我们可以通过以下代码片段来回答这个问题：
- en: '[PRE62]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Now that we know that there are no major differences in how ordinary string
    literals and text blocks are treated internally, we can be confident to mix them
    in a simple concatenation (basically, a text block can be used anywhere an ordinary
    string literal can be used):'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道，在内部处理普通字符串字面量和文本块时没有重大差异，我们可以自信地将它们混合在简单的连接中（基本上，文本块可以在普通字符串字面量可以使用的任何地方使用）：
- en: '[PRE63]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Moreover, since a text block returns a `String`, we can use the entire arsenal
    of methods that we use for ordinary string literals. Here is an example:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，由于文本块返回一个 `String`，我们可以使用我们用于普通字符串字面量的整个方法库。以下是一个示例：
- en: '[PRE64]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Also, as you just saw in *Problem 8*, *Formatting text blocks with variables/expressions*,
    text blocks can be used and mixed with ordinary string literals in `StringBuilder`(`Buffer`),
    `MessageFormat.format()`, `String.format()`, and `String.formatted()`.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，正如你在 *问题 8* 中看到的，*使用变量/表达式格式化文本块*，文本块可以与普通字符串字面量一起在 `StringBuilder`(`Buffer`)、`MessageFormat.format()`、`String.format()`
    和 `String.formatted()` 中使用和混合。
- en: 11\. Mixing regular expression with text blocks
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 11. 将正则表达式与文本块混合
- en: 'Regular expressions can be used with text blocks. Let’s consider a simple string,
    as follows:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式可以与文本块一起使用。让我们考虑一个简单的字符串，如下所示：
- en: '[PRE65]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'So here we have a name (Mark Janson) and some details about his address, delimited
    by a semicolon (`;`). It is a common scenario to pass such strings through regular
    expressions and extract the information as named groups. In this example, we can
    consider five named groups as follows:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这里有一个名字（Mark Janson）以及一些关于他地址的详细信息，由分号（`;`）分隔。将此类字符串通过正则表达式传递并提取信息作为命名组是一种常见场景。在这个例子中，我们可以考虑以下五个命名组：
- en: '`name`: should contain the person’s name (Mark Janson)'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`：应包含个人的姓名（Mark Janson）'
- en: '`address`: should contain the person’s street information (243 West Main St)'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`address`：应包含个人的街道信息（243 West Main St）'
- en: '`city`: should contain the person’s city (Louisville)'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`city`：应包含个人的城市（Louisville）'
- en: '`zip`: should contain the city’s zip code (40202)'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`zip`：应包含城市的邮政编码（40202）'
- en: '`country`: should contain the country’s name (USA)'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`country`：应包含国家的名称（USA）'
- en: 'A regular expression that can match these named groups may look as follows:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 可以匹配这些命名组的正则表达式可能看起来如下：
- en: '[PRE66]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'This is a single-line string, so we can use it via the `Pattern` API, as follows:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个单行字符串，因此我们可以通过 `Pattern` API 使用它，如下所示：
- en: '[PRE67]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'However, as you can see, writing our regex like this has a serious impact on
    readability. Fortunately, we can employ text blocks to solve this issue, as follows:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，正如你所看到的，这样编写我们的正则表达式会对可读性产生严重影响。幸运的是，我们可以使用文本块来解决这个问题，如下所示：
- en: '[PRE68]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: This is more readable, right? The only thing that we should take care of is
    to use the JDK 14 new escape sequence, `\` (a single backslash), to remove the
    trailing line feed at the end of each line.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 这更易于阅读，对吧？我们唯一需要注意的事情是使用 JDK 14 的新转义序列 `\`（一个反斜杠），以删除每行末尾的换行符。
- en: 'Next, you can simply match the address and extract the named groups, as follows:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你可以简单地匹配地址并提取命名组，如下所示：
- en: '[PRE69]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'If you want just to extract the names of the groups, then you can rely on JDK
    20’s `namedGroups()`:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只想提取组名，那么你可以依赖 JDK 20 的 `namedGroups()`：
- en: '[PRE70]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Actually, `namedGroups()` returns an unmodifiable `Map<String, Integer>`, where
    the key is the group name and the value is the group number. Furthermore, JDK
    20 has also added the `hasMatch()` method, which returns `true` if the matcher
    contains a valid match from a previous match or find operation:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，`namedGroups()` 返回一个不可修改的 `Map<String, Integer>`，其中键是组名，值是组号。此外，JDK 20 还添加了
    `hasMatch()` 方法，该方法在匹配器包含来自先前匹配或查找操作的有效匹配时返回 `true`：
- en: '[PRE71]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Note that `hasMatch()` will not attempt to trigger a match against the pattern
    as `matches()` does. When you need to check for valid matches in different places
    of your code, `hasMatch()` is preferable, since it will not perform matches. So,
    you can call `matches()` once, and in subsequent checks for valid matches, just
    call `hasMatch()`.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`hasMatch()` 不会像 `matches()` 那样尝试触发与模式的匹配。当你需要在代码的不同位置检查有效匹配时，`hasMatch()`
    更可取，因为它不会执行匹配。因此，你可以先调用一次 `matches()`，然后在后续的有效匹配检查中，只需调用 `hasMatch()`。
- en: 'Moreover, if you just need to extract the input subsequence captured for each
    named group by a given delimiter, then you can rely on JDK 21’s `splitWithDelimiters(CharSequence
    input, int limit)`. For instance, our string can be split by a semicolon (regex,
    `;+`), as follows:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果您只需要提取由给定分隔符捕获的每个命名组的输入子序列，则可以依赖 JDK 21 的 `splitWithDelimiters(CharSequence
    input, int limit)`。例如，我们的字符串可以通过分号（正则表达式，`;+`）分割，如下所示：
- en: '[PRE72]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'The returned array contains the extracted data and the delimiters, as follows:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的数组包含提取的数据和分隔符，如下所示：
- en: '[PRE73]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: The second argument of `splitWithDelimiters()` is an integer representing how
    many times to apply the regex. If the `limit` argument is 0, then the pattern
    will be applied as many times as possible, and the trailing empty strings, whether
    substrings or delimiters, will be discarded. If it is positive, then the pattern
    will be applied, at most, the `limit` - 1 times, and if it is negative, the pattern
    will be applied as many times as possible.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '`splitWithDelimiters()` 函数的第二个参数是一个整数，表示应用正则表达式的次数。如果 `limit` 参数为 0，则模式将被尽可能多次地应用，并且尾随的空字符串（无论是子字符串还是分隔符）将被丢弃。如果它是正数，则模式将被应用，最多
    `limit` - 1 次；如果是负数，则模式将被尽可能多次地应用。'
- en: 12\. Checking if two text blocks are isomorphic
  id: totrans-318
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 12. 检查两个文本块是否同构
- en: Two text blocks are isomorphic if the resulting strings are isomorphic. Two
    string literals are considered isomorphic if we can map every character of the
    first string to every character of the second string in a one-to-one fashion.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 如果结果字符串是同构的，则两个文本块是同构的。如果我们可以以一对一的方式将第一个字符串的每个字符映射到第二个字符串的每个字符，则两个字符串字面量被认为是同构的。
- en: 'For example, consider that the first string is “`abbcdd`" and the second string
    is “`qwwerr`". The one-to-one character mapping is shown in *Figure 1.8*:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑第一个字符串是 “`abbcdd`" 和第二个字符串是 “`qwwerr`"。一对一字符映射如图 *1.8* 所示：
- en: '![Figure 1.7.png](img/B19665_01_08.png)'
  id: totrans-321
  prefs: []
  type: TYPE_IMG
  zh: '![Figure 1.7.png](img/B19665_01_08.png)'
- en: 'Figure 1.8: One-to-one character mapping between two strings'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.8：两个字符串之间的一对一字符映射
- en: So as you can see in *Figure 1.8*, character “a” of the first string can be
    replaced by character “q” of the second string. Moreover, character “b” of the
    first string can be replaced by character “w” of the second string, character
    “c” by character “e”, and character “d” by character “r”. Obviously, vice versa
    is also true. In other words, these two strings are isomorphic.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在 *图 1.8* 中所看到的，第一个字符串中的字符 “a” 可以被第二个字符串中的字符 “q” 替换。此外，第一个字符串中的字符 “b” 可以被第二个字符串中的字符
    “w” 替换，字符 “c” 被 “e” 替换，字符 “d” 被 “r” 替换。显然，反之亦然。换句话说，这两个字符串是同构的。
- en: How about the strings “aab” and “que”? These two strings are not isomorphic
    because “a” cannot be mapped to both “q” and “u”.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 关于字符串 “aab” 和 “que”，这两个字符串不是同构的，因为 “a” 不能同时映射到 “q” 和 “u”。
- en: 'If we extrapolate this logic to text blocks, then *Figure 1.9* is exactly what
    we need:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将此逻辑外推到文本块，那么 *图 1.9* 正是我们所需要的：
- en: '![Figure 1.8.png](img/B19665_01_09.png)'
  id: totrans-326
  prefs: []
  type: TYPE_IMG
  zh: '![Figure 1.8.png](img/B19665_01_09.png)'
- en: 'Figure 1.9: Two isomorphic text blocks'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.9：两个同构的文本块
- en: Two text blocks are isomorphic if their string lines are isomorphic in a one-to-one
    fashion. Moreover, notice that essential white spaces and **Line Terminators**
    (**LF**) should be mapped as well, while incidental leading/trailing white spaces
    are ignored.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个文本块的字符串行以一对一的方式同构，则两个文本块是同构的。此外，请注意，必要的空白和 **换行符**（**LF**）也应进行映射，而偶然的起始/结束空白被忽略。
- en: 'The algorithm for ordinary string literals and text blocks is exactly the same,
    and it relies on *hashing* (more details about this topic are available in *Example
    6*: *Hash table* in the *The Complete Coding Interview Guide in Java* book) and
    consists of the following steps:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 普通字符串字面量和文本块的算法完全相同，并且它依赖于 *哈希*（关于此主题的更多详细信息可在 *Java 完整编码面试指南* 书中的 *示例 6*：*哈希表*
    找到）并包括以下步骤：
- en: Check if the two text blocks (`s1` and `s2`) have the same length. If their
    lengths differ, then the text blocks are not isomorphic.
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查两个文本块 (`s1` 和 `s2`) 的长度是否相同。如果它们的长度不同，则文本块不是同构的。
- en: Create an empty map that will store mappings of the characters from `s1` (as
    keys) to those of `s2` (as values).
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个空映射，该映射将存储从 `s1`（作为键）到 `s2`（作为值）的字符映射。
- en: Pick up the first/next character from `s1` (`chs1`) and `s2` (`chs2`).
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `s1` (`chs1`) 和 `s2` (`chs2`) 中取出第一个/下一个字符。
- en: Check if `chs1` is present as a key in the map.
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查 `chs1` 是否作为键存在于映射中。
- en: If `chs1` is present in the map as a key, then it has to be mapped to a value
    from `s2` that is equal to `chs2`; otherwise, the text blocks are not isomorphic.
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 `chs1` 作为键存在于映射中，那么它必须映射到 `s2` 中的一个等于 `chs2` 的值；否则，文本块不是同构的。
- en: If `chs1` is not present in the map as a key, then the map shouldn’t contain
    `chs2` as a value; otherwise, the text blocks are not isomorphic.
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 `chs1` 不作为键存在于映射中，那么映射不应该包含 `chs2` 作为值；否则，文本块不是同构的。
- en: If `chs1` is not present in the map as a key and the map doesn’t contain `chs2`
    as a value, then put (`chs1` and `chs2`) in the map – `chs1` as a key and `chs2`
    as a value.
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 `chs1` 不作为键存在于映射中，并且映射不包含 `chs2` 作为值，那么在映射中放入 (`chs1` 和 `chs2`) – `chs1`
    作为键和 `chs2` 作为值。
- en: Repeat step 3 until the entire text block (`s1`) is processed.
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复步骤 3，直到整个文本块（`s1`）被处理。
- en: If the entire text block (`s1`) was processed, then the text blocks are isomorphic.
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果整个文本块（`s1`）已被处理，那么文本块是同构的。
- en: 'In code lines, this O(n) algorithm can be expressed as follows:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码行中，这个 O(n) 算法可以表示如下：
- en: '[PRE74]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Done! You can practice this example in the bundled code. This was the last problem
    covering text block topics. It is time to move on and discuss string concatenation.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 完成！你可以在捆绑的代码中练习这个例子。这是关于文本块主题的最后一个问题。现在是时候继续前进，讨论字符串连接了。
- en: 13\. Concatenating strings versus StringBuilder
  id: totrans-342
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 13. 字符串连接与 StringBuilder
- en: 'Check out the following plain string concatenation:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下普通字符串连接：
- en: '[PRE75]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: We know that the `String` class is immutable (a created `String` cannot be modified).
    This means that creating `str12` requires an intermediary string that represents
    the concatenation of `str1` with white space. So after `str12` is created, we
    know that `str1 + " "` is just noise or garbage, since we cannot refer to it further.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道 `String` 类是不可变的（创建的 `String` 不能被修改）。这意味着创建 `str12` 需要一个中间字符串，它代表 `str1`
    与空格的连接。因此，在 `str12` 创建后，我们知道 `str1 + " "` 只是噪音或垃圾，因为我们无法进一步引用它。
- en: In such scenarios, the recommendation is to use a `StringBuilder`, since it
    is a mutable class and we can append strings to it. So this is how the following
    statement was born:In Java, don’t use the “`+`" operator to concatenate strings!
    Use `StringBuilder`, which is much faster.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，建议使用 `StringBuilder`，因为它是一个可变类，我们可以向其中追加字符串。所以这就是以下说法的由来：在 Java 中，不要使用
    “`+`” 运算符来连接字符串！使用 `StringBuilder`，它要快得多。
- en: Have you heard this statement before? I’m pretty sure you have, especially if
    you still run your applications on JDK 8 or even on a previous release. Well,
    this statement is not a myth, and it was true for sure at some moment in time,
    but is it still valid in the era of smart compilers?
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 你以前听说过这个说法吗？我非常确信你听说过，尤其是如果你仍然在 JDK 8 或更早的版本上运行你的应用程序。好吧，这个说法不是神话，在某个时刻确实是真的，但在智能编译器的时代它仍然有效吗？
- en: 'For instance, consider the following two snippets of code that represent a
    simple concatenation of strings:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑以下两个代码片段，它们代表字符串的简单连接：
- en: '![Figure 1.10.png](img/B19665_01_10.png)'
  id: totrans-349
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.10.png](img/B19665_01_10.png)'
- en: 'Figure 1.10: String concatenation vs. StringBuilder'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.10：字符串连接与 StringBuilder
- en: In JDK 8, which approach (from *Figure 1.10*) is better?
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JDK 8 中，哪种方法（来自 *图 1.10*）更好？
- en: JDK 8
  id: totrans-352
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JDK 8
- en: 'Let’s inspect the bytecode produced by these two snippets of code (use `javap
    -c -p` or Apache Commons **Byte Code Engineering Library** (**BCEL**); we have
    used the BCEL). The `concatViaPlus()` bytecode looks as follows:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查这两个代码片段生成的字节码（使用 `javap -c -p` 或 Apache Commons **字节码工程库**（**BCEL**）；我们使用了
    BCEL）。`concatViaPlus()` 的字节码如下：
- en: '![Figure 1.11.png](img/B19665_01_11.png)'
  id: totrans-354
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.11.png](img/B19665_01_11.png)'
- en: 'Figure 1.11: JDK 8 bytecode of concatViaPlus()'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.11：concatViaPlus() 的 JDK 8 字节码
- en: The JDK 8 compiler is smart enough to use a `StringBuilder` under the hood to
    shape our concatenation via the “`+`" operator. If you check the bytecode (skipped
    here for brevity) generated from `concatViaStringBuilder()`, then you’ll see something
    more or less similar to *Figure 1.11*.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: JDK 8 编译器足够智能，可以在底层使用 `StringBuilder` 来通过 “`+`” 运算符来塑造我们的连接。如果你检查从 `concatViaStringBuilder()`
    生成的字节码（这里为了简洁省略），那么你会看到与 *图 1.11* 大致相似的内容。
- en: 'In JDK 8, the compiler knows when and how to optimize the bytecode via `StringBuilder`.
    In other words, the explicit usage of `StringBuilder` doesn’t come with a significant
    benefit over plain concatenation via the “`+`" operator. There are many simple
    cases where this statement applies. What does a benchmark have to say about this?
    Check out the results:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 在JDK 8中，编译器知道何时以及如何通过`StringBuilder`优化字节码。换句话说，与通过“`+`"运算符进行普通连接相比，显式使用`StringBuilder`并没有带来显著的好处。有许多简单的情况都适用这个说法。基准测试对此有何看法？查看结果：
- en: '![Figure 1.12.png](img/B19665_01_12.png)'
  id: totrans-358
  prefs: []
  type: TYPE_IMG
  zh: '![图1.12.png](img/B19665_01_12.png)'
- en: 'Figure 1.12: JDK 8 benchmark concatViaPlus() versus concatViaStringBuilder()'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.12：JDK 8基准测试`concatViaPlus()`与`concatViaStringBuilder()`
- en: Obviously, concatenation via the “`+`" operator has won this game. Let’s repeat
    this logic for JDK 11.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，通过“`+`"运算符进行的连接赢得了这场比赛。让我们为JDK 11重复这个逻辑。
- en: JDK 11
  id: totrans-361
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JDK 11
- en: 'JDK 11 produces the following bytecode for `concatViaPlus()`:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: JDK 11为`concatViaPlus()`方法生成了以下字节码：
- en: '![Figure 1.13.png](img/B19665_01_13.png)'
  id: totrans-363
  prefs: []
  type: TYPE_IMG
  zh: '![图1.13.png](img/B19665_01_13.png)'
- en: 'Figure 1.13: JDK 11 bytecode of concatViaPlus()'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.13：JDK 11的`concatViaPlus()`字节码
- en: We can immediately observe a big difference here. This time, the concatenation
    is accomplished via a call to `invokedynamic` (this is a dynamic call), which
    acts as a delegator for our code. Here, it delegates the code to `makeConcatWithConstants()`,
    which is a method of the `StringConcatFactory` class. While you can find this
    in the JDK documentation, pay attention that this class API was not created to
    be called directly. This class was specially created and designed to serve bootstrap
    methods for `invokedynamic` instructions. Before going further, let’s look at
    an important note that you should consider.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以立即观察到这里有一个很大的不同。这次，连接是通过调用`invokedynamic`（这是一个动态调用）来完成的，它充当我们代码的代理人。在这里，它将代码委托给`makeConcatWithConstants()`，这是`StringConcatFactory`类的一个方法。虽然你可以在JDK文档中找到这个方法，请注意，这个类API并不是为了直接调用而创建的。这个类是专门创建和设计的，用于为`invokedynamic`指令提供引导方法。在继续之前，让我们看看你应该考虑的一个重要提示。
- en: '**Important note**'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '**重要提示**'
- en: The `invokedynamic` delegates/passes our concatenation code to be solved by
    code that is not part of the bytecode (this is why we cannot see the actual code
    (instructions) that solve our code). This is extremely powerful because it allows
    the Java engineers to continue the optimization process of the concatenation logic,
    while we can take advantage of it by simply moving to the next JDK. The code doesn’t
    even need to be recompiled to take advantage of further optimizations.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '`invokedynamic`将我们的连接代码委托/传递给不包含在字节码中的代码来解决（这就是为什么我们看不到解决我们代码的实际代码（指令））。这非常强大，因为它允许Java工程师继续优化连接逻辑的过程，同时我们可以通过简单地升级到下一个JDK来利用它。代码甚至不需要重新编译就可以利用进一步的优化。'
- en: '**Fun fact**: The *indify* term comes from `invokedynamic`, also known as *indy*.
    It was introduced in JDK 7 and is used in JDK 8 lambda implementations. Since
    this instruction was quite useful, it becomes a solution for many other things,
    including JEP 280: *Indify String Concatenation*, introduced in JDK 9\. I preferred
    to use it here with JDK 11, but this feature is available starting with JDK 9+,
    so you can give it a try in JDK 17 or 20, for example.'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '**有趣的事实**：*indify*这个术语来自`invokedynamic`，也称为*indy*。它在JDK 7中引入，并用于JDK 8 lambda实现。由于这个指令非常有用，它成为了解决许多其他问题的解决方案，包括在JDK
    9中引入的JEP 280：*Indify String Concatenation*。我更喜欢在这里使用JDK 11，但这个特性从JDK 9+开始可用，所以你可以在JDK
    17或20等版本中尝试一下。'
- en: 'In a nutshell, `invokedynamic` works like this:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，`invokedynamic`的工作方式如下：
- en: The compiler appends an `invokedynamic` call at the point of concatenation.
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译器在连接点附加了一个`invokedynamic`调用。
- en: The `invokedynamic` call first executes the bootstrap method `makeConcat`[`WithConstants`].
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`invokedynamic`调用首先执行引导方法`makeConcat`[`WithConstants`].'
- en: The `invokedynamic` method calls `makeConcat`[`WithConstants`], which is a bootstrap
    method meant to call the actual code responsible for concatenation.
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`invokedynamic`方法调用`makeConcat`[`WithConstants`]，这是一个用于调用实际负责连接的代码的引导方法。'
- en: The `makeConcat`[`WithConstants`] uses an internal strategy to determine the
    best method of solving the concatenation.
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`makeConcat`[`WithConstants`]使用内部策略来确定解决连接的最佳方法。'
- en: The method that fits the best is called, and the concatenation logic takes place.
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用最合适的方法，然后执行连接逻辑。
- en: This way, JEP 280 adds great flexibility, since JDK 10, 11, 12, 13, and so on
    can use different strategies and methods to accommodate string concatenation in
    the best possible way for our context.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，JEP 280 为 JDK 10、11、12、13 等版本提供了极大的灵活性，因为它们可以使用不同的策略和方法来适应我们上下文中字符串连接的最佳方式。
- en: 'How about the bytecode of `concatViaStringBuilder()`? This method doesn’t take
    advantage of `invokeddynamic` (it relies on the classic `invokevirtual` instruction),
    as you can see here:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 那么 `concatViaStringBuilder()` 的字节码是什么样的呢？这个方法没有利用 `invokedynamic`（它依赖于经典的 `invokevirtual`
    指令），正如您在这里可以看到的：
- en: '![Figure 1.14.png](img/B19665_01_14.png)'
  id: totrans-377
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.14.png](img/B19665_01_14.png)'
- en: 'Figure 1.14: JDK 11 bytecode of concatViaStringBuilder()'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.14：JDK 11 concatViaStringBuilder() 的字节码
- en: 'I’m sure that you’re curious about which bytecode performs better, so here
    are the results:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 我相信您一定很好奇哪种字节码的性能更好，所以这里有一些结果：
- en: '![Figure 1.15.png](img/B19665_01_15.png)'
  id: totrans-380
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.15.png](img/B19665_01_15.png)'
- en: 'Figure 1.15: JDK 11, benchmark concatViaPlus() versus concatViaStringBuilder()'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.15：JDK 11，concatViaPlus() 与 concatViaStringBuilder() 的基准比较
- en: The results of these benchmarks were obtained on an Intel^® Core^™ i7-3612QM
    CPU @ 2.10GHz machine with Windows 10, but feel free to test it on different machines
    and different JDK versions, since the results are highly dependent on the machine.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 这些基准测试的结果是在一台装有 Windows 10 的 Intel^® Core^™ i7-3612QM CPU @ 2.10GHz 的机器上获得的，但您也可以在不同的机器和不同的
    JDK 版本上测试它，因为结果高度依赖于机器。
- en: Again, the `concatViaPlus()` wins this game. In the bundled code, you can find
    the complete code for this example. Moreover, you’ll find the code for inspecting
    bytecode and benchmarking the concatenation in a loop via the “`+`" operator and
    `StringBuilder`. Give it a spin!
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，`concatViaPlus()` 在这场游戏中获胜。在附带代码中，您可以找到这个示例的完整代码。此外，您还可以找到检查字节码以及通过“`+`”运算符和
    `StringBuilder` 在循环中进行字符串连接基准测试的代码。试试看吧！
- en: 14\. Converting int to String
  id: totrans-384
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 14. 将 int 转换为 String
- en: 'As usual, in Java, we can accomplish a task in multiple ways. For instance,
    we can convert an `int` (primitive integer) to `String` via `Integer.toString()`,
    as follows:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 如同往常，在 Java 中，我们可以用多种方式完成一个任务。例如，我们可以通过 `Integer.toString()` 将 `int`（原始整数）转换为
    `String`，如下所示：
- en: '[PRE76]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Alternatively, you can accomplish this task via a quite common hack (the code
    reviewer will raise his eyebrow here), consisting of concatenating an empty string
    with the integer:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您也可以通过一种相当常见的技巧（代码审查员会在这里皱眉）来完成这个任务，即通过将空字符串与整数连接起来：
- en: '[PRE77]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '`String.valueOf()` can also be used as follows:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: '`String.valueOf()` 也可以如下使用：'
- en: '[PRE78]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'A more esoteric approach via `String.format()` is as follows:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 `String.format()` 的更高级方法如下：
- en: '[PRE79]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'These methods also work for a boxed integer and, therefore, for an `Integer`
    object. Since boxing and unboxing are costly operations, we strive to avoid them
    unless they are really necessary. However, you never know when an unboxing operation
    may sneak “behind the scenes” and ruin the performance of your application. To
    verify this statement, imagine that, for each of the previous methods, we also
    have its equal getting an `Integer` instead of an `int`. Here is one of them (the
    rest were skipped for brevity):'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法也适用于装箱整数和 `Integer` 对象。由于装箱和拆箱是昂贵的操作，我们努力避免它们，除非它们真的有必要。然而，您永远不知道拆箱操作何时会“幕后”偷偷进行并破坏您应用程序的性能。为了验证这个说法，想象一下，对于前面提到的每种方法，我们也有一个使用
    `Integer` 而不是 `int` 的等效方法。这里有一个（为了简洁起见，其他方法被省略了）：
- en: '[PRE80]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Benchmarking all these methods results in the following figure:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 对所有这些方法的基准测试结果如下：
- en: '![Figure 1.16.png](img/B19665_01_16.png)'
  id: totrans-396
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.16.png](img/B19665_01_16.png)'
- en: 'Figure 1.16: The results of benchmarking int to String conversion'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.16：基准测试 int 转换为 String 的结果
- en: 'There are two crystal-clear conclusions that we can derive from here:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里我们可以得出两个非常明确的结论：
- en: Using `String.format()` is very slow, and it should be avoided for `int` and
    `Integer`.
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `String.format()` 非常慢，对于 `int` 和 `Integer` 应该避免使用。
- en: All solutions that use an `Integer` are slower than those using an `int` primitive.
    So avoid unnecessary unboxing, even for such simple cases, since they may cause
    serious performance penalties.
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有使用 `Integer` 的解决方案都比使用原始 `int` 的解决方案慢。因此，即使在这种情况下，也应避免不必要的拆箱，因为它们可能会引起严重的性能惩罚。
- en: The results of these benchmarks were obtained on an Intel^® Core^™ i7-3612QM
    CPU @ 2.10GHz machine with Windows 10, but feel free to test it on different machines,
    since the results are highly dependent on the machine.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 这些基准测试的结果是在一台装有 Windows 10 的 Intel^® Core^™ i7-3612QM CPU @ 2.10GHz 的机器上获得的，但您也可以在不同的机器上测试它，因为结果高度依赖于机器。
- en: Next, let’s change the topic and talk about Java locales.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们改变话题，谈谈Java区域设置。
- en: 15\. Introducing string templates
  id: totrans-403
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 15. 字符串模板的介绍
- en: 'Until JDK 21, Java allows us to perform string composition for SQL, JSON, XML,
    and so on via different approaches, covered earlier in *Problem 8*. In that problem,
    you can see how to use text blocks and embedded expressions via simple concatenation,
    using the plus (`+`) operator, `StringBuilder.append()`, `String.format()`, `formatted()`,
    and so on. While using the plus (`+`) operator and `StringBuilder.append()` can
    be cumbersome and affect readability, the `String.format()` and `formatted()`
    may cause type mismatches. For instance, in the following example, it is quite
    easy to mess up the data types (`LocalDate`, `double`, and `String`) and the format
    specifiers (`%d`, `%s`, and `%.2f`):'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 直到JDK 21，Java允许我们通过不同的方法执行SQL、JSON、XML等的字符串组合，这些方法在之前的*问题8*中已经介绍过。在那个问题中，你可以看到如何通过简单的连接使用文本块和内嵌表达式，使用加号（`+`）运算符、`StringBuilder.append()`、`String.format()`、`formatted()`等。虽然使用加号（`+`）运算符和`StringBuilder.append()`可能会很繁琐并影响可读性，但`String.format()`和`formatted()`可能会引起类型不匹配。例如，在下面的例子中，很容易搞错数据类型（`LocalDate`、`double`和`String`）和格式说明符（`%d`、`%s`和`%.2f`）：
- en: '[PRE81]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Moreover, any of these approaches doesn’t cover input validity (as we don’t
    know if the expressions are valid) and security issues (injections, which commonly
    affect SQL strings).
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，这些方法中的任何一种都不涵盖输入有效性（因为我们不知道表达式是否有效）和安全问题（注入，这通常影响SQL字符串）。
- en: Starting with JDK 21, we can address these issues via *string templates* (JEP
    430).
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 从JDK 21开始，我们可以通过 *字符串模板*（JEP 430）来解决这些问题。
- en: What’s a string template?
  id: totrans-408
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是字符串模板？
- en: 'String templates (template expressions) are a mechanism introduced as a preview
    feature in JDK 21 that can help us perform string interpolation efficiently and
    safely. This feature consists of three parts, as follows:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串模板（模板表达式）是JDK 21中引入的一个预览功能，可以帮助我们高效且安全地执行字符串插值。这个功能由以下三个部分组成：
- en: A template processor (`RAW`, `STR`, `FMT`, user-defined, and so on)
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模板处理器（`RAW`、`STR`、`FMT`、用户定义的等）
- en: A dot character
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个点字符
- en: A string template containing the embedded expression(s) as `\{expression}`
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含内嵌表达式（`\{expression}`）的字符串模板
- en: '`RAW`, `STR`, and `FMT` are the three *template processors* provided by JDK
    21, but as you’ll see, we can write our own template processors as well.'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: '`RAW`、`STR`和`FMT`是JDK 21提供的三个 *模板处理器*，但正如你将看到的，我们也可以编写自己的模板处理器。'
- en: A *template processor* takes a string literal and the proper expressions, and
    it is capable of validating and interpolating it in a final result, which can
    be a string or other domain-specific object (for instance, a JSON object). If
    the template processor cannot successfully create the result, then an exception
    may be thrown.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 *模板处理器* 接收一个字符串字面量和适当的表达式，并且能够验证和插入它到一个最终结果中，这个结果可以是一个字符串或其他特定领域的对象（例如，一个JSON对象）。如果模板处理器无法成功创建结果，则可能会抛出异常。
- en: The STR template processor
  id: totrans-415
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: STR模板处理器
- en: 'The `STR` template processor is available as a `static` field in `java.lang.StringTemplate`.
    Its goal is to serve simple string concatenation tasks. For instance, we can rewrite
    the previous example using `STR`, as follows:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: '`STR`模板处理器作为`java.lang.StringTemplate`中的`static`字段提供。它的目标是服务于简单的字符串连接任务。例如，我们可以使用`STR`重写之前的例子，如下所示：'
- en: '[PRE82]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Here, we have three embedded expressions (`\{fiscalDate.getYear()}`, `\{employeeCode}`,
    and `\{value}`) that `STR` will process in order to obtain the final string:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有三个内嵌表达式（`\{fiscalDate.getYear()}`、`\{employeeCode}`和`\{value}`），`STR`将按顺序处理这些表达式以获得最终的字符串：
- en: '[PRE83]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: As you can see, the `STR` processor has replaced every embedded expression with
    the string value of that expression. The returned result is a `String`, and we
    can use any number of embedded expressions. If the expression is large, then you
    can split it in your IDE across multiple lines without introducing new lines in
    the final result.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`STR`处理器已经将每个内嵌表达式替换为该表达式的字符串值。返回的结果是一个`String`，我们可以使用任意数量的内嵌表达式。如果表达式很大，那么你可以在你的IDE中将其拆分成多行，而不会在最终结果中引入新行。
- en: The FMT template processor
  id: totrans-421
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: FMT模板处理器
- en: 'In the previous example, we have the `\{value}` embedded expression, which
    is evaluated by `STR` to 4552.2367\. This is correct, but we may like to format
    this value with two decimals, as 4552.24\. In such cases, we need the `FMT` processor,
    which is available as a `static` field in `java.util.FormatProcessor` and is capable
    of interpreting the format specifiers present in embedded expressions (`STR` cannot
    do that). So using `FMT` to rewrite our example can be done as follows:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们有 `\{value}` 嵌入表达式，它被 `STR` 评估为 4552.2367。这是正确的，但我们可能希望将此值格式化为两位小数，即
    4552.24。在这种情况下，我们需要 `FMT` 处理器，它作为 `java.util.FormatProcessor` 中的 `static` 字段可用，并且能够解释嵌入表达式中的格式说明符（`STR`
    不能这样做）。因此，使用 `FMT` 重写我们的示例可以这样做：
- en: '[PRE84]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Notice how the format specifier was added to the embedded expression `(%.2f\{value}`)
    before the backslash character. This will result in the following string:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 注意格式说明符是如何在反斜杠字符之前添加到嵌入表达式 `(%.2f{value}`) 中的。这将导致以下字符串：
- en: '[PRE85]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: In the same manner, you can use any other format specifier. `FMT` will take
    each of them into account in order to return the expected result.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 以同样的方式，你可以使用任何其他格式说明符。`FMT` 将考虑它们以返回预期的结果。
- en: The RAW template processor
  id: totrans-427
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RAW 模板处理器
- en: 'The `RAW` template processor is available as a `static` field of `java.lang.StringTemplate`.
    Calling `RAW` will return a `StringTemplate` instance that can be used later.
    For instance, here is a `StringTemplate` that we have extracted separately using
    `RAW`:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: '`RAW` 模板处理器作为 `java.lang.StringTemplate` 的 `static` 字段可用。调用 `RAW` 将返回一个 `StringTemplate`
    实例，稍后可以使用。例如，这里是一个我们使用 `RAW` 分别提取的 `StringTemplate`：'
- en: '[PRE86]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Next, we can use `templateRaw` repeatedly, as in the following example:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以重复使用 `templateRaw`，如下例所示：
- en: '[PRE87]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'The `\{templateRaw.interpolate()}` expression calls the `interpolate()` method,
    which is responsible for processing the string defined in `templateRaw`. It is
    like calling `interpolate()`, as follows:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: '`\{templateRaw.interpolate()}` 表达式调用 `interpolate()` 方法，该方法负责处理 `templateRaw`
    中定义的字符串。它就像调用 `interpolate()` 一样，如下所示：'
- en: '[PRE88]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'The final result is the following string:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 最终结果是以下字符串：
- en: '[PRE89]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: The employee code is evaluated to an RN4555 string.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 员工代码被评估为 RN4555 字符串。
- en: 'The character sequences that precede an embedded expression and the character
    sequence following the last embedded expression are known as *fragments*. If the
    string template begins with an embedded expression, then its fragment is zero-length.
    The same is true for directly adjacent embedded expressions. For instance, the
    fragments of `templateRaw` (`"employee_nr": "\{employeeCode}",`) are `"employee_nr":
    "` and `",`. We have access to these fragments as a `List<String>` via the `fragments()`
    method.'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: '在嵌入表达式之前和最后一个嵌入表达式之后的字符序列被称为 *片段*。如果字符串模板以嵌入表达式开始，则其片段为零长度。同样，直接相邻的嵌入表达式也是如此。例如，`templateRaw`
    的片段（`"employee_nr": "{employeeCode}",`）是 `"employee_nr": "` 和 `","`。我们通过 `fragments()`
    方法可以访问这些片段作为 `List<String>`。'
- en: '[PRE90]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Moreover, getting the results of the embedded expressions as a `List<Object>`
    can be done via the `values()` methods, as follows:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，通过 `values()` 方法获取嵌入表达式的结果作为 `List<Object>` 可以这样做：
- en: '[PRE91]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: For `templateRaw`, this list will contain a single entry, RN4555.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `templateRaw`，此列表将包含单个条目，RN4555。
- en: In the bundled code, you can find more examples, including using `STR`, `FMT`,
    and `RAW` with simple strings (not text blocks).
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 在捆绑的代码中，你可以找到更多示例，包括使用 `STR`、`FMT` 和 `RAW` 与简单字符串（不是文本块）一起使用。
- en: 16\. Writing a custom template processor
  id: totrans-443
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 16. 编写自定义模板处理器
- en: 'The built-in `STR` and `FMT` can return only `String` instances and cannot
    throw exceptions. However, both of them are actually instances of the functional
    interface `StringTemplate.Processor<R,E extends Throwable>`, which defines the
    `process()` method:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 内置的 `STR` 和 `FMT` 只能返回 `String` 实例，并且不能抛出异常。然而，它们实际上是功能接口 `StringTemplate.Processor<R,E
    extends Throwable>` 的实例，该接口定义了 `process()` 方法：
- en: '[PRE92]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: By implementing the `Processor<R,E extends Throwable>` interface, we can write
    custom template processors that return `R` (any result type), not just `String`.
    Moreover, if something goes wrong during processing (for instance, validation
    issues are present), we can throw checked exceptions (`E extends Throwable`).
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 通过实现 `Processor<R,E extends Throwable>` 接口，我们可以编写自定义模板处理器，返回 `R`（任何结果类型），而不仅仅是
    `String`。此外，如果在处理过程中出现问题（例如，存在验证问题），我们可以抛出检查异常（`E extends Throwable`）。
- en: 'For instance, let’s assume that we need to interpolate strings with expressions
    representing phone numbers. So we accept only the expressions that are phone numbers,
    matching the following regular expression:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们需要将表示电话号码的表达式进行字符串插值。因此，我们只接受匹配以下正则表达式的电话号码表达式：
- en: '[PRE93]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'In this case, the result is a `String`, so our custom template processor can
    be written as follows:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，结果是`String`，因此我们的自定义模板处理器可以编写如下：
- en: '[PRE94]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Now, we can test our processor with a simple message, as follows (here, we
    use valid phone numbers):'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用以下简单消息测试我们的处理器（这里使用有效的电话号码）：
- en: '[PRE95]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'The resulting string is as follows:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的字符串如下：
- en: '[PRE96]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'As you can see, our processor relies on a `StringBuilder` to obtain the final
    string. However, we can use the `StringTemplate.interpolate(List<String> fragments,
    List<?> values)` method as well and obtain a cleaner solution, as follows:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们的处理器依赖于`StringBuilder`来获取最终的字符串。然而，我们也可以使用`StringTemplate.interpolate(List<String>
    fragments, List<?> values)`方法，并获得一个更简洁的解决方案，如下所示：
- en: '[PRE97]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'However, as we said earlier, a template processor can return any type (`R`).
    For instance, let’s assume that we shaped our previous message as a JSON string,
    as follows:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，正如我们之前所说的，模板处理器可以返回任何类型（`R`）。例如，假设我们将之前的消息格式化为JSON字符串，如下所示：
- en: '[PRE98]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'This time, we want to interpolate strings with variables representing phone
    numbers and return a JSON object. More precisely, we want to return an instance
    of `com.fasterxml.jackson.databind.JsonNode` (here, we use the Jackson library,
    but it can be GSON, JSON-B, and so on):'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们想要使用表示电话号码的变量进行字符串插值，并返回一个JSON对象。更确切地说，我们想要返回`com.fasterxml.jackson.databind.JsonNode`的实例（在这里，我们使用Jackson库，但也可以是GSON、JSON-B等）：
- en: '[PRE99]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'This time, the returned type is `JsonNode`:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，返回的类型是`JsonNode`：
- en: '[PRE100]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: In the bundled code, you can also find an example that uses a lambda expression
    for writing the previous custom template processor. Moreover, you can find an
    example in which instead of throwing an exception for invalid expressions we just
    replace the invalid values with a default value.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 在捆绑的代码中，您还可以找到一个使用lambda表达式编写之前自定义模板处理器的示例。此外，您还可以找到一个示例，其中对于无效的表达式，我们只是用默认值替换它们，而不是抛出异常。
- en: 'Please note, a recent article *Update on String Templates (JEP 459)*, which
    you can find at: [https://mail.openjdk.org/pipermail/amber-spec-experts/2024-March/004010.html](https://mail.openjdk.org/pipermail/amber-spec-experts/2024-March/004010.html),
    suggests that processors, used in this way, will ultimately be replaced with simpler
    method calls.'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，最近的一篇文章《字符串模板更新（JEP 459）》，您可以在以下链接找到：[https://mail.openjdk.org/pipermail/amber-spec-experts/2024-March/004010.html](https://mail.openjdk.org/pipermail/amber-spec-experts/2024-March/004010.html)，指出使用这种方式，处理器最终将被更简单的方法调用所取代。
- en: 17\. Creating a Locale
  id: totrans-465
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 17. 创建一个区域设置
- en: A Java `Locale` (`java.util.Locale`) represents an object that wraps information
    about a specific geographical, political, or cultural region – that is, an object
    useful for internationalization purposes. A `Locale` is typically used in conjunction
    with `DateFormat`/`DateTimeFormatter` to represent date-time in a format specific
    to a country, with `NumberFormat` (or its subclass, `DecimalFormat`) used to represent
    numbers in a format specific to a country (for instance, to represent an amount
    of money in a specific currency), or with `MessageFormat` to create formatted
    messages for a specific country.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: Java的`Locale`（`java.util.Locale`）代表一个封装有关特定地理、政治或文化区域信息的对象——即用于国际化的对象。`Locale`通常与`DateFormat`/`DateTimeFormatter`一起使用，以特定于国家的格式表示日期时间，使用`NumberFormat`（或其子类`DecimalFormat`）以特定于国家的格式表示数字（例如，表示特定货币的金额），或使用`MessageFormat`为特定国家创建格式化消息。
- en: 'For the most popular locales, Java provides a list of constants (for instance,
    `Locale.GERMANY`, `Locale.CANADA`, and so on). For locales that are not on this
    list, we have to use the formats defined in several RFCs. Most commonly, we use
    the *language* pattern (for instance, `ro` for Romanian) or the *language_country*
    pattern (for instance, `ro_RO` for Romania, `en_US` for United States, and so
    on). Sometimes, we may need the *language_country _variant* pattern, where *variant*
    is useful to map additional functionalities added by software vendors, such as
    browsers or operating systems (for instance, `de_DE_WIN` is a locale for German
    speakers in Germany, for Windows). However, two locales are treated as non-conforming:
    `ja_JP_JP` (which represents Japanese, as used in Japan) and `th_TH_TH` (which
    represents Thai, as used in Thailand, including Thai digits).'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 对于最受欢迎的区域设置，Java提供了一系列常量（例如，`Locale.GERMANY`、`Locale.CANADA`等）。对于不在该列表上的区域设置，我们必须使用在几个RFC中定义的格式。最常见的是使用*语言*模式（例如，`ro`代表罗马尼亚）或*语言_国家*模式（例如，`ro_RO`代表罗马尼亚，`en_US`代表美国，等等）。有时，我们可能需要*语言_国家_变体*模式，其中*变体*有助于映射软件供应商添加的附加功能，例如浏览器或操作系统（例如，`de_DE_WIN`是德国德语使用者的区域设置，针对Windows）。然而，有两个区域设置被视为非规范：`ja_JP_JP`（代表在日本使用的日语）和`th_TH_TH`（代表在泰国使用的泰语，包括泰语数字）。
- en: 'While you can learn more about `Locale` from its comprehensive documentation,
    let’s mention that, before JDK 19, we can create a `Locale` via one of its three
    constructors – most commonly, via `Locale(String language, String country)`, as
    follows:'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可以从其全面的文档中了解更多关于`Locale`的信息，但让我们提一下，在JDK 19之前，我们可以通过其三个构造函数之一创建一个`Locale`——最常见的是通过`Locale(String
    language, String country)`，如下所示：
- en: '[PRE101]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Of course, if your `Locale` has already a defined constant, you can simply
    embed that constant where you need it in code or simply declare a `Locale`, as
    follows (here, for Germany):'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果你的`Locale`已经定义了一个常量，你可以在代码中直接嵌入该常量，或者简单地声明一个`Locale`，如下所示（这里以德国为例）：
- en: '[PRE102]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'Another approach relies on `Locale.Builder` via a chain of setters:'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是通过`Locale.Builder`的setter链：
- en: '[PRE103]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Alternatively, this can be done via `Locale.forLanguageTag()` to follow the
    IETF BCP 47 standard language tags (which can be useful to represent complex tags
    such as China-specific Chinese, Mandarin, Simplified script, and “`zh-cmn-Hans-CN`"):'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，这也可以通过`Locale.forLanguageTag()`来完成，以遵循IETF BCP 47标准语言标签（这可以用来表示复杂标签，如特定于中国的中文、普通话、简体字和“`zh-cmn-Hans-CN`”）：
- en: '[PRE104]'
  id: totrans-475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'Moreover, Java supports *language ranges*. This means that we can define a
    set of language tags that share some specific attributes. For instance, “`de-*`"
    represents a language range to recognize German in any region:'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Java支持*语言范围*。这意味着我们可以定义一组具有某些特定属性的标签。例如，“`de-*`"代表一个识别任何地区的德语的语言范围：
- en: '[PRE105]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'The previous `Locale.LanguageRange()` constructor takes two arguments: the
    language range and its weight (1.0, 0.5, 0.0). Typically, this weight reveals
    the user’s preference (1.0 at the highest and 0.0 at the lowest). The weight is
    useful for defining *priority lists* as follows (we prefer Castilian Spanish (Spain)
    over Mexican Spanish and over Brazilian Portuguese):'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的`Locale.LanguageRange()`构造函数接受两个参数：语言范围及其权重（1.0、0.5、0.0）。通常，这个权重揭示了用户的偏好（最高为1.0，最低为0.0）。权重对于定义*优先级列表*很有用，如下所示（我们更喜欢西班牙的卡斯蒂利亚语（西班牙）而不是墨西哥的西班牙语和巴西的葡萄牙语）：
- en: '[PRE106]'
  id: totrans-479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: Pay attention to defining a valid string of preferences so the `parse()` method
    can work.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 注意定义一个有效的偏好字符串，以便`parse()`方法可以工作。
- en: 'Starting with JDK 19, the three constructors of `Locale` have been deprecated,
    and we can rely on three static `of()` methods instead. The equivalent of the
    previous code via the proper `of()` method is:'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 从JDK 19开始，`Locale`的三个构造函数已被弃用，我们可以依赖三个静态的`of()`方法。通过适当的`of()`方法，之前的代码等价于：
- en: '[PRE107]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'Here are two more examples:'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还有两个示例：
- en: '[PRE108]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'Using a `Locale` is straightforward. Here is an example of using the previous
    `ro` to format date-time via `DateFormat` for Romania and Italy:'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Locale`非常简单。以下是一个使用之前的`ro`通过`DateFormat`格式化罗马尼亚和意大利日期时间的示例：
- en: '[PRE109]'
  id: totrans-486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: In the next problem, we continue the locale journey.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个问题中，我们继续区域设置的旅程。
- en: 18\. Customizing localized date-time formats
  id: totrans-488
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 18. 自定义本地化日期时间格式
- en: Starting with JDK 8, we have a comprehensive date-time API containing classes
    such as `LocalDate`, `LocalTime`, `LocalDateTime`, `ZonedDateTime`, `OffsetDateTime`,
    and `OffsetTime`.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 从JDK 8开始，我们有一个包含`LocalDate`、`LocalTime`、`LocalDateTime`、`ZonedDateTime`、`OffsetDateTime`和`OffsetTime`等类的综合日期时间API。
- en: 'We can easily format the date-time output returned by these classes via `DateTimeFormatter.ofPattern()`.
    For instance, here, we format a `LocalDateTime` via the `y-MM-dd HH:mm:ss` pattern:'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过 `DateTimeFormatter.ofPattern()` 简单地格式化这些类返回的日期时间输出。例如，这里，我们通过 `y-MM-dd
    HH:mm:ss` 模式格式化一个 `LocalDateTime`：
- en: '[PRE110]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: More examples are available in the bundled code.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 更多示例可以在捆绑的代码中找到。
- en: How about customizing our format based on a given locale – for instance, Germany?
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，根据给定的区域设置自定义我们的格式如何——比如，德国？
- en: '[PRE111]'
  id: totrans-494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'We accomplish this via `ofLocalizedDate()`,`ofLocalizedTime()`, and `ofLocalizedDateTime()`,
    as in the following examples:'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过 `ofLocalizedDate()`, `ofLocalizedTime()`, 和 `ofLocalizedDateTime()` 来完成这个任务，如下面的例子所示：
- en: '[PRE112]'
  id: totrans-496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'We may also use:'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用：
- en: '[PRE113]'
  id: totrans-498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'A localized date, time, or date-time formatter supports four format styles:'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 本地化日期、时间或日期时间格式化程序支持四种格式样式：
- en: '`FULL`: Format using all details.'
  id: totrans-500
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FULL`: 使用所有细节的格式。'
- en: '`LONG`: Format using lots of detail but not all.'
  id: totrans-501
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LONG`: 使用很多细节但不是全部的格式。'
- en: '`MEDIUM`: Format with some detail.'
  id: totrans-502
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MEDIUM`: 使用一些细节的格式。'
- en: '`SHORT`: Format as short as possible (typically numeric).'
  id: totrans-503
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SHORT`: 尽可能简短地格式化（通常是数字）。'
- en: 'Depending on the combination between the localized artifact and format style,
    the code may end up with an exception such as *DateTimeException: Unable to extract….*.
    If you see such an exception, then it is time to consult the following table,
    which provides the accepted combos:'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: '根据本地化元素和格式样式的组合，代码可能会抛出异常，例如 *DateTimeException: Unable to extract….*。如果您看到这样的异常，那么是时候查阅以下表格了，它提供了接受的组合：'
- en: '![Figure 1.17.png](img/B19665_01_17.png)'
  id: totrans-505
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.17.png](img/B19665_01_17.png)'
- en: 'Figure 1.17: Format style of a localized date, time, and date-time'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.17：本地化日期、时间和日期时间的格式样式
- en: Moreover, starting with JDK 19, we can use `ofLocalizedPattern(String pattern)`
    as well.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，从 JDK 19 开始，我们还可以使用 `ofLocalizedPattern(String pattern)`。
- en: We can pass any pattern that is shown in *Figure 1.18*.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以传递 *图 1.18* 中显示的任何模式。
- en: '![Figure 1.17.png](img/B19665_01_18.png)'
  id: totrans-509
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.17.png](img/B19665_01_18.png)'
- en: 'Figure 1.18: Building a pattern for ofLocalizedPattern(String pattern)'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.18：为 ofLocalizedPattern(String pattern) 构建模式
- en: 'This being said, let’s change the current locale to Romania:'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，让我们将当前的区域设置更改为罗马尼亚：
- en: '[PRE114]'
  id: totrans-512
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'Let’s also have some examples of `ofLocalizedPattern()`:'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再举一些 `ofLocalizedPattern()` 的例子：
- en: '[PRE115]'
  id: totrans-514
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'And even more:'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 还有更多：
- en: '[PRE116]'
  id: totrans-516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: You can practice all these examples in the bundled code. Moreover, in the bundled
    code, you can find an application that uses locales and `NumberFormat` to format
    a royalty amount for different locales (currencies).
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在捆绑的代码中练习所有这些示例。此外，在捆绑的代码中，您可以找到一个使用区域设置和 `NumberFormat` 格式化不同区域设置（货币）版税金额的应用程序。
- en: 19\. Restoring Always-Strict Floating-Point semantics
  id: totrans-518
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 19. 恢复始终严格的浮点语义
- en: 'Floating-point calculations are not easy! Even some simple arithmetical properties
    don’t apply to such calculations. For instance, floating-point addition or multiplication
    is not associative. In other words (x + y) + z is not equal to x + (y + z) where
    x, y, and z are real numbers. A quick example to test the associativity of multiplication
    follows:'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 浮点计算并不容易！即使是某些简单的算术属性也不适用于此类计算。例如，浮点加法或乘法不是结合的。换句话说，(x + y) + z 不等于 x + (y +
    z)，其中 x、y 和 z 是实数。以下是一个测试乘法结合性的快速示例：
- en: '[PRE117]'
  id: totrans-520
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: This means that floating-point arithmetic is a methodical approximation of real
    arithmetic. Computers have to approximate because of some limitations. For instance,
    exact floating-point outputs become very large quite quickly. Moreover, the exact
    inputs are not known, so with inexact inputs, it is difficult to obtain exact
    outputs.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着浮点算术是实数算术的系统近似。由于一些限制，计算机必须进行近似。例如，精确的浮点输出会非常快地变得非常大。此外，精确的输入是未知的，因此对于不精确的输入，很难获得精确的输出。
- en: To solve this problem, Java has to adopt a *rounding policy*. In other words,
    Java has to use a special kind of function capable of mapping from a real value
    to a floating-point value. These days, Java uses the so-called *round to nearest
    policy*. This policy attempts to round an inexact value to a value that is nearest
    to the *infinitely precise result*. In the case of equality (where the representable
    values are equally near to the inexact value), the value having the zero-most
    significant bit is the winner.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，Java 必须采用一种 *舍入策略*。换句话说，Java 必须使用一种能够将实数值映射到浮点值的特殊函数。如今，Java 使用所谓的
    *四舍五入到最接近的策略*。这种策略试图将一个不精确的值四舍五入到最接近的 *无限精确的结果*。在相等的情况下（可表示的值与不精确值同样接近），具有零最高有效位的值是获胜者。
- en: Moreover, floating-point calculations may produce different outputs on different
    platforms. In other words, running floating-point calculations on different chip
    architectures (for instance, 16-, 32-, or 64-bit processors) may lead to different
    results. Java solves this issue via the `strictfp` modifier. This keyword follows
    the IEEE 754 standards for floating-point calculations and was introduced in JDK
    1.2.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，浮点计算在不同平台上可能会产生不同的输出。换句话说，在不同的芯片架构（例如，16位、32位或64位处理器）上运行浮点计算可能会导致不同的结果。Java通过`strictfp`修饰符解决了这个问题。这个关键字遵循IEEE
    754浮点计算标准，并在JDK 1.2中引入。
- en: '**Important note**'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: '**重要提示**'
- en: The `strictfp` modifier represents all intermediate values in single/double-precision
    conforming to IEEE 754\. However, some hardware-specific issues caused `strictfp`
    to become optional in JDK 1.2.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: '`strictfp`修饰符表示所有中间值都符合IEEE 754的单精度/双精度。然而，一些硬件特定问题导致`strictfp`在JDK 1.2中成为可选的。'
- en: 'Let’s assume that we have to implement a scientific calculator. Obviously,
    our calculator has to provide consistent results across platforms, so we rely
    on `strictfp`, as follows:'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们需要实现一个科学计算器。显然，我们的计算器必须在各个平台上提供一致的结果，因此我们依赖于`strictfp`，如下所示：
- en: '[PRE118]'
  id: totrans-527
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: The `strictfp` modifier used with the class guarantees that all member methods
    of this class take advantage of its effect. Now, we have consistent results across
    platforms. You can find this example in the bundled code.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 与类一起使用的`strictfp`修饰符确保该类的所有成员方法都利用其效果。现在，我们在各个平台上有了一致的结果。您可以在捆绑的代码中找到这个示例。
- en: '**Important note**'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: '**重要提示**'
- en: The `strictfp` modifier can be used for classes (and is applied to nested classes
    as well), non-abstract methods, and interfaces. It cannot be used for variables,
    constructors, or abstract methods.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: '`strictfp`修饰符可用于类（以及嵌套类），非抽象方法和接口。它不能用于变量、构造函数或抽象方法。'
- en: 'When the `strictfp` modifier is used on an interface, there are some important
    points to consider, as follows:'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 当在接口上使用`strictfp`修饰符时，有一些重要的事项需要考虑，如下所述：
- en: It is not applied to the `abstract` methods declared in the interface.
  id: totrans-532
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不适用于接口中声明的`abstract`方法。
- en: It is applied to the `default` methods declared in the interface.
  id: totrans-533
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它应用于接口中声明的`default`方法。
- en: It is not applied to methods defined in classes that implement the interface.
  id: totrans-534
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不适用于实现接口的类中定义的方法。
- en: It is applied to all the methods declared in the inner classes of the interface.
  id: totrans-535
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它应用于接口内部类中声明的所有方法。
- en: 'For instance, consider the following `strictfp` interface:'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑以下`strictfp`接口：
- en: '[PRE119]'
  id: totrans-537
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'Also, there is a non-`strictfp` class that implements the previous `strictfp`
    interface:'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一个实现先前`strictfp`接口的非`strictfp`类：
- en: '[PRE120]'
  id: totrans-539
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'To find out which artifacts are `strictfp`, let’s run a little bit of Java
    reflection code that will reveal the modifiers of each method:'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 要找出哪些工件是`strictfp`，我们可以运行一小段Java反射代码，这将揭示每个方法的修饰符：
- en: '[PRE121]'
  id: totrans-541
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'Then, let’s call this method:'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，让我们称这个方法为：
- en: '[PRE122]'
  id: totrans-543
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'As you can see, the `strictfp` modifier is not present for all of our methods.
    So if we need `strictfp` on `perimeter()` and `diagonal()`, then we have to add
    it manually:'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`strictfp`修饰符并不适用于我们所有的方法。因此，如果我们需要在`perimeter()`和`diagonal()`上使用`strictfp`，那么我们必须手动添加它：
- en: '[PRE123]'
  id: totrans-545
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: However, starting with JDK 17, there is some big news in this area.
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，从JDK 17开始，这个领域有一些重大新闻。
- en: '**Important note**'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: '**重要提示**'
- en: Hardware has seriously evolved, and the issues causing `strictfp` to be optional
    in JDK 1.2 have been fixed, so the default floating-point semantics can be changed
    to consistently strict. In other words, starting with JDK 17, there is no need
    to explicitly use `strictfp`. JEP 306, *Restore Always-Strict Floating-Point Semantics*,
    provides this functionality out of the box everywhere. So starting with JDK 17,
    all floating-point operations are consistently strict.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 硬件已经严重发展，导致`strictfp`在JDK 1.2中成为可选的问题已经得到解决，因此默认的浮点语义可以更改为一致严格。换句话说，从JDK 17开始，不再需要显式使用`strictfp`。JEP
    306，*恢复始终严格的浮点语义*，提供了这种功能。因此，从JDK 17开始，所有浮点操作都是一致的严格。
- en: Besides being good news for us as developers, JEP 306 also sustains several
    Java classes, such as `java.lang.Math` and `java.lang.StrictMath`, which become
    more robust and easy to implement.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 除了对我们这些开发者来说是好消息之外，JEP 306还支持几个Java类，如`java.lang.Math`和`java.lang.StrictMath`，它们变得更加健壮且易于实现。
- en: 20\. Computing mathematical absolute value for int/long and result overflow
  id: totrans-550
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 20. 计算int/long的数学绝对值和结果溢出
- en: 'Mathematical absolute value is notated by placing the value between two pipe
    operators and is computed as follows:'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 数学绝对值通过在两个管道操作符之间放置值来表示，并按以下方式计算：
- en: '[PRE124]'
  id: totrans-552
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'It is commonly used for computing/expressing distances. For example, imagine
    that 0 represents the sea level and we have a scuba diver and a climber. The scuba
    diver is underwater at -45 ft (notice that we use negative numbers to express
    how deep in the water the scuba diver is). At the same time, the climber has climbed
    30 ft high. Which of them is closer to the sea level (0)? We may think that since
    -45 < 30, the scuba diver is closer because its value is smaller. However, we
    can easily find the correct answer by applying the mathematical absolute, as follows:'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常用于计算/表示距离。例如，想象0代表海平面，我们有一个潜水员和一名登山者。潜水员在水下-45英尺（注意，我们使用负数来表示潜水员在水中的深度）。同时，登山者已经爬升了30英尺。他们哪一个离海平面（0）更近？我们可能会认为由于-45
    < 30，潜水员更近，因为它的值更小。然而，我们可以通过应用数学绝对值轻松找到正确答案，如下所示：
- en: '[PRE125]'
  id: totrans-554
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'Now, let’s dive into the solution with the following example:'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过以下示例深入了解解决方案：
- en: '[PRE126]'
  id: totrans-556
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'This is a very simple use case of `Math.abs()`, which returns the mathematical
    absolute value of the given integer. Now, let’s apply this method to the following
    large numbers:'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`Math.abs()`的一个非常简单的用例，它返回给定整数的数学绝对值。现在，让我们将此方法应用于以下大数：
- en: '[PRE127]'
  id: totrans-558
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'This is not good! The `int` domain was overflowed because of `|Integer.MIN_VALUE|
    > |Integer.MAX_VALUE|`. The expected result is the positive value of 2,147,483,648,
    which doesn’t fit in the `int` domain. However, changing the `x` type from `int`
    to `long` will solve the problem:'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 这不好！由于`|Integer.MIN_VALUE| > |Integer.MAX_VALUE|`，`int`域溢出了。预期的结果是正的21,474,836,48，但这不适合`int`域。然而，将`x`类型从`int`改为`long`将解决问题：
- en: '[PRE128]'
  id: totrans-560
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'But the problem will reappear if, instead of `Integer.MIN_VALUE`, there is
    `Long.MIN_VALUE`:'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果问题不是由`Integer.MIN_VALUE`引起，而是由`Long.MIN_VALUE`引起，问题将再次出现：
- en: '[PRE129]'
  id: totrans-562
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'Starting with JDK 15, the `Math` class was enriched with two `absExact()` methods.
    There is one for `int` and one for `long`. These methods are very useful if the
    mathematical absolute result is prone to overflowing the `int` or `long` domain
    (for instance, the `Integer`/`Long.MIN_VALUE` values overflows the positive `int`/`long`
    range). In such cases, these methods throw `ArithmeticException` instead of returning
    a misleading result, as in the following example:'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 从JDK 15开始，`Math`类增加了两个`absExact()`方法。一个用于`int`，一个用于`long`。如果数学绝对结果容易超出`int`或`long`的范围（例如，`Integer`/`Long.MIN_VALUE`值超出了正`int`/`long`范围），这些方法非常有用。在这种情况下，这些方法会抛出`ArithmeticException`，而不是返回误导性的结果，如下例所示：
- en: '[PRE130]'
  id: totrans-564
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'In a functional style context, a potential solution will rely on the `UnaryOperator`
    functional interface, as follows:'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数式风格上下文中，一个潜在的解决方案将依赖于`UnaryOperator`函数式接口，如下所示：
- en: '[PRE131]'
  id: totrans-566
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: When working with large numbers, also focus on `BigInteger` (immutable arbitrary-precision
    integers) and `BigDecimal` (immutable arbitrary-precision signed decimal numbers).
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理大数时，也要关注`BigInteger`（不可变任意精度整数）和`BigDecimal`（不可变任意精度有符号十进制数）。
- en: 21\. Computing the quotient of the arguments and result overflow
  id: totrans-568
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 21. 计算参数和结果的商，结果溢出
- en: 'Let’s start with two simple computations, as follows:'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从两个简单的计算开始，如下所示：
- en: '[PRE132]'
  id: totrans-570
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'This is a very simple use case that works as expected. Now, let’s keep the
    divisor as `-1`, and let’s change the dividend to `Integer.MIN_VALUE` (-2,147,483,648):'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常简单的用例，按预期工作。现在，让我们保持除数为`-1`，并将被除数改为`Integer.MIN_VALUE`（-2,147,483,648）：
- en: '[PRE133]'
  id: totrans-572
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'This time, the result is not correct. The `int` domain was overflowed because
    of `|Integer.MIN_VALUE| > |Integer.MAX_VALUE|`. It should be the positive 2,147,483,648,
    which doesn’t fit in the `int` domain. However, changing the `x` type from `int`
    to `long` will solve the problem:'
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，结果是不正确的。由于`|Integer.MIN_VALUE| > |Integer.MAX_VALUE|`，`int`域溢出了。它应该是正的21,474,836,48，但这不适合`int`域。然而，将`x`类型从`int`改为`long`将解决问题：
- en: '[PRE134]'
  id: totrans-574
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'But the problem will reappear if, instead of `Integer.MIN_VALUE`, there is
    `Long.MIN_VALUE`:'
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果问题不是由`Integer.MIN_VALUE`引起，而是由`Long.MIN_VALUE`引起，问题将再次出现：
- en: '[PRE135]'
  id: totrans-576
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'Starting with JDK 18, the `Math` class was enriched with two `divideExact()`
    methods. There is one for `int` and one for `long`. These methods are very useful
    if the division result is prone to overflowing the `int` or `long` (as `Integer`/`Long.MIN_VALUE`
    overflows the positive `int`/`long` range). In such cases, these methods throw
    `ArithmeticException` instead of returning a misleading result, as in the following
    example:'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 从 JDK 18 开始，`Math` 类增加了两个 `divideExact()` 方法。一个用于 `int`，一个用于 `long`。如果除法结果容易溢出
    `int` 或 `long`（如 `Integer`/`Long.MIN_VALUE` 溢出正 `int`/`long` 范围），这些方法非常有用。在这种情况下，这些方法会抛出
    `ArithmeticException` 而不是返回误导性的结果，如下例所示：
- en: '[PRE136]'
  id: totrans-578
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 'In a functional style context, a potential solution will rely on the `BinaryOperator`
    functional interface, as follows:'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数式风格语境中，一个潜在的解决方案将依赖于 `BinaryOperator` 函数式接口，如下所示：
- en: '[PRE137]'
  id: totrans-580
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: As we said in the previous problem as well, when working with large numbers,
    also focus on `BigInteger` (immutable arbitrary-precision integers) and `BigDecimal`
    (immutable arbitrary-precision signed decimal numbers).
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前一个问题中也说的，当处理大数时，也要关注 `BigInteger`（不可变任意精度整数）和 `BigDecimal`（不可变任意精度有符号十进制数）。
- en: 22\. Computing the largest/smallest value that is less/greater than or equal
    to the algebraic quotient
  id: totrans-582
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 22. 计算大于/等于代数商的最大/最小值
- en: By the largest value, we understand the value closest to positive infinity,
    while by the smallest value, we understand the value closest to negative infinity.
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 最大的值，我们理解为最接近正无穷大的值，而最小的值，我们理解为最接近负无穷大的值。
- en: Computing the largest value that is less than or equal to the algebraic quotient
    can be done, starting with JDK 8, via `floorDiv(int x, int y)` and `floorDiv(long
    x, long y)`. Starting with JDK 9, we also have `floorDiv(long x, int y)`.
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 从 JDK 8 开始，可以通过 `floorDiv(int x, int y)` 和 `floorDiv(long x, long y)` 来计算小于或等于代数商的最大值。从
    JDK 9 开始，我们也有 `floorDiv(long x, int y)`。
- en: Computing the smallest value that is greater than or equal to the algebraic
    quotient can be done, starting with JDK 18, via `ceilDiv(int x, int y)`, `ceilDiv(long
    x, int y)`, and `ceilDiv(long x, long y)`.
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 从 JDK 18 开始，可以通过 `ceilDiv(int x, int y)`、`ceilDiv(long x, int y)` 和 `ceilDiv(long
    x, long y)` 来计算大于或等于代数商的最小值。
- en: 'However, none of these functions are capable of managing the corner case divisions
    presented in the previous problem, `Integer.MIN_VALUE/-1` and `Long.MIN_VALUE/-1`:'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这些函数都无法处理前一个问题中提到的角点情况除法，即 `Integer.MIN_VALUE/-1` 和 `Long.MIN_VALUE/-1`：
- en: '[PRE138]'
  id: totrans-587
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'Starting with JDK 18, whenever the result returned by `floorDiv()`/`ceilDiv()`
    is prone to overflowing the `int` or `long` domains, we can use `floorDivExact()`
    and `ceilDivExact()`. These methods come with flavors for `int` and `long` arguments.
    As you have probably intuited already, these methods throw `ArithmeticException`
    instead of returning a misleading result, as in the following example:'
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 从 JDK 18 开始，每当 `floorDiv()`/`ceilDiv()` 返回的结果可能溢出 `int` 或 `long` 范围时，我们可以使用
    `floorDivExact()` 和 `ceilDivExact()`。这些方法为 `int` 和 `long` 参数提供了不同的版本。正如你可能已经直觉到的，这些方法会抛出
    `ArithmeticException` 而不是返回误导性的结果，如下例所示：
- en: '[PRE139]'
  id: totrans-589
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'In a functional style context, a potential solution will rely on the `BinaryOperator`
    functional interface, as follows:'
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数式风格语境中，一个潜在的解决方案将依赖于 `BinaryOperator` 函数式接口，如下所示：
- en: '[PRE140]'
  id: totrans-591
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: Done! As you already know, when working with large numbers, also focus on `BigInteger`
    (immutable arbitrary-precision integers) and `BigDecimal` (immutable arbitrary-precision
    signed decimal numbers). These may save your day.
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 完成！正如你所知，当处理大数时，也要关注 `BigInteger`（不可变任意精度整数）和 `BigDecimal`（不可变任意精度有符号十进制数）。这些可能会帮到你。
- en: 23\. Getting integral and fractional parts from a double
  id: totrans-593
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 23. 从 double 中获取整数部分和小数部分
- en: 'You know those problems that are very easy if you know the solution and seem
    very difficult if you don’t? This is exactly that kind of a problem. The solution
    is quite simple, as you can see in the following code:'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道那些如果你知道解决方案就非常简单，如果你不知道就看起来非常困难的问题吗？这正是那种问题。解决方案非常简单，如下面的代码所示：
- en: '[PRE141]'
  id: totrans-595
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: This was easy; I don’t think you need further explanations. But this approach
    is not quite accurate. I mean, the integral part is -9, but this returns -9.0\.
    Also, the fractional part is -0.33543545, but the returned value is -0.3354354500000003.
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单；我认为你不需要进一步的解释。但这种方法并不完全准确。我的意思是，整数部分是 -9，但返回的是 -9.0。另外，小数部分是 -0.33543545，但返回的值是
    -0.3354354500000003。
- en: 'If we need a more accurate result, then using `BigDecimal` is more useful:'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要更精确的结果，那么使用 `BigDecimal` 会更有用：
- en: '[PRE142]'
  id: totrans-598
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: This time, the results are -9 and -0.33543545.
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，结果是 -9 和 -0.33543545。
- en: 24\. Testing if a double number is an integer
  id: totrans-600
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 24. 测试双精度浮点数是否为整数
- en: 'First of all, let’s consider the following expected results (false means that
    the double is not an integer):'
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们考虑以下预期结果（false 表示双精度浮点数不是整数）：
- en: '[PRE143]'
  id: totrans-602
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: 'Most probably, the first solution for testing if a double number is an integer
    consists of a simple cast as follows:'
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 测试一个双精度浮点数是否为整数的最常见方法可能是一个简单的强制类型转换，如下所示：
- en: '[PRE144]'
  id: totrans-604
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: 'However, there are several other options. For instance, we can rely on modulus,
    as follows:'
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，还有其他几种选择。例如，我们可以依赖模运算，如下所示：
- en: '[PRE145]'
  id: totrans-606
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: 'Alternatively, we can rely on the `Math.floor()` and `Double.isFinite()` methods.
    If the given double is a finite number and is equal to the result of `Math.floor()`,
    then it is an integer:'
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以依赖 `Math.floor()` 和 `Double.isFinite()` 方法。如果给定的双精度浮点数是一个有限数，并且等于 `Math.floor()`
    的结果，那么它就是一个整数：
- en: '[PRE146]'
  id: totrans-608
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: 'We can also replace this equality via `Math.ceil()`:'
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以通过 `Math.ceil()` 来替换这个等式：
- en: '[PRE147]'
  id: totrans-610
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: 'Moreover, we can combine `Double.isFinite()` with `Math.rint()`, as follows:'
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可以将 `Double.isFinite()` 与 `Math.rint()` 结合使用，如下所示：
- en: '[PRE148]'
  id: totrans-612
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: 'Finally, we can rely on Guava’s `DoubleMath.isMathematicalInteger()`:'
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以依赖 Guava 的 `DoubleMath.isMathematicalInteger()` 方法：
- en: '[PRE149]'
  id: totrans-614
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: 'But which of these approaches has a better performance? Which one are you betting
    on? Well, let’s see what a benchmark has to say:'
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，这些方法中哪一个性能更好？你更倾向于哪一个？好吧，让我们看看基准测试有什么要说的：
- en: '![Figure 1.19.png](img/B19665_01_19.png)'
  id: totrans-616
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.19.png](img/B19665_01_19.png)'
- en: 'Figure 1.19: Benchmark results'
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.19：基准测试结果
- en: Based on these results, the conclusion is quite obvious – the solution that
    relies on modulus should be avoided. Also, the Guava solution seems to be slightly
    slower than the rest.
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这些结果，结论相当明显——基于模运算的解决方案应该避免使用。此外，Guava 的解决方案似乎比其他方案略慢。
- en: 25\. Hooking Java (un)signed integers in a nutshell
  id: totrans-619
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 25. 简要介绍 Java（无）符号整数
- en: '*Signed* values (or variables) such as signed integers or signed longs allow
    us to represent negative and positive numbers.'
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: '*有符号* 值（或变量），如有符号整数或有符号长整型，允许我们表示负数和正数。'
- en: '*Unsigned* values (or variables) such as unsigned integers or unsigned longs
    allow us to represent only positive numbers.'
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: '*无符号* 值（或变量），如无符号整数或无符号长整型，允许我们仅表示正数。'
- en: Signed and unsigned values (variables) of the same type share the same range.
    However, as you can see in the following figure, unsigned variables cover a larger
    magnitude number.
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 同一类型的有符号和无符号值（变量）具有相同的范围。然而，正如你在以下图中可以看到的，无符号变量覆盖了更大的数值范围。
- en: '![Figure 1.20.png](img/B19665_01_20.png)'
  id: totrans-623
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.20.png](img/B19665_01_20.png)'
- en: 'Figure 1.20: Signed and unsigned integers'
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.20：有符号和无符号整数
- en: The signed 32-bit integers range from –2,147,483,648 to 2,147,483,647 (around
    4 billion values). Unsigned 32-bit integers range from 0 to 4,294,967,295 (also
    around 4 billion values).
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 有符号 32 位整数范围从 –2,147,483,648 到 2,147,483,647（大约 40 亿个值）。无符号 32 位整数范围从 0 到 4,294,967,295（也是大约
    40 亿个值）。
- en: So when we use signed integer variables, we can use 2 billion positive values,
    but when we use unsigned integer variables, we can use 4 billion positive values.
    The hatched part of the figure represents the extra 2 billion positive integer
    values.
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用有符号整数变量时，我们可以使用 20 亿个正数值，但当我们使用无符号整数变量时，我们可以使用 40 亿个正数值。图中的阴影部分表示额外的 20
    亿个正整数值。
- en: Commonly, unsigned values are needed when we don’t need negative values at all
    (for instance, to count something like an event occurrence) and we need to use
    values that reside in the hashed area in *Figure 1.20*.
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当我们根本不需要负数值时（例如，要计数某些事件的发生），我们需要使用位于 *图 1.20* 中哈希区域的值，这时就需要无符号值。
- en: Java supports only signed integers that use the popular *two’s complement* representation
    in a signed system (for a detailed explanation of two’s complement representation
    and bit manipulation, please check out *The Complete Coding Interview Guide in
    Java*, *Chapter 9*, *Bit Manipulation*). However, starting with JDK 8, we also
    have the *Unsigned Integer API*, which adds support for unsigned arithmetic.
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: Java 仅支持使用流行的 *二进制补码* 表示法在有符号系统中表示的有符号整数（有关二进制补码表示法和位操作的详细解释，请参阅 *Java 完整编码面试指南*，第
    9 章，*位操作*）。然而，从 JDK 8 开始，我们也拥有了 *无符号整数 API*，它增加了对无符号算术的支持。
- en: 'Moreover, JDK 9, comes with a method named `Math.multiplyHigh(long x, long
    y)`. This method returns a `long`, representing the most significant 64 bits of
    the 128-bit product of two 64-bit factors. The following figure clarifies this
    statement:'
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，JDK 9 提供了一个名为 `Math.multiplyHigh(long x, long y)` 的方法。此方法返回一个 `long` 类型的值，表示两个
    64 位因子的 128 位乘积的最高 64 位。以下图解说明了这一说法：
- en: '![Figure 1.21.png](img/B19665_01_21.png)'
  id: totrans-630
  prefs: []
  type: TYPE_IMG
  zh: '![Figure 1.21.png](img/B19665_01_21.png)'
- en: 'Figure 1.21: The most significant 64 bits of the 128-bit product of two 64-bit
    factors'
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.21：两个 64 位因子 128 位乘积的最高 64 位
- en: 'For example:'
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE150]'
  id: totrans-633
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: 'The returned result (-7187) is a signed value. The unsigned version of this
    method, `unsignedMultiplyHigh(long x, long y)`, was introduced in JDK 18 and works
    as follows:'
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的结果 (-7187) 是一个有符号值。此方法的未签名版本 `unsignedMultiplyHigh(long x, long y)` 在 JDK
    18 中引入，其工作方式如下：
- en: '[PRE151]'
  id: totrans-635
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: So `unsignedMultiplyHigh(long x, long y)` returns a long representing the most
    significant 64 bits of the unsigned 128-bit product of two unsigned 64-bit factors.
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`unsignedMultiplyHigh(long x, long y)` 返回一个 long 类型的值，表示两个无符号 64 位因子的无符号
    128 位乘积的最高 64 位。
- en: 'However, remember that Java supports unsigned arithmetic, not unsigned values/variables.
    However, thanks to the Data Geekery company (very well known for the famous jOOQ),
    we have the **jOOU** (**Java Object Oriented Unsigned**) project, created to bring
    unsigned number types into Java. While you can explore this project at [https://github.com/jOOQ/jOOU](https://github.com/jOOQ/jOOU),
    here is an example of defining an unsigned long:'
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，请记住，Java 支持无符号算术，而不是无符号值/变量。但是，多亏了 Data Geekery 公司（因其著名的 jOOQ 而闻名），我们有了 **jOOU**
    （**Java Object Oriented Unsigned**）项目，该项目旨在将无符号数字类型引入 Java。虽然你可以在这里探索这个项目 [https://github.com/jOOQ/jOOU](https://github.com/jOOQ/jOOU)，以下是一个定义无符号
    long 的示例：
- en: '[PRE152]'
  id: totrans-638
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: 'Here is its use in `unsignedMultiplyHigh(long x, long y)`:'
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: 这是它在 `unsignedMultiplyHigh(long x, long y)` 中的使用示例：
- en: '[PRE153]'
  id: totrans-640
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: You can find these examples in the bundled code.
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在捆绑的代码中找到这些示例。
- en: 26\. Returning the flooring/ceiling modulus
  id: totrans-642
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 26. 返回地板/天花板模数
- en: Having the *dividend / divisor = quotient* computation, we know that the *floor*
    operation applied to the (*dividend*, *divisor*) pair returns the largest integer
    that is less than or equal to the algebraic *quotient*. By the largest integer,
    we understand the integer closest to positive infinity. Starting with JDK 8, this
    operation can be obtained via `Math.floorDiv()` and, starting with JDK 18, `Math.floorDivExact()`.
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: 有 *被除数 / 除数 = 商* 的计算，我们知道对 (*被除数*, *除数*) 对应用 *floor* 操作返回的是小于或等于代数 *商* 的最大整数。我们所说的最大整数是指最接近正无穷大的整数。从
    JDK 8 开始，这个操作可以通过 `Math.floorDiv()` 方法获得，从 JDK 18 开始，可以通过 `Math.floorDivExact()`
    方法获得。
- en: On the other hand, the *ceil* operation applied to the (*dividend*, *divisor*)
    pair returns the smallest integer that is greater than or equal to the algebraic
    *quotient*. By the smallest integer, we understand the integer closest to negative
    infinity. Starting with JDK 18, this operation can be obtained via `Math.ceilDiv()`
    and `Math.ceilDivExact()`.
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，对 (*被除数*, *除数*) 对应用 *ceil* 操作返回的是大于或等于代数 *商* 的最小整数。我们所说的最小整数是指最接近负无穷大的整数。从
    JDK 18 开始，这个操作可以通过 `Math.ceilDiv()` 和 `Math.ceilDivExact()` 方法获得。
- en: More details are available in *Problem 22*.
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: 更多细节请参阅 *问题 22*。
- en: 'Now, based on the *floor* and *ceil* operations, we can define the following
    floor/ceil modulus relationships:'
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，基于 *floor* 和 *ceil* 操作，我们可以定义以下 floor/ceil modulus 关系：
- en: '[PRE154]'
  id: totrans-647
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: 'So we can write this in code as:'
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以在代码中这样写：
- en: '[PRE155]'
  id: totrans-649
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: 'Starting with JDK 8, floor modulus can be obtained via `Math.floorMod()`, as
    follows:'
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: 从 JDK 8 开始，可以通过 `Math.floorMod()` 方法获取模数，如下所示：
- en: '[PRE156]'
  id: totrans-651
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: 'Here, we use `floorMod(int dividend, int divisor)`. But we can also use two
    more flavors: `floorMod(long dividend, long divisor)` and, starting with JDK 9,
    `floorMod(long dividend, int divisor)`.'
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们使用 `floorMod(int dividend, int divisor)`。但也可以使用另外两种形式：`floorMod(long dividend,
    long divisor)` 和从 JDK 9 开始的 `floorMod(long dividend, int divisor)`。
- en: If the *dividend % divisor* is 0, then `floorMod()` is 0\. If *dividend % divisor*
    and `floorMod()` are not 0, then their result differs only if the signs of the
    parameters differ.
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 *被除数 % 除数* 为 0，则 `floorMod()` 为 0。如果 *被除数 % 除数* 和 `floorMod()` 都不为 0，则它们的结果仅在参数的符号不同时才不同。
- en: 'Starting with JDK 18, ceil modulus can be obtained via `Math.ceilMod()`, as
    follows:'
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 从 JDK 18 开始，可以通过 `Math.ceilMod()` 方法获得 ceiling modulus，如下所示：
- en: '[PRE157]'
  id: totrans-655
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: 'Here, we use `ceilMod(int dividend, int divisor)`. But we can also use two
    more flavors: `ceilMod(long dividend, int divisor)` and `ceilMod(long dividend,
    long divisor)`.'
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们使用 `ceilMod(int dividend, int divisor)`。但也可以使用另外两种形式：`ceilMod(long dividend,
    int divisor)` 和从 JDK 9 开始的 `ceilMod(long dividend, int divisor)`。
- en: If the *dividend % divisor* is 0, then `ceilMod()` is 0\. If *dividend % divisor*
    and `ceilMod()` are not 0, then their results differ only if the signs of the
    parameters are the same.
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*被除数 % 除数*为0，则`ceilMod()`为0。如果*被除数 % 除数*和`ceilMod()`不为0，那么它们的结果只有在参数的符号相同时才不同。
- en: 'Moreover, the relationship between `floorMod()` and `floorDiv()` is as follows:'
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`floorMod()`和`floorDiv()`之间的关系如下：
- en: '[PRE158]'
  id: totrans-659
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: 'Also, the relationship between `ceilMod()` and `ceilDiv()` is as follows:'
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`ceilMod()`和`ceilDiv()`之间的关系如下：
- en: '[PRE159]'
  id: totrans-661
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: Notice that if the divisor is 0, then both `floorMod()` and `ceilMod()` throw
    `ArithmeticException`.
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果除数为0，则`floorMod()`和`ceilMod()`都会抛出`ArithmeticException`。
- en: 27\. Collecting all prime factors of a given number
  id: totrans-663
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 27. 收集给定数的所有质因数
- en: 'A prime number is a number divisible by itself and 1 (for instance, 2, 3, and
    5 are prime numbers). Having a given number, we can extract its prime factors,
    as in the following figure:'
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: 一个质数是只能被自己和1整除的数（例如，2，3和5是质数）。给定一个数，我们可以提取它的质因数，如下所示：
- en: '![Figure 1.22.png](img/B19665_01_22.png)'
  id: totrans-665
  prefs: []
  type: TYPE_IMG
  zh: '![Figure 1.22.png](img/B19665_01_22.png)'
- en: 'Figure 1.22: Prime factors of 90 are 2, 3, 3, and 5'
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.22：90的质因数是2，3，3和5
- en: 'The prime factors of 90 are 2, 3, 3, and 5\. Based on *Figure 1.22*, we can
    create an algorithm to solve this problem, as follows:'
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: 90的质因数是2，3，3和5。根据*图1.22*，我们可以创建一个算法来解决这个问题，如下所示：
- en: Define a `List` to collect prime factors of the given `v`.
  id: totrans-668
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个`List`来收集给定`v`的质因数。
- en: Initialize a variable `s` with 2 (the smallest prime number).
  id: totrans-669
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将变量`s`初始化为2（最小的质数）。
- en: If `v % s` is 0, collect `s` as a prime factor and compute the new `v` as `v
    / s`.
  id: totrans-670
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`v % s`为0，则收集`s`作为质因数，并计算新的`v`为`v / s`。
- en: If `v % s` is not 0, then increase `s` by 1.
  id: totrans-671
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`v % s`不为0，则将`s`增加1。
- en: Repeat step 3 as long as `v` is greater than 1.
  id: totrans-672
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只要`v`大于1，就重复步骤3。
- en: 'In code lines, this O(n) algorithm (O(log n) for composite numbers) can be
    expressed as follows:'
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码行中，这个O(n)算法（对于合数是O(log n)）可以表示如下：
- en: '[PRE160]'
  id: totrans-674
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: In the bundled code, you can find two more approaches. Moreover, you’ll also
    find an application that counts the number of primes less than the given number,
    `v` (`v` should be positive).
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: 在捆绑的代码中，你可以找到两种更多的方法。此外，你还会找到一个应用，它可以计算小于给定数字`v`（`v`应该是正数）的质数数量。
- en: 28\. Computing the square root of a number using the Babylonian method
  id: totrans-676
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 28. 使用巴比伦方法计算一个数的平方根
- en: Believe it or not, the ancient Babylonians (around 1500 BC) knew how to estimate
    square roots long before the popular method discovered by Newton.
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: 信不信由你，古代的巴比伦人（大约公元前1500年）在牛顿发现的方法流行之前就知道如何估计平方根。
- en: 'Mathematically speaking, the Babylonian approach for estimating the square
    root of `v > 0` is the recurrence relation from the following figure:'
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: 从数学的角度讲，估计`v > 0`的平方根的巴比伦方法是以下图所示的递归关系：
- en: '![Figure 1.23.png](img/B19665_01_23.png)'
  id: totrans-679
  prefs: []
  type: TYPE_IMG
  zh: '![Figure 1.23.png](img/B19665_01_23.png)'
- en: 'Figure 1.23: The recurrence relation of Babylonian square root approximation'
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.23：巴比伦平方根近似的递归关系
- en: The recurrence formula starts with an initial guess of x[0]. Next, we calculate
    x[1], x[2], …, x[n] by substituting x[n-1] in the formula on the right-hand side
    and evaluating the expression.
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: 递归公式从初始猜测x[0]开始。接下来，我们通过将x[n-1]代入右侧的公式并计算表达式来计算x[1]，x[2]，…，x[n]。
- en: 'For instance, let’s try to apply this formula to estimate the square root of
    65 (the result is 8.06). Let’s start with x[0] as 65/2, so x[0] =32.5, and let’s
    calculate x[1] as:'
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们尝试将这个公式应用于估计65的平方根（结果是8.06）。让我们以x[0]作为65/2开始，所以x[0] = 32.5，然后让我们计算x[1]如下：
- en: '![](img/B19665_01_001.png)'
  id: totrans-683
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19665_01_001.png)'
- en: 'Having x[1], we can calculate x[2] as follows:'
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: 有x[1]，我们可以按照以下方式计算x[2]：
- en: '![](img/B19665_01_002.png)'
  id: totrans-685
  prefs: []
  type: TYPE_IMG
  zh: '![Figure 1.23.png](img/B19665_01_002.png)'
- en: 'Having x[2], we can calculate x[3] as follows:'
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: 有x[2]，我们可以按照以下方式计算x[3]：
- en: '![](img/B19665_01_003.png)'
  id: totrans-687
  prefs: []
  type: TYPE_IMG
  zh: '![Figure 1.23.png](img/B19665_01_003.png)'
- en: 'We are getting closer to the final result. Having x[3], we can calculate x[4]
    as follows:'
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在接近最终结果。有x[3]，我们可以按照以下方式计算x[4]：
- en: '![](img/B19665_01_004.png)'
  id: totrans-689
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19665_01_004.png)'
- en: Done! After four iterations, we found that the square root of 65 is 8.06\. Of
    course, being an approximation of the real value, we can continue until we reach
    the desired precision. More precision involves more iterations.
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: 完成！经过四次迭代，我们发现65的平方根是8.06。当然，作为一个真实值的近似，我们可以继续迭代直到达到所需的精度。更高的精度需要更多的迭代。
- en: 'The algorithm that is based on the Babylonian approach to approximate the square
    root of `v > 0` has several steps, as follows:'
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: 基于巴比伦方法来近似`v > 0`的平方根的算法有几个步骤，如下所示：
- en: To start, choose an arbitrary positive value, `x` (the closer it is to the final
    result, the fewer iterations are needed). For instance, we start with `x = v/2`
    as the initial guess.
  id: totrans-692
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，选择一个任意正数，`x`（它越接近最终结果，所需的迭代次数就越少）。例如，我们以`x = v/2`作为初始猜测开始。
- en: Initialize `y = 1`, and choose the desired precision (for instance, `e = 0.000000000001`).
  id: totrans-693
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化`y = 1`，并选择所需的精度（例如，`e = 0.000000000001`）。
- en: 'Until the precision (`e`) is achieved, do the following:'
  id: totrans-694
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 直到达到精度（`e`），执行以下操作：
- en: Calculate the next approximation (`xnext`) as the average of `x` and `y`.
  id: totrans-695
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将下一个近似值（`xnext`）计算为`x`和`y`的平均值。
- en: Use the next approximation to set `y` as `v/xnext`.
  id: totrans-696
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用下一个近似值将`y`设置为`v/xnext`。
- en: 'So in code lines, we have the following snippet:'
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在代码行中，我们有以下片段：
- en: '[PRE161]'
  id: totrans-698
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: In the bundled code, you can also see an implementation that is useful if you
    know that `v` is a perfect square (for instance, 25, 144, 169, and so on).
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: 在捆绑的代码中，你还可以看到一个有用的实现，如果你知道`v`是一个完全平方数（例如，25、144、169等等）。
- en: 29\. Rounding a float number to specified decimals
  id: totrans-700
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 29. 将浮点数四舍五入到指定的小数位数
- en: 'Consider the following `float` number and the number of decimals that we want
    to keep:'
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下`float`数字和我们想要保留的小数位数：
- en: '[PRE162]'
  id: totrans-702
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: So the expected result after rounding up is 14.98777.
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，向上取整后的预期结果是14.98777。
- en: 'We can solve this problem in a straightforward manner in at least three ways.
    For instance, we can rely on the `BigDecimal` API, as follows:'
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用至少三种直接的方式解决这个问题。例如，我们可以依赖`BigDecimal` API，如下所示：
- en: '[PRE163]'
  id: totrans-705
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: First, we create a `BigDecimal` number from the given `float`. Second, we scale
    this `BigDecimal` to the desired number of decimals. Finally, we return the new
    `float` value.
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将给定的`float`创建为一个`BigDecimal`数字。其次，我们将这个`BigDecimal`缩放到所需的小数位数。最后，我们返回新的`float`值。
- en: 'Another approach can rely on `DecimalFormat`, as follows:'
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法可以依赖于`DecimalFormat`，如下所示：
- en: '[PRE164]'
  id: totrans-708
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: We define the format via `setMaximumFractionDigits()` and simply use this format
    on the given `float`. The returned `String` is passed through `Float.parseFloat()`
    to obtain the final `float`.
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过`setMaximumFractionDigits()`定义格式，并简单地使用这个格式在给定的`float`上。返回的`String`通过`Float.parseFloat()`转换为最终的`float`。
- en: 'Finally, we can apply a more esoteric but self-explanatory approach, as follows:'
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以采用一种更加晦涩但自解释的方法，如下所示：
- en: '[PRE165]'
  id: totrans-711
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: You can practice these examples in the bundled code. Feel free to add your own
    solutions.
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在捆绑的代码中练习这些示例。请随意添加你自己的解决方案。
- en: 30\. Clamping a value between min and max
  id: totrans-713
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 30. 在最小和最大之间夹紧一个值
- en: Let’s assume that we have a pressure regulator that is capable of adjusting
    the given pressure in a certain range. For instance, if the passed pressure is
    below the minimum pressure, then the regulator increases the pressure to the minimum
    pressure. On the other hand, if the passed pressure is higher than the maximum
    pressure, then the regulator decreases the pressure to the maximum pressure. Moreover,
    if the passed pressure is between the minimum (inclusive) and maximum (inclusive)
    pressure, then nothing happens – this is the normal pressure.
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个能够调整给定压力在一定范围内的压力调节器。例如，如果传递的压力低于最小压力，则调节器将压力增加到最小压力。另一方面，如果传递的压力高于最大压力，则调节器将压力降低到最大压力。此外，如果传递的压力在最小（包含）和最大（包含）压力之间，则不发生任何操作——这是正常压力。
- en: 'Coding this scenario can be done in a straightforward manner, as follows:'
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: 编写这个场景可以直接进行，如下所示：
- en: '[PRE166]'
  id: totrans-716
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: 'Neat! You can find different ways of expressing this code in shorter and smarter
    ways, but starting with JDK 21, we can accommodate solutions to this problem via
    the `Math.clamp()` method. One of the flavors of this method is `clamp(long value,
    int min, int max)`, which clamps the given `value` between the given `min` and
    `max`. For instance, we can rewrite the previous code via the `clamp()` method,
    as follows:'
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: 真棒！你可以找到不同的方法以更短、更智能的方式表达这段代码，但自JDK 21开始，我们可以通过`Math.clamp()`方法来解决这个问题。这个方法的一个版本是`clamp(long
    value, int min, int max)`，它将给定的`value`夹在给定的`min`和`max`之间。例如，我们可以通过`clamp()`方法重写之前的代码，如下所示：
- en: '[PRE167]'
  id: totrans-718
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: 'Cool, right!? The logic behind the `clamp()` method relies on the following
    code line:'
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: 很酷，对吧！`clamp()`方法背后的逻辑依赖于以下代码行：
- en: '[PRE168]'
  id: totrans-720
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: Other flavors of `clamp()` are `clamp(long value, long min, long max)`, `clamp(float
    value, float min, float max)`, and `clamp(double value, double min, double max)`.
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: '`clamp()`的其他版本有`clamp(long value, long min, long max)`、`clamp(float value,
    float min, float max)`和`clamp(double value, double min, double max)`。'
- en: 31\. Multiply two integers without using loops, multiplication, bitwise, division,
    and operators
  id: totrans-722
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The solution to this problem can start from the following algebraic formula,
    also known as the *special binomial product formula*:'
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.24.png](img/B19665_01_24.png)'
  id: totrans-724
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.24: Extracting a*b from a binomial formula'
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have the a*b product, there is only one issue left. The formula
    of a*b contains a division by 2, and we are not allowed to explicitly use the
    division operation. However, the division operation can be mocked in a recursive
    fashion, as follows:'
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE169]'
  id: totrans-727
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: 'Nothing can stop us now from using this recursive code to implement a*b, as
    follows:'
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE170]'
  id: totrans-729
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: In the bundled code, you can also practice a recursive approach to this problem.
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
- en: 32\. Using TAU
  id: totrans-731
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is TAU?
  id: totrans-732
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Short answer**: It is the Greek letter ![](img/B19665_01_005.png).'
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
- en: '**Long answer**: It is a Greek letter used to define the proportion of the
    circumference of a circle to its radius. Put simply, TAU is one turn of an entire
    circle, so 2*PI.'
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
- en: 'TAU allows us to express sinuses, cosines, and angles in a more intuitive and
    simple way. For instance, the well-known angles of 30⁰, 45⁰, 90⁰, and so on can
    be easily expressed in radians via TAU as a fraction of a circle, as in the following
    figure:'
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.25.png](img/B19665_01_25.png)'
  id: totrans-736
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.25: Angles represented using TAU'
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
- en: This is more intuitive than PI. It is like slicing a pie into equal parts. For
    instance, if we slice at TAU/8 (45⁰), it means that we sliced the pie into eight
    equal parts. If we slice at TAU/4 (90⁰), it means that we sliced the pie into
    four equal parts.
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
- en: The value of TAU is 6.283185307179586 = 2 * 3.141592653589793\. So the relationship
    between TAU and PI is TAU=2*PI. In Java, the well-known PI is represented via
    the `Math.PI` constant. Starting with JDK 19, the `Math` class was enriched with
    the `Math.TAU` constant.
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s consider the following simple problem: A circle has a circumference of
    21.33 cm. What is the radius of the circle?'
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
- en: 'We know that C = 2*PI*r, where C is the circumference and r is the radius.
    Therefore, r = C/(2*PI) or r = C/TAU. In code lines, we have:'
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE171]'
  id: totrans-742
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: Both approaches return a radius equal to 3.394.
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
- en: 33\. Selecting a pseudo-random number generator
  id: totrans-744
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we flip a coin or roll the dice, we say that we see “true” or “natural”
    randomness at work. Even so, there are tools that pretend they are capable of
    predicting the path of flipping a coin, rolling dice, or spinning a roulette wheel,
    especially if some contextual conditions are met.
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
- en: Computers can generate random numbers using algorithms via the so-called **random
    generators**. Since algorithms are involved, the generated numbers are considered
    pseudo-random. This is known as “pseudo”-randomness. Obviously, pseudo-random
    numbers are also predictable. How so?
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
- en: A pseudo-random generator starts its job by *seeding* data. This is the generator’s
    secret (the *seed*), and it represents a piece of data used as the starting point
    to generate pseudo-random numbers. If we know how the algorithm works and what
    the *seed* was, then the output is predictable. Without knowing the *seed*, the
    rate of predictability is very low. So choosing the proper *seed* is a major step
    for every pseudo-random generator.
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
- en: 'Until JDK 17, Java’s API for generating pseudo-random numbers was a bit obtuse.
    Basically, we have a robust API wrapped in the well-known `java.util.Random` class,
    and two subclasses of `Random`: `SecureRandom` (cryptographically pseudo-random
    generator) and `ThreadLocalRandom` (not a thread-safe pseudo-random generator).
    From a performance perspective, the relationship between these pseudo-random generators
    is that `SecureRandom` is slower than `Random`, which is slower than `ThreadLocalRandom`.'
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
- en: As well as these classes, we have `SplittableRandom`. This is a non-thread-safe
    pseudo-generator capable of spinning a new `SplittableRandom` at each call of
    its `split()` method. This way, each thread (for instance, in a fork/join architecture)
    can use its own `SplittableGenerator`.
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
- en: 'The class hierarchy of pseudo-random generators, up to JDK 17, is shown in
    the following figure:'
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.26.png](img/B19665_01_26.png)'
  id: totrans-751
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.26: The class hierarchy of Java pseudo-random generators before JDK
    17'
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
- en: As this architecture reveals, switching between pseudo-random generators or
    choosing between different types of algorithms is really cumbersome. Look at that
    `SplittableRandom` – is lost in no man’s land.
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
- en: 'Starting with JDK 17, we have a more flexible and powerful API for generating
    pseudo-random numbers. This is an interface-based API (released with JEP 356)
    that orbits the new `RandomGenerator` interface. Here is the enhanced class hierarchy
    of JDK 17:'
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.27.png](img/B19665_01_27.png)'
  id: totrans-755
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.27: The class hierarchy of Java pseudo-random generators, starting
    with JDK 17'
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
- en: The `RandomGenerator` interface represents the climax of this API. It represents
    a common and uniform protocol for generating pseudo-random numbers. This interface
    has taken over the `Random` API and added a few more.
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
- en: The `RandomGenerator` interface is extended by five sub-interfaces meant to
    provide special protocols for five different types of pseudo-random generators.
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
- en: '`StreamableGenerator` can return streams of `RandomGenerator` objects'
  id: totrans-759
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SplittableGenerator` can return a new generator from this one (split itself)'
  id: totrans-760
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`JumpableGenerator` can jump ahead a moderate number of draws'
  id: totrans-761
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LeapableGenerator` can jump ahead a large number of draws'
  id: totrans-762
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ArbitrarilyJumpableGenerator` can jump ahead an arbitrary number of draws'
  id: totrans-763
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Getting the default `RandomGenerator` can be done as follows (this is the simplest
    approach to start generating pseudo-random numbers, but you have no control over
    what is chosen):'
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE172]'
  id: totrans-765
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: 'Besides these interfaces, the new API comes with a class (`RandomGeneratorFactory`),
    which is a factory of pseudo-random generators based on the selected algorithms.
    There are three groups of new algorithms (most probably, more are on the way);
    these groups are as follows:'
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
- en: LXM group;
  id: totrans-767
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`L128X1024MixRandom`'
  id: totrans-768
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`L128X128MixRandom`'
  id: totrans-769
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`L128X256MixRandom`'
  id: totrans-770
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`L32X64MixRandom`'
  id: totrans-771
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`L64X1024MixRandom`'
  id: totrans-772
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`L64X128MixRandom`'
  id: totrans-773
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`L64X128StarStarRandom`'
  id: totrans-774
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`L64X256MixRandom`'
  id: totrans-775
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Xoroshiro group:'
  id: totrans-776
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Xoroshiro128PlusPlus`'
  id: totrans-777
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Xoshiro group:'
  id: totrans-778
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Xoshiro256PlusPlus`'
  id: totrans-779
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The highlighted algorithm is the default one (`L32X64MixRandom`).
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
- en: Depending on the pseudo-random generator type, we can select all/some of the
    previous algorithms. For instance, the `L128X256MixRandom` algorithm can be used
    with `SplittableGenerator`, but it cannot be used with `LeapableGenerator`. A
    mismatch between the chosen algorithm and the pseudo-random generator results
    in `IllegalArgumentException`. The following figure can help you to decide which
    algorithm to use.
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.28.png](img/B19665_01_28.png)'
  id: totrans-782
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.28: JDK 17 random generator algorithms and their properties'
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
- en: 'This figure was produced via the following code, which lists all the available
    algorithms and their properties (*streamable*, *leapable*, *statistical*, and
    so on):'
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE173]'
  id: totrans-785
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: Choosing an algorithm can be easily done by name or properties.
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
- en: Choosing an algorithm by name
  id: totrans-787
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Choosing an algorithm by name can be done via a set of static `of()` methods.
    There is an `of()` method in `RandomGenerator` and `RandomGeneratorFactory` that
    can be used to create a pseudo-random generator for a specific algorithm, as follows:'
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE174]'
  id: totrans-789
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: Next, we can generate pseudo-random numbers by calling a well-known API (`ints()`,
    `doubles()`, `nextInt()`, `nextFloat()`, and so on).
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
- en: 'If we need a certain pseudo-random generator and algorithm, then we can use
    the `of()` method of that generator, as follows (here, we create a `LeapableGenerator`):'
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE175]'
  id: totrans-792
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: 'In the case of `SplittableRandom`, you can use the constructor as well, but
    you cannot specify the algorithm:'
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE176]'
  id: totrans-794
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: In the bundled code, you can see more examples.
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
- en: Choosing an algorithm by property
  id: totrans-796
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As you saw in *Figure 1.28*, an algorithm has a set of properties (is *Jumpable*,
    is *Statistical*, and so on). Let’s pick an algorithm that is *statistical* and
    *leapable*:'
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE177]'
  id: totrans-798
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: The returned algorithm can be `Xoshiro256PlusPlus`.
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
- en: 34\. Filling a long array with pseudo-random numbers
  id: totrans-800
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we want to fill up a large array with data, we can consider the `Arrays.setAll()`
    and `Arrays.parallelSetAll()`. These methods can fill up an array by applying
    a generator function to compute each element of the array.
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we have to fill up the array with pseudo-random data, we should consider
    that the generator function should be a pseudo-random generator. If we want to
    do this in parallel, then we should consider the `SplittableRandom` (JDK 8+)/`SplittableGenerator`
    (JDK 17+), which are dedicated to generating pseudo-random numbers in isolated
    parallel computations. In conclusion, the code may look as follows (JDK 17+):'
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE178]'
  id: totrans-803
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: 'Alternatively, we can use `SplittableRandom` (this time, we cannot specify
    the algorithm, JDK 8+):'
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE179]'
  id: totrans-805
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: Next, let’s see how we can create a stream of pseudo-random generators.
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
- en: 35\. Creating a stream of pseudo-random generators
  id: totrans-807
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before creating a stream of pseudo-random generators, let’s create a stream
    of pseudo-random numbers. First thing first, let’s see how to do it with the legacy
    `Random`, `SecureRandom`, and `ThreadLocalRandom`.
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
- en: 'Since these three pseudo-random generators contain methods such as `ints()`
    returning `IntStream`, `doubles()` returning `DoubleStream`, and so on, we can
    easily generate an (in)finite stream of pseudo-random numbers, as follows:'
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE180]'
  id: totrans-810
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: 'In our examples, we collect the generated pseudo-random numbers in an array.
    Of course, you can process them as you want. We can obtain similar results via
    `SecureRandom`, as follows:'
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE181]'
  id: totrans-812
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: 'How about `ThreadLocalRandom`? Here it is:'
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE182]'
  id: totrans-814
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: 'If you just need a stream of doubles between 0.0 and 1.0, then rely on `Math.random()`,
    which internally uses an instance of `java.util.Random`. The following example
    collects an array of doubles between 0.0 and 0.5\. The stream will stop when the
    first `double` larger than 0.5 is generated:'
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE183]'
  id: totrans-816
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: 'How about using the new JDK 17 API? The `RandomGenerator` contains the well-known
    methods `ints()`, `doubles()`, and so on, and they are available in all its sub-interfaces.
    For instance, `StreamableGenerator` can be used, as follows:'
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE184]'
  id: totrans-818
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: Similarly, we can use `JumpableGenerator`, `LeapableGenerator`, and so on.
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
- en: 'OK, now let’s get back to our problem. How do we generate a stream of pseudo-random
    generators? All `RandomGenerator` sub-interfaces contain a method named `rngs()`
    that comes in different flavors. Without arguments, this method returns an infinite
    stream of new pseudo-random generators that implement the `RandomGenerator` interface.
    The following code generated five `StreamableGenerator` instances, and each of
    those generated 10 pseudo-random integers:'
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE185]'
  id: totrans-821
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: 'We can accomplish the same thing with `JumpableGenerator`, but instead of `rngs()`,
    we may prefer `jumps()`, which implements the behavior specific to this type of
    generator:'
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE186]'
  id: totrans-823
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: 'The same thing can be accomplished via `LeapableGenerator`. This time, we can
    use `rngs()` or `leaps()`, which implement the behavior specific to this type
    of generator:'
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE187]'
  id: totrans-825
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: Next, let’s see how we can interleave legacy and new pseudo-random generators.
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
- en: 36\. Getting a legacy pseudo-random generator from new ones of JDK 17
  id: totrans-827
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A legacy pseudo-random generator such as `Random`, `SecureRandom`, or `ThreadLocalRandom`
    can delegate method calls to a `RandomGenerator`, passed as an argument to `Random.from()`,
    `SecureRandom.from()`, or `ThreadLocalRandom.from()`, as follows:'
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE188]'
  id: totrans-829
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: The `from()` methods are available starting with JDK 19\. In the bundled code,
    you can see more examples.
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
- en: 37\. Using pseudo-random generators in a thread-safe fashion (multithreaded
    environments)
  id: totrans-831
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Random` and `SecureRandom` instances are thread-safe. While this statement
    is true, pay attention that when a `Random` instance (or `Math.random()`) is used
    by multiple threads (multithreaded environment), your code is prone to thread
    contention because these threads share the same *seed*. Sharing the same seed
    involves synchronization of the *seed* access; therefore, it opens the door to
    thread contention. Obviously, thread contention leads to performance penalties,
    since threads may wait in the queue to gain access to the *seed*. Synchronization
    is typically expensive.'
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
- en: An alternative to `Random` is `ThreadLocalRandom`, which uses a `Random` instance
    for each thread and provides protection against thread contention, since it doesn’t
    contain synchronized code or atomic operations. The downside is that `ThreadLocalRandom`
    uses an internal *seed* per thread that we cannot control or modify.
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
- en: '`SplittableRandom` is not thread-safe. Moreover, the new API consisting of
    implementations of `RandomGenerator` is not thread-safe.'
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
- en: 'This being said, a pseudo-random generator can be used in a multithread environment
    by using a thread-safe generator, or by splitting a new instance for each new
    thread. And when I say “splitting,” I mean using `SplittableGenerator.splits(long
    n)`, where `n` is the number of splits. Check out the code that uses 10 threads
    to populate a Java list with integers (each thread uses its own pseudo-random
    generator):'
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE189]'
  id: totrans-836
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: 'A snippet from the output:'
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE190]'
  id: totrans-838
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: You can also use a `JumpableGenerator` or `LeapableGenerator`. The only difference
    is that instead of `splits()`, `JumpableGenerator` uses `jumps()` and `LeapableGenerator`
    uses `leaps()`.
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-840
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter collected 37 problems related to strings, locales, numbers, and
    math, intended to mix classical must-know problems with a bunch of problems solved
    via the latest JDK features, such as text blocks and pseudo-random generators.
    If you want to explore other similar problems, then consider *Java Coding Problems,
    First Edition*, which has a similar chapter (*Chapter 1*), covering another 39
    problems.
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
- en: Leave a review!
  id: totrans-842
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Enjoying this book? Help readers like you by leaving an Amazon review. Scan
    the QR code below for a 20% discount code.
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Leave_Reivew_QR.png)'
  id: totrans-844
  prefs: []
  type: TYPE_IMG
- en: '**Limited Offer*'
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
