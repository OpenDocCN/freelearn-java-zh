- en: '1'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Text Blocks, Locales, Numbers, and Math
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter includes 37 problems covering 4 main topics: text blocks, locales,
    numbers, and mathematical operations. We will start with text blocks (elegant
    multiline strings introduced in JDK 13 (JEP 355, preview)/ JDK 15 (JEP 378, final)),
    continue with problems for creating a Java `Locale`, including localized locales
    (JDK 19’s `ofLocalizedPattern()`), and finish with problems about numbers and
    math, such as the Babylonian method for computing the square root and different
    corner cases of results overflows. The last part of the chapter is dedicated to
    JDK 17’s (JEP 356, final) new API for pseudo-random generators.'
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you’ll be up to date with all the new and cool JDK
    features added that relate to these four topics.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout this book you will find references to the first edition. The role
    of these references is to provide you with the best resources for further reading
    related to certain topics. You can successfully go through this edition even if
    you haven’t read the first one and don’t intend to.
  prefs: []
  type: TYPE_NORMAL
- en: Problems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Use the following problems to test your string manipulation, Java locales,
    and mathematical corner case programming prowess. I strongly encourage you to
    give each problem a try before you turn to the solutions and download the example
    programs:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating a multiline SQL, JSON, and HTML string**: Write a program that declares
    a multiline string (for instance, SQL, JSON, and HTML strings).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Exemplifying the usage of text block delimiters**: Write a program that exemplifies
    step-by-step how the delimiters of a text block affect the resulting string.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Working with indentation in text blocks**: Write a program that exemplifies
    different techniques to indent a text block. Explain the meaning of *incidental*
    and *essential* white spaces.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Removing incidental white spaces in text blocks**: Highlight the main steps
    of the algorithm used by the compiler to remove the *incidental* white spaces
    of a text block.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Using text blocks just for readability**: Write a program that creates a
    string looking like a text block (multiline string) but acts as a single-line
    string literal.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Escaping quotes and line terminators in text blocks**: Write a program that
    exemplifies how to handle Java escape sequences (including quotes, `\"`, and line
    terminators, `\n` and `\r`) in a text block.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Translating escape sequences programmatically**: Write a program that has
    programmatic access for translating escape sequences in a text block. Consider
    that you have a text block containing embedded escape sequences, and you have
    to pass it to a function that gets a string that must not contain such sequences.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Formatting text blocks with variables/expressions**: Write a program that
    exposes several techniques for formatting text blocks with variables/expressions.
    Comment on each technique from the readability perspective. Also, provide a **Java
    Microbenchmark Harness** (**JMH**) benchmark for these techniques.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Adding comments in text blocks**: Explain how we can add comments in a text
    block.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Mixing ordinary string literals with text blocks**: Write a program that
    mixes ordinary string literals with text blocks – for instance, via concatenation.
    Also, is an ordinary string literal and a text block equal if they have the same
    content?'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Mixing regular expression with text blocks**: Write an example of mixing
    regular expressions that have named groups with text blocks.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Checking if two text blocks are isomorphic**: Write a program that checks
    if two text blocks are isomorphic. Two strings are considered isomorphic if we
    can map every character of the first string to every character of the second string
    in a one-to-one fashion (for instance, “xxyznnxiz” and “aavurraqu” are isomorphic).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Concatenating strings vs. StringBuilder**: Write a JMH benchmark for comparing
    string concatenation (via the “`+`" operator) with the `StringBuilder` approach.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Converting int to String**: Write a program that provides several common
    techniques for converting an `int` to a `String`. Also, for the proposed solutions,
    provide a JMH benchmark.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Introducing string templates**: Explain and exemplify the usage of JDK 21’s
    (JEP 430, preview) string templates feature.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Writing a custom template processor**: Introduce an API for writing a user-defined
    template processor. Next, provide a few examples of custom template processors.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Creating a Locale**: Write a program that reveals different approaches for
    creating a `Locale`. Also, create *language ranges* and *language priority lists*.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Customizing localized date-time formats**: Write a program that exemplifies
    the usage of custom localized date-time formats.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Restoring always-strict floating-point semantics**: Explain what the `strictfp`
    modifier is and how/where to use it in a Java application.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Computing mathematical absolute value for int/long and a result overflow**:
    Write a program that exemplifies a corner case where applying the mathematical
    absolute value to an `int`/`long` leads to a result overflow. Also, provide a
    solution to this problem.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Computing the quotient of the arguments and result overflow**: Write a program
    that exemplifies a corner case where computing the quotient of the arguments leads
    to a result overflow. Also, provide a solution to this problem.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Computing the largest/smallest value that is less/greater than or equal to
    the algebraic quotient**: Write a program that relies on `java.util.Math` methods
    to compute the largest/smallest value that is less/greater than or equal to the
    algebraic quotient. Don’t forget to cover the result overflow corner case as well.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Getting integral and fractional parts from a double**: Write a program that
    exposes several techniques for getting the integral and fractional parts of a
    `double`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Testing if a double number is an integer**: Write a program that shows several
    approaches for testing if a `double` number is an integer. In addition, provide
    a JMH benchmark for the proposed solutions.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Hooking Java (un)signed integers in a nutshell**: Explain and exemplify in
    code the usage of signed/unsigned integers in Java.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Returning the flooring/ceiling modulus**: Define the *floor*/*ceil* modulus
    based on the *floor* and *ceil* operations, and exemplify the result in code lines.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Collecting all prime factors of a given number**: A prime number is a number
    divisible by itself and 1 (for instance, 2, 3, and 5 are prime numbers). Write
    a program that collects all prime factors of a given positive number.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Computing the square root of a number using the Babylonian method**: Explain
    the Babylonian method for computing the square root, elaborate a step-by-step
    algorithm for this method, and write the code based on this algorithm.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Rounding a float number to specified decimals**: Write a program that contains
    several approaches for rounding a given `float` number to specified decimals.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Clamping a value between min and max**: Provide a solution for clamping a
    given value between a given minimum and maximum.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Multiply two integers without using loops, multiplication, bitwise, division,
    and operators:** Write a program that multiplies two integers without using loops,
    multiplication, bitwise, division, and operators. For instance, start from the
    *special binomial product formula*.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Using TAU**: Explain the meaning of TAU in geometry/trigonometry, and write
    a program that solves the following problem: A circle has a circumference of 21.33
    cm. What is the radius of the circle?'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Selecting a pseudo-random number generator**: Provide a short dissertation
    about the new API for generating pseudo-random numbers introduced in JDK 17 (JEP
    356, final). Moreover, exemplify different techniques for selecting a pseudo-random
    number generator.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Filling a long array with pseudo-random numbers**: Write a program that fills
    an array of long arrays with pseudo-random numbers in a parallel and non-parallel
    fashion.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Creating a stream of pseudo-random generators**: Write a program that creates
    a stream of pseudo-random numbers and a stream of pseudo-random generators.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Getting a legacy pseudo-random generator from new ones of JDK 17**: Write
    a program that instantiates a legacy pseudo-random generator (for instance, `Random`)
    that can delegate method calls to a JDK 17 `RandomGenerator`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Using pseudo-random generators in a thread-safe fashion (multithreaded environments)**:
    Explain and exemplify the usage of pseudo-random generators in a multithreaded
    environment (for instance, using an `ExecutorService`).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The following sections describe solutions to the preceding problems. Remember
    that there usually isn’t a single correct way to solve a particular problem. Also,
    remember that the explanations shown here include only the most interesting and
    important details needed to solve the problems. Download the example solutions
    to see additional details and to experiment with the programs at [https://github.com/PacktPublishing/Java-Coding-Problems-Second-Edition/tree/main/Chapter01](https://github.com/PacktPublishing/Java-Coding-Problems-Second-Edition/tree/main/Chapter01).
  prefs: []
  type: TYPE_NORMAL
- en: 1\. Creating a multiline SQL, JSON, and HTML string
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let’s consider the following SQL multiline string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As is common knowledge, before JDK 8, we could wrap this SQL as a Java `String`
    (string literal) in several ways.
  prefs: []
  type: TYPE_NORMAL
- en: Before JDK 8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Probably the most common approach relies on straightforward concatenation via
    the well-known “`+`" operator. This way, we obtain a multiline string representation,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The compiler should be (and usually is) smart enough to internally transform
    the “`+`" operations into a `StringBuilder`/`StringBuffer` instance and use the
    `append()` method to build the final string. However, we can use `StringBuilder`
    (not thread-safe) or `StringBuffer` (thread-safe) directly, as in the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Another approach (typically not so popular as the previous two) consists of
    using the `String.concat()` method. This is an immutable operation that basically
    appends a given string at the end of the current one. Finally, it returns the
    new combined string. Trying to append `null` values results in `NullPointerException`
    (in the previous two examples, we can append `null` values without getting any
    exceptions). Chaining `concat()` calls allows us to express multiline strings,
    as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Furthermore, we have the `String.format()` method. By simply using the `%s`
    format specifier, we can concatenate multiple strings (including `null` values)
    in a multiline string, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: While these approaches are still popular these days, let’s see what JDK 8 has
    to say about this topic.
  prefs: []
  type: TYPE_NORMAL
- en: Starting with JDK 8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Starting with JDK 8, we can use the `String.join()` method to represent multiline
    strings. This method is also specialized in string concatenation, and it allows
    us to have easy readability in our example. How so? This method takes as the first
    argument a delimiter, and it uses this between the strings that will be concatenated.
    So, if we consider that `\n` is our line delimiter, then it can be specified only
    once, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Beside the `String.join()` method, JDK 8 also comes with `java.util.StringJoiner`.
    A `StringJoiner` supports a delimiter (as `String.join()`) but also supports a
    prefix and a suffix. Expressing our multiline SQL string doesn’t require a prefix/suffix;
    therefore, the delimiter remains our favorite feature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we cannot mention JDK 8 without touching on its mighty Stream API.
    More precisely, we are interested in the `Collectors.joining()` collector. This
    collector works as `String.join()`, and in our case, it looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: All the previous examples have a bunch of shortcomings in common. The most important
    of these is that none of these examples represents a truly multiline string literal,
    and the degree of readability is seriously affected by the escaping characters
    and extra quotes needed for each line demarcation. Fortunately, starting with
    JDK 13 (as a future preview) and ending with JDK 15 (as a final feature), the
    new text blocks have become the standard for representing multiline string literals.
    Let’s see how.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing text blocks (JDK 13/15)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'JDK 13 (JEP 355) offers a preview feature that aims to add support for multiline
    string literals. Over two versions, in JDK 15 (JEP 378), the text block feature
    has become final and permanent for use. But that’s enough history; let’s quickly
    see how text blocks shape our multiline SQL string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This is so cool, right?! We immediately see that the readability of our SQL
    has been restored, and we didn’t mess it up with delimiters, line terminators,
    and concatenations. The text block is concise, easy to update, and easy to understand.
    The footprint of extra code in our SQL string is zero, and the Java compiler will
    do the best to create a `String` in the most predictable way possible. Here is
    another example that embeds a piece of JSON information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'How about representing a piece of HTML as a text block? Sure, here it is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: So what is the syntax of a text block?
  prefs: []
  type: TYPE_NORMAL
- en: Hooking text blocks syntax
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The syntax of text blocks is quite simple. No bells and whistles, no complicated
    things – there are just two aspects to keep in mind:'
  prefs: []
  type: TYPE_NORMAL
- en: A text block must start with `"""` (that is, three double quotation marks) and
    a newline. We refer to this construction as the *opening delimiter*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A text block must end with `"""` (that is, three double quotation marks). The
    `"""` can be on its own line (as a new line) or at the end of the last line of
    text (as in our example). We refer to this construction as the *closing delimiter.*
    However, there is a semantic difference between these two approaches (dissected
    in the next problem).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this context, the following examples are syntactically correct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'On the other hand, the following examples are incorrect and lead to compiler
    errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: However, please consider the following best practice.
  prefs: []
  type: TYPE_NORMAL
- en: '**Important note**'
  prefs: []
  type: TYPE_NORMAL
- en: 'By looking on the previous snippets of code, we can shape a best practice for
    text blocks: use text blocks only when you have a multiline string; if the string
    fits a single line of code (as in the previous snippets), then use an ordinary
    string literal, since using text blocks doesn’t add any significant value.'
  prefs: []
  type: TYPE_NORMAL
- en: In the bundled code, you can practice all the examples from this problem on
    a piece of SQL, JSON, and HTML.
  prefs: []
  type: TYPE_NORMAL
- en: '**Important note**'
  prefs: []
  type: TYPE_NORMAL
- en: For third-party library support, please consider Apache Commons, `StringUtils.join()`,
    and Guava’s `Joiner.on()`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s focus on working with text block delimiters.
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Exemplifying the usage of text block delimiters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Remember from the previous problem, *Creating a multiline SQL, JSON, and HTML
    string*, that a text block is syntactically delimited by an opening and a closing
    delimiter, represented by three double quotation marks, `"""`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The best approach for exemplifying the usage of these delimiters consists of
    three simple steps: consider an example, inspect the output, and provide a conclusion.
    This being said, let’s start with an example that imitates some of the JEP’s examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'So by following the JEP examples, we have to align the content with the opening
    delimiter. It’s probable that this alignment style is not consistent with the
    rest of our code and is not such a good practice. What will happen with the text
    block content if we rename the `sql` variable `updateSql`, `updateOfficeByEmployeeJobTitle`,
    or something else? Obviously, in order to preserve the alignment, this will push
    our content to the right even more. Fortunately, we can shift-left the content
    without affecting the final result, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Shifting right the opening/closing delimiters themselves will not affect the
    resulting `String`. It is unlikely that you’ll have a good reason to do this,
    but just for the sake of completion, the following example produces the same result
    as the previous two examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Now, let’s see something more interesting. The opening delimiter doesn’t accept
    content on the same line, while the closing delimiter sits to the right at the
    end of the content. However, what happens if we move the closing delimiter to
    its own line, as in the following two examples?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, the resulting string contains a new line at the end of the content.
    Check the following figure (the text `-- BEFORE TEXT BLOCK –` and `-- AFTER TEXT
    BLOCK --` are just guidelines added via `System.out.println()` to help you delimit
    the text block itself; they are not necessary and not part of the text block):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.1.png](img/B19665_01_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.1: Move the closing delimiter to its own line, vertically aligned
    with the opening delimiter'
  prefs: []
  type: TYPE_NORMAL
- en: In the left figure (*A*) the closing delimiter is at the end of the content.
    However, in the right figure (*B*), we moved the closing delimiter to its own
    line, and as you can see, the resulting `String` was enriched with a new line
    at the end.
  prefs: []
  type: TYPE_NORMAL
- en: '**Important note**'
  prefs: []
  type: TYPE_NORMAL
- en: Placing the closing delimiter on its own line will append a new line to the
    final `String`. Also, pay attention that vertically aligning the opening delimiter,
    the content, and the closing delimiter to the left margin may result later in
    extra work. If the variable name is modified, then manual re-indentation is needed
    to maintain this alignment.
  prefs: []
  type: TYPE_NORMAL
- en: So pay attention to how you place the closing delimiter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Do you find this weird? Well, that’s not all! In the previous example, the
    closing delimiter was placed on its own line but vertically aligned with the opening
    delimiter. Let’s take a step forward and let’s shift-left the end delimiter, as
    in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The following figure reveals the effect of this action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.2.png](img/B19665_01_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.2: Moving the closing delimiter to its own line and shifting it to
    the left'
  prefs: []
  type: TYPE_NORMAL
- en: In the left figure (*A*), we have the closing delimiter on its own line and
    aligned with the opening delimiter. In the right figure (*B*), we have the effect
    of the previous code. Moving the closing delimiter to the left results in an additional
    indentation of the content to the right. The additional indentation depends on
    how much we shift-left the closing delimiter.
  prefs: []
  type: TYPE_NORMAL
- en: '**Important note**'
  prefs: []
  type: TYPE_NORMAL
- en: Placing the closing delimiter on its own line and shifting it to the left will
    append a new line and additional indentation to the final `String`.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, if we move the closing delimiter to its own line and shift
    it to the right, it doesn’t affect the final `String`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This code appends a new line to the final `String` but doesn’t affect indentation.
    In order to better understand the behavior of opening/closing delimiters, you
    have to explore the next problem.
  prefs: []
  type: TYPE_NORMAL
- en: 3\. Working with indentation in text blocks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Indentation in text blocks is easy to understand if we have a clear picture
    of two terms:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Incidental* (or *unessential*) white spaces – represent the meaningless white
    spaces that result from code formatting (*leading* white spaces commonly added
    by the IDE) or are added intentionally/accidentally at the end of the text (*trailing*
    white spaces)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Essential* white spaces – represent the white spaces that we explicitly add,
    which are meaningful for the final string'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In *Figure 1.3*, you can see the incidental versus essential white spaces in
    a JSON text block:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.3.png](img/B19665_01_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.3: Incidental versus essential white spaces in a JSON text block'
  prefs: []
  type: TYPE_NORMAL
- en: In the left figure, you can see the incidental versus essential white spaces
    when the closing delimiter is placed at the end of the content. In the middle
    figure, the closing delimiter was moved to its own line, while in the right figure,
    we also shifted to the left.
  prefs: []
  type: TYPE_NORMAL
- en: The incidental (unessential) white spaces are automatically removed by the Java
    compiler. The compiler removes all incidental trailing spaces (to enforce the
    same look in different text editors, which may automatically remove trailing white
    spaces) and uses a special internal algorithm (dissected in the next problem)
    to determine and remove the incidental leading white spaces. Also, it is important
    to mention that the line containing the closing delimiter is always part of this
    check (this is known as the *significant trailing line policy*).
  prefs: []
  type: TYPE_NORMAL
- en: 'The essential white spaces are preserved in the final string. Basically, as
    you can intuit from the previous figures, the essential white spaces can be added
    in two ways, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: By shifting the closing delimiter left (when this delimiter is on its own line)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By shifting the content right (by explicitly adding white spaces or by using
    helper methods dedicated to controlling indentation)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shifting the closing delimiter and/or the content
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s start with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The white spaces highlighted with the “`–`" sign represent incidental leading
    white spaces (there are no incidental trailing white spaces), while the white
    spaces highlighted with the “`+`" sign represent essential white spaces that you’ll
    see in the resulting `String`. If we shift-right the whole content while the closing
    delimiter is at the end of the content, then the explicitly added white spaces
    are considered incidental and are removed by the compiler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'However, if we move the closing delimiter to its own line (vertically aligned
    with the opening delimiter) and shift-right only the content, then we obtain essential
    white spaces that remain in the final string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, we can add the same essential white spaces by left shifting the
    closing delimiter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Moreover, we can adjust each line of text by manually adding white spaces,
    as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Next, let’s see some helper methods useful for indentation purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Using indentation methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Starting with JDK 12, we can add essential white spaces to a literal string
    via the `String.indent(int n)` method, where `n` represents the number of white
    spaces. This method can also be applied to indent the whole content of a text
    block, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Obviously, the white spaces added via `indent()` are not visible in the code
    editor of the IDE, but they are highlighted here via the “`*`" sign, just to illustrate
    the effect on the final string. However, when `indent()` is used, a new line is
    also appended, even if the closing delimiter is at the end of the content. In
    this context, moving the closing delimiter to its own line results in the same
    effect, so don’t expect to see two new lines appended. Of course, feel free to
    practice the bundled code for the real experience.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `indent()` method may be useful to align a block of content that contains
    lines of text placed at the same level of indentation, like the poem that follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'If we manually add white spaces in front of each line of the poem, then the
    compiler will remove them, so no essential white spaces could be added globally.
    We can move the closing delimiter to its own line and shift it to the left, or
    shift-right the content to obtain the desired essential white spaces. However,
    in such a case, you still need to remove the new line that is added (as a result
    of moving the closing delimiter to its own line). The easiest way to do this is
    via the JDK 14 new escape sequence, `\`. By adding this escape sequence at the
    end of a line, we instruct the compiler to suppress appending a new line character
    to that line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: While this escape sequence (`\`) is dissected in Problem 5, *Using text block
    just for readability*, let’s see a few approaches based on a string API.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before JDK 11, we can remove this line via a simple regular expression such
    as `replaceFirst("\\s++$", "")`, or rely on a third-party helper such as the Apache
    Commons `StringUtils.stripEnd()` method. However, starting with JDK 11, we can
    achieve this goal via `String.stripTrailing()`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Now, the content block is indented as a result of shifting the closing delimiter
    left, and the automatically added new line is removed thanks to the `stripTrailing()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: '**Important note**'
  prefs: []
  type: TYPE_NORMAL
- en: As well as `stripTrailing()`, JDK 11 also comes with `stripLeading()` and `strip()`.
    Also, starting with JDK 15, we have `stripIndent()`, which removes the leading
    and trailing white spaces exactly as the compiler does.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, starting with JDK 12, we can use `String.indent(int n)`, which saves
    us from adding white spaces manually:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Now, it is time to move forward and dissect the algorithm for removing incidental
    white spaces.
  prefs: []
  type: TYPE_NORMAL
- en: 4\. Removing incidental white spaces in text blocks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Removing incidental white spaces in text blocks is typically a job accomplished
    by the compiler via a special algorithm. To understand the main aspects of this
    algorithm, let’s go over it with the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: To remove the incidental leading white spaces, the compiler has to inspect all
    non-blank lines (lines containing only white spaces), so in our case, it will
    inspect 17 lines. There are 16 lines of JSON code and the closing delimiter line.
  prefs: []
  type: TYPE_NORMAL
- en: The compiler scans each of these 17 lines and counts the number of leading white
    spaces. The character used to represent the white space is not relevant in this
    count – it could be simple space, tab, and so on. They all have the same weight
    of 1, so a single white space is the same as a single tab. This is needed because
    the compiler can’t know how tab characters will be displayed in different text
    editors (for instance, a tab could be made of four or eight characters). Once
    this step of the algorithm is done, the compiler knows the exact number of leading
    white spaces for each of the inspected lines. For instance, line 1 has 4 **leading
    white spaces** (**lws**), line 2 has 6 lws, line 3 has 8 lws, and so on (check
    the previous snippet of code to see all the numbers).
  prefs: []
  type: TYPE_NORMAL
- en: '**Important note**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s quickly look at another text block best practice: Don’t mix white spaces
    and tabs in the same text block. This way, you enforce indentation consistency
    and avoid any potential irregular indentation.'
  prefs: []
  type: TYPE_NORMAL
- en: At this point, the compiler computes the minimum value of those numbers, and
    the result (in this case, 4) represents the number of incidental leading white
    spaces that should be removed from each of the 17 lines. So in the final result,
    at least one of the lines has no leading white space. Of course, the essential
    white space (an additional indentation represented via the “`+`" sign) remains
    untouched. For instance, in line 5, we have 10 lws – 4 incidental lws = 6 essential
    lws that remain untouched.
  prefs: []
  type: TYPE_NORMAL
- en: In the bundled code, you can find three more JSON examples that you can use
    to practice this algorithm. Now, we will tackle some text block readability aspects.
  prefs: []
  type: TYPE_NORMAL
- en: 5\. Using text blocks just for readability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Using text blocks just for readability can be translated as making a string
    look like a text block but act as a single-line string literal. This is especially
    useful for formatting long lines of text. For instance, we may want to have the
    following SQL string look like a text block (for readability purposes) but act
    as a single-line string literal (in the sense of being compact when we pass it
    to the database):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Starting with JDK 14, we can accomplish this goal via the new escape sequence,
    `\` (a single backslash). By adding this escape sequence at the end of a line,
    we instruct the compiler to suppress appending a new line character to that line.
    So in our case, we can express the SQL as a single-line string literal, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Pay attention to not adding any white spaces after `\` because you’ll get an
    error.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we throw this text block in a `System.out.println()`, then the output reveals
    the single-line string literal, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let’s check out another example, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, the resulting string is not exactly what we want because the essential
    white space is preserved. This means that the single-line string is sprinkled
    with sequences of spaces that we should reduce to a single space. This is where
    a regular expression can help:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Done! Now, we have a single-line SQL string that looks like a text block in
    an IDE.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s assume that we want to print on a nice background the following
    poem wrapped in a text block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Adding a background to this poem will result in something like the following
    figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.4.png](img/B19665_01_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.4: Adding a background to the poem'
  prefs: []
  type: TYPE_NORMAL
- en: '**Important note**'
  prefs: []
  type: TYPE_NORMAL
- en: The colored background is just a guideline for alignment, as white on white
    would not be legible.
  prefs: []
  type: TYPE_NORMAL
- en: Since the compiler removes the trailing white space, we will obtain something
    as shown in the left figure. Obviously, we want something as shown in the right
    figure, so we need to find a way to preserve the trailing white space as essential.
    Starting with JDK 14, we can do that via the new escape sequence, `\s`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can repeat this escape sequence for every space as follows (we add three
    white spaces to the first line and two white spaces to the last line; this way,
    we obtain a symmetrical text block):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, we can manually add white spaces and a single `\s` at the end
    of the line. This is possible because the compiler preserves any white spaces
    in front of `\s`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Done! Now, we have preserved white spaces, so when the background color is applied,
    we will obtain something as shown on the right side of *Figure 1.4*.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s focus on escaping characters.
  prefs: []
  type: TYPE_NORMAL
- en: 6\. Escaping quotes and line terminators in text blocks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Escaping double quotes is necessary only when we want to embed, in the text
    block, the sequence of three double quotes (`"""`), as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Escaping `"""` can be done with `\"""`. There is no need to write `\"\"\"`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The resulting string will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Whenever you need to embed `"` or `""`, simply do it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'So even if it works, don’t do this, since is not necessary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: However, a construction such as `""""` (where the first `"` represents a double
    quote and the last `"""` represents the closing delimiter of the text block) will
    raise an error. In such a case, you can place a space as `" """` or escape the
    double quote as `\""""`.
  prefs: []
  type: TYPE_NORMAL
- en: 'By definition, a text block represents string literals spanning multiple lines,
    so there is no need to explicitly escape line terminators (new lines), such as
    `\n`, `\r`, or `\f`. Just add new lines of text in the text block, and the compiler
    will take care of line terminators. Of course, this doesn’t mean that using them
    doesn’t work. For instance, obtaining a text block that has interleaved blank
    lines can be done via `\n`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Using escape sequences (for example, `\b`, `\t`, `\r`, `\n`, `\f`, and so on)
    in text blocks can be done exactly like they would be done in old-school string
    literals. For instance, there is nothing wrong here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'However, the same thing can be obtained without escape sequences (consider
    `\t` (tab) as eight white spaces):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: You can practice all these examples in the bundled code.
  prefs: []
  type: TYPE_NORMAL
- en: '**Important note**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s quickly look at another text block best practice: Adding escape sequences
    explicitly may negatively affect the readability of the text block, so use them
    carefully and only when they are really needed. For instance, explicit `\n` and
    `\"` are rarely necessary for text blocks.'
  prefs: []
  type: TYPE_NORMAL
- en: Speaking about the `\n` line terminator (new line), it is important to be aware
    of the following note.
  prefs: []
  type: TYPE_NORMAL
- en: '**Important note**'
  prefs: []
  type: TYPE_NORMAL
- en: Probably the most used line terminator in Java is `\n` (Unix, **Line Feed**
    (**LF**)), but we can also use `\r` (Windows, **Carriage Return** (**CR**)) or
    `\n\r` (Windows, **Carriage Return Line Feed** (**CRLF**)). No matter which of
    these we prefer, Java text blocks always use `\n` (LF). First, the compiler normalizes
    all line breaks that are not added explicitly via escape sequences to `\n` (LF).
    Second, after the normalization of line terminators and managed indentation, the
    compiler handles all the explicit escape sequences (`\n` (LF), `\f` (FF), `\r`(CR),
    and so on), as in any string literal. Practically, this allows us to copy into
    a text block a legacy Java string containing escape sequences, obtaining the expected
    result without further modifications.
  prefs: []
  type: TYPE_NORMAL
- en: If you ever need to use the line terminator specific to your operating system,
    then you have to explicitly replace it after text block normalization via `String.replaceAll()`,
    as `String::replaceAll("\n", System.lineSeparator()`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Embedding in a text block an escape sequence can be done as usual via the `\\`
    construction. Here is an example of embedding the `\"` escape sequence as `\\"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: You can check the output in the bundled code. Now, let’s see how we can translate
    escape sequences programmatically.
  prefs: []
  type: TYPE_NORMAL
- en: 7\. Translating escape sequences programmatically
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We already know that the compiler is responsible for the translation of escape
    sequences, and most of the time, there is no need to explicitly interfere in this
    process. But there are cases when we may need programmatic access to this process
    (for instance, to explicitly un-escape a string before passing it to a function).
  prefs: []
  type: TYPE_NORMAL
- en: Starting with JDK 15, we can accomplish this via `String.translateEscapes()`,
    which is capable of un-escape sequences such as `\t`, `\n`, `\b`, and so on, and
    octal numbers (`\0`–`\377`). However, this method doesn’t translate Unicode escapes
    (`\uXXXX`).
  prefs: []
  type: TYPE_NORMAL
- en: 'We can perform an equality test in order to reveal how `translateEscapes()`
    works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: As you can already intuit, the result is *yes*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s assume that we want to use an external service that prints addresses
    on parcels. The function responsible for this task gets a string representing
    the address without containing escape sequences. The problem is that our customer’s
    addresses pass through a formatting process that patches them with escape sequences,
    as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The following figure reveals how the resulting string will look if we don’t
    translate escapes of the address (left side) and how it will look if we do (right
    side). Of course, our goal is to obtain the address from the right side and send
    it to print:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.5.png](img/B19665_01_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.5: We want the string from the right side'
  prefs: []
  type: TYPE_NORMAL
- en: 'Translation of escapes can be done programmatically via `String.translateEscapes()`,
    right before sending the result to the external service. Here is the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Now, `translatedAddress` can be passed to the external printing service. As
    an exercise, you can think about how to exploit this method to write a parser
    of source code, provided via Java or another programming language.
  prefs: []
  type: TYPE_NORMAL
- en: '**Important note**'
  prefs: []
  type: TYPE_NORMAL
- en: Similar results (of course, read the documentation to obtain the fine-grained
    information) can be obtained via Apache Commons’ Lang third-party library support.
    Please consider `StringEscapeUtils.unescapeJava(String)`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s talk about embedding expressions in text blocks.
  prefs: []
  type: TYPE_NORMAL
- en: 8\. Formatting text blocks with variables/expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Java, it is a common practice to format string literals with variables/expressions
    to obtain dynamic strings. For instance, we can create a dynamic piece of XML
    string via the following well-known concatenation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Of course, this tiny construction has serious issues from a readability perspective.
    XML code is human-readable if it is formatted and indented accordingly; otherwise,
    is really hard to follow its hierarchy. So, can we express this XML to look like
    the following figure?
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.6.png](img/B19665_01_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.6: Formatted XML'
  prefs: []
  type: TYPE_NORMAL
- en: 'Sure we can! By using some escape sequences (for instance, `\n`, `\t`, and
    `\s`), white spaces, and so on, we can construct a `String` to look like *Figure
    1.6*. However, it would be better to express this concatenation via a text block.
    Maybe we can achieve the same readability in the IDE’s code editor and console
    (at runtime). A possible approach looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'So we can concatenate text blocks exactly like string literals via the “`+`"
    operator. Cool! The output of this code corresponds to the left side of *Figure
    1.6*. On the other hand, the right side of *Figure 1.6* can be achieved as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Well, while the resulting string looks good in both cases, we cannot say the
    same thing about the code itself. It still has a low readability rate.
  prefs: []
  type: TYPE_NORMAL
- en: '**Important note**'
  prefs: []
  type: TYPE_NORMAL
- en: 'By looking at the previous two snippets of code, we can easily conclude a best
    practice for text blocks: use them only when they significantly contribute to
    code clarity and the readability of multiline strings. Also, avoid declaring text
    blocks in complex expressions (for instance, in lambda expressions), since they
    may affect the readability of the entire expression. It is better to extract text
    blocks separately in static variables and refer to them in complex expressions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try another approach. This time, let’s use a `StringBuilder` to obtain
    the result from the left side of *Figure 1.6*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, obtaining the result from the right side of *Figure 1.6* can be done
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: So we can use text blocks in `StringBuilder`/`StringBuffer` exactly as we use
    string literals. While the resulting string corresponds to the examples from *Figure
    1.6*, the code itself is still unsatisfactory from the readability perspective.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s give it another try via the JDK 1.4, `MessageFormat.format()`. First,
    let’s shape the example from *Figure 1.6*, left side:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'And obtaining the result from *Figure 1.6* (right side) can be done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The text blocks and `MessageFormat.format()` combo is a winning approach. The
    code readability is obviously better. But, let’s go further, and let’s give it
    a try in JDK 5 `String.format()`. As usual, *Figure 1.6* (left side) is first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'And obtaining the result from *Figure 1.6* (right side) can be done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'The text blocks and `String.format()` combo is another winning approach but
    is not the latest feature that we can exploit. Starting with JDK 15, `String.format()`
    has a more convenient companion named `formatted()`. Here is `String.formatted()`
    at work to reproduce *Figure 1.6* (left side):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'And obtaining the result from *Figure 1.6* (right side) can be done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: That is the best we can do. We managed to achieve the same level of readability
    in the IDE’s code editor and runtime for a text block containing dynamic parts
    (variables). Cool, isn’t it?!
  prefs: []
  type: TYPE_NORMAL
- en: From the performance perspective, you can find a benchmark of these approaches
    in the bundled code. In the following figure, you can see the results of this
    benchmark on an Intel^® Core^™ i7-3612QM CPU @ 2.10GHz machine with Windows 10,
    but feel free to test it on different machines, since the results are highly dependent
    on the machine.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.7.png](img/B19665_01_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.7: Benchmark results'
  prefs: []
  type: TYPE_NORMAL
- en: Conforming to these results, concatenation via the “`+`" operator is the fastest,
    while the `MessageFormat.format()` is the slowest.
  prefs: []
  type: TYPE_NORMAL
- en: 9\. Adding comments in text blocks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Question: Can we add comments in text blocks?'
  prefs: []
  type: TYPE_NORMAL
- en: 'Official answer (according to the Java Language Specification): The lexical
    grammar implies that comments do not occur within character literals, string literals,
    or text blocks.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You might be tempted to try something like this, thinking it’s a quick hack,
    but I really don’t recommend it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Short answer: No, we cannot have comments in text blocks.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s move on and talk about mixing ordinary string literals with text blocks.
  prefs: []
  type: TYPE_NORMAL
- en: 10\. Mixing ordinary string literals with text blocks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before mixing ordinary string literals with text blocks, let’s consider the
    following statement: How different is an ordinary string literal from a text block?
    We can answer this question via the following snippet of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we know that there are no major differences in how ordinary string
    literals and text blocks are treated internally, we can be confident to mix them
    in a simple concatenation (basically, a text block can be used anywhere an ordinary
    string literal can be used):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Moreover, since a text block returns a `String`, we can use the entire arsenal
    of methods that we use for ordinary string literals. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Also, as you just saw in *Problem 8*, *Formatting text blocks with variables/expressions*,
    text blocks can be used and mixed with ordinary string literals in `StringBuilder`(`Buffer`),
    `MessageFormat.format()`, `String.format()`, and `String.formatted()`.
  prefs: []
  type: TYPE_NORMAL
- en: 11\. Mixing regular expression with text blocks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Regular expressions can be used with text blocks. Let’s consider a simple string,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'So here we have a name (Mark Janson) and some details about his address, delimited
    by a semicolon (`;`). It is a common scenario to pass such strings through regular
    expressions and extract the information as named groups. In this example, we can
    consider five named groups as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`name`: should contain the person’s name (Mark Janson)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`address`: should contain the person’s street information (243 West Main St)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`city`: should contain the person’s city (Louisville)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`zip`: should contain the city’s zip code (40202)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`country`: should contain the country’s name (USA)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A regular expression that can match these named groups may look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a single-line string, so we can use it via the `Pattern` API, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'However, as you can see, writing our regex like this has a serious impact on
    readability. Fortunately, we can employ text blocks to solve this issue, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: This is more readable, right? The only thing that we should take care of is
    to use the JDK 14 new escape sequence, `\` (a single backslash), to remove the
    trailing line feed at the end of each line.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, you can simply match the address and extract the named groups, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want just to extract the names of the groups, then you can rely on JDK
    20’s `namedGroups()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Actually, `namedGroups()` returns an unmodifiable `Map<String, Integer>`, where
    the key is the group name and the value is the group number. Furthermore, JDK
    20 has also added the `hasMatch()` method, which returns `true` if the matcher
    contains a valid match from a previous match or find operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Note that `hasMatch()` will not attempt to trigger a match against the pattern
    as `matches()` does. When you need to check for valid matches in different places
    of your code, `hasMatch()` is preferable, since it will not perform matches. So,
    you can call `matches()` once, and in subsequent checks for valid matches, just
    call `hasMatch()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Moreover, if you just need to extract the input subsequence captured for each
    named group by a given delimiter, then you can rely on JDK 21’s `splitWithDelimiters(CharSequence
    input, int limit)`. For instance, our string can be split by a semicolon (regex,
    `;+`), as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'The returned array contains the extracted data and the delimiters, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: The second argument of `splitWithDelimiters()` is an integer representing how
    many times to apply the regex. If the `limit` argument is 0, then the pattern
    will be applied as many times as possible, and the trailing empty strings, whether
    substrings or delimiters, will be discarded. If it is positive, then the pattern
    will be applied, at most, the `limit` - 1 times, and if it is negative, the pattern
    will be applied as many times as possible.
  prefs: []
  type: TYPE_NORMAL
- en: 12\. Checking if two text blocks are isomorphic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Two text blocks are isomorphic if the resulting strings are isomorphic. Two
    string literals are considered isomorphic if we can map every character of the
    first string to every character of the second string in a one-to-one fashion.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, consider that the first string is “`abbcdd`" and the second string
    is “`qwwerr`". The one-to-one character mapping is shown in *Figure 1.8*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.7.png](img/B19665_01_08.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.8: One-to-one character mapping between two strings'
  prefs: []
  type: TYPE_NORMAL
- en: So as you can see in *Figure 1.8*, character “a” of the first string can be
    replaced by character “q” of the second string. Moreover, character “b” of the
    first string can be replaced by character “w” of the second string, character
    “c” by character “e”, and character “d” by character “r”. Obviously, vice versa
    is also true. In other words, these two strings are isomorphic.
  prefs: []
  type: TYPE_NORMAL
- en: How about the strings “aab” and “que”? These two strings are not isomorphic
    because “a” cannot be mapped to both “q” and “u”.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we extrapolate this logic to text blocks, then *Figure 1.9* is exactly what
    we need:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.8.png](img/B19665_01_09.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.9: Two isomorphic text blocks'
  prefs: []
  type: TYPE_NORMAL
- en: Two text blocks are isomorphic if their string lines are isomorphic in a one-to-one
    fashion. Moreover, notice that essential white spaces and **Line Terminators**
    (**LF**) should be mapped as well, while incidental leading/trailing white spaces
    are ignored.
  prefs: []
  type: TYPE_NORMAL
- en: 'The algorithm for ordinary string literals and text blocks is exactly the same,
    and it relies on *hashing* (more details about this topic are available in *Example
    6*: *Hash table* in the *The Complete Coding Interview Guide in Java* book) and
    consists of the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Check if the two text blocks (`s1` and `s2`) have the same length. If their
    lengths differ, then the text blocks are not isomorphic.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an empty map that will store mappings of the characters from `s1` (as
    keys) to those of `s2` (as values).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pick up the first/next character from `s1` (`chs1`) and `s2` (`chs2`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check if `chs1` is present as a key in the map.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If `chs1` is present in the map as a key, then it has to be mapped to a value
    from `s2` that is equal to `chs2`; otherwise, the text blocks are not isomorphic.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If `chs1` is not present in the map as a key, then the map shouldn’t contain
    `chs2` as a value; otherwise, the text blocks are not isomorphic.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If `chs1` is not present in the map as a key and the map doesn’t contain `chs2`
    as a value, then put (`chs1` and `chs2`) in the map – `chs1` as a key and `chs2`
    as a value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat step 3 until the entire text block (`s1`) is processed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the entire text block (`s1`) was processed, then the text blocks are isomorphic.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In code lines, this O(n) algorithm can be expressed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Done! You can practice this example in the bundled code. This was the last problem
    covering text block topics. It is time to move on and discuss string concatenation.
  prefs: []
  type: TYPE_NORMAL
- en: 13\. Concatenating strings versus StringBuilder
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Check out the following plain string concatenation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: We know that the `String` class is immutable (a created `String` cannot be modified).
    This means that creating `str12` requires an intermediary string that represents
    the concatenation of `str1` with white space. So after `str12` is created, we
    know that `str1 + " "` is just noise or garbage, since we cannot refer to it further.
  prefs: []
  type: TYPE_NORMAL
- en: In such scenarios, the recommendation is to use a `StringBuilder`, since it
    is a mutable class and we can append strings to it. So this is how the following
    statement was born:In Java, don’t use the “`+`" operator to concatenate strings!
    Use `StringBuilder`, which is much faster.
  prefs: []
  type: TYPE_NORMAL
- en: Have you heard this statement before? I’m pretty sure you have, especially if
    you still run your applications on JDK 8 or even on a previous release. Well,
    this statement is not a myth, and it was true for sure at some moment in time,
    but is it still valid in the era of smart compilers?
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, consider the following two snippets of code that represent a
    simple concatenation of strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.10.png](img/B19665_01_10.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.10: String concatenation vs. StringBuilder'
  prefs: []
  type: TYPE_NORMAL
- en: In JDK 8, which approach (from *Figure 1.10*) is better?
  prefs: []
  type: TYPE_NORMAL
- en: JDK 8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s inspect the bytecode produced by these two snippets of code (use `javap
    -c -p` or Apache Commons **Byte Code Engineering Library** (**BCEL**); we have
    used the BCEL). The `concatViaPlus()` bytecode looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.11.png](img/B19665_01_11.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.11: JDK 8 bytecode of concatViaPlus()'
  prefs: []
  type: TYPE_NORMAL
- en: The JDK 8 compiler is smart enough to use a `StringBuilder` under the hood to
    shape our concatenation via the “`+`" operator. If you check the bytecode (skipped
    here for brevity) generated from `concatViaStringBuilder()`, then you’ll see something
    more or less similar to *Figure 1.11*.
  prefs: []
  type: TYPE_NORMAL
- en: 'In JDK 8, the compiler knows when and how to optimize the bytecode via `StringBuilder`.
    In other words, the explicit usage of `StringBuilder` doesn’t come with a significant
    benefit over plain concatenation via the “`+`" operator. There are many simple
    cases where this statement applies. What does a benchmark have to say about this?
    Check out the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.12.png](img/B19665_01_12.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.12: JDK 8 benchmark concatViaPlus() versus concatViaStringBuilder()'
  prefs: []
  type: TYPE_NORMAL
- en: Obviously, concatenation via the “`+`" operator has won this game. Let’s repeat
    this logic for JDK 11.
  prefs: []
  type: TYPE_NORMAL
- en: JDK 11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'JDK 11 produces the following bytecode for `concatViaPlus()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.13.png](img/B19665_01_13.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.13: JDK 11 bytecode of concatViaPlus()'
  prefs: []
  type: TYPE_NORMAL
- en: We can immediately observe a big difference here. This time, the concatenation
    is accomplished via a call to `invokedynamic` (this is a dynamic call), which
    acts as a delegator for our code. Here, it delegates the code to `makeConcatWithConstants()`,
    which is a method of the `StringConcatFactory` class. While you can find this
    in the JDK documentation, pay attention that this class API was not created to
    be called directly. This class was specially created and designed to serve bootstrap
    methods for `invokedynamic` instructions. Before going further, let’s look at
    an important note that you should consider.
  prefs: []
  type: TYPE_NORMAL
- en: '**Important note**'
  prefs: []
  type: TYPE_NORMAL
- en: The `invokedynamic` delegates/passes our concatenation code to be solved by
    code that is not part of the bytecode (this is why we cannot see the actual code
    (instructions) that solve our code). This is extremely powerful because it allows
    the Java engineers to continue the optimization process of the concatenation logic,
    while we can take advantage of it by simply moving to the next JDK. The code doesn’t
    even need to be recompiled to take advantage of further optimizations.
  prefs: []
  type: TYPE_NORMAL
- en: '**Fun fact**: The *indify* term comes from `invokedynamic`, also known as *indy*.
    It was introduced in JDK 7 and is used in JDK 8 lambda implementations. Since
    this instruction was quite useful, it becomes a solution for many other things,
    including JEP 280: *Indify String Concatenation*, introduced in JDK 9\. I preferred
    to use it here with JDK 11, but this feature is available starting with JDK 9+,
    so you can give it a try in JDK 17 or 20, for example.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In a nutshell, `invokedynamic` works like this:'
  prefs: []
  type: TYPE_NORMAL
- en: The compiler appends an `invokedynamic` call at the point of concatenation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `invokedynamic` call first executes the bootstrap method `makeConcat`[`WithConstants`].
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `invokedynamic` method calls `makeConcat`[`WithConstants`], which is a bootstrap
    method meant to call the actual code responsible for concatenation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `makeConcat`[`WithConstants`] uses an internal strategy to determine the
    best method of solving the concatenation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The method that fits the best is called, and the concatenation logic takes place.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This way, JEP 280 adds great flexibility, since JDK 10, 11, 12, 13, and so on
    can use different strategies and methods to accommodate string concatenation in
    the best possible way for our context.
  prefs: []
  type: TYPE_NORMAL
- en: 'How about the bytecode of `concatViaStringBuilder()`? This method doesn’t take
    advantage of `invokeddynamic` (it relies on the classic `invokevirtual` instruction),
    as you can see here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.14.png](img/B19665_01_14.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.14: JDK 11 bytecode of concatViaStringBuilder()'
  prefs: []
  type: TYPE_NORMAL
- en: 'I’m sure that you’re curious about which bytecode performs better, so here
    are the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.15.png](img/B19665_01_15.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.15: JDK 11, benchmark concatViaPlus() versus concatViaStringBuilder()'
  prefs: []
  type: TYPE_NORMAL
- en: The results of these benchmarks were obtained on an Intel^® Core^™ i7-3612QM
    CPU @ 2.10GHz machine with Windows 10, but feel free to test it on different machines
    and different JDK versions, since the results are highly dependent on the machine.
  prefs: []
  type: TYPE_NORMAL
- en: Again, the `concatViaPlus()` wins this game. In the bundled code, you can find
    the complete code for this example. Moreover, you’ll find the code for inspecting
    bytecode and benchmarking the concatenation in a loop via the “`+`" operator and
    `StringBuilder`. Give it a spin!
  prefs: []
  type: TYPE_NORMAL
- en: 14\. Converting int to String
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As usual, in Java, we can accomplish a task in multiple ways. For instance,
    we can convert an `int` (primitive integer) to `String` via `Integer.toString()`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can accomplish this task via a quite common hack (the code
    reviewer will raise his eyebrow here), consisting of concatenating an empty string
    with the integer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '`String.valueOf()` can also be used as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'A more esoteric approach via `String.format()` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'These methods also work for a boxed integer and, therefore, for an `Integer`
    object. Since boxing and unboxing are costly operations, we strive to avoid them
    unless they are really necessary. However, you never know when an unboxing operation
    may sneak “behind the scenes” and ruin the performance of your application. To
    verify this statement, imagine that, for each of the previous methods, we also
    have its equal getting an `Integer` instead of an `int`. Here is one of them (the
    rest were skipped for brevity):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Benchmarking all these methods results in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.16.png](img/B19665_01_16.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.16: The results of benchmarking int to String conversion'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two crystal-clear conclusions that we can derive from here:'
  prefs: []
  type: TYPE_NORMAL
- en: Using `String.format()` is very slow, and it should be avoided for `int` and
    `Integer`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All solutions that use an `Integer` are slower than those using an `int` primitive.
    So avoid unnecessary unboxing, even for such simple cases, since they may cause
    serious performance penalties.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The results of these benchmarks were obtained on an Intel^® Core^™ i7-3612QM
    CPU @ 2.10GHz machine with Windows 10, but feel free to test it on different machines,
    since the results are highly dependent on the machine.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s change the topic and talk about Java locales.
  prefs: []
  type: TYPE_NORMAL
- en: 15\. Introducing string templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Until JDK 21, Java allows us to perform string composition for SQL, JSON, XML,
    and so on via different approaches, covered earlier in *Problem 8*. In that problem,
    you can see how to use text blocks and embedded expressions via simple concatenation,
    using the plus (`+`) operator, `StringBuilder.append()`, `String.format()`, `formatted()`,
    and so on. While using the plus (`+`) operator and `StringBuilder.append()` can
    be cumbersome and affect readability, the `String.format()` and `formatted()`
    may cause type mismatches. For instance, in the following example, it is quite
    easy to mess up the data types (`LocalDate`, `double`, and `String`) and the format
    specifiers (`%d`, `%s`, and `%.2f`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: Moreover, any of these approaches doesn’t cover input validity (as we don’t
    know if the expressions are valid) and security issues (injections, which commonly
    affect SQL strings).
  prefs: []
  type: TYPE_NORMAL
- en: Starting with JDK 21, we can address these issues via *string templates* (JEP
    430).
  prefs: []
  type: TYPE_NORMAL
- en: What’s a string template?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'String templates (template expressions) are a mechanism introduced as a preview
    feature in JDK 21 that can help us perform string interpolation efficiently and
    safely. This feature consists of three parts, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: A template processor (`RAW`, `STR`, `FMT`, user-defined, and so on)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A dot character
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A string template containing the embedded expression(s) as `\{expression}`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RAW`, `STR`, and `FMT` are the three *template processors* provided by JDK
    21, but as you’ll see, we can write our own template processors as well.'
  prefs: []
  type: TYPE_NORMAL
- en: A *template processor* takes a string literal and the proper expressions, and
    it is capable of validating and interpolating it in a final result, which can
    be a string or other domain-specific object (for instance, a JSON object). If
    the template processor cannot successfully create the result, then an exception
    may be thrown.
  prefs: []
  type: TYPE_NORMAL
- en: The STR template processor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `STR` template processor is available as a `static` field in `java.lang.StringTemplate`.
    Its goal is to serve simple string concatenation tasks. For instance, we can rewrite
    the previous example using `STR`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have three embedded expressions (`\{fiscalDate.getYear()}`, `\{employeeCode}`,
    and `\{value}`) that `STR` will process in order to obtain the final string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the `STR` processor has replaced every embedded expression with
    the string value of that expression. The returned result is a `String`, and we
    can use any number of embedded expressions. If the expression is large, then you
    can split it in your IDE across multiple lines without introducing new lines in
    the final result.
  prefs: []
  type: TYPE_NORMAL
- en: The FMT template processor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the previous example, we have the `\{value}` embedded expression, which
    is evaluated by `STR` to 4552.2367\. This is correct, but we may like to format
    this value with two decimals, as 4552.24\. In such cases, we need the `FMT` processor,
    which is available as a `static` field in `java.util.FormatProcessor` and is capable
    of interpreting the format specifiers present in embedded expressions (`STR` cannot
    do that). So using `FMT` to rewrite our example can be done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice how the format specifier was added to the embedded expression `(%.2f\{value}`)
    before the backslash character. This will result in the following string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: In the same manner, you can use any other format specifier. `FMT` will take
    each of them into account in order to return the expected result.
  prefs: []
  type: TYPE_NORMAL
- en: The RAW template processor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `RAW` template processor is available as a `static` field of `java.lang.StringTemplate`.
    Calling `RAW` will return a `StringTemplate` instance that can be used later.
    For instance, here is a `StringTemplate` that we have extracted separately using
    `RAW`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we can use `templateRaw` repeatedly, as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'The `\{templateRaw.interpolate()}` expression calls the `interpolate()` method,
    which is responsible for processing the string defined in `templateRaw`. It is
    like calling `interpolate()`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'The final result is the following string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: The employee code is evaluated to an RN4555 string.
  prefs: []
  type: TYPE_NORMAL
- en: 'The character sequences that precede an embedded expression and the character
    sequence following the last embedded expression are known as *fragments*. If the
    string template begins with an embedded expression, then its fragment is zero-length.
    The same is true for directly adjacent embedded expressions. For instance, the
    fragments of `templateRaw` (`"employee_nr": "\{employeeCode}",`) are `"employee_nr":
    "` and `",`. We have access to these fragments as a `List<String>` via the `fragments()`
    method.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'Moreover, getting the results of the embedded expressions as a `List<Object>`
    can be done via the `values()` methods, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: For `templateRaw`, this list will contain a single entry, RN4555.
  prefs: []
  type: TYPE_NORMAL
- en: In the bundled code, you can find more examples, including using `STR`, `FMT`,
    and `RAW` with simple strings (not text blocks).
  prefs: []
  type: TYPE_NORMAL
- en: 16\. Writing a custom template processor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The built-in `STR` and `FMT` can return only `String` instances and cannot
    throw exceptions. However, both of them are actually instances of the functional
    interface `StringTemplate.Processor<R,E extends Throwable>`, which defines the
    `process()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: By implementing the `Processor<R,E extends Throwable>` interface, we can write
    custom template processors that return `R` (any result type), not just `String`.
    Moreover, if something goes wrong during processing (for instance, validation
    issues are present), we can throw checked exceptions (`E extends Throwable`).
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, let’s assume that we need to interpolate strings with expressions
    representing phone numbers. So we accept only the expressions that are phone numbers,
    matching the following regular expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, the result is a `String`, so our custom template processor can
    be written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can test our processor with a simple message, as follows (here, we
    use valid phone numbers):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'The resulting string is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, our processor relies on a `StringBuilder` to obtain the final
    string. However, we can use the `StringTemplate.interpolate(List<String> fragments,
    List<?> values)` method as well and obtain a cleaner solution, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'However, as we said earlier, a template processor can return any type (`R`).
    For instance, let’s assume that we shaped our previous message as a JSON string,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, we want to interpolate strings with variables representing phone
    numbers and return a JSON object. More precisely, we want to return an instance
    of `com.fasterxml.jackson.databind.JsonNode` (here, we use the Jackson library,
    but it can be GSON, JSON-B, and so on):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, the returned type is `JsonNode`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: In the bundled code, you can also find an example that uses a lambda expression
    for writing the previous custom template processor. Moreover, you can find an
    example in which instead of throwing an exception for invalid expressions we just
    replace the invalid values with a default value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Please note, a recent article *Update on String Templates (JEP 459)*, which
    you can find at: [https://mail.openjdk.org/pipermail/amber-spec-experts/2024-March/004010.html](https://mail.openjdk.org/pipermail/amber-spec-experts/2024-March/004010.html),
    suggests that processors, used in this way, will ultimately be replaced with simpler
    method calls.'
  prefs: []
  type: TYPE_NORMAL
- en: 17\. Creating a Locale
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A Java `Locale` (`java.util.Locale`) represents an object that wraps information
    about a specific geographical, political, or cultural region – that is, an object
    useful for internationalization purposes. A `Locale` is typically used in conjunction
    with `DateFormat`/`DateTimeFormatter` to represent date-time in a format specific
    to a country, with `NumberFormat` (or its subclass, `DecimalFormat`) used to represent
    numbers in a format specific to a country (for instance, to represent an amount
    of money in a specific currency), or with `MessageFormat` to create formatted
    messages for a specific country.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the most popular locales, Java provides a list of constants (for instance,
    `Locale.GERMANY`, `Locale.CANADA`, and so on). For locales that are not on this
    list, we have to use the formats defined in several RFCs. Most commonly, we use
    the *language* pattern (for instance, `ro` for Romanian) or the *language_country*
    pattern (for instance, `ro_RO` for Romania, `en_US` for United States, and so
    on). Sometimes, we may need the *language_country _variant* pattern, where *variant*
    is useful to map additional functionalities added by software vendors, such as
    browsers or operating systems (for instance, `de_DE_WIN` is a locale for German
    speakers in Germany, for Windows). However, two locales are treated as non-conforming:
    `ja_JP_JP` (which represents Japanese, as used in Japan) and `th_TH_TH` (which
    represents Thai, as used in Thailand, including Thai digits).'
  prefs: []
  type: TYPE_NORMAL
- en: 'While you can learn more about `Locale` from its comprehensive documentation,
    let’s mention that, before JDK 19, we can create a `Locale` via one of its three
    constructors – most commonly, via `Locale(String language, String country)`, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, if your `Locale` has already a defined constant, you can simply
    embed that constant where you need it in code or simply declare a `Locale`, as
    follows (here, for Germany):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'Another approach relies on `Locale.Builder` via a chain of setters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, this can be done via `Locale.forLanguageTag()` to follow the
    IETF BCP 47 standard language tags (which can be useful to represent complex tags
    such as China-specific Chinese, Mandarin, Simplified script, and “`zh-cmn-Hans-CN`"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'Moreover, Java supports *language ranges*. This means that we can define a
    set of language tags that share some specific attributes. For instance, “`de-*`"
    represents a language range to recognize German in any region:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous `Locale.LanguageRange()` constructor takes two arguments: the
    language range and its weight (1.0, 0.5, 0.0). Typically, this weight reveals
    the user’s preference (1.0 at the highest and 0.0 at the lowest). The weight is
    useful for defining *priority lists* as follows (we prefer Castilian Spanish (Spain)
    over Mexican Spanish and over Brazilian Portuguese):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: Pay attention to defining a valid string of preferences so the `parse()` method
    can work.
  prefs: []
  type: TYPE_NORMAL
- en: 'Starting with JDK 19, the three constructors of `Locale` have been deprecated,
    and we can rely on three static `of()` methods instead. The equivalent of the
    previous code via the proper `of()` method is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are two more examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'Using a `Locale` is straightforward. Here is an example of using the previous
    `ro` to format date-time via `DateFormat` for Romania and Italy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: In the next problem, we continue the locale journey.
  prefs: []
  type: TYPE_NORMAL
- en: 18\. Customizing localized date-time formats
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Starting with JDK 8, we have a comprehensive date-time API containing classes
    such as `LocalDate`, `LocalTime`, `LocalDateTime`, `ZonedDateTime`, `OffsetDateTime`,
    and `OffsetTime`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can easily format the date-time output returned by these classes via `DateTimeFormatter.ofPattern()`.
    For instance, here, we format a `LocalDateTime` via the `y-MM-dd HH:mm:ss` pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: More examples are available in the bundled code.
  prefs: []
  type: TYPE_NORMAL
- en: How about customizing our format based on a given locale – for instance, Germany?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'We accomplish this via `ofLocalizedDate()`,`ofLocalizedTime()`, and `ofLocalizedDateTime()`,
    as in the following examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'We may also use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'A localized date, time, or date-time formatter supports four format styles:'
  prefs: []
  type: TYPE_NORMAL
- en: '`FULL`: Format using all details.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LONG`: Format using lots of detail but not all.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MEDIUM`: Format with some detail.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SHORT`: Format as short as possible (typically numeric).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Depending on the combination between the localized artifact and format style,
    the code may end up with an exception such as *DateTimeException: Unable to extract….*.
    If you see such an exception, then it is time to consult the following table,
    which provides the accepted combos:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.17.png](img/B19665_01_17.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.17: Format style of a localized date, time, and date-time'
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, starting with JDK 19, we can use `ofLocalizedPattern(String pattern)`
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: We can pass any pattern that is shown in *Figure 1.18*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.17.png](img/B19665_01_18.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.18: Building a pattern for ofLocalizedPattern(String pattern)'
  prefs: []
  type: TYPE_NORMAL
- en: 'This being said, let’s change the current locale to Romania:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s also have some examples of `ofLocalizedPattern()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: 'And even more:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: You can practice all these examples in the bundled code. Moreover, in the bundled
    code, you can find an application that uses locales and `NumberFormat` to format
    a royalty amount for different locales (currencies).
  prefs: []
  type: TYPE_NORMAL
- en: 19\. Restoring Always-Strict Floating-Point semantics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Floating-point calculations are not easy! Even some simple arithmetical properties
    don’t apply to such calculations. For instance, floating-point addition or multiplication
    is not associative. In other words (x + y) + z is not equal to x + (y + z) where
    x, y, and z are real numbers. A quick example to test the associativity of multiplication
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: This means that floating-point arithmetic is a methodical approximation of real
    arithmetic. Computers have to approximate because of some limitations. For instance,
    exact floating-point outputs become very large quite quickly. Moreover, the exact
    inputs are not known, so with inexact inputs, it is difficult to obtain exact
    outputs.
  prefs: []
  type: TYPE_NORMAL
- en: To solve this problem, Java has to adopt a *rounding policy*. In other words,
    Java has to use a special kind of function capable of mapping from a real value
    to a floating-point value. These days, Java uses the so-called *round to nearest
    policy*. This policy attempts to round an inexact value to a value that is nearest
    to the *infinitely precise result*. In the case of equality (where the representable
    values are equally near to the inexact value), the value having the zero-most
    significant bit is the winner.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, floating-point calculations may produce different outputs on different
    platforms. In other words, running floating-point calculations on different chip
    architectures (for instance, 16-, 32-, or 64-bit processors) may lead to different
    results. Java solves this issue via the `strictfp` modifier. This keyword follows
    the IEEE 754 standards for floating-point calculations and was introduced in JDK
    1.2.
  prefs: []
  type: TYPE_NORMAL
- en: '**Important note**'
  prefs: []
  type: TYPE_NORMAL
- en: The `strictfp` modifier represents all intermediate values in single/double-precision
    conforming to IEEE 754\. However, some hardware-specific issues caused `strictfp`
    to become optional in JDK 1.2.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s assume that we have to implement a scientific calculator. Obviously,
    our calculator has to provide consistent results across platforms, so we rely
    on `strictfp`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: The `strictfp` modifier used with the class guarantees that all member methods
    of this class take advantage of its effect. Now, we have consistent results across
    platforms. You can find this example in the bundled code.
  prefs: []
  type: TYPE_NORMAL
- en: '**Important note**'
  prefs: []
  type: TYPE_NORMAL
- en: The `strictfp` modifier can be used for classes (and is applied to nested classes
    as well), non-abstract methods, and interfaces. It cannot be used for variables,
    constructors, or abstract methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the `strictfp` modifier is used on an interface, there are some important
    points to consider, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: It is not applied to the `abstract` methods declared in the interface.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is applied to the `default` methods declared in the interface.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is not applied to methods defined in classes that implement the interface.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is applied to all the methods declared in the inner classes of the interface.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For instance, consider the following `strictfp` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, there is a non-`strictfp` class that implements the previous `strictfp`
    interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: 'To find out which artifacts are `strictfp`, let’s run a little bit of Java
    reflection code that will reveal the modifiers of each method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, let’s call this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the `strictfp` modifier is not present for all of our methods.
    So if we need `strictfp` on `perimeter()` and `diagonal()`, then we have to add
    it manually:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: However, starting with JDK 17, there is some big news in this area.
  prefs: []
  type: TYPE_NORMAL
- en: '**Important note**'
  prefs: []
  type: TYPE_NORMAL
- en: Hardware has seriously evolved, and the issues causing `strictfp` to be optional
    in JDK 1.2 have been fixed, so the default floating-point semantics can be changed
    to consistently strict. In other words, starting with JDK 17, there is no need
    to explicitly use `strictfp`. JEP 306, *Restore Always-Strict Floating-Point Semantics*,
    provides this functionality out of the box everywhere. So starting with JDK 17,
    all floating-point operations are consistently strict.
  prefs: []
  type: TYPE_NORMAL
- en: Besides being good news for us as developers, JEP 306 also sustains several
    Java classes, such as `java.lang.Math` and `java.lang.StrictMath`, which become
    more robust and easy to implement.
  prefs: []
  type: TYPE_NORMAL
- en: 20\. Computing mathematical absolute value for int/long and result overflow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Mathematical absolute value is notated by placing the value between two pipe
    operators and is computed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: 'It is commonly used for computing/expressing distances. For example, imagine
    that 0 represents the sea level and we have a scuba diver and a climber. The scuba
    diver is underwater at -45 ft (notice that we use negative numbers to express
    how deep in the water the scuba diver is). At the same time, the climber has climbed
    30 ft high. Which of them is closer to the sea level (0)? We may think that since
    -45 < 30, the scuba diver is closer because its value is smaller. However, we
    can easily find the correct answer by applying the mathematical absolute, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s dive into the solution with the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a very simple use case of `Math.abs()`, which returns the mathematical
    absolute value of the given integer. Now, let’s apply this method to the following
    large numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: 'This is not good! The `int` domain was overflowed because of `|Integer.MIN_VALUE|
    > |Integer.MAX_VALUE|`. The expected result is the positive value of 2,147,483,648,
    which doesn’t fit in the `int` domain. However, changing the `x` type from `int`
    to `long` will solve the problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: 'But the problem will reappear if, instead of `Integer.MIN_VALUE`, there is
    `Long.MIN_VALUE`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: 'Starting with JDK 15, the `Math` class was enriched with two `absExact()` methods.
    There is one for `int` and one for `long`. These methods are very useful if the
    mathematical absolute result is prone to overflowing the `int` or `long` domain
    (for instance, the `Integer`/`Long.MIN_VALUE` values overflows the positive `int`/`long`
    range). In such cases, these methods throw `ArithmeticException` instead of returning
    a misleading result, as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: 'In a functional style context, a potential solution will rely on the `UnaryOperator`
    functional interface, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: When working with large numbers, also focus on `BigInteger` (immutable arbitrary-precision
    integers) and `BigDecimal` (immutable arbitrary-precision signed decimal numbers).
  prefs: []
  type: TYPE_NORMAL
- en: 21\. Computing the quotient of the arguments and result overflow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let’s start with two simple computations, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a very simple use case that works as expected. Now, let’s keep the
    divisor as `-1`, and let’s change the dividend to `Integer.MIN_VALUE` (-2,147,483,648):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, the result is not correct. The `int` domain was overflowed because
    of `|Integer.MIN_VALUE| > |Integer.MAX_VALUE|`. It should be the positive 2,147,483,648,
    which doesn’t fit in the `int` domain. However, changing the `x` type from `int`
    to `long` will solve the problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: 'But the problem will reappear if, instead of `Integer.MIN_VALUE`, there is
    `Long.MIN_VALUE`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: 'Starting with JDK 18, the `Math` class was enriched with two `divideExact()`
    methods. There is one for `int` and one for `long`. These methods are very useful
    if the division result is prone to overflowing the `int` or `long` (as `Integer`/`Long.MIN_VALUE`
    overflows the positive `int`/`long` range). In such cases, these methods throw
    `ArithmeticException` instead of returning a misleading result, as in the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: 'In a functional style context, a potential solution will rely on the `BinaryOperator`
    functional interface, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: As we said in the previous problem as well, when working with large numbers,
    also focus on `BigInteger` (immutable arbitrary-precision integers) and `BigDecimal`
    (immutable arbitrary-precision signed decimal numbers).
  prefs: []
  type: TYPE_NORMAL
- en: 22\. Computing the largest/smallest value that is less/greater than or equal
    to the algebraic quotient
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By the largest value, we understand the value closest to positive infinity,
    while by the smallest value, we understand the value closest to negative infinity.
  prefs: []
  type: TYPE_NORMAL
- en: Computing the largest value that is less than or equal to the algebraic quotient
    can be done, starting with JDK 8, via `floorDiv(int x, int y)` and `floorDiv(long
    x, long y)`. Starting with JDK 9, we also have `floorDiv(long x, int y)`.
  prefs: []
  type: TYPE_NORMAL
- en: Computing the smallest value that is greater than or equal to the algebraic
    quotient can be done, starting with JDK 18, via `ceilDiv(int x, int y)`, `ceilDiv(long
    x, int y)`, and `ceilDiv(long x, long y)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, none of these functions are capable of managing the corner case divisions
    presented in the previous problem, `Integer.MIN_VALUE/-1` and `Long.MIN_VALUE/-1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: 'Starting with JDK 18, whenever the result returned by `floorDiv()`/`ceilDiv()`
    is prone to overflowing the `int` or `long` domains, we can use `floorDivExact()`
    and `ceilDivExact()`. These methods come with flavors for `int` and `long` arguments.
    As you have probably intuited already, these methods throw `ArithmeticException`
    instead of returning a misleading result, as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: 'In a functional style context, a potential solution will rely on the `BinaryOperator`
    functional interface, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: Done! As you already know, when working with large numbers, also focus on `BigInteger`
    (immutable arbitrary-precision integers) and `BigDecimal` (immutable arbitrary-precision
    signed decimal numbers). These may save your day.
  prefs: []
  type: TYPE_NORMAL
- en: 23\. Getting integral and fractional parts from a double
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You know those problems that are very easy if you know the solution and seem
    very difficult if you don’t? This is exactly that kind of a problem. The solution
    is quite simple, as you can see in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: This was easy; I don’t think you need further explanations. But this approach
    is not quite accurate. I mean, the integral part is -9, but this returns -9.0\.
    Also, the fractional part is -0.33543545, but the returned value is -0.3354354500000003.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we need a more accurate result, then using `BigDecimal` is more useful:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: This time, the results are -9 and -0.33543545.
  prefs: []
  type: TYPE_NORMAL
- en: 24\. Testing if a double number is an integer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First of all, let’s consider the following expected results (false means that
    the double is not an integer):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: 'Most probably, the first solution for testing if a double number is an integer
    consists of a simple cast as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: 'However, there are several other options. For instance, we can rely on modulus,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, we can rely on the `Math.floor()` and `Double.isFinite()` methods.
    If the given double is a finite number and is equal to the result of `Math.floor()`,
    then it is an integer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also replace this equality via `Math.ceil()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: 'Moreover, we can combine `Double.isFinite()` with `Math.rint()`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can rely on Guava’s `DoubleMath.isMathematicalInteger()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: 'But which of these approaches has a better performance? Which one are you betting
    on? Well, let’s see what a benchmark has to say:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.19.png](img/B19665_01_19.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.19: Benchmark results'
  prefs: []
  type: TYPE_NORMAL
- en: Based on these results, the conclusion is quite obvious – the solution that
    relies on modulus should be avoided. Also, the Guava solution seems to be slightly
    slower than the rest.
  prefs: []
  type: TYPE_NORMAL
- en: 25\. Hooking Java (un)signed integers in a nutshell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Signed* values (or variables) such as signed integers or signed longs allow
    us to represent negative and positive numbers.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Unsigned* values (or variables) such as unsigned integers or unsigned longs
    allow us to represent only positive numbers.'
  prefs: []
  type: TYPE_NORMAL
- en: Signed and unsigned values (variables) of the same type share the same range.
    However, as you can see in the following figure, unsigned variables cover a larger
    magnitude number.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.20.png](img/B19665_01_20.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.20: Signed and unsigned integers'
  prefs: []
  type: TYPE_NORMAL
- en: The signed 32-bit integers range from –2,147,483,648 to 2,147,483,647 (around
    4 billion values). Unsigned 32-bit integers range from 0 to 4,294,967,295 (also
    around 4 billion values).
  prefs: []
  type: TYPE_NORMAL
- en: So when we use signed integer variables, we can use 2 billion positive values,
    but when we use unsigned integer variables, we can use 4 billion positive values.
    The hatched part of the figure represents the extra 2 billion positive integer
    values.
  prefs: []
  type: TYPE_NORMAL
- en: Commonly, unsigned values are needed when we don’t need negative values at all
    (for instance, to count something like an event occurrence) and we need to use
    values that reside in the hashed area in *Figure 1.20*.
  prefs: []
  type: TYPE_NORMAL
- en: Java supports only signed integers that use the popular *two’s complement* representation
    in a signed system (for a detailed explanation of two’s complement representation
    and bit manipulation, please check out *The Complete Coding Interview Guide in
    Java*, *Chapter 9*, *Bit Manipulation*). However, starting with JDK 8, we also
    have the *Unsigned Integer API*, which adds support for unsigned arithmetic.
  prefs: []
  type: TYPE_NORMAL
- en: 'Moreover, JDK 9, comes with a method named `Math.multiplyHigh(long x, long
    y)`. This method returns a `long`, representing the most significant 64 bits of
    the 128-bit product of two 64-bit factors. The following figure clarifies this
    statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.21.png](img/B19665_01_21.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.21: The most significant 64 bits of the 128-bit product of two 64-bit
    factors'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: 'The returned result (-7187) is a signed value. The unsigned version of this
    method, `unsignedMultiplyHigh(long x, long y)`, was introduced in JDK 18 and works
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: So `unsignedMultiplyHigh(long x, long y)` returns a long representing the most
    significant 64 bits of the unsigned 128-bit product of two unsigned 64-bit factors.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, remember that Java supports unsigned arithmetic, not unsigned values/variables.
    However, thanks to the Data Geekery company (very well known for the famous jOOQ),
    we have the **jOOU** (**Java Object Oriented Unsigned**) project, created to bring
    unsigned number types into Java. While you can explore this project at [https://github.com/jOOQ/jOOU](https://github.com/jOOQ/jOOU),
    here is an example of defining an unsigned long:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is its use in `unsignedMultiplyHigh(long x, long y)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: You can find these examples in the bundled code.
  prefs: []
  type: TYPE_NORMAL
- en: 26\. Returning the flooring/ceiling modulus
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having the *dividend / divisor = quotient* computation, we know that the *floor*
    operation applied to the (*dividend*, *divisor*) pair returns the largest integer
    that is less than or equal to the algebraic *quotient*. By the largest integer,
    we understand the integer closest to positive infinity. Starting with JDK 8, this
    operation can be obtained via `Math.floorDiv()` and, starting with JDK 18, `Math.floorDivExact()`.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, the *ceil* operation applied to the (*dividend*, *divisor*)
    pair returns the smallest integer that is greater than or equal to the algebraic
    *quotient*. By the smallest integer, we understand the integer closest to negative
    infinity. Starting with JDK 18, this operation can be obtained via `Math.ceilDiv()`
    and `Math.ceilDivExact()`.
  prefs: []
  type: TYPE_NORMAL
- en: More details are available in *Problem 22*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, based on the *floor* and *ceil* operations, we can define the following
    floor/ceil modulus relationships:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: 'So we can write this in code as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: 'Starting with JDK 8, floor modulus can be obtained via `Math.floorMod()`, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we use `floorMod(int dividend, int divisor)`. But we can also use two
    more flavors: `floorMod(long dividend, long divisor)` and, starting with JDK 9,
    `floorMod(long dividend, int divisor)`.'
  prefs: []
  type: TYPE_NORMAL
- en: If the *dividend % divisor* is 0, then `floorMod()` is 0\. If *dividend % divisor*
    and `floorMod()` are not 0, then their result differs only if the signs of the
    parameters differ.
  prefs: []
  type: TYPE_NORMAL
- en: 'Starting with JDK 18, ceil modulus can be obtained via `Math.ceilMod()`, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we use `ceilMod(int dividend, int divisor)`. But we can also use two
    more flavors: `ceilMod(long dividend, int divisor)` and `ceilMod(long dividend,
    long divisor)`.'
  prefs: []
  type: TYPE_NORMAL
- en: If the *dividend % divisor* is 0, then `ceilMod()` is 0\. If *dividend % divisor*
    and `ceilMod()` are not 0, then their results differ only if the signs of the
    parameters are the same.
  prefs: []
  type: TYPE_NORMAL
- en: 'Moreover, the relationship between `floorMod()` and `floorDiv()` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, the relationship between `ceilMod()` and `ceilDiv()` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: Notice that if the divisor is 0, then both `floorMod()` and `ceilMod()` throw
    `ArithmeticException`.
  prefs: []
  type: TYPE_NORMAL
- en: 27\. Collecting all prime factors of a given number
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A prime number is a number divisible by itself and 1 (for instance, 2, 3, and
    5 are prime numbers). Having a given number, we can extract its prime factors,
    as in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.22.png](img/B19665_01_22.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.22: Prime factors of 90 are 2, 3, 3, and 5'
  prefs: []
  type: TYPE_NORMAL
- en: 'The prime factors of 90 are 2, 3, 3, and 5\. Based on *Figure 1.22*, we can
    create an algorithm to solve this problem, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Define a `List` to collect prime factors of the given `v`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Initialize a variable `s` with 2 (the smallest prime number).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If `v % s` is 0, collect `s` as a prime factor and compute the new `v` as `v
    / s`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If `v % s` is not 0, then increase `s` by 1.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat step 3 as long as `v` is greater than 1.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In code lines, this O(n) algorithm (O(log n) for composite numbers) can be
    expressed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: In the bundled code, you can find two more approaches. Moreover, you’ll also
    find an application that counts the number of primes less than the given number,
    `v` (`v` should be positive).
  prefs: []
  type: TYPE_NORMAL
- en: 28\. Computing the square root of a number using the Babylonian method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Believe it or not, the ancient Babylonians (around 1500 BC) knew how to estimate
    square roots long before the popular method discovered by Newton.
  prefs: []
  type: TYPE_NORMAL
- en: 'Mathematically speaking, the Babylonian approach for estimating the square
    root of `v > 0` is the recurrence relation from the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.23.png](img/B19665_01_23.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.23: The recurrence relation of Babylonian square root approximation'
  prefs: []
  type: TYPE_NORMAL
- en: The recurrence formula starts with an initial guess of x[0]. Next, we calculate
    x[1], x[2], …, x[n] by substituting x[n-1] in the formula on the right-hand side
    and evaluating the expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, let’s try to apply this formula to estimate the square root of
    65 (the result is 8.06). Let’s start with x[0] as 65/2, so x[0] =32.5, and let’s
    calculate x[1] as:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19665_01_001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Having x[1], we can calculate x[2] as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19665_01_002.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Having x[2], we can calculate x[3] as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19665_01_003.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We are getting closer to the final result. Having x[3], we can calculate x[4]
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19665_01_004.png)'
  prefs: []
  type: TYPE_IMG
- en: Done! After four iterations, we found that the square root of 65 is 8.06\. Of
    course, being an approximation of the real value, we can continue until we reach
    the desired precision. More precision involves more iterations.
  prefs: []
  type: TYPE_NORMAL
- en: 'The algorithm that is based on the Babylonian approach to approximate the square
    root of `v > 0` has several steps, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: To start, choose an arbitrary positive value, `x` (the closer it is to the final
    result, the fewer iterations are needed). For instance, we start with `x = v/2`
    as the initial guess.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Initialize `y = 1`, and choose the desired precision (for instance, `e = 0.000000000001`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Until the precision (`e`) is achieved, do the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Calculate the next approximation (`xnext`) as the average of `x` and `y`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the next approximation to set `y` as `v/xnext`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'So in code lines, we have the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: In the bundled code, you can also see an implementation that is useful if you
    know that `v` is a perfect square (for instance, 25, 144, 169, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: 29\. Rounding a float number to specified decimals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Consider the following `float` number and the number of decimals that we want
    to keep:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: So the expected result after rounding up is 14.98777.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can solve this problem in a straightforward manner in at least three ways.
    For instance, we can rely on the `BigDecimal` API, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: First, we create a `BigDecimal` number from the given `float`. Second, we scale
    this `BigDecimal` to the desired number of decimals. Finally, we return the new
    `float` value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another approach can rely on `DecimalFormat`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: We define the format via `setMaximumFractionDigits()` and simply use this format
    on the given `float`. The returned `String` is passed through `Float.parseFloat()`
    to obtain the final `float`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we can apply a more esoteric but self-explanatory approach, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: You can practice these examples in the bundled code. Feel free to add your own
    solutions.
  prefs: []
  type: TYPE_NORMAL
- en: 30\. Clamping a value between min and max
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s assume that we have a pressure regulator that is capable of adjusting
    the given pressure in a certain range. For instance, if the passed pressure is
    below the minimum pressure, then the regulator increases the pressure to the minimum
    pressure. On the other hand, if the passed pressure is higher than the maximum
    pressure, then the regulator decreases the pressure to the maximum pressure. Moreover,
    if the passed pressure is between the minimum (inclusive) and maximum (inclusive)
    pressure, then nothing happens – this is the normal pressure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Coding this scenario can be done in a straightforward manner, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: 'Neat! You can find different ways of expressing this code in shorter and smarter
    ways, but starting with JDK 21, we can accommodate solutions to this problem via
    the `Math.clamp()` method. One of the flavors of this method is `clamp(long value,
    int min, int max)`, which clamps the given `value` between the given `min` and
    `max`. For instance, we can rewrite the previous code via the `clamp()` method,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: 'Cool, right!? The logic behind the `clamp()` method relies on the following
    code line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: Other flavors of `clamp()` are `clamp(long value, long min, long max)`, `clamp(float
    value, float min, float max)`, and `clamp(double value, double min, double max)`.
  prefs: []
  type: TYPE_NORMAL
- en: 31\. Multiply two integers without using loops, multiplication, bitwise, division,
    and operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The solution to this problem can start from the following algebraic formula,
    also known as the *special binomial product formula*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.24.png](img/B19665_01_24.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.24: Extracting a*b from a binomial formula'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have the a*b product, there is only one issue left. The formula
    of a*b contains a division by 2, and we are not allowed to explicitly use the
    division operation. However, the division operation can be mocked in a recursive
    fashion, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: 'Nothing can stop us now from using this recursive code to implement a*b, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: In the bundled code, you can also practice a recursive approach to this problem.
  prefs: []
  type: TYPE_NORMAL
- en: 32\. Using TAU
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is TAU?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Short answer**: It is the Greek letter ![](img/B19665_01_005.png).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Long answer**: It is a Greek letter used to define the proportion of the
    circumference of a circle to its radius. Put simply, TAU is one turn of an entire
    circle, so 2*PI.'
  prefs: []
  type: TYPE_NORMAL
- en: 'TAU allows us to express sinuses, cosines, and angles in a more intuitive and
    simple way. For instance, the well-known angles of 30⁰, 45⁰, 90⁰, and so on can
    be easily expressed in radians via TAU as a fraction of a circle, as in the following
    figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.25.png](img/B19665_01_25.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.25: Angles represented using TAU'
  prefs: []
  type: TYPE_NORMAL
- en: This is more intuitive than PI. It is like slicing a pie into equal parts. For
    instance, if we slice at TAU/8 (45⁰), it means that we sliced the pie into eight
    equal parts. If we slice at TAU/4 (90⁰), it means that we sliced the pie into
    four equal parts.
  prefs: []
  type: TYPE_NORMAL
- en: The value of TAU is 6.283185307179586 = 2 * 3.141592653589793\. So the relationship
    between TAU and PI is TAU=2*PI. In Java, the well-known PI is represented via
    the `Math.PI` constant. Starting with JDK 19, the `Math` class was enriched with
    the `Math.TAU` constant.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s consider the following simple problem: A circle has a circumference of
    21.33 cm. What is the radius of the circle?'
  prefs: []
  type: TYPE_NORMAL
- en: 'We know that C = 2*PI*r, where C is the circumference and r is the radius.
    Therefore, r = C/(2*PI) or r = C/TAU. In code lines, we have:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: Both approaches return a radius equal to 3.394.
  prefs: []
  type: TYPE_NORMAL
- en: 33\. Selecting a pseudo-random number generator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we flip a coin or roll the dice, we say that we see “true” or “natural”
    randomness at work. Even so, there are tools that pretend they are capable of
    predicting the path of flipping a coin, rolling dice, or spinning a roulette wheel,
    especially if some contextual conditions are met.
  prefs: []
  type: TYPE_NORMAL
- en: Computers can generate random numbers using algorithms via the so-called **random
    generators**. Since algorithms are involved, the generated numbers are considered
    pseudo-random. This is known as “pseudo”-randomness. Obviously, pseudo-random
    numbers are also predictable. How so?
  prefs: []
  type: TYPE_NORMAL
- en: A pseudo-random generator starts its job by *seeding* data. This is the generator’s
    secret (the *seed*), and it represents a piece of data used as the starting point
    to generate pseudo-random numbers. If we know how the algorithm works and what
    the *seed* was, then the output is predictable. Without knowing the *seed*, the
    rate of predictability is very low. So choosing the proper *seed* is a major step
    for every pseudo-random generator.
  prefs: []
  type: TYPE_NORMAL
- en: 'Until JDK 17, Java’s API for generating pseudo-random numbers was a bit obtuse.
    Basically, we have a robust API wrapped in the well-known `java.util.Random` class,
    and two subclasses of `Random`: `SecureRandom` (cryptographically pseudo-random
    generator) and `ThreadLocalRandom` (not a thread-safe pseudo-random generator).
    From a performance perspective, the relationship between these pseudo-random generators
    is that `SecureRandom` is slower than `Random`, which is slower than `ThreadLocalRandom`.'
  prefs: []
  type: TYPE_NORMAL
- en: As well as these classes, we have `SplittableRandom`. This is a non-thread-safe
    pseudo-generator capable of spinning a new `SplittableRandom` at each call of
    its `split()` method. This way, each thread (for instance, in a fork/join architecture)
    can use its own `SplittableGenerator`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The class hierarchy of pseudo-random generators, up to JDK 17, is shown in
    the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.26.png](img/B19665_01_26.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.26: The class hierarchy of Java pseudo-random generators before JDK
    17'
  prefs: []
  type: TYPE_NORMAL
- en: As this architecture reveals, switching between pseudo-random generators or
    choosing between different types of algorithms is really cumbersome. Look at that
    `SplittableRandom` – is lost in no man’s land.
  prefs: []
  type: TYPE_NORMAL
- en: 'Starting with JDK 17, we have a more flexible and powerful API for generating
    pseudo-random numbers. This is an interface-based API (released with JEP 356)
    that orbits the new `RandomGenerator` interface. Here is the enhanced class hierarchy
    of JDK 17:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.27.png](img/B19665_01_27.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.27: The class hierarchy of Java pseudo-random generators, starting
    with JDK 17'
  prefs: []
  type: TYPE_NORMAL
- en: The `RandomGenerator` interface represents the climax of this API. It represents
    a common and uniform protocol for generating pseudo-random numbers. This interface
    has taken over the `Random` API and added a few more.
  prefs: []
  type: TYPE_NORMAL
- en: The `RandomGenerator` interface is extended by five sub-interfaces meant to
    provide special protocols for five different types of pseudo-random generators.
  prefs: []
  type: TYPE_NORMAL
- en: '`StreamableGenerator` can return streams of `RandomGenerator` objects'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SplittableGenerator` can return a new generator from this one (split itself)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`JumpableGenerator` can jump ahead a moderate number of draws'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LeapableGenerator` can jump ahead a large number of draws'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ArbitrarilyJumpableGenerator` can jump ahead an arbitrary number of draws'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Getting the default `RandomGenerator` can be done as follows (this is the simplest
    approach to start generating pseudo-random numbers, but you have no control over
    what is chosen):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: 'Besides these interfaces, the new API comes with a class (`RandomGeneratorFactory`),
    which is a factory of pseudo-random generators based on the selected algorithms.
    There are three groups of new algorithms (most probably, more are on the way);
    these groups are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: LXM group;
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`L128X1024MixRandom`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`L128X128MixRandom`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`L128X256MixRandom`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`L32X64MixRandom`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`L64X1024MixRandom`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`L64X128MixRandom`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`L64X128StarStarRandom`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`L64X256MixRandom`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Xoroshiro group:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Xoroshiro128PlusPlus`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Xoshiro group:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Xoshiro256PlusPlus`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The highlighted algorithm is the default one (`L32X64MixRandom`).
  prefs: []
  type: TYPE_NORMAL
- en: Depending on the pseudo-random generator type, we can select all/some of the
    previous algorithms. For instance, the `L128X256MixRandom` algorithm can be used
    with `SplittableGenerator`, but it cannot be used with `LeapableGenerator`. A
    mismatch between the chosen algorithm and the pseudo-random generator results
    in `IllegalArgumentException`. The following figure can help you to decide which
    algorithm to use.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.28.png](img/B19665_01_28.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.28: JDK 17 random generator algorithms and their properties'
  prefs: []
  type: TYPE_NORMAL
- en: 'This figure was produced via the following code, which lists all the available
    algorithms and their properties (*streamable*, *leapable*, *statistical*, and
    so on):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: Choosing an algorithm can be easily done by name or properties.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing an algorithm by name
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Choosing an algorithm by name can be done via a set of static `of()` methods.
    There is an `of()` method in `RandomGenerator` and `RandomGeneratorFactory` that
    can be used to create a pseudo-random generator for a specific algorithm, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: Next, we can generate pseudo-random numbers by calling a well-known API (`ints()`,
    `doubles()`, `nextInt()`, `nextFloat()`, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: 'If we need a certain pseudo-random generator and algorithm, then we can use
    the `of()` method of that generator, as follows (here, we create a `LeapableGenerator`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: 'In the case of `SplittableRandom`, you can use the constructor as well, but
    you cannot specify the algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: In the bundled code, you can see more examples.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing an algorithm by property
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As you saw in *Figure 1.28*, an algorithm has a set of properties (is *Jumpable*,
    is *Statistical*, and so on). Let’s pick an algorithm that is *statistical* and
    *leapable*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: The returned algorithm can be `Xoshiro256PlusPlus`.
  prefs: []
  type: TYPE_NORMAL
- en: 34\. Filling a long array with pseudo-random numbers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we want to fill up a large array with data, we can consider the `Arrays.setAll()`
    and `Arrays.parallelSetAll()`. These methods can fill up an array by applying
    a generator function to compute each element of the array.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we have to fill up the array with pseudo-random data, we should consider
    that the generator function should be a pseudo-random generator. If we want to
    do this in parallel, then we should consider the `SplittableRandom` (JDK 8+)/`SplittableGenerator`
    (JDK 17+), which are dedicated to generating pseudo-random numbers in isolated
    parallel computations. In conclusion, the code may look as follows (JDK 17+):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, we can use `SplittableRandom` (this time, we cannot specify
    the algorithm, JDK 8+):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: Next, let’s see how we can create a stream of pseudo-random generators.
  prefs: []
  type: TYPE_NORMAL
- en: 35\. Creating a stream of pseudo-random generators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before creating a stream of pseudo-random generators, let’s create a stream
    of pseudo-random numbers. First thing first, let’s see how to do it with the legacy
    `Random`, `SecureRandom`, and `ThreadLocalRandom`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since these three pseudo-random generators contain methods such as `ints()`
    returning `IntStream`, `doubles()` returning `DoubleStream`, and so on, we can
    easily generate an (in)finite stream of pseudo-random numbers, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: 'In our examples, we collect the generated pseudo-random numbers in an array.
    Of course, you can process them as you want. We can obtain similar results via
    `SecureRandom`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: 'How about `ThreadLocalRandom`? Here it is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: 'If you just need a stream of doubles between 0.0 and 1.0, then rely on `Math.random()`,
    which internally uses an instance of `java.util.Random`. The following example
    collects an array of doubles between 0.0 and 0.5\. The stream will stop when the
    first `double` larger than 0.5 is generated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: 'How about using the new JDK 17 API? The `RandomGenerator` contains the well-known
    methods `ints()`, `doubles()`, and so on, and they are available in all its sub-interfaces.
    For instance, `StreamableGenerator` can be used, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: Similarly, we can use `JumpableGenerator`, `LeapableGenerator`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'OK, now let’s get back to our problem. How do we generate a stream of pseudo-random
    generators? All `RandomGenerator` sub-interfaces contain a method named `rngs()`
    that comes in different flavors. Without arguments, this method returns an infinite
    stream of new pseudo-random generators that implement the `RandomGenerator` interface.
    The following code generated five `StreamableGenerator` instances, and each of
    those generated 10 pseudo-random integers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: 'We can accomplish the same thing with `JumpableGenerator`, but instead of `rngs()`,
    we may prefer `jumps()`, which implements the behavior specific to this type of
    generator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: 'The same thing can be accomplished via `LeapableGenerator`. This time, we can
    use `rngs()` or `leaps()`, which implement the behavior specific to this type
    of generator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: Next, let’s see how we can interleave legacy and new pseudo-random generators.
  prefs: []
  type: TYPE_NORMAL
- en: 36\. Getting a legacy pseudo-random generator from new ones of JDK 17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A legacy pseudo-random generator such as `Random`, `SecureRandom`, or `ThreadLocalRandom`
    can delegate method calls to a `RandomGenerator`, passed as an argument to `Random.from()`,
    `SecureRandom.from()`, or `ThreadLocalRandom.from()`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: The `from()` methods are available starting with JDK 19\. In the bundled code,
    you can see more examples.
  prefs: []
  type: TYPE_NORMAL
- en: 37\. Using pseudo-random generators in a thread-safe fashion (multithreaded
    environments)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Random` and `SecureRandom` instances are thread-safe. While this statement
    is true, pay attention that when a `Random` instance (or `Math.random()`) is used
    by multiple threads (multithreaded environment), your code is prone to thread
    contention because these threads share the same *seed*. Sharing the same seed
    involves synchronization of the *seed* access; therefore, it opens the door to
    thread contention. Obviously, thread contention leads to performance penalties,
    since threads may wait in the queue to gain access to the *seed*. Synchronization
    is typically expensive.'
  prefs: []
  type: TYPE_NORMAL
- en: An alternative to `Random` is `ThreadLocalRandom`, which uses a `Random` instance
    for each thread and provides protection against thread contention, since it doesn’t
    contain synchronized code or atomic operations. The downside is that `ThreadLocalRandom`
    uses an internal *seed* per thread that we cannot control or modify.
  prefs: []
  type: TYPE_NORMAL
- en: '`SplittableRandom` is not thread-safe. Moreover, the new API consisting of
    implementations of `RandomGenerator` is not thread-safe.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This being said, a pseudo-random generator can be used in a multithread environment
    by using a thread-safe generator, or by splitting a new instance for each new
    thread. And when I say “splitting,” I mean using `SplittableGenerator.splits(long
    n)`, where `n` is the number of splits. Check out the code that uses 10 threads
    to populate a Java list with integers (each thread uses its own pseudo-random
    generator):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE189]'
  prefs: []
  type: TYPE_PRE
- en: 'A snippet from the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: You can also use a `JumpableGenerator` or `LeapableGenerator`. The only difference
    is that instead of `splits()`, `JumpableGenerator` uses `jumps()` and `LeapableGenerator`
    uses `leaps()`.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter collected 37 problems related to strings, locales, numbers, and
    math, intended to mix classical must-know problems with a bunch of problems solved
    via the latest JDK features, such as text blocks and pseudo-random generators.
    If you want to explore other similar problems, then consider *Java Coding Problems,
    First Edition*, which has a similar chapter (*Chapter 1*), covering another 39
    problems.
  prefs: []
  type: TYPE_NORMAL
- en: Leave a review!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Enjoying this book? Help readers like you by leaving an Amazon review. Scan
    the QR code below for a 20% discount code.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Leave_Reivew_QR.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Limited Offer*'
  prefs: []
  type: TYPE_NORMAL
