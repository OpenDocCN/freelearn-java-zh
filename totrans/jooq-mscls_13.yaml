- en: '*Chapter 10*: Exporting, Batching, Bulking, and Loading'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第10章*：导出、分批、批量加载数据'
- en: 'Manipulating large amounts of data requires serious skills (know-how and programming
    skills) in exporting, batching, bulking, and loading data. Each of these areas
    requires a significant amount of code and a lot of time to be implemented and
    tested against real datasets. Fortunately, jOOQ provides comprehensive APIs that
    cover all these operations and expose them in a fluent style, while hiding the
    implementation details. In this context, our agenda includes the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 处理大量数据需要具备在导出、分批、批量加载数据方面的专业技能（知识和技术以及编程技能）。这些领域中的每一个都需要大量的代码和大量时间来实现和测试。幸运的是，jOOQ提供了涵盖所有这些操作的全面API，并以流畅的风格公开它们，同时隐藏了实现细节。在这种情况下，我们的议程包括以下内容：
- en: Exporting data in text, JSON, XML, CSV, charts, and `INSERT` statements
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以文本、JSON、XML、CSV、图表和`INSERT`语句导出数据
- en: Batching `INSERT`, `UPDATE`, `DELETE`, `MERGE`, and `Record`
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分批`INSERT`、`UPDATE`、`DELETE`、`MERGE`和`Record`
- en: Bulking queries
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 批量查询
- en: Loading JSON, CSV, arrays, and `Record`
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加载JSON、CSV、数组以及`Record`
- en: Let's get started!
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code for this chapter can be found on GitHub at [https://github.com/PacktPublishing/jOOQ-Masterclass/tree/master/Chapter10](https://github.com/PacktPublishing/jOOQ-Masterclass/tree/master/Chapter10).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在GitHub上找到：[https://github.com/PacktPublishing/jOOQ-Masterclass/tree/master/Chapter10](https://github.com/PacktPublishing/jOOQ-Masterclass/tree/master/Chapter10)。
- en: Exporting data
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导出数据
- en: Exporting (or formatting) data is achievable via the `org.jooq.Formattable`
    API. jOOQ exposes a suite of `format()` and `formatFoo()` methods that can be
    used to format `Result` and `Cursor` (remember `fetchLazy()` from [*Chapter 8*](B16833_08.xhtml#_idTextAnchor128),
    *Fetching and Mapping*) as text, JSON, XML, CSV, XML, charts, and `INSERT` statements.
    As you can see in the documentation, all these methods come in different flavors
    capable of exporting data into a string or a file via the Java `OutputStream`
    or `Writer` APIs.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`org.jooq.Formattable` API可以导出（或格式化）数据。jOOQ公开了一系列`format()`和`formatFoo()`方法，可用于将`Result`和`Cursor`（记住来自[*第8章*](B16833_08.xhtml#_idTextAnchor128)，*获取和映射*中的`fetchLazy()`）格式化为文本、JSON、XML、CSV、XML、图表和`INSERT`语句。正如您在文档中所见，所有这些方法都有不同的变体，可以将数据导出到字符串或文件中，通过Java的`OutputStream`或`Writer`
    API。
- en: Exporting as text
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 以文本格式导出
- en: 'I''m sure that you have already seen in your console output something similar
    to the following:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我相信您已经在控制台输出中看到了类似以下内容：
- en: '![Figure 10.1 – Tabular text data'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.1 – 表格文本数据'
- en: '](img/B16833_Figure_10.1.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B16833_Figure_10.1.jpg)'
- en: Figure 10.1 – Tabular text data
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.1 – 表格文本数据
- en: 'This textual tabular representation can be achieved via the `format()` method.
    A flavor of this method takes an integer argument representing the maximum number
    of records to include in the formatted result (by default, jOOQ logs just the
    first five records of the result formatted via jOOQ''s text export, but we can
    easily format and log all the `fetch` records as `result.format(result.size()`).
    But, if you need a fine-tuning of this output, then jOOQ has a dedicated immutable
    class named `TXTFormat` with a lot of intuitive options available in the documentation.
    Using this class in conjunction with exporting the resulting text into a file
    named `result.txt` via `format``(Writer writer, TXTFormat format)` can be done
    as shown in the following example:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这种文本表格表示可以通过`format()`方法实现。此方法的一种变体接受一个整数参数，表示要包含在格式化结果中的最大记录数（默认情况下，jOOQ仅记录通过jOOQ文本导出格式化的结果的前五条记录，但我们可以轻松地格式化和记录所有`fetch`记录，如`result.format(result.size())`）。但是，如果您需要调整此输出，那么jOOQ有一个名为`TXTFormat`的专用不可变类，在文档中提供了许多直观的选项。使用此类并结合通过`format`(Writer
    writer, TXTFormat format)`将结果文本导出到名为`result.txt`的文件中，可以像以下示例所示进行：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: You can see this example in the bundled code, `Format` (available for MySQL
    and PostgreSQL), next to other examples.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在捆绑的代码中看到此示例，`Format`（适用于MySQL和PostgreSQL），在其它示例旁边。
- en: Exporting JSON
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导出JSON
- en: 'Exporting `Result`/`Cursor` as JSON can be done via `formatJSON()` and its
    overloads. Without arguments, `formatJSON()` produces a JSON containing two main
    arrays: an array named `"fields"`, representing a header (as you''ll see later,
    this can be useful for importing the JSON into the database), and an array named
    `"records"`, which wraps the fetched data. Here is such an output:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`formatJSON()`及其重载可以将`Result`/`Cursor`导出为JSON。如果没有参数，`formatJSON()`生成包含两个主要数组的JSON：一个名为`"fields"`的数组，表示标题（如您稍后所见，这可以用于将JSON导入数据库），以及一个名为`"records"`的数组，它包装了获取的数据。以下是一个这样的输出：
- en: '[PRE10]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'So, this JSON can be obtained via the `formatJSON()` method without arguments,
    or via `formatJSON(JSONFormat.DEFAULT_FOR_RESULTS)`. If we want to render only
    the `"records"` array and avoid rendering the header represented by the `"fields"`
    array, then we can rely on `formatJSON(JSONFormat.DEFAULT_FOR_RECORDS)`. This
    produces something as shown here (as you''ll see later, this can also be imported
    back into the database):'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，可以通过不带参数的 `formatJSON()` 方法或通过 `formatJSON(JSONFormat.DEFAULT_FOR_RESULTS)`
    获取此 JSON。如果我们只想渲染 `"records"` 数组并避免渲染由 `"fields"` 数组表示的标题，则可以依赖 `formatJSON(JSONFormat.DEFAULT_FOR_RECORDS)`。这会产生如下所示的内容（您稍后会发现，这也可以导入回数据库）：
- en: '[PRE25]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '`DEFAULT_FOR_RESULTS` and `DEFAULT_FOR_RECORDS` are two statics of the immutable
    `org.jooq.JSONFormat` used to fine-tune JSON imports/exports. When these statics
    are not enough, we can instantiate `JSONFormat` and fluently append a suite of
    intuitive options such as the ones from this example (check all the available
    options in the jOOQ documentation):'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`DEFAULT_FOR_RESULTS` 和 `DEFAULT_FOR_RECORDS` 是不可变的 `org.jooq.JSONFormat` 的两个静态，用于微调
    JSON 的导入/导出。当这些静态不足以满足需求时，我们可以实例化 `JSONFormat` 并流畅地添加一系列直观的选项，例如本示例中的选项（请参阅 jOOQ
    文档中的所有可用选项）：'
- en: '[PRE30]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Further, let''s use `jsonFormat` in the context of exporting a JSON into a
    file via `formatJSON(Writer writer, JSONFormat format)`:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，让我们在将 JSON 导出到文件时使用 `formatJSON(Writer writer, JSONFormat format)` 的上下文中使用
    `jsonFormat`：
- en: '[PRE36]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The resulting JSON looks like this (also importable into the database):'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的 JSON 看起来如下（也可以导入到数据库中）：
- en: '[PRE46]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'If we fetch a single `Record` (so, not `Result`/`Cursor`, via `fetchAny()`,
    for instance), then `formatJSON()` will return an array containing only the data,
    as in this sample of fetching `Record3<String, Long, String>`:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们获取单个 `Record`（因此，不是 `Result`/`Cursor`，例如通过 `fetchAny()`），那么 `formatJSON()`
    将返回一个只包含数据的数组，如下是获取 `Record3<String, Long, String>` 的示例：
- en: '[PRE54]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'But, if we explicitly mention `JSONFormat.RecordFormat.OBJECT`, then this becomes
    the following:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果我们明确指出 `JSONFormat.RecordFormat.OBJECT`，则它变为以下内容：
- en: '[PRE55]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: You can check out this example in the bundled code, *Format* (available for
    MySQL and PostgreSQL), next to other examples including formatting a UDT, an array
    type, and an embeddable type as JSON.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在捆绑的代码中的 *Format* 示例中查看此示例（适用于 MySQL 和 PostgreSQL），包括格式化 UDT、数组类型和可嵌入类型作为
    JSON 的其他示例。
- en: Export XML
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导出 XML
- en: 'Exporting `Result`/`Cursor` as XML can be done via `formatXML()` and its overloads.
    Without arguments, `formatXML()` produces an XML containing two main elements:
    an element named `<fields/>`, representing a header, and an element named `<records/>`,
    which wraps the fetched data. Here is such an output:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `Result`/`Cursor` 作为 XML 导出可以通过 `formatXML()` 和其重载方法完成。不带参数时，`formatXML()`
    生成包含两个主要元素的 XML：一个名为 `<fields/>` 的元素，表示标题，以及一个名为 `<records/>` 的元素，它包装了获取的数据。以下是一个输出示例：
- en: '[PRE57]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'The jOOQ code that produced this output is as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 生成此输出的 jOOQ 代码如下：
- en: '[PRE75]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'So, this XML can be obtained via the `formatXML()` method without arguments
    or via `formatXML(XMLFormat.DEFAULT_FOR_RESULTS)`. If we want to keep only the
    `<records/>` element and avoid rendering the `<fields/>` element, then use `formatJXML(XMLFormat.DEFAULT_FOR_RECORDS)`.
    This is an output sample:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，可以通过不带参数的 `formatXML()` 方法或通过 `formatXML(XMLFormat.DEFAULT_FOR_RESULTS)`
    获取此 XML。如果我们只想保留 `<records/>` 元素并避免渲染 `<fields/>` 元素，则使用 `formatJXML(XMLFormat.DEFAULT_FOR_RECORDS)`。这是一个输出示例：
- en: '[PRE81]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '`DEFAULT_FOR_RESULTS` and `DEFAULT_FOR_RECORDS` are two statics of the immutable
    `org.jooq.XMLFormat`, used to fine-tune XML imports/exports. Besides these, we
    can instantiate `XMLFormat` and fluently append a suite of intuitive options.
    For instance, the previous snippets of XML are rendered based on the default record
    format, `XMLFormat.RecordFormat.VALUE_ELEMENTS_WITH_FIELD_ATTRIBUTE`; notice the
    `<value/>` element and the `field` attribute. But, using `XMLFormat`, we can go
    for two other options: `VALUE_ELEMENTS` and `COLUMN_NAME_ELEMENTS`. The former
    formats the records using just the `<value/>` element as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`DEFAULT_FOR_RESULTS` 和 `DEFAULT_FOR_RECORDS` 是不可变的 `org.jooq.XMLFormat` 的两个静态，用于微调
    XML 的导入/导出。除了这些之外，我们还可以实例化 `XMLFormat` 并流畅地添加一系列直观的选项。例如，前面的 XML 片段是基于默认记录格式 `XMLFormat.RecordFormat.VALUE_ELEMENTS_WITH_FIELD_ATTRIBUTE`
    生成的，请注意 `<value/>` 元素和 `field` 属性。但是，使用 `XMLFormat`，我们可以选择两种其他选项：`VALUE_ELEMENTS`
    和 `COLUMN_NAME_ELEMENTS`。前者使用 `<value/>` 元素格式化记录，如下所示：'
- en: '[PRE89]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '`COLUMN_NAME_ELEMENTS` uses the column names as elements. Let''s use this setting
    next to `header(false)` to format the `MANAGER.MANAGER_EVALUATION` UDT (available
    in the PostgreSQL schema):'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`COLUMN_NAME_ELEMENTS` 使用列名作为元素。让我们使用此设置与 `header(false)` 一起格式化 `MANAGER.MANAGER_EVALUATION`
    UDT（在 PostgreSQL 模式中可用）：'
- en: '[PRE94]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'The resulting XML looks like this:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的XML如下：
- en: '[PRE100]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '[PRE105]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '[PRE106]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '[PRE107]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[PRE108]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '[PRE109]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '[PRE110]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'If we fetch a single `Record` (so, no `Result`/`Cursor` via `fetchAny()`, for
    instance) then `formatXML()` will return an XML containing only the data, as in
    this sample of fetching `Record3<String, Long, String>`:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们获取单个`Record`（因此，没有通过`fetchAny()`等获取`Result`/`Cursor`），那么`formatXML()`将返回只包含数据的XML，如下面这个获取`Record3<String,
    Long, String>`的示例：
- en: '[PRE111]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '[PRE112]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '[PRE113]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '[PRE114]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '[PRE115]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'Of course, you can alter this default output via `XMLFormat`. For instance,
    let''s consider that we have this record:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，您可以通过`XMLFormat`来更改此默认输出。例如，让我们考虑我们有一个这样的记录：
- en: '[PRE116]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'And, let''s apply `RecordFormat.COLUMN_NAME_ELEMENTS`:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，让我们应用`RecordFormat.COLUMN_NAME_ELEMENTS`：
- en: '[PRE117]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '[PRE118]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'The rendered XML is as follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的XML如下：
- en: '[PRE119]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: '[PRE120]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '[PRE121]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: '[PRE122]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: '[PRE123]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: Consider this example next to others (including exporting XML into a file) in
    the bundled code, `Format` (available for MySQL and PostgreSQL).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在捆绑的代码中，`Format`（适用于MySQL和PostgreSQL）的其他示例中，考虑此示例（包括将XML导出到文件）。
- en: Exporting HTML
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导出HTML
- en: 'Exporting `Result`/`Cursor` as HTML can be done via `formatHTML()` and its
    overloads. By default, jOOQ attempts to wrap the fetched data in a simple HTML
    table, therefore, expect to see tags such as `<table/>`, `<th/>`, and `<td/>`
    in the resultant HTML. For instance, formatting the `MANAGER.MANAGER_EVALUATION`
    UDT (available in the PostgreSQL schema) can be done as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 将`Result`/`Cursor`导出为HTML可以通过`formatHTML()`及其重载来实现。默认情况下，jOOQ尝试将获取的数据包装在一个简单的HTML表中，因此，在生成的HTML中，您可能会看到`<table/>`，`<th/>`和`<td/>`等标签。例如，格式化`MANAGER.MANAGER_EVALUATION`
    UDT（在PostgreSQL模式中可用）可以如下进行：
- en: '[PRE124]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '[PRE125]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: '[PRE126]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: '[PRE127]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'The resultant HTML looks like this:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的HTML如下：
- en: '[PRE128]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: '[PRE129]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: '[PRE130]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: '[PRE131]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: '[PRE132]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: '[PRE133]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: '[PRE134]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: '[PRE135]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: '[PRE136]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: '[PRE137]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: '[PRE138]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: '[PRE139]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: '[PRE140]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'Notice that the value of `MANAGER_EVALUATION`, (*67, 34, 33, 66*), is wrapped
    in a `<td/>` tag. But, maybe you''d like to obtain something like this:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到`MANAGER_EVALUATION`的值（*67, 34, 33, 66*）被包裹在一个`<td/>`标签中。但也许您想要得到如下这样的结果：
- en: '[PRE141]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: '[PRE142]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: '[PRE143]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: '[PRE144]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: '[PRE145]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: '[PRE146]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: '[PRE147]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: '[PRE148]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: '[PRE149]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: '[PRE150]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: '[PRE151]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: '[PRE152]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: '[PRE153]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: '[PRE154]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: '[PRE155]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: '[PRE156]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: '[PRE157]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: '[PRE158]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: '[PRE159]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: 'We can obtain this HTML by decorating our query as follows:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下方式装饰我们的查询来获取此HTML：
- en: '[PRE160]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: '[PRE161]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: '[PRE162]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: '[PRE163]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: '[PRE164]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: '[PRE165]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: '[PRE166]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: Check out more examples in the bundled code, *Format* (available for MySQL and
    PostgreSQL).
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在捆绑的代码中查看更多示例，*格式*（适用于MySQL和PostgreSQL）。
- en: Exporting CSV
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导出CSV
- en: 'Exporting `Result`/`Cursor` as CSV can be done via `formatCSV()` and its overloads.
    By default, jOOQ renders a CSV file as the one here:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 将`Result`/`Cursor`导出为CSV可以通过`formatCSV()`及其重载来实现。默认情况下，jOOQ将CSV文件渲染成如下所示：
- en: '[PRE167]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: '[PRE168]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: '[PRE169]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: '[PRE170]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: '[PRE171]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: 'Among the handy overloads, we have `formatCSV``(boolean header, char delimiter,
    String nullString)`. Via this method, we can specify whether the CSV header should
    be rendered (by default, `true`), the record''s delimiter (by default, a *comma*),
    and a string for representing `NULL` values (by default, `""`). Next to this method,
    we also have a suite of combinations of these arguments such as `formatCSV(char
    delimiter, String nullString)`, `formatCSV(char delimiter)`, and `formatCSV(boolean
    header, char delimiter)`. Here is an example that renders the header (default)
    and uses `TAB` as a delimiter and `"N/A"` for representing `NULL` values:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在便捷的重载方法中，我们有`formatCSV`(布尔头部，字符分隔符，字符串nullString)。通过此方法，我们可以指定是否渲染CSV头部（默认为`true`），记录的分隔符（默认为一个*逗号*），以及表示`NULL`值的字符串（默认为`""`）。紧邻此方法，我们还有一系列这些参数的组合，例如`formatCSV(char
    delimiter, String nullString)`，`formatCSV(char delimiter)`，和`formatCSV(boolean
    header, char delimiter)`。以下是一个示例，它渲染了头部（默认）并使用`TAB`作为分隔符，以及`"N/A"`来表示`NULL`值：
- en: '[PRE172]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: '[PRE173]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: '[PRE174]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: '[PRE175]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: '[PRE176]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: 'The resulting CSV looks like this:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的CSV看起来如下：
- en: '[PRE177]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: '[PRE178]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: '[PRE179]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: '[PRE180]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: '[PRE181]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: '[PRE182]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: '[PRE183]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: '[PRE184]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: '[PRE185]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: 'Whenever we need more options, we can rely on the immutable `CSVFormat`. Here
    is an example of using `CSVFormat` and exporting the result in a file:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要更多选项时，我们可以依赖不可变的`CSVFormat`。以下是一个使用`CSVFormat`并导出结果的文件示例：
- en: '[PRE186]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: '[PRE187]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: '[PRE188]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: '[PRE189]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: '[PRE190]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: '[PRE191]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: '[PRE192]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: '[PRE193]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: '[PRE194]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: '[PRE195]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: The complete code next to other examples is available in the bundled code, *Format*
    (available for MySQL and PostgreSQL).
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的代码在其他示例旁边可用，在捆绑的代码中，*格式*（适用于MySQL和PostgreSQL）。
- en: Exporting a chart
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导出图表
- en: 'Exporting `Result`/`Cursor` as a chart may result in something as observed
    in this figure:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 将`Result`/`Cursor`导出为图表可能会导致如图所示的观察结果：
- en: '![Figure 10.2 – jOOQ chart sample'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.2 – jOOQ图表示例'
- en: '](img/B16833_Figure_10.2.jpg)'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16833_Figure_10.2.jpg)'
- en: Figure 10.2 – jOOQ chart sample
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.2 – jOOQ图表示例
- en: 'This is an area chart containing three graphs: *a*, *b*, and *c*. Graph `a`
    represents `PRODUCT.BUY_PRICE`, graph *b* represents `PRODUCT.MSRP`, and graph
    *c* represents `avg(ORDERDETAIL.PRICE_EACH)`. While this chart can be displayed
    on the console, it can be exported to a file as shown here:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个包含三个图表的区域图表：*a*，*b*和*c*。图表`a`表示`PRODUCT.BUY_PRICE`，图表*b*表示`PRODUCT.MSRP`，图表*c*表示`avg(ORDERDETAIL.PRICE_EACH)`。虽然此图表可以在控制台上显示，但它可以像下面这样导出到文件：
- en: '[PRE196]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: '[PRE197]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: '[PRE198]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: '[PRE199]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE199]'
- en: '[PRE200]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE200]'
- en: '[PRE201]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: '[PRE202]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: '[PRE203]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE203]'
- en: '[PRE204]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE204]'
- en: '[PRE205]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE205]'
- en: '[PRE206]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE206]'
- en: '[PRE207]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE207]'
- en: 'Obviously, the chart is obtained via the `formatChart()` method. More precisely,
    in this example, via `formatChart``(Writer writer, ChartFormat format)`. The `ChartFormat`
    class is immutable and contains a suite of options for customizing the chart.
    While you can check all of them in the jOOQ documentation, here is the `cf` used
    in this example:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，图表是通过 `formatChart()` 方法获得的。更确切地说，在这个示例中，通过 `formatChart``(Writer writer,
    ChartFormat format)`。`ChartFormat` 类是不可变的，并包含一系列用于自定义图表的选项。虽然您可以在 jOOQ 文档中检查它们的所有内容，但以下是在本例中使用的
    `cf`：
- en: '[PRE208]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE208]'
- en: '[PRE209]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE209]'
- en: '[PRE210]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE210]'
- en: '[PRE211]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE211]'
- en: '[PRE212]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE212]'
- en: '[PRE213]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE213]'
- en: '[PRE214]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE214]'
- en: '[PRE215]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE215]'
- en: '[PRE216]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE216]'
- en: '[PRE217]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE217]'
- en: '[PRE218]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE218]'
- en: '[PRE219]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE219]'
- en: The complete code next to other examples is available in the bundled code in
    the application named *Format* (available for MySQL and PostgreSQL).
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他示例旁边的完整代码可在名为 *Format* 的应用程序捆绑的代码中找到（适用于 MySQL 和 PostgreSQL）。
- en: Exporting INSERT statements
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导出 INSERT 语句
- en: jOOQ can export `Result`/`Cursor` as `INSERT` statements via the `formatInsert()`
    method and its overloads. By default, if the first record is `TableRecord`, then
    `formatInsert()` uses the first record's `TableRecord.getTable()` method to generate
    `INSERT` statements into this table, otherwise, it generates `INSERT` statements
    into `UNKNOWN_TABLE`. In both cases, jOOQ calls the `Result.fields()` method to
    determine the column names.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: jOOQ 可以通过 `formatInsert()` 方法及其重载将 `Result`/`Cursor` 导出为 `INSERT` 语句。默认情况下，如果第一条记录是
    `TableRecord`，则 `formatInsert()` 使用第一条记录的 `TableRecord.getTable()` 方法生成此表的 `INSERT`
    语句；否则，它将生成 `UNKNOWN_TABLE` 的 `INSERT` 语句。在两种情况下，jOOQ 都调用 `Result.fields()` 方法来确定列名。
- en: 'Here is an example that exports the generated `INSERT` statements into a file
    on disk. The `INSERT` statements are generated into a database table named `product_stats`
    specified via `formatInsert(Writer writer, Table<?> table, Field<?>… fields)`:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例，将生成的 `INSERT` 语句导出到磁盘上的文件。`INSERT` 语句生成到名为 `product_stats` 的数据库表中，该表通过
    `formatInsert(Writer writer, Table<?> table, Field<?>… fields)` 指定：
- en: '[PRE220]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE220]'
- en: '[PRE221]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE221]'
- en: '[PRE222]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE222]'
- en: '[PRE223]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE223]'
- en: '[PRE224]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE224]'
- en: '[PRE225]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE225]'
- en: '[PRE226]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE226]'
- en: '[PRE227]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE227]'
- en: '[PRE228]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE228]'
- en: '[PRE229]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE229]'
- en: '[PRE230]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE230]'
- en: '[PRE231]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE231]'
- en: '[PRE232]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE232]'
- en: '[PRE233]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE233]'
- en: 'A generated `INSERT` statement looks like the following:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的 `INSERT` 语句看起来如下所示：
- en: '[PRE234]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE234]'
- en: The complete code next to other examples, including exporting `INSERT` statements
    for UDT, JSON, array, and embeddable types, is available in the bundled code,
    `Format` (available for MySQL and PostgreSQL). Next, let's talk about batching.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他示例旁边完整的代码，包括导出 UDT、JSON、数组和可嵌入类型的 `INSERT` 语句，可在捆绑的代码 `Format` 中找到（适用于 MySQL
    和 PostgreSQL）。接下来，让我们谈谈批处理。
- en: Batching
  id: totrans-299
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 批处理
- en: Batching can be the perfect solution for avoiding performance penalties caused
    by a significant number of separate database/network round trips representing
    inserts, deletes, updates, merges, and so on. For instance, without batching,
    having 1,000 inserts requires 1,000 separate round trips, while employing batching
    with a batch size of 30 will result in 34 separate round trips. The more inserts
    (statements) we have, the more helpful batching is.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 批处理可以是避免由大量单独的数据库/网络往返（表示插入、删除、更新、合并等）引起的性能惩罚的完美解决方案。例如，如果没有批处理，1000 个插入需要 1000
    个单独的往返，而使用批处理大小为 30 的批处理将导致 34 个单独的往返。我们拥有的插入（语句）越多，批处理就越有用。
- en: Batching via DSLContext.batch()
  id: totrans-301
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过 DSLContext.batch() 批处理
- en: 'The `DSLContext` class exposes a suite of `batch()` methods that allow us to
    execute a set of queries in batch mode. So, we have the following `batch()` methods:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '`DSLContext` 类公开了一系列 `batch()` 方法，允许我们在批处理模式下执行一组查询。因此，我们有以下 `batch()` 方法：'
- en: '[PRE235]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE235]'
- en: '[PRE236]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE236]'
- en: '[PRE237]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE237]'
- en: '[PRE238]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE238]'
- en: '[PRE239]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE239]'
- en: '[PRE240]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE240]'
- en: '[PRE241]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE241]'
- en: '[PRE242]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE242]'
- en: Behind the scenes, jOOQ implements these methods via JDBC's `addBatch()`. Each
    query is accumulated in the batch via `addBatch()`, and in the end, it calls the
    JDBC `executeBatch()` method to send the batch to the database.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在幕后，jOOQ 通过 JDBC 的 `addBatch()` 实现这些方法。每个查询通过 `addBatch()` 累积到批处理中，最后它调用 JDBC
    的 `executeBatch()` 方法将批处理发送到数据库。
- en: 'For instance, let''s assume that we need to batch a set of `INSERT` statements
    into the `SALE` table. If you have a Hibernate (JPA) background, then you know
    that this kind of batch will not work because the `SALE` table has an auto-incremented
    primary key, and Hibernate will automatically disable/prevent insert batching.
    But, jOOQ doesn''t have such issues, so batching a set of inserts into a table
    having an auto-incremented primary key can be done via `batch(Query... queries)`,
    as follows:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们需要将一组 `INSERT` 语句批处理到 `SALE` 表中。如果您有 Hibernate（JPA）背景，那么您知道这种批处理将不起作用，因为
    `SALE` 表有一个自动增长的键，Hibernate 将自动禁用/阻止插入批处理。但是，jOOQ 没有这样的问题，因此可以通过 `batch(Query...
    queries)` 将一组插入批处理到具有自动增长键的表中，如下所示：
- en: '[PRE243]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE243]'
- en: '[PRE244]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE244]'
- en: '[PRE245]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE245]'
- en: '[PRE246]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE246]'
- en: '[PRE247]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE247]'
- en: '[PRE248]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE248]'
- en: '[PRE249]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE249]'
- en: '[PRE250]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE250]'
- en: '[PRE251]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE251]'
- en: 'The returned array contains the number of affected rows per `INSERT` statement
    (in this case, `[1, 1, 1, …]`). While executing several queries without bind values
    can be done as you just saw, jOOQ allows us to execute one query several times
    with bind values as follows:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的数组包含每个`INSERT`语句影响的行数（在这种情况下，`[1, 1, 1, …]`）。虽然可以像您刚才看到的那样执行不带绑定值的多个查询，但jOOQ允许我们多次执行一个查询，并带有绑定值，如下所示：
- en: '[PRE252]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE252]'
- en: '[PRE253]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE253]'
- en: '[PRE254]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE254]'
- en: '[PRE255]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE255]'
- en: '[PRE256]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE256]'
- en: '[PRE257]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE257]'
- en: '[PRE258]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE258]'
- en: '[PRE259]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE259]'
- en: Notice that you will have to provide *dummy* bind values for the original query,
    and this is commonly achieved via `null` values, as in this example. jOOQ generates
    a single query (`PreparedStatement`) with placeholders (`?`) and will loop the
    bind values to populate the batch. Whenever you see that `int[]` contains a negative
    value (for instance, `-2`) it means that the affected row count value couldn't
    be determined by JDBC.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，您将不得不为原始查询提供**虚拟**的绑定值，这通常通过`null`值来实现，如本例所示。jOOQ生成一个单独的查询（`PreparedStatement`），其中包含占位符（`?`），并将循环绑定值以填充批次。每当您看到`int[]`包含负值（例如，`-2`）时，这意味着受影响的行数值无法由JDBC确定。
- en: 'In most cases, JDBC prepared statements are better, so, whenever possible,
    jOOQ relies on `PreparedStatement` ([www.jooq.org/doc/latest/manual/sql-execution/statement-type/](http://www.jooq.org/doc/latest/manual/sql-execution/statement-type/)).
    But, we can easily switch to static statements (`java.sql.Statement`) via `setStatementType()`
    or `withStatementType()` as in the following example (you can also apply this
    globally via `@Bean`):'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，JDBC预编译语句更好，因此，只要可能，jOOQ就依赖于`PreparedStatement`（[www.jooq.org/doc/latest/manual/sql-execution/statement-type/](http://www.jooq.org/doc/latest/manual/sql-execution/statement-type/)）。但是，我们可以通过`setStatementType()`或`withStatementType()`轻松切换到静态语句（`java.sql.Statement`），如下例所示（您也可以通过`@Bean`全局应用此方法）：
- en: '[PRE260]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE260]'
- en: '[PRE261]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE261]'
- en: '[PRE262]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE262]'
- en: '[PRE263]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE263]'
- en: '[PRE264]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE264]'
- en: '[PRE265]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE265]'
- en: '[PRE266]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE266]'
- en: '[PRE267]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE267]'
- en: '[PRE268]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE268]'
- en: '[PRE269]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE269]'
- en: '[PRE270]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE270]'
- en: This time, the bind values will be automatically inlined into a static batch
    query. This is the same as the first examples from this section, which use `batch(Query...
    queries)`.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，绑定值将自动内联到静态批量查询中。这与本节第一例中的`batch(Query... queries)`使用相同。
- en: 'Obviously, using binding values is also useful for inserting (updating, deleting,
    and so on) a collection of objects. For instance, consider the following list
    of `SimpleSale` (POJO):'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，使用绑定值对于插入（更新、删除等）对象集合也是很有用的。例如，考虑以下`SimpleSale`（POJO）列表：
- en: '[PRE271]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE271]'
- en: '[PRE272]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE272]'
- en: '[PRE273]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE273]'
- en: '[PRE274]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE274]'
- en: 'First, we define the proper `BatchBindStep` containing one `INSERT` (it could
    be `UPDATE`, `DELETE`, and so on, as well):'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们定义适当的`BatchBindStep`，包含一个`INSERT`（它也可以是`UPDATE`、`DELETE`等）：
- en: '[PRE275]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE275]'
- en: '[PRE276]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE276]'
- en: '[PRE277]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE277]'
- en: '[PRE278]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE278]'
- en: 'Second, we bind the values and execute the batch:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 第二步，绑定值并执行批次：
- en: '[PRE279]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE279]'
- en: '[PRE280]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE280]'
- en: '[PRE281]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE281]'
- en: '[PRE282]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE282]'
- en: 'You can find these examples in the bundled code, `BatchInserts`, next to examples
    for batching updates, `BatchUpdates`, and deletes, `BatchDeletes`, as well. But,
    we can also combine all these kinds of statements in a single `batch()` method,
    as follows:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在捆绑的代码中找到这些示例，`BatchInserts`旁边还有批量更新示例`BatchUpdates`和删除示例`BatchDeletes`。但是，我们也可以将这些类型的所有语句组合在一个单独的`batch()`方法中，如下所示：
- en: '[PRE283]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE283]'
- en: '[PRE284]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE284]'
- en: '[PRE285]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE285]'
- en: '[PRE286]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE286]'
- en: '[PRE287]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE287]'
- en: '[PRE288]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE288]'
- en: '[PRE289]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE289]'
- en: '[PRE290]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE290]'
- en: '[PRE291]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE291]'
- en: '[PRE292]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE292]'
- en: '[PRE293]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE293]'
- en: '[PRE294]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE294]'
- en: '[PRE295]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE295]'
- en: '[PRE296]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE296]'
- en: '[PRE297]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE297]'
- en: '[PRE298]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE298]'
- en: '[PRE299]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE299]'
- en: '[PRE300]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE300]'
- en: '[PRE301]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE301]'
- en: '[PRE302]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE302]'
- en: '[PRE303]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE303]'
- en: While using `batch()` methods, jOOQ will always preserve your order of statements
    and will send all these statements in a single batch (round trip) to the database.
    This example is available in an application named *CombineBatchStatements*.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`batch()`方法时，jOOQ将始终保留您的语句顺序，并将所有这些语句作为一个单独的批次（往返）发送到数据库。此示例在名为*CombineBatchStatements*的应用程序中可用。
- en: During the batch preparation, the statements are accumulated in memory, so you
    have to pay attention to avoid memory issues such as OOMs. You can easily emulate
    a batch size by calling the jOOQ batch in a `for` loop that limits the number
    of statements to a certain value. You can execute all batches in a single transaction
    (in case of an issue, roll back all batches) or execute each batch in a separate
    transaction (in case of an issue, roll back only the last batch). You can see
    these approaches in the bundled code, `EmulateBatchSize`.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 在批量准备过程中，语句被累积在内存中，因此您必须注意避免内存问题，如OOMs。您可以通过在`for`循环中调用jOOQ批量来轻松模拟批量大小，该循环限制语句的数量为某个值。您可以在单个事务中执行所有批次（如果出现问题，则回滚所有批次）或在每个单独的事务中执行每个批次（如果出现问题，则仅回滚最后一个批次）。您可以在捆绑的代码中看到这些方法，例如`EmulateBatchSize`。
- en: While a synchronous batch ends up with an `execute()` call, an asynchronous
    batch ends up with an `executeAsync()` call. For example, consider the application
    named *AsyncBatch*. Next, let's talk about batching records.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 同步批量最终会以`execute()`调用结束，而异步批量最终会以`executeAsync()`调用结束。例如，考虑名为*AsyncBatch*的应用程序。接下来，让我们谈谈批量记录。
- en: Batching records
  id: totrans-385
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 批量记录
- en: 'Batching records is another story. The jOOQ API for batching records relies
    on a set of dedicated methods per statement type as follows:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 批量处理记录是另一回事。jOOQ API 为批量处理记录依赖于每个语句类型的一组专用方法，如下所示：
- en: '`INSERT`: `batchInsert()` follows `TableRecord.insert()` semantics'
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`INSERT`: `batchInsert()` 遵循 `TableRecord.insert()` 语义'
- en: '`UPDATE`: `batchUpdate()` follows `UpdatableRecord.update()` semantics'
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UPDATE`: `batchUpdate()` 遵循 `UpdatableRecord.update()` 语义'
- en: '`DELETE`: `batchDelete()` follows `UpdatableRecord.delete()` semantics'
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DELETE`: `batchDelete()` 遵循 `UpdatableRecord.delete()` 语义'
- en: '`MERGE`: `batchMerge()` follows `UpdatableRecord.merge()` semantics'
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MERGE`: `batchMerge()` 遵循 `UpdatableRecord.merge()` 语义'
- en: '`INSERT`/`UPDATE`: `batchStore()` follows `UpdatableRecord.store()` semantics'
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`INSERT`/`UPDATE`: `batchStore()` 遵循 `UpdatableRecord.store()` 语义'
- en: Next, we'll cover each of these statements but before that, let's point out
    an important aspect. By default, all these methods create batch operations for
    executing a certain type of query with bind values. jOOQ preserves the order of
    the records as long as the records generate the same SQL with bind variables,
    otherwise, the order is changed to group together the records that share the same
    SQL with bind variables. So, in the best-case scenario, when all records generate
    the same SQL with bind variables, there will be a single batch operation, while
    in the worst-case scenario, the number of records will be equal to the number
    of batch operations. In short, the number of batch operations that will be executed
    is equal to the number of distinct rendered SQL statements.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将逐一介绍这些语句，但在那之前，让我们指出一个重要方面。默认情况下，所有这些方法都会为执行特定类型的查询并绑定值创建批量操作。jOOQ只要记录生成相同的
    SQL 并带有绑定变量，就会保留记录的顺序；否则，顺序会改变，将具有相同 SQL 并带有绑定变量的记录分组在一起。因此，在最佳情况下，当所有记录都生成相同的
    SQL 并带有绑定变量时，将只有一个批量操作，而在最坏情况下，记录的数量将与批量操作的数量相等。简而言之，将要执行的批量操作数量等于生成的不同 SQL 语句的数量。
- en: If we switch from the default `PreparedStatement` to a static `Statement` (`StatementType.STATIC_STATEMENT`),
    then the record values are inlined. This time, there will be just one batch operation
    and the order of records is preserved exactly. Obviously, this is preferable when
    the order of records must be preserved and/or the batch is very large, and rearranging
    the records can be time-consuming and results in a significant number of batch
    operations.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们从默认的 `PreparedStatement` 切换到静态 `Statement` (`StatementType.STATIC_STATEMENT`)，那么记录值将被内联。这次，将只有一个批量操作，并且记录的顺序将完全保留。显然，当必须保留记录的顺序并且/或者批量非常大，重新排列记录可能耗时且导致大量批量操作时，这是首选的。
- en: Batch records insert, update, and delete
  id: totrans-394
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 批量记录插入、更新和删除
- en: 'Let''s consider the following set of `Record`:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑以下 `Record` 集合：
- en: '[PRE304]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE304]'
- en: '[PRE305]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE305]'
- en: '[PRE306]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE306]'
- en: 'Inserting these records in batch can be done as follows:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 批量插入这些记录可以这样做：
- en: '[PRE307]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE307]'
- en: 'In this case, these records are inserted in a single batch operation since
    the generated SQL with bind variables is the same for `sr1` to `sr3`. Moreover,
    the batch preserves the order of records as given (`sr3`, `sr1`, and `sr2`). If
    we want to update, and respectively to delete these records, then we replace `batchInsert()`
    with `batchUpdate()`, and, respectively, `batchDelete()`. You can also have these
    records in a collection and pass that collection to `batchInsert()`, as in this
    example:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，这些记录在一个批量操作中插入，因为为 `sr1` 到 `sr3` 生成的 SQL 并带有绑定变量是相同的。此外，批量操作保留了记录的顺序（即
    `sr3`, `sr1`, 和 `sr2`）。如果我们想更新这些记录，并分别删除这些记录，那么我们将 `batchInsert()` 替换为 `batchUpdate()`，并分别替换为
    `batchDelete()`。您也可以将这些记录放在一个集合中，并将该集合传递给 `batchInsert()`，如下例所示：
- en: '[PRE308]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE308]'
- en: '[PRE309]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE309]'
- en: 'Next, let''s consider a mix of records:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们考虑记录的混合：
- en: '[PRE310]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE310]'
- en: '[PRE311]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE311]'
- en: '[PRE312]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE312]'
- en: '[PRE313]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE313]'
- en: '[PRE314]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE314]'
- en: '[PRE315]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE315]'
- en: Calling `batchInsert(bt1, sr1, sr2, bt2, sr4, sr3)` is executed in two batch
    operations, one for `SaleRecord` and one for `BankTransactionRecord`. jOOQ will
    group `SaleRecord` (`sr1`, `sr2`, `sr3`, and `sr4`) in one batch operation and
    `BankTransactionRecord` (`bt1` and `bt2`) in another batch operation, so the order
    of records in not preserved (or, is partially preserved) since (`bt1`, `sr1`,
    `sr2`, `bt2`, `sr4`, and `sr3`) may become ((`bt1` and `bt2`), (`sr1`, `sr2`,
    `sr4`, and `sr3`)).
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 `batchInsert(bt1, sr1, sr2, bt2, sr4, sr3)` 将执行两个批量操作，一个用于 `SaleRecord`，另一个用于
    `BankTransactionRecord`。jOOQ会将 `SaleRecord` (`sr1`, `sr2`, `sr3`, 和 `sr4`) 分组在一个批量操作中，并将
    `BankTransactionRecord` (`bt1` 和 `bt2`) 分组在另一个批量操作中，因此记录的顺序不会保留（或者部分保留），因为 (`bt1`,
    `sr1`, `sr2`, `bt2`, `sr4`, 和 `sr3`) 可能会变成 ((`bt1` 和 `bt2`), (`sr1`, `sr2`, `sr4`,
    和 `sr3`)).
- en: 'Finally, let''s consider these records:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们考虑这些记录：
- en: '[PRE316]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE316]'
- en: '[PRE317]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE317]'
- en: '[PRE318]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE318]'
- en: '[PRE319]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE319]'
- en: '[PRE320]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE320]'
- en: '[PRE321]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE321]'
- en: '[PRE322]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE322]'
- en: '[PRE323]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE323]'
- en: '[PRE324]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE324]'
- en: '[PRE325]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE325]'
- en: '[PRE326]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE326]'
- en: '[PRE327]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE327]'
- en: '[PRE328]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE328]'
- en: '[PRE329]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE329]'
- en: '[PRE330]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE330]'
- en: '[PRE331]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE331]'
- en: '[PRE332]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE332]'
- en: '[PRE333]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE333]'
- en: If we execute `batchInsert(sr3, sr2, sr1)`, then there will be three batch operations,
    since `sr1`, `sr2`, and `sr3` produce three SQLs that will different bind variables.
    The order of records is preserved as `sr3`, `sr2`, and `sr1`. The same flow applies
    for `batchUpdate()` and `batchDelete()`.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们执行 `batchInsert(sr3, sr2, sr1)`，那么将有三个批处理操作，因为 `sr1`、`sr2` 和 `sr3` 产生了三个不同的
    SQL，它们将具有不同的绑定变量。记录的顺序保持为 `sr3`、`sr2` 和 `sr1`。对于 `batchUpdate()` 和 `batchDelete()`
    也适用相同的流程。
- en: 'Any of these examples can take advantage of JDBC static statements by simply
    adding the `STATIC_STATEMENT` setting as follows:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 这些示例中的任何一个都可以通过简单地添加 `STATIC_STATEMENT` 设置来利用 JDBC 静态语句，如下所示：
- en: '[PRE334]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE334]'
- en: '[PRE335]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE335]'
- en: '[PRE336]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE336]'
- en: You can practice these examples in *BatchInserts*, *BatchUpdates*, and *BatchDeletes*.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 *BatchInserts*、*BatchUpdates* 和 *BatchDeletes* 中练习这些示例。
- en: Batch merge
  id: totrans-437
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 批处理合并
- en: As you already know from the bullet list from the *Batching records* section,
    `batchMerge()` is useful for executing batches of `MERGE` statements. Mainly,
    `batchMerge()` conforms to the `UpdatableRecord.merge()` semantics covered in
    [*Chapter 9*](B16833_09.xhtml#_idTextAnchor162), *CRUD, Transactions, and Locking*.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从 *批处理记录* 部分的要点列表中已经知道，`batchMerge()` 对于执行批处理 `MERGE` 语句非常有用。主要来说，`batchMerge()`
    符合在 [*第 9 章*](B16833_09.xhtml#_idTextAnchor162) 中提到的 `UpdatableRecord.merge()`
    语义，*CRUD、事务和锁定*。
- en: 'In other words, `batchMerge()` renders the synthetic `INSERT ... ON DUPLICATE
    KEY UPDATE` statement emulated depending on dialect; in MySQL, via `INSERT ...
    ON DUPLICATE KEY UPDATE`, in PostgreSQL, via `INSERT ... ON CONFLICT`, and in
    SQL Server and Oracle, via `MERGE INTO`. Practically, `batchMerge()` renders an
    `INSERT ... ON DUPLICATE KEY UPDATE` statement independent of the fact that the
    record has been previously fetched from the database or is created now. The number
    of distinct rendered SQL statements gives us the number of batches. So, by default
    (which means default settings, default changed flags, and no optimistic locking),
    jOOQ renders a query that delegates to the database the decision between insert
    and update based on the primary key uniqueness. Let''s consider the following
    records:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，`batchMerge()` 根据方言生成模拟的 `INSERT ... ON DUPLICATE KEY UPDATE` 语句；在 MySQL
    中，通过 `INSERT ... ON DUPLICATE KEY UPDATE`，在 PostgreSQL 中，通过 `INSERT ... ON CONFLICT`，在
    SQL Server 和 Oracle 中，通过 `MERGE INTO`。实际上，`batchMerge()` 生成的 `INSERT ... ON DUPLICATE
    KEY UPDATE` 语句与记录是否已经从数据库中检索出来或现在创建无关。生成的不同 SQL 语句的数量给出了批次的数量。因此，默认情况下（这意味着默认设置、默认更改标志和没有乐观锁定），jOOQ
    生成的查询将委托给数据库根据主键的唯一性来决定是插入还是更新。让我们考虑以下记录：
- en: '[PRE337]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE337]'
- en: '[PRE338]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE338]'
- en: '[PRE339]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE339]'
- en: 'We execute a merge in batch as shown here:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 我们按照以下方式执行批处理合并：
- en: '[PRE340]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE340]'
- en: 'For instance, in PostgreSQL, the render SQL is as follows:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在 PostgreSQL 中，生成的 SQL 如下所示：
- en: '[PRE341]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE341]'
- en: '[PRE342]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE342]'
- en: '[PRE343]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE343]'
- en: '[PRE344]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE344]'
- en: '[PRE345]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE345]'
- en: '[PRE346]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE346]'
- en: Because `sr1` (having primary key *1*) and `sr2` (having primary key *2*) already
    exist in the `SALE` table, the database will decide to update them, while `sr3`
    (having primary key *9999*) will be inserted, since it doesn't exist in the database.
    There will be just one batch since the generated SQL with bind variables is the
    same for all `SaleRecord`. The order of records is preserved. More examples are
    available in `BatchMerges`.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 `sr1`（主键为 *1*）和 `sr2`（主键为 *2*）已经存在于 `SALE` 表中，数据库将决定更新它们，而 `sr3`（主键为 *9999*）将被插入，因为它在数据库中不存在。由于所有
    `SaleRecord` 生成的带有绑定变量的 SQL 是相同的，所以将只有一个批次。记录的顺序被保留。更多示例可以在 `BatchMerges` 中找到。
- en: Batch store
  id: totrans-453
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 批处理存储
- en: '`batchStore()` is useful for executing `INSERT` or `UPDATE` statements in the
    batch. Mainly, `batchStore()` conforms to `UpdatableRecord.store()`, which was
    covered in the previous chapter. So, unlike `batchMerge()`, which delegates the
    decision of choosing between update or insert to the database, `batchStore()`
    allows jOOQ to decide whether INSERT or UPDATE should be rendered by analyzing
    the state of the primary key''s value.'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: '`batchStore()` 对于执行批处理中的 `INSERT` 或 `UPDATE` 语句非常有用。主要来说，`batchStore()` 符合上一章中提到的
    `UpdatableRecord.store()`。因此，与 `batchMerge()` 不同，后者将选择更新或插入的决定委托给数据库，`batchStore()`
    允许 jOOQ 通过分析主键值的当前状态来决定是否生成 INSERT 或 UPDATE。'
- en: 'For instance, let''s rely on defaults (which means default settings, default
    changed flags, and no optimistic locking), the following two records are used
    for executing in a batch store:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们依赖默认设置（这意味着默认设置、默认更改标志和没有乐观锁定），以下两个记录将用于批处理存储执行：
- en: '[PRE347]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE347]'
- en: '[PRE348]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE348]'
- en: '[PRE349]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE349]'
- en: '[PRE350]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE350]'
- en: '[PRE351]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE351]'
- en: '[PRE352]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE352]'
- en: Since `sr1` is a brand-new `SaleRecord`, it will result in `INSERT`. On the
    other hand, `sr2` was fetched from the database and it was updated, so it will
    result in `UPDATE`. Obviously, the generated SQL statements are not the same,
    therefore, there will be two batch operations and the order will be preserved
    as `sr1` and `sr2`.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `sr1` 是一个全新的 `SaleRecord`，它将导致 `INSERT`。另一方面，`sr2` 从数据库中获取并更新了，所以它将导致 `UPDATE`。显然，生成的
    SQL 语句不相同，因此，将有两个批处理操作，并且顺序将保留为 `sr1` 和 `sr2`。
- en: 'Here is another example that updates `SaleRecord` and adds a few more:'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还有一个更新 `SaleRecord` 并添加更多内容的示例：
- en: '[PRE353]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE353]'
- en: '[PRE354]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE354]'
- en: '[PRE355]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE355]'
- en: '[PRE356]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE356]'
- en: '[PRE357]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE357]'
- en: '[PRE358]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE358]'
- en: '[PRE359]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE359]'
- en: '[PRE360]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE360]'
- en: '[PRE361]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE361]'
- en: 'We have two batch operations: a batch that contains all updates needed to update
    the fetched `SaleRecord` and a batch that contains all inserts needed to insert
    the new `SaleRecord`.'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两种批处理操作：一个包含所有更新所需更新获取的 `SaleRecord` 的批处理，以及一个包含所有插入所需插入新 `SaleRecord` 的批处理。
- en: In the bundled code, you can find more examples that couldn't be listed here
    because they are large, so take your time to practice examples from `BatchStores`.
    This was the last topic of this section. Next, let's talk about the *batched connection*
    API.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 在捆绑的代码中，你可以找到更多无法在此列出因为它们很大的示例，所以请花时间练习 `BatchStores` 中的示例。这是本节最后一个主题。接下来，让我们谈谈
    *批处理连接* API。
- en: Batched connection
  id: totrans-475
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 批处理连接
- en: Besides the batching capabilities covered so far, jOOQ also comes with an API
    named `org.jooq.tools.jdbc.BatchedConnection`. Its main purpose is to buffer already
    existing jOOQ/JDBC statements and execute them in batches without requiring us
    to change the SQL strings or the order of execution. We can use `BatchedConnection`
    explicitly or indirectly via `DSLContext.batched``(BatchedRunnable runnable)`
    or `DSLContext.batchedResult``(BatchedCallable<T> callable)`. The difference between
    them consists of the fact that the former returns `void` and the latter returns
    `T`.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 除了前面提到的批处理功能外，jOOQ还提供了一个名为 `org.jooq.tools.jdbc.BatchedConnection` 的API。其主要目的是缓冲现有的jOOQ/JDBC语句，并在不要求我们更改SQL字符串或执行顺序的情况下批量执行它们。我们可以显式或间接地通过
    `DSLContext.batched`(`BatchedRunnable runnable`) 或 `DSLContext.batchedResult`(`BatchedCallable<T>
    callable`) 来使用 `BatchedConnection`。它们之间的区别在于前者返回 `void`，而后者返回 `T`。
- en: 'For instance, let''s assume that we have a method (service) that produces a
    lot of `INSERT` and `UPDATE` statements:'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们有一个（服务）方法，它会产生大量的 `INSERT` 和 `UPDATE` 语句：
- en: '[PRE362]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE362]'
- en: '[PRE363]'
  id: totrans-479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE363]'
- en: '[PRE364]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE364]'
- en: '[PRE365]'
  id: totrans-481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE365]'
- en: '[PRE366]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE366]'
- en: '[PRE367]'
  id: totrans-483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE367]'
- en: '[PRE368]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE368]'
- en: 'To improve the performance of this method, we can simply add batch-collecting
    code via `DSLContext.batched()`, as here:'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提高此方法的速度，我们只需通过 `DSLContext.batched()` 添加批收集代码，如下所示：
- en: '[PRE369]'
  id: totrans-486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE369]'
- en: '[PRE370]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE370]'
- en: '[PRE371]'
  id: totrans-488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE371]'
- en: 'Of course, if `INSERT` statements are produced by an `inserts(Configuration
    c)` method and `UPDATE` statements by another method, `updates(Configuration c)`,
    then both of them should be collected:'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果 `INSERT` 语句由 `inserts(Configuration c)` 方法生成，而 `UPDATE` 语句由另一个方法 `updates(Configuration
    c)` 生成，那么两者都应该被收集：
- en: '[PRE372]'
  id: totrans-490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE372]'
- en: '[PRE373]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE373]'
- en: '[PRE374]'
  id: totrans-492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE374]'
- en: '[PRE375]'
  id: totrans-493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE375]'
- en: '[PRE376]'
  id: totrans-494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE376]'
- en: '[PRE377]'
  id: totrans-495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE377]'
- en: 'Moreover, this API can be used for batching jOOQ records as well. Here is a
    sample:'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，此API还可以用于批处理jOOQ记录。以下是一个示例：
- en: '[PRE378]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE378]'
- en: '[PRE379]'
  id: totrans-498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE379]'
- en: '[PRE380]'
  id: totrans-499
  prefs: []
  type: TYPE_PRE
  zh: '[PRE380]'
- en: '[PRE381]'
  id: totrans-500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE381]'
- en: '[PRE382]'
  id: totrans-501
  prefs: []
  type: TYPE_PRE
  zh: '[PRE382]'
- en: '[PRE383]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE383]'
- en: '[PRE384]'
  id: totrans-503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE384]'
- en: '[PRE385]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE385]'
- en: '[PRE386]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE386]'
- en: 'Or, here is another example:'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，这里还有一个例子：
- en: '[PRE387]'
  id: totrans-507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE387]'
- en: '[PRE388]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE388]'
- en: '[PRE389]'
  id: totrans-509
  prefs: []
  type: TYPE_PRE
  zh: '[PRE389]'
- en: '[PRE390]'
  id: totrans-510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE390]'
- en: '[PRE391]'
  id: totrans-511
  prefs: []
  type: TYPE_PRE
  zh: '[PRE391]'
- en: '[PRE392]'
  id: totrans-512
  prefs: []
  type: TYPE_PRE
  zh: '[PRE392]'
- en: '[PRE393]'
  id: totrans-513
  prefs: []
  type: TYPE_PRE
  zh: '[PRE393]'
- en: '[PRE394]'
  id: totrans-514
  prefs: []
  type: TYPE_PRE
  zh: '[PRE394]'
- en: '[PRE395]'
  id: totrans-515
  prefs: []
  type: TYPE_PRE
  zh: '[PRE395]'
- en: '[PRE396]'
  id: totrans-516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE396]'
- en: '[PRE397]'
  id: totrans-517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE397]'
- en: '[PRE398]'
  id: totrans-518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE398]'
- en: Notice that jOOQ will preserve exactly your order of statements and this order
    may affect the number of batch operations. Read carefully the following note,
    since it is very important to have it in your mind while working with this API.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，jOOQ将保留你的语句顺序，这个顺序可能会影响批处理操作的数量。仔细阅读以下说明，因为它在工作与此API时非常重要。
- en: Important Note
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'jOOQ automatically creates a new batch every time it detects that:'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: jOOQ每次检测到以下情况时，都会自动创建一个新的批处理：
- en: '- The SQL string changes (even whitespace is considered a change).'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: '- SQL 字符串发生变化（甚至空白也被视为变化）。'
- en: '- A query produces results (for instance, `SELECT`); such queries are not part
    of the batch.'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: '- 一个查询产生结果（例如，`SELECT`）；此类查询不是批处理的一部分。'
- en: '- A static statement occurs after a prepared statement (or vice versa).'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: '- 一个静态语句出现在预处理语句之后（或反之亦然）。'
- en: '- A JDBC interaction is invoked (transaction committed, connection closed,
    and so on).'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: '- 调用了一个 JDBC 交互（事务提交，连接关闭等）。'
- en: '- The batch size threshold is reached.'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 批处理大小阈值已达到。
- en: As an important limitation, notice that the affected row count value will be
    reported always by the JDBC `PreparedStatement.executeUpdate()` as 0.
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一项重要限制，请注意，受影响的行数值始终由JDBC `PreparedStatement.executeUpdate()` 报告为0。
- en: 'Notice that the last bullet from the previous note refers to a batch size threshold.
    Well, this API can take advantage of `Settings.batchSize()`, which sets the maximum
    batch statement size as here:'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，上一条说明中的最后一个项目指的是批处理大小阈值。嗯，这个API可以利用 `Settings.batchSize()`，它设置最大批处理语句大小如下：
- en: '[PRE399]'
  id: totrans-529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE399]'
- en: '[PRE400]'
  id: totrans-530
  prefs: []
  type: TYPE_PRE
  zh: '[PRE400]'
- en: '[PRE401]'
  id: totrans-531
  prefs: []
  type: TYPE_PRE
  zh: '[PRE401]'
- en: '[PRE402]'
  id: totrans-532
  prefs: []
  type: TYPE_PRE
  zh: '[PRE402]'
- en: 'Moreover, if we rely on `BatchedConnection` explicitly, then we can wrap the
    JDBC connection and specify the batch size as an argument via the `BatchedConnection(Connection
    delegate, int batchSize)` constructor as follows (here, the batch size is set
    to 2; consider reading the comments):'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE403]'
  id: totrans-534
  prefs: []
  type: TYPE_PRE
  zh: '[PRE403]'
- en: '[PRE404]'
  id: totrans-535
  prefs: []
  type: TYPE_PRE
  zh: '[PRE404]'
- en: '[PRE405]'
  id: totrans-536
  prefs: []
  type: TYPE_PRE
  zh: '[PRE405]'
- en: '[PRE406]'
  id: totrans-537
  prefs: []
  type: TYPE_PRE
  zh: '[PRE406]'
- en: '[PRE407]'
  id: totrans-538
  prefs: []
  type: TYPE_PRE
  zh: '[PRE407]'
- en: '[PRE408]'
  id: totrans-539
  prefs: []
  type: TYPE_PRE
  zh: '[PRE408]'
- en: '[PRE409]'
  id: totrans-540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE409]'
- en: '[PRE410]'
  id: totrans-541
  prefs: []
  type: TYPE_PRE
  zh: '[PRE410]'
- en: '[PRE411]'
  id: totrans-542
  prefs: []
  type: TYPE_PRE
  zh: '[PRE411]'
- en: '[PRE412]'
  id: totrans-543
  prefs: []
  type: TYPE_PRE
  zh: '[PRE412]'
- en: '[PRE413]'
  id: totrans-544
  prefs: []
  type: TYPE_PRE
  zh: '[PRE413]'
- en: '[PRE414]'
  id: totrans-545
  prefs: []
  type: TYPE_PRE
  zh: '[PRE414]'
- en: '[PRE415]'
  id: totrans-546
  prefs: []
  type: TYPE_PRE
  zh: '[PRE415]'
- en: '[PRE416]'
  id: totrans-547
  prefs: []
  type: TYPE_PRE
  zh: '[PRE416]'
- en: '[PRE417]'
  id: totrans-548
  prefs: []
  type: TYPE_PRE
  zh: '[PRE417]'
- en: '[PRE418]'
  id: totrans-549
  prefs: []
  type: TYPE_PRE
  zh: '[PRE418]'
- en: '[PRE419]'
  id: totrans-550
  prefs: []
  type: TYPE_PRE
  zh: '[PRE419]'
- en: '[PRE420]'
  id: totrans-551
  prefs: []
  type: TYPE_PRE
  zh: '[PRE420]'
- en: '[PRE421]'
  id: totrans-552
  prefs: []
  type: TYPE_PRE
  zh: '[PRE421]'
- en: '[PRE422]'
  id: totrans-553
  prefs: []
  type: TYPE_PRE
  zh: '[PRE422]'
- en: '[PRE423]'
  id: totrans-554
  prefs: []
  type: TYPE_PRE
  zh: '[PRE423]'
- en: '[PRE424]'
  id: totrans-555
  prefs: []
  type: TYPE_PRE
  zh: '[PRE424]'
- en: '[PRE425]'
  id: totrans-556
  prefs: []
  type: TYPE_PRE
  zh: '[PRE425]'
- en: '[PRE426]'
  id: totrans-557
  prefs: []
  type: TYPE_PRE
  zh: '[PRE426]'
- en: '[PRE427]'
  id: totrans-558
  prefs: []
  type: TYPE_PRE
  zh: '[PRE427]'
- en: '[PRE428]'
  id: totrans-559
  prefs: []
  type: TYPE_PRE
  zh: '[PRE428]'
- en: '[PRE429]'
  id: totrans-560
  prefs: []
  type: TYPE_PRE
  zh: '[PRE429]'
- en: '[PRE430]'
  id: totrans-561
  prefs: []
  type: TYPE_PRE
  zh: '[PRE430]'
- en: '[PRE431]'
  id: totrans-562
  prefs: []
  type: TYPE_PRE
  zh: '[PRE431]'
- en: '[PRE432]'
  id: totrans-563
  prefs: []
  type: TYPE_PRE
  zh: '[PRE432]'
- en: '[PRE433]'
  id: totrans-564
  prefs: []
  type: TYPE_PRE
  zh: '[PRE433]'
- en: '[PRE434]'
  id: totrans-565
  prefs: []
  type: TYPE_PRE
  zh: '[PRE434]'
- en: '[PRE435]'
  id: totrans-566
  prefs: []
  type: TYPE_PRE
  zh: '[PRE435]'
- en: '[PRE436]'
  id: totrans-567
  prefs: []
  type: TYPE_PRE
  zh: '[PRE436]'
- en: '[PRE437]'
  id: totrans-568
  prefs: []
  type: TYPE_PRE
  zh: '[PRE437]'
- en: '[PRE438]'
  id: totrans-569
  prefs: []
  type: TYPE_PRE
  zh: '[PRE438]'
- en: '[PRE439]'
  id: totrans-570
  prefs: []
  type: TYPE_PRE
  zh: '[PRE439]'
- en: '[PRE440]'
  id: totrans-571
  prefs: []
  type: TYPE_PRE
  zh: '[PRE440]'
- en: '[PRE441]'
  id: totrans-572
  prefs: []
  type: TYPE_PRE
  zh: '[PRE441]'
- en: '[PRE442]'
  id: totrans-573
  prefs: []
  type: TYPE_PRE
  zh: '[PRE442]'
- en: '[PRE443]'
  id: totrans-574
  prefs: []
  type: TYPE_PRE
  zh: '[PRE443]'
- en: '[PRE444]'
  id: totrans-575
  prefs: []
  type: TYPE_PRE
  zh: '[PRE444]'
- en: '[PRE445]'
  id: totrans-576
  prefs: []
  type: TYPE_PRE
  zh: '[PRE445]'
- en: '[PRE446]'
  id: totrans-577
  prefs: []
  type: TYPE_PRE
  zh: '[PRE446]'
- en: '[PRE447]'
  id: totrans-578
  prefs: []
  type: TYPE_PRE
  zh: '[PRE447]'
- en: '[PRE448]'
  id: totrans-579
  prefs: []
  type: TYPE_PRE
  zh: '[PRE448]'
- en: '[PRE449]'
  id: totrans-580
  prefs: []
  type: TYPE_PRE
  zh: '[PRE449]'
- en: '[PRE450]'
  id: totrans-581
  prefs: []
  type: TYPE_PRE
  zh: '[PRE450]'
- en: '[PRE451]'
  id: totrans-582
  prefs: []
  type: TYPE_PRE
  zh: '[PRE451]'
- en: '[PRE452]'
  id: totrans-583
  prefs: []
  type: TYPE_PRE
  zh: '[PRE452]'
- en: '[PRE453]'
  id: totrans-584
  prefs: []
  type: TYPE_PRE
  zh: '[PRE453]'
- en: '[PRE454]'
  id: totrans-585
  prefs: []
  type: TYPE_PRE
  zh: '[PRE454]'
- en: Moreover, `BatchedConnection` implements `java.sql.Connection`, so you can use
    the entire arsenal of `Connection` methods, including methods for shaping the
    behavior of transactions. More examples are available in `Batched`.
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's tackle two special cases encountered in PostgreSQL and SQL Server.
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
- en: Batching and fetching sequences in PostgreSQL/Oracle
  id: totrans-588
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As you know, PostgreSQL/Oracle can rely on sequences for providing primary
    keys (and other unique values). For instance, our PostgreSQL `employee` table
    uses the following sequence for producing sequence values for `employee_number`:'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE455]'
  id: totrans-590
  prefs: []
  type: TYPE_PRE
  zh: '[PRE455]'
- en: '[PRE456]'
  id: totrans-591
  prefs: []
  type: TYPE_PRE
  zh: '[PRE456]'
- en: '[PRE457]'
  id: totrans-592
  prefs: []
  type: TYPE_PRE
  zh: '[PRE457]'
- en: '[PRE458]'
  id: totrans-593
  prefs: []
  type: TYPE_PRE
  zh: '[PRE458]'
- en: '[PRE459]'
  id: totrans-594
  prefs: []
  type: TYPE_PRE
  zh: '[PRE459]'
- en: '[PRE460]'
  id: totrans-595
  prefs: []
  type: TYPE_PRE
  zh: '[PRE460]'
- en: '[PRE461]'
  id: totrans-596
  prefs: []
  type: TYPE_PRE
  zh: '[PRE461]'
- en: '[PRE462]'
  id: totrans-597
  prefs: []
  type: TYPE_PRE
  zh: '[PRE462]'
- en: '[PRE463]'
  id: totrans-598
  prefs: []
  type: TYPE_PRE
  zh: '[PRE463]'
- en: 'But, in the context of batching, fetching the `employee` primary keys from
    the application requires a database round trip (`SELECT`) for each primary key.
    Obviously, it is a performance penalty to have a batch of *n* `INSERT` statements
    and execute *n* round trips (`SELECT` statements) just to fetch their primary
    keys. Fortunately, jOOQ leverages at least two solutions. One of them is to inline
    sequence references in SQL statements (the `EMPLOYEE_SEQ.nextval()` call):'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE464]'
  id: totrans-600
  prefs: []
  type: TYPE_PRE
  zh: '[PRE464]'
- en: '[PRE465]'
  id: totrans-601
  prefs: []
  type: TYPE_PRE
  zh: '[PRE465]'
- en: '[PRE466]'
  id: totrans-602
  prefs: []
  type: TYPE_PRE
  zh: '[PRE466]'
- en: '[PRE467]'
  id: totrans-603
  prefs: []
  type: TYPE_PRE
  zh: '[PRE467]'
- en: '[PRE468]'
  id: totrans-604
  prefs: []
  type: TYPE_PRE
  zh: '[PRE468]'
- en: '[PRE469]'
  id: totrans-605
  prefs: []
  type: TYPE_PRE
  zh: '[PRE469]'
- en: '[PRE470]'
  id: totrans-606
  prefs: []
  type: TYPE_PRE
  zh: '[PRE470]'
- en: '[PRE471]'
  id: totrans-607
  prefs: []
  type: TYPE_PRE
  zh: '[PRE471]'
- en: '[PRE472]'
  id: totrans-608
  prefs: []
  type: TYPE_PRE
  zh: '[PRE472]'
- en: 'Another approach is to pre-fetch a number of *n* primary keys via `SELECT`:'
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE473]'
  id: totrans-610
  prefs: []
  type: TYPE_PRE
  zh: '[PRE473]'
- en: 'Then, use these primary keys in batch (notice the `ids.get(n).value1()` call):'
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE474]'
  id: totrans-612
  prefs: []
  type: TYPE_PRE
  zh: '[PRE474]'
- en: '[PRE475]'
  id: totrans-613
  prefs: []
  type: TYPE_PRE
  zh: '[PRE475]'
- en: '[PRE476]'
  id: totrans-614
  prefs: []
  type: TYPE_PRE
  zh: '[PRE476]'
- en: '[PRE477]'
  id: totrans-615
  prefs: []
  type: TYPE_PRE
  zh: '[PRE477]'
- en: '[PRE478]'
  id: totrans-616
  prefs: []
  type: TYPE_PRE
  zh: '[PRE478]'
- en: '[PRE479]'
  id: totrans-617
  prefs: []
  type: TYPE_PRE
  zh: '[PRE479]'
- en: '[PRE480]'
  id: totrans-618
  prefs: []
  type: TYPE_PRE
  zh: '[PRE480]'
- en: '[PRE481]'
  id: totrans-619
  prefs: []
  type: TYPE_PRE
  zh: '[PRE481]'
- en: '[PRE482]'
  id: totrans-620
  prefs: []
  type: TYPE_PRE
  zh: '[PRE482]'
- en: Both of these examples rely on the `public static final EMPLOYEE_SEQ` field
    or, more precisely, on `jooq.generated.Sequences.EMPLOYEE_SEQ`. Mainly, the jOOQ
    Code Generator will generate a sequence object per database sequence and each
    such object has access to methods such as `nextval()`, `currval()`, `nextvals(int
    n)`, and others, which will be covered in [*Chapter 11*](B16833_11.xhtml#_idTextAnchor209),
    *jOOQ Keys*.
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
- en: Of course, if you rely on an auto-generated sequence from (`BIG`)`SERIAL` or
    on a sequence associated as default (for example, in the `sale` table, we have
    a sequence associated to `sale_id` as `DEFAULT NEXTVAL ('sale_seq')`), then the
    simplest way to batch is to omit the primary key field in statements, and the
    database will do the rest. The previous examples, along with many more, are available
    in *BatchInserts* for PostgreSQL.
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
- en: SQL Server IDENTITY columns and explicit values
  id: totrans-623
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Inserting explicit values for the SQL Server `IDENTITY` columns results in
    the error *Cannot insert explicit value for identity column in table ''table_name''
    when* `IDENTITY_INSERT` *is set to* `OFF`. Bypassing this error can be done by
    setting `IDENTITY_INSERT` to `ON` before `INSERT`. In the context of batching,
    this can be done as shown here:'
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE483]'
  id: totrans-625
  prefs: []
  type: TYPE_PRE
  zh: '[PRE483]'
- en: '[PRE484]'
  id: totrans-626
  prefs: []
  type: TYPE_PRE
  zh: '[PRE484]'
- en: '[PRE485]'
  id: totrans-627
  prefs: []
  type: TYPE_PRE
  zh: '[PRE485]'
- en: '[PRE486]'
  id: totrans-628
  prefs: []
  type: TYPE_PRE
  zh: '[PRE486]'
- en: '[PRE487]'
  id: totrans-629
  prefs: []
  type: TYPE_PRE
  zh: '[PRE487]'
- en: '[PRE488]'
  id: totrans-630
  prefs: []
  type: TYPE_PRE
  zh: '[PRE488]'
- en: '[PRE489]'
  id: totrans-631
  prefs: []
  type: TYPE_PRE
  zh: '[PRE489]'
- en: '[PRE490]'
  id: totrans-632
  prefs: []
  type: TYPE_PRE
  zh: '[PRE490]'
- en: '[PRE491]'
  id: totrans-633
  prefs: []
  type: TYPE_PRE
  zh: '[PRE491]'
- en: You can find this example in `BatchInserts` for SQL Server. Next, let's talk
    about bulking.
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
- en: Bulking
  id: totrans-635
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Writing bulk queries in jOOQ is just a matter of using the jOOQ DSL API. For
    instance, a bulk insert SQL looks like this:'
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE492]'
  id: totrans-637
  prefs: []
  type: TYPE_PRE
  zh: '[PRE492]'
- en: '[PRE493]'
  id: totrans-638
  prefs: []
  type: TYPE_PRE
  zh: '[PRE493]'
- en: '[PRE494]'
  id: totrans-639
  prefs: []
  type: TYPE_PRE
  zh: '[PRE494]'
- en: '[PRE495]'
  id: totrans-640
  prefs: []
  type: TYPE_PRE
  zh: '[PRE495]'
- en: '[PRE496]'
  id: totrans-641
  prefs: []
  type: TYPE_PRE
  zh: '[PRE496]'
- en: 'This can be expressed in jOOQ by chaining the `values()` call:'
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以在jOOQ中通过链式调用`values()`方法表示：
- en: '[PRE497]'
  id: totrans-643
  prefs: []
  type: TYPE_PRE
  zh: '[PRE497]'
- en: '[PRE498]'
  id: totrans-644
  prefs: []
  type: TYPE_PRE
  zh: '[PRE498]'
- en: '[PRE499]'
  id: totrans-645
  prefs: []
  type: TYPE_PRE
  zh: '[PRE499]'
- en: '[PRE500]'
  id: totrans-646
  prefs: []
  type: TYPE_PRE
  zh: '[PRE500]'
- en: '[PRE501]'
  id: totrans-647
  prefs: []
  type: TYPE_PRE
  zh: '[PRE501]'
- en: '[PRE502]'
  id: totrans-648
  prefs: []
  type: TYPE_PRE
  zh: '[PRE502]'
- en: '[PRE503]'
  id: totrans-649
  prefs: []
  type: TYPE_PRE
  zh: '[PRE503]'
- en: '[PRE504]'
  id: totrans-650
  prefs: []
  type: TYPE_PRE
  zh: '[PRE504]'
- en: '[PRE505]'
  id: totrans-651
  prefs: []
  type: TYPE_PRE
  zh: '[PRE505]'
- en: '[PRE506]'
  id: totrans-652
  prefs: []
  type: TYPE_PRE
  zh: '[PRE506]'
- en: '[PRE507]'
  id: totrans-653
  prefs: []
  type: TYPE_PRE
  zh: '[PRE507]'
- en: '[PRE508]'
  id: totrans-654
  prefs: []
  type: TYPE_PRE
  zh: '[PRE508]'
- en: '[PRE509]'
  id: totrans-655
  prefs: []
  type: TYPE_PRE
  zh: '[PRE509]'
- en: '[PRE510]'
  id: totrans-656
  prefs: []
  type: TYPE_PRE
  zh: '[PRE510]'
- en: 'Or, you can use a bulk update SQL as follows:'
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以使用以下批量更新SQL：
- en: '[PRE511]'
  id: totrans-658
  prefs: []
  type: TYPE_PRE
  zh: '[PRE511]'
- en: '[PRE512]'
  id: totrans-659
  prefs: []
  type: TYPE_PRE
  zh: '[PRE512]'
- en: '[PRE513]'
  id: totrans-660
  prefs: []
  type: TYPE_PRE
  zh: '[PRE513]'
- en: '[PRE514]'
  id: totrans-661
  prefs: []
  type: TYPE_PRE
  zh: '[PRE514]'
- en: '[PRE515]'
  id: totrans-662
  prefs: []
  type: TYPE_PRE
  zh: '[PRE515]'
- en: '[PRE516]'
  id: totrans-663
  prefs: []
  type: TYPE_PRE
  zh: '[PRE516]'
- en: '[PRE517]'
  id: totrans-664
  prefs: []
  type: TYPE_PRE
  zh: '[PRE517]'
- en: '[PRE518]'
  id: totrans-665
  prefs: []
  type: TYPE_PRE
  zh: '[PRE518]'
- en: '[PRE519]'
  id: totrans-666
  prefs: []
  type: TYPE_PRE
  zh: '[PRE519]'
- en: '[PRE520]'
  id: totrans-667
  prefs: []
  type: TYPE_PRE
  zh: '[PRE520]'
- en: '[PRE521]'
  id: totrans-668
  prefs: []
  type: TYPE_PRE
  zh: '[PRE521]'
- en: '[PRE522]'
  id: totrans-669
  prefs: []
  type: TYPE_PRE
  zh: '[PRE522]'
- en: 'It can be expressed in jOOQ as follows:'
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以在jOOQ中表示如下：
- en: '[PRE523]'
  id: totrans-671
  prefs: []
  type: TYPE_PRE
  zh: '[PRE523]'
- en: '[PRE524]'
  id: totrans-672
  prefs: []
  type: TYPE_PRE
  zh: '[PRE524]'
- en: '[PRE525]'
  id: totrans-673
  prefs: []
  type: TYPE_PRE
  zh: '[PRE525]'
- en: '[PRE526]'
  id: totrans-674
  prefs: []
  type: TYPE_PRE
  zh: '[PRE526]'
- en: '[PRE527]'
  id: totrans-675
  prefs: []
  type: TYPE_PRE
  zh: '[PRE527]'
- en: '[PRE528]'
  id: totrans-676
  prefs: []
  type: TYPE_PRE
  zh: '[PRE528]'
- en: '[PRE529]'
  id: totrans-677
  prefs: []
  type: TYPE_PRE
  zh: '[PRE529]'
- en: More examples are available in `Bulk` for MySQL. Next, let's talk about the
    *Loader* API, which has built-in bulk support.
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: 更多示例可以在MySQL的`Bulk`中找到。接下来，让我们谈谈*Loader* API，它具有内置的批量支持。
- en: Loading (the Loader API)
  id: totrans-679
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加载（加载器API）
- en: Whenever we need to load (import) our database tables with data coming from
    different sources (CSV, JSON, and so on), we can rely on the jOOQ Loader API (`org.jooq.Loader`).
    This is a fluent API that allows us to smoothly tackle the most important challenges,
    such as handling duplicate keys, bulking, batching, committing, and error handling.
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们需要将来自不同来源（CSV、JSON等）的数据加载（导入）到我们的数据库表中时，我们可以依赖jOOQ加载器API（`org.jooq.Loader`）。这是一个流畅的API，它允许我们轻松应对最重要的挑战，例如处理重复键、批量处理、分批处理、提交和错误处理。
- en: The Loader API syntax
  id: totrans-681
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加载器API语法
- en: 'Typically, we have a file containing the data to be imported in a common format
    such as CSV or JSON, and we customize the Loader API general syntax to fit our
    needs:'
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们有一个包含要导入数据的文件，这些数据以CSV或JSON等常见格式存储，我们自定义加载器API的一般语法以适应我们的需求：
- en: '[PRE530]'
  id: totrans-683
  prefs: []
  type: TYPE_PRE
  zh: '[PRE530]'
- en: '[PRE531]'
  id: totrans-684
  prefs: []
  type: TYPE_PRE
  zh: '[PRE531]'
- en: '[PRE532]'
  id: totrans-685
  prefs: []
  type: TYPE_PRE
  zh: '[PRE532]'
- en: '[PRE533]'
  id: totrans-686
  prefs: []
  type: TYPE_PRE
  zh: '[PRE533]'
- en: '[PRE534]'
  id: totrans-687
  prefs: []
  type: TYPE_PRE
  zh: '[PRE534]'
- en: While `TARGET_TABLE` is obviously the table in which the data should be imported,
    let's see what options we have.
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`TARGET_TABLE`显然是应该导入数据的那张表，但让我们看看我们有哪些选项。
- en: Options
  id: totrans-689
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 选项
- en: 'We can mainly distinguish between three types of options that can be used for
    customizing the import process: options for handling duplicate keys, throttling
    options, and options for handling failures (errors). The following diagram highlights
    each category of options and the valid paths that can be used for chaining these
    options fluently:'
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以主要区分三种用于自定义导入过程的选项类型：处理重复键的选项、限制选项和处理失败（错误）的选项。以下图表突出了每个选项类别以及可以用于流畅链式调用这些选项的有效路径：
- en: '![Figure 10.3 – The Loader API options'
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.3 – 加载器API选项'
- en: '](img/B16833_Figure_10.3.jpg)'
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16833_Figure_10.3.jpg)'
- en: Figure 10.3 – The Loader API options
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.3 – 加载器API选项
- en: Let's explore each of these categories, starting with the one for tackling duplicate
    keys.
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索这些类别中的每一个，从处理重复键的类别开始。
- en: Duplicate keys options
  id: totrans-695
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 重复键选项
- en: A duplicate key occurs when a unique key exists in the table and we attempt
    to import a record having the same key. By unique key, jOOQ means any unique key,
    not only primary keys.
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: 当表中存在唯一键并且我们尝试导入具有相同键的记录时，会发生重复键。通过唯一键，jOOQ指的是任何唯一键，而不仅仅是主键。
- en: So, handling duplicate keys can be done via `onDuplicateKeyError()`, which is
    the default, or via `onDuplicateKeyIgnore()` or `onDuplicateKeyUpdate()`. The
    default behavior throws an exception if there are any duplicate keys.
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，处理重复键可以通过`onDuplicateKeyError()`来完成，这是默认行为，或者通过`onDuplicateKeyIgnore()`或`onDuplicateKeyUpdate()`。默认行为是在存在任何重复键时抛出异常。
- en: By explicitly using `onDuplicateKeyIgnore()`, we instruct jOOQ to skip any duplicate
    key without throwing an exception (this is the synthetic `ON DUPLICATE KEY IGNORE`
    clause, which can be emulated by jOOQ depending on dialect). We can instruct jOOQ
    to execute `UPDATE` instead of `INSERT` via `onDuplicateKeyUpdate()` (this is
    the synthetic `ON DUPLICATE KEY UPDATE` clause, which can be emulated by jOOQ
    depending on dialect).
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: 通过显式使用`onDuplicateKeyIgnore()`，我们指示jOOQ跳过任何重复键而不会抛出异常（这是合成的`ON DUPLICATE KEY
    IGNORE`子句，jOOQ可以根据方言进行模拟）。我们可以通过`onDuplicateKeyUpdate()`指示jOOQ执行`UPDATE`而不是`INSERT`（这是合成的`ON
    DUPLICATE KEY UPDATE`子句，jOOQ可以根据方言进行模拟）。
- en: Throttling options
  id: totrans-699
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 限制选项
- en: 'There are three throttling options that can be used to fine-tune the import.
    These options refer to bulking, batching, and committing. jOOQ allows us to explicitly
    use any combination of these options or to rely on the following defaults: no
    bulking, batching, and committing.'
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: 有三种限制选项可以用来微调导入过程。这些选项涉及批量处理、分批处理和提交。jOOQ允许我们显式使用这些选项的任何组合，或者依赖以下默认设置：无批量处理、分批处理和提交。
- en: Bulking can be set via `bulkNone()` (which is the default and means that no
    bulking will be used), `bulkAfter(int rows)` (which allows us to specify how many
    rows will be inserted in one bulk via a multi-row `INSERT` (`insert into ... (...)
    values (?, ?, ?,...), (?, ?, ?,...), (?, ?, ?,...), ...`), and `bulkAll()` (which
    attempts to create one bulk from the entire source of data).
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: 批量可以通过 `bulkNone()`（这是默认设置，表示不使用批量）设置，`bulkAfter(int rows)`（允许我们通过多行 `INSERT`（例如，`insert
    into ... (...) values (?, ?, ?,...), (?, ?, ?,...), (?, ?, ?,...), ...`）指定每个批量将插入多少行），以及
    `bulkAll()`（尝试从整个数据源创建一个批量）。
- en: As you can see from *Figure 10.3*, `bulkNone()` is the only one that can be
    chained after all options used for handling duplicate values. The `bulkAfter()`
    and `bulkAll()` methods can be chained only after `onDuplicateKeyError()`. Moreover,
    `bulkNone()`, `bulkAfter()`, and `bulkAll()` are mutually exclusive.
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: 如 *图10.3* 所示，`bulkNone()` 是唯一一个可以在处理重复值的所有选项之后链式调用的。`bulkAfter()` 和 `bulkAll()`
    方法只能在 `onDuplicateKeyError()` 之后链式调用。此外，`bulkNone()`、`bulkAfter()` 和 `bulkAll()`
    是互斥的。
- en: Batching can be avoided via the default `batchNone()`, or it can be explicitly
    set via `batchAfter(int bulk)` or `batchAll()`. Explicitly specifying the number
    of bulk statements that should be sent to the server as a single JDBC batch statement
    can be accomplished via `batchAfter(int bulk)`. On the other hand, sending a single
    batch containing all bulks can be done via `batchAll()`. If bulking is not used
    (`bulkNone()`) then it is as if each row represents a bulk, so, for instance,
    `batchAfter(3)` means to create batches of three rows each.
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过默认的 `batchNone()` 避免批处理，或者可以通过 `batchAfter(int bulk)` 或 `batchAll()` 明确设置。通过
    `batchAfter(int bulk)` 明确指定应作为单个 JDBC 批处理语句发送到服务器的批量语句数量。另一方面，可以通过 `batchAll()`
    发送包含所有批量的单个批量。如果没有使用批量（`bulkNone()`），那么每行就像是一个批量，因此，例如，`batchAfter(3)` 表示创建每批包含三行的批次。
- en: As you can see from *Figure 10.3*, `batchNone()`, `batchAfter()`, and `batchAll()`
    are mutually exclusive.
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: 如 *图10.3* 所示，`batchNone()`、`batchAfter()` 和 `batchAll()` 是互斥的。
- en: Finally, committing data to the database can be controlled via four dedicated
    methods. By default, `commitNone()` leaves committing and rolling back operations
    up to client code (for instance, via `commitNone()`, we can allow Spring Boot
    to handle commit and rollback). But, if we want to commit after a certain number
    of batches, then we have to use `commitAfter(int batches)` or the handy `commitEach()`
    method, which is equivalent to `commitAfter(1)`. And, if we decide to commit all
    batches at once, then we need `commitAll()`. If batching is not used (relying
    on `batchNone()`), then it is as if each batch is a bulk, (for instance, `commitAfter(3)`
    means to commit after every three bulks). If bulking is not used either (relying
    on `bulkNone()`), then it is as if each bulk is a row (for instance, `commitAfter(3)`
    means to commit after every three rows).
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将数据提交到数据库可以通过四种专用方法进行控制。默认情况下，`commitNone()` 将提交和回滚操作留给客户端代码（例如，通过 `commitNone()`，我们可以允许
    Spring Boot 处理提交和回滚）。但是，如果我们想在一定数量的批次之后提交，那么我们必须使用 `commitAfter(int batches)`
    或便捷的 `commitEach()` 方法，它等同于 `commitAfter(1)`。而且，如果我们决定一次性提交所有批次，那么我们需要 `commitAll()`。如果没有使用批处理（依赖于
    `batchNone()`），那么每个批次就像是一个批量，例如，`commitAfter(3)` 表示每三个批量后提交。如果没有使用批量（依赖于 `bulkNone()`），那么每个批量就像是一行，例如，`commitAfter(3)`
    表示每三行后提交。
- en: As you can see from *Figure 10.3*, `commitNone()`, `commitAfter()`, `commitEach()`,
    and `commitAll()` are mutually exclusive.
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: 如 *图10.3* 所示，`commitNone()`、`commitAfter()`、`commitEach()` 和 `commitAll()` 是互斥的。
- en: Error options
  id: totrans-707
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 错误选项
- en: Attempting to manipulate (import) large amounts of data is a process quite prone
    to errors. While some of the errors are fatal and should stop the importing process,
    others can be safely ignored or postponed to be resolved after import. In the
    case of fatal errors, the Loader API relies on a method named `onErrorAbort()`.
    If an error occurs, then the Loader API stops the import process. On the other
    hand, we have `onErrorIgnore()`, which instructs the Loader API to skip any insert
    that caused an error and try to execute the next one.
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试操作（导入）大量数据是一个很容易出错的流程。其中一些错误是致命的，应该停止导入过程，而其他错误可以安全地忽略或推迟到导入后解决。在致命错误的情况下，Loader
    API 依赖于名为 `onErrorAbort()` 的方法。如果发生错误，则 Loader API 停止导入过程。另一方面，我们有 `onErrorIgnore()`，它指示
    Loader API 跳过任何导致错误的插入操作，并尝试执行下一个操作。
- en: Special cases
  id: totrans-709
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 特殊情况
- en: 'While finding the optimal combination of these options is a matter of benchmarking,
    there are several things that you should know, as follows:'
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
- en: If there are no unique keys in our table then `onDuplicateKeyUpdate()` acts
    exactly as `onDuplicateKeyIgnore()`.
  id: totrans-711
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If `bulkAll()` + `commitEach()` or `bulkAll()` + `commitAfter()` is used, then
    jOOQ forces the usage of `commitAll()`.
  id: totrans-712
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If `batchAll()` + `commitEach()` or `batchAll()` + `commitAfter()` is used,
    then jOOQ forces the usage of `commitAll()`.
  id: totrans-713
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, let's quickly cover the supported sources of data.
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
- en: Importing data sources
  id: totrans-715
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Providing the source of data can be accomplished via dedicated methods that
    are specific to the supported different data types. For instance, if the data
    source is a CSV file, then we rely on the `loadCSV()` method; if it is a JSON
    file, then we rely on the `loadJSON()` method; and if it is an XML file, then
    we rely on `loadXML()`. Moreover, we can import arrays via `loadArrays()` and
    jOOQ `Record`s via `loadRecords()`.
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
- en: The `loadCSV()`, `loadJSON()`, and `loadXML()` methods come in 10+ flavors that
    allow us to load data from `String`, `File`, `InputStream`, and `Reader`. On the
    other hand, `loadArrays()` and `loadRecords()` allow us to load data from an array,
    `Iterable`, `Iterator`, or `Stream`.
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
- en: Listeners
  id: totrans-718
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Loader API comes with import listeners to be chained for keeping track of
    import progress. We mainly have `onRowStart(LoaderRowListener listener)` and `onRowEnd``(LoaderRowListener
    listener)`. The former specifies a listener to be invoked before processing the
    current row, while the latter specifies a listener to be invoked after processing
    the current row. `LoaderRowListener` is a functional interface.
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
- en: Execution and error handling
  id: totrans-720
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: After the Loader API is executed, we have access to meaningful feedback that
    is available through the returned `org.jooq.Loader`. For instance, we can find
    out the number of executed bulks/batches via the `executed()` method, the number
    of processed rows via the `processed()` method, the number of stored rows (`INSERT`/`UPDATE`)
    via the `stored()` method, the number of ignored rows (caused by errors or duplicate
    keys) via the `ignored()` method, and the potential errors via the `errors()`
    method as `List<LoaderError>`. As you'll see in the next section of examples,
    `LoaderError` contains details about the errors (if any).
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
- en: Examples of using the Loader API
  id: totrans-722
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Finally, after all this theory, it is time to see some examples of loading
    CSV, JSON, `Record`, and arrays. All these examples are executed and dissected
    in the context of Spring Boot `@Transactional`. Feel free to practice them under
    the jOOQ transactional context by simply removing `@Transactional` and wrapping
    the code as follows:'
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE535]'
  id: totrans-724
  prefs: []
  type: TYPE_PRE
  zh: '[PRE535]'
- en: '[PRE536]'
  id: totrans-725
  prefs: []
  type: TYPE_PRE
  zh: '[PRE536]'
- en: '[PRE537]'
  id: totrans-726
  prefs: []
  type: TYPE_PRE
  zh: '[PRE537]'
- en: '[PRE538]'
  id: totrans-727
  prefs: []
  type: TYPE_PRE
  zh: '[PRE538]'
- en: So, let's start by loading some CSV.
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
- en: Loading CSV
  id: totrans-729
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Loading CSV is accomplished via the `loadCSV()` method. Let''s start with a
    simple example based on the following typical CSV file (`in.csv`):'
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE539]'
  id: totrans-731
  prefs: []
  type: TYPE_PRE
  zh: '[PRE539]'
- en: '[PRE540]'
  id: totrans-732
  prefs: []
  type: TYPE_PRE
  zh: '[PRE540]'
- en: '[PRE541]'
  id: totrans-733
  prefs: []
  type: TYPE_PRE
  zh: '[PRE541]'
- en: '[PRE542]'
  id: totrans-734
  prefs: []
  type: TYPE_PRE
  zh: '[PRE542]'
- en: '[PRE543]'
  id: totrans-735
  prefs: []
  type: TYPE_PRE
  zh: '[PRE543]'
- en: 'Obviously, this data should be imported in the `sale` table, so `TARGET_TABLE`
    (`Table<R>`) that should be passed to `loadInto()` is `SALE`. Pointing jOOQ to
    this file is accomplished via the `loadCSV()` method as follows:'
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE544]'
  id: totrans-737
  prefs: []
  type: TYPE_PRE
  zh: '[PRE544]'
- en: '[PRE545]'
  id: totrans-738
  prefs: []
  type: TYPE_PRE
  zh: '[PRE545]'
- en: '[PRE546]'
  id: totrans-739
  prefs: []
  type: TYPE_PRE
  zh: '[PRE546]'
- en: '[PRE547]'
  id: totrans-740
  prefs: []
  type: TYPE_PRE
  zh: '[PRE547]'
- en: '[PRE548]'
  id: totrans-741
  prefs: []
  type: TYPE_PRE
  zh: '[PRE548]'
- en: This code relies on the default options. Notice the call of the `fieldsCorresponding()`
    method. This method signals to jOOQ that all input fields having a corresponding
    field in `SALE` (with the same name) should be loaded. Practically, in this case,
    all fields from the CSV file have a correspondent in the `SALE` table, so all
    of them will be imported.
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
- en: 'But, obviously, this is not always the case. Maybe we want to load only a subset
    of scattered fields. In such cases, simply pass *dummy* nulls for the field indexes
    (positions) that shouldn''t be loaded (this is an index/position-based field mapping).
    This time, let''s collect the number of processed rows as well via `processed()`:'
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE549]'
  id: totrans-744
  prefs: []
  type: TYPE_PRE
  zh: '[PRE549]'
- en: '[PRE550]'
  id: totrans-745
  prefs: []
  type: TYPE_PRE
  zh: '[PRE550]'
- en: '[PRE551]'
  id: totrans-746
  prefs: []
  type: TYPE_PRE
  zh: '[PRE551]'
- en: '[PRE552]'
  id: totrans-747
  prefs: []
  type: TYPE_PRE
  zh: '[PRE552]'
- en: '[PRE553]'
  id: totrans-748
  prefs: []
  type: TYPE_PRE
  zh: '[PRE553]'
- en: '[PRE554]'
  id: totrans-749
  prefs: []
  type: TYPE_PRE
  zh: '[PRE554]'
- en: '[PRE555]'
  id: totrans-750
  prefs: []
  type: TYPE_PRE
  zh: '[PRE555]'
- en: '[PRE556]'
  id: totrans-751
  prefs: []
  type: TYPE_PRE
  zh: '[PRE556]'
- en: 'This code loads from CSV only `SALE.FISCAL_YEAR`, `SALE.SALE_`, `SALE.FISCAL_MONTH`,
    `SALE.REVENUE_GROWTH`, and `SALE.TREND`. Notice that we''ve used the `fields()`
    method instead of `fieldsCorresponding()`, since `fields()` allows us to keep
    only the desired fields and skip the rest. A sample of the resultant `INSERT`
    (in MySQL dialect) looks like this:'
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE557]'
  id: totrans-753
  prefs: []
  type: TYPE_PRE
  zh: '[PRE557]'
- en: '[PRE558]'
  id: totrans-754
  prefs: []
  type: TYPE_PRE
  zh: '[PRE558]'
- en: '[PRE559]'
  id: totrans-755
  prefs: []
  type: TYPE_PRE
  zh: '[PRE559]'
- en: 'While this CSV file is a typical one (first line header, data separated by
    a comma, and so on), sometimes we have to deal with CSV files that are quite customized,
    such as the following one:'
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE560]'
  id: totrans-757
  prefs: []
  type: TYPE_PRE
  zh: '[PRE560]'
- en: '[PRE561]'
  id: totrans-758
  prefs: []
  type: TYPE_PRE
  zh: '[PRE561]'
- en: '[PRE562]'
  id: totrans-759
  prefs: []
  type: TYPE_PRE
  zh: '[PRE562]'
- en: '[PRE563]'
  id: totrans-760
  prefs: []
  type: TYPE_PRE
  zh: '[PRE563]'
- en: 'This CSV file contains the same data as the previous one expect that there
    is no header line, the data separator is `|`, the quote mark is `*`, and the `null`
    values are represented as `{null}`. Loading this CSV file into `SALE` requires
    the following code:'
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE564]'
  id: totrans-762
  prefs: []
  type: TYPE_PRE
  zh: '[PRE564]'
- en: '[PRE565]'
  id: totrans-763
  prefs: []
  type: TYPE_PRE
  zh: '[PRE565]'
- en: '[PRE566]'
  id: totrans-764
  prefs: []
  type: TYPE_PRE
  zh: '[PRE566]'
- en: '[PRE567]'
  id: totrans-765
  prefs: []
  type: TYPE_PRE
  zh: '[PRE567]'
- en: '[PRE568]'
  id: totrans-766
  prefs: []
  type: TYPE_PRE
  zh: '[PRE568]'
- en: '[PRE569]'
  id: totrans-767
  prefs: []
  type: TYPE_PRE
  zh: '[PRE569]'
- en: '[PRE570]'
  id: totrans-768
  prefs: []
  type: TYPE_PRE
  zh: '[PRE570]'
- en: '[PRE571]'
  id: totrans-769
  prefs: []
  type: TYPE_PRE
  zh: '[PRE571]'
- en: '[PRE572]'
  id: totrans-770
  prefs: []
  type: TYPE_PRE
  zh: '[PRE572]'
- en: '[PRE573]'
  id: totrans-771
  prefs: []
  type: TYPE_PRE
  zh: '[PRE573]'
- en: First of all, since there is no header, we rely on `fields()` to explicitly
    specify the list of fields (`SALE_ID` is mapped to index `1` in CSV, `FISCAL_YEAR`
    to index `2`, and so on). Next, we call `ignoreRows(0)`; by default, jOOQ skips
    the first line, which is considered the header of the CSV file, but since there
    is no header in this case, we have to instruct jOOQ to take into account the first
    line as a line containing data. Obviously, this method is useful for skipping
    *n* rows as well. Taking it a step further, we call `separator()`, `nullString()`,
    and `quote()` to override the defaults. Finally, we call `errors()` and collect
    potential errors in `List<LoaderError>`. This is an optional step and is not related
    to this particular example. In the bundled code (*LoadCSV* for MySQL), you can
    see how to loop this list and extract valuable information about what happened
    during the loading process. Moreover, you'll see more examples of loading CSV
    files. Next, let's explore more examples for loading a JSON file.
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
- en: Loading JSON
  id: totrans-773
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Loading JSON is done via the `loadJSON()` method. Let''s start with a JSON
    file:'
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE574]'
  id: totrans-775
  prefs: []
  type: TYPE_PRE
  zh: '[PRE574]'
- en: '[PRE575]'
  id: totrans-776
  prefs: []
  type: TYPE_PRE
  zh: '[PRE575]'
- en: '[PRE576]'
  id: totrans-777
  prefs: []
  type: TYPE_PRE
  zh: '[PRE576]'
- en: '[PRE577]'
  id: totrans-778
  prefs: []
  type: TYPE_PRE
  zh: '[PRE577]'
- en: '[PRE578]'
  id: totrans-779
  prefs: []
  type: TYPE_PRE
  zh: '[PRE578]'
- en: '[PRE579]'
  id: totrans-780
  prefs: []
  type: TYPE_PRE
  zh: '[PRE579]'
- en: '[PRE580]'
  id: totrans-781
  prefs: []
  type: TYPE_PRE
  zh: '[PRE580]'
- en: '[PRE581]'
  id: totrans-782
  prefs: []
  type: TYPE_PRE
  zh: '[PRE581]'
- en: '[PRE582]'
  id: totrans-783
  prefs: []
  type: TYPE_PRE
  zh: '[PRE582]'
- en: '[PRE583]'
  id: totrans-784
  prefs: []
  type: TYPE_PRE
  zh: '[PRE583]'
- en: '[PRE584]'
  id: totrans-785
  prefs: []
  type: TYPE_PRE
  zh: '[PRE584]'
- en: '[PRE585]'
  id: totrans-786
  prefs: []
  type: TYPE_PRE
  zh: '[PRE585]'
- en: '[PRE586]'
  id: totrans-787
  prefs: []
  type: TYPE_PRE
  zh: '[PRE586]'
- en: '[PRE587]'
  id: totrans-788
  prefs: []
  type: TYPE_PRE
  zh: '[PRE587]'
- en: '[PRE588]'
  id: totrans-789
  prefs: []
  type: TYPE_PRE
  zh: '[PRE588]'
- en: '[PRE589]'
  id: totrans-790
  prefs: []
  type: TYPE_PRE
  zh: '[PRE589]'
- en: 'This JSON file was previously exported via `formatJSON()`. Notice the `"fields"`
    header, which is useful for loading this file into the `SALE` table via the mapping
    provided by the `fieldsCorresponding()` method. Without a header, the `fieldsCorresponding()`
    method cannot produce the expected results since the input fields are missing.
    But, if we rely on the `fields()` method, then we can list the desired fields
    (all or a subset of them) and count on index-based mapping without worrying about
    the presence or absence of the `"fields"` header. Moreover, this time, let''s
    add an `onRowEnd()` listener as well:'
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE590]'
  id: totrans-792
  prefs: []
  type: TYPE_PRE
  zh: '[PRE590]'
- en: '[PRE591]'
  id: totrans-793
  prefs: []
  type: TYPE_PRE
  zh: '[PRE591]'
- en: '[PRE592]'
  id: totrans-794
  prefs: []
  type: TYPE_PRE
  zh: '[PRE592]'
- en: '[PRE593]'
  id: totrans-795
  prefs: []
  type: TYPE_PRE
  zh: '[PRE593]'
- en: '[PRE594]'
  id: totrans-796
  prefs: []
  type: TYPE_PRE
  zh: '[PRE594]'
- en: '[PRE595]'
  id: totrans-797
  prefs: []
  type: TYPE_PRE
  zh: '[PRE595]'
- en: '[PRE596]'
  id: totrans-798
  prefs: []
  type: TYPE_PRE
  zh: '[PRE596]'
- en: '[PRE597]'
  id: totrans-799
  prefs: []
  type: TYPE_PRE
  zh: '[PRE597]'
- en: '[PRE598]'
  id: totrans-800
  prefs: []
  type: TYPE_PRE
  zh: '[PRE598]'
- en: '[PRE599]'
  id: totrans-801
  prefs: []
  type: TYPE_PRE
  zh: '[PRE599]'
- en: '[PRE600]'
  id: totrans-802
  prefs: []
  type: TYPE_PRE
  zh: '[PRE600]'
- en: '[PRE601]'
  id: totrans-803
  prefs: []
  type: TYPE_PRE
  zh: '[PRE601]'
- en: '[PRE602]'
  id: totrans-804
  prefs: []
  type: TYPE_PRE
  zh: '[PRE602]'
- en: '[PRE603]'
  id: totrans-805
  prefs: []
  type: TYPE_PRE
  zh: '[PRE603]'
- en: 'After each row is processed you''ll see an output in the log as shown here:'
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE604]'
  id: totrans-807
  prefs: []
  type: TYPE_PRE
  zh: '[PRE604]'
- en: '[PRE605]'
  id: totrans-808
  prefs: []
  type: TYPE_PRE
  zh: '[PRE605]'
- en: 'But, let''s look at a JSON file without the `"fields"` header, as follows:'
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE606]'
  id: totrans-810
  prefs: []
  type: TYPE_PRE
  zh: '[PRE606]'
- en: '[PRE607]'
  id: totrans-811
  prefs: []
  type: TYPE_PRE
  zh: '[PRE607]'
- en: '[PRE608]'
  id: totrans-812
  prefs: []
  type: TYPE_PRE
  zh: '[PRE608]'
- en: '[PRE609]'
  id: totrans-813
  prefs: []
  type: TYPE_PRE
  zh: '[PRE609]'
- en: '[PRE610]'
  id: totrans-814
  prefs: []
  type: TYPE_PRE
  zh: '[PRE610]'
- en: '[PRE611]'
  id: totrans-815
  prefs: []
  type: TYPE_PRE
  zh: '[PRE611]'
- en: '[PRE612]'
  id: totrans-816
  prefs: []
  type: TYPE_PRE
  zh: '[PRE612]'
- en: '[PRE613]'
  id: totrans-817
  prefs: []
  type: TYPE_PRE
  zh: '[PRE613]'
- en: '[PRE614]'
  id: totrans-818
  prefs: []
  type: TYPE_PRE
  zh: '[PRE614]'
- en: '[PRE615]'
  id: totrans-819
  prefs: []
  type: TYPE_PRE
  zh: '[PRE615]'
- en: '[PRE616]'
  id: totrans-820
  prefs: []
  type: TYPE_PRE
  zh: '[PRE616]'
- en: '[PRE617]'
  id: totrans-821
  prefs: []
  type: TYPE_PRE
  zh: '[PRE617]'
- en: '[PRE618]'
  id: totrans-822
  prefs: []
  type: TYPE_PRE
  zh: '[PRE618]'
- en: '[PRE619]'
  id: totrans-823
  prefs: []
  type: TYPE_PRE
  zh: '[PRE619]'
- en: '[PRE620]'
  id: totrans-824
  prefs: []
  type: TYPE_PRE
  zh: '[PRE620]'
- en: '[PRE621]'
  id: totrans-825
  prefs: []
  type: TYPE_PRE
  zh: '[PRE621]'
- en: '[PRE622]'
  id: totrans-826
  prefs: []
  type: TYPE_PRE
  zh: '[PRE622]'
- en: 'This kind of JSON can be loaded via `fieldsCorresponding()` or via `fields()`.
    Since the field names are available as JSON keys, the `fieldsCorresponding()`
    method maps them correctly. Using `fields()` should be done by keeping in mind
    the order of keys in this JSON. So, `"fiscal_month"` is on index `1`, `"revenue_growth"`
    on index `2`, and so on. Here is an example that loads only `"fiscal_month"`,
    `"revenue_growth"`, `"sale"`, `"fiscal_year"`, and `"employee_number"`:'
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE623]'
  id: totrans-828
  prefs: []
  type: TYPE_PRE
  zh: '[PRE623]'
- en: '[PRE624]'
  id: totrans-829
  prefs: []
  type: TYPE_PRE
  zh: '[PRE624]'
- en: '[PRE625]'
  id: totrans-830
  prefs: []
  type: TYPE_PRE
  zh: '[PRE625]'
- en: '[PRE626]'
  id: totrans-831
  prefs: []
  type: TYPE_PRE
  zh: '[PRE626]'
- en: '[PRE627]'
  id: totrans-832
  prefs: []
  type: TYPE_PRE
  zh: '[PRE627]'
- en: '[PRE628]'
  id: totrans-833
  prefs: []
  type: TYPE_PRE
  zh: '[PRE628]'
- en: '[PRE629]'
  id: totrans-834
  prefs: []
  type: TYPE_PRE
  zh: '[PRE629]'
- en: '[PRE630]'
  id: totrans-835
  prefs: []
  type: TYPE_PRE
  zh: '[PRE630]'
- en: 'But, sometimes, the missing data is in JSON itself, as here:'
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE631]'
  id: totrans-837
  prefs: []
  type: TYPE_PRE
  zh: '[PRE631]'
- en: '[PRE632]'
  id: totrans-838
  prefs: []
  type: TYPE_PRE
  zh: '[PRE632]'
- en: '[PRE633]'
  id: totrans-839
  prefs: []
  type: TYPE_PRE
  zh: '[PRE633]'
- en: '[PRE634]'
  id: totrans-840
  prefs: []
  type: TYPE_PRE
  zh: '[PRE634]'
- en: '[PRE635]'
  id: totrans-841
  prefs: []
  type: TYPE_PRE
  zh: '[PRE635]'
- en: '[PRE636]'
  id: totrans-842
  prefs: []
  type: TYPE_PRE
  zh: '[PRE636]'
- en: '[PRE637]'
  id: totrans-843
  prefs: []
  type: TYPE_PRE
  zh: '[PRE637]'
- en: '[PRE638]'
  id: totrans-844
  prefs: []
  type: TYPE_PRE
  zh: '[PRE638]'
- en: '[PRE639]'
  id: totrans-845
  prefs: []
  type: TYPE_PRE
  zh: '[PRE639]'
- en: 'Here is another example:'
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE640]'
  id: totrans-847
  prefs: []
  type: TYPE_PRE
  zh: '[PRE640]'
- en: '[PRE641]'
  id: totrans-848
  prefs: []
  type: TYPE_PRE
  zh: '[PRE641]'
- en: '[PRE642]'
  id: totrans-849
  prefs: []
  type: TYPE_PRE
  zh: '[PRE642]'
- en: '[PRE643]'
  id: totrans-850
  prefs: []
  type: TYPE_PRE
  zh: '[PRE643]'
- en: '[PRE644]'
  id: totrans-851
  prefs: []
  type: TYPE_PRE
  zh: '[PRE644]'
- en: '[PRE645]'
  id: totrans-852
  prefs: []
  type: TYPE_PRE
  zh: '[PRE645]'
- en: '[PRE646]'
  id: totrans-853
  prefs: []
  type: TYPE_PRE
  zh: '[PRE646]'
- en: '[PRE647]'
  id: totrans-854
  prefs: []
  type: TYPE_PRE
  zh: '[PRE647]'
- en: '[PRE648]'
  id: totrans-855
  prefs: []
  type: TYPE_PRE
  zh: '[PRE648]'
- en: 'This time, in both cases, we must rely on `fields()`, as here:'
  id: totrans-856
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE649]'
  id: totrans-857
  prefs: []
  type: TYPE_PRE
  zh: '[PRE649]'
- en: '[PRE650]'
  id: totrans-858
  prefs: []
  type: TYPE_PRE
  zh: '[PRE650]'
- en: '[PRE651]'
  id: totrans-859
  prefs: []
  type: TYPE_PRE
  zh: '[PRE651]'
- en: '[PRE652]'
  id: totrans-860
  prefs: []
  type: TYPE_PRE
  zh: '[PRE652]'
- en: '[PRE653]'
  id: totrans-861
  prefs: []
  type: TYPE_PRE
  zh: '[PRE653]'
- en: '[PRE654]'
  id: totrans-862
  prefs: []
  type: TYPE_PRE
  zh: '[PRE654]'
- en: 'Next, let''s assume that we have a JSON file that should be imported into the
    database using batches of size `2` (rows), so we need `batchAfter(2)`. The commit
    (as in all the previous examples) will be accomplished by Spring Boot via `@Transactional`:'
  id: totrans-863
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE655]'
  id: totrans-864
  prefs: []
  type: TYPE_PRE
  zh: '[PRE655]'
- en: '[PRE656]'
  id: totrans-865
  prefs: []
  type: TYPE_PRE
  zh: '[PRE656]'
- en: '[PRE657]'
  id: totrans-866
  prefs: []
  type: TYPE_PRE
  zh: '[PRE657]'
- en: '[PRE658]'
  id: totrans-867
  prefs: []
  type: TYPE_PRE
  zh: '[PRE658]'
- en: '[PRE659]'
  id: totrans-868
  prefs: []
  type: TYPE_PRE
  zh: '[PRE659]'
- en: '[PRE660]'
  id: totrans-869
  prefs: []
  type: TYPE_PRE
  zh: '[PRE660]'
- en: '[PRE661]'
  id: totrans-870
  prefs: []
  type: TYPE_PRE
  zh: '[PRE661]'
- en: '[PRE662]'
  id: totrans-871
  prefs: []
  type: TYPE_PRE
  zh: '[PRE662]'
- en: '[PRE663]'
  id: totrans-872
  prefs: []
  type: TYPE_PRE
  zh: '[PRE663]'
- en: '[PRE664]'
  id: totrans-873
  prefs: []
  type: TYPE_PRE
  zh: '[PRE664]'
- en: '[PRE665]'
  id: totrans-874
  prefs: []
  type: TYPE_PRE
  zh: '[PRE665]'
- en: Since `commitNone()` is the default behavior, it could be omitted. Essentially,
    `commitNone()` allows `@Transactional` to handle the commit/rollback actions.
    By default, `@Transactional` commits the transaction at the end of the annotated
    method. If something goes wrong, the entire payload (all batches) is rolled back.
    But, if you remove `@Transactional`, then `auto-commit` `=true` goes into action.
    This commits after each batch (so, after every two rows). If something goes wrong,
    then there is no rollback action, but the loading process is aborted immediately
    since we rely on the default settings, `onDuplicateKeyError()` and `onErrorAbort()`.
    If we remove `@Transactional` and set `auto-commit` to `false` (`spring.datasource.hikari.auto-commit=false`),
    then nothing commits.
  id: totrans-875
  prefs: []
  type: TYPE_NORMAL
- en: This example returns the number of executed batches via `executed()`. For instance,
    if there are 36 rows processed with `batchAfter(2)`, then `executed()` returns
    18\.
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s consider a JSON file that contains duplicate keys. Every time
    a duplicate key is found, the Loader API should skip it, and, in the end, it should
    report the number of ignored rows. Moreover, the Loader API should commit after
    each batch of three rows:'
  id: totrans-877
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE666]'
  id: totrans-878
  prefs: []
  type: TYPE_PRE
  zh: '[PRE666]'
- en: '[PRE667]'
  id: totrans-879
  prefs: []
  type: TYPE_PRE
  zh: '[PRE667]'
- en: '[PRE668]'
  id: totrans-880
  prefs: []
  type: TYPE_PRE
  zh: '[PRE668]'
- en: '[PRE669]'
  id: totrans-881
  prefs: []
  type: TYPE_PRE
  zh: '[PRE669]'
- en: '[PRE670]'
  id: totrans-882
  prefs: []
  type: TYPE_PRE
  zh: '[PRE670]'
- en: '[PRE671]'
  id: totrans-883
  prefs: []
  type: TYPE_PRE
  zh: '[PRE671]'
- en: '[PRE672]'
  id: totrans-884
  prefs: []
  type: TYPE_PRE
  zh: '[PRE672]'
- en: '[PRE673]'
  id: totrans-885
  prefs: []
  type: TYPE_PRE
  zh: '[PRE673]'
- en: '[PRE674]'
  id: totrans-886
  prefs: []
  type: TYPE_PRE
  zh: '[PRE674]'
- en: If you want to execute `UPDATE` instead of ignoring duplicate keys, just replace
    `onDuplicateKeyIgnore()` with `onDuplicateKeyUpdate()`.
  id: totrans-887
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let''s import a JSON using `bulkAfter(2)`, `batchAfter(3)`, and `commitAfter(3)`.
    In other words, each bulk has two rows, and each batch has three bulks. Therefore,
    six rows commit after three batches, that is nine bulks, so after 18 rows, you
    get the following:'
  id: totrans-888
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们使用 `bulkAfter(2)`、`batchAfter(3)` 和 `commitAfter(3)` 导入 JSON。换句话说，每个批量有两行，每个批次有三个批量。因此，在三个批次之后，九个批量提交，即在
    18 行之后，您将得到以下内容：
- en: '[PRE675]'
  id: totrans-889
  prefs: []
  type: TYPE_PRE
  zh: '[PRE675]'
- en: '[PRE676]'
  id: totrans-890
  prefs: []
  type: TYPE_PRE
  zh: '[PRE676]'
- en: '[PRE677]'
  id: totrans-891
  prefs: []
  type: TYPE_PRE
  zh: '[PRE677]'
- en: '[PRE678]'
  id: totrans-892
  prefs: []
  type: TYPE_PRE
  zh: '[PRE678]'
- en: '[PRE679]'
  id: totrans-893
  prefs: []
  type: TYPE_PRE
  zh: '[PRE679]'
- en: '[PRE680]'
  id: totrans-894
  prefs: []
  type: TYPE_PRE
  zh: '[PRE680]'
- en: '[PRE681]'
  id: totrans-895
  prefs: []
  type: TYPE_PRE
  zh: '[PRE681]'
- en: '[PRE682]'
  id: totrans-896
  prefs: []
  type: TYPE_PRE
  zh: '[PRE682]'
- en: '[PRE683]'
  id: totrans-897
  prefs: []
  type: TYPE_PRE
  zh: '[PRE683]'
- en: '[PRE684]'
  id: totrans-898
  prefs: []
  type: TYPE_PRE
  zh: '[PRE684]'
- en: If something goes wrong, the last uncommitted batch is rolled back without affecting
    the already committed batches. More examples are available in the bundled code,
    `LoadJSON`, for MySQL.
  id: totrans-899
  prefs: []
  type: TYPE_NORMAL
  zh: 如果出现问题，最后未提交的批次将被回滚，而不会影响已提交的批次。更多示例可以在捆绑的代码 `LoadJSON` 中找到，适用于 MySQL。
- en: Loading records
  id: totrans-900
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 加载记录
- en: 'Loading jOOQ `Record` via the Loader API is a straightforward process accomplished
    via the `loadRecords()` method. Let''s consider the following set of records:'
  id: totrans-901
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 Loader API 加载 jOOQ `Record` 是一个简单的过程，通过 `loadRecords()` 方法实现。让我们考虑以下记录集：
- en: '[PRE685]'
  id: totrans-902
  prefs: []
  type: TYPE_PRE
  zh: '[PRE685]'
- en: '[PRE686]'
  id: totrans-903
  prefs: []
  type: TYPE_PRE
  zh: '[PRE686]'
- en: '[PRE687]'
  id: totrans-904
  prefs: []
  type: TYPE_PRE
  zh: '[PRE687]'
- en: '[PRE688]'
  id: totrans-905
  prefs: []
  type: TYPE_PRE
  zh: '[PRE688]'
- en: '[PRE689]'
  id: totrans-906
  prefs: []
  type: TYPE_PRE
  zh: '[PRE689]'
- en: '[PRE690]'
  id: totrans-907
  prefs: []
  type: TYPE_PRE
  zh: '[PRE690]'
- en: 'Loading them can be done as follows:'
  id: totrans-908
  prefs: []
  type: TYPE_NORMAL
  zh: 加载它们可以这样做：
- en: '[PRE691]'
  id: totrans-909
  prefs: []
  type: TYPE_PRE
  zh: '[PRE691]'
- en: '[PRE692]'
  id: totrans-910
  prefs: []
  type: TYPE_PRE
  zh: '[PRE692]'
- en: '[PRE693]'
  id: totrans-911
  prefs: []
  type: TYPE_PRE
  zh: '[PRE693]'
- en: '[PRE694]'
  id: totrans-912
  prefs: []
  type: TYPE_PRE
  zh: '[PRE694]'
- en: '[PRE695]'
  id: totrans-913
  prefs: []
  type: TYPE_PRE
  zh: '[PRE695]'
- en: '[PRE696]'
  id: totrans-914
  prefs: []
  type: TYPE_PRE
  zh: '[PRE696]'
- en: '[PRE697]'
  id: totrans-915
  prefs: []
  type: TYPE_PRE
  zh: '[PRE697]'
- en: '[PRE698]'
  id: totrans-916
  prefs: []
  type: TYPE_PRE
  zh: '[PRE698]'
- en: '[PRE699]'
  id: totrans-917
  prefs: []
  type: TYPE_PRE
  zh: '[PRE699]'
- en: '[PRE700]'
  id: totrans-918
  prefs: []
  type: TYPE_PRE
  zh: '[PRE700]'
- en: '[PRE701]'
  id: totrans-919
  prefs: []
  type: TYPE_PRE
  zh: '[PRE701]'
- en: '[PRE702]'
  id: totrans-920
  prefs: []
  type: TYPE_PRE
  zh: '[PRE702]'
- en: 'Let''s look at loading the following map of `Record`:'
  id: totrans-921
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何加载以下 `Record` 映射：
- en: '[PRE703]'
  id: totrans-922
  prefs: []
  type: TYPE_PRE
  zh: '[PRE703]'
- en: 'So, `CustomerRecord` should be loaded in `CUSTOMER`, and `CustomerdetailRecord`
    should be loaded in `CUSTOMERDETAIL`. For this, we can use `Map.keySet()` and
    `Map.values()` as follows:'
  id: totrans-923
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`CustomerRecord` 应该加载到 `CUSTOMER` 中，而 `CustomerdetailRecord` 应该加载到 `CUSTOMERDETAIL`
    中。为此，我们可以使用 `Map.keySet()` 和 `Map.values()` 如下：
- en: '[PRE704]'
  id: totrans-924
  prefs: []
  type: TYPE_PRE
  zh: '[PRE704]'
- en: '[PRE705]'
  id: totrans-925
  prefs: []
  type: TYPE_PRE
  zh: '[PRE705]'
- en: '[PRE706]'
  id: totrans-926
  prefs: []
  type: TYPE_PRE
  zh: '[PRE706]'
- en: '[PRE707]'
  id: totrans-927
  prefs: []
  type: TYPE_PRE
  zh: '[PRE707]'
- en: '[PRE708]'
  id: totrans-928
  prefs: []
  type: TYPE_PRE
  zh: '[PRE708]'
- en: '[PRE709]'
  id: totrans-929
  prefs: []
  type: TYPE_PRE
  zh: '[PRE709]'
- en: '[PRE710]'
  id: totrans-930
  prefs: []
  type: TYPE_PRE
  zh: '[PRE710]'
- en: '[PRE711]'
  id: totrans-931
  prefs: []
  type: TYPE_PRE
  zh: '[PRE711]'
- en: '[PRE712]'
  id: totrans-932
  prefs: []
  type: TYPE_PRE
  zh: '[PRE712]'
- en: '[PRE713]'
  id: totrans-933
  prefs: []
  type: TYPE_PRE
  zh: '[PRE713]'
- en: More examples are available in the bundled code, `LoadRecords`, for MySQL.
  id: totrans-934
  prefs: []
  type: TYPE_NORMAL
  zh: 更多示例可以在捆绑的代码 `LoadRecords` 中找到，适用于 MySQL。
- en: Loading arrays
  id: totrans-935
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 加载数组
- en: 'Loading arrays is accomplished via the `loadArrays()` method. Let''s consider
    the following array containing data that should be loaded into the `SALE` table:'
  id: totrans-936
  prefs: []
  type: TYPE_NORMAL
  zh: 加载数组是通过 `loadArrays()` 方法实现的。让我们考虑以下包含应加载到 `SALE` 表中的数据的数组：
- en: '[PRE714]'
  id: totrans-937
  prefs: []
  type: TYPE_PRE
  zh: '[PRE714]'
- en: 'Loading this array can be done as follows:'
  id: totrans-938
  prefs: []
  type: TYPE_NORMAL
  zh: 加载这个数组可以这样做：
- en: '[PRE715]'
  id: totrans-939
  prefs: []
  type: TYPE_PRE
  zh: '[PRE715]'
- en: '[PRE716]'
  id: totrans-940
  prefs: []
  type: TYPE_PRE
  zh: '[PRE716]'
- en: '[PRE717]'
  id: totrans-941
  prefs: []
  type: TYPE_PRE
  zh: '[PRE717]'
- en: '[PRE718]'
  id: totrans-942
  prefs: []
  type: TYPE_PRE
  zh: '[PRE718]'
- en: '[PRE719]'
  id: totrans-943
  prefs: []
  type: TYPE_PRE
  zh: '[PRE719]'
- en: '[PRE720]'
  id: totrans-944
  prefs: []
  type: TYPE_PRE
  zh: '[PRE720]'
- en: 'Here is another example that relies on `loadArrays(Object[]... os)`:'
  id: totrans-945
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是另一个依赖于 `loadArrays(Object[]... os)` 的例子：
- en: '[PRE721]'
  id: totrans-946
  prefs: []
  type: TYPE_PRE
  zh: '[PRE721]'
- en: '[PRE722]'
  id: totrans-947
  prefs: []
  type: TYPE_PRE
  zh: '[PRE722]'
- en: '[PRE723]'
  id: totrans-948
  prefs: []
  type: TYPE_PRE
  zh: '[PRE723]'
- en: '[PRE724]'
  id: totrans-949
  prefs: []
  type: TYPE_PRE
  zh: '[PRE724]'
- en: '[PRE725]'
  id: totrans-950
  prefs: []
  type: TYPE_PRE
  zh: '[PRE725]'
- en: '[PRE726]'
  id: totrans-951
  prefs: []
  type: TYPE_PRE
  zh: '[PRE726]'
- en: '[PRE727]'
  id: totrans-952
  prefs: []
  type: TYPE_PRE
  zh: '[PRE727]'
- en: '[PRE728]'
  id: totrans-953
  prefs: []
  type: TYPE_PRE
  zh: '[PRE728]'
- en: '[PRE729]'
  id: totrans-954
  prefs: []
  type: TYPE_PRE
  zh: '[PRE729]'
- en: '[PRE730]'
  id: totrans-955
  prefs: []
  type: TYPE_PRE
  zh: '[PRE730]'
- en: '[PRE731]'
  id: totrans-956
  prefs: []
  type: TYPE_PRE
  zh: '[PRE731]'
- en: '[PRE732]'
  id: totrans-957
  prefs: []
  type: TYPE_PRE
  zh: '[PRE732]'
- en: '[PRE733]'
  id: totrans-958
  prefs: []
  type: TYPE_PRE
  zh: '[PRE733]'
- en: '[PRE734]'
  id: totrans-959
  prefs: []
  type: TYPE_PRE
  zh: '[PRE734]'
- en: You can check out these examples next to others not listed here in the bundled
    code, `LoadArrays`, for MySQL. It is time to summarize this chapter.
  id: totrans-960
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在捆绑的代码 `LoadArrays` 中查看这些示例，这些示例未在此列出，适用于 MySQL。现在是总结本章内容的时候了。
- en: Summary
  id: totrans-961
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: 'In this chapter, we''ve covered four important topics: exporting, batching,
    bulking, and loading. As you saw, jOOQ comes with dedicated APIs for accomplishing
    each of these tasks that require a lot of complex code under the hood. Frequently,
    jOOQ simplifies the complexity (as usual) and allows us to focus on what we have
    to do and less on how we do it. For instance, it is amazing to see that it takes
    seconds to write a snippet of code for loading a CSV or a JSON file into the database
    while having fluent and smooth support for error handling control, diagnosis output,
    bulking, batching, and committing control.'
  id: totrans-962
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了四个重要主题：导出、分批、批量处理和加载。如您所见，jOOQ 提供了专门的 API 来完成这些任务，这些任务在底层需要大量复杂的代码。通常，jOOQ
    简化了复杂性，并允许我们专注于我们必须做的事情，而不是如何去做。例如，看到将 CSV 或 JSON 文件加载到数据库中的代码片段只需几秒钟就完成，同时具有流畅和顺畅的错误处理控制、诊断输出、批量处理、分批和提交控制的支持，这真是太令人惊讶了。
- en: In the next chapter, we will cover the jOOQ keys.
  id: totrans-963
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍 jOOQ 键。
