- en: ZGC
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ZGC
- en: Java 11 includes a lot of improvements and changes in the GC domain. With **Z
    Garbage Collector** (**ZGC**), Java is bringing another GC for you—scalable, with
    low latency. It is a completely new GC, written from scratch. It can work with
    heap memory, ranging from KBs to a large TB memory. As a concurrent garbage collector,
    ZGC promises not to exceed application latency by 10 milliseconds, even for bigger
    heap sizes. It is also easy to tune.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Java 11 在GC（垃圾回收）领域包含了许多改进和变化。随着**Z垃圾回收器**（**ZGC**），Java 为您带来了另一个GC——可扩展的，低延迟。这是一个全新的GC，从头开始编写。它可以与堆内存一起工作，从KB到大型TB内存。作为一个并发垃圾回收器，ZGC
    承诺不会使应用程序延迟超过10毫秒，即使对于更大的堆大小。它也很容易调整。
- en: It was released with Java 11 as an experimental GC. Work is in progress on this
    GC in OpenJDK and you can expect more changes to it over time.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 它作为 Java 11 的一个实验性GC发布。在 OpenJDK 上对这种GC的工作正在进行中，您可以期待随着时间的推移对其进行更多更改。
- en: 'In this chapter, we''ll cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Why ZGC is required
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么需要 ZGC
- en: Features of ZGC
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ZGC 的特性
- en: Examples of working with ZGC
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与 ZGC 一起工作的示例
- en: ZGC use cases
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ZGC 的用例
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can use the ZGC with Java 11 and with Linux/x64 systems. ZGC is an experimental
    GC. All of the code in this chapter can be accessed by going to this book's GitHub
    repository at: [https://github.com/PacktPublishing/Java-11-and-12-New-Features](https://github.com/PacktPublishing/Java-11-and-12-New-Features).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 ZGC 与 Java 11 和 Linux/x64 系统一起使用。ZGC 是一个实验性GC。本章中的所有代码都可以通过访问本书的GitHub仓库来获取：[https://github.com/PacktPublishing/Java-11-and-12-New-Features](https://github.com/PacktPublishing/Java-11-and-12-New-Features)。
- en: Let's get started by assessing why we need ZGC.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从评估为什么我们需要 ZGC 开始。
- en: The motivation
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动机
- en: One of the features that resulted in the rise of Java in the early days was
    its automatic memory management with its GCs, which freed developers from manual
    memory management and lowered memory leaks.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 早期崛起的一个特性是其 GC 的自动内存管理，这使开发者免于手动内存管理并降低了内存泄漏。
- en: However, with unpredictable timings and durations, garbage collection can (at
    times) do more harm to an application than good. Increased latency directly affects
    the throughput and performance of an application. With eve-decreasing hardware
    costs and programs engineered to use largish memories, applications are demanding
    lower latency and higher throughput from garbage collectors.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于不可预测的时间和持续时间，垃圾回收有时可能对应用程序造成比好处更大的伤害。增加的延迟会直接影响应用程序的吞吐量和性能。随着硬件成本的不断降低和旨在使用较大内存的程序，应用程序对垃圾收集器提出了更低的延迟和更高的吞吐量的要求。
- en: ZGC promises a latency of no more than 10 milliseconds, which doesn't increase
    with heap size or a live set. This is because its stop-the-world pauses are limited
    to root scanning.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: ZGC 承诺的延迟不超过10毫秒，这不会随着堆大小或活动集的增加而增加。这是因为它的停止世界暂停仅限于根扫描。
- en: ZGC is a scalable, low latency GC, which promises up to 10 milliseconds of latency,
    even for large heap memory (terabytes in size).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: ZGC 是一个可扩展的、低延迟的GC，承诺即使对于大型堆内存（TB大小），延迟也不会超过10毫秒。
- en: Features of ZGC
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ZGC 的特性
- en: Written from scratch, ZGC brings in a lot of features, which have been instrumental
    in its proposal, design, and implementation.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 从头开始编写的 ZGC 带来了许多特性，这些特性在其提案、设计和实现中发挥了关键作用。
- en: One of the most outstanding features of ZGC is that it is a concurrent GC. It
    can mark memory and copy and relocate it, all concurrently. It also has a concurrent
    reference processor. This essentially means that you can add all sort of references,
    such as weak references, soft references, phantom references, or finalizers (these
    are deprecated now). Even then, ZGC won't add more GC pauses for you (since it
    will clean or reclaim the memory concurrently).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: ZGC 最突出的特性之一是它是一个并发GC。它可以并发地标记内存、复制和重新定位它。它还有一个并发引用处理器。这本质上意味着您可以添加各种引用，例如弱引用、软引用、虚引用或终结器（这些现在已弃用）。即使如此，ZGC
    也不会为您添加更多的GC暂停（因为它将并发地清理或回收内存）。
- en: As opposed to the store barriers that are used by another HotSpot GCs, ZGC uses
    load barriers. The load barriers are used to keep track of heap usage. One of
    the intriguing features of ZGC is the usage of load barriers with colored pointers.
    This is what enables ZGC to perform concurrent operations when Java threads are
    running, such as object relocation or relocation set selection.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他 HotSpot GC 使用的存储屏障不同，ZGC 使用加载屏障。加载屏障用于跟踪堆的使用情况。ZGC 的一个有趣特性是使用带有彩色指针的加载屏障。这使得
    ZGC 能够在 Java 线程运行时执行并发操作，例如对象重定位或重定位集选择。
- en: ZGC is a region-based garbage collector. However, if you compare it to the G1
    garbage collector, ZGC is more flexible in configuring its size and scheme. Compared
    to G1, ZGC has better ways to deal with very large object allocations.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: ZGC 是基于区域的垃圾收集器。然而，如果您将其与 G1 垃圾收集器进行比较，ZGC 在配置其大小和方案方面更加灵活。与 G1 相比，ZGC 有更好的方法来处理非常大的对象分配。
- en: ZGC is a single-generation GC. It also supports partial compaction. ZGC is also
    highly performant when it comes to reclaiming memory and reallocating it.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: ZGC 是单代垃圾收集器。它还支持部分压缩。在回收内存和重新分配内存方面，ZGC 的性能也非常高。
- en: ZGC is NUMA-aware, which essentially means that it has a NUMA-aware memory allocator.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: ZGC 是 NUMA 兼容的，这意味着它具有 NUMA 兼容的内存分配器。
- en: An experimental garbage collector, ZGC is only available on Linux/x64\. More
    platform support will be added in the future if there is a considerable demand
    for it.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 作为实验性的垃圾收集器，ZGC 仅适用于 Linux/x64。如果对其有相当大的需求，将来将添加更多平台支持。
- en: Getting started with ZGC
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用 ZGC
- en: 'Working with ZGC involves multiple steps. You should install the JDK binary,
    which is specific to Linux/x64, and build and start it. You can use the following
    commands to download ZGC and build it on your system:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 ZGC 涉及多个步骤。您应该安装针对 Linux/x64 的 JDK 二进制文件，并构建和启动它。您可以使用以下命令下载 ZGC 并在您的系统上构建它：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'After execution of the preceding commands, you can find the JDK root directory
    in the following location:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 执行前面的命令后，您可以在以下位置找到 JDK 根目录：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Java tools, such as `java`, `javac`, and others can be found in the `/bin` subdirectory
    of the preceding path (its usual location).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Java 工具，如 `java`、`javac` 等，可以在前面路径的 `/bin` 子目录中找到（其通常位置）。
- en: 'Spoiler alert: You won''t be able to work with ZGC unless you have Linux/x64.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：除非您有 Linux/x64，否则您将无法使用 ZGC。
- en: 'Let''s create a basic `HelloZGC` class, as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个基本的 `HelloZGC` 类，如下所示：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You can use the following command to enable ZGC and use it:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下命令来启用 ZGC 并使用它：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Since ZGC is an experimental GC, you need to unlock it using the runtime option,
    that is, `XX:+UnlockExperimentalVMOptions`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 ZGC 是一个实验性的垃圾收集器，您需要使用运行时选项来解锁它，即 `XX:+UnlockExperimentalVMOptions`。
- en: 'For enabling basic GC logging, you can add the `-Xlog:gc` option. Let''s modify
    the preceding code, as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用基本的 GC 日志记录，您可以添加 `-Xlog:gc` 选项。让我们修改前面的代码，如下所示：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Detailed logging is helpful when you are fine-tuning your application. You
    can enable it by using the `-Xlog:gc*` option  as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 详细日志记录在您微调应用程序时非常有帮助。您可以通过使用 `-Xlog:gc*` 选项来启用它，如下所示：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The previous command will output all the logs to the console, which could make
    it difficult to search for specific content. You can specify the logs to be written
    to a file as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令将输出所有日志到控制台，这可能会使搜索特定内容变得困难。您可以将日志指定写入文件，如下所示：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: When compared with G1 and parallel GCs, ZGC performs better in terms of lower
    latency and higher application throughput.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 与 G1 和并行 GC 相比，ZGC 在降低延迟和提高应用程序吞吐量方面表现更好。
- en: Let's take a sneak peek into how ZGC arranges the heap for object allocation
    (in short, let's start with exploring the secret sauce of ZGC).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们窥视一下 ZGC 如何安排堆以进行对象分配（简而言之，让我们从探索 ZGC 的秘密配方开始）。
- en: ZGC heap
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ZGC 堆
- en: 'ZGC divides memory into regions, also called **ZPages**. ZPages can be dynamically
    created and destroyed. These can also be dynamically sized (unlike the G1 GC),
    which are multiples of 2 MB. Here are the size groups of heap regions:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: ZGC 将内存划分为区域，也称为 **ZPages**。ZPages 可以动态创建和销毁。它们也可以动态调整大小（与 G1 GC 不同），大小是 2 MB
    的倍数。以下是堆区域的大小组：
- en: Small (2 MB)
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 小型（2 MB）
- en: Medium (32 MB)
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中等（32 MB）
- en: Large (*N ** 2 MB)
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大型 (*N ** 2 MB)
- en: 'ZGC heap can have multiple occurrences of these heap regions. The medium and
    large regions are allocated contiguously, as shown in the following diagram:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: ZGC 堆可以有多个这些堆区域的出现。中等和大型区域是连续分配的，如下面的图所示：
- en: '![](img/f39ecb71-53bb-4779-b4e2-42c64f9856ba.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f39ecb71-53bb-4779-b4e2-42c64f9856ba.png)'
- en: Unlike other GCs, the physical heap regions of ZGC can map into a bigger heap
    address space (which can include virtual memory). This can be crucial to combat
    memory fragmentation issues. Imagine that you can allocate a really big object
    in memory, but you can't do so due to unavailability of contiguous space in memory.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他 GC 不同，ZGC 的物理堆区域可以映射到一个更大的堆地址空间（这可能包括虚拟内存）。这对抗内存碎片问题可能至关重要。想象一下，你可以在内存中分配一个非常大的对象，但由于内存中连续空间不可用，你无法这样做。
- en: This often leads to multiple GC cycles to free up enough contiguous space. If
    none are available, even after (multiple) GC cycle(s), your JVM will shut down
    with `OutOfMemoryError`. However, this particular use case is not an issue with
    the ZGC. Since the physical memory maps to a bigger address space, locating a
    bigger contiguous space is feasible.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常会导致多个 GC 周期以释放足够的连续空间。如果没有可用空间，即使经过（多个）GC 周期，你的 JVM 也会因为 `OutOfMemoryError`
    而关闭。然而，这个特定的用例与 ZGC 没有问题。由于物理内存映射到一个更大的地址空间，定位更大的连续空间是可行的。
- en: ZPages are a multiple of the same number, say, 2 MB on an Intel machine. It
    could vary, to, say, 4 MB on an *S* machine.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: ZPages 是相同数字的倍数，例如，在英特尔机器上为 2 MB。它可能变化，例如，在 *S* 机器上为 4 MB。
- en: Now, let's see how the ZGC reclaims the memory from its regions.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看 ZGC 如何从其区域回收内存。
- en: ZGC phases
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ZGC 阶段
- en: 'A GC cycle of ZGC includes multiple phases:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: ZGC 的一个 GC 周期包括多个阶段：
- en: Pause Mark Start
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 暂停标记开始
- en: Pause Mark End
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 暂停标记结束
- en: Pause Relocate Start
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 暂停重定位开始
- en: In the first phase, Pause Mark Start, ZGC marks objects that have been pointed
    to by roots. This includes walking through the live set of objects, and then finding
    and marking them. This is by far one of the most heavy-duty workloads in the ZGC
    GC cycle.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一阶段，暂停标记开始，ZGC 标记由根指针指向的对象。这包括遍历活动对象集，然后找到并标记它们。这无疑是 ZGC GC 周期中最繁重的工作负载之一。
- en: Once this completes, the next cycle is Pause Mark Start, which is used for synchronization
    and starts with a short pause of 1 ms. In this second phase, ZGC starts with reference
    processing and moves to week-root cleaning. It also includes the relocation set
    selection. ZGC marks the regions it wants to compact.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成，下一个周期是暂停标记开始，用于同步，并从 1 毫秒的短暂暂停开始。在这个第二阶段，ZGC 从引用处理开始，然后转向弱根清理。它还包括重定位集选择。ZGC
    标记它想要压缩的区域。
- en: The next step, Pause Relocate Start, triggers the actual region compaction.
    It begins with root scanning pointing into the location set, followed by the concurrent
    reallocation of objects in the relocation set.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步，暂停重定位开始，触发实际的区域压缩。它从指向位置集的根扫描开始，然后是重定位集中对象的并发重新分配。
- en: The first phase, that is, Pause Mark Start, also includes remapping the live
    data. Since marking and remap of live data is the most heavy-duty GC operation,
    it isn't executed as a separate one. Remap starts after Pause Relocate Start but
    overlaps with the Pause Mark Start phase of the next GC cycle.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 第一阶段，即暂停标记开始，还包括重映射活动数据。由于标记和重映射活动数据是最繁重的 GC 操作，它不会作为一个单独的操作执行。重映射在暂停重定位开始后开始，但与下一个
    GC 周期的暂停标记开始阶段重叠。
- en: Colored pointers
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 彩色指针
- en: 'Colored pointers are one of the core concepts of ZGC. It enables ZGC to find,
    mark, locate, and remap the objects. It doesn''t support x32 platforms. Implementation
    of colored points needs virtual address masking, which could be accomplished either
    in the hardware, operating system, or software. The following diagram shows the
    64-bit pointer layout:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 彩色指针是 ZGC 的核心概念之一。它使 ZGC 能够找到、标记、定位和重映射对象。它不支持 x32 平台。彩色指针的实现需要虚拟地址掩码，这可以在硬件、操作系统或软件中完成。以下图表显示了
    64 位指针布局：
- en: '![](img/caffda24-905f-4ef1-8271-d83de904e81a.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/caffda24-905f-4ef1-8271-d83de904e81a.png)'
- en: 'As shown in the preceding diagram, the 64-bit object reference is divided as
    follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，64 位对象引用如下划分：
- en: 18 bits: **Unused bits**
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 18 位：**未使用位**
- en: 1-bit: **Finalizable**
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 位：**可终止**
- en: 1-bit: **Remapped**
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 位：**重映射**
- en: 1-bit: **Marked1**
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 位：**标记1**
- en: 1-bit: **Marked0**
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 位：**标记0**
- en: 42 bits: **Object Address**
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 42 位：**对象地址**
- en: The first 18 bits are reserved for future use. The 42 bits can address up to
    4 TB of address space. Now comes the remaining, intriguing, 4 bits. The `Marked1`
    and `Marked0` bits are used to mark objects for garbage collection. By setting
    the single bit for **Remapped**, an object can be marked not pointing to into
    the relocation set. The last 1-bit for finalizing relates to concurrent reference
    processing. It marks that an object can only be reachable through a finalizer.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的18位被保留供将来使用。42位可以寻址高达4TB的地址空间。现在剩下的是剩余的、引人入胜的4位。`Marked1`和`Marked0`位用于标记对象以进行垃圾收集。通过设置单个位为**Remapped**，对象可以被标记为不指向重定位集。最后的1位用于最终化，与并发引用处理相关。它标记了一个对象只能通过最终化器访问。
- en: When you run ZGC on a system, you'll notice that it uses a lot of virtual memory
    space, which, as you know, is not the same as the physical memory space. This
    is due to heap multi-mapping. It specifies how the objects with the colored pointers
    are stored in the virtual memory.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在系统上运行ZGC时，你会注意到它使用了大量的虚拟内存空间，正如你所知，这并不等同于物理内存空间。这是由于堆多映射。它指定了带有彩色指针的对象如何在虚拟内存中存储。
- en: As an example, for a colorless pointer, say, `0x0000000011111111`, its colored
    pointers would be `0x0000**10**0011111111` (remapped bit set), `0x00000**8**0011111111`
    (`Marked1` bit set), and `0x00000**4**0011111111` (`Marked0` bit set). The same
    physical heap memory would map to three different locations in address space,
    each corresponding to the colored pointer. This would be implemented differently
    when the mapping is handled differently.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，对于一个无色的指针，比如`0x0000000011111111`，它的彩色指针将是`0x0000**10**0011111111`（重映射位设置），`0x00000**8**0011111111`（`Marked1`位设置），和`0x00000**4**0011111111`（`Marked0`位设置）。相同的物理堆内存将映射到地址空间中的三个不同位置，每个位置对应一个彩色指针。当映射处理不同时，这将以不同的方式实现。
- en: Let's explore other important JVM runtime parameters, which you can use to tune
    ZGC.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索其他重要的JVM运行时参数，你可以使用这些参数来调整ZGC。
- en: Tuning ZGC
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调整ZGC
- en: 'Let''s look at a couple of options to fine-tune ZGC (this chapter covers just
    a few basic ones). Let''s start with the most basic option of setting the max
    heap size. We can do this by using the following JVM runtime option:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些调整ZGC的选项（本章仅涵盖一些基本选项）。让我们从设置最大堆大小的最基本选项开始。我们可以通过以下JVM运行时选项来实现：
- en: '[PRE7]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: To get the optimal performance, you must set a heap size that can not only store
    the live set of your application but also has enough space to service the allocations.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得最佳性能，你必须设置一个堆大小，不仅能够存储应用程序的存活集，而且还有足够的空间来服务分配。
- en: 'ZGC is a concurrent garbage collector. By setting the amount of CPU time that
    should be assigned to ZGC threads, you can control how often the GC kicks in.
    You can do so by using the following option:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: ZGC是一个并发垃圾收集器。通过设置分配给ZGC线程的CPU时间量，你可以控制GC触发的频率。你可以通过以下选项来实现：
- en: '[PRE8]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: A higher value for the `ConcGCThreads` option will leave less amount of CPU
    time for your application. On the other hand, a lower value may result in your
    application struggling for memory; your application might generate more garbage
    than what is collected by ZGC. ZGC can also use default values for `ConcGCThreads`.
    To fine-tune your application on this parameter, you might prefer to execute against
    test values.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConcGCThreads`选项的更高值将留给应用程序更少的CPU时间。另一方面，较低的值可能会导致应用程序在内存上挣扎；应用程序可能会生成比ZGC收集的更多垃圾。ZGC也可以使用`ConcGCThreads`的默认值。为了在此参数上微调你的应用程序，你可能更喜欢针对测试值执行。'
- en: 'For advanced ZGC tuning, you can also enable large pages for enhanced performance
    of your application. You can do this by using the following option:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 对于高级ZGC调整，你还可以为应用程序的性能增强启用大页。你可以通过以下选项来实现：
- en: '[PRE9]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The preceding command needs root privileges. Please refer to [https://wiki.openjdk.java.net/display/zgc](https://wiki.openjdk.java.net/display/zgc)
    for detailed steps.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令需要root权限。请参阅[https://wiki.openjdk.java.net/display/zgc](https://wiki.openjdk.java.net/display/zgc)以获取详细步骤。
- en: 'Instead of enabling large pages, you can also enable transparent huge pages
    by using the following option:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 除了启用大页之外，你也可以通过以下选项启用透明大页：
- en: '[PRE10]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The preceding option also includes additional settings and configurations, which
    can be accessed by using ZGC's official wiki page, hosted at [https://wiki.openjdk.java.net/display/zgc](https://wiki.openjdk.java.net/display/zgc).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的选项还包括额外的设置和配置，这些可以通过使用ZGC的官方wiki页面访问，该页面托管在[https://wiki.openjdk.java.net/display/zgc](https://wiki.openjdk.java.net/display/zgc)。
- en: 'ZGC is a NUMA-aware GC. Applications executing on the NUMA machine can result
    in a noticeable performance gain. By default, NUMA support is enabled for ZGC.
    However, if the JVM realizes that it is bound to a subset in the JVM, this feature
    can be disabled. To override a JVM''s decision, you can use the following option:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: ZGC 是一个 NUMA 意识的垃圾回收器。在 NUMA 机器上执行的应用程序可以带来明显的性能提升。默认情况下，ZGC 启用了 NUMA 支持。然而，如果
    JVM 认为它绑定在 JVM 的一个子集上，则此功能可以被禁用。要覆盖 JVM 的决定，可以使用以下选项：
- en: '[PRE11]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Summary
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered a scalable, low latency GC for OpenJDK—ZGC. It is
    an experimental GC, which has been written from scratch. As a concurrent GC, it
    promises max latency to be less than 10 milliseconds, which doesn't increase with
    heap size or live data.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了适用于 OpenJDK 的一个可扩展、低延迟的垃圾回收器——ZGC。它是一个从头开始编写的实验性垃圾回收器。作为一个并发垃圾回收器，它承诺最大延迟小于
    10 毫秒，并且不会随着堆大小或存活数据的增加而增加。
- en: At present, it only works with Linux/x64\. More platforms can be supported in
    the future, if there is considerable demand for it.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，它仅支持 Linux/x64。如果对其有相当大的需求，未来可以支持更多平台。
- en: In the next chapter, you'll discover how you can use **Java Flight Recorder**
    (**JFR**) and **Mission Control** (**MC**) to capture the OS and JVM events in
    a file and analyze them.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将了解到如何使用 **Java 飞行记录器**（**JFR**）和 **任务控制**（**MC**）将操作系统和 JVM 事件捕获到文件中并进行分析。
