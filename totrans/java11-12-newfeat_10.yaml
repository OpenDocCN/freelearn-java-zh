- en: ZGC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Java 11 includes a lot of improvements and changes in the GC domain. With **Z
    Garbage Collector** (**ZGC**), Java is bringing another GC for you—scalable, with
    low latency. It is a completely new GC, written from scratch. It can work with
    heap memory, ranging from KBs to a large TB memory. As a concurrent garbage collector,
    ZGC promises not to exceed application latency by 10 milliseconds, even for bigger
    heap sizes. It is also easy to tune.
  prefs: []
  type: TYPE_NORMAL
- en: It was released with Java 11 as an experimental GC. Work is in progress on this
    GC in OpenJDK and you can expect more changes to it over time.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Why ZGC is required
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Features of ZGC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Examples of working with ZGC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ZGC use cases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can use the ZGC with Java 11 and with Linux/x64 systems. ZGC is an experimental
    GC. All of the code in this chapter can be accessed by going to this book's GitHub
    repository at: [https://github.com/PacktPublishing/Java-11-and-12-New-Features](https://github.com/PacktPublishing/Java-11-and-12-New-Features).
  prefs: []
  type: TYPE_NORMAL
- en: Let's get started by assessing why we need ZGC.
  prefs: []
  type: TYPE_NORMAL
- en: The motivation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the features that resulted in the rise of Java in the early days was
    its automatic memory management with its GCs, which freed developers from manual
    memory management and lowered memory leaks.
  prefs: []
  type: TYPE_NORMAL
- en: However, with unpredictable timings and durations, garbage collection can (at
    times) do more harm to an application than good. Increased latency directly affects
    the throughput and performance of an application. With eve-decreasing hardware
    costs and programs engineered to use largish memories, applications are demanding
    lower latency and higher throughput from garbage collectors.
  prefs: []
  type: TYPE_NORMAL
- en: ZGC promises a latency of no more than 10 milliseconds, which doesn't increase
    with heap size or a live set. This is because its stop-the-world pauses are limited
    to root scanning.
  prefs: []
  type: TYPE_NORMAL
- en: ZGC is a scalable, low latency GC, which promises up to 10 milliseconds of latency,
    even for large heap memory (terabytes in size).
  prefs: []
  type: TYPE_NORMAL
- en: Features of ZGC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Written from scratch, ZGC brings in a lot of features, which have been instrumental
    in its proposal, design, and implementation.
  prefs: []
  type: TYPE_NORMAL
- en: One of the most outstanding features of ZGC is that it is a concurrent GC. It
    can mark memory and copy and relocate it, all concurrently. It also has a concurrent
    reference processor. This essentially means that you can add all sort of references,
    such as weak references, soft references, phantom references, or finalizers (these
    are deprecated now). Even then, ZGC won't add more GC pauses for you (since it
    will clean or reclaim the memory concurrently).
  prefs: []
  type: TYPE_NORMAL
- en: As opposed to the store barriers that are used by another HotSpot GCs, ZGC uses
    load barriers. The load barriers are used to keep track of heap usage. One of
    the intriguing features of ZGC is the usage of load barriers with colored pointers.
    This is what enables ZGC to perform concurrent operations when Java threads are
    running, such as object relocation or relocation set selection.
  prefs: []
  type: TYPE_NORMAL
- en: ZGC is a region-based garbage collector. However, if you compare it to the G1
    garbage collector, ZGC is more flexible in configuring its size and scheme. Compared
    to G1, ZGC has better ways to deal with very large object allocations.
  prefs: []
  type: TYPE_NORMAL
- en: ZGC is a single-generation GC. It also supports partial compaction. ZGC is also
    highly performant when it comes to reclaiming memory and reallocating it.
  prefs: []
  type: TYPE_NORMAL
- en: ZGC is NUMA-aware, which essentially means that it has a NUMA-aware memory allocator.
  prefs: []
  type: TYPE_NORMAL
- en: An experimental garbage collector, ZGC is only available on Linux/x64\. More
    platform support will be added in the future if there is a considerable demand
    for it.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with ZGC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Working with ZGC involves multiple steps. You should install the JDK binary,
    which is specific to Linux/x64, and build and start it. You can use the following
    commands to download ZGC and build it on your system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'After execution of the preceding commands, you can find the JDK root directory
    in the following location:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Java tools, such as `java`, `javac`, and others can be found in the `/bin` subdirectory
    of the preceding path (its usual location).
  prefs: []
  type: TYPE_NORMAL
- en: 'Spoiler alert: You won''t be able to work with ZGC unless you have Linux/x64.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a basic `HelloZGC` class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use the following command to enable ZGC and use it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Since ZGC is an experimental GC, you need to unlock it using the runtime option,
    that is, `XX:+UnlockExperimentalVMOptions`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For enabling basic GC logging, you can add the `-Xlog:gc` option. Let''s modify
    the preceding code, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Detailed logging is helpful when you are fine-tuning your application. You
    can enable it by using the `-Xlog:gc*` option  as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous command will output all the logs to the console, which could make
    it difficult to search for specific content. You can specify the logs to be written
    to a file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: When compared with G1 and parallel GCs, ZGC performs better in terms of lower
    latency and higher application throughput.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a sneak peek into how ZGC arranges the heap for object allocation
    (in short, let's start with exploring the secret sauce of ZGC).
  prefs: []
  type: TYPE_NORMAL
- en: ZGC heap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'ZGC divides memory into regions, also called **ZPages**. ZPages can be dynamically
    created and destroyed. These can also be dynamically sized (unlike the G1 GC),
    which are multiples of 2 MB. Here are the size groups of heap regions:'
  prefs: []
  type: TYPE_NORMAL
- en: Small (2 MB)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Medium (32 MB)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Large (*N ** 2 MB)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ZGC heap can have multiple occurrences of these heap regions. The medium and
    large regions are allocated contiguously, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f39ecb71-53bb-4779-b4e2-42c64f9856ba.png)'
  prefs: []
  type: TYPE_IMG
- en: Unlike other GCs, the physical heap regions of ZGC can map into a bigger heap
    address space (which can include virtual memory). This can be crucial to combat
    memory fragmentation issues. Imagine that you can allocate a really big object
    in memory, but you can't do so due to unavailability of contiguous space in memory.
  prefs: []
  type: TYPE_NORMAL
- en: This often leads to multiple GC cycles to free up enough contiguous space. If
    none are available, even after (multiple) GC cycle(s), your JVM will shut down
    with `OutOfMemoryError`. However, this particular use case is not an issue with
    the ZGC. Since the physical memory maps to a bigger address space, locating a
    bigger contiguous space is feasible.
  prefs: []
  type: TYPE_NORMAL
- en: ZPages are a multiple of the same number, say, 2 MB on an Intel machine. It
    could vary, to, say, 4 MB on an *S* machine.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's see how the ZGC reclaims the memory from its regions.
  prefs: []
  type: TYPE_NORMAL
- en: ZGC phases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A GC cycle of ZGC includes multiple phases:'
  prefs: []
  type: TYPE_NORMAL
- en: Pause Mark Start
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pause Mark End
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pause Relocate Start
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the first phase, Pause Mark Start, ZGC marks objects that have been pointed
    to by roots. This includes walking through the live set of objects, and then finding
    and marking them. This is by far one of the most heavy-duty workloads in the ZGC
    GC cycle.
  prefs: []
  type: TYPE_NORMAL
- en: Once this completes, the next cycle is Pause Mark Start, which is used for synchronization
    and starts with a short pause of 1 ms. In this second phase, ZGC starts with reference
    processing and moves to week-root cleaning. It also includes the relocation set
    selection. ZGC marks the regions it wants to compact.
  prefs: []
  type: TYPE_NORMAL
- en: The next step, Pause Relocate Start, triggers the actual region compaction.
    It begins with root scanning pointing into the location set, followed by the concurrent
    reallocation of objects in the relocation set.
  prefs: []
  type: TYPE_NORMAL
- en: The first phase, that is, Pause Mark Start, also includes remapping the live
    data. Since marking and remap of live data is the most heavy-duty GC operation,
    it isn't executed as a separate one. Remap starts after Pause Relocate Start but
    overlaps with the Pause Mark Start phase of the next GC cycle.
  prefs: []
  type: TYPE_NORMAL
- en: Colored pointers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Colored pointers are one of the core concepts of ZGC. It enables ZGC to find,
    mark, locate, and remap the objects. It doesn''t support x32 platforms. Implementation
    of colored points needs virtual address masking, which could be accomplished either
    in the hardware, operating system, or software. The following diagram shows the
    64-bit pointer layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/caffda24-905f-4ef1-8271-d83de904e81a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As shown in the preceding diagram, the 64-bit object reference is divided as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 18 bits: **Unused bits**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1-bit: **Finalizable**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1-bit: **Remapped**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1-bit: **Marked1**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1-bit: **Marked0**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 42 bits: **Object Address**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first 18 bits are reserved for future use. The 42 bits can address up to
    4 TB of address space. Now comes the remaining, intriguing, 4 bits. The `Marked1`
    and `Marked0` bits are used to mark objects for garbage collection. By setting
    the single bit for **Remapped**, an object can be marked not pointing to into
    the relocation set. The last 1-bit for finalizing relates to concurrent reference
    processing. It marks that an object can only be reachable through a finalizer.
  prefs: []
  type: TYPE_NORMAL
- en: When you run ZGC on a system, you'll notice that it uses a lot of virtual memory
    space, which, as you know, is not the same as the physical memory space. This
    is due to heap multi-mapping. It specifies how the objects with the colored pointers
    are stored in the virtual memory.
  prefs: []
  type: TYPE_NORMAL
- en: As an example, for a colorless pointer, say, `0x0000000011111111`, its colored
    pointers would be `0x0000**10**0011111111` (remapped bit set), `0x00000**8**0011111111`
    (`Marked1` bit set), and `0x00000**4**0011111111` (`Marked0` bit set). The same
    physical heap memory would map to three different locations in address space,
    each corresponding to the colored pointer. This would be implemented differently
    when the mapping is handled differently.
  prefs: []
  type: TYPE_NORMAL
- en: Let's explore other important JVM runtime parameters, which you can use to tune
    ZGC.
  prefs: []
  type: TYPE_NORMAL
- en: Tuning ZGC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s look at a couple of options to fine-tune ZGC (this chapter covers just
    a few basic ones). Let''s start with the most basic option of setting the max
    heap size. We can do this by using the following JVM runtime option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: To get the optimal performance, you must set a heap size that can not only store
    the live set of your application but also has enough space to service the allocations.
  prefs: []
  type: TYPE_NORMAL
- en: 'ZGC is a concurrent garbage collector. By setting the amount of CPU time that
    should be assigned to ZGC threads, you can control how often the GC kicks in.
    You can do so by using the following option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: A higher value for the `ConcGCThreads` option will leave less amount of CPU
    time for your application. On the other hand, a lower value may result in your
    application struggling for memory; your application might generate more garbage
    than what is collected by ZGC. ZGC can also use default values for `ConcGCThreads`.
    To fine-tune your application on this parameter, you might prefer to execute against
    test values.
  prefs: []
  type: TYPE_NORMAL
- en: 'For advanced ZGC tuning, you can also enable large pages for enhanced performance
    of your application. You can do this by using the following option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command needs root privileges. Please refer to [https://wiki.openjdk.java.net/display/zgc](https://wiki.openjdk.java.net/display/zgc)
    for detailed steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of enabling large pages, you can also enable transparent huge pages
    by using the following option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The preceding option also includes additional settings and configurations, which
    can be accessed by using ZGC's official wiki page, hosted at [https://wiki.openjdk.java.net/display/zgc](https://wiki.openjdk.java.net/display/zgc).
  prefs: []
  type: TYPE_NORMAL
- en: 'ZGC is a NUMA-aware GC. Applications executing on the NUMA machine can result
    in a noticeable performance gain. By default, NUMA support is enabled for ZGC.
    However, if the JVM realizes that it is bound to a subset in the JVM, this feature
    can be disabled. To override a JVM''s decision, you can use the following option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered a scalable, low latency GC for OpenJDK—ZGC. It is
    an experimental GC, which has been written from scratch. As a concurrent GC, it
    promises max latency to be less than 10 milliseconds, which doesn't increase with
    heap size or live data.
  prefs: []
  type: TYPE_NORMAL
- en: At present, it only works with Linux/x64\. More platforms can be supported in
    the future, if there is considerable demand for it.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you'll discover how you can use **Java Flight Recorder**
    (**JFR**) and **Mission Control** (**MC**) to capture the OS and JVM events in
    a file and analyze them.
  prefs: []
  type: TYPE_NORMAL
