<html><head></head><body>
<div class="IMG---Figure" id="_idContainer060">
<h1 class="chapter-number" id="_idParaDest-140"><a id="_idTextAnchor149"/><span class="koboSpan" id="kobo.1.1">8</span></h1>
<h1 id="_idParaDest-141"><a id="_idTextAnchor150"/><span class="koboSpan" id="kobo.2.1">Test Doubles – Stubs and Mocks</span></h1>
<p><span class="koboSpan" id="kobo.3.1">In this chapter, we’re going to solve a common testing challenge. </span><span class="koboSpan" id="kobo.3.2">How do you test an object that depends on another object? </span><span class="koboSpan" id="kobo.3.3">What do we do if that collaborator is difficult to set up with test data? </span><span class="koboSpan" id="kobo.3.4">Several techniques are available to help us with this and they build on the SOLID principles we learned previously. </span><span class="koboSpan" id="kobo.3.5">We can use the idea of dependency injection to enable us to replace collaborating objects with ones specially written to help us write </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">our test.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">These new objects are called test doubles, and we will learn about two important kinds of test double in this chapter. </span><span class="koboSpan" id="kobo.5.2">We will learn when to apply each kind of test double and then learn two ways of creating them in Java – both by writing the code ourselves and by using the popular library Mockito. </span><span class="koboSpan" id="kobo.5.3">By the end of the chapter, we will have techniques that allow us to write tests for objects where it is difficult or impossible to test them with the real collaborating objects in place. </span><span class="koboSpan" id="kobo.5.4">This allows us to use TDD with </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">complex systems.</span></span></p>
<p><span class="koboSpan" id="kobo.7.1">In this chapter, we’re going to cover the following </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">main topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.9.1">The problems of </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">testing collaborators</span></span></li>
<li><span class="koboSpan" id="kobo.11.1">The purpose of </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">test doubles</span></span></li>
<li><span class="koboSpan" id="kobo.13.1">Using stubs for </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">pre-canned results</span></span></li>
<li><span class="koboSpan" id="kobo.15.1">Using mocks to </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">verify interactions</span></span></li>
<li><span class="koboSpan" id="kobo.17.1">Understanding when test doubles </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">are appropriate</span></span></li>
<li><span class="koboSpan" id="kobo.19.1">Working with Mockito – a popular </span><span class="No-Break"><span class="koboSpan" id="kobo.20.1">mocking library</span></span></li>
<li><span class="koboSpan" id="kobo.21.1">Driving error handling code </span><span class="No-Break"><span class="koboSpan" id="kobo.22.1">using stubs</span></span></li>
<li><span class="koboSpan" id="kobo.23.1">Testing an error condition </span><span class="No-Break"><span class="koboSpan" id="kobo.24.1">in Wordz</span></span></li>
</ul>
<h1 id="_idParaDest-142"><a id="_idTextAnchor151"/><span class="koboSpan" id="kobo.25.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.26.1">The code for this chapter can be found </span><span class="No-Break"><span class="koboSpan" id="kobo.27.1">at </span></span><a href="B18384_08.xhtml#_idTextAnchor177"><span class="No-Break"><span class="koboSpan" id="kobo.28.1">https://github.com/PacktPublishing/Test-Driven-Development-with-Java/tree/main/chapter08</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.29.1">.</span></span></p>
<h1 id="_idParaDest-143"><a id="_idTextAnchor152"/><span class="koboSpan" id="kobo.30.1">The problems collaborators present for testing</span></h1>
<p><span class="koboSpan" id="kobo.31.1">In this section, we will understand</span><a id="_idIndexMarker322"/><span class="koboSpan" id="kobo.32.1"> the challenges that arise as we grow our software into a larger code base. </span><span class="koboSpan" id="kobo.32.2">We will review what is meant by a collaborating object, then we will take a look at two examples of collaborations that are challenging </span><span class="No-Break"><span class="koboSpan" id="kobo.33.1">to test.</span></span></p>
<p><span class="koboSpan" id="kobo.34.1">As we grow our software system, we will soon outgrow what can go in a single class (or function, for that matter). </span><span class="koboSpan" id="kobo.34.2">We will split our code into multiple parts. </span><span class="koboSpan" id="kobo.34.3">If we pick a single object as our subject under test, any other object that it depends on is a collaborator. </span><span class="koboSpan" id="kobo.34.4">Our TDD tests must account for the presence of these collaborators. </span><span class="koboSpan" id="kobo.34.5">Sometimes, this is straightforward, as we’ve seen in </span><span class="No-Break"><span class="koboSpan" id="kobo.35.1">earlier chapters.</span></span></p>
<p><span class="koboSpan" id="kobo.36.1">Unfortunately, things aren’t always that simple. </span><span class="koboSpan" id="kobo.36.2">Some collaborations make tests difficult – or impossible – to write. </span><span class="koboSpan" id="kobo.36.3">These kinds of collaborators introduce either unrepeatable behaviors that we must contend with or present errors that are difficult </span><span class="No-Break"><span class="koboSpan" id="kobo.37.1">to trigger.</span></span></p>
<p><span class="koboSpan" id="kobo.38.1">Let’s review these challenges with some short examples. </span><span class="koboSpan" id="kobo.38.2">We’ll start with a common problem: a collaborator that exhibits </span><span class="No-Break"><span class="koboSpan" id="kobo.39.1">unrepeatable behavior.</span></span></p>
<h2 id="_idParaDest-144"><a id="_idTextAnchor153"/><span class="koboSpan" id="kobo.40.1">The challenges of testing unrepeatable behavior</span></h2>
<p><span class="koboSpan" id="kobo.41.1">We’ve learned that the basic</span><a id="_idIndexMarker323"/><span class="koboSpan" id="kobo.42.1"> steps of a TDD test are Arrange, Act, and Assert. </span><span class="koboSpan" id="kobo.42.2">We ask the object to act and then assert that an expected outcome happens. </span><span class="koboSpan" id="kobo.42.3">But what happens when that outcome </span><span class="No-Break"><span class="koboSpan" id="kobo.43.1">is unpredictable?</span></span></p>
<p><span class="koboSpan" id="kobo.44.1">To illustrate, let’s review a class that rolls a die and presents a text string to say what </span><span class="No-Break"><span class="koboSpan" id="kobo.45.1">we rolled:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.46.1">
package examples;
import java.util.random.RandomGenerator;
public class DiceRoll {
    private final int NUMBER_OF_SIDES = 6;
    private final RandomGenerator rnd =
                       RandomGenerator.getDefault();
    public String asText() {
        int rolled = rnd.nextInt(NUMBER_OF_SIDES) + 1;
        return String.format("You rolled a %d", rolled);
    }
}</span></pre>
<p><span class="koboSpan" id="kobo.47.1">This is simple enough code, with only a handful of executable lines in it. </span><span class="koboSpan" id="kobo.47.2">Sadly, </span><em class="italic"><span class="koboSpan" id="kobo.48.1">simple to write is not always simple to test</span></em><span class="koboSpan" id="kobo.49.1">. </span><span class="koboSpan" id="kobo.49.2">How would we write a test for this? </span><span class="koboSpan" id="kobo.49.3">Specifically – how would we write the assert? </span><span class="koboSpan" id="kobo.49.4">In previous tests, we’ve always known exactly what to expect in the assertion. </span><span class="koboSpan" id="kobo.49.5">Here, the assertion</span><a id="_idIndexMarker324"/><span class="koboSpan" id="kobo.50.1"> will be some fixed text plus a random number. </span><span class="koboSpan" id="kobo.50.2">We don’t know in advance what that random number </span><span class="No-Break"><span class="koboSpan" id="kobo.51.1">will be.</span></span></p>
<h2 id="_idParaDest-145"><a id="_idTextAnchor154"/><span class="koboSpan" id="kobo.52.1">The challenges of testing error handling</span></h2>
<p><span class="koboSpan" id="kobo.53.1">Testing code that handles error conditions</span><a id="_idIndexMarker325"/><span class="koboSpan" id="kobo.54.1"> is another challenge. </span><span class="koboSpan" id="kobo.54.2">The difficulty here lies not in asserting that the error was handled, but rather the challenge is how to trigger that error to happen inside the </span><span class="No-Break"><span class="koboSpan" id="kobo.55.1">collaborating object.</span></span></p>
<p><span class="koboSpan" id="kobo.56.1">To illustrate, let’s imagine a code to warn us when the battery in our portable device is </span><span class="No-Break"><span class="koboSpan" id="kobo.57.1">getting low:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.58.1">
public class BatteryMonitor {
    public void warnWhenBatteryPowerLow() {
        if (DeviceApi.getBatteryPercentage() &lt; 10) {
            System.out.println("Warning - Battery low");
        }
    }
}</span></pre>
<p><span class="koboSpan" id="kobo.59.1">The preceding code in </span><strong class="source-inline"><span class="koboSpan" id="kobo.60.1">BatteryMonitor</span></strong><span class="koboSpan" id="kobo.61.1"> features a </span><strong class="source-inline"><span class="koboSpan" id="kobo.62.1">DeviceApi</span></strong><span class="koboSpan" id="kobo.63.1"> class, which is a library class that lets us read how much battery we have left on our phone. </span><span class="koboSpan" id="kobo.63.2">It provides a static method to do this, called </span><strong class="source-inline"><span class="koboSpan" id="kobo.64.1">getBatteryPercentage()</span></strong><span class="koboSpan" id="kobo.65.1">. </span><span class="koboSpan" id="kobo.65.2">This will return an integer in the range </span><em class="italic"><span class="koboSpan" id="kobo.66.1">0 </span></em><span class="koboSpan" id="kobo.67.1">to </span><em class="italic"><span class="koboSpan" id="kobo.68.1">100</span></em><span class="koboSpan" id="kobo.69.1"> percent. </span><span class="koboSpan" id="kobo.69.2">The code that we want to write a TDD test for calls </span><strong class="source-inline"><span class="koboSpan" id="kobo.70.1">getBatteryPercentage()</span></strong><span class="koboSpan" id="kobo.71.1"> and will display a warning message if it is less than </span><em class="italic"><span class="koboSpan" id="kobo.72.1">10</span></em><span class="koboSpan" id="kobo.73.1"> percent. </span><span class="koboSpan" id="kobo.73.2">But there’s a problem writing this test: how can we force the </span><strong class="source-inline"><span class="koboSpan" id="kobo.74.1">getBatteryPercentage()</span></strong><span class="koboSpan" id="kobo.75.1"> method to return a number less than 10 as part of our Arrange step? </span><span class="koboSpan" id="kobo.75.2">Would we discharge the battery somehow? </span><span class="koboSpan" id="kobo.75.3">How would we </span><span class="No-Break"><span class="koboSpan" id="kobo.76.1">do this?</span></span></p>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.77.1">BatteryMonitor</span></strong><span class="koboSpan" id="kobo.78.1"> provides an example</span><a id="_idIndexMarker326"/><span class="koboSpan" id="kobo.79.1"> of code that collaborates with another object, where it is impossible to force a known response from that collaborator. </span><span class="koboSpan" id="kobo.79.2">We have no way to change the value that </span><strong class="source-inline"><span class="koboSpan" id="kobo.80.1">getBatteryPercentage()</span></strong><span class="koboSpan" id="kobo.81.1"> will return. </span><span class="koboSpan" id="kobo.81.2">We would literally have to wait until the battery had discharged before this test could pass. </span><span class="koboSpan" id="kobo.81.3">That’s not what TDD </span><span class="No-Break"><span class="koboSpan" id="kobo.82.1">is about.</span></span></p>
<h2 id="_idParaDest-146"><a id="_idTextAnchor155"/><span class="koboSpan" id="kobo.83.1">Understanding why these collaborations are challenging</span></h2>
<p><span class="koboSpan" id="kobo.84.1">When doing TDD, we want </span><em class="italic"><span class="koboSpan" id="kobo.85.1">fast</span></em><span class="koboSpan" id="kobo.86.1"> and </span><em class="italic"><span class="koboSpan" id="kobo.87.1">repeatable</span></em><span class="koboSpan" id="kobo.88.1"> tests. </span><span class="koboSpan" id="kobo.88.2">Any scenario that involves unpredictable behavior or requires us to control a situation that we have no control over clearly causes problems </span><span class="No-Break"><span class="koboSpan" id="kobo.89.1">for TDD.</span></span></p>
<p><span class="koboSpan" id="kobo.90.1">The best way to write tests </span><a id="_idIndexMarker327"/><span class="koboSpan" id="kobo.91.1">in these cases is by eliminating the cause of the difficulty. </span><span class="koboSpan" id="kobo.91.2">Fortunately, a simple solution exists. </span><span class="koboSpan" id="kobo.91.3">We can apply the </span><em class="italic"><span class="koboSpan" id="kobo.92.1">Dependency Injection Principle</span></em><span class="koboSpan" id="kobo.93.1"> we learned about in the previous chapter, along with one new idea – the </span><em class="italic"><span class="koboSpan" id="kobo.94.1">test double</span></em><span class="koboSpan" id="kobo.95.1">. </span><span class="koboSpan" id="kobo.95.2">We will review test doubles in the </span><span class="No-Break"><span class="koboSpan" id="kobo.96.1">next section.</span></span></p>
<h1 id="_idParaDest-147"><a id="_idTextAnchor156"/><span class="koboSpan" id="kobo.97.1">The purpose of test doubles</span></h1>
<p><span class="koboSpan" id="kobo.98.1">In this section, we’re going</span><a id="_idIndexMarker328"/><span class="koboSpan" id="kobo.99.1"> to learn techniques that allow us to test these challenging collaborations. </span><span class="koboSpan" id="kobo.99.2">We will introduce the idea of test doubles. </span><span class="koboSpan" id="kobo.99.3">We will learn how to apply the SOLID principles to design code flexible enough to use these </span><span class="No-Break"><span class="koboSpan" id="kobo.100.1">test doubles.</span></span></p>
<p><span class="koboSpan" id="kobo.101.1">The challenges of the previous section are solved by using </span><strong class="bold"><span class="koboSpan" id="kobo.102.1">test doubles</span></strong><span class="koboSpan" id="kobo.103.1">. </span><span class="koboSpan" id="kobo.103.2">A test double replaces</span><a id="_idIndexMarker329"/><span class="koboSpan" id="kobo.104.1"> one of the collaborating objects in our test. </span><span class="koboSpan" id="kobo.104.2">By design, this test double avoids the difficulties of the replaced object. </span><span class="koboSpan" id="kobo.104.3">Think of them as the stunt doubles in movies, replacing the real actors to help safely get an </span><span class="No-Break"><span class="koboSpan" id="kobo.105.1">action shot.</span></span></p>
<p><span class="koboSpan" id="kobo.106.1">A software test double is an object we have written specifically to be easy to use in our unit test. </span><span class="koboSpan" id="kobo.106.2">In the test, we inject our test double into the SUT in the Arrange step. </span><span class="koboSpan" id="kobo.106.3">In production code, we inject in the production object that our test double </span><span class="No-Break"><span class="koboSpan" id="kobo.107.1">had replaced.</span></span></p>
<p><span class="koboSpan" id="kobo.108.1">Let’s reconsider our </span><strong class="source-inline"><span class="koboSpan" id="kobo.109.1">DiceRoll</span></strong><span class="koboSpan" id="kobo.110.1"> example earlier. </span><span class="koboSpan" id="kobo.110.2">How would we refactor that code to make it easier </span><span class="No-Break"><span class="koboSpan" id="kobo.111.1">to test?</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.112.1">Create an interface that abstracts the source of </span><span class="No-Break"><span class="koboSpan" id="kobo.113.1">random numbers:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.114.1">
interface RandomNumbers {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.115.1">
    int nextInt(int upperBoundExclusive);</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.116.1">
}</span></pre></li>
<li><span class="koboSpan" id="kobo.117.1">Apply the </span><em class="italic"><span class="koboSpan" id="kobo.118.1">Dependency Inversion Principle</span></em><span class="koboSpan" id="kobo.119.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.120.1">class DiceRoll</span></strong><span class="koboSpan" id="kobo.121.1"> to make use of </span><span class="No-Break"><span class="koboSpan" id="kobo.122.1">this abstraction:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.123.1">
package examples;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.124.1">
import java.util.random.RandomGenerator;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.125.1">
public class DiceRoll {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.126.1">
    private final int NUMBER_OF_SIDES = 6;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.127.1">
    </span><strong class="bold"><span class="koboSpan" id="kobo.128.1">private final RandomNumbers rnd ;</span></strong></pre><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.129.1">    public DiceRoll( RandomNumbers r ) {</span></strong></pre><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.130.1">        this.rnd = r;</span></strong></pre><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.131.1">    }</span></strong></pre><pre class="source-code"><span class="koboSpan" id="kobo.132.1">
    public String asText() {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.133.1">
        int rolled = rnd.nextInt(NUMBER_OF_SIDES) + 1;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.134.1">
        return String.format("You rolled a %d",</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.135.1">
                             rolled);</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.136.1">
    }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.137.1">
}</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.138.1">We have inverted the dependency</span><a id="_idIndexMarker330"/><span class="koboSpan" id="kobo.139.1"> on the random number generator by replacing it with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.140.1">RandomNumbers</span></strong><span class="koboSpan" id="kobo.141.1"> interface. </span><span class="koboSpan" id="kobo.141.2">We added a constructor that allows a suitable </span><strong class="source-inline"><span class="koboSpan" id="kobo.142.1">RandomNumbers</span></strong><span class="koboSpan" id="kobo.143.1"> implementation to be injected. </span><span class="koboSpan" id="kobo.143.2">We assign that to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.144.1">rnd</span></strong><span class="koboSpan" id="kobo.145.1"> field. </span><span class="koboSpan" id="kobo.145.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.146.1">asText()</span></strong><span class="koboSpan" id="kobo.147.1"> method now calls the </span><strong class="source-inline"><span class="koboSpan" id="kobo.148.1">nextInt()</span></strong><span class="koboSpan" id="kobo.149.1"> method on whatever object we passed to </span><span class="No-Break"><span class="koboSpan" id="kobo.150.1">the constructor.</span></span></p>
<ol>
<li value="3"><span class="koboSpan" id="kobo.151.1">Write a test, using a test double to replace the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.152.1">RandomNumbers</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.153.1"> source:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.154.1">
package examples;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.155.1">
import org.junit.jupiter.api.Test;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.156.1">
import static org.assertj.core.api.Assertions.assertThat;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.157.1">
class DiceRollTest {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.158.1">
    @Test</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.159.1">
    void producesMessage() {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.160.1">
        </span><strong class="bold"><span class="koboSpan" id="kobo.161.1">var stub = new StubRandomNumbers();</span></strong></pre><pre class="source-code"><span class="koboSpan" id="kobo.162.1">
        var roll = </span><strong class="bold"><span class="koboSpan" id="kobo.163.1">new DiceRoll(stub);</span></strong></pre><pre class="source-code"><span class="koboSpan" id="kobo.164.1">
        var actual = roll.asText();</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.165.1">
        assertThat(actual).isEqualTo("You rolled a</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.166.1">
                                     5");</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.167.1">
    }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.168.1">
}</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.169.1">We see the usual Arrange, Act, and</span><a id="_idIndexMarker331"/><span class="koboSpan" id="kobo.170.1"> Assert sections in this test. </span><span class="koboSpan" id="kobo.170.2">The new idea here is </span><strong class="source-inline"><span class="koboSpan" id="kobo.171.1">class StubRandomNumbers</span></strong><span class="koboSpan" id="kobo.172.1">. </span><span class="koboSpan" id="kobo.172.2">Let’s look at the </span><span class="No-Break"><span class="koboSpan" id="kobo.173.1">stub code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.174.1">
package examples;
public class </span><strong class="bold"><span class="koboSpan" id="kobo.175.1">StubRandomNumbers implements RandomNumbers</span></strong><span class="koboSpan" id="kobo.176.1"> {
    @Override
    public int nextInt(int upperBoundExclusive) {
        </span><strong class="bold"><span class="koboSpan" id="kobo.177.1">return 4;</span></strong><span class="koboSpan" id="kobo.178.1">  // @see </span><a href="B18384_08.xhtml#_idTextAnchor176"><span class="koboSpan" id="kobo.179.1">https://xkcd.com/221</span></a><span class="koboSpan" id="kobo.180.1">
    }
}</span></pre>
<p><span class="koboSpan" id="kobo.181.1">There are a few things to notice about this stub. </span><span class="koboSpan" id="kobo.181.2">Firstly, it implements our </span><strong class="source-inline"><span class="koboSpan" id="kobo.182.1">RandomNumbers</span></strong><span class="koboSpan" id="kobo.183.1"> interface, making it an LSP-compliant substitute for that interface. </span><span class="koboSpan" id="kobo.183.2">This allows us to inject it into the constructor of </span><strong class="source-inline"><span class="koboSpan" id="kobo.184.1">DiceRoll</span></strong><span class="koboSpan" id="kobo.185.1">, our SUT. </span><span class="koboSpan" id="kobo.185.2">The second most important aspect is that every call to </span><strong class="source-inline"><span class="koboSpan" id="kobo.186.1">nextInt()</span></strong><span class="koboSpan" id="kobo.187.1"> will </span><em class="italic"><span class="koboSpan" id="kobo.188.1">return the </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.189.1">same number</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.190.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.191.1">By replacing the real </span><strong class="source-inline"><span class="koboSpan" id="kobo.192.1">RandomNumbers</span></strong><span class="koboSpan" id="kobo.193.1"> source with a stub that delivers a known value, we have made our test assertion easy to write. </span><span class="koboSpan" id="kobo.193.2">The stub eliminates the problem of unrepeatable values from the </span><span class="No-Break"><span class="koboSpan" id="kobo.194.1">random generator.</span></span></p>
<p><span class="koboSpan" id="kobo.195.1">We can now see how the </span><strong class="source-inline"><span class="koboSpan" id="kobo.196.1">DiceRollTest</span></strong><span class="koboSpan" id="kobo.197.1"> works. </span><span class="koboSpan" id="kobo.197.2">We supply</span><a id="_idIndexMarker332"/><span class="koboSpan" id="kobo.198.1"> a test double to our SUT. </span><span class="koboSpan" id="kobo.198.2">The test double always returns the same value. </span><span class="koboSpan" id="kobo.198.3">As a result, we can assert against a </span><span class="No-Break"><span class="koboSpan" id="kobo.199.1">known outcome.</span></span></p>
<h2 id="_idParaDest-148"><a id="_idTextAnchor157"/><span class="koboSpan" id="kobo.200.1">Making the production version of the code</span></h2>
<p><span class="koboSpan" id="kobo.201.1">To make </span><strong class="source-inline"><span class="koboSpan" id="kobo.202.1">class DiceRoll</span></strong><span class="koboSpan" id="kobo.203.1"> work properly</span><a id="_idIndexMarker333"/><span class="koboSpan" id="kobo.204.1"> in production, we would need to inject a genuine source of random numbers. </span><span class="koboSpan" id="kobo.204.2">A suitable class would be </span><span class="No-Break"><span class="koboSpan" id="kobo.205.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.206.1">
public class RandomlyGeneratedNumbers implements RandomNumbers {
    private final RandomGenerator rnd =
                       RandomGenerator.getDefault();
    @Override
    public int nextInt(int upperBoundExclusive) {
        return rnd.nextInt(upperBoundExclusive);
    }
}</span></pre>
<p><span class="koboSpan" id="kobo.207.1">There isn’t much work to do here – the preceding code simply implements the </span><strong class="source-inline"><span class="koboSpan" id="kobo.208.1">nextInt()</span></strong><span class="koboSpan" id="kobo.209.1"> method using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.210.1">RandomGenerator</span></strong><span class="koboSpan" id="kobo.211.1"> library class built </span><span class="No-Break"><span class="koboSpan" id="kobo.212.1">into Java.</span></span></p>
<p><span class="koboSpan" id="kobo.213.1">We can now use this to create our production version of the code.  </span><span class="koboSpan" id="kobo.213.2">We already changed our </span><strong class="source-inline"><span class="koboSpan" id="kobo.214.1">DiceRoll</span></strong><span class="koboSpan" id="kobo.215.1"> class to allow us to inject in any suitable implementation of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.216.1">RandomNumbers</span></strong><span class="koboSpan" id="kobo.217.1"> interface. </span><span class="koboSpan" id="kobo.217.2">For our test code, we injected in a test double – an instance of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.218.1">StubRandomNumbers</span></strong><span class="koboSpan" id="kobo.219.1"> class. </span><span class="koboSpan" id="kobo.219.2">For our production code, we will instead inject in an instance of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.220.1">RandomlyGeneratedNumbers</span></strong><span class="koboSpan" id="kobo.221.1"> class. </span><span class="koboSpan" id="kobo.221.2">The production code will use that object to create</span><a id="_idIndexMarker334"/><span class="koboSpan" id="kobo.222.1"> real random numbers – and there will be no code changes inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.223.1">DiceRoll</span></strong><span class="koboSpan" id="kobo.224.1"> class. </span><span class="koboSpan" id="kobo.224.2">We have used the Dependency Inversion Principle to make </span><strong class="source-inline"><span class="koboSpan" id="kobo.225.1">class DiceRoll</span></strong><span class="koboSpan" id="kobo.226.1"> configurable by dependency injection. </span><span class="koboSpan" id="kobo.226.2">This means that </span><strong class="source-inline"><span class="koboSpan" id="kobo.227.1">class DiceRoll</span></strong><span class="koboSpan" id="kobo.228.1"> now follows the Open/Closed Principle – it is </span><em class="italic"><span class="koboSpan" id="kobo.229.1">open</span></em><span class="koboSpan" id="kobo.230.1"> to new kinds of random number generation behavior but </span><em class="italic"><span class="koboSpan" id="kobo.231.1">closed</span></em><span class="koboSpan" id="kobo.232.1"> to code changes inside the </span><span class="No-Break"><span class="koboSpan" id="kobo.233.1">class itself.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.234.1">Dependency inversion, dependency injection, and inversion of control</span></p>
<p class="callout"><span class="koboSpan" id="kobo.235.1">The preceding example</span><a id="_idIndexMarker335"/><span class="koboSpan" id="kobo.236.1"> shows these three ideas in action. </span><em class="italic"><span class="koboSpan" id="kobo.237.1">Dependency inversion</span></em><span class="koboSpan" id="kobo.238.1"> is the design technique where we create an abstraction in our code. </span><em class="italic"><span class="koboSpan" id="kobo.239.1">Dependency injection</span></em><span class="koboSpan" id="kobo.240.1"> is the runtime technique where we supply</span><a id="_idIndexMarker336"/><span class="koboSpan" id="kobo.241.1"> an implementation of that abstraction to code that depends on it. </span><span class="koboSpan" id="kobo.241.2">Together, these ideas are often termed </span><strong class="bold"><span class="koboSpan" id="kobo.242.1">Inversion of Control</span></strong><span class="koboSpan" id="kobo.243.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.244.1">IoC</span></strong><span class="koboSpan" id="kobo.245.1">). </span><span class="koboSpan" id="kobo.245.2">Frameworks such as Spring</span><a id="_idIndexMarker337"/><span class="koboSpan" id="kobo.246.1"> are sometimes called IoC containers because they provide tools to help you manage creating and injecting dependencies in </span><span class="No-Break"><span class="koboSpan" id="kobo.247.1">an application.</span></span></p>
<p><span class="koboSpan" id="kobo.248.1">The following code is an example of how we would use </span><strong class="source-inline"><span class="koboSpan" id="kobo.249.1">DiceRoll</span></strong><span class="koboSpan" id="kobo.250.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.251.1">RandomlyGeneratedNumbers</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.252.1">in production:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.253.1">
public class DiceRollApp {
    public static void main(String[] args) {
        new DiceRollApp().run();
    }
    private void run() {
        var rnd = new RandomlyGeneratedNumbers();
        var roll = new DiceRoll(rnd);
        System.out.println(roll.asText());
    }
}</span></pre>
<p><span class="koboSpan" id="kobo.254.1">You can see in the previous code that we inject an instance of the production-version </span><strong class="source-inline"><span class="koboSpan" id="kobo.255.1">RandomlyGeneratedNumbers</span></strong><span class="koboSpan" id="kobo.256.1"> class into the </span><strong class="source-inline"><span class="koboSpan" id="kobo.257.1">DiceRoll</span></strong><span class="koboSpan" id="kobo.258.1"> class. </span><span class="koboSpan" id="kobo.258.2">This process</span><a id="_idIndexMarker338"/><span class="koboSpan" id="kobo.259.1"> of creating and injecting objects is often termed </span><strong class="bold"><span class="koboSpan" id="kobo.260.1">object wiring</span></strong><span class="koboSpan" id="kobo.261.1">. </span><span class="koboSpan" id="kobo.261.2">Frameworks</span><a id="_idIndexMarker339"/><span class="koboSpan" id="kobo.262.1"> such as </span><em class="italic"><span class="koboSpan" id="kobo.263.1">Spring </span></em><span class="koboSpan" id="kobo.264.1">(</span><a href="B18384_08.xhtml#_idTextAnchor175"><span class="koboSpan" id="kobo.265.1">https://spring.io/</span></a><span class="koboSpan" id="kobo.266.1">), </span><em class="italic"><span class="koboSpan" id="kobo.267.1">Google Guice </span></em><span class="koboSpan" id="kobo.268.1">(</span><a href="B18384_08.xhtml#_idTextAnchor172"><span class="koboSpan" id="kobo.269.1">https://github.com/google/guice</span></a><span class="koboSpan" id="kobo.270.1">), and the built-in </span><em class="italic"><span class="koboSpan" id="kobo.271.1">Java CDI </span></em><span class="koboSpan" id="kobo.272.1">(</span><a href="B18384_08.xhtml#_idTextAnchor171"><span class="koboSpan" id="kobo.273.1">https://docs.oracle.com/javaee/6/tutorial/doc/giwhl.html</span></a><span class="koboSpan" id="kobo.274.1">) provide ways to minimize the boilerplate of creating dependencies</span><a id="_idIndexMarker340"/><span class="koboSpan" id="kobo.275.1"> and wiring them up, </span><span class="No-Break"><span class="koboSpan" id="kobo.276.1">using annotations.</span></span></p>
<p><span class="koboSpan" id="kobo.277.1">Using DIP to swap a production</span><a id="_idIndexMarker341"/><span class="koboSpan" id="kobo.278.1"> object for a test double is a very powerful technique. </span><span class="koboSpan" id="kobo.278.2">This test double is an example of a kind of double known as a stub. </span><span class="koboSpan" id="kobo.278.3">We’ll cover what a stub is along with when to use one in the </span><span class="No-Break"><span class="koboSpan" id="kobo.279.1">next section.</span></span></p>
<h1 id="_idParaDest-149"><a id="_idTextAnchor158"/><span class="koboSpan" id="kobo.280.1">Using stubs for pre-canned results</span></h1>
<p><span class="koboSpan" id="kobo.281.1">The previous section explained</span><a id="_idIndexMarker342"/><span class="koboSpan" id="kobo.282.1"> that test doubles were a kind of object</span><a id="_idIndexMarker343"/><span class="koboSpan" id="kobo.283.1"> that could stand in for a production object so that we could write a test more easily. </span><span class="koboSpan" id="kobo.283.2">In this section, we will take a closer look at that test double and </span><span class="No-Break"><span class="koboSpan" id="kobo.284.1">generalize it.</span></span></p>
<p><span class="koboSpan" id="kobo.285.1">In the preceding </span><strong class="source-inline"><span class="koboSpan" id="kobo.286.1">DiceRoll</span></strong><span class="koboSpan" id="kobo.287.1"> example, the test was simpler to write because we replaced the random number generation with a known, fixed value. </span><span class="koboSpan" id="kobo.287.2">Our genuine random number generator made it difficult to write an assertion, as we were never sure what the expected random number should be. </span><span class="koboSpan" id="kobo.287.3">Our test double was an object that instead supplied a well-known value. </span><span class="koboSpan" id="kobo.287.4">We can then work out the expected value for our assertion, making our test easy </span><span class="No-Break"><span class="koboSpan" id="kobo.288.1">to write.</span></span></p>
<p><span class="koboSpan" id="kobo.289.1">A test double</span><a id="_idIndexMarker344"/><span class="koboSpan" id="kobo.290.1"> that supplies values like this is called a </span><strong class="bold"><span class="koboSpan" id="kobo.291.1">stub</span></strong><span class="koboSpan" id="kobo.292.1">. </span><span class="koboSpan" id="kobo.292.2">Stubs always replace an object that we cannot control with a test-only version that we can control. </span><span class="koboSpan" id="kobo.292.3">They always produce known data values for our code under test to consume. </span><span class="koboSpan" id="kobo.292.4">Graphically, a stub looks </span><span class="No-Break"><span class="koboSpan" id="kobo.293.1">like this:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer053">
<span class="koboSpan" id="kobo.294.1"><img alt="Figure 8.1 – Replacing a collaborator with a stub" src="image/Figure_8.1_B18384.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.295.1">Figure 8.1 – Replacing a collaborator with a stub</span></p>
<p><span class="koboSpan" id="kobo.296.1">In the diagram, our test class is responsible for wiring up our SUT to an appropriate stub object in the Arrange step. </span><span class="koboSpan" id="kobo.296.2">When the Act step asks our SUT to execute the code we want to test, that code will pull the known data values from the stub. </span><span class="koboSpan" id="kobo.296.3">The Assert step can be written based on the expected behavior that these known data values </span><span class="No-Break"><span class="koboSpan" id="kobo.297.1">will cause.</span></span></p>
<p><span class="koboSpan" id="kobo.298.1">It is important to note why this works. </span><span class="koboSpan" id="kobo.298.2">One objection to this arrangement is that we are not testing the real system. </span><span class="koboSpan" id="kobo.298.3">Our SUT is wired up to some object that will never be part of our production system. </span><span class="koboSpan" id="kobo.298.4">That is true. </span><span class="koboSpan" id="kobo.298.5">But this works because our test is only testing the logic within the SUT. </span><span class="koboSpan" id="kobo.298.6">This test is </span><em class="italic"><span class="koboSpan" id="kobo.299.1">not</span></em><span class="koboSpan" id="kobo.300.1"> testing the behavior of the dependencies themselves. </span><span class="koboSpan" id="kobo.300.2">Indeed, it must not attempt to do that. </span><span class="koboSpan" id="kobo.300.3">Testing the test double is a classic anti-pattern for </span><span class="No-Break"><span class="koboSpan" id="kobo.301.1">unit tests.</span></span></p>
<p><span class="koboSpan" id="kobo.302.1">Our SUT has used</span><a id="_idIndexMarker345"/><span class="koboSpan" id="kobo.303.1"> the Dependency Inversion Principle</span><a id="_idIndexMarker346"/><span class="koboSpan" id="kobo.304.1"> to fully isolate itself from the object the stub is standing in for. </span><span class="koboSpan" id="kobo.304.2">It makes no difference to the SUT how it gets its data from its collaborator. </span><span class="koboSpan" id="kobo.304.3">That’s why this testing approach </span><span class="No-Break"><span class="koboSpan" id="kobo.305.1">is valid.</span></span></p>
<h2 id="_idParaDest-150"><a id="_idTextAnchor159"/><span class="koboSpan" id="kobo.306.1">When to use stub objects</span></h2>
<p><span class="koboSpan" id="kobo.307.1">Stubs are useful whenever</span><a id="_idIndexMarker347"/><span class="koboSpan" id="kobo.308.1"> our SUT uses a </span><em class="italic"><span class="koboSpan" id="kobo.309.1">pull model</span></em><span class="koboSpan" id="kobo.310.1"> of collaborating with a dependency. </span><span class="koboSpan" id="kobo.310.2">Some</span><a id="_idIndexMarker348"/><span class="koboSpan" id="kobo.311.1"> examples of when using stubs makes sense are </span><span class="No-Break"><span class="koboSpan" id="kobo.312.1">as follows:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.313.1">Stubbing a repository interface/database</span></strong><span class="koboSpan" id="kobo.314.1">: Using a stub instead of calling to a real database for data </span><span class="No-Break"><span class="koboSpan" id="kobo.315.1">access code</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.316.1">Stubbing reference data sources</span></strong><span class="koboSpan" id="kobo.317.1">: Replacing properties files or web services containing reference data with </span><span class="No-Break"><span class="koboSpan" id="kobo.318.1">stub data</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.319.1">Providing application objects to code that converts to HTML or JSON formats</span></strong><span class="koboSpan" id="kobo.320.1">: When testing code that converts to HTML or JSON, supply input data with </span><span class="No-Break"><span class="koboSpan" id="kobo.321.1">a stub</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.322.1">Stubbing the system clock to test time-dependent behavior</span></strong><span class="koboSpan" id="kobo.323.1">: To get repeatable behavior out of a time call, stub the call with </span><span class="No-Break"><span class="koboSpan" id="kobo.324.1">known times</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.325.1">Stubbing random number generators to create predictability</span></strong><span class="koboSpan" id="kobo.326.1">: Replace a call to a random number generator with a call to </span><span class="No-Break"><span class="koboSpan" id="kobo.327.1">a stub</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.328.1">Stubbing authentication systems to always allow a test user to log in</span></strong><span class="koboSpan" id="kobo.329.1">: Replace calls to authentication systems with simple “login </span><span class="No-Break"><span class="koboSpan" id="kobo.330.1">succeeded” stubs</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.331.1">Stubbing responses from a third-party web service such as a payment provider</span></strong><span class="koboSpan" id="kobo.332.1">: Replace real calls to third-party services with calls to </span><span class="No-Break"><span class="koboSpan" id="kobo.333.1">a stub</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.334.1">Stubbing a call to an operating system command</span></strong><span class="koboSpan" id="kobo.335.1">: Replace a call to the OS to, for example, list a directory with pre-canned </span><span class="No-Break"><span class="koboSpan" id="kobo.336.1">stub data</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.337.1">In this section, we have seen how using stubs allows us to control data that gets supplied to an SUT. </span><span class="koboSpan" id="kobo.337.2">It</span><a id="_idIndexMarker349"/><span class="koboSpan" id="kobo.338.1"> supports a </span><em class="italic"><span class="koboSpan" id="kobo.339.1">pull model</span></em><span class="koboSpan" id="kobo.340.1"> of fetching objects from elsewhere. </span><span class="koboSpan" id="kobo.340.2">But that’s not the only mechanism by which objects</span><a id="_idIndexMarker350"/><span class="koboSpan" id="kobo.341.1"> can collaborate. </span><span class="koboSpan" id="kobo.341.2">Some objects use a</span><em class="italic"><span class="koboSpan" id="kobo.342.1"> push model</span></em><span class="koboSpan" id="kobo.343.1">. </span><span class="koboSpan" id="kobo.343.2">In this case, when</span><a id="_idIndexMarker351"/><span class="koboSpan" id="kobo.344.1"> we call a method on our SUT, we expect it to call another method on some other object. </span><span class="koboSpan" id="kobo.344.2">Our test must confirm that this method call actually took place. </span><span class="koboSpan" id="kobo.344.3">This is something that stubs cannot help with and needs a different approach. </span><span class="koboSpan" id="kobo.344.4">We will cover this approach in the </span><span class="No-Break"><span class="koboSpan" id="kobo.345.1">next section.</span></span></p>
<h1 id="_idParaDest-151"><a id="_idTextAnchor160"/><span class="koboSpan" id="kobo.346.1">Using mocks to verify interactions</span></h1>
<p><span class="koboSpan" id="kobo.347.1">In this section, we’ll take</span><a id="_idIndexMarker352"/><span class="koboSpan" id="kobo.348.1"> a look at another important kind of test double: the mock object. </span><span class="koboSpan" id="kobo.348.2">Mock objects solve a slightly different problem than stub objects do, as we shall see in </span><span class="No-Break"><span class="koboSpan" id="kobo.349.1">this section.</span></span></p>
<p><strong class="bold"><span class="koboSpan" id="kobo.350.1">Mock objects</span></strong><span class="koboSpan" id="kobo.351.1"> are a kind of test double</span><a id="_idIndexMarker353"/><span class="koboSpan" id="kobo.352.1"> that </span><em class="italic"><span class="koboSpan" id="kobo.353.1">record interactions</span></em><span class="koboSpan" id="kobo.354.1">. </span><span class="koboSpan" id="kobo.354.2">Unlike stubs, which supply well-known objects to the SUT, a mock will simply record interactions that the SUT has with the mock. </span><span class="koboSpan" id="kobo.354.3">It is the perfect tool to answer the question, “</span><em class="italic"><span class="koboSpan" id="kobo.355.1">Did the SUT call the method correctly?</span></em><span class="koboSpan" id="kobo.356.1">” This solves the problem of </span><em class="italic"><span class="koboSpan" id="kobo.357.1">push model</span></em><span class="koboSpan" id="kobo.358.1"> interactions between the SUT and its collaborator. </span><span class="koboSpan" id="kobo.358.2">The SUT commands the collaborator to do something rather than requesting something from it. </span><span class="koboSpan" id="kobo.358.3">A mock provides a way to verify that it issued that command, along with any </span><span class="No-Break"><span class="koboSpan" id="kobo.359.1">necessary parameters.</span></span></p>
<p><span class="koboSpan" id="kobo.360.1">The following UML object diagram shows the </span><span class="No-Break"><span class="koboSpan" id="kobo.361.1">general arrangement:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer054">
<span class="koboSpan" id="kobo.362.1"><img alt="Figure 8.2 – Replace collaborator with mock" src="image/Figure_8.2_B18384.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.363.1">Figure 8.2 – Replace collaborator with mock</span></p>
<p><span class="koboSpan" id="kobo.364.1">We see our test code wiring</span><a id="_idIndexMarker354"/><span class="koboSpan" id="kobo.365.1"> up a mock object to the SUT. </span><span class="koboSpan" id="kobo.365.2">The Act step will make the SUT execute code that we expect to interact with its collaborator. </span><span class="koboSpan" id="kobo.365.3">We have swapped out that collaborator for a mock, which will record the fact that a certain method was called </span><span class="No-Break"><span class="koboSpan" id="kobo.366.1">on it.</span></span></p>
<p><span class="koboSpan" id="kobo.367.1">Let’s look at a concrete example to make this easier to understand. </span><span class="koboSpan" id="kobo.367.2">Suppose our SUT is expected to send an email to a user. </span><span class="koboSpan" id="kobo.367.3">Once again, we will use the Dependency Inversion Principle to create an abstraction of our mail server as </span><span class="No-Break"><span class="koboSpan" id="kobo.368.1">an interface:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.369.1">
public interface MailServer {
    void sendEmail(String recipient, String subject,
                   String text);
}</span></pre>
<p><span class="koboSpan" id="kobo.370.1">The preceding code shows a simplified interface only suitable for sending a short text email. </span><span class="koboSpan" id="kobo.370.2">It is good enough for our purposes. </span><span class="koboSpan" id="kobo.370.3">To test the SUT that called the </span><strong class="source-inline"><span class="koboSpan" id="kobo.371.1">sendEmail()</span></strong><span class="koboSpan" id="kobo.372.1"> method on this interface, we would write a </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.373.1">MockMailServer</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.374.1"> class:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.375.1">
public class MockMailServer implements MailServer {
    boolean wasCalled;
    String actualRecipient;
    String actualSubject;
    String actualText;
    @Override
    public void sendEmail(String recipient, String subject,
                          String text) {
        wasCalled = true;
        actualRecipient = recipient;
        actualSubject = subject;
        actualText = text;
    }
}</span></pre>
<p><span class="koboSpan" id="kobo.376.1">The preceding </span><strong class="source-inline"><span class="koboSpan" id="kobo.377.1">MockMailServer</span></strong><span class="koboSpan" id="kobo.378.1"> class implements the </span><strong class="source-inline"><span class="koboSpan" id="kobo.379.1">MailServer</span></strong><span class="koboSpan" id="kobo.380.1"> interface. </span><span class="koboSpan" id="kobo.380.2">It has a single responsibility – to record the fact that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.381.1">sendEmail()</span></strong><span class="koboSpan" id="kobo.382.1"> method was called and to capture</span><a id="_idIndexMarker355"/><span class="koboSpan" id="kobo.383.1"> the actual parameter values sent to that method. </span><span class="koboSpan" id="kobo.383.2">It exposes these as simple fields with package-public visibility. </span><span class="koboSpan" id="kobo.383.3">Our test code can use these fields to form the assertion. </span><span class="koboSpan" id="kobo.383.4">Our test simply has to wire up this mock object to the SUT, cause the SUT to execute code that we expect to call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.384.1">sendEmail()</span></strong><span class="koboSpan" id="kobo.385.1"> method, and then check that it did </span><span class="No-Break"><span class="koboSpan" id="kobo.386.1">do that:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.387.1">
@Test
public void sendsWelcomeEmail() {
    var mailServer = new MockMailServer();
    var notifications = new UserNotifications(mailServer);
    notifications.welcomeNewUser();
    assertThat(mailServer.wasCalled).isTrue();
    assertThat(mailServer.actualRecipient)
         .isEqualTo("test@example.com");
    assertThat(mailServer.actualSubject)
         .isEqualTo("Welcome!");
    assertThat(mailServer.actualText)
         .contains("Welcome to your account");
}</span></pre>
<p><span class="koboSpan" id="kobo.388.1">We can see that this test wires up the mock to our SUT, then causes the SUT to execute the </span><strong class="source-inline"><span class="koboSpan" id="kobo.389.1">welcomeNewUser()</span></strong><span class="koboSpan" id="kobo.390.1"> method. </span><span class="koboSpan" id="kobo.390.2">We expect this method to call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.391.1">sendEmail()</span></strong><span class="koboSpan" id="kobo.392.1"> method on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.393.1">MailServer</span></strong><span class="koboSpan" id="kobo.394.1"> object. </span><span class="koboSpan" id="kobo.394.2">Then, we need to write assertions to confirm that call was made with the correct parameter values passed. </span><span class="koboSpan" id="kobo.394.3">We’re using the idea of four assert statements logically here and testing one idea – effectively a </span><span class="No-Break"><span class="koboSpan" id="kobo.395.1">single assert.</span></span></p>
<p><span class="koboSpan" id="kobo.396.1">The power of mock objects is that we can </span><em class="italic"><span class="koboSpan" id="kobo.397.1">record interactions</span></em><span class="koboSpan" id="kobo.398.1"> with objects that are difficult to control. </span><span class="koboSpan" id="kobo.398.2">In the case of a mail server, such as the one seen in the preceding code block, we would not want to be sending actual emails to anybody. </span><span class="koboSpan" id="kobo.398.3">We also would not want to write a test that waited around monitoring the mailbox of a test user. </span><span class="koboSpan" id="kobo.398.4">Not only is this slow and can be unreliable, but it is also not what we intend to test. </span><span class="koboSpan" id="kobo.398.5">The SUT only has the responsibility of making the call to </span><strong class="source-inline"><span class="koboSpan" id="kobo.399.1">sendEmail()</span></strong><span class="koboSpan" id="kobo.400.1"> – what happens after that is out of the scope of the SUT. </span><span class="koboSpan" id="kobo.400.2">It is, therefore, out of scope for </span><span class="No-Break"><span class="koboSpan" id="kobo.401.1">this test.</span></span></p>
<p><span class="koboSpan" id="kobo.402.1">As in the previous examples with other test doubles, the fact</span><a id="_idIndexMarker356"/><span class="koboSpan" id="kobo.403.1"> that we have used the </span><strong class="bold"><span class="koboSpan" id="kobo.404.1">Dependency Inversion Principle</span></strong><span class="koboSpan" id="kobo.405.1"> means our production code is easy enough to create. </span><span class="koboSpan" id="kobo.405.2">We simply need to create an implementation of </span><strong class="source-inline"><span class="koboSpan" id="kobo.406.1">MailServer</span></strong><span class="koboSpan" id="kobo.407.1"> that uses the SMTP protocol to talk to a real mail server. </span><span class="koboSpan" id="kobo.407.2">We would most likely search for a library class that does that for us already, then we would need to make a very simple adapter object that binds that library code to </span><span class="No-Break"><span class="koboSpan" id="kobo.408.1">our interface.</span></span></p>
<p><span class="koboSpan" id="kobo.409.1">This section has covered </span><a id="_idIndexMarker357"/><span class="koboSpan" id="kobo.410.1">two common kinds of test double, stubs, and mocks. </span><span class="koboSpan" id="kobo.410.2">But test doubles are not always appropriate to use. </span><span class="koboSpan" id="kobo.410.3">In the next section, we’ll discuss some issues to be aware of when using </span><span class="No-Break"><span class="koboSpan" id="kobo.411.1">test doubles.</span></span></p>
<h1 id="_idParaDest-152"><a id="_idTextAnchor161"/><span class="koboSpan" id="kobo.412.1">Understanding when test doubles are appropriate</span></h1>
<p><span class="koboSpan" id="kobo.413.1">Mock objects are a useful kind</span><a id="_idIndexMarker358"/><span class="koboSpan" id="kobo.414.1"> of test double, as we have seen. </span><span class="koboSpan" id="kobo.414.2">But they are not always the right approach. </span><span class="koboSpan" id="kobo.414.3">There are some situations where we should actively avoid using mocks. </span><span class="koboSpan" id="kobo.414.4">These situations include over-using mocks, using mocks for code you don’t own, and mocking value objects. </span><span class="koboSpan" id="kobo.414.5">We’ll look at these situations next. </span><span class="koboSpan" id="kobo.414.6">Then, we’ll recap with general advice for where mocks are typically useful. </span><span class="koboSpan" id="kobo.414.7">Let’s start by considering the problems caused when we overuse </span><span class="No-Break"><span class="koboSpan" id="kobo.415.1">mock objects.</span></span></p>
<h2 id="_idParaDest-153"><a id="_idTextAnchor162"/><span class="koboSpan" id="kobo.416.1">Avoiding the overuse of mock objects</span></h2>
<p><span class="koboSpan" id="kobo.417.1">At a first glance, using mock objects</span><a id="_idIndexMarker359"/><span class="koboSpan" id="kobo.418.1"> seems to solve a number of problems for us. </span><span class="koboSpan" id="kobo.418.2">Yet if used without care, we can end up with very poor-quality tests. </span><span class="koboSpan" id="kobo.418.3">To understand why, let’s go back to our basic definition of a TDD test. </span><span class="koboSpan" id="kobo.418.4">It is a test that verifies </span><em class="italic"><span class="koboSpan" id="kobo.419.1">behaviors</span></em><span class="koboSpan" id="kobo.420.1"> and is independent of </span><em class="italic"><span class="koboSpan" id="kobo.421.1">implementations</span></em><span class="koboSpan" id="kobo.422.1">. </span><span class="koboSpan" id="kobo.422.2">If we use a mock object to stand in for a genuine abstraction, then we are complying </span><span class="No-Break"><span class="koboSpan" id="kobo.423.1">with that.</span></span></p>
<p><span class="koboSpan" id="kobo.424.1">The potential problem happens because it is all too easy to create a mock object for an implementation detail, not an abstraction. </span><span class="koboSpan" id="kobo.424.2">If we do this, we end up locking our code into a specific implementation and structure. </span><span class="koboSpan" id="kobo.424.3">Once a test is coupled to a specific implementation detail, then changing that implementation requires a change to the test. </span><span class="koboSpan" id="kobo.424.4">If the new implementation has the same outcomes as the old one, the test really should still pass. </span><span class="koboSpan" id="kobo.424.5">Tests that depend on specific implementation details or code structures actively impede refactoring and adding </span><span class="No-Break"><span class="koboSpan" id="kobo.425.1">new features.</span></span></p>
<h2 id="_idParaDest-154"><a id="_idTextAnchor163"/><span class="koboSpan" id="kobo.426.1">Don’t mock code you don’t own</span></h2>
<p><span class="koboSpan" id="kobo.427.1">Another area where mocks should</span><a id="_idIndexMarker360"/><span class="koboSpan" id="kobo.428.1"> not be used is as a stand-in for a concrete class written outside of your team. </span><span class="koboSpan" id="kobo.428.2">Suppose we are using a class called </span><strong class="source-inline"><span class="koboSpan" id="kobo.429.1">PdfGenerator</span></strong><span class="koboSpan" id="kobo.430.1"> from a library to create a PDF document. </span><span class="koboSpan" id="kobo.430.2">Our code would call methods on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.431.1">PdfGenerator</span></strong><span class="koboSpan" id="kobo.432.1"> class. </span><span class="koboSpan" id="kobo.432.2">We might think it would be easy to test our code if we use a mock object to stand in for the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.433.1">PdfGenerator</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.434.1"> class.</span></span></p>
<p><span class="koboSpan" id="kobo.435.1">This approach has a problem that will only arise in the future. </span><span class="koboSpan" id="kobo.435.2">The class in the external library will quite likely change. </span><span class="koboSpan" id="kobo.435.3">Let’s say that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.436.1">PdfGenerator</span></strong><span class="koboSpan" id="kobo.437.1"> class removes one of the methods our code is calling. </span><span class="koboSpan" id="kobo.437.2">We will be forced to update the library version at some point as part of our security policy if nothing else. </span><span class="koboSpan" id="kobo.437.3">When we pull in the new version, our code will no longer compile against this changed class – </span><em class="italic"><span class="koboSpan" id="kobo.438.1">but our tests will still pass because the mock object still has the old method in it</span></em><span class="koboSpan" id="kobo.439.1">. </span><span class="koboSpan" id="kobo.439.2">This is a subtle trap that we have laid for future maintainers of the code. </span><span class="koboSpan" id="kobo.439.3">It is best avoided. </span><span class="koboSpan" id="kobo.439.4">A reasonable approach is to wrap the third-party library, and ideally</span><a id="_idIndexMarker361"/><span class="koboSpan" id="kobo.440.1"> place it behind an interface to invert the dependency on it, isolating </span><span class="No-Break"><span class="koboSpan" id="kobo.441.1">it fully.</span></span></p>
<h2 id="_idParaDest-155"><a id="_idTextAnchor164"/><span class="koboSpan" id="kobo.442.1">Don’t mock value objects</span></h2>
<p><span class="koboSpan" id="kobo.443.1">A </span><strong class="bold"><span class="koboSpan" id="kobo.444.1">value object</span></strong><span class="koboSpan" id="kobo.445.1"> is an object that has no specific </span><a id="_idIndexMarker362"/><span class="koboSpan" id="kobo.446.1">identity, it is defined</span><a id="_idIndexMarker363"/><span class="koboSpan" id="kobo.447.1"> only by the data it contains. </span><span class="koboSpan" id="kobo.447.2">Some examples would include an integer or a string object. </span><span class="koboSpan" id="kobo.447.3">We consider two strings to be the same if they contain the same text. </span><span class="koboSpan" id="kobo.447.4">They might be two separate string objects in memory, but if they hold the same value, we consider them to </span><span class="No-Break"><span class="koboSpan" id="kobo.448.1">be equal.</span></span></p>
<p><span class="koboSpan" id="kobo.449.1">The clue that something is a value object in Java is the presence of a customized </span><strong class="source-inline"><span class="koboSpan" id="kobo.450.1">equals()</span></strong><span class="koboSpan" id="kobo.451.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.452.1">hashCode()</span></strong><span class="koboSpan" id="kobo.453.1"> method. </span><span class="koboSpan" id="kobo.453.2">By default, Java compares the equality of two objects using their identity – it checks that two object references are referring to the same object instance in memory. </span><span class="koboSpan" id="kobo.453.3">We must override the </span><strong class="source-inline"><span class="koboSpan" id="kobo.454.1">equals()</span></strong><span class="koboSpan" id="kobo.455.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.456.1">hashCode()</span></strong><span class="koboSpan" id="kobo.457.1"> methods to provide the correct behavior for value objects, based on </span><span class="No-Break"><span class="koboSpan" id="kobo.458.1">their content.</span></span></p>
<p><span class="koboSpan" id="kobo.459.1">A value object is a simple thing. </span><span class="koboSpan" id="kobo.459.2">It may have some complex behaviors inside its methods but, in principle, value objects should be easy to create. </span><span class="koboSpan" id="kobo.459.3">There is no benefit in creating a mock object to stand in for one of these value objects. </span><span class="koboSpan" id="kobo.459.4">Instead, create the value object and use it in </span><span class="No-Break"><span class="koboSpan" id="kobo.460.1">your test.</span></span></p>
<h2 id="_idParaDest-156"><a id="_idTextAnchor165"/><span class="koboSpan" id="kobo.461.1">You can’t mock without dependency injection</span></h2>
<p><span class="koboSpan" id="kobo.462.1">Test doubles can only be used where</span><a id="_idIndexMarker364"/><span class="koboSpan" id="kobo.463.1"> we can inject them. </span><span class="koboSpan" id="kobo.463.2">This is not always possible. </span><span class="koboSpan" id="kobo.463.3">If the code we want to test creates a concrete class using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.464.1">new</span></strong><span class="koboSpan" id="kobo.465.1"> keyword, then we cannot replace it with </span><span class="No-Break"><span class="koboSpan" id="kobo.466.1">a double:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.467.1">
package examples;
public class UserGreeting {
    private final UserProfiles profiles
        = new UserProfilesPostgres();
    public String formatGreeting(UserId id) {
        return String.format("Hello and welcome, %s",
                profiles.fetchNicknameFor(id));
    }
}</span></pre>
<p><span class="koboSpan" id="kobo.468.1">We see that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.469.1">profiles</span></strong><span class="koboSpan" id="kobo.470.1"> field has been initialized using a concrete class </span><strong class="source-inline"><span class="koboSpan" id="kobo.471.1">UserProfilesPostgres()</span></strong><span class="koboSpan" id="kobo.472.1">. </span><span class="koboSpan" id="kobo.472.2">There is no direct way to inject a test double with this design. </span><span class="koboSpan" id="kobo.472.3">We could attempt to get around this, using Java Reflection, but it is best to consider this as TDD feedback on a limitation of our design. </span><span class="koboSpan" id="kobo.472.4">The solution is to allow the dependency to be injected, as we have seen in </span><span class="No-Break"><span class="koboSpan" id="kobo.473.1">previous examples.</span></span></p>
<p><span class="koboSpan" id="kobo.474.1">This is often a problem with </span><strong class="bold"><span class="koboSpan" id="kobo.475.1">legacy code</span></strong><span class="koboSpan" id="kobo.476.1">, which is simply code that has been</span><a id="_idIndexMarker365"/><span class="koboSpan" id="kobo.477.1"> written before we work on it. </span><span class="koboSpan" id="kobo.477.2">If this code</span><a id="_idIndexMarker366"/><span class="koboSpan" id="kobo.478.1"> has created concrete objects – and the code cannot be changed – then we cannot apply a </span><span class="No-Break"><span class="koboSpan" id="kobo.479.1">test double.</span></span></p>
<h2 id="_idParaDest-157"><a id="_idTextAnchor166"/><span class="koboSpan" id="kobo.480.1">Don’t test the mock</span></h2>
<p><em class="italic"><span class="koboSpan" id="kobo.481.1">Testing the mock</span></em><span class="koboSpan" id="kobo.482.1"> is a phrase used to describe</span><a id="_idIndexMarker367"/><span class="koboSpan" id="kobo.483.1"> a test with too many assumptions built into a test double. </span><span class="koboSpan" id="kobo.483.2">Suppose we write a stub that stands in for some database access, but that stub contains hundreds of lines of code to emulate detailed specific queries to that database. </span><span class="koboSpan" id="kobo.483.3">When we write the test assertions, they will all be based on those detailed queries that we emulated in </span><span class="No-Break"><span class="koboSpan" id="kobo.484.1">the stub.</span></span></p>
<p><span class="koboSpan" id="kobo.485.1">That approach will prove that the SUT logic responds to those queries. </span><span class="koboSpan" id="kobo.485.2">But our stub now assumes a great deal about how the real data access code will work. </span><span class="koboSpan" id="kobo.485.3">The stub code and the real data access code can quickly get out of step. </span><span class="koboSpan" id="kobo.485.4">This results in an invalid unit test that passes but with stubbed responses that can no longer happen </span><span class="No-Break"><span class="koboSpan" id="kobo.486.1">in reality.</span></span></p>
<h2 id="_idParaDest-158"><a id="_idTextAnchor167"/><span class="koboSpan" id="kobo.487.1">When to use mock objects</span></h2>
<p><span class="koboSpan" id="kobo.488.1">Mocks are useful whenever</span><a id="_idIndexMarker368"/><span class="koboSpan" id="kobo.489.1"> our SUT is using a push model and requesting an action from some other component, where there is no obvious response such as </span><span class="No-Break"><span class="koboSpan" id="kobo.490.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.491.1">Requesting an action from a remote service, such as sending an email to a </span><span class="No-Break"><span class="koboSpan" id="kobo.492.1">mail server</span></span></li>
<li><span class="koboSpan" id="kobo.493.1">Inserting or deleting data from </span><span class="No-Break"><span class="koboSpan" id="kobo.494.1">a database</span></span></li>
<li><span class="koboSpan" id="kobo.495.1">Sending a command over a TCP socket or </span><span class="No-Break"><span class="koboSpan" id="kobo.496.1">serial interface</span></span></li>
<li><span class="koboSpan" id="kobo.497.1">Invalidating </span><span class="No-Break"><span class="koboSpan" id="kobo.498.1">a cache</span></span></li>
<li><span class="koboSpan" id="kobo.499.1">Writing logging information either to a log file or distributing </span><span class="No-Break"><span class="koboSpan" id="kobo.500.1">logging endpoint</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.501.1">We’ve learned some techniques</span><a id="_idIndexMarker369"/><span class="koboSpan" id="kobo.502.1"> in this section that allow us to verify that an action was requested. </span><span class="koboSpan" id="kobo.502.2">We have seen how we can use the Dependency Inversion Principle once again to allow us to inject a test double which we can query. </span><span class="koboSpan" id="kobo.502.3">We’ve also seen an example of hand-written code to do this. </span><span class="koboSpan" id="kobo.502.4">But must we always write test doubles by hand? </span><span class="koboSpan" id="kobo.502.5">In the next section, we will cover a very useful library that does most of the work </span><span class="No-Break"><span class="koboSpan" id="kobo.503.1">for us.</span></span></p>
<h1 id="_idParaDest-159"><a id="_idTextAnchor168"/><span class="koboSpan" id="kobo.504.1">Working with Mockito – a popular mocking library</span></h1>
<p><span class="koboSpan" id="kobo.505.1">The previous sections</span><a id="_idIndexMarker370"/><span class="koboSpan" id="kobo.506.1"> have shown examples of using stubs and mocks to test code. </span><span class="koboSpan" id="kobo.506.2">We have been writing these test doubles by hand. </span><span class="koboSpan" id="kobo.506.3">It’s obviously quite repetitive and time-consuming to do this. </span><span class="koboSpan" id="kobo.506.4">It begs the question of if this repetitive boilerplate code can be automated away. </span><span class="koboSpan" id="kobo.506.5">Thankfully for us, it can. </span><span class="koboSpan" id="kobo.506.6">This section will review the help available in the popular </span><span class="No-Break"><span class="koboSpan" id="kobo.507.1">Mockito library.</span></span></p>
<p><span class="koboSpan" id="kobo.508.1">Mockito is a free-of-charge open source library under the MIT license. </span><span class="koboSpan" id="kobo.508.2">This license means we can use this for commercial development work, subject to agreement by those we work for. </span><span class="koboSpan" id="kobo.508.3">Mockito provides a large range of features aimed at creating test doubles with very little code. </span><span class="koboSpan" id="kobo.508.4">The Mockito</span><a id="_idIndexMarker371"/><span class="koboSpan" id="kobo.509.1"> website can be found </span><span class="No-Break"><span class="koboSpan" id="kobo.510.1">at </span></span><a href="B18384_08.xhtml#_idTextAnchor174"><span class="No-Break"><span class="koboSpan" id="kobo.511.1">https://site.mockito.org/</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.512.1">.</span></span></p>
<h2 id="_idParaDest-160"><a id="_idTextAnchor169"/><span class="koboSpan" id="kobo.513.1">Getting started with Mockito</span></h2>
<p><span class="koboSpan" id="kobo.514.1">Getting started</span><a id="_idIndexMarker372"/><span class="koboSpan" id="kobo.515.1"> with Mockito is straightforward. </span><span class="koboSpan" id="kobo.515.2">We pull in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.516.1">Mockito</span></strong><span class="koboSpan" id="kobo.517.1"> library and an extension library in our Gradle file. </span><span class="koboSpan" id="kobo.517.2">The extension library allows </span><strong class="source-inline"><span class="koboSpan" id="kobo.518.1">Mockito</span></strong><span class="koboSpan" id="kobo.519.1"> to integrate closely </span><span class="No-Break"><span class="koboSpan" id="kobo.520.1">with </span></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.521.1">JUnit5</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.522.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.523.1">The excerpt of </span><strong class="source-inline"><span class="koboSpan" id="kobo.524.1">build.gradle</span></strong><span class="koboSpan" id="kobo.525.1"> looks </span><span class="No-Break"><span class="koboSpan" id="kobo.526.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.527.1">
dependencies {
    testImplementation 'org.junit.jupiter:junit-jupiter-api:5.8.2'
    testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine:5.8.2'
    testImplementation 'org.assertj:assertj-core:3.22.0'
</span><strong class="bold"><span class="koboSpan" id="kobo.528.1">    testImplementation 'org.mockito:mockito-core:4.8.0'</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.529.1">    testImplementation 'org.mockito:mockito-junit-jupiter:4.8.0'</span></strong><span class="koboSpan" id="kobo.530.1">
}</span></pre>
<h2 id="_idParaDest-161"><a id="_idTextAnchor170"/><span class="koboSpan" id="kobo.531.1">Writing a stub with Mockito</span></h2>
<p><span class="koboSpan" id="kobo.532.1">Let’s see how Mockito</span><a id="_idIndexMarker373"/><span class="koboSpan" id="kobo.533.1"> helps us create a stub</span><a id="_idIndexMarker374"/><span class="koboSpan" id="kobo.534.1"> object. </span><span class="koboSpan" id="kobo.534.2">We’ll use TDD to create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.535.1">UserGreeting</span></strong><span class="koboSpan" id="kobo.536.1"> class that delivers a personalized greeting, after fetching our nickname from </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.537.1">interface UserProfiles</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.538.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.539.1">Let’s write this using small steps, to see how TDD and Mockito </span><span class="No-Break"><span class="koboSpan" id="kobo.540.1">work together:</span></span></p>
<ol>
<li value="1"><span class="koboSpan" id="kobo.541.1">Write the basic JUnit5 test class and integrate it </span><span class="No-Break"><span class="koboSpan" id="kobo.542.1">with Mockito:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.543.1">
package examples</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.544.1">
import org.junit.jupiter.api.extension.ExtendWith;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.545.1">
import org.mockito.junit.jupiter.MockitoExtension;</span></pre><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.546.1">@ExtendWith(MockitoExtension.class)</span></strong></pre><pre class="source-code"><span class="koboSpan" id="kobo.547.1">
public class UserGreetingTest {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.548.1">
}</span></pre></li>
</ol>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.549.1">@ExtendWith(MockitoExtension.class)</span></strong><span class="koboSpan" id="kobo.550.1"> marks this test as using Mockito. </span><span class="koboSpan" id="kobo.550.2">When we run this JUnit5 test, the annotation ensures that the Mockito library code </span><span class="No-Break"><span class="koboSpan" id="kobo.551.1">is run.</span></span></p>
<ol>
<li value="2"><span class="koboSpan" id="kobo.552.1">Add a test confirming</span><a id="_idIndexMarker375"/><span class="koboSpan" id="kobo.553.1"> the expected behavior. </span><span class="koboSpan" id="kobo.553.2">We will capture</span><a id="_idIndexMarker376"/><span class="koboSpan" id="kobo.554.1"> this in </span><span class="No-Break"><span class="koboSpan" id="kobo.555.1">an assertion:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.556.1">
package examples;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.557.1">
import org.junit.jupiter.api.Test;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.558.1">
import org.junit.jupiter.api.extension.ExtendWith;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.559.1">
import org.mockito.junit.jupiter.MockitoExtension;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.560.1">
import static org.assertj.core.api.Assertions.assertThat;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.561.1">
@ExtendWith(MockitoExtension.class)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.562.1">
public class UserGreetingTest {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.563.1">
    @Test</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.564.1">
    void formatsGreetingWithName() {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.565.1">
        </span><strong class="bold"><span class="koboSpan" id="kobo.566.1">String actual = «»;</span></strong></pre><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.567.1">        assertThat(actual)</span></strong></pre><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.568.1">           .isEqualTo("Hello and welcome, Alan");</span></strong></pre><pre class="source-code"><span class="koboSpan" id="kobo.569.1">
    }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.570.1">
}</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.571.1">This is standard usage</span><a id="_idIndexMarker377"/><span class="koboSpan" id="kobo.572.1"> of the </span><em class="italic"><span class="koboSpan" id="kobo.573.1">JUnit</span></em><span class="koboSpan" id="kobo.574.1"> and </span><em class="italic"><span class="koboSpan" id="kobo.575.1">AssertJ</span></em><span class="koboSpan" id="kobo.576.1"> frameworks as we have</span><a id="_idIndexMarker378"/><span class="koboSpan" id="kobo.577.1"> seen before. </span><span class="koboSpan" id="kobo.577.2">If we run the test now, it </span><span class="No-Break"><span class="koboSpan" id="kobo.578.1">will fail.</span></span></p>
<ol>
<li value="3"><span class="koboSpan" id="kobo.579.1">Drive out our SUT – the class we want to write – with an </span><span class="No-Break"><span class="koboSpan" id="kobo.580.1">Act step:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.581.1">
package examples;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.582.1">
import org.junit.jupiter.api.Test;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.583.1">
import org.junit.jupiter.api.extension.ExtendWith;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.584.1">
import org.mockito.junit.jupiter.MockitoExtension;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.585.1">
import static org.assertj.core.api.Assertions.assertThat;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.586.1">
@ExtendWith(MockitoExtension.class)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.587.1">
public class UserGreetingTest {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.588.1">
    </span><strong class="bold"><span class="koboSpan" id="kobo.589.1">private static final UserId USER_ID</span></strong></pre><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.590.1">        = new UserId("1234");</span></strong></pre><pre class="source-code"><span class="koboSpan" id="kobo.591.1">
    @Test</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.592.1">
    void formatsGreetingWithName() {</span></pre><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.593.1">        var greeting = new UserGreeting();</span></strong></pre><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.594.1">        String actual =</span></strong></pre><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.595.1">            greeting.formatGreeting(USER_ID);</span></strong></pre><pre class="source-code"><span class="koboSpan" id="kobo.596.1">
        assertThat(actual)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.597.1">
            .isEqualTo("Hello and welcome, Alan");</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.598.1">
    }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.599.1">
}</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.600.1">This step drives out the two new production code classes, as shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.601.1">following steps.</span></span></p>
<ol>
<li value="4"><span class="koboSpan" id="kobo.602.1">Add a </span><strong class="source-inline"><span class="koboSpan" id="kobo.603.1">class </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.604.1">UserGreeting</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.605.1"> skeleton:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.606.1">
package examples;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.607.1">
public class UserGreeting {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.608.1">
    public String formatGreeting(UserId id) {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.609.1">
        throw new UnsupportedOperationException();</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.610.1">
    }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.611.1">
}</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.612.1">As usual, we add</span><a id="_idIndexMarker379"/><span class="koboSpan" id="kobo.613.1"> no code beyond what is required to make our test</span><a id="_idIndexMarker380"/><span class="koboSpan" id="kobo.614.1"> compile. </span><span class="koboSpan" id="kobo.614.2">The design decision captured here shows that our behavior is provided by a </span><strong class="source-inline"><span class="koboSpan" id="kobo.615.1">formatGreeting()</span></strong><span class="koboSpan" id="kobo.616.1">method, which identifies a user by a </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.617.1">UserId</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.618.1"> class.</span></span></p>
<ol>
<li value="5"><span class="koboSpan" id="kobo.619.1">Add a </span><strong class="source-inline"><span class="koboSpan" id="kobo.620.1">class </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.621.1">UserId</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.622.1"> skeleton:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.623.1">
package examples;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.624.1">
public class UserId {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.625.1">
    public UserId(String id) {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.626.1">
    }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.627.1">
}</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.628.1">Again, we get an empty shell just to get the test to compile. </span><span class="koboSpan" id="kobo.628.2">Then, we run the test and it </span><span class="No-Break"><span class="koboSpan" id="kobo.629.1">still fails:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer055">
<span class="koboSpan" id="kobo.630.1"><img alt="Figure 8.3 – Test failure" src="image/Figure_8.3_B18384.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.631.1">Figure 8.3 – Test failure</span></p>
<ol>
<li value="6"><span class="koboSpan" id="kobo.632.1">Another design decision</span><a id="_idIndexMarker381"/><span class="koboSpan" id="kobo.633.1"> to capture is that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.634.1">UserGreeting</span></strong><span class="koboSpan" id="kobo.635.1"> class will depend</span><a id="_idIndexMarker382"/><span class="koboSpan" id="kobo.636.1"> on a </span><strong class="source-inline"><span class="koboSpan" id="kobo.637.1">UserProfiles</span></strong><span class="koboSpan" id="kobo.638.1"> interface. </span><span class="koboSpan" id="kobo.638.2">We need to create a field, create the interface skeleton, and inject the field in a new constructor for </span><span class="No-Break"><span class="koboSpan" id="kobo.639.1">the SUT:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.640.1">
package examples;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.641.1">
import org.junit.jupiter.api.Test;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.642.1">
import org.junit.jupiter.api.extension.ExtendWith;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.643.1">
import org.mockito.junit.jupiter.MockitoExtension;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.644.1">
import static org.assertj.core.api.Assertions.assertThat;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.645.1">
@ExtendWith(MockitoExtension.class)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.646.1">
public class UserGreetingTest {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.647.1">
    private static final UserId USER_ID</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.648.1">
        = new UserId("1234");</span></pre><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.649.1">    private UserProfiles profiles;</span></strong></pre><pre class="source-code"><span class="koboSpan" id="kobo.650.1">
    @Test</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.651.1">
    void formatsGreetingWithName() {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.652.1">
        var greeting</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.653.1">
            = </span><strong class="bold"><span class="koboSpan" id="kobo.654.1">new UserGreeting(profiles);</span></strong></pre><pre class="source-code"><span class="koboSpan" id="kobo.655.1">
        String actual =</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.656.1">
            greeting.formatGreeting(USER_ID);</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.657.1">
        assertThat(actual)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.658.1">
            .isEqualTo("Hello and welcome, Alan");</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.659.1">
    }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.660.1">
}</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.661.1">We continue by adding</span><a id="_idIndexMarker383"/><span class="koboSpan" id="kobo.662.1"> the bare minimum code to get the test</span><a id="_idIndexMarker384"/><span class="koboSpan" id="kobo.663.1"> to compile. </span><span class="koboSpan" id="kobo.663.2">If we run the test, it will still fail. </span><span class="koboSpan" id="kobo.663.3">But we’ve progressed further so the failure is now an  </span><strong class="source-inline"><span class="koboSpan" id="kobo.664.1">UnsupportedOperationException</span></strong><span class="koboSpan" id="kobo.665.1"> error. </span><span class="koboSpan" id="kobo.665.2">This confirms that </span><strong class="source-inline"><span class="koboSpan" id="kobo.666.1">formatGreeting()</span></strong><span class="koboSpan" id="kobo.667.1"> has </span><span class="No-Break"><span class="koboSpan" id="kobo.668.1">been called:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer056">
<span class="koboSpan" id="kobo.669.1"><img alt="Figure 8.4 – Failure confirms method call" src="image/Figure_8.4_B18384.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.670.1">Figure 8.4 – Failure confirms method call</span></p>
<ol>
<li value="7"><span class="koboSpan" id="kobo.671.1">Add behavior to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.672.1">formatGreeting()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.673.1"> method:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.674.1">
package examples;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.675.1">
public class UserGreeting {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.676.1">
    private final UserProfiles profiles;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.677.1">
    public UserGreeting(UserProfiles profiles) {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.678.1">
        this.profiles = profiles;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.679.1">
    }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.680.1">
    public String formatGreeting(UserId id) {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.681.1">
        </span><strong class="bold"><span class="koboSpan" id="kobo.682.1">return String.format("Hello and Welcome, %s",</span></strong></pre><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.683.1">                profiles.fetchNicknameFor(id));</span></strong></pre><pre class="source-code"><span class="koboSpan" id="kobo.684.1">
    }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.685.1">
}</span></pre></li>
<li><span class="koboSpan" id="kobo.686.1">Add </span><strong class="source-inline"><span class="koboSpan" id="kobo.687.1">fetchNicknameFor()</span></strong><span class="koboSpan" id="kobo.688.1"> to</span><a id="_idIndexMarker385"/><span class="koboSpan" id="kobo.689.1"> the</span><a id="_idIndexMarker386"/> <span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.690.1">UserProfiles</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.691.1"> interface:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.692.1">
package examples;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.693.1">
public interface UserProfiles {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.694.1">
    String fetchNicknameFor(UserId id);</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.695.1">
}</span></pre></li>
<li><span class="koboSpan" id="kobo.696.1">Run the test. </span><span class="koboSpan" id="kobo.696.2">It will fail with a </span><span class="No-Break"><span class="koboSpan" id="kobo.697.1">null exception:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer057">
<span class="koboSpan" id="kobo.698.1"><img alt="Figure 8.5 – Null exception failure" src="image/Figure_8.5_B18384.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.699.1">Figure 8.5 – Null exception failure</span></p>
<p><span class="koboSpan" id="kobo.700.1">The test fails because</span><a id="_idIndexMarker387"/><span class="koboSpan" id="kobo.701.1"> we passed the </span><strong class="source-inline"><span class="koboSpan" id="kobo.702.1">profiles</span></strong><span class="koboSpan" id="kobo.703.1"> field as a dependency</span><a id="_idIndexMarker388"/><span class="koboSpan" id="kobo.704.1"> into our SUT, but that field has never been initialized. </span><span class="koboSpan" id="kobo.704.2">This is where Mockito comes into </span><span class="No-Break"><span class="koboSpan" id="kobo.705.1">play (finally).</span></span></p>
<ol>
<li value="10"><span class="koboSpan" id="kobo.706.1">Add the </span><strong class="source-inline"><span class="koboSpan" id="kobo.707.1">@Mock</span></strong><span class="koboSpan" id="kobo.708.1"> annotation to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.709.1">profiles</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.710.1"> field:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.711.1">
package examples;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.712.1">
import org.junit.jupiter.api.Test;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.713.1">
import org.junit.jupiter.api.extension.ExtendWith;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.714.1">
import org.mockito.Mock;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.715.1">
import org.mockito.junit.jupiter.MockitoExtension;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.716.1">
import static org.assertj.core.api.Assertions.assertThat;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.717.1">
@ExtendWith(MockitoExtension.class)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.718.1">
public class UserGreetingTest {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.719.1">
    private static final UserId USER_ID = new     UserId("1234");</span></pre><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.720.1">    </span></strong><strong class="bold"><span class="koboSpan" id="kobo.721.1">@Mock</span></strong></pre><pre class="source-code"><span class="koboSpan" id="kobo.722.1">
    private UserProfiles profiles;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.723.1">
    @Test</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.724.1">
    void formatsGreetingWithName() {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.725.1">
        var greeting = new UserGreeting(profiles);</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.726.1">
        String actual =</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.727.1">
               greeting.formatGreeting(USER_ID);</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.728.1">
        assertThat(actual)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.729.1">
                .isEqualTo("Hello and welcome, Alan");</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.730.1">
    }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.731.1">
}</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.732.1">Running the test now produces</span><a id="_idIndexMarker389"/><span class="koboSpan" id="kobo.733.1"> a different failure, as we have not yet configured</span><a id="_idIndexMarker390"/><span class="koboSpan" id="kobo.734.1"> the </span><span class="No-Break"><span class="koboSpan" id="kobo.735.1">Mockito mock:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer058">
<span class="koboSpan" id="kobo.736.1"><img alt="Figure 8.6 – Added mock, not configured" src="image/Figure_8.6_B18384.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.737.1">Figure 8.6 – Added mock, not configured</span></p>
<ol>
<li value="11"><span class="koboSpan" id="kobo.738.1">Configure </span><strong class="source-inline"><span class="koboSpan" id="kobo.739.1">@Mock</span></strong><span class="koboSpan" id="kobo.740.1"> to return</span><a id="_idIndexMarker391"/><span class="koboSpan" id="kobo.741.1"> the correct stub data</span><a id="_idIndexMarker392"/><span class="koboSpan" id="kobo.742.1"> for </span><span class="No-Break"><span class="koboSpan" id="kobo.743.1">our test:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.744.1">
package examples;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.745.1">
import org.junit.jupiter.api.Test;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.746.1">
import org.junit.jupiter.api.extension.ExtendWith;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.747.1">
import org.mockito.Mock;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.748.1">
import org.mockito.Mockito;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.749.1">
import org.mockito.junit.jupiter.MockitoExtension;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.750.1">
import static org.assertj.core.api.Assertions.assertThat;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.751.1">
import static org.mockito.Mockito.*;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.752.1">
@ExtendWith(MockitoExtension.class)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.753.1">
public class UserGreetingTest {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.754.1">
    private static final UserId USER_ID = new     UserId("1234");</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.755.1">
    @Mock</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.756.1">
    private UserProfiles profiles;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.757.1">
    @Test</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.758.1">
    void formatsGreetingWithName() {</span></pre><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.759.1">        when(profiles.fetchNicknameFor(USER_ID))</span></strong></pre><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.760.1">           .thenReturn("Alan");</span></strong></pre><pre class="source-code"><span class="koboSpan" id="kobo.761.1">
        var greeting = new UserGreeting(profiles);</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.762.1">
        String actual =</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.763.1">
               greeting.formatGreeting(USER_ID);</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.764.1">
        assertThat(actual)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.765.1">
                .isEqualTo("Hello and welcome, Alan");</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.766.1">
    }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.767.1">
}</span></pre></li>
<li><span class="koboSpan" id="kobo.768.1">If you run the test</span><a id="_idIndexMarker393"/><span class="koboSpan" id="kobo.769.1"> again, it will fail due</span><a id="_idIndexMarker394"/><span class="koboSpan" id="kobo.770.1"> to a mistake in the greeting text. </span><span class="koboSpan" id="kobo.770.2">Fix this and then re-run the test, and it </span><span class="No-Break"><span class="koboSpan" id="kobo.771.1">will pass:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer059">
<span class="koboSpan" id="kobo.772.1"><img alt="Figure 8.7 – Test pass" src="image/Figure_8.7_B18384.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.773.1">Figure 8.7 – Test pass</span></p>
<p><span class="koboSpan" id="kobo.774.1">We’ve just created </span><strong class="source-inline"><span class="koboSpan" id="kobo.775.1">class UserGreeting</span></strong><span class="koboSpan" id="kobo.776.1">, which accesses some stored nicknames for the user, via </span><strong class="source-inline"><span class="koboSpan" id="kobo.777.1">interface UserProfiles</span></strong><span class="koboSpan" id="kobo.778.1">. </span><span class="koboSpan" id="kobo.778.2">That interface used DIP to isolate </span><strong class="source-inline"><span class="koboSpan" id="kobo.779.1">UserGreeting</span></strong><span class="koboSpan" id="kobo.780.1"> from any implementation details of that store. </span><span class="koboSpan" id="kobo.780.2">We used a stub implementation to write the test. </span><span class="koboSpan" id="kobo.780.3">We’ve followed TDD and leveraged Mockito to write that stub </span><span class="No-Break"><span class="koboSpan" id="kobo.781.1">for us.</span></span></p>
<p><span class="koboSpan" id="kobo.782.1">You’ll also notice that the test failed</span><a id="_idIndexMarker395"/><span class="koboSpan" id="kobo.783.1"> in the final step. </span><span class="koboSpan" id="kobo.783.2">I expected that step</span><a id="_idIndexMarker396"/><span class="koboSpan" id="kobo.784.1"> to pass. </span><span class="koboSpan" id="kobo.784.2">It didn’t because I had typed the greeting message incorrectly. </span><span class="koboSpan" id="kobo.784.3">Once again, TDD came to </span><span class="No-Break"><span class="koboSpan" id="kobo.785.1">my rescue.</span></span></p>
<h2 id="_idParaDest-162"><a id="_idTextAnchor171"/><span class="koboSpan" id="kobo.786.1">Writing a mock with Mockito</span></h2>
<p><span class="koboSpan" id="kobo.787.1">Mockito can create mock</span><a id="_idIndexMarker397"/><span class="koboSpan" id="kobo.788.1"> objects just as easily as stubs. </span><span class="koboSpan" id="kobo.788.2">We can still use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.789.1">@Mock</span></strong><span class="koboSpan" id="kobo.790.1"> annotation on a field we wish to become a mock – perhaps making sense of the annotation, at last. </span><span class="koboSpan" id="kobo.790.2">We use the Mockito </span><strong class="source-inline"><span class="koboSpan" id="kobo.791.1">verify()</span></strong><span class="koboSpan" id="kobo.792.1"> method to check that our SUT called an expected method on </span><span class="No-Break"><span class="koboSpan" id="kobo.793.1">a collaborator.</span></span></p>
<p><span class="koboSpan" id="kobo.794.1">Let’s look at how a mock is used. </span><span class="koboSpan" id="kobo.794.2">We’ll write a test for some SUT code that we expect to send an email </span><span class="No-Break"><span class="koboSpan" id="kobo.795.1">via </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.796.1">MailServer</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.797.1">:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.798.1">@ExtendWith(MockitoExtension.class)</span></strong><span class="koboSpan" id="kobo.799.1">
class WelcomeEmailTest {
    </span><strong class="bold"><span class="koboSpan" id="kobo.800.1">@Mock</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.801.1">    private MailServer mailServer;</span></strong><span class="koboSpan" id="kobo.802.1">
    @Test
    public void sendsWelcomeEmail() {
        var notifications
                 = new UserNotifications( mailServer );
        notifications.welcomeNewUser("test@example.com");
</span><strong class="bold"><span class="koboSpan" id="kobo.803.1">        verify(mailServer).sendEmail("test@example.com",</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.804.1">                "Welcome!",</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.805.1">                "Welcome to your account");</span></strong><span class="koboSpan" id="kobo.806.1">
    }
}</span></pre>
<p><span class="koboSpan" id="kobo.807.1">In this test, we see the </span><strong class="source-inline"><span class="koboSpan" id="kobo.808.1">@ExtendWith(MockitoExtension.class)</span></strong><span class="koboSpan" id="kobo.809.1"> annotation to initialize Mockito, and the familiar Arrange, Act and Assert format of our test method. </span><span class="koboSpan" id="kobo.809.2">The new idea here is in the assertion. </span><span class="koboSpan" id="kobo.809.3">We use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.810.1">verify()</span></strong><span class="koboSpan" id="kobo.811.1"> method from the Mockito library to check that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.812.1">sendEmail()</span></strong><span class="koboSpan" id="kobo.813.1"> method was called correctly by our SUT. </span><span class="koboSpan" id="kobo.813.2">The check also verifies that it was called with the correct </span><span class="No-Break"><span class="koboSpan" id="kobo.814.1">parameter values.</span></span></p>
<p><span class="koboSpan" id="kobo.815.1">Mockito uses code generation to achieve all this. </span><span class="koboSpan" id="kobo.815.2">It wraps the interface we labeled with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.816.1">@Mock</span></strong><span class="koboSpan" id="kobo.817.1"> annotation and intercepts each and every call. </span><span class="koboSpan" id="kobo.817.2">It stores parameter values for each call. </span><span class="koboSpan" id="kobo.817.3">When we come to using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.818.1">verify()</span></strong><span class="koboSpan" id="kobo.819.1"> method to confirm that the method was called correctly, Mockito</span><a id="_idIndexMarker398"/><span class="koboSpan" id="kobo.820.1"> has all the data it needs to </span><span class="No-Break"><span class="koboSpan" id="kobo.821.1">do this.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.822.1">Beware Mockito’s when() and verify() syntax!</span></p>
<p class="callout"><span class="koboSpan" id="kobo.823.1">Mockito </span><a id="_idIndexMarker399"/><span class="koboSpan" id="kobo.824.1">has</span><a id="_idIndexMarker400"/><span class="koboSpan" id="kobo.825.1"> subtly</span><a id="_idIndexMarker401"/><span class="koboSpan" id="kobo.826.1"> different syntax</span><a id="_idIndexMarker402"/><span class="koboSpan" id="kobo.827.1"> for </span><strong class="source-inline"><span class="koboSpan" id="kobo.828.1">when()</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.829.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.830.1">verify()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.831.1">:</span></span></p>
<p class="callout"><span class="koboSpan" id="kobo.832.1">* </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.833.1">when(</span></strong></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.834.1">object.method()</span></strong></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.835.1">).thenReturn(expected value);</span></strong></span></p>
<p class="callout"><span class="koboSpan" id="kobo.836.1">* </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.837.1">verify(</span></strong></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.838.1">object</span></strong></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.839.1">).method();</span></strong></span></p>
<h2 id="_idParaDest-163"><a id="_idTextAnchor172"/><span class="koboSpan" id="kobo.840.1">Blurring the distinction between stubs and mocks</span></h2>
<p><span class="koboSpan" id="kobo.841.1">One thing to note about Mockito terminology</span><a id="_idIndexMarker403"/><span class="koboSpan" id="kobo.842.1"> is that it blurs the distinction</span><a id="_idIndexMarker404"/><span class="koboSpan" id="kobo.843.1"> between a stub and a mock object. </span><span class="koboSpan" id="kobo.843.2">In Mockito, we create test doubles that are labeled as mock objects. </span><span class="koboSpan" id="kobo.843.3">But in our test, we can use these doubles as either a stub, a mock, or even a mixture </span><span class="No-Break"><span class="koboSpan" id="kobo.844.1">of both.</span></span></p>
<p><span class="koboSpan" id="kobo.845.1">Setting up a test double to be both a stub and a mock is a test code smell. </span><span class="koboSpan" id="kobo.845.2">It’s not wrong, but it’s worth a pause for thought. </span><span class="koboSpan" id="kobo.845.3">We should consider if the collaborator that we are both mocking and stubbing has mixed up some responsibilities. </span><span class="koboSpan" id="kobo.845.4">It may be beneficial to split that </span><span class="No-Break"><span class="koboSpan" id="kobo.846.1">object up.</span></span></p>
<h2 id="_idParaDest-164"><a id="_idTextAnchor173"/><span class="koboSpan" id="kobo.847.1">Argument matchers – customizing behavior of test doubles</span></h2>
<p><span class="koboSpan" id="kobo.848.1">So far, we have configured Mockito test doubles</span><a id="_idIndexMarker405"/><span class="koboSpan" id="kobo.849.1"> to respond to very specific inputs</span><a id="_idIndexMarker406"/><span class="koboSpan" id="kobo.850.1"> to the methods they replace. </span><span class="koboSpan" id="kobo.850.2">The previous MailServer example checked for three specific parameter values being passed to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.851.1">sendEmail()</span></strong><span class="koboSpan" id="kobo.852.1"> method call. </span><span class="koboSpan" id="kobo.852.2">But we sometimes want more flexibility in our </span><span class="No-Break"><span class="koboSpan" id="kobo.853.1">test doubles.</span></span></p>
<p><span class="koboSpan" id="kobo.854.1">Mockito provides library methods called argument matchers. </span><span class="koboSpan" id="kobo.854.2">These are static methods that are used inside </span><strong class="source-inline"><span class="koboSpan" id="kobo.855.1">when()</span></strong><span class="koboSpan" id="kobo.856.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.857.1">verify()</span></strong><span class="koboSpan" id="kobo.858.1"> statements. </span><span class="koboSpan" id="kobo.858.2">Argument matchers are used to instruct Mockito to respond to a range of parameter values – including nulls and unknown values – that might get passed into a method </span><span class="No-Break"><span class="koboSpan" id="kobo.859.1">under test.</span></span></p>
<p><span class="koboSpan" id="kobo.860.1">The following test uses an argument matcher that accepts any value </span><span class="No-Break"><span class="koboSpan" id="kobo.861.1">of </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.862.1">UserId</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.863.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.864.1">
package examples2;
import examples.UserGreeting;
import examples.UserId;
import examples.UserProfiles;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.when;
@ExtendWith(MockitoExtension.class)
public class UserGreetingTest {
    @Mock
    private UserProfiles profiles;
    @Test
    void formatsGreetingWithName() {
      when(profiles.fetchNicknameFor(any()))
          .thenReturn("Alan");
        var greeting = new UserGreeting(profiles);
        String actual =
          greeting.formatGreeting(new UserId(""));
        assertThat(actual)
          .isEqualTo("Hello and welcome, Alan");
    }
}</span></pre>
<p><span class="koboSpan" id="kobo.865.1">We’ve added an </span><strong class="source-inline"><span class="koboSpan" id="kobo.866.1">any()</span></strong><span class="koboSpan" id="kobo.867.1"> argument matcher to the stubbing of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.868.1">fetchNicknameFor()</span></strong><span class="koboSpan" id="kobo.869.1"> method. </span><span class="koboSpan" id="kobo.869.2">This instructs Mockito to return the expected value </span><strong class="source-inline"><span class="koboSpan" id="kobo.870.1">Alan</span></strong><span class="koboSpan" id="kobo.871.1"> no matter what parameter value is passed into </span><strong class="source-inline"><span class="koboSpan" id="kobo.872.1">fetchNicknameFor()</span></strong><span class="koboSpan" id="kobo.873.1">. </span><span class="koboSpan" id="kobo.873.2">This is useful when writing tests to guide our readers and help them to understand what is important and what is not for a </span><span class="No-Break"><span class="koboSpan" id="kobo.874.1">particular test.</span></span></p>
<p><span class="koboSpan" id="kobo.875.1">Mockito offers a number of argument</span><a id="_idIndexMarker407"/><span class="koboSpan" id="kobo.876.1"> matchers, described in the Mockito official</span><a id="_idIndexMarker408"/><span class="koboSpan" id="kobo.877.1"> documentation. </span><span class="koboSpan" id="kobo.877.2">These argument matchers are especially useful when creating a stub to simulate an error condition. </span><span class="koboSpan" id="kobo.877.3">This is the subject of the </span><span class="No-Break"><span class="koboSpan" id="kobo.878.1">next section.</span></span></p>
<h1 id="_idParaDest-165"><a id="_idTextAnchor174"/><span class="koboSpan" id="kobo.879.1">Driving error handling code with tests</span></h1>
<p><span class="koboSpan" id="kobo.880.1">In this section, we’re going to look into a great</span><a id="_idIndexMarker409"/><span class="koboSpan" id="kobo.881.1"> use of stub objects, which</span><a id="_idIndexMarker410"/><span class="koboSpan" id="kobo.882.1"> is their role in testing </span><span class="No-Break"><span class="koboSpan" id="kobo.883.1">error conditions.</span></span></p>
<p><span class="koboSpan" id="kobo.884.1">As we create our code, we need to ensure that it handles error conditions well. </span><span class="koboSpan" id="kobo.884.2">Some error conditions are easy to test. </span><span class="koboSpan" id="kobo.884.3">An example might be a user input validator. </span><span class="koboSpan" id="kobo.884.4">To test that it handles the error caused by invalid data, we simply write a test that feeds it invalid data and then write an assertion to check it successfully reported the data was invalid. </span><span class="koboSpan" id="kobo.884.5">But what about the code that </span><span class="No-Break"><span class="koboSpan" id="kobo.885.1">uses it?</span></span></p>
<p><span class="koboSpan" id="kobo.886.1">If our SUT is code that responds to an error condition raised by one of its collaborators, we need to test that error response. </span><span class="koboSpan" id="kobo.886.2">How we test it depends on the mechanism we chose to report that error. </span><span class="koboSpan" id="kobo.886.3">We may be using a simple status code, in which case returning that error code from a stub will work </span><span class="No-Break"><span class="koboSpan" id="kobo.887.1">very well.</span></span></p>
<p><span class="koboSpan" id="kobo.888.1">We may also have chosen to use Java exceptions to report this error. </span><span class="koboSpan" id="kobo.888.2">Exceptions are controversial. </span><span class="koboSpan" id="kobo.888.3">If misused, they can lead to very unclear control flow in your code. </span><span class="koboSpan" id="kobo.888.4">We need to know how to test them, however, as they appear in several Java libraries and in-house coding styles. </span><span class="koboSpan" id="kobo.888.5">Fortunately, there’s nothing difficult about writing the test for </span><span class="No-Break"><span class="koboSpan" id="kobo.889.1">exception-handling code.</span></span></p>
<p><span class="koboSpan" id="kobo.890.1">We start with creating a stub, using any of the approaches covered in this chapter. </span><span class="koboSpan" id="kobo.890.2">We then need to arrange for the stub to throw the appropriate exception when we call a method. </span><span class="koboSpan" id="kobo.890.3">Mockito has a nice feature to do this, so let’s see an example Mockito test that </span><span class="No-Break"><span class="koboSpan" id="kobo.891.1">uses exceptions:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.892.1">
    @Test
    public void rejectsInvalidEmailRecipient() {
        </span><strong class="bold"><span class="koboSpan" id="kobo.893.1">doThrow</span></strong><span class="koboSpan" id="kobo.894.1">(new IllegalArgumentException())
            .when(mailServer).sendEmail(any(),any(),any());
        var notifications
            = new UserNotifications( mailServer );
        </span><strong class="bold"><span class="koboSpan" id="kobo.895.1">assertThatExceptionOfType</span></strong><span class="koboSpan" id="kobo.896.1">(NotificationFailureException.class)
                .</span><strong class="bold"><span class="koboSpan" id="kobo.897.1">isThrownBy</span></strong><span class="koboSpan" id="kobo.898.1">(()-&gt;notifications
                    .welcomeNewUser("not-an-email-address"));
    }</span></pre>
<p><span class="koboSpan" id="kobo.899.1">At the start</span><a id="_idIndexMarker411"/><span class="koboSpan" id="kobo.900.1"> of this test, we use Mockito </span><strong class="source-inline"><span class="koboSpan" id="kobo.901.1">doThrow()</span></strong><span class="koboSpan" id="kobo.902.1"> to configure our mock</span><a id="_idIndexMarker412"/><span class="koboSpan" id="kobo.903.1"> object. </span><span class="koboSpan" id="kobo.903.2">This configures the Mockito mock object </span><strong class="source-inline"><span class="koboSpan" id="kobo.904.1">mailServer</span></strong><span class="koboSpan" id="kobo.905.1"> to throw </span><strong class="source-inline"><span class="koboSpan" id="kobo.906.1">IllegalArgumentException</span></strong><span class="koboSpan" id="kobo.907.1"> whenever we call </span><strong class="source-inline"><span class="koboSpan" id="kobo.908.1">sendEmail()</span></strong><span class="koboSpan" id="kobo.909.1">, no matter what parameter values we send. </span><span class="koboSpan" id="kobo.909.2">This reflects a design decision to make </span><strong class="source-inline"><span class="koboSpan" id="kobo.910.1">sendEmail()</span></strong><span class="koboSpan" id="kobo.911.1"> throw that exception as a mechanism to report that the email address was not valid. </span><span class="koboSpan" id="kobo.911.2">When our SUT calls </span><strong class="source-inline"><span class="koboSpan" id="kobo.912.1">mailServer.sendEmail()</span></strong><span class="koboSpan" id="kobo.913.1">, that method will throw </span><strong class="source-inline"><span class="koboSpan" id="kobo.914.1">IllegalArgumentExeption</span></strong><span class="koboSpan" id="kobo.915.1">. </span><span class="koboSpan" id="kobo.915.2">We can exercise the code that </span><span class="No-Break"><span class="koboSpan" id="kobo.916.1">handles this.</span></span></p>
<p><span class="koboSpan" id="kobo.917.1">For this example, we decided to make the SUT wrap and rethrow </span><strong class="source-inline"><span class="koboSpan" id="kobo.918.1">IllegalArgumentException</span></strong><span class="koboSpan" id="kobo.919.1">. </span><span class="koboSpan" id="kobo.919.2">We choose to create a new exception that relates to the responsibility of user notifications. </span><span class="koboSpan" id="kobo.919.3">We will call it </span><strong class="source-inline"><span class="koboSpan" id="kobo.920.1">NotificationFailureException</span></strong><span class="koboSpan" id="kobo.921.1">. </span><span class="koboSpan" id="kobo.921.2">The assertion step of the test then uses the AssertJ library feature </span><strong class="source-inline"><span class="koboSpan" id="kobo.922.1">assertThatExceptionOfType()</span></strong><span class="koboSpan" id="kobo.923.1">. </span><span class="koboSpan" id="kobo.923.2">This performs the Act and Assert steps together. </span><span class="koboSpan" id="kobo.923.3">We call our SUT </span><strong class="source-inline"><span class="koboSpan" id="kobo.924.1">welcomeNewUser()</span></strong><span class="koboSpan" id="kobo.925.1"> method and assert that it throws our </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.926.1">NotificationFailureException</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.927.1"> error.</span></span></p>
<p><span class="koboSpan" id="kobo.928.1">We can see how this is enough to trigger the exception-handling response in our SUT code. </span><span class="koboSpan" id="kobo.928.2">This means we can write our test and then drive out the required code. </span><span class="koboSpan" id="kobo.928.3">The code we write will include a catch handler for </span><strong class="source-inline"><span class="koboSpan" id="kobo.929.1">InvalidArgumentException</span></strong><span class="koboSpan" id="kobo.930.1">. </span><span class="koboSpan" id="kobo.930.2">In this case, all the new code has to do is throw a </span><strong class="source-inline"><span class="koboSpan" id="kobo.931.1">NotificationFailureException</span></strong><span class="koboSpan" id="kobo.932.1"> error. </span><span class="koboSpan" id="kobo.932.2">This is a new class that we will create that extends </span><strong class="source-inline"><span class="koboSpan" id="kobo.933.1">RuntimeException</span></strong><span class="koboSpan" id="kobo.934.1">. </span><span class="koboSpan" id="kobo.934.2">We do this to report that something went wrong by sending a notification. </span><span class="koboSpan" id="kobo.934.3">As part of normal system layering</span><a id="_idIndexMarker413"/><span class="koboSpan" id="kobo.935.1"> considerations, we want to replace the original exception</span><a id="_idIndexMarker414"/><span class="koboSpan" id="kobo.936.1"> with a more general one, which is better suited to this layer </span><span class="No-Break"><span class="koboSpan" id="kobo.937.1">of code.</span></span></p>
<p><span class="koboSpan" id="kobo.938.1">This section has examined features of Mockito and AssertJ libraries that help us use TDD to drive out exception-handling behavior. </span><span class="koboSpan" id="kobo.938.2">In the next section, let’s apply this to an error in our </span><span class="No-Break"><span class="koboSpan" id="kobo.939.1">Wordz application.</span></span></p>
<h1 id="_idParaDest-166"><a id="_idTextAnchor175"/><span class="koboSpan" id="kobo.940.1">Testing an error condition in Wordz</span></h1>
<p><span class="koboSpan" id="kobo.941.1">In this section, we will apply</span><a id="_idIndexMarker415"/><span class="koboSpan" id="kobo.942.1"> what we’ve learned by writing a test for a class</span><a id="_idIndexMarker416"/><span class="koboSpan" id="kobo.943.1"> that will choose a random word for the player to guess, from a stored set of words. </span><span class="koboSpan" id="kobo.943.2">We will create an interface called </span><strong class="source-inline"><span class="koboSpan" id="kobo.944.1">WordRepository</span></strong><span class="koboSpan" id="kobo.945.1"> to access stored words. </span><span class="koboSpan" id="kobo.945.2">We will do this through a </span><strong class="source-inline"><span class="koboSpan" id="kobo.946.1">fetchWordByNumber(wordNumber)</span></strong><span class="koboSpan" id="kobo.947.1"> method, where </span><strong class="source-inline"><span class="koboSpan" id="kobo.948.1">wordNumber</span></strong><span class="koboSpan" id="kobo.949.1"> identifies a word. </span><span class="koboSpan" id="kobo.949.2">The design decision here is that every word is stored with a sequential number starting from </span><em class="italic"><span class="koboSpan" id="kobo.950.1">1</span></em><span class="koboSpan" id="kobo.951.1"> to help us pick one </span><span class="No-Break"><span class="koboSpan" id="kobo.952.1">at random.</span></span></p>
<p><span class="koboSpan" id="kobo.953.1">We will be writing a </span><strong class="source-inline"><span class="koboSpan" id="kobo.954.1">WordSelection</span></strong><span class="koboSpan" id="kobo.955.1"> class, which is responsible for picking a random number and using that to fetch a word from storage that is tagged with that number. </span><span class="koboSpan" id="kobo.955.2">We will be using our </span><strong class="source-inline"><span class="koboSpan" id="kobo.956.1">RandomNumbers</span></strong><span class="koboSpan" id="kobo.957.1"> interface from earlier. </span><span class="koboSpan" id="kobo.957.2">For this example, our test will cover the case where we attempt to fetch a word from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.958.1">WordRepository</span></strong><span class="koboSpan" id="kobo.959.1"> interface, but for some reason, it </span><span class="No-Break"><span class="koboSpan" id="kobo.960.1">isn’t there.</span></span></p>
<p><span class="koboSpan" id="kobo.961.1">We can write the test </span><span class="No-Break"><span class="koboSpan" id="kobo.962.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.963.1">
@</span><strong class="bold"><span class="koboSpan" id="kobo.964.1">ExtendWith(MockitoExtension.class)</span></strong><span class="koboSpan" id="kobo.965.1">
public class WordSelectionTest {
    @Mock
    private WordRepository repository;
    @Mock
    private RandomNumbers random;
    @Test
    public void reportsWordNotFound() {
        </span><strong class="bold"><span class="koboSpan" id="kobo.966.1">doThrow</span></strong><span class="koboSpan" id="kobo.967.1">(new WordRepositoryException())
                .when(repository)
                  .</span><strong class="bold"><span class="koboSpan" id="kobo.968.1">fetchWordByNumber</span></strong><span class="koboSpan" id="kobo.969.1">(</span><strong class="bold"><span class="koboSpan" id="kobo.970.1">anyInt()</span></strong><span class="koboSpan" id="kobo.971.1">);
        var selection = </span><strong class="bold"><span class="koboSpan" id="kobo.972.1">new WordSelection(repository,</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.973.1">                                          random)</span></strong><span class="koboSpan" id="kobo.974.1">;
        </span><strong class="bold"><span class="koboSpan" id="kobo.975.1">assertThatExceptionOfType</span></strong><span class="koboSpan" id="kobo.976.1">(WordSelectionException.class)
                .</span><strong class="bold"><span class="koboSpan" id="kobo.977.1">isThrownBy</span></strong><span class="koboSpan" id="kobo.978.1">(
                        ()-&gt;</span><strong class="bold"><span class="koboSpan" id="kobo.979.1">selection.getRandomWord()</span></strong><span class="koboSpan" id="kobo.980.1">);
    }
}</span></pre>
<p><span class="koboSpan" id="kobo.981.1">The test captures</span><a id="_idIndexMarker417"/><span class="koboSpan" id="kobo.982.1"> a few more design</span><a id="_idIndexMarker418"/><span class="koboSpan" id="kobo.983.1"> decisions relating to how we intend </span><strong class="source-inline"><span class="koboSpan" id="kobo.984.1">WordRepository</span></strong><span class="koboSpan" id="kobo.985.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.986.1">WordSelection</span></strong><span class="koboSpan" id="kobo.987.1"> to work. </span><span class="koboSpan" id="kobo.987.2">Our </span><strong class="source-inline"><span class="koboSpan" id="kobo.988.1">fetchWordByNumber(wordNumber)</span></strong><span class="koboSpan" id="kobo.989.1"> repository method will throw </span><strong class="source-inline"><span class="koboSpan" id="kobo.990.1">WordRepositoryException</span></strong><span class="koboSpan" id="kobo.991.1"> if there are any problems retrieving the word. </span><span class="koboSpan" id="kobo.991.2">Our intention is to make </span><strong class="source-inline"><span class="koboSpan" id="kobo.992.1">WordSelection</span></strong><span class="koboSpan" id="kobo.993.1"> throw its own custom exception to report that it cannot complete the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.994.1">getRandomWord()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.995.1"> request.</span></span></p>
<p><span class="koboSpan" id="kobo.996.1">To set this situation up in the test, we first arrange for the repository to throw. </span><span class="koboSpan" id="kobo.996.2">This is done using the Mockito </span><strong class="source-inline"><span class="koboSpan" id="kobo.997.1">doThrow()</span></strong><span class="koboSpan" id="kobo.998.1"> feature. </span><span class="koboSpan" id="kobo.998.2">Whenever the </span><strong class="source-inline"><span class="koboSpan" id="kobo.999.1">fetchWordByNumber()</span></strong><span class="koboSpan" id="kobo.1000.1"> method is called, whatever parameter we pass into it Mockito will throw the exception we asked it to throw, which is </span><strong class="source-inline"><span class="koboSpan" id="kobo.1001.1">WordRepositoryException</span></strong><span class="koboSpan" id="kobo.1002.1">. </span><span class="koboSpan" id="kobo.1002.2">This allows us to drive out the code that handles this </span><span class="No-Break"><span class="koboSpan" id="kobo.1003.1">error condition.</span></span></p>
<p><span class="koboSpan" id="kobo.1004.1">Our Arrange step is completed by creating the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1005.1">WordSelection</span></strong><span class="koboSpan" id="kobo.1006.1"> SUT class. </span><span class="koboSpan" id="kobo.1006.2">We pass in two collaborators to the constructor: the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1007.1">WordRepository</span></strong><span class="koboSpan" id="kobo.1008.1"> instance and a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1009.1">RandomNumbers</span></strong><span class="koboSpan" id="kobo.1010.1"> instance. </span><span class="koboSpan" id="kobo.1010.2">We have asked Mockito to create stubs for both interfaces by adding the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1011.1">@Mock</span></strong><span class="koboSpan" id="kobo.1012.1"> annotation to test double the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1013.1">repository</span></strong><span class="koboSpan" id="kobo.1014.1"> and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1015.1">random</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1016.1"> fields.</span></span></p>
<p><span class="koboSpan" id="kobo.1017.1">With the SUT now properly constructed, we are ready to write the Act and Assert steps of the test. </span><span class="koboSpan" id="kobo.1017.2">We are testing that an exception is thrown, so we need to use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1018.1">assertThatExceptionOfType()</span></strong><span class="koboSpan" id="kobo.1019.1"> AssertJ facility to do this. </span><span class="koboSpan" id="kobo.1019.2">We can pass in the class of the exception that we are expecting to be thrown, which is </span><strong class="source-inline"><span class="koboSpan" id="kobo.1020.1">WordSelectionException</span></strong><span class="koboSpan" id="kobo.1021.1">. </span><span class="koboSpan" id="kobo.1021.2">We chain the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1022.1">isThrownBy()</span></strong><span class="koboSpan" id="kobo.1023.1"> method to perform the Act step and make our SUT code run. </span><span class="koboSpan" id="kobo.1023.2">This is provided as a Java lambda function as a parameter to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1024.1">isThrownBy()</span></strong><span class="koboSpan" id="kobo.1025.1"> method. </span><span class="koboSpan" id="kobo.1025.2">This will call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1026.1">getRandomWord()</span></strong><span class="koboSpan" id="kobo.1027.1"> method, which we intend to fail and throw an exception. </span><span class="koboSpan" id="kobo.1027.2">The assertion will confirm that this has happened and that the expected kind of exception class has been thrown. </span><span class="koboSpan" id="kobo.1027.3">We will run the test, see it fail, and then add the necessary logic to make the </span><span class="No-Break"><span class="koboSpan" id="kobo.1028.1">test pass.</span></span></p>
<p><span class="koboSpan" id="kobo.1029.1">The test code</span><a id="_idIndexMarker419"/><span class="koboSpan" id="kobo.1030.1"> shows us that we can use test doubles and verification</span><a id="_idIndexMarker420"/><span class="koboSpan" id="kobo.1031.1"> of error conditions with test-first TDD. </span><span class="koboSpan" id="kobo.1031.2">It also shows that tests can become easily coupled to a specific implementation of a solution. </span><span class="koboSpan" id="kobo.1031.3">There are a lot of design decisions in this test about which exceptions happen and where they are used. </span><span class="koboSpan" id="kobo.1031.4">These decisions even include the fact that exceptions are being used at all to report errors. </span><span class="koboSpan" id="kobo.1031.5">All that said, this is still a reasonable way to split responsibilities and define contracts between components. </span><span class="koboSpan" id="kobo.1031.6">It is all captured in </span><span class="No-Break"><span class="koboSpan" id="kobo.1032.1">the test.</span></span></p>
<h1 id="_idParaDest-167"><a id="_idTextAnchor176"/><span class="koboSpan" id="kobo.1033.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.1034.1">In this chapter, we’ve looked at how to solve the problem of testing problematic collaborators. </span><span class="koboSpan" id="kobo.1034.2">We have learned how to use stand-in objects for collaborators called test doubles. </span><span class="koboSpan" id="kobo.1034.3">We’ve learned that this gives us simple control over what those collaborators do inside our </span><span class="No-Break"><span class="koboSpan" id="kobo.1035.1">test code.</span></span></p>
<p><span class="koboSpan" id="kobo.1036.1">Two kinds of test double are especially useful to us: the stub and the mock. </span><span class="koboSpan" id="kobo.1036.2">Stubs return data. </span><span class="koboSpan" id="kobo.1036.3">Mocks verify that methods were called. </span><span class="koboSpan" id="kobo.1036.4">We’ve learned how to use the Mockito library to create stubs and mocks </span><span class="No-Break"><span class="koboSpan" id="kobo.1037.1">for us.</span></span></p>
<p><span class="koboSpan" id="kobo.1038.1">We’ve used AssertJ to verify the SUT behaved correctly under the various conditions of our test doubles. </span><span class="koboSpan" id="kobo.1038.2">We’ve learned how to test error conditions that </span><span class="No-Break"><span class="koboSpan" id="kobo.1039.1">throw exceptions.</span></span></p>
<p><span class="koboSpan" id="kobo.1040.1">These techniques have expanded our toolkit for </span><span class="No-Break"><span class="koboSpan" id="kobo.1041.1">writing tests.</span></span></p>
<p><span class="koboSpan" id="kobo.1042.1">In the next chapter, we are going to cover a very useful system design technique that allows us to get most of our code under FIRST unit test, and at the same time avoid the problems of testing collaborations with external systems that we </span><span class="No-Break"><span class="koboSpan" id="kobo.1043.1">cannot control.</span></span></p>
<h1 id="_idParaDest-168"><a id="_idTextAnchor177"/><span class="koboSpan" id="kobo.1044.1">Questions and answers</span></h1>
<ol>
<li value="1"><span class="koboSpan" id="kobo.1045.1">Are the terms stub and mock </span><span class="No-Break"><span class="koboSpan" id="kobo.1046.1">used interchangeably?</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.1047.1">Yes, even though they have different meanings. </span><span class="koboSpan" id="kobo.1047.2">In normal conversation, we tend to trade precision for fluency, and that’s okay. </span><span class="koboSpan" id="kobo.1047.3">It’s important to understand the different uses that each kind of test double has. </span><span class="koboSpan" id="kobo.1047.4">When speaking, it’s usually better to not be pedantic whenever a group of people knows what is meant. </span><span class="koboSpan" id="kobo.1047.5">So long as we stay aware that a test double is the proper general term and that the specific types of doubles have different roles, all will </span><span class="No-Break"><span class="koboSpan" id="kobo.1048.1">be well.</span></span></p>
<ol>
<li value="2"><span class="koboSpan" id="kobo.1049.1">What is the problem known as “testing </span><span class="No-Break"><span class="koboSpan" id="kobo.1050.1">the mock”?</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.1051.1">This happens when the SUT has no real logic in it, yet we try to write a unit test anyway. </span><span class="koboSpan" id="kobo.1051.2">We wire up a test double to the SUT and write the test. </span><span class="koboSpan" id="kobo.1051.3">What we will find is that the assertions only check that the test double-returned the right data. </span><span class="koboSpan" id="kobo.1051.4">It’s an indication that we have tested at the wrong level. </span><span class="koboSpan" id="kobo.1051.5">This kind of error can be driven by setting unwise code coverage targets or forcing an equally unwise test-per-method rule. </span><span class="koboSpan" id="kobo.1051.6">This test adds no value and should </span><span class="No-Break"><span class="koboSpan" id="kobo.1052.1">be removed.</span></span></p>
<ol>
<li value="3"><span class="koboSpan" id="kobo.1053.1">Can test doubles be </span><span class="No-Break"><span class="koboSpan" id="kobo.1054.1">used anywhere?</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.1055.1">No. </span><span class="koboSpan" id="kobo.1055.2">This only works if you have designed your code using the Dependency Inversion Principle so that a test double can be swapped in place of a production object. </span><span class="koboSpan" id="kobo.1055.3">Using TDD certainly forces us to think about this kind of design </span><span class="No-Break"><span class="koboSpan" id="kobo.1056.1">issue early.</span></span></p>
<p><span class="koboSpan" id="kobo.1057.1">Writing tests later is made more difficult if there is insufficient access to inject test doubles where they are needed. </span><span class="koboSpan" id="kobo.1057.2">Legacy code is particularly difficult in this respect, and I recommend reading the book </span><em class="italic"><span class="koboSpan" id="kobo.1058.1">Working Effectively with Legacy Code </span></em><span class="koboSpan" id="kobo.1059.1">by Michael Feathers for techniques to aid in adding tests to code that lacks the necessary test access points. </span><span class="koboSpan" id="kobo.1059.2">(See the </span><em class="italic"><span class="koboSpan" id="kobo.1060.1">Further </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1061.1">reading</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.1062.1"> list.)</span></span></p>
<h1 id="_idParaDest-169"><a id="_idTextAnchor178"/><span class="koboSpan" id="kobo.1063.1">Further reading</span></h1>
<ul>
<li><a href="B18384_08.xhtml#_idTextAnchor174"><span class="No-Break"><span class="koboSpan" id="kobo.1064.1">https://site.mockito.org/</span></span></a></li>
</ul>
<p><span class="koboSpan" id="kobo.1065.1">Mockito library </span><span class="No-Break"><span class="koboSpan" id="kobo.1066.1">home page</span></span></p>
<ul>
<li><em class="italic"><span class="koboSpan" id="kobo.1067.1">Working Effectively with Legacy Code, Michael C. </span><span class="koboSpan" id="kobo.1067.2">Feathers </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1068.1">ISBN 978-0131177055</span></em></span></li>
</ul>
<p><span class="koboSpan" id="kobo.1069.1">This book explains how you can work with legacy code written without Dependency Inversion access points for test doubles. </span><span class="koboSpan" id="kobo.1069.2">It shows a range of techniques to safely rework the legacy code so that test doubles can </span><span class="No-Break"><span class="koboSpan" id="kobo.1070.1">be introduced.</span></span></p>
</div>
</body></html>