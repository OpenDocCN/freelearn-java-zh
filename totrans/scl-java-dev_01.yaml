- en: Chapter 1. Programming Interactively within Your Project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Moving away from a well established and mature language such as Java requires
    some pretty good reasons. Before pragmatically trying out some of the apparent
    differences between Java and Scala in order to get acquainted with the Scala syntax,
    we are going to clarify what makes Scala so attractive.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The advantages of using Scala for Java projects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting familiar with the syntax of the language through a crash course following
    an interactive session, including case classes, operations on collections, and
    a glimpse of some useful features such as options, tuples, maps, pattern matching,
    and string interpolation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advantages of using Scala for Java projects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The order of appearance and importance that we propose here only reflects our
    personal experience since every project and group of programmers usually have
    their own agenda when it comes to priorities.
  prefs: []
  type: TYPE_NORMAL
- en: More concise and expressive
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The ultimate reason why you should adopt Scala is readability: code that is
    similar to plain English will make it easier for anyone (including yourself) to
    understand, maintain, and refactor it. Scala is unique in that it unifies the
    object-oriented side that Java has in order to make code modular with the power
    of functional languages to express transformations concisely. To illustrate how
    to achieve conciseness by the introduction of anonymous functions (also called
    **lambdas**) into the language, take a look at the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'As a Java programmer, the line might look awkward at first since it does not
    follow the usual pattern of invoking method signatures on classes. A possible
    Java translation of the previous code could be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Downloading the example code**'
  prefs: []
  type: TYPE_NORMAL
- en: You can download the example code files for all books by Packt Publishing that
    you have purchased from your account at [http://www.packtpub.com](http://www.packtpub.com).
    If you purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  prefs: []
  type: TYPE_NORMAL
- en: 'We first create a `List` with five integers, then create an empty `List` that
    will hold the result of the filtering and then loop over the elements of the `List`
    to retain only the ones that match the `if` predicate (`element < 4`) and finally
    print out the result. Even if this is straightforward to write, it requires a
    few lines of code, whereas the Scala line could just be read like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '"From the given `List`, filter each element such that this element is lower
    than `4`".'
  prefs: []
  type: TYPE_NORMAL
- en: The fact that the code becomes really concise but expressive makes it easier
    for the programmer to comprehend at once a difficult or lengthy algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: Increased productivity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Having a compiler that performs a lot of type checking and works as a personal
    assistant, is in our opinion, a significant advantage over languages that check
    types dynamically at runtime, and the fact that Java is a statically-typed language
    is probably one of the main reasons that made it so popular in the first place.
    The Scala compiler belongs to this category as well and goes even further by finding
    out many of the types automatically, often relieving the programmer from specifying
    these types explicitly in the code. Moreover, the compiler in your IDE gives instant
    feedback, and therefore, increases your productivity.
  prefs: []
  type: TYPE_NORMAL
- en: Natural evolution from Java
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Scala integrates seamlessly with Java, which is a very attractive feature, to
    avoid reinventing the wheel. You can start running Scala today in a production
    environment. Large corporations such as Twitter, LinkedIn, or Foursquare (to name
    a few) have done that on large-scale deployments for many years now, followed
    recently by other big players such as Intel or Amazon. Scala compiles to Java
    bytecode, which means that performance will be comparable. Most of the code that
    you are running while executing Scala programs is probably Java code, the major
    difference being what programmers see and the advanced type checking while compiling
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Better fit for asynchronous and concurrent code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To achieve better performance and handle more load, modern Java frameworks and
    libraries for web development are now tackling difficult problems that are tied
    to multi-core architectures and the integration with unpredictable external systems.
    Scala's incentive to use immutable data structures and functional programming
    constructs as well as its support for parallel collections has a better chance
    to succeed in writing concurrent code that will behave correctly. Moreover, Scala's
    superior type system and macro support enable DSLs for trivially safe asynchronous
    constructs, for example, composable futures and asynchronous language extensions.
  prefs: []
  type: TYPE_NORMAL
- en: In summary, Scala is the only language that has it all. It is statically typed,
    runs on the JVM and is totally Java compatible, is both object-oriented and functional,
    and is not verbose, thereby leading to better productivity, less maintenance,
    and therefore more fun.
  prefs: []
  type: TYPE_NORMAL
- en: If you are now getting impatient to start experimenting with the promising features
    of Scala that were briefly described previously, this is a good time to open a
    browser, access the Typesafe page URL at [http://www.typesafe.com/platform/getstarted](http://www.typesafe.com/platform/getstarted),
    and download the Typesafe Activator.
  prefs: []
  type: TYPE_NORMAL
- en: The intent of the rest of the chapter is to incrementally introduce some of
    the basic concepts of Scala by typing commands in an interactive shell and get
    direct feedback from the compiler. This method of learning by experimentation
    should feel like a breath of fresh air and has already proven to be a very effective
    way of learning the syntax and useful constructs of the language. While Scala
    continues to evolve at École Polytechnique Fédérale de Lausanne (EPFL), many large
    and small corporations are now taking advantage of the features of the Typesafe
    platform.
  prefs: []
  type: TYPE_NORMAL
- en: As stated on their website, the Typesafe Activator is "a local web and command-line
    tool that helps developers get started with the Typesafe platform". We will cover
    the Activator in more detail in a later chapter dedicated to programming tools,
    but for now, we will only take the shortest path in getting up and running and
    get familiar with some of the syntax of the language.
  prefs: []
  type: TYPE_NORMAL
- en: You should now be able to extract the downloaded zip archive to your system
    in a directory of your choice.
  prefs: []
  type: TYPE_NORMAL
- en: 'Locate the activator script within the extracted archive and either right-click
    on it and select **Open** if you are running Windows or enter the following command
    in a terminal window if you are on Linux/Mac:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In both cases, this will start the Activator UI in a browser window.
  prefs: []
  type: TYPE_NORMAL
- en: In the **New application** section of the HTML page of the Activator, click
    on the `[Basics] Hello-Scala!` template.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice the **Location** field of the HTML form in the following screenshot.
    It indicates where your project will be created:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Better fit for asynchronous and concurrent code](img/3637OS_01_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At present, you don't need to pay too much attention to all of the things that
    happen in the background nor to the generated structure of the project. Out of
    curiosity, you may click on the **Code view & Open in IDE** tab and then on the
    **Run** tab to execute this Hello World Scala project, which should print, well,
    **"Hello, world !"**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start a terminal window and navigate to the root directory of the *hello-scala*
    project that we just created, by entering the following command on the command
    line (assuming our project is under `C:\Users\Thomas\hello-scala`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This command will start the Scala interpreter, also known as Scala **REPL**
    (**Read-Eval-Print-Loop**), a simple command-line tool to program interactively.
  prefs: []
  type: TYPE_NORMAL
- en: Learning Scala through the REPL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As a Java developer, an REPL may be new to you since there is no such thing
    for the Java language. It used to refer to the Lisp language interactive environment,
    and today, equivalent tools are available for many programming languages such
    as JavaScript, Clojure, Ruby, and Scala. It consists of a command-line shell where
    you can enter one or more expressions rather than complete files and get immediate
    feedback by evaluating the result. The REPL is a fantastic tool that helps us
    to learn all the Scala syntax because it compiles and executes every statement
    that you write using the full power of the compiler. In such an interactive environment,
    you get instant feedback on every line of code you write.
  prefs: []
  type: TYPE_NORMAL
- en: If you are new to Scala, we recommend that you carefully follow this REPL session
    as it will give you a lot of useful knowledge for programming with Scala.
  prefs: []
  type: TYPE_NORMAL
- en: Let's dive into some of the most apparent differences between Java and Scala
    in order to get acquainted with the Scala syntax.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring val/var variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In Java, you would declare a new variable by putting in order its type, followed
    by the name, and then the optional value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In Scala, the order of declaring the variable name and type is inverted, with
    the name appearing before its type. Let''s enter the following line into the REPL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Inverting the order of declaring the variables, type, and name as compared
    to Java might at first seem a strange idea if you want to make it as easy as possible
    for a Java developer to grab the Scala syntax. However, it makes sense for several
    reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Scala compiler, in this case, is able to deduct the type automatically.
    You could (and probably should, for conciseness) omit this type by entering the
    equivalent but shorter line of code instead:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is the most basic illustration of what is called **Type Inference**, and
    you will see that the Scala compiler will try to deduct types whenever it can.
    If we had omitted this optional type but followed the Java syntax, the parsing
    done by the compiler would have been more difficult to implement.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In our opinion, it is more important to know a variable name than its type in
    order to understand the flow of a program (and therefore make it appear first);
    for instance, if you deal with a variable representing a **social security number**
    (**ssn**), we think the term ssn is more valuable than knowing if it is represented
    as a string or an integer or any other type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You probably noticed the `val` variable in front of the declaration; it means
    that we explicitly declare the variable as immutable. We can try to modify it
    as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code will not only give you a clear explanation of what was wrong
    but also the exact place where the parser did not agree (notice the `^` character
    precisely showing where the error lies in the line).
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to create a mutable variable instead, we should declare it with
    `var` as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In summary, you cannot change `yourPast` but you can change `yourFuture`!
  prefs: []
  type: TYPE_NORMAL
- en: The semicolon at the end of the lines is optional in Scala; a small but pleasant
    feature of the language.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s move on to an important difference. In Java, you have primitive types
    such as `int`, `char`, or `boolean` (eight in total), as well as operators to
    manipulate data such as `+` or `>`. In Scala, there are only classes and objects,
    making Scala more "object-oriented" than Java in some way. For instance, enter
    the following value into the REPL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: By default, the compiler created an immutable `Int` (integer) variable with
    the `res1` name (that is, result 1) in case you need to reuse it later on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, enter the following line in REPL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code resembles the usage of an operator (as in Java) but is in
    fact the invocation of a method named `+` called on object `3` with the input
    parameter `2`, equivalent to the slightly less clear statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Syntactic sugar (that is, syntax designed to make things easier to read or express)
    was added here by removing the necessity to specify the parenthesis. This also
    means that we can now implement similar methods on our own defined types to express
    code elegantly. For example, we can express the addition of two `Money` objects
    of different currencies (note that the `Money` type does not exist in the default
    Scala library) by simply stating `Money(10,"EUR") + Money(15,"USD")`. Let's try
    to do that in the REPL.
  prefs: []
  type: TYPE_NORMAL
- en: Defining classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we can define a new class `Money` that has a constructor parameter named
    `amount` of type `Int` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Scala has a special syntax for declaring constructor parameters that will be
    explored in more depth later.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can create a `Money` instance as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'You get back an object with its displayed reference. The REPL provides you
    with **TAB completion**, so type `notMuch.` and hit the *Tab* key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: By using the preceding autocompletion, you will get suggestions of the available
    methods for that class, as you will get with most Java IDEs.
  prefs: []
  type: TYPE_NORMAL
- en: 'As shown previously, you can construct new instances of `Money` by invoking
    the constructor, but you do not have access to the `amount` variable since it
    is not a field. To make it a field of the `Money` class, you have to add a ''`val`''
    or ''`var`'' declaration in front of it, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, instead of again typing the line that created an instance, we will
    use the up arrow (the shortcut to display previous expressions: the history of
    the console) and navigate to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *Tab* key can be pressed at any time in the REPL and provides autocompletion.
  prefs: []
  type: TYPE_NORMAL
- en: 'Invoking autocompletion on this new instance will display the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'So, we can simply read the value of the getter for this `amount` field by referring
    to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, if we had declared the amount to be a `var` variable instead of
    `val`, we would also have access to the `setter` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The `setter` method is invoked when we use the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Explaining case classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As Java developers, we are accustomed to the JavaBean style domain classes
    that not only include fields with getters and setters but also constructors as
    well as `hashCode`, `equals`, and `toString` methods, as shown in the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Achieving this in Scala is very straightforward and only requires the addition
    of the `case` word in front of the class declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: We have just defined a class `Money` with two immutable fields named `amount`
    and `currency` with default values.
  prefs: []
  type: TYPE_NORMAL
- en: Without going too much into the details of the `case` classes, we can say that
    in addition to the preceding features of a traditional JavaBean style domain class,
    they have a powerful mechanism for pattern matching. The `case` word is analogous
    to the `switch` statement in Java, though it is more flexible, as we will see
    later on. The `case` classes contain additional features among which one is a
    factory method to create instances (no need to use the `new` keyword to create
    one).
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, the fields declared in Scala classes are public, unlike Java, where
    they have a package-private scope, defined between private and protected. We could
    have written `case class Money(private val amount: Int, private val currency:
    String)` to make them private instead, or used `var` instead of `val` to make
    the fields mutable.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The shortest way to create an instance of `Money` is very straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In the previous instance declaration, since only one parameter is given instead
    of two, the compiler matched it against the first declared field, that is, `amount`.
    Since the value `15` is of the same type as `amount` (that is, `Integer`), the
    compiler was able to populate the instance with this amount, using the default
    value `"USD"` as the currency.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unlike the `amount` variable, invoking the `Money` constructor with the sole
    currency parameter will fail, as seen in the following statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code does not work because the compiler could not guess which
    parameter we were referring to, and therefore tried to match them in order of
    declaration. To be able to use the default value for `amount` with the given `"EUR"`
    string, we need to include the parameter name explicitly, as shown in the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We could therefore also mark all parameters explicitly, which can be recommended
    when there are many parameters as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'An additional useful method when constructing instances is the `copy` method,
    which creates a new instance out of the original and eventually replaces given
    parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use the `copy` method with explicitly named parameters, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The `copy` method can be very useful when writing test fixtures, in particular,
    when the mockup instances to be initialized have constructors with many fields
    that are similar.
  prefs: []
  type: TYPE_NORMAL
- en: Let's move on by creating an `addition` operation of our `Money` class. For
    simplicity, we will pretend for a moment that we only deal with amounts of the
    same currency, the default USD.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Java, we would probably add such a method with the following signature and
    simple content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'In Scala, we use the `def` keyword to define a class method or a function.
    In the REPL, we can have multiline expressions. The following `case` class declaration,
    containing the implementation of a summing method `+` is an example of such features:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we can use `+` as a method name. We have also included the return
    type `Money` in the signature declaration, which is only optional since the type
    inference of Scala will deduct it, but including it explicitly is a good documentation
    practice for public methods (and methods are public by default if no other scope
    is specified). Moreover, in Scala, since the `return` word at the end of the method
    is optional, the last statement is always the one that is returned to the caller
    of the method. Furthermore, it is generally considered a good practice to omit
    the `return` keyword since it is not mandatory.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now write the addition of two `Money` instances with the following simple
    expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Things start becoming exciting once we start manipulating collections of objects,
    and the functional programming part of Scala helps very much for that matter.
    Since generics are part of the language (Java 5 onwards), Java can, for example,
    iterate over a list of integers by writing the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'In Scala, the declaration of a list can be written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Scala collections systematically distinguish between immutable and mutable collections,
    but encourage immutability by constructing immutable collections by default. They
    simulate additions, updates, or removals by returning new collections from such
    operations instead of modifying them.
  prefs: []
  type: TYPE_NORMAL
- en: 'One way to print out the numbers is that we can follow Java''s imperative style
    of programming and iterate over the collection by creating a `for` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Another way to write the code in Scala (as well as many other languages on
    the JVM, such as Groovy, JRuby, or Jython) involves a more functional style, using
    lambda expressions (sometimes referred to as closures). In brief, lambdas are
    just functions that you can pass around as parameters. These functions take input
    parameters (in our case, the `n` integer) and return the last statement/line of
    their body. They are in the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'A typical example of lambda to iterate over the elements of the `numbers` list
    we have defined earlier, is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: In that case, the body consists of only one statement (`println...`), and therefore
    returns `Unit`, that is, an empty result roughly equivalent to `void` in Java,
    except that `void` does not return anything.
  prefs: []
  type: TYPE_NORMAL
- en: As the time of writing this book, lambda expressions in Java are around the
    corner and will be introduced very soon as part of the JDK8 release, adopting
    a Scala-like style. Some of the functional constructs will therefore soon be available
    to Java developers.
  prefs: []
  type: TYPE_NORMAL
- en: 'It should become possible to write our tiny example in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: As we stated previously, Scala collections are, by default, immutable. This
    is a very important aspect for making them behave as expected when dealing with
    multiprocessor architectures. One unique feature of the Scala collections compared
    to Java is that they include support for running operations in parallel.
  prefs: []
  type: TYPE_NORMAL
- en: Operations on collections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are going to illustrate how the manipulation of collections
    in Scala can be expressed in a concise and expressive way.
  prefs: []
  type: TYPE_NORMAL
- en: Transforming collections containing primitive types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The REPL is a great tool to try out the powerful operations that we can apply
    to the collection elements. Let''s go back to our interpreter prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The `drop` method indicates that we get rid of the first two elements of the
    list, and the `take` method indicates that we keep only three elements from the
    result obtained after the `drop` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'This last command is interesting for two reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: Since every method call is evaluated to an expression, we can chain several
    method calls at once (here, `take` is invoked on the result of `drop`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As already stated before, the syntactic sugar added to the Scala syntax makes
    it equivalent to write `numbers drop 2` instead of the more traditional Java `numbers.drop(2)`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Another way of writing elements in a given list is by using the `::` method,
    generally referred to in Scala documentation as the "cons operator". This alternative
    syntax looks like the following expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are wondering why there is a `Nil` value at the end of this expression,
    this is because there is a simple rule in Scala that says that a method whose
    last character is `:` (that is, a colon) is applied on its right side rather than
    the left side (such a method is called as right-associative). So, the evaluation
    of `6 :: Nil` is not equivalent to `6.::(Nil)` in that case, but rather `Nil.::(6)`.
    We can exhibit that into the REPL as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The evaluation of `5 :: 6 :: Nil` is therefore done by applying the `::` method
    on the `simpleList` that we saw earlier, which is `List(6)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: In this case, `5` was appended before `6`. Repeating this operation several
    times will give you the final `List(1,2,3,4,5,6)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This convenient way of expressing lists is not just for simple values such
    as integers but can be applied to any type. Moreover, we can concatenate two `List`
    instances by using the `:::` method in a similar way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'We can even mix elements of various types in the same `List`, for example,
    integers and Booleans, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'However, as you probably noticed, the result type `AnyVal` chosen by the compiler
    in that case is the first common type between integers and Booleans encountered
    in their hierarchy. For instance, retrieving only the Boolean element (at index
    two in the list) will return an element of type `AnyVal` rather than a `Boolean`
    value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if we put an element of type `String` within the list as well, we will
    get a different common type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The reason for that can be directly visualized by looking at the hierarchy
    of Scala types. Classes representing primitive types such as `Int`, `Byte`, `Boolean`,
    or `Char` belong to value types of `scala.AnyVal,` whereas `String`, `Vector`,
    `List`, or `Set` belong to reference types of `scala.AnyRef`, both being subclasses
    of the common type `Any`, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Transforming collections containing primitive types](img/3637_01_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The full hierarchy of Scala types is given in the official Scala documentation
    at [http://docs.scala-lang.org/tutorials/tour/unified-types.html](http://docs.scala-lang.org/tutorials/tour/unified-types.html).
  prefs: []
  type: TYPE_NORMAL
- en: Collections of more complex objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s manipulate objects that are more complex than integers. We can, for
    instance, create some collections of `Money` instances that we made earlier and
    experiment with them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Filter and partition
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Filtering elements of a collection is one of the most common operations and
    can be written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The parameter given to the `filter` method is a function that takes a `Money`
    item as the input and returns a `Boolean` value (that is, a predicate), which
    is the result of evaluating `money.currency=="EUR"`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `filter` method iterates over the collection items and applies the function
    to each element, keeping only the elements for which the function returns `True`.
    Lambda expressions are also referred to as **anonymous functions** because we
    could give any name we want to the input argument, for example, `x` instead of
    the `money` used previously, and still get the same output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'A slightly shorter way of writing this one-liner can be done using an `_` sign,
    a character that one encounters often when reading Scala code and that might seem
    awkward for a Java developer at first sight. It simply means "that thing", or
    "the current element". It can be thought of as the blank space or gap used to
    fill paper-based inquiries or passport registration forms, in the olden days.
    Other languages that deal with anonymous functions reserve other keywords, such
    as `it` in Groovy, or `self` in Python. The previous lambda example can be rewritten
    with the short underscore notation as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'A `filterNot` method also exists to keep elements for which the evaluation
    of the function returns `False`. Moreover, a `partition` method is available to
    combine both the `filter` and `filterNot` methods into one single call that returns
    two collections, one evaluating to `True` and the other to its complement, as
    shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Dealing with tuples
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Notice the return type of the partition result, `(List[Money],List[Money])`.
    Scala supports the concept of tuples. The preceding parenthesis notation denotes
    a `Tuple` type, which is a part of the standard Scala library and useful to manipulate
    several elements at once without having to create a more complex type for encapsulating
    them. In our case, `allAmounts` is a `Tuple2` pair containing two lists of `Money`.
    To access only one of the two collections, we just need to type the following
    expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'A cleaner and more natural syntax to achieve this as a one-liner, is the one
    that expresses the `partition` method without referring to `._1` and `._2`, as
    shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, as a result, we get two variables, `euros` and `everythingButEuros`,
    which we can reuse individually:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Introducing Map
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Another elegant usage of tuples is related to the definition of a `Map` collection,
    another structure that is part of the Scala collections. Similar to Java, the
    `Map` collection stores key-value pairs. In Java, a trivial `HashMap` definition
    that populates and retrieves elements of a `Map` collection with a couple of values
    can be written with a few lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Since no amount of GBP currency has been inserted into the `Map` collection,
    running this sample will return a `null` value for the `Pounds` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Populating a `Map` collection in Scala can be elegantly written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'The `"USD" -> 10` expression is a convenient way of specifying a key-value
    pair and is equivalent to the definition of a `Tuple2[String,Integer]` object
    in this case, as illustrated directly in the REPL (which could infer the type
    automatically):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'The process of adding and retrieving an element is very straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'However, accessing an element that is not included in the `Map` collection
    will throw an exception, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Introducing the Option construct
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A safer way to retrieve an element from the `Map` collection that was introduced
    in the previous section is to invoke its `.get()` method, which will instead return
    an object of type `Option`, a feature that is not currently available in Java.
    Basically, an `Option` type wraps a value into an object that can either return
    the type `None` if the value is null, or `Some(value)` otherwise. Let''s enter
    this in the REPL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: A glimpse at pattern matching
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Avoiding the throwing of an exception makes it convenient to continue handling
    the flow of an algorithm as an evaluated expression. It not only gives the programmer
    the freedom of sophisticated chaining of the `Option` values without having to
    check for the existence of a value, but also enables one to handle the two different
    cases via **pattern matching**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Pattern matching is an essential and powerful feature of the Scala language.
    We will look at more examples of it later on.
  prefs: []
  type: TYPE_NORMAL
- en: The `filter` and `partition` methods were just two examples of the so-called
    "higher-order" functions on lists, since they operate on containers of collection
    types (such as lists, sets, and so on) rather than the types themselves.
  prefs: []
  type: TYPE_NORMAL
- en: The map method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Among the collections'' methods that cannot be overlooked lies the `map` method
    (not to be confused with the `Map` object). Basically, it applies a function to
    every element of a collection, but instead of returning `Unit` for the `foreach`
    method, it returns a collection of a similar container type (for example, a `List`
    will return a `List` of the same size) that contains the result of transforming
    each element through the function. A very simple example is shown in the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'In Scala, you may define standalone functions as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: We have declared an `increment` function that takes an `Int` value as the input
    (denoted by `x`) and returns another `Int` value (`x+1`).
  prefs: []
  type: TYPE_NORMAL
- en: 'The previous `List` transformation can be rewritten slightly in a different
    manner as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Using a bit of syntactic sugar, the `.` sign in the method call, as well as
    the parenthesis on the function parameter can be omitted for readability, which
    leads to the following concise one-liner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Going back to our initial list of the `Money` amounts, we can, for example,
    transform them into strings as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Looking at String Interpolation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In Java, concatenating strings using a `+` operator, as we did in the previous
    line, is a very common operation. In Scala, a more elegant and efficient way to
    deal with the presentation of strings is a feature named **String Interpolation**.
    Available since Scala Version 2.10, the new syntax involves prepending a `s` character
    to the string literal as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Any variable in scope can be processed and embedded in a string. Formatting
    can even be more precise by using an `f` interpolator instead of `s`. In that
    case, the syntax follows the same style as that of the `printf` method of other
    languages, where, for instance, `%4d` means a four-digit formatting or `%12.2f`
    means a floating point notation with exactly twelve digits before the comma and
    two afterwards:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Moreover, the String Interpolation syntax enables us to embed the full evaluation
    of an expression, that is, a full block of code performing a calculation. The
    following is an example, where we want to display the value of our `many` variable
    twice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: The preceding block of code obeys the same rules as any method or function evaluation,
    meaning that the last statement in the block is the result. Although here we have
    a very simple computation, it is perfectly valid to include a multiline algorithm
    if needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Knowing the interpolation syntax, we can rewrite our previous `amounts` as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: The groupBy method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Another convenient operation is the `groupBy` method that transforms a collection
    into a `Map` collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: The foldLeft method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One last method that we would like to introduce here is the `foldLeft` method,
    which propagates some state from one element to the next. For instance, to sum
    elements in a list, you need to accumulate them and keep track of the intermediate
    counter from one element to the next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'The value `0` given as the first argument to `foldLeft` is the initial value
    (which means `total=0` when applying the function for the first `List` element).
    The `(total,element)` notation represents a `Tuple2` pair. Note, however, that
    for summation, the Scala API provides a `sum` method, so the last statement could
    have been written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This interactive chapter that introduced some of the commonly used operations
    on objects and collections was only a glimpse to demonstrate some of the expressiveness
    and powerful constructs of Scala.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to increasingly blend Scala with an existing
    standard Java web application. Since there are so many ways by which one can create
    a standard web application, combining some of the many frameworks and database
    technologies available, irrespective of whether they involve Spring, Hibernate,
    JPA, SQL, or NoSQL, we will take the straightforward path of some of the well-established
    JavaEE tutorials.
  prefs: []
  type: TYPE_NORMAL
