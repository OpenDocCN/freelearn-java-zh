- en: Designing and Structuring Java Enterprise Applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every piece of software is designed in a certain way. The design includes the
    architecture of the system, structure of the projects, and structure and quality
    of the code. It can either communicate the intentions well or obfuscate them.
    Engineers need to design an enterprise application or system, before it is implemented.
    In order to do that, the purpose and motivations of the software need to be clear.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: What aspects to focus on when developing software
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Project build structures and Java EE build systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to structure enterprise projects modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to realize module package structures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The purpose of enterprise applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Behind every action, be it in daily life, big organizations, or software projects,
    there should be a reason. We humans need reasons why we are doing things. In enterprise
    software development, there is no difference.
  prefs: []
  type: TYPE_NORMAL
- en: When we build software applications, the first question asked should be *why?*.
    Why is this piece of software needed? Why is it reasonable or required to spend
    time and effort to develop a solution? And why should the company care about developing
    that solution itself?
  prefs: []
  type: TYPE_NORMAL
- en: In other words, what is the application's purpose? What problem is this piece
    of software trying to solve? Do we want the application to implement an important
    business process? Will it generate revenue? Is it going to gather revenue directly,
    for example by selling products, or indirectly by marketing, supporting customers,
    or business processes? Are there other possibilities to support customers, employees,
    or business processes?
  prefs: []
  type: TYPE_NORMAL
- en: These and other questions target the application's business goals. Generally
    speaking, every piece of software needs a justification in the overall picture
    before we invest time and effort into it.
  prefs: []
  type: TYPE_NORMAL
- en: The most obvious legitimization is to implement necessary business use cases.
    These use cases bring certain value for the overall business and will sooner or
    later realize features and generate revenue. At the end of the day, the software
    should achieve the goal of implementing the business use cases as best as possible.
  prefs: []
  type: TYPE_NORMAL
- en: What developers should focus on
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Therefore, software developers as well as project managers should first focus
    on meeting the business concerns and implementing the use cases.
  prefs: []
  type: TYPE_NORMAL
- en: This clearly sounds obvious, but too often the focus of enterprise projects
    starts drifting away into other concerns. Developer effort is spent on implementation
    details or features that have little benefit for solving the actual problem. How
    many logging implementations, home-grown enterprise frameworks, or over-engineered
    levels of abstractions have we seen in the past?
  prefs: []
  type: TYPE_NORMAL
- en: Non-functional requirements, quality of software, and so-called cross-cutting
    concerns are in fact an important aspect of software development. But the first
    and main focus of all engineering effort should be directed to meeting the business
    requirements and developing software that actually has a purpose.
  prefs: []
  type: TYPE_NORMAL
- en: Meeting customer's demands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have the following questions:'
  prefs: []
  type: TYPE_NORMAL
- en: What is the application's business purpose?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are the most important features that users care about?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Which aspects will generate revenue?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The answers to these questions should be known to the stakeholders. If not,
    then the correct way would be to take a step back, look at the overall picture
    of the software landscape, and reconsider the software's right to exist. Not in
    all cases the motivation will be purely business-driven. There are, in fact, a
    lot of cases where we will implement solutions that do not directly generate revenue
    but do so indirectly, by supporting others. These cases are certainly necessary
    and we will cover them and the general topic of how to construct reasonable system
    landscapes in Chapter 8, *Microservices and System Architecture*.
  prefs: []
  type: TYPE_NORMAL
- en: Besides these supporting software systems, we focus on business aspects. Having
    this main goal in mind, the first thing to address is how to model the business
    use cases and transform them into software. Only after that, the use cases are
    implemented using certain technologies.
  prefs: []
  type: TYPE_NORMAL
- en: These priorities will also reflect the customer demands. The application's stakeholders
    care about software that fulfills its purpose.
  prefs: []
  type: TYPE_NORMAL
- en: Software engineers tend to see this differently. They care about implementation
    details and the elegance of solutions. Engineers are often passionate about certain
    technologies and spend much time and effort choosing the right solutions as well
    as implementing them well. This includes a lot of technical cross-cutting concerns,
    such as logging, and so-called over-engineering, which is not mandatory for the
    business domain. Embracing software craftsmanship certainly has its importance
    and is essential for writing better software, but many times it is orthogonal
    to the client's motivations. Before spending time and effort with implementation
    details, engineers should be aware of the client's demands first.
  prefs: []
  type: TYPE_NORMAL
- en: Project timeline requirements are another aspect to consider. Software teams
    weigh business use cases against the quality of technical solutions. They tend
    to postpone required software tests or quality measures in order to meet deadlines.
    The technology used to implement the business application should support effective
    and pragmatic development.
  prefs: []
  type: TYPE_NORMAL
- en: When seeing the enterprise world through the eyes of a paying customer or a
    manager with limited time and budget, software engineers will likely understand
    their priorities. Caring about revenue-generating use cases first is mandatory.
    Technical necessities beyond these are seen by customers and managers as a *necessary
    evil*.
  prefs: []
  type: TYPE_NORMAL
- en: The rest of this book will show you how to meet and balance these two motivations
    with Java EE.
  prefs: []
  type: TYPE_NORMAL
- en: Outer enterprise project structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having the goal of business use cases in mind, let's move our focus a bit more
    down to earth to real-world enterprise projects. In later chapters, we will see
    what methods are there to help us reflecting the business domains in the architecture
    in a suitable way.
  prefs: []
  type: TYPE_NORMAL
- en: Business and team structures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Software projects are usually developed by a team of engineers, software developers,
    or architects. For simplicity, we will call them developers. Software developers,
    architects, testers, and all kind of engineers should arguably program from time
    to time.
  prefs: []
  type: TYPE_NORMAL
- en: However, in most situations we have several people working simultaneously on
    a software project. This already requires us to take a few things into account,
    mainly communication and organizational overhead. When we look at the structure
    within organizations with several teams working on multiple projects, or temporarily
    even the same project, we deal with even more challenges.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Conway''s law claims that:'
  prefs: []
  type: TYPE_NORMAL
- en: Organizations which design systems [...] are constrained to produce designs
    which are copies of the communication structures of these organizations.
  prefs: []
  type: TYPE_NORMAL
- en: '- Melvin Conway'
  prefs: []
  type: TYPE_NORMAL
- en: That being said, the way in which the teams are organized and communicate with
    each other will inevitably leak into software design. The organization chart of
    developers and their effective communication structures has to be considered when
    constructing software projects. We will have a detailed look into how to construct
    several distributed systems and more specific microservices in Chapter 8, *Microservices
    and System Architecture*.
  prefs: []
  type: TYPE_NORMAL
- en: Even in a single project owned by a team of few developers, there will likely
    be multiple features and bug fixes being developed simultaneously. This fact impacts
    how we plan the iterations, organize, and integrate source code, and build and
    deploy runnable software. In particular [Chapter 6](599c6821-8971-4489-931c-9e11b5e23afd.xhtml),
    *Application Development Workflows* and Chapter 7, *Testing* will cover this topic.
  prefs: []
  type: TYPE_NORMAL
- en: Software projects contents
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Enterprise software projects include several artifacts necessary to build and
    ship applications. Let's have a closer look at them.
  prefs: []
  type: TYPE_NORMAL
- en: Application source code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First of all, all enterprise applications, like probably any application, are
    written in source code. The source code is arguably the most important part of
    our software project. It represents the application and all its functionality
    at its core and can be seen as the single source of truth of software behavior.
  prefs: []
  type: TYPE_NORMAL
- en: The project's sources are separated into code that runs on production and test
    code to verify the application's behavior. The technologies as well as the quality
    demands will vary for test and production code. In Chapter 7, *Testing*, we will
    deeply cover the technologies and structures of software tests. Apart from that
    chapter, the focus of this book lies on production code, which is shipped and
    which handles the business logic.
  prefs: []
  type: TYPE_NORMAL
- en: Software structures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The software project organizes the source code in certain structures. In Java
    projects, we have the possibility to cluster components and responsibilities into
    Java packages and project modules, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a3993e8c-d3db-4403-a5ca-129fcb4b833a.png)'
  prefs: []
  type: TYPE_IMG
- en: Structuring these components is obviously less a technical rather than an architectural
    necessity. Code that is packaged arbitrarily would technically run equally well.
    However, this structure helps engineers understanding the software and its responsibilities.
    By clustering software components that fulfill coherent features, we increase
    cohesion and achieve a better organization of the source code.
  prefs: []
  type: TYPE_NORMAL
- en: This and the next chapter will discuss the benefits of *Domain-Driven Design*,
    described in the book by Eric Evans, and the why and how to organize code in business-driven
    packages. For now, let's record that we group coherent components that form logical
    features into logical packages or project modules.
  prefs: []
  type: TYPE_NORMAL
- en: Java SE 9 comes with the possibility of shipping modules as Java 9 modules.
    These modules are, in essence, similar to the JAR files with the ability to declare
    dependencies and usages restrictions of other modules. Since this book is targeted
    for Java EE 8 and since the fact that the usage of Java 9 modules hasn't spread
    yet in real-world projects, we will cover only Java packages and project modules.
  prefs: []
  type: TYPE_NORMAL
- en: Breaking the structure of software projects further down, the next smaller unit
    of software components is a Java class. Classes and the responsibilities thereof
    encapsulate single functionalities in the domain. They are ideally loosely coupled
    and show a high cohesion.
  prefs: []
  type: TYPE_NORMAL
- en: A lot has been written about clean code practices and representing functionality
    in source code. The book *Clean Code* by Robert C. Martin, for example, explains
    methods such as proper naming or refactoring, that help achieve well-crafted source
    code in packages, classes and methods.
  prefs: []
  type: TYPE_NORMAL
- en: Version control systems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The source code is kept under version control, since most software projects
    require coordination of simultaneous code changes, made by multiple developers.
    **Version control systems** (**VCS**) have established themselves as mandatory
    to reliably coordinate, track, and comprehend changes in software systems.
  prefs: []
  type: TYPE_NORMAL
- en: There are a lot of choices of version control systems, such as Git, Subversion,
    Mercurial or CVS. In the last years, **distributed revision control** systems,
    particularly **Git**, have been widely accepted as the state-of-the-art tools.
    They use a so-called *hash tree*, or *Merkle tree* to store and resolve individual
    commits, which enables efficient *diffs* and *merges*.
  prefs: []
  type: TYPE_NORMAL
- en: Distributed VCS enables developers to work with project repositories in distributed
    ways, without constantly requiring a network connection. Every workstation has
    its own repository, which includes the full history and is eventually synchronized
    with the central project repository.
  prefs: []
  type: TYPE_NORMAL
- en: As of writing this book, the vast majority of software projects use Git as version
    control system.
  prefs: []
  type: TYPE_NORMAL
- en: Binaries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The VCS project repository should only contain the sources that are produced
    and maintained by developers. Certainly, enterprise applications will have to
    be deployed as some kind of binary artifacts. Only these shippable binaries can
    be executed as runnable software. The binaries are ultimately the outcome of the
    development and build process.
  prefs: []
  type: TYPE_NORMAL
- en: In the Java world this means that the Java source code is compiled to portable
    bytecode and is usually packaged as **Web Application Archive** (**WAR**) or **Java
    Archive** (**JAR**), respectively. WAR or JAR files comprise all classes and files
    required to ship an application, framework dependency, or library. The **Java
    Virtual Machine** (**JVM**) finally executes the bytecode and together with that,
    our business functionality.
  prefs: []
  type: TYPE_NORMAL
- en: In enterprise projects the deployment artifacts, the WAR or JAR files, are either
    deployed to an application container or already ship the container themselves.
    The application container is needed, since beside their distilled business logic,
    enterprise applications will have to integrate additional concerns, such as application
    life cycle or communication in various forms. For example, a web application that
    implements certain logic but is not addressable over HTTP communication has little
    value. In Java Enterprise, the application container is responsible for providing
    this integration. The packaged application contains the distilled business logic
    and is deployed to a server, which takes care of the rest.
  prefs: []
  type: TYPE_NORMAL
- en: In recent years, more Linux container technologies such as Docker have emerged.
    This carries the ideas of shippable binaries even further. The *binary* then not
    only contains the packaged Java application, but all components required to run
    the application. This, for examples, includes an application server, the Java
    Virtual Machine, and required operating system binaries. We will discuss the topic
    of shipping and deploying enterprise applications, especially regarding container
    technology, in [Chapter 4](f0a49441-e411-49c4-a4b6-c6193ba36094.xhtml), *Lightweight
    Java EE*.
  prefs: []
  type: TYPE_NORMAL
- en: The binaries are produced as part of the software build process. It enables
    to reliably recreate all binaries from the repository's sources. Therefore, the
    binaries should not be kept under version control. The same is true for generated
    source code. In the past, for example, JAX-WS classes which are required for SOAP
    communication were usually generated from descriptor files. Generated source code
    is created during the build process and should also not be kept under version
    control. The idea is to keep only the distilled source code in the repository
    and no artifacts that can be derived from it.
  prefs: []
  type: TYPE_NORMAL
- en: Build systems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The build process is first of all responsible for compiling the sources of a
    Java software project into bytecode. This happens every time changes have been
    made to the project. All modern build systems ship with useful conventions to
    minimize the required configuration.
  prefs: []
  type: TYPE_NORMAL
- en: In the enterprise world, with all its different frameworks and libraries, an
    important step is to organize and define all dependencies on APIs and implementations.
    Build tools such as **Apache Maven** or **Gradle** support developers by including
    powerful dependency resolution mechanisms. The build tool adds all the dependencies
    with the corresponding versions required to compile or run the application, respectively.
    This simplyfies to setup the project among multiple developers. It also enables
    repeatable builds.
  prefs: []
  type: TYPE_NORMAL
- en: Packaging the compiled classes and their dependencies into deployment artifacts
    is also part of the build process. Depending on the used technology the artifacts
    are packaged as WAR or JAR files. [Chapter 4](f0a49441-e411-49c4-a4b6-c6193ba36094.xhtml),
    *Lightweight Java EE* will discuss the different ways of packaging Java enterprise
    applications together with their pros and cons.
  prefs: []
  type: TYPE_NORMAL
- en: The topics, *Gradle* and *Apache Maven*, will discuss the implementation and
    differences of the two main build systems in more depth.
  prefs: []
  type: TYPE_NORMAL
- en: Single versus multi-module projects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As said before, we can organize the application's source code in Java packages
    and project modules, respectively. Project modules group related functionality
    together into separately buildable sub-projects. They are usually specified by
    the build systems.
  prefs: []
  type: TYPE_NORMAL
- en: At first, the motivations behind splitting up project modules are quite understandable.
    Grouping Java code and packages into related modules creates a clearer view for
    the developers, enables a better structure, and increases cohesion.
  prefs: []
  type: TYPE_NORMAL
- en: Another reason for multi-modules is build time performance. The more complex
    our software project becomes the longer it will take to compile and package it
    into artifacts. Developers mostly touch few locations in the projects at a time.
    Therefore, the idea is to not always rebuild the whole project, but only the modules
    necessary in order to apply the desired changes. This is an advertised advantage
    of the Gradle build system, to save time by rebuilding only what has changed.
  prefs: []
  type: TYPE_NORMAL
- en: Another argument for this practice is the possibility of reusing certain sub-modules
    in several projects. By building sub-projects into self-sufficient artifacts we
    could possibly take and include a sub-artifact in another software project. For
    example, a common practice is to design a *model* module that contains the entities
    of the business domain, usually as standalone **plain old Java objects** (**POJOs**).
    This model would be packaged to a JAR file and reused as a dependency in other
    enterprise projects.
  prefs: []
  type: TYPE_NORMAL
- en: There are, however, some drawbacks, or rather, illusions to this practice.
  prefs: []
  type: TYPE_NORMAL
- en: Illusion of reusability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have to remind ourselves that software projects are built by teams of developers
    and the project structure will therefore adhere to their communication structures.
    Reusing certain modules within several projects requires quite a bit of coordination.
  prefs: []
  type: TYPE_NORMAL
- en: Technical dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A project's module that is subject to be reused has to meet specific criteria.
    First of all the technology of the shared modules has to match the target project.
    This sounds obvious, but has quite some implications on the implementation details.
    Especially used libraries and frameworks will inevitably cause the involved modules
    to be coupled and dependent on the specific technology. For example, model classes
    in Java EE typically contain annotations from APIs such as JPA that need to be
    available in all dependent modules.
  prefs: []
  type: TYPE_NORMAL
- en: Third-party dependencies with specific versions that are required for a shared
    module to function correctly have even more technical impact. These dependencies
    then have to be available at runtime and must not collide with other dependencies
    or versions thereof. This can cause a lot of headache with colliding dependencies
    that are already available on the server. The same holds true for implementation
    details that contain implicit dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: A typical example of this is JSON mapping libraries such as Jackson or Gson.
    A lot of third-party dependencies use these libraries in specific versions that
    might collide with other dependencies or versions at runtime. Another example
    is logging implementations such as **Logback** or **Log4j**.
  prefs: []
  type: TYPE_NORMAL
- en: In general, shared models should be as self-sufficient as possible or at least
    contain only stable dependencies that won't likely drift into these issues. A
    good example for a very stable dependency is the Java EE API. Because of the backwards-compatible
    nature of the Enterprise Edition, usage of the API and resulting functionality
    won't break if a newer version is introduced.
  prefs: []
  type: TYPE_NORMAL
- en: But even if the Java EE API is the only dependency of shared modules, it will
    bind the model to a specific version and reduce the freedom to change.
  prefs: []
  type: TYPE_NORMAL
- en: Organizational challenges
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Shared technology and dependencies come with organizational challenges. The
    greater the number of developers and teams, respectively, the bigger the impact
    of used technology and dependencies. Teams have to agree upon certain technology,
    used frameworks and libraries and versions thereof.
  prefs: []
  type: TYPE_NORMAL
- en: If a single teams want to change something in this graph of dependencies or
    some of the used technologies, this change requires a lot of coordination and
    overhead. Chapter 8, *Microservices and System Architecture*, covers this topic
    of sharing code and artifacts within several systems and whether this is advisable
    or not.
  prefs: []
  type: TYPE_NORMAL
- en: Reusability considerations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The trade-off is always reusability and having to deal with these issues versus
    simplicity and potential duplication. Depending on the level of self-sufficiency,
    the choice will be made toward one or the other. Generally speaking, the cost
    of coordinating dependencies, versions, and technology, outweighs the benefits
    of avoiding redundancy.
  prefs: []
  type: TYPE_NORMAL
- en: An important question to be asked, however, is how the projects modules are
    layered either vertically or horizontally. An example for horizontal layering
    is the typical three-tier architecture of clustering into a *presentation*, *business*
    and *data layer*. Vertical layering means to group functionality based on their
    business domain. Examples would be modules for accounts, orders or articles, including
    all technical requirements such as HTTP endpoints or database access. Both types
    of modules can potentially be reused.
  prefs: []
  type: TYPE_NORMAL
- en: In reality horizontal layered modules like models are more likely subject to
    be shared among other projects. These types of modules naturally have a smaller
    variety of dependencies, ideally zero. On the contrary, vertical layered modules
    will contain implementation details and expect certain circumstances, for example,
    how the container is configured. And again, it depends a lot on the technology
    being used within the modules that are subject to share.
  prefs: []
  type: TYPE_NORMAL
- en: Project artifacts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's take a step back and look at the deployment artifacts of our enterprise
    application. Typically, an application results in a single artifact that will
    run our software. Even with several multi-modules being used at the end of the
    day, these will boil down to a single or few artifacts. So, in most of the cases
    all of this structure is flattened again into single JAR or WAR files. Looking
    at the reusability of modules, which is not necessarily being given, this raises
    the question of whether we need several modules per project at all. At the end
    of the day, introducing and managing sub-projects, vertical or horizontal, will
    require certain developer effort.
  prefs: []
  type: TYPE_NORMAL
- en: It is true that splitting up the code base can improve build performance if
    only sub-projects that have been changed are rebuilt. However, in the sub-chapters
    *Apache Maven* and *Gradle* and [Chapter 4](f0a49441-e411-49c4-a4b6-c6193ba36094.xhtml),
    *Lightweight Java EE* we will see that building a single reasonably designed project
    into a single artifact is sufficiently fast and that there are usually other aspects
    responsible for making builds slow.
  prefs: []
  type: TYPE_NORMAL
- en: One project per artifact
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is advisable to package the enterprise project into a single deployment artifact
    that emerges from a single project module. The number and structure of deployment
    artifacts then maps the structure of the software projects. If other artifacts
    emerge from the project, they are organized in separate project modules as well.
    This enables an understandable and lightweight project structure.
  prefs: []
  type: TYPE_NORMAL
- en: Usually, an enterprise project will result in a shippable JAR or WAR file, originating
    from a single project module. Yet sometimes, we do have good reasons to create
    modules that are shared among projects. These are then sensibly crafted as own
    project modules that build own artifacts, for example JAR files.
  prefs: []
  type: TYPE_NORMAL
- en: There are still other motivations for multi-module projects. System tests that
    verify a deployed enterprise application from the *outside* don't necessarily
    have dependencies on the production code. It makes sense, in some situations,
    to organize these tests in separate project modules that are part of a multi-module
    project.
  prefs: []
  type: TYPE_NORMAL
- en: Another example is frontend technologies that are just loosely coupled to the
    backend application. With modern client-centric JavaScript frameworks being used
    more and more, the coupling to the backend also decreases. The workflow and life
    cycle of developing frontends can vary from the backend application. Therefore,
    it can make sense to split the technology into several sub-projects or even several
    software projects. The topic, *Structuring for modern frontend technologies*,
    covers how to tackle these situations.
  prefs: []
  type: TYPE_NORMAL
- en: These situations, however, also fit the concept of mapping *artifacts* in the
    broader sense to project modules. A system test project is used and executed separately
    from the production code. Developing and building the frontend project could equally
    be differ from the backend part. There may be some other situations where it is
    advisable as well.
  prefs: []
  type: TYPE_NORMAL
- en: Build systems for Java EE
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The project modules are specified as modules of the build system. Whether we
    can follow the straightforward way of having a single project or multiple projects;
    for example, motivated by system tests, we will build and execute them as part
    of the build process.
  prefs: []
  type: TYPE_NORMAL
- en: A good build system needs to ship certain features. The main task of it is to
    compile the sources and package the binaries as artifacts. Required dependencies
    are also resolved and used for compilation or packaged, respectively. There are
    several scopes where dependencies are required, such as during compilation, testing,
    or runtime. Different scope definition specify whether dependencies are shipped
    with the artifact.
  prefs: []
  type: TYPE_NORMAL
- en: The project should be built in a reliable, reproducible way. Several builds
    with identical project contents and build configuration must produce the same
    results. This is important for implementing **Continuous Delivery** (**CD**) pipelines,
    which enable reproducible builds. That said the build system must be able to run
    on a **Continuous Integration** (**CI**) server, such as **Jenkins** or **TeamCity**.
    This requires the software to ship a command-line interface, especially for Unix-based
    systems. [Chapter 6](599c6821-8971-4489-931c-9e11b5e23afd.xhtml), *Application
    Development Workflows*, will show the motivations behind Continuous Delivery.
  prefs: []
  type: TYPE_NORMAL
- en: The build system will be used by software engineers working on various environments
    and operating systems, which should be supported as well. For JVM-based build
    systems this portability is usually given. It may be the case that projects have
    specific requirements such as native code that needs to be built on specific environments.
    For Java enterprise applications, however, this is usually not the case.
  prefs: []
  type: TYPE_NORMAL
- en: In general the build process should run as fast as possible. Booting up and
    configuring the build system should not require much time. The longer the build
    takes the higher the turnaround times and the slower the feedback engineers get
    from the build pipeline. In [Chapter 4](f0a49441-e411-49c4-a4b6-c6193ba36094.xhtml),
    *Lightweight Java EE,* we will cover more of this topic.
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing, Apache Maven is the most used build system well known
    to the majority of Java developers.
  prefs: []
  type: TYPE_NORMAL
- en: Maven is a Java-based build system configured by XML. It's projects are defined
    by a so-called **project object model** (**POM**). Maven makes use of a **convention
    over configuration** approach that minimizes the required configuration. The default
    configuration is well suited for Java applications.
  prefs: []
  type: TYPE_NORMAL
- en: Another build tool with high usage is Gradle. Gradle is a build tool that offers
    a Groovy-based **Domain-Specific Language** (**DSL**) to configure fully extensible
    and scriptable project builds. Since Groovy is a full programming language Gradle
    build scripts are naturally powerful and flexible.
  prefs: []
  type: TYPE_NORMAL
- en: Both Gradle and Maven include a sophisticated dependency management and are
    well suited to build Java-based projects. There are certainly still other build
    systems, such as SBT, however, Gradle and Maven are, by far, the most-used ones
    and will be covered in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Apache Maven
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Apache Maven is widely used in Java-based projects and known to the vast majority
    of enterprise developers. The wide-spread usage and the familiarity of this tool
    is certainly a benefit.
  prefs: []
  type: TYPE_NORMAL
- en: Maven is based on a **convention over configuration** approach which simplifies
    straightforward use cases. Maven's configuration, however, does not always provide
    flexibility. In fact, this inflexibility is sometimes a feature. Since it's cumbersome
    to change the default Maven project structure and build process, most of the Java
    enterprise projects come in a very similar and familiar way. New developers easily
    find their way through the project's build configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following snippet shows a typical example of a Maven project structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d1e10bd8-29c3-43a9-93eb-4151e67d690e.png)'
  prefs: []
  type: TYPE_IMG
- en: This will seem familiar to the majority of enterprise Java developers. This
    example web application is packaged as a WAR file.
  prefs: []
  type: TYPE_NORMAL
- en: One of the shortcomings of Apache Maven is its somewhat nontransparent way of
    defining used build plugins and dependencies thereof. Using the default build
    convention without explicitly specifying versions for plugins such as the **Maven
    Compiler Plugin** can result in unwanted changes of used versions. This violates
    the principle of repeatable builds.
  prefs: []
  type: TYPE_NORMAL
- en: Because of this, projects that require reproducibility often explicitly specify
    and override the plugin dependency versions in the POMs. By doing so, projects
    will be built using the same versions all the time, even if the default plugin
    versions change.
  prefs: []
  type: TYPE_NORMAL
- en: Super POM definitions are another common solution to specify exact plugin versions.
    Project POMs can inherit from parent projects and reduce boilerplate plugin definitions.
  prefs: []
  type: TYPE_NORMAL
- en: Developers can use the *effective POM* view that shows the resulting POM, after
    applying the default configuration and potential inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: 'A typical issue with Maven POMs is that enterprise projects very often overuse
    the XML definitions. They prematurely introduce plugins or configuration that
    already would be covered by the build conventions. The following snippet shows
    the minimum POM requirements for a Java EE 8 project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The *car manufacture* application is built into a WAR artifact. The `finalName`
    overrides the implied name of the WAR file, here resulting in `car-manufacture.war`.
  prefs: []
  type: TYPE_NORMAL
- en: The specified Java EE 8 API is the only production dependency that a straightforward
    enterprise solution requires. [Chapter 4](f0a49441-e411-49c4-a4b6-c6193ba36094.xhtml),
    *Lightweight Java EE* will deeply cover the topic of project dependencies and
    their impact.
  prefs: []
  type: TYPE_NORMAL
- en: The provided `properties` tag removes the need to explicitly configure the build
    plugins. Maven plugins per convention uses properties for configuration. Specifying
    these will reconfigure the used plugin without needing to explicitly declare the
    full definitions.
  prefs: []
  type: TYPE_NORMAL
- en: The properties cause the project to be built using Java SE 8, with all source
    files considered to be encoded as UTF-8\. The WAR file doesn't need to ship a
    `web.xml` deployment descriptor; this is why we instruct Maven not to fail the
    build on a missing descriptor. In the past, the Servlet API required deployment
    descriptors in order to configure and map the application's Servlets. Since the
    advent of Servlet API version 3, `web.xml` descriptors are not necessarily required
    anymore; Servlets are configurable using annotations.
  prefs: []
  type: TYPE_NORMAL
- en: Maven defines its build process in several phases, such as *compile*, *test*,
    or *package*. Depending on the chosen phase, multiple steps will be executed.
    For example, triggering the *package* phase will compile the `main` as well as
    `test` sources, run the test cases, and package all classes and resources into
    the artifact.
  prefs: []
  type: TYPE_NORMAL
- en: The Maven build commands are triggered in the IDE or the `mvn` command line,
    for example, as `mvn package`. This command triggers the *package* phase, resulting
    in a packaged artifact. More details on phases and functionality of Apache Maven
    can be found under its official documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Gradle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At the time of writing, Gradle is less commonly used in Java enterprise projects
    than Apache Maven. This may be due to enterprise developers often being unfamiliar
    with dynamic JVM languages such as Groovy, which Gradle uses as its build script
    language. However, writing Gradle build files doesn't require deep knowledge of
    Groovy.
  prefs: []
  type: TYPE_NORMAL
- en: Gradle comes with quite a few benefits, most importantly its flexibility. Developers
    can leverage the full power of a programming language in order to define and potentially
    customize the project build.
  prefs: []
  type: TYPE_NORMAL
- en: Gradle will keep a daemon running in the background, that is being reused after
    the first build, to speed up subsequent build executions. It also keeps track
    of build inputs and outputs, whether changes have been made since the last build
    execution. This enables the system to cache steps and decrease the development
    build time.
  prefs: []
  type: TYPE_NORMAL
- en: However, depending on the complexity of the project and its used dependencies
    this optimization might not even be required. [Chapter 4](f0a49441-e411-49c4-a4b6-c6193ba36094.xhtml),
    *Lightweight Java EE* will cover the impact of project dependencies and zero-dependency
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following snippet shows the build structure of a Gradle project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/46247618-3f58-4403-b4fc-0da571e05ade.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the structure is quite similar to Maven projects, with the difference
    being that built binaries are per default placed into the `build` directory.
  prefs: []
  type: TYPE_NORMAL
- en: It's common for Gradle projects to include a wrapper script for environments
    that have no Gradle installations.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code demonstrates an example of a `build.script` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Gradle build tasks are triggered via the command line, using `gradle` or the
    provided wrapper scripts. Executing `gradle build`, for example, is the analog
    of `mvn package`, compiling the sources, executing tests and building the artifact.
  prefs: []
  type: TYPE_NORMAL
- en: There are certain benefits of having a fully-fledged programming language defining
    the build files. With the build scripts being treated as code, developers are
    encouraged to apply clean code principles for definitions that become too complex.
    Sophisticated build steps can, for example, be refactored into several, readable
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: However, this power also brings the danger of over-engineering the build. As
    said, the inflexibility of Apache Maven can be considered a feature; the possibility
    of easily customizing build scripts eventually leads to build definitions that
    are very specific to the project. Compared to Maven, overly-customized builds
    can be an obstacle for developers who are unfamiliar with the project.
  prefs: []
  type: TYPE_NORMAL
- en: Experience shows that the vast majority of enterprise project builds are quite
    similar. This raises the question of whether the flexibility Gradle provides is
    required. Projects that don't have any special requirements, unlike for example
    product development, are sufficiently covered using Maven as build system.
  prefs: []
  type: TYPE_NORMAL
- en: The rest of this book will thus use Maven when a build system is required as
    an example. All code examples, however, are equally well suited to use Gradle.
  prefs: []
  type: TYPE_NORMAL
- en: Structuring for modern frontend technologies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After shedding light on modern build systems for enterprise systems, let's have
    a look at how to integrate frontend technologies into the backend.
  prefs: []
  type: TYPE_NORMAL
- en: Traditionally, this was pretty straightforward. The frontend of web applications
    were, in most of the cases, server-side rendered HTML pages, powered by JSP or
    JSF. The HTML was crafted on the server on demand, that is, on request, and returned
    to the client. In order to realize that, the JSP or JSF pages, respectively, have
    to reside on the backend. Therefore, the whole enterprise application would be
    shipped and deployed as single artifact.
  prefs: []
  type: TYPE_NORMAL
- en: Enter JavaScript frameworks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With new frontend technologies, basically sophisticated JavaScript frameworks,
    and especially single page applications, this premise has changed quite a bit.
    The web frontend frameworks became more and more client-centric and included much
    more business logic than in the past. On the server side this meant that the interaction
    between backend and frontend moved from fine grained methods to more coarse grained,
    business use case methods.
  prefs: []
  type: TYPE_NORMAL
- en: So, the more client-centric and powerful the JavaScript frameworks became, the
    more the communication between frontend and backend went from tightly coupled
    requests and responses to a more *API-like* usage, typically JSON via HTTP. This
    also meant that the server-side became more client-agnostic. For example, communicating
    solely via *RESTful-like*, JSON-format APIs enables native or mobile clients such
    as smartphones to use the same API like the frontend does.
  prefs: []
  type: TYPE_NORMAL
- en: We have seen this movement in a lot of enterprise projects. However, one could
    argue about the relevance of putting more and more logic into the client side
    or whether a hybrid solution of having some parts rendered on the server-side
    and some on the client-side is more appropriate. Without going too much into this
    topic, let us look at a few key points.
  prefs: []
  type: TYPE_NORMAL
- en: Preparation of data or content will be performed faster on the server-side.
    There are more capabilities and resources available than on the client. The server
    can also utilize features such as caching and use the advantage of *seeing* the
    whole picture.
  prefs: []
  type: TYPE_NORMAL
- en: Sophisticated frontend technologies often include a navigation logic that makes
    use of so-called *hashbang* pages. An example of a hashbang page URL is `/car-manufacture/#!/cars/1234`.
    These pages, for example, *car 1234*, do not reside on the server, but are only
    rendered on the client-side. The URL of that sub-page is determined after the
    hash-sign, which is not taken into account while requesting resources over HTTP.
    That means that the client requests a generic *entry page* that then does the
    whole navigation logic including rendering sub-pages. This clearly reduces the
    number of requests, but has the drawback that the server cannot support preparing
    or pre-rendering content; everything happens on the client-side. There have been
    big companies such as Twitter that originally pursued this approach but went away
    from it again, due to this reason. In particular, viewing these pages on mobile
    devices comes with certain challenges. With potential slow mobile connections
    and less computing power, rendering and executing sophisticated client-logic on
    these devices do take longer than displaying pre-rendered HTML.
  prefs: []
  type: TYPE_NORMAL
- en: Compared to statically typed, high-level languages such as Java, JavaScript
    frontends do have the issue that dynamically typed languages introduce more potential
    errors while programming that would have been prevented by a compiler. Because
    of this reason, we have seen more sophisticated frontend technologies such as
    TypeScript emerging, which introduced static types and higher language features
    that are processed into JavaScript again.
  prefs: []
  type: TYPE_NORMAL
- en: Organizing modern frontends
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: However, no matter which specific frontend technology is chosen, enterprise
    projects do have more sophisticated frontends than in the past. This comes with
    new challenges of how to organize the daily development work. Typically the work
    cycles of the frontend and the backend will vary slightly. Some developers will
    typically see themselves more on the backend and others more on the frontend side.
    Even if the team solely consists of *full-stack* developers, some de-facto roles
    are likely to emerge over time.
  prefs: []
  type: TYPE_NORMAL
- en: Depending on the used technology it therefore makes sense to separate the frontend
    into a single project. As said before, as soon as some part of the software is
    shipped individually or has different life cycles than the rest, it makes sense
    to create a dedicated project module.
  prefs: []
  type: TYPE_NORMAL
- en: If the frontend technology can be deployed without any backend dependencies
    other than the HTTP usage, organizing the project is pretty straightforward. The
    project can be built and deployed on a web server individually and will use one
    or several backends from the client side. This project then only consists of static
    resources, such as HTML, JavaScript, or CSS files, which are transferred to the
    client and executed there. There will be no tight technical dependencies to the
    used backends, besides the HTTP API.
  prefs: []
  type: TYPE_NORMAL
- en: This aspect clearly has to be communicated well upfront during development,
    as well as documented on the backend side. Typically, the backend defines HTTP
    resources that serve required content in JSON format, which can optionally be
    filtered by query parameters if necessary. The reason behind the JSON format being
    popular is that JavaScript client code can use the response directly as JavaScript
    objects without any other transformation required.
  prefs: []
  type: TYPE_NORMAL
- en: If the frontend will be deployed together with the backend as a single artifact
    the project structure requires more coordination. The artifact contains both layers
    of technology and compiles and packages both at build time. During development
    this combination isn't necessarily helpful if the cycles of developing the frontend
    vary from the backend side. A programmer currently focusing on the frontend side
    probably doesn't want to build the backend part each and every time. The same
    is true with the backend technology waiting for potentially slow JavaScript compilation
    and packaging.
  prefs: []
  type: TYPE_NORMAL
- en: In these cases, it makes sense to split the project into several modules that
    can be built individually. What has proven itself well is to package the frontend
    module as an individual module and to introduce it as a dependency of the backend
    module, which then will package it altogether. By doing this, the frontend module
    clearly can be built individually, whereas a backend developer can rebuild the
    backend part as well by using their latest version of the frontend. Therefore,
    build times are reduced on both sides.
  prefs: []
  type: TYPE_NORMAL
- en: To realize this feature, the Servlet API can deliver static resources that are
    packed not only in the archive, but also in contained JAR files. Resources that
    reside under `META-INF/resources` of a JAR file that is contained in the WAR file,
    are delivered by the Servlet container, as well. The frontend project contains
    all its required frontend technology, framework and tools, and builds a separate
    JAR file.
  prefs: []
  type: TYPE_NORMAL
- en: This enables developers to separate the frontend from the backend project to
    adapt to different life cycles.
  prefs: []
  type: TYPE_NORMAL
- en: The rest of this book will focus on the backend technology and business use
    cases that are accessible via machine to machine communication such as web services.
  prefs: []
  type: TYPE_NORMAL
- en: Enterprise project code structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After seeing how we can organize our enterprise project structure, let's have
    a closer look at the detailed structure within a project. Assuming we have modeled
    an enterprise system that is reasonable in size and responsibility, we now map
    the concerns of the project into code structures.
  prefs: []
  type: TYPE_NORMAL
- en: Previously, we have discussed vertical versus horizontal module layers. This
    is precisely one of the aspects we need to look into when structuring the project.
  prefs: []
  type: TYPE_NORMAL
- en: Situation in enterprise projects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The structure of typical enterprise projects has traditionally been a three-tier
    architecture. Three-tiers means three technically motivated layers, namely the
    *presentation*, *business*, and *data layer*. That being said, the project is
    organized horizontally, with three sub-modules, or packages, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: The idea is to separate concerns from the data layer, from the business layer,
    and both of them from the presentation layers, as well. Functionality on a *lower*
    layer can therefore not have any dependencies on a *higher* layer, only the other
    way around. The business layer cannot use functionality of the presentation layer,
    only vice versa. The same is true for the data layer not depending on the business
    layer.
  prefs: []
  type: TYPE_NORMAL
- en: Each technically motivated layer or module has its own internal dependencies,
    that cannot be used from the outside as well. For example, only the *data layer*
    would be able to use the database, no direct invocations from the *business* layer
    would be possible.
  prefs: []
  type: TYPE_NORMAL
- en: Another motivation is to be able to swap implementation details without impacting
    other layers. If the database technology would be changed in favor of another,
    that would in theory not affect the other two layers, since the data layer encapsulates
    these details. The same is true if the presentation technology changes. In fact,
    even several *presentation* layers can be developed with all of them using the
    same *business* layer components, at least if the layers are organized as separate
    modules.
  prefs: []
  type: TYPE_NORMAL
- en: We have seen heated discussions, mostly from high-level architects, about the
    necessity of organizing and separating responsibilities by technical concerns.
    However, there are some drawbacks from this approach.
  prefs: []
  type: TYPE_NORMAL
- en: Horizontal versus vertical layering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Clean code is all about code that aims to be understood by humans not machines.
    The same holds true for designing domains and organizing responsibilities. We
    want to find structures that easily tell the engineers what the project is all
    about.
  prefs: []
  type: TYPE_NORMAL
- en: The challenge with structuring by technical concerns at already high layers
    of abstractions is that the purpose and domain of the software gets obfuscated
    and hidden in lower layers of abstraction. When someone unfamiliar with the project
    looks at the code structure the first thing that they see are the three technical
    layers, although names and numbers might differ in some cases. This will at least
    look familiar to them, but it tells nothing about the actual domain.
  prefs: []
  type: TYPE_NORMAL
- en: Software engineers seek to understand domain modules, not necessarily technical
    layers.
  prefs: []
  type: TYPE_NORMAL
- en: For example, when touching the *accounts* functionality, developers regard everything
    related to the accounts domain, not all the database access classes at once. Other
    than that, developers hardly search for *all database access classes*, but for
    that single class which handles that logic of their current domain.
  prefs: []
  type: TYPE_NORMAL
- en: The same is true when changes have to be made to the system. Changes in functionality
    are more likely to affect all technical layers of a single or a few business domains,
    but hardly all classes of a single technical layer at once. For example, changing
    a field to the user account likely affects the user model, database accesses,
    business use cases, and even the presentation logic, but not necessarily all the
    other model classes as well.
  prefs: []
  type: TYPE_NORMAL
- en: To make the idea what aspects developers are interested in more clearer, let
    me give another example. Imagine a family organized their clothes in a single
    big wardrobe. They could cluster all pants from all family members in a single
    drawer, as well as separate drawers for all socks and all shirts, respectively.
    But the family members won't likely search for all pants at once when they try
    to dress. Rather than this, they're just interested in their individual clothes,
    be it pants, shirts, socks, or something else. Therefore, it would make sense
    for them to organize by several areas of the wardrobe first, one per family member
    and then structuring by *technical clothes* aspects second, ideally following
    a similar structure. The same can be seen for software responsibilities.
  prefs: []
  type: TYPE_NORMAL
- en: Business-driven structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Uncle Bob once wrote about *Screaming Architectures* that should aim to at
    first tell the engineer what the whole enterprise project is about. The idea was
    that when looking at blueprints of buildings and seeing the structure and the
    detailed interior you immediately can tell: *this is a house*, *this is a library*,
    *this is a train station*. The same should hold true for software systems. You
    should be able to look at the project structure and be able to say: *this is an
    accounting system*, *this is a book store inventory system*, *this is an order
    management system*. Is this the case for the most projects we have? Or, does looking
    at the highest level of modules and packages rather tell us: *this is a Spring
    application*, *this system has a presentation, business and data layer*, *this
    system uses a Hazelcast cache*?'
  prefs: []
  type: TYPE_NORMAL
- en: The technical implementations are certainly important to us developers. But
    again, the first thing that we focus on is business concerns. Following this approach,
    these aspects should be reflected in the project and module structure as well.
  prefs: []
  type: TYPE_NORMAL
- en: Most importantly, this means our domain should be reflected in the application
    structure. Just by looking at the highest hierarchy of package names should give
    a good idea of what the software is trying to do. We therefore layer after business
    concerns first, implementation details second.
  prefs: []
  type: TYPE_NORMAL
- en: Blueprint plans for buildings will also first build up a picture what the building
    is about, how the rooms are separated, and where doors and windows are located.
    Then, as a secondary priority they may specify used materials, bricks, and types
    of concrete being used.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an outlook for microservices consider the following: designing vertical
    modules enables the team to split up the application into a system of several
    applications much more easily. Looking at the module dependencies, for example
    through static code analysis, provides a picture of where the integration points
    between the systems would be. These integration points would emerge in some form
    of communication between the applications. In theory, we can then take that single
    module, plus minimal *plumbing*, and package it as a separate, self-sufficient
    application.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A point on names: by using the term *modules* we, by now, focus on business
    driven modules that are realized in Java packages and sub-packages, not build
    project modules. The term *modules* then serves more as a concept, less as a strict
    technical realization.'
  prefs: []
  type: TYPE_NORMAL
- en: Designing reasonable modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: More down to earth, how do we find reasonably sized and structured modules?
  prefs: []
  type: TYPE_NORMAL
- en: Putting business concerns first, a good start is to draw overviews of all the
    responsibilities and use cases of the application. This may be part of a brainstorming
    session, ideally together with business domain experts if that step hasn't been
    done before. What are the application's responsibilities? What business motivated
    use cases do we have? Which coherent functionality can be seen? The answers to
    these questions already give a good idea which modules are likely to be represented,
    without focusing on external systems, implementation details, or framework choices.
  prefs: []
  type: TYPE_NORMAL
- en: In this step we also already consider dependencies between these business concerns.
    Dependencies are helpful indicators of whether modules should be split up or,
    especially when circular dependencies are found, should be merged together. Constructing
    these overview diagrams, starting from a higher level and working the way down
    in several iterations will give a clearer image of what the business contents
    of the application are. Generally speaking, the identified modules should match
    well with the business aspects identified by the domain experts.
  prefs: []
  type: TYPE_NORMAL
- en: 'To give an example, an online shopping application could identify modules for
    *users*, *recommendation*, *articles*, *payment*, and *shipping*. These would
    be reflected as the base domain modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/86827232-c66e-4b88-b9c4-7fa61411aa97.png)'
  prefs: []
  type: TYPE_IMG
- en: The identified modules represent the base Java packages in our application.
  prefs: []
  type: TYPE_NORMAL
- en: It makes sense to put some effort into these considerations. However, as always,
    any *definitive* structure or implementation, no matter whether on code or module
    level, should be able to be changed later on. New requirements might emerge or
    there might be a better understanding later on, once the developers start to deep
    dive into the domain. Iterative refactoring, no matter on which level, will improve
    the quality of the system.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 8, *Microservices and System Architecture*, will show similar motivations
    and methodologies when designing systems that comprise distributed applications.
    Particularly, the Domain-Driven Design approaches of bounded contexts and context
    maps will be discussed.
  prefs: []
  type: TYPE_NORMAL
- en: Realizing package structures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Assuming we found appropriate base Java packages to start with. Now, how do
    you realize the inner package structure, that is, which sub-packages to use?
  prefs: []
  type: TYPE_NORMAL
- en: Package contents
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At first let's have a look at the contents of a vertically sliced module. Since
    it is modeled after business concerns, the module will include everything necessary
    to fulfill certain functionality.
  prefs: []
  type: TYPE_NORMAL
- en: First of all, the module includes technical entry points for use cases such
    as HTTP endpoints, presentation framework controllers, or JMS endpoints. These
    classes and methods usually make use of Java EE principles, such as inversion
    of control, to be called from the container as soon as some communication hits
    the application.
  prefs: []
  type: TYPE_NORMAL
- en: The functionalities that initiate the actual use cases are the next and equally
    important concern. They usually differ from the technical endpoints such that
    they don't contain any communication logic. The business use case boundaries are
    the entry point of our domain logic. They are implemented as managed beans, usually
    Stateless Sessions Beans, EJBs in other words, or CDI managed beans.
  prefs: []
  type: TYPE_NORMAL
- en: The boundaries initiate and implement the business logic. In cases where the
    logic of a use case consists of just a few steps the boundary can sufficiently
    contain the whole logic in the business method or private methods in the class
    definition. Then no other delegate is required. For the vast majority of use cases
    the boundary would delegate logic to corresponding services. These delegates have
    finer-grained responsibilities. Depending on the domain this includes implementing
    detailed business logic or accessing external systems such as databases. Following
    Domain-Driven Design language, these classes include services, transaction scripts,
    factories, and repositories.
  prefs: []
  type: TYPE_NORMAL
- en: The next type of objects are all classes that typically would be considered
    as *model* content, such as entities, value objects, and transfer objects. These
    classes represent the entities in the domain, but also can, and should, implement
    business logic. Examples are entity beans that are managed in the database, other
    POJOs, and enumerations.
  prefs: []
  type: TYPE_NORMAL
- en: In some cases the package might also contain cross-cutting concerns such as
    interceptors with business or technical responsibilities. All these types of components
    now have to be organized within a module.
  prefs: []
  type: TYPE_NORMAL
- en: Horizontal package layering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If we were to organize the module contents, our first attempt probably would
    be to design the inner package structure by technical layering. Slicing up by
    business concerns first and technical ones second at least sounds reasonable.
  prefs: []
  type: TYPE_NORMAL
- en: In the *users* package this would mean to have sub-packages such as *controller*,
    *business* or *core*, *model*, *data* and *client*, respectively. By following
    this approach, we split up responsibilities inside the *users* package by their
    technical categories. In order to be consistent, all the other modules and packages
    in the project would have similar packages, depending on their contents. The idea
    is similar to a three-tier architecture, but inside of the domain modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the sub-packages would be considered to be the technical entry point,
    for instance *controller*. This package would contain the communication endpoints
    initiating the use case logic and serve as entry point outside of the application.
    The following shows the structure of a horizontally organized `users` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3db0ac0a-adde-467a-94e3-8066492acbb9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This structure is realized in Java packages as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/846313ce-1cb0-4168-93e8-c676b0677d3f.png)'
  prefs: []
  type: TYPE_IMG
- en: Flat module package
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An even simpler and more straightforward approach to organize module contents
    is to directly put all related classes into this module package in a flat hierarchy.
    For the `users` package this means to place all classes, including user related
    use case entry points, user database access code, potential external system functionality,
    and the user entity classes themselves, directly into this package.
  prefs: []
  type: TYPE_NORMAL
- en: Depending on the complexity of the modules this can be a clean and straightforward
    approach or it can become too unorganized over time. Especially entities, value
    objects, and transfer objects can reach a number of classes that, if put into
    a single package, drastically reduce clarity and overview. However, it makes a
    lot of sense to start with this approach and refactor later.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following shows the package structure of an example `users` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/89782f98-faa5-42ea-84a7-b43607cbe0b4.png)'
  prefs: []
  type: TYPE_IMG
- en: A benefit of this approach is that it's well supported by the Java language.
    By default Java classes and methods come with package-private visibility. This
    fact together with organizing all classes in one place leverages encapsulations
    and visibility practices. Components, that are desired to be accessible from outside
    of the package, get public visibility; all classes and methods that are only accessed
    from within this package define package-private visibility. The package can therefore
    encapsulate all internal concerns.
  prefs: []
  type: TYPE_NORMAL
- en: Entity Control Boundary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Coping with the number of classes in the module package, there is another approach
    similar to technical layering, but with fewer and clearer defined packages. The
    idea is to structure due to what is a use case boundary of the module, which are
    subsequent business logic components, and which are entity classes.
  prefs: []
  type: TYPE_NORMAL
- en: This focuses on organizing module packages by their responsibilities, but with
    fewer technical details at the top package layer, compared to horizontal layering.
    The **boundary** package contains the use cases initiators, the boundaries, which
    are accessed from the outside of the system. These classes typically represent
    HTTP endpoints, message driven beans, frontend related controllers, or simply
    Enterprise Java Beans. They will implement the business driven use cases and optionally
    delegate to subsequent classes residing in the optional **control** package. The
    **entity** package contains all the *nouns* in the module, domain entities or
    transfer objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ivar Jacobson has formed the term **Entity Control Boundary** for following
    way of organizing modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3879e8f1-419e-4893-95c8-1ac90cbda261.png)'
  prefs: []
  type: TYPE_IMG
- en: Packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's have a closer look at the boundary package. The idea was that all business
    use cases called from the frontend or outside of the system are initiated here.
    Invocations for creation, update, or deletion of users, first land in classes
    residing in this package. Depending on the complexity of the use cases, the boundary
    either completely handles the logic itself or delegates into the control before
    becoming too complex.
  prefs: []
  type: TYPE_NORMAL
- en: For a Java enterprise application, classes in the boundary package are implemented
    as managed beans. As mentioned before, typically EJBs are used here.
  prefs: []
  type: TYPE_NORMAL
- en: If the logic in the boundary becomes too complex and not manageable within a
    single class anymore, we refactor the logic into delegates that are used in the
    boundary. These delegates or *controls* are placed in the control package. They
    typically fulfill more detailed business logic or handle database or external
    system access by acting within the technical transaction that was initiated in
    the boundary.
  prefs: []
  type: TYPE_NORMAL
- en: This structure increases cohesion and reusability and honors the single responsibility
    principle. The structure of the business use case becomes more readable, once
    we introduce these abstraction layers. You can start by looking at the boundary
    as the entry point of the use case, and retrace every delegated step one after
    another.
  prefs: []
  type: TYPE_NORMAL
- en: In Domain-Driven Design language, the contents of the control package includes
    services, transaction scripts, factories and repositories. However, the existence
    of a control package for business use cases is optional.
  prefs: []
  type: TYPE_NORMAL
- en: At the heart of our domain we have all entities and value objects. These, together
    with transfer objects, build up the model of our domain module, the objects that
    a use case typically deals with. They are organized within the entity package,
    the last one of the Entity Control Boundary pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Now, what about presentation-related components and cross-cutting concerns such
    as Interceptors or framework *plumbing* logic? Fortunately, in a modern Java EE
    project required framework plumbing is kept within limits as we will see in [Chapter
    3](329094a0-f41b-4ad1-b05e-cd52c4bb9e42.xhtml), *Implementing Modern Java Enterprise
    Applications*. The few things that are required, for example bootstrapping JAX-RS
    with the application activator class, are placed in the root package of our project
    or in a specific `platform` package. The same is true for cross-cutting concerns
    such as technically motivated interceptors that are not bound to a specific module,
    but the application as a whole. The number of these classes is typically not too
    high; if so, then a dedicated package makes sense. The danger of having such a
    platform package is that it naturally tempts developers to put other components
    in there as well. This place is just meant for the few platform specific classes;
    everything else should reside in its own business motivated module package.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of the `users` module, using the Entity Control
    Boundary pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2edc5642-6f75-4394-ad53-c8f4cc4362bb.png)'
  prefs: []
  type: TYPE_IMG
- en: Package access
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Not all accesses from every package of the Entity Control Boundary pattern are
    allowed or make sense, respectively. In general, the logic flow starts at the
    boundary, going down to the control and entity package. The boundary package therefore,
    has dependencies to both the control, if existent, and the entity package. Using
    boundaries of other modules are not allowed and won't make sense, since the boundary
    represents a business use case. Accessing another boundary would mean to invoke
    something that should be a separate, standalone use case. Therefore boundaries
    can only go *down* the hierarchy to controls.
  prefs: []
  type: TYPE_NORMAL
- en: However, dependencies and invocations from boundaries to controls of other modules
    are allowed and do make sense in some cases. Developers have to pay attention
    that the transaction scopes are still chosen correctly when accessing components
    from other modules. When accessing controls of other modules, it will also happen
    that they work with or return entities of that foreign module. This happens for
    more than trivial use cases and won't be an issue, as long as care is taken where
    the responsibilities are placed, and that the controls and entities are being
    used correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Controls may access controls of other modules and their own and foreign entities.
    For the same reason as with boundaries, it makes no sense that a control invokes
    functionality of any boundary. This would be equivalent to starting new top-level
    business use cases within a running use case.
  prefs: []
  type: TYPE_NORMAL
- en: Entities are only allowed to depend on other entities. In some cases it will
    be necessary to have imports on controls, for example, if JPA entity listeners
    or JSON-B type converters exist that can implement sophisticated logic. These
    technically motivated cases are the exception where it should be allowed for simplicity
    to import these classes. Ideally, these entity *supporting* components, such as
    entity listeners or converters should reside directly in the entity package. Due
    to other dependencies and usage of delegates this premise cannot always be fulfilled,
    which should not lead to overly complex technical workarounds.
  prefs: []
  type: TYPE_NORMAL
- en: This also brings us to another more general topic.
  prefs: []
  type: TYPE_NORMAL
- en: Don't over-enforce architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Whichever architectural pattern you choose, the main priority of the application
    should be the business domain. This is true for both finding reasonable, domain-motivated
    modules, but also how to structure the packages within a module, so that developers
    can work with it with least effort.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is one important thing to note: developers should be able to work on the
    project without too complex or overly enforced structures and architectures. We
    have seen too many examples in the past that deliberately used technically driven
    layers or overly strict patterns, just to *match the book* and fulfill certain
    constraints. But these constraints are often self-motivated and don''t fulfill
    any higher purpose. We should sensibly reconsider what is required and what just
    bloats the development processes. Search for the term *cargo cult programming*
    when you have the time, and you will find an interesting real-world story of following
    rules and rituals without questioning their purpose.'
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, don't over-complicate or over-enforce architecture. If there is a
    simple and straightforward way that fulfills what currently is required, just
    go for it. This is not only true for premature refactoring, but also for architectural
    design. If putting a few classes in a single, well-named package serves the purpose
    and clearly documents the reasoning, why not? If a business use case boundary
    class can already fulfill the whole, simple logic, why introduce empty delegates?
  prefs: []
  type: TYPE_NORMAL
- en: The trade-off of following an architectural pattern, even if not required in
    all places, is consistency versus simplicity. Having all packages, modules, and
    projects showing the same patterns and structure shows a picture familiar to developers.
    However, in Chapter 8, *Microservices and System Architecture* we will see that
    in greater detail, ultimately, consistency is a goal that isn't likely to be achieved
    within the whole organization, or even single projects. The benefits of crafting
    something simpler and eventually more flexible outweighs uniformity in many cases.
  prefs: []
  type: TYPE_NORMAL
- en: The same is true for overly trying to encapsulate the implementation using technical
    layers. It is definitely the case that modules as well as classes should encapsulate
    implementation details and provide clean and clear interfaces. However, these
    responsibilities can and should be contained in single, ideally self-sufficient
    packages or classes. Packaging the module's concerns by technical terms ultimately
    exposes the details to the rest of the module, for example, that a database or
    a client to an external system is being used. Organizing by domain motivation
    first, enables us to encapsulate functionality into single points of responsibility,
    transparent to the rest of the modules or application.
  prefs: []
  type: TYPE_NORMAL
- en: In order to prevent accidental misuse of a way of packaging, the easiest and
    most transparent way is to introduce static code analysis. Package imports in
    classes and whole packages can be scanned and analyzed to detect and prevent unwanted
    dependencies. This represents a security measurement, similar to test cases, to
    avoid careless mistakes. Static code analyses will typically run as an extended
    part of the build process on the Continuous Integration server, as they may take
    some time to build. In [Chapter 6](599c6821-8971-4489-931c-9e11b5e23afd.xhtml),
    *Application Development Workflows* we will cover this topic in more depth.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Enterprise software should be built with the main priority to solve business
    problems, leading to business-driven applications and technology rather than to
    technology-driven solutions. The business use cases are what ultimately will generate
    revenue for the company.
  prefs: []
  type: TYPE_NORMAL
- en: If possible, enterprise applications should be developed in one build project
    per artifact, kept under version control. Splitting up a project into several,
    independent build modules that are in the end boiled down to a single artifact,
    doesn't add much value. For the coarse project structure it's advisable to structure
    the software modules vertically, not horizontally. This means to structure by
    business rather than technical concerns. Looking at the project structure should
    immediately tell developers what the project's domain and responsibilities are
    about.
  prefs: []
  type: TYPE_NORMAL
- en: An individual application module can, in the simplest way, be designed as a
    single, flat Java package. This is advisable if the number of classes per module
    is small. For more complex modules it makes sense to add another hierarchical
    layer using patterns such as Entity Control Boundary.
  prefs: []
  type: TYPE_NORMAL
- en: Software engineers should be reminded not to over-enforce software architecture.
    Well-thought-out design and bureaucratic organization certainly support developers
    a lot in crafting high quality software. Still, there is always a happy medium
    between reasonable design and over-engineering.
  prefs: []
  type: TYPE_NORMAL
- en: After seeing the course structure of enterprise projects and how to design modules,
    let's dive down one level to how to realize project modules. The following chapter
    will show you what it takes to implement enterprise applications with Java EE.
  prefs: []
  type: TYPE_NORMAL
