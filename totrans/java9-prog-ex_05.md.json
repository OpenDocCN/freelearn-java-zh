["```java\nwhile (guesser.guess() != Row.none) { \n    while (guesser.nextGuess() != Guesser.none) { \n        public void addNewGuess(Row row) { \n            Color[] guess = super.nextGuess();\n\n```", "```java\npackage packt.java9.by.example.mastermind; \n\n public class PrettyPrintRow { \n\n     public static String pprint(Row row) { \n         String string = \"\"; \n         PrintableRow pRow = new PrintableRow(row); \n         for (int i = 0; i < pRow.nrOfColumns(); i++) { \n             string += pRow.pos(i); \n         } \n         string += \" \"; \n         string += pRow.full(); \n         string += \"/\"; \n         string += pRow.partial(); \n         return string; \n     } \n }\n\n```", "```java\npackage packt.java9.by.example.mastermind.lettered; \n\n import packt.java9.by.example.mastermind.Color; \n\n public class LetteredColor extends Color { \n\n     private final String letter; \n     public LetteredColor(String letter){ \n         this.letter = letter; \n     } \n\n     @Override \n     public String toString(){ \n         return letter; \n     } \n }\n\n```", "```java\npackage packt.java9.by.example.mastermind; \n\n public interface ColorFactory { \n     Color newColor(); \n }\n\n```", "```java\npackage packt.java9.by.example.mastermind; \n\n public class SimpleColorFactory implements ColorFactory { \n     @Override \n     public Color newColor() { \n         return new Color(); \n     } \n }\n\n```", "```java\npackage packt.java9.by.example.mastermind.lettered; \n\n import packt.java9.by.example.mastermind.Color; \n import packt.java9.by.example.mastermind.ColorFactory; \n\n public class LetteredColorFactory implements ColorFactory { \n\n     private final String letters = \"0123456789ABCDEFGHIJKLMNOPQRSTVWXYZabcdefghijklmnopqrstvwxzy\"; \n     private int counter = 0; \n\n     @Override \n     public Color newColor() { \n         Color color = new LetteredColor(letters.substring(counter, counter + 1)); \n         counter++; \n         return color; \n     } \n }\n\n```", "```java\npackage packt.java9.by.example.mastermind; \n\n import java.util.HashMap; \n import java.util.List; \n import java.util.Map; \n\n public class ColorManager { \n     final protected int nrColors; \n     final protected Map<Color, Color> successor = new HashMap<>(); \n     private Color first; \n     private final ColorFactory factory; \n\n     public ColorManager(int nrColors, ColorFactory factory) { \n         this.nrColors = nrColors; \n         this.factory = factory; \n         createOrdering(); \n     } \n\n     private Color[] createColors() { \n         Color[] colors = new Color[nrColors]; \n         for (int i = 0; i < colors.length; i++) { \n             colors[i] = factory.newColor(); \n         } \n         return colors; \n     } \n\n     private void createOrdering() { \n         Color[] colors = createColors(); \n         first = colors[0]; \n         for (int i = 0; i < nrColors - 1; i++) { \n             successor.put(colors[i], colors[i + 1]); \n         } \n     } \n\n     public Color firstColor() { \n         return first; \n     } \n\n     public boolean thereIsNextColor(Color color) { \n         return successor.containsKey(color); \n     } \n\n     public Color nextColor(Color color) { \n         return successor.get(color); \n     } \n\n     public int getNrColors() { \n         return nrColors; \n     } \n }\n\n```", "```java\n@Test\n public void thereIsAFirstColor() { \n     ColorManager manager  \n          = new ColorManager(NR_COLORS, Color::new); \n     Assert.assertNotNull(manager.firstColor()); \n }\n\n```", "```java\npackage packt.java9.by.example.mastermind; \n\n import java.util.Arrays; \n import java.util.HashSet; \n import java.util.Set; \n\n public class Guess { \n     final static public Guess none = new Guess(new Color[0]); \n     final private Color[] colors; \n     private boolean uniquenessWasNotCalculated = true; \n     private boolean unique; \n\n     public Guess(Color[] colors) { \n         this.colors = Arrays.copyOf(colors, colors.length); \n     }\n\n```", "```java\npublic Color getColor(int i) { \n         return colors[i]; \n     } \n\n     public int nrOfColumns() { \n         return colors.length; \n     } \n\n     /** \n      * Calculate the next guess and return a new Guess object. \n      * The guesses are ordered in the order of the colors as \n      * specified by the color manager. \n      * \n      * @param manager that specifies the order of the colors \n      *                can return the next color after one color. \n      * @return the guess that comes after this guess. \n      */ \n     public Guess nextGuess(ColorManager manager) { \n         final Color[] colors = Arrays.copyOf( \n                                     this.colors, nrOfColumns()); \n\n         int i = 0; \n         boolean guessFound = false; \n         while (i < colors.length && !guessFound) { \n             if (manager.thereIsNextColor(getColor(i))) { \n                 colors[i] = manager.nextColor(colors[i]); \n                 guessFound = true; \n             } else { \n                 colors[i] = manager.firstColor(); \n                 i++; \n             } \n         } \n         if (guessFound) { \n             return new Guess(colors); \n         } else { \n             return Guess.none; \n         } \n     }\n\n```", "```java\nprivate void assertCompatibility(Guess guess) { \n         if (nrOfColumns() != guess.nrOfColumns()) { \n             throw new IllegalArgumentException(\"Cannot compare different length guesses\"); \n         } \n     } \n\n     /** \n      * Count the number of colors that are present on the guess \n      * but not on the pos where they are in the other guess. \n      * If the same color is on multiple pos it is counted \n      * for each pos once. For example the secret is \n      * <pre> \n      *     RGRB \n      * </pre> \n      * and the guess is \n      * <pre> \n      *     YRPR \n      * </pre> \n      * then this method will return 2\\. \n      * \n      * @param guess is the actual guess that we evaluate \n      * @return the number of good colors not in pos \n      */ \n     public int nrOfPartialMatches(Guess guess) { \n         assertCompatibility(guess); \n         int count = 0; \n         for (int i = 0; i < nrOfColumns(); i++) { \n             for (int j = 0; j < nrOfColumns(); j++) { \n                 if (i != j && \n                         guess.getColor(i) == this.getColor(j)) { \n                     count++; \n                 } \n             } \n         } \n         return count; \n     } \n\n     /** \n      * Count the number of colors that are correct and are in pos. \n      * \n      * @param guess is the actual guess that we evaluate \n      * @return the number of colors that match in pos \n      */ \n     public int nrOfFullMatches(Guess guess) { \n         assertCompatibility(guess); \n         int count = 0; \n         for (int i = 0; i < nrOfColumns(); i++) { \n             if (guess.getColor(i) == this.getColor(i)) { \n                 count++; \n             } \n         } \n         return count; \n     }\n\n```", "```java\n     /** \n      * @return true if the guess does not \n      *         contain any color more than once \n      */ \n     public boolean isUnique() { \n         if (uniquenessWasNotCalculated) { \n             final Set<Color> alreadyPresent = new HashSet<>(); \n             unique = true; \n             for (Color color : colors) { \n                 if (alreadyPresent.contains(color)) { \n                     unique = false; \n                     break; \n                 } \n                 alreadyPresent.add(color); \n             } \n             uniquenessWasNotCalculated = false; \n         } \n         return unique; \n     }\n\n```", "```java\n     @Override \n     public boolean equals(Object other) { \n         if (this == other) return true; \n         if (other == null || !(other instanceof Guess)) \n                                               return false; \n         Guess guess = (Guess) other; \n         return Arrays.equals(colors, guess.colors); \n     } \n\n     @Override \n     public int hashCode() { \n         return Arrays.hashCode(colors); \n     } \n\n     @Override \n     public String toString() { \n         if (this == none) { \n             return \"none\"; \n         } else { \n             String s = \"\"; \n             for (int i = colors.length - 1; i >= 0; i--) { \n                 s += colors[i]; \n             } \n             return s; \n         } \n     } \n }\n\n```", "```java\npublic class ThreadIntermingling { \n     static class MyThread extends Thread { \n         private final String name; \n         MyThread(String name){ \n             this.name = name; \n         } \n         @Override \n         public void run(){ \n             for(int i = 1 ; i < 1000 ; i ++ ){ \n                 System.out.print(name + \" \" + i+ \", \"); \n             } \n         } \n     } \n     public static void main(String[] args){ \n         Thread t1 = new MyThread(\"t1\"); \n         Thread t2 = new MyThread(\"t2\"); \n         t1.start(); \n         t2.start(); \n         System.out.print(\"started \"); \n\n     } \n }\n\n```", "```java\nstarted t2 1, t2 2, t2 3, t2 4, t2 5, t2 6, t2 7, t2 8, t1 1, t2 9, t2 10, t2 11, t2 12,...\n\n```", "```java\nSystem.out.println(); \nSystem.out.println(t1.getState()); \nSystem.out.println(); \nt1.start();\n\n```", "```java\n    void method1(){ \n1       a = b; \n2       b = a+1; \n        } \n    void method2(){ \n3       c = b; \n4       b = c+2; \n        }\n\n```", "```java\npublic class ThreadIntermingling { \n      static class MyThread implements Runnable { \n          private final String name; \n\n          MyThread(String name) { \n              this.name = name; \n          } \n\n          @Override \n          public void run() { \n              for (int i = 1; i < 1000; i++) { \n                  System.out.print(name + \" \" + i + \", \"); \n              } \n          } \n      } \n      public static void main(String[] args) \n                throws InterruptedException, ExecutionException { \n          ExecutorService es = Executors.newFixedThreadPool(2); \n          Runnable t1 = new MyThread(\"t1\"); \n          Runnable t2 = new MyThread(\"t2\"); \n          Future<?> f1 = es.submit(t1); \n          Future<?> f2 = es.submit(t2); \n          System.out.print(\"started \"); \n          f1.get(); \n          f2.get(); \n          System.out.println(); \n          f1 = es.submit(t1); \n          es.shutdown(); \n      } \n  }\n\n```", "```java\npublic class FJQuickSort<E> { \n     final private Comparator<E> comparator; \n     final private Swapper swapper; \n\n     public FJQuickSort(Comparator<E> comparator, Swapper swapper){ \n         this.comparator = comparator; \n         this.swapper = swapper; \n     } \n\n     public void qsort(SortableCollection<E> sortable, \n                       int start, int end) { \n         ForkJoinPool pool = new ForkJoinPool(); \n         pool.invoke(new RASort(sortable,start,end)); \n     } \n\n     private class RASort extends RecursiveAction { \n\n         final SortableCollection<E> sortable; \n         final int start, end; \n\n         public RASort(SortableCollection<E> sortable, \n                       int start, int end) { \n             this.sortable = sortable; \n             this.start = start; \n             this.end = end; \n         } \n\n         public void compute() { \n             if (start < end) { \n                 final E pivot = sortable.get(start); \n                 final Partitioner<E> partitioner =  \n                          new Partitioner<>(comparator, swapper); \n                 int cutIndex = partitioner.partition( \n                                    sortable, start, end, pivot); \n                 if (cutIndex == start) { \n                     cutIndex++; \n                 } \n                 RecursiveAction left =  \n                    new RASort(sortable, start, cutIndex - 1); \n                 RecursiveAction right =  \n                    new RASort(sortable, cutIndex, end); \n                 invokeAll(left,right); \n                 left.join(); \n                 right.join(); \n             } \n         } \n     }\n\n```", "```java\npackage packt.java9.by.example.thread; \n\n public class VolatileDemonstration implements Runnable { \n     private Object o = null; \n     private static final Object NON_NULL = new Object(); \n     @Override \n     public void run() { \n         while( o == null ); \n         System.out.println(\"o is not null\"); \n     } \n     public static void main(String[] args) \n                            throws InterruptedException { \n         VolatileDemonstration me = new VolatileDemonstration(); \n         new Thread(me).start(); \n         Thread.sleep(1000); \n         me.o = NON_NULL; \n     } \n }\n\n```", "```java\nprivate volatile Object o = null;\n\n```", "```java\nprivate volatile int i=0,j=0; \n\n public void method(){ \n     i++; j++; \n }\n\n```", "```java\npublic class SynchronizedDemo implements Runnable { \n     public static final int N = 1000; \n     public static final int MAX_TRY = 1_000_000; \n\n     private final char threadChar; \n     private final StringBuffer sb; \n     public SynchronizedDemo(char threadChar, StringBuffer sb) { \n         this.threadChar = threadChar; \n         this.sb = sb; \n     } \n     @Override \n     public void run() { \n         for (int i = 0; i < N; i++) { \n             synchronized (sb) { \n                 sb.append(threadChar); \n                 sleep(); \n                 sb.append(threadChar); \n             } \n         } \n     } \n     private void sleep() { \n         try { \n             Thread.sleep(1); \n         } catch (InterruptedException ignored) {} \n     } \n     public static void main(String[] args) { \n         boolean failed = false; \n         int tries = 0; \n         while (!failed && tries < MAX_TRY) { \n             tries++; \n             StringBuffer sb = new StringBuffer(4 * N); \n             new Thread(new SynchronizedDemo('a', sb)).start(); \n             new Thread(new SynchronizedDemo('b', sb)).start(); \n             failed = sb.indexOf(\"aba\") != -1 || \n                      sb.indexOf(\"bab\") != -1; \n         } \n         System.out.println(failed ?  \n               \"failed after \" + tries + \" tries\" : \"not failed\"); \n     } \n }\n\n```", "```java\na.lock(); b.lock(); a.unlock(); c.lock()\n\n```", "```java\nboolean compareAndSet(expectedValue, updateValue);\n\n```", "```java\npublic class IntervalGuesser extends UniqueGuesser implements Runnable { \n     private final Guess start; \n     private final Guess end; \n     private Guess lastGuess; \n     private final BlockingQueue<Guess> guessQueue; \n\n     public IntervalGuesser(Table table, Guess start, Guess end, BlockingQueue<Guess> guessQueue) { \n         super(table); \n         this.start = start; this.end = end; \n         this.lastGuess = start; \n         this.guessQueue = guessQueue; \n         nextGuess = start; \n     } \n     @Override \n     public void run() { \n         Guess guess = guess(); \n         try { \n             while (guess != Guess.none) { \n                 guessQueue.put(guess); \n                 guess = guess(); \n             } \n         } catch (InterruptedException ignored) { \n         } \n     } \n     @Override \n     protected Guess nextGuess() { \n         Guess guess; \n         guess = super.nextGuess(); \n         if (guess.equals(end)) { \n             guess = Guess.none; \n         } \n         lastGuess = guess; \n         return guess; \n     } \n\n     public String toString() { \n         return \"[\" + start + \",\" + end + \"]\"; \n     } \n }\n\n```", "```java\n@Override \n public void play() { \n     Table table = new Table(NR_COLUMNS, manager); \n     Secret secret = new RandomSecret(manager); \n     Guess secretGuess = secret.createSecret(NR_COLUMNS); \n     Game game = new Game(table, secretGuess); \n     final IntervalGuesser[] guessers = createGuessers(table); \n     startAsynchronousGuessers(guessers); \n     final Guesser finalCheckGuesser = new UniqueGuesser(table); \n     try { \n         while (!game.isFinished()) { \n             final Guess guess = guessQueue.take(); \n             if (finalCheckGuesser.guessMatch(guess)) { \n                 game.addNewGuess(guess); \n             } \n         } \n     } catch (InterruptedException ie) { \n\n     } finally { \n         stopAsynchronousGuessers(guessers); \n     } \n }\n\n```", "```java\nprivate ExecutorService executorService; \n\n private void startAsynchronousGuessers( \n                                   IntervalGuesser[] guessers) { \n     executorService = Executors.newFixedThreadPool(nrThreads); \n     for (IntervalGuesser guesser : guessers) { \n         executorService.execute(guesser); \n     } \n } \n\nprivate void stopAsynchronousGuessers( \n                                   IntervalGuesser[] guessers) { \n     executorService.shutdown(); \n     guessQueue.drainTo(new LinkedList<>()); \n }\n\n```", "```java\nbuildscript { \n     repositories { \n         jcenter() \n     } \n     dependencies { \n         classpath \"me.champeau.gradle:jmh-gradle-plugin:0.2.0\" \n     } \n } \n apply plugin: \"me.champeau.gradle.jmh\" \n\n jmh { \n     jmhVersion = '1.13' \n     includeTests = true \n }\n\n```", "```java\npublic class MicroBenchmark { \n     public static void main(String... args) \n                              throws IOException, RunnerException { \n         Options opt = new OptionsBuilder() \n                 .include(MicroBenchmark.class.getSimpleName()) \n                 .forks(1) \n                 .build(); \n         new Runner(opt).run(); \n     } \n\n     @State(Scope.Benchmark) \n     public static class ThreadsAndQueueSizes { \n         @Param(value = {\"1\", \"4\", \"8\"}) \n         String nrThreads; \n         @Param(value = { \"-1\",\"1\", \"10\", \"100\", \"1000000\"}) \n         String queueSize; \n     } \n\n     @Benchmark \n     @Fork(1) \n     public void playParallel(ThreadsAndQueueSizes t3qs) throws InterruptedException { \n         int nrThreads = Integer.valueOf(t3qs.nrThreads); \n         int queueSize = Integer.valueOf(t3qs.queueSize); \n         new ParallelGamePlayer(nrThreads, queueSize).play(); \n     } \n\n     @Benchmark \n     @Fork(1) \n     public void playSimple(){ \n         new SimpleGamePlayer().play(); \n     } \n\n }\n\n```", "```java\nBenchmark     (nrThreads)  (queueSize) Score   Error \nplayParallel            1           -1 15,636 &pm; 1,905 \nplayParallel            1            1 15,316 &pm; 1,237 \nplayParallel            1           10 15,425 &pm; 1,673 \nplayParallel            1          100 16,580 &pm; 1,133 \nplayParallel            1      1000000 15,035 &pm; 1,148 \nplayParallel            4           -1 25,945 &pm; 0,939 \nplayParallel            4            1 25,559 &pm; 1,250 \nplayParallel            4           10 25,034 &pm; 1,414 \nplayParallel            4          100 24,971 &pm; 1,010 \nplayParallel            4      1000000 20,584 &pm; 0,655 \nplayParallel            8           -1 24,713 &pm; 0,687 \nplayParallel            8            1 24,265 &pm; 1,022 \nplayParallel            8           10 24,475 &pm; 1,137 \nplayParallel            8          100 24,514 &pm; 0,836 \nplayParallel            8      1000000 16,595 &pm; 0,739 \nplaySimple            N/A          N/A 18,613 &pm; 2,040\n\n```"]