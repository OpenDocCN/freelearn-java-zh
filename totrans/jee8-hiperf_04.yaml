- en: Application Optimization – Memory Management and Server Configuration
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用优化 – 内存管理和服务器配置
- en: We now know how to get information about the performance of our application.
    From high-level execution time to deep container internals, we can determine which
    part of the code is slowing us down.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在知道如何获取我们应用程序的性能信息。从高级执行时间到深入容器内部，我们可以确定代码的哪个部分在拖慢我们的进度。
- en: However, this is mainly about our code or stack (the Java EE container). There
    are other criteria that can influence the performance of the same machine (considering
    that the CPU and the memory are fixed).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这主要关于我们的代码或堆栈（Java EE 容器）。还有其他标准可能会影响同一台机器的性能（考虑到 CPU 和内存是固定的）。
- en: 'In this chapter, we will investigate the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将调查以下内容：
- en: How JVM manages the memory and automatically releases unused objects
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JVM 如何管理内存并自动释放未使用的对象
- en: Compare different options to release the memory that JVM offers
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比较不同的选项以释放 JVM 提供的内存
- en: See how the server configuration can also impact the performance
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 看看服务器配置如何也会影响性能
- en: Java and the memory
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java 和内存
- en: Java is a high-level language, which means that it is doing a lot of work for
    you. Nowadays, most languages do that (such as Scala, Go, and even recent C++
    updates), but to understand the memory challenge, we need to go back to the early
    programming days and compare two simple code segments.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Java 是一种高级语言，这意味着它在为你做很多工作。如今，大多数语言都在做这件事（如 Scala、Go，甚至最近的 C++ 更新），但为了理解内存挑战，我们需要回到早期的编程时代，并比较两个简单的代码段。
- en: 'The first one is a simplified version of our provisioning service, directly
    taken from our quote manager application:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个是一个简化的我们的配置服务版本，直接从我们的报价管理应用程序中取出：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The variable usage is interesting to observe. With respect to the Java variable
    scope, `client` is available to the complete `refresh` method, the `symbols` array
    is available in the `try` block. Therefore, the `for` loop and `data` are only
    for one iteration of the loop. However, we never really allocate any object memory
    explicitly; we can call `new` to reference a constructor but we do not have the
    memory vision, the pointer, or the size.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 变量使用情况值得观察。关于 Java 变量作用域，`client` 对整个 `refresh` 方法都是可用的，`symbols` 数组在 `try`
    块中可用。因此，`for` 循环和 `data` 只是对循环的一次迭代。然而，我们从未真正显式地分配任何对象内存；我们可以调用 `new` 来引用构造函数，但我们没有内存视图、指针或大小。
- en: 'If we compare the same code block to a version where you need to manage the
    memory, it will look as follows:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将相同的代码块与需要管理内存的版本进行比较，它将如下所示：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The code gets way more complex even if this example assumes that `client.close()`
    handles the releasing, which cannot be true. In fact, each allocated object needs
    to call the `releaseMemory()` function to release the allocated structure. It
    also implies that we should not miss any call. Otherwise, we would be leaking
    memory. The previous code example uses a lot of nested `try`/`finally` to guarantee
    this.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 即使这个例子假设 `client.close()` 处理释放，代码也会变得更加复杂，这是不可能的。实际上，每个分配的对象都需要调用 `releaseMemory()`
    函数来释放分配的结构。这也意味着我们不应该错过任何调用。否则，我们就会泄漏内存。前面的代码示例使用了大量的嵌套 `try`/`finally` 来保证这一点。
- en: What should we learn from this simple example? We should learn that Java allows
    the developer not to care about memory management in most cases. If you use some
    native integration through JNI, for instance, you may still need to handle it.
    To ensure that the application behaves well and does not leak—which is important
    for a server that is not supposed to be restarted—the JVM provides several solutions
    for memory management. This is transparently done but directly impacts the performance,
    since memory allocation is sensitive for a process and memory deallocation has
    some challenges.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该从这个简单的例子中学到什么？我们应该学到的是 Java 允许开发者大多数情况下不必关心内存管理。如果你通过 JNI 使用一些本地集成，例如，你可能仍然需要处理它。为了确保应用程序表现良好且不会泄漏——这对于不应该重新启动的服务器来说很重要——JVM
    提供了几个内存管理解决方案。这是透明地完成的，但直接影响了性能，因为内存分配对进程来说很敏感，内存释放也有一些挑战。
- en: Garbage collector
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 垃圾收集器
- en: Garbage collector is the name of the part of the JVM that handles the memory.
    To make it very simple, it is the part releasing the memory held by some unused
    objects and reallocating this memory space to new objects.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 垃圾收集器是 JVM 中处理内存的部分。为了使其非常简单，它就是释放一些未使用对象持有的内存并将此内存空间重新分配给新对象的部分。
- en: This part is dependent on the JVM you are using, but all the algorithms use
    the same sort of logic. So, it is important to understand how it works in the
    high level, and then you can investigate the specifics of your particular JVM.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这一部分取决于你使用的 JVM，但所有算法都使用类似的逻辑。因此，了解它在高层次上是如何工作的非常重要，然后你可以调查你特定 JVM 的具体细节。
- en: In the context of this book, we will limit ourselves to the HotSpot JVM (the
    Oracle one).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的背景下，我们将限制自己讨论 HotSpot JVM（即 Oracle 的那个）。
- en: 'The heap memory is divided into two main spaces: the young generation and the
    old one. The young generation is itself divided into multiple spaces: the Eden
    and the survivors (there are two survivors). Both the generations also have a *virtual*
    space that is mainly there to support either garbage collection operations or
    generation resizing.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 堆内存分为两个主要空间：年轻代和老生代。年轻代本身又分为多个空间：Eden 和幸存者（有两个幸存者）。这两个代也都有一个**虚拟**空间，主要存在是为了支持垃圾收集操作或代大小调整。
- en: Since Java 8, the permanent space (used until Java 7) has been dropped and replaced
    by metaspace. Its role is to hold the metadata of the application in memory, such
    as the classes (name, annotations, fields, and so on). If you remember the previous
    chapter on how to monitor your applications, you will probably be thinking about
    the `jcmd GC.class_stats` command that gives you information about this space
    of memory. In terms of the performance, it is important to ensure that this space
    is constant once the JVM is *hot*. Concretely, it means that once we have executed
    all the possible code paths of our application, we should not see many changes
    on the memory allocated to that space. If you still see it moving significantly
    after that time, you may have a leak or a classloader issue that you'll need to
    investigate before you continue working on the performance.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 自 Java 8 以来，永久空间（在 Java 7 中使用）已被移除，并由元空间取代。它的作用是在内存中保存应用程序的元数据，例如类（名称、注解、字段等）。如果你还记得之前关于如何监控应用程序的章节，你可能会想到`jcmd
    GC.class_stats`命令，它提供了关于这个内存空间的信息。在性能方面，确保这个空间在 JVM 热稳定后保持恒定非常重要。具体来说，这意味着一旦我们执行了应用程序所有可能的代码路径，我们不应该看到分配给该空间的内存有太多变化。如果你在那之后仍然看到它有显著移动，你可能有一个泄漏或类加载器问题，在继续工作之前你需要调查这些问题。
- en: 'From now on, we will just deal with the heap. It is the part of the memory
    that you need to start with when you start tuning an application for production
    deployment or benchmark. To summarize what we have just talked about, you can
    visualize the way the memory is split with the following diagram:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在起，我们只处理堆。这是你在开始为生产部署或基准测试调整应用程序时需要从其开始的内存部分。为了总结我们刚才讨论的内容，你可以用以下图表来可视化内存的分割方式：
- en: '![](img/6f100ec7-b72d-4507-a89a-7cec663e56db.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6f100ec7-b72d-4507-a89a-7cec663e56db.png)'
- en: The global idea is to start filling the *first* zone (the **Eden** zone of the
    young generation) with *dynamic* objects—you can visualize it as request-related
    objects with a mental model—and once it is full, the garbage collector will move
    objects still used to the next zone (**Survivor 1**, **Survivor 2**, and, finally,
    the **Tenured** zone). This is a very high-level understanding of the generations.
    The point behind splitting the memory this way is that the garbage collector works
    on zones smaller than the full memory when it needs to run, and it can apply different
    algorithms to each zone and be more efficient. Keep in mind that the more you
    go to the old generation, the more objects survive the garbage collection cycles
    and stay in the memory in terms of the application runtime.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 整体思路是首先填充**第一个**区域（年轻代中的**Eden**区域）——你可以将其想象为与请求相关的对象，并使用一个心理模型来可视化——一旦填满，垃圾收集器会将仍然被使用的对象移动到下一个区域（**Survivor
    1**、**Survivor 2**，最后是**Tenured**区域）。这是对代的高层次理解。这样分割内存的目的是，当垃圾收集器需要运行时，它可以在小于完整内存的区域内工作，并且可以对每个区域应用不同的算法，从而提高效率。请记住，你进入老生代越深，在应用运行时内存中存活的对象就越多。
- en: The main difference between the young and old generations is the way the garbage
    collector impacts the application. While working on the young generation and running,
    it will execute what is called a *minor collection*. This browses through the
    corresponding zone, is generally fast, and has low impact in terms of the application's
    performance.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 年轻代和老年代之间主要的不同之处在于垃圾收集器对应用程序的影响方式。当在年轻代工作并运行时，它将执行所谓的**小收集**。这会遍历相应的区域，通常很快，并且对应用程序性能的影响很小。
- en: However, when a collection is executed in the old generation, it is called a *major
    collection* and generally blocks the application. This means that your application
    may not be responding during the collection time, which highly affects the performance.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当一个收集器在旧代执行时，它被称为**主要收集器**，通常会导致应用程序阻塞。这意味着在收集器运行期间，您的应用程序可能无法响应，这会严重影响性能。
- en: Now there are several more detailed ways to delve into the ways the JVM garbage
    collection works, and each of them has an impact on the performance.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在有几个更详细的方法可以深入了解JVM垃圾收集器的工作方式，并且它们都对性能有影响。
- en: Garbage collector algorithms
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 垃圾收集器算法
- en: 'Over the years, the garbage collector algorithms have been enhanced and there
    are multiple algorithms available now. They match several sorts of applications
    and are more or less adapted, depending on the product:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，垃圾收集器算法得到了增强，现在有多种算法可供选择。它们匹配多种类型的应用程序，并且根据产品或多或少进行了适应：
- en: '**Serial collector**: This is a mono-threaded implementation and the default
    algorithm for client-side machines (32 bit or single processor).'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**串行收集器**：这是一个单线程实现，是客户端机器（32位或单处理器）的默认算法。'
- en: '**Parallel collector**: The serial collector algorithm adapts to server resources
    (fast CPU and big memory sizes). The parallel collector is the default one for
    server machines (>= 2 processors).'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**并行收集器**：串行收集器算法适应服务器资源（快速CPU和大内存大小）。并行收集器是服务器机器（>= 2处理器）的默认收集器。'
- en: '**Parallel compacting collector**: This allows to paralellize the tenured generation
    processing.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**并行压缩收集器**：这允许并行处理老年代。'
- en: '**Concurrent Mark Sweep (CMS) collector**: With this collector, the tenured
    generation is processed in parallel with the application.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**并发标记清除（CMS）收集器**：使用此收集器时，老年代将与应用程序并行处理。'
- en: '**Garbage first collector (G1)**: This collection is concurrently performed
    with the application that targets the server application we are dealing with in
    the context of this book. This will be the default collector with Java 9 but is
    already available with Java 8.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**垃圾优先收集器（G1）**：这种收集器与应用程序同时进行，目标是本书中我们处理的服务器应用程序。这将是Java 9的默认收集器，但已经在Java
    8中可用。'
- en: The serial collector
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '**串行收集器**'
- en: 'To force using the serial collector, you will need to add the following option to
    your JVM:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 要强制使用串行收集器，您需要将以下选项添加到您的JVM中：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Once this option is added to the JVM, you will have a garbage collector using
    a single thread and potentially lock the application for collection.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦将此选项添加到JVM中，您将有一个使用单个线程的垃圾收集器，并且可能会锁定应用程序以进行收集。
- en: The first collection will move the still used objects from eden to the first
    empty survivor space. If the used objects are too big, they are directly moved
    to the tenured space. Younger objects of the *survivor 1* (also known as *survivor
    from*) space are then moved to the *survivor 2* (also known as *survivor to*)
    space if there is space; otherwise, they are moved directly to the tenured space.
    Older objects are moved to the tenured space.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次收集会将仍然使用的对象从伊甸园移动到第一个空的幸存者空间。如果使用对象太大，它们将直接移动到老年代。然后，*幸存者1*（也称为*幸存者来源*）空间中的较年轻对象如果空间允许，将移动到*幸存者2*（也称为*幸存者目标*）空间；否则，它们将直接移动到老年代。较老的对象将移动到老年代。
- en: Once all these moves are done, the eden and survivor spaces (which were full)
    can be freed. Note that the survivor space is then reversed in terms of its role,
    which means that the survivor space is always empty.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成所有这些移动，伊甸园和幸存者空间（之前已满）就可以释放。请注意，幸存者空间在角色上被反转，这意味着幸存者空间始终为空。
- en: 'Here is a way to represent the algorithm:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一种表示算法的方法：
- en: '![](img/7aa913cc-38a3-4fa5-a5fa-cd6361a3718b.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7aa913cc-38a3-4fa5-a5fa-cd6361a3718b.jpg)'
- en: 'We start from a state where the eden becomes full and the first survivor has
    some objects:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从一个状态开始，其中伊甸园已满，第一个幸存者有一些对象：
- en: '![](img/8644e415-ee19-42a0-8f12-19f454940308.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8644e415-ee19-42a0-8f12-19f454940308.jpg)'
- en: 'In the first phase, the used objects are moved from eden to the second survivor
    if they fit (the two small green blocks) or directly to the tenured space if too
    big (the large block in the end):'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一阶段，如果它们适合（两个小绿色块），则使用的对象将从伊甸园移动到第二个幸存者，或者如果太大（最后的大块），则直接移动到持久空间：
- en: '![](img/7f7d9996-e6ca-4a9b-b963-eb5badeb0f1d.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7f7d9996-e6ca-4a9b-b963-eb5badeb0f1d.jpg)'
- en: 'Now, the same logic is applied to the first survivor space, so we have the
    small used objects moving to the other survivor and the big ones to the tenured
    space. At this stage, you can still have unused objects in the first survivor:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，相同的逻辑应用于第一个幸存者空间，因此我们有小块使用的对象移动到另一个幸存者，而大块则移动到持久空间。在这个阶段，你仍然可以在第一个幸存者中找到未使用的对象：
- en: '![](img/f9fd35ad-2702-410b-bae7-5e4b64f14668.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f9fd35ad-2702-410b-bae7-5e4b64f14668.jpg)'
- en: 'Finally, the last step is to free the unused memory: the eden and first survivor
    in our example. In the next cycle, exactly the same logic will be followed, but
    the two survivor spaces will be reversed.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是释放未使用的内存：在我们的例子中是伊甸园和第一个幸存者。在下一个周期中，将遵循完全相同的逻辑，但两个幸存者空间将颠倒。
- en: This algorithm mainly concerns how the young generation is managed, but it is
    not sufficient in itself, since it will fill the old one pretty quickly. For this
    reason, a complete cycle requires a second algorithm called the Mark-Sweep-Compact,
    which is applied on the tenured space.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这个算法主要关注年轻代的管理，但它本身并不足够，因为它会很快填满老一代。因此，一个完整的周期需要一个名为标记-清扫-压缩的第二个算法，它应用于持久空间。
- en: 'As you can guess from its name, the algorithm has three phases:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所猜，该算法有三个阶段：
- en: '**Mark**: In this phase, the collector identifies the still used instances
    and marks the associated memory space'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**标记**：在这个阶段，收集器识别出仍然被使用的实例，并标记相关的内存空间'
- en: '**Sweep**: The unmarked memory in the previous step is freed'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**清扫**：上一步中未标记的内存被释放'
- en: '**Compact**: The previous step may have created holes in the memory space,
    so the collector compacts it, ensuring that all the objects are placed side by
    side for faster access'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**压缩**：上一步可能已经在内存空间中创建了空洞，因此收集器将其压缩，确保所有对象都并排放置以实现更快的访问'
- en: 'You can visualize it—for a single memory zone—with the following diagram:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用以下图表来可视化它——对于一个单独的内存区域：
- en: '![](img/22b758bc-46b0-432f-895c-1e2e7b88e075.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/22b758bc-46b0-432f-895c-1e2e7b88e075.png)'
- en: 'Let''s assume that our initial state is the previous diagram. We have five
    objects filling the space. The first step is then to *Mark* the still used objects
    to be able to remove the remaining ones (no more used). It can be illustrated
    with the following diagram:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们的初始状态是前面的图表。我们有五个对象填充空间。第一步是将仍然使用的对象*标记*，以便能够移除剩余的（不再使用的）。可以用以下图表来表示：
- en: '![](img/8d42ee2c-77a6-446b-8d4b-2f81d5e42b1d.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8d42ee2c-77a6-446b-8d4b-2f81d5e42b1d.png)'
- en: 'The darker blocks are the no-more-used ones in this illustration, and the lighter
    ones are the still-used ones. Now that we have proceeded from the *Mark* phase,
    we will execute the *Sweep* phase and remove the unused blocks:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个说明中，较暗的块是不再使用的，较亮的块是仍然使用的。现在我们已经从*标记*阶段进行，我们将执行*清扫*阶段并移除未使用的块：
- en: '![](img/711d8745-6257-45f3-8a03-abc8284c5713.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/711d8745-6257-45f3-8a03-abc8284c5713.png)'
- en: At this point, we are fine in terms of the memory volume. This means that we've
    freed all the memory we can and we could almost stop the collection here. However,
    as you can see in this diagram, there are some holes in the free space.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在内存量方面我们做得很好。这意味着我们已经释放了我们能释放的所有内存，我们几乎可以在这里停止收集。然而，正如你在这张图中看到的，有一些空闲空间的空洞。
- en: 'One issue is that if we need to allocate a big object, then it can be split
    into multiple memory zones and the memory access may become slower. To optimize
    this, we have the last step, that is, *Compact*:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 一个问题是，如果我们需要分配一个大对象，那么它可以分成多个内存区域，内存访问可能会变慢。为了优化这一点，我们有了最后一步，即*压缩*：
- en: '![](img/bd0e64a1-1b15-4336-abbe-9f407bf2f574.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/bd0e64a1-1b15-4336-abbe-9f407bf2f574.png)'
- en: After this last step, the memory is optimized (compacted); all the objects are
    side by side and we have the biggest possible available memory zone vacant at
    the end.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一最后步骤之后，内存得到了优化（压缩）；所有对象都并排放置，我们在最后得到了最大的可用内存区域空闲。
- en: For a server (don't forget that we're talking about Java EE in this book), this
    is rarely the fastest garbage collector mode, but the concepts are quite important
    to understand and if you write a Java EE client (using the JAX-RS client API,
    for instance) it can still apply to your final delivery, which will not require
    a lot of memory allocation.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 对于服务器（别忘了我们在这本书中讨论的是 Java EE），这通常不是最快的垃圾收集器模式，但理解这些概念非常重要。如果你编写一个 Java EE 客户端（例如使用
    JAX-RS 客户端 API），它仍然适用于你的最终交付，这不会需要大量的内存分配。
- en: Parallel and parallel compacting collectors
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并行和并行压缩收集器
- en: The parallel collector is close to the serial collector (which is why it is
    important to understand the serial algorithm). The main difference will be how
    it sets up the collection. We saw that, in a serial collection, a single thread
    is responsible for the collection, but with the parallel collector, multiple threads
    adopt the role. This means that you can hope to reduce the *stop the world* duration
    (when the garbage collector enforces the application to stop responding and do
    its job) by the number of threads (theoretically).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 并行收集器接近于串行收集器（这就是为什么理解串行算法很重要）。主要区别将在于它如何设置收集。我们看到了在串行收集中，单个线程负责收集，但在并行收集器中，多个线程承担这个角色。这意味着你可以期望通过线程数（理论上）来减少
    *停止世界* 的持续时间（当垃圾收集器强制应用程序停止响应并执行其任务时）。
- en: 'This can be activated/enforced (this is supposed to be the default for a server
    machine) by adding this option on the JVM: `-XX:+UseParallelGC`.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过在 JVM 中添加此选项来激活/强制（这应该是服务器机器的默认设置）：`-XX:+UseParallelGC`。
- en: 'The parallel collector can be tuned with several JVM options, but here are
    some you may want to customize:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 并行收集器可以通过几个 JVM 选项进行调整，但以下是一些你可能想要自定义的选项：
- en: '`-XX:MaxGCPauseMillis=N`: You configure the value (`N`) to the maximum duration
    you desire for the pauses of the garbage collector. Note that this is just a hint
    and there is no guarantee that you will obtain the desired result, but it can
    be interesting as a first attempt. Also keep in mind that it will optimize the
    garbage collector pause duration (and, maybe, not the throughput of the application,
    which can be an issue for the server). In the end, you may manually tune the heap
    size and ratio, but starting to test this JVM option can give you some hints about
    the way to go.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-XX:MaxGCPauseMillis=N`：你将值（`N`）配置为你希望垃圾收集器暂停的最大持续时间。请注意，这只是一个提示，并不能保证你将获得期望的结果，但它可以作为第一次尝试是有趣的。同时，请记住，这将优化垃圾收集器暂停的持续时间（也许，不是应用程序的吞吐量，这可能是服务器的一个问题）。最后，你可能需要手动调整堆大小和比率，但开始测试这个
    JVM 选项可以给你一些关于如何进行的提示。'
- en: '`-XX:GCTimeRatio=N`: This is also a hint, allowing you to request that no more
    than *1/(1+N)* of the application time is spent in garbage collection. This is
    intended to optimize the throughput of the application—which is generally the
    case for a server. This is not the easiest configuration to understand, so let''s
    use a small example. If you set *N* to 19, then 1/20 of the application time (5%)
    will be allocated to garbage collection. The default is 99 so only 1% of the application
    time is allocated to garbage collection.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-XX:GCTimeRatio=N`：这也是一个提示，允许你请求应用程序时间中不超过 *1/(1+N)* 的时间用于垃圾收集。这是为了优化应用程序的吞吐量——这通常是服务器的情况。这不是最容易理解配置，所以让我们用一个小的例子来说明。如果你将
    *N* 设置为 19，那么应用程序时间的 1/20（5%）将分配给垃圾收集。默认值是 99，所以只有 1% 的应用程序时间分配给垃圾收集。'
- en: '`-XX:ParallelGCThreads=N`: This allows you to configure the number of threads
    allocated to parallel garbage collection.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-XX:ParallelGCThreads=N`：这允许你配置分配给并行垃圾收集的线程数。'
- en: There are no magic values for these flags, but once you have identified the
    memory needs of your application, it is very interesting to tune them a bit to
    be aligned with the application requirements.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这些标志没有魔法值，但一旦你确定了应用程序的内存需求，调整它们以与应用程序要求相一致是非常有趣的。
- en: What is interesting to know is that the garbage collector can adjust the generation
    sizes, depending on the configured ratio to try to respect it. This is done by
    increasing the generation sizes to decrease the collection times. By default,
    a generation size is increased by 20% and decreased by 8%. Here again, you can
    customize this adjustment with some JVM flags.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，垃圾收集器可以根据配置的比率调整代的大小，试图尊重它。这是通过增加代的大小来减少收集时间来实现的。默认情况下，代的大小增加 20%，减少
    8%。在这里，你也可以通过一些 JVM 标志来自定义这种调整。
- en: 'There are lots of flags, and their name and supported values can depend on
    the JVM you use. Since they are not portable flags, you may need to check them
    against your JVM documentation. With the Hotspot, you can do it with the following
    command:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多标志，它们的名称和支持的值可能取决于您使用的JVM。由于它们不是可移植的标志，您可能需要根据您的JVM文档进行检查。对于Hotspot，您可以使用以下命令：
- en: '[PRE3]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This command prints the Java version (just to avoid any error) and also prints
    the JVM flags, allowing you to list them all, which is the part we care about.
    Once you have the output, you just need to filter the flags you want. In our case,
    we want to customize the way the generation sizes are increased/decreased, so
    we can filter the flags with the `grep` command (on Unix) using the `Generation`
    keyword:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令打印Java版本（仅为了防止任何错误）以及JVM标志，允许您列出所有标志，这是我们关注的重点部分。一旦您获得输出，您只需过滤您想要的标志。在我们的情况下，我们想要自定义增加/减少生成大小的方式，因此我们可以使用`grep`命令（在Unix上）通过`Generation`关键字来过滤标志：
- en: '[PRE4]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`+PrintFlagsFinal` allows you to list the options, their value (after the equal
    sign), their type (first string), and the flag type (in braces).'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`+PrintFlagsFinal`允许您列出选项、它们的值（等于号之后）、它们的类型（第一个字符串）以及标志类型（在大括号中）。'
- en: If you add other options to the JVM (such as `-client` or `-server`), it will
    adjust the values to reflect these flags.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您向JVM添加其他选项（如`-client`或`-server`），它将调整值以反映这些标志。
- en: As you can see in the previous capture, you can use `-XX:YoungGenerationSizeIncrement`
    to customize the increase percentage of the young generation when needed to respect
    the configured ratio. `YoungGenerationSizeSupplement` is a supplement for the
    young generation size increment used at startup, and the decay flag is the decay
    factor to the supplement value. Indeed, the tenured generation has the same sort
    of configuration.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在前面的截图中所见，您可以使用`-XX:YoungGenerationSizeIncrement`来在需要时自定义年轻代增加的百分比，以尊重配置的比率。`YoungGenerationSizeSupplement`是启动时使用的年轻代大小增加的补充，而衰减标志是补充值的衰减因子。实际上，老年代也有类似的配置。
- en: These configurations are very advanced and you must ensure that you can explain
    why you tune them before doing it; otherwise, you can just mess up your JVM configuration
    and make your application behave badly.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这些配置非常高级，您必须在执行之前确保您能解释为什么调整它们；否则，您可能会弄乱您的JVM配置，并使您的应用程序表现不佳。
- en: Finally, parallel GC still uses a single thread for the tenured generation collection.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，并行GC仍然使用单个线程进行老年代收集。
- en: Now, there is also a compacting parallel collector. It is the same as the parallel
    collector in the young generation, but in the tenured one, the algorithm differs
    a bit. It is close to the *Mark*/*Sweep*/*Compact* algorithm, except it divides
    the space in more zones to let the collector work in parallel on them. Then, the
    sweep phase is replaced by a *summary* phase, where the density is verified to
    request a compaction. Finally, the compaction is done in parallel. To use this
    option, you need to activate another JVM flag: `-XX:+UseParallelOldGC`. This option
    is supposed to be good for applications with large heaps, which is the case with
    applications handling a lot of concurrent requests and using some caching mechanism.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，还有一个压缩并行收集器。它与年轻代中的并行收集器相同，但在老年代中，算法略有不同。它接近于*标记*/*清除*/*压缩*算法，除了它将空间分成更多区域，以便收集器可以并行地在这上面工作。然后，清除阶段被一个*总结*阶段所取代，其中检查密度以请求压缩。最后，压缩是并行完成的。要使用此选项，您需要激活另一个JVM标志：`-XX:+UseParallelOldGC`。此选项对于具有大堆的应用程序来说应该是好的，这对于处理大量并发请求并使用某些缓存机制的应用程序来说是这种情况。
- en: Concurrent Mark Sweep (CMS)
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并发标记清除（CMS）
- en: The goal of the CMS is to reduce GC pauses, enabling you to execute the GC while
    the application is running. For this, it uses multiple threads. The main idea
    is to be able to free some memory before the tenured generation is full, and the
    GC needs to pause the application threads. If it happens too frequently, you will
    need to adjust the application tuning (CMS configuration) to avoid it as much
    as possible and to keep it behaving correctly. You can identify this type of issue
    checking `verbose:gc` output and `Concurrent Mode Failure` messages.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: CMS的目标是减少GC暂停，使您能够在应用程序运行时执行GC。为此，它使用多个线程。主要思想是在老年代充满之前释放一些内存，并且GC需要暂停应用程序线程。如果这种情况发生得太频繁，您可能需要调整应用程序调优（CMS配置）以尽可能避免这种情况，并保持其正确行为。您可以通过检查`verbose:gc`输出和`Concurrent
    Mode Failure`消息来识别此类问题。
- en: 'Compared to the standard *Mark* phase, the one of the *CMS* algorithm will
    pause the application twice: first pause to mark objects directly reachable from
    the root of the memory graph and the second pause to identify the objects missed
    in the concurrent tracing phase. This concurrent tracing phase will take resources
    that the application will not be able to use anymore, and the throughput will
    potentially decrease a bit.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 与标准的*标记*阶段相比，*CMS*算法将暂停应用程序两次：第一次暂停标记从内存图根直接可达的对象，第二次暂停识别在并发跟踪阶段遗漏的对象。这个并发跟踪阶段将占用应用程序不能再使用的资源，并且吞吐量可能会略微下降。
- en: 'A collection mainly has two triggers:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 一个集合主要有两个触发器：
- en: A kind of timeout based on the historical statistics of the memory, with a safety
    bound added to avoid a concurrent mode failure, which is very costly. This safety
    bound can be controlled based on a percentage, customizable with the `-XX:CMSIncrementalSafetyFactory=N` flag.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种基于内存历史统计信息的超时机制，并添加了一个安全边界以避免并发模式失败，这代价非常高。这个安全边界可以通过`-XX:CMSIncrementalSafetyFactory=N`标志根据百分比进行控制。
- en: Based on the remaining size on the tenured space. This trigger can be controlled
    with `-XX:CMSInitiatingOccupancyFaction=N`, *N* being the percentage of the tenured
    space that should trigger a collection if it is full. By default, it is 92% (N=92).
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于剩余的持久空间大小。这个触发器可以通过`-XX:CMSInitiatingOccupancyFaction=N`进行控制，其中*N*是如果满了应该触发收集的持久空间的百分比。默认情况下，它是92%（N=92）。
- en: When investigating long GC pauses, you may need to tune the safety factor and,
    potentially, the occupancy fraction options to see if triggering the GC earlier
    (or later) can help.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在调查长时间的GC暂停时，你可能需要调整安全因子，并可能调整占用分数选项，以查看提前（或延迟）触发GC是否有所帮助。
- en: One last thing to note about this algorithm is that there is no compaction,
    so the memory access can become slower with time.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这个算法的最后一件事是，没有压缩，所以随着时间的推移，内存访问可能会变慢。
- en: Garbage First (G1)
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 垃圾收集器第一代（G1）
- en: The Garbage First collector is the most recent implementation. It is a server-side
    implementation that tends to decrease the pauses and concurrently works with the
    application. It introduces a new way of visualizing the heap.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 垃圾收集器第一代（Garbage First collector）是最新的实现。它是一种服务器端实现，旨在减少暂停时间，并与应用程序并发工作。它引入了一种新的堆可视化方式。
- en: The heap is divided into constant-sized regions. The G1 starts to mark the regions
    concurrently. After this phase, it knows which regions are almost empty and then
    starts collecting the memory from these regions, allowing the G1 to get a lot
    of memory pretty  quickly and without much effort. This is where the name of this
    algorithm comes from. Then, in the compact phase, G1 can copy objects from multiple
    regions to a single region to ensure that it stays efficient.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 堆被分成固定大小的区域。G1开始并发标记区域。在这个阶段之后，它知道哪些区域几乎为空，然后开始从这些区域收集内存，使G1能够快速且不费劲地获得大量内存。这就是这个算法名称的由来。然后，在压缩阶段，G1可以将多个区域的对象复制到单个区域，以确保其效率。
- en: An important thing to know about the G1 implementation is that it is based on
    statistics and can have a few glitches in the execution, even if the model is
    quite accurate in practice.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 关于G1实现的一个重要事项是，它基于统计信息，即使模型在实际应用中相当准确，执行过程中也可能出现一些小故障。
- en: 'The fact that G1 splits the heap in regions also means that it is intended
    for applications using a lot of memory (Oracle claims more than 6 GB) and requiring
    small pause times (less than 0.5 seconds). This implies that switching from the
    CMS to the G1 is not always worth it; you should ensure that you meet one of these
    criteria before switching to the G1:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: G1将堆分成区域的事实也意味着它适用于使用大量内存（Oracle声称超过6 GB）且需要很短暂停时间（小于0.5秒）的应用程序。这意味着从CMS切换到G1并不总是值得的；在切换到G1之前，你应该确保满足以下标准之一：
- en: ~50% of the heap is used by live data
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大约50%的堆被活动数据使用
- en: The statistics are not that accurate with the CMS algorithm (if the allocation
    rate varies a lot)
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与CMS算法相比，统计信息并不那么准确（如果分配率变化很大）
- en: You have identified long GC pauses
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你已经识别出长时间的GC暂停
- en: The G1 also has several JVM flags that you can use to customize the behavior
    the garbage collector should take. For instance, `-XX:MaxGCPauseMillis` sets the
    pause duration that you accept in milliseconds (statistically once again) and `-XX:ConcGCThreads=N` defines
    the concurrent number of threads used to mark the regions (recommended setting
    is about 25% of the parallel GC thread count). Default settings are intended for
    the most common use cases but you may need to refine the configuration to adapt
    it to your application and the way it uses (or reuses) memory.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: G1 还有一些 JVM 标志，您可以使用它们来定制垃圾收集器应采取的行为。例如，`-XX:MaxGCPauseMillis` 设置您接受的暂停时间（统计上再次），而
    `-XX:ConcGCThreads=N` 定义用于标记区域的并发线程数（建议设置为并行 GC 线程数的约 25%）。默认设置旨在针对最常见的用例，但您可能需要调整配置以适应您的应用程序及其使用（或重用）内存的方式。
- en: Here again, activating the G1 collector needs its own JVM flag: `-XX:UseG1GC`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，激活 G1 收集器需要其自己的 JVM 标志：`-XX:UseG1GC`。
- en: Common memory settings
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常见内存设置
- en: 'We saw how the memory was collected and that there are a lot of tuning options
    (once again, don''t forget to check your particular JVM options). However, there
    are some very common memory settings that you will want to customize before finely
    tuning the collector. Here is a small table with these memory settings:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到了内存的收集方式，以及有很多调整选项（再次提醒，不要忘记检查您特定的 JVM 选项）。然而，有一些非常常见的内存设置，在精细调整收集器之前，您可能希望自定义这些设置。以下是一个包含这些内存设置的小表格：
- en: '| **Option** | **Description** |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| **选项** | **描述** |'
- en: '| `-Xmx<size>` | The maximum memory size allocated to the heap, for example, `-Xmx1g` to
    allow the heap to grow until 1GB |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| `-Xmx<size>` | 分配给堆的最大内存大小，例如，`-Xmx1g` 允许堆增长到 1GB |'
- en: '| `-Xms<size>` | The starting memory size allocated to the heap, for example,
    `-Xms512m` to allocate 512 MB to the heap |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| `-Xms<size>` | 分配给堆的起始内存大小，例如，`-Xms512m` 将 512 MB 分配给堆 |'
- en: '| `-Xss<size>` | The stack size (can avoid `StackOverflowError`) |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| `-Xss<size>` | 栈大小（可以避免 `StackOverflowError`）|'
- en: '| `-XX:SurvivorRatio=N` | Ration between eden and survivor spaces |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| `-XX:SurvivorRatio=N` | Eden 和幸存空间之间的比率 |'
- en: '| `-XX:MinHeapFreeRatio=N` and `-XX:MaxHeapFreeRatio=N` | The ratio to trigger
    a heap resize, the min flag will trigger a heap increase, and the max flag will
    trigger a heap size decreasing |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| `-XX:MinHeapFreeRatio=N` 和 `-XX:MaxHeapFreeRatio=N` | 触发堆调整的比率，最小标志将触发堆增加，而最大标志将触发堆大小减少
    |'
- en: 'With all that we saw previously, it means that tuning the JVM memory can lead
    to a big set of options/flags, but don''t be afraid, it is just a matter of taking
    control over its application. Here is a complete flag set example:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们之前看到的，这意味着调整 JVM 内存可以导致一大组选项/标志，但不要害怕，这只是掌握其应用程序的问题。以下是一个完整的标志集示例：
- en: '[PRE5]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This command is a common server memory configuration for a server with a lot
    of available memory for the application(s) you deploy:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令是针对具有大量可用内存的服务器的常见服务器内存配置：
- en: Allocate 24 Gigabytes for the heap (fixed since the min and max memory size
    are set to the same size).
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为堆分配 24 GB（由于最小和最大内存大小设置为相同的大小，因此是固定的）。
- en: Enforce the JVM to use the G1 collector (accurate, as we use more than 6 GB
    of heap) and customizes G1 configuration. It defines a targeted max GC pause of
    150 ms and requests G1 to use 16 parallel threads for the memory collection and
    four threads to mark regions once collected.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 强制 JVM 使用 G1 收集器（准确，因为我们使用了超过 6 GB 的堆）并自定义 G1 配置。它定义了一个目标最大 GC 暂停时间为 150 毫秒，并要求
    G1 使用 16 个并行线程进行内存收集，并在收集后使用四个线程标记区域。
- en: Finally, the collection cycles will start if the heap is occupied at 70%.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，如果堆占用率达到 70%，将开始收集周期。
- en: This is not a bad setting to start with for a server (you can increase the number
    of threads a bit, but not too much, as they can be used at the same time your
    application is running); increase the max GC pause if you can accept it.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 对于服务器来说，这不是一个坏的起始设置（您可以稍微增加线程数，但不要太多，因为它们可以在您的应用程序运行时同时使用）；如果可以接受，增加最大 GC 暂停时间。
- en: The parameter you will probably tune the most is the heap size (24 GB in the
    previous example), depending on the requirements of your application.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能调整最多的参数是堆大小（在先前的示例中为 24 GB），这取决于您应用程序的需求。
- en: Debugging GC behavior
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试 GC 行为
- en: Now that we know how to tune the memory quite finely, we need to know what our
    application does, to be able to adjust the configuration. To do so, the JVM provides
    several ad hoc tools.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何非常精细地调整 JVM 内存，我们需要了解我们的应用程序做了什么，以便能够调整配置。为此，JVM 提供了几个专门工具。
- en: 'The most common and, probably, the most useful tool for the memory is the `-verbose:gc`
    option that you can pass launching your JVM. It will output memory information.
    If we activate it on our quote application, you will quickly see these sorts of
    lines:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 对于内存来说，最常见且可能最有用的工具是`-verbose:gc`选项，你可以在启动JVM时传递它。它将输出内存信息。如果我们激活它在我们的引用应用程序中，你将很快看到这些类型的行：
- en: '[PRE6]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We can distinguish two kinds of lines corresponding to different generation
    zone collection:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以区分两种类型的行，对应不同的代区收集：
- en: '**GC**: This is a young generation collection'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GC**: 这是一个年轻代收集器'
- en: '**Full GC**: This is a tenured generation collection'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Full GC**: 这是一个老年代收集器'
- en: 'Each collection is associated with a reason:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 每次收集都与一个原因相关联：
- en: '**Allocation failure**: The GC is asked to run because no more memory is available'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分配失败**：GC被要求运行，因为没有更多的内存可用'
- en: '**Metadata GC threshold**: The metaspace threshold is reached'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**元数据GC阈值**：元空间阈值已达到'
- en: Then, you can see the resizing of the memory; for instance, `41320K->14967K(153600K)`
    means that the used memory is resized from ~41M to ~15M. The number in the parentheses
    is the available space (~150 MB here).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以看到内存的调整；例如，`41320K->14967K(153600K)`表示使用的内存从约41M调整到约15M。括号中的数字是可用空间（这里约150MB）。
- en: Don't be afraid to see the GC running often and even the full GC lines. While
    their executions are fast and you see that the memory size is acceptable, it is
    not an issue at all. However, if the execution is long and the memory stays high
    even after the collection, then you will need to tune the GC or update the application
    to ensure it comes back to something fast and reliable.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 不要害怕看到GC经常运行，甚至出现完整的GC行。虽然它们的执行速度快，而且你看到内存大小是可以接受的，但这根本不是问题。然而，如果执行时间长，即使收集后内存仍然很高，那么你可能需要调整GC或更新应用程序以确保它快速且可靠地返回。
- en: You can activate this output at runtime through JMX if you go on the `java.lang:type=Memory`
    MBean and set the `Verbose` attribute to `true`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你通过JMX激活这个输出，你可以转到`java.lang:type=Memory` MBean并将`Verbose`属性设置为`true`。
- en: 'If you want even more details about the GC, you can add the `-XX:+PrintGCDetails` option
    and the lines will be more verbose:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要更多关于GC的详细信息，你可以添加`-XX:+PrintGCDetails`选项，这样行就会更加详细：
- en: '[PRE7]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We can recognize the previous information but there is new data as well:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以识别之前的信息，但也有一些新的数据：
- en: '`PSYoungGen`: This is the collector type; this value means minor GC'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PSYoungGen`：这是收集器类型；这个值表示小GC'
- en: The resizing after (`X->Y(Z)`) shows the young generation size
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: (`X->Y(Z)`)之后的调整显示了年轻代的大小
- en: The last resizing is the full heap one
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后的调整是整个堆的调整
- en: Finally, the duration is expressed in terms of user time, system time, and real
    time
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，持续时间以用户时间、系统时间和实际时间来表示
- en: 'If you want to save all this information (log lines) in a file, you can add
    a flag with a file path and the JVM will dump this output in the file instead
    of the console:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要将所有这些信息（日志行）保存到文件中，你可以添加一个带有文件路径的标志，JVM将把这个输出写入文件而不是控制台：
- en: '[PRE8]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This will allow you to analyze the GC behavior *offline*. There are some tools
    able to parse this output and let you visualize it directly. One of them is *GCViewer*,
    which you can find at [https://github.com/chewiebug/GCViewer/wiki/Changelog](https://github.com/chewiebug/GCViewer/wiki/Changelog).
    Once the JAR is downloaded, you can run it with Java directly:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这将允许你**离线**分析GC行为。有一些工具可以解析这个输出并直接可视化它。其中之一是*GCViewer*，你可以在[https://github.com/chewiebug/GCViewer/wiki/Changelog](https://github.com/chewiebug/GCViewer/wiki/Changelog)找到它。一旦下载了JAR文件，你可以直接用Java运行它：
- en: '[PRE9]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Then, just open the `output.log` file in the interface and you should visualize
    your GC as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，只需在界面中打开`output.log`文件，你应该会这样可视化你的GC：
- en: '![](img/78dc1415-597d-4a0f-a1a4-9ccb6022da73.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](img/78dc1415-597d-4a0f-a1a4-9ccb6022da73.png)'
- en: 'This tool has two main interesting features:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这个工具有两个主要有趣的功能：
- en: The temporal graph deduced from the log output
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从日志输出推导出的时间图
- en: The statistics tabs (on the right) showing the statistic summary of the GC,
    and the number and duration of the pauses
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 右侧的统计标签（显示GC的统计摘要和暂停的次数和持续时间）
- en: This last information can let you validate the behavior of your application
    once you add some caching or some background task parallelly executed with the
    main application.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这最后的信息可以让你在添加一些缓存或与主应用程序并行执行的某些后台任务后验证应用程序的行为。
- en: It will let you ensure the impact of one part of the application on the other
    in terms of memory and potentially find a performance issue if the memory is too
    impacted by this new feature.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使您能够确保应用程序的一部分对另一部分在内存方面的影响，并且如果内存受到新功能的过度影响，可能会发现性能问题。
- en: 'Here is the legend associated with the colors of the graph:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是与图表颜色相关的图例：
- en: '![](img/7c9c01cd-e77b-49df-966c-336bdf0f583d.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7c9c01cd-e77b-49df-966c-336bdf0f583d.png)'
- en: We find most of the information we talked about in the previous part and, particularly,
    the collections, generations, and so on. Note that the *Y* axis can be read with
    two units (time and memory size) depending on which graph you are looking at.
    You will likely filter the printed graphs to see it clearly, but you will find
    all the information you need to see when your GC is running.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前面部分讨论的大多数信息都可以找到，特别是集合、世代等。请注意，*Y*轴可以读取两个单位（时间和内存大小），具体取决于您正在查看哪个图表。您可能会过滤打印的图表以清楚地查看它，但您将在
    GC 运行时找到您需要查看的所有信息。
- en: Heap dump
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 堆转储
- en: 'Sometimes, you will need to get a heap dump to investigate what is in memory
    and why the GC runs so often or for so long. To do so, the JDK provides a tool
    called `jmap` that allows you to take a dump from the Java PID:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，您可能需要获取堆转储以调查内存中的内容以及为什么垃圾回收（GC）运行如此频繁或如此长时间。为此，JDK 提供了一个名为`jmap`的工具，允许您从
    Java PID 中获取转储：
- en: '[PRE10]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This command will stop the application (a bit like a *stop the world* pause)
    and write all the instances into the configured file. Opening the output with
    `jvisualvm` will enable you to investigate the instances, and, in particular, the
    number of instances and the corresponding allocating size.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将停止应用程序（类似于*停止世界*暂停）并将所有实例写入配置的文件中。使用`jvisualvm`打开输出文件将使您能够调查实例，特别是实例的数量和相应的分配大小。
- en: 'Here is what it can look like:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 它可能看起来像这样：
- en: '![](img/831907f8-7b00-40d1-a064-641beb3e487a.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/831907f8-7b00-40d1-a064-641beb3e487a.png)'
- en: Normally, you should mainly see JVM classes such as `char[]`, `String`, `Map`, and
    so on.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，您应该主要看到 JVM 类，如`char[]`、`String`、`Map`等。
- en: 'If you double-click on a type, you will see the instances. For example, on `String`
    for our quote manager dump, we will have a view like this one:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您双击一个类型，您将看到实例。例如，在我们的报价管理器转储中的`String`上，我们将有一个类似这样的视图：
- en: '![](img/ac3cc129-cce2-4737-a950-d6539a5ca24c.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ac3cc129-cce2-4737-a950-d6539a5ca24c.png)'
- en: Here, we visualize the `String` instances related to the request (the request
    URL or a subpart of it, such as the protocol, the host, or the port). So we can
    deduce that the instances are related to the request and its parsing. This is
    perfectly normal, but if you start seeing a lot of your own classes in the classes,
    view, and/or a few classes but with a huge allocation size, you can double-click
    on these types and get the instance details to identify why it happened.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可视化与请求相关的`String`实例（请求 URL 或其子部分，例如协议、主机或端口）。因此，我们可以推断出这些实例与请求及其解析相关。这是完全正常的，但如果您开始看到很多自己的类在类、视图和/或几个类中，但分配大小巨大，您可以双击这些类型以获取实例详细信息以确定为什么会发生这种情况。
- en: 'If we double-click on `JsonQuotePage`, we will see something like this:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们双击`JsonQuotePage`，我们将看到类似这样的内容：
- en: '![](img/2c887942-c264-422b-8209-8072abd044ce.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2c887942-c264-422b-8209-8072abd044ce.png)'
- en: The reference of the instance on the left side (in the list of instances) doesn't
    help us much, but the detailed view (on the right side) of a single instance shows
    the actual data structure with its values.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 左侧（实例列表）的实例引用对我们帮助不大，但单个实例的详细视图（右侧）显示了实际的数据结构及其值。
- en: 'As a reminder, our POJO page model is the following one:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 作为提醒，我们的 POJO 页面模型如下所示：
- en: '[PRE11]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Our structure (class) has two fields: `total` and `items`, and we can find
    these two entries in the detailed view of the instance we obtained from the dump.
    As shown in the screenshot, we can even browse the `items` values. This will let
    you identify whether there is something particular with the values and whether
    you will need to customize the query you use to retrieve the data.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的结构（类）有两个字段：`total`和`items`，我们可以在从转储中获得的实例的详细视图中找到这两个条目。如图所示，我们甚至可以浏览`items`值。这将帮助您确定是否存在特定值，以及您是否需要自定义用于检索数据的查询。
- en: Java EE and the resources
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java EE 和资源
- en: With Java EE, you will likely have a lot of volatile objects (with a short lifespan) that
    are bound to a request. If we take `QuoteResource`, we will first allocate our
    JSON model, then our entity model, and so on. All these instances will be needed
    for the request only and nothing more. Thus, the garbage collector will quickly
    collect them. The garbage collector is quite good for such dynamic applications.
    However, it doesn't mean that we do not have long living instances. Even without
    an application cache, the server caches a lot of metadata to ensure that it works
    and runs fast. One example is the CDI container, which will keep the metadata
    of all the beans in the memory to make sure that it can create them when requested
    by the application. This takes memory and will never be released until the application
    is not deployed. This means that by tuning the memory of your application, you
    will also need to ensure that you tune the memory of the server. As already explained
    earlier, in performance tuning, the application is not only composed of your code
    but also the server code; otherwise, you will miss most of the logic and you can't
    be accurate tuning your application.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Java EE，你可能会遇到很多绑定到请求上的易变对象（生命周期较短）。如果我们以`QuoteResource`为例，我们首先会分配我们的JSON模型，然后是我们的实体模型，等等。所有这些实例仅用于请求，不再需要其他。因此，垃圾收集器会迅速收集它们。垃圾收集器对于这种动态应用来说相当不错。然而，这并不意味着我们没有长期存在的实例。即使没有应用程序缓存，服务器也会缓存大量元数据以确保其正常运行和快速运行。一个例子是CDI容器，它会将所有bean的元数据保存在内存中，以确保当应用程序请求时可以创建它们。这会占用内存，并且只有在应用程序未部署时才会释放。这意味着通过调整应用程序的内存，你还需要确保调整服务器的内存。正如之前已经解释过的，在性能调整中，应用程序不仅由你的代码组成，还包括服务器代码；否则，你将错过大部分逻辑，你无法准确调整应用程序。
- en: 'In general, the server adds some long live instances to ensure that the server
    layer does not slow your application down. However, there is a particular kind
    of logic that the server implements for you that directly impacts the performance
    of your application, and that you will need to watch out for: the resources.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，服务器会添加一些长期存在的实例以确保服务器层不会减慢你的应用程序。然而，服务器为你实现的一种特定逻辑会直接影响应用程序的性能，你需要注意：资源。
- en: What we call resources in an application server is generally what is managed
    by the server. It is often something you want to be able to configure outside
    the application even if Java EE 6 introduced some `@XXXDefinition` annotations
    to be able to do it from the application itself. The goal is to inject a preconfigured—and
    adapted to the current environment—instance. It is also often connected to something
    external or directly related to the machine resources. Since the next chapter
    will be about threading, here, we will focus on the external resources.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在应用程序服务器中称为资源的东西通常是由服务器管理的。这通常是你在应用程序外部想要能够配置的东西，即使Java EE 6引入了一些`@XXXDefinition`注解，以便能够从应用程序本身执行此操作。目标是注入一个预先配置并且适应当前环境的实例。它通常也与外部资源或与机器资源直接相关。由于下一章将介绍线程，在这里，我们将关注外部资源。
- en: 'On top of the list of the most used resources, we find `DataSource`. This represents
    a connection to a database such as MySQL in our quote application. To cite a few
    other well-known resources before digging into the `DataSource` case, you can
    encounter the following:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在最常用资源列表的顶部，我们发现`DataSource`。这代表了我们报价应用程序中连接到数据库（如MySQL）的连接。在深入研究`DataSource`案例之前，你可以遇到以下一些其他知名资源：
- en: Concurrent resources (`ManagedExecutorService`) to handle concurrency. We will
    deal with them in the next chapter.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并发资源（`ManagedExecutorService`）用于处理并发。我们将在下一章中处理它们。
- en: '`DataSource`, which connects to the databases.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DataSource`，它连接到数据库。'
- en: The JMS resources, such as `ConnectionFactory`, which connects to a broker,
    and `Queue` and `Topic`, which represent a destination.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JMS资源，例如`ConnectionFactory`，它连接到代理，以及`Queue`和`Topic`，它们代表目的地。
- en: The Java mail `Session`, which allows you to interact with a mail box (often
    used to send mails from the application).
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java邮件`Session`，它允许你与邮箱交互（通常用于从应用程序发送邮件）。
- en: The resource adapters, which provide a way of handling inputs/outputs in an
    EE fashion (integrated with security and transactions).
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资源适配器，它提供了一种以EE方式处理输入/输出的方式（与安全性和事务集成）。
- en: All these resources are configurable in the server—most of them from the application—and
    allow the operation team (or the person responsible for the deployment) to tune
    the resource the application is using. It also keeps the developer from having
    to care about the configuration and ensure that the deployment will be customizable
    enough.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些资源都可以在服务器中进行配置——大多数来自应用程序——并允许操作团队（或负责部署的人员）调整应用程序使用的资源。这也让开发者不必关心配置，并确保部署足够可定制。
- en: DataSource
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据源
- en: 'To illustrate it, we will refer to our `DataSource` example. In the first chapter,
    we configured a pool and a data source. The data source was just a name in the
    JNDI that the application was using to find the data source and later uses it
    in its JPA layer. This is pretty much what a data source is: a connection factory.
    What is crucial here is the way the connections are managed.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这一点，我们将参考我们的`DataSource`示例。在第一章中，我们配置了一个池和数据源。数据源只是应用程序在JNDI中使用的一个名称，用于查找数据源，并在其JPA层中使用它。这基本上就是数据源：一个连接工厂。这里关键的是连接的管理方式。
- en: 'Most of the time, the production data sources are remote processes or, at least,
    require a network connection. If you remember our MySQL connection URL, we used
    the following:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，生产数据源是远程进程，或者至少需要网络连接。如果你记得我们的MySQL连接URL，我们使用了以下：
- en: '[PRE12]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This is a very common *development* configuration and it connects to `localhost`*.* Thus,
    the network cost is the machine local loop cost, which is generally optimized
    to be very fast. In real deployment, you will more likely connect to the following:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常常见的*开发*配置，并且它连接到`localhost`*.* 因此，网络成本是机器本地环路的成本，这通常被优化得非常快。在实际部署中，你更有可能连接到以下：
- en: '[PRE13]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This URL will mark a remote host, and obtaining a connection will imply some
    real latency. Indeed, it will not be as slow as an internet connection, where
    the network has a lot of switches, routers, and hops. However, going over the
    network always implies some milliseconds of latency.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这个URL将标记一个远程主机，获取连接将涉及一些实际延迟。确实，它不会像互联网连接那样慢，因为网络有很多交换机、路由器和跳数。然而，通过网络始终意味着一些毫秒级的延迟。
- en: What is interesting with data sources (it is also the case for JMS resources
    in general) is that the protocol associated with the connection is a connected
    protocol. Understand that once the connection is obtained, sending a command is
    faster, as you don't have to create another connection.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 数据源（这通常也适用于JMS资源）有趣的地方在于与连接关联的协议是一个连接协议。理解一旦获得连接，发送命令就会更快，因为你不必创建另一个连接。
- en: 'If you ran the quote manager application, you would probably get some warning
    like this one:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行了报价管理器应用程序，你可能会得到一些这样的警告：
- en: '[PRE14]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This warning is issued by the MySQL driver and encourages you to use SSL for
    the network communication. This is mainly for security reasons, but the SSL connection
    is even slower. You can check out the HTTP2 protocol (introduced in Servlet 4.0
    release, included in Java EE 8) that introduces the push protocol to avoid doing
    too many connections from the browser over SSL, because it was starting to be
    really slow with modern applications having a lot of web resources.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这个警告是由MySQL驱动程序发出的，并鼓励你使用SSL进行网络通信。这主要是出于安全原因，但SSL连接甚至更慢。你可以查看HTTP2协议（在Servlet
    4.0版本中引入，包含在Java EE 8中），它引入了推送协议以避免浏览器通过SSL进行过多的连接，因为随着现代应用程序拥有大量网络资源，这已经开始变得非常慢。
- en: This means that reusing the same connection over and over is always a good idea
    because it will cut down the actual connection step and will just let the application
    issue commands and do its business.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着反复重用相同的连接总是一个好主意，因为它将减少实际的连接步骤，并让应用程序发出命令并执行其业务。
- en: 'To solve this *connection* issue, the server configures the data source as
    a connection pool. A pool is a set of reusable connections. Each server has its
    own pool and its own configuration, which are more or less advanced but all share
    the same logic:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个*连接*问题，服务器将数据源配置为连接池。一个池是一组可重用的连接。每个服务器都有自己的池和自己的配置，这些配置或多或少是高级的，但都遵循相同的逻辑：
- en: '**Some size configuration**: The number of connections to keep in the memory
    while the server is idled (min), the number of connections that can be created
    (max), how long a connection can be awaited, and so on'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一些大小配置**：在服务器空闲时保持内存中的连接数量（最小值），可以创建的连接数量（最大值），连接可以等待多长时间，等等'
- en: '**Some eviction configuration**: The way to determine a connection should be
    dropped from the pool'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一些驱逐配置**：确定一个连接应该从池中移除的方式'
- en: 'The eviction is very important as the pool is related to long running connections.
    You, therefore, need to be able to remove transparently the corrupted connections.
    For instance, the MySQL server drops a connection after 8 hours by default. So,
    if you run your application for 8 hours and 1 minute, all the requests will start
    failing if you don''t have any eviction. For a data source, this is generally
    done with `ValidationQuery`, which is a SQL query executed from time to time.
    If this fails, it is considered as invalidating the connection and removing it
    from the pool. The *time to time* can generally be configured too, and can mainly
    mean three moments: *before the connection is shared and given to the application*,
    *when the connection is given back to the pool* (the application is done with
    it), or *in a background thread when the connection is idled*.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 驱逐非常重要，因为池与长时间运行的连接相关。因此，你需要能够透明地移除损坏的连接。例如，MySQL服务器默认情况下在8小时后丢弃连接。所以，如果你运行你的应用程序8小时又1分钟，如果没有驱逐，所有请求都将开始失败。对于数据源，这通常是通过`ValidationQuery`完成的，这是一个定时执行的SQL查询。如果这个查询失败，它被认为是验证连接无效并从池中移除。*定时*通常也可以配置，主要可以意味着三个时刻：*在连接被共享并分配给应用程序之前*，*当连接被归还到池中时*（应用程序已经完成），或者*在后台线程中连接空闲时*。
- en: The choice is a trade-off between *do you accept a few requests failing because
    the connection was not yet evicted by the background thread* and *do you accept
    it to be a bit slower because the connection is validated every time*. You can
    even mix all these validation types. A very important point here is to make sure
    that the validation query is very fast to execute. Never use `SELECT * from CUSTOMER`,
    which can return back thousands (or more) lines. Always use a constant result
    set query. For MySQL, it is recommended that you use `SELECT 1`, which will just
    return `1`. Each database has this kind of query, so check it out and ensure that
    it is well configured in your pool.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 选择是在*你接受因为连接尚未被后台线程驱逐而导致一些请求失败*和*你接受它稍微慢一点，因为每次连接都需要验证*之间权衡。你甚至可以混合所有这些验证类型。这里一个非常重要的点是确保验证查询执行非常快。永远不要使用`SELECT
    * from CUSTOMER`，这可能会返回成千上万（或更多）行。始终使用一个常量结果集查询。对于MySQL，建议你使用`SELECT 1`，这将只返回`1`。每个数据库都有这种查询，所以请检查它，并确保它在你的池中配置得当。
- en: You will indeed find other configurations depending on the pool you rely on,
    but they are less impacting on the performance, so we will not detail them here.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 你确实会发现根据你所依赖的池子，会有其他配置，但它们对性能的影响较小，所以我们在这里不会详细说明。
- en: One crucial thing about the connection pools—data source ones or not—is to make
    sure you are not waiting for them. As suggested earlier, if you are waiting for
    connections, then you are slower than you should be, as the pool should avoid
    this case. This means that when it comes to the performance, you don't have to
    hesitate and should just ask your pool to never wait for a connection. This parameter
    is often called *Max Wait Time*. Setting it to 0 or something very small can cause
    your application to start failing with exceptions saying that the application
    was not able to retrieve a connection in the configured time. This is exactly
    what we want! This means that the pool is too small for the application's needs
    and, thus, you need to increase the pool size. Alternatively, you can also decrease
    the load sent to the server. It doesn't mean you shouldn't configure any wait
    time in production. This is a parameter that can ensure you respond to your clients,
    but it will potentially increase your response time. If it is acceptable, don't
    hesitate to increase the value once you've tuned the application, but don't do
    it before ensuring that you are not using a wrongly configured pool.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 关于连接池的一个关键点是——无论是数据源连接池还是其他类型的连接池——确保你不会等待它们。如前所述，如果你在等待连接，那么你的速度会比应有的速度慢，因为连接池应该避免这种情况。这意味着在性能方面，你不必犹豫，只需要求你的连接池永远不要等待连接。这个参数通常被称为*最大等待时间*。将其设置为0或非常小可能导致你的应用程序开始失败，并抛出异常，表示应用程序无法在配置的时间内检索到连接。这正是我们想要的！这意味着连接池对于应用程序的需求来说太小了，因此你需要增加连接池的大小。或者，你也可以减少发送到服务器的负载。这并不意味着在生产环境中你不应该配置任何等待时间。这是一个可以确保你响应客户的参数，但它可能会增加你的响应时间。如果这是可以接受的，一旦调整了应用程序，你就不必犹豫地增加这个值，但在做之前，请确保你没有使用错误配置的连接池。
- en: If your pool size is too small, you will likely see it in the stack traces or
    in the monitoring you set up with the invocation, such as `allocateConnection`
    or `getConnection`, depending on your server.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的连接池大小过小，你可能会在堆栈跟踪中看到它，或者在调用时设置的监控中看到，例如`allocateConnection`或`getConnection`，具体取决于你的服务器。
- en: 'In terms of size tuning, it is tempting to simply set as many connections as
    possible, but you need to keep in mind a few important points:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在调整大小方面，简单地设置尽可能多的连接可能很有吸引力，但你需要记住几个重要点：
- en: The database connection count can be limited. Never allocate all of them to
    your application cluster, and ensure that you can keep at least a few for maintenance
    purposes. For instance, if your MySQL allows 152 connections (default `max_connections`
    of MySQL is 151 and `mysqld` allows `max_connections+1` actual connections), then
    your application—as a cluster—can use 140 connections.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库连接数可能有限。永远不要将所有连接都分配给你的应用程序集群，并确保你可以保留至少几个用于维护目的。例如，如果你的MySQL允许152个连接（MySQL的默认`max_connections`为151，而`mysqld`允许`max_connections+1`个实际连接），那么你的应用程序作为一个集群，可以使用140个连接。
- en: The pool handling requires you to deal with concurrency. Your application will
    request connections from all its threads and then the container pool will need
    to give different connections to all the threads to ensure that there is no data
    corruption of cross-thread connection usage. On the other hand, eviction will
    also happen at the same time the application is running and will potentially lock
    the pool (it is close to the GC algorithm problem). The smaller the work needed
    to be done on the pool, the better it will behave and the less it will impact
    the application.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接池的处理需要你处理并发。你的应用程序将从所有线程请求连接，然后容器池需要为所有线程提供不同的连接，以确保没有跨线程连接使用的数据损坏。另一方面，在应用程序运行的同时也会发生回收，可能会锁定连接池（这接近GC算法问题）。需要处理的池工作越少，它的表现就越好，对应用程序的影响就越小。
- en: This means that not over adjusting the pool is also important. It is generally
    a heuristic you should do based on your application and the targeted SLA. If you
    have no idea about the size you must use, you can start setting the maximum size
    of the pool to 25% of your maximum concurrent threads (HTTP pool size, for instance)
    and then increase it until you don't get an error anymore, with a maximum wait
    time of 0.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着不过度调整连接池也很重要。这通常是一个基于你的应用程序和目标SLA的启发式方法。如果你对必须使用的连接池大小没有头绪，你可以从将连接池的最大大小设置为最大并发线程数的25%（例如HTTP连接池大小）开始，然后逐渐增加，直到不再出现错误，最大等待时间为0。
- en: Java EE and pools
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java EE和连接池
- en: 'Java EE has a lot of pool types involved in its stack. Here is a summary of
    the ones you may want to have a look at while tuning your application. Each time,
    the tuning logic will be based on the same logic: no wait time and start with
    a medium size in order not to over allocate resources and impact the application
    too much.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: Java EE 在其堆栈中涉及许多池类型。以下是在调整应用程序时你可能想查看的池类型总结。每次调整逻辑都将基于相同的逻辑：没有等待时间，并从中等大小开始，以避免过度分配资源并过度影响应用程序。
- en: '| **Pool Type** | **Description** |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| **池类型** | **描述** |'
- en: '| The `DataSource` pool | This handles and recycles database connections. |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| `DataSource` 池 | 这处理和回收数据库连接。 |'
- en: '| The `ConnectionFactory` pool | This handles JMX connections to the broker.
    |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| `ConnectionFactory` 池 | 这处理与代理的 JMX 连接。 |'
- en: '| The `@Stateless` pool | This handles the recycling of stateless instances.
    Today, it is relevant when stateless instances are used as a poor man throttling
    implementation (max instance = max concurrency) or when the instances access some
    thread of unsafe resources, which is very expensive to instantiate. It can be
    seen as the Java EE pool API for application needs. |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| `@Stateless` 池 | 这处理无状态实例的回收。如今，当无状态实例用作穷人的节流实现（最大实例 = 最大并发性）或实例访问某些不安全的资源时，这些资源非常昂贵且难以实例化，它就变得相关。它可以被视为针对应用程序需求的
    Java EE 池 API。 |'
- en: '| The HTTP thread pool | These threads are used to server the requests. They
    often have some sibling threads to accept the connection (selector threads). |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| HTTP 线程池 | 这些线程用于处理请求。它们通常有一些兄弟线程来接受连接（选择器线程）。 |'
- en: '| The managed thread pool | This is usable by the application; these thread
    pools are used to execute custom tasks. They are often used in reactive programming
    to inherit from EE features in a reactive stack, such as RxJava. |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| 管理的线程池 | 应用程序可以使用这些线程池来执行自定义任务。它们通常用于反应式编程，以继承反应堆栈中的 EE 功能，如 RxJava。 |'
- en: '| The Resource Adapter / JCA Connector pool | The JCA specification defines
    multiple pools: the instance pools that are configured in a dependent way but
    share the same principle as the other pools, and the thread pool using `WorkManager`,
    which is the pre EE concurrency utility way to have a user thread pool injected
    by the server into the application (connector here). Applications rarely use JCA
    connectors today, but if you have inherited one, ensure that it is well tuned
    and integrated with your server. |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '| 资源适配器/ JCA 连接器池 | JCA 规范定义了多个池：以依赖方式配置但与其他池具有相同原则的实例池，以及使用 `WorkManager`
    的线程池，这是在 EE 并发工具方式中，由服务器注入到应用程序（连接器此处）的用户线程池。如今，应用程序很少使用 JCA 连接器，但如果你继承了其中一个，请确保它已良好调整并与你的服务器集成。
    |'
- en: Java EE and HTTP pools
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java EE 和 HTTP 池
- en: Even if Java EE containers are more and more commonly used for daemons and standalone
    applications, most of the developed applications are still web applications and,
    therefore, use HTTP either as clients of another server or as the server themselves.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 即使 Java EE 容器越来越多地用于守护程序和独立应用程序，但大多数开发的应用程序仍然是 Web 应用程序，因此要么作为其他服务器的客户端使用 HTTP，要么作为服务器本身。
- en: In the last sentence, *Java EE containers* include the wide embedded varieties
    of containers such as TomEE Embedded, Apache Meecrowave, WildFly Swarm, and so
    on, and is not limited to standalone containers or full profile servers.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一句话中，*Java EE 容器* 包括广泛的嵌入式容器，如 TomEE Embedded、Apache Meecrowave、WildFly Swarm
    等，并不仅限于独立容器或完整配置的服务器。
- en: This means that the Java EE configuration will have to deal with HTTP configuration.
    It needs to be handled at multiple levels (networks, HTTP caching, and so on)
    but also in multiple layers (server/HTTP connector, client connection pooling,
    SSL tuning, and so on).
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着 Java EE 配置将不得不处理 HTTP 配置。它需要在多个级别（网络、HTTP 缓存等）以及多个层次（服务器/HTTP 连接器、客户端连接池、SSL
    调优等）进行处理。
- en: 'We will delve into more details about this in [Chapter 5](cdbfd25b-1b43-4b9d-b45c-78586b39ebb5.xhtml), *Scale
    Up: Threading and Implications* for the pooling - related configuration and in
    [Chapter 6](8db12a5f-dba9-449b-af38-4963ac0adec0.xhtml), *Be Lazy, Cache Your
    Data* for the caching configuration.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在第 5 章 [深入探讨此细节](cdbfd25b-1b43-4b9d-b45c-78586b39ebb5.xhtml)，*扩展：线程和影响*，以及第
    6 章 [懒加载，缓存你的数据](8db12a5f-dba9-449b-af38-4963ac0adec0.xhtml)中详细介绍相关配置。
- en: Java EE implicit features
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java EE 隐含特性
- en: The Java EE philosophy has always been *to work out of the box*. However, it
    may have some impact on the performance as, sometimes, features are activated
    without your application requiring them at all. If you know that you don't need
    a feature, don't hesitate to disable it.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: Java EE 哲学始终是 *即开即用*。然而，它可能对性能有一定影响，因为有时功能被激活，而你的应用程序根本不需要它们。如果你知道你不需要一个功能，请不要犹豫去禁用它。
- en: 'For instance, in `persistence.xml`*,* we disabled bean validation integration
    adding this line:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在 `persistence.xml`*，* 我们通过添加以下行禁用了 bean 验证集成：
- en: '[PRE15]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This avoids the JPA provider adding the bean validation listeners it uses to
    validate the entities and, thus, saves some CPU cycles without impacting the application.
    If you check the chain of our application, we use JAX-RS (has a bean validation
    integration) and then JPA (has another bean validation integration).
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这样可以避免 JPA 提供者添加用于验证实体的 bean 验证监听器，从而在不影响应用程序的情况下节省一些 CPU 周期。如果你检查我们应用程序的链，我们使用
    JAX-RS（具有 bean 验证集成）然后是 JPA（具有另一个 bean 验证集成）。
- en: The rule for validation can be to always validate the data when it is entering
    the system (JAX-RS for us) and not validate them internally. In fact, it is redundant
    in terms of application logic. This is why it is fine to disable it at the JPA
    layer, for instance.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 验证的规则可以是始终在数据进入系统时（对我们来说是 JAX-RS）进行验证，而不是在内部进行验证。实际上，从应用程序逻辑的角度来看是多余的。这就是为什么在
    JPA 层禁用它是可以的。
- en: Summary
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we saw how memory is managed with Java, and how to influence
    it to optimize and adapt it to your application requirements. We also saw how
    the Java EE server-provided resources help you save time, as they not only enable
    you to skip reconnection time between usages but also imply a dedicated tuning
    to not abuse the server memory and CPU.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了 Java 如何管理内存，以及如何影响它以优化和适应你的应用程序需求。我们还看到了 Java EE 服务器提供的资源如何帮助你节省时间，因为它们不仅使你能够跳过使用之间的重新连接时间，而且意味着对服务器内存和
    CPU 的专用调整。
- en: The idea behind this chapter is to ensure that you have the keys and knowledge
    to be able to investigate any issue with memory and to be able to tune the memory
    and resources without being lost or using some random numbers.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 本章背后的想法是确保你拥有调查任何内存问题的关键和知识，并且能够在不迷失方向或使用一些随机数字的情况下调整内存和资源。
- en: Also, this part is probably the most unportable one and will be related to the
    JVM (for the memory) and server (for the resources) you'll use in your deployment.
    All the concepts will still apply but the way you tune them can differ, since
    this is not something standardized yet—even if the JVM tuning does not change
    as much as server configurations. However, don't hesitate to check out your JVM
    or server documentation and make sure to have read it before entering into a benchmark
    phase in order not to lose time in testing options you don't know upfront.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，这部分可能是最不可移植的部分，并且将与你在部署中使用的 JVM（对于内存）和服务器（对于资源）相关。所有概念仍然适用，但调整它们的方式可能不同，因为这不是一个标准化的东西——即使
    JVM 调优的变化不如服务器配置那么大。然而，不要犹豫去查看你的 JVM 或服务器文档，并确保在进入基准测试阶段之前已经阅读过，以免在测试你事先不知道的选项时浪费时间。
- en: 'In the next chapter, we will see how to make the most of Java EE concurrent
    programming and how it is linked to the Java EE threading model to ensure that
    your application can scale. The memory and the CPU are the two most central resources
    a server uses on a machine: we just saw the memory resource, and we will now deal
    with the CPU through the threading study.'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看到如何充分利用 Java EE 并发编程，以及它与 Java EE 线程模型的关系，以确保你的应用程序可以扩展。内存和 CPU 是服务器在机器上使用的两种最核心的资源：我们刚刚看到了内存资源，现在我们将通过线程研究来处理
    CPU。
