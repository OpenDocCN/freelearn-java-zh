- en: New Tools and Tool Enhancements
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 新工具和工具增强
- en: In the previous chapter, we explored Java 9's new stack walker API and learned
    how it enables Java applications to walk the calling stack. This is a specialized
    functionality that is not often implemented in Java applications. That being said,
    the API may be good for some very special cases, such as for functionality that
    is delivered by a framework. You learned that if you develop framework-supporting
    application programming and you want code that depends on the caller context,
    then the stack walker API is for you. We also discovered that the API gives fast
    and optimized access to the call stack, implementing lazy access to the individual
    frames.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们探讨了Java 9的新堆栈跟踪器API，并学习了它如何使Java应用程序能够遍历调用堆栈。这是一个在Java应用程序中不常实现的专业功能。话虽如此，该API可能适用于一些非常特殊的情况，例如由框架提供的功能。您了解到，如果您开发支持框架的应用程序编程，并且需要依赖于调用上下文的代码，那么堆栈跟踪器API就是您所需要的。我们还发现，该API提供了对调用堆栈的快速和优化访问，实现了对单个帧的懒访问。
- en: In this chapter, we will cover 16 **Java Enhancement Proposals** (**JEPs**)
    that were incorporated into the Java 9 platform. These JEPs cover a wide range
    of tools and updates to APIs to make developing with Java easier, with greater
    optimization possibilities for our resulting programs.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍被纳入Java 9平台的16个**Java增强提案**（**JEPs**）。这些JEPs涵盖了广泛的工具和API更新，以使使用Java开发更加容易，并为我们的程序提供更大的优化可能性。
- en: 'Our review of new tools and tool enhancements will include the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对新的工具和工具增强的回顾将包括以下内容：
- en: The new HTTP client
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新的HTTP客户端
- en: Javadoc and the Doclet API
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Javadoc和Doclet API
- en: mJRE changes
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: mJRE更改
- en: JavaScript parser
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript解析器
- en: Multi-release JAR files
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多版本JAR文件
- en: The Java-level JVM compiler interface
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java级别的JVM编译器接口
- en: TIFF support
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TIFF支持
- en: Platform logging
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 平台日志记录
- en: XML Catalogs
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: XML目录
- en: Collections
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集合
- en: Platform-specific desktop features
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 平台特定的桌面功能
- en: Enhanced method handling
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 增强方法处理
- en: Enhanced deprecation
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 增强弃用
- en: The new HTTP client [JEP-110]
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 新的HTTP客户端[JEP-110]
- en: In this section, we will review Java's **Hypertext Transfer Protocol** (**HTTP**)
    client, starting with a pre-Java 9 look and then diving into the new HTTP client
    that is part of the Java 9 platform. This approach is needed to support an understanding
    of the changes made in Java 9.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将回顾Java的**超文本传输协议**（**HTTP**）客户端，从Java 9之前的样式开始，然后深入探讨Java 9平台中的新HTTP客户端。这种做法是为了支持对Java
    9中做出的更改的理解。
- en: The HTTP client before Java 9
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java 9之前的HTTP客户端
- en: 'JDK version 1.1 introduced the `HttpURLConnection` API that supported HTTP-specific
    features. This was a robust class that included the fields listed here:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: JDK版本1.1引入了支持HTTP特定功能的`HttpURLConnection` API。这是一个包含此处列出的字段的健壮类：
- en: '`chunkLength`'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`chunkLength`'
- en: '`fixedContentLength`'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fixedContentLength`'
- en: '`fixedContentLengthLong`'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fixedContentLengthLong`'
- en: '`HTTP_ACCEPTED`'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HTTP_ACCEPTED`'
- en: '`HTTP_BAD_GATEWAY`'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HTTP_BAD_GATEWAY`'
- en: '`HTTP_BAD_METHOD`'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HTTP_BAD_METHOD`'
- en: '`HTTP_BAD_REQUEST`'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HTTP_BAD_REQUEST`'
- en: '`HTTP_CLIENT_TIMEOUT`'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HTTP_CLIENT_TIMEOUT`'
- en: '`HTTP_CONFLICT`'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HTTP_CONFLICT`'
- en: '`HTTP_CREATED`'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HTTP_CREATED`'
- en: '`HTTP_ENTITY_TOO_LARGE`'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HTTP_ENTITY_TOO_LARGE`'
- en: '`HTTP_FORBIDDEN`'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HTTP_FORBIDDEN`'
- en: '`HTTP_GONE`'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HTTP_GONE`'
- en: '`HTTP_INTERNAL_ERROR`'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HTTP_INTERNAL_ERROR`'
- en: '`HTTP_LENGTH_REQUIRED`'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HTTP_LENGTH_REQUIRED`'
- en: '`HTTP_MOVED_PERM`'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HTTP_MOVED_PERM`'
- en: '`HTTP_MOVED_TEMP`'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HTTP_MOVED_TEMP`'
- en: '`HTTP_MULT_CHOICE`'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HTTP_MULT_CHOICE`'
- en: '`HTTP_NO_CONTENT`'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HTTP_NO_CONTENT`'
- en: '`HTTP_NOT_ACCEPTABLE`'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HTTP_NOT_ACCEPTABLE`'
- en: '`HTTP_NOT_AUTHORITATIVE`'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HTTP_NOT_AUTHORITATIVE`'
- en: '`HTTP_NOT_FOUND`'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HTTP_NOT_FOUND`'
- en: '`HTTP_NOT_IMPLEMENTED`'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HTTP_NOT_IMPLEMENTED`'
- en: '`HTTP_NOT_MODIFIED`'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HTTP_NOT_MODIFIED`'
- en: '`HTTP_OK`'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HTTP_OK`'
- en: '`HTTP_PARTIAL`'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HTTP_PARTIAL`'
- en: '`HTTP_PAYMENT_REQUIRED`'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HTTP_PAYMENT_REQUIRED`'
- en: '`HTTP_PRECON_FAILED`'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HTTP_PRECON_FAILED`'
- en: '`HTTP_PROXY_AUTH`'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HTTP_PROXY_AUTH`'
- en: '`HTTP_REQ_TOO_LONG`'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HTTP_REQ_TOO_LONG`'
- en: '`HTTP_RESET`'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HTTP_RESET`'
- en: '`HTTP_SEE_OTHER`'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HTTP_SEE_OTHER`'
- en: '`HTTP_SERVER_ERROR`'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HTTP_SERVER_ERROR`'
- en: '`HTTP_UNAUTHORIZED`'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HTTP_UNAUTHORIZED`'
- en: '`HTTP_UNAVAIABLE`'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HTTP_UNAVAIABLE`'
- en: '`HTTP_UNSUPPORTED_TYPE`'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HTTP_UNSUPPORTED_TYPE`'
- en: '`HTTP_USE_PROXY`'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HTTP_USE_PROXY`'
- en: '`HTTP_VERSION`'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HTTP_VERSION`'
- en: '`instanceFollowRedirects`'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`instanceFollowRedirects`'
- en: '`method`'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`method`'
- en: '`responseCode`'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`responseCode`'
- en: '`responseMessage`'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`responseMessage`'
- en: 'As you can see from the list of fields, there was a great support for HTTP.
    In addition to a constructor, there are a plethora of available methods, including
    the following ones:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从字段列表中看到的，对HTTP的支持非常广泛。除了构造函数之外，还有许多可用的方法，包括以下这些：
- en: '`disconnect()`'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`disconnect()`'
- en: '`getErrorStream()`'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getErrorStream()`'
- en: '`getFollowRedirects()`'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getFollowRedirects()`'
- en: '`getHeaderField(int n)`'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getHeaderField(int n)`'
- en: '`getHeaderFieldDate(String name, long Default)`'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getHeaderFieldDate(String name, long Default)`'
- en: '`getHeaderFieldKey(int n)`'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getHeaderFieldKey(int n)`'
- en: '`getInstanceFollowRedirects()`'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getInstanceFollowRedirects()`'
- en: '`getPermission()`'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getPermission()`'
- en: '`getRequestMethod()`'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getRequestMethod()`'
- en: '`getResponseCode()`'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getResponseCode()`'
- en: '`getResponseMessage()`'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getResponseMessage()`'
- en: '`setChunkedStreamingMode(int chunklen)`'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setChunkedStreamingMode(int chunklen)`'
- en: '`setFixedLengthStreamingMode(int contentLength)`'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setFixedLengthStreamingMode(int contentLength)`'
- en: '`setFixedlengthStreamingMode(long contentLength)`'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setFixedlengthStreamingMode(long contentLength)`'
- en: '`setFollowRedirects(boolean set)`'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setFollowRedirects(boolean set)`'
- en: '`setInstanceFollowRedircts(boolean followRedirects)`'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setInstanceFollowRedircts(boolean followRedirects)`'
- en: '`setRequestMethod(String method)`'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setRequestMethod(String method)`'
- en: '`usingProxy()`'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`usingProxy()`'
- en: The class methods listed earlier are in addition to the methods inherited from
    the `java.net.URLConnection` class and the `java.lang.Object` class.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 之前列出的类方法除了从`java.net.URLConnection`类和`java.lang.Object`类继承的方法外，还包括。
- en: 'There were problems with the original HTTP client that made it ripe for updating
    with the new Java platform. Those problems were as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 原始HTTP客户端存在一些问题，这使得它非常适合使用新的Java平台进行更新。这些问题如下：
- en: The base `URLConnection` API had, defunct protocols such as Gopher and FTP increasingly
    over the years
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基础`URLConnection` API有，如Gopher和FTP等已废弃的协议，随着时间的推移越来越多
- en: The `HttpURLConnection` API predated HTTP 1.1 and was overly abstract, making
    it less usable
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HttpURLConnection` API在HTTP 1.1之前就已经存在，并且过于抽象，使其不太可用'
- en: The HTTP client was woefully under documented, making the API frustrating and
    difficult to use
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP客户端严重缺乏文档，使得API令人沮丧且难以使用
- en: The client only functioned on one thread at a time
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端一次只能在一个线程上运行
- en: The API was extremely difficult to maintain due to the above points about it
    predating HTTP 1.1 and it lacking sufficient documentation
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于它早于HTTP 1.1并且缺乏足够的文档，该API难以维护
- en: Now that we know what was wrong with the HTTP client, let's look at what's in
    store for Java 9.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经知道了HTTP客户端的问题，让我们看看Java 9有哪些期待。
- en: Java 9's new HTTP client
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java 9的新HTTP客户端
- en: 'There were several goals associated with creating the new HTTP client for the
    Java 9 platform. JEP-110 was the organizing proposal for the new HTTP client.
    The primary goals of JEP-110 are listed here and featured the creation of the
    new HTTP client presented. These goals are presented in the broad categories of
    ease of use, core capabilities, additional capabilities, and performance:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 创建Java 9平台的新的HTTP客户端有几个相关目标。JEP-110是新HTTP客户端的组织提案。JEP-110的主要目标在此列出，并展示了所提出的新HTTP客户端。这些目标按易用性、核心功能、其他功能和性能的广泛类别呈现：
- en: 'Ease of use:'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 易用性：
- en: The API was designed to provide up to 90 percent of HTTP-related application
    requirements.
  id: totrans-93
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该API旨在提供高达90%的HTTP相关应用程序需求。
- en: The new API is usable, without unnecessary complexity, for the most common use
    cases.
  id: totrans-94
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新的API简单易用，适用于最常见的用例。
- en: A simplistic blocking mode is included.
  id: totrans-95
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含一个简单的阻塞模式。
- en: The API supports modern Java language features. Lambda expressions, a major
    new introduction released with Java 8, are an example.
  id: totrans-96
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该API支持现代Java语言特性。Java 8中引入的主要新特性Lambda表达式就是一个例子。
- en: 'Core capabilities:'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 核心功能：
- en: Supports HTTPS/TLS
  id: totrans-98
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持HTTPS/TLS
- en: Supports HTTP/2
  id: totrans-99
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持HTTP/2
- en: Provides visibility on all details related to HTTP protocol requests and responses
  id: totrans-100
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供有关HTTP协议请求和响应的所有细节的可见性
- en: Supports standard/common authentication mechanisms
  id: totrans-101
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持标准/常用认证机制
- en: Provides **headers received** event notifications
  id: totrans-102
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供接收**头部**事件通知
- en: Provides **response body received** event notifications
  id: totrans-103
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供接收**响应体**事件通知
- en: Provides error event notifications
  id: totrans-104
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供错误事件通知
- en: 'Additional capabilities:'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他功能：
- en: The new API can be used for WebSocket handshakes
  id: totrans-106
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新的API可用于WebSocket握手
- en: It performs security checks in concert with the current networking API
  id: totrans-107
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它与当前的网络API一起执行安全检查
- en: 'Performance:'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能：
- en: 'For HTTP/1.1:'
  id: totrans-109
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于HTTP/1.1：
- en: The new API must perform at least as efficiently as the previous API.
  id: totrans-110
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新的API必须至少与之前的API一样高效。
- en: Memory consumption must not exceed that of Apache HttpClient, Netty, and Jetty,
    when being used as a client API.
  id: totrans-111
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当用作客户端API时，内存消耗不得超过Apache HttpClient、Netty和Jetty。
- en: 'For HTTP/2:'
  id: totrans-112
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于HTTP/2：
- en: Performance must exceed that of HTTP/1.1.
  id: totrans-113
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能必须超过HTTP/1.1。
- en: The new performance must match or exceed that of Netty and Jetty when being
    used as a client API. No performance degradation should be a result of the new
    client.
  id: totrans-114
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当用作客户端API时，新的性能必须与Netty和Jetty相当或更好。新的客户端不应导致性能下降。
- en: Memory consumption must not exceed that of Apache HttpClient, Netty, and Jetty,
    when being used as a client API.
  id: totrans-115
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当用作客户端API时，内存消耗不得超过Apache HttpClient、Netty和Jetty。
- en: Avoids running timer threads
  id: totrans-116
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免运行计时线程
- en: New API limitations
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 新API的限制
- en: There are some intentional shortcomings of the new API. While this might sound
    counter-intuitive, the new API was not intended to completely replace the current
    `HttpURLConnection` API. Instead, the new API is intended to eventually replace
    the current one.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 新API有一些故意的不足之处。虽然这听起来可能有些反直觉，但新的API并不是旨在完全取代当前的`HttpURLConnection` API。相反，新的API旨在最终取代当前的API。
- en: 'The following code snippet provides an example of how to implement the `HttpURLConnect`
    class to open and read a URL in a Java application:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段提供了一个示例，说明如何在Java应用程序中实现`HttpURLConnect`类以打开和读取URL：
- en: '[PRE0]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The preceding code does not include exception handling for brevity.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简洁，前面的代码没有包含异常处理。
- en: 'Here are some specific limitations of the new API:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 新API的一些具体限制如下：
- en: Not all HTTP-related functionality is supported. It is estimated that about
    10 percent of the HTTP's protocol is not exposed by the API.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并非所有与HTTP相关的功能都得到支持。据估计，大约有10%的HTTP协议没有被API暴露。
- en: Standard/common authentication mechanisms have been limited to basic authentication.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标准的/常见的身份验证机制仅限于基本身份验证。
- en: The overarching goal of the new API was the simplicity of use, which means that
    performance improvements might not be realized. Certainly, there will be no performance
    degradation, but there is not likely to be an overwhelming level of improvement,
    either.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新API的总体目标是使用简单性，这意味着性能改进可能不会实现。当然，不会有性能下降，但也不太可能有一个压倒性的改进水平。
- en: There is no support for filtering on requests.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对请求的过滤没有支持。
- en: There is no support for filtering on responses.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对响应的过滤没有支持。
- en: The new API does not include a pluggable connection cache.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新的API不包括可插拔的连接缓存。
- en: There is a lack of a general upgrade mechanism.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缺乏一个通用的升级机制。
- en: The new API is delivered as part of the Java 9 platform in the incubator mode.
    This suggests that the API will be standardized in a future Java platform, perhaps
    with Java 10.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 新API作为Java 9平台的一部分以孵化模式提供。这表明该API将在未来的Java平台上标准化，可能是Java 10。
- en: Simplified Doclet API [JEP-221]
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简化的Doclet API [JEP-221]
- en: The Doclet API and Javadoc are closely related. Javadoc is a documentation tool
    and the Doclet API provides functionality so that we can inspect the javadoc comments
    embedded at the source-levels of libraries and programs. In this section, we will
    review the pre-Java 9 status of the Doclet API and then explore the changes introduced
    to the Doclet API in the Java 9 platform. In the following section, we will review
    Javadoc.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: Doclet API和Javadoc密切相关。Javadoc是一个文档工具，而Doclet API提供了功能，使我们能够检查嵌入在库和程序源代码级别的javadoc注释。在本节中，我们将回顾Java
    9之前的Doclet API状态，然后探讨Java 9平台引入的Doclet API的变化。在下一节中，我们将回顾Javadoc。
- en: The pre-Java 9 Doclet API
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java 9之前的Doclet API
- en: The pre-Java 9 Doclet API, or the `com.sun.javadoc` package, gives us access
    to look at javadoc comments located in the source code. Invoking a Doclet is accomplished
    by using the `start` method. That method's signature is `public static boolean
    start(RootDoc root)`. We will use the `RootDoc` instance as a container for the
    program structure information.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: Java 9之前的Doclet API，或`com.sun.javadoc`包，使我们能够查看位于源代码中的javadoc注释。通过使用`start`方法调用Doclet。该方法签名是`public
    static boolean start(RootDoc root)`。我们将使用`RootDoc`实例作为程序结构信息的容器。
- en: 'In order to call javadoc, we need to pass the following:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 为了调用javadoc，我们需要传递以下内容：
- en: Package names
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包名
- en: Source file names (for classes and interfaces)
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 源文件名（对于类和接口）
- en: 'An access control option--one of the following:'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个访问控制选项——以下之一：
- en: '`package`'
  id: totrans-139
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`package`'
- en: '`private`'
  id: totrans-140
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`private`'
- en: '`protected`'
  id: totrans-141
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`protected`'
- en: '`public`'
  id: totrans-142
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public`'
- en: When the preceding listed items are used to call javadoc, a **documented set**
    is provided as a filtered list. If our aim is to obtain a comprehensive, unfiltered
    list, we can use `allClasses(false)`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用前面列出的项目调用javadoc时，会提供一个**文档集**作为过滤后的列表。如果我们目的是获得一个全面、未过滤的列表，我们可以使用`allClasses(false)`。
- en: 'Let''s review an example Doclet:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一个示例Doclet：
- en: '[PRE1]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'As you can see by the thoroughly commented code, gaining access to the javadoc
    content is relatively easy. In our preceding example, we would invoke the `AllThrows`
    class using the following code in the command line:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如您通过详尽的注释代码所看到的，获取javadoc内容相对容易。在我们的前一个示例中，我们将在命令行中使用以下代码调用`AllThrows`类：
- en: '[PRE2]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The output of our result will consist of the following structure:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的结果输出将包括以下结构：
- en: '[PRE3]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: API enums
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API枚举
- en: The API consists of one enum, `LanguageVersion`, which provides the Java programming
    language version. The constants for this enum are `Java_1_1` and `Java_1_5`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 该API包含一个枚举，`LanguageVersion`，它提供了Java编程语言的版本。该枚举的常量有`Java_1_1`和`Java_1_5`。
- en: API classes
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API类
- en: 'The `Doclet` class provides an example of how to create a class to start a
    Doclet. It contains an empty `Doclet()` constructor and the following methods:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`Doclet`类提供了一个如何创建一个类以启动Doclet的示例。它包含一个空的`Doclet()`构造函数和以下方法：'
- en: '`languageVersion()`'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`languageVersion()`'
- en: '`optionLength(String option)`'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`optionLength(String option)`'
- en: '`start(RootDoc root)`'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`start(RootDoc root)`'
- en: '`validOptions(String[][] options, DocErrorReporter reporter)`'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`validOptions(String[][] options, DocErrorReporter reporter)`'
- en: API interfaces
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API接口
- en: 'The Doclet API contains the following listed interfaces. The interface names
    are self-describing. You can consult the documentation for additional details:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: Doclet API包含以下列出的接口。接口名称是自我描述的。你可以查阅文档以获取更多详细信息：
- en: '`AnnotatedType`'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AnnotatedType`'
- en: '`AnnotationDesc`'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AnnotationDesc`'
- en: '`AnnotationDesc.ElementValuePair`'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AnnotationDesc.ElementValuePair`'
- en: '`AnnotationTypeDoc`'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AnnotationTypeDoc`'
- en: '`AnnotationTypeElementDoc`'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AnnotationTypeElementDoc`'
- en: '`AnnotationValue`'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AnnotationValue`'
- en: '`ClassDoc`'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ClassDoc`'
- en: '`ConstructorDoc`'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ConstructorDoc`'
- en: '`Doc`'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Doc`'
- en: '`DocErrorReporter`'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DocErrorReporter`'
- en: '`ExecutableMemberDoc`'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ExecutableMemberDoc`'
- en: '`FieldDoc`'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FieldDoc`'
- en: '`MemberDoc`'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MemberDoc`'
- en: '`MethodDoc`'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MethodDoc`'
- en: '`PackageDoc`'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PackageDoc`'
- en: '`Parameter`'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Parameter`'
- en: '`ParameterizedType`'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ParameterizedType`'
- en: '`ParamTag`'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ParamTag`'
- en: '`ProgramElementDoc`'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ProgramElementDoc`'
- en: '`RootDoc`'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RootDoc`'
- en: '`SeeTag`'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SeeTag`'
- en: '`SerialFieldTag`'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SerialFieldTag`'
- en: '`SourcePosition`'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SourcePosition`'
- en: '`Tag`'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Tag`'
- en: '`ThrowsTag`'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ThrowsTag`'
- en: '`Type`'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Type`'
- en: '`TypeVariable`'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TypeVariable`'
- en: '`WildcardType`'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WildcardType`'
- en: Problems with the pre-existing Doclet API
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 存在的Doclet API的问题
- en: 'Fueling the need for a new Doclet API were several issues with the pre-existing
    Doclet API:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 驱动需要新的Doclet API的是几个与现有Doclet API相关的问题：
- en: It was not ideal for testing or concurrent usage. This stemmed from its implementation
    of static methods.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不适合测试或并发使用。这源于其静态方法的实现。
- en: The language model used in the API had several limitations and became more problematic
    with each successive Java upgrade.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API中使用的语言模型存在一些限制，并且随着每个后续的Java升级而变得更加有问题。
- en: The API was inefficient, largely due to its heavy use of substring matching.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该API效率低下，很大程度上是由于其大量使用子字符串匹配。
- en: There was no reference provided regarding the specific location of any given
    comment. This made diagnostics and troubleshooting difficult.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有提供有关任何给定注释具体位置的参考。这使得诊断和故障排除变得困难。
- en: Java 9's Doclet API
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java 9的Doclet API
- en: Now that you have a good handle on the Doclet API as it existed prior to Java
    9, let's look at what changes have been made and delivered with the Java 9 platform.
    The new Doclet API is in the `jdk.javadoc.doclet` package.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经很好地掌握了Java 9之前存在的Doclet API，让我们看看Java 9平台所做出的更改和交付的内容。新的Doclet API位于`jdk.javadoc.doclet`包中。
- en: 'At a high level, the changes to the Doclet API are as follows:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 从高层次来看，Doclet API的更改如下：
- en: Updates the `com.sun.javadoc` Doclet API to take advantage of several Java SE
    and JDK APIs
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新`com.sun.javadoc` Doclet API以利用几个Java SE和JDK API
- en: Updates the `com.sun.tools.doclets.standard.Standard` Doclet to use the new
    API
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新`com.sun.tools.doclets.standard.Standard` Doclet以使用新的API
- en: Supports the updated Taglet API that is used to create custom javadoc tags
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持更新的Taglet API，该API用于创建自定义javadoc标签
- en: 'In addition to the changes listed earlier, the new API uses the two APIs listed
    here:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 除了前面列出的更改之外，新的API还使用了这里列出的两个API：
- en: Compiler tree API
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译器树API
- en: Language model API
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 语言模型API
- en: Let's explore each of these in the following sections.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在接下来的部分中探讨这些内容。
- en: Compiler tree API
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编译器树API
- en: The compiler tree API is in the `com.sun.source.doctree` package. It provides
    several interfaces to document source-level comments. These APIs are represented
    as **Abstract Syntax Trees** (**ASTs**).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器树API位于`com.sun.source.doctree`包中。它提供了几个接口来文档化源级注释。这些API表示为**抽象语法树**（**ASTs**）。
- en: 'There are two enums:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个枚举：
- en: '`AttributeTree.ValueKind` with the following constants:'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AttributeTree.ValueKind`具有以下常量：'
- en: '`DOUBLE`'
  id: totrans-208
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DOUBLE`'
- en: '`EMPTY`'
  id: totrans-209
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EMPTY`'
- en: '`SINGLE`'
  id: totrans-210
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SINGLE`'
- en: '`UNQUOTED`'
  id: totrans-211
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UNQUOTED`'
- en: '`DocTree.Kind` with the following constants:'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DocTree.Kind`具有以下常量：'
- en: '`ATTRIBUTE`'
  id: totrans-213
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ATTRIBUTE`'
- en: '`AUTHOR`'
  id: totrans-214
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AUTHOR`'
- en: '`CODE`'
  id: totrans-215
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CODE`'
- en: '`COMMENT`'
  id: totrans-216
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`COMMENT`'
- en: '`DEPRECATED`'
  id: totrans-217
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DEPRECATED`'
- en: '`DOC_COMMENT`'
  id: totrans-218
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DOC_COMMENT`'
- en: '`DOC_ROOT`'
  id: totrans-219
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DOC_ROOT`'
- en: '`END_ELEMENT`'
  id: totrans-220
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`END_ELEMENT`'
- en: '`ENTITY`'
  id: totrans-221
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ENTITY`'
- en: '`ERRONEOUS`'
  id: totrans-222
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ERRONEOUS`'
- en: '`EXCEPTION`'
  id: totrans-223
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EXCEPTION`'
- en: '`IDENTIFIER`'
  id: totrans-224
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IDENTIFIER`'
- en: '`INHERIT_DOC`'
  id: totrans-225
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`INHERIT_DOC`'
- en: '`LINK`'
  id: totrans-226
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LINK`'
- en: '`LINK_PLAIN`'
  id: totrans-227
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LINK_PLAIN`'
- en: '`LITERAL`'
  id: totrans-228
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LITERAL`'
- en: '`OTHER`'
  id: totrans-229
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OTHER`'
- en: '`PARAM`'
  id: totrans-230
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PARAM`'
- en: '`REFERENCE`'
  id: totrans-231
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`REFERENCE`'
- en: '`RETURN`'
  id: totrans-232
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RETURN`'
- en: '`SEE`'
  id: totrans-233
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SEE`'
- en: '`SERIAL`'
  id: totrans-234
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SERIAL`'
- en: '`SERIAL_DATA`'
  id: totrans-235
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SERIAL_DATA`'
- en: '`SERIAL_FIELD`'
  id: totrans-236
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SERIAL_FIELD`'
- en: '`SINCE`'
  id: totrans-237
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SINCE`'
- en: '`START_ELEMENT`'
  id: totrans-238
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`START_ELEMENT`'
- en: '`TEXT`'
  id: totrans-239
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TEXT`'
- en: '`THROWS`'
  id: totrans-240
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`THROWS`'
- en: '`UNKNOWN_BLOCK_TAG`'
  id: totrans-241
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UNKNOWN_BLOCK_TAG`'
- en: '`UNKNOWN_INLINE_TAG`'
  id: totrans-242
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UNKNOWN_INLINE_TAG`'
- en: '`VALUE`'
  id: totrans-243
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VALUE`'
- en: '`VERSION`'
  id: totrans-244
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VERSION`'
- en: 'The `com.sun.source.doctree` package contains several interfaces. They are
    detailed in the following table:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '`com.sun.source.doctree`包包含几个接口。它们在以下表格中详细说明：'
- en: '| **Interface name** | **Extends** | **A tree node for:** | **Non-inherited
    methods** |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
  zh: '| **接口名称** | **扩展** | **树节点用于：** | **非继承方法** |'
- en: '| `AttributeTree` | `DocTree` | HTML element | `getName()`, `getValue()`, `getValueKind()`
    |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
  zh: '| `AttributeTree` | `DocTree` | HTML元素 | `getName()`, `getValue()`, `getValueKind()`
    |'
- en: '| `AuthorTree` | `BlockTagTree`, `DocTree` | `@author` block tag | `getName()`
    |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
  zh: '| `AuthorTree` | `BlockTagTree`, `DocTree` | `@author`块标签 | `getName()` |'
- en: '| `BlockTagTree` | `DocTree` | Base class for different types of block tags
    | `getTagName()` |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
  zh: '| `BlockTagTree` | `DocTree` | 不同类型块标签的基类 | `getTagName()` |'
- en: '| `CommentTree` | `DocTree` | An embedded HTML comment with the following HTML
    tags--`<!--text-->` | `getBody()` |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
  zh: '| `CommentTree` | `DocTree` | 包含以下HTML标签的嵌入式HTML注释--`<!--text-->` | `getBody()`
    |'
- en: '| `DeprecatedTree` | `BlockTagTree` | `@deprecated` block tag | `getBody()`
    |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
  zh: '| `DeprecatedTree` | `BlockTagTree` | `@deprecated`块标签 | `getBody()` |'
- en: '| `DocCommentTree` | `DocTree` | Body block tags | `getBlockTags()`, `getBody()`,
    `getFirstSentence()` |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
  zh: '| `DocCommentTree` | `DocTree` | 主体块标签 | `getBlockTags()`, `getBody()`, `getFirstSentence()`
    |'
- en: '| `DocRootTree` | `InlineTagTree` | `@docroot` inline tag | N/A |'
  id: totrans-253
  prefs: []
  type: TYPE_TB
  zh: '| `DocRootTree` | `InlineTagTree` | `@docroot`内联标签 | N/A |'
- en: '| `DocTree` | N/A | Common interface for all | `accept(DocTreeVisitor<R,D>visitor,Ddata)`,
    `getKind()` |'
  id: totrans-254
  prefs: []
  type: TYPE_TB
  zh: '| `DocTree` | N/A | 所有接口的通用接口 | `accept(DocTreeVisitor<R,D>visitor,Ddata)`,
    `getKind()` |'
- en: '| `DocTreeVisitor<R,P>` | N/A | `R` = return type of visitor''s methods; `P`
    = type of the additional parameter | `visitAttribute(AttributeTree node, P p)`,
    `visitAuthor(AuthorTree node, P p)`, `visitComment(CommentTree node, P p)`, `visitDeprecated(DeprecatedTree
    node, P p)`, `visitDocComment(DocCommentTree node, P p)`, `visitDocRoot(DocRootTree
    node, P p)`, `visitEndElement(EndElementTree node, P p)`, `visitEntity(EntityTree
    node, P p)`, `visitErroneous(ErroneousTree node, P p)`, `visitIdentifier(IdentifierTree
    node, P p)`, `visitInheritDoc(InheritDocTree node, P p)`, `visitLink(LinkTree
    node, P p)`, `visitLiteral(LiteralTree node, P p)`, `visitOther(DocTree node,
    P p)`, `visitParam(ParamTree node, P p)`, `visitReference(ReferenceTree node,
    P p)`, `visitReturn(ReturnTree node, P p)`, `visitSee(SeeTree node, P p)`, `visitSerial(SerialTree
    node, P p)`, `visitSerialData(SerialDataTree node, P p)`, `visitSerialField(SerialFieldTree
    node, P p)`, `visitSince(SinceTree node, P p)`, `visitStartElement(StartElementTree
    node, P p)`, `visitText(TextTree node, P p)`, `visitThrows(ThrowsTree node, P
    p)`, `visitUnknownBlockTag(UnknownBlockTagTree node, P p)`, `visitUnknownInlineTag(UnknownInlineTagTree
    node, P p)`, `visitValue(ValueTree node, P p)`, `visitVersion(VersionTree node,
    P p)` |'
  id: totrans-255
  prefs: []
  type: TYPE_TB
  zh: '| `DocTreeVisitor<R,P>` | N/A | `R` = 访问者方法的返回类型; `P` = 额外参数的类型 | `visitAttribute(AttributeTree
    node, P p)`, `visitAuthor(AuthorTree node, P p)`, `visitComment(CommentTree node,
    P p)`, `visitDeprecated(DeprecatedTree node, P p)`, `visitDocComment(DocCommentTree
    node, P p)`, `visitDocRoot(DocRootTree node, P p)`, `visitEndElement(EndElementTree
    node, P p)`, `visitEntity(EntityTree node, P p)`, `visitErroneous(ErroneousTree
    node, P p)`, `visitIdentifier(IdentifierTree node, P p)`, `visitInheritDoc(InheritDocTree
    node, P p)`, `visitLink(LinkTree node, P p)`, `visitLiteral(LiteralTree node,
    P p)`, `visitOther(DocTree node, P p)`, `visitParam(ParamTree node, P p)`, `visitReference(ReferenceTree
    node, P p)`, `visitReturn(ReturnTree node, P p)`, `visitSee(SeeTree node, P p)`,
    `visitSerial(SerialTree node, P p)`, `visitSerialData(SerialDataTree node, P p)`,
    `visitSerialField(SerialFieldTree node, P p)`, `visitSince(SinceTree node, P p)`,
    `visitStartElement(StartElementTree node, P p)`, `visitText(TextTree node, P p)`,
    `visitThrows(ThrowsTree node, P p)`, `visitUnknownBlockTag(UnknownBlockTagTree
    node, P p)`, `visitUnknownInlineTag(UnknownInlineTagTree node, P p)`, `visitValue(ValueTree
    node, P p)`, `visitVersion(VersionTree node, P p)` |'
- en: '| `EndElementTree` | `DocTree` | End of an HTML element `</name>` | `getName()`
    |'
  id: totrans-256
  prefs: []
  type: TYPE_TB
  zh: '| `EndElementTree` | `DocTree` | HTML元素的结束`</name>` | `getName()` |'
- en: '| `EntityTree` | `DocTree` | An HTML entity | `getName()` |'
  id: totrans-257
  prefs: []
  type: TYPE_TB
  zh: '| `EntityTree` | `DocTree` | HTML实体 | `getName()` |'
- en: '| `ErroneousTree` | `TextTree` | This is for malformed text | `getDiagnostic()`
    |'
  id: totrans-258
  prefs: []
  type: TYPE_TB
  zh: '| `ErroneousTree` | `TextTree` | 用于格式错误的文本 | `getDiagnostic()` |'
- en: '| `IdentifierTree` | `DocTree` | An identifier in a comment | `getName()` |'
  id: totrans-259
  prefs: []
  type: TYPE_TB
  zh: '| `IdentifierTree` | `DocTree` | 注释中的标识符 | `getName()` |'
- en: '| `InheritDocTree` | `InlineTagTree` | `@inheritDoc`inline tag | N/A |'
  id: totrans-260
  prefs: []
  type: TYPE_TB
  zh: '| `InheritDocTree` | `InlineTagTree` | `@inheritDoc`内联标签 | N/A |'
- en: '| `InlineTagTree` | `DocTree` | Common interface for inline tags | `getTagName()`
    |'
  id: totrans-261
  prefs: []
  type: TYPE_TB
  zh: '| `InlineTagTree` | `DocTree` | 内联标签的通用接口 | `getTagName()` |'
- en: '| `LinkTree` | `InlineTagTree` | `@link` or `@linkplan` inline tags | `getLabel()`,
    `getReference()` |'
  id: totrans-262
  prefs: []
  type: TYPE_TB
  zh: '| `LinkTree` | `InlineTagTree` | `@link`或`@linkplan`内联标签 | `getLabel()`, `getReference()`
    |'
- en: '| `LiteralTree` | `InlineTagTree` | `@literal` or `@code` inline tags | `getBody()`
    |'
  id: totrans-263
  prefs: []
  type: TYPE_TB
  zh: '| `LiteralTree` | `InlineTagTree` | `@literal`或`@code`内联标签 | `getBody()` |'
- en: '| `ParamTree` | `BlockTagTree` | `@param` block tags | `getDescription()`,
    `getName()`, `isTypeParameter()` |'
  id: totrans-264
  prefs: []
  type: TYPE_TB
  zh: '| `ParamTree` | `BlockTagTree` | `@param`块标签 | `getDescription()`, `getName()`,
    `isTypeParameter()` |'
- en: '| `ReferenceTree` | `DocTree` | Used to reference a Java lang element | `getSignature()`
    |'
  id: totrans-265
  prefs: []
  type: TYPE_TB
  zh: '| `ReferenceTree` | `DocTree` | 用于引用Java语言元素 | `getSignature()` |'
- en: '| `ReturnTree` | `BlockTagTree` | `@return` block tags | `getDescription()`
    |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
  zh: '| `ReturnTree` | `BlockTagTree` | `@return`块标签 | `getDescription()` |'
- en: '| `SeeTree` | `BlockTagTree` | `@see` block tags | `getReference()` |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
  zh: '| `SeeTree` | `BlockTagTree` | `@see`块标签 | `getReference()` |'
- en: '| `SerialDataTree` | `BlockTagTree` | `@serialData` block tags | `getDescription()`
    |'
  id: totrans-268
  prefs: []
  type: TYPE_TB
  zh: '| `SerialDataTree` | `BlockTagTree` | `@serialData`块标签 | `getDescription()`
    |'
- en: '| `SerialFieldTree` | `BlockTagTree` | `@serialData` block tags and `@serialField`field
    names and descriptions | `getDescription()`, `getName()`, `getType()` |'
  id: totrans-269
  prefs: []
  type: TYPE_TB
  zh: '| `SerialFieldTree` | `BlockTagTree` | `@serialData`块标签和`@serialField`字段名及描述
    | `getDescription()`, `getName()`, `getType()` |'
- en: '| `SerialTree` | `BlockTagTree` | `@serial` block tags | `getDescription()`
    |'
  id: totrans-270
  prefs: []
  type: TYPE_TB
  zh: '| `SerialTree` | `BlockTagTree` | `@serial`块标签 | `getDescription()` |'
- en: '| `SinceTree` | `BlockTagTree` | `@since` block tags | `getBody()` |'
  id: totrans-271
  prefs: []
  type: TYPE_TB
  zh: '| `SinceTree` | `BlockTagTree` | `@since`块标签 | `getBody()` |'
- en: '| `StartElementTree` | `DocTree` | Start of an HTML element `< name [attributes]
    [/] >` | `getAttributes()`, `getName()`, `isSelfClosing()` |'
  id: totrans-272
  prefs: []
  type: TYPE_TB
  zh: '| `StartElementTree` | `DocTree` | HTML元素的开始 `< name [attributes] [/] >` |
    `getAttributes()`, `getName()`, `isSelfClosing()` |'
- en: '| `TextTree` | `DocTree` | Plain text | `getBody()` |'
  id: totrans-273
  prefs: []
  type: TYPE_TB
  zh: '| `TextTree` | `DocTree` | 纯文本 | `getBody()` |'
- en: '| `ThrowsTree` | `BlockTagTree` | `@exception` or `@throws` block tags | `getDescription()`,
    `getExceptionname()` |'
  id: totrans-274
  prefs: []
  type: TYPE_TB
  zh: '| `ThrowsTree` | `BlockTagTree` | `@exception`或`@throws`块标签 | `getDescription()`,
    `getExceptionname()` |'
- en: '| `UnknownBlockTagTree` | `BlockTagTree` | Unrecognizedinline tags | `getContent()`
    |'
  id: totrans-275
  prefs: []
  type: TYPE_TB
  zh: '| `UnknownBlockTagTree` | `BlockTagTree` | 不可识别的内联标签 | `getContent()` |'
- en: '| `UnknownInlineTagTree` | `InlineTagTree` | Unrecognizedinline tags | `getContent()`
    |'
  id: totrans-276
  prefs: []
  type: TYPE_TB
  zh: '| `UnknownInlineTagTree` | `InlineTagTree` | 不可识别的内联标签 | `getContent()` |'
- en: '| `ValueTree` | `InlineTagTree` | `@value` inline tags | `getReference()` |'
  id: totrans-277
  prefs: []
  type: TYPE_TB
  zh: '| `ValueTree` | `InlineTagTree` | `@value`内联标签 | `getReference()` |'
- en: '| `VersionTree` | `BlockTagTree` | `@version` block tags | `getBody()` |'
  id: totrans-278
  prefs: []
  type: TYPE_TB
  zh: '| `VersionTree` | `BlockTagTree` | `@version`块标签 | `getBody()` |'
- en: Language model API
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 语言模型API
- en: 'The language model API is in the `java.lang.model` package. It includes packages
    and classes that are used for language processing and language modeling. It consists
    of the following components:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 语言模型API位于`java.lang.model`包中。它包括用于语言处理和语言建模的包和类。它由以下组件组成：
- en: '`AnnotatedConstruct` interface'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AnnotatedConstruct接口
- en: '`SourceVersion` enum'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SourceVersion枚举
- en: '`UnknownEntityException` exception'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UnknownEntityException异常
- en: Each of these language model API components is further explored in the next
    three sections.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的三个部分中将进一步探讨这些语言模型API组件。
- en: The AnnotatedConstruct interface
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AnnotatedConstruct接口
- en: 'The `AnnotatedConstruction` interface provides an annotatable construct to
    the language model API that has been part of the Java platform since version 1.8\.
    It is applicable to constructs that are either an element (Interface `Element`)
    or a type (Interface `TypeMirror`). The annotations for each of these constructs
    differ, as shown in this table:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: AnnotatedConstruction接口为语言模型API提供了一个可注解的构造，该API自Java平台1.8版本以来一直是Java平台的一部分。它适用于元素（接口`Element`）或类型（接口`TypeMirror`）的构造。这些构造的注解各不相同，如表中所示：
- en: '| **Construct type** | **Interface** | **Annotation** |'
  id: totrans-287
  prefs: []
  type: TYPE_TB
  zh: '| **构造类型** | **接口** | **注解** |'
- en: '| `element` | `Element` | Declaration |'
  id: totrans-288
  prefs: []
  type: TYPE_TB
  zh: '| `element` | `Element` | 声明 |'
- en: '| `type` | `TypeMirror` | Based on use of a type name |'
  id: totrans-289
  prefs: []
  type: TYPE_TB
  zh: '| `type` | `TypeMirror` | 基于类型名称的使用 |'
- en: 'The `AnnotatedConstruction` interface has three methods:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: AnnotatedConstruction接口有三个方法：
- en: '`getAnnotation(Class<A> annotationType)`: This method returns the type of the
    construct''s annotation'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getAnnotation(Class<A> annotationType)`: 此方法返回构造注解的类型'
- en: '`getAnnotationMirrors()`: This method returns a list of annotations that are
    on the construct'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getAnnotationMirrors()`: 此方法返回构造上的注解列表'
- en: '`getAnnotationsByType(Class<A> annotationType)`: This method returns the construct''s
    associated annotations'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getAnnotationsByType(Class<A> annotationType)`: 此方法返回构造关联的注解'
- en: The SourceVersion enum
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SourceVersion枚举
- en: 'The `SourceVersion` enum consists of the following constants:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: SourceVersion枚举包含以下常量：
- en: '`RELEASE_0`'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RELEASE_0`'
- en: '`RELEASE_1`'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RELEASE_1`'
- en: '`RELEASE_2`'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RELEASE_2`'
- en: '`RELEASE_3`'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RELEASE_3`'
- en: '`RELEASE_4`'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RELEASE_4`'
- en: '`RELEASE_5`'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RELEASE_5`'
- en: '`RELEASE_6`'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RELEASE_6`'
- en: '`RELEASE_7`'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RELEASE_7`'
- en: '`RELEASE_8`'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RELEASE_8`'
- en: It is anticipated that the `SourceVersion` enum will be updated to include `RELEASE_9`
    once the Java 9 platform has been officially released.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 预计一旦Java 9平台正式发布，`SourceVersion`枚举将更新以包括`RELEASE_9`。
- en: 'This enum also contains several methods, which are as follows:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 此枚举还包含几个方法，如下所示：
- en: '**Method name**: `isIdentifier`'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '**方法名称**: `isIdentifier`'
- en: '`public static boolean isIdentifier(CharSequence name)`'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '`public static boolean isIdentifier(CharSequence name)`'
- en: This method returns `true` if the parameter string is a Java identifier or keyword.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法返回 `true` 如果参数字符串是 Java 标识符或关键字。
- en: '**Method name**: `isKeyword`'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '**方法名称**: `isKeyword`'
- en: '`public static boolean isKeyword(CharSequence s)`'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '`public static boolean isKeyword(CharSequence s)`'
- en: This method returns `true` if the given `CharSequence` is a literal or keyword.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法返回 `true` 如果给定的 `CharSequence` 是一个字面量或关键字。
- en: '**Method name**: `isName`'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '**方法名称**: `isName`'
- en: '`public static boolean isName(CharSequence name)`'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '`public static boolean isName(CharSequence name)`'
- en: This method returns `true` if the `CharSequence` is a valid name.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法返回 `true` 如果 `CharSequence` 是一个有效的名称。
- en: '**Method name**: `latest`'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '**方法名称**: `latest`'
- en: '`public static SourceVersion latest()`'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '`public static SourceVersion latest()`'
- en: This method returns the latest source version for modeling purposes.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法返回建模目的的最新源版本。
- en: '**Method name**: `latestSupported`'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '**方法名称**: `latestSupported`'
- en: '`public static SourceVersion latestSupported()`'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '`public static SourceVersion latestSupported()`'
- en: This method returns the latest source version that can be fully supported for
    modeling.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法返回可以完全支持的最新源版本。
- en: '**Method name**: `valueOf`'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '**方法名称**: `valueOf`'
- en: '`public static SourceVersion valueOf(String name)`'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '`public static SourceVersion valueOf(String name)`'
- en: This method returns the enum constant based on the parameter string provided.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法根据提供的参数字符串返回枚举常量。
- en: 'You should be aware that the `value(String name)` method throws two exceptions:
    `IllegalArgumentException` and `NullPointerException`.'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该知道，`value(String name)` 方法会抛出两个异常：`IllegalArgumentException` 和 `NullPointerException`。
- en: '**Method name**: `values`'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '**方法名称**: `values`'
- en: '`public static SourceVersion[] values()`'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '`public static SourceVersion[] values()`'
- en: This method returns an array of the enum constants.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法返回枚举常量的数组。
- en: The UnknownEntityException exception
  id: totrans-329
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 未知实体异常
- en: 'The `UnknownEntityException` class extends `RuntimeException` and is a superclass
    of unknown exceptions. The class constructor is as follows:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '`UnknownEntityException` 类扩展了 `RuntimeException` 并是未知异常的超类。类的构造函数如下：'
- en: '[PRE4]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The constructor creates a new instance of `UnknownEntityException` with the
    message provided as a string argument. The method does not take additional arguments.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数使用提供的字符串参数创建一个新的 `UnknownEntityException` 实例。该方法不接受额外的参数。
- en: 'This class does not have its own methods, but inherits methods from both `java.lang.Throwable`
    and `class.java.lang.Object` classes as shown here:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 此类没有自己的方法，但如所示从 `java.lang.Throwable` 和 `class.java.lang.Object` 类继承方法：
- en: 'The `java.lang.Throwable` class methods:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.lang.Throwable` 类的方法：'
- en: '`addSuppressed()`'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`addSuppressed()`'
- en: '`fillInStackTrace()`'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fillInStackTrace()`'
- en: '`getCause()`'
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getCause()`'
- en: '`getLocalizedMessage()`'
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getLocalizedMessage()`'
- en: '`getMessage()`'
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getMessage()`'
- en: '`getStackTrace()`'
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getStackTrace()`'
- en: '`getSuppressed()`'
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getSuppressed()`'
- en: '`initCause()`'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`initCause()`'
- en: '`printStackTrace()`'
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`printStackTrace()`'
- en: '`setStackTrace()`'
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setStackTrace()`'
- en: '`toString()`'
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`toString()`'
- en: 'The `java.lang.Object` class methods:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.lang.Object` 类的方法：'
- en: '`clone()`'
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`clone()`'
- en: '`equals()`'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`equals()`'
- en: '`finalize()`'
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`finalize()`'
- en: '`getClass()`'
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getClass()`'
- en: '`hashCode()`'
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hashCode()`'
- en: '`notify()`'
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`notify()`'
- en: '`notifyAll()`'
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`notifyAll()`'
- en: '`wait()`'
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`wait()`'
- en: HTML5 Javadoc [JEP-224]
  id: totrans-355
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTML5 Javadoc [JEP-224]
- en: The Javadoc tool has been updated for the Java 9 platform. It can now generate
    HTML 5 markup output in addition to HTML 4\. The new Javadoc tool provides support
    for both HTML 4 and HTML 5.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: Javadoc 工具已更新以支持 Java 9 平台。它现在可以生成 HTML 5 标记输出，除了 HTML 4。新的 Javadoc 工具提供了对 HTML
    4 和 HTML 5 的支持。
- en: HTML 4 will continue, even with the advent of the Java 9 platform, to be the
    default Javadoc output format. HTML 5 will be an option and will not become the
    default output markup format until Java 10.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 即使 Java 9 平台出现，HTML 4 也将继续作为默认的 Javadoc 输出格式。HTML 5 将是一个选项，并且不会在 Java 10 之前成为默认输出标记格式。
- en: 'The following short Java application simply generates a `319`-wide by `319`-high
    frame. It is shown here without any Javadoc tags, which we will discuss later
    in this section:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 以下简短的 Java 应用程序简单地生成一个宽 `319`、高 `319` 的框架。这里显示时没有使用任何 Javadoc 标签，我们将在本节稍后讨论：
- en: '[PRE5]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Once your package or class is completed, you can generate a Javadoc using the
    Javadoc tool. You can run the Javadoc tool, located in your JDK /bin directory,
    from the command line or from within your **Integrated Development Environment**
    (**IDE**). Each IDE handles Javadoc generation differently. For example, in Eclipse,
    you would select Project from the pull-down menu and then Generate Javadoc. In
    the IntelliJ IDEA IDE, you select the Tools pull-down menu and then Generate Javadoc.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 当您的包或类完成时，您可以使用 Javadoc 工具生成 Javadoc。您可以从命令行或从您的 **集成开发环境**（**IDE**）中运行位于 JDK
    /bin 目录中的 Javadoc 工具。每个 IDE 处理 Javadoc 生成的方式不同。例如，在 Eclipse 中，您会从下拉菜单中选择项目，然后生成
    Javadoc。在 IntelliJ IDEA IDE 中，您会选择工具下拉菜单，然后生成 Javadoc。
- en: 'The following screenshot shows the IntelliJ IDEA interface for the Generate
    Javadoc functionality. As you can see, the `-html5` command-line argument has
    been included:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的截图显示了 IntelliJ IDEA 中生成 Javadoc 功能的界面。如您所见，已包含 `-html5` 命令行参数：
- en: '![](img/0a6b1732-b267-427a-b490-8c23c71e3037.png)'
  id: totrans-362
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0a6b1732-b267-427a-b490-8c23c71e3037.png)'
- en: 'When the OK button is clicked, you will see a series of status messages, as
    shown in the following example:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 当您点击“确定”按钮时，您将看到一系列状态消息，如下例所示：
- en: '[PRE6]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Once the Javadoc tool exits, you are ready to view the Javadoc. Here is a screenshot
    of what was generated based on the previously provided code. As you can see, it
    is formatted in the same manner in which the formal Java documentation from Oracle
    is documented:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Javadoc 工具退出后，您就可以查看 Javadoc。以下是根据之前提供的代码生成的截图。如您所见，它以与 Oracle 正式 Java 文档相同的方式格式化：
- en: '![](img/9f97610a-7166-4ee8-98ff-55ec4cd03073.png)'
  id: totrans-366
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9f97610a-7166-4ee8-98ff-55ec4cd03073.png)'
- en: 'When we generated the Javadoc, multiple documents were created, as illustrated
    by the directory tree provided in the following screenshot:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们生成 Javadoc 时，会创建多个文档，如下面的截图所示，展示了提供的目录树：
- en: '![](img/3358f198-85b3-4189-9f35-3f7da7619a62.png)'
  id: totrans-368
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3358f198-85b3-4189-9f35-3f7da7619a62.png)'
- en: 'You can also add optional tags that are recognized by the Javadoc tool. Those
    tags are provided here:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以添加 Javadoc 工具可识别的可选标签。这些标签在此提供：
- en: '`@author`'
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@author`'
- en: '`@code`'
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@code`'
- en: '`@deprecated`'
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@deprecated`'
- en: '`@docRoot`'
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@docRoot`'
- en: '`@exception`'
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@exception`'
- en: '`@inheritDoc`'
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@inheritDoc`'
- en: '`@link`'
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@link`'
- en: '`@linkplain`'
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@linkplain`'
- en: '`@param`'
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@param`'
- en: '`@return`'
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@return`'
- en: '`@see`'
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@see`'
- en: '`@serial`'
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@serial`'
- en: '`@serialData`'
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@serialData`'
- en: '`@serialField`'
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@serialField`'
- en: '`@since`'
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@since`'
- en: '`@throws`'
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@throws`'
- en: '`@value`'
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@value`'
- en: '`@version`'
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@version`'
- en: For more information on how to write document comments for the Javadoc tool,
    you can visit Oracle's official instructions at [http://www.oracle.com/technetwork/articles/java/index-137868.html](http://www.oracle.com/technetwork/articles/java/index-137868.html).
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 关于如何为 Javadoc 工具编写文档注释的更多信息，您可以访问 Oracle 的官方说明[http://www.oracle.com/technetwork/articles/java/index-137868.html](http://www.oracle.com/technetwork/articles/java/index-137868.html)。
- en: Javadoc search [JEP-225]
  id: totrans-389
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Javadoc 搜索 [JEP-225]
- en: Prior to Java 9, the standard Doclet generated API documentation pages that
    made navigating them difficult. Unless you are very familiar with the layout of
    these documentation pages, you will likely use browser-based find functionality
    to search text. This is considered clunky and suboptimal.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 9 之前，标准 Doclet 生成的 API 文档页面难以导航。除非您非常熟悉这些文档页面的布局，否则您可能会使用基于浏览器的查找功能来搜索文本。这被认为是不灵活且次优的。
- en: The Java 9 platform includes a search box as part of the API documentation.
    This search box is granted by the standard Doclet and can be used to search for
    text within the documentation. This represents a great convenience for developers
    and is likely to change our usage of Doclet-generated documentation.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: Java 9 平台包括一个搜索框，作为 API 文档的一部分。这个搜索框由标准 Doclet 提供，可以用于在文档中搜索文本。这对开发者来说非常方便，可能会改变我们对
    Doclet 生成文档的使用方式。
- en: 'With the new Javadoc search functionality, we have the ability to search for
    the following indexed components:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 使用新的 Javadoc 搜索功能，我们可以搜索以下索引组件：
- en: Module names
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块名
- en: Package names
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包名
- en: Types
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型
- en: Members
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 成员
- en: Terms/phrases indexed using the new `@index` inline tag
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用新的 `@index` 内联标签索引的术语/短语
- en: Introducing camel case search
  id: totrans-398
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍驼峰式搜索
- en: The new Javadoc search functionality includes a great shortcut using camel case
    search. As an example, we can search for `openED` to find the `openExternalDatabase()`
    method.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 新的 Javadoc 搜索功能包括一个使用驼峰式搜索的快捷方式。例如，我们可以搜索 `openED` 来找到 `openExternalDatabase()`
    方法。
- en: Remove launch-time JRE version selection [JEP-231]
  id: totrans-400
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 移除启动时 JRE 版本选择 [JEP-231]
- en: 'Prior to Java 9, we could use the **mJRE** (**Multiple JRE**) feature to specify
    a specific JRE version, or range of versions, for launching our applications.
    We would accomplish this via the command-line option `-version` or with an entry
    in the JAR file''s manifest. The following flowchart illustrates what happens
    based on our selection:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 9 之前，我们可以使用 **mJRE**（**多个 JRE**）功能来指定用于启动我们应用程序的特定 JRE 版本或版本范围。我们会通过命令行选项
    `-version` 或在 JAR 文件清单中的条目来完成此操作。以下流程图说明了基于我们的选择会发生什么：
- en: '![](img/db52f66a-a51b-451b-ab60-77c0541baff0.png)'
  id: totrans-402
  prefs: []
  type: TYPE_IMG
  zh: '![](img/db52f66a-a51b-451b-ab60-77c0541baff0.png)'
- en: This functionality was introduced with JDK 5 and was not fully documented in
    that release or any subsequent release prior to JDK 9.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 这个功能是在 JDK 5 中引入的，在那个版本或任何后续版本（直到 JDK 9）中都没有得到充分记录。
- en: 'The following specific changes were introduced with the Java 9 platform:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在 Java 9 平台上引入的具体更改：
- en: The mJRE feature has been removed.
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: mJRE 功能已被移除。
- en: The launcher will now produce an error whenever the `-version` command-line
    option is used. This is a terminal errors in that processing will not continue.
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当使用 `-version` 命令行选项时，启动器现在将产生一个错误。这是一个终止错误，因为处理将不会继续。
- en: A warning will be produced if there is a `-version` entry in a JARs manifest.
    The warning will not stop execution.
  id: totrans-407
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 JAR 文件的清单中存在 `-version` 条目，将会产生一个警告。这个警告不会停止执行。
- en: Interestingly, the presence of a `-version` entry in a manifest file will only
    generate a warning. This is by design, to take into account the likelihood of
    the entry being in older JAR file. It is estimated that this warning will be changed
    into a terminal error when the Java 10 platform is released.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，在清单文件中存在 `-version` 条目只会生成一个警告。这是设计上的考虑，为了考虑到该条目可能存在于较旧的 JAR 文件中的可能性。据估计，当
    Java 10 平台发布时，这个警告将被改为一个终止错误。
- en: Parser API for Nashorn [JEP-236]
  id: totrans-409
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Nashorn 的解析器 API [JEP-236]
- en: The focus of JEP 236 was to create an API for Nashorn's EMCAScript abstract
    syntax tree. In this section, we will individually look at Nashorn, EMCAScript
    and then the Parser API.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: JEP 236 的重点是创建 Nashorn 的 EMCAScript 抽象语法树 API。在本节中，我们将分别查看 Nashorn、EMCAScript
    以及解析器 API。
- en: Nashorn
  id: totrans-411
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Nashorn
- en: Oracle Nashorn is a JavaScript engine for the JVM developed in Java by Oracle.
    It was released with Java 8\. It was created to provide developers with a highly
    efficiently and lightweight JavaScript runtime engine. Using this engine, developers
    were able to embed JavaScript code in their Java applications. Prior to Java 8,
    developers had access to the JavaScript engine created by Netscape. That engine,
    introduced in 1997, was maintained by Mozilla.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: Oracle Nashorn 是 Oracle 开发的用于 JVM 的 JavaScript 引擎，用 Java 编写。它与 Java 8 一起发布。它被创建是为了为开发者提供一个高效且轻量级的
    JavaScript 运行时引擎。使用这个引擎，开发者能够将 JavaScript 代码嵌入到他们的 Java 应用程序中。在 Java 8 之前，开发者可以访问由
    Netscape 创建的 JavaScript 引擎。这个引擎是在 1997 年引入的，由 Mozilla 维护。
- en: Nashorn can be used both as a command-line tool and as an embedded interpreter
    in Java applications. Let's look at examples of both.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: Nashorn 可以用作命令行工具，也可以用作 Java 应用程序中的嵌入式解释器。让我们看看这两种示例。
- en: Nashorn is the German word for rhinoceros. The name spawned from the Rhino-named
    JavaScript engine from the Mozilla Foundation. Rhino is said to have originated
    from the picture of the animal on a JavaScript book cover. File this one under
    **interesting facts**.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: Nashorn 是德语中犀牛的意思。这个名字来源于 Mozilla 基金会的名为 Rhino 的 JavaScript 引擎。据说 Rhino 的名字来源于
    JavaScript 书籍封面上的动物图片。把这个归入 **有趣的事实**。
- en: Using Nashorn as a command-line tool
  id: totrans-415
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Nashorn 作为命令行工具
- en: 'The Nashorn executable file, `jjs.exe`, resides in the `\bin` folder. To access
    it, you can navigate to that folder or, if your system path is set up appropriately,
    you can launch into the shell by entering the `jjs` command in a Terminal / Command
    Prompt window on your system:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: Nashorn 可执行文件 `jjs.exe` 位于 `\bin` 文件夹中。要访问它，你可以导航到该文件夹，或者如果你的系统路径设置得当，你可以在系统的终端/命令提示符窗口中输入
    `jjs` 命令来启动壳：
- en: '![](img/3a503feb-a949-46a1-a7de-2e1a7ec42a89.png)'
  id: totrans-417
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3a503feb-a949-46a1-a7de-2e1a7ec42a89.png)'
- en: 'Here, you can see an open terminal window that first checks the version of
    Java and then uses the `jjs -version` command to launch the Nashorn shell. In
    this example, both Java and Nashorn are version 1.8.0.121\. Alternatively, we
    can simply launch Nashorn with the `jjs` command, and the shell will open without
    the version identification:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到一个打开的终端窗口，它首先检查 Java 的版本，然后使用 `jjs -version` 命令来启动 Nashorn 壳。在这个例子中，Java
    和 Nashorn 都是 1.8.0.121 版本。或者，我们也可以简单地使用 `jjs` 命令启动 Nashorn，壳将打开而不显示版本标识：
- en: '![](img/09232883-d452-4d5e-be30-dba2c5b9ce30.png)'
  id: totrans-419
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/09232883-d452-4d5e-be30-dba2c5b9ce30.png)'
- en: Next, let's create a short JavaScript and run it using Nashorn. Consider the
    following simple JavaScript code that has three simple lines of output.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们创建一个简短的JavaScript代码，并使用Nashorn运行它。考虑以下具有三条简单输出行的简单JavaScript代码。
- en: '[PRE7]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'To have Java run this JavaScript application, we will use the `jjs address.js`
    command. Here is the output:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 要让Java运行此JavaScript应用程序，我们将使用`jjs address.js`命令。以下是输出结果：
- en: '![](img/af11affd-fc08-47cf-a425-56dadf4aab0f.png)'
  id: totrans-423
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/af11affd-fc08-47cf-a425-56dadf4aab0f.png)'
- en: 'There is a lot you can do with Nashorn. From the Command Prompt/Terminal window,
    we can execute `jjs` with the `-help` option to see a full list of command-line
    commands:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Nashorn有很多事情可以做。从命令提示符/终端窗口，我们可以使用带有`-help`选项的`jjs`来查看完整的命令行命令列表：
- en: '![](img/b4ff29b9-e56f-48ad-9a8e-954b4d673ba1.png)'
  id: totrans-425
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b4ff29b9-e56f-48ad-9a8e-954b4d673ba1.png)'
- en: 'As you can see, using the `-scripting` option gives us the ability to create
    scripts using Nashorn as a text editor. There are several built-in functions that
    are useful when using Nashorn:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，使用`-scripting`选项使我们能够使用Nashorn作为文本编辑器创建脚本。Nashorn有几个内置函数，在使用Nashorn时非常有用：
- en: '`echo()`: This is similar to a `System.out.print()` Java method'
  id: totrans-427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`echo()`: 这类似于`System.out.print()` Java方法'
- en: '`exit()`: This exits Nashorn'
  id: totrans-428
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`exit()`: 这将退出Nashorn'
- en: '`load()`: This loads a script from a given path or URL'
  id: totrans-429
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`load()`: 这从给定的路径或URL加载脚本'
- en: '`print()`: This is similar to a `System.out.print()` Java method'
  id: totrans-430
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`print()`: 这类似于`System.out.print()` Java方法'
- en: '`readFull()`: This reads a file''s contents'
  id: totrans-431
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`readFull()`: 这读取文件的内容'
- en: '`readLine()`: This reads a single line from `stdin`'
  id: totrans-432
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`readLine()`: 这从`stdin`读取一行'
- en: '`quit()`: This exits Nashorn'
  id: totrans-433
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`quit()`: 这将退出Nashorn'
- en: Using Nashorn as an embedded interpreter
  id: totrans-434
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将Nashorn用作嵌入式解释器
- en: 'A more common use of Nashorn, compared to using it as a command-line tool,
    is using it as an embedded interpreter. The `javax.script` API is public and can
    be accessed via the `nashorn` identifier. The following code demonstrates how
    we can gain access to Nashorn, define a JavaScript function, and obtain the results--all
    from within a Java application:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 与将其用作命令行工具相比，Nashorn的一个更常见用途是将其用作嵌入式解释器。`javax.script` API是公开的，可以通过`nashorn`标识符访问。以下代码演示了如何在Java应用程序中访问Nashorn，定义一个JavaScript函数，并获取结果——所有这些都在Java应用程序内部完成：
- en: '[PRE8]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Here is the output provided in the console window:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是控制台窗口中提供的输出：
- en: '![](img/75b7bde5-385d-42a5-9a3a-2fbe94c1e09d.png)'
  id: totrans-438
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/75b7bde5-385d-42a5-9a3a-2fbe94c1e09d.png)'
- en: This is a simplistic example to give you an idea of what is possible with embedded
    use of Nashorn. There are ample examples in Oracle's official documentation.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的例子，旨在让您了解使用嵌入式Nashorn可以实现什么。Oracle的官方文档中有大量示例。
- en: EMCAScript
  id: totrans-440
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ECMAScript
- en: '**EMCA** (**European Computer Manufacturers Association**) was formed in 1961
    as a standards organization for both information systems and communications systems.
    Today, the EMCA continues to develop standards and issue technical reports to
    help standardize how consumer electronics, information systems, and communications
    technology are used. They are over 400 ECMA standards, most of which have been
    adopted.'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: '**EMCA**（**欧洲计算机制造商协会**）于1961年成立，作为信息系统和通信系统的标准组织。今天，EMCA继续制定标准和发布技术报告，以帮助标准化消费电子、信息系统和通信技术的使用。他们有超过400个ECMA标准，其中大部分已被采用。'
- en: You will notice that EMCA is not spelled with all capital letters as it is no
    longer considered an acronym. In 1994, the European Computer Manufacturers Association
    formally changed its name to EMCA.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到EMCA不再全部大写，因为它不再被视为缩写。1994年，欧洲计算机制造商协会正式将其名称更改为EMCA。
- en: 'EMCAScript, also referred to as ES, was created in 1997 as a scripted-language
    specification. JavaScript implements this specification. The specification includes
    the following:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: ECMAScript，也称为ES，于1997年作为一个脚本语言规范被创建。JavaScript实现了这个规范。该规范包括以下内容：
- en: Complementary technologies
  id: totrans-444
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 补充技术
- en: Libraries
  id: totrans-445
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 库
- en: Scripting language syntax
  id: totrans-446
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 脚本语言语法
- en: Semantics
  id: totrans-447
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 语义
- en: Parser API
  id: totrans-448
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解析器API
- en: 'One of the changes in the Java platform with version 9 is to provide specific
    support for Nashorn''s EMCAScript abstract syntax tree. The goals of the new API
    are to provide the following:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: Java平台在版本9中的一个变化是为Nashorn的ECMAScript抽象语法树提供特定支持。新API的目标是提供以下功能：
- en: Interfaces to represent Nashorn syntax tree nodes
  id: totrans-450
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表示Nashorn语法树节点的接口
- en: The ability to create parser instances that can be configured with command-line
    options
  id: totrans-451
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够创建可以配置命令行选项的解析器实例
- en: A visitor pattern API for interfacing with AST nodes
  id: totrans-452
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于与 AST 节点接口的访问者模式 API
- en: Test programs to use the API
  id: totrans-453
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于使用 API 的测试程序
- en: The new API, `jdk.nashorn.api.tree`, was created to permit future changes to
    the Nashorn classes. Prior to the new Parser API, IDEs used Nashorn's internal
    AST representations for code analysis. According to Oracle, use of the `idk.nashorn.internal.ir`
    package prevented the modernization of Nashorn's internal classes.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 新的 API，`jdk.nashorn.api.tree`，被创建以允许对 Nashorn 类进行未来的更改。在新解析器 API 之前，IDE 使用 Nashorn
    的内部 AST 表示进行代码分析。根据 Oracle 的说法，使用 `idk.nashorn.internal.ir` 包阻止了 Nashorn 内部类的现代化。
- en: 'Here is a look at the the class hierarchy of the new `jdk.nashorn.api.tree`
    package:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是查看新 `jdk.nashorn.api.tree` 包的类层次结构：
- en: '![](img/f2633438-e406-4357-bfc9-b0a78e686fef.png)'
  id: totrans-456
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f2633438-e406-4357-bfc9-b0a78e686fef.png)'
- en: 'The following graphic illustrates the complexity of the new API, featuring
    a full interface hierarchy:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图形展示了新 API 的复杂性，包括完整的接口层次结构：
- en: '![](img/43b9ee78-0a9e-4251-bdaf-9fdb9f107bb0.png)'
  id: totrans-458
  prefs: []
  type: TYPE_IMG
  zh: '![](img/43b9ee78-0a9e-4251-bdaf-9fdb9f107bb0.png)'
- en: 'The last component of the `jdk.nashorn.api.tree` package is the enum hierarchy,
    shown here:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: '`jdk.nashorn.api.tree` 包的最后一个组件是枚举层次结构，如下所示：'
- en: '![](img/5fd964b6-5153-4c60-a597-be9989942268.png)'
  id: totrans-460
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5fd964b6-5153-4c60-a597-be9989942268.png)'
- en: Multi-release JAR files [JEP-238]
  id: totrans-461
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多版本 JAR 文件 [JEP-238]
- en: The JAR file format has been extended in the Java 9 platform and now permits
    multiple versions of class files to exist in a single JAR file. The class versions
    can be specific to a Java release version. This enhancement allows developers
    to use a single JAR file to house multiple releases of their software.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 9 平台上扩展了 JAR 文件格式，现在允许单个 JAR 文件中存在多个版本的类文件。类版本可以针对特定的 Java 发布版本。此增强允许开发者使用单个
    JAR 文件来存放其软件的多个版本。
- en: 'The JAR file enhancement includes the following:'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: JAR 文件增强包括以下内容：
- en: Support for the `JarFile` API
  id: totrans-464
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持 `JarFile` API
- en: Support for standard class loaders
  id: totrans-465
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持标准类加载器
- en: 'The changes to the JAR file format resulted in necessary changes to core Java
    tools so that they are able to interpret the new multiple-release JAR files. These
    core tools include the following:'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 对 JAR 文件格式的更改导致了核心 Java 工具的必要更改，以便它们能够解释新的多版本 JAR 文件。这些核心工具包括以下内容：
- en: javac
  id: totrans-467
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: javac
- en: javap
  id: totrans-468
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: javap
- en: jdeps
  id: totrans-469
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: jdeps
- en: Finally, the new JAR file format supports modularity as the key characteristic
    of the Java 9 platform. The changes to the JAR file format have not resulted in
    reduced performance of related tools or processes.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，新的 JAR 文件格式支持模块化作为 Java 9 平台的关键特性。对 JAR 文件格式的更改并未导致相关工具或过程的性能降低。
- en: Identifying multi-release JAR files
  id: totrans-471
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 识别多版本 JAR 文件
- en: 'Multi-release JAR files will have a new attribute, `Multi-Release: true`. This
    attribute will be located in the JAR `MANIFEST.MF` main section.'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: '多版本 JAR 文件将有一个新的属性，`Multi-Release: true`。此属性位于 JAR 文件的 `MANIFEST.MF` 主部分。'
- en: 'The directory structure will differ between standard JAR files and multi-release
    JAR files. Here is a look at a typical JAR file structure:'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 标准 JAR 文件和多版本 JAR 文件之间的目录结构将不同。下面是查看典型 JAR 文件结构的情况：
- en: '![](img/582bb88d-54ac-4dae-abb2-f5f3c913027d.png)'
  id: totrans-474
  prefs: []
  type: TYPE_IMG
  zh: '![](img/582bb88d-54ac-4dae-abb2-f5f3c913027d.png)'
- en: 'This illustration shows the new multi-release JAR file structure with Java
    version-specific class files for both Java 8 and Java 9:'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 此图展示了新的多版本 JAR 文件结构，其中包含针对 Java 8 和 Java 9 的特定版本类文件：
- en: '![](img/f2fa5f0f-5f49-407f-b993-9c2a3cbf0ef9.png)'
  id: totrans-476
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f2fa5f0f-5f49-407f-b993-9c2a3cbf0ef9.png)'
- en: Related JDK changes
  id: totrans-477
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 相关 JDK 变更
- en: 'Several changes had to be made to the JDK to support the new multi-release
    JAR file format. These changes include the following:'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持新的多版本 JAR 文件格式，对 JDK 进行了多项更改。这些更改包括以下内容：
- en: The `URLClassLoader` is JAR-based and was modified so that it can read class
    files from the specified version.
  id: totrans-479
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`URLClassLoader` 是基于 JAR 的，并被修改成能够读取指定版本的类文件。'
- en: The new module-based class loader, new to Java 9, was written so that it can
    read class files from the specified version.
  id: totrans-480
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新的基于模块的类加载器，Java 9 的新特性，被编写成能够读取指定版本的类文件。
- en: The `java.util.jar.JarFile` class was modified so that it selects the appropriate
    class version from the multi-release JAR files.
  id: totrans-481
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.util.jar.JarFile` 类已被修改，以便从多版本 JAR 文件中选择适当的类版本。'
- en: The JAR URL scheme's protocol handler was modified so that it selects the appropriate
    class version from the multi-release JAR files.
  id: totrans-482
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JAR URL 方案的协议处理程序已被修改，以便从多版本 JAR 文件中选择适当的类版本。
- en: The Java Compiler, `javac`, was made to read identified versions of the class
    files. These version identifications are made using the `-target` and `-release`
    command-line options with the `JavacFileManager` API and the `ZipFileSystem` API.
  id: totrans-483
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java编译器`javac`被修改为读取已识别的类文件版本。这些版本识别是通过使用带有`-target`和`-release`命令行选项的`JavacFileManager`
    API和`ZipFileSystem` API来完成的。
- en: 'The following tools were modified to take advantage of the changes to the `JavacFileManager`
    API and the `ZipFileSystem` API:'
  id: totrans-484
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下工具已被修改以利用对`JavacFileManager` API和`ZipFileSystem` API的更改：
- en: '`javah`: This generates C header and source files'
  id: totrans-485
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`javah`：这会生成C头文件和源文件'
- en: '`schemagen`: This is the schema generator for namespaces in Java classes'
  id: totrans-486
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`schemagen`：这是Java类中命名空间的模式生成器'
- en: '`wsgen`: This is the parser for web service deployment'
  id: totrans-487
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`wsgen`：这是用于部署Web服务的解析器'
- en: The javap tool was updated to support the new versioning schema.
  id: totrans-488
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: javap工具已更新以支持新的版本控制方案。
- en: The jdeps tool was modified to support the new versioning schema.
  id: totrans-489
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: jdeps工具已被修改以支持新的版本控制方案。
- en: The JAR packing tool set was updated accordingly. This tool set consists of
    `pack200` and `unpack200`.
  id: totrans-490
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JAR打包工具集已相应更新。此工具集包括`pack200`和`unpack200`。
- en: Of course, the JAR tool was enhanced so that it can create the multi-release
    JAR files.
  id: totrans-491
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当然，JAR工具也得到了增强，可以创建多版本JAR文件。
- en: All related documentation has been updated to support all the changes involved
    in establishing and supporting the new multi-release JAR file format.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 所有相关文档都已更新，以支持建立和支持新的多版本JAR文件格式所涉及的所有更改。
- en: Java-level JVM compiler interface [JEP-243]
  id: totrans-493
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java级别的JVM编译器接口 [JEP-243]
- en: The JEP-243 was to create a Java-based **JVM Compiler Interface** (**JVMCI**).
    The JVMCI enables a Java compiler (which must have been written in Java) to be
    used as a dynamic compiler by the JVM.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: JEP-243旨在创建基于Java的**JVM编译器接口**（**JVMCI**）。JVMCI允许Java编译器（必须是用Java编写的）作为JVM的动态编译器使用。
- en: 'The reasoning behind the desire for the JVMCI is that it would be a highly
    optimized compiler that does not require low-level language features. Some JVM
    subsystems require low-level functionality, such as with garbage collection and
    bytemode interpretation. So, the JVMCI was written in Java instead of C or C++.
    This provides the collateral benefit of some of Java''s greatest features, such
    as the following ones:'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 对JVMCI的渴望背后的原因是它将是一个高度优化的编译器，不需要低级语言功能。一些JVM子系统需要低级功能，例如垃圾收集和bytemode解释。因此，JVMCI是用Java而不是C或C++编写的。这带来了Java的一些最伟大特性的附带好处，如下所示：
- en: Exception handling
  id: totrans-496
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异常处理
- en: IDEs that are both free and robust
  id: totrans-497
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 既是免费又强大的IDE
- en: Memory management
  id: totrans-498
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存管理
- en: Runtime extensibility
  id: totrans-499
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行时可扩展性
- en: Synchronization
  id: totrans-500
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同步
- en: Unit testing support
  id: totrans-501
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试支持
- en: As JVMCI was written in Java, it will arguably be easier to maintain.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 由于JVMCI是用Java编写的，因此维护起来可能更容易。
- en: 'There are three primary components of the JVMCI API:'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: JVMCI API有三个主要组件：
- en: Virtual machine data structure access
  id: totrans-504
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虚拟机数据结构访问
- en: Installing compiled code with its metadata
  id: totrans-505
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与其元数据一起安装编译代码
- en: Using the JVM's compilation system
  id: totrans-506
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用JVM的编译系统
- en: 'The JVMCI actually existed, to some extent, in Java 8\. The JVMCI API was only
    accessible via a class loader that worked for code on the boot class path. In
    Java 9, this changes. It will still be experimental in Java 9, but more accessible.
    In order to enable the JVMCI, the following series of command-line options must
    be used:'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: JVMCI实际上在Java 8中就已经存在，某种程度上。JVMCI API只能通过一个适用于启动类路径上代码的类加载器来访问。在Java 9中，这种情况发生了变化。在Java
    9中，它仍然将是实验性的，但更容易访问。为了启用JVMCI，必须使用以下一系列命令行选项：
- en: '[PRE9]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Oracle is keeping the JVMCI experimental in Java 9 to permit further testing
    and to afford the greatest level of protection for developers.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: Oracle将JVMCI在Java 9中保持为实验性，以允许进一步的测试，并为开发者提供最大的保护。
- en: BeanInfo annotations [JEP-256]
  id: totrans-510
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: BeanInfo注解 [JEP-256]
- en: The JEP-256 focused on replacing `@beanifo` javadoc tags with more appropriate
    annotations. Furthermore, these new annotations are now processed at runtime so
    that `BeanInfo` classes can be generated dynamically. The modularity of Java 9
    resulted in this change. The creation of custom `BeanInfo` classes has been simplified
    and the client library has been modularized.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: JEP-256专注于用更合适的注解替换`@beanifo` javadoc标签。此外，这些新注解现在在运行时进行处理，以便可以动态生成`BeanInfo`类。Java
    9的模块化导致了这一变化。自定义`BeanInfo`类的创建已经简化，客户端库也已经模块化。
- en: In order to fully grasp this change, we will review `JavaBean`, `BeanProperty`,
    and `SwingContainer` before going any further into this JEP.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完全理解这个变化，在进一步探讨这个 JEP 之前，我们将回顾 `JavaBean`、`BeanProperty` 和 `SwingContainer`。
- en: JavaBean
  id: totrans-513
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaBean
- en: 'A `JavaBean` is a Java class. Like other Java classes, `JavaBeans` are reusable
    code. They are unique in their design because they encapsulate several objects
    into one. There are three conventions a `JavaBean` class must follow:'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: '`JavaBean` 是一个 Java 类。与其他 Java 类一样，`JavaBeans` 是可重用的代码。它们在设计上独特，因为它们将多个对象封装到一个类中。一个
    `JavaBean` 类必须遵循以下三个约定：'
- en: The constructor should not take any arguments
  id: totrans-515
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构造函数不应该接受任何参数
- en: It must be serializable
  id: totrans-516
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它必须是可序列化的
- en: It must contain mutator and accessor methods for its properties
  id: totrans-517
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它必须包含其属性的修改器和访问器方法
- en: 'Here is an example `JavaBean` class:'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个 `JavaBean` 类的示例：
- en: '[PRE10]'
  id: totrans-519
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Accessing `JavaBean` classes is as simple as using the mutator and accessor
    methods. This is likely not new to you, but there is a good chance you did not
    know that those carefully coded classes you created were called `JavaBean` classes.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 访问 `JavaBean` 类就像使用修改器和访问器方法一样简单。这可能对你来说并不陌生，但你可能不知道你精心编写的那些类被称为 `JavaBean`
    类。
- en: BeanProperty
  id: totrans-521
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: BeanProperty
- en: '`BeanProperty` is an annotation type. We use this annotation to specify a property
    so that we can automatically generate `BeanInfo` classes. This is a new annotation
    for Java 9.'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: '`BeanProperty` 是一个注解类型。我们使用这个注解来指定一个属性，以便我们可以自动生成 `BeanInfo` 类。这是 Java 9 中的一个新注解。'
- en: 'The `BeanProperty` annotation has the following optional elements:'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: '`BeanProperty` 注解有以下可选元素：'
- en: '`boolean bound`'
  id: totrans-524
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boolean bound`'
- en: '`String description`'
  id: totrans-525
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`String description`'
- en: '`String[] enumerationValues`'
  id: totrans-526
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`String[] enumerationValues`'
- en: '`boolean expert`'
  id: totrans-527
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boolean expert`'
- en: '`boolean hidden`'
  id: totrans-528
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boolean hidden`'
- en: '`boolean preferred`'
  id: totrans-529
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boolean preferred`'
- en: '`boolean required`'
  id: totrans-530
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boolean required`'
- en: '`boolean visualUpdate`'
  id: totrans-531
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boolean visualUpdate`'
- en: SwingContainer
  id: totrans-532
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SwingContainer
- en: '`SwingContainer` is an annotation type. We use this annotation to specify a
    swing-related property so that we can automatically generate `BeanInfo` classes.
    This is a new annotation for Java 9.'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: '`SwingContainer` 是一个注解类型。我们使用这个注解来指定与 Swing 相关的属性，以便我们可以自动生成 `BeanInfo` 类。这是
    Java 9 中的一个新注解。'
- en: 'The `SwingContainer` annotation has the following optional elements:'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: '`SwingContainer` 注解有以下可选元素：'
- en: '`String delegate`'
  id: totrans-535
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`String delegate`'
- en: '`boolean value`'
  id: totrans-536
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boolean value`'
- en: Now that we have reviewed `JavaBean`, `BeanProperty`, and `SwingContainer`,
    let's take a look at the `BeanInfo` classes.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经回顾了 `JavaBean`、`BeanProperty` 和 `SwingContainer`，让我们来看看 `BeanInfo` 类。
- en: BeanInfo classes
  id: totrans-538
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: BeanInfo 类
- en: For the most part, `BeanInfo` classes are automatically generated at runtime.
    The exception is with Swing classes. Those classes generate `BeanInfo` classes
    based on the `@beaninfo` javadoc tags. This is done at compile time, not runtime.
    In Java 9, the `@beaninfo` tags have been replaced with `@interface JavaBean`,
    `@interface BeanProperty`, and `@interface SwingContainer` annotations.
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分情况下，`BeanInfo` 类在运行时自动生成。例外的是 Swing 类。这些类基于 `@beaninfo` javadoc 标签生成 `BeanInfo`
    类。这是在编译时完成的，而不是在运行时。在 Java 9 中，`@beaninfo` 标签已被 `@interface JavaBean`、`@interface
    BeanProperty` 和 `@interface SwingContainer` 注解所取代。
- en: 'These new annotations are used to set the corresponding attributes based on
    the optional elements noted in the previous sections. As an example, the following
    code snippet sets the attributes for a `SwingContainer`:'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 这些新注解用于根据前几节中提到的可选元素设置相应的属性。例如，以下代码片段设置了 `SwingContainer` 的属性：
- en: '[PRE11]'
  id: totrans-541
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This provides us with three benefits:'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 这为我们提供了三个好处：
- en: It will be much easier to specify attributes in Bean classes instead of having
    to create individual `BeanInfo` classes
  id: totrans-543
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Bean 类中指定属性将比创建单个 `BeanInfo` 类要容易得多
- en: We will be able to remove auto-generated classes
  id: totrans-544
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将能够移除自动生成的类
- en: The client library is much more easily modularized with this approach
  id: totrans-545
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用这种方法，客户端库的模块化将变得更加容易
- en: TIFF image input/output [JEP-262]
  id: totrans-546
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TIFF 图像输入/输出 [JEP-262]
- en: 'JEP-262 is pretty straight forward. For Java 9, the image input/output plugins
    have been extended to include support for the TIFF image format. The `ImageIO`
    class extends the `Object` class and is part of Java SE. The class contains several
    methods for encoding and decoding images. Here is a list of static methods:'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: JEP-262 非常直接。对于 Java 9，图像输入/输出插件已扩展以包括对 TIFF 图像格式的支持。`ImageIO` 类扩展了 `Object`
    类，并是 Java SE 的一部分。该类包含用于编码和解码图像的几个方法。以下是静态方法列表：
- en: '| **Method** | **Return value** |'
  id: totrans-548
  prefs: []
  type: TYPE_TB
  zh: '| **方法** | **返回值** |'
- en: '| `createImageInputStream(Object input)` | `ImageInputStream` |'
  id: totrans-549
  prefs: []
  type: TYPE_TB
  zh: '| `createImageInputStream(Object input)` | `ImageInputStream` |'
- en: '| `createImageOutputStream(Object output)` | `ImageOutputStream` |'
  id: totrans-550
  prefs: []
  type: TYPE_TB
  zh: '| `createImageOutputStream(Object output)` | `ImageOutputStream` |'
- en: '| `getCacheDirectory()` | Current value of the `CacheDirectory` |'
  id: totrans-551
  prefs: []
  type: TYPE_TB
  zh: '| `getCacheDirectory()` | 当前 `CacheDirectory` 的值 |'
- en: '| `getImageReader(ImageWriter writer)` | `ImageReader` |'
  id: totrans-552
  prefs: []
  type: TYPE_TB
  zh: '| `getImageReader(ImageWriter writer)` | `ImageReader` |'
- en: '| `getImageReaders(Object input)` | Iterator of current `ImageReaders` |'
  id: totrans-553
  prefs: []
  type: TYPE_TB
  zh: '| `getImageReaders(Object input)` | 当前 `ImageReaders` 迭代器 |'
- en: '| `getImageReadersByFormatName(String formatName)` | Iterator of current `ImageReaders`
    with the specified format name |'
  id: totrans-554
  prefs: []
  type: TYPE_TB
  zh: '| `getImageReadersByFormatName(String formatName)` | 带有指定格式名称的当前 `ImageReaders`
    迭代器 |'
- en: '| `getImageReadersByMIMEType(String MIMEType)` | Iterator of current `ImageReaders`
    of the specified MIME type |'
  id: totrans-555
  prefs: []
  type: TYPE_TB
  zh: '| `getImageReadersByMIMEType(String MIMEType)` | 当前指定 MIME 类型的 `ImageReaders`
    迭代器 |'
- en: '| `getImageReadersBySuffix(String fileSuffix)` | Iterator of current `ImageReaders`
    with the specified suffix. |'
  id: totrans-556
  prefs: []
  type: TYPE_TB
  zh: '| `getImageReadersBySuffix(String fileSuffix)` | 带有指定后缀的当前 `ImageReaders` 迭代器
    |'
- en: '| `getImageTranscoders(ImageReader reader)` | Iterator of current `ImageTranscoders`
    |'
  id: totrans-557
  prefs: []
  type: TYPE_TB
  zh: '| `getImageTranscoders(ImageReader reader)` | 当前 `ImageTranscoders` 迭代器 |'
- en: '| `getImageWriter(ImageReader reader)` | `ImageWriter` |'
  id: totrans-558
  prefs: []
  type: TYPE_TB
  zh: '| `getImageWriter(ImageReader reader)` | `ImageWriter` |'
- en: '| `getImageWriters(ImageTypeSpecifier type, String formatName)` | Iterator
    of current `ImageWriters` that can encode to the specified type |'
  id: totrans-559
  prefs: []
  type: TYPE_TB
  zh: '| `getImageWriters(ImageTypeSpecifier type, String formatName)` | 可以编码到指定类型的当前
    `ImageWriters` 迭代器 |'
- en: '| `getImageWritersByFormatName(String formatName)` | Iterator of current `ImageWriters`
    with the specified format name |'
  id: totrans-560
  prefs: []
  type: TYPE_TB
  zh: '| `getImageWritersByFormatName(String formatName)` | 带有指定格式名称的当前 `ImageWriters`
    迭代器 |'
- en: '| `getImageWritersByMIMEType(String MIMEType)` | Iterator of current `ImageWriters`
    of the specified MIME type |'
  id: totrans-561
  prefs: []
  type: TYPE_TB
  zh: '| `getImageWritersByMIMEType(String MIMEType)` | 当前指定 MIME 类型的 `ImageWriters`
    迭代器 |'
- en: '| `getImageWritersBySuffix(String fileSuffix)` | Iterator of current `ImageWriters`
    with the specified suffix. |'
  id: totrans-562
  prefs: []
  type: TYPE_TB
  zh: '| `getImageWritersBySuffix(String fileSuffix)` | 带有指定后缀的当前 `ImageWriters` 迭代器
    |'
- en: '| `getReaderFileSuffixes()` | String array with file suffixes understood by
    current readers |'
  id: totrans-563
  prefs: []
  type: TYPE_TB
  zh: '| `getReaderFileSuffixes()` | 当前读取器理解的文件后缀名字符串数组 |'
- en: '| `getReaderFormatNames()` | String array with format names understood by current
    readers |'
  id: totrans-564
  prefs: []
  type: TYPE_TB
  zh: '| `getReaderFormatNames()` | 当前读取器理解的格式名称字符串数组 |'
- en: '| `getReaderMIMETypes()` | String array with MIME types understood by current
    readers |'
  id: totrans-565
  prefs: []
  type: TYPE_TB
  zh: '| `getReaderMIMETypes()` | 当前读取器理解的 MIME 类型字符串数组 |'
- en: '| `getUseCache()` | `UseCache` value |'
  id: totrans-566
  prefs: []
  type: TYPE_TB
  zh: '| `getUseCache()` | `UseCache` 值 |'
- en: '| `getWriterFileSuffixes()` | String array of file suffixes understood by current
    writers |'
  id: totrans-567
  prefs: []
  type: TYPE_TB
  zh: '| `getWriterFileSuffixes()` | 当前编写器理解的文件后缀名字符串数组 |'
- en: '| `getWriterFormatNames()` | String array with format names understood by current
    writers |'
  id: totrans-568
  prefs: []
  type: TYPE_TB
  zh: '| `getWriterFormatNames()` | 当前编写器理解的格式名称字符串数组 |'
- en: '| `getWriterMIMETypes()` | String array with MIME types understood by current
    writers |'
  id: totrans-569
  prefs: []
  type: TYPE_TB
  zh: '| `getWriterMIMETypes()` | 当前编写器理解的 MIME 类型字符串数组 |'
- en: '| `read(File input)` | `BufferedImage` with an `ImageReader` |'
  id: totrans-570
  prefs: []
  type: TYPE_TB
  zh: '| `read(File input)` | 带有 `ImageReader` 的 `BufferedImage` |'
- en: '| `read(ImageInputStream stream)` | `BufferedImage` with `ImageInputStream`
    and an `ImageReader` |'
  id: totrans-571
  prefs: []
  type: TYPE_TB
  zh: '| `read(ImageInputStream stream)` | 带有 `ImageInputStream` 和 `ImageReader` 的
    `BufferedImage` |'
- en: '| `read(InputStream input)` | `BufferedImage` with `InputStream` and `ImageReader`
    |'
  id: totrans-572
  prefs: []
  type: TYPE_TB
  zh: '| `read(InputStream input)` | 带有 `InputStream` 和 `ImageReader` 的 `BufferedImage`
    |'
- en: '| `read(URL input)` | `BufferedImage` with an `ImageReader` |'
  id: totrans-573
  prefs: []
  type: TYPE_TB
  zh: '| `read(URL input)` | 带有 `ImageReader` 的 `BufferedImage` |'
- en: 'There are also a few static methods that do not return a value or return a
    Boolean:'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 存在几个不返回值或返回布尔值的静态方法：
- en: '| **Method** | **Description** |'
  id: totrans-575
  prefs: []
  type: TYPE_TB
  zh: '| **方法** | **描述** |'
- en: '| `scanForPlugins()` | Performs the following actions:'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: '| `scanForPlugins()` | 执行以下操作：'
- en: Scans the application classpath for plugins
  id: totrans-577
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在应用程序类路径中扫描插件
- en: Loads plugin service provider classes
  id: totrans-578
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加载插件服务提供程序类
- en: Registers service provide instances in the IIORegistry
  id: totrans-579
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 IIORegistry 中注册服务提供程序实例
- en: '|'
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `setCacheDirectory(File cacheDirectory)` | This is where the cache files
    will be stored. |'
  id: totrans-581
  prefs: []
  type: TYPE_TB
  zh: '| `setCacheDirectory(File cacheDirectory)` | 缓存文件将存储在这里。 |'
- en: '| `setUseCache(boolean useCache)` | This method toggles if the cache will be
    disk-based or not. This applies to `ImageInputStream` and `ImageOutputStream`
    instances. |'
  id: totrans-582
  prefs: []
  type: TYPE_TB
  zh: '| `setUseCache(boolean useCache)` | 此方法切换缓存是否基于磁盘。这适用于 `ImageInputStream` 和
    `ImageOutputStream` 实例。 |'
- en: '| `write(RenderedImage im, String formatName, File output)` | Writes an image
    to the specified file. |'
  id: totrans-583
  prefs: []
  type: TYPE_TB
  zh: '| `write(RenderedImage im, String formatName, File output)` | 将图像写入指定的文件。 |'
- en: '| `write(RenderedImage im, String formatName, ImageOutputStream output)` |
    Writes an image to an `ImageOutputStream`. |'
  id: totrans-584
  prefs: []
  type: TYPE_TB
  zh: '| `write(RenderedImage im, String formatName, ImageOutputStream output)` |
    将图像写入 `ImageOutputStream`。 |'
- en: '| `write(RenderedImage im, String formatName, OutputStream output)` | Writes
    an image to an `OutputStream`. |'
  id: totrans-585
  prefs: []
  type: TYPE_TB
  zh: '| `write(RenderedImage im, String formatName, OutputStream output)` | 将图像写入
    `OutputStream`。 |'
- en: 'As you can glean from the provided methods, the image input/output framework
    provides us with a convenient way of using image codecs. As of Java 7, the following
    image format plugins were implemented by `javax.imageio`:'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 从提供的方法中可以看出，图像输入/输出框架为我们提供了一个方便的方式来使用图像编解码器。截至Java 7，以下图像格式插件由 `javax.imageio`
    实现：
- en: BMP
  id: totrans-587
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: BMP
- en: GIF
  id: totrans-588
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GIF
- en: JPEG
  id: totrans-589
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JPEG
- en: PNG
  id: totrans-590
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PNG
- en: WBMP
  id: totrans-591
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WBMP
- en: The TIFF is, as you can see, not on the list of image file formats. TIFFs are
    a common file format and, in 2001, macOS, with the release of MacOS X, used the
    format extensively.
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，TIFF并未出现在图像文件格式的列表中。TIFFs是一种常见的文件格式，在2001年，随着MacOS X的发布，macOS广泛使用了该格式。
- en: The Java 9 platform includes `ImageReader` and `ImageWriter` plugins for the
    TIFFs. These plugins have been written in Java and have been bundled in the new
    `javax.imageio.plugins.tiff` package.
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: Java 9平台包括TIFFs的`ImageReader`和`ImageWriter`插件。这些插件是用Java编写的，并打包在新的`javax.imageio.plugins.tiff`包中。
- en: Platform logging API and service [JEP-264]
  id: totrans-594
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 平台日志API和服务 [JEP-264]
- en: The Java 9 platform includes a new logging API enabling platform classes to
    log messages. It has a commensurate service for manipulating the logs. Before
    we go too far into what is new regarding the logging API and service, let's review
    `java.util.logging.api` which was introduced in Java 7.
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: Java 9平台包括一个新的日志API，使平台类能够记录消息。它有一个相应的服务来操作日志。在我们深入探讨关于日志API和服务的更新之前，让我们回顾一下在Java
    7中引入的 `java.util.logging.api`。
- en: The java.util.logging package
  id: totrans-596
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`java.util.logging` 包'
- en: 'The `java.util.logging` package includes classes and interfaces that collectively
    comprise Java''s core logging features. This functionality was created with the
    following goals:'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.util.logging` 包包含类和接口，共同构成了Java的核心日志功能。此功能创建的目标如下：'
- en: Problem diagnosis by end users and system administrators
  id: totrans-598
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过最终用户和系统管理员进行问题诊断
- en: Problem diagnosis by field service engineers
  id: totrans-599
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过现场服务工程师进行问题诊断
- en: Problem diagnosis by the development organization
  id: totrans-600
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过开发组织进行问题诊断
- en: As you can see, the primary purpose was to enable maintenance of remote software.
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，主要目的是为了使远程软件的维护成为可能。
- en: 'The `java.util.logging` package has two interfaces:'
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.util.logging` 包包含两个接口：'
- en: '`public interface Filter`'
  id: totrans-603
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public interface Filter`'
- en: 'Purpose: This provides fine-grain control over logged data'
  id: totrans-604
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目的：这提供了对记录数据的细粒度控制
- en: 'Method:'
  id: totrans-605
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法：
- en: '`isLoggable(LogRecord record)`'
  id: totrans-606
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isLoggable(LogRecord record)`'
- en: '`public interface LoggingMXBean`'
  id: totrans-607
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public interface LoggingMXBean`'
- en: 'Purpose: This is the logging facility''s management interface'
  id: totrans-608
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目的：这是日志设施的管理接口
- en: 'Methods:'
  id: totrans-609
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法：
- en: '`getLoggerLevel(String loggerName)`'
  id: totrans-610
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getLoggerLevel(String loggerName)`'
- en: '`getLoggerNames()`'
  id: totrans-611
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getLoggerNames()`'
- en: '`getparentLoggerName(String loggerName)`'
  id: totrans-612
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getparentLoggerName(String loggerName)`'
- en: '`setLoggerLevel(String loggerName, String levelName)`'
  id: totrans-613
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setLoggerLevel(String loggerName, String levelName)`'
- en: 'The following table provides the `java.util.logging` package classes, along
    with a brief description regarding what each class provides in respect to logging
    functionality and management:'
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: 下表提供了 `java.util.logging` 包的类，以及每个类在日志功能和管理方面的简要描述：
- en: '| **Class** | **Definition** | **Description** |'
  id: totrans-615
  prefs: []
  type: TYPE_TB
  zh: '| **类** | **定义** | **描述** |'
- en: '| `ConsoleHandler` | `public class ConsoleHandler extends StreamHandler` |
    Publishes log records to `System.err` |'
  id: totrans-616
  prefs: []
  type: TYPE_TB
  zh: '| `ConsoleHandler` | `public class ConsoleHandler extends StreamHandler` |
    将日志记录发布到 `System.err` |'
- en: '| `ErrorManager` | `public class ErrorManager extends Object` | Used to process
    errors during logging |'
  id: totrans-617
  prefs: []
  type: TYPE_TB
  zh: '| `ErrorManager` | `public class ErrorManager extends Object` | 用于在记录过程中处理错误
    |'
- en: '| `FileHandler` | `public class FileHandler extends StreamHandler` | File logging
    |'
  id: totrans-618
  prefs: []
  type: TYPE_TB
  zh: '| `FileHandler` | `public class FileHandler extends StreamHandler` | 文件记录 |'
- en: '| `Formatter` | `public abstract class Formatter extends Object` | For formatting
    `LogRecords` |'
  id: totrans-619
  prefs: []
  type: TYPE_TB
  zh: '| `Formatter` | `public abstract class Formatter extends Object` | 格式化 `LogRecords`
    |'
- en: '| `Handler` | `public abstract class Handler extends Object` | Exports `Logger`
    messages |'
  id: totrans-620
  prefs: []
  type: TYPE_TB
  zh: '| `Handler` | `public abstract class Handler extends Object` | 导出 `Logger`
    消息 |'
- en: '| `Level` | `public class Level extends Object implements Serializable` | Controls
    level of logging. The levels, in descending order, are--severe, warning, info,
    config, fine, finer, and finest |'
  id: totrans-621
  prefs: []
  type: TYPE_TB
  zh: '| `Level` | `public class Level extends Object implements Serializable` | 控制日志级别。级别按降序排列为--严重、警告、信息、配置、精细、更精细和最精细
    |'
- en: '| `Logger` | `public class Logger extends Object` | Logs messages |'
  id: totrans-622
  prefs: []
  type: TYPE_TB
  zh: '| `Logger` | `public class Logger extends Object` | 记录消息 |'
- en: '| `LoggingPermission` | `public final class LoggingPermission extends BasicPermission`
    | `SecurityManager` checks this |'
  id: totrans-623
  prefs: []
  type: TYPE_TB
- en: '| `LogManager` | `public class LogManager` | For maintaining shared state between
    loggers and logging services |'
  id: totrans-624
  prefs: []
  type: TYPE_TB
- en: '| `LogRecord` | `public class LogRecord extends Object implements Serializable`
    | Passed between handlers |'
  id: totrans-625
  prefs: []
  type: TYPE_TB
- en: '| `MemoryHandler` | `public class MemoryHandler extends Handler` | Buffers
    requests in memory |'
  id: totrans-626
  prefs: []
  type: TYPE_TB
- en: '| `SimpleFormatter` | `public class SimpleFormatter extends Formatter` | Provides
    human-readable `LogRecord` metadata |'
  id: totrans-627
  prefs: []
  type: TYPE_TB
- en: '| `SocketHandler` | `public class SocketHandler extends StreamHandler` | Network
    logging handler |'
  id: totrans-628
  prefs: []
  type: TYPE_TB
- en: '| `StreamHandler` | `public class StreamHandler extends Handler` | Stream-based
    logging handler |'
  id: totrans-629
  prefs: []
  type: TYPE_TB
- en: '| `XMLFormatter` | `public class XMLFormatter extends Formatter` | Formats
    logs into XML |'
  id: totrans-630
  prefs: []
  type: TYPE_TB
- en: Next, let's review what changes were made in Java 9.
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
- en: Logging in Java 9
  id: totrans-632
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Prior to Java 9, there were multiple logging schemas available, including `java.util.logging`,
    `SLF4J`, and `Log4J`. The latter two are third-party frameworks that have separate
    facade and implementation components. This pattern has been replicated in the
    new Java 9 platform.
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
- en: Java 9 introduced changes to the `java.base` module so that it would handle
    logging functions and not rely on the `java.util.logging` API. It has separate
    facade and implementation components. This means that when using third-party frameworks,
    the JDK only needs to provide the implementation component and return platform
    loggers that work with the requesting logging framework.
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see in the following illustration, we use the `java.util.ServiceLoader`
    API to load our `LoggerFinder` implementation. The JDK uses a default implementation
    if a concrete implementation is not found using the system class loader:'
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9bdf222e-0a06-4a54-b8d9-728601e10744.png)'
  id: totrans-636
  prefs: []
  type: TYPE_IMG
- en: XML Catalogs [JEP-268]
  id: totrans-637
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'JEP 268, titled XML Catalogs, focused on creating a standard XML Catalog API
    to support the OASIS XML Catalogs Standard v1.1\. The new API defines catalog
    and catalog-resolve abstractions so that JAXP processors can use them. In this
    section, we will look at the following:'
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
- en: The OASIS XML Catalog standard
  id: totrans-639
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JAXP processors
  id: totrans-640
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: XML Catalogs prior to Java 9
  id: totrans-641
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Java 9 platform changes
  id: totrans-642
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The OASIS XML Catalog standard
  id: totrans-643
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**XML** (**eXtensible Markup Language**) Catalogs are XML documents consisting
    of catalog entries. Each entry pairs an identifier to another location. OASIS
    is a not-for-profit consortium with the mission of advancing open standards. They
    published the XML catalog standard, version 1.1., in 2005\. This standard has
    two basic use cases:'
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
- en: Map an external identifier to a URI reference
  id: totrans-645
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Map a URI reference to another URI reference
  id: totrans-646
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is a sample XML catalog entry:'
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-648
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The complete OASIS XML Catalog standard can be found at the official site:
    [https://www.oasis-open.org/committees/download.php/14809/xml-catalogs.html](https://www.oasis-open.org/committees/download.php/14809/xml-catalogs.html)'
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
- en: JAXP processors
  id: totrans-650
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Java API for XML processing is referred to as JAXP. As its name suggests,
    this API is used for parsing XML documents. There are four related interfaces:'
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
- en: 'DOM: Document Object Model parsing'
  id: totrans-652
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'SAX: Simple API for XML parsing'
  id: totrans-653
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'StAX: Streaming API for XML parsing'
  id: totrans-654
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'XSLT: Interface to transform XML documents'
  id: totrans-655
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: XML Catalogs prior to Java 9
  id: totrans-656
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Java platform has had an internal catalog resolver since JDK 6\. There was
    no public API, so external tools and libraries were used to access the functionality.
    Moving into Java 9, the goal was to make the internal catalog resolver a standard
    API for common use and ease of support.
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
- en: Java 9 platform changes
  id: totrans-658
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The new XML Catalog API, delivered with Java 9, follows the OASIS XML Catalogs
    standard, v1.1\. Here are the feature and capability highlights:'
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
- en: Implements `EntityResolver`
  id: totrans-660
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implements `URIResolver`
  id: totrans-661
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creation of XML Catalogs is possible via the `CatalogManager`
  id: totrans-662
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CatalogManager` will be used to create `CatalogResolvers`'
  id: totrans-663
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OASIS open catalog file semantics will be followed
  id: totrans-664
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Map an external identifier to a URI reference
  id: totrans-665
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Map a URI reference to another URI reference
  id: totrans-666
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CatalogResolvers` will implement the JAXP `EntityResolver` interface'
  id: totrans-667
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CatalogResolvers` will implement the JAXP `URIResolver` interface'
  id: totrans-668
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The SAX `XMLFilter` will be supported by the resolver.
  id: totrans-669
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since the new XML Catalog API will be public, the pre-Java 9 internal catalog
    resolver will be removed, as it will no longer be necessary.
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
- en: Convenience factory methods for collections [JEP-269]
  id: totrans-671
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Java programming language does not support collection literals. Adding this
    feature to the Java platform was proposed in 2013 and revisited in 2016, but it
    only gained exposure as a research proposal, not for future implementation.
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
- en: Oracle's definition of a collection literal is "*a syntactic expression form
    that evaluates to an aggregate type, such as an array, list, or map*" ([http://openjdk.java.net/jeps/186](http://openjdk.java.net/jeps/186)).
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, that is until Java 9 is released. Implementing collection literals
    in the Java programming language is reported to have the following benefits:'
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
- en: Performance improvement
  id: totrans-675
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Increased safety
  id: totrans-676
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reduction of boilerplate code
  id: totrans-677
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Even without being part of the research group, our knowledge of the Java programming
    language clues us in to additional benefits:'
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
- en: Ability to write shorter code
  id: totrans-679
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ability to write space-efficient code
  id: totrans-680
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ability to make collection literals immutable
  id: totrans-681
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's look at two cases--using collections before Java 9, and then with the
    new support for collection literals in the new Java platform.
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
- en: Using collections before Java 9
  id: totrans-683
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here is an example of how we would create our own collections prior to Java
    9\. This first class defines the structure for `PlanetCollection`. It has the
    following components:'
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
- en: A single instance variable
  id: totrans-685
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A one argument constructor
  id: totrans-686
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mutator/setter method
  id: totrans-687
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessor/getter method
  id: totrans-688
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Method to print the object
  id: totrans-689
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is the code implementing the preceding listed constructor and methods:'
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-691
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, let''s look at the driver class that populates the collection:'
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-693
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Here is the output from this application:'
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fb5b62da-e9be-429a-9a1e-aa29485632a3.png)'
  id: totrans-695
  prefs: []
  type: TYPE_IMG
- en: This code is, unfortunately, very verbose. We populated our collection in static
    initializer blocks instead of using a field initializer. There are other methods
    of populating our list, but they are all more verbose than they should have to
    be. These other methods have additional problems, such as the need to create extra
    classes, the use of obscure code, and hidden references.
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
- en: Let's now take a look at the solution to this problem, provided by the new Java
    9 platform. We will look at what is new in the next section.
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
- en: Using new collection literals
  id: totrans-698
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to rectify the currently required code verbosity in creating collections,
    we need library APIs for creating collection instances. Look at our pre-Java 9
    code snippet in the previous section and then consider this possible refactoring:'
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-700
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This code is highly human-readable and not verbose.
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
- en: 'The new implementation will include static factory methods on the following
    interfaces:'
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
- en: '`List`'
  id: totrans-703
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Map`'
  id: totrans-704
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Set`'
  id: totrans-705
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, we are now able to create unmodifiable instances of `List` collections,
    `Map` collections, and `Set` collections. They can be instantiated with the following
    syntax:'
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
- en: '`List.of(a, b, c, d, e);`'
  id: totrans-707
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Set.of(a, b, c, d, e);`'
  id: totrans-708
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Map.of();`'
  id: totrans-709
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Map` collections will have a set of fixed arguments.
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
- en: Platform-specific desktop features [JEP-272]
  id: totrans-711
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The exciting JEP-272 was to create a new public API so that we can write applications
    with access to platform-specific desktop features. These features include interacting
    with task bars/docks and listening for application and system events.
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
- en: The macOS X `com.apple.eawt` package was an internal API and, starting with
    Java 9, is no longer accessible. In support of Java 9's new embedded platform-specific
    desktop features, `apple.applescript` classes are being removed from the Java
    platform without replacement.
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
- en: 'This effort had several objectives:'
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
- en: Create a public API to replace the functionality in `com.apple.{east,eio}`
  id: totrans-715
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Ensure OS X developers do not loose functionality. To this end, the Java 9
    platform has replacements for the following packages:'
  id: totrans-716
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`com.apple.eawt`'
  id: totrans-717
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`com.apple.eio`'
  id: totrans-718
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Provide developers with a near-common set of features for platforms (that is,
    Windows and Linux) in addition to OS X. The common features include:'
  id: totrans-719
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Login/logout handler with event listeners
  id: totrans-720
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Screen lock handler with event listeners
  id: totrans-721
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Task bar / dock actions to include:'
  id: totrans-722
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Requesting user attention
  id: totrans-723
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Indicating task progress
  id: totrans-724
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Action shortcuts
  id: totrans-725
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The new API will be added to the `java.awt.Desktop` class.
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
- en: Enhanced method handles [JEP-274]
  id: totrans-727
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The **Enhanced Method Handles** JEP-274 was to improve the following listed
    classes, to make common usage easier with improved optimizations:'
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
- en: '`MethodHandle` class'
  id: totrans-729
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MethodHandles` class'
  id: totrans-730
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MethodHandles.Lookup` class'
  id: totrans-731
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The listed classes are all part of the `java.lang.invoke` package, which has
    been updated as part of the Java 9 platform. The improvements were made possible
    through the use of lookup refinement and `MethodHandle` combinations `for` loops
    and `try...finally` blocks.
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we will look at the following regarding JEP-274:'
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
- en: Reason for the enhancement
  id: totrans-734
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lookup functions
  id: totrans-735
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Argument handling
  id: totrans-736
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additional combinations
  id: totrans-737
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reason for the enhancement
  id: totrans-738
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This enhancement stemmed from developer feedback and the desire to make the
    `MethodHandle`, `MethodHandles`, and `MethodHandles.Lookup` classes much easier
    to use. There was also the call to add additional use cases.
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
- en: 'The changes resulted in the following benefits:'
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
- en: Enabled precision in the usage of the `MethodHandle` API
  id: totrans-741
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instantiation reduction
  id: totrans-742
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Increased JVM compiler optimizations
  id: totrans-743
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lookup functions
  id: totrans-744
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Changes regarding lookup functions, for the Java 9 platform, include the following:'
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
- en: '`MethodHandles` can now be bound to non-abstract methods in interfaces'
  id: totrans-746
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The lookup API allows class lookups from different contexts
  id: totrans-747
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `MethodHandles.Lookup.findSpecial(Class<?> refs, String name, MethodType
    type, Class<?> specialCaller)` class has been modified to permit locating super-callable
    methods on interfaces.
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition, the following methods have been added to the `MethodHandles.Lookup`
    class:'
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
- en: '`Class<?> findClass(String targetName)`'
  id: totrans-750
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Class<?> accessClass(Class<?> targetClass)`'
  id: totrans-751
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Argument handling
  id: totrans-752
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Three updates were made to improve `MethodHandle` argument handling for the
    Java 9 platform. These changes are highlighted as follows:'
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
- en: Argument folding using `foldArguments(MethodHandle target, MethodHandle combinator)`
    did not previously have a position argument.
  id: totrans-754
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Argument collection using the `MethodHandle.asCollector(Class<?> arrayType,
    int arrayLength)` method did not previously support collecting the arguments into
    an array except for the trailing element. This has been changed, and there is
    now an additional `asCollector` method to support that functionality in Java 9.
  id: totrans-755
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Argument spreading using the `MethodHandle.asSpreader(Class<?> arrayType, int
    arrayLength)` method spreads the contents of the trailing array to a number of
    arguments, in a reverse method of argument collection. Argument spreading has
    been modified to support the expansion of an array anywhere in the method signature.
  id: totrans-756
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The new method definitions for the updated `asCollector` and `asSpreader` methods
    are provided in the next section.
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
- en: Additional combinations
  id: totrans-758
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following addition combinations have been added to support the ease of
    use and optimizations for the `MethodHandle`, `MethodHandles`, and `MethodHandles.Lookup`
    classes of the `java.lang.invoke` package in the Java 9 platform:'
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
- en: 'Generic loop abstraction:'
  id: totrans-760
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MethodHandle loop(MethodHandle[] . . . clauses)`'
  id: totrans-761
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`While` loops:'
  id: totrans-762
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MethodHandle whileLoop(MethodHandle init, MethodHandle pred, MethodHandle
    body)`'
  id: totrans-763
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Do...while` loops:'
  id: totrans-764
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`` `MethodHandle doWhileLoop(MethodHandle init, MethodHandle body, MethodHandle
    pred)` ``'
  id: totrans-765
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Counting loops:'
  id: totrans-766
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MethodHandle countedLoop(MethodHandle iterations, MethodHandle init, MethodHandle
    body)`'
  id: totrans-767
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Data structure iteration:'
  id: totrans-768
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MethodHandle iteratedLoop(MethodHandle iterator, MethodHandle init, MethodHandle
    body)`'
  id: totrans-769
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Try...finally` blocks:'
  id: totrans-770
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MethodHandle tryFinally(MethodHandle target, MethodHandle cleanup)`'
  id: totrans-771
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Argument handling:'
  id: totrans-772
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Argument spreading:'
  id: totrans-773
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MethodHandle asSpreader(int pos, Class<?> arrayType, int arrayLength)`'
  id: totrans-774
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Argument collection:'
  id: totrans-775
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MethodHandle asCollector(int pos, Class<?> arrayType, int arrayLength)`'
  id: totrans-776
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Argument folding:'
  id: totrans-777
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MethodHandle foldArguments(MethodHandle target, int pos, MethodHandle combiner)`'
  id: totrans-778
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Enhanced deprecation [JEP-277]
  id: totrans-779
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are two facilities for expressing deprecation:'
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
- en: '`@Deprecated` annotation'
  id: totrans-781
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@deprecated` javadoc tag'
  id: totrans-782
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These facilities were introduced in Java SE 5 and JDK 1.1, respectively. The
    `@Deprecated` annotation was intended to annotate program components that should
    not be used because they were deemed dangerous and/or there was a better option.
    That was the intended use. Actual use varied including and because warnings were
    only provided at compile time; there was little reason to ignore the annotated
    code.
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
- en: The **Enhanced Deprecation** JEP-277 was taken on to provide developers with
    clearer information regarding the intended disposition of the APIs in the specification
    documentation. Work on this JEP also resulted in a tool for analyzing a program's
    use of deprecated APIs.
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
- en: 'To support this fidelity in information, the following components have been
    added to the `java.lang.Deprecated` annotation type:'
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
- en: '`forRemoval()`:'
  id: totrans-786
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returns Boolean `true` if the API element has been slated for future removal
  id: totrans-787
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Returns Boolean `false` if the API element has not been slated for future removal
    but is deprecated
  id: totrans-788
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Default is `false`
  id: totrans-789
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`since()`:'
  id: totrans-790
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returns a string containing the release or version number, at which point the
    specified API was marked as deprecated
  id: totrans-791
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: What the @Deprecated annotation really means
  id: totrans-792
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When an API, or methods within an API, has/have been marked with the `@Deprecated`
    annotation, one or more of the following conditions typically exists:'
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
- en: There are errors in the API for which there is no plan to fix them
  id: totrans-794
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the API is likely to result in errors
  id: totrans-795
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The API has been replaced by another API
  id: totrans-796
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The API is experimental
  id: totrans-797
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  id: totrans-798
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered 16 JEPs that were incorporated into the Java 9 platform.
    These JEPs cover a wide range of tools and updates to APIs to make developing
    with Java easier, with greater optimization possibilities for our resulting programs.
    Our review included a look at the new HTTP client, changes to Javadoc and the
    Doclet API, the new JavaScript parser, JAR and JRE changes, the new Java-level
    JVM compiler interface, the new support for TIFF images, platform logging, XML
    Catalog support, collections, and the new platform-specific desktop features.
    We also looked at enhancements to method handling and the deprecation annotation.
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will cover concurrency enhancements introduced with
    the Java 9 platform. Our primary focus will be the support for reactive programming
    that is provided by the flow class API. We will also explore additional concurrency
    enhancements introduced in Java 9.
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍Java 9平台引入的并发增强功能。我们的主要关注点将是流类API提供的响应式编程支持。我们还将探讨Java 9中引入的其他并发增强功能。
