- en: New Tools and Tool Enhancements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we explored Java 9's new stack walker API and learned
    how it enables Java applications to walk the calling stack. This is a specialized
    functionality that is not often implemented in Java applications. That being said,
    the API may be good for some very special cases, such as for functionality that
    is delivered by a framework. You learned that if you develop framework-supporting
    application programming and you want code that depends on the caller context,
    then the stack walker API is for you. We also discovered that the API gives fast
    and optimized access to the call stack, implementing lazy access to the individual
    frames.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will cover 16 **Java Enhancement Proposals** (**JEPs**)
    that were incorporated into the Java 9 platform. These JEPs cover a wide range
    of tools and updates to APIs to make developing with Java easier, with greater
    optimization possibilities for our resulting programs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our review of new tools and tool enhancements will include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The new HTTP client
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Javadoc and the Doclet API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: mJRE changes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JavaScript parser
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multi-release JAR files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Java-level JVM compiler interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TIFF support
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Platform logging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: XML Catalogs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collections
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Platform-specific desktop features
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enhanced method handling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enhanced deprecation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The new HTTP client [JEP-110]
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will review Java's **Hypertext Transfer Protocol** (**HTTP**)
    client, starting with a pre-Java 9 look and then diving into the new HTTP client
    that is part of the Java 9 platform. This approach is needed to support an understanding
    of the changes made in Java 9.
  prefs: []
  type: TYPE_NORMAL
- en: The HTTP client before Java 9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'JDK version 1.1 introduced the `HttpURLConnection` API that supported HTTP-specific
    features. This was a robust class that included the fields listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`chunkLength`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fixedContentLength`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fixedContentLengthLong`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HTTP_ACCEPTED`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HTTP_BAD_GATEWAY`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HTTP_BAD_METHOD`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HTTP_BAD_REQUEST`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HTTP_CLIENT_TIMEOUT`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HTTP_CONFLICT`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HTTP_CREATED`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HTTP_ENTITY_TOO_LARGE`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HTTP_FORBIDDEN`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HTTP_GONE`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HTTP_INTERNAL_ERROR`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HTTP_LENGTH_REQUIRED`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HTTP_MOVED_PERM`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HTTP_MOVED_TEMP`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HTTP_MULT_CHOICE`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HTTP_NO_CONTENT`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HTTP_NOT_ACCEPTABLE`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HTTP_NOT_AUTHORITATIVE`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HTTP_NOT_FOUND`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HTTP_NOT_IMPLEMENTED`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HTTP_NOT_MODIFIED`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HTTP_OK`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HTTP_PARTIAL`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HTTP_PAYMENT_REQUIRED`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HTTP_PRECON_FAILED`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HTTP_PROXY_AUTH`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HTTP_REQ_TOO_LONG`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HTTP_RESET`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HTTP_SEE_OTHER`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HTTP_SERVER_ERROR`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HTTP_UNAUTHORIZED`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HTTP_UNAVAIABLE`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HTTP_UNSUPPORTED_TYPE`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HTTP_USE_PROXY`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HTTP_VERSION`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`instanceFollowRedirects`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`method`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`responseCode`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`responseMessage`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As you can see from the list of fields, there was a great support for HTTP.
    In addition to a constructor, there are a plethora of available methods, including
    the following ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '`disconnect()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getErrorStream()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getFollowRedirects()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getHeaderField(int n)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getHeaderFieldDate(String name, long Default)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getHeaderFieldKey(int n)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getInstanceFollowRedirects()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getPermission()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getRequestMethod()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getResponseCode()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getResponseMessage()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setChunkedStreamingMode(int chunklen)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setFixedLengthStreamingMode(int contentLength)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setFixedlengthStreamingMode(long contentLength)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setFollowRedirects(boolean set)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setInstanceFollowRedircts(boolean followRedirects)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setRequestMethod(String method)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`usingProxy()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The class methods listed earlier are in addition to the methods inherited from
    the `java.net.URLConnection` class and the `java.lang.Object` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'There were problems with the original HTTP client that made it ripe for updating
    with the new Java platform. Those problems were as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The base `URLConnection` API had, defunct protocols such as Gopher and FTP increasingly
    over the years
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `HttpURLConnection` API predated HTTP 1.1 and was overly abstract, making
    it less usable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The HTTP client was woefully under documented, making the API frustrating and
    difficult to use
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The client only functioned on one thread at a time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The API was extremely difficult to maintain due to the above points about it
    predating HTTP 1.1 and it lacking sufficient documentation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we know what was wrong with the HTTP client, let's look at what's in
    store for Java 9.
  prefs: []
  type: TYPE_NORMAL
- en: Java 9's new HTTP client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There were several goals associated with creating the new HTTP client for the
    Java 9 platform. JEP-110 was the organizing proposal for the new HTTP client.
    The primary goals of JEP-110 are listed here and featured the creation of the
    new HTTP client presented. These goals are presented in the broad categories of
    ease of use, core capabilities, additional capabilities, and performance:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Ease of use:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The API was designed to provide up to 90 percent of HTTP-related application
    requirements.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The new API is usable, without unnecessary complexity, for the most common use
    cases.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A simplistic blocking mode is included.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The API supports modern Java language features. Lambda expressions, a major
    new introduction released with Java 8, are an example.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Core capabilities:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Supports HTTPS/TLS
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Supports HTTP/2
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Provides visibility on all details related to HTTP protocol requests and responses
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Supports standard/common authentication mechanisms
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Provides **headers received** event notifications
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Provides **response body received** event notifications
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Provides error event notifications
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Additional capabilities:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The new API can be used for WebSocket handshakes
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: It performs security checks in concert with the current networking API
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Performance:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For HTTP/1.1:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The new API must perform at least as efficiently as the previous API.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Memory consumption must not exceed that of Apache HttpClient, Netty, and Jetty,
    when being used as a client API.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For HTTP/2:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Performance must exceed that of HTTP/1.1.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The new performance must match or exceed that of Netty and Jetty when being
    used as a client API. No performance degradation should be a result of the new
    client.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Memory consumption must not exceed that of Apache HttpClient, Netty, and Jetty,
    when being used as a client API.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoids running timer threads
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: New API limitations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are some intentional shortcomings of the new API. While this might sound
    counter-intuitive, the new API was not intended to completely replace the current
    `HttpURLConnection` API. Instead, the new API is intended to eventually replace
    the current one.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet provides an example of how to implement the `HttpURLConnect`
    class to open and read a URL in a Java application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code does not include exception handling for brevity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some specific limitations of the new API:'
  prefs: []
  type: TYPE_NORMAL
- en: Not all HTTP-related functionality is supported. It is estimated that about
    10 percent of the HTTP's protocol is not exposed by the API.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Standard/common authentication mechanisms have been limited to basic authentication.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The overarching goal of the new API was the simplicity of use, which means that
    performance improvements might not be realized. Certainly, there will be no performance
    degradation, but there is not likely to be an overwhelming level of improvement,
    either.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is no support for filtering on requests.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is no support for filtering on responses.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The new API does not include a pluggable connection cache.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is a lack of a general upgrade mechanism.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The new API is delivered as part of the Java 9 platform in the incubator mode.
    This suggests that the API will be standardized in a future Java platform, perhaps
    with Java 10.
  prefs: []
  type: TYPE_NORMAL
- en: Simplified Doclet API [JEP-221]
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Doclet API and Javadoc are closely related. Javadoc is a documentation tool
    and the Doclet API provides functionality so that we can inspect the javadoc comments
    embedded at the source-levels of libraries and programs. In this section, we will
    review the pre-Java 9 status of the Doclet API and then explore the changes introduced
    to the Doclet API in the Java 9 platform. In the following section, we will review
    Javadoc.
  prefs: []
  type: TYPE_NORMAL
- en: The pre-Java 9 Doclet API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The pre-Java 9 Doclet API, or the `com.sun.javadoc` package, gives us access
    to look at javadoc comments located in the source code. Invoking a Doclet is accomplished
    by using the `start` method. That method's signature is `public static boolean
    start(RootDoc root)`. We will use the `RootDoc` instance as a container for the
    program structure information.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to call javadoc, we need to pass the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Package names
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Source file names (for classes and interfaces)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An access control option--one of the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`package`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`private`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`protected`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: When the preceding listed items are used to call javadoc, a **documented set**
    is provided as a filtered list. If our aim is to obtain a comprehensive, unfiltered
    list, we can use `allClasses(false)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s review an example Doclet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see by the thoroughly commented code, gaining access to the javadoc
    content is relatively easy. In our preceding example, we would invoke the `AllThrows`
    class using the following code in the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of our result will consist of the following structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: API enums
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The API consists of one enum, `LanguageVersion`, which provides the Java programming
    language version. The constants for this enum are `Java_1_1` and `Java_1_5`.
  prefs: []
  type: TYPE_NORMAL
- en: API classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Doclet` class provides an example of how to create a class to start a
    Doclet. It contains an empty `Doclet()` constructor and the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`languageVersion()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`optionLength(String option)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`start(RootDoc root)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`validOptions(String[][] options, DocErrorReporter reporter)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: API interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Doclet API contains the following listed interfaces. The interface names
    are self-describing. You can consult the documentation for additional details:'
  prefs: []
  type: TYPE_NORMAL
- en: '`AnnotatedType`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AnnotationDesc`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AnnotationDesc.ElementValuePair`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AnnotationTypeDoc`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AnnotationTypeElementDoc`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AnnotationValue`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ClassDoc`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ConstructorDoc`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Doc`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DocErrorReporter`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ExecutableMemberDoc`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FieldDoc`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MemberDoc`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MethodDoc`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PackageDoc`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Parameter`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ParameterizedType`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ParamTag`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ProgramElementDoc`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RootDoc`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SeeTag`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SerialFieldTag`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SourcePosition`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Tag`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ThrowsTag`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Type`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TypeVariable`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WildcardType`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Problems with the pre-existing Doclet API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Fueling the need for a new Doclet API were several issues with the pre-existing
    Doclet API:'
  prefs: []
  type: TYPE_NORMAL
- en: It was not ideal for testing or concurrent usage. This stemmed from its implementation
    of static methods.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The language model used in the API had several limitations and became more problematic
    with each successive Java upgrade.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The API was inefficient, largely due to its heavy use of substring matching.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There was no reference provided regarding the specific location of any given
    comment. This made diagnostics and troubleshooting difficult.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Java 9's Doclet API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you have a good handle on the Doclet API as it existed prior to Java
    9, let's look at what changes have been made and delivered with the Java 9 platform.
    The new Doclet API is in the `jdk.javadoc.doclet` package.
  prefs: []
  type: TYPE_NORMAL
- en: 'At a high level, the changes to the Doclet API are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Updates the `com.sun.javadoc` Doclet API to take advantage of several Java SE
    and JDK APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updates the `com.sun.tools.doclets.standard.Standard` Doclet to use the new
    API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Supports the updated Taglet API that is used to create custom javadoc tags
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In addition to the changes listed earlier, the new API uses the two APIs listed
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: Compiler tree API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Language model API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's explore each of these in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Compiler tree API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The compiler tree API is in the `com.sun.source.doctree` package. It provides
    several interfaces to document source-level comments. These APIs are represented
    as **Abstract Syntax Trees** (**ASTs**).
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two enums:'
  prefs: []
  type: TYPE_NORMAL
- en: '`AttributeTree.ValueKind` with the following constants:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DOUBLE`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EMPTY`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SINGLE`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UNQUOTED`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DocTree.Kind` with the following constants:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ATTRIBUTE`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AUTHOR`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CODE`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`COMMENT`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DEPRECATED`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DOC_COMMENT`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DOC_ROOT`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`END_ELEMENT`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ENTITY`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ERRONEOUS`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EXCEPTION`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IDENTIFIER`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`INHERIT_DOC`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LINK`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LINK_PLAIN`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LITERAL`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OTHER`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PARAM`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`REFERENCE`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RETURN`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SEE`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SERIAL`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SERIAL_DATA`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SERIAL_FIELD`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SINCE`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`START_ELEMENT`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TEXT`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`THROWS`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UNKNOWN_BLOCK_TAG`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UNKNOWN_INLINE_TAG`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VALUE`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VERSION`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `com.sun.source.doctree` package contains several interfaces. They are
    detailed in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Interface name** | **Extends** | **A tree node for:** | **Non-inherited
    methods** |'
  prefs: []
  type: TYPE_TB
- en: '| `AttributeTree` | `DocTree` | HTML element | `getName()`, `getValue()`, `getValueKind()`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `AuthorTree` | `BlockTagTree`, `DocTree` | `@author` block tag | `getName()`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `BlockTagTree` | `DocTree` | Base class for different types of block tags
    | `getTagName()` |'
  prefs: []
  type: TYPE_TB
- en: '| `CommentTree` | `DocTree` | An embedded HTML comment with the following HTML
    tags--`<!--text-->` | `getBody()` |'
  prefs: []
  type: TYPE_TB
- en: '| `DeprecatedTree` | `BlockTagTree` | `@deprecated` block tag | `getBody()`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `DocCommentTree` | `DocTree` | Body block tags | `getBlockTags()`, `getBody()`,
    `getFirstSentence()` |'
  prefs: []
  type: TYPE_TB
- en: '| `DocRootTree` | `InlineTagTree` | `@docroot` inline tag | N/A |'
  prefs: []
  type: TYPE_TB
- en: '| `DocTree` | N/A | Common interface for all | `accept(DocTreeVisitor<R,D>visitor,Ddata)`,
    `getKind()` |'
  prefs: []
  type: TYPE_TB
- en: '| `DocTreeVisitor<R,P>` | N/A | `R` = return type of visitor''s methods; `P`
    = type of the additional parameter | `visitAttribute(AttributeTree node, P p)`,
    `visitAuthor(AuthorTree node, P p)`, `visitComment(CommentTree node, P p)`, `visitDeprecated(DeprecatedTree
    node, P p)`, `visitDocComment(DocCommentTree node, P p)`, `visitDocRoot(DocRootTree
    node, P p)`, `visitEndElement(EndElementTree node, P p)`, `visitEntity(EntityTree
    node, P p)`, `visitErroneous(ErroneousTree node, P p)`, `visitIdentifier(IdentifierTree
    node, P p)`, `visitInheritDoc(InheritDocTree node, P p)`, `visitLink(LinkTree
    node, P p)`, `visitLiteral(LiteralTree node, P p)`, `visitOther(DocTree node,
    P p)`, `visitParam(ParamTree node, P p)`, `visitReference(ReferenceTree node,
    P p)`, `visitReturn(ReturnTree node, P p)`, `visitSee(SeeTree node, P p)`, `visitSerial(SerialTree
    node, P p)`, `visitSerialData(SerialDataTree node, P p)`, `visitSerialField(SerialFieldTree
    node, P p)`, `visitSince(SinceTree node, P p)`, `visitStartElement(StartElementTree
    node, P p)`, `visitText(TextTree node, P p)`, `visitThrows(ThrowsTree node, P
    p)`, `visitUnknownBlockTag(UnknownBlockTagTree node, P p)`, `visitUnknownInlineTag(UnknownInlineTagTree
    node, P p)`, `visitValue(ValueTree node, P p)`, `visitVersion(VersionTree node,
    P p)` |'
  prefs: []
  type: TYPE_TB
- en: '| `EndElementTree` | `DocTree` | End of an HTML element `</name>` | `getName()`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `EntityTree` | `DocTree` | An HTML entity | `getName()` |'
  prefs: []
  type: TYPE_TB
- en: '| `ErroneousTree` | `TextTree` | This is for malformed text | `getDiagnostic()`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `IdentifierTree` | `DocTree` | An identifier in a comment | `getName()` |'
  prefs: []
  type: TYPE_TB
- en: '| `InheritDocTree` | `InlineTagTree` | `@inheritDoc`inline tag | N/A |'
  prefs: []
  type: TYPE_TB
- en: '| `InlineTagTree` | `DocTree` | Common interface for inline tags | `getTagName()`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `LinkTree` | `InlineTagTree` | `@link` or `@linkplan` inline tags | `getLabel()`,
    `getReference()` |'
  prefs: []
  type: TYPE_TB
- en: '| `LiteralTree` | `InlineTagTree` | `@literal` or `@code` inline tags | `getBody()`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `ParamTree` | `BlockTagTree` | `@param` block tags | `getDescription()`,
    `getName()`, `isTypeParameter()` |'
  prefs: []
  type: TYPE_TB
- en: '| `ReferenceTree` | `DocTree` | Used to reference a Java lang element | `getSignature()`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `ReturnTree` | `BlockTagTree` | `@return` block tags | `getDescription()`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `SeeTree` | `BlockTagTree` | `@see` block tags | `getReference()` |'
  prefs: []
  type: TYPE_TB
- en: '| `SerialDataTree` | `BlockTagTree` | `@serialData` block tags | `getDescription()`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `SerialFieldTree` | `BlockTagTree` | `@serialData` block tags and `@serialField`field
    names and descriptions | `getDescription()`, `getName()`, `getType()` |'
  prefs: []
  type: TYPE_TB
- en: '| `SerialTree` | `BlockTagTree` | `@serial` block tags | `getDescription()`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `SinceTree` | `BlockTagTree` | `@since` block tags | `getBody()` |'
  prefs: []
  type: TYPE_TB
- en: '| `StartElementTree` | `DocTree` | Start of an HTML element `< name [attributes]
    [/] >` | `getAttributes()`, `getName()`, `isSelfClosing()` |'
  prefs: []
  type: TYPE_TB
- en: '| `TextTree` | `DocTree` | Plain text | `getBody()` |'
  prefs: []
  type: TYPE_TB
- en: '| `ThrowsTree` | `BlockTagTree` | `@exception` or `@throws` block tags | `getDescription()`,
    `getExceptionname()` |'
  prefs: []
  type: TYPE_TB
- en: '| `UnknownBlockTagTree` | `BlockTagTree` | Unrecognizedinline tags | `getContent()`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `UnknownInlineTagTree` | `InlineTagTree` | Unrecognizedinline tags | `getContent()`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `ValueTree` | `InlineTagTree` | `@value` inline tags | `getReference()` |'
  prefs: []
  type: TYPE_TB
- en: '| `VersionTree` | `BlockTagTree` | `@version` block tags | `getBody()` |'
  prefs: []
  type: TYPE_TB
- en: Language model API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The language model API is in the `java.lang.model` package. It includes packages
    and classes that are used for language processing and language modeling. It consists
    of the following components:'
  prefs: []
  type: TYPE_NORMAL
- en: '`AnnotatedConstruct` interface'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SourceVersion` enum'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UnknownEntityException` exception'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each of these language model API components is further explored in the next
    three sections.
  prefs: []
  type: TYPE_NORMAL
- en: The AnnotatedConstruct interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `AnnotatedConstruction` interface provides an annotatable construct to
    the language model API that has been part of the Java platform since version 1.8\.
    It is applicable to constructs that are either an element (Interface `Element`)
    or a type (Interface `TypeMirror`). The annotations for each of these constructs
    differ, as shown in this table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Construct type** | **Interface** | **Annotation** |'
  prefs: []
  type: TYPE_TB
- en: '| `element` | `Element` | Declaration |'
  prefs: []
  type: TYPE_TB
- en: '| `type` | `TypeMirror` | Based on use of a type name |'
  prefs: []
  type: TYPE_TB
- en: 'The `AnnotatedConstruction` interface has three methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`getAnnotation(Class<A> annotationType)`: This method returns the type of the
    construct''s annotation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getAnnotationMirrors()`: This method returns a list of annotations that are
    on the construct'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getAnnotationsByType(Class<A> annotationType)`: This method returns the construct''s
    associated annotations'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The SourceVersion enum
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `SourceVersion` enum consists of the following constants:'
  prefs: []
  type: TYPE_NORMAL
- en: '`RELEASE_0`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RELEASE_1`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RELEASE_2`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RELEASE_3`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RELEASE_4`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RELEASE_5`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RELEASE_6`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RELEASE_7`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RELEASE_8`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is anticipated that the `SourceVersion` enum will be updated to include `RELEASE_9`
    once the Java 9 platform has been officially released.
  prefs: []
  type: TYPE_NORMAL
- en: 'This enum also contains several methods, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Method name**: `isIdentifier`'
  prefs: []
  type: TYPE_NORMAL
- en: '`public static boolean isIdentifier(CharSequence name)`'
  prefs: []
  type: TYPE_NORMAL
- en: This method returns `true` if the parameter string is a Java identifier or keyword.
  prefs: []
  type: TYPE_NORMAL
- en: '**Method name**: `isKeyword`'
  prefs: []
  type: TYPE_NORMAL
- en: '`public static boolean isKeyword(CharSequence s)`'
  prefs: []
  type: TYPE_NORMAL
- en: This method returns `true` if the given `CharSequence` is a literal or keyword.
  prefs: []
  type: TYPE_NORMAL
- en: '**Method name**: `isName`'
  prefs: []
  type: TYPE_NORMAL
- en: '`public static boolean isName(CharSequence name)`'
  prefs: []
  type: TYPE_NORMAL
- en: This method returns `true` if the `CharSequence` is a valid name.
  prefs: []
  type: TYPE_NORMAL
- en: '**Method name**: `latest`'
  prefs: []
  type: TYPE_NORMAL
- en: '`public static SourceVersion latest()`'
  prefs: []
  type: TYPE_NORMAL
- en: This method returns the latest source version for modeling purposes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Method name**: `latestSupported`'
  prefs: []
  type: TYPE_NORMAL
- en: '`public static SourceVersion latestSupported()`'
  prefs: []
  type: TYPE_NORMAL
- en: This method returns the latest source version that can be fully supported for
    modeling.
  prefs: []
  type: TYPE_NORMAL
- en: '**Method name**: `valueOf`'
  prefs: []
  type: TYPE_NORMAL
- en: '`public static SourceVersion valueOf(String name)`'
  prefs: []
  type: TYPE_NORMAL
- en: This method returns the enum constant based on the parameter string provided.
  prefs: []
  type: TYPE_NORMAL
- en: 'You should be aware that the `value(String name)` method throws two exceptions:
    `IllegalArgumentException` and `NullPointerException`.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Method name**: `values`'
  prefs: []
  type: TYPE_NORMAL
- en: '`public static SourceVersion[] values()`'
  prefs: []
  type: TYPE_NORMAL
- en: This method returns an array of the enum constants.
  prefs: []
  type: TYPE_NORMAL
- en: The UnknownEntityException exception
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `UnknownEntityException` class extends `RuntimeException` and is a superclass
    of unknown exceptions. The class constructor is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The constructor creates a new instance of `UnknownEntityException` with the
    message provided as a string argument. The method does not take additional arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'This class does not have its own methods, but inherits methods from both `java.lang.Throwable`
    and `class.java.lang.Object` classes as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `java.lang.Throwable` class methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`addSuppressed()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fillInStackTrace()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getCause()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getLocalizedMessage()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getMessage()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getStackTrace()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getSuppressed()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`initCause()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`printStackTrace()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setStackTrace()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`toString()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `java.lang.Object` class methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`clone()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`equals()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`finalize()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getClass()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`hashCode()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`notify()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`notifyAll()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`wait()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HTML5 Javadoc [JEP-224]
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Javadoc tool has been updated for the Java 9 platform. It can now generate
    HTML 5 markup output in addition to HTML 4\. The new Javadoc tool provides support
    for both HTML 4 and HTML 5.
  prefs: []
  type: TYPE_NORMAL
- en: HTML 4 will continue, even with the advent of the Java 9 platform, to be the
    default Javadoc output format. HTML 5 will be an option and will not become the
    default output markup format until Java 10.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following short Java application simply generates a `319`-wide by `319`-high
    frame. It is shown here without any Javadoc tags, which we will discuss later
    in this section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Once your package or class is completed, you can generate a Javadoc using the
    Javadoc tool. You can run the Javadoc tool, located in your JDK /bin directory,
    from the command line or from within your **Integrated Development Environment**
    (**IDE**). Each IDE handles Javadoc generation differently. For example, in Eclipse,
    you would select Project from the pull-down menu and then Generate Javadoc. In
    the IntelliJ IDEA IDE, you select the Tools pull-down menu and then Generate Javadoc.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the IntelliJ IDEA interface for the Generate
    Javadoc functionality. As you can see, the `-html5` command-line argument has
    been included:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0a6b1732-b267-427a-b490-8c23c71e3037.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When the OK button is clicked, you will see a series of status messages, as
    shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the Javadoc tool exits, you are ready to view the Javadoc. Here is a screenshot
    of what was generated based on the previously provided code. As you can see, it
    is formatted in the same manner in which the formal Java documentation from Oracle
    is documented:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9f97610a-7166-4ee8-98ff-55ec4cd03073.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When we generated the Javadoc, multiple documents were created, as illustrated
    by the directory tree provided in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3358f198-85b3-4189-9f35-3f7da7619a62.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You can also add optional tags that are recognized by the Javadoc tool. Those
    tags are provided here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@author`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@code`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@deprecated`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@docRoot`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@exception`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@inheritDoc`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@link`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@linkplain`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@param`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@return`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@see`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@serial`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@serialData`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@serialField`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@since`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@throws`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@value`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@version`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For more information on how to write document comments for the Javadoc tool,
    you can visit Oracle's official instructions at [http://www.oracle.com/technetwork/articles/java/index-137868.html](http://www.oracle.com/technetwork/articles/java/index-137868.html).
  prefs: []
  type: TYPE_NORMAL
- en: Javadoc search [JEP-225]
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Prior to Java 9, the standard Doclet generated API documentation pages that
    made navigating them difficult. Unless you are very familiar with the layout of
    these documentation pages, you will likely use browser-based find functionality
    to search text. This is considered clunky and suboptimal.
  prefs: []
  type: TYPE_NORMAL
- en: The Java 9 platform includes a search box as part of the API documentation.
    This search box is granted by the standard Doclet and can be used to search for
    text within the documentation. This represents a great convenience for developers
    and is likely to change our usage of Doclet-generated documentation.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the new Javadoc search functionality, we have the ability to search for
    the following indexed components:'
  prefs: []
  type: TYPE_NORMAL
- en: Module names
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Package names
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Members
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Terms/phrases indexed using the new `@index` inline tag
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing camel case search
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The new Javadoc search functionality includes a great shortcut using camel case
    search. As an example, we can search for `openED` to find the `openExternalDatabase()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: Remove launch-time JRE version selection [JEP-231]
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Prior to Java 9, we could use the **mJRE** (**Multiple JRE**) feature to specify
    a specific JRE version, or range of versions, for launching our applications.
    We would accomplish this via the command-line option `-version` or with an entry
    in the JAR file''s manifest. The following flowchart illustrates what happens
    based on our selection:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/db52f66a-a51b-451b-ab60-77c0541baff0.png)'
  prefs: []
  type: TYPE_IMG
- en: This functionality was introduced with JDK 5 and was not fully documented in
    that release or any subsequent release prior to JDK 9.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following specific changes were introduced with the Java 9 platform:'
  prefs: []
  type: TYPE_NORMAL
- en: The mJRE feature has been removed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The launcher will now produce an error whenever the `-version` command-line
    option is used. This is a terminal errors in that processing will not continue.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A warning will be produced if there is a `-version` entry in a JARs manifest.
    The warning will not stop execution.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interestingly, the presence of a `-version` entry in a manifest file will only
    generate a warning. This is by design, to take into account the likelihood of
    the entry being in older JAR file. It is estimated that this warning will be changed
    into a terminal error when the Java 10 platform is released.
  prefs: []
  type: TYPE_NORMAL
- en: Parser API for Nashorn [JEP-236]
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The focus of JEP 236 was to create an API for Nashorn's EMCAScript abstract
    syntax tree. In this section, we will individually look at Nashorn, EMCAScript
    and then the Parser API.
  prefs: []
  type: TYPE_NORMAL
- en: Nashorn
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Oracle Nashorn is a JavaScript engine for the JVM developed in Java by Oracle.
    It was released with Java 8\. It was created to provide developers with a highly
    efficiently and lightweight JavaScript runtime engine. Using this engine, developers
    were able to embed JavaScript code in their Java applications. Prior to Java 8,
    developers had access to the JavaScript engine created by Netscape. That engine,
    introduced in 1997, was maintained by Mozilla.
  prefs: []
  type: TYPE_NORMAL
- en: Nashorn can be used both as a command-line tool and as an embedded interpreter
    in Java applications. Let's look at examples of both.
  prefs: []
  type: TYPE_NORMAL
- en: Nashorn is the German word for rhinoceros. The name spawned from the Rhino-named
    JavaScript engine from the Mozilla Foundation. Rhino is said to have originated
    from the picture of the animal on a JavaScript book cover. File this one under
    **interesting facts**.
  prefs: []
  type: TYPE_NORMAL
- en: Using Nashorn as a command-line tool
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Nashorn executable file, `jjs.exe`, resides in the `\bin` folder. To access
    it, you can navigate to that folder or, if your system path is set up appropriately,
    you can launch into the shell by entering the `jjs` command in a Terminal / Command
    Prompt window on your system:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3a503feb-a949-46a1-a7de-2e1a7ec42a89.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here, you can see an open terminal window that first checks the version of
    Java and then uses the `jjs -version` command to launch the Nashorn shell. In
    this example, both Java and Nashorn are version 1.8.0.121\. Alternatively, we
    can simply launch Nashorn with the `jjs` command, and the shell will open without
    the version identification:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/09232883-d452-4d5e-be30-dba2c5b9ce30.png)'
  prefs: []
  type: TYPE_IMG
- en: Next, let's create a short JavaScript and run it using Nashorn. Consider the
    following simple JavaScript code that has three simple lines of output.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'To have Java run this JavaScript application, we will use the `jjs address.js`
    command. Here is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/af11affd-fc08-47cf-a425-56dadf4aab0f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'There is a lot you can do with Nashorn. From the Command Prompt/Terminal window,
    we can execute `jjs` with the `-help` option to see a full list of command-line
    commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b4ff29b9-e56f-48ad-9a8e-954b4d673ba1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, using the `-scripting` option gives us the ability to create
    scripts using Nashorn as a text editor. There are several built-in functions that
    are useful when using Nashorn:'
  prefs: []
  type: TYPE_NORMAL
- en: '`echo()`: This is similar to a `System.out.print()` Java method'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`exit()`: This exits Nashorn'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`load()`: This loads a script from a given path or URL'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`print()`: This is similar to a `System.out.print()` Java method'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`readFull()`: This reads a file''s contents'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`readLine()`: This reads a single line from `stdin`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`quit()`: This exits Nashorn'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Nashorn as an embedded interpreter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A more common use of Nashorn, compared to using it as a command-line tool,
    is using it as an embedded interpreter. The `javax.script` API is public and can
    be accessed via the `nashorn` identifier. The following code demonstrates how
    we can gain access to Nashorn, define a JavaScript function, and obtain the results--all
    from within a Java application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the output provided in the console window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/75b7bde5-385d-42a5-9a3a-2fbe94c1e09d.png)'
  prefs: []
  type: TYPE_IMG
- en: This is a simplistic example to give you an idea of what is possible with embedded
    use of Nashorn. There are ample examples in Oracle's official documentation.
  prefs: []
  type: TYPE_NORMAL
- en: EMCAScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**EMCA** (**European Computer Manufacturers Association**) was formed in 1961
    as a standards organization for both information systems and communications systems.
    Today, the EMCA continues to develop standards and issue technical reports to
    help standardize how consumer electronics, information systems, and communications
    technology are used. They are over 400 ECMA standards, most of which have been
    adopted.'
  prefs: []
  type: TYPE_NORMAL
- en: You will notice that EMCA is not spelled with all capital letters as it is no
    longer considered an acronym. In 1994, the European Computer Manufacturers Association
    formally changed its name to EMCA.
  prefs: []
  type: TYPE_NORMAL
- en: 'EMCAScript, also referred to as ES, was created in 1997 as a scripted-language
    specification. JavaScript implements this specification. The specification includes
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Complementary technologies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Libraries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scripting language syntax
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Semantics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parser API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the changes in the Java platform with version 9 is to provide specific
    support for Nashorn''s EMCAScript abstract syntax tree. The goals of the new API
    are to provide the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Interfaces to represent Nashorn syntax tree nodes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ability to create parser instances that can be configured with command-line
    options
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A visitor pattern API for interfacing with AST nodes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test programs to use the API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The new API, `jdk.nashorn.api.tree`, was created to permit future changes to
    the Nashorn classes. Prior to the new Parser API, IDEs used Nashorn's internal
    AST representations for code analysis. According to Oracle, use of the `idk.nashorn.internal.ir`
    package prevented the modernization of Nashorn's internal classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a look at the the class hierarchy of the new `jdk.nashorn.api.tree`
    package:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f2633438-e406-4357-bfc9-b0a78e686fef.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following graphic illustrates the complexity of the new API, featuring
    a full interface hierarchy:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/43b9ee78-0a9e-4251-bdaf-9fdb9f107bb0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The last component of the `jdk.nashorn.api.tree` package is the enum hierarchy,
    shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5fd964b6-5153-4c60-a597-be9989942268.png)'
  prefs: []
  type: TYPE_IMG
- en: Multi-release JAR files [JEP-238]
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The JAR file format has been extended in the Java 9 platform and now permits
    multiple versions of class files to exist in a single JAR file. The class versions
    can be specific to a Java release version. This enhancement allows developers
    to use a single JAR file to house multiple releases of their software.
  prefs: []
  type: TYPE_NORMAL
- en: 'The JAR file enhancement includes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Support for the `JarFile` API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Support for standard class loaders
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The changes to the JAR file format resulted in necessary changes to core Java
    tools so that they are able to interpret the new multiple-release JAR files. These
    core tools include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: javac
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: javap
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: jdeps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, the new JAR file format supports modularity as the key characteristic
    of the Java 9 platform. The changes to the JAR file format have not resulted in
    reduced performance of related tools or processes.
  prefs: []
  type: TYPE_NORMAL
- en: Identifying multi-release JAR files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Multi-release JAR files will have a new attribute, `Multi-Release: true`. This
    attribute will be located in the JAR `MANIFEST.MF` main section.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The directory structure will differ between standard JAR files and multi-release
    JAR files. Here is a look at a typical JAR file structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/582bb88d-54ac-4dae-abb2-f5f3c913027d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This illustration shows the new multi-release JAR file structure with Java
    version-specific class files for both Java 8 and Java 9:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f2fa5f0f-5f49-407f-b993-9c2a3cbf0ef9.png)'
  prefs: []
  type: TYPE_IMG
- en: Related JDK changes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Several changes had to be made to the JDK to support the new multi-release
    JAR file format. These changes include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The `URLClassLoader` is JAR-based and was modified so that it can read class
    files from the specified version.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The new module-based class loader, new to Java 9, was written so that it can
    read class files from the specified version.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `java.util.jar.JarFile` class was modified so that it selects the appropriate
    class version from the multi-release JAR files.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The JAR URL scheme's protocol handler was modified so that it selects the appropriate
    class version from the multi-release JAR files.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Java Compiler, `javac`, was made to read identified versions of the class
    files. These version identifications are made using the `-target` and `-release`
    command-line options with the `JavacFileManager` API and the `ZipFileSystem` API.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following tools were modified to take advantage of the changes to the `JavacFileManager`
    API and the `ZipFileSystem` API:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`javah`: This generates C header and source files'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`schemagen`: This is the schema generator for namespaces in Java classes'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`wsgen`: This is the parser for web service deployment'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The javap tool was updated to support the new versioning schema.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The jdeps tool was modified to support the new versioning schema.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The JAR packing tool set was updated accordingly. This tool set consists of
    `pack200` and `unpack200`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Of course, the JAR tool was enhanced so that it can create the multi-release
    JAR files.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All related documentation has been updated to support all the changes involved
    in establishing and supporting the new multi-release JAR file format.
  prefs: []
  type: TYPE_NORMAL
- en: Java-level JVM compiler interface [JEP-243]
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The JEP-243 was to create a Java-based **JVM Compiler Interface** (**JVMCI**).
    The JVMCI enables a Java compiler (which must have been written in Java) to be
    used as a dynamic compiler by the JVM.
  prefs: []
  type: TYPE_NORMAL
- en: 'The reasoning behind the desire for the JVMCI is that it would be a highly
    optimized compiler that does not require low-level language features. Some JVM
    subsystems require low-level functionality, such as with garbage collection and
    bytemode interpretation. So, the JVMCI was written in Java instead of C or C++.
    This provides the collateral benefit of some of Java''s greatest features, such
    as the following ones:'
  prefs: []
  type: TYPE_NORMAL
- en: Exception handling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: IDEs that are both free and robust
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memory management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Runtime extensibility
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Synchronization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit testing support
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As JVMCI was written in Java, it will arguably be easier to maintain.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three primary components of the JVMCI API:'
  prefs: []
  type: TYPE_NORMAL
- en: Virtual machine data structure access
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing compiled code with its metadata
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the JVM's compilation system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The JVMCI actually existed, to some extent, in Java 8\. The JVMCI API was only
    accessible via a class loader that worked for code on the boot class path. In
    Java 9, this changes. It will still be experimental in Java 9, but more accessible.
    In order to enable the JVMCI, the following series of command-line options must
    be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Oracle is keeping the JVMCI experimental in Java 9 to permit further testing
    and to afford the greatest level of protection for developers.
  prefs: []
  type: TYPE_NORMAL
- en: BeanInfo annotations [JEP-256]
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The JEP-256 focused on replacing `@beanifo` javadoc tags with more appropriate
    annotations. Furthermore, these new annotations are now processed at runtime so
    that `BeanInfo` classes can be generated dynamically. The modularity of Java 9
    resulted in this change. The creation of custom `BeanInfo` classes has been simplified
    and the client library has been modularized.
  prefs: []
  type: TYPE_NORMAL
- en: In order to fully grasp this change, we will review `JavaBean`, `BeanProperty`,
    and `SwingContainer` before going any further into this JEP.
  prefs: []
  type: TYPE_NORMAL
- en: JavaBean
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A `JavaBean` is a Java class. Like other Java classes, `JavaBeans` are reusable
    code. They are unique in their design because they encapsulate several objects
    into one. There are three conventions a `JavaBean` class must follow:'
  prefs: []
  type: TYPE_NORMAL
- en: The constructor should not take any arguments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It must be serializable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It must contain mutator and accessor methods for its properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is an example `JavaBean` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Accessing `JavaBean` classes is as simple as using the mutator and accessor
    methods. This is likely not new to you, but there is a good chance you did not
    know that those carefully coded classes you created were called `JavaBean` classes.
  prefs: []
  type: TYPE_NORMAL
- en: BeanProperty
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`BeanProperty` is an annotation type. We use this annotation to specify a property
    so that we can automatically generate `BeanInfo` classes. This is a new annotation
    for Java 9.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `BeanProperty` annotation has the following optional elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '`boolean bound`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`String description`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`String[] enumerationValues`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`boolean expert`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`boolean hidden`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`boolean preferred`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`boolean required`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`boolean visualUpdate`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SwingContainer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`SwingContainer` is an annotation type. We use this annotation to specify a
    swing-related property so that we can automatically generate `BeanInfo` classes.
    This is a new annotation for Java 9.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `SwingContainer` annotation has the following optional elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '`String delegate`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`boolean value`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we have reviewed `JavaBean`, `BeanProperty`, and `SwingContainer`,
    let's take a look at the `BeanInfo` classes.
  prefs: []
  type: TYPE_NORMAL
- en: BeanInfo classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For the most part, `BeanInfo` classes are automatically generated at runtime.
    The exception is with Swing classes. Those classes generate `BeanInfo` classes
    based on the `@beaninfo` javadoc tags. This is done at compile time, not runtime.
    In Java 9, the `@beaninfo` tags have been replaced with `@interface JavaBean`,
    `@interface BeanProperty`, and `@interface SwingContainer` annotations.
  prefs: []
  type: TYPE_NORMAL
- en: 'These new annotations are used to set the corresponding attributes based on
    the optional elements noted in the previous sections. As an example, the following
    code snippet sets the attributes for a `SwingContainer`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This provides us with three benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: It will be much easier to specify attributes in Bean classes instead of having
    to create individual `BeanInfo` classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will be able to remove auto-generated classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The client library is much more easily modularized with this approach
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TIFF image input/output [JEP-262]
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'JEP-262 is pretty straight forward. For Java 9, the image input/output plugins
    have been extended to include support for the TIFF image format. The `ImageIO`
    class extends the `Object` class and is part of Java SE. The class contains several
    methods for encoding and decoding images. Here is a list of static methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Method** | **Return value** |'
  prefs: []
  type: TYPE_TB
- en: '| `createImageInputStream(Object input)` | `ImageInputStream` |'
  prefs: []
  type: TYPE_TB
- en: '| `createImageOutputStream(Object output)` | `ImageOutputStream` |'
  prefs: []
  type: TYPE_TB
- en: '| `getCacheDirectory()` | Current value of the `CacheDirectory` |'
  prefs: []
  type: TYPE_TB
- en: '| `getImageReader(ImageWriter writer)` | `ImageReader` |'
  prefs: []
  type: TYPE_TB
- en: '| `getImageReaders(Object input)` | Iterator of current `ImageReaders` |'
  prefs: []
  type: TYPE_TB
- en: '| `getImageReadersByFormatName(String formatName)` | Iterator of current `ImageReaders`
    with the specified format name |'
  prefs: []
  type: TYPE_TB
- en: '| `getImageReadersByMIMEType(String MIMEType)` | Iterator of current `ImageReaders`
    of the specified MIME type |'
  prefs: []
  type: TYPE_TB
- en: '| `getImageReadersBySuffix(String fileSuffix)` | Iterator of current `ImageReaders`
    with the specified suffix. |'
  prefs: []
  type: TYPE_TB
- en: '| `getImageTranscoders(ImageReader reader)` | Iterator of current `ImageTranscoders`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `getImageWriter(ImageReader reader)` | `ImageWriter` |'
  prefs: []
  type: TYPE_TB
- en: '| `getImageWriters(ImageTypeSpecifier type, String formatName)` | Iterator
    of current `ImageWriters` that can encode to the specified type |'
  prefs: []
  type: TYPE_TB
- en: '| `getImageWritersByFormatName(String formatName)` | Iterator of current `ImageWriters`
    with the specified format name |'
  prefs: []
  type: TYPE_TB
- en: '| `getImageWritersByMIMEType(String MIMEType)` | Iterator of current `ImageWriters`
    of the specified MIME type |'
  prefs: []
  type: TYPE_TB
- en: '| `getImageWritersBySuffix(String fileSuffix)` | Iterator of current `ImageWriters`
    with the specified suffix. |'
  prefs: []
  type: TYPE_TB
- en: '| `getReaderFileSuffixes()` | String array with file suffixes understood by
    current readers |'
  prefs: []
  type: TYPE_TB
- en: '| `getReaderFormatNames()` | String array with format names understood by current
    readers |'
  prefs: []
  type: TYPE_TB
- en: '| `getReaderMIMETypes()` | String array with MIME types understood by current
    readers |'
  prefs: []
  type: TYPE_TB
- en: '| `getUseCache()` | `UseCache` value |'
  prefs: []
  type: TYPE_TB
- en: '| `getWriterFileSuffixes()` | String array of file suffixes understood by current
    writers |'
  prefs: []
  type: TYPE_TB
- en: '| `getWriterFormatNames()` | String array with format names understood by current
    writers |'
  prefs: []
  type: TYPE_TB
- en: '| `getWriterMIMETypes()` | String array with MIME types understood by current
    writers |'
  prefs: []
  type: TYPE_TB
- en: '| `read(File input)` | `BufferedImage` with an `ImageReader` |'
  prefs: []
  type: TYPE_TB
- en: '| `read(ImageInputStream stream)` | `BufferedImage` with `ImageInputStream`
    and an `ImageReader` |'
  prefs: []
  type: TYPE_TB
- en: '| `read(InputStream input)` | `BufferedImage` with `InputStream` and `ImageReader`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `read(URL input)` | `BufferedImage` with an `ImageReader` |'
  prefs: []
  type: TYPE_TB
- en: 'There are also a few static methods that do not return a value or return a
    Boolean:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Method** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `scanForPlugins()` | Performs the following actions:'
  prefs: []
  type: TYPE_NORMAL
- en: Scans the application classpath for plugins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loads plugin service provider classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Registers service provide instances in the IIORegistry
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `setCacheDirectory(File cacheDirectory)` | This is where the cache files
    will be stored. |'
  prefs: []
  type: TYPE_TB
- en: '| `setUseCache(boolean useCache)` | This method toggles if the cache will be
    disk-based or not. This applies to `ImageInputStream` and `ImageOutputStream`
    instances. |'
  prefs: []
  type: TYPE_TB
- en: '| `write(RenderedImage im, String formatName, File output)` | Writes an image
    to the specified file. |'
  prefs: []
  type: TYPE_TB
- en: '| `write(RenderedImage im, String formatName, ImageOutputStream output)` |
    Writes an image to an `ImageOutputStream`. |'
  prefs: []
  type: TYPE_TB
- en: '| `write(RenderedImage im, String formatName, OutputStream output)` | Writes
    an image to an `OutputStream`. |'
  prefs: []
  type: TYPE_TB
- en: 'As you can glean from the provided methods, the image input/output framework
    provides us with a convenient way of using image codecs. As of Java 7, the following
    image format plugins were implemented by `javax.imageio`:'
  prefs: []
  type: TYPE_NORMAL
- en: BMP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GIF
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JPEG
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PNG
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: WBMP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The TIFF is, as you can see, not on the list of image file formats. TIFFs are
    a common file format and, in 2001, macOS, with the release of MacOS X, used the
    format extensively.
  prefs: []
  type: TYPE_NORMAL
- en: The Java 9 platform includes `ImageReader` and `ImageWriter` plugins for the
    TIFFs. These plugins have been written in Java and have been bundled in the new
    `javax.imageio.plugins.tiff` package.
  prefs: []
  type: TYPE_NORMAL
- en: Platform logging API and service [JEP-264]
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Java 9 platform includes a new logging API enabling platform classes to
    log messages. It has a commensurate service for manipulating the logs. Before
    we go too far into what is new regarding the logging API and service, let's review
    `java.util.logging.api` which was introduced in Java 7.
  prefs: []
  type: TYPE_NORMAL
- en: The java.util.logging package
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `java.util.logging` package includes classes and interfaces that collectively
    comprise Java''s core logging features. This functionality was created with the
    following goals:'
  prefs: []
  type: TYPE_NORMAL
- en: Problem diagnosis by end users and system administrators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Problem diagnosis by field service engineers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Problem diagnosis by the development organization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see, the primary purpose was to enable maintenance of remote software.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `java.util.logging` package has two interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '`public interface Filter`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Purpose: This provides fine-grain control over logged data'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Method:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`isLoggable(LogRecord record)`'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public interface LoggingMXBean`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Purpose: This is the logging facility''s management interface'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Methods:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getLoggerLevel(String loggerName)`'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getLoggerNames()`'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getparentLoggerName(String loggerName)`'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setLoggerLevel(String loggerName, String levelName)`'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following table provides the `java.util.logging` package classes, along
    with a brief description regarding what each class provides in respect to logging
    functionality and management:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Class** | **Definition** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `ConsoleHandler` | `public class ConsoleHandler extends StreamHandler` |
    Publishes log records to `System.err` |'
  prefs: []
  type: TYPE_TB
- en: '| `ErrorManager` | `public class ErrorManager extends Object` | Used to process
    errors during logging |'
  prefs: []
  type: TYPE_TB
- en: '| `FileHandler` | `public class FileHandler extends StreamHandler` | File logging
    |'
  prefs: []
  type: TYPE_TB
- en: '| `Formatter` | `public abstract class Formatter extends Object` | For formatting
    `LogRecords` |'
  prefs: []
  type: TYPE_TB
- en: '| `Handler` | `public abstract class Handler extends Object` | Exports `Logger`
    messages |'
  prefs: []
  type: TYPE_TB
- en: '| `Level` | `public class Level extends Object implements Serializable` | Controls
    level of logging. The levels, in descending order, are--severe, warning, info,
    config, fine, finer, and finest |'
  prefs: []
  type: TYPE_TB
- en: '| `Logger` | `public class Logger extends Object` | Logs messages |'
  prefs: []
  type: TYPE_TB
- en: '| `LoggingPermission` | `public final class LoggingPermission extends BasicPermission`
    | `SecurityManager` checks this |'
  prefs: []
  type: TYPE_TB
- en: '| `LogManager` | `public class LogManager` | For maintaining shared state between
    loggers and logging services |'
  prefs: []
  type: TYPE_TB
- en: '| `LogRecord` | `public class LogRecord extends Object implements Serializable`
    | Passed between handlers |'
  prefs: []
  type: TYPE_TB
- en: '| `MemoryHandler` | `public class MemoryHandler extends Handler` | Buffers
    requests in memory |'
  prefs: []
  type: TYPE_TB
- en: '| `SimpleFormatter` | `public class SimpleFormatter extends Formatter` | Provides
    human-readable `LogRecord` metadata |'
  prefs: []
  type: TYPE_TB
- en: '| `SocketHandler` | `public class SocketHandler extends StreamHandler` | Network
    logging handler |'
  prefs: []
  type: TYPE_TB
- en: '| `StreamHandler` | `public class StreamHandler extends Handler` | Stream-based
    logging handler |'
  prefs: []
  type: TYPE_TB
- en: '| `XMLFormatter` | `public class XMLFormatter extends Formatter` | Formats
    logs into XML |'
  prefs: []
  type: TYPE_TB
- en: Next, let's review what changes were made in Java 9.
  prefs: []
  type: TYPE_NORMAL
- en: Logging in Java 9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Prior to Java 9, there were multiple logging schemas available, including `java.util.logging`,
    `SLF4J`, and `Log4J`. The latter two are third-party frameworks that have separate
    facade and implementation components. This pattern has been replicated in the
    new Java 9 platform.
  prefs: []
  type: TYPE_NORMAL
- en: Java 9 introduced changes to the `java.base` module so that it would handle
    logging functions and not rely on the `java.util.logging` API. It has separate
    facade and implementation components. This means that when using third-party frameworks,
    the JDK only needs to provide the implementation component and return platform
    loggers that work with the requesting logging framework.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see in the following illustration, we use the `java.util.ServiceLoader`
    API to load our `LoggerFinder` implementation. The JDK uses a default implementation
    if a concrete implementation is not found using the system class loader:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9bdf222e-0a06-4a54-b8d9-728601e10744.png)'
  prefs: []
  type: TYPE_IMG
- en: XML Catalogs [JEP-268]
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'JEP 268, titled XML Catalogs, focused on creating a standard XML Catalog API
    to support the OASIS XML Catalogs Standard v1.1\. The new API defines catalog
    and catalog-resolve abstractions so that JAXP processors can use them. In this
    section, we will look at the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The OASIS XML Catalog standard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JAXP processors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: XML Catalogs prior to Java 9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Java 9 platform changes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The OASIS XML Catalog standard
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**XML** (**eXtensible Markup Language**) Catalogs are XML documents consisting
    of catalog entries. Each entry pairs an identifier to another location. OASIS
    is a not-for-profit consortium with the mission of advancing open standards. They
    published the XML catalog standard, version 1.1., in 2005\. This standard has
    two basic use cases:'
  prefs: []
  type: TYPE_NORMAL
- en: Map an external identifier to a URI reference
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Map a URI reference to another URI reference
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is a sample XML catalog entry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The complete OASIS XML Catalog standard can be found at the official site:
    [https://www.oasis-open.org/committees/download.php/14809/xml-catalogs.html](https://www.oasis-open.org/committees/download.php/14809/xml-catalogs.html)'
  prefs: []
  type: TYPE_NORMAL
- en: JAXP processors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Java API for XML processing is referred to as JAXP. As its name suggests,
    this API is used for parsing XML documents. There are four related interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: 'DOM: Document Object Model parsing'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'SAX: Simple API for XML parsing'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'StAX: Streaming API for XML parsing'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'XSLT: Interface to transform XML documents'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: XML Catalogs prior to Java 9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Java platform has had an internal catalog resolver since JDK 6\. There was
    no public API, so external tools and libraries were used to access the functionality.
    Moving into Java 9, the goal was to make the internal catalog resolver a standard
    API for common use and ease of support.
  prefs: []
  type: TYPE_NORMAL
- en: Java 9 platform changes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The new XML Catalog API, delivered with Java 9, follows the OASIS XML Catalogs
    standard, v1.1\. Here are the feature and capability highlights:'
  prefs: []
  type: TYPE_NORMAL
- en: Implements `EntityResolver`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implements `URIResolver`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creation of XML Catalogs is possible via the `CatalogManager`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CatalogManager` will be used to create `CatalogResolvers`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OASIS open catalog file semantics will be followed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Map an external identifier to a URI reference
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Map a URI reference to another URI reference
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CatalogResolvers` will implement the JAXP `EntityResolver` interface'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CatalogResolvers` will implement the JAXP `URIResolver` interface'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The SAX `XMLFilter` will be supported by the resolver.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since the new XML Catalog API will be public, the pre-Java 9 internal catalog
    resolver will be removed, as it will no longer be necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Convenience factory methods for collections [JEP-269]
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Java programming language does not support collection literals. Adding this
    feature to the Java platform was proposed in 2013 and revisited in 2016, but it
    only gained exposure as a research proposal, not for future implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Oracle's definition of a collection literal is "*a syntactic expression form
    that evaluates to an aggregate type, such as an array, list, or map*" ([http://openjdk.java.net/jeps/186](http://openjdk.java.net/jeps/186)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, that is until Java 9 is released. Implementing collection literals
    in the Java programming language is reported to have the following benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: Performance improvement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Increased safety
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reduction of boilerplate code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Even without being part of the research group, our knowledge of the Java programming
    language clues us in to additional benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: Ability to write shorter code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ability to write space-efficient code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ability to make collection literals immutable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's look at two cases--using collections before Java 9, and then with the
    new support for collection literals in the new Java platform.
  prefs: []
  type: TYPE_NORMAL
- en: Using collections before Java 9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here is an example of how we would create our own collections prior to Java
    9\. This first class defines the structure for `PlanetCollection`. It has the
    following components:'
  prefs: []
  type: TYPE_NORMAL
- en: A single instance variable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A one argument constructor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mutator/setter method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessor/getter method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Method to print the object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is the code implementing the preceding listed constructor and methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s look at the driver class that populates the collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the output from this application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fb5b62da-e9be-429a-9a1e-aa29485632a3.png)'
  prefs: []
  type: TYPE_IMG
- en: This code is, unfortunately, very verbose. We populated our collection in static
    initializer blocks instead of using a field initializer. There are other methods
    of populating our list, but they are all more verbose than they should have to
    be. These other methods have additional problems, such as the need to create extra
    classes, the use of obscure code, and hidden references.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now take a look at the solution to this problem, provided by the new Java
    9 platform. We will look at what is new in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Using new collection literals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to rectify the currently required code verbosity in creating collections,
    we need library APIs for creating collection instances. Look at our pre-Java 9
    code snippet in the previous section and then consider this possible refactoring:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This code is highly human-readable and not verbose.
  prefs: []
  type: TYPE_NORMAL
- en: 'The new implementation will include static factory methods on the following
    interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '`List`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Map`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Set`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, we are now able to create unmodifiable instances of `List` collections,
    `Map` collections, and `Set` collections. They can be instantiated with the following
    syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '`List.of(a, b, c, d, e);`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Set.of(a, b, c, d, e);`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Map.of();`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Map` collections will have a set of fixed arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Platform-specific desktop features [JEP-272]
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The exciting JEP-272 was to create a new public API so that we can write applications
    with access to platform-specific desktop features. These features include interacting
    with task bars/docks and listening for application and system events.
  prefs: []
  type: TYPE_NORMAL
- en: The macOS X `com.apple.eawt` package was an internal API and, starting with
    Java 9, is no longer accessible. In support of Java 9's new embedded platform-specific
    desktop features, `apple.applescript` classes are being removed from the Java
    platform without replacement.
  prefs: []
  type: TYPE_NORMAL
- en: 'This effort had several objectives:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a public API to replace the functionality in `com.apple.{east,eio}`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Ensure OS X developers do not loose functionality. To this end, the Java 9
    platform has replacements for the following packages:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`com.apple.eawt`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`com.apple.eio`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Provide developers with a near-common set of features for platforms (that is,
    Windows and Linux) in addition to OS X. The common features include:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Login/logout handler with event listeners
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Screen lock handler with event listeners
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Task bar / dock actions to include:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Requesting user attention
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Indicating task progress
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Action shortcuts
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The new API will be added to the `java.awt.Desktop` class.
  prefs: []
  type: TYPE_NORMAL
- en: Enhanced method handles [JEP-274]
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The **Enhanced Method Handles** JEP-274 was to improve the following listed
    classes, to make common usage easier with improved optimizations:'
  prefs: []
  type: TYPE_NORMAL
- en: '`MethodHandle` class'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MethodHandles` class'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MethodHandles.Lookup` class'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The listed classes are all part of the `java.lang.invoke` package, which has
    been updated as part of the Java 9 platform. The improvements were made possible
    through the use of lookup refinement and `MethodHandle` combinations `for` loops
    and `try...finally` blocks.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we will look at the following regarding JEP-274:'
  prefs: []
  type: TYPE_NORMAL
- en: Reason for the enhancement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lookup functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Argument handling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additional combinations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reason for the enhancement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This enhancement stemmed from developer feedback and the desire to make the
    `MethodHandle`, `MethodHandles`, and `MethodHandles.Lookup` classes much easier
    to use. There was also the call to add additional use cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'The changes resulted in the following benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: Enabled precision in the usage of the `MethodHandle` API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instantiation reduction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Increased JVM compiler optimizations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lookup functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Changes regarding lookup functions, for the Java 9 platform, include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`MethodHandles` can now be bound to non-abstract methods in interfaces'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The lookup API allows class lookups from different contexts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `MethodHandles.Lookup.findSpecial(Class<?> refs, String name, MethodType
    type, Class<?> specialCaller)` class has been modified to permit locating super-callable
    methods on interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition, the following methods have been added to the `MethodHandles.Lookup`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Class<?> findClass(String targetName)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Class<?> accessClass(Class<?> targetClass)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Argument handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Three updates were made to improve `MethodHandle` argument handling for the
    Java 9 platform. These changes are highlighted as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Argument folding using `foldArguments(MethodHandle target, MethodHandle combinator)`
    did not previously have a position argument.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Argument collection using the `MethodHandle.asCollector(Class<?> arrayType,
    int arrayLength)` method did not previously support collecting the arguments into
    an array except for the trailing element. This has been changed, and there is
    now an additional `asCollector` method to support that functionality in Java 9.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Argument spreading using the `MethodHandle.asSpreader(Class<?> arrayType, int
    arrayLength)` method spreads the contents of the trailing array to a number of
    arguments, in a reverse method of argument collection. Argument spreading has
    been modified to support the expansion of an array anywhere in the method signature.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The new method definitions for the updated `asCollector` and `asSpreader` methods
    are provided in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Additional combinations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following addition combinations have been added to support the ease of
    use and optimizations for the `MethodHandle`, `MethodHandles`, and `MethodHandles.Lookup`
    classes of the `java.lang.invoke` package in the Java 9 platform:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Generic loop abstraction:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MethodHandle loop(MethodHandle[] . . . clauses)`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`While` loops:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MethodHandle whileLoop(MethodHandle init, MethodHandle pred, MethodHandle
    body)`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Do...while` loops:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`` `MethodHandle doWhileLoop(MethodHandle init, MethodHandle body, MethodHandle
    pred)` ``'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Counting loops:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MethodHandle countedLoop(MethodHandle iterations, MethodHandle init, MethodHandle
    body)`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Data structure iteration:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MethodHandle iteratedLoop(MethodHandle iterator, MethodHandle init, MethodHandle
    body)`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Try...finally` blocks:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MethodHandle tryFinally(MethodHandle target, MethodHandle cleanup)`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Argument handling:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Argument spreading:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MethodHandle asSpreader(int pos, Class<?> arrayType, int arrayLength)`'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Argument collection:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MethodHandle asCollector(int pos, Class<?> arrayType, int arrayLength)`'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Argument folding:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MethodHandle foldArguments(MethodHandle target, int pos, MethodHandle combiner)`'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Enhanced deprecation [JEP-277]
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are two facilities for expressing deprecation:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@Deprecated` annotation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@deprecated` javadoc tag'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These facilities were introduced in Java SE 5 and JDK 1.1, respectively. The
    `@Deprecated` annotation was intended to annotate program components that should
    not be used because they were deemed dangerous and/or there was a better option.
    That was the intended use. Actual use varied including and because warnings were
    only provided at compile time; there was little reason to ignore the annotated
    code.
  prefs: []
  type: TYPE_NORMAL
- en: The **Enhanced Deprecation** JEP-277 was taken on to provide developers with
    clearer information regarding the intended disposition of the APIs in the specification
    documentation. Work on this JEP also resulted in a tool for analyzing a program's
    use of deprecated APIs.
  prefs: []
  type: TYPE_NORMAL
- en: 'To support this fidelity in information, the following components have been
    added to the `java.lang.Deprecated` annotation type:'
  prefs: []
  type: TYPE_NORMAL
- en: '`forRemoval()`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returns Boolean `true` if the API element has been slated for future removal
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Returns Boolean `false` if the API element has not been slated for future removal
    but is deprecated
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Default is `false`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`since()`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returns a string containing the release or version number, at which point the
    specified API was marked as deprecated
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: What the @Deprecated annotation really means
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When an API, or methods within an API, has/have been marked with the `@Deprecated`
    annotation, one or more of the following conditions typically exists:'
  prefs: []
  type: TYPE_NORMAL
- en: There are errors in the API for which there is no plan to fix them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the API is likely to result in errors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The API has been replaced by another API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The API is experimental
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered 16 JEPs that were incorporated into the Java 9 platform.
    These JEPs cover a wide range of tools and updates to APIs to make developing
    with Java easier, with greater optimization possibilities for our resulting programs.
    Our review included a look at the new HTTP client, changes to Javadoc and the
    Doclet API, the new JavaScript parser, JAR and JRE changes, the new Java-level
    JVM compiler interface, the new support for TIFF images, platform logging, XML
    Catalog support, collections, and the new platform-specific desktop features.
    We also looked at enhancements to method handling and the deprecation annotation.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will cover concurrency enhancements introduced with
    the Java 9 platform. Our primary focus will be the support for reactive programming
    that is provided by the flow class API. We will also explore additional concurrency
    enhancements introduced in Java 9.
  prefs: []
  type: TYPE_NORMAL
