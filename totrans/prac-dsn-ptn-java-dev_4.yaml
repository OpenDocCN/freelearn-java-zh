- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Applying Structural Design Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Every piece of software has a purpose or, in other words, an expected behavior
    that it should fulfill. While the previous chapter described in detail creational
    design patterns, this chapter will focus on designing maintainable and flexible
    source code for objects created. Structural patterns attempt to bring clarity
    to relationships between created instances, not only to maintain an application
    but also to easily understand its purpose. Let us dive deeper and start examining
    the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Incompatible object collaboration with the adapter pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decoupling and developing objects independently with the bridge pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Treating objects the same way using the composite pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extending object functionality by using the decorator pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simplifying communication with the facade pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using conditions to select desired objects with the filter pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sharing objects across an application with the flyweight pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling requests with the front-controller pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identifying instances using the marker pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring the concept of modules with the module pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Providing a placeholder for an object employing the proxy pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discovering multiple inheritance in Java with the twin pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you’ll have a solid understanding of how to structure
    a code base around created instances.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can find the code files for this chapter on GitHub at [https://github.com/PacktPublishing/Practical-Design-Patterns-for-Java-Developers/tree/main/Chapter04](https://github.com/PacktPublishing/Practical-Design-Patterns-for-Java-Developers/tree/main/Chapter04).
  prefs: []
  type: TYPE_NORMAL
- en: Incompatible object collaboration with the adapter pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The main goal of the adapter pattern is to connect the source class interface
    to another interface that clients will expect. The adapter pattern allows classes
    to work together that otherwise couldn’t due to an incompatible abstraction or
    implementation. It is considered one of the most common patterns and is one of
    the **Gang of Four** (**GoF**) design patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Motivation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The adapter pattern is also known as **wrapper**. An adapter wraps the behavior
    of the adaptee (connected class) and allows access to the adaptee without modification
    using an already existing interface. Commonly, an adaptee uses an incompatible
    interface, and an adapter consolidates such behavior and transparently provides
    access to the required functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Finding it in the JDK
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `java.base` module provides multiple implementations of the adapter pattern.
    The `Collections` utility class from the `java.util` package provides a `list`
    method, which accepts an `Enumeration` interface and adapts the result into an
    `ArrayList` instance.
  prefs: []
  type: TYPE_NORMAL
- en: Sample code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The adapter pattern can be implemented in several ways. One of them is considered
    in the example of a vehicle that can have different types of engines (*Example
    4.1*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Example 4.1 – Although each type of vehicle shares similar logic, the behavior
    of the refuel method varies by engine type
  prefs: []
  type: TYPE_NORMAL
- en: 'These engines share some similar functionalities and features, but not all.
    They are very different from each other (*Figure 4**.1*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1 – UML class diagram highlighting engine type differences](img/B18884_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.1 – UML class diagram highlighting engine type differences
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, the `Vehicle` class and its instance play the role of adapter.
    In the case of the `drive` method, both motors behave similarly. The `tank` method
    execution is a different scenario because the vehicle adapter needs to know the
    exact engine type to correctly execute the `refuel` method (*Example 4.2*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Example 4.2 – The Vehicle instance operates with an engine based on its type,
    identified by the pattern-matching functionality
  prefs: []
  type: TYPE_NORMAL
- en: New language features such as `switch` statement enhancements can be very useful
    as there is no need to keep the exact adaptee instance reference for the adapter.
    The `sealed` classes enforce the desired purpose and increase maintainability
    by protecting their intent, such as by avoiding unwanted extensions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Both engine types considered may still implement similar abstraction in order
    to maintain the concept of the engine (*Example 4.3*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Example 4.3 – The Engine interface allows only certain classes to implement
    its methods
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Vehicle` adapter provides the required logic to handle the different engine
    implementations properly. The `ElectricEngine` implementation provides an additional
    `checkPlug` method (*Example 4.4*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Example 4.4 – ElectricEngine implements additional logic that is not shareable
    with the general Engine concept
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The adapter structural design pattern has a valid place in development as it
    represents a maintainable way to connect different functionalities and control
    them through a similar interface. The adapter is properly encapsulated and can
    be even more abstract. The new `sealed` classes support the pattern concept of
    maintainability and clarity. The consequence of using the adapter pattern may
    be that the adapter needs to commit to a specific adaptee or interface. The adapter
    may extend some of the adaptee functionalities as a subclass. The adapter pattern
    is worth considering when additional third-party libraries or APIs are to be implemented.
    It provides a transparent and decoupled way to interact with libraries, following
    the SOLID concept. Solutions can also be easily refactored.
  prefs: []
  type: TYPE_NORMAL
- en: This look at the adapter pattern has shown the approach of using incompatible
    APIs. Next, let us investigate how to use different replaceable implementations.
  prefs: []
  type: TYPE_NORMAL
- en: Decoupling and developing objects independently with the bridge pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The goal of this pattern is to separate the abstraction from its implementation
    so that both can change independently. The bridge pattern was described by the
    GoF.
  prefs: []
  type: TYPE_NORMAL
- en: Motivation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The bridge pattern is about prioritizing composition over inheritance. The implementation
    details are moved from the hierarchy to another object with a separate hierarchy.
    The bridge pattern uses encapsulation and aggregation, and may use inheritance
    to separate responsibilities into different classes.
  prefs: []
  type: TYPE_NORMAL
- en: Finding it in the JDK
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Uses of the bridge pattern can be found in the `java.util.logging` package and
    the implementation of the `Logger` class. The class is located in the `java.logging`
    module. It implements the `Filter` interface. This interface is used to gain additional
    control over logged content beyond the standard log level.
  prefs: []
  type: TYPE_NORMAL
- en: Sample code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let us see an example of two types of vehicles: a sport car and a pickup. The
    vehicles vary in engine type: petrol and diesel. The intention is to enforce a
    separate development for the `Vehicle` and `Engine` abstraction source code. The
    example case creates vehicles and executes `drive` and `stop` methods (*Example
    4.5*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Example 4.5 – The vehicles use different engines; they can be developed separately
    due to the bridge pattern’s isolation
  prefs: []
  type: TYPE_NORMAL
- en: 'Each vehicle extends the `Vehicle` abstraction class that runs the engine and
    encapsulates the basic functions. The `Engine` interface, used by the vehicle
    abstraction, plays the role of a bridge, as shown in the following diagram (*Figure
    4**.2*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18884_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.2 – The UML class diagram shows how the Engine interface bridges access
    to a specific implementation
  prefs: []
  type: TYPE_NORMAL
- en: 'The engines already behave differently, and due to the bridge they may continue
    evolving (*Example 4.6*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Example 4.6 – The engines differ in implementation
  prefs: []
  type: TYPE_NORMAL
- en: The vehicle abstraction does not have any engine implementation details, which
    may vary even in the class hierarchy. The vehicle only needs to rely on the provided
    interface.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The bridge pattern is a good idea to consider when the application source code
    requires reducing bindings to specific implementation classes. Due to the bridge
    pattern, the decision about a specific implementation can be deferred until runtime.
    The bridge pattern helps to encourage SOLID design principles through responsibility
    separation and encapsulation. The implementation can be freely tested and shared
    as required through the application source code. It is required to keep in mind
    not to add unwanted responsibilities to the bridge implementation and consider
    alternative approaches in terms of design patterns when such a situation takes
    a place.
  prefs: []
  type: TYPE_NORMAL
- en: The bridge pattern can open the door to better composition of implementation
    specifics, as we’ll explore in the next pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Treating objects the same way using the composite pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The composite pattern is a remarkable solution for handling objects uniformly
    while arranging them in a tree structure, which simplifies access to instances.
    The demand for it naturally came from industry, and the pattern was soon identified
    and described by the GoF.
  prefs: []
  type: TYPE_NORMAL
- en: Motivation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Grouping objects around the underlying business logic is a powerful approach.
    A composite design pattern outlines a way to achieve such a state. Since each
    member of the group is treated uniformly, it is possible to create hierarchical
    tree structures and part-whole hierarchies. It helps to establish the logical
    relationships of the application and the composition of the desired objects.
  prefs: []
  type: TYPE_NORMAL
- en: Finding it in the JDK
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the JDK, the composite pattern can be found in the `java.base` module, the
    `java.util` package, and the `Properties` class. The `Properties` class implements
    the `Map` interface through its `Hashtable` implementation, and also contains
    a `ConcurrentHashMap` instance to store the property values internally. Although
    the `Properties` class’s `put` operation remains synchronized due to the `Hashtable`
    implementation, the `get` operation does not, as it is simple to read into the
    concurrent map.
  prefs: []
  type: TYPE_NORMAL
- en: Sample code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To explore the power of the composition pattern, consider the `SportVehicle`
    class, which implements the `Vehicle` interface. It is standard knowledge that
    every vehicle is a collection of parts and every part is a grouping of smaller
    parts (*Figure 4**.3*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.3 – The UML class diagram shows how SportVehicle is composed of
    VehiclePart types](img/B18884_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.3 – The UML class diagram shows how SportVehicle is composed of VehiclePart
    types
  prefs: []
  type: TYPE_NORMAL
- en: 'When the vehicle manufacturing process starts, the composition pattern provides
    a complete collection of every part that is present in the final results (*Example
    4.7*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Example 4.7 – Reviewing the SportVehicle instance composition
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The composite pattern allows the representation of the composition of a class
    in granular detail. It takes into account the smaller parts of the composite by
    creating part-whole hierarchies. While this provides advantages because each part
    is treated uniformly, it can lead to ignoring differences between parts. On the
    other hand, the composite pattern holds all the involved parts together in a transparent
    form.
  prefs: []
  type: TYPE_NORMAL
- en: Let us now examine how an individual object can be extended with additional
    functionality without changing the API.
  prefs: []
  type: TYPE_NORMAL
- en: Extending object functionality by using the decorator pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The decorator pattern provides the ability to add new functionality to objects
    by placing those objects in a decorator, Sothat a decorated instance provides
    extended functionality. The implementation of the decorator pattern is relatively
    simple and dynamic in languages such as Python and Kotlin. On the other hand,
    Java may provide more stability and maintainability of the source code through
    visibility and new enhancements, which can be very valuable. The decorator pattern
    was identified and described by the GoF.
  prefs: []
  type: TYPE_NORMAL
- en: Motivation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With the decorator pattern, you can dynamically attach additional responsibilities
    to an object. A decorator provides a flexible alternative to subclasses to extend
    the functionality of a class. The decorator can be added statically or dynamically
    without altering the current behavior of an object.
  prefs: []
  type: TYPE_NORMAL
- en: Finding it in the JDK
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Uses of the decorator pattern can be found in the Java collections framework,
    the `java.base` module, and the `java.util` package. The `Collection` class contains
    different ways to use the decorator pattern. For example, the `unmodifiableCollection`
    method wraps the requested collection into an unmodifiable collection represented
    by an `UnmodifiableCollection` instance that acts as a decorator for the provided
    collection type, similar to other methods starting with `unmodifiable...` words.
    Another example is methods starting with the word `synchronized...` of the `Collections`
    utility class.
  prefs: []
  type: TYPE_NORMAL
- en: Sample code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When you think about the previous examples of vehicles, the decorator pattern
    can be considered a tuned vehicle. The standard `SportVehicle` class is like this.
    It implements the `Vehicle` interface to fulfill standard functions. The application
    designer later decides to improve the current state and creates a `TunedVehicleDecorator`
    class that wraps the standard vehicle, without having to change previous functions
    (*Figure 4**.4*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.4 – The UML class diagram highlights the relationship between SportVehicle
    and TunedVehicleDecorator types](img/B18884_04_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.4 – The UML class diagram highlights the relationship between SportVehicle
    and TunedVehicleDecorator types
  prefs: []
  type: TYPE_NORMAL
- en: 'All considered vehicles expose similar APIs to execute their implementations
    (*Example 4.8)*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Example 4.8 – The tuned car abstraction extends the features of the SportVehicle
    type by adding more horsepower (200)
  prefs: []
  type: TYPE_NORMAL
- en: 'The decorator pattern may be introduced in multiple ways. In the presented
    example, `TunedVehicleDecorator` is an abstract class that holds the reference
    to the vehicle. The `SportVehicle` instance extends newly implemented functionality
    (*Example 4.9)*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Example 4.9 – Decorator wraps the Vehicle instance and extends its functionality
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Class decoration can be very useful in many cases during application development.
    The decorator pattern can be used to migrate application logic where previous
    functionalities should remain hidden or unwanted subclassing should be avoided.
    The example showed how sealed classes can contribute to code maintainability and
    comprehensibility. Decoration helps not only to add new features but also to remove
    obsolete features. The decorator pattern is a transparent way to modify an object
    without disrupting the current interface.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes it makes sense to use the decorator pattern together with another
    design pattern we’ll examine – the façade pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Simplifying communication with the facade pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The facade pattern provides a unified interface to a set of underlying subsystems.
    In other words, a facade defines a higher-level interface that facilitates use.
    The facade pattern was described by the GoF.
  prefs: []
  type: TYPE_NORMAL
- en: Motivation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As subsystems evolve, they often become more complex. Most patterns, when used,
    result in smaller classes, thus making the subsystem more reusable and easier
    to customize, but also making it more difficult for all clients to work with.
    The facade pattern provides a simple default view of the subsystem that is good
    enough for most clients. Only clients who need more customizations will need to
    look beyond the façade pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Finding it in the JDK
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Java collections framework resides in the `java.base` module and `java.util`
    has already been mentioned several times. It is a widely used part of the JDK,
    especially for internal logic implementation. Interfaces such as `List`, `Set`,
    `Queue`, `Map`, and `Enumeration` can be considered facades of a particular implementation.
    Let us review the `List` interface in more detail. It is implemented by the commonly
    used `ArrayList` or `LinkedList` classes and others. Implementation specifics
    vary in detail, some of which were mentioned in [*Chapter 2*](B18884_02.xhtml#_idTextAnchor037),
    *Discovering the Java Platform for Design Patterns* (*Tables 2.3*, *2.4*, and
    *2.5*).
  prefs: []
  type: TYPE_NORMAL
- en: Sample code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The facade pattern is a frequently used design pattern in software engineering
    and is easily presented. Consider a case where a driver obtains their driving
    license for a vehicle. The driver’s license entitles them to drive both gasoline
    and diesel cars and, of course, to refuel them. The driver gets both types as
    a reward (*Example 4.10*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Example 4.10 – The facade pattern promotes a standardized control interface
  prefs: []
  type: TYPE_NORMAL
- en: 'Consolidating vehicle types has a positive impact on code structure that is
    easy to implement (*Figure 4**.5*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.5 – The UML class diagram of the facade pattern usage for Vehicle
    implementations](img/B18884_04_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.5 – The UML class diagram of the facade pattern usage for Vehicle implementations
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The heavy use of the facade pattern makes it a good candidate to consider at
    any stage of application development. It promotes not only the principle of interface
    segregation but the entire SOLID concept. It helps implement internal dependencies
    while remaining customizable and maintainable. Facade helps introduce loose coupling
    and separates clients, forcing the removal of unwilling dependencies. The facade
    pattern naturally supports the horizontal scaling of the source code. Although
    the facade pattern provides a lot of benefits, misuse caused by unmaintained source
    code can turn into unwanted state. The solution is to re-evaluate the current
    implementation and apply improvements according to the SOLID principles.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll examine how to select the correct object from a collection based
    on a rule.
  prefs: []
  type: TYPE_NORMAL
- en: Using conditions to select desired objects with the filter pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The filter pattern – sometimes called the criteria pattern – is a design pattern
    that allows clients to filter a set of objects using different criteria, or rules,
    and chain them separately using logical operations.
  prefs: []
  type: TYPE_NORMAL
- en: Motivation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The filter pattern helps simplify the code base to work like container objects
    that use subtyping instead of parameterization (generics) for an extensible class
    structure. It allows the client to easily extend and expose the filtering capability
    of container-like objects. Different filtering conditions can be dynamically added
    or removed without notifying the client.
  prefs: []
  type: TYPE_NORMAL
- en: Finding it in the JDK
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let us consider a filter as an interface with a single function and a logical
    Boolean result. A nice example of the filter pattern is the `Predicate` class,
    found in the `java.base` module and the `java.util.function` package. `Predicate`
    represents a Boolean function and is intended for use in the *Java Stream API*
    (discussed earlier, in [*Chapter 2*](B18884_02.xhtml#_idTextAnchor037), *Discovering
    the Java Platform for Design Patterns*), more specifically in the `filter` method,
    which accepts a predicate and returns a true or false primitive.
  prefs: []
  type: TYPE_NORMAL
- en: Sample code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A nice example of using the filter pattern would be an application that requires
    the selection of desired sensors in a vehicle. Every vehicle these days contains
    a huge number of sensors, so it can be difficult for a client to research each
    one individually (*Example 4.11*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Example 4.11 – Chaining a particular group of vehicle sensors with the filter
    pattern is simple and transparent
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s draw an example (*Figure 4**.6*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.6 – The UML class diagram of possible rules used by the container
    to select the proper Sensor instance](img/B18884_04_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.6 – The UML class diagram of possible rules used by the container to
    select the proper Sensor instance
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Rule` interface fulfills the expectation of the functional interface as
    it contains only one method, `validateSensors`. It also means that the compiler
    treats and optimizes the `Rule` interfaces like other annotated functional interfaces.
    Each rule can contain a specific implementation (*Example 4.12*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Example 4.12 – Rules can contain trivial logic such as RuleAnalog, or advanced
    logic, such as RuleAnd, with respect to other rules running in the decision process
  prefs: []
  type: TYPE_NORMAL
- en: The sample application can be easily extended with any additional, more complex
    rule through a transparently defined interface.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Filtering or better selection of the correct instances may be required in places
    such as joining different request types or database results present in the Java
    heap. The filter pattern has shown its flexibility and that each rule can be developed
    independently, that is, optimized without the involvement of others, which makes
    it a suitable candidate when a client needs to work with container structures.
  prefs: []
  type: TYPE_NORMAL
- en: The next pattern represents a possible way to reduce the memory footprint by
    sharing instances.
  prefs: []
  type: TYPE_NORMAL
- en: Sharing objects across an application with the flyweight pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The flyweight pattern is used to minimize memory usage or computational cost
    by sharing as much as possible with similar objects. The flyweight pattern was
    described by the GoF author group.
  prefs: []
  type: TYPE_NORMAL
- en: Motivation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When a newly developed application uses many objects that are not required by
    the client. Memory maintenance costs can be high not only because of the large
    number of instances but also because of the creation of a new object. In many
    cases, such groups of objects can be successfully replaced by a relatively small
    number of instances. These instances can be transparently shared between the desired
    clients. This will reduce the pressure on the garbage collection algorithm. In
    addition, an application can reduce the number of open sockets when instances
    use such communication types.
  prefs: []
  type: TYPE_NORMAL
- en: Finding it in the JDK
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The flyweight pattern can easily be found in the JDK. It may not be obvious
    to many. For example, in the implementation of primitive wrapper types, the `java.base`
    module and the `java.lang` package use this pattern to reduce memory overhead.
    A pattern is particularly useful when an application needs to handle many repeated
    values. Classes such as `Integer`, `Byte`, and `Character` provide a `valueOf`
    method, and its implementation uses an internal cache to store repeated elements.
  prefs: []
  type: TYPE_NORMAL
- en: Sample code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let us examine an example case where a garage continually hires out specific
    vehicle types. The garage contains some vehicles that can be hired. Each has already
    prepared vehicle documents by default. When another vehicle is required, the new
    document is put into the system on demand (*Example 4.13*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Example 4.13 – Sharing a template with the flyweight pattern is transparent
    and does not pollute memory
  prefs: []
  type: TYPE_NORMAL
- en: 'The heart of our next example (*Example 4.14*) is the implementation of `VehicleGarage`,
    which contains the cache for storing registration templates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Example 4.14 – The VehicleGarage implementation allows you to add a missing
    type on demand in order to control template size
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example diagram shows that the client is not aware of the `VehicleType`
    class because it is not required (*Figure 4**.7*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.7 – The UML class diagram shows which classes VehicleGarage requires](img/B18884_04_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.7 – The UML class diagram shows which classes VehicleGarage requires
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The big advantage of the flyweight pattern is the ability to administrate a
    large number of requests for the required objects. It instantiates objects on
    demand and allows you to obtain control over the present instances. The application
    does not need to depend on the identity (`hashCode` and `equals`) of the object.
    The flyweight pattern provides a transparent way to obtain access to the object
    and its implementation enforces the SOLID design concept and DRY approach.
  prefs: []
  type: TYPE_NORMAL
- en: The next section describes how to consolidate incoming requests in a controlled
    manner.
  prefs: []
  type: TYPE_NORMAL
- en: Handling requests with the front-controller pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The goal of the pattern is to create a common service for most of the client
    requirements. The pattern defines a procedure that allows common functions such
    as authentication, security, custom manipulation, and logging to be encapsulated
    at a single location.
  prefs: []
  type: TYPE_NORMAL
- en: Motivation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This pattern is commonly seen within web applications. It implements and defines
    the standard handler used by the controller. It is the handler’s responsibility
    to evaluate the validity of all incoming requests, although the handler itself
    may be available in many incarnations at runtime. The code is encapsulated in
    one place and referenced by the clients.
  prefs: []
  type: TYPE_NORMAL
- en: Finding it in the JDK
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Usage of the front-controller pattern can be found in the `jdk.httpserver`
    module, the `sun.net.httpserver` package, and the `HttpServer` abstract class.
    The class implements the `createContext` abstract method, which accepts the `HttpHander`
    interface. Handler instances participate in HTTP request processing by executing
    the handler method. The release of JDK 18 comes with the `SimpleFileServer` wrapper
    of the underlying `HttpServer` implementations, available also as the standalone
    command `jwebserver` (*JEP-408: Simple* *Web Server*).'
  prefs: []
  type: TYPE_NORMAL
- en: Sample code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let us create a simple theoretical example not focused on parsing the web request
    (*Example 4.15*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Example 4.15 – The vehicle system uses the front-controller pattern to process
    incoming commands
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine that vehicles contain a controller that is responsible for controlling
    brakes and motor units. All incoming commands are processed in this controller
    (*Figure 4**.8*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.8 – The front-controller pattern enforces a loose coupling of the
    controller and dispatcher](img/B18884_04_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.8 – The front-controller pattern enforces a loose coupling of the controller
    and dispatcher
  prefs: []
  type: TYPE_NORMAL
- en: 'The `VehicleController` object requires an instance of a specific handler.
    A handler is defined by an instance of the `RequestDispatcher` class (*Example
    4.16*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Example 4.16 – The request handler representation RequestDispatcher instance
    needs to be injected into VehicleController
  prefs: []
  type: TYPE_NORMAL
- en: Both the `BrakesUnit` and `EngineUnit` classes are separated from the handling
    or control logic and can be developed independently.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The main use of the front-controller pattern is in web frameworks, in addition
    to encapsulating requests for handling requests and increasing the portability
    of different types of handlers. These tools only need to be properly registered
    and run at runtime. Based on the implementation, the pattern supports dynamic
    handling behavior without the requirement to replace the class at runtime. The
    front-controller pattern introduces a centralized mechanism for processing incoming
    information.
  prefs: []
  type: TYPE_NORMAL
- en: Software design sometimes requires the dissemination of specific information
    for a group of classes. For such purposes, tagging is well worth considering.
    Let’s dive deeper into it in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Identifying instances using the marker pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This pattern is extremely useful in identifying instances at runtime for specific
    treatment, such as triggering the desired action when an instance is available.
  prefs: []
  type: TYPE_NORMAL
- en: Motivation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The marker interface pattern represents an empty interface. Such an interface
    is used to identify a special group of classes at runtime. Because of this fact,
    the maker pattern is sometimes called tagging, as its sole purpose is to distinguish
    a special type of instance. The application thus provides the possibility to use
    special handling for such cases at runtime. Logic can be separated and properly
    encapsulated. Because annotation represents a special form of interface, Java
    implements the marker interface in two ways – a class can inherit from an interface
    or be annotated.
  prefs: []
  type: TYPE_NORMAL
- en: Finding it in the JDK
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A clearer example of using the marker interface in the JDK can be found in the
    `java.base` module. The `java.io` package defines the `Serializable` interface
    and the `java.lang` package provides the `Cloneable` interface. Both do not implement
    any method, and both are used to inform the runtime about special handling. The
    `Serializable` interface is important during the serialization and deserialization
    processes (the `writeObject` and `readObject` methods), where each nested field
    requires an interface implementation to obtain the state of the instance while
    traversing the object graph. In a similar way, the `Cloneable` interface informs
    the JVM that the `Object.clone()` method is being used and it can create a field-to-field
    copy of the object. It is good to be aware of the field differences. The primitive
    types provide values but object-only references. It means that objects require
    an implementation of the `Cloneable` interface to provide a copy.
  prefs: []
  type: TYPE_NORMAL
- en: Sample code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let us draw a simple real-world example where a vehicle contains multiple sensors
    (*Figure 4**.9*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.9 – UML class diagram of certified sensor tags (CertifiedSensor
    and CertifiedAnnotation) using the marker interface pattern](img/B18884_04_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.9 – UML class diagram of certified sensor tags (CertifiedSensor and
    CertifiedAnnotation) using the marker interface pattern
  prefs: []
  type: TYPE_NORMAL
- en: 'The vehicle controller needs to identify special groups of the sensors that
    are certified for delivering specific information (*Example 4.17*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Example 4.17 – The marker interface pattern for sensor identification using
    the switch pattern-matching construct
  prefs: []
  type: TYPE_NORMAL
- en: This example introduced both types of pattern usage. It defines the `CertifiedAnnotation`
    and `CertifiedSensor` interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'To group all sensor kinds during the implementation, the `Sensor` interface
    is used (*Example 4.18*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Example 4.18 – Implementation of the tagging interfaces CertifiedAnnotation
    and CertifiedSensor, and Sensor abstraction with methods
  prefs: []
  type: TYPE_NORMAL
- en: 'Using tags is trivial. A class must be annotated or inherit the marker interface
    (*Example 4.19*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Example 4.19 – Marker usage for the sensor identification
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The marker interface pattern can be a powerful tool at runtime, but it must
    be used wisely as it can have some drawbacks. One is that the purpose of using
    the marker pattern may be forgotten, or it may become obsolete as the application
    evolves. The second is the implementation of special handling logic. Distributing
    such logic can negatively affect application behavior. On the other hand, a marker
    interface can simplify application logic, and in many cases, an interface is preferred
    over an annotation because it is more traceable.
  prefs: []
  type: TYPE_NORMAL
- en: Let us introduce a vehicle unit’s modularity in the next pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the concept of modules with the module pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This pattern implements the concept of software modules defined by modular programming.
    The pattern is used in cases where the programming language does not have direct
    support for such a concept or the application requires it.
  prefs: []
  type: TYPE_NORMAL
- en: Motivation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This pattern can be implemented in several ways depending on the application
    requirements. The module pattern concentrates or encapsulates the composition
    of an application’s functionality into precisely identified modules. The Java
    platform has already implemented basic support for the module concept through
    the Jigsaw project, available since the release of JDK 9, but it is possible to
    try to create it programmatically in a similar way, although not entirely in isolation,
    as the source code can influence its modularization approach.
  prefs: []
  type: TYPE_NORMAL
- en: Finding it in the JDK
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The best example that can be found in the JDK of the module pattern is the Java
    platform modules. This concept was discussed in great detail in [*Chapter 2*](B18884_02.xhtml#_idTextAnchor037),
    *Discovering the Java Platform for Design Patterns*, in the *Getting to grips
    with the Java Module* *System* section.
  prefs: []
  type: TYPE_NORMAL
- en: Sample code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let us imagine a vehicle that need to have isolated brakes and engine systems.
    This is pretty much according to a real-world scenario. Each module will operate
    independently, and only one provider is present at runtime. Before the vehicle
    can be used, both modules need to be activated (*Example 4.20*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Example 4.20 – The client function initModules activates the modules correctly
    in encapsulation
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram emphasizes the separation of modules, although the programmatic
    approach allows sharing or implementing shared abstractions (*Figure 4**.10*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.10 – UML class diagram showing a pattern implementation realized
    by the provided VehicleModule interface](img/B18884_04_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.10 – UML class diagram showing a pattern implementation realized by
    the provided VehicleModule interface
  prefs: []
  type: TYPE_NORMAL
- en: 'Each module is represented as a singleton instance in order to ensure only
    one instance provides a transparent gateway to access the module functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Example 4.21 – The EngineModule and BrakesModule example implementations are
    represented by singletons and have a similar structure
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The module pattern introduces structure to the source code in a very transparent
    way. Each module can be developed independently without influence. Because a programmatic
    solution may not fully enforce source code isolation, it is necessary to extend
    modules wisely. Another drawback may be module initialization, as a singleton
    may not be an acceptable solution. On the other hand, the module pattern provides
    a workflow to develop a source code with all SOLID concepts in mind.
  prefs: []
  type: TYPE_NORMAL
- en: What about using proxies instead of modules and implementations? Let us dive
    deeper in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Providing a placeholder for an object using the proxy pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The proxy pattern is considered a placeholder that manages access to another
    object in order to gain control of it. The pattern may also be known by the name
    surrogate. The proxy pattern was described by the GoF.
  prefs: []
  type: TYPE_NORMAL
- en: Motivation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In its most general form, a proxy is a class acting as an interface to the client.
    A proxy is considered a wrapper or agent object that is used by a client. The
    client accesses the actual object through the same interface and the actual implementation
    stays hidden from the client in the background. Communication between the client
    and the implementation remains transparent, thanks to the proxy pattern.
  prefs: []
  type: TYPE_NORMAL
- en: By using a proxy, the client can access the actual object, or it can provide
    additional logic.
  prefs: []
  type: TYPE_NORMAL
- en: Finding it in the JDK
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The proxy design pattern also has a place in the JDK. The most well-known one
    is the public `Proxy` class, which you can find in the `java.reflect` package
    of the `java.base` module. The `Proxy` class provides several static methods for
    creating objects used for method invocation.
  prefs: []
  type: TYPE_NORMAL
- en: Sample code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The given example can be considered as the remote control of a vehicle. A controller,
    represented by a proxy design pattern, provides exactly the same functionality
    as a real vehicle, also managing the connection between the real vehicle instance
    (*Example 4.22*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Example 4.22 – The VehicleProxy instance works like a real vehicle
  prefs: []
  type: TYPE_NORMAL
- en: 'The real vehicle implementation is defined by the generic abstraction provided
    by the `Vehicle` interfaces (*Figure 4**.11*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.11 – An example of a vehicle proxy can be depicted by a UML class
    diagram](img/B18884_04_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.11 – An example of a vehicle proxy can be depicted by a UML class diagram
  prefs: []
  type: TYPE_NORMAL
- en: 'This allows seamlessly extending the types of controlled vehicles, as shown
    in the proxy pattern implementation (*Example 4.23*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Example 4.23 – The VehicleProxy class contains a reference to the actual Vehicle
    instance
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The proxy design pattern brings many advantages to the source code, for example,
    the implementation can be replaced at runtime. In addition to being used to fully
    control access to the actual instance, it can also be used for lazy initiation,
    as we saw in *Example 4.23*. The proxy has its legitimate place in driver implementation
    or network connections as it naturally enforces not only logging possibilities
    but also code separation through the segregation of the interfaces and other SOLID
    principles. It is useful to consider when an application requires I/O operations.
  prefs: []
  type: TYPE_NORMAL
- en: Java as a language does not support multiple inheritance, but it is still possible
    to achieve. Let us examine how in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Discovering multiple inheritance in Java with the twin pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This pattern allows you to combine functions of objects that tend to be used
    together, which is a common paradigm used by languages without multiple inheritance
    support.
  prefs: []
  type: TYPE_NORMAL
- en: Motivation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The twin pattern presents the possibility to implement multiple inheritance
    in Java. Multiple inheritance is not a supported concept as it may lead to compiler
    inconsistency, known as the diamond problem. The diamond problem defines a state
    through class abstraction where the compiler may turn out to be inconsistent.
    This state is due to the lack of information due to multiple abstract classes.
    The compiler does not have enough information about which methods should execute.
  prefs: []
  type: TYPE_NORMAL
- en: Sample code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This pattern is not supported by the platform and is rarely required for development.
    For these reasons, the pattern most likely does not exist inside the released
    JDK, as described. However, let us examine a possible example to better understand
    the pattern. Imagine the vehicle initiation sequence. During initiation, the engine
    and brake units need to be initiated together. In other words, when the engine
    is initiated, the brakes must be initiated too, and the other way around (*Example
    4.24*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Example 4.24 – The twin pattern gives a guarantee that both units are always
    initiated
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows us tight coupling between units:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.12 – Both considered units, VehicleEngine and VehicleBrakes, are
    very closely coupled](img/B18884_04_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.12 – Both considered units, VehicleEngine and VehicleBrakes, are very
    closely coupled
  prefs: []
  type: TYPE_NORMAL
- en: 'The coupling also translates into a code base that can be very fragile for
    future development (*Example 4.25*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Example 4.25 – The VehicleBrakes class implementation shows a tight coupling
    with its twin, VehicleEngine
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The twin pattern can be used to achieve multiple inheritance in Java. It must
    be used wisely, as a logical unwritten requirement is to guarantee complete separation
    of the objects under consideration. In other words, the twin design pattern allows
    twins to function as a single instance with extended functionality and features.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Knowledge of structural patterns along with newly added Java syntax enhancements
    not only improves maintainability but also enforces all previously learned OOP
    concepts and improves responsiveness to potential deviations in code behavior
    such as exceptions, unexpected crashes, or logical issues.
  prefs: []
  type: TYPE_NORMAL
- en: We built a solid foundation through the examples in this chapter and learned
    how to use the adapter pattern to create collaboration between mutually incompatible
    objects, and also how to transparently separate an object’s implementation from
    its abstraction using the bridge pattern. The composite pattern presented a way
    to organize and wrap objects into a tree structure around the underlying business
    logic. We investigated the possibility of expanding an object’s functionality
    by using the decorator pattern. A way to simplify communication between objects
    was presented by the facade pattern, followed by the filter pattern, which allows
    us to select only the instances we want. We learned how the flyweight design pattern
    allows us to re-use already created runtime instances, and the approach of processing
    the incoming information was presented by the front-controller pattern, so that
    the client can only respond to valid requests. We discovered how the marker pattern
    allows a client to handle a specific group of objects in a unique way. We explored
    the possibility of modularizing the code base by implementing the module pattern.
    We saw how to use the proxy pattern to let a client indirectly gain control of
    an object without being aware of its implementation details, and we saw how to
    use the twin pattern to implement multiple inheritance in Java even though the
    language does not support it.
  prefs: []
  type: TYPE_NORMAL
- en: With the knowledge gained about creational and structural design patterns, the
    underlying source code structure is well organized and open to continuous application
    development. The next chapter examines the behavioral design patterns that help
    organize communication and responsibilities between targeted instances.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What challenges do structural design patterns solve?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which structural design patterns are described by the Gang of Four?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which design pattern is appropriate for creating a tree structure of related
    objects?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which structural design pattern can be used to identify an object at runtime?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which design pattern can be used for indirect object access, with the same functionality
    of the object itself?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which design pattern promotes the separation of logic from its abstraction?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Design Patterns: Elements of Reusable Object-Oriented Software* by Erich Gamma,
    Richard Helm, Ralph Johnson, and John Vlissides, Addison-Wesley, 1995'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Design Principles and Design Patterns* by Robert C. Martin, Object Mentor,
    2000'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*JSR-376: Java Platform Module* *System*, [https://openjdk.java.net/projects/jigsaw/spec/](https://openjdk.java.net/projects/jigsaw/spec/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*JSR-408: Simple Web* *Server*, [https://openjdk.org/jeps/408](https://openjdk.org/jeps/408)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Clean Code* by Robert C. Martin, Pearson Education, Inc, 2009'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Effective Java – Third edition* by Joshua Bloch, Addison-Wesley, 2018'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Twin – A Design Pattern for Modelling Multiple Inheritance*, Hanspeter Mössenböck,
    University of Linz, Institute for System Software, 1999, [https://ssw.jku.at/Research/Papers/Moe99/Paper.pdf](https://ssw.jku.at/Research/Papers/Moe99/Paper.pdf)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
