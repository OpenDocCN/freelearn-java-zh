- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Applying Structural Design Patterns
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用结构型设计模式
- en: 'Every piece of software has a purpose or, in other words, an expected behavior
    that it should fulfill. While the previous chapter described in detail creational
    design patterns, this chapter will focus on designing maintainable and flexible
    source code for objects created. Structural patterns attempt to bring clarity
    to relationships between created instances, not only to maintain an application
    but also to easily understand its purpose. Let us dive deeper and start examining
    the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 每个软件都有一个目的或换句话说，它应该满足的预期行为。虽然前一章详细描述了创建型设计模式，但本章将专注于为创建的对象设计可维护和灵活的源代码。结构型模式试图阐明创建实例之间的关系，不仅是为了维护应用程序，也是为了容易理解其目的。让我们深入了解，并开始检查以下主题：
- en: Incompatible object collaboration with the adapter pattern
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用适配器模式实现不兼容对象协作
- en: Decoupling and developing objects independently with the bridge pattern
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用桥接模式解耦并独立开发对象
- en: Treating objects the same way using the composite pattern
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用组合模式以相同的方式处理对象
- en: Extending object functionality by using the decorator pattern
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用装饰器模式扩展对象功能
- en: Simplifying communication with the facade pattern
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用外观模式简化通信
- en: Using conditions to select desired objects with the filter pattern
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用条件选择所需对象与过滤器模式
- en: Sharing objects across an application with the flyweight pattern
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用享元模式在应用程序中共享对象
- en: Handling requests with the front-controller pattern
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用前端控制器模式处理请求
- en: Identifying instances using the marker pattern
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用标记模式识别实例
- en: Exploring the concept of modules with the module pattern
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用模块模式探索模块的概念
- en: Providing a placeholder for an object employing the proxy pattern
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用代理模式为对象提供一个占位符
- en: Discovering multiple inheritance in Java with the twin pattern
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用双生模式在Java中探索多重继承
- en: By the end of this chapter, you’ll have a solid understanding of how to structure
    a code base around created instances.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将牢固地理解如何围绕创建的实例构建代码库。
- en: Technical requirements
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can find the code files for this chapter on GitHub at [https://github.com/PacktPublishing/Practical-Design-Patterns-for-Java-Developers/tree/main/Chapter04](https://github.com/PacktPublishing/Practical-Design-Patterns-for-Java-Developers/tree/main/Chapter04).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在GitHub上找到本章的代码文件：[https://github.com/PacktPublishing/Practical-Design-Patterns-for-Java-Developers/tree/main/Chapter04](https://github.com/PacktPublishing/Practical-Design-Patterns-for-Java-Developers/tree/main/Chapter04)。
- en: Incompatible object collaboration with the adapter pattern
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用适配器模式实现不兼容对象协作
- en: The main goal of the adapter pattern is to connect the source class interface
    to another interface that clients will expect. The adapter pattern allows classes
    to work together that otherwise couldn’t due to an incompatible abstraction or
    implementation. It is considered one of the most common patterns and is one of
    the **Gang of Four** (**GoF**) design patterns.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 适配器模式的主要目标是连接源类接口到客户端期望的另一个接口。适配器模式允许类在没有不兼容抽象或实现的情况下协同工作。它被认为是最常见的模式之一，也是**四人帮**（**GoF**）设计模式之一。
- en: Motivation
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动机
- en: The adapter pattern is also known as **wrapper**. An adapter wraps the behavior
    of the adaptee (connected class) and allows access to the adaptee without modification
    using an already existing interface. Commonly, an adaptee uses an incompatible
    interface, and an adapter consolidates such behavior and transparently provides
    access to the required functionality.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 适配器模式也被称为**包装器**。适配器封装了适配者（连接类）的行为，并允许通过一个已存在的接口来访问适配者，而不进行修改。通常，适配者使用不兼容的接口，适配器将这种行为合并并提供对所需功能的透明访问。
- en: Finding it in the JDK
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在JDK中找到它
- en: The `java.base` module provides multiple implementations of the adapter pattern.
    The `Collections` utility class from the `java.util` package provides a `list`
    method, which accepts an `Enumeration` interface and adapts the result into an
    `ArrayList` instance.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.base`模块提供了适配器模式的多种实现。`java.util`包中的`Collections`实用类提供了一个`list`方法，该方法接受一个`Enumeration`接口，并将结果适配为`ArrayList`实例。'
- en: Sample code
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例代码
- en: 'The adapter pattern can be implemented in several ways. One of them is considered
    in the example of a vehicle that can have different types of engines (*Example
    4.1*):'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 适配器模式可以以多种方式实现。其中一种在以下车辆示例中考虑（*示例 4.1*）：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here is the output:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是输出：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Example 4.1 – Although each type of vehicle shares similar logic, the behavior
    of the refuel method varies by engine type
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 4.1 – 尽管每种类型的车辆都共享类似的逻辑，但加油方法的操作因引擎类型而异
- en: 'These engines share some similar functionalities and features, but not all.
    They are very different from each other (*Figure 4**.1*):'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这些引擎共享一些类似的功能和特性，但并非全部。它们彼此之间非常不同（*图 4**.1*）：
- en: '![Figure 4.1 – UML class diagram highlighting engine type differences](img/B18884_04_01.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.1 – 强调引擎类型差异的 UML 类图](img/B18884_04_01.jpg)'
- en: Figure 4.1 – UML class diagram highlighting engine type differences
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1 – 强调引擎类型差异的 UML 类图
- en: 'In this example, the `Vehicle` class and its instance play the role of adapter.
    In the case of the `drive` method, both motors behave similarly. The `tank` method
    execution is a different scenario because the vehicle adapter needs to know the
    exact engine type to correctly execute the `refuel` method (*Example 4.2*):'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，`Vehicle`类及其实例扮演适配器的角色。在`drive`方法的情况下，两种马达的行为相似。`tank`方法的执行是一个不同的场景，因为车辆适配器需要知道确切的引擎类型才能正确执行`refuel`方法（*示例
    4.2*）：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Example 4.2 – The Vehicle instance operates with an engine based on its type,
    identified by the pattern-matching functionality
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 4.2 – `Vehicle`实例根据其类型使用引擎，该类型由模式匹配功能识别
- en: New language features such as `switch` statement enhancements can be very useful
    as there is no need to keep the exact adaptee instance reference for the adapter.
    The `sealed` classes enforce the desired purpose and increase maintainability
    by protecting their intent, such as by avoiding unwanted extensions.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 新的语言特性，如`switch`语句增强，非常有用，因为不需要保留适配器的确切实例引用。`sealed`类通过保护其意图，例如通过避免不想要的扩展，来强制执行所需的目的并提高可维护性。
- en: 'Both engine types considered may still implement similar abstraction in order
    to maintain the concept of the engine (*Example 4.3*):'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑的两种引擎类型仍然可以实施类似抽象，以保持引擎的概念（*示例 4.3*）：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Example 4.3 – The Engine interface allows only certain classes to implement
    its methods
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 4.3 – `Engine`接口只允许某些类实现其方法
- en: 'The `Vehicle` adapter provides the required logic to handle the different engine
    implementations properly. The `ElectricEngine` implementation provides an additional
    `checkPlug` method (*Example 4.4*):'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`Vehicle`适配器提供了处理不同引擎实现所需逻辑的必要逻辑。`ElectricEngine`实现提供了一个额外的`checkPlug`方法（*示例
    4.4*）：'
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Example 4.4 – ElectricEngine implements additional logic that is not shareable
    with the general Engine concept
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 4.4 – `ElectricEngine`实现了与通用`Engine`概念不共享的附加逻辑
- en: Conclusion
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结论
- en: The adapter structural design pattern has a valid place in development as it
    represents a maintainable way to connect different functionalities and control
    them through a similar interface. The adapter is properly encapsulated and can
    be even more abstract. The new `sealed` classes support the pattern concept of
    maintainability and clarity. The consequence of using the adapter pattern may
    be that the adapter needs to commit to a specific adaptee or interface. The adapter
    may extend some of the adaptee functionalities as a subclass. The adapter pattern
    is worth considering when additional third-party libraries or APIs are to be implemented.
    It provides a transparent and decoupled way to interact with libraries, following
    the SOLID concept. Solutions can also be easily refactored.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 适配器结构设计模式在开发中有一个合理的位置，因为它代表了一种连接不同功能并通过类似接口控制它们的可维护方式。适配器被适当封装，甚至可以更加抽象。新的`sealed`类支持可维护性和清晰性的模式概念。使用适配器模式的后果可能是适配器需要承诺特定的适配器或接口。适配器可以作为子类扩展一些适配器功能。当需要实现额外的第三方库或API时，适配器模式值得考虑。它提供了一个透明且解耦的方式来与库交互，遵循SOLID原则。解决方案也可以轻松重构。
- en: This look at the adapter pattern has shown the approach of using incompatible
    APIs. Next, let us investigate how to use different replaceable implementations.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 对适配器模式的这种分析展示了使用不兼容API的方法。接下来，让我们研究如何使用不同的可替换实现。
- en: Decoupling and developing objects independently with the bridge pattern
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用桥接模式解耦并独立开发对象
- en: The goal of this pattern is to separate the abstraction from its implementation
    so that both can change independently. The bridge pattern was described by the
    GoF.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 此模式的目的是将抽象与其实现分离，以便两者可以独立更改。桥接模式由GoF描述。
- en: Motivation
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动机
- en: The bridge pattern is about prioritizing composition over inheritance. The implementation
    details are moved from the hierarchy to another object with a separate hierarchy.
    The bridge pattern uses encapsulation and aggregation, and may use inheritance
    to separate responsibilities into different classes.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 桥接模式是优先考虑组合而非继承。实现细节从层次结构移动到另一个具有独立层次结构的对象。桥接模式使用封装和聚合，并且可能使用继承将责任分离到不同的类中。
- en: Finding it in the JDK
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在JDK中找到它
- en: Uses of the bridge pattern can be found in the `java.util.logging` package and
    the implementation of the `Logger` class. The class is located in the `java.logging`
    module. It implements the `Filter` interface. This interface is used to gain additional
    control over logged content beyond the standard log level.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 桥接模式的使用可以在`java.util.logging`包和`Logger`类的实现中找到。该类位于`java.logging`模块中。它实现了`Filter`接口。该接口用于在标准日志级别之外获得对记录内容的额外控制。
- en: Sample code
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 样本代码
- en: 'Let us see an example of two types of vehicles: a sport car and a pickup. The
    vehicles vary in engine type: petrol and diesel. The intention is to enforce a
    separate development for the `Vehicle` and `Engine` abstraction source code. The
    example case creates vehicles and executes `drive` and `stop` methods (*Example
    4.5*):'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看两种类型车辆的例子：一辆跑车和一辆皮卡。这些车辆在发动机类型上有所不同：汽油和柴油。目的是为了强制对`Vehicle`和`Engine`抽象源代码进行独立开发。示例案例创建了车辆并执行了`drive`和`stop`方法（*示例4.5*）：
- en: '[PRE5]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Here is the output:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是输出：
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Example 4.5 – The vehicles use different engines; they can be developed separately
    due to the bridge pattern’s isolation
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 示例4.5 – 车辆使用不同的发动机；由于桥接模式的隔离，它们可以独立开发
- en: 'Each vehicle extends the `Vehicle` abstraction class that runs the engine and
    encapsulates the basic functions. The `Engine` interface, used by the vehicle
    abstraction, plays the role of a bridge, as shown in the following diagram (*Figure
    4**.2*):'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 每个车辆都扩展了运行发动机并封装基本功能的`Vehicle`抽象类。车辆抽象使用的`Engine`接口扮演了桥接的角色，如下面的图所示（*图4**.2*）：
- en: '![](img/B18884_04_02.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18884_04_02.jpg)'
- en: Figure 4.2 – The UML class diagram shows how the Engine interface bridges access
    to a specific implementation
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2 – UML类图显示了如何通过Engine接口桥接对特定实现的访问
- en: 'The engines already behave differently, and due to the bridge they may continue
    evolving (*Example 4.6*):'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 发动机已经表现出不同的行为，由于桥接，它们可能会继续发展（*示例4.6*）：
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Example 4.6 – The engines differ in implementation
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 示例4.6 – 发动机在实现上有所不同
- en: The vehicle abstraction does not have any engine implementation details, which
    may vary even in the class hierarchy. The vehicle only needs to rely on the provided
    interface.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 车辆抽象没有任何发动机实现细节，这些细节可能在类层次结构中有所不同。车辆只需要依赖于提供的接口。
- en: Conclusion
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结论
- en: The bridge pattern is a good idea to consider when the application source code
    requires reducing bindings to specific implementation classes. Due to the bridge
    pattern, the decision about a specific implementation can be deferred until runtime.
    The bridge pattern helps to encourage SOLID design principles through responsibility
    separation and encapsulation. The implementation can be freely tested and shared
    as required through the application source code. It is required to keep in mind
    not to add unwanted responsibilities to the bridge implementation and consider
    alternative approaches in terms of design patterns when such a situation takes
    a place.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序源代码需要减少对特定实现类的绑定时，桥接模式是一个很好的考虑方案。由于桥接模式，关于特定实现的决定可以推迟到运行时。桥接模式通过责任分离和封装来鼓励SOLID设计原则。实现可以自由地通过应用程序源代码进行测试和共享。需要记住的是，不要向桥接实现添加不希望的责任，并在出现这种情况时考虑设计模式的替代方法。
- en: The bridge pattern can open the door to better composition of implementation
    specifics, as we’ll explore in the next pattern.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 桥接模式可以为实现细节的更好组合打开大门，我们将在下一个模式中探讨。
- en: Treating objects the same way using the composite pattern
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用组合模式以相同方式处理对象
- en: The composite pattern is a remarkable solution for handling objects uniformly
    while arranging them in a tree structure, which simplifies access to instances.
    The demand for it naturally came from industry, and the pattern was soon identified
    and described by the GoF.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 组合模式是一个在以树结构排列对象的同时统一处理对象的显著解决方案，这简化了对实例的访问。对它的需求自然来自工业界，该模式很快就被GoF识别并描述。
- en: Motivation
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动机
- en: Grouping objects around the underlying business logic is a powerful approach.
    A composite design pattern outlines a way to achieve such a state. Since each
    member of the group is treated uniformly, it is possible to create hierarchical
    tree structures and part-whole hierarchies. It helps to establish the logical
    relationships of the application and the composition of the desired objects.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 围绕底层业务逻辑对对象进行分组是一种强大的方法。组合设计模式概述了实现这种状态的方法。由于每个组员都受到统一对待，因此可以创建层次树结构和部分-整体层次结构。它有助于建立应用程序的逻辑关系和所需对象的组合。
- en: Finding it in the JDK
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 JDK 中找到它
- en: In the JDK, the composite pattern can be found in the `java.base` module, the
    `java.util` package, and the `Properties` class. The `Properties` class implements
    the `Map` interface through its `Hashtable` implementation, and also contains
    a `ConcurrentHashMap` instance to store the property values internally. Although
    the `Properties` class’s `put` operation remains synchronized due to the `Hashtable`
    implementation, the `get` operation does not, as it is simple to read into the
    concurrent map.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JDK 中，组合模式可以在 `java.base` 模块、`java.util` 包和 `Properties` 类中找到。`Properties`
    类通过其 `Hashtable` 实现实现了 `Map` 接口，并且还包含一个 `ConcurrentHashMap` 实例来内部存储属性值。尽管由于 `Hashtable`
    实现的原因，`Properties` 类的 `put` 操作保持同步，但 `get` 操作并不同步，因为将其读取到并发映射中很简单。
- en: Sample code
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例代码
- en: 'To explore the power of the composition pattern, consider the `SportVehicle`
    class, which implements the `Vehicle` interface. It is standard knowledge that
    every vehicle is a collection of parts and every part is a grouping of smaller
    parts (*Figure 4**.3*):'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 要探索组合模式的力量，可以考虑实现 `Vehicle` 接口的 `SportVehicle` 类。众所周知，每辆车都是部件的集合，每个部件都是更小部件的分组（*图
    4**.3*）：
- en: '![Figure 4.3 – The UML class diagram shows how SportVehicle is composed of
    VehiclePart types](img/B18884_04_03.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.3 – UML 类图显示了 SportVehicle 是如何由 VehiclePart 类型组成的](img/B18884_04_03.jpg)'
- en: Figure 4.3 – The UML class diagram shows how SportVehicle is composed of VehiclePart
    types
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.3 – UML 类图显示了 SportVehicle 是如何由 VehiclePart 类型组成的
- en: 'When the vehicle manufacturing process starts, the composition pattern provides
    a complete collection of every part that is present in the final results (*Example
    4.7*):'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当车辆制造过程开始时，组合模式提供了一组完整的部件，这些部件最终都会出现在结果中（*示例 4.7*）：
- en: '[PRE8]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Here’s the output:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是输出：
- en: '[PRE9]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Example 4.7 – Reviewing the SportVehicle instance composition
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 4.7 – 检查 SportVehicle 实例的组合
- en: Conclusion
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结论
- en: The composite pattern allows the representation of the composition of a class
    in granular detail. It takes into account the smaller parts of the composite by
    creating part-whole hierarchies. While this provides advantages because each part
    is treated uniformly, it can lead to ignoring differences between parts. On the
    other hand, the composite pattern holds all the involved parts together in a transparent
    form.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 组合模式允许以细粒度详细表示类的组合。它通过创建部分-整体层次结构来考虑组合的较小部分。虽然这提供了优势，因为每个部分都受到统一对待，但它可能导致忽略部分之间的差异。另一方面，组合模式以透明的方式将所有涉及的部分组合在一起。
- en: Let us now examine how an individual object can be extended with additional
    functionality without changing the API.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在看看如何在不改变 API 的情况下，通过附加额外的功能来扩展单个对象。
- en: Extending object functionality by using the decorator pattern
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过使用装饰器模式扩展对象功能
- en: The decorator pattern provides the ability to add new functionality to objects
    by placing those objects in a decorator, Sothat a decorated instance provides
    extended functionality. The implementation of the decorator pattern is relatively
    simple and dynamic in languages such as Python and Kotlin. On the other hand,
    Java may provide more stability and maintainability of the source code through
    visibility and new enhancements, which can be very valuable. The decorator pattern
    was identified and described by the GoF.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器模式通过将对象放入装饰器中，提供了向对象添加新功能的能力，因此装饰后的实例提供了扩展功能。装饰器模式的实现相对简单且在 Python 和 Kotlin
    等语言中具有动态性。另一方面，Java 通过可见性和新增强功能提供了源代码的更多稳定性和可维护性，这非常有价值。装饰器模式是由 GoF 确定并描述的。
- en: Motivation
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动机
- en: With the decorator pattern, you can dynamically attach additional responsibilities
    to an object. A decorator provides a flexible alternative to subclasses to extend
    the functionality of a class. The decorator can be added statically or dynamically
    without altering the current behavior of an object.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 使用装饰器模式，你可以动态地为对象附加额外的职责。装饰器为扩展类的功能提供了一个灵活的替代子类的方法。装饰器可以静态或动态地添加，而不会改变对象当前的行为。
- en: Finding it in the JDK
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 JDK 中查找
- en: Uses of the decorator pattern can be found in the Java collections framework,
    the `java.base` module, and the `java.util` package. The `Collection` class contains
    different ways to use the decorator pattern. For example, the `unmodifiableCollection`
    method wraps the requested collection into an unmodifiable collection represented
    by an `UnmodifiableCollection` instance that acts as a decorator for the provided
    collection type, similar to other methods starting with `unmodifiable...` words.
    Another example is methods starting with the word `synchronized...` of the `Collections`
    utility class.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器模式的使用可以在 Java 集合框架、`java.base` 模块和 `java.util` 包中找到。`Collection` 类包含了使用装饰器模式的不同方式。例如，`unmodifiableCollection`
    方法将请求的集合包装成一个不可修改的集合，该集合由一个 `UnmodifiableCollection` 实例表示，该实例作为提供集合类型的装饰器，类似于以
    `unmodifiable...` 开头的方法。另一个例子是 `Collections` 工具类中以 `synchronized...` 开头的方法。
- en: Sample code
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 样本代码
- en: 'When you think about the previous examples of vehicles, the decorator pattern
    can be considered a tuned vehicle. The standard `SportVehicle` class is like this.
    It implements the `Vehicle` interface to fulfill standard functions. The application
    designer later decides to improve the current state and creates a `TunedVehicleDecorator`
    class that wraps the standard vehicle, without having to change previous functions
    (*Figure 4**.4*):'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 当你考虑之前的车辆示例时，装饰器模式可以被视为调校过的车辆。标准的 `SportVehicle` 类就是这样。它实现了 `Vehicle` 接口以执行标准功能。应用设计师后来决定改进当前状态，并创建了一个
    `TunedVehicleDecorator` 类来包装标准车辆，而不必改变之前的函数（*图 4**.4*）：
- en: '![Figure 4.4 – The UML class diagram highlights the relationship between SportVehicle
    and TunedVehicleDecorator types](img/B18884_04_04.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.4 – UML 类图突出了 SportVehicle 和 TunedVehicleDecorator 类型之间的关系](img/B18884_04_04.jpg)'
- en: Figure 4.4 – The UML class diagram highlights the relationship between SportVehicle
    and TunedVehicleDecorator types
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.4 – UML 类图突出了 SportVehicle 和 TunedVehicleDecorator 类型之间的关系
- en: 'All considered vehicles expose similar APIs to execute their implementations
    (*Example 4.8)*:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 所考虑的车辆都公开了类似的 API 来执行它们的实现（*示例 4.8*）：
- en: '[PRE10]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Here is the output:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是输出：
- en: '[PRE11]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Example 4.8 – The tuned car abstraction extends the features of the SportVehicle
    type by adding more horsepower (200)
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 4.8 – 调校汽车抽象通过增加更多马力（200）扩展了 SportVehicle 类型的功能
- en: 'The decorator pattern may be introduced in multiple ways. In the presented
    example, `TunedVehicleDecorator` is an abstract class that holds the reference
    to the vehicle. The `SportVehicle` instance extends newly implemented functionality
    (*Example 4.9)*:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器模式可以通过多种方式引入。在所提供的示例中，`TunedVehicleDecorator` 是一个抽象类，它持有对车辆的引用。`SportVehicle`
    实例扩展了新实现的功能（*示例 4.9*）：
- en: '[PRE12]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Example 4.9 – Decorator wraps the Vehicle instance and extends its functionality
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 4.9 – 装饰器包装了 Vehicle 实例并扩展了其功能
- en: Conclusion
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结论
- en: Class decoration can be very useful in many cases during application development.
    The decorator pattern can be used to migrate application logic where previous
    functionalities should remain hidden or unwanted subclassing should be avoided.
    The example showed how sealed classes can contribute to code maintainability and
    comprehensibility. Decoration helps not only to add new features but also to remove
    obsolete features. The decorator pattern is a transparent way to modify an object
    without disrupting the current interface.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用开发过程中的许多情况下，类装饰可以非常有用。装饰器模式可以用来迁移应用逻辑，其中之前的功能应该保持隐藏或应避免不想要的子类化。示例展示了密封类如何有助于代码的可维护性和可理解性。装饰器不仅有助于添加新功能，还有助于移除过时的功能。装饰器模式是一种在不破坏当前接口的情况下修改对象的可透明方式。
- en: Sometimes it makes sense to use the decorator pattern together with another
    design pattern we’ll examine – the façade pattern.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 有时使用装饰器模式与我们将要检查的另一个设计模式（外观模式）一起使用是有意义的。
- en: Simplifying communication with the facade pattern
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用外观模式简化通信
- en: The facade pattern provides a unified interface to a set of underlying subsystems.
    In other words, a facade defines a higher-level interface that facilitates use.
    The facade pattern was described by the GoF.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 门面模式为一系列底层子系统提供了一个统一的接口。换句话说，门面定义了一个高级接口，便于使用。门面模式由 GoF 描述。
- en: Motivation
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动机
- en: As subsystems evolve, they often become more complex. Most patterns, when used,
    result in smaller classes, thus making the subsystem more reusable and easier
    to customize, but also making it more difficult for all clients to work with.
    The facade pattern provides a simple default view of the subsystem that is good
    enough for most clients. Only clients who need more customizations will need to
    look beyond the façade pattern.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 随着子系统的演变，它们通常变得更加复杂。大多数模式在使用时会导致类变得更小，从而使子系统更易于重用和定制，但也使得所有客户端与之交互变得更加困难。门面模式提供了一个简单的默认视图，这对于大多数客户端来说已经足够好。只有需要更多定制的客户端才需要超越门面模式。
- en: Finding it in the JDK
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 JDK 中找到它
- en: The Java collections framework resides in the `java.base` module and `java.util`
    has already been mentioned several times. It is a widely used part of the JDK,
    especially for internal logic implementation. Interfaces such as `List`, `Set`,
    `Queue`, `Map`, and `Enumeration` can be considered facades of a particular implementation.
    Let us review the `List` interface in more detail. It is implemented by the commonly
    used `ArrayList` or `LinkedList` classes and others. Implementation specifics
    vary in detail, some of which were mentioned in [*Chapter 2*](B18884_02.xhtml#_idTextAnchor037),
    *Discovering the Java Platform for Design Patterns* (*Tables 2.3*, *2.4*, and
    *2.5*).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: Java 集合框架位于 `java.base` 模块中，`java.util` 已经被提及多次。它是 JDK 中广泛使用的一部分，尤其是在内部逻辑实现方面。例如
    `List`、`Set`、`Queue`、`Map` 和 `Enumeration` 等接口可以被视为特定实现的门面。让我们更详细地回顾一下 `List`
    接口。它由常用的 `ArrayList` 或 `LinkedList` 类以及其他类实现。实现的具体细节有所不同，其中一些在 [*第 2 章*](B18884_02.xhtml#_idTextAnchor037)
    《发现 Java 平台设计模式》中提到（*表 2.3*、*2.4* 和 *2.5*）。
- en: Sample code
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例代码
- en: 'The facade pattern is a frequently used design pattern in software engineering
    and is easily presented. Consider a case where a driver obtains their driving
    license for a vehicle. The driver’s license entitles them to drive both gasoline
    and diesel cars and, of course, to refuel them. The driver gets both types as
    a reward (*Example 4.10*):'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 门面模式是软件工程中常用的一种设计模式，且易于展示。考虑一个司机获得驾驶执照的情况，该执照使他们有权驾驶汽油和柴油汽车，当然，也可以为他们加油。司机作为奖励获得这两种类型（*示例
    4.10*）：
- en: '[PRE13]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Here’s the output:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出结果：
- en: '[PRE14]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Example 4.10 – The facade pattern promotes a standardized control interface
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 4.10 – 门面模式促进标准化控制接口
- en: 'Consolidating vehicle types has a positive impact on code structure that is
    easy to implement (*Figure 4**.5*):'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 整合车辆类型对代码结构有积极的影响，易于实现（*图 4**.5*）：
- en: '![Figure 4.5 – The UML class diagram of the facade pattern usage for Vehicle
    implementations](img/B18884_04_05.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.5 – 门面模式在车辆实现中的 UML 类图](img/B18884_04_05.jpg)'
- en: Figure 4.5 – The UML class diagram of the facade pattern usage for Vehicle implementations
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.5 – 门面模式在车辆实现中的 UML 类图
- en: Conclusion
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结论
- en: The heavy use of the facade pattern makes it a good candidate to consider at
    any stage of application development. It promotes not only the principle of interface
    segregation but the entire SOLID concept. It helps implement internal dependencies
    while remaining customizable and maintainable. Facade helps introduce loose coupling
    and separates clients, forcing the removal of unwilling dependencies. The facade
    pattern naturally supports the horizontal scaling of the source code. Although
    the facade pattern provides a lot of benefits, misuse caused by unmaintained source
    code can turn into unwanted state. The solution is to re-evaluate the current
    implementation and apply improvements according to the SOLID principles.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 大量使用门面模式使其在任何应用开发阶段都成为考虑的好候选。它不仅促进了接口分离原则，还促进了整个 SOLID 概念。它有助于实现内部依赖关系，同时保持可定制性和可维护性。门面有助于引入松散耦合，并分离客户端，迫使移除不情愿的依赖。门面模式自然支持源代码的水平扩展。尽管门面模式提供了很多好处，但由未维护的源代码引起的误用可能会变成不受欢迎的状态。解决方案是重新评估当前实现，并根据
    SOLID 原则进行改进。
- en: Next, we’ll examine how to select the correct object from a collection based
    on a rule.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨如何根据规则从集合中选择正确的对象。
- en: Using conditions to select desired objects with the filter pattern
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用过滤模式通过条件选择所需对象
- en: The filter pattern – sometimes called the criteria pattern – is a design pattern
    that allows clients to filter a set of objects using different criteria, or rules,
    and chain them separately using logical operations.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤模式——有时也称为标准模式——是一种设计模式，它允许客户端使用不同的标准或规则来过滤一组对象，并通过逻辑运算分别将它们链接起来。
- en: Motivation
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动机
- en: The filter pattern helps simplify the code base to work like container objects
    that use subtyping instead of parameterization (generics) for an extensible class
    structure. It allows the client to easily extend and expose the filtering capability
    of container-like objects. Different filtering conditions can be dynamically added
    or removed without notifying the client.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤模式有助于简化代码库，使其像使用子类型而不是参数化（泛型）的可扩展类结构的容器对象一样工作。它允许客户端轻松扩展并公开容器类似对象的过滤能力。不同的过滤条件可以动态添加或删除，而无需通知客户端。
- en: Finding it in the JDK
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 JDK 中找到它
- en: Let us consider a filter as an interface with a single function and a logical
    Boolean result. A nice example of the filter pattern is the `Predicate` class,
    found in the `java.base` module and the `java.util.function` package. `Predicate`
    represents a Boolean function and is intended for use in the *Java Stream API*
    (discussed earlier, in [*Chapter 2*](B18884_02.xhtml#_idTextAnchor037), *Discovering
    the Java Platform for Design Patterns*), more specifically in the `filter` method,
    which accepts a predicate and returns a true or false primitive.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将过滤器视为一个具有单个函数和逻辑布尔结果的接口。过滤模式的一个很好的例子是 `Predicate` 类，它在 `java.base` 模块和 `java.util.function`
    包中找到。`Predicate` 表示一个布尔函数，并打算用于 *Java Stream API*（之前在 [*第 2 章*](B18884_02.xhtml#_idTextAnchor037)，*发现
    Java 平台设计模式*）中，更具体地说是在 `filter` 方法中，该方法接受一个谓词并返回一个布尔值。
- en: Sample code
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 样本代码
- en: 'A nice example of using the filter pattern would be an application that requires
    the selection of desired sensors in a vehicle. Every vehicle these days contains
    a huge number of sensors, so it can be difficult for a client to research each
    one individually (*Example 4.11*):'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 使用过滤模式的一个很好的例子是一个需要选择车辆中所需传感器的应用程序。如今，每辆车都包含大量的传感器，因此客户端可能难以单独研究每一个（*示例 4.11*）：
- en: '[PRE15]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Here’s the output:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出：
- en: '[PRE16]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Example 4.11 – Chaining a particular group of vehicle sensors with the filter
    pattern is simple and transparent
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 4.11 – 使用过滤模式简单且透明地将特定车辆传感器组链接起来
- en: 'Let’s draw an example (*Figure 4**.6*):'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们画一个例子（*图 4**.6*）：
- en: '![Figure 4.6 – The UML class diagram of possible rules used by the container
    to select the proper Sensor instance](img/B18884_04_06.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.6 – 容器用于选择合适的传感器实例的可能规则的 UML 类图](img/B18884_04_06.jpg)'
- en: Figure 4.6 – The UML class diagram of possible rules used by the container to
    select the proper Sensor instance
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.6 – 容器用于选择合适的传感器实例的可能规则的 UML 类图
- en: 'The `Rule` interface fulfills the expectation of the functional interface as
    it contains only one method, `validateSensors`. It also means that the compiler
    treats and optimizes the `Rule` interfaces like other annotated functional interfaces.
    Each rule can contain a specific implementation (*Example 4.12*):'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`Rule` 接口满足功能接口的期望，因为它只包含一个方法，`validateSensors`。这也意味着编译器将 `Rule` 接口像其他注解功能接口一样处理和优化。每个规则都可以包含一个特定的实现（*示例
    4.12*）：'
- en: '[PRE17]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Example 4.12 – Rules can contain trivial logic such as RuleAnalog, or advanced
    logic, such as RuleAnd, with respect to other rules running in the decision process
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 4.12 – 规则可以包含简单的逻辑，如 RuleAnalog，或与决策过程中运行的其他规则相关的复杂逻辑，如 RuleAnd
- en: The sample application can be easily extended with any additional, more complex
    rule through a transparently defined interface.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 样本应用程序可以通过一个透明定义的接口轻松地扩展以包含任何额外的、更复杂的规则。
- en: Conclusion
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结论
- en: Filtering or better selection of the correct instances may be required in places
    such as joining different request types or database results present in the Java
    heap. The filter pattern has shown its flexibility and that each rule can be developed
    independently, that is, optimized without the involvement of others, which makes
    it a suitable candidate when a client needs to work with container structures.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 堆中连接不同的请求类型或数据库结果的地方可能需要过滤或更好地选择正确的实例。过滤模式已经展示了其灵活性，以及每个规则可以独立开发，即在不涉及他人的情况下优化，这使得它成为客户端需要与容器结构一起工作时的一个合适候选。
- en: The next pattern represents a possible way to reduce the memory footprint by
    sharing instances.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个模式代表了一种通过共享实例来减少内存占用的一种可能方式。
- en: Sharing objects across an application with the flyweight pattern
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用享元模式在应用程序中动态共享对象
- en: The flyweight pattern is used to minimize memory usage or computational cost
    by sharing as much as possible with similar objects. The flyweight pattern was
    described by the GoF author group.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 享元模式通过尽可能多地与相似对象共享来最小化内存使用或计算成本。享元模式由GoF作者组描述。
- en: Motivation
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动机
- en: When a newly developed application uses many objects that are not required by
    the client. Memory maintenance costs can be high not only because of the large
    number of instances but also because of the creation of a new object. In many
    cases, such groups of objects can be successfully replaced by a relatively small
    number of instances. These instances can be transparently shared between the desired
    clients. This will reduce the pressure on the garbage collection algorithm. In
    addition, an application can reduce the number of open sockets when instances
    use such communication types.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个新开发的应用程序使用许多客户端不需要的对象时，内存维护成本可能很高，这不仅因为实例数量庞大，还因为新对象的创建。在许多情况下，这些对象组可以成功地被相对较少的实例所替代。这些实例可以在所需的客户端之间透明地共享。这将减轻垃圾收集算法的压力。此外，当实例使用此类通信类型时，应用程序可以减少打开套接字的数量。
- en: Finding it in the JDK
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在JDK中找到它
- en: The flyweight pattern can easily be found in the JDK. It may not be obvious
    to many. For example, in the implementation of primitive wrapper types, the `java.base`
    module and the `java.lang` package use this pattern to reduce memory overhead.
    A pattern is particularly useful when an application needs to handle many repeated
    values. Classes such as `Integer`, `Byte`, and `Character` provide a `valueOf`
    method, and its implementation uses an internal cache to store repeated elements.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 享元模式在JDK中很容易找到。对许多人来说可能并不明显。例如，在原始包装类型的实现中，`java.base`模块和`java.lang`包使用这种模式来减少内存开销。当应用程序需要处理许多重复值时，模式特别有用。例如，`Integer`、`Byte`和`Character`类提供了一个`valueOf`方法，其实现使用内部缓存来存储重复元素。
- en: Sample code
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例代码
- en: 'Let us examine an example case where a garage continually hires out specific
    vehicle types. The garage contains some vehicles that can be hired. Each has already
    prepared vehicle documents by default. When another vehicle is required, the new
    document is put into the system on demand (*Example 4.13*):'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考察一个例子，其中车库持续出租特定类型的车辆。车库中包含一些可以出租的车辆。每个车辆默认已经准备好了车辆文件。当需要另一辆车时，新的文件会按需放入系统中（*示例4.13*）：
- en: '[PRE18]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Here’s the output:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是输出结果：
- en: '[PRE19]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Example 4.13 – Sharing a template with the flyweight pattern is transparent
    and does not pollute memory
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 示例4.13 – 使用享元模式共享模板是透明的，并且不会污染内存
- en: 'The heart of our next example (*Example 4.14*) is the implementation of `VehicleGarage`,
    which contains the cache for storing registration templates:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们下一个示例（*示例4.14*）的核心是实现`VehicleGarage`，它包含用于存储注册模板的缓存：
- en: '[PRE20]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Example 4.14 – The VehicleGarage implementation allows you to add a missing
    type on demand in order to control template size
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 示例4.14 – VehicleGarage实现允许你按需添加缺失的类型以控制模板大小
- en: 'The following example diagram shows that the client is not aware of the `VehicleType`
    class because it is not required (*Figure 4**.7*):'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例图显示客户端没有意识到`VehicleType`类，因为它不是必需的（*图4**.7*）：
- en: '![Figure 4.7 – The UML class diagram shows which classes VehicleGarage requires](img/B18884_04_07.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![图4.7 – UML类图显示了VehicleGarage需要哪些类](img/B18884_04_07.jpg)'
- en: Figure 4.7 – The UML class diagram shows which classes VehicleGarage requires
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.7 – UML类图显示了VehicleGarage需要哪些类
- en: Conclusion
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结论
- en: The big advantage of the flyweight pattern is the ability to administrate a
    large number of requests for the required objects. It instantiates objects on
    demand and allows you to obtain control over the present instances. The application
    does not need to depend on the identity (`hashCode` and `equals`) of the object.
    The flyweight pattern provides a transparent way to obtain access to the object
    and its implementation enforces the SOLID design concept and DRY approach.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 享元模式的大优点是能够管理大量对所需对象的请求。它按需实例化对象，并允许你控制现有实例。应用程序不需要依赖于对象的标识（`hashCode`和`equals`）。享元模式提供了一种透明的方式来访问对象及其实现强制执行SOLID设计概念和DRY方法。
- en: The next section describes how to consolidate incoming requests in a controlled
    manner.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个部分将描述如何以受控的方式合并传入的请求。
- en: Handling requests with the front-controller pattern
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用前端控制器模式处理请求
- en: The goal of the pattern is to create a common service for most of the client
    requirements. The pattern defines a procedure that allows common functions such
    as authentication, security, custom manipulation, and logging to be encapsulated
    at a single location.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 该模式的目标是为大多数客户端需求创建一个通用服务。该模式定义了一个程序，允许将认证、安全、自定义操作和日志记录等公共功能封装在单个位置。
- en: Motivation
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动机
- en: This pattern is commonly seen within web applications. It implements and defines
    the standard handler used by the controller. It is the handler’s responsibility
    to evaluate the validity of all incoming requests, although the handler itself
    may be available in many incarnations at runtime. The code is encapsulated in
    one place and referenced by the clients.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式在Web应用程序中很常见。它实现了并定义了控制器使用的标准处理器。评估所有传入请求的有效性是处理器的责任，尽管处理器本身可能在运行时以多种形式存在。代码封装在一个地方，并由客户端引用。
- en: Finding it in the JDK
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在JDK中找到它
- en: 'Usage of the front-controller pattern can be found in the `jdk.httpserver`
    module, the `sun.net.httpserver` package, and the `HttpServer` abstract class.
    The class implements the `createContext` abstract method, which accepts the `HttpHander`
    interface. Handler instances participate in HTTP request processing by executing
    the handler method. The release of JDK 18 comes with the `SimpleFileServer` wrapper
    of the underlying `HttpServer` implementations, available also as the standalone
    command `jwebserver` (*JEP-408: Simple* *Web Server*).'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '前端控制器模式的使用可以在`jdk.httpserver`模块、`sun.net.httpserver`包和`HttpServer`抽象类中找到。该类实现了接受`HttpHandler`接口的`createContext`抽象方法。处理器实例通过执行处理器方法参与HTTP请求处理。JDK
    18的发布附带了对底层`HttpServer`实现的`SimpleFileServer`包装器，也可以作为独立的命令`jwebserver`（*JEP-408:
    简单* *Web服务器*）。'
- en: Sample code
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例代码
- en: 'Let us create a simple theoretical example not focused on parsing the web request
    (*Example 4.15*):'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个简单的理论示例，不专注于解析网络请求（**示例4.15**）：
- en: '[PRE21]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Here’s the output:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是输出：
- en: '[PRE22]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Example 4.15 – The vehicle system uses the front-controller pattern to process
    incoming commands
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 示例4.15 – 车辆系统使用前端控制器模式处理传入的命令
- en: 'Imagine that vehicles contain a controller that is responsible for controlling
    brakes and motor units. All incoming commands are processed in this controller
    (*Figure 4**.8*):'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，车辆中包含一个控制器，该控制器负责控制制动器和电机单元。所有传入的命令都在这个控制器中处理（**图4.8**.8）：
- en: '![Figure 4.8 – The front-controller pattern enforces a loose coupling of the
    controller and dispatcher](img/B18884_04_08.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![图4.8 – 前端控制器模式强制控制器和调度器的松耦合](img/B18884_04_08.jpg)'
- en: Figure 4.8 – The front-controller pattern enforces a loose coupling of the controller
    and dispatcher
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.8 – 前端控制器模式强制控制器和调度器的松耦合
- en: 'The `VehicleController` object requires an instance of a specific handler.
    A handler is defined by an instance of the `RequestDispatcher` class (*Example
    4.16*):'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`VehicleController`对象需要一个特定处理器的实例。处理器由`RequestDispatcher`类的实例定义（**示例4.16**）：'
- en: '[PRE23]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Example 4.16 – The request handler representation RequestDispatcher instance
    needs to be injected into VehicleController
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 示例4.16 – 请求处理器表示`RequestDispatcher`实例需要注入到`VehicleController`
- en: Both the `BrakesUnit` and `EngineUnit` classes are separated from the handling
    or control logic and can be developed independently.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`BrakesUnit`和`EngineUnit`类都与处理或控制逻辑分离，可以独立开发。'
- en: Conclusion
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结论
- en: The main use of the front-controller pattern is in web frameworks, in addition
    to encapsulating requests for handling requests and increasing the portability
    of different types of handlers. These tools only need to be properly registered
    and run at runtime. Based on the implementation, the pattern supports dynamic
    handling behavior without the requirement to replace the class at runtime. The
    front-controller pattern introduces a centralized mechanism for processing incoming
    information.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 前端控制器模式的主要用途在于Web框架中，除了封装请求处理请求和增加不同类型处理器的可移植性。这些工具只需要在运行时正确注册并运行。根据实现，该模式支持动态处理行为，而不需要在运行时替换类。前端控制器模式引入了一种集中机制来处理传入的信息。
- en: Software design sometimes requires the dissemination of specific information
    for a group of classes. For such purposes, tagging is well worth considering.
    Let’s dive deeper into it in the next section.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 软件设计有时需要为类组传播特定信息。为此，标记是一个值得考虑的好方法。让我们在下一节深入探讨。
- en: Identifying instances using the marker pattern
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用标记模式识别实例
- en: This pattern is extremely useful in identifying instances at runtime for specific
    treatment, such as triggering the desired action when an instance is available.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式在运行时识别特定实例以进行特定处理时极为有用，例如在实例可用时触发所需操作。
- en: Motivation
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动机
- en: The marker interface pattern represents an empty interface. Such an interface
    is used to identify a special group of classes at runtime. Because of this fact,
    the maker pattern is sometimes called tagging, as its sole purpose is to distinguish
    a special type of instance. The application thus provides the possibility to use
    special handling for such cases at runtime. Logic can be separated and properly
    encapsulated. Because annotation represents a special form of interface, Java
    implements the marker interface in two ways – a class can inherit from an interface
    or be annotated.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 标记接口模式代表一个空接口。这种接口用于在运行时识别一组特殊的类。正因为如此，标记模式有时被称为标记，因为它的唯一目的是区分一种特殊的实例。因此，应用程序提供了在运行时对这些情况使用特殊处理的可能。逻辑可以分离并适当封装。由于注解代表一种特殊的接口形式，Java以两种方式实现标记接口——一个类可以继承接口或被注解。
- en: Finding it in the JDK
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在JDK中查找
- en: A clearer example of using the marker interface in the JDK can be found in the
    `java.base` module. The `java.io` package defines the `Serializable` interface
    and the `java.lang` package provides the `Cloneable` interface. Both do not implement
    any method, and both are used to inform the runtime about special handling. The
    `Serializable` interface is important during the serialization and deserialization
    processes (the `writeObject` and `readObject` methods), where each nested field
    requires an interface implementation to obtain the state of the instance while
    traversing the object graph. In a similar way, the `Cloneable` interface informs
    the JVM that the `Object.clone()` method is being used and it can create a field-to-field
    copy of the object. It is good to be aware of the field differences. The primitive
    types provide values but object-only references. It means that objects require
    an implementation of the `Cloneable` interface to provide a copy.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在`java.base`模块中可以找到一个更清晰的JDK中使用标记接口的例子。`java.io`包定义了`Serializable`接口，而`java.lang`包提供了`Cloneable`接口。这两个接口都没有实现任何方法，它们都用于通知运行时进行特殊处理。`Serializable`接口在序列化和反序列化过程中非常重要（`writeObject`和`readObject`方法），在遍历对象图时，每个嵌套字段都需要一个接口实现来获取实例的状态。以类似的方式，`Cloneable`接口通知JVM正在使用`Object.clone()`方法，并且它可以创建对象的字段到字段的复制。了解字段差异是很好的。原始类型提供值，但只有对象引用。这意味着对象需要一个`Cloneable`接口的实现来提供复制。
- en: Sample code
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例代码
- en: 'Let us draw a simple real-world example where a vehicle contains multiple sensors
    (*Figure 4**.9*):'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们举一个简单的现实世界例子，其中一辆车包含多个传感器（*图4.9*）：
- en: '![Figure 4.9 – UML class diagram of certified sensor tags (CertifiedSensor
    and CertifiedAnnotation) using the marker interface pattern](img/B18884_04_09.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![图4.9 – 使用标记接口模式的认证传感器标签（CertifiedSensor和CertifiedAnnotation）的UML类图](img/B18884_04_09.jpg)'
- en: Figure 4.9 – UML class diagram of certified sensor tags (CertifiedSensor and
    CertifiedAnnotation) using the marker interface pattern
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.9 – 使用标记接口模式的认证传感器标签（CertifiedSensor和CertifiedAnnotation）的UML类图
- en: 'The vehicle controller needs to identify special groups of the sensors that
    are certified for delivering specific information (*Example 4.17*):'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 车辆控制器需要识别那些被认证用于提供特定信息的特殊传感器组（*示例4.17*）：
- en: '[PRE24]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Here is the output:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是输出：
- en: '[PRE25]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Example 4.17 – The marker interface pattern for sensor identification using
    the switch pattern-matching construct
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 示例4.17 – 使用switch模式匹配结构的传感器识别的标记接口模式
- en: This example introduced both types of pattern usage. It defines the `CertifiedAnnotation`
    and `CertifiedSensor` interface.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子介绍了两种类型的模式使用。它定义了`CertifiedAnnotation`和`CertifiedSensor`接口。
- en: 'To group all sensor kinds during the implementation, the `Sensor` interface
    is used (*Example 4.18*):'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在实现过程中对所有的传感器种类进行分组，使用了`Sensor`接口（*示例4.18*）：
- en: '[PRE26]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Example 4.18 – Implementation of the tagging interfaces CertifiedAnnotation
    and CertifiedSensor, and Sensor abstraction with methods
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: 'Using tags is trivial. A class must be annotated or inherit the marker interface
    (*Example 4.19*):'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Example 4.19 – Marker usage for the sensor identification
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The marker interface pattern can be a powerful tool at runtime, but it must
    be used wisely as it can have some drawbacks. One is that the purpose of using
    the marker pattern may be forgotten, or it may become obsolete as the application
    evolves. The second is the implementation of special handling logic. Distributing
    such logic can negatively affect application behavior. On the other hand, a marker
    interface can simplify application logic, and in many cases, an interface is preferred
    over an annotation because it is more traceable.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: Let us introduce a vehicle unit’s modularity in the next pattern.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the concept of modules with the module pattern
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This pattern implements the concept of software modules defined by modular programming.
    The pattern is used in cases where the programming language does not have direct
    support for such a concept or the application requires it.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: Motivation
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This pattern can be implemented in several ways depending on the application
    requirements. The module pattern concentrates or encapsulates the composition
    of an application’s functionality into precisely identified modules. The Java
    platform has already implemented basic support for the module concept through
    the Jigsaw project, available since the release of JDK 9, but it is possible to
    try to create it programmatically in a similar way, although not entirely in isolation,
    as the source code can influence its modularization approach.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: Finding it in the JDK
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The best example that can be found in the JDK of the module pattern is the Java
    platform modules. This concept was discussed in great detail in [*Chapter 2*](B18884_02.xhtml#_idTextAnchor037),
    *Discovering the Java Platform for Design Patterns*, in the *Getting to grips
    with the Java Module* *System* section.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: Sample code
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let us imagine a vehicle that need to have isolated brakes and engine systems.
    This is pretty much according to a real-world scenario. Each module will operate
    independently, and only one provider is present at runtime. Before the vehicle
    can be used, both modules need to be activated (*Example 4.20*):'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Here’s the output:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Example 4.20 – The client function initModules activates the modules correctly
    in encapsulation
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram emphasizes the separation of modules, although the programmatic
    approach allows sharing or implementing shared abstractions (*Figure 4**.10*):'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.10 – UML class diagram showing a pattern implementation realized
    by the provided VehicleModule interface](img/B18884_04_10.jpg)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
- en: Figure 4.10 – UML class diagram showing a pattern implementation realized by
    the provided VehicleModule interface
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: 'Each module is represented as a singleton instance in order to ensure only
    one instance provides a transparent gateway to access the module functionality:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 每个模块都表示为一个单例实例，以确保只有一个实例提供对模块功能的透明网关：
- en: '[PRE30]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Example 4.21 – The EngineModule and BrakesModule example implementations are
    represented by singletons and have a similar structure
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 4.21 – EngineModule 和 BrakesModule 的示例实现以单例形式表示，具有相似的结构
- en: Conclusion
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结论
- en: The module pattern introduces structure to the source code in a very transparent
    way. Each module can be developed independently without influence. Because a programmatic
    solution may not fully enforce source code isolation, it is necessary to extend
    modules wisely. Another drawback may be module initialization, as a singleton
    may not be an acceptable solution. On the other hand, the module pattern provides
    a workflow to develop a source code with all SOLID concepts in mind.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 模块模式以非常透明的方式为源代码引入结构。每个模块可以独立开发，不受影响。由于程序性解决方案可能无法完全强制源代码隔离，因此有必要明智地扩展模块。另一个缺点可能是模块初始化，因为单例可能不是一个可接受解决方案。另一方面，模块模式提供了一种以所有
    SOLID 概念为前提开发源代码的工作流程。
- en: What about using proxies instead of modules and implementations? Let us dive
    deeper in the next section.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 关于使用代理而不是模块和实现，让我们在下一节深入探讨。
- en: Providing a placeholder for an object using the proxy pattern
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用代理模式为对象提供一个占位符
- en: The proxy pattern is considered a placeholder that manages access to another
    object in order to gain control of it. The pattern may also be known by the name
    surrogate. The proxy pattern was described by the GoF.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 代理模式被认为是一个占位符，用于管理对另一个对象的访问以控制它。该模式也被称为代理。代理模式由 GoF 描述。
- en: Motivation
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动机
- en: In its most general form, a proxy is a class acting as an interface to the client.
    A proxy is considered a wrapper or agent object that is used by a client. The
    client accesses the actual object through the same interface and the actual implementation
    stays hidden from the client in the background. Communication between the client
    and the implementation remains transparent, thanks to the proxy pattern.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在其最一般的形式中，代理是一个充当客户端接口的类。代理被认为是一个包装器或代理对象，由客户端使用。客户端通过相同的接口访问实际对象，而实际实现则在客户端背后保持隐藏。由于代理模式，客户端和实现之间的通信保持透明。
- en: By using a proxy, the client can access the actual object, or it can provide
    additional logic.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用代理，客户端可以访问实际对象，或者它可以提供额外的逻辑。
- en: Finding it in the JDK
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 JDK 中查找
- en: The proxy design pattern also has a place in the JDK. The most well-known one
    is the public `Proxy` class, which you can find in the `java.reflect` package
    of the `java.base` module. The `Proxy` class provides several static methods for
    creating objects used for method invocation.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 代理设计模式在 JDK 中也有其位置。最著名的是公共 `Proxy` 类，您可以在 `java.base` 模块的 `java.reflect` 包中找到它。`Proxy`
    类提供了几个静态方法用于创建用于方法调用的对象。
- en: Sample code
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例代码
- en: 'The given example can be considered as the remote control of a vehicle. A controller,
    represented by a proxy design pattern, provides exactly the same functionality
    as a real vehicle, also managing the connection between the real vehicle instance
    (*Example 4.22*):'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 给定的示例可以被视为车辆的遥控器。一个控制器，由代理设计模式表示，提供了与真实车辆完全相同的功能，同时也管理着真实车辆实例之间的连接（*示例 4.22*）：
- en: '[PRE31]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Here’s the output:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出：
- en: '[PRE32]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Example 4.22 – The VehicleProxy instance works like a real vehicle
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 4.22 – VehicleProxy 实例像真实车辆一样工作
- en: 'The real vehicle implementation is defined by the generic abstraction provided
    by the `Vehicle` interfaces (*Figure 4**.11*):'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 实际车辆实现由 `Vehicle` 接口提供的通用抽象定义（*图 4**.11*）：
- en: '![Figure 4.11 – An example of a vehicle proxy can be depicted by a UML class
    diagram](img/B18884_04_11.jpg)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.11 – 车辆代理的示例可以用 UML 类图表示](img/B18884_04_11.jpg)'
- en: Figure 4.11 – An example of a vehicle proxy can be depicted by a UML class diagram
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.11 – 车辆代理的示例可以用 UML 类图表示
- en: 'This allows seamlessly extending the types of controlled vehicles, as shown
    in the proxy pattern implementation (*Example 4.23*):'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许无缝地扩展受控车辆类型，如图 4.23 中代理模式实现所示：
- en: '[PRE33]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Example 4.23 – The VehicleProxy class contains a reference to the actual Vehicle
    instance
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 4.23 – VehicleProxy 类包含对实际 Vehicle 实例的引用
- en: Conclusion
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结论
- en: The proxy design pattern brings many advantages to the source code, for example,
    the implementation can be replaced at runtime. In addition to being used to fully
    control access to the actual instance, it can also be used for lazy initiation,
    as we saw in *Example 4.23*. The proxy has its legitimate place in driver implementation
    or network connections as it naturally enforces not only logging possibilities
    but also code separation through the segregation of the interfaces and other SOLID
    principles. It is useful to consider when an application requires I/O operations.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: Java as a language does not support multiple inheritance, but it is still possible
    to achieve. Let us examine how in the next section.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: Discovering multiple inheritance in Java with the twin pattern
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This pattern allows you to combine functions of objects that tend to be used
    together, which is a common paradigm used by languages without multiple inheritance
    support.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: Motivation
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The twin pattern presents the possibility to implement multiple inheritance
    in Java. Multiple inheritance is not a supported concept as it may lead to compiler
    inconsistency, known as the diamond problem. The diamond problem defines a state
    through class abstraction where the compiler may turn out to be inconsistent.
    This state is due to the lack of information due to multiple abstract classes.
    The compiler does not have enough information about which methods should execute.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: Sample code
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This pattern is not supported by the platform and is rarely required for development.
    For these reasons, the pattern most likely does not exist inside the released
    JDK, as described. However, let us examine a possible example to better understand
    the pattern. Imagine the vehicle initiation sequence. During initiation, the engine
    and brake units need to be initiated together. In other words, when the engine
    is initiated, the brakes must be initiated too, and the other way around (*Example
    4.24*):'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Here’s the output:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Example 4.24 – The twin pattern gives a guarantee that both units are always
    initiated
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows us tight coupling between units:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.12 – Both considered units, VehicleEngine and VehicleBrakes, are
    very closely coupled](img/B18884_04_12.jpg)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
- en: Figure 4.12 – Both considered units, VehicleEngine and VehicleBrakes, are very
    closely coupled
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: 'The coupling also translates into a code base that can be very fragile for
    future development (*Example 4.25*):'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Example 4.25 – The VehicleBrakes class implementation shows a tight coupling
    with its twin, VehicleEngine
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The twin pattern can be used to achieve multiple inheritance in Java. It must
    be used wisely, as a logical unwritten requirement is to guarantee complete separation
    of the objects under consideration. In other words, the twin design pattern allows
    twins to function as a single instance with extended functionality and features.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Knowledge of structural patterns along with newly added Java syntax enhancements
    not only improves maintainability but also enforces all previously learned OOP
    concepts and improves responsiveness to potential deviations in code behavior
    such as exceptions, unexpected crashes, or logical issues.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 对结构模式的知识以及新增的Java语法增强不仅提高了可维护性，还强制执行了所有之前学习的面向对象概念，并提高了对代码行为潜在偏差（如异常、意外崩溃或逻辑问题）的响应能力。
- en: We built a solid foundation through the examples in this chapter and learned
    how to use the adapter pattern to create collaboration between mutually incompatible
    objects, and also how to transparently separate an object’s implementation from
    its abstraction using the bridge pattern. The composite pattern presented a way
    to organize and wrap objects into a tree structure around the underlying business
    logic. We investigated the possibility of expanding an object’s functionality
    by using the decorator pattern. A way to simplify communication between objects
    was presented by the facade pattern, followed by the filter pattern, which allows
    us to select only the instances we want. We learned how the flyweight design pattern
    allows us to re-use already created runtime instances, and the approach of processing
    the incoming information was presented by the front-controller pattern, so that
    the client can only respond to valid requests. We discovered how the marker pattern
    allows a client to handle a specific group of objects in a unique way. We explored
    the possibility of modularizing the code base by implementing the module pattern.
    We saw how to use the proxy pattern to let a client indirectly gain control of
    an object without being aware of its implementation details, and we saw how to
    use the twin pattern to implement multiple inheritance in Java even though the
    language does not support it.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章中的示例，我们建立了坚实的基础，学习了如何使用适配器模式在互不兼容的对象之间建立协作，以及如何使用桥接模式透明地分离一个对象的实现与其抽象。组合模式提供了一种将对象组织并包装成围绕底层业务逻辑的树结构的方法。我们研究了通过使用装饰器模式扩展对象功能的可能性。门面模式提供了一种简化对象间通信的方法，随后是过滤器模式，它允许我们仅选择我们想要的实例。我们学习了如何使用享元设计模式来复用已创建的运行时实例，以及通过前端控制器模式处理传入信息的方法，这样客户端只能对有效的请求做出响应。我们发现如何使用标记模式以独特的方式让客户端处理一组特定的对象。我们探讨了通过实现模块模式模块化代码库的可能性。我们看到了如何使用代理模式让客户端在不了解其实施细节的情况下间接控制对象，以及如何使用双生模式在Java中实现多重继承，尽管该语言不支持它。
- en: With the knowledge gained about creational and structural design patterns, the
    underlying source code structure is well organized and open to continuous application
    development. The next chapter examines the behavioral design patterns that help
    organize communication and responsibilities between targeted instances.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 通过对创建型和结构设计模式的知识积累，底层源代码结构得到了良好的组织，并便于持续的应用开发。下一章将探讨行为设计模式，这些模式有助于组织目标实例之间的通信和责任。
- en: Questions
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What challenges do structural design patterns solve?
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 结构设计模式解决了哪些挑战？
- en: Which structural design patterns are described by the Gang of Four?
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 四人帮描述了哪些结构设计模式？
- en: Which design pattern is appropriate for creating a tree structure of related
    objects?
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪种设计模式适用于创建相关对象的树结构？
- en: Which structural design pattern can be used to identify an object at runtime?
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪种结构设计模式可以在运行时识别一个对象？
- en: Which design pattern can be used for indirect object access, with the same functionality
    of the object itself?
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪种设计模式可以用于间接访问对象，同时具有与对象本身相同的功能？
- en: Which design pattern promotes the separation of logic from its abstraction?
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪种设计模式促进了逻辑与其抽象的分离？
- en: Further reading
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*Design Patterns: Elements of Reusable Object-Oriented Software* by Erich Gamma,
    Richard Helm, Ralph Johnson, and John Vlissides, Addison-Wesley, 1995'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides 所著的 *《设计模式：可复用面向对象软件元素》*，Addison-Wesley，1995年
- en: '*Design Principles and Design Patterns* by Robert C. Martin, Object Mentor,
    2000'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Robert C. Martin 所著的 *《设计原则与设计模式》*，Object Mentor，2000年
- en: '*JSR-376: Java Platform Module* *System*, [https://openjdk.java.net/projects/jigsaw/spec/](https://openjdk.java.net/projects/jigsaw/spec/)'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*JSR-376: Java 平台模块* *系统*, [https://openjdk.java.net/projects/jigsaw/spec/](https://openjdk.java.net/projects/jigsaw/spec/)'
- en: '*JSR-408: Simple Web* *Server*, [https://openjdk.org/jeps/408](https://openjdk.org/jeps/408)'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*JSR-408: 简单 Web* *服务器*, [https://openjdk.org/jeps/408](https://openjdk.org/jeps/408)'
- en: '*Clean Code* by Robert C. Martin, Pearson Education, Inc, 2009'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《代码整洁之道》* by Robert C. Martin, Pearson Education, Inc, 2009'
- en: '*Effective Java – Third edition* by Joshua Bloch, Addison-Wesley, 2018'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《有效Java – 第三版》* by Joshua Bloch, Addison-Wesley, 2018'
- en: '*Twin – A Design Pattern for Modelling Multiple Inheritance*, Hanspeter Mössenböck,
    University of Linz, Institute for System Software, 1999, [https://ssw.jku.at/Research/Papers/Moe99/Paper.pdf](https://ssw.jku.at/Research/Papers/Moe99/Paper.pdf)'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《双胞胎 – 多重继承建模设计模式》* by Hanspeter Mössenböck, 林茨大学，系统软件研究所，1999, [https://ssw.jku.at/Research/Papers/Moe99/Paper.pdf](https://ssw.jku.at/Research/Papers/Moe99/Paper.pdf)'
