<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Consideration of Structural and Behavioral Patterns</h1>
                </header>
            
            <article>
                
<p>You have seen implementations and examples of the creational design pattern from the GOF pattern family in <a href="75fe3bc7-3b5a-4e07-9915-73a0fd8a8ef2.xhtml" target="_blank">Chapter 2</a>, <em>Overview of GOF Design Patterns - Core Design Patterns.</em> Now, in this chapter, you'll be given an overview of other parts of GOF Design Patterns, they are the structural and behavioral design patterns, including some best practices for application design. You'll also get an overview of common problem solving with these design patterns.</p>
<p>At the end of this chapter, you will understand how these design patterns provide the best solution to address the design and development related issues in the object composition and delegating responsibilities between the working objects in the application. You will get information about how the Spring Framework implements the structural and behavioral designs pattern internally to provide best enterprise solutions.</p>
<p>This chapter will cover the following points:</p>
<ul>
<li>Implementing the structural design patterns</li>
<li>Implementing the behavioral design patterns</li>
<li>J2EE design patterns</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Examining the core design patterns</h1>
                </header>
            
            <article>
                
<p>Let's continue our journey into the core design patterns:</p>
<ul>
<li><strong>Structural design pattern</strong>: Patterns under this category deal with the composition of classes or objects. In the enterprise application, there are two common techniques for reusing functionality in object-oriented systems as follows:
<ul>
<li><strong>Inheritance</strong>: It is used to inherit commonly used states and behaviors from other classes.</li>
<li><strong>Composition</strong>: It is used to compose the other objects as instance variables of classes. It defines ways to compose objects to obtain new functionalities.</li>
</ul>
</li>
<li><strong>Behavioral design pattern</strong>: Patterns under this category characterize the ways in which classes or objects interact with and distribute responsibility. These patterns define the methods of communication between the objects in the enterprise application. So here, you will learn how to use behavioral patterns to reduce complicated flow control. Furthermore, you will use behavioral patterns to encapsulate algorithms and dynamically select them at runtime.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Structural design patterns</h1>
                </header>
            
            <article>
                
<p>In the previous section, we discussed creational design patterns and how they provide the best solutions for object creation according to business demands. Creational design patterns only provide a solution for creating objects in the application with how these objects merge with each other in the application for a specific business goal, the structural design pattern comes into the picture. In this chapter, we will be exploring structural patterns, and how these patterns are useful to define the relationship between the objects either using inheritance or composition for larger structures of an application. Structural patterns allow you to solve many problems related to structuring the relationship between the objects. They show you how to glue different parts of a system together in a flexible and extensible fashion. Structural patterns help you guarantee that when one of the parts changes, the entire structure does not need to change; in a car you could replace the tyres with different vendors without impacting the other parts of that car. They also show you how to recast parts of the system that do not fit (but that you need to use) into parts that do fit.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The adapter design pattern</h1>
                </header>
            
            <article>
                
<div class="packt_quote">Convert the interface of a class into another interface clients expect. Adapter lets classes work together that couldn't otherwise because of incompatible interfaces.<br/>
-GoF Design Patterns: Elements of Reusable Object-Oriented Software</div>
<p>Adapter design patterns come under the structural design pattern, according to this design pattern two incompatible classes work together that couldn't otherwise because of incompatible interfaces. This pattern works as a bridge between two incompatible interfaces. This pattern is used when two inferences of the application are incompatible in their functionalities, but these functionalities need to be integrated as a business requirement.</p>
<p class="CDPAlignCenter CDPAlign CDPAlignLeft">There are many real-life examples where we can use the adapter pattern. Suppose you have different types of electric plugs such as cylindrical and rectangular plugs, as shown in the following figure. You can use an adapter in between to fit a rectangular plug in a cylindrical socket assuming voltage requirements are met:</p>
<div class="CDPAlignCenter CDPAlign"><br/>
<img height="158" width="369" src="assets/5000d228-a61c-4e20-b993-7e743f469815.jpg"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Benefits of the adapter pattern</h1>
                </header>
            
            <article>
                
<p>Let's look at the following benefits of using the adapter design pattern in the application.</p>
<ul>
<li>The adapter pattern allows you to communicate and interact with two or more incompatible objects</li>
<li>This pattern promotes the reusability of older existing functionalities in your application</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Common requirements for the adapter pattern</h1>
                </header>
            
            <article>
                
<p>The following are the common requirements for this design pattern to addresses the design problems:</p>
<ul>
<li>If you are to use this pattern in your application, there is a need to use an existing class with an incompatible interface.</li>
<li>Another use of this pattern in your application is when you want to create a reusable class that collaborates with classes that have incompatible interfaces.</li>
<li>There are several existing subclasses to be used, but it's impractical to adapt their interface by sub classing each one. An object adapter can adapt the interface of its parent class.</li>
</ul>
<p>Let's see how Spring implements the adapter design pattern internally.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementation of the adapter design pattern in the Spring Framework</h1>
                </header>
            
            <article>
                
<p>Spring Framework uses the adapter design pattern to implement a lot of functionality across the framework transparently. The following are some listed classes based on the <span>adapter design pattern</span> in the Spring Framework:</p>
<ul>
<li><kbd>JpaVendorAdapter</kbd></li>
<li><kbd>HibernateJpaVendorAdapter</kbd></li>
<li><kbd>HandlerInterceptorAdapter</kbd></li>
<li><kbd>MessageListenerAdapter</kbd></li>
<li><kbd>SpringContextResourceAdapter</kbd></li>
<li><kbd>ClassPreProcessorAgentAdapter</kbd></li>
<li><kbd>RequestMappingHandlerAdapter</kbd></li>
<li><kbd>AnnotationMethodHandlerAdapter</kbd></li>
<li><kbd>WebMvcConfigurerAdapter</kbd></li>
</ul>
<p><strong>The UML diagram for the adapter pattern</strong></p>
<p><span>Let's understand the preceding</span> UML diagram that illustrates the components of the adapter design pattern:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/d434b73f-a719-4594-a789-0f07fdfa5ccb.jpg"/></div>
<ul>
<li><strong>The Target Interface</strong>: This is the desired interface class that will be used by the clients</li>
<li><strong>The Adapter class</strong>: This class is a wrapper class that implements the desired target interface and modifies the specific request available from the Adaptee class</li>
<li><strong>The Adaptee class</strong>: This is the class that is used by the Adapter class to reuse the existing functionalities and modify them for desired use</li>
<li><strong>Client</strong>: This class will interact with the Adapter class</li>
</ul>
<p>Let's look at the following sample implementation of the adapter design pattern.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Sample implementation of the adapter design pattern</h1>
                </header>
            
            <article>
                
<p>I am going to create an example that shows the actual demonstration of the adapter design pattern, so let's discuss this example, I am creating this example based on making payment through a payment gateway. Suppose I have one old payment gateway and also have the latest advanced payment gateway, and both gateways are unrelated to each other, so my requirement is, I want to migrate from the old payment gateway to an advanced payment gateway while changing my existing source code. I am creating an adapter class to solve this problem. This adapter class is working as a bridge between two different payment gateways, let's look at the following code:</p>
<p>Let's now create an interface for the old payment gateway:</p>
<pre>    package com.packt.patterninspring.chapter3.adapter.pattern; 
    import com.packt.patterninspring.chapter3.model.Account; 
    public interface PaymentGateway { 
      void doPayment(Account account1, Account account2); 
    } </pre>
<p>Let's now create an implementation class for the old payment gateway <kbd>PaymentGateway.java</kbd>:</p>
<pre>    package com.packt.patterninspring.chapter3.adapter.pattern; 
    import com.packt.patterninspring.chapter3.model.Account; 
    public class PaymentGatewayImpl implements PaymentGateway{ 
      @Override 
      public void doPayment(Account account1, Account account2){ 
         System.out.println("Do payment using Payment Gateway"); 
      } 
    } </pre>
<p>The following interface and its implementation have new and advanced functionalities for the payment gateway:</p>
<pre>    package com.packt.patterninspring.chapter3.adapter.pattern; 
    public interface AdvancedPayGateway { 
      void makePayment(String mobile1, String mobile2); 
    } </pre>
<p>Let's now create an implementation class for the advance payment gateway interface:</p>
<pre>    package com.packt.patterninspring.chapter3.adapter.pattern; 
    import com.packt.patterninspring.chapter3.model.Account; 
    public class AdvancedPaymentGatewayAdapter implements <br/>       AdvancedPayGateway{ 
      private PaymentGateway paymentGateway; 
      public AdvancedPaymentGatewayAdapter(PaymentGateway<br/>         paymentGateway) { 
        this.paymentGateway = paymentGateway; 
      } 
      public void makePayment(String mobile1, String mobile2) { 
         Account account1 = null;//get account number by <br/>             mobile number mobile  
         Account account2 = null;//get account number by <br/>            mobile number mobile  
         paymentGateway.doPayment(account1, account2); 
      } 
    } </pre>
<p>Let's see a demo class for this pattern as follows:</p>
<pre>    package com.packt.patterninspring.chapter3.adapter.pattern; 
    public class AdapterPatternMain { 
      public static void main(String[] args) { 
        PaymentGateway paymentGateway = new PaymentGatewayImpl(); 
        AdvancedPayGateway advancedPayGateway = new <br/>           AdvancedPaymentGatewayAdapter(paymentGateway); 
        String mobile1 = null; 
        String mobile2 = null; 
        advancedPayGateway.makePayment(mobile1, mobile2); 
      } 
    } </pre>
<p>In the preceding class, we have the old payment gateway object as the <kbd>PaymentGateway</kbd> interface, but we convert this old payment gateway implementation to the advanced form of the payment gateway by using the <kbd>AdvancedPaymentGatewayAdapter</kbd> adapter class. Let's run this demo class and see the output as follows:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/a227c50d-f5fc-4ab5-8d81-13819b77e63d.png"/></div>
<p>Now that we've seen the adapter design pattern, let's turn to a different variant of it--the Bridge design pattern.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Bridge design pattern</h1>
                </header>
            
            <article>
                
<div class="packt_quote">Decouple an abstraction from its implementation so that the two can vary independently<br/>
- GoF Design Patterns: Elements of Reusable Object-Oriented Software</div>
<p>In software engineering, one of the most popular notions is preferred composition over inheritance. Bridge design pattern promotes this popular notion. Similar to the adapter pattern, this pattern also comes under the structural design pattern family of the GoF Design Pattern. The approach of the Bridge pattern is to decouple an abstraction used by the client code from its implementation; that means it separates the abstraction and its implementation in to separate class hierarchies. And also, Bridge pattern prefers composition over inheritance because inheritance isn't always flexible and it breaks the encapsulation, so any change made in the implementer affects the abstraction used by the client code.</p>
<p>The bridge provides a way to communicate between two different independent components in software development, and a bridge structure provides you with a way to decouple the abstract class and the implementer class. So any change made in either the implementation class or the implementer (that is, the interface) doesn't affect the abstract class or its refined abstraction class. It makes this possible by using composition between the interface and the abstraction. Bridge pattern uses an interface as a bridge between the concrete classes of an abstract class and implementing classes of that interface. You can make changes in both types of class without any impact on the client code.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Benefits of the Bridge pattern</h1>
                </header>
            
            <article>
                
<p>Following are the benefits of the Bridge design pattern:</p>
<ul>
<li>The Bridge design pattern allows you to separate the implementation and the abstraction</li>
<li>This design pattern provides the flexibility to change both types of classes without side effects in the client code</li>
<li>This design pattern allows the hiding of actual implementation details from the client by using abstraction between them</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Common problems solved by the Bridge design pattern</h1>
                </header>
            
            <article>
                
<p>Following are the common problems addressed by the Bridge design pattern:</p>
<ul>
<li>Removes a permanent binding between the functional abstraction and its implementation</li>
<li>You can make changes to the implementing classes without affecting the abstraction and client code</li>
<li>You can extend the abstraction and its implementation using subclasses</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementing the Bridge design pattern in the Spring Framework</h1>
                </header>
            
            <article>
                
<p>The following Spring modules are based on the Bridge design pattern:</p>
<ul>
<li><kbd>ViewRendererServlet</kbd>: It is a bridge servlet, mainly for Portlet MVC support</li>
<li><strong>The Bridge design pattern</strong>: The Bridge design pattern is used in the Spring logging process</li>
</ul>
<p>Let's see a sample implementation of the Bridge design pattern.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Sample implementation of the Bridge design pattern</h1>
                </header>
            
            <article>
                
<p>Let's look at the following example, where we will demonstrate the use of the Bridge design pattern. Suppose you want to open two types of accounts, one is a Savings Account and the other is a Current Account in the banking system.</p>
<p class="mce-root"><strong>System without using the Bridge design pattern</strong></p>
<p>Let's look at an example without using the Bridge design pattern. In the following figure, you can see the relationship between the Bank and Account interfaces:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="142" width="407" src="assets/88b1a26b-0da1-4c49-8017-c40a7e3c6a19.png"/></div>
<div class="packt_figure packt_figref CDPAlignCenter CDPAlign">System without using the Bridge design pattern</div>
<p>Let's create a design without using the Bridge design pattern. First create an interface or an abstract class, <strong>Bank</strong>. And then create its derived classes: <strong>IciciBank</strong> and <strong>HdfcBank</strong>. To open an account in the bank, first decide on the types of account classes--<strong>Saving Account</strong> and <strong>Current Account</strong>, these classes extend the specific banks classes (<strong>HdfcBank</strong> and <strong>IciciBank</strong>). There is a simple deep inheritance hierarchy in this application. So what is wrong with this design as compared to the preceding figure? You will notice that in this design, there are two parts, one is the abstraction part and the other is the implementation part. Client code interacts with the abstraction part. Client code can only access new changes or new functionalities of the implementation part when you will update the abstraction part, meaning the parts, the abstraction, and the implementation, are tightly coupled with each other.</p>
<p>Now let's see how to improve this example using the Bridge design pattern:</p>
<p class="mce-root"><strong>System with the Bridge design pattern</strong></p>
<p>In the following figure, we create a relation between the <kbd>Bank</kbd> and <kbd>Account</kbd> interface by using the Bridge design pattern:</p>
<div class="CDPAlignCenter CDPAlign"><img height="99" width="406" src="assets/90bfdc00-6b6a-42f8-89b2-334f66690e3b.png"/></div>
<div class="packt_figure packt_figref CDPAlignCenter CDPAlign">System using Bridge Design Pattern</div>
<p><strong>UML structure for the Bridge design pattern</strong></p>
<p>Let's look at the following figure of how the Bridge design pattern solves these design issues, as seen in the example where we did not use the Bridge design pattern. Bridge pattern separates the abstraction and implementation into two class hierarchies:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="218" width="333" class=" image-border" src="assets/219a9390-0d2f-4746-97f8-d85e68e87b2c.png"/></div>
<div class="packt_figure packt_figref CDPAlignCenter CDPAlign">UML for Bridge design pattern</div>
<p>We have an <kbd>Account</kbd> interface that is acting as a bridge implementer and the concrete classes <kbd>SavingAccount</kbd>, and <kbd>CurrentAccount</kbd> implementing the Account interface. The <kbd>Bank</kbd> is an abstract class and it will use object of Account.</p>
<p>Let's create a bridge implementer interface.</p>
<p>Following is the <kbd>Account.java</kbd> file:</p>
<pre>    package com.packt.patterninspring.chapter3.bridge.pattern; 
    public interface Account { 
      Account openAccount(); 
      void accountType(); 
    } </pre>
<p>Create concrete bridge implementer classes to implement the <kbd>implementer</kbd> interface. Let's create a <kbd>SavingAccount</kbd> class as an implementation of <kbd>Account</kbd>.</p>
<p>Following is the <kbd>SavingAccount.java</kbd> file:</p>
<pre>    package com.packt.patterninspring.chapter3.bridge.pattern; 
    public class SavingAccount implements Account { 
      @Override 
      public Account openAccount() { 
         System.out.println("OPENED: SAVING ACCOUNT "); 
         return new SavingAccount(); 
      } 
      @Override 
      public void accountType() { 
        System.out.println("##It is a SAVING Account##"); 
      } 
    } </pre>
<p>Create a <kbd>CurrentAccount</kbd> class that implements the <kbd>Account</kbd> interface.</p>
<p>Following is the <kbd>CurrentAccount.java</kbd> file:</p>
<pre>    package com.packt.patterninspring.chapter3.bridge.pattern; 
    public class CurrentAccount implements Account { 
      @Override 
      public Account openAccount() { 
        System.out.println("OPENED: CURRENT ACCOUNT "); 
        return new CurrentAccount(); 
      } 
      @Override 
      public void accountType() { 
        System.out.println("##It is a CURRENT Account##"); 
      } 
    } </pre>
<p>Create abstraction in the Bridge design pattern, but first, create the interface <strong>Bank</strong>.</p>
<p>Following is the <kbd>Bank.java</kbd> file:</p>
<pre>    package com.packt.patterninspring.chapter3.bridge.pattern; 
    public abstract class Bank { 
      //Composition with implementor 
      protected Account account; 
      public Bank(Account account){ 
         this.account = account; 
      } 
      abstract Account openAccount(); 
    } </pre>
<p>Let's implement the first abstraction for the <kbd>Bank</kbd> interface and see the following implementation class for the <kbd>Bank</kbd> interface.</p>
<p>Following is the <kbd>IciciBank.java</kbd> file:</p>
<pre>    package com.packt.patterninspring.chapter3.bridge.pattern; 
    public class IciciBank extends Bank { 
      public IciciBank(Account account) { 
        super(account); 
      } 
      @Override 
      Account openAccount() { 
        System.out.print("Open your account with ICICI Bank"); 
        return account; 
      } 
    } </pre>
<p>Let's implement the second abstraction for the <kbd>Bank</kbd> interface and look at the following implementation class for the <kbd>Bank</kbd> interface.</p>
<p>Following is the <kbd>HdfcBank.java</kbd> file:</p>
<pre>    package com.packt.patterninspring.chapter3.bridge.pattern; 
      public class HdfcBank extends Bank { 
        public HdfcBank(Account account) { 
          super(account); 
        } 
        @Override 
        Account openAccount() { 
          System.out.print("Open your account with HDFC Bank"); 
          return account; 
        } 
      } </pre>
<p>Create a demonstration class of the Bridge design pattern.</p>
<p>Following is the <kbd>BridgePatternMain.java</kbd> file:</p>
<pre>    package com.packt.patterninspring.chapter3.bridge.pattern; 
    public class BridgePatternMain { 
      public static void main(String[] args) { 
         Bank icici = new IciciBank(new CurrentAccount()); 
         Account current = icici.openAccount(); 
         current.accountType(); 
         Bank hdfc = new HdfcBank(new SavingAccount()); 
         Account saving = hdfc.openAccount(); 
         saving.accountType(); 
      } 
    } </pre>
<p>Let's run this demo class and see the following output in the console:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="89" width="449" class=" image-border" src="assets/478f1615-93b0-45d3-9a2d-15b422ed5002.png"/></div>
<p>Now that we've seen the Bridge design pattern, let's turn to a different variant of it--the composite design pattern.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Composite design pattern</h1>
                </header>
            
            <article>
                
<div class="packt_quote">Compose objects into tree structures to represent part-whole hierarchies. Composite lets clients treat individual objects and compositions of objects uniformly.<br/>
-GoF Design Patterns</div>
<p>In software engineering, the composite pattern comes under the structural design pattern. According to this pattern, a group of objects of the same type are treated as a single object by the client. The idea behind the Composite design pattern is to compose a set of objects into a tree structure to represent a module of a larger structural application. And this structure for clients is a single unit or instance uniformly.</p>
<p>The motivation behind the Composite design pattern is that objects in the system are grouped into the tree structure, and a tree structure is a combination of the node-leaf and branches. In the tree structure, nodes have a number of leaves and other nodes. Leaf doesn't have anything, which means there is no child of leaf in the tree. Leaf is treated as the end point of tree-structured data.</p>
<p>Let's look at the following figure, which represents data in the tree structure in the form of node and leaf:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="166" width="300" class=" image-border" src="assets/31cc8e59-1456-460a-980b-8e1c4547f63b.png"/></div>
<div class="packt_figure packt_figref CDPAlignCenter CDPAlign">Tree structured data using nodes and leaves</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Common problems solved by the composite pattern</h1>
                </header>
            
            <article>
                
<p>As a developer, it is more difficult to design an application so that the client can access your objects uniformly across the application, even if that object was a composition of objects or an individual object. This design pattern resolves difficulties and allows you to design objects in such a way that you can use that object as a composition of objects and a single individual object.</p>
<p>This pattern solves the challenges faced when creating hierarchical tree structures to provide clients with a uniform way to access and manipulate objects in the tree. The composite pattern is a good choice; it is less complex in this situation to treat primitives and composites as homogeneous.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">UML structure of the Composite design pattern</h1>
                </header>
            
            <article>
                
<p>Composite design pattern is based on the composition of similar types of objects into the tree structure, as you know that each tree has three main parts branch, node, and leaf. So let's have a look at the following terms used in this design pattern.</p>
<p><strong>Component</strong>: It is basically a branch of the tree and the branch has other branches, nodes, and leaves. Component provides the abstraction for all components, including composite objects. In the composition pattern, component <strong>is</strong> basically declared as an interface for objects.</p>
<p><strong>Leaf</strong>: <span>It is an object that implements all component methods.</span></p>
<p><strong>Composite</strong>: It is represented as a node in the tree structure, it has other nodes and leaves, and it represents a composite component. It has methods to add the children, that is, it represents a collection of the same type of objects. It has other component methods for its children.</p>
<p>Let's look at the following UML diagram for this design pattern:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="239" width="370" class=" image-border" src="assets/1d30f74d-8cb9-467d-8960-00ff63b5ae13.png"/></div>
<div class="packt_figure packt_figref CDPAlignCenter CDPAlign">UML diagram for the Composite Design Pattern</div>
<p><strong>Benefits of the Composite design pattern</strong></p>
<ul>
<li>This pattern provides the flexibility to add new component to process dynamically, with change in the existing components</li>
<li>This pattern allows you to create a class hierarchy that contains individual and composite objects</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Sample implementation of the Composite design pattern</h1>
                </header>
            
            <article>
                
<p>In the following example, I am implementing an <kbd>Account</kbd> interface, which can be either a <kbd>SavingAccount</kbd> and <kbd>CurrentAccount</kbd> or a composition of several accounts. I have a <kbd>CompositeBankAccount</kbd> class, which acts as a composite pattern actor class. Let's look at the following code for this example.</p>
<p>Create an <kbd>Account</kbd> interface that will be treated as a component:</p>
<pre>    public interface Account { 
      void accountType(); 
    } </pre>
<p>Create a <kbd>SavingAccount</kbd> class and <kbd>CurrentAccount</kbd> class as an implementation of the component and that will also be treated as a leaf:</p>
<p>Following is the <kbd>SavingAccount.java</kbd> file:</p>
<pre>    public class SavingAccount implements Account{ 
      @Override 
      public void accountType() { 
        System.out.println("SAVING ACCOUNT"); 
      } 
    } </pre>
<p>Following is the <kbd>CurrentAccount.java</kbd> file:</p>
<pre>    public class CurrentAccount implements Account { 
      @Override 
      public void accountType() { 
         System.out.println("CURRENT ACCOUNT"); 
      } 
    } </pre>
<p>Create a <kbd>CompositeBankAccount</kbd> class that will be treated as a Composite and implements the <kbd>Account</kbd> interface:</p>
<p>Following is the <kbd>CompositeBankAccount.java</kbd> file:</p>
<pre>     package com.packt.patterninspring.chapter3.composite.pattern; 
     import java.util.ArrayList; 
     import java.util.List; 
     import com.packt.patterninspring.chapter3.model.Account; 
     public class CompositeBankAccount implements Account { 
       //Collection of child accounts. 
       private List&lt;Account&gt; childAccounts = new ArrayList&lt;Account&gt;(); 
       @Override 
       public void accountType() { 
         for (Account account : childAccounts) { 
               account.accountType(); 
         } 
       } 
       //Adds the account to the composition. 
          public void add(Account account) { 
            childAccounts.add(account); 
          } 
          //Removes the account from the composition. 
          public void remove(Account account) { 
            childAccounts.remove(account); 
         } 
       } </pre>
<p>Create a <kbd>CompositePatternMain</kbd> class that will also be treated as a Client:</p>
<p>Following is the <kbd>CompositePatternMain.java</kbd> file:</p>
<pre>    package com.packt.patterninspring.chapter3.composite.pattern; 
    import com.packt.patterninspring.chapter3.model.CurrentAccount; 
    import com.packt.patterninspring.chapter3.model.SavingAccount; 
    public class CompositePatternMain { 
      public static void main(String[] args) { 
         //Saving Accounts 
         SavingAccount savingAccount1 = new SavingAccount(); 
         SavingAccount savingAccount2 = new SavingAccount(); 
         //Current Account 
         CurrentAccount currentAccount1 = new CurrentAccount(); 
         CurrentAccount currentAccount2 = new CurrentAccount(); 
         //Composite Bank Account 
         CompositeBankAccount compositeBankAccount1 = new<br/>         CompositeBankAccount(); 
         CompositeBankAccount compositeBankAccount2 = new<br/>         CompositeBankAccount(); 
         CompositeBankAccount compositeBankAccount = new<br/>         CompositeBankAccount(); 
         //Composing the bank accounts 
         compositeBankAccount1.add(savingAccount1); 
         compositeBankAccount1.add(currentAccount1); 
         compositeBankAccount2.add(currentAccount2); 
         compositeBankAccount2.add(savingAccount2); 
         compositeBankAccount.add(compositeBankAccount2); 
         compositeBankAccount.add(compositeBankAccount1); 
         compositeBankAccount.accountType(); 
      } 
    } </pre>
<p>Let's run this demo class and see the following output at the console:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="119" width="219" class=" image-border" src="assets/42f4f28b-863a-4bf9-95ab-b0bbe993d9ee.png"/></div>
<p>Now that we have discussed the composite design pattern, let's turn to the decorator design pattern.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Decorator design pattern</h1>
                </header>
            
            <article>
                
<div class="packt_quote">Attach additional responsibilities to an object dynamically. Decorators provide a flexible alternative to sub classing for extending functionality.<br/>
- GOF Design Pattern</div>
<p>In software engineering, the common intent of all GOF structural patterns is to simplify the complex relationship between objects and classes in a flexible enterprise application. The decorator pattern is a special type of design pattern among these that comes under the structural design pattern, which allows you to add and remove behaviors for an individual object at runtime dynamically or statically, without changing the existing behavior of other associated objects from the same class. This design pattern does this without violating the Single Responsibility Principle or the SOLID principle of object-oriented programming.</p>
<p>This design pattern uses the compositions over the inheritance for objects associations; it allows you to divide the functionality into different concrete classes with a unique area of concern.</p>
<p><strong>Benefits of the Decorator design pattern</strong></p>
<ul>
<li>This pattern allows you to extend functionality dynamically and statically without altering the structure of existing objects</li>
<li>By using this pattern, you could add a new responsibility to an object dynamically</li>
<li>This pattern is also known as <strong><strong>Wrapper</strong></strong></li>
<li>This pattern uses the compositions for object relationships to maintain SOLID principles</li>
<li>This pattern simplifies coding by writing new classes for every new specific functionality rather than changing the existing code of your application</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Common problems solved by the Decorator pattern</h1>
                </header>
            
            <article>
                
<p>In an enterprise application, there is a business requirement or there might be a future plan to extend the behavior of the product by adding new functionalities. To achieve this, you could use inheritance to extend the behavior of an object. But inheritance should be done at compile time and methods are also available for other instances of that class. Because of the code modification, there is a violation of the Open Closed Principle. To avoid this violation of the SOLID principle, you can attach new responsibility to an object dynamically. This is the situation where the decorator design pattern comes into the picture and addresses this issue in a very flexible way. Let's look at the following example of how to implement this design pattern into a real case study.</p>
<p>Consider that a bank offers multiple accounts with different benefits to customers. It divides the customers into three categories--senior citizens, privileged, and young. The bank launches a scheme on the savings account for senior citizens--if they open a savings account in this bank, they will be provided medical insurance of up to $1,000. Similarly, the bank also provides a scheme for the privileged customers as an accident insurance of up to $1,600 and an overdraft facility of $84. There is no scheme for the young.</p>
<p>To address the new requirement, we can add new subclasses of <kbd>SavingAccount</kbd>; one each to represent a saving account with additional benefits as decoration, and this is what our design looks like now:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="106" width="390" src="assets/1f5bb028-442a-4fae-9f5e-54403523bae7.png"/></div>
<div class="packt_figure packt_figref CDPAlignCenter CDPAlign">Application design with inheritance without using the Decorator Design Pattern</div>
<p>This design will be very complex as I will add more benefit schemes to the <strong>SavingAccount</strong>, but what would happen when the bank launches the same scheme for <strong>CurrentAccount</strong>? Clearly, this design is flawed, but this is an ideal use case for the decorator pattern. This pattern allows you to add runtime dynamic behavior. In this case, I will create an abstract <strong>AccountDecorator</strong> class to implement <strong>Account</strong>. And furthermore, I will create the <strong>SeniorCitizen</strong> class and <strong>Privilege</strong> class, which extends <strong>AccountDecorator</strong> because young does not have any extra benefits, so the SavingAccount class does not extend <strong>AccountDecorator</strong>. This is how the design will be:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="178" width="409" class=" image-border" src="assets/ef7b6378-ece3-4d56-abfd-5c7c81794b74.png"/></div>
<div class="packt_figure packt_figref CDPAlignCenter CDPAlign">Application design with composition using the decorator design pattern</div>
<p>The preceding figure follows the Decorator design pattern by creating <strong>AccountDecorator</strong> as a <strong>Decorator</strong> in this pattern, and focuses on important things to observe the relationship between <strong>Account</strong> and <strong>AccountDecorator</strong>. This relationship is as follows:</p>
<ul>
<li><strong>Is-a</strong> relationship between the <kbd>AccountDecorator</kbd> and <kbd>Account</kbd>, that is, inheritance for the correct type</li>
<li><strong>Has-a</strong> relationship between the <kbd>AccountDecorator</kbd> and <kbd>Account</kbd>, that is, composition in order to add new behavior without changing the existing code</li>
</ul>
<p>Let's look at the UML structure<strong>:</strong></p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="303" width="367" class=" image-border" src="assets/577f047c-f03e-46a7-a6e4-4495bd2971ab.png"/></div>
<div class="packt_figure packt_figref CDPAlignCenter CDPAlign">UML for the Decorator design pattern</div>
<p>The classes and objects participating in this pattern are:</p>
<ul>
<li><strong>Component</strong> (<strong>Account</strong>): It is an interface for objects that can have responsibilities added to them dynamically</li>
<li><strong>ConcreteComponent</strong> (<strong>SavingAccount</strong>): It is a concrete class of component interface and it defines an object to which additional responsibilities can be attached</li>
<li><strong>Decorator</strong> (<strong>AccountDecorator</strong>): It has a reference to a <strong>Component</strong> object and defines an interface that conforms to the interface of the component</li>
<li><strong>ConcreteDecorator</strong> (<strong>SeniorCitizen and Privilege</strong>): It is a concrete implementation of <strong>Decorator</strong> and it adds responsibilities to the component</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementing the Decorator pattern</h1>
                </header>
            
            <article>
                
<p>Let's look at the following code to demonstrate the Decorator design pattern.</p>
<p>Create a component class:</p>
<p>Following is the <kbd>Account.java</kbd> file:</p>
<pre>    package com.packt.patterninspring.chapter3.decorator.pattern; 
    public interface Account { 
       String getTotalBenefits(); 
    } </pre>
<p>Create concrete components classes:</p>
<p>Following is the <kbd>SavingAccount.java</kbd> file:</p>
<pre>    package com.packt.patterninspring.chapter3.decorator.pattern; 
    public class SavingAccount implements Account { 
      @Override 
      public String getTotalBenefits() { 
         return "This account has 4% interest rate with per day<br/>           $5000 withdrawal limit"; 
      } 
    } </pre>
<p>Let's create another concrete class for Account component:</p>
<p>Following is the <kbd>CurrentAccount.java</kbd> file:</p>
<pre>    package com.packt.patterninspring.chapter3.decorator.pattern; 
    public class CurrentAccount implements Account { 
      @Override 
      public String getTotalBenefits() { 
         return "There is no withdrawal limit for current account"; 
      } 
    } </pre>
<p>Let's create a <kbd>Decorator</kbd> class for Account component. This decorator class apply other run time behavior to the Account component classes.</p>
<p>Following is the <kbd>AccountDecorator.java</kbd> file:</p>
<pre>    package com.packt.patterninspring.chapter3.decorator.pattern; 
    public abstract class AccountDecorator implements Account { 
      abstract String applyOtherBenefits(); 
    } </pre>
<p>Let's create a <kbd>ConcreteDecorator</kbd> class to implement the AccountDecorator class. Following class <kbd>SeniorCitizen</kbd> is extended <kbd>AccountDecorator</kbd> class to access other run time behavior such as <kbd>applyOtherBenefits()</kbd>.</p>
<p>Following is the <kbd>SeniorCitizen.java</kbd> file:</p>
<pre>    package com.packt.patterninspring.chapter3.decorator.pattern; 
    public class SeniorCitizen extends AccountDecorator { 
      Account account; 
      public SeniorCitizen(Account account) { 
         super(); 
         this.account = account; 
      } 
      public String getTotalBenefits() { 
         return account.getTotalBenefits() + " other benefits are <br/>             "+applyOtherBenefits(); 
      } 
      String applyOtherBenefits() { 
         return " an medical insurance of up to $1,000 for Senior <br/>         Citizen"; 
      } 
    } </pre>
<p>Let's create another <kbd>ConcreteDecorator</kbd> class to implement the <kbd>AccountDecorator</kbd> class. Following class <kbd>Privilege</kbd> is extended <kbd>AccountDecorator</kbd> class to access other run time behavior such as <kbd>applyOtherBenefits(</kbd>).</p>
<p>Following is the <kbd>Privilege.java</kbd> file:</p>
<pre>    package com.packt.patterninspring.chapter3.decorator.pattern; 
    public class Privilege extends AccountDecorator { 
      Account account; 
      public Privilege(Account account) { 
         this.account = account; 
      } 
      public String getTotalBenefits() { 
         return account.getTotalBenefits() + " other benefits are    <br/>            "+applyOtherBenefits(); 
      } 
      String applyOtherBenefits() { 
        return " an accident insurance of up to $1,600 and<br/>           an overdraft facility of $84"; 
        } 
      } </pre>
<p>Let's now write some test code to see how the Decorator pattern works at runtime:</p>
<p>Following is the <kbd>DecoratorPatternMain.java</kbd> file:</p>
<pre>    package com.packt.patterninspring.chapter3.decorator.pattern; 
    public class DecoratorPatternMain { 
      public static void main(String[] args) { 
         /*Saving account with no decoration*/ 
         Account basicSavingAccount = new SavingAccount(); 
         System.out.println(basicSavingAccount.getTotalBenefits()); 
         /*Saving account with senior citizen benefits decoration*/ 
         Account seniorCitizenSavingAccount = new SavingAccount(); 
         seniorCitizenSavingAccount = new <br/>            SeniorCitizen(seniorCitizenSavingAccount); 
         System.out.println<br/>        (seniorCitizenSavingAccount.getTotalBenefits()); 
         /*Saving account with privilege decoration*/ 
         Account privilegeCitizenSavingAccount = new SavingAccount(); 
         privilegeCitizenSavingAccount = new<br/>            Privilege(privilegeCitizenSavingAccount); 
         System.out.println<br/>        (privilegeCitizenSavingAccount.getTotalBenefits()); 
      } 
    } </pre>
<p>Let's run this demo class and see the following output at the console:</p>
<div class="CDPAlignCenter CDPAlign"><strong><img height="77" width="445" class=" image-border" src="assets/b59232d4-7614-48e2-8273-161735ffa0f2.png"/></strong></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Decorator design pattern in the Spring Framework</h1>
                </header>
            
            <article>
                
<p>The Spring Framework uses the Decorator design pattern to build important functionalities such as transactions, cache synchronization, and security-related tasks. Let's look at some functionalities where Spring implements this pattern transparently:</p>
<ul>
<li>Weaving the advice into the Spring application. It uses the Decorator pattern via the CGLib proxy. It works by generating a subclass of the target class at runtime.</li>
<li><kbd>BeanDefinitionDecorator</kbd> : It is used to decorate the bean definition via applied custom attributes.</li>
<li><kbd>WebSocketHandlerDecorator</kbd>: It is used to decorate a WebSocketHandler with additional behaviors.</li>
</ul>
<p>Now let's turn to another GOF Design Pattern - Facade design pattern.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Facade Design Pattern</h1>
                </header>
            
            <article>
                
<div class="packt_quote">Provide a unified interface to a set of interfaces in a subsystem. Facade defines a higher-level interface that makes the subsystem easier to use.<br/>
- GOF Design Patterns</div>
<p>The Facade design pattern is nothing but an interface of interfaces to simplify interactions between the client code and subsystem classes. This design comes under the GOF structural design pattern.</p>
<p>Benefits of Facade Pattern:</p>
<ul>
<li>This pattern reduces the complexities for clients to interact with subsystems</li>
<li>This pattern consolidates all the business services as single interfaces to make them more understandable</li>
<li>This pattern reduces dependencies of client code on the inner workings of a system</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Knowing when to use the Facade Pattern</h1>
                </header>
            
            <article>
                
<p>Suppose you are designing a system, and this system has a very large number of independent classes and also has a set of services to be implemented. This system is going to be very complex, so the Facade pattern comes into the picture and reduces the complexities of the larger system and simplifies interactions of the client code with a set of classes from a subsystem of the large complex system.</p>
<p>Suppose you want to develop a bank enterprise application with a large number of services to perform a task, for example, <kbd>AccountService</kbd> for getting the <kbd>Account</kbd> by <kbd>accountId</kbd>, <kbd>PaymentService</kbd> for payment gateway services, and <kbd>TransferService</kbd> for the amount transfer from one account to another account. A client code of the application interacts with all these services to transfer money from one account to another account. This is how different clients interact with the amount transfer process of the bank system. As shown in the following figure, here you can see client code that directly interacts with the subsystem classes and client also should aware about the internal working of subsystem classes, so it is simply a violation of the SOLID design principles because client code is tightly coupled with the classes of subsystem of your banking application:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="286" width="429" src="assets/f793e18e-9f34-4e4b-a9fd-350cebfc824a.png"/></div>
<div class="packt_figure packt_figref CDPAlignCenter CDPAlign">Banking Application Subsystem without Facade Design Pattern</div>
<p>Rather than client code directly interacting with the classes of a subsystem, you could introduce one more interface, which makes the subsystems easier to use, as shown in the following figure. This interface is known as a <kbd>Facade</kbd> interface, it is based on the Facade pattern, and it is a simple way to interact with the subsystems:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="283" width="354" src="assets/1bdbdb56-6b8d-4173-8697-349d257f6923.png"/></div>
<div class="packt_figure packt_figref CDPAlignCenter CDPAlign">Banking Application Subsystem with Facade design pattern</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementing the Facade design pattern</h1>
                </header>
            
            <article>
                
<p>Let's look into the following listings to demonstrate the Facade design pattern.</p>
<p>Create subsystem service classes for your Bank application: Let's see the following PaymentService class for the subsystem.</p>
<p>Following is the <kbd>PaymentService.java</kbd> file:</p>
<pre>    package com.packt.patterninspring.chapter3.facade.pattern; 
    public class PaymentService { 
      public static boolean doPayment(){ 
         return true; 
      } 
    } </pre>
<p>Let's create another service class AccountService for the subsystem.</p>
<p>Following is the <kbd>AccountService.java</kbd> file:</p>
<pre>   package com.packt.patterninspring.chapter3.facade.pattern; 
   import com.packt.patterninspring.chapter3.model.Account; 
   import com.packt.patterninspring.chapter3.model.SavingAccount; 
   public class AccountService { 
     public static Account getAccount(String accountId) { 
        return new SavingAccount(); 
     } 
   } </pre>
<p>Let's create another service class TransferService for the subsystem.</p>
<p>Following is the <kbd>TransferService.java</kbd> file:</p>
<pre>    package com.packt.patterninspring.chapter3.facade.pattern; 
    import com.packt.patterninspring.chapter3.model.Account; 
    public class TransferService { 
      public static void transfer(int amount, Account fromAccount,<br/>            Account toAccount) { 
        System.out.println("Transfering Money"); 
      } 
    } </pre>
<p>Create a Facade Service class to interact with the subsystem: Let's see the following Facade interface for the subsystem and then implement this Facade interface as a global banking service in the application.</p>
<p>Following is the <kbd>BankingServiceFacade.java</kbd> file:</p>
<pre>    package com.packt.patterninspring.chapter3.facade.pattern; 
    public interface BankingServiceFacade { 
       void moneyTransfer(); 
    } </pre>
<p>Following is the <kbd>BankingServiceFacadeImpl.java</kbd> file:</p>
<pre>    package com.packt.patterninspring.chapter3.facade.pattern; 
    import com.packt.patterninspring.chapter3.model.Account; 
    public class BankingServiceFacadeImpl implements <br/>        BankingServiceFacade{ 
      @Override 
      public void moneyTransfer() { 
         if(PaymentService.doPayment()){ 
               Account fromAccount = AccountService.getAccount("1"); 
               Account toAccount   = AccountService.getAccount("2"); 
               TransferService.transfer(1000, fromAccount, toAccount); 
         } 
      } 
    } </pre>
<p>Create the client of the Facade:</p>
<p>Following is the <kbd>FacadePatternClient.java</kbd> file:</p>
<pre>    package com.packt.patterninspring.chapter3.facade.pattern; 
    public class FacadePatternClient { 
      public static void main(String[] args) { 
        BankingServiceFacade serviceFacade = new <br/>          BankingServiceFacadeImpl(); 
        serviceFacade.moneyTransfer(); 
      } 
    } </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The UML structure for the Facade design pattern</h1>
                </header>
            
            <article>
                
<p>The classes and objects participating in this pattern are:</p>
<ul>
<li>Facade (<kbd>BankingServiceFacade</kbd>)</li>
</ul>
<p>This is a Facade interface that knows which subsystem classes are responsible for a request. This interface is responsible for delegating client requests to appropriate subsystem objects.</p>
<ul>
<li>Subsystem classes (<kbd>AccountService</kbd>, <kbd>TransferService</kbd>, <kbd>PaymentService</kbd>)</li>
</ul>
<p>These interfaces are actually subsystem functionalities of the banking process system application. These are responsible for handling processes assigned by the Facade object. No interfaces in this category have a reference to the Facade object; they don't have implementation details of Facade. These are totally independent of Facade objects.</p>
<p>Let's see the following UML diagram for this pattern:</p>
<div class="CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/5ac8fdbb-ec4e-4d2c-b2e9-fcc173631224.png"/></div>
<div class="packt_figure packt_figref CDPAlignCenter CDPAlign">UML diagram for Facade design pattern</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Facade Pattern in the Spring Framework</h1>
                </header>
            
            <article>
                
<p>In the enterprise application, if you are working in Spring applications, the facade pattern is used commonly in the business service layer of the application to consolidate all services. And you could also apply this pattern on DAOs on the persistent layer.</p>
<p>Now that we've seen the Facade design pattern, let's turn to a different variant of it--Proxy design pattern.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Proxy design pattern</h1>
                </header>
            
            <article>
                
<div class="packt_quote">Provide a surrogate or placeholder for another object to control access to it.<br/>
-GOF Design Patterns</div>
<p>Proxy design pattern provides an object of a class with the functionality of another class with having it. This pattern comes under the structural design pattern of GOF Design Patterns. The intent of this design pattern is to provide an alternate class for another class , along with its functionality, to the outside world.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Purpose of the Proxy pattern</h1>
                </header>
            
            <article>
                
<p>Let's look at the following points:</p>
<ul>
<li>This pattern hides the actual object from the outside world.</li>
<li>This pattern can improve the performance because it is creating an object on demand.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">UML structure for the Proxy design pattern</h1>
                </header>
            
            <article>
                
<p>Let's see the following UML diagram for this pattern:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/05f5033a-1a34-4cd6-aace-e6cf6e6fb9ac.png"/></div>
<div class="packt_figure packt_figref CDPAlignCenter CDPAlign">UML diagram for Proxy design pattern</div>
<p>Now let's look at the different components of this UML diagram:</p>
<ul>
<li><strong>Subject</strong>: Actual interface to be implemented by Proxy and RealSubject.</li>
<li><strong>RealSubject</strong>: Real implementation of <strong>Subject</strong>. It is a real object that represented by the proxy.</li>
<li><strong>Proxy</strong>: It is a proxy object and it is also the implementation of the real object <strong>Subject</strong>. It maintains the references to the real object.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementing the Proxy design pattern</h1>
                </header>
            
            <article>
                
<p>Let's look into following code to demonstrate the Proxy pattern.</p>
<p>Create a Subject.</p>
<p>Following is the <kbd>Account.java</kbd> file:</p>
<pre>    public interface Account { 
      void accountType(); 
    } </pre>
<p>Create a RealSubject class that implements Subject, let's see the following class as RealSubject class for the Proxy design pattern.</p>
<p>Following is the <kbd>SavingAccount.java</kbd> file:</p>
<pre>    public class SavingAccount implements Account{ 
       public void accountType() { 
          System.out.println("SAVING ACCOUNT"); 
       } 
    } </pre>
<p>Create a Proxy class which implements Subject and having the Real Subject</p>
<p>Following is the <kbd>ProxySavingAccount.java</kbd> file:</p>
<pre>    package com.packt.patterninspring.chapter2.proxy.pattern; 
    import com.packt.patterninspring.chapter2.model.Account; 
    import com.packt.patterninspring.chapter2.model.SavingAccount; 
    public class ProxySavingAccount implements Account{ 
      private Account savingAccount; 
      public void accountType() { 
         if(savingAccount == null){ 
               savingAccount = new SavingAccount(); 
         } 
         savingAccount.accountType(); 
      }  
    } </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Proxy pattern in the Spring Framework</h1>
                </header>
            
            <article>
                
<p>Spring Framework uses the Proxy design pattern in the Spring AOP module transparently. As I have discussed in <a href="18f63847-961b-45a2-bef0-30602dcabed3.xhtml" target="_blank">Chapter 1</a>, <em>Getting Started with Spring Framework 5.0 and Design Patterns</em>. In Spring AOP, you create proxies of the object to apply cross cutting concern across the point cut in the Spring application. In the Spring, other modules also implement the Proxy pattern, such as RMI, Spring's HTTP Invoker, Hessian, and Burlap.</p>
<p>Let's see the next section about Behavioral design pattern with its underlying patterns and example.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Behavioral design patterns</h1>
                </header>
            
            <article>
                
<p>The intent of Behavioral design pattern is the interaction and cooperation between a set of objects to perform a task that no single object can carry out by itself. The interaction between the objects should be such that they should be loosely coupled. Patterns under this category, characterize the ways in which classes or objects interact and distribute responsibility. Let's see in the next sections, different variants of the Behavioral design patterns.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Chain of Responsibility design pattern</h1>
                </header>
            
            <article>
                
<div class="packt_quote">Avoid coupling the sender of a request to its receiver by giving more than one object a chance to handle the request. Chain the receiving objects and pass the request along the chain until an object handles it.<br/>
-GOF Design Patterns</div>
<p>Chain of responsibility design pattern comes under the Behavioral design pattern of GOF patterns family. According to this pattern, sender and receiver of a request are decoupled. The sender sends a request to the chain of receivers and any one of receivers in the chain can handle the request. In this pattern, the receiver object has the reference of another receiver object so that if it does not handle the request then it passes the same request to the other receiver object.</p>
<p>For example, in a banking System, you could use any ATM to withdraw the money in any place, so it is one of the live examples of the Chain of Responsibility design pattern.</p>
<p>There are following benefits of this pattern:</p>
<ul>
<li>This pattern reduces the coupling between sender and receiver objects in the system to handle a request.</li>
<li>This pattern is more flexible to assign the responsibility to another referenced object.</li>
<li>This pattern makes a chain of objects using composition, and this set of objects work as a single unit.</li>
</ul>
<p>Let's see the following UML diagram showing all components of a chain of responsibility design pattern:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="157" width="412" class=" image-border" src="assets/b759bfd8-4afb-4bc7-a381-d7c2b5ba9eec.png"/></div>
<div class="packt_figure packt_figref CDPAlignCenter CDPAlign">UML Diagram for Chain of Responsibility design pattern</div>
<p> </p>
<ul>
<li><strong>Handler</strong>: This is an abstract class or interface in the system to handle request.</li>
<li><strong>ConcreteHandler</strong>: These are concrete classes which implement <strong>Handler</strong> to handle the request, or it passes same request to the next successor of the handler chain.</li>
<li><strong>Client</strong>: It is main application class to initiate the request to the handler objects on the chain.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Chain of Responsibility pattern in the Spring Framework</h1>
                </header>
            
            <article>
                
<p>Spring Security project implemented the Chain of Responsibility pattern in the Spring Framework. Spring Security allows you to implement authentication and authorization functionality in your application by using chains of security filters. This is a highly configurable framework. You can add your custom filter with this chain of filters to customize the functionality because of Chain of Responsibility design pattern.</p>
<p>Now that we've seen the Chain of responsibility design pattern, let's turn to a different variant of it--Command design pattern.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Command design pattern</h1>
                </header>
            
            <article>
                
<div class="packt_quote">Encapsulate a request as an object, thereby letting you parameterize clients with different requests, queue or log requests, and support undoable operations<br/>
-GOF Design Patterns</div>
<p>The Command design pattern falls under the Behavioral pattern family of the GOF patterns, this pattern is a very simple data-driven pattern which allows you to encapsulate your request data into an object and pass that object as a command to the invoker method, and it return the command as another object to the caller.</p>
<p>The following lists the benefits of using the Command pattern:</p>
<ul>
<li>This pattern enables you to transfer data as an object between the system components sender and receiver.</li>
<li>This pattern allows you to parameterize objects by an action to perform.</li>
<li>You could easily add new commands in the system without changing existing classes.</li>
</ul>
<p>Let's look at the following UML diagram showing all components of Command design pattern:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="231" width="353" class=" image-border" src="assets/3065e0ae-3e83-4601-9104-726bfe750cde.png"/></div>
<div class="packt_figure packt_figref CDPAlignCenter CDPAlign">UML Diagram for Command Design Pattern</div>
<ul>
<li><strong>Command</strong>: It is an interface or abstract class having an action <span>to perform in the system.</span></li>
</ul>
<ul>
<li><strong>ConcreteCommand</strong>: It is a concrete implementation of the <kbd>Command</kbd> interface and defining an action will be performed.</li>
</ul>
<ul>
<li><strong>Client</strong>: This is a main class, it creates a <kbd>ConcreteCommand</kbd> object and sets its receiver.</li>
</ul>
<ul>
<li><strong>Invoker</strong>: It is a caller to invoke the request to carry the command object.</li>
</ul>
<ul>
<li><strong>Receiver</strong>: It is simple handler method which performs the actual operation by <kbd>ConcreteCommand</kbd>.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Command design pattern in the Spring Framework</h1>
                </header>
            
            <article>
                
<p>Spring MVC has implemented the Command design pattern in the Spring Framework. In your enterprise applications using the Spring Framework, you often see the concepts of the Command pattern applied through the use of Command objects.</p>
<p>Now that we've seen Command design pattern, let's turn to a different variant of it--Interpreter design pattern.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Interpreter Design pattern</h1>
                </header>
            
            <article>
                
<div class="packt_quote">Given a language, define a representation for its grammar along with an interpreter that uses the representation to interpret sentences in the language.<br/>
-GOF Design Pattern</div>
<p>Interpreter design pattern allows you to interpret an expression language in the programming to define a representation for its grammar. This type of a pattern comes under the Behavioral design pattern family of GOF patterns.</p>
<p>The following lists the benefits of using the Interpreter pattern:</p>
<ul>
<li>This pattern allows you to change and extend the grammar easily.</li>
<li>Using the expression language is very easy</li>
</ul>
<p>Let's see the following UML diagram is showing all components of Interpreter design pattern:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="248" width="377" class=" image-border" src="assets/2cf328c2-4671-4233-a791-fb66bdea1f72.png"/></div>
<div class="packt_figure packt_figref CDPAlignCenter CDPAlign">UML diagram for Interpreter design pattern</div>
<ul>
<li><strong>AbstractExpression:</strong> It is an interface to execute a task by using <kbd>interpret()</kbd> <span>operation.</span></li>
<li><strong>TerminalExpression:</strong> It is an implementation of above interface and it implements <kbd>interpret()</kbd> <span><span>operation for terminal expressions.</span></span></li>
<li><strong>NonterminalExpression:</strong> It is also an implementation of above interface and it implements <kbd>interpret()</kbd> <span>operation for non-terminal expressions.</span></li>
<li><strong>Context:</strong> It is a <kbd>String</kbd> expression and contains information that is global to the interpreter.</li>
<li><strong>Client:</strong> It is the main class to invoke the Interpret operation.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Interpreter design pattern in the Spring Framework</h1>
                </header>
            
            <article>
                
<p>In the Spring Framework, Interpreter pattern is used with the <strong>Spring Expression Language</strong> (<strong>SpEL</strong>). Spring added this new feature from Spring 3.0, you can use it in your enterprise application using the Spring Framework.</p>
<p>Now that we've seen Interpreter design pattern, let's turn to a different variant of it--Iterator design pattern.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Iterator Design Pattern</h1>
                </header>
            
            <article>
                
<div class="packt_quote">Provide a way to access the elements of an aggregate object sequentially without Exposing its underlying representation.<br/>
-GOF Design Pattern</div>
<p>This is a very commonly used design pattern in the programming language as like in Java. This pattern comes from the Behavioral Design Pattern family of GOF pattern. This pattern allows you to access the items from the collection object in sequence without information its internal representation.</p>
<p>These are following benefits of the Iterator pattern:</p>
<ul>
<li>Easily access the items of the collection.</li>
<li>You can use multiple to access the item from the collection because it support lot of variations in the traversal.</li>
<li>It provides a uniform interface for traversing different structures in a collection.</li>
</ul>
<p>Let's see the following UML diagram is showing all components of Iterator design pattern:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/6cbed143-241f-488a-bec5-4cd6418c5270.png"/></div>
<div class="packt_figure packt_figref CDPAlignCenter CDPAlign">UML Diagram for Iterator Design Pattern</div>
<ul>
<li><strong>Iterator:</strong> It is an interface or abstract class for accessing and traversing items of the collections.</li>
<li><strong>ConcreteIterator:</strong> It is an implementation <span>of the <strong>Iterator</strong> interface.</span></li>
<li><strong>Aggregate:</strong> It is an interface to create an Iterator object.</li>
<li><strong>ConcreteAggregate:</strong> It is the implementation <span>of the <strong>Aggregate</strong> interface, it implements the <strong>Iterator</strong> creation interface to return an instance of the proper <strong>ConcreteIterator</strong>.</span></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Iterator design pattern in the Spring Framework</h1>
                </header>
            
            <article>
                
<p>The Spring Framework also extends the Iterator pattern through the <strong>CompositeIterator</strong> class. Mainly this pattern used in the Collection Framework of Java for iterating the elements in sequence.</p>
<p>Now that we've seen Iterator design pattern, let's turn to a different variant of it--Observer design pattern.</p>
<p><strong>Observer</strong> <strong>Design Pattern</strong></p>
<div class="packt_quote">Define a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically<br/>
-GOF Design Pattern</div>
<p>Observer pattern is one of very common design pattern, This pattern is a part of the Behavioral design pattern family of GOF pattern that addresses responsibilities of objects in an application and how they communicate between them at runtime. According to this pattern, sometimes objects make a one-to-many relationship between the objects in your application, such that if one object is modified, it's notified to other dependent objects automatically.</p>
<p>For example, Facebook post comments are one of the examples of the observer design pattern. If you comment on a post of your friend then you are always notified by this post whenever anyone else comments on the same post again.</p>
<p>The Observer pattern provides communication between decoupled objects. It makes a relationship between objects mostly a one-to-many relationship. In this pattern, there is an object which is known as the subject. Whenever there is any change in the state of this subject, it will be notified to its list of dependents accordingly. This list of dependents is known as observers. The following figure illustrates the Observer pattern:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="258" width="520" src="assets/8368e46a-cf78-4b1b-a6a8-a2b40e03ae8c.png"/></div>
<div class="packt_figure packt_figref CDPAlignCenter CDPAlign">Use case of the Observer design pattern</div>
<p class="mce-root"/>
<p>There are following lists of the benefits of using the Observer pattern:</p>
<ul>
<li>This pattern provides decoupled relationship between the subject and observer</li>
<li>It provides support for broadcasting</li>
</ul>
<p>Let's see the following UML diagram is showing all components of Observer design pattern:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/90e6cd43-41bf-43f1-8b0d-a21741e91510.png"/></div>
<div class="packt_figure packt_figref CDPAlignCenter CDPAlign">UML Diagram for Observer Design Pattern</div>
<ul>
<li><strong>Subject</strong>: It is an interface. It has information about its observers.</li>
<li><strong>ConcreteSubject</strong>: It is a concrete implementation of <strong>Subject</strong>, it has information about all its observers to be notified when its state changes.</li>
<li><strong>Observer</strong>: It is an interface to be notified of changes in a subject.</li>
<li><strong>ConcreteObserver</strong>: It is a concrete implementation of Observer, it keeps <span><span>its state consistent with the subject's state.</span></span></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Observer pattern in the Spring Framework</h1>
                </header>
            
            <article>
                
<p>In the Spring Framework, the Observer design pattern is used to implement event handling function of <kbd>ApplicationContext</kbd>. Spring provides us the <kbd>ApplicationEvent</kbd> class and <kbd>ApplicationListener</kbd> interface to enable event handling in Spring <kbd>ApplicationContext</kbd>. Any bean in your Spring application implements the <kbd>ApplicationListener</kbd> interface, it will receive an <kbd>ApplicationEvent</kbd> every time the <kbd>ApplicationEvent</kbd> is published by an event publisher. Here, the event publisher is the subject and the bean that implements ApplicationListener is the observer.</p>
<p>Now that we've seen Observer design pattern, let's turn to a different variant of it--Template design pattern.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Template Design Pattern</h1>
                </header>
            
            <article>
                
<div class="packt_quote">Define the skeleton of an algorithm in an operation, deferring some steps to subclasses. Template Method lets subclasses redefine certain steps of an algorithm without changing the algorithm's structure.<br/>
60; -GOF Design Patterns</div>
<p>In Template design pattern, an abstract class wraps some defined ways to its method. That method allows you to override parts of the method without rewriting it. You could use its concrete class to your application to perform similar type actions. This design pattern comes under the Behavior design pattern family of GOF pattern.</p>
<p>There are following lists the benefits of using the Template pattern:</p>
<ul>
<li>It reduces the boilerplate codes in the application by reusing code.</li>
<li>This pattern creates a template or way to reuse multiple similar algorithms to perform some business requirements.</li>
</ul>
<p>Let's see the following UML diagram is showing the components of Template design pattern:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/a46a5f03-e61f-49be-892f-f3a1c9f16669.png"/></div>
<div class="packt_figure packt_figref CDPAlignCenter CDPAlign">UML Diagram for Template design pattern</div>
<ul>
<li><strong>AbstractClass</strong>: This is an abstract class that contains a template method defining the skeleton of an algorithm.</li>
<li><strong>ConcreteClass:</strong> This is a concrete subclass <span>of</span> <strong>AbstractClass</strong> <span>that implements the operations to carry out the algorithm-specific primitive steps.</span></li>
</ul>
<p>Let's see the next section about J2EE design patterns in the enterprise distributed applications</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">JEE design patterns</h1>
                </header>
            
            <article>
                
<p>It is other main category of design patterns. Application design can be immensely simplified by applying Java EE design patterns. Java EE design patterns have been documented in Sun's Java Blueprints. These Java EE design patterns provide time-tested solution guidelines and best practices for object interaction in the different layer of a Java EE application. These design patterns are specifically concerned with the following listed layers:</p>
<ul>
<li>Design pattern at presentation layer</li>
<li>Design <span>pattern</span> at business layer</li>
<li>Design <span>pattern</span> at integration layer</li>
</ul>
<p>These design patterns are specifically concerned with the following listed layers.</p>
<ul>
<li><strong>Design pattern at presentation layer</strong>:
<ul>
<li><strong>View Helper</strong>: It separates views from the business logic of an enterprise J2EE application.</li>
<li><strong>Front Controller</strong>: It provides a single point of action to handle the all coming requests to the J2EE web application, it forwards the request to specific application controller to access model and view for presentation tier resources.</li>
<li><strong>Application Controller</strong>-The request actually handled by the Application Controller, it acts as a front controller helper. It responsible for the coordination with the business models and view components.</li>
<li><strong>Dispatcher View</strong>-It is related to the view only and it executes without business logic to prepare a response to the next view.</li>
<li><strong>Intercepting filters</strong> -In the J2EE web application, you could configure multiple interceptors for pre and post processing an user's request such as tracking and auditing user's requests.</li>
</ul>
</li>
<li><strong>Design pattern at business layer</strong>:
<ul>
<li><strong>Business Delegate</strong>-It acts as a bridge between application controllers and business logic</li>
<li><strong>Application Service</strong>-It provides business logics to implement the model as simple Java objects for presentation layer</li>
</ul>
</li>
</ul>
<ul>
<li><strong>Design pattern at integration layer</strong>:
<ul>
<li><strong>Data Access Object</strong>-It is implemented for accessing business data and it separates data access logic from business logic in the enterprise application.</li>
<li><strong>Web Service Broke</strong>r-It encapsulates the logic to access the external application's resources and it is exposed as web services.</li>
</ul>
</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>After reading this chapter, the reader should now have a good idea about GOF Design Patterns and their best practices. I highlighted the problems that come if you don't implement design patterns in your enterprise application and how Spring solves these problems by using lots of design patterns and good practices to create an application. In the preceding chapter too, I have mentioned the three main categories of GOF Design Patterns such as Creational Design Pattern; it is useful for creation of object instances and also to apply some constraints at the creation time of the enterprise application by specific manner by Factory, Abstract Factory, Builder, Prototype and Singleton pattern. The second main category is the Structural design pattern, it is used for design structure of the enterprise application by dealing with the composition of classes or objects so that it reduces application complexity and improve the reusability and performance of the application. They are Adapter pattern, Bridge pattern, Composite pattern, Decorator pattern, and Facade pattern come under this category of patterns. Finally, one more main category of the pattern is Behavioral design pattern, it characterizes the ways in which classes or objects interact and distribute responsibility. Patterns come under this category are specifically concerned with communication between objects.</p>


            </article>

            
        </section>
    </body></html>