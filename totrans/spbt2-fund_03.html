<html><head></head><body><div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Testing Spring Applications</h1>
                </header>
            
            <article>
                
<p class="mce-root">In this chapter, we will learn about different ways to test Spring applications. This section will focus on unit tests and how they are different than the other test types. After studying a bit of theory, you can continue to the practical sub-section, where you should start writing simple unit tests on their own.</p>
<p>By the end of this chapter, you will be able to:</p>
<ul>
<li>Create unit tests for Spring applications</li>
<li>Create integration tests that start parts of the application internally</li>
<li>Utilize the rich Spring toolset for tests</li>
<li>Analyze the different test types</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Applying Unit Tests</h1>
                </header>
            
            <article>
                
<p>In the previous chapters, you saw how you can create a Spring application and how you can add dependencies among components within the application.</p>
<p>In this section, you will see how you can test the classes of your application as regular classes or with some Spring support for wiring dependencies. Writing these tests on your own is important so that you know what you wrote works. UI tests are sometimes written by a dedicated QA department.</p>
<div class="packt_infobox"><br/>
By using these fake dependencies, you can simulate behavior of other classes or verify that the dependency has been called the correct way. For more information, especially on fake dependencies and mocking, you can have a look at Martin Fowler's article at <a href="https://martinfowler.com/articles/mocksArentStubs.html#TheDifferenceBetweenMocksAndStubs">https://martinfowler.com/articles/mocksArentStubs.html#TheDifferenceBetweenMocksAndStubs</a>.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Unit Testing</h1>
                </header>
            
            <article>
                
<p>In software development, you have multiple layers of tests that you can write. Unit tests are the most basic tests that test small parts of the software and usually run very fast. They are very important to verify that the functionality that you wrote works on a fundamental level.</p>
<p>For example, consider a method that adds two numbers, which is used in some ledger applications. You want to make sure that this method is able to cope with all sorts of errors and inputs. This can be easily tested by using unit tests. There is virtually no setup, and they can test a lot in a short amount of time. You can even test very detailed things such as integer overflows when you add two very big numbers.</p>
<p>There is a testing pyramid, which highlights that the most tests should consist of unit tests:</p>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/81e14f01-26d0-4107-abbe-08831a53aef0.png" style="width:21.58em;height:18.17em;" width="461" height="387"/></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Test Types – Side by Side</h1>
                </header>
            
            <article>
                
<p>There is no fixed definition on the testing terms, but besides unit tests, there are also two other types that are commonly referred to: integration tests and UI tests. Depending on the project, there are also test types in-between these three types:</p>
<p>Take a look at the following table that highlights the main concepts:</p>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/368a9b3a-292c-4dbd-ad8b-5a7c8b6a272b.png" style="width:34.75em;height:25.17em;" width="657" height="476"/></div>
<div class="packt_tip"><br/>
When writing tests, make sure that they are reliable. Try to avoid random numbers, time-based assertions, and so on. Whenever possible or necessary, try to provide a fixed set of numbers or your own "clock" so that you can reliably test your code. Nothing is worse than tests that fail from time to time because of an edge case, for example, due to date changes or unforeseen random numbers. There are input generators that can provide you with random data that fits a provided set of requirements, but overall, I would suggest sticking to reproducible, well-known (and thought through) inputs.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Writing Unit Tests with Plain JUnits</h1>
                </header>
            
            <article>
                
<p>The Spring Initializr already adds the test dependencies and also creates an empty test class for you. We are going to show you how to write unit tests by testing the <kbd>BlogRepository</kbd> based on the code of <em>Configuration of Spring Boot Applications</em> from <em><a href="f4efef8a-3e71-483b-84be-a741a3f8ff0d.xhtml"/><a href="f4efef8a-3e71-483b-84be-a741a3f8ff0d.xhtml">Chapter 2</a>: Building a Spring Application</em>. The most bare-bones way to write tests is to just use JUnit and test the class on its own.</p>
<p>To be able to set a list of blog entries, we have to add a setter to the <kbd>BlogRepository</kbd> class, or we can create a constructor that we can use in the test. Alternatively, we can simply use constructor injection by adding the annotation <kbd>@AllArgsConstructor</kbd> to the <kbd>BlogRepository</kbd>. Of course, this class is very simple, and usually you don't use an in-memory list as a data source, so this example is a little bit fabricated to show unit testing:</p>
<pre>public class BlogRepositoryJUnitTest {<br/>   @Test<br/>   public void testAdd(){<br/>       ArrayList&lt;BlogEntry&gt; db = new ArrayList&lt;&gt;();<br/>       BlogRepository repository = new BlogRepository(db);<br/><br/>       BlogEntry entry = new BlogEntry();<br/>       repository.add(entry);<br/><br/>       assertThat(db).contains(entry);<br/>   }<br/>}</pre>
<div class="packt_infobox"><br/>
This test creates the <kbd>BlogRepository</kbd> with an <kbd>ArrayList</kbd> instance that is under our control. Then, we can add the <kbd>BlogEntry</kbd> and verify that it has been stored. We are using <kbd>assertThat()</kbd> from <kbd>AssertJ</kbd>, which is a very nice assertion framework that is already added as a dependency by Spring.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Writing Unit Tests with Mockito Support</h1>
                </header>
            
            <article>
                
<p>By default, <strong>Mockito</strong>, a mocking framework, is also included in the dependencies, and it has a nice Spring integration as well.</p>
<p>You just add the runner by using the <kbd>@RunWith</kbd> annotation, and then you can define the class you want to test as a field and mark it with the <kbd>@InjectMocks</kbd> annotation. All dependencies that you want to use can be added with the <kbd>@Mock</kbd> annotation. They will be recreated for each test and contain a mocked version of the class. In your test, you can define the behavior for calls by using <kbd>Mockito.when(...)</kbd>. You can also verify that, for example, certain calls have been made with given parameters. This is done using the <kbd>Mockito.verify(...)</kbd> methods. The injection works as it does with Spring, so when Spring is able to autowire a dependency, Mockito will very likely be able to as well:</p>
<pre>@RunWith(MockitoJUnitRunner.class)<br/>public class BlogRepositorySpringTest {<br/>   @Mock<br/>   List&lt;BlogEntry&gt; db;<br/>   @InjectMocks<br/>   BlogRepository repository;<br/><br/>   @Test<br/>   public void testAdd(){<br/>       BlogEntry entry = new BlogEntry();<br/>       repository.add(entry);<br/>       Mockito.verify(db).add(eq(entry));<br/>   }<br/>}</pre>
<div class="packt_infobox"><br/>
For detailed information regarding Mockito, please check out its website at <a href="http://site.mockito.org/">http://site.mockito.org/</a>.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Creating Unit Tests</h1>
                </header>
            
            <article>
                
<p>The aim is to create small unit tests for classes. Now you are going to write your own unit tests for the <kbd>BlogService</kbd> class. Writing tests is very important to ensure that your code not only works now, but also keeps working when the project advances. So, in professional software development, writing unit tests and the other test types is very important. The steps for completion are as follows:</p>
<ol>
<li>Open the IDE and the <kbd>BlogMania</kbd> application for this section.</li>
</ol>
<p style="padding-left: 60px">  Take a look at this screenshot:</p>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/41ac7889-4156-486c-a53d-17c28d2198f8.png" style="width:45.92em;height:16.25em;" width="1210" height="427"/></div>
<ol start="2">
<li>Open the <kbd>BlogService</kbd> class, place the cursor on the class name, and press <span class="packt_screen">Shift-CTRL-T</span>, which should open a menu to create the test class.</li>
<li>Select JUnit as <kbd>test-library</kbd>, select the save method in the box at the bottom, and press <span class="packt_screen">OK</span>. IntelliJ will create and open the file.</li>
<li>Add the Mockito annotations and fields for the service and its dependencies.</li>
<li>Create a simple test for the public methods of the <kbd>BlogService</kbd>. For example, check that the entry is stored, that certain methods are called on the dependencies, or that the output starts with a given string.</li>
</ol>
<div class="packt_infobox">All data is present and add has been called on the <kbd>BlogRepository</kbd>. The blog's title is missing, and you expect an <kbd>IllegalArgumentException</kbd>. You can add a try catch to the test method or examine the <kbd>@Test</kbd> annotation, as it has a property for that.<br/>
Go to <a href="https://bit.ly/2p4Wc3C">https://bit.ly/2p4Wc3C</a> to access the code for the <kbd>BlogServiceTest.java</kbd> file.<br/>
Go to <a href="https://bit.ly/2NDu8SQ">https://bit.ly/2NDu8SQ</a> to access the code for the <kbd>BlogmaniaApplicationTests.java</kbd> file.</div>
<ol start="6">
<li>Add another test that checks whether a date has been added when it's not set before the entry is saved by the repository.</li>
</ol>
<p>Now, you have created your first simple unit tests for a spring class.</p>
<p>Take a look at the screenshot of your outcome:</p>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/1a0ef137-d440-41e5-9f52-9895dd901414.png" style="width:50.75em;height:24.50em;" width="1209" height="584"/></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Integration Tests</h1>
                </header>
            
            <article>
                
<p>In the previous section, you saw how you can test Spring applications using unit tests.</p>
<p>While this is a very important way to test your application, a few things should be tested with more of the infrastructure of the application and maybe the surrounding services that are present. You might want to test whether the SQL you send to the database works or that your REST API generates the correct JSON format when all of Spring's mechanisms are in place and active.</p>
<p>In this section, you will create integration tests of different kinds and dip your toes into the test support of Spring.</p>
<p>JUnit has the concept of a test runner, which handles the way the tests in this particular class are executed. This is used by Mockito to create mocked instances before the tests are executed.</p>
<p>To make a test for a Spring integration test, you only need to add the <kbd>SpringRunner</kbd> as a JUnit test runner and add the <kbd>@SpringBootTest</kbd> annotation to the test class. This enables Spring to start the application inside the test and make it available for you.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The @SpringBootTest Annotation</h1>
                </header>
            
            <article>
                
<p>Take a look at this sample code:</p>
<pre>@RunWith(SpringRunner.class)<br/>@SpringBootTest<br/>public class BlogmaniaApplicationTests {<br/>@Test<br/>public void contextLoads() {<br/>}<br/>}</pre>
<p>This test starts up and only serves the purpose of checking whether you have made a mistake configuring Spring. The reason for this is that this only fails when the Spring context can't start, for example, due to missing classes or Bean definitions.</p>
<div class="packt_tip"><br/>
Integration tests are usually much slower than unit tests. Try to keep the number of integration tests low. Don't try to test every aspect using ITs. Negative tests should be done as unit tests. Try to write mainly "happy-path" tests that verify basic functionality. When it takes too long to run all tests, they lose their value as a feedback mechanism during development.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Testing Beans</h1>
                </header>
            
            <article>
                
<p>When we revisit the <kbd>BlogRepositoryTest</kbd> and recreate it as an integration test, it would look as follow:</p>
<pre>@RunWith(SpringRunner.class)<br/>@SpringBootTest<br/>public class BlogRepositorySpringIntegrationTest {<br/>   @Autowired<br/>   List&lt;BlogEntry&gt; db;<br/>   @Autowired<br/>   BlogRepository repository;<br/>   @Test<br/>   public void testAdd() {<br/>       BlogEntry entry = new BlogEntry();<br/>       repository.add(entry);<br/>       assertThat(db).contains(entry);<br/>  }<br/>}</pre>
<p>As you can see, we now have to verify the result of the test in the <kbd>db-bean</kbd>, because this way we don't have a way to verify calls on the <kbd>BlogRepository</kbd>.</p>
<p>This means that we have to check whether the call had the desired effect by hand.</p>
<p>However, the advantage is that all of the mechanisms that Spring offers are in place. So, when there are proxies around Beans or special scopes on Beans, for example, you can test that using these tests. You can also test your web applications using these kinds of tests, but due to time constraints, this will not be covered in this book.</p>
<p>There is a reason that Mockito is already added by Spring. We can simply mock Beans in a test and verify their calls or configure effects of calls on a Bean:</p>
<pre>@RunWith(SpringRunner.class)<br/>@SpringBootTest<br/>public class BlogRepositorySpringIntegrationMockTest {<br/>   @MockBean<br/>   List&lt;BlogEntry&gt; db;<br/>   @Autowired<br/>   BlogRepository repository;<br/>   @Test<br/>   public void testAdd() {<br/>       BlogEntry entry = new BlogEntry();<br/>       repository.add(entry);<br/>       Mockito.verify(db).add(eq(entry));<br/>   }<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>
<p>By marking the list with <kbd>@MockBean</kbd>, we utilize Spring's Mockito support. We now get the full Spring context, but this Bean has been replaced with a mocked version. We can configure it any way we need it for the test. This is a very handy feature and allows us to write tests with ease, which would have been very complex to write otherwise.</p>
<div class="packt_infobox"><br/>
There are also other annotations such as <kbd>@SpyBean</kbd>, which wrap a proxy around the original Bean to enable you to verify whether certain calls are made, while keeping the old functionality intact.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Configuring the Test Context</h1>
                </header>
            
            <article>
                
<p>When you only use the <kbd>@SpringBootTest</kbd> annotation, you will get the full Spring context. This may not always be what you need for your tests. In this case, you can configure Spring differently for your test:</p>
<pre>@RunWith(SpringRunner.class)<br/>@SpringBootTest(<br/>       properties = {"my.property=test","spring.application.<br/>name=systemUnderTest"},<br/>       classes = {BlogRepositorySpringIntegrationCfgTest.<br/>TestConfigClass.class})<br/>// […]<br/>       public List&lt;BlogEntry&gt; db(){<br/>           return new LinkedList&lt;&gt;();<br/>       }<br/>   }<br/>}</pre>
<div class="packt_infobox"><br/>
Go to <a href="https://bit.ly/2NGKolQ">https://bit.ly/2NGKolQ</a> to access the complete code for the <em>Configuring the Test Context code example</em>.</div>
<p>In this example, we are configuring two properties for the Spring context and we are also preventing the whole context from starting. We provide the <kbd>TestConfigClass</kbd> to the <kbd>@SpringBootTest</kbd> annotation, which will be used to start the application context. In this case, we only load Beans from the service package and provide our own <kbd>db-bean</kbd>, which in this case uses a <kbd>LinkedList</kbd>. If the <kbd>ComponentScan</kbd> adds a <kbd>db-bean</kbd> as well, then our local Bean overrides the Bean from the scan. As you can see, this provides you with a lot of ways to modify and monitor what your application code does when you test it.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Activity: Writing Integration Tests</h1>
                </header>
            
            <article>
                
<p><strong>Aim</strong></p>
<p>To write integration tests for the application.</p>
<p><strong>Scenario</strong></p>
<p>You should reuse the project that has been used for this chapter and open it in the IDE.</p>
<p><strong>Steps for Completion</strong></p>
<ol>
<li>Create a new integration test class on your own.</li>
</ol>
<p style="padding-left: 60px">  Take a look at this screenshot:</p>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/aafda812-ad23-454f-9223-22efc26bd431.png" style="width:42.92em;height:27.92em;" width="1622" height="1054"/></div>
<ol start="2">
<li>Create various tests for the method of the service.</li>
<li>Create a happy path test.</li>
<li>Create tests for interesting parameter combinations.</li>
<li>Fix the service code.</li>
</ol>
<p class="mce-root"/>
<p class="mce-root"/>
<p>For those of you that are advanced:</p>
<p class="mce-root">Create the following types of tests, have a look at them, and analyze their advantages/disadvantages (omit the type you created in <em>step 2</em>):</p>
<ul>
<li class="mce-root">Unit tests without Mockito</li>
<li class="mce-root">Unit tests with Mockito</li>
<li class="mce-root">Integration tests without any mocking</li>
<li class="mce-root">Integration tests with <kbd>MockBeans</kbd></li>
<li class="mce-root">Integration tests with <kbd>SpyBeans</kbd></li>
</ul>
<div class="packt_infobox"><br/>
Go to <a href="https://bit.ly/2MqhUZ4">https://bit.ly/2MqhUZ4</a> to access the code for the <kbd>BlogService</kbd> test files. <span>To refer to the detailed steps, go to the <em>Solutions</em> section at the end of </span><span>this book on page 251.<br/></span> <span><br/></span></div>
<p><strong>Outcome</strong></p>
<p>The resulting code is in the <kbd>com/packt/springboot/blogmania/blogentries/service/activity</kbd> package of the source code by going to <a href="https://bit.ly/2MqhUZ4">https://bit.ly/2MqhUZ4</a>. Take a look at this screenshot:</p>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/d9067b68-fa64-402c-b9dc-3e3ddd9cada7.png" width="1530" height="610"/></div>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, you saw how you can test a Spring application. You have experienced the simplicity and the speed of unit tests and the expressiveness and power of integration tests.</p>
<p>In the next chapter, we will start looking at web application development, so that you can create applications that really matter.</p>


            </article>

            
        </section>
    </div>



  </body></html>