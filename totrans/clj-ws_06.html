<html><head></head><body>
		<div>
			<div id="_idContainer061" class="Content">
			</div>
		</div>
		<div id="_idContainer062" class="Content">
			<h1 id="_idParaDest-131"><a id="_idTextAnchor145"/>6. Recursion and Looping</h1>
		</div>
		<div id="_idContainer072" class="Content">
			<p class="callout-heading">Overview</p>
			<p class="callout">In this chapter, you will learn more flexible ways to work with collections. When the problem you need to solve does not fit the patterns that we've looked at so far. We will also use <strong class="source-inline">doseq</strong> for loops with side effects and see how you can avoid writing some loops by using specialized repetition functions such as <strong class="source-inline">repeat</strong> and <strong class="source-inline">iterate</strong>. You will use <strong class="source-inline">recur</strong> for recursive looping and identify when this is possible, work with the <strong class="source-inline">loop</strong> macro, and solve complex problems with recursion.</p>
			<p class="callout">By the end of this chapter, you will be able to implement different aspects of recursion and see how they can replace traditional loops.</p>
			<h1 id="_idParaDest-132"><a id="_idTextAnchor146"/>Introduction</h1>
			<p>Data in our programs doesn't always take the nice, linear form for which functions such as <strong class="source-inline">map</strong> or <strong class="source-inline">reduce</strong> are particularly adapted. None of the techniques we've discussed in the last two chapters will work for traversing non-linear structures such as trees or graphs. And while it's possible to do a lot by being creative with <strong class="source-inline">reduce</strong>, the strong guard rails that <strong class="source-inline">reduce</strong> provides can sometimes get in the way of writing expressive code. There are situations that call for tools that give the programmer more control. Clojure has other resources for these kinds of problems and that is what we are going to look at in this chapter.</p>
			<p>Recursion plays a major role when functions such as <strong class="source-inline">map</strong> and <strong class="source-inline">reduce</strong> are no longer adapted to the task at hand. Thinking recursively is an important Clojure skill to learn. Because functional programming languages tend to emphasize recursion, this might seem unfamiliar if your background is in more procedural languages. Most programming languages do actually support recursion, so the concept is not necessarily that foreign. Additionally, some of the things that we have already done with <strong class="source-inline">reduce</strong> are actually recursive, so even if you've never used recursion very much before, the learning curve should not be that steep.</p>
			<p>Having said that, there are some aspects of recursion that may require you to think in new ways if you do not have much experience with functional programming. Compared to <strong class="source-inline">map</strong> and <strong class="source-inline">filter</strong>, or even <strong class="source-inline">reduce</strong>, recursive approaches are far more flexible. And by "flexible," we mean powerful but easy to get wrong. When trying to get a recursive function to do just what we want, we make mistakes and end up in infinite loops, blowing the call stack (we'll discuss what that means shortly) or getting other kinds of errors that would simply not be possible otherwise. This is why "looping," whether it's with the <strong class="source-inline">loop</strong> macro or with recursive functions, should always be what you turn to when the other options just won't work.</p>
			<h1 id="_idParaDest-133"><a id="_idTextAnchor147"/>Clojure's Most Procedural Loop: doseq</h1>
			<p>Before we get started with recursion, let's take a look at the <strong class="source-inline">doseq</strong> macro. It is arguably the most procedural of Clojure's looping alternatives. At least, it looks a lot like the <strong class="source-inline">foreach</strong> loop found in other languages. Here's a very simple use of <strong class="source-inline">doseq</strong>:</p>
			<p class="source-code">user&gt; (doseq [n (range 5)]</p>
			<p class="source-code">    (println (str "Line " n)))</p>
			<p class="source-code">Line 0</p>
			<p class="source-code">Line 1</p>
			<p class="source-code">Line 2</p>
			<p class="source-code">Line 3</p>
			<p class="source-code">Line 4</p>
			<p class="source-code">nil</p>
			<p>Translated into English, we might say: "For each integer from 0 to 5, print out a string with the word 'Line' and the integer." You might ask: "<em class="italic">What is that nil doing there?</em>" Good question. <strong class="source-inline">doseq</strong> always returns <strong class="source-inline">nil</strong>. In other words, <strong class="source-inline">doseq</strong> doesn't collect anything. The sole purpose of <strong class="source-inline">doseq</strong> is to perform side effects, such as printing to the REPL, which is what <strong class="source-inline">println</strong> does here. The strings that appear in your REPL—<strong class="source-inline">Line 0</strong>, <strong class="source-inline">Line 1</strong>, and so on—are not returned values; they are side effects.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">In Clojure, like in many languages in the Lisp family, functions that produce side effects often have names that end with an exclamation point. While it's not a firm rule, this convention does make code easier to read and helps to remind us to be careful of side effects. Clojure developers often use an exclamation point to indicate that a function modifies a mutable data structure, writes to a file or a database, or performs any kind of operation that produces a lasting effect outside the scope of the function.</p>
			<p>So, why not just use <strong class="source-inline">map</strong>? Well, there are a couple of good reasons. The first is that <strong class="source-inline">map</strong> does not guarantee that the entire sequence will be executed. The <strong class="source-inline">map</strong> function is lazy, and <strong class="source-inline">doseq</strong> is not.</p>
			<p>Generally, with <strong class="source-inline">map</strong>, <strong class="source-inline">filter</strong>, <strong class="source-inline">reduce</strong>, and all the other sequence-manipulating functions, you should always try to use <strong class="bold">pure functions</strong>, that is, functions without side effects. The exception to this rule is debugging, in which case a carefully placed <strong class="source-inline">println</strong> statement can be a lifesaver. (Remember, though, that <strong class="source-inline">println</strong> returns <strong class="source-inline">nil</strong>, so you have to be careful not to place it at the end of a function where it would mask the return value). With sequential data of some sort, it's important to use <strong class="source-inline">doseq</strong> when you want to produce side effects, and only then. By being strict about this, you also make your code easier to read and maintain. <strong class="source-inline">doseq</strong> is a flag in your source code that says: "Be careful, there are side effects here!" It is also a clear signal that we are not interested in the return value, since <strong class="source-inline">doseq</strong> always returns <strong class="source-inline">nil</strong>. This practice encourages developers to isolate code with side effects in specific parts of a program.</p>
			<p>But what if we only wanted to print something on odd-numbered lines in the previous example? Here's one way we could do that:</p>
			<p class="source-code">(doseq [n (range 5)]</p>
			<p class="source-code"> (when (odd? n)</p>
			<p class="source-code">  (println (str "Line " n))))</p>
			<p>There is nothing wrong with this code per se. As a general rule, though, it would be preferable to remove as much logic as possible from the body of <strong class="source-inline">doseq</strong>, perhaps doing something like this:</p>
			<p class="source-code">(doseq [n (filter odd? (range 5))]</p>
			<p class="source-code">    (println (str "Line " n)))</p>
			<p>By enforcing the separation between the place where we shape our data and the place where the data is consumed, not only have we removed a conditional, but we've also organized our code in a way that opens the door to better practices. Maybe in the future, we will need to choose differently which lines to print. If that happens, our code is already in the right place, written in the clear vocabulary of Clojure sequence handling, and possibly benefiting from lazy evaluation. Remember: shape the data, and then use the data.</p>
			<h2 id="_idParaDest-134"><a id="_idTextAnchor148"/>Looping Shortcuts</h2>
			<p>Generally, it is best to avoid writing real loops. Clojure provides some interesting functions that can help in some simple cases where what you really want is just a <strong class="bold">repetition</strong> of some kind. Unlike most of the techniques in this chapter, these functions return lazy sequences. We mention them here because many times, when a loop might seem necessary at first, these functions provide a simpler solution.</p>
			<p>The simplest possible example is the <strong class="source-inline">repeat</strong> function, which is so simple that it barely qualifies as a looping construct. However, it can still come in handy from time to time. <strong class="source-inline">repeat</strong> simply repeats whatever value it is called with, returning a lazy sequence of that value. Here's an easy way to repeat yourself:</p>
			<p class="source-code">user&gt; (take 5 (repeat "myself"))</p>
			<p class="source-code">("myself" "myself" "myself" "myself" "myself")</p>
			<p>Yes, it's that simple. Still, it can be useful if you need to quickly load default values into a map. Imagine a game where each player is represented by a map. You need to initialize the player with default values for various counters and most of them have a default of <strong class="source-inline">0</strong>. One way to do this is to use <strong class="source-inline">repeat</strong>. Since <strong class="source-inline">repeat</strong> returns a lazy sequence, it will supply just as many zeros as you need:</p>
			<p class="source-code">user&gt; (zipmap [:score :hits :friends :level :energy :boost] (repeat 0))</p>
			<p class="source-code">{:score 0, :hits 0, :friends 0, :level 0, :energy 0, :boost 0}</p>
			<p>The next step beyond <strong class="source-inline">repeat</strong> is the <strong class="source-inline">repeatedly</strong> function. Instead of taking a value, <strong class="source-inline">repeatedly</strong> takes a function and returns a lazy sequence of calls to that function. The function provided to <strong class="source-inline">repeatedly</strong> cannot take any arguments, which limits its usefulness to <strong class="bold">impure functions</strong>, that is, functions whose return values do not depend on inputs, perhaps consulting some kind of external data store or sensor. Otherwise, if the function always returned the same value, <strong class="source-inline">repeatedly</strong> would return a list of identical values just like <strong class="source-inline">repeat</strong>.</p>
			<p>Probably the most common use of <strong class="source-inline">repeatedly</strong> is producing a sequence of random values. A call to <strong class="source-inline">rand-int</strong> potentially varies every time we call it (unless, of course, you call <strong class="source-inline">(rand-int 1)</strong>, which can only ever return <strong class="source-inline">0</strong>.) Here's a good way of producing a list of random integers from 0 to 100, where <strong class="source-inline">repeatedly</strong> simply calls <strong class="source-inline">rand-int</strong> 10 times. The output from <strong class="source-inline">rand-int</strong> is different nearly every time it's called, so the resulting sequence is a series of random integers: </p>
			<p class="source-code">user&gt; (take 10 (repeatedly (partial rand-int 100)))</p>
			<p class="source-code">(21 52 38 59 86 73 53 53 60 90)</p>
			<p>As a convenience, <strong class="source-inline">repeatedly</strong> can take an integer argument that limits the number of values returned. We could write the previous expression without calling <strong class="source-inline">take</strong>, like this:</p>
			<p class="source-code">user&gt; (repeatedly 10 (partial rand-int 100))</p>
			<p class="source-code">(55 0 65 34 64 19 21 63 25 94)</p>
			<p>In the next exercise, we'll try a more complex scenario using <strong class="source-inline">repeatedly</strong> to generate random test data.</p>
			<p>The next step beyond <strong class="source-inline">repeatedly</strong> is a function called <strong class="source-inline">iterate</strong>. Like <strong class="source-inline">repeatedly</strong>, <strong class="source-inline">iterate</strong> calls a function over and over again, returning the resulting lazy sequence. Unlike <strong class="source-inline">repeatedly</strong>, though, the function provided to <strong class="source-inline">iterate</strong> takes arguments, and the result of each call is passed on to the next iteration.</p>
			<p>Let's say we have a bank account that returns an annual rate of 1% and we want to project what the balance will be each month for the next year. We could write a function like this:</p>
			<p class="source-code">user&gt; (defn savings [principal yearly-rate]</p>
			<p class="source-code">    (let [monthly-rate (+ 1 (/ yearly-rate 12))]</p>
			<p class="source-code">     (iterate (fn [p] (* p monthly-rate)) principal)))</p>
			<p>To predict the balances over the next 12 months, we have will ask for 13 months, since the first value returned is the starting balance:</p>
			<p class="source-code">user&gt; (take 13 (savings 1000 0.01))</p>
			<p class="source-code">(1000</p>
			<p class="source-code"> 1000.8333333333333</p>
			<p class="source-code"> 1001.667361111111</p>
			<p class="source-code"> 1002.5020839120368</p>
			<p class="source-code"> 1003.3375023152968</p>
			<p class="source-code"> 1004.1736169005594</p>
			<p class="source-code"> 1005.0104282479765</p>
			<p class="source-code"> 1005.847936938183</p>
			<p class="source-code"> 1006.6861435522981</p>
			<p class="source-code"> 1007.5250486719249</p>
			<p class="source-code"> 1008.3646528791514</p>
			<p class="source-code"> 1009.2049567565506</p>
			<p class="source-code"> 1010.045960887181)</p>
			<p>By compounding the interest every month, you have already earned almost 5 cents more than the annual rate!</p>
			<p>Functions such as <strong class="source-inline">repeatedly</strong> and <strong class="source-inline">iterate</strong> can be used in very specific situations where they perfectly match what you need. The real world is often just a little bit more complicated though. Sometimes, the task at hand will require writing customized ways of moving through your data. It's time to move on to recursion.</p>
			<h2 id="_idParaDest-135"><a id="_idTextAnchor149"/>Exercise 6.01: An Endless Stream of Groceries</h2>
			<p>Your employer is building a system to automatically handle groceries coming down a conveyor belt. As part of their research, they want you to build a simulator. The goal is to have an endless stream of random groceries. Your job is to write a function to do this:</p>
			<ol>
				<li>Create a new directory in a convenient place; add a <strong class="source-inline">deps.edn</strong> file containing just an empty map and start a new REPL.</li>
				<li>Open a new file with an expressive name such as <strong class="source-inline">groceries.clj</strong> and include the corresponding namespace declaration:<p class="source-code">(ns groceries)</p><p>Before we start, we need to build our grocery store simulator. The first step is to define all the possible articles. (This store doesn't offer a lot of choices, but at least it has them in infinite supply.) Copy the <strong class="source-inline">grocery-articles</strong> variable from <a href="https://packt.live/2tuSvd1">https://packt.live/2tuSvd1</a> into your REPL and evaluate it:</p><p class="source-code-heading">grocery_store.clj</p><p class="source-code">3  (def grocery-articles [{:name "Flour"</p><p class="source-code">4               :weight 1000   ; grams</p><p class="source-code">5               :max-dimension 140 ; millimeters</p><p class="source-code">6              }</p><p class="source-code">7              {:name "Bread"</p><p class="source-code">8              :weight 350</p><p class="source-code">9              :max-dimension 250}</p><p class="source-code">10             {:name "Potatoes"</p><p class="source-code">11             :weight 2500</p><p class="source-code">12             :max-dimension 340}</p><p class="source-code">13             {:name "Pepper"</p><p class="source-code">14             :weight 85</p><p class="source-code">15             :max-dimension 90}</p><p class="source-code-link">The full file is available at <a href="https://packt.live/35r3Xng">https://packt.live/35r3Xng</a>.</p></li>
				<li>Define a function that will return long lists of randomly ordered grocery articles:<p class="source-code">(defn article-stream [n] </p><p class="source-code"> (repeatedly n #(rand-nth grocery-articles)))</p><p><strong class="source-inline">rand-nth</strong> returns a randomly selected item from <strong class="source-inline">grocery-articles</strong> each time it is called. <strong class="source-inline">repeatedly</strong> creates a lazy sequence of calls to <strong class="source-inline">rand-nth</strong>. The <strong class="source-inline">n</strong> argument tells <strong class="source-inline">repeatedly</strong> how many random articles to return.</p></li>
				<li>Test the function by asking for some articles:<p class="source-code">groceries&gt; (article-stream 12)</p><p class="source-code">({:name "Olive oil", :weight 400, :max-dimension 280}</p><p class="source-code"> {:name "Potatoes", :weight 2500, :max-dimension 340}</p><p class="source-code"> {:name "Green beans", :weight 300, :max-dimension 120}</p><p class="source-code"> {:name "Potatoes", :weight 2500, :max-dimension 340}</p><p class="source-code"> {:name "Flour", :weight 1000, :max-dimension 140}</p><p class="source-code"> {:name "Ice cream", :weight 450, :max-dimension 200}</p><p class="source-code"> {:name "Potatoes", :weight 2500, :max-dimension 340}</p><p class="source-code"> {:name "Green beans", :weight 300, :max-dimension 120}</p><p class="source-code"> {:name "Potatoes", :weight 2500, :max-dimension 340}</p><p class="source-code"> {:name "Ice cream", :weight 450, :max-dimension 200}</p><p class="source-code"> {:name "Pepper", :weight 85, :max-dimension 90}</p><p class="source-code"> {:name "Bread", :weight 350, :max-dimension 250})</p></li>
				<li>Try again to make sure that the results are random:<p class="source-code">groceries&gt; (article-stream 5)</p><p class="source-code">({:name "Potatoes", :weight 2500, :max-dimension 340}</p><p class="source-code"> {:name "Green beans", :weight 300, :max-dimension 120}</p><p class="source-code"> {:name "Bread", :weight 350, :max-dimension 250}</p><p class="source-code"> {:name "Olive oil", :weight 400, :max-dimension 280}</p><p class="source-code"> {:name "Pepper", :weight 85, :max-dimension 90})</p><p>It seems to work. This shows how functions can be combined in cases where, in other languages, it might seem more natural to write a <strong class="source-inline">for</strong> loop. In JavaScript once again, we might write a function like this (assuming that <strong class="source-inline">groceryArticles</strong> is an array of objects):</p><p class="source-code">function randomArticles (groceryArticles, n) {</p><p class="source-code"> var articles = [];</p><p class="source-code"> for (var i = 0; i &lt; n.length; i++) {</p><p class="source-code">  articles.push(</p><p class="source-code">  groceryArticles[Math.random(groceryArticles.length – 1)]</p><p class="source-code">  );</p><p class="source-code"> }</p><p class="source-code"> return articles;</p><p class="source-code">}</p><p>A function such as <strong class="source-inline">repeatedly</strong> provides a concise way to express this and saves us the trouble of writing all this iterative logic.</p></li>
			</ol>
			<h2 id="_idParaDest-136"><a id="_idTextAnchor150"/>Recursion at Its Simplest</h2>
			<p>As we said before, a recursive function is a function that, as part of its execution, calls itself. Visually, recursion can be imagined as something like one of those pictures you've probably seen, where, inside the main picture, there is a smaller version of the original picture. Since the second picture is identical to the first, it also contains a very small, third version of the picture. After that, any further pictures are usually hard to represent as something bigger than a tiny dot. However, even if we can't see them, we can imagine the process going on for basically forever… or at least down to the molecular level. Recursion works in a similar way. And the problem of a recursive process that just keeps going on and on, like in the picture, is also a very real issue. However, before we look at the pitfalls of recursion, let's take a look at some simple examples.</p>
			<p>To start out, we'll do something you already know how to do: find the sum of a collection of numbers. In real life, you would never use recursion for this, but the problem is deliberately simple so that we can point out some of the mechanisms of recursion:</p>
			<p class="source-code">(defn recursive-sum [so-far numbers]</p>
			<p class="source-code"> (if (first numbers)</p>
			<p class="source-code">  (recursive-sum</p>
			<p class="source-code">   (+ so-far (first numbers))</p>
			<p class="source-code">   (next numbers))</p>
			<p class="source-code">  so-far))</p>
			<p>A call to this function would look like this:</p>
			<p class="source-code">user&gt; (recursive-sum 0 [300 25 8])</p>
			<p class="source-code">333</p>
			<p>This probably looks familiar to you because this is quite similar to the functions we passed to <strong class="source-inline">reduce</strong>. This isn't too surprising. We could even think of <strong class="source-inline">reduce</strong> as a framework for "controlled recursion," or "recursion with guardrails," which is why it's generally best to use <strong class="source-inline">reduce</strong> when you can, and recursion only when you must.</p>
			<p>There are some important differences here though, so let's take a closer look at how this function works. The first thing to notice is the conditional with two branches: <strong class="source-inline">(if (first numbers))</strong>. When we first call the function, <strong class="source-inline">(first numbers)</strong> returns 300. That's truthy, so we keep going, and right away our functions call <strong class="source-inline">recursive-sum</strong> again (we warned you, there's going to be a lot of this in recursion.) The function gets called again but with different arguments: <strong class="source-inline">(first numbers)</strong> gets added to <strong class="source-inline">so-far</strong>, our accumulator, and instead of using numbers again as the second argument, we have <strong class="source-inline">(next numbers)</strong>.</p>
			<p>With each call to <strong class="source-inline">recursive-sum</strong>, one more integer is shifted from the input sequence to the output integer:</p>
			<div>
				<div id="_idContainer063" class="IMG---Figure">
					<img src="image/B14502_06_01.jpg" alt="Figure 6.1: Recursively moving items from the input sequence to the output integer&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.1: Recursively moving items from the input sequence to the output integer</p>
			<p>With <strong class="source-inline">reduce</strong>, we don't need to think about how to advance through the sequence. The <strong class="source-inline">reduce</strong> function itself takes care of the mechanics of the iterations: moving from one item to the next and stopping when there are no more items. With a recursive function, it's up to us to make sure that each function call receives the right data and that the function stops when the data has been consumed. When you need it, recursion is extremely powerful because, as the programmer, you have complete control over the iteration. You get to decide what the arguments of each successive call will hold. You also get to decide how and when the recursion will stop.</p>
			<p>So, how do we move through the sequence? On each call to <strong class="source-inline">recursive-sum</strong>, the input sequence is split between the first item and all the following items. The call to <strong class="source-inline">first</strong> gives us the current item, and the call to <strong class="source-inline">next</strong> helps set up the argument for the next function call. Repeating this splitting action moves us down the sequence.</p>
			<p>There is one more problem, though: when do we stop? This is why our function, like the vast majority of recursive functions, is organized around a condition. Ours is simple: stop adding or keep going? The <strong class="source-inline">next</strong> function is important here too. When called on an empty list, <strong class="source-inline">next</strong> returns <strong class="source-inline">nil</strong>:</p>
			<p class="source-code">user&gt; (next '())</p>
			<p class="source-code">nil</p>
			<p>In this case, <strong class="source-inline">nil</strong> reliably means that it is time to stop iterating and just return the value that we have accumulated. More complex situations will require more complicated branching, but the basic idea generally remains the same.</p>
			<h2 id="_idParaDest-137">E<a id="_idTextAnchor151"/>xercise 6.02: Partitioning Grocery Bags</h2>
			<p>In this exercise, we'll go back to the grocery conveyor belt simulation from the previous exercise. Now that we can simulate an endless stream of random articles, we need to be able to place the food items into grocery bags as they arrive at the end of the belt. If the bag gets too full, it will break or start to overflow. We need to know when to stop before it gets too full. Luckily, a barcode reader can tell us the weight and longest dimension of the items. If either of these gets beyond a certain number, the bag is removed and replaced with an empty bag:</p>
			<ol>
				<li value="1">Use the same environment as in the previous exercise.</li>
				<li>Our grocery bags will be modeled as lists of articles. Define a <strong class="source-inline">full-bag?</strong> predicate so that we'll know when to stop filling a bag:<p class="source-code">(defn full-bag? [items]</p><p class="source-code"> (let [weight (apply + (map :weight items))</p><p class="source-code">    size (apply + (map :max-dimension items))]</p><p class="source-code">  (or (&gt; weight 3200)</p><p class="source-code">    (&gt; size 800))))</p></li>
				<li>Test <strong class="source-inline">full-bag?</strong> with the output from grocery streams of different lengths:<p class="source-code">groceries&gt; (full-bag? (article-stream 10))</p><p class="source-code">true</p><p class="source-code">groceries&gt; (full-bag? (article-stream 1))</p><p class="source-code">false</p><p class="source-code">groceries&gt; (full-bag? (article-stream 1000))</p><p class="source-code">true</p><p class="source-code">groceries&gt; (full-bag? '())</p><p class="source-code">false</p></li>
				<li>Set up two functions, <strong class="source-inline">bag-sequences</strong> and its recursive helper function, <strong class="source-inline">bag-sequences*</strong>. Define <strong class="source-inline">bag-sequences*</strong> first, since <strong class="source-inline">bag-sequences</strong> will call it:<p class="source-code">(defn bag-sequences* [{:keys [current-bag bags] :as acc} stream]</p><p class="source-code"> ;; TODO: write code</p><p class="source-code">)</p><p class="source-code">(defn bag-sequences [stream]</p><p class="source-code"> (bag-sequences* {:bags []</p><p class="source-code">          :current-bag []} stream))</p><p>As you can see from the arguments to the helper function, we've defined an accumulator, this time with two fields: <strong class="source-inline">:bags</strong> will hold the list of all the completed bags and <strong class="source-inline">:current-bag</strong> will hold the items we are testing. When <strong class="source-inline">:current-bag</strong> fills up, we will place it in <strong class="source-inline">:bags</strong> and start off with a fresh, empty vector in <strong class="source-inline">:current-bag</strong>.</p><p>The second function, without the asterisk, will be the public-facing function. Users of our library won't have to worry about supplying the accumulator; <strong class="source-inline">bag-sequences*</strong> will be the truly recursive function and do all the work.</p></li>
				<li>Inside the <strong class="source-inline">bag-sequences*</strong> function, we will use a <strong class="source-inline">cond</strong> expression to react to the state of the articles as they arrive. Write the first, negative condition of the <strong class="source-inline">cond</strong> expression: <p class="source-code">(defn bag-sequences* [{:keys [current-bag bags] :as acc} stream]</p><p class="source-code"> (cond</p><p class="source-code">  (not stream)</p><p class="source-code">  (conj bags current-bag)</p><p class="source-code">  ;; TODO: the other cond branches</p><p class="source-code">  ))</p><p>Here, we decide what happens if there are no more articles in <strong class="source-inline">stream</strong>. If there's nothing left to put in the bag, then it's time to add <strong class="source-inline">current-bag</strong> to the list and return everything we've accumulated so far.</p><p class="callout-heading">Note</p><p class="callout">In recursive functions, it's common practice to test whether the end of the input sequence has been reached as early as possible. This test is often a simple one, so it's good to get it out of the way. More importantly, if we know that the input sequence is not empty, we don't have to guard against <strong class="source-inline">nil</strong> values in the tests that follow. This helps eliminate some possible errors in the subsequent test clauses and allows us to write simpler, more readable code.</p></li>
				<li>Add the condition for when the current bag is full:<p class="source-code">(defn bag-sequences* [{:keys [current-bag bags] :as acc} stream]</p><p class="source-code"> (cond</p><p class="source-code">  (not stream)</p><p class="source-code">  (conj bags current-bag)</p><p class="source-code">  (full-bag? (conj current-bag (first stream)))</p><p class="source-code">  (bag-sequences* (assoc acc</p><p class="source-code">              :current-bag [(first stream)]</p><p class="source-code">              :bags (conj bags current-bag))</p><p class="source-code">          (next stream))</p><p class="source-code">  ;; TODO: one more branch, for when the bag is not full yet</p><p class="source-code">  ))</p><p>Thanks to the convenient <strong class="source-inline">full-bag?</strong> function, we know that the current bag is full. This means we need to move some data around inside <strong class="source-inline">acc</strong> when we make the next call to <strong class="source-inline">bag-sequences*</strong>. Both of the arguments to <strong class="source-inline">bag-sequences*</strong> need to be updated. Our call to <strong class="source-inline">assoc</strong> may look strange at first glance, but <strong class="source-inline">assoc</strong> can accept multiple pairs of keys and values.</p><p>The most recent article in <strong class="source-inline">stream</strong> is going to become the first article in a new "bag" vector, so we assign that to the <strong class="source-inline">:current-bag</strong> key in <strong class="source-inline">acc</strong>. At this point, the <strong class="source-inline">current-bag</strong> binding (from the destructuring in the function's parameters) still refers to the bag we decided is full. We are going to add it to the list of bags we are maintaining in the <strong class="source-inline">:bags</strong> key in <strong class="source-inline">acc</strong>.</p><p>And since we want to keep advancing through <strong class="source-inline">stream</strong>, we use <strong class="source-inline">next</strong> to move on to the next article: <strong class="source-inline">(next stream)</strong>.</p></li>
				<li>Write the final, default condition. If we've made it past the two previous conditions, we know that <strong class="source-inline">stream</strong> is not empty and that the current bag is not full. In this case, all we need to do is add the current article to the current bag. With this condition, our function is complete:<p class="source-code">(defn bag-sequences* [{:keys [current-bag bags] :as acc} stream]</p><p class="source-code"> (cond</p><p class="source-code">  (not stream)</p><p class="source-code">  (conj bags current-bag)</p><p class="source-code">  (full-bag? (conj current-bag (first stream)))</p><p class="source-code">  (bag-sequences* (assoc acc</p><p class="source-code">              :current-bag [(first stream)]</p><p class="source-code">              :bags (conj bags current-bag))</p><p class="source-code">          (next stream))</p><p class="source-code">  :otherwise-bag-not-full</p><p class="source-code">  (bag-sequences* (update acc :current-bag conj (first stream))</p><p class="source-code">          (next stream))))</p><p>This time, we'll use <strong class="source-inline">update</strong> instead of <strong class="source-inline">assoc</strong> to "modify" the <strong class="source-inline">:current-bag</strong> key in <strong class="source-inline">acc</strong>. This form of the <strong class="source-inline">update</strong> function takes, as its third argument, a function that will be applied to the value corresponding to the key provided and any further arguments. That means that, in this case, <strong class="source-inline">conj</strong> will be called as if we had written <strong class="source-inline">(conj (:current-bag acc) (first stream))</strong>. </p></li>
				<li>Test the function using the <strong class="source-inline">article-stream</strong> function that we wrote in the previous exercise:<p class="source-code">groceries&gt; (bag-sequences (article-stream 12))</p><p class="source-code">[[{:name "Pepper", :weight 85, :max-dimension 90}</p><p class="source-code"> {:name "Pepper", :weight 85, :max-dimension 90}</p><p class="source-code"> {:name "Green beans", :weight 300, :max-dimension 120}</p><p class="source-code"> {:name "Flour", :weight 1000, :max-dimension 140}</p><p class="source-code"> {:name "Olive oil", :weight 400, :max-dimension 280}]</p><p class="source-code"> [{:name "Bread", :weight 350, :max-dimension 250}</p><p class="source-code"> {:name "Pepper", :weight 85, :max-dimension 90}</p><p class="source-code"> {:name "Green beans", :weight 300, :max-dimension 120}</p><p class="source-code"> {:name "Olive oil", :weight 400, :max-dimension 280}]</p><p class="source-code">  [{:name "Potatoes", :weight 2500, :max-dimension 340}</p><p class="source-code"> {:name "Bread", :weight 350, :max-dimension 250}]]</p><p>This seems to work! Each bag appears as a vector of items. The length of the vectors varies depending on the size and weight of the items.</p></li>
			</ol>
			<p>We've solved one of the problems we mentioned at the beginning of the chapter: traversing a sequence in steps of different lengths. In this example, we've partitioned the input sequence into chunks whose size depends on the properties of the underlying data. </p>
			<h2 id="_idParaDest-138">W<a id="_idTextAnchor152"/>hen to Use recur</h2>
			<p>Now, <strong class="source-inline">bag-sequence</strong> worked fine for relatively short <strong class="source-inline">grocery-stream</strong> sequences, but when we moved it into production in our multimodal grocery mega-platform, the entire system ground quickly to a halt. Here's the message that appeared on all the technicians' consoles:</p>
			<p class="source-code">packt-clj.recursion&gt; (def production-bags (bag-sequences (article-stream 10000)))</p>
			<p class="source-code">Execution error (StackOverflowError) at packt-clj.recursion/article-stream$fn (recursion.clj:34).</p>
			<p class="source-code">null</p>
			<p>So, what happened? What's a <strong class="source-inline">StackOverflowError</strong>?</p>
			<p>The <strong class="bold">stack</strong> is how the JVM keeps track of nested function calls. Each function call requires a little bit of bookkeeping to maintain some contextual information, such as the value of local variables. The runtime also needs to know where the results of each call should go. When a function is called within another function, the outer function waits for the inner function to complete. If the inner function also calls other functions, it too must wait for those to complete, and so on. The job of the stack is to keep track of these chains of function calls.</p>
			<p>We can use a very simple function as an illustration. This one takes two integers and performs two different operations on them:</p>
			<p class="source-code">user&gt; (defn tiny-stack [a b]</p>
			<p class="source-code">    (* b (+ a b)))</p>
			<p class="source-code">#'user/tiny-stack</p>
			<p class="source-code">user&gt; (tiny-stack 4 7)</p>
			<p class="source-code">77</p>
			<p>Here's a simplified version of what happens when we call <strong class="source-inline">tiny-stack</strong>:</p>
			<p>We call <strong class="source-inline">tiny-stack</strong> and an initial stack frame is produced. It waits for the contents of the function to be evaluated.</p>
			<p>While <strong class="source-inline">tiny-stack</strong> waits, the <strong class="source-inline">*</strong> function is called. A new stack frame is produced. The <strong class="source-inline">b</strong> binding evaluates right away, but it can't return yet because of the call to <strong class="source-inline">+</strong>.</p>
			<p><strong class="source-inline">+</strong> is finally called, producing a new, short-lived stack frame. The two integers are added together, the value is returned, and the stack frame of <strong class="source-inline">+</strong> is erased.</p>
			<p>The call to <strong class="source-inline">*</strong> can now complete. It passes its return value back up to <strong class="source-inline">tiny-stack</strong> and then its stack frame is erased.</p>
			<p><strong class="source-inline">tiny-stack</strong> returns <strong class="source-inline">77</strong> and its stack frame is erased:</p>
			<div>
				<div id="_idContainer064" class="IMG---Figure">
					<img src="image/B14502_06_02.jpg" alt="Figure 6.2: A visualization of stack frames in nested function calls&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.2: A visualization of stack frames in nested function calls</p>
			<p>This is how the stack frame is supposed to work. Most of the time, we don't have to think about it at all. However, when we use recursion to walk the length of a sequence, we are actually using the stack, through nesting, to move along the sequence. Because there are limits to how many stack frames the runtime can handle, if we have a very long sequence, we will eventually run out of stack frames and our program will explode:</p>
			<div>
				<div id="_idContainer065" class="IMG---Figure">
					<img src="image/B14502_06_03.jpg" alt="Figure 6.3: Representation of recursion&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.3: Representation of recursion</p>
			<p>With recursion, the length of the input vector is translated into depth in the call stack until it goes too far</p>
			<p>At this point, you're probably thinking that recursion doesn't sound like such a great pattern after all. This is actually due to a limitation that is built into the JVM. Other Lisps, not based on the JVM, do not have this limitation, and, in those languages, the preceding code would work just fine.</p>
			<p>There is, however, a solution in Clojure, and it is called <strong class="source-inline">recur</strong>. Let's take another look at the <strong class="source-inline">recursive-sum</strong> function that we wrote in the last section:</p>
			<p class="source-code">(defn recursive-sum [so-far numbers]</p>
			<p class="source-code"> (if (first numbers)</p>
			<p class="source-code">  (recursive-sum</p>
			<p class="source-code">   (+ so-far (first numbers))</p>
			<p class="source-code">   (next numbers))</p>
			<p class="source-code">  so-far))</p>
			<p>First, let's watch this explode on a long input sequence:</p>
			<p class="source-code">user&gt; (recursive-sum 0 (range 10000))</p>
			<p class="source-code">Execution error (StackOverflowError) at user/recursive-sum (REPL:53).</p>
			<p class="source-code">null</p>
			<p>To use <strong class="source-inline">recur</strong>, we simply replace the call to <strong class="source-inline">recursive-sum</strong> with the <strong class="source-inline">recur</strong> in our original equation:</p>
			<p class="source-code">user&gt; (defn safe-recursive-sum [so-far numbers]</p>
			<p class="source-code">    (if (first numbers)</p>
			<p class="source-code">     (recur</p>
			<p class="source-code">      (+ so-far (first numbers))</p>
			<p class="source-code">      (next numbers))</p>
			<p class="source-code">     so-far))</p>
			<p class="source-code">#'user/safe-recursive-sum</p>
			<p class="source-code">user&gt; (safe-recursive-sum 0 (range 10000))</p>
			<p class="source-code">49995000</p>
			<p>Why does this work? Well, with <strong class="source-inline">recur</strong>, a function becomes tail recursive. <strong class="bold">Tail recursion</strong> means that successive calls don't add to the call stack. Instead, the runtime treats them as repetitions of the current frame. You can think of this as a way of staying in the same frame rather than waiting for all the nested calls to resolve. In this way, the looping can continue without adding to the stack. This allows us to process large amounts of data without running into the dreaded stack overflow.</p>
			<p>A function can only be tail recursive if it returns a complete call to itself and nothing more. This is a little hard to understand at first, but it should become clearer as we work through some examples. In the next exercise, we'll look at a straightforward use of <strong class="source-inline">recur</strong> in a tail recursive function.</p>
			<h2 id="_idParaDest-139">Exe<a id="_idTextAnchor153"/>rcise 6.03: Large-Scale Grocery Partitioning with recur</h2>
			<p>As we mentioned before, our previous experiment with <strong class="source-inline">bag-sequences</strong> did not scale well once the input stream became too long because we ran into stack overflow exceptions. Maybe we can improve on the previous design by using <strong class="source-inline">recur</strong>:</p>
			<ol>
				<li value="1">Set up the same environment as in the previous exercise.</li>
				<li>Make a copy of the <strong class="source-inline">bag-sequences</strong> and <strong class="source-inline">bag-sequences*</strong> functions with new names, such as <strong class="source-inline">robust-bag-sequences</strong> and <strong class="source-inline">robust-bag-sequences*</strong>.</li>
				<li>In <strong class="source-inline">robust-bag-sequences*</strong>, use <strong class="source-inline">recur</strong> instead of calling <strong class="source-inline">bag-sequences*</strong>:<p class="source-code">(defn robust-bag-sequences* [{:keys [current-bag bags] :as acc} stream]</p><p class="source-code"> (cond</p><p class="source-code">  (not stream)</p><p class="source-code">  (conj bags current-bag)</p><p class="source-code">  (full-bag? (conj current-bag (first stream)))</p><p class="source-code">  (recur (assoc acc</p><p class="source-code">         :current-bag [(first stream)]</p><p class="source-code">         :bags (conj bags current-bag))</p><p class="source-code">      (next stream))</p><p class="source-code">  :otherwise-bag-not-full</p><p class="source-code">  (recur (assoc acc :current-bag (conj current-bag (first stream)))</p><p class="source-code">      (next stream))))</p><p>The only difference with the previous version of <strong class="source-inline">bag-sequences*</strong> is that we've replaced the recursive calls (where we wrote out the function name, <strong class="source-inline">bag-sequences*</strong>) with <strong class="source-inline">recur</strong>. This function is tail recursive. Why? Well, let's look at the three possible outputs that correspond to the three branches of the <strong class="source-inline">cond</strong> expression. The first branch simply returns data, so there is no recursion at all there. The other two return calls to <strong class="source-inline">recur</strong> that are the last things to be evaluated in the function. This fits our definition of tail recursion, which is that the function must return a call to itself <em class="italic">and nothing else</em>.</p></li>
				<li>In the public-facing <strong class="source-inline">robust-bag-sequences</strong> function, don't forget to update the call to <strong class="source-inline">bag-sequences*</strong> to the new function name:<p class="source-code">(defn robust-bag-sequences [stream]</p><p class="source-code"> (robust-bag-sequences* {:bags []</p><p class="source-code">             :current-bag []} stream))</p></li>
				<li>Evaluate your namespace and test the new function on a very long <strong class="source-inline">article-stream</strong>. Don't forget to assign the result to a variable, otherwise it will fill your REPL!<p>Here, we put 1 million articles into 343,091 bags:</p><p class="source-code">groceries&gt; (def bags (robust-bag-sequences (article-stream 1000000)))</p><p class="source-code">#'packt-clj.recursion/bags</p><p class="source-code">groceries&gt; (count bags)</p><p class="source-code">343091</p><p class="source-code">groceries&gt; (first bags)</p><p class="source-code">[{:name "Olive oil", :weight 400, :max-dimension 280}</p><p class="source-code"> {:name "Potatoes", :weight 2500, :max-dimension 340}]</p><p>Because the contents of <strong class="source-inline">article-stream</strong> are random, your results will be slightly different.</p><p>This example shows the basics of using <strong class="source-inline">recur</strong> to easily improve the performance of the recursive function. The <strong class="source-inline">robust-bag-sequences*</strong> function is indeed tail recursive because it returns a complete call to itself and nothing more.</p></li>
			</ol>
			<h2 id="_idParaDest-140">Wha<a id="_idTextAnchor154"/>t about loop?</h2>
			<p>As you may already know, Clojure does, in fact, have a <strong class="source-inline">loop</strong> macro. If, on hearing that, you're suddenly thinking "Great, I can just use <strong class="source-inline">loop</strong> instead!," you are probably going to be disappointed. The <strong class="source-inline">loop</strong> macro can indeed be useful, but the terrible secret of <strong class="source-inline">loop</strong> is that it is almost identical to writing a recursive function with <strong class="source-inline">recur</strong>.</p>
			<p>The advantage of the <strong class="source-inline">loop</strong> macro is that it can be contained inside a function. This removes the need to write a public function that sets up the recursion and possibly does some "post-production" on the result, and a helper function that does the actual recursion. There is nothing wrong with that pattern, of course, but using <strong class="source-inline">loop</strong> can make a namespace easier to read by limiting the number of functions that need to be defined.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Clojure provides another mechanism for avoiding public functions. Functions defined with <strong class="source-inline">defn-</strong> instead of <strong class="source-inline">defn</strong> are only available inside the namespace where they are defined.</p>
			<p>The basic logic and structure of <strong class="source-inline">loop</strong> is really quite similar to that of a function with <strong class="source-inline">recur:</strong> a call to <strong class="source-inline">loop</strong> starts with one or more bindings and, just like a recursive function, starts over again thanks to <strong class="source-inline">recur</strong>. Just like with a recursive function, the parameters to <strong class="source-inline">recur</strong> must be modified on each iteration to avoid looping infinitely. And calls to <strong class="source-inline">loop</strong> must also be tail recursive, just like functions using <strong class="source-inline">recur</strong>.</p>
			<p>Here is a simple skeleton for a function that uses <strong class="source-inline">loop</strong> to do something to the articles in our imaginary grocery store. Let's suppose that the <strong class="source-inline">process</strong> function does something important with each article, such as sending an API call to a different service. For now, we'll define it as a stub function aliased to <strong class="source-inline">identity</strong>, which is the Clojure function that simply returns whatever arguments it is provided with:</p>
			<p class="source-code">(def process identity)</p>
			<p class="source-code">(defn grocery-verification [input-items]</p>
			<p class="source-code">  (loop [remaining-items input-items</p>
			<p class="source-code">        processed-items []]</p>
			<p class="source-code">    (if (not (seq remaining-items))</p>
			<p class="source-code">      processed-items</p>
			<p class="source-code">      (recur (next remaining-items)</p>
			<p class="source-code">        (conj processed-items (process (first remaining-items)))))))</p>
			<p>Obviously, the basic pattern is very similar to the recursive functions that we've already looked at: the conditionals to detect whether to continue iterating, and the call to <strong class="source-inline">recur</strong> at the end, are starting to become very familiar to you. It's important to remember that the initial bindings are just that: initial. Just like arguments to a function, they are assigned at the beginning of the loop and then reassigned by the calls to <strong class="source-inline">recur</strong>. Making sure that the iteration continues smoothly and not infinitely is up to you.</p>
			<h2 id="_idParaDest-141">Exe<a id="_idTextAnchor155"/>rcise 6.04: Groceries with loop</h2>
			<p>Use <strong class="source-inline">loop</strong> to rewrite the <strong class="source-inline">robust-bag-sequences</strong> function from the previous exercise:</p>
			<ol>
				<li value="1">Use the same environment as the previous exercises.</li>
				<li>Write the outline for a function with the same call signature as <strong class="source-inline">robust-bag-sequences</strong>:<p class="source-code">(defn looping-robust-bag-sequences [stream]</p><p class="source-code"> )</p></li>
				<li>Set up a loop inside the function with the same arguments as <strong class="source-inline">robust-bag-sequences*</strong>:<p class="source-code">(defn looping-robust-bag-sequences [stream]</p><p class="source-code"> (loop [remaining-stream stream</p><p class="source-code">     acc {:current-bag []</p><p class="source-code">       :bags []}]</p><p class="source-code">    ;;TODO: the real work</p><p class="source-code">  ))</p><p>As you can see, the initial setup of our accumulator is going to happen in the bindings.</p></li>
				<li>Fill in the rest of the logic by reusing the code from <strong class="source-inline">robust-bag-sequences*</strong> in the previous exercise:<p class="source-code"> (defn looping-robust-bag-sequences [stream]</p><p class="source-code"> (loop [remaining-stream stream</p><p class="source-code">     acc {:current-bag []</p><p class="source-code">       :bags []}]</p><p class="source-code">  (let [{:keys [current-bag bags]} acc]</p><p class="source-code">   (cond (not remaining-stream)</p><p class="source-code">      (conj bags current-bag)</p><p class="source-code">      (full-bag? (conj current-bag (first remaining-stream)))</p><p class="source-code">      (recur (next remaining-stream)</p><p class="source-code">          (assoc acc</p><p class="source-code">             :current-bag [(first remaining-stream)]</p><p class="source-code">             :bags (conj bags current-bag)))</p><p class="source-code">      :otherwise-bag-not-full</p><p class="source-code">      (recur (next remaining-stream)</p><p class="source-code">          (assoc acc :current-bag (conj current-bag (first remaining-stream)))))))) </p><p>This version is almost the same as the original. The primary difference is that, because of the way the variables are bound, we end up using a <strong class="source-inline">let</strong> binding to destructure the accumulator in order to have the <strong class="source-inline">current-bag</strong> and <strong class="source-inline">bags</strong> bindings. Other than that, the code is the same.</p></li>
				<li>Test the new version of the function:<p class="source-code">groceries&gt; (looping-robust-bag-sequences (article-stream 8))</p><p class="source-code">[[{:name "Bread", :weight 350, :max-dimension 250}</p><p class="source-code"> {:name "Potatoes", :weight 2500, :max-dimension 340}]</p><p class="source-code"> [{:name "Potatoes", :weight 2500, :max-dimension 340}]</p><p class="source-code"> [{:name "Potatoes", :weight 2500, :max-dimension 340}</p><p class="source-code"> {:name "Olive oil", :weight 400, :max-dimension 280}]</p><p class="source-code"> [{:name "Flour", :weight 1000, :max-dimension 140}</p><p class="source-code"> {:name "Green beans", :weight 300, :max-dimension 120}</p><p class="source-code"> {:name "Pepper", :weight 85, :max-dimension 90}]]</p><p>This version of the code illustrates how similar <strong class="source-inline">loop</strong> and a recursive function can be. Choosing one form or the other depends mostly on which version will make your code easier to understand. Thinking of <strong class="source-inline">loop</strong> as a form of recursion will also make it easier to remember to write tail recursive code inside the loop.</p></li>
			</ol>
			<h2 id="_idParaDest-142">Tai<a id="_idTextAnchor156"/>l Recursion</h2>
			<p>As we said earlier, <strong class="source-inline">recur</strong> tells the JVM to expect the function to be tail recursive. What does that mean exactly, though? Replacing the function name with <strong class="source-inline">recur</strong> is not, in fact, enough to make a recursive function call tail recursive.</p>
			<p>Let's start with an example of what happens when a recursive function is <em class="italic">not</em> tail recursive. So far, we've done a lot of adding of sequences of integers. Here's a new twist: suppose the integers are not in a simple sequence, but in nested sequences, perhaps like this:</p>
			<p class="source-code">(def nested [5 12 [3 48 16] [1 [53 8 [[4 43]] [8 19 3]] 29]])</p>
			<p>Nested vectors like this are a common way of representing trees in Clojure. The vectors themselves are the branch nodes and the integers, in this case, are the leaves:</p>
			<div>
				<div id="_idContainer066" class="IMG---Figure">
					<img src="image/B14502_06_04.jpg" alt="Figure 6.4: Nested vectors are a common way of representing tree structures&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.4: Nested vectors are a common way of representing tree structures</p>
			<p>We haven't seen this kind of problem yet. It happens to be the kind of problem for which recursion is possibly the best or even the only solution. It's also an important kind of problem: these nested vectors actually define a tree structure. Trees are, of course, one of the most useful ways of representing data, so this is a fairly important subject.</p>
			<p>Essentially, to solve this problem, we need a recursive function that adds when it sees a number and calls itself when it sees a list. Here's a start that looks a lot like some of the other functions we've written so far:</p>
			<p class="source-code">(defn naive-tree-sum [so-far x]</p>
			<p class="source-code"> (cond (not x) so-far</p>
			<p class="source-code">    (integer? (first x)) (recur (+ so-far (first x)) (next x))</p>
			<p class="source-code">    ; TODO: more code</p>
			<p class="source-code">    ))</p>
			<p>The first condition in the <strong class="source-inline">cond</strong> form is pretty standard: if we're at the end of the input, we just return whatever is in <strong class="source-inline">so-far</strong>, our accumulator. The next condition should also seem pretty straightforward by now: if we have a number, add it to our running total and keep going by splitting the input sequence between the first item and the next items.</p>
			<p>Now, let's write that last condition for when <strong class="source-inline">(first x)</strong> is a vector. The new call to <strong class="source-inline">recur</strong> will need to calculate <strong class="source-inline">(first x)</strong> so that it can be an integer. Here's what that would have to look like:</p>
			<p class="source-code">(defn naive-tree-sum [so-far x]</p>
			<p class="source-code"> (cond (not x) so-far</p>
			<p class="source-code">    (integer? (first x)) (recur (+ so-far (first x)) (next x))</p>
			<p class="source-code">    (or (seq? (first x)) (vector? (first x)))</p>
			<p class="source-code">    (recur (recur so-far (first x)) (next x)))) ;; Warning!!!</p>
			<p>If you type this into your REPL and evaluate it, you'll get an error:</p>
			<p class="source-code">1. Caused by java.lang.UnsupportedOperationException</p>
			<p class="source-code">  Can only recur from tail position</p>
			<p>What's going on? Why doesn't this work?</p>
			<p>On the surface, we're just respecting the established pattern. The nested call to <strong class="source-inline">recur</strong> does look a little strange. But if <strong class="source-inline">(first x)</strong> is a vector or a list, we can't just add it to <strong class="source-inline">so-far</strong>. Our function needs an integer as the <strong class="source-inline">so-far</strong> argument. We need to transform the vector at <strong class="source-inline">(first x)</strong> into an integer by evaluating that entire part of the tree. And when that's done, and we have a nice, simple integer instead of a subtree, we can finally move on to the rest of the sequence, with <strong class="source-inline">(next x)</strong>.</p>
			<p>The reason that the compiler refuses to compile our code, though, is that, because of the final line, the function is not tail recursive. In the last line of the function, the first <strong class="source-inline">recur</strong> has to wait for the second one to finish before moving on. That is a violation of the tail position requirement of <strong class="source-inline">recur</strong>: simultaneous calls to <strong class="source-inline">recur</strong> are forbidden. As we said before, to be tail recursive, a function must return only a call to itself, and nothing more. But in this case, one <strong class="source-inline">recur</strong> is waiting for the other to return.</p>
			<p>We could also think about this in terms of stack frames. Tail recursion means that when the recursive function is called again (through <strong class="source-inline">recur</strong>), a new frame is not produced: the previous function call is "forgotten," or "erased," by the new one. The only trace of the previous calls is in the changes made to the arguments to the current call. The problem with this function is that the first call to <strong class="source-inline">recur</strong> can't be "forgotten." It's waiting for the result of the second call. It's only when the second call is resolved that the first will be able to continue. If we're in a situation where two stack frames need to coexist, we can't use <strong class="source-inline">recur</strong>. When treating linear data, this is generally not a problem. Tree structures, on the other hand, usually can't be handled in the linear way required by <strong class="source-inline">recur</strong>.</p>
			<p>Let's try rewriting the same function without using <strong class="source-inline">recur</strong>:</p>
			<p class="source-code">user&gt; (defn less-naive-tree-sum [so-far x]</p>
			<p class="source-code">        (cond (not x) so-far</p>
			<p class="source-code">          (integer? (first x)) (less-naive-tree-sum (+ so-far (first x)) (next x))</p>
			<p class="source-code">          (or (seq? (first x)) (vector? (first x)))</p>
			<p class="source-code">          (less-naive-tree-sum (less-naive-tree-sum so-far (first x)) (next x))))</p>
			<p class="source-code">#'user/less-naive-tree-sum</p>
			<p class="source-code">user&gt; (less-naive-tree-sum 0 nested)</p>
			<p class="source-code">252</p>
			<p>This works! We might have a new problem, though. Without <strong class="source-inline">recur</strong>, this version of the function will explode the stack when run on a tree with too many items. This may, or may not, be a problem, depending on what kind of data needs to be processed. If we did have many thousands of items and sub-vectors, we would need to find another solution. For that, you'll need to wait until the next chapter, where we'll learn about producing our own <strong class="bold">lazy sequences</strong>, which will permit us to use recursion on large, complex trees.</p>
			<p>Recursion without <strong class="source-inline">recur</strong> and without lazy sequences can work just fine in many cases, though. When the input data is not in the thousands or millions of items, "normal" non-lazy recursion will probably be all you need. For now, the important thing is to understand that there are limits to when <strong class="source-inline">recur</strong> can be used. Luckily, many of the tasks you'll need to accomplish with recursion fit nicely into a tail recursive pattern. And don't worry: if you forget, the compiler is always there to remind you.</p>
			<h1 id="_idParaDest-143"><a id="_idTextAnchor157"/>Solving Complex Problems with Recursion</h1>
			<p>When we talk about recursion, there are really two categories of use cases that are quite different from each other. This is particularly true of Clojure. On the one hand, recursion is the primary, low-level way to build loops where other languages would use <strong class="source-inline">for</strong>, <strong class="source-inline">foreach</strong>, or <strong class="source-inline">with</strong>. On the other hand, functional languages such as Clojure generally make it easier for programmers to find elegant, recursive solutions to complex problems.</p>
			<p>Tail recursion and functions, or loops, built around <strong class="source-inline">recur</strong> are suited for problems where the data, input, and output, is essentially linear. Because tail recursive functions can only return one call at a time, they cannot handle problems where it is necessary to follow multiple, forking paths through the data. Clojure provides the tools you need. Using them may require some practice in approaching the problem in a recursive style. </p>
			<p>To help build this skill, the remaining exercises in this chapter will be dedicated to solving a complex problem: finding the most efficient path through a network of nodes. Or, to put it differently: how to travel cheaply between European capitals. These exercises will show you how to break a problem down and resolve it recursively.</p>
			<h2 id="_idParaDest-144">Exer<a id="_idTextAnchor158"/>cise 6.05: Europe by Train</h2>
			<p>In this exercise, we need to find the least expensive way for a traveler to get from one European city to another. All we have is a list of city-to-city connections and an amount in euros. For the sake of this exercise, we will pretend that these are the only routes available and that the price of train tickets is constant for a given route. Here are our routes:</p>
			<p class="source-code-heading">train_routes.clj</p>
			<p class="source-code">1  (def routes</p>
			<p class="source-code">2   [[:paris :london 236]</p>
			<p class="source-code">3    [:paris :frankfurt 121]</p>
			<p class="source-code">4    [:paris :milan 129]</p>
			<p class="source-code">5    [:milan :rome 95]</p>
			<p class="source-code">6    [:milan :barcelona 258]</p>
			<p class="source-code">7    [:milan :vienna 79]</p>
			<p class="source-code">8    [:barcelona :madrid 141]</p>
			<p class="source-code">9    [:madrid :lisbon 127]</p>
			<p class="source-code">10   [:madrid :paris 314]</p>
			<p class="source-code-link">The full code for this step is available at <a href="https://packt.live/2FpIjVM">https://packt.live/2FpIjVM</a></p>
			<p>And here is a visual representation:</p>
			<div>
				<div id="_idContainer067" class="IMG---Figure">
					<img src="image/B14502_06_05.jpg" alt="Figure 6.5: Train routes across Europe&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.5: Train routes across Europe</p>
			<p class="callout-heading">Note </p>
			<p class="callout">The list of paths between cities and the visual map are two ways of representing a graph, which is the computer science term for a system of nodes. A tree is one kind of graph in which there are no "cycles": you can't go from point A, to point B, to point C, and then back to point A. The European railroad network, on the other hand, has plenty of cycles. In graph theory, each city would be called a node and the paths between cities would be called an edge.</p>
			<p>The goal is to write a function that takes two cities and returns a list of cities that represents the best route. To solve this problem, we will use recursion, as well as many of the techniques from the last two chapters.</p>
			<p>In this exercise, we will set up the project and transform the list of routes into a table that we'll be able to query to see 1) if City A is connected to City B and, if so, 2) the cost of travel between cities A and B.</p>
			<p>Thus, the table would look like this:</p>
			<p class="source-code">{:paris {:london 236</p>
			<p class="source-code">     :frankfurt 121</p>
			<p class="source-code">     :milan 129</p>
			<p class="source-code">     ;;...etc...</p>
			<p class="source-code">     }</p>
			<p class="source-code"> :milan {:paris 129</p>
			<p class="source-code">     :vienna 79</p>
			<p class="source-code">     :rome 95</p>
			<p class="source-code">     ;;...etc...</p>
			<p class="source-code">     }}</p>
			<p>We also have to make sure that all of the routes are represented in both directions. In the initial list, we have <strong class="source-inline">[:paris :milan 129]</strong>. We also need to represent the reverse route, that is, Milan to Paris. In the preceding example, we have <strong class="source-inline">:milan</strong> in the <strong class="source-inline">:paris</strong> section, as well as <strong class="source-inline">:paris</strong> in the <strong class="source-inline">:milan</strong> section:</p>
			<ol>
				<li value="1">Create a new project directory with a <strong class="source-inline">deps.edn</strong> file containing just an empty map, <strong class="source-inline">{}</strong>, and start a new REPL.</li>
				<li>Open a new file called <strong class="source-inline">train_routes.clj</strong> with just a <strong class="source-inline">(ns train-routes)</strong> namespace declaration.</li>
				<li>Copy the <strong class="source-inline">routes</strong> variable from <a href="https://packt.live/39J0Fit">https://packt.live/39J0Fit</a> into the new namespace. </li>
				<li>The first step is to group all the routes together by origin city. Use <strong class="source-inline">group-by</strong> to do this. Start by defining a function called <strong class="source-inline">grouped-routes</strong>:<p class="source-code">(defn grouped-routes</p><p class="source-code"> [routes]</p><p class="source-code"> (-&gt;&gt; routes</p><p class="source-code">    (group-by first)))</p></li>
				<li>Run this early version of the function on the route list and look at the results for just one city:<p class="source-code">train-routes&gt; (:paris (grouped-routes routes))</p><p class="source-code">[[:paris :london 236]</p><p class="source-code"> [:paris :frankfurt 121]</p><p class="source-code"> [:paris :milan 129]</p><p class="source-code"> [:paris :amsterdam 139]]</p><p>With the call to <strong class="source-inline">group-by</strong>, we have a list of all the <strong class="source-inline">:paris</strong> routes. We now need a way to change this sub-list into a map.</p></li>
				<li>Write a function that accepts one of these sub-lists and returns a map:<p class="source-code">(defn route-list-&gt;distance-map [route-list]</p><p class="source-code"> (-&gt;&gt; route-list</p><p class="source-code">    (map (fn [[_ city cost]] [city cost]))</p><p class="source-code">    (into {})))</p><p>This function uses the <strong class="source-inline">map</strong>-<strong class="source-inline">into</strong> pattern to create a list of two-item vector tuples. We don't need the first item because it's the same as the key associated with the sub-list, so we use destructuring to place <strong class="source-inline">city</strong> and <strong class="source-inline">cost</strong> in a new vector. </p></li>
				<li>Test <strong class="source-inline">route-list-&gt;distance-map</strong> in the REPL with some sample data:<p class="source-code">train-routes&gt; (route-list-&gt;distance-map [[:paris :milan 129]</p><p class="source-code">                                        [:paris :frankfurt 121]])</p><p class="source-code">{:milan 129, :frankfurt 121}</p></li>
				<li>Continue building the <strong class="source-inline">grouped-routes</strong> function. Use the <strong class="source-inline">map-into</strong> pattern again to apply <strong class="source-inline">route-list-&gt;distance-map</strong> to all the sub-lists returned by the call to <strong class="source-inline">group-by</strong>:<p class="source-code">(defn grouped-routes</p><p class="source-code"> [routes]</p><p class="source-code"> (-&gt;&gt; routes</p><p class="source-code">    (group-by first)</p><p class="source-code">    (map (fn [[k v]] [k (route-list-&gt;distance-map v)]))</p><p class="source-code">    (into {})))</p><p>The call to <strong class="source-inline">map</strong> treats the key-value pairs of the top-level map as a series of two-item vectors and runs <strong class="source-inline">route-list-&gt;distance-map</strong> on each value. The call to <strong class="source-inline">into</strong> converts the sequence back into a map.</p></li>
				<li>Test this version of <strong class="source-inline">grouped-routes</strong> in the REPL:<p class="source-code">train-routes&gt; (:paris (grouped-routes routes))</p><p class="source-code">{:london 236, :frankfurt 121, :milan 129, :amsterdam 139}</p><p>Perfect! This kind of map will make it easy to look up a route between an origin (<strong class="source-inline">:paris</strong>) and a destination (<strong class="source-inline">:amsterdam</strong>).</p><p>We still need to produce the reverse routes. We'll use <strong class="source-inline">mapcat</strong>, in a pattern we mentioned back in <em class="italic">Chapter 4</em>, <em class="italic">Mapping and Filtering</em>, to produce two routes for each input route. This can go before the call to <strong class="source-inline">group-by</strong>:</p><p class="source-code">(defn grouped-routes</p><p class="source-code"> [routes]</p><p class="source-code"> (-&gt;&gt; routes</p><p class="source-code">    (mapcat (fn [[origin-city dest-city cost :as r]]</p><p class="source-code">         [r [dest-city origin-city cost]]))</p><p class="source-code">    (group-by first)</p><p class="source-code">    (map (fn [[k v]] [k (route-list-&gt;distance-map v)]))</p><p class="source-code">    (into {})))</p><p>The anonymous function in the <strong class="source-inline">mapcat</strong> call returns a vector containing two sub-vectors. The first of these is the original route, and the second is the same route with the origin and destination cities reversed. Thanks to <strong class="source-inline">mapcat</strong>, the result is a flattened list with twice as many elements as the input list.</p></li>
				<li>Test this in the REPL again:<p class="source-code">train-routes&gt; (:paris (grouped-routes routes))</p><p class="source-code">{:london 236,</p><p class="source-code"> :frankfurt 121,</p><p class="source-code"> :milan 129,</p><p class="source-code"> :madrid 314,</p><p class="source-code"> :geneva 123,</p><p class="source-code"> :amsterdam 139}</p><p>Now, the <strong class="source-inline">[:madrid :paris 34]</strong> route is also included as a <strong class="source-inline">:paris</strong> to <strong class="source-inline">:madrid</strong> route.</p></li>
				<li>Define a <strong class="source-inline">lookup</strong> variable with the lookup table:<p class="source-code">train-routes&gt; (def lookup (grouped-routes routes))</p><p class="source-code">#'train-routes/lookup</p><p>We'll need this variable later.</p></li>
				<li>Test the lookup table. First<a id="_idTextAnchor159"/>, we'll ask for a route from Paris to Madrid:<p class="source-code">train-routes&gt; (get-in lookup [:paris :madrid])</p><p class="source-code">314</p><p>Can we go back to Paris?</p><p class="source-code">train-routes&gt; (get-in lookup [:madrid :paris])</p><p class="source-code">314</p><p>Let's try a route that we know does not exist:</p><p class="source-code">train-routes&gt; (get-in lookup [:paris :bratislava])</p><p class="source-code">nil</p><p>Our lookup table answers two important questions: Is there a route between City A and City B? How much does it cost?</p></li>
			</ol>
			<p>We now have a data store that we can consult when we need to find which cities are available from any given point in the European rail graph. Rearranging data into an easy-to-query form can be an important step when dealing with a complex problem like this one. The next steps will be easier thanks to this easy access to our data.</p>
			<h2 id="_idParaDest-145"><a id="_idTextAnchor160"/>Pathfinding</h2>
			<p>If we are in a city that is not directly connected to the city we want to travel to, we need to choose intermediate cities. To get from City A to City F, maybe we can go to City C first; or, maybe we'll need to go to City B and then City D before reaching City F. To find the best path, we first need to find all the possible paths.</p>
			<p>This is why a recursive approach is a good fit. The basic strategy is to test whether City A and City F are connected. If so, we've already found the answer. If not, we look at all the cities we can reach directly from City A. We go through the same process on each of those, and so on and so forth, until finally we find a city that is connected directly to City F. The process is recursive because we repeat the same process on each node until we find what we are looking for. </p>
			<p>Let's try to visualize this process, using a small part of the network. In this example, we'll start in Paris and search for Berlin. The first step is to test the cities we can reach from Paris. In London, Amsterdam, and Frankfurt, we ask: are you Berlin?</p>
			<div>
				<div id="_idContainer068" class="IMG---Figure">
					<img src="image/B14502_06_06.jpg" alt="Figure 6.6: Starting in Paris, we query all the available cities&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.6: Starting in Paris, we query all the available cities</p>
			<p>Since none of the cities is the one that we are looking for, we repeat the process from London, Amsterdam, and Frankfurt:</p>
			<div>
				<div id="_idContainer069" class="IMG---Figure">
					<img src="image/B14502_06_07.jpg" alt="Figure 6.7: Searching again from the previously found cities&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.7: Searching again from the previously found cities</p>
			<p>From London, we have nowhere left to go. But from Amsterdam and Frankfurt, we can reach Berlin. Success! Not only have we found Berlin, but we've found two paths to get there.</p>
			<p>We could represent these paths as Clojure vectors:</p>
			<p class="source-code"> [:paris :london nil]</p>
			<p class="source-code"> [:paris :amsterdam :berlin]</p>
			<p class="source-code"> [:paris :frankfurt :berlin]</p>
			<p class="source-code"> [:paris :frankfurt :prague nil]</p>
			<p>Notice that the paths going through Prague and London end with <strong class="source-inline">nil</strong>. This is how we will represent paths that do not lead to our destination and must be removed from the result set.</p>
			<p>There is one more issue that we haven't dealt with yet. What prevents us from going from Amsterdam back to Paris? This would create infinite loops where we search from Paris, then search Amsterdam, then search Paris again, and so on. To get around this problem, we will need to "remember" where we've been.</p>
			<p>This is our general approach. Now, let's write some more code!</p>
			<h2 id="_idParaDest-146"><a id="_idTextAnchor161"/>Exercise 6.06: The Search Function</h2>
			<p>The next step is to write the main search function, a recursive function that we'll call <strong class="source-inline">find-path*</strong>. The <strong class="source-inline">find-path</strong> function will be the public interface that calls <strong class="source-inline">find-path*</strong>:</p>
			<ol>
				<li value="1">At this point, we are ready to write the main search function. The <strong class="source-inline">find-path</strong> function can be used for the wrapper function that will serve as the public interface. To get started, let's write the empty functions:<p class="source-code">(defn find-path* [route-lookup destination path]</p><p class="source-code"> ;; TODO: write code</p><p class="source-code"> )</p><p class="source-code">(defn find-path [route-lookup origin destination]</p><p class="source-code"> ;; TODO: write code</p><p class="source-code"> )</p><p>We've written the "private" function, <strong class="source-inline">find-path*</strong>, first since the "public" function, <strong class="source-inline">find-path</strong>, will refer to it.</p><p>There are already some design decisions here in the function arguments. Both functions accept the <strong class="source-inline">route-lookup</strong> argument. This will be the lookup table generated by <strong class="source-inline">grouped-routes</strong>. They both accept the destination argument as well. Since we want to build up a list of cities, a path, the private function, <strong class="source-inline">find-path*</strong>, doesn't take an origin argument like <strong class="source-inline">find-path</strong> does. Instead, it will take whatever the current path is. Since it's a recursive function, the current "origin" will always be whatever the last city in the path is.</p><p>In other words, if we're testing a path, the value of <strong class="source-inline">path</strong> might be <strong class="source-inline">[:paris :milan]</strong>. That means that on the next iteration, <strong class="source-inline">find-path*</strong> will try all the cities available from <strong class="source-inline">:milan</strong>, making <strong class="source-inline">:milan</strong> the temporary origin. The next cities are tested in the same way and the path gets lengthened by one city on each successive call.</p></li>
				<li>Call <strong class="source-inline">find-path*</strong> from <strong class="source-inline">find-path</strong>:<p class="source-code">(defn find-path [route-lookup origin destination]</p><p class="source-code">  (find-path* route-lookup destination [origin]))</p><p>This is simple. We package the initial <strong class="source-inline">origin</strong> in a vector to pass off to <strong class="source-inline">find-path*</strong>. This way, we know that we will always have at least one city in the <strong class="source-inline">path</strong> parameter.</p></li>
				<li>Set up the basic conditional structure of the recursive function:<p class="source-code">(defn find-path* [route-lookup destination path]</p><p class="source-code"> (let [position (last path)]</p><p class="source-code">  (cond</p><p class="source-code">   (= position destination) path</p><p class="source-code">   (get-in route-lookup [position destination])</p><p class="source-code">   (conj path destination)</p><p class="source-code">   ;; TODO: still not there</p><p class="source-code">   )))</p><p>This part does two things. We are going to need to refer to the current position a lot, so it's a good idea to create a <strong class="source-inline">let</strong> binding immediately. As we mentioned earlier, our current position is always the last item in the <strong class="source-inline">path</strong> argument. The whole process is about adding cities on to the end of this list.</p><p>The next thing we do is to start setting up the different checks we'll use. The two conditions we add here both end the recursion and return a value. These are the "Are we there yet?" tests. The second one is the one that will be called the most, so let's look at it first.</p><p>If you remember how our lookup table is structured, there is a top-level set of keys, one for each city in our system. The value of each of those keys is a map of reachable cities. That's why we can use <strong class="source-inline">get-in</strong> here. Say our lookup table looks something like this:</p><p class="source-code">{:paris {:frankfurt 121</p><p class="source-code">     :milan 129</p><p class="source-code">     ;; etc.</p><p class="source-code">     }</p><p class="source-code"> ;; etc.</p><p class="source-code"> }</p><p>If we call <strong class="source-inline">(get-in routes-lookup [:paris :milan])</strong>, we will get <strong class="source-inline">129</strong>. If our current position is <strong class="source-inline">:paris</strong> and our destination is <strong class="source-inline">:milan</strong>, then this call will return truthy. In that case, we add <strong class="source-inline">:milan</strong> to the current path and we return the path. We've arrived.</p><p>So, why do we need the first condition then? In what circumstances would the destination city already be in the path? There is only one way that could happen, but we do have to take care of it. Someday, a user will call your function and ask the best route from <strong class="source-inline">:paris</strong> to <strong class="source-inline">:paris</strong> and we don't want to blow up the stack on such a simple request.</p></li>
				<li>Test the simple cases. We already have enough code for two cases, so let's see whether our functions work. Try <strong class="source-inline">find-path*</strong> first with a one-city path:<p class="source-code">train-routes&gt; (find-path* lookup :sevilla [:sevilla])</p><p class="source-code">[:sevilla]</p><p>Now, let's try the same thing with <strong class="source-inline">find-path</strong>:</p><p class="source-code">train-routes&gt; (find-path lookup :sevilla :sevilla)</p><p class="source-code">[:sevilla]</p><p>The current code should also work if the destination city is only one "hop" away from the origin:</p><p class="source-code">train-routes&gt; (find-path* lookup :madrid [:sevilla])</p><p class="source-code">[:sevilla :madrid]</p><p>So far so good. Onward!</p></li>
				<li>Start building the recursive logic to <strong class="source-inline">find-path*</strong>:<p class="source-code">(defn find-path* [route-lookup destination path]</p><p class="source-code"> (let [position (last path)]</p><p class="source-code">  (cond</p><p class="source-code">   (= position destination) path</p><p class="source-code">   (get-in route-lookup [position destination])</p><p class="source-code">   (conj path destination)</p><p class="source-code">   :otherwise-we-search</p><p class="source-code">   (let [path-set (set path)</p><p class="source-code">      from-here (remove path-set (keys (get route-lookup position)))]</p><p class="source-code">    (when-not (empty? from-here)</p><p class="source-code">     (-&gt;&gt; from-here</p><p class="source-code">        (map (fn [pos] (find-path* route-lookup destination (conj path pos))))</p><p class="source-code">        (remove empty?)))))))</p><p>For the final condition, we use an expressive Clojure keyword such as <strong class="source-inline">:otherwise-we-search</strong> as a condition, but anything that isn't <strong class="source-inline">false</strong> or <strong class="source-inline">nil</strong> will do. If we get this far, we know that we haven't reached the destination yet, so we have to keep searching.</p></li>
				<li>Let's look at this line by line. The first thing we do is define <strong class="source-inline">path-set</strong>, which will allow us to test whether a city is already in our path. You can try building and using a set in the REPL:<p class="source-code">train-routes&gt; (set [:amsterdam :paris :milan])</p><p class="source-code">#{:paris :milan :amsterdam}</p><p class="source-code">train-routes&gt; ((set [:amsterdam :paris :milan]) :berlin)</p><p class="source-code">nil</p><p class="source-code">train-routes&gt; ((set [:amsterdam :paris :milan]) :paris)</p><p class="source-code">:paris</p><p>The reason this is important becomes apparent in the next line. We bind <strong class="source-inline">from-here</strong> to this:</p><p class="source-code">(remove path-set (keys (get route-lookup position)))</p><p>We can't use <strong class="source-inline">get-in</strong> like we did earlier because this time, we don't want just one city reachable from <strong class="source-inline">position</strong>, we want all of them. So, we grab the entire sub-map for the current city, with <strong class="source-inline">(get route-lookup position)</strong>, and then extract a list of keywords. Now, the <strong class="source-inline">path-set</strong> binding from the previous line becomes useful. We use it to remove any cities that we've already visited. This is how we avoid recursively going back and forth between <strong class="source-inline">:paris</strong> and <strong class="source-inline">:amsterdam</strong> forever.</p><p>The <strong class="source-inline">from-here</strong> binding now contains all the cities we still need to test. First, though, we check to see whether <strong class="source-inline">from-here</strong> is empty, using Clojure's well-named <strong class="source-inline">empty?</strong> predicate. Let's say our destination is <strong class="source-inline">:berlin</strong> and our current path is <strong class="source-inline">[:paris :london]</strong>. The only way out of <strong class="source-inline">:london</strong> is to go back to <strong class="source-inline">:paris</strong>, but we've already been there. This means it's time to give up, so we return <strong class="source-inline">nil</strong>. As you'll soon see, paths that resolve to <strong class="source-inline">nil</strong> will be ignored.</p></li>
				<li>After this, we start threading <strong class="source-inline">from-here</strong> through a series of s-expressions. The first one is where the actual recursion is going to happen:<p class="source-code">(map (fn [pos] (find-path* route-lookup destination (conj path pos))))</p></li>
				<li>We're mapping over the cities that we can reach from our current position. Say we've arrived in <strong class="source-inline">:paris</strong> from <strong class="source-inline">:london</strong>. In the lookup table, the value for <strong class="source-inline">:paris</strong> is as follows:<p class="source-code">train-routes&gt; (:paris lookup)</p><p class="source-code">{:london 236,</p><p class="source-code"> :frankfurt 121,</p><p class="source-code"> :milan 129,</p><p class="source-code"> :madrid 314,</p><p class="source-code"> :geneva 123,</p><p class="source-code"> :amsterdam 139}</p></li>
				<li>We can't go back to <strong class="source-inline">:london</strong>, so that means <strong class="source-inline">from-here</strong> is <strong class="source-inline">[:frankfurt :milan :madrid :geneva :amsterdam]</strong>. The anonymous function provided to <strong class="source-inline">map</strong> will be called once for each of these cities as <strong class="source-inline">pos</strong>. Each city will thus be appended to the path argument in the recursive calls to <strong class="source-inline">find-path*</strong>. The following values will be tried as the <strong class="source-inline">path</strong> argument to <strong class="source-inline">find-path*</strong>:<p class="source-code"> [:london :paris :frankfurt]</p><p class="source-code"> [:london :paris :milan]</p><p class="source-code"> [:london :paris :madrid]</p><p class="source-code"> [:london :paris :geneva]</p><p class="source-code"> [:london :paris :amsterdam]</p><p>Remember that <strong class="source-inline">map</strong> returns a list. The list returned here will be the result of calling <strong class="source-inline">find-path*</strong> on each city. Each of those calls will produce a list as well, until the search finds the destination city or runs out of places to look.</p><p>Now, we can start to visualize the recursive structure of our path search:</p><div id="_idContainer070" class="IMG---Figure"><img src="image/B14502_06_08.jpg" alt="Figure 6.8: Each city resolves to a new list of cities, each of which resolves to a new list&#13;&#10;"/></div><p class="figure-caption">Figure 6.8: Each city resolves to a new list of cities, each of which resolves to a new list</p><p>Eventually, the search will either find the destination or run out of options, at which point the lists will all be resolved. If there are no more options and the destination still hasn't been found, <strong class="source-inline">nil</strong> is returned. Otherwise, a list of resolved paths is returned. This simple call to <strong class="source-inline">map</strong> ends up walking the entire city graph until all the possible routes are found.</p><p>Before returning, though, the call to map gets threaded through one last s-expression: <strong class="source-inline">(remove empty?)</strong>. This is how we filter out the <strong class="source-inline">nil</strong> paths that never find the destination.</p></li>
				<li>Test the current state of the function on a short path.<p>To make this easier to test, we'll use a smaller rail network. Start by defining a new variable for the lookup table:</p><p class="source-code">train-routes&gt; (def small-routes (grouped-routes [[:paris :milan 100][:paris :geneva 100][:geneva :rome 100][:milan :rome 100]]))</p><p class="source-code">#'train-routes/small-routes</p><p class="source-code">train-routes&gt; small-routes</p><p class="source-code">{:paris {:milan 100, :geneva 100},</p><p class="source-code"> :milan {:paris 100, :rome 100},</p><p class="source-code"> :geneva {:paris 100, :rome 100},</p><p class="source-code"> :rome {:geneva 100, :milan 100}}</p><p>There should be precisely two paths between <strong class="source-inline">:paris</strong> and <strong class="source-inline">:rome</strong>:</p><p class="source-code">train-routes&gt; (find-path* small-routes :rome [:paris])</p><p class="source-code">([:paris :milan :rome] [:paris :geneva :rome])</p></li>
				<li>Test the current state of the function with a slightly bigger network. We'll add another route between <strong class="source-inline">:paris</strong> and <strong class="source-inline">:milan</strong>:<p class="source-code">train-routes&gt; (def more-routes (grouped-routes [[:paris :milan 100]</p><p class="source-code">                                               [:paris :geneva 100]</p><p class="source-code">                                               [:paris :barcelona 100]</p><p class="source-code">                                               [:barcelona :milan 100]</p><p class="source-code">                                               [:geneva :rome 100]</p><p class="source-code">                                               [:milan :rome 100]]))</p><p class="source-code">#'train-routes/more-routes</p></li>
				<li>With this set of routes, our result is not quite what we expect:<p class="source-code">train-routes&gt; (find-path* more-routes :rome [:paris])</p><p class="source-code">([:paris :milan :rome]</p><p class="source-code"> [:paris :geneva :rome]</p><p class="source-code"> ([:paris :barcelona :milan :rome]))</p></li>
				<li>The data looks good, but where did those extra parentheses come from? This is a consequence of using <strong class="source-inline">map</strong> in a recursive way. <strong class="source-inline">map</strong> always returns a list. The <strong class="source-inline">:barcelona</strong> route requires an extra level of recursion because it is one item longer than the others. As a result, it is wrapped in a list. We can verify this by adding another possible route:<p class="source-code">train-routes&gt; (def even-more-routes (grouped-routes [[:paris :milan 100]</p><p class="source-code">                                                    [:paris :geneva 100]</p><p class="source-code">                                                     [:paris :barcelona 100]</p><p class="source-code">                                                     [:barcelona :madrid 100]</p><p class="source-code">                                                     [:madrid :milan 100]</p><p class="source-code">                                                     [:barcelona :milan 100]</p><p class="source-code">                                                     [:geneva :rome 100]</p><p class="source-code">                                                     [:milan :rome 100]]))</p><p class="source-code">#'train-routes/even-more-routes</p><p class="source-code">train-routes&gt; (find-path* even-more-routes :rome [:paris])</p><p class="source-code">([:paris :milan :rome]</p><p class="source-code"> [:paris :geneva :rome]</p><p class="source-code"> (([:paris :barcelona :madrid :milan :rome])</p><p class="source-code"> [:paris :barcelona :milan :rome]))</p><p>As you can see, the five-city path that goes through <strong class="source-inline">:madrid</strong> is wrapped in an extra set of parentheses.</p></li>
				<li>Unnest the nested lists. To solve this problem, use <strong class="source-inline">mapcat</strong> to strip away the containing lists. Here is the final version of <strong class="source-inline">find-path*</strong>:<p class="source-code">(defn find-path* [route-lookup destination path]</p><p class="source-code"> (let [position (last path)]</p><p class="source-code">  (cond</p><p class="source-code">   (= position destination) path</p><p class="source-code">   (get-in route-lookup [position destination])</p><p class="source-code">   (conj path destination)</p><p class="source-code">   :otherwise-we-search</p><p class="source-code">   (let [path-set (set path)</p><p class="source-code">      from-here (remove path-set (keys (get route-lookup position)))]</p><p class="source-code">    (when-not (empty? from-here)</p><p class="source-code">     (-&gt;&gt; from-here</p><p class="source-code">        (map (fn [pos] (find-path* route-lookup destination (conj path pos))))</p><p class="source-code">        (remove empty?)</p><p class="source-code">        (mapcat (fn [x] (if (keyword? (first x))</p><p class="source-code">                 [x]</p><p class="source-code">                 x)))))))))</p><p>The last addition is the call to <strong class="source-inline">mapcat</strong>. It might look strange at first, but remember: <strong class="source-inline">mapcat</strong> removes the outer parentheses from the items in the list that it returns. That's why we have the conditional: if <strong class="source-inline">x</strong> is just a path, like <strong class="source-inline">[:prague :bratislava]</strong>, we don't want it to be directly concatenated, which is why we return <strong class="source-inline">[x]</strong> instead. The new wrapper is instantly removed when the items are concatenated together, and the original vector remains intact. In the other cases though, when the underlying vector is wrapped in a list, <strong class="source-inline">mapcat</strong> "removes" it.</p></li>
				<li>Test this version on the small and large railroad networks. First, we'll test it with <strong class="source-inline">even-more-routes</strong>:<p class="source-code">train-routes&gt; (find-path* even-more-routes :rome [:paris])</p><p class="source-code">([:paris :milan :rome]</p><p class="source-code"> [:paris :geneva :rome]</p><p class="source-code"> [:paris :barcelona :madrid :milan :rome]</p><p class="source-code"> [:paris :barcelona :milan :rome])</p><p>Much better!</p></li>
				<li>Now, try it with the full-sized lookup table. We won't print the full results here because they're quite long:<p class="source-code">train-routes&gt; (find-pa<a id="_idTextAnchor162"/>th* lookup :rome [:paris])</p><p class="source-code">([:paris :frankfurt :milan :rome]</p><p class="source-code"> [:paris :frankfurt :berlin :warsaw :prague :vienna :milan :rome]</p><p class="source-code"> [:paris :frankfurt :berlin :warsaw :prague :bratislava :vienna :milan :rome]</p><p class="source-code"> [:paris :frankfurt :berlin :warsaw :prague :budapest :vienna :milan :rome]</p><p class="source-code"> [:paris :frankfurt :geneva :milan :rome]</p><p class="source-code"> [:paris :frankfurt :prague :vienna :milan :rome]</p><p class="source-code"> [:paris :frankfurt :prague :bratislava :vienna :milan :rome]</p><p class="source-code"> [:paris :frankfurt :prague :budapest :vienna :milan :rome]</p><p class="source-code"> ;; etc. )</p><p>Now, we can walk the entire network. Our <strong class="source-inline">find-path</strong> function returns all the possible routes between any two cities. </p></li>
			</ol>
			<p>Once again, Clojure has helped us write a concise solution to a fairly complex problem. A recursive algorithm such as this depends on a design that combines two elements. On the one hand, the recursive function treats each new node as if it were the first node. Recursive solutions are often perceived as "elegant" because of this. By solving the problem for one item, it can be solved for an entire network of items. To work, however, this requires the second design element: a way of accumulating the results from one node to another. In this example, we built up our knowledge by adding cities to one of the parameters. In the next exercise, we'll use different techniques for bringing the data together.</p>
			<p>This exercise also shows the value of using small, sample inputs at the REPL. The interactive programming experience allows you to quickly try things and verify your hypotheses.</p>
			<h2 id="_idParaDest-147"><a id="_idTextAnchor163"/>Exercise 6.07: Calculating the Costs of the Routes</h2>
			<p>There's just one more problem to solve. In our original problem description, we didn't ask for all the possible routes, but just the least expensive one! We need a way to evaluate the cost of all the paths and choose one. To accomplish this, we will use the lookup table from the two previous exercises to calculate the cost of each path returned by <strong class="source-inline">find-path*</strong>. Then, we can use a reducing pattern from <em class="italic">Chapter 5</em>, <em class="italic">Many to One: Reducing,</em> for finding the path with the lowest cost:</p>
			<ol>
				<li value="1">Write a <strong class="source-inline">cost-of-route</strong> function.<p>To do this, we'll use a pattern from <em class="italic">Chapter 4</em>, <em class="italic">Mapping and Filtering</em>, <strong class="source-inline">map</strong>, with two input lists. The first will be the path, and the second will be the path offset by one item so that each call can evaluate the cost of going from one city to the next. It should look like this:</p><p class="source-code">(defn cost-of-route</p><p class="source-code"> [route-lookup route]</p><p class="source-code"> (apply +</p><p class="source-code">     (map (fn [start end]</p><p class="source-code">        (get-in route-lookup [start end]))</p><p class="source-code">       route</p><p class="source-code">       (next route))))</p><p>By now, this should look familiar. <strong class="source-inline">(next route)</strong> provides the offset version of <strong class="source-inline">route</strong>. For each pair of cities, we use <strong class="source-inline">get-in</strong> the same way we did earlier. That call gives us the cost of a given segment in the path. Then, we use the <strong class="source-inline">(apply +)</strong> pattern to find the grand total.</p></li>
				<li>Test the new function:<p class="source-code">train-routes&gt; (cost-of-route lookup [:london :paris :amsterdam :berlin :warsaw])</p><p class="source-code">603</p><p>And it even works with the edge cases:</p><p class="source-code">train-routes&gt; (cost-of-route lookup [:london])</p><p class="source-code">0</p></li>
				<li>Write a <strong class="source-inline">min-route</strong> function to find the least expensive route.<p>Now, we'll leverage another familiar pattern, this time using <strong class="source-inline">reduce</strong>. We want to find the route with the lowest total cost and we need a function like <strong class="source-inline">min</strong>, except that it will return the <em class="italic">item</em> that has the minimum cost, and not just the minimum cost itself:</p><p class="source-code">(defn min-route [route-lookup routes]</p><p class="source-code"> (reduce (fn [current-best route]</p><p class="source-code">      (let [cost (cost-of-route route-lookup route)]</p><p class="source-code">       (if (or (&lt; cost (:cost current-best))</p><p class="source-code">           (= 0 (:cost current-best)))</p><p class="source-code">          {:cost cost :best route}</p><p class="source-code">        current-best)))</p><p class="source-code">     {:cost 0 :best [(ffirst routes)]}</p><p class="source-code">     routes))</p><p>The only slightly tricky aspect of this function is the initialization value in the call to <strong class="source-inline">reduce</strong>: <strong class="source-inline">{:cost 0 :best [(ffirst routes)]}</strong>. We start with a default cost of <strong class="source-inline">0</strong>. So far so good. The default <strong class="source-inline">:best</strong> route should be the route corresponding to a distance of zero, which means that we're not going anywhere. That's why we use <strong class="source-inline">ffirst</strong>, which is not a typo but a convenience function for nested lists. It is a shortcut for <strong class="source-inline">(first (first my-list))</strong>, so it returns the first element of the first element of the outer list.</p></li>
				<li>Now, put it all together. Add a call to <strong class="source-inline">min-route</strong> to the public-facing <strong class="source-inline">find-path</strong> function:<p class="source-code">(defn find-path [route-lookup origin destination]</p><p class="source-code">  (min-route route-lookup (find-path* route-lookup destination [origin])))</p></li>
				<li>Test this out on several pairs of cities:<p class="source-code">train-routes&gt; (find-path lookup :paris :rome)</p><p class="source-code">{:cost 224, :best [:paris :milan :rome]}</p><p class="source-code">train-routes&gt; (find-path lookup :paris :berlin)</p><p class="source-code">{:cost 291, :best [:paris :frankfurt :berlin]}</p><p class="source-code">train-routes&gt; (find-path lookup :warsaw :sevilla)</p><p class="source-code">{:cost 720,</p><p class="source-code"> :best [:warsaw :prague :vienna :milan :barcelona :sevilla]}</p><p>Working through this code involved a lot of different steps, but, in the end, it was worth it. We've actually solved a somewhat difficult problem in about 50 lines of code. Best of all, the solution involved many techniques that we've already seen, which shows, one more time, how important and powerful they can be when used together.</p></li>
			</ol>
			<h2 id="_idParaDest-148"><a id="_idTextAnchor164"/>A Brief Introduction to HTML</h2>
			<p>In many of the remaining chapters of this book and starting with the activity at the end of this chapter, we will be working in one way or another with <strong class="bold">Hypertext Markup Language</strong> (<strong class="bold">HTML</strong>), which holds together just about every web page you've ever seen. Producing HTML from data is an extremely common programming task. Just about every mainstream programming language has multiple templating libraries for generating web pages. Even before Clojure, Lisps have used nested s-expressions for this. S-expressions are a particularly good fit for HTML documents, which are structured like logical trees.</p>
			<p>In case you're not familiar with the essentials of producing HTML, it's worth briefly reviewing the basics. HTML is the content of the text file that provides the structure for other kinds of content (that is, images, audio, and video resources) on a web page. The fundamental unit of HTML is called an element. Here is a simple paragraph element, using the <strong class="source-inline">&lt;p&gt;</strong> tag:</p>
			<p class="source-code">&lt;p&gt;A short paragraph.&lt;/p&gt;</p>
			<p>The HTML standard, of which there are several versions, contains many, many kinds of elements. The <strong class="source-inline">&lt;html&gt;</strong> element contains a web page in its entirety. In turn, this contains the <strong class="source-inline">&lt;head&gt;</strong> and <strong class="source-inline">&lt;body&gt;</strong> elements. The first of these contains various kinds of metadata for displaying the page; the second contains the actual content that will be shown to the user. The <strong class="source-inline">&lt;body&gt;</strong> element can contain both text and more elements. </p>
			<p>We'll only use a small handful of elements here:</p>
			<ul>
				<li><strong class="source-inline">&lt;div&gt;</strong>: Perhaps the most widely used element of all, <strong class="source-inline">&lt;div&gt;</strong> is a generic container for anything from the size of the paragraph up to an entire document. It can't be used for content below the size of a paragraph, however, because the end of a <strong class="source-inline">&lt;div&gt;</strong> causes a break in the text flow.</li>
				<li><strong class="source-inline">&lt;p&gt;</strong>: The paragraph element.</li>
				<li><strong class="source-inline">&lt;ul&gt;</strong> and <strong class="source-inline">&lt;li&gt;</strong>: "UL" stands for "unordered list," that is, a list without numbers. A <strong class="source-inline">&lt;ul&gt;</strong> should only contain "list items," that is, <strong class="source-inline">&lt;li&gt;</strong> elements.</li>
				<li><strong class="source-inline">&lt;span&gt;</strong>, <strong class="source-inline">&lt;em&gt;</strong>, and <strong class="source-inline">&lt;strong&gt;</strong>: These elements are part of the text; they are for wrapping single words or single letters. They do not cause breaks in text flow. <strong class="source-inline">&lt;span&gt;</strong> is a generic element. <strong class="source-inline">&lt;em&gt;</strong> (for emphasis) generally produces italicized text, while <strong class="source-inline">&lt;strong&gt;</strong> generally produces bold text.</li>
				<li><strong class="source-inline">&lt;a&gt;</strong>: A hypertext link element. This is also a text-level element. The <strong class="source-inline">href</strong> attribute (we'll explain attributes in a second) of an <strong class="source-inline">&lt;a&gt;</strong> element tells the browser where to go when you click on a link.</li>
				<li><strong class="source-inline">&lt;img&gt;</strong>: The <strong class="source-inline">&lt;img&gt;</strong> tag inserts an image, referenced by its <strong class="source-inline">src</strong> attribute.</li>
				<li><strong class="source-inline">&lt;h1&gt;</strong>, <strong class="source-inline">&lt;h2&gt;</strong>, and <strong class="source-inline">&lt;h3&gt;</strong>:These are the heading elements, for page titles, section titles, subsection titles, and more.</li>
			</ul>
			<p>These few elements are enough to get started producing web content. You can learn about others as needed by consulting, for example, the Mozilla Developers Network's MDN web documentation.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The MDN web docs can be referred to at <a href="https://packt.live/2s3M8go">https://packt.live/2s3M8go</a>.</p>
			<p>Since we will be producing HTML, there are only a few things you need to know in order to produce well-formed HTML:</p>
			<ul>
				<li>Most HTML tags have three parts: a start tag, a closing tag, and some content. </li>
				<li>A start tag consists of a short string wrapped in angle brackets: <strong class="source-inline">&lt;h1&gt;</strong>.</li>
				<li>A closing tag is similar, except that there is a slash, <strong class="source-inline">/</strong>, in front of the tag name, <strong class="source-inline">&lt;/h1&gt;</strong>.</li>
				<li>Opening tags can contain attributes, which are key-value pairs, with the values in quotes:<strong class="source-inline"> &lt;h1 class="example-title"&gt;Example&lt;/h1&gt;</strong>.</li>
				<li>Certain attributes, known as "Boolean attributes", don't need to have a value. The presence of a key is enough: <p class="source-code">&lt;input type="checkbox" checked&gt;</p></li>
				<li>Some tags do not have any content. They can be written as a single element containing a slash after the tag name: <strong class="source-inline">&lt;br/&gt;</strong>.</li>
				<li>In some dialects of HTML, certain tags without content can be written without a slash: <strong class="source-inline">&lt;img&gt;</strong>.</li>
				<li>If an element begins inside another element, its end tag must occur before the end of the containing element.</li>
			</ul>
			<p>The last point is important. This means that it would be invalid to write something like this:</p>
			<p class="source-code">&lt;div&gt;Soon a paragraph &lt;p&gt;will start&lt;/div&gt;, then end too late.&lt;/p&gt;</p>
			<p>The <strong class="source-inline">&lt;p&gt;</strong> element here should be a child element of <strong class="source-inline">&lt;div&gt;</strong>. A child element must be contained completely by its parent element. This is a very good thing when manipulating HTML because it means that correctly formed HTML is always a tree structure, with a root note, the <strong class="source-inline">&lt;html&gt;</strong> element that contains nodes that contain other nodes, and so on. As you'll see, this matches well with the kinds of tree structures that we've already looked at here.</p>
			<p>Now, you know enough to write a system that will produce well-formed HTML. (To become a renowned web designer, however, you'll need to learn a little bit more.)</p>
			<p>In Clojure, vectors are generally used for representing the structure of an HTML document. One of the more popular libraries that does this is called <strong class="source-inline">Hiccup</strong>. With <strong class="source-inline">Hiccup</strong>, a short paragraph containing a link would look like this:</p>
			<p class="source-code">[:p "This paragraph is just an "</p>
			<p class="source-code"> [:a {:href "http://example.com"} "example"] "."]</p>
			<p>The output would be as follows:</p>
			<p class="source-code">&lt;p&gt;This paragraph is just an &lt;a href="http://example.com"&gt;example&lt;/a&gt;.&lt;/p&gt;</p>
			<p>The syntax for this is quite simple. Besides using vectors, it uses keywords to identify HTML tags and maps to add attributes such as <strong class="source-inline">href</strong> or <strong class="source-inline">class</strong>.</p>
			<p>Some ta<a id="_idTextAnchor165"/>gs, such as <strong class="source-inline">&lt;link&gt;</strong>, <strong class="source-inline">&lt;meta&gt;</strong>, <strong class="source-inline">&lt;br&gt;</strong>, <strong class="source-inline">&lt;input&gt;</strong>, and <strong class="source-inline">&lt;img&gt;</strong>, are generally not closed, so they should receive special handling. All other tags should be explicitly closed even if they don't have any content. </p>
			<p class="callout-heading">Note</p>
			<p class="callout">More information on Hiccup can be found at <a href="https://packt.live/36vXZ5U">https://packt.live/36vXZ5U</a>.</p>
			<h2 id="_idParaDest-149">Activity<a id="_idTextAnchor166"/> 6.01: Generating HTML from Clojure Vectors</h2>
			<p>The company you work for is building a new web application. Generating and serving HTML pages is, quite logically, a key part of the operation. Your team has been asked to write a library for generating HTML from Clojure data.</p>
			<p>Producing HTML from data is an extremely common programming task. Just about every mainstream programming language has multiple templating libraries for generating web pages. Even before Clojure, Lisps have used nested s-expressions for this. S-expressions are a particularly good fit for HTML documents that are structured like logical trees.</p>
			<p><strong class="bold">Goal</strong></p>
			<p>In this activity, you are going to write your own system for generating HTML from nested vectors, using this format. The goal is to be able to take any vector written with this syntax, including an arbitrary number of descendant vectors, and produce a single string containing correctly structured HTML.</p>
			<p>Your code should also handle "Boolean attributes." Clojure maps don't allow keys to have no value to do this of course. You'll need to invent a convention so that users of your library can assign some non-string value to these attributes and get a Boolean attribute in the output string.</p>
			<p><strong class="bold">Steps</strong></p>
			<p>The foll<a id="_idTextAnchor167"/>owing steps will help you to complete the activity:</p>
			<ol>
				<li value="1">Set up a new project directory with an empty <strong class="source-inline">deps.edn</strong> file. You don't need any external dependencies for this activity. Make your own namespace with a catchy name for this new library.</li>
				<li>If you decide to use the <strong class="source-inline">clojure.string</strong> library, now is the time to reference it in the <strong class="source-inline">:require</strong> part of your namespace.</li>
				<li>It's often a good idea to start by writing some of the smaller functions. Simple functions that take a keyword and output a string containing either an opening tag or a closing tag would be convenient, for example. You'll need the <strong class="source-inline">name</strong> function for converting a keyword into a string.<p>A good choice for this would be the function that will accept a map, such as <strong class="source-inline">{:class "my-css-class"}</strong>, and return a properly formatted set of HTML attributes: <strong class="source-inline">class="my-css-class"</strong>. Don't forget to handle the case of Boolean attributes too. Remember that a Clojure map can be read as a sequence of key-value pairs. And don't forget to put quotes around the values. A string containing a single escaped quotation mark looks this: <strong class="source-inline">"\""</strong>.</p><p>It might be useful to have a predicate function to determine whether the second element in a vector is an attribute map.</p><p>When parsing a vector, you'll know that the first element is a keyword. The second element might be a map if there are attributes, but it might not. Use the <strong class="source-inline">map?</strong> predicate to test that.</p></li>
				<li>The fun part will be writing the recursive function. We won't say much about that, except that the basic tree walking pattern that we used in the "Europe by train" example should provide you with a rough base. You won't be able to use <strong class="source-inline">recur</strong> because you need to handle a real tree.<p>There are a lot of different kinds of elements that you need to handle, in addition to string content. In cases like this, it is often a good idea to write very clear predicates that you will use when deciding how to handle an element, such as <strong class="source-inline">singleton-with-attrs?</strong>, for example. These will be useful when writing the conditional part of your recursive function.</p></li>
			</ol>
			<p>Upon completing the activity, you will be able to test your code with an input of your choice. You should see an output similar to the following:</p>
			<div>
				<div id="_idContainer071" class="IMG---Figure">
					<img src="image/B14502_06_09.jpg" alt="Figure 6.9: Expected output&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.9: Expected output</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The solution to this activity can be found on page 696.</p>
			<h1 id="_idParaDest-150"><a id="_idTextAnchor168"/>Summary</h1>
			<p>We've covered a lot of ground in this chapter. Recursion in Clojure, as in many functional languages, is a central concept. On the one hand, it can be necessary for some fairly simple looping situations. In those cases, <strong class="source-inline">recur</strong>, whether used with <strong class="source-inline">loop</strong> or in a recursive function, can almost be seen as just "Clojure's syntax for looping." Understanding tail recursion is important for avoiding mistakes, but otherwise, it is relatively simple. On the other hand, recursion can be an extremely powerful way of solving complex problems. If it makes your head spin from time to time, that's normal: recursion is more than just a technique. It's a way of thinking about problem solving. Don't worry, though. In the next chapter, you are going to be able to practice your recursion skills some more!</p>
			<p>In the next chapter, we will continue exploring the recursive techniques and focus on lazy evaluation.</p>
		</div>
	</body></html>