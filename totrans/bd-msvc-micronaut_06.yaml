- en: '*Chapter 4*: Securing the Microservices'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Protecting microservices'' interfaces as well as the world encompassed by them
    is a crucial facet for any application development. Various topologies, tools,
    and frameworks have arisen in recent times to address the security aspects of
    web services/microservices. In the course of this chapter, we will dive into some
    core and often-used security paradigms in microservices. We will continue with
    the `pet-clinic` application from the previous chapter. For hands-on work, we
    will work toward securing microservices while covering the following authentication
    strategies in the Micronaut framework:'
  prefs: []
  type: TYPE_NORMAL
- en: '`pet-owner`: Working hands-on to secure `pet-owner` microservice endpoints
    using **session authentication**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pet-clinic`: Working hands-on to secure `pet-clinic` microservice endpoints
    using **JWT authentication**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pet-clinic-review`: Working hands-on to secure `pet-clinic-review` microservice
    endpoints using **OAuth authentication**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With the aforementioned hands-on exercises, we will be covering the following
    topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Using **session authentication** to secure the service endpoints
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using **JWT authentication** to secure the service endpoints
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using **OAuth** to secure the service endpoints
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have a nifty knowledge of working with
    various authentication strategies and local or cloud identity providers in the
    Micronaut framework.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All the commands and technical instructions in this chapter are run on Windows
    10 and Mac OS X. Code examples covered in this chapter are available in the book's
    GitHub repository at [https://github.com/PacktPublishing/Building-Microservices-with-Micronaut/tree/master/Chapter04](https://github.com/PacktPublishing/Building-Microservices-with-Micronaut/tree/master/Chapter04).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following tools need to be installed and set up in the development environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Java SDK**: Version 13 or above (we used Java 14).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Maven**: This is optional and only required if you would like to use Maven
    as the build system. However, we recommend having Maven set up on any development
    machine. Instructions to download and install Maven can be found at [https://maven.apache.org/download.cgi](https://maven.apache.org/download.cgi).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Development IDE**: Based on your preference, any Java-based IDE can be used,
    but for the purpose of writing this chapter, IntelliJ was used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Git**: Instructions to download and install Git can be found at [https://git-scm.com/downloads](https://git-scm.com/downloads).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**PostgreSQL**: Instructions to download and install PostgreSQL can be found
    at [https://www.postgresql.org/download/](https://www.postgresql.org/download/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**MongoDB**: MongoDB Atlas provides a free online database-as-a-service with
    up to 512 MB storage. However, if a local database is preferred, then instructions
    to download and install can be found at [https://docs.mongodb.com/manual/administration/install-community/](https://docs.mongodb.com/manual/administration/install-community/).
    We used a local installation for this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rest client**: Any HTTP rest client can be used. We used the Advanced REST
    Client Chrome plugin.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Docker**: Instructions to download and install Docker can be found at [https://docs.docker.com/get-docker/](https://docs.docker.com/get-docker/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**OpenSSL**: Instructions to download and install OpenSSL can be found at [https://www.openssl.org/source/](https://www.openssl.org/source/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working on RESTful microservices in the Micronaut framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to dive into the security aspects of the Micronaut framework, we will
    continue working on the `pet-clinic` application. The following table summarizes
    the changes we will be making to secure each of the microservices in the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 4.1 – Securing the microservices in the pet-clinic application'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Table_4.1.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Table 4.1 – Securing the microservices in the pet-clinic application
  prefs: []
  type: TYPE_NORMAL
- en: 'To secure the desired endpoints in the microservices, we will focus on the
    following two key aspects:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Identity provider**: Essentially, an identity provider owns the concerns
    regarding storing and maintaining digital identities. Furthermore, it resolves
    any security claim by authenticating the submitted digital identity with its quorum
    of stored identities.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Authentication strategy**: The authentication strategy will dictate how a
    microservice will communicate with the identity provider to authenticate and authorize
    the user requests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Adding to the diagram of the components from [*Chapter 3*](B16585_03_Final_VK_ePub.xhtml#_idTextAnchor065),
    *Working on Restful Web Services*, the following will be the changes in this chapter
    within each microservice:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1 – Microservice components'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.1_B16585.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.1 – Microservice components
  prefs: []
  type: TYPE_NORMAL
- en: We will stick to our usual pattern of separating the concerns. We will use an
    identity provider in tandem with an authentication strategy within each of the
    microservices.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, our focus will be to cover out-of-the-box tools provided
    by the Micronaut framework for security concerns.
  prefs: []
  type: TYPE_NORMAL
- en: The basics of Micronaut security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For handling any security aspects, the Micronaut framework has a built-in `SecurityFilter`
    object. The `SecurityFilter` object intercepts any incoming HTTP requests and
    kickstarts the authentication/authorization process as configured in the application.
    In the following diagram, you can see the workflow within the `SecurityFilter`
    object for authorizing a user request:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.2 – Micronaut security filter'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.2_B16585.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.2 – Micronaut security filter
  prefs: []
  type: TYPE_NORMAL
- en: 'Micronaut''s `SecurityFilter` has three essential parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '`AuthenticationFetcher` will fetch the required downstream authenticator for
    authenticating the user request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Authenticator` injects the configured authentication provider(s) and security
    configurations for authenticating the user request. An `AuthenticationResponse`
    object is created based on the success or failure of the auth operation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SecuredAnnotationRule` or `IpPatternsRule` or by creating its own security
    rules by extending `AbstractSecurityRule`. If the request satisfies all the security
    rules, then a successful `AuthenticationResponse` response is returned by the
    security filter; otherwise, it will return a failed `AuthenticationResponse` response.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By leveraging `SecurityFilter`, in the next section, we will focus on how to
    secure a microservice using session authentication in the Micronaut framework.
  prefs: []
  type: TYPE_NORMAL
- en: Securing service endpoints using session authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In session-based authentication, the user state is stored at the server side.
    When a user logs in to the server, the server starts the session and issues a
    session ID in a cookie. The server uses the session ID to uniquely identify a
    session from the session quorum. Any subsequent user requests must have this session
    ID passed as a cookie to resume the session:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.3 – Session-based authentication'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.3_B16585.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.3 – Session-based authentication
  prefs: []
  type: TYPE_NORMAL
- en: As shown in the preceding figure, in a session-based authentication strategy,
    the server does the heavy lifting of keeping a track of the session. A client
    must provide a valid session ID to resume the session.
  prefs: []
  type: TYPE_NORMAL
- en: 'To learn how to secure a microservice using session-based authentication, we
    will experiment on the `pet-owner` microservice. To begin, we will need to enable
    security by adding the following dependencies to the `pom.xml` project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'By importing the `micronaut-security` and `micronaut-security-session` dependencies,
    we can leverage the session authentication toolkit in the `pet-owner` microservice.
    Once these dependencies are imported, we will then need to configure `application.properties`
    as shown in the next code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As mentioned in the preceding `application.properties` instance, we will enable
    the security by setting `enabled` to `true` and specifying `session` as the desired
    authentication strategy. Furthermore, the Micronaut security toolkit provides
    `LoginController` and `LogoutController` out of the box. In the application properties,
    we have enabled them and since we haven't specified a custom path for these controllers,
    they will be accessible at default specified paths of `…/login` and `…/logout`,
    respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use a basic local identity provider that will leverage application
    properties to store user data. This is very primitive but will help in simplifying
    learning and exploration. Let''s add some user data to `application.properties`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We have added three users: `alice`, `bob`, and `charlie`. Each user is also
    assigned a role for the `pet-owner` microservice.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will explore how to implement an authentication provider
    that will use the configured application properties for user data.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a basic authentication provider
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To implement a basic authentication provider, we will begin by creating a `com.packtpub.micronaut.security`
    security package. This package will encompass all the artifacts concerning security.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will first add `IdentityStore` to this package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The `IdentityStore` class maps to the application properties for accessing
    the user data. We can leverage this identity store to implement the authentication
    provider, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '`LocalAuthProvider` implements the standard `AuthenticationProvider` interface
    by concretely defining the `authenticate()` method. In the `authenticate()` method,
    we simply check whether the identity and secret specified in the user request
    match any username and password in the identity store. If we find a match, then
    we return the `UserDetails` object, else we return `AuthenticatonFailed`.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will concentrate on how we can configure authorizations
    for the `pet-owner` endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring authorizations for the service endpoints
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Often in the user requirements for a microservice, there will be scenarios where
    we need anonymous as well as secured access. To begin with, we will provide anonymous
    access to `PetResource` and `VisitResource`.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to provide anonymous access in Micronaut security:'
  prefs: []
  type: TYPE_NORMAL
- en: Using `@Secured(SecurityRule.IS_ANONYMOUS)`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring `intercept-url-map` in the application properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the following sections, we will drill down into both approaches.
  prefs: []
  type: TYPE_NORMAL
- en: Granting anonymous access using SecurityRule.IS_ANONYMOUS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Micronaut security has a built-in anonymous access security rule. To give access
    to the whole controller or limit it to a specific endpoint, we can simply use
    the `@Secured` annotation. In `PetResource`, we have given anonymous access to
    all the endpoints by using this annotation at the controller level:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Using `@Secured(SecurityRule.IS_ANONYMOUS)` allows anonymous access to all
    the `PetResource` endpoints. We can simply boot the service and try accessing
    any `PetResource` endpoint. You can use any REST client to hit the endpoint. In
    the following screenshot, you''ll notice how we are using a rest client to make
    the HTTP GET call:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.4 – Anonymous access to pets'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.4_B16585.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.4 – Anonymous access to pets
  prefs: []
  type: TYPE_NORMAL
- en: As shown in the preceding screenshot, we can anonymously access `PetResource`
    as it is configured for anonymous access using `@Secured(SecurityRule.IS_ANONYMOUS)`.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will see how we can grant anonymous access using application
    properties.
  prefs: []
  type: TYPE_NORMAL
- en: Granting anonymous access using application properties
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can also configure anonymous access to a controller or specific endpoint
    in the controller using application properties. In the following code snippet,
    we are configuring anonymous access to `…/api/visits` endpoints:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In the application properties, we have configured that any user request to `…/api/visits`
    should be granted anonymous access. This will allow all users (authenticated as
    well as unauthenticated) to access `VisitResource`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To quickly test that we can access `…/api/vistis` anonymously, we can try hitting
    any `VisitResource` endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.5 – Anonymous access to visits'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.5_B16585.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.5 – Anonymous access to visits
  prefs: []
  type: TYPE_NORMAL
- en: As shown in the preceding screenshot, we can anonymously access `VisitResource`
    as it is configured for anonymous access using `intercept-url-map` in `application.properties`.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will explore how to grant secure access using the earlier-defined
    authentication provider.
  prefs: []
  type: TYPE_NORMAL
- en: Granting secured access using the local identity provider
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To grant secured access, we can use the `@Secured` annotation as well as `intercept-url-map`.
    In this hands-on `OwnerResource`, we will define secured access to `OwnerResource`
    using the `@Secured` annotation. Check out the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'All the endpoints within `OwnerResource` are granted only secured access. If
    we try to hit any `…/owners` endpoint, the microservice will return a forbidden
    response, as shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.6 – Unauthenticated access to owners'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.6_B16585.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.6 – Unauthenticated access to owners
  prefs: []
  type: TYPE_NORMAL
- en: As shown in the preceding screenshot, if we try to access any owner endpoint
    without specifying identity credentials, the microservice will throw an `HTTP
    401 Unauthorized` response.
  prefs: []
  type: TYPE_NORMAL
- en: 'For successful access to the owner endpoints, we will need to obtain a session
    cookie. We can log in using the built-in login controller. To log in, simply send
    a post request to the `…/login` path with the correct username and password:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'If the request succeeds, a cookie will be sent in the response:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.7 – Obtaining a cookie for the secured access'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.7_B16585.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.7 – Obtaining a cookie for the secured access
  prefs: []
  type: TYPE_NORMAL
- en: As observed in the preceding screenshot, we will send a post request to `…/login`
    using the correct username and password, to which the service will return a cookie
    in response.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can pass this cookie to any requests to `OwnerResource`. In the following
    screenshot, we passed the obtained cookie to make an HTTP GET call to the `/api/owners`
    endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.8 – Using an obtained cookie for the secured access'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.8_B16585.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.8 – Using an obtained cookie for the secured access
  prefs: []
  type: TYPE_NORMAL
- en: Since we passed the obtained cookie in the request headers, the service will
    extract this cookie, validate, and successfully return the `HTTP 200` response.
  prefs: []
  type: TYPE_NORMAL
- en: Until now, we covered how to address anonymous and authenticated access scenarios
    using session authentication. In the next section, we will dive into using **JSON
    Web Tokens** (**JWTs**) for securing access to a microservice in the Micronaut
    framework.
  prefs: []
  type: TYPE_NORMAL
- en: Using JWT authentication to secure the service endpoints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In token-based authentication, the user state is stored at the client side.
    When a client logs in to the server, the server encrypts the user data into a
    token with a secret and sends it back to the client. Any subsequent user requests
    must have this token set in the request header. The server retrieves the token,
    validates the authenticity, and resumes the user session:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.9 – Token-based authentication'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.9_B16585.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.9 – Token-based authentication
  prefs: []
  type: TYPE_NORMAL
- en: As shown in the preceding diagram, in a token-based authentication strategy,
    the client does the heavy lifting of keeping track of the session in the JSON
    web token. A client must provide a valid token to resume the session.
  prefs: []
  type: TYPE_NORMAL
- en: To learn how to secure a microservice using token-based authentication, we will
    work on a hands-on `pet-clinic` microservice. To begin, we will set up a third-party
    identity provider using Keycloak. In the next section, we will set up Keycloak
    locally.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Keycloak as the identity provider
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will run the Keycloak server in the local Docker container. If you don''t
    have Docker installed, you may refer to the *Technical requirements* section to
    see how to install Docker on your development workspace. To boot up a local Keycloak
    server in Docker, open a Bash terminal and run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: After this, Docker will instantiate a Keycloak server in a container and mount
    container port `8080` to host operating system port `8888`. Furthermore, it will
    create a `micronaut` admin user with the password as `micronaut123`. After successful
    installation, you can access Keycloak at `http://localhost:8888/`. In the next
    section, we will begin by setting up a client for the microservice.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a client on the Keycloak server
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To use Keycloak as an identity provider, we will start with setting up a client.
    Follow these instructions to set up a Keycloak identity provider client:'
  prefs: []
  type: TYPE_NORMAL
- en: Access the **Keycloak admin** module at [http://localhost:8888/auth/admin/](http://localhost:8888/auth/admin/).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Provide a valid admin username and password (in our case, it's `micronaut` and
    `micronaut123`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Clients** from the left navigation menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Provide a client ID (you can skip the rest of the inputs).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After creating a client with the provided Client ID, Keycloak will open the
    settings tab for the client. You must select the highlighted values shown in the
    following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.10 – Creating a client in the Keycloak server'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.10_B16585.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.10 – Creating a client in the Keycloak server
  prefs: []
  type: TYPE_NORMAL
- en: The Keycloak server will create the `pet-clinic` client in the default master
    realm. Next, we will set up some users for this client space.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the users in the client space
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The user setup will enable us to use these identities as test users (and, of
    course, later, the actual users can be configured). We will begin by creating
    the roles. For the `pet-clinic` microservice, we will define two roles: `pet-clinic-admin`
    and `pet-clinic-user`. To create a role, follow the instructions mentioned next:'
  prefs: []
  type: TYPE_NORMAL
- en: Select **Roles** on the main menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Hit the **Add Role** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Provide a role name and hit the **Save** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We will add three users – `Alice` (admin), `Bob` (user), and `Charlie` (user).
    To add a user, follow the instructions mentioned next:'
  prefs: []
  type: TYPE_NORMAL
- en: Select **Users** on the main menu and hit **Add User**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Provide a username and keep the default settings. Hit the **Save** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the user is created, go to the **Credentials** tab specify the password
    and change the **Temporary** flag to **off**. Hit the **Reset** **Password** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To configure `user-role`, go to the **Role Mappings** tab and select the desired
    user role. Changes will be saved automatically.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat the preceding instructions to set up `Alice` as `pet-clinic-admin`, `Bob`
    as `pet-clinic-user`, and `Charlie` as `pet-clinic-user`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to surface this role data from Keycloak, we need to make the following
    changes:'
  prefs: []
  type: TYPE_NORMAL
- en: Select the **Client Scopes** option from the main menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Roles** in the listed options.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to the **Mappers** tab for the roles and select **Realm Roles**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Provide the input as highlighted in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.11 – Configuring the Realm Roles mapper'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.11_B16585.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.11 – Configuring the Realm Roles mapper
  prefs: []
  type: TYPE_NORMAL
- en: Once the users are created and roles are assigned, we can proceed with the `pet-clinic`
    microservice changes. In the next section, we will dive into making `pet-clinic`
    secure using token-based authentication with a Keycloak identity provider.
  prefs: []
  type: TYPE_NORMAL
- en: Securing the pet-clinic microservice using token-based authentication
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To secure the `pet-clinic` microservice, we will first need to enable security
    by adding the following dependencies in the `pom.xml` project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'By importing the `micronaut-security` and `micronaut-security-jwt` dependencies,
    we can leverage the token authentication toolkit in the `pet-clinic` microservice.
    We will use OAuth 2 for integrating with the Keycloak server. Once these dependencies
    are imported, we will then need to configure `application.properties` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In the application properties, `client-id` and `client-secret` must be copied
    from `KeyCloak`. Client secret can be copied by going to `http://localhost:8888/auth/realms/master/.well-known/openid-configuration`.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will focus on how to grant secured access to the controller
    endpoints using the configured token-based authentication strategy and Keycloak
    identity server.
  prefs: []
  type: TYPE_NORMAL
- en: Granting secured access using the KeyCloak identity provider
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To grant secured access, we can use the `@Secured` annotation as well as `intercept-url-map`.
    In the hands-on example, we will grant secured access to `VetResource` using the
    `@Secured` annotation, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'All the endpoints within `VetResource` are granted only secured access. If
    we try to hit any `…/vets` endpoints, the microservice will return a forbidden
    response:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.12 – Unauthenticated access to vets'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.12_B16585.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.12 – Unauthenticated access to vets
  prefs: []
  type: TYPE_NORMAL
- en: As shown in the preceding figure, if we try to access any vet endpoint without
    specifying a valid token, the microservice will throw an `HTTP 401 Unauthorized`
    response.
  prefs: []
  type: TYPE_NORMAL
- en: 'For successful access to the vet endpoints, we will need to obtain a valid
    JWT. We can log in using the built-in login controller. To log in, simply send
    a post request to the `…/login` path with the correct username and password. If
    the request succeeds, a cookie with a JWT will be sent in the response, as shown
    in the next screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.13 – Obtaining a cookie for the secured access'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.13_B16585.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.13 – Obtaining a cookie for the secured access
  prefs: []
  type: TYPE_NORMAL
- en: As highlighted in the screenshot, we will send a post request to the `…/login`
    endpoint using the correct username and password. The service will grant the secured
    access using the KeyCloak identity provider and return a cookie with the JWT.
  prefs: []
  type: TYPE_NORMAL
- en: 'Copy the JWT portion from the preceding response. We can pass this token to
    any requests to `VetResource`. In the following screenshot, we are invoking the
    `…/vets` endpoint using the just-obtained JWT:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.14 – Using the obtained token for the secured access'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.14_B16585.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.14 – Using the obtained token for the secured access
  prefs: []
  type: TYPE_NORMAL
- en: Since we passed a valid token in the request headers, the service will validate
    this token and successfully return the `HTTP 200` response.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have explored how to secure a microservice using a JWT with an external
    identity provider. In the next section, we will focus on how to implement microservice
    security using OAuth with a cloud identity provider.
  prefs: []
  type: TYPE_NORMAL
- en: Using OAuth to secure service endpoints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'OAuth is yet another token-based authentication strategy. Its wide acceptability,
    good coverage of the depth and breadth of web security concerns, and the flexibility
    of managing user sessions at both the client and server side make it an enterprise-grade
    authentication mechanism. OAuth dictates to use the token to establish the identity
    instead of passing usernames and passwords. A token can be obtained from an external
    identity provider and this token can then be passed to any subsequent requests
    to resume a session:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.15 – Separating the concerns with OAuth'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.15_B16585.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.15 – Separating the concerns with OAuth
  prefs: []
  type: TYPE_NORMAL
- en: As shown in the preceding figure, in the OAuth token-based authentication strategy,
    the client obtains a token from the identity provider and uses this token in any
    API requests to the server. The server validates this token with the identity
    provider to return a proper response.
  prefs: []
  type: TYPE_NORMAL
- en: To learn how to secure a microservice using an OAuth and cloud-based identity
    provider, we will do a hands-on exercise with the `pet-clinic-review` microservice.
    To begin, we will set up a cloud identity provider using Okta.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Okta as the identity provider
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Okta is a leading SaaS identity management portal. We will use Okta as the
    identity provider. In order to begin, you must be registered with Okta. Sign up
    at [developer.okta.com](http://developer.okta.com). Once you''re signed up, Okta
    will ask the user to confirm the email. In the email, you will also receive an
    Okta domain, as highlighted in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.16 – Domain name in the Okta signup acknowledgment'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.16_B16585.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.16 – Domain name in the Okta signup acknowledgment
  prefs: []
  type: TYPE_NORMAL
- en: As shown in the figure, an Okta domain will be created for your developer account.
    You must save this as this will be used later to configure Okta as the identity
    provider.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will see how to create an application on Okta.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an app on Okta
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In order to use Okta with your microservice, you are required to create an
    app on Okta. Follow the instructions given as follows for creating an app on Okta:'
  prefs: []
  type: TYPE_NORMAL
- en: Log on to [https://developer.okta.com/.](https://developer.okta.com/.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the landing page, select **Creating a Web Application**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose **Native** as your platform and hit the **Next** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Provide the app settings mentioned in the following screenshot and once all
    the inputs are provided, hit the **Done** button:![Figure 4.17 – Creating the
    microservice app on Okta
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_4.17_B16585.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 4.17 – Creating the microservice app on Okta
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We will keep most of the inputs as their defaults. Under **Grant type allowed**,
    check all the boxes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the app is created successfully, edit **Client Credentials** and select
    the **Use client authentication** option for **Client authentication**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After creating the application as previously instructed, jot down the client
    ID and client secret. This will be used later. Next, we will set up some users
    for this app.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the users in the client space
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The user setup will enable us to use these identities as test users. We will
    add three users – `Alice` (admin), `Bob` (user), and `Charlie` (user). To add
    a user, follow the given instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: On the main navigation bar, hover over **Users** and select **People**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Hit the **Add Person** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Provide inputs as shown in the following screenshot:![Figure 4.18 – Adding a
    person (user) on Okta
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_4.18_B16585.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 4.18 – Adding a person (user) on Okta
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In the password input, choose **Set by admin** and you must keep **User must
    change password on first login** unchecked. This will allow us to quickly use
    the identity without resetting the password.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat the preceding instructions for setting up `Bob` and `Charlie` as application
    users. Once the users are created, we can proceed with the `pet-clinic-reviews`
    microservice changes.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will dive into making `pet-clinic-reviews` secure but
    let's first start with enabling SSL to make encrypted communication over HTTPS.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling SSL in the Micronaut framework
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Any security safeguarding is left incomplete if a microservice is not exposed
    to HTTPS. In earlier sections, we purposely focused on authentication and authorization
    only while skipping SSL. As we will be using a third-party identity provided over
    the cloud, it's recommended and required to enable SSL in the `pet-clinic-reviews`
    microservice.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to enable SSL, we will need an SSL certificate for localhost. We will
    be creating a self-signed certificate using OpenSSL. Follow these instructions
    for creating a self-signed certificate using OpenSSL:'
  prefs: []
  type: TYPE_NORMAL
- en: Open a Git Bash terminal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change directory to the root directory of the `pet-clinic-reviews` project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run `winpty openssl req -x509 -newkey rsa:2048 -keyout key.pem -out cert.pem
    -days 365` in Git Bash. Provide the correct information to create a self-signed
    certificate. This will create a `key.pem` file and `cert.pem` file in the opened
    directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To combine the key and certificate files, run `winpty openssl pkcs12 -inkey
    key.pem -in cert.pem -export -out cert.p12` in Git Bash.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To verify that you've created the P12 file, run `winpty openssl pkcs12 -in cert.p12
    -noout -info` in Git Bash. You must provide the same password that was used to
    create the P12 file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Following the previous instructions, we can successfully create a platform-agnostic
    certificate. The P12 format has gained popularity as it can be used across platforms
    and operating systems. Next, we will add this certificate to the host operating
    system trust store so it can be trusted by all the running applications on the
    system. Follow the instructions mentioned next to add the certificate to the trust
    store:'
  prefs: []
  type: TYPE_NORMAL
- en: Determine `$JAVA_HOME`. It can be found in the system variables.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy the just-created `cert.pem` file to `$JAVA_HOME/jre/lib/security/cacerts`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the Git Bash terminal with admin rights and change the directory to `$JAVA_HOME/jre/lib/security`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run `winpty keytool -importcert -file cert.pem -alias localhost -keystore $JAVA_HOME/jre/lib/security/cacerts
    -storepass changeit` in the Git Bash terminal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By following the previous instructions, we will add the self-signed certificate
    to the trust store. This will enable the system to trust this certificate when
    it's used over SSL.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our custom developer Okta domain may also not be trusted by the system. We
    will follow similar instructions to add the Okta certificate to the `cacerts`
    trust store:'
  prefs: []
  type: TYPE_NORMAL
- en: Open a new tab in the Chrome browser. Open the developer tools.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Hit `https://${yourOktaDomain}/oauth2/default/.well-known/oauth-authorization-server?client_id=${yourClientId}`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the developer tools, go to the **Security** tab and click on **View certificate**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This will open the certificate in a prompt. Go to the **Details** tab on this
    prompt.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **Copy file** and follow the instructions to export the certificate
    to a local directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy the just-exported certificate to `$JAVA_HOME/jre/lib/security/cacerts`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the Git Bash terminal with admin rights and change the directory to `$JAVA_HOME/jre/lib/security`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run `winpty keytool -importcert -file okta.cert -alias localhost -keystore $JAVA_HOME/jre/lib/security/cacerts
    -storepass changeit` in the Git Bash terminal. In the file option, you must provide
    the exported certificate name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adding the developer domain Okta certificate to the system trust store will
    enable us to communicate with the Okta identity provider. In the next section,
    we will dive into enabling SSL in the `pet-clinic-reviews` microservice using
    the self-signed certificate.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the application properties for SSL
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Once you have a legible certificate, the Micronaut framework provides a quick
    way to turn on SSL by configuring some application properties. Make the following
    changes to the application properties to enable SSL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: To enable SSL, we have used a self-signed certificate that we created in the
    previous section. The `8443` for secured communication.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will focus on how to configure the `pet-clinic-reviews`
    microservice with OAuth security using the Okta identity provider.
  prefs: []
  type: TYPE_NORMAL
- en: Securing the pet-clinic-reviews microservice using OAuth
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To secure the `pet-clinic` microservice, we will first need to enable security
    by adding the following dependencies in the `pom` project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'By importing the `micronaut-security` and `micronaut-security-jwt` dependencies,
    we can leverage the token authentication and OAuth toolkit in the `pet-clinic-reviews`
    microservice. Once these dependencies are imported, we will then need to configure
    `application.properties` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In the application properties, `client-id` and `client-secret` must be copied
    from Okta. For the issuer, you must provide your Okta domain in the first part.
    You might just need to change your developer domain but you can get more information
    on authorization and token URLs by accessing the OAuth configurations at `https://${yourOktaDomain}/oauth2/default/.well-known/oauth-authorization-server?client_id=${yourClientId}`.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will focus on how to grant secured access to the controller
    endpoints using the OAuth and Okta identity servers.
  prefs: []
  type: TYPE_NORMAL
- en: Granting secured access using the Okta identity provider
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For granting secured access, we can use the `@Secured` annotation as well as
    `intercept-url-map`. In our hands-on example, we will grant secured access to
    `VetReviewResource` using the `@Secured` annotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'All the endpoints within `VetReviewResource` are granted only secured access.
    If we try to hit any `…/vet-reviews` endpoints, the microservice will return a
    forbidden response. In the following figure, we tried to access the `…/vet-reviews`
    endpoint unsecured and the service responded with `HTTP 401`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.19 – Unauthenticated access to vets'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.19_B16585.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.19 – Unauthenticated access to vets
  prefs: []
  type: TYPE_NORMAL
- en: As highlighted in the previous screenshot, if we try to access any `vet-reviews`
    endpoint without specifying a valid token, the microservice will throw an `HTTP
    401 Unauthorized` response.
  prefs: []
  type: TYPE_NORMAL
- en: 'For successful access to the vet endpoints, we will need to obtain a valid
    JWT. We can obtain a valid token by accessing the Okta token API. The following
    is the `curl` command to call the Okta token API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous `curl` command, you must provide the correct values in `client_id`
    and `client_secret`, the `POST` URL and the user credentials. If everything is
    validated successfully, the token API will respond back with a bearer and ID token.
    Copy the returned access token. We can pass this token to any requests to `VetReviewResource`
    for secured communication:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.20 – Using the obtained token for secured access'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.20_B16585.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.20 – Using the obtained token for secured access
  prefs: []
  type: TYPE_NORMAL
- en: Since we passed a valid token in the request headers, the service will validate
    this token and successfully return the `HTTP 200` response.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned about and experimented with OAuth security. To make
    `pet-clinic-reviews` service endpoints secure, we used OAuth with Okta as a third-party
    identity provider.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored various ways to secure microservices in the Micronaut
    framework. We began our journey by diving into a session authentication strategy,
    and then we explored token-based authentication using an external Keycloak identity
    server. Lastly, we worked on securing a microservice using OAuth with a cloud-based
    identity provider. Furthermore, we also worked on enabling SSL to make service
    communication secure over HTTPS.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter provided you with a handy, focused skillset in safeguarding a microservice
    in the Micronaut framework using various authentication strategies, along with
    how to work with local or external (cloud) identity providers.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will explore how we can integrate different microservices
    using event-driven architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What are the various authentication strategies in the Micronaut framework?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a security filter in Micronaut?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you set up session-based authentication in the Micronaut framework?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the `@Secured` annotation in the Micronaut framework?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is `intercept-url-maps` in the Micronaut framework?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you set up token-based authentication in the Micronaut framework?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you set up JWT authentication in the Micronaut framework?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you integrate with Keycloak in the Micronaut framework?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you set up OAuth authentication in the Micronaut framework?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you integrate with Okta in the Micronaut framework?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you enable SSL in the Micronaut framework?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
