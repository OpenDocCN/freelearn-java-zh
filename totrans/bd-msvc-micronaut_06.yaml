- en: '*Chapter 4*: Securing the Microservices'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 4 章*: 保护微服务'
- en: 'Protecting microservices'' interfaces as well as the world encompassed by them
    is a crucial facet for any application development. Various topologies, tools,
    and frameworks have arisen in recent times to address the security aspects of
    web services/microservices. In the course of this chapter, we will dive into some
    core and often-used security paradigms in microservices. We will continue with
    the `pet-clinic` application from the previous chapter. For hands-on work, we
    will work toward securing microservices while covering the following authentication
    strategies in the Micronaut framework:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 保护微服务接口以及它们所包含的世界是任何应用程序开发的关键方面。近年来，出现了各种拓扑、工具和框架来解决 Web 服务/微服务的安全方面。在本章中，我们将深入研究微服务中的一些核心和常用安全范式。我们将继续使用上一章的
    `pet-clinic` 应用程序。为了实际操作，我们将致力于在 Micronaut 框架中涵盖以下认证策略的同时保护微服务：
- en: '`pet-owner`: Working hands-on to secure `pet-owner` microservice endpoints
    using **session authentication**'
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pet-owner`: 通过实际操作来保护 `pet-owner` 微服务端点，使用 **会话认证**'
- en: '`pet-clinic`: Working hands-on to secure `pet-clinic` microservice endpoints
    using **JWT authentication**'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pet-clinic`: 通过实际操作来保护 `pet-clinic` 微服务端点，使用 **JWT 认证**'
- en: '`pet-clinic-review`: Working hands-on to secure `pet-clinic-review` microservice
    endpoints using **OAuth authentication**'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pet-clinic-review`: 通过实际操作来保护 `pet-clinic-review` 微服务端点，使用 **OAuth 认证**'
- en: 'With the aforementioned hands-on exercises, we will be covering the following
    topics in this chapter:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 通过上述实际操作练习，我们将在本章中涵盖以下主题：
- en: Using **session authentication** to secure the service endpoints
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 **会话认证**来保护服务端点
- en: Using **JWT authentication** to secure the service endpoints
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 **JWT 认证**来保护服务端点
- en: Using **OAuth** to secure the service endpoints
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 **OAuth** 来保护服务端点
- en: By the end of this chapter, you will have a nifty knowledge of working with
    various authentication strategies and local or cloud identity providers in the
    Micronaut framework.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将掌握在 Micronaut 框架中与各种认证策略和本地或云身份提供者一起工作的实用知识。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: All the commands and technical instructions in this chapter are run on Windows
    10 and Mac OS X. Code examples covered in this chapter are available in the book's
    GitHub repository at [https://github.com/PacktPublishing/Building-Microservices-with-Micronaut/tree/master/Chapter04](https://github.com/PacktPublishing/Building-Microservices-with-Micronaut/tree/master/Chapter04).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中所有命令和技术说明均在 Windows 10 和 Mac OS X 上运行。本章涵盖的代码示例可在本书的 GitHub 仓库中找到，地址为 [https://github.com/PacktPublishing/Building-Microservices-with-Micronaut/tree/master/Chapter04](https://github.com/PacktPublishing/Building-Microservices-with-Micronaut/tree/master/Chapter04)。
- en: 'The following tools need to be installed and set up in the development environment:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发环境中需要安装和设置以下工具：
- en: '**Java SDK**: Version 13 or above (we used Java 14).'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Java SDK**: 版本 13 或更高（我们使用了 Java 14）。'
- en: '**Maven**: This is optional and only required if you would like to use Maven
    as the build system. However, we recommend having Maven set up on any development
    machine. Instructions to download and install Maven can be found at [https://maven.apache.org/download.cgi](https://maven.apache.org/download.cgi).'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Maven**: 这不是必需的，只有当你想使用 Maven 作为构建系统时才需要。然而，我们建议在任何开发机器上设置 Maven。下载和安装 Maven
    的说明可以在 [https://maven.apache.org/download.cgi](https://maven.apache.org/download.cgi)
    找到。'
- en: '**Development IDE**: Based on your preference, any Java-based IDE can be used,
    but for the purpose of writing this chapter, IntelliJ was used.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开发 IDE**: 根据您的偏好，可以使用任何基于 Java 的 IDE，但为了编写本章，使用了 IntelliJ。'
- en: '**Git**: Instructions to download and install Git can be found at [https://git-scm.com/downloads](https://git-scm.com/downloads).'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Git**: 下载和安装 Git 的说明可以在 [https://git-scm.com/downloads](https://git-scm.com/downloads)
    找到。'
- en: '**PostgreSQL**: Instructions to download and install PostgreSQL can be found
    at [https://www.postgresql.org/download/](https://www.postgresql.org/download/).'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PostgreSQL**: 下载和安装 PostgreSQL 的说明可以在 [https://www.postgresql.org/download/](https://www.postgresql.org/download/)
    找到。'
- en: '**MongoDB**: MongoDB Atlas provides a free online database-as-a-service with
    up to 512 MB storage. However, if a local database is preferred, then instructions
    to download and install can be found at [https://docs.mongodb.com/manual/administration/install-community/](https://docs.mongodb.com/manual/administration/install-community/).
    We used a local installation for this chapter.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**MongoDB**：MongoDB Atlas 提供了一个免费的在线数据库即服务，存储空间高达 512 MB。然而，如果您更喜欢本地数据库，则可以在[https://docs.mongodb.com/manual/administration/install-community/](https://docs.mongodb.com/manual/administration/install-community/)找到下载和安装的说明。我们为本章使用了本地安装。'
- en: '**Rest client**: Any HTTP rest client can be used. We used the Advanced REST
    Client Chrome plugin.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Rest 客户端**：可以使用任何 HTTP REST 客户端。我们使用了 Advanced REST Client Chrome 插件。'
- en: '**Docker**: Instructions to download and install Docker can be found at [https://docs.docker.com/get-docker/](https://docs.docker.com/get-docker/).'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Docker**：有关下载和安装 Docker 的说明可以在[https://docs.docker.com/get-docker/](https://docs.docker.com/get-docker/)找到。'
- en: '**OpenSSL**: Instructions to download and install OpenSSL can be found at [https://www.openssl.org/source/](https://www.openssl.org/source/).'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OpenSSL**：有关下载和安装 OpenSSL 的说明可以在[https://www.openssl.org/source/](https://www.openssl.org/source/)找到。'
- en: Working on RESTful microservices in the Micronaut framework
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Micronaut 框架中处理 RESTful 微服务
- en: 'In order to dive into the security aspects of the Micronaut framework, we will
    continue working on the `pet-clinic` application. The following table summarizes
    the changes we will be making to secure each of the microservices in the application:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 为了深入了解 Micronaut 框架的安全方面，我们将继续在 `pet-clinic` 应用程序上工作。以下表格总结了我们将对应用程序中的每个微服务进行的安全更改：
- en: '![Table 4.1 – Securing the microservices in the pet-clinic application'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '![表 4.1 – 在 pet-clinic 应用程序中保护微服务'
- en: '](img/Table_4.1.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '![表 4.1.jpg](img/Table_4.1.jpg)'
- en: Table 4.1 – Securing the microservices in the pet-clinic application
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4.1 – 在 pet-clinic 应用程序中保护微服务
- en: 'To secure the desired endpoints in the microservices, we will focus on the
    following two key aspects:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保微服务中的预期端点，我们将重点关注以下两个关键方面：
- en: '**Identity provider**: Essentially, an identity provider owns the concerns
    regarding storing and maintaining digital identities. Furthermore, it resolves
    any security claim by authenticating the submitted digital identity with its quorum
    of stored identities.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**身份提供者**：本质上，身份提供者拥有存储和维护数字身份的担忧。此外，它通过使用其存储的数字身份的多数派来验证提交的数字身份，解决任何安全声明。'
- en: '**Authentication strategy**: The authentication strategy will dictate how a
    microservice will communicate with the identity provider to authenticate and authorize
    the user requests.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**认证策略**：认证策略将决定微服务如何与身份提供者通信以认证和授权用户请求。'
- en: 'Adding to the diagram of the components from [*Chapter 3*](B16585_03_Final_VK_ePub.xhtml#_idTextAnchor065),
    *Working on Restful Web Services*, the following will be the changes in this chapter
    within each microservice:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加到来自[*第 3 章*](B16585_03_Final_VK_ePub.xhtml#_idTextAnchor065)，“在 Restful Web
    服务上工作”的组件图的基础上，本章中每个微服务的以下内容将发生变化：
- en: '![Figure 4.1 – Microservice components'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.1 – 微服务组件'
- en: '](img/Figure_4.1_B16585.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.1_B16585.jpg](img/Figure_4.1_B16585.jpg)'
- en: Figure 4.1 – Microservice components
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1 – 微服务组件
- en: We will stick to our usual pattern of separating the concerns. We will use an
    identity provider in tandem with an authentication strategy within each of the
    microservices.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将坚持我们通常的模式，将关注点分开。我们将在每个微服务中使用一个身份提供者，并与认证策略协同工作。
- en: In the next section, our focus will be to cover out-of-the-box tools provided
    by the Micronaut framework for security concerns.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们的重点将是介绍 Micronaut 框架为安全考虑提供的现成工具。
- en: The basics of Micronaut security
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Micronaut 安全基础
- en: 'For handling any security aspects, the Micronaut framework has a built-in `SecurityFilter`
    object. The `SecurityFilter` object intercepts any incoming HTTP requests and
    kickstarts the authentication/authorization process as configured in the application.
    In the following diagram, you can see the workflow within the `SecurityFilter`
    object for authorizing a user request:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理任何安全方面，Micronaut 框架内置了一个 `SecurityFilter` 对象。`SecurityFilter` 对象拦截任何传入的
    HTTP 请求，并启动应用程序中配置的认证/授权过程。在以下图中，您可以看到 `SecurityFilter` 对象中授权用户请求的工作流程：
- en: '![Figure 4.2 – Micronaut security filter'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.2 – Micronaut 安全过滤器'
- en: '](img/Figure_4.2_B16585.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.2_B16585.jpg](img/Figure_4.2_B16585.jpg)'
- en: Figure 4.2 – Micronaut security filter
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.2 – Micronaut 安全过滤器
- en: 'Micronaut''s `SecurityFilter` has three essential parts:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Micronaut 的 `SecurityFilter` 有三个基本部分：
- en: '`AuthenticationFetcher` will fetch the required downstream authenticator for
    authenticating the user request.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AuthenticationFetcher` 将获取用于验证用户请求所需的下游认证器。'
- en: '`Authenticator` injects the configured authentication provider(s) and security
    configurations for authenticating the user request. An `AuthenticationResponse`
    object is created based on the success or failure of the auth operation.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Authenticator` 注入配置的认证提供程序和安全配置以验证用户请求。根据认证操作的成功或失败，创建一个 `AuthenticationResponse`
    对象。'
- en: '`SecuredAnnotationRule` or `IpPatternsRule` or by creating its own security
    rules by extending `AbstractSecurityRule`. If the request satisfies all the security
    rules, then a successful `AuthenticationResponse` response is returned by the
    security filter; otherwise, it will return a failed `AuthenticationResponse` response.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过 `SecuredAnnotationRule` 或 `IpPatternsRule` 或通过扩展 `AbstractSecurityRule` 创建自己的安全规则。如果请求满足所有安全规则，则安全过滤器将返回成功的
    `AuthenticationResponse` 响应；否则，它将返回失败的 `AuthenticationResponse` 响应。
- en: By leveraging `SecurityFilter`, in the next section, we will focus on how to
    secure a microservice using session authentication in the Micronaut framework.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 通过利用 `SecurityFilter`，在下一节中，我们将关注如何在 Micronaut 框架中使用会话认证来保护微服务。
- en: Securing service endpoints using session authentication
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用会话认证保护服务端点
- en: 'In session-based authentication, the user state is stored at the server side.
    When a user logs in to the server, the server starts the session and issues a
    session ID in a cookie. The server uses the session ID to uniquely identify a
    session from the session quorum. Any subsequent user requests must have this session
    ID passed as a cookie to resume the session:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于会话的认证中，用户状态存储在服务器端。当用户登录到服务器时，服务器启动会话并发出一个会话 ID 作为 cookie。服务器使用会话 ID 从会话共识中唯一标识一个会话。任何后续的用户请求都必须将此会话
    ID 作为 cookie 传递以恢复会话：
- en: '![Figure 4.3 – Session-based authentication'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.3 – 基于会话的认证'
- en: '](img/Figure_4.3_B16585.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 4.3](img/Figure_4.3_B16585.jpg)'
- en: Figure 4.3 – Session-based authentication
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.3 – 基于会话的认证
- en: As shown in the preceding figure, in a session-based authentication strategy,
    the server does the heavy lifting of keeping a track of the session. A client
    must provide a valid session ID to resume the session.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，在基于会话的认证策略中，服务器负责跟踪会话。客户端必须提供一个有效的会话 ID 以恢复会话。
- en: 'To learn how to secure a microservice using session-based authentication, we
    will experiment on the `pet-owner` microservice. To begin, we will need to enable
    security by adding the following dependencies to the `pom.xml` project:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解如何使用基于会话的认证来保护微服务，我们将对 `pet-owner` 微服务进行实验。首先，我们需要通过向 `pom.xml` 项目添加以下依赖项来启用安全功能：
- en: '[PRE0]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'By importing the `micronaut-security` and `micronaut-security-session` dependencies,
    we can leverage the session authentication toolkit in the `pet-owner` microservice.
    Once these dependencies are imported, we will then need to configure `application.properties`
    as shown in the next code block:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 通过导入 `micronaut-security` 和 `micronaut-security-session` 依赖项，我们可以在 `pet-owner`
    微服务中利用会话认证工具包。一旦导入这些依赖项，我们接下来需要按照下一个代码块所示配置 `application.properties`：
- en: '[PRE1]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As mentioned in the preceding `application.properties` instance, we will enable
    the security by setting `enabled` to `true` and specifying `session` as the desired
    authentication strategy. Furthermore, the Micronaut security toolkit provides
    `LoginController` and `LogoutController` out of the box. In the application properties,
    we have enabled them and since we haven't specified a custom path for these controllers,
    they will be accessible at default specified paths of `…/login` and `…/logout`,
    respectively.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述的 `application.properties` 实例，我们将通过将 `enabled` 设置为 `true` 并指定 `session`
    作为所需的认证策略来启用安全功能。此外，Micronaut 安全工具包提供了开箱即用的 `LoginController` 和 `LogoutController`。在应用程序属性中，我们已经启用了它们，并且由于我们没有指定这些控制器的自定义路径，它们将分别可在默认指定的路径
    `…/login` 和 `…/logout` 上访问。
- en: 'We will use a basic local identity provider that will leverage application
    properties to store user data. This is very primitive but will help in simplifying
    learning and exploration. Let''s add some user data to `application.properties`:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一个基本的本地身份提供程序，该程序将利用应用程序属性来存储用户数据。这非常原始，但有助于简化学习和探索。让我们向 `application.properties`
    添加一些用户数据：
- en: '[PRE2]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We have added three users: `alice`, `bob`, and `charlie`. Each user is also
    assigned a role for the `pet-owner` microservice.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已添加了三个用户：`alice`、`bob` 和 `charlie`。每个用户也被分配了 `pet-owner` 微服务的角色。
- en: In the next section, we will explore how to implement an authentication provider
    that will use the configured application properties for user data.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨如何实现一个使用配置的应用程序属性进行用户数据操作的认证提供者。
- en: Implementing a basic authentication provider
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现基本认证提供者
- en: To implement a basic authentication provider, we will begin by creating a `com.packtpub.micronaut.security`
    security package. This package will encompass all the artifacts concerning security.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现一个基本的身份验证提供者，我们首先将创建一个 `com.packtpub.micronaut.security` 安全包。这个包将包含所有与安全相关的工件。
- en: 'We will first add `IdentityStore` to this package:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将 `IdentityStore` 添加到这个包中：
- en: '[PRE3]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `IdentityStore` class maps to the application properties for accessing
    the user data. We can leverage this identity store to implement the authentication
    provider, as shown in the following code snippet:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`IdentityStore` 类映射到应用程序属性，用于访问用户数据。我们可以利用这个身份存储库来实现认证提供者，如下面的代码片段所示：'
- en: '[PRE4]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`LocalAuthProvider` implements the standard `AuthenticationProvider` interface
    by concretely defining the `authenticate()` method. In the `authenticate()` method,
    we simply check whether the identity and secret specified in the user request
    match any username and password in the identity store. If we find a match, then
    we return the `UserDetails` object, else we return `AuthenticatonFailed`.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`LocalAuthProvider` 通过具体定义 `authenticate()` 方法来实现标准 `AuthenticationProvider`
    接口。在 `authenticate()` 方法中，我们简单地检查用户请求中指定的身份和密码是否与身份存储库中的任何用户名和密码匹配。如果我们找到匹配项，则返回
    `UserDetails` 对象，否则返回 `AuthenticatonFailed`。'
- en: In the next section, we will concentrate on how we can configure authorizations
    for the `pet-owner` endpoints.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将集中讨论如何为 `pet-owner` 端点配置授权。
- en: Configuring authorizations for the service endpoints
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置服务端点的授权
- en: Often in the user requirements for a microservice, there will be scenarios where
    we need anonymous as well as secured access. To begin with, we will provide anonymous
    access to `PetResource` and `VisitResource`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在微服务的用户需求中，通常会有需要匿名访问以及受保护访问的场景。首先，我们将为 `PetResource` 和 `VisitResource` 提供匿名访问。
- en: 'There are two ways to provide anonymous access in Micronaut security:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Micronaut 安全中提供匿名访问有两种方式：
- en: Using `@Secured(SecurityRule.IS_ANONYMOUS)`
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `@Secured(SecurityRule.IS_ANONYMOUS)`
- en: Configuring `intercept-url-map` in the application properties
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在应用程序属性中配置 `intercept-url-map`
- en: In the following sections, we will drill down into both approaches.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将深入探讨这两种方法。
- en: Granting anonymous access using SecurityRule.IS_ANONYMOUS
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 SecurityRule.IS_ANONYMOUS 授予匿名访问
- en: 'Micronaut security has a built-in anonymous access security rule. To give access
    to the whole controller or limit it to a specific endpoint, we can simply use
    the `@Secured` annotation. In `PetResource`, we have given anonymous access to
    all the endpoints by using this annotation at the controller level:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Micronaut 安全内置了一个匿名访问安全规则。为了给整个控制器提供访问权限或将其限制在特定的端点上，我们可以简单地使用 `@Secured` 注解。在
    `PetResource` 中，我们通过在控制器级别使用此注解来为所有端点提供匿名访问：
- en: '[PRE5]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Using `@Secured(SecurityRule.IS_ANONYMOUS)` allows anonymous access to all
    the `PetResource` endpoints. We can simply boot the service and try accessing
    any `PetResource` endpoint. You can use any REST client to hit the endpoint. In
    the following screenshot, you''ll notice how we are using a rest client to make
    the HTTP GET call:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `@Secured(SecurityRule.IS_ANONYMOUS)` 允许对所有 `PetResource` 端点进行匿名访问。我们可以简单地启动服务并尝试访问任何
    `PetResource` 端点。您可以使用任何 REST 客户端来调用端点。在下面的屏幕截图中，您将注意到我们如何使用 REST 客户端进行 HTTP GET
    调用：
- en: '![Figure 4.4 – Anonymous access to pets'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.4 – 对宠物的匿名访问'
- en: '](img/Figure_4.4_B16585.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.4_B16585.jpg)'
- en: Figure 4.4 – Anonymous access to pets
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.4 – 对宠物的匿名访问
- en: As shown in the preceding screenshot, we can anonymously access `PetResource`
    as it is configured for anonymous access using `@Secured(SecurityRule.IS_ANONYMOUS)`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一个屏幕截图所示，我们可以匿名访问 `PetResource`，因为它使用 `@Secured(SecurityRule.IS_ANONYMOUS)`
    进行了匿名访问配置。
- en: In the next section, we will see how we can grant anonymous access using application
    properties.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看到如何使用应用程序属性授予匿名访问。
- en: Granting anonymous access using application properties
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用应用程序属性授予匿名访问
- en: 'We can also configure anonymous access to a controller or specific endpoint
    in the controller using application properties. In the following code snippet,
    we are configuring anonymous access to `…/api/visits` endpoints:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用应用程序属性配置控制器或控制器中的特定端点的匿名访问。在以下代码片段中，我们正在配置对 `…/api/visits` 端点的匿名访问：
- en: '[PRE6]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the application properties, we have configured that any user request to `…/api/visits`
    should be granted anonymous access. This will allow all users (authenticated as
    well as unauthenticated) to access `VisitResource`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序属性中，我们已配置任何用户对`…/api/visits`的请求都应授予匿名访问权限。这将允许所有用户（包括已认证和未认证的用户）访问`VisitResource`。
- en: 'To quickly test that we can access `…/api/vistis` anonymously, we can try hitting
    any `VisitResource` endpoint:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 要快速测试我们能否匿名访问`…/api/vistis`，我们可以尝试对任何`VisitResource`端点进行访问：
- en: '![Figure 4.5 – Anonymous access to visits'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.5 – 对访问的匿名访问'
- en: '](img/Figure_4.5_B16585.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_4.5_B16585.jpg)'
- en: Figure 4.5 – Anonymous access to visits
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.5 – 对访问的匿名访问'
- en: As shown in the preceding screenshot, we can anonymously access `VisitResource`
    as it is configured for anonymous access using `intercept-url-map` in `application.properties`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一个屏幕截图所示，由于`application.properties`中的`intercept-url-map`配置了匿名访问，我们可以匿名访问`VisitResource`。
- en: In the next section, we will explore how to grant secure access using the earlier-defined
    authentication provider.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨如何使用先前定义的认证提供者授予安全访问权限。
- en: Granting secured access using the local identity provider
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用本地身份提供者授予安全访问权限
- en: 'To grant secured access, we can use the `@Secured` annotation as well as `intercept-url-map`.
    In this hands-on `OwnerResource`, we will define secured access to `OwnerResource`
    using the `@Secured` annotation. Check out the following code block:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 要授予安全访问权限，我们可以使用`@Secured`注解以及`intercept-url-map`。在这个动手实践的`OwnerResource`中，我们将使用`@Secured`注解定义对`OwnerResource`的安全访问。查看以下代码块：
- en: '[PRE7]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'All the endpoints within `OwnerResource` are granted only secured access. If
    we try to hit any `…/owners` endpoint, the microservice will return a forbidden
    response, as shown next:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`OwnerResource`中的所有端点仅授予安全访问权限。如果我们尝试访问任何`…/owners`端点，微服务将返回一个禁止响应，如以下所示：'
- en: '![Figure 4.6 – Unauthenticated access to owners'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.6 – 对所有者的未认证访问'
- en: '](img/Figure_4.6_B16585.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_4.6_B16585.jpg)'
- en: Figure 4.6 – Unauthenticated access to owners
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.6 – 对所有者的未认证访问'
- en: As shown in the preceding screenshot, if we try to access any owner endpoint
    without specifying identity credentials, the microservice will throw an `HTTP
    401 Unauthorized` response.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一个屏幕截图所示，如果我们尝试在不指定身份凭证的情况下访问任何所有者端点，微服务将抛出`HTTP 401 Unauthorized`响应。
- en: 'For successful access to the owner endpoints, we will need to obtain a session
    cookie. We can log in using the built-in login controller. To log in, simply send
    a post request to the `…/login` path with the correct username and password:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 为了成功访问所有者端点，我们需要获取一个会话cookie。我们可以使用内置的登录控制器进行登录。要登录，只需向`…/login`路径发送带有正确用户名和密码的POST请求：
- en: '[PRE8]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If the request succeeds, a cookie will be sent in the response:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果请求成功，响应中会发送一个cookie：
- en: '![Figure 4.7 – Obtaining a cookie for the secured access'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.7 – 获取安全访问的cookie'
- en: '](img/Figure_4.7_B16585.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_4.7_B16585.jpg)'
- en: Figure 4.7 – Obtaining a cookie for the secured access
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.7 – 获取安全访问的cookie
- en: As observed in the preceding screenshot, we will send a post request to `…/login`
    using the correct username and password, to which the service will return a cookie
    in response.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一个屏幕截图所示，我们将使用正确的用户名和密码向`…/login`发送POST请求，服务将返回cookie作为响应。
- en: 'We can pass this cookie to any requests to `OwnerResource`. In the following
    screenshot, we passed the obtained cookie to make an HTTP GET call to the `/api/owners`
    endpoint:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将此cookie传递给对`OwnerResource`的任何请求。在下面的屏幕截图中，我们传递了获取到的cookie来对`/api/owners`端点进行HTTP
    GET调用：
- en: '![Figure 4.8 – Using an obtained cookie for the secured access'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.8 – 使用获取到的cookie进行安全访问'
- en: '](img/Figure_4.8_B16585.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_4.8_B16585.jpg)'
- en: Figure 4.8 – Using an obtained cookie for the secured access
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.8 – 使用获取到的cookie进行安全访问
- en: Since we passed the obtained cookie in the request headers, the service will
    extract this cookie, validate, and successfully return the `HTTP 200` response.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在请求头中传递了获取到的cookie，服务将提取此cookie，验证并成功返回`HTTP 200`响应。
- en: Until now, we covered how to address anonymous and authenticated access scenarios
    using session authentication. In the next section, we will dive into using **JSON
    Web Tokens** (**JWTs**) for securing access to a microservice in the Micronaut
    framework.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们介绍了如何使用会话认证处理匿名和认证访问场景。在下一节中，我们将深入探讨在Micronaut框架中使用**JSON Web Tokens**（JWTs）来保护对微服务的访问。
- en: Using JWT authentication to secure the service endpoints
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用JWT认证保护服务端点
- en: 'In token-based authentication, the user state is stored at the client side.
    When a client logs in to the server, the server encrypts the user data into a
    token with a secret and sends it back to the client. Any subsequent user requests
    must have this token set in the request header. The server retrieves the token,
    validates the authenticity, and resumes the user session:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于令牌的身份验证中，用户状态存储在客户端。当客户端登录到服务器时，服务器将用户数据加密成一个带有秘密的令牌，并将其发送回客户端。任何后续的用户请求都必须在请求头中设置此令牌。服务器检索令牌，验证其真实性，并恢复用户会话：
- en: '![Figure 4.9 – Token-based authentication'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.9 – 基于令牌的身份验证'
- en: '](img/Figure_4.9_B16585.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.9_B16585.jpg)'
- en: Figure 4.9 – Token-based authentication
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.9 – 基于令牌的身份验证
- en: As shown in the preceding diagram, in a token-based authentication strategy,
    the client does the heavy lifting of keeping track of the session in the JSON
    web token. A client must provide a valid token to resume the session.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，在基于令牌的身份验证策略中，客户端负责在JSON Web令牌中跟踪会话。客户端必须提供一个有效的令牌以恢复会话。
- en: To learn how to secure a microservice using token-based authentication, we will
    work on a hands-on `pet-clinic` microservice. To begin, we will set up a third-party
    identity provider using Keycloak. In the next section, we will set up Keycloak
    locally.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 要学习如何使用基于令牌的身份验证来保护微服务，我们将通过一个实际的`pet-clinic`微服务进行操作。首先，我们将使用Keycloak设置一个第三方身份提供者。在下一节中，我们将本地设置Keycloak。
- en: Setting up Keycloak as the identity provider
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置Keycloak作为身份提供者
- en: 'We will run the Keycloak server in the local Docker container. If you don''t
    have Docker installed, you may refer to the *Technical requirements* section to
    see how to install Docker on your development workspace. To boot up a local Keycloak
    server in Docker, open a Bash terminal and run the following command:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本地Docker容器中运行Keycloak服务器。如果您尚未安装Docker，您可以参考*技术要求*部分了解如何在您的开发工作区中安装Docker。要启动本地Keycloak服务器，请打开Bash终端并运行以下命令：
- en: '[PRE9]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: After this, Docker will instantiate a Keycloak server in a container and mount
    container port `8080` to host operating system port `8888`. Furthermore, it will
    create a `micronaut` admin user with the password as `micronaut123`. After successful
    installation, you can access Keycloak at `http://localhost:8888/`. In the next
    section, we will begin by setting up a client for the microservice.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，Docker将在容器中实例化一个Keycloak服务器，并将容器端口`8080`映射到主机操作系统的端口`8888`。此外，它将创建一个密码为`micronaut123`的`micronaut`管理员用户。安装成功后，您可以通过`http://localhost:8888/`访问Keycloak。在下一节中，我们将开始为微服务设置客户端。
- en: Creating a client on the Keycloak server
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在Keycloak服务器上创建客户端
- en: 'To use Keycloak as an identity provider, we will start with setting up a client.
    Follow these instructions to set up a Keycloak identity provider client:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 要将Keycloak用作身份提供者，我们将从设置客户端开始。按照以下说明设置Keycloak身份提供者客户端：
- en: Access the **Keycloak admin** module at [http://localhost:8888/auth/admin/](http://localhost:8888/auth/admin/).
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问[http://localhost:8888/auth/admin/](http://localhost:8888/auth/admin/)的**Keycloak管理员**模块。
- en: Provide a valid admin username and password (in our case, it's `micronaut` and
    `micronaut123`).
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供有效的管理员用户名和密码（在我们的例子中，是`micronaut`和`micronaut123`）。
- en: Select **Clients** from the left navigation menu.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从左侧导航菜单中选择**客户端**。
- en: Provide a client ID (you can skip the rest of the inputs).
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供客户端ID（您可以跳过其余的输入）。
- en: 'After creating a client with the provided Client ID, Keycloak will open the
    settings tab for the client. You must select the highlighted values shown in the
    following screenshot:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建具有提供的客户端ID的客户端后，Keycloak将为客户端打开设置标签页。您必须选择以下截图所示的突出显示的值：
- en: '![Figure 4.10 – Creating a client in the Keycloak server'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.10 – 在Keycloak服务器中创建客户端'
- en: '](img/Figure_4.10_B16585.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.10_B16585.jpg)'
- en: Figure 4.10 – Creating a client in the Keycloak server
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.10 – 在Keycloak服务器中创建客户端
- en: The Keycloak server will create the `pet-clinic` client in the default master
    realm. Next, we will set up some users for this client space.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: Keycloak服务器将在默认的主域中创建`pet-clinic`客户端。接下来，我们将为这个客户端空间设置一些用户。
- en: Setting up the users in the client space
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在客户端空间中设置用户
- en: 'The user setup will enable us to use these identities as test users (and, of
    course, later, the actual users can be configured). We will begin by creating
    the roles. For the `pet-clinic` microservice, we will define two roles: `pet-clinic-admin`
    and `pet-clinic-user`. To create a role, follow the instructions mentioned next:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 用户设置将使我们能够将这些身份用作测试用户（当然，稍后，实际用户也可以进行配置）。我们将首先创建角色。对于`pet-clinic`微服务，我们将定义两个角色：`pet-clinic-admin`和`pet-clinic-user`。要创建一个角色，请遵循以下说明：
- en: Select **Roles** on the main menu.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在主菜单中选择**角色**。
- en: Hit the **Add Role** button.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**添加角色**按钮。
- en: Provide a role name and hit the **Save** button.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供角色名称并点击**保存**按钮。
- en: 'We will add three users – `Alice` (admin), `Bob` (user), and `Charlie` (user).
    To add a user, follow the instructions mentioned next:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将添加三个用户 – `Alice`（管理员）、`Bob`（用户）和`Charlie`（用户）。要添加用户，请遵循以下说明：
- en: Select **Users** on the main menu and hit **Add User**.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在主菜单中选择**用户**并点击**添加用户**。
- en: Provide a username and keep the default settings. Hit the **Save** button.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供用户名并保持默认设置。点击**保存**按钮。
- en: Once the user is created, go to the **Credentials** tab specify the password
    and change the **Temporary** flag to **off**. Hit the **Reset** **Password** button.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户创建后，前往**凭证**选项卡，指定密码并将**临时**标志更改为**关闭**。点击**重置****密码**按钮。
- en: To configure `user-role`, go to the **Role Mappings** tab and select the desired
    user role. Changes will be saved automatically.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要配置`user-role`，请前往**角色映射**选项卡并选择所需用户角色。更改将自动保存。
- en: Repeat the preceding instructions to set up `Alice` as `pet-clinic-admin`, `Bob`
    as `pet-clinic-user`, and `Charlie` as `pet-clinic-user`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 重复前面的说明，将`Alice`设置为`pet-clinic-admin`，`Bob`设置为`pet-clinic-user`，`Charlie`设置为`pet-clinic-user`。
- en: 'In order to surface this role data from Keycloak, we need to make the following
    changes:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从Keycloak中公开这些角色数据，我们需要进行以下更改：
- en: Select the **Client Scopes** option from the main menu.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从主菜单中选择**客户端作用域**选项。
- en: Select **Roles** in the listed options.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在列出的选项中选择**角色**。
- en: Go to the **Mappers** tab for the roles and select **Realm Roles**.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往角色的**映射器**选项卡，并选择**领域角色**。
- en: 'Provide the input as highlighted in the following screenshot:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供以下截图中所突出显示的输入：
- en: '![Figure 4.11 – Configuring the Realm Roles mapper'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.11 – 配置领域角色映射器'
- en: '](img/Figure_4.11_B16585.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.11_B16585.jpg)'
- en: Figure 4.11 – Configuring the Realm Roles mapper
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.11 – 配置领域角色映射器
- en: Once the users are created and roles are assigned, we can proceed with the `pet-clinic`
    microservice changes. In the next section, we will dive into making `pet-clinic`
    secure using token-based authentication with a Keycloak identity provider.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了用户并分配了角色，我们就可以继续对`pet-clinic`微服务进行更改。在下一节中，我们将深入了解如何使用Keycloak身份提供者的基于令牌的认证来使`pet-clinic`微服务安全。
- en: Securing the pet-clinic microservice using token-based authentication
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用基于令牌的认证保护pet-clinic微服务
- en: 'To secure the `pet-clinic` microservice, we will first need to enable security
    by adding the following dependencies in the `pom.xml` project:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保护`pet-clinic`微服务，我们首先需要在`pom.xml`项目中添加以下依赖项来启用安全功能：
- en: '[PRE10]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'By importing the `micronaut-security` and `micronaut-security-jwt` dependencies,
    we can leverage the token authentication toolkit in the `pet-clinic` microservice.
    We will use OAuth 2 for integrating with the Keycloak server. Once these dependencies
    are imported, we will then need to configure `application.properties` as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 通过导入`micronaut-security`和`micronaut-security-jwt`依赖项，我们可以在`pet-clinic`微服务中利用令牌认证工具包。我们将使用OAuth
    2与Keycloak服务器集成。一旦导入这些依赖项，我们还需要按照以下方式配置`application.properties`：
- en: '[PRE11]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the application properties, `client-id` and `client-secret` must be copied
    from `KeyCloak`. Client secret can be copied by going to `http://localhost:8888/auth/realms/master/.well-known/openid-configuration`.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序属性中，`client-id`和`client-secret`必须从`KeyCloak`复制。客户端密钥可以通过访问`http://localhost:8888/auth/realms/master/.well-known/openid-configuration`来复制。
- en: In the next section, we will focus on how to grant secured access to the controller
    endpoints using the configured token-based authentication strategy and Keycloak
    identity server.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将重点介绍如何使用配置的基于令牌的认证策略和Keycloak身份服务器来授予控制器端点的安全访问权限。
- en: Granting secured access using the KeyCloak identity provider
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用KeyCloak身份提供者授予安全访问权限
- en: 'To grant secured access, we can use the `@Secured` annotation as well as `intercept-url-map`.
    In the hands-on example, we will grant secured access to `VetResource` using the
    `@Secured` annotation, as shown in the following code snippet:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 为了授予安全访问权限，我们可以使用 `@Secured` 注解以及 `intercept-url-map`。在动手实验中，我们将使用 `@Secured`
    注解授予 `VetResource` 的安全访问权限，如下代码片段所示：
- en: '[PRE12]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'All the endpoints within `VetResource` are granted only secured access. If
    we try to hit any `…/vets` endpoints, the microservice will return a forbidden
    response:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`VetResource` 中的所有端点都只授予安全访问权限。如果我们尝试访问任何 `…/vets` 端点，微服务将返回一个禁止响应：'
- en: '![Figure 4.12 – Unauthenticated access to vets'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.12 – 未认证访问兽医'
- en: '](img/Figure_4.12_B16585.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.12_B16585.jpg)'
- en: Figure 4.12 – Unauthenticated access to vets
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.12 – 未认证访问兽医
- en: As shown in the preceding figure, if we try to access any vet endpoint without
    specifying a valid token, the microservice will throw an `HTTP 401 Unauthorized`
    response.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，如果我们尝试访问任何兽医端点而不指定有效的令牌，微服务将抛出 `HTTP 401 未授权` 响应。
- en: 'For successful access to the vet endpoints, we will need to obtain a valid
    JWT. We can log in using the built-in login controller. To log in, simply send
    a post request to the `…/login` path with the correct username and password. If
    the request succeeds, a cookie with a JWT will be sent in the response, as shown
    in the next screenshot:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 为了成功访问兽医端点，我们需要获取一个有效的 JWT。我们可以使用内置的登录控制器进行登录。要登录，只需向 `…/login` 路径发送带有正确用户名和密码的
    POST 请求。如果请求成功，响应中将发送包含 JWT 的 cookie，如下一屏幕截图所示：
- en: '![Figure 4.13 – Obtaining a cookie for the secured access'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.13 – 获取用于安全访问的 cookie'
- en: '](img/Figure_4.13_B16585.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.13_B16585.jpg)'
- en: Figure 4.13 – Obtaining a cookie for the secured access
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.13 – 获取用于安全访问的 cookie
- en: As highlighted in the screenshot, we will send a post request to the `…/login`
    endpoint using the correct username and password. The service will grant the secured
    access using the KeyCloak identity provider and return a cookie with the JWT.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如屏幕截图所示，我们将使用正确的用户名和密码向 `…/login` 端点发送 POST 请求。服务将使用 KeyCloak 身份提供者授予安全访问权限，并返回包含
    JWT 的 cookie。
- en: 'Copy the JWT portion from the preceding response. We can pass this token to
    any requests to `VetResource`. In the following screenshot, we are invoking the
    `…/vets` endpoint using the just-obtained JWT:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 复制前一个响应中的 JWT 部分。我们可以将此令牌传递给对 `VetResource` 的任何请求。在下面的屏幕截图中，我们正在调用刚刚获取的 JWT
    的 `…/vets` 端点：
- en: '![Figure 4.14 – Using the obtained token for the secured access'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.14 – 使用获取的令牌进行安全访问'
- en: '](img/Figure_4.14_B16585.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.14_B16585.jpg)'
- en: Figure 4.14 – Using the obtained token for the secured access
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.14 – 使用获取的令牌进行安全访问
- en: Since we passed a valid token in the request headers, the service will validate
    this token and successfully return the `HTTP 200` response.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在请求头中传递了有效的令牌，服务将验证此令牌并成功返回 `HTTP 200` 响应。
- en: So far, we have explored how to secure a microservice using a JWT with an external
    identity provider. In the next section, we will focus on how to implement microservice
    security using OAuth with a cloud identity provider.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经探讨了如何使用外部身份提供者的 JWT 来保护微服务。在下一节中，我们将关注如何使用云身份提供者的 OAuth 来实现微服务安全。
- en: Using OAuth to secure service endpoints
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 OAuth 保护服务端点
- en: 'OAuth is yet another token-based authentication strategy. Its wide acceptability,
    good coverage of the depth and breadth of web security concerns, and the flexibility
    of managing user sessions at both the client and server side make it an enterprise-grade
    authentication mechanism. OAuth dictates to use the token to establish the identity
    instead of passing usernames and passwords. A token can be obtained from an external
    identity provider and this token can then be passed to any subsequent requests
    to resume a session:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth 是另一种基于令牌的认证策略。由于其广泛的接受度、对网络安全深度和广度的良好覆盖，以及客户端和服务器端管理用户会话的灵活性，使其成为企业级认证机制。OAuth
    规定使用令牌来建立身份，而不是传递用户名和密码。令牌可以从外部身份提供者获取，然后可以将此令牌传递给任何后续请求以恢复会话：
- en: '![Figure 4.15 – Separating the concerns with OAuth'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.15 – 使用 OAuth 分离关注点'
- en: '](img/Figure_4.15_B16585.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.15_B16585.jpg)'
- en: Figure 4.15 – Separating the concerns with OAuth
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.15 – 使用 OAuth 分离关注点
- en: As shown in the preceding figure, in the OAuth token-based authentication strategy,
    the client obtains a token from the identity provider and uses this token in any
    API requests to the server. The server validates this token with the identity
    provider to return a proper response.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，在基于OAuth令牌的认证策略中，客户端从身份提供者获取令牌，并在向服务器发送任何API请求时使用此令牌。服务器通过身份提供者验证此令牌以返回适当的响应。
- en: To learn how to secure a microservice using an OAuth and cloud-based identity
    provider, we will do a hands-on exercise with the `pet-clinic-review` microservice.
    To begin, we will set up a cloud identity provider using Okta.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解如何使用OAuth和基于云的身份提供者来保护微服务，我们将通过`pet-clinic-review`微服务进行实际操作练习。首先，我们将使用Okta设置一个云身份提供者。
- en: Setting up Okta as the identity provider
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置Okta作为身份提供者
- en: 'Okta is a leading SaaS identity management portal. We will use Okta as the
    identity provider. In order to begin, you must be registered with Okta. Sign up
    at [developer.okta.com](http://developer.okta.com). Once you''re signed up, Okta
    will ask the user to confirm the email. In the email, you will also receive an
    Okta domain, as highlighted in the following screenshot:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: Okta是领先的SaaS身份管理门户。我们将使用Okta作为身份提供者。为了开始，您必须在Okta上注册。在[developer.okta.com](http://developer.okta.com)上注册。注册后，Okta将要求用户确认电子邮件。在电子邮件中，您还将收到一个Okta域名，如图中所示：
- en: '![Figure 4.16 – Domain name in the Okta signup acknowledgment'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 4.16 – Okta注册确认中的域名]'
- en: '](img/Figure_4.16_B16585.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure_4.16_B16585.jpg]'
- en: Figure 4.16 – Domain name in the Okta signup acknowledgment
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 4.16 – Okta注册确认中的域名]'
- en: As shown in the figure, an Okta domain will be created for your developer account.
    You must save this as this will be used later to configure Okta as the identity
    provider.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如图中所示，将为您的开发者账户创建一个Okta域名。您必须保存此信息，因为这将用于以后配置Okta作为身份提供者。
- en: In the next section, we will see how to create an application on Okta.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将了解如何在Okta上创建应用程序。
- en: Creating an app on Okta
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在Okta上创建应用
- en: 'In order to use Okta with your microservice, you are required to create an
    app on Okta. Follow the instructions given as follows for creating an app on Okta:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用Okta与您的微服务，您需要在Okta上创建一个应用。按照以下说明创建Okta上的应用：
- en: Log on to [https://developer.okta.com/.](https://developer.okta.com/.)
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录到[https://developer.okta.com/](https://developer.okta.com/)。
- en: On the landing page, select **Creating a Web Application**.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在主页面上，选择**创建Web应用程序**。
- en: Choose **Native** as your platform and hit the **Next** button.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**原生**作为您的平台并点击**下一步**按钮。
- en: Provide the app settings mentioned in the following screenshot and once all
    the inputs are provided, hit the **Done** button:![Figure 4.17 – Creating the
    microservice app on Okta
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供以下截图中的应用程序设置，并在所有输入都提供后，点击**完成**按钮：![Figure 4.17 – 在Okta上创建微服务应用]
- en: '](img/Figure_4.17_B16585.jpg)'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![Figure 4.17_B16585.jpg]'
- en: Figure 4.17 – Creating the microservice app on Okta
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![Figure 4.17 – 在Okta上创建微服务应用]'
- en: We will keep most of the inputs as their defaults. Under **Grant type allowed**,
    check all the boxes.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将保留大部分输入的默认值。在**允许的授权类型**下，勾选所有复选框。
- en: Once the app is created successfully, edit **Client Credentials** and select
    the **Use client authentication** option for **Client authentication**.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦应用创建成功，编辑**客户端凭证**并选择**使用客户端身份验证**选项以进行**客户端身份验证**。
- en: After creating the application as previously instructed, jot down the client
    ID and client secret. This will be used later. Next, we will set up some users
    for this app.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 按照之前的说明创建应用程序后，记下客户端ID和客户端密钥。这将在以后使用。接下来，我们将为该应用程序设置一些用户。
- en: Setting up the users in the client space
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在客户端空间中设置用户
- en: 'The user setup will enable us to use these identities as test users. We will
    add three users – `Alice` (admin), `Bob` (user), and `Charlie` (user). To add
    a user, follow the given instructions:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 用户设置将使我们能够将这些身份用作测试用户。我们将添加三个用户 - `Alice`（管理员）、`Bob`（用户）和`Charlie`（用户）。要添加用户，请遵循以下说明：
- en: On the main navigation bar, hover over **Users** and select **People**.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在主导航栏上，将鼠标悬停在**用户**上，然后选择**人员**。
- en: Hit the **Add Person** button.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**添加人员**按钮。
- en: Provide inputs as shown in the following screenshot:![Figure 4.18 – Adding a
    person (user) on Okta
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供以下截图中的输入：![Figure 4.18 – 在Okta上添加人员（用户）]
- en: '](img/Figure_4.18_B16585.jpg)'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![Figure 4.18_B16585.jpg]'
- en: Figure 4.18 – Adding a person (user) on Okta
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![Figure 4.18 – 在Okta上添加人员（用户）]'
- en: In the password input, choose **Set by admin** and you must keep **User must
    change password on first login** unchecked. This will allow us to quickly use
    the identity without resetting the password.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在密码输入中，选择**由管理员设置**，并且必须保持**用户必须在首次登录时更改密码**未选中。这将允许我们快速使用身份而不重置密码。
- en: Repeat the preceding instructions for setting up `Bob` and `Charlie` as application
    users. Once the users are created, we can proceed with the `pet-clinic-reviews`
    microservice changes.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 重复前面的说明，为`Bob`和`Charlie`设置应用程序用户。一旦用户创建，我们就可以继续对`pet-clinic-reviews`微服务进行更改。
- en: In the next section, we will dive into making `pet-clinic-reviews` secure but
    let's first start with enabling SSL to make encrypted communication over HTTPS.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将深入探讨如何使`pet-clinic-reviews`安全，但首先让我们先启用SSL，以便在HTTPS上加密通信。
- en: Enabling SSL in the Micronaut framework
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Micronaut框架中启用SSL
- en: Any security safeguarding is left incomplete if a microservice is not exposed
    to HTTPS. In earlier sections, we purposely focused on authentication and authorization
    only while skipping SSL. As we will be using a third-party identity provided over
    the cloud, it's recommended and required to enable SSL in the `pet-clinic-reviews`
    microservice.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如果微服务没有暴露给HTTPS，任何安全防护措施都将是不完整的。在前面的小节中，我们故意只关注了身份验证和授权，而跳过了SSL。由于我们将使用通过云提供的第三方身份，建议并在`pet-clinic-reviews`微服务中启用SSL。
- en: 'In order to enable SSL, we will need an SSL certificate for localhost. We will
    be creating a self-signed certificate using OpenSSL. Follow these instructions
    for creating a self-signed certificate using OpenSSL:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 为了启用SSL，我们需要一个用于localhost的SSL证书。我们将使用OpenSSL创建自签名证书。按照以下说明使用OpenSSL创建自签名证书：
- en: Open a Git Bash terminal.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开Git Bash终端。
- en: Change directory to the root directory of the `pet-clinic-reviews` project.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将目录更改为`pet-clinic-reviews`项目的根目录。
- en: Run `winpty openssl req -x509 -newkey rsa:2048 -keyout key.pem -out cert.pem
    -days 365` in Git Bash. Provide the correct information to create a self-signed
    certificate. This will create a `key.pem` file and `cert.pem` file in the opened
    directory.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Git Bash中运行`winpty openssl req -x509 -newkey rsa:2048 -keyout key.pem -out
    cert.pem -days 365`。提供正确信息以创建自签名证书。这将创建一个`key.pem`文件和一个`cert.pem`文件在打开的目录中。
- en: To combine the key and certificate files, run `winpty openssl pkcs12 -inkey
    key.pem -in cert.pem -export -out cert.p12` in Git Bash.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要合并密钥和证书文件，请在Git Bash中运行`winpty openssl pkcs12 -inkey key.pem -in cert.pem -export
    -out cert.p12`。
- en: To verify that you've created the P12 file, run `winpty openssl pkcs12 -in cert.p12
    -noout -info` in Git Bash. You must provide the same password that was used to
    create the P12 file.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要验证您已创建P12文件，请在Git Bash中运行`winpty openssl pkcs12 -in cert.p12 -noout -info`。您必须提供用于创建P12文件的相同密码。
- en: 'Following the previous instructions, we can successfully create a platform-agnostic
    certificate. The P12 format has gained popularity as it can be used across platforms
    and operating systems. Next, we will add this certificate to the host operating
    system trust store so it can be trusted by all the running applications on the
    system. Follow the instructions mentioned next to add the certificate to the trust
    store:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 根据前面的说明，我们可以成功创建一个平台无关的证书。P12格式因其可以在不同平台和操作系统之间使用而变得流行。接下来，我们将添加此证书到主机操作系统的信任库，以便系统上所有运行的应用程序都可以信任它。按照以下说明将证书添加到信任库：
- en: Determine `$JAVA_HOME`. It can be found in the system variables.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确定`$JAVA_HOME`。它可以在系统变量中找到。
- en: Copy the just-created `cert.pem` file to `$JAVA_HOME/jre/lib/security/cacerts`.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将刚刚创建的`cert.pem`文件复制到`$JAVA_HOME/jre/lib/security/cacerts`。
- en: Open the Git Bash terminal with admin rights and change the directory to `$JAVA_HOME/jre/lib/security`.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以管理员权限打开Git Bash终端，并将目录更改为`$JAVA_HOME/jre/lib/security`。
- en: Run `winpty keytool -importcert -file cert.pem -alias localhost -keystore $JAVA_HOME/jre/lib/security/cacerts
    -storepass changeit` in the Git Bash terminal.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Git Bash终端中运行`winpty keytool -importcert -file cert.pem -alias localhost -keystore
    $JAVA_HOME/jre/lib/security/cacerts -storepass changeit`。
- en: By following the previous instructions, we will add the self-signed certificate
    to the trust store. This will enable the system to trust this certificate when
    it's used over SSL.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 通过遵循前面的说明，我们将把自签名证书添加到信任库中。这将使系统在通过SSL使用此证书时信任它。
- en: 'Our custom developer Okta domain may also not be trusted by the system. We
    will follow similar instructions to add the Okta certificate to the `cacerts`
    trust store:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的定制开发者Okta域也可能不被系统信任。我们将遵循类似的说明将Okta证书添加到`cacerts`信任库中：
- en: Open a new tab in the Chrome browser. Open the developer tools.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Chrome浏览器中打开一个新的标签页。打开开发者工具。
- en: Hit `https://${yourOktaDomain}/oauth2/default/.well-known/oauth-authorization-server?client_id=${yourClientId}`.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击`https://${yourOktaDomain}/oauth2/default/.well-known/oauth-authorization-server?client_id=${yourClientId}`。
- en: In the developer tools, go to the **Security** tab and click on **View certificate**.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在开发者工具中，转到**安全**选项卡并点击**查看证书**。
- en: This will open the certificate in a prompt. Go to the **Details** tab on this
    prompt.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将在提示中打开证书。转到此提示的**详细信息**选项卡。
- en: Click on **Copy file** and follow the instructions to export the certificate
    to a local directory.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**复制文件**并按照说明将证书导出到本地目录。
- en: Copy the just-exported certificate to `$JAVA_HOME/jre/lib/security/cacerts`.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将刚刚导出的证书复制到`$JAVA_HOME/jre/lib/security/cacerts`。
- en: Open the Git Bash terminal with admin rights and change the directory to `$JAVA_HOME/jre/lib/security`.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用管理员权限打开Git Bash终端，并将目录更改为`$JAVA_HOME/jre/lib/security`。
- en: Run `winpty keytool -importcert -file okta.cert -alias localhost -keystore $JAVA_HOME/jre/lib/security/cacerts
    -storepass changeit` in the Git Bash terminal. In the file option, you must provide
    the exported certificate name.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Git Bash终端中运行`winpty keytool -importcert -file okta.cert -alias localhost -keystore
    $JAVA_HOME/jre/lib/security/cacerts -storepass changeit`。在文件选项中，你必须提供导出的证书名称。
- en: Adding the developer domain Okta certificate to the system trust store will
    enable us to communicate with the Okta identity provider. In the next section,
    we will dive into enabling SSL in the `pet-clinic-reviews` microservice using
    the self-signed certificate.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 将开发域Okta证书添加到系统信任存储库将使我们能够与Okta身份提供者通信。在下一节中，我们将深入了解如何使用自签名证书在`pet-clinic-reviews`微服务中启用SSL。
- en: Configuring the application properties for SSL
  id: totrans-242
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置SSL的应用程序属性
- en: 'Once you have a legible certificate, the Micronaut framework provides a quick
    way to turn on SSL by configuring some application properties. Make the following
    changes to the application properties to enable SSL:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了可读的证书，Micronaut框架提供了一种快速的方法通过配置一些应用程序属性来启用SSL。对应用程序属性进行以下更改以启用SSL：
- en: '[PRE13]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: To enable SSL, we have used a self-signed certificate that we created in the
    previous section. The `8443` for secured communication.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 为了启用SSL，我们使用了在上一节中创建的自签名证书。用于安全通信的`8443`。
- en: In the next section, we will focus on how to configure the `pet-clinic-reviews`
    microservice with OAuth security using the Okta identity provider.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将关注如何使用Okta身份提供者配置`pet-clinic-reviews`微服务以使用OAuth安全。
- en: Securing the pet-clinic-reviews microservice using OAuth
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用OAuth保护`pet-clinic-reviews`微服务
- en: 'To secure the `pet-clinic` microservice, we will first need to enable security
    by adding the following dependencies in the `pom` project:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保护`pet-clinic`微服务，我们首先需要通过在`pom`项目中添加以下依赖项来启用安全：
- en: '[PRE14]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'By importing the `micronaut-security` and `micronaut-security-jwt` dependencies,
    we can leverage the token authentication and OAuth toolkit in the `pet-clinic-reviews`
    microservice. Once these dependencies are imported, we will then need to configure
    `application.properties` as follows:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 通过导入`micronaut-security`和`micronaut-security-jwt`依赖项，我们可以在`pet-clinic-reviews`微服务中利用令牌认证和OAuth工具包。一旦导入这些依赖项，我们还需要按照以下方式配置`application.properties`：
- en: '[PRE15]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the application properties, `client-id` and `client-secret` must be copied
    from Okta. For the issuer, you must provide your Okta domain in the first part.
    You might just need to change your developer domain but you can get more information
    on authorization and token URLs by accessing the OAuth configurations at `https://${yourOktaDomain}/oauth2/default/.well-known/oauth-authorization-server?client_id=${yourClientId}`.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序属性中，`client-id`和`client-secret`必须从Okta复制。对于发行者，你必须提供你的Okta域名在第一部分。你可能只需要更改你的开发域名，但你可以通过访问`https://${yourOktaDomain}/oauth2/default/.well-known/oauth-authorization-server?client_id=${yourClientId}`中的OAuth配置来获取有关授权和令牌URL的更多信息。
- en: In the next section, we will focus on how to grant secured access to the controller
    endpoints using the OAuth and Okta identity servers.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将关注如何使用OAuth和Okta身份服务器授予控制器端点的安全访问权限。
- en: Granting secured access using the Okta identity provider
  id: totrans-254
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Okta身份提供者授予安全访问权限
- en: 'For granting secured access, we can use the `@Secured` annotation as well as
    `intercept-url-map`. In our hands-on example, we will grant secured access to
    `VetReviewResource` using the `@Secured` annotation:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 为了授予安全访问权限，我们可以使用`@Secured`注解以及`intercept-url-map`。在我们的实际操作示例中，我们将使用`@Secured`注解来授予`VetReviewResource`的安全访问权限：
- en: '[PRE16]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'All the endpoints within `VetReviewResource` are granted only secured access.
    If we try to hit any `…/vet-reviews` endpoints, the microservice will return a
    forbidden response. In the following figure, we tried to access the `…/vet-reviews`
    endpoint unsecured and the service responded with `HTTP 401`:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '`VetReviewResource` 中的所有端点都仅授予安全访问权限。如果我们尝试访问任何 `…/vet-reviews` 端点，微服务将返回一个禁止响应。在以下图中，我们尝试未加密地访问
    `…/vet-reviews` 端点，服务响应为 `HTTP 401`：'
- en: '![Figure 4.19 – Unauthenticated access to vets'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.19 – 未认证访问兽医'
- en: '](img/Figure_4.19_B16585.jpg)'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.19_B16585.jpg)'
- en: Figure 4.19 – Unauthenticated access to vets
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.19 – 未认证访问兽医
- en: As highlighted in the previous screenshot, if we try to access any `vet-reviews`
    endpoint without specifying a valid token, the microservice will throw an `HTTP
    401 Unauthorized` response.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一个屏幕截图所示，如果我们尝试访问任何未指定有效令牌的 `vet-reviews` 端点，微服务将抛出 `HTTP 401 未授权` 响应。
- en: 'For successful access to the vet endpoints, we will need to obtain a valid
    JWT. We can obtain a valid token by accessing the Okta token API. The following
    is the `curl` command to call the Okta token API:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 为了成功访问兽医端点，我们需要获取一个有效的 JWT。我们可以通过访问 Okta 令牌 API 来获取有效令牌。以下是通过调用 Okta 令牌 API
    的 `curl` 命令：
- en: '[PRE17]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In the previous `curl` command, you must provide the correct values in `client_id`
    and `client_secret`, the `POST` URL and the user credentials. If everything is
    validated successfully, the token API will respond back with a bearer and ID token.
    Copy the returned access token. We can pass this token to any requests to `VetReviewResource`
    for secured communication:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的 `curl` 命令中，你必须提供正确的 `client_id` 和 `client_secret`、`POST` URL 和用户凭据。如果一切验证成功，令牌
    API 将返回一个载体令牌和 ID 令牌。复制返回的访问令牌。我们可以将此令牌传递给对 `VetReviewResource` 的任何请求，以实现安全通信：
- en: '![Figure 4.20 – Using the obtained token for secured access'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.20 – 使用获取的令牌进行安全访问'
- en: '](img/Figure_4.20_B16585.jpg)'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.20_B16585.jpg)'
- en: Figure 4.20 – Using the obtained token for secured access
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.20 – 使用获取的令牌进行安全访问
- en: Since we passed a valid token in the request headers, the service will validate
    this token and successfully return the `HTTP 200` response.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在请求头中传递了一个有效令牌，该服务将验证此令牌并成功返回 `HTTP 200` 响应。
- en: In this section, we learned about and experimented with OAuth security. To make
    `pet-clinic-reviews` service endpoints secure, we used OAuth with Okta as a third-party
    identity provider.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了 OAuth 安全性，并进行了实验。为了使 `pet-clinic-reviews` 服务端点安全，我们使用了 OAuth 和 Okta
    作为第三方身份提供者。
- en: Summary
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored various ways to secure microservices in the Micronaut
    framework. We began our journey by diving into a session authentication strategy,
    and then we explored token-based authentication using an external Keycloak identity
    server. Lastly, we worked on securing a microservice using OAuth with a cloud-based
    identity provider. Furthermore, we also worked on enabling SSL to make service
    communication secure over HTTPS.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了在 Micronaut 框架中保护微服务的各种方法。我们的旅程从深入研究会话身份验证策略开始，然后探讨了使用外部 Keycloak
    身份服务器进行的基于令牌的身份验证。最后，我们使用基于云的身份提供者 OAuth 来保护微服务。此外，我们还启用了 SSL，以确保通过 HTTPS 进行服务通信的安全。
- en: This chapter provided you with a handy, focused skillset in safeguarding a microservice
    in the Micronaut framework using various authentication strategies, along with
    how to work with local or external (cloud) identity providers.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 本章为你提供了一套实用的技能集，用于在 Micronaut 框架中使用各种身份验证策略来保护微服务，以及如何与本地或外部（云）身份提供者协同工作。
- en: In the next chapter, we will explore how we can integrate different microservices
    using event-driven architecture.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨如何使用事件驱动架构集成不同的微服务。
- en: Questions
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What are the various authentication strategies in the Micronaut framework?
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Micronaut 框架中有哪些不同的身份验证策略？
- en: What is a security filter in Micronaut?
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Micronaut 中的安全过滤器是什么？
- en: How do you set up session-based authentication in the Micronaut framework?
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何在 Micronaut 框架中设置基于会话的身份验证？
- en: What is the `@Secured` annotation in the Micronaut framework?
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Micronaut 框架中的 `@Secured` 注解是什么？
- en: What is `intercept-url-maps` in the Micronaut framework?
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Micronaut 框架中的 `intercept-url-maps` 是什么？
- en: How do you set up token-based authentication in the Micronaut framework?
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何在 Micronaut 框架中设置基于令牌的身份验证？
- en: How do you set up JWT authentication in the Micronaut framework?
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何在 Micronaut 框架中设置 JWT 身份验证？
- en: How do you integrate with Keycloak in the Micronaut framework?
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何在 Micronaut 框架中与 Keycloak 集成？
- en: How do you set up OAuth authentication in the Micronaut framework?
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何在 Micronaut 框架中设置 OAuth 认证？
- en: How do you integrate with Okta in the Micronaut framework?
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何在 Micronaut 框架中与 Okta 集成？
- en: How do you enable SSL in the Micronaut framework?
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何在 Micronaut 框架中启用 SSL？
