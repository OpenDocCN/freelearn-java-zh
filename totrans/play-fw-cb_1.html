<html><head></head><body><h1 id="e-VohW">Chapter 1. Basics of Play Framework</h1>
<p id="e-jBig">In this chapter, we will cover the following recipes:</p>
<ul id="e-Xq0t">
<li id="e-X3Vv">Installing Play Framework</li>
<li id="e-Yjwa">Creating a Play application using Typesafe Activator</li>
<li id="e-Og0B">Using the Play console</li>
<li id="e-WuJt">Working with modules</li>
<li id="e-LiNx">Working with controllers and routes</li>
<li id="e-LDmr">Using Action parameters in controllers</li>
<li id="e-VqHw">Using reverse routing and redirects</li>
<li id="e-ET3B">Working with View templates</li>
<li id="e-sZfj">Using helper tags</li>
<li id="e-BZe7">Using View layouts and Includes</li>
<li id="e-kvDu">Working with XML and text files</li>
<li id="e-AqwM">Using Ebean (Java) with MySQL</li>
<li id="e-N2Au">Using Anorm (Scala) and database evolutions with MYSQL</li>
<li id="e-ftR3">Using a form template and web actions</li>
<li id="e-Uf3w">Using a form validation</li>
<li id="e-sYZ8">Securing form submission</li>
<li id="e-rwp3">Testing with JUnit (Java) and specs2 (Scala)</li>
<li id="e-BjW8">Testing models</li>
<li id="e-J8BN">Testing controllers</li>
</ul>
<h1 id="e-DJ2i">Introduction</h1>
<p id="e-Q4ar">Play is a developer-friendly and modern web application framework for both Java and Scala. This first chapter will take you through the steps in installing Play Framework for local development. This chapter will describe the Play application project directory structure, its various members and its function in a Play application.</p>
<p id="e-Vdqp">This chapter will also introduce you to the <code>Activator</code> command, which replaces the old Play command. Activator is used for various stages during development, including compilation, downloading library dependencies, testing, and building. It is really quite similar to other build tools such as Ant or Maven.</p>
<p id="e-VXW4">This first chapter will also go about implementing <strong>Model-View-Controller</strong> (<strong>MVC</strong>) components available in Play Framework. This will be followed by source code to create controllers and routing actions using View templates and model components used to interface with an RDBMS (such as MySQL). This chapter will tackle basic HTTP forms, recognizing the importance of modern web applications being able to deal with user interactivity and data and how Play Framework provides various APIs to make life easier for developers.</p>
<p id="e-dLVc">By the end of the chapter, you should have a good grasp of how to implement basic web application functionalities such as form submissions and data access with MySQL, create URL routes to web actions, and create views composed of smaller, modular, and reusable view components.</p>
<p id="e-JAnX">Most of the recipes in this chapter assume that you have a level of familiarity with Java development, web application development, command-line interfaces, <strong>Structured Query Language</strong> (<strong>SQL</strong>), development build tools, third-party library usage, dependency management, and unit testing.</p>

<h1 id="e-NSq9">Installing Play Framework</h1>
<p id="e-Q8KW">This recipe will guide you through installing Play Framework 2.3 for local development. This section will guide you on the prerequisite installations for Play Framework, such as the <strong>Java Development Kit</strong> (<strong>JDK</strong>), and the necessary steps to ensure that Play Framework has access to the JDK's binaries.</p>
<h2 id="e-xcyt">Getting ready</h2>
<p id="e-HI6u">Play Framework requires a JDK version of 6 or above. Head over to the Oracle website and download the appropriate JDK for your development machine at <a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html">http://www.oracle.com/technetwork/java/javase/downloads/index.html</a>.</p>
<p id="e-BqiL">Once you have downloaded a suitable JDK, ensure that the binary folder is added to the system path:</p>
<pre id="e-iBc3">&lt;span class="strong"&gt;&lt;strong&gt;    $ export JAVA_PATH=/YOUR/INSTALLATION/PATH&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    $ export PATH=$PATH:$JAVA_HOME/bin&lt;/strong&gt;&lt;/span&gt;</pre>
<p id="e-AZXy">You can also refer to Oracle's online documentation for more information regarding setting environment variables at <a href="http://docs.oracle.com/cd/E19182-01/820-7851/inst_cli_jdk_javahome_t/index.html">http://docs.oracle.com/cd/E19182-01/820-7851/inst_cli_jdk_javahome_t/index.html</a>.</p>
<p id="e-sXcB">Here's how you can verify that the JDK is now accessible in the system path:</p>
<pre id="e-tXM8">&lt;span class="strong"&gt;&lt;strong&gt;    $ javac -version&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    javac 1.7.0_71&lt;/strong&gt;&lt;/span&gt;
 &lt;span class="strong"&gt;&lt;strong&gt;    $ java -version&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    java version "1.7.0_71"&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    Java(TM) SE Runtime Environment (build 1.7.0_71-b14)&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    Java HotSpot(TM) 64-Bit Server VM (build 24.71-b01, mixed mode)&lt;/strong&gt;&lt;/span&gt;</pre>
<h2 id="e-FMcu">How to do it...</h2>
<p id="e-nxuD">As of Play 2.3.x, Play is now distributed using a tool called Typesafe Activator (<a href="http://typesafe.com/activator">http://typesafe.com/activator</a>), install it using following steps:</p>
<ol id="e-y5yl">
<li id="e-biWL">Download the <em>Typesafe Reactive Platform</em> distribution at <a href="https://typesafe.com/platform/getstarted">https://typesafe.com/platform/getstarted</a> and unzip it at your desired location that has write access.</li>
<li id="e-Swky">After downloading and unzipping the distribution, add the <code>Activator</code> installation directory to your system path:<pre id="e-BfPd">&lt;span class="strong"&gt;&lt;strong&gt;    $ export ACTIVATOR_HOME=&amp;lt;/YOUR/INSTALLATION/PATH&amp;gt;&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    $ export PATH=$PATH:$ACTIVATOR_HOME&lt;/strong&gt;&lt;/span&gt;</pre>
</li>
<li id="e-hsZ5">Now, verify that Activator is now accessible in the system path:<pre id="e-G7Qe">&lt;span class="strong"&gt;&lt;strong&gt;    $ activator --version&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    sbt launcher version 0.13.5&lt;/strong&gt;&lt;/span&gt;</pre>
</li>
<li id="e-njaZ">You should now be able to create a Play application using the <code>activator</code> command:<pre id="e-GuSK">&lt;span class="strong"&gt;&lt;strong&gt;    $ activator new &amp;lt;YOUR_APP_NAME&amp;gt;&lt;/strong&gt;&lt;/span&gt;</pre>
</li>
</ol>

<h1 id="e-v7pX">Creating a Play application using Typesafe Activator</h1>
<p id="e-fo7A">Once you have a JDK and Activator installed and properly configured, you should be ready to create Play 2.3.x applications. Beginning with Play 2.0, developers are now able to create Java- or Scala-based Play applications. Activator provides many Play project templates for both Java and Scala. For the first project, let us use the basic project templates. We will also be using the command-line interface of Activator across all recipes in this cookbook.</p>
<h2 id="e-W1qS">How to do it...</h2>
<p id="e-OpR9">You need to perform the following for creating the templates for both Java and Scala:</p>
<ul id="e-VTf3">
<li id="e-WuqT">For Java, let's use the <code>play-java</code> template and call our first application <code>foo_java</code> by using the following command:<pre id="e-z8YK">&lt;span class="strong"&gt;&lt;strong&gt;    $ activator new foo_java play-java&lt;/strong&gt;&lt;/span&gt;</pre>
</li>
<li id="e-XZ8u">For Scala, let's use the <code>play-scala</code> template and call our first application <code>foo_scala</code> by using the following command:<pre id="e-CtvE">&lt;span class="strong"&gt;&lt;strong&gt;    $ activator new foo_scala play-scala&lt;/strong&gt;&lt;/span&gt;</pre>
</li>
</ul>
<h2 id="e-dVNy">How it works…</h2>
<p id="e-LpxF">This <code>Activator</code> command creates the project's root directory (<code>foo_java</code> or <code>foo_scala</code>) and creates all the relevant subdirectories, config files, and class files:</p>
<p id="e-CEbe">The following screenshot shows the root directory for <code>foo_java</code>:</p>
<img data-width="700" data-height="485" src="qUbtEvvV.jpg"/><p id="e-IZvd">The following screenshot shows the root directory for <code>foo_scala</code>:</p>
<img data-width="700" data-height="485" src="Tbg8FVM3.jpg"/><p id="e-hEJK">As you notice, both the Java and Scala project template generated an almost identical list of files, except for class files that are generated as <code>.java</code> files for the <em>play_java</em> template and as<code>.scala</code> files for the <em>play_scala</em> template.</p>
<p id="e-HtdG">For the project's directory structure, one of the more important aspects of Play Framework is its adherence to the concept of convention over configuration. This is best reflected by the standard project directory structure of every Play application it follows:</p>
<p id="e-QcmS">1st Level</p>
<p id="e-fU5s">2nd Level</p>
<p id="e-vu0f">3rd Level</p>
<p id="e-oTpN">Description</p>
<p id="e-klhr"><code>app/</code></p>
<p id="e-eeNw"> </p>
<p id="e-OGjI"> </p>
<p id="e-Br0Z">Application source files</p>
<p id="e-IkqS"> </p>
<p id="e-R8VT"><code>assets</code>/</p>
<p id="e-WJds"> </p>
<p id="e-aq5m">Compiled JavaScript or style sheets</p>
<p id="e-Cups"> </p>
<p id="e-qaQO"> </p>
<p id="e-YKGE"><code>stylesheets</code>/</p>
<p id="e-Rjat">Compiled style sheet (such as LESS or SASS)</p>
<p id="e-Gof6"> </p>
<p id="e-Vrek"> </p>
<p id="e-vlSu"><code>javascripts</code>/</p>
<p id="e-n9TD">Compiled JavaScript (such as CoffeeScript)</p>
<p id="e-kYsI"> </p>
<p id="e-oY1u"><code>controllers</code>/</p>
<p id="e-m1Ze"> </p>
<p id="e-B0el">Application request-response controllers</p>
<p id="e-yMLn"> </p>
<p id="e-jNto"><code>models</code>/</p>
<p id="e-hUuW"> </p>
<p id="e-SjvJ">Application domain objects</p>
<p id="e-f2pB"> </p>
<p id="e-xfnI"><code>views</code>/</p>
<p id="e-qosq"> </p>
<p id="e-W0mW">Application presentation views</p>
<p id="e-btXb"><code>conf/</code></p>
<p id="e-pEYb"> </p>
<p id="e-wmeV"> </p>
<p id="e-UIBF">Application configuration files</p>
<p id="e-DTOe"><code>public</code>/</p>
<p id="e-SP0l"> </p>
<p id="e-kGcV"> </p>
<p id="e-bRPb">Publicly available assets</p>
<p id="e-Wi4t"> </p>
<p id="e-d5yX"><code>stylesheets</code>/</p>
<p id="e-My1y"> </p>
<p id="e-PsHJ">Publicly available style sheet files</p>
<p id="e-H3bJ"> </p>
<p id="e-BHV5"><code>javascripts</code>/</p>
<p id="e-YFwY"> </p>
<p id="e-hPSA">Publicly available JavaScript files</p>
<p id="e-Met3"><code>project</code>/</p>
<p id="e-fNVl"> </p>
<p id="e-ZNa2"> </p>
<p id="e-KofF">Build configuration files (such as <code>Build.scala</code> and <code>plugins.sbt)</code></p>
<p id="e-Y44m"><code>lib</code>/</p>
<p id="e-CJKG"> </p>
<p id="e-ETLt"> </p>
<p id="e-vxw4">Unmanaged libraries and packages</p>
<p id="e-fhcA"><code>logs</code>/</p>
<p id="e-GMcb"> </p>
<p id="e-FRNk"> </p>
<p id="e-jNdu">Log files</p>
<p id="e-u2if"><code>test</code>/</p>
<p id="e-Kufr"> </p>
<p id="e-buWO"> </p>
<p id="e-L7mf">Test source files</p>
<p id="e-SkfP">Source code, configuration files, and web assets are organized in a predefined directory structure, making it easy for the developer to navigate through the project directory tree and find relevant files in logical placements.</p>
<h2 id="e-QA0e">There's more...</h2>
<p id="e-RGq7">Go to <a href="http://typesafe.com/activator/templates">http://typesafe.com/activator/templates</a> for a comprehensive list of available project templates.</p>

<h1 id="e-XGIt">Using the Play console</h1>
<p id="e-aSPo">The Play console is a command-line interface tool used to build and run Play applications. It is important for every developer to be familiar with the available commands, such as <code>clean</code>, <code>compile</code>, <code>dependencies</code>, and <code>run</code>, to fully utilize the power of the Play console.</p>
<h2 id="e-yeDa">How to do it…</h2>
<p id="e-iwgy">You need to perform the following to use the Play console for both Java and Scala:</p>
<ol id="e-AKWS">
<li id="e-J9eE">After Activator finishes setting up the Play project, you can enter the Play console of your Play application.<ul id="e-Zf93">
<li id="e-cTvK">Use the following command for Java:<pre id="e-P7qz">&lt;span class="strong"&gt;&lt;strong&gt;    $ cd foo_java&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    $ activator&lt;/strong&gt;&lt;/span&gt;</pre>
</li>
<li id="e-vUgJ">Use the following command for Scala:<pre id="e-XKlA">&lt;span class="strong"&gt;&lt;strong&gt;    $ cd foo_scala&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    $ activator&lt;/strong&gt;&lt;/span&gt;</pre>
</li>
</ul>
</li>
<li id="e-uPt8">Once you have entered the Play console, you can run your application in the development mode:<ul id="e-YA59">
<li id="e-wB3d">Use the following command for Java:<pre id="e-Ubay">&lt;span class="strong"&gt;&lt;strong&gt;    [foo_java] $ run&lt;/strong&gt;&lt;/span&gt;</pre>
</li>
<li id="e-SVY0">Use the following command for Scala:<pre id="e-TC2V">&lt;span class="strong"&gt;&lt;strong&gt;    [foo_scala] $ run&lt;/strong&gt;&lt;/span&gt;</pre>
</li>
</ul>
</li>
<li id="e-BRVx">Now, open a web browser and head over to <code>http://localhost:9000</code>:<img data-width="800" data-height="642" src="OgbeLjyc.jpg"/>
</li>
<li id="e-Czar">Use the following command line to start your Play application with Hot-Reloading enabled:<pre id="e-hSVW">&lt;span class="strong"&gt;&lt;strong&gt;    $ activator "~run"&lt;/strong&gt;&lt;/span&gt;</pre>
</li>
<li id="e-MtO2">Use the following command line to start your Play application on a different port:<pre id="e-EU6e">&lt;span class="strong"&gt;&lt;strong&gt;    $ activator "run 9001"&lt;/strong&gt;&lt;/span&gt;</pre>
</li>
</ol>
<h3 id="e-nEbm">Note</h3>
<p id="e-aUTp">Running your application in development mode configures your application to run in auto-reload, where Play will attempt to recompile any recent changes to the project files, removing the need to manually restart your application for every code edit. You are now ready to view your application using your web browser.</p>
<h2 id="e-bti5">There's more…</h2>
<p id="e-uS5C">You can also use the Play console to manually compile class files using the <code>compile</code> command in the activator console (use the <code>activator</code> command):</p>
<ul id="e-CDvc">
<li id="e-jqqq">Use the following command for Java:<pre id="e-BxP3">&lt;span class="strong"&gt;&lt;strong&gt;    [foo_java] $ compile&lt;/strong&gt;&lt;/span&gt;</pre>
</li>
<li id="e-kRxc">Use the following command for Scala:<pre id="e-rzNT">&lt;span class="strong"&gt;&lt;strong&gt;    [foo_scala] $ compile&lt;/strong&gt;&lt;/span&gt;</pre>
</li>
</ul>
<p id="e-hF1r">You can also run Play commands directly instead of using the Play console:</p>
<ul id="e-qa9C">
<li id="e-yZb5">Use the following command for Java:<pre id="e-XxJW">&lt;span class="strong"&gt;&lt;strong&gt;    $ cd foo_java&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    $ activator compile&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    $ activator run&lt;/strong&gt;&lt;/span&gt;</pre>
</li>
<li id="e-HiBX">Use the following command for Scala:<pre id="e-KdpZ">&lt;span class="strong"&gt;&lt;strong&gt;    $ cd foo_scala&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    $ activator compile&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    $ activator run&lt;/strong&gt;&lt;/span&gt;</pre>
</li>
</ul>
<p id="e-Ed8m">Use the following command to generate an eclipse project file for your existing Play application using <code>Activator</code>:</p>
<pre id="e-uqQE">&lt;span class="strong"&gt;&lt;strong&gt;    $ activator eclipse&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    [info] Loading project definition from /private/tmp/foo_scala/project&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    [info] Set current project to foo_scala (in build file:/private/tmp/foo_scala/)&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    [info] About to create Eclipse project files for your project(s).&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    [info] Compiling 5 Scala sources and 1 Java source to /private/tmp/foo_scala/target/scala-2.11/classes...&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    [info] Successfully created Eclipse project files for project(s):&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    [info] foo_scala&lt;/strong&gt;&lt;/span&gt;</pre>
<p id="e-dcDC">Use the following command to generate an IntelliJ IDEA project file for your existing Play application using <code>Activator</code>:</p>
<pre id="e-Nap9">&lt;span class="strong"&gt;&lt;strong&gt;    $ activator idea&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    [info] Loading project definition from /private/tmp/foo_java/project&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    [info] Set current project to foo_java (in build file:/private/tmp/foo_java/)&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    [info] Creating IDEA module for project 'foo_java' ...&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    [info] Running compile:managedSources ...&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    [info] Running test:managedSources ...&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    [info] Excluding folder target&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    [info] Created /private/tmp/foo_java/.idea/IdeaProject.iml&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    [info] Created /private/tmp/foo_java/.idea&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    [info] Excluding folder /private/tmp/foo_java/target/scala-2.11/cache&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    [info] Excluding folder /private/tmp/foo_java/target/scala-2.11/classes&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    [info] Excluding folder /private/tmp/foo_java/target/scala-2.11/classes_managed&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    [info] Excluding folder /private/tmp/foo_java/target/native_libraries&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    [info] Excluding folder /private/tmp/foo_java/target/resolution-cache&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    [info] Excluding folder /private/tmp/foo_java/target/streams&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    [info] Excluding folder /private/tmp/foo_java/target/web&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    [info] Created /private/tmp/foo_java/.idea_modules/foo_java.iml&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    [info] Created /private/tmp/foo_java/.idea_modules/foo_java-build.iml&lt;/strong&gt;&lt;/span&gt;</pre>

<h1 id="e-I0BR">Working with modules</h1>
<p id="e-IISg">You can utilize other Play Framework or third-party modules in your Play application. This is easily done by editing the build file (<code>build.sbt</code>) and declaring library dependencies in the style of <code>sbt</code> dependency declaration.</p>
<h2 id="e-RiH3">How to do it…</h2>
<p id="e-EzHh">You need to perform the following steps to declare a module:</p>
<ol id="e-jq4b">
<li id="e-bqFu">Open the <code>build.sbt</code> file and add the following lines, using the notation of the group ID <code>%</code> module name <code>%</code> version while declaring library dependencies:<pre id="e-JwZL">libraryDependencies ++= Seq(
      jdbc,
      "mysql" % "mysql-connector-java" % "5.1.28"
    )</pre>
</li>
<li id="e-GJdc">Once the changes to <code>build.sbt</code> have been saved, head over to the command line and have Activator download the newly declared dependencies:<pre id="e-naXD">&lt;span class="strong"&gt;&lt;strong&gt;    $ activator clean dependencies&lt;/strong&gt;&lt;/span&gt;</pre>
</li>
</ol>
<h2 id="e-xtX2">How it works…</h2>
<p id="e-glld">In this recipe, we declare what our Play application will need and reference the <strong>Java Database Connectivity</strong> (<strong>JDBC</strong>) module provided by Play Framework and the MySQL Java Connector module provided by MySQL. Once we have our modules declared, we can run the activator dependencies command to make Activator download all declared dependencies from the public Maven repositories and store them in the local development machine.</p>
<h2 id="e-Qngh">There's more...</h2>
<p id="e-BfSb">Please refer to the Play Framework website for a complete list of official Play modules (<a href="https://www.playframework.com/documentation/2.3.x/Modules">https://www.playframework.com/documentation/2.3.x/Modules</a>). You can also refer to the Typesafe official release repository for other useful plugins and modules at your disposal (<a href="http://repo.typesafe.com/typesafe/releases/">http://repo.typesafe.com/typesafe/releases/</a>).</p>

<h1 id="e-apOz">Working with controllers and routes</h1>
<p id="e-Liu2">Play applications use controllers to handle HTTP requests and responses. Play controllers are composed of actions that have specific functionality. Play applications use a router to map HTTP requests to controller actions.</p>
<h2 id="e-cWGT">How to do it...</h2>
<p id="e-xTBE">To create a new page, which prints out "Hello World" for a Play Java project, we need to take the following steps:</p>
<ol id="e-ujXP">
<li id="e-AO1v">Run the <code>foo_java</code> application with Hot-Reloading enabled:<pre id="e-opfJ">&lt;span class="strong"&gt;&lt;strong&gt;    $ activator "~run"&lt;/strong&gt;&lt;/span&gt;</pre>
</li>
<li id="e-kn5W">Edit <code>foo_java/app/controllers/Application.java</code> by adding the following action:<pre id="e-CP5j">public static Result hello() {
      return ok("Hello World");
    }</pre>
</li>
<li id="e-TAIH">Edit <code>foo_java/conf/routes</code> by adding the following line:<pre id="e-UD4O">GET    /hello    controllers.Application.hello()</pre>
</li>
<li id="e-iFhW">View your new hello page using a web browser:<pre id="e-e25d">&lt;code class="literal"&gt;http://localhost:9000/hello&lt;/code&gt;</pre>
</li>
</ol>
<p id="e-p3Z3">For Scala, we need to take the following steps:</p>
<ol id="e-oQor">
<li id="e-CdHM">Run the <code>foo_scala</code> application with Hot-Reloading enabled:<pre id="e-ghsI">&lt;span class="strong"&gt;&lt;strong&gt;    $ activator "~run"&lt;/strong&gt;&lt;/span&gt;</pre>
</li>
<li id="e-aDUf">Edit <code>foo_scala/app/controllers/Application.scala</code> by adding the following action:<pre id="e-SKKx">def hello = Action {
      Ok("Hello World")
    }</pre>
</li>
<li id="e-oXJp">Edit <code>foo_scala/conf/routes</code> by adding the following line:<pre id="e-CDdn">GET    /hello    controllers.Application.hello</pre>
</li>
<li id="e-bU6I">View your new hello page using a web browser:<pre id="e-lsrP">&lt;code class="literal"&gt;http://localhost:9000/hello&lt;/code&gt;</pre>
</li>
</ol>
<h2 id="e-qP67">How it works…</h2>
<p id="e-jo89">In this recipe, we enumerated the steps necessary to create a new accessible page by creating a new web action in a controller and defined this new page's URL route by adding a new entry to the <code>conf/routes</code> file. We should now have a "Hello World" page, and all without having to reload the application server.</p>

<h1 id="e-Dfjf">Using Action parameters in controllers</h1>
<p id="e-fMPb">Web applications should be able to accept dynamic data as part of their canonical URL. An example of this is <code>GET</code> operations of RESTful API web services. Play makes it easy for developers to implement this.</p>
<h2 id="e-lnQL">How to do it…</h2>
<p id="e-HT47">For Java, we need to take the following steps:</p>
<ol id="e-Jqb9">
<li id="e-tenp">Run the <code>foo_java</code> application with Hot-Reloading enabled.</li>
<li id="e-VbFq">Edit <code>foo_java/app/controllers/Application.java</code> by adding the following action:<pre id="e-tolb">public static Result echo(String msg) {
      return ok("Echoing " + msg);
    }</pre>
</li>
<li id="e-KUSm">Edit <code>foo_java/conf/routes</code> by adding the following line:<pre id="e-GcyT">GET    /echo/:msg    controllers.Application.echo(msg)</pre>
</li>
<li id="e-MSDK">View your new echo page using a web browser:<pre id="e-tEca">&lt;code class="literal"&gt;http://localhost:9000/echo/foo&lt;/code&gt;</pre>
</li>
<li id="e-eAsY">You should be able to see the text <strong>Echoing foo</strong>.</li>
</ol>
<p id="e-Bfhg">For Scala, we need to take the following steps:</p>
<ol id="e-wiJ8">
<li id="e-GPQO">Run the <code>foo_scala</code> application with Hot-Reloading enabled.</li>
<li id="e-uHqE">Edit <code>foo_scala/app/controllers/Application.scala</code> by adding the following action:<pre id="e-YTCw">def echo(msg: String) = Action {
      Ok("Echoing " + msg)
    }</pre>
</li>
<li id="e-XagX">Edit <code>foo_scala/conf/routes</code> by adding the following line:<pre id="e-OXEF">GET    /echo/:msg    controllers.Application.echo(msg)</pre>
</li>
<li id="e-ZJKx">View your new echo page using a web browser:<pre id="e-OYHu">&lt;code class="literal"&gt;http://localhost:9000/echo/bar&lt;/code&gt;</pre>
</li>
<li id="e-HepD">You should be able to see the text <strong>Echoing bar</strong>.</li>
</ol>
<h2 id="e-IESq">How it works...</h2>
<p id="e-zEpe">In this recipe, we made edits to just two files, the application controller, <code>Application.java</code> and <code>Application.scala</code>, and <code>routes</code>. We added a new web action, which takes in a String argument <code>msg</code> in <code>Application.scala</code> and returns the contents of the message to the HTTP response. We then add a new entry in the <code>routes</code> file that declares a new URL route and declares the <code>:msg</code> route parameter as part of the canonical URL.</p>

<h1 id="e-wkel">Using reverse routing and redirects</h1>
<p id="e-VkAc">One of the more essential tasks for a web application is to be able to redirect HTTP requests, and redirecting HTTP with Play Framework is quite straightforward. This recipe shows how developers can use reverse routing to refer to defined routes.</p>
<h2 id="e-badR">How to do it…</h2>
<p id="e-F941">For Java, we need to take the following steps:</p>
<ol id="e-W0Tu">
<li id="e-iCvb">Run the <code>foo_java</code> application with Hot-Reloading enabled.</li>
<li id="e-Km4R">Edit <code>foo_java/app/controllers/Application.java</code> by adding the following action:<pre id="e-wSBi">public static Result helloRedirect() {
      return redirect(controllers.routes.Application.echo("HelloWorldv2"));
    }</pre>
</li>
<li id="e-fDPq">Edit <code>foo_java/conf/routes</code> by adding the following line:<pre id="e-qazE">GET    /v2/hello    controllers.Application.helloRedirect()</pre>
</li>
<li id="e-U6nW">View your new echo page using a web browser:<pre id="e-eXaL">&lt;code class="literal"&gt;http://localhost:9000/v2/hello&lt;/code&gt;</pre>
</li>
<li id="e-HStJ">You should be able to see the text <strong>Echoing HelloWorldv2</strong>.</li>
<li id="e-LUxI">Notice that the URL in the web browser has also redirected to <code>http://localhost:9000/echo/HelloWorldv2</code>
</li>
</ol>
<p id="e-lKsi">For Scala, we need to take the following steps:</p>
<ol id="e-mfLv">
<li id="e-mcmw">Run the <code>foo_scala</code> application with Hot-Reloading enabled.</li>
<li id="e-eScZ">Edit <code>foo_scala/app/controllers/Application.scala</code> by adding the following action:<pre id="e-Qnra">def helloRedirect() = Action {
      Redirect(routes.Application.echo("HelloWorldv2"))
    }</pre>
</li>
<li id="e-xqAV">Edit <code>foo_scala/conf/routes</code> by adding the following line:<pre id="e-WFhK">GET    /v2/hello    controllers.Application.helloRedirect</pre>
</li>
<li id="e-U5yr">View your new echo page using a web browser:<pre id="e-SCvg">&lt;code class="literal"&gt;http://localhost:9000/v2/hello&lt;/code&gt;</pre>
</li>
<li id="e-z3FA">You should be able to see the text <strong>Echoing HelloWorldv2</strong>.</li>
<li id="e-nw1e">Notice that the URL in the web browser has also redirected to <code>http://localhost:9000/echo/HelloWorldv2</code>
</li>
</ol>
<h2 id="e-OYHc">How it works...</h2>
<p id="e-JpCf">In this recipe, we utilized reverse routes while referring to existing routes inside other action methods. This is handy, as we will not need to hard code rendered URL routes from within other action methods. We also utilized our first HTTP redirect, a very common web application function, by which we were able to issue a 302 HTTP redirect, a standard HTTP status code handled by all standard web servers.</p>

<h1 id="e-lOmg">Working with View templates</h1>
<p id="e-mG9R">You expect to be able to send some data back to the View itself in web applications; this is quite straightforward with Play Framework. A Play View template is simply a text file that contains directives, web markup tags, and template tags. The <code>View Template</code> files also follow standard naming conventions and they are placed in predefined directories within the Play project directory, which makes it easier to manage template files.</p>
<h2 id="e-QKEU">How to do it...</h2>
<p id="e-OEjA">For Java, we need to take the following steps:</p>
<ol id="e-Mq8e">
<li id="e-ezRt">Run the <code>foo_java</code> application with Hot-Reloading enabled.</li>
<li id="e-B8fH">Create the view file <code>products.scala.html</code> in <code>foo_java/app/views/</code>. Add the contents of the view file:<pre id="e-AbX0">@(products: Collection[String])
     &amp;lt;h3&amp;gt;@products.mkString(",")&amp;lt;/h3&amp;gt;</pre>
</li>
<li id="e-ixiw">Edit <code>foo_java/app/controllers/Application.java</code> by adding the following action:<pre id="e-k5wB">private static final java.util.Map&amp;lt;Integer, String&amp;gt; productMap = new java.util.HashMap&amp;lt;Integer, String&amp;gt;();
     static {
      productMap.put(1, "Keyboard");
      productMap.put(2, "Mouse");
      productMap.put(3, "Monitor");
    }
     public static Result listProducts() {
      return ok(products.render(productMap.values()));
    }</pre>
</li>
<li id="e-hTeb">Edit <code>foo_java/conf/routes</code> by adding the following line:<pre id="e-PY8a">GET    /products    controllers.Application.listProducts</pre>
</li>
<li id="e-OIKF">View the products page using a web browser:<pre id="e-KzKM">&lt;code class="literal"&gt;http://localhost:9000/products&lt;/code&gt;</pre>
</li>
</ol>
<p id="e-noxa">For Scala, we need to take the following steps:</p>
<ol id="e-C9C7">
<li id="e-rLmI">Run the <code>foo_scala</code> application with Hot-Reloading enabled.</li>
<li id="e-e2TH">Create the view file <code>products.scala.html</code> in <code>foo_scala/app/views/</code>. Add the contents of the view file:<pre id="e-cY3f">@(products: Seq[String])
     &amp;lt;h3&amp;gt;@products.mkString(",")&amp;lt;/h3&amp;gt;</pre>
</li>
<li id="e-G8pK">Edit <code>foo_scala/app/controllers/Application.scala</code> by adding the following action:<pre id="e-Wi5b">private val productMap = Map(1 -&amp;gt; "Keyboard", 2 -&amp;gt; "Mouse", 3 -&amp;gt; "Monitor")
    def listProducts() = Action {
      Ok(views.html.products(productMap.values.toSeq))
    }</pre>
</li>
<li id="e-yPWY">Edit <code>foo_scala/conf/routes</code> by adding the following line:<pre id="e-gOEe">GET    /products    controllers.Application.listProducts</pre>
</li>
<li id="e-ERlZ">View the products page using a web browser:<pre id="e-obH5">&lt;code class="literal"&gt;http://localhost:9000/products&lt;/code&gt;</pre>
</li>
</ol>
<h2 id="e-orOK">How it works...</h2>
<p id="e-ms6j">In this recipe, we were able to retrieve a collection of data from the server side and display the contents of the collection in our View template. For now, we use a static collection of String objects to display in the View template instead of retrieving some data set from a database, which we will tackle in the upcoming recipes.</p>
<p id="e-UNoG">We introduced declaring parameters in View templates by declaring them in the first line of code in our view template and passing data into our View templates from the controller.</p>

<h1 id="e-NxJh">Using helper tags</h1>
<p id="e-XLWv">View tags allow developers to create reusable view functions and components and make the management of views a lot simpler and easier.</p>
<h2 id="e-HyQw">How to do it...</h2>
<p id="e-WqiZ">For Java, we need to take the following steps:</p>
<ol id="e-HAWS">
<li id="e-QmBf">Run the <code>foo_java</code> application with Hot-Reloading enabled.</li>
<li id="e-rA5M">Create the tag file <code>productsIterator.scala.html</code> in <code>foo_java/app/views/tags</code>
</li>
<li id="e-c50c">Add the contents of the tag file:<pre id="e-tnQ9">@(products: Collection[String])
     &amp;lt;ul&amp;gt;
      @for(product &amp;lt;- products) {
        &amp;lt;li&amp;gt;@product&amp;lt;/li&amp;gt;
      }
    &amp;lt;/ul&amp;gt;</pre>
</li>
<li id="e-n4gc">Edit <code>foo_java/app/views/products.scala.html</code> by adding the following block:<pre id="e-HHfH">@import tags._
 
    @productsIterator(products)</pre>
</li>
<li id="e-z6nX">Reload the products page using a web browser to see the new product listing, using an unordered list HTML tag:<pre id="e-HCGs">&lt;code class="literal"&gt;http://localhost:9000/products&lt;/code&gt;</pre>
</li>
</ol>
<p id="e-u7Sa">For Scala, we need to take the following steps:</p>
<ol id="e-zU08">
<li id="e-U0d8">Run the <code>foo_scala</code> application with Hot-Reloading enabled.</li>
<li id="e-OZbr">Create the tag file <code>productsIterator.scala.html</code> in <code>foo_scala/app/views/tags</code>
</li>
<li id="e-Yg4Z">Add contents of the tag file:<pre id="e-vBr5">@(products: Seq[String])
     &amp;lt;ul&amp;gt;
      @for(product &amp;lt;- products) {
        &amp;lt;li&amp;gt;@product&amp;lt;/li&amp;gt;
  }
    &amp;lt;/ul&amp;gt;</pre>
</li>
<li id="e-Vpap">Edit <code>foo_scala/app/views/products.scala.html</code> by adding the following block:<pre id="e-AgBu">@import tags._
 
    @productsIterator(products)</pre>
</li>
<li id="e-tc3K">Reload the products page using a web browser to see the new products listing, using an unordered list HTML tag:<pre id="e-CKEf">&lt;code class="literal"&gt;http://localhost:9000/products&lt;/code&gt;</pre>
</li>
</ol>
<h2 id="e-TgyO">How it works...</h2>
<p id="e-a7YV">In this recipe, we were able to create a new view tag in <code>app/views/tags</code>. We proceeded to use this tag in our View template.</p>
<p id="e-bd5s">First, we created a new tag that receives a collection of product titles, from which it is then displayed in the template as an unordered list. We then imported the tag in our products View template and invoked the helper function by calling it using its filename (<code>@productsIterator(products)</code>).</p>

<h1 id="e-Tcif">Using View layouts and Includes</h1>
<p id="e-Z4SQ">For this recipe, we will create a main layout View template that will include a defined header and footer view. This will allow our View template to inherit a consistent look and feel by including this main View template and manage all UI changes in a single file. Our Products view will utilize the main layout view in this example.</p>
<h2 id="e-gIVI">How to do it...</h2>
<p id="e-BFmN">For Java, we need to take the following steps:</p>
<ol id="e-j8Ko">
<li id="e-aLSt">Run the <code>foo_java</code> application with Hot-Reloading enabled.</li>
<li id="e-Vm3S">Create the main layout view file <code>mainLayout.scala.html</code> in <code>foo_java/app/views/common</code>
</li>
<li id="e-IRHm">Add the contents of the main layout view file:<pre id="e-xSKp">@(title: String)(content: Html)
  &amp;lt;!DOCTYPE html&amp;gt;
  &amp;lt;html lang="en"&amp;gt;
    &amp;lt;head&amp;gt;
      &amp;lt;title&amp;gt;@title&amp;lt;/title&amp;gt;
    &amp;lt;/head&amp;gt;
    &amp;lt;body&amp;gt;
      &amp;lt;header&amp;gt;@header()&amp;lt;/header&amp;gt;
      &amp;lt;section class="content"&amp;gt;@content&amp;lt;/section&amp;gt;
      &amp;lt;footer&amp;gt;@footer()&amp;lt;/footer&amp;gt;
    &amp;lt;/body&amp;gt;
  &amp;lt;/html&amp;gt;</pre>
</li>
<li id="e-qmz5">Create the header view file <code>header.scala.html</code> in <code>foo_java/app/views/common</code> and add the following code:<pre id="e-tCjj">&amp;lt;div&amp;gt;
    &amp;lt;h1&amp;gt;Acme Products Inc&amp;lt;/h1&amp;gt;
  &amp;lt;/div&amp;gt;</pre>
</li>
<li id="e-SjYs">Create the footer view file <code>footer.scala.html</code> in <code>foo_java/app/views/common</code> and add the following code:<pre id="e-j5RJ">&amp;lt;div&amp;gt;
    Copyright 2014
  &amp;lt;/div&amp;gt;</pre>
</li>
<li id="e-LcRz">Edit the products view file <code>foo_java/app/views/products.scala.html</code> to use the main layout View template by replacing all the file contents with the following code:<pre id="e-n6FB">@(products: Collection[String])
   @import tags._
  @import common._
   @mainLayout(title = "Acme Products") {
    @productsIterator(products)
  }</pre>
</li>
<li id="e-pUyV">Reload the updated products page using a web browser:<pre id="e-dRr0">&lt;code class="literal"&gt;http://localhost:9000/products&lt;/code&gt;</pre>
</li>
</ol>
<p id="e-a8nY">For Scala, we need to take the following steps:</p>
<ol id="e-s0C3">
<li id="e-G10N">Run the <code>foo_scala</code> application with Hot-Reloading enabled.</li>
<li id="e-kxzK">Create the main layout view file <code>mainLayout.scala.html</code> in <code>foo_scala/app/views/common</code>
</li>
<li id="e-sGYe">Add the contents of the main layout view file:<pre id="e-qHsH">@(title: String)(content: Html)
  &amp;lt;!DOCTYPE html&amp;gt;
  &amp;lt;html lang="en"&amp;gt;
    &amp;lt;head&amp;gt;
      &amp;lt;title&amp;gt;@title&amp;lt;/title&amp;gt;
    &amp;lt;/head&amp;gt;
    &amp;lt;body&amp;gt;
      &amp;lt;header&amp;gt;@header()&amp;lt;/header&amp;gt;
      &amp;lt;section class="content"&amp;gt;@content&amp;lt;/section&amp;gt;
      &amp;lt;footer&amp;gt;@footer()&amp;lt;/footer&amp;gt;
    &amp;lt;/body&amp;gt;
  &amp;lt;/html&amp;gt;</pre>
</li>
<li id="e-loEA">Create the header view file <code>header.scala.html</code> in <code>foo_scala/app/views/common</code> and add the following code:<pre id="e-cXBu">&amp;lt;div&amp;gt;
    &amp;lt;h1&amp;gt;Acme Products Inc&amp;lt;/h1&amp;gt;
  &amp;lt;/div&amp;gt;</pre>
</li>
<li id="e-U3AE">Create the footer view file <code>footer.scala.html</code> in <code>foo_scala/app/views/common</code> and add the following code:<pre id="e-u5WV">&amp;lt;div&amp;gt;
    Copyright 2014
  &amp;lt;/div&amp;gt;</pre>
</li>
<li id="e-XecB">Edit the products view file <code>foo_scala/app/views/products.scala.html</code> to use the main layout view template by replacing all the file contents with following code:<pre id="e-y0Sq">@(products: Seq[String])
   @import tags._
  @import common._
   @mainLayout(title = "Acme Products") {
    @productsIterator(products)
  }</pre>
</li>
<li id="e-ceqz">Reload the updated products page using a web browser:<pre id="e-lyDB">&lt;code class="literal"&gt;http://localhost:9000/products&lt;/code&gt;</pre>
</li>
</ol>
<h2 id="e-rwnD">How it works...</h2>
<p id="e-k5ti">In this recipe, we created a main layout view template that can be reused throughout the Play application. A common layout view removes the need to duplicate the view logic in related views and makes it a lot easier to manage parent views and child views.</p>

<h1 id="e-jT8k">Working with XML and text files</h1>
<p id="e-p4hN">Using View templates, we are also able to respond to HTTP requests in other content types such as text files and XML data formats. Play Framework has native handlers for XML and text file content type responses.</p>
<h2 id="e-hyCU">How to do it...</h2>
<p id="e-NJri">For Java, we need to take the following steps:</p>
<ol id="e-iRzh">
<li id="e-A3EW">Run the <code>foo_java</code> application with Hot-Reloading enabled:<pre id="e-soYs">&lt;span class="strong"&gt;&lt;strong&gt;    $ activator "~run"&lt;/strong&gt;&lt;/span&gt;</pre>
</li>
<li id="e-mCy5">Create the text-based view template file <code>products.scala.txt</code> in <code>app/views/</code> and add the following content:<pre id="e-DBha">@(productMap: Map[Integer, String])
    @for((id, name) &amp;lt;- productMap) {
      The Product '@name' has an ID of @id
    }</pre>
</li>
<li id="e-DiT8">Create the XML-based view template file <code>products.scala.xml</code> in <code>app/views/</code> and add the following content:<pre id="e-N6IP">@(productMap: Map[Integer, String]) &amp;lt;products&amp;gt;
    @for((id, name) &amp;lt;- productMap) {
      &amp;lt;product id="@id"&amp;gt;@name&amp;lt;/product&amp;gt;
    }
    &amp;lt;/products&amp;gt;</pre>
</li>
<li id="e-ej5y">Edit <code>foo_java/app/controllers/Application.java</code> by adding the following actions:<pre id="e-vW4b">public static Result listProductsAsXML() {
        return ok(views.xml.products.render(productMap));
    }
     public static Result listProductsAsTXT() {
        return ok(views.txt.products.render(productMap));
    }</pre>
</li>
<li id="e-WoaU">Edit <code>foo_java/conf/routes</code> by adding the following lines:<pre id="e-wO4w">GET    /products.txt    controllers.Application.listProductsAsTXT()
    GET    /products.xml    controllers.Application.listProductsAsXML()</pre>
</li>
<li id="e-mESF">View the new routes and actions using a web browser:<ul id="e-XvBI">
<li id="e-Yx3M">
<code>http://localhost:9000/products.txt</code> and,</li>
<li id="e-g9OB"><code>http://localhost:9000/products.xml</code></li>
</ul>
</li>
</ol>
<p id="e-cygE">For Scala, we need to take the following steps:</p>
<ol id="e-rfC7">
<li id="e-IJ8n">Run the <code>foo_scala</code> application with Hot-Reloading enabled:<pre id="e-OtLI">$ activator "~run"</pre>
</li>
<li id="e-y6hi">Create the text-based view template file <code>products.scala.txt</code> in <code>app/views/</code> and add the following content:<pre id="e-pf6z">@(productMap: Map[Int, String])
    @for((id, name) &amp;lt;- productMap) {
      The Product '@name' has an ID of @id
    }</pre>
</li>
<li id="e-SvKT">Create the XML-based view template file <code>products.scala.xml</code> in <code>app/views/</code> and add the following content:<pre id="e-s5q4">@(productMap: Map[Int, String]) &amp;lt;products&amp;gt;
    @for((id, name) &amp;lt;- productMap) {
      &amp;lt;product id="@id"&amp;gt;@name&amp;lt;/product&amp;gt;
    }
    &amp;lt;/products&amp;gt;</pre>
</li>
<li id="e-Ifx8">Edit <code>foo_scala/app/controllers/Application.scala</code> by adding the following actions:<pre id="e-pPMr">def listProductsAsTXT = Action {
      Ok(views.txt.products(productMap))
    }
     def listProductsAsXML = Action {
      Ok(views.xml.products(productMap))
    }</pre>
</li>
<li id="e-JATl">Edit <code>foo_scala/conf/routes</code> by adding the following lines:<pre id="e-LOnK">GET    /products.txt    controllers.Application.listProductsAsTXT
    GET    /products.xml    controllers.Application.listProductsAsXML</pre>
</li>
<li id="e-reIP">View the new routes and actions using a web browser:<ul id="e-ofkc">
<li id="e-ra5u">
<code>http://localhost:9000/products.txt</code> and</li>
<li id="e-Xf98"><code>http://localhost:9000/products.xml</code></li>
</ul>
</li>
</ol>
<h2 id="e-opnJ">How it works...</h2>
<p id="e-V2hy">In this recipe, we utilized build-in support for other content types in Play Framework. We created new URL routes and web actions to be able to respond to requests for data in XML or text file formats. By following file naming standards and convention for views, we were able to create view templates in HTML, XML, and text file formats, which Play automatically handles, and then adds the appropriate content type headers in the HTTP response.</p>

<h1 id="e-KBwa">Using Ebean (Java) with MySQL</h1>
<p id="e-qiGs">Play Framework 2.x includes an object-relational mapping tool called <strong>Ebean</strong> for Java-based Play applications. To be able to use Ebean, ensure that Ebean and a suitable MySQL driver are declared as project dependencies in <code>foo_java/build.sbt</code>.</p>
<p id="e-d18a">For this recipe, we will be utilizing Ebean with database evolutions. Play Framework 2.x gives developers a way to manage database migrations. Database migrations are useful for tracking schema changes during the course of application development. Database evolutions are enabled by default but can be disabled in <code>conf/application.conf</code> with the following settings:</p>
<pre id="e-Eq1s">evolutionplugin=disabled</pre>
<p id="e-yht5">Evolution scripts are stored in the <code>conf/evolutions/default/</code> directory. For more information regarding database evolutions, please refer to Play's online documentation at</p>
<p id="e-YUsC"><a href="https://www.playframework.com/documentation/2.3.x/Evolutions">https://www.playframework.com/documentation/2.3.x/Evolutions</a>.</p>
<h2 id="e-DLN1">How to do it...</h2>
<p id="e-U5jt">You need to perform the following steps to utilize Ebean:</p>
<ol id="e-hdmy">
<li id="e-K3It">Add the Ebean dependency in <code>build.sbt</code>:<pre id="e-UtHI">libraryDependencies ++= Seq(
        javaJdbc,   javaEbean,
        "mysql" % "mysql-connector-java" % "5.1.28"
    )</pre>
</li>
<li id="e-fPHn">Ensure that Ebean and MySQL are configured properly in <code>conf/application.conf</code>:<pre id="e-hqf3">db.default.driver=com.mysql.jdbc.Driver
    db.default.url="jdbc:mysql://&amp;lt;YOUR_MYSQL_HOST&amp;gt;/&amp;lt;YOUR_DB&amp;gt;"
    db.default.user=&amp;lt;YOUR_USER&amp;gt;
    db.default.password=&amp;lt;YOUR_PASSWORD&amp;gt;
     ebean.default="models.*"</pre>
</li>
<li id="e-TwgX">For the next recipes, we need to create our product table in our MySQL database. Create our first database evolution file <code>1.sql</code> in <code>conf/evolutions/default</code> and add the following SQL statements:<pre id="e-fdJZ"># --- !Ups
    CREATE TABLE Products (
      id INT NOT NULL AUTO_INCREMENT,
      name VARCHAR(100) NOT NULL,
      PRIMARY KEY (id)
    );
   # --- !Downs
    DROP TABLE Products;</pre>
</li>
<li id="e-C05F">The next step is to create the Ebean model for our entity <code>Product</code>:<pre id="e-bhdD">package models;
     import java.util.*;
    import javax.persistence.*;
    import play.db.ebean.*;
    import play.data.format.*;
    import play.data.validation.*;
     @Entity
   @Table(name = "Products")
    public class Product extends Model {
      
    @Id
    public Long id;
  
    @Column
    @Constraints.Required
    public String name;
     public static Finder&amp;lt;Long, Product&amp;gt; find = new Finder&amp;lt;Long, Product&amp;gt;(
      Long.class, Product.class
    );
     public Long getId() {
      return id;
    }
    public void setId(Long id) {
      this.id = id;
    }
    public String getName() {
      return name;
    }
    public void setName(String name) {
      this.name = name;
    }
}</pre>
</li>
</ol>
<p id="e-zrJ2">The following displays various database-oriented operations using Ebean.</p>
<h3 id="e-vB7V">Tip</h3>
<p id="e-T0iy"><strong>Downloading the example code</strong></p>
<p id="e-OlYT">You can download the example code files for all Packt books you have purchased from your account at <a href="http://www.packtpub.com">http://www.packtpub.com</a>. If you purchased this book elsewhere, you can visit <a href="http://www.packtpub.com/support">http://www.packtpub.com/support</a> and register to have the files e-mailed directly to you.</p>
<h3 id="e-Nmw1">Creating a record</h3>
<p id="e-eg2e">The following code snippet will create a new record:</p>
<pre id="e-uZgy">Product product = new Product();
      product.name = "Apple iPhone";
      product.save();</pre>
<h3 id="e-JP1e">Updating a record</h3>
<p id="e-vkAK">The following code snippet will update a record:</p>
<pre id="e-OZcQ">Product forUpdate = Product.find.ref(1L);
      forUpdate.name = "Apple iPhone 6";
      forUpdate.update();Deleting a record:
  Product.find.ref(1L).delete();</pre>
<h3 id="e-S3u3">Querying a record</h3>
<p id="e-QXZp">The following code snippet will query a record:</p>
<pre id="e-UOXv">Product p = Product.find.byId(1L);</pre>
<h3 id="e-FyQB">Retrieving a record</h3>
<p id="e-kFpa">The following code snippet will retrieve a record:</p>
<pre id="e-EMCP">List&amp;lt;Product&amp;gt; products = Product.find.all();</pre>

<h1 id="e-ozRv">Using Anorm (Scala) and database evolutions with MySQL</h1>
<p id="e-z8GR">Play Framework 2.x includes Anorm, a useful data access library for Scala-based Play applications. To be able to use Anorm, ensure that Anorm and a suitable MySQL driver are declared as project dependencies in <code>foo_scala/build.sbt</code>.</p>
<p id="e-tKMJ">For this recipe, we will be utilizing Anorm with database evolutions. Play Framework 2.x gives developers a way to manage database migrations. Database migrations are useful for tracking schema changes during the course of application development. Database evolutions are enabled by default but can be disabled in <code>conf/application.conf</code> using the following settings:</p>
<pre id="e-Cmo8">evolutionplugin=disabled</pre>
<p id="e-guAT">Evolution scripts are stored in the <code>conf/evolutions/default/</code> directory. For more information regarding database evolutions, please refer to Play's online documentation at <a href="https://www.playframework.com/documentation/2.3.x/Evolutions">https://www.playframework.com/documentation/2.3.x/Evolutions</a>.</p>
<p id="e-j6DN">You need to perform the following steps to utilize Anorm:</p>
<ol id="e-VcAq">
<li id="e-Blkg">Add the Anorm dependency to <code>build.sbt</code>:<pre id="e-njbm">libraryDependencies ++= Seq(
      jdbc,
      anorm,
   "mysql" % "mysql-connector-java" % "5.1.28"
    )</pre>
</li>
<li id="e-HeXD">Ensure that Anorm and MySQL are configured properly in <code>conf/application.conf</code>:<pre id="e-fu2Q">db.default.driver= com.mysql.jdbc.Driver
    db.default.url="jdbc:mysql://localhost/YOUR_DB"
    db.default.user=YOUR_USER
    db.default.password=YOUR_PASSWORD</pre>
</li>
<li id="e-MR8J">For the next recipes, we need to create our products table in our MySQL database. Create our first database evolution file <code>1.sql</code> in <code>conf/evolutions/default</code> and add the following SQL statements:<pre id="e-AOLg"># --- !Ups
    CREATE TABLE Products (
      id INT NOT NULL AUTO_INCREMENT,
      name VARCHAR(100) NOT NULL,
      PRIMARY KEY (id)
    );
 # --- !Downs
    DROP TABLE Products;</pre>
</li>
</ol>
<h2 id="e-JksS">There's more…</h2>
<p id="e-cKP6">The following sections display various database-oriented operations using <code>Anorm</code>.</p>
<h3 id="e-U3E5">Creating a new record</h3>
<p id="e-OL1f">The following code snippet will create a new record:</p>
<pre id="e-L0MD">DB.withConnection { implicit c =&amp;gt;
     SQL("INSERT INTO Products(id, name) VALUES ({id}, {name});")
        .on('id -&amp;gt; product.id, 'name -&amp;gt; product.name).executeInsert()
   }</pre>
<h3 id="e-ZCp8">Updating a record</h3>
<p id="e-lDk1">The following code snippet will update a record:</p>
<pre id="e-q9im">   DB.withConnection { implicit c =&amp;gt;
      SQL("UPDATE Products SET name = {name} WHERE id = {id}")
       .on('name -&amp;gt; product.name, 'id -&amp;gt; product.id).executeUpdate()
   }</pre>
<h3 id="e-b1Cl">Deleting a record</h3>
<p id="e-kqgX">The following code snippet will delete a record:</p>
<pre id="e-yZPI">   DB.withConnection { implicit c =&amp;gt;
      SQL("DELETE FROM Products WHERE id={id};")
       .on('id -&amp;gt; id).executeUpdate()
   }Querying a record</pre>
<p id="e-R12U">The following code snippet will query a record:</p>
<pre id="e-kxqz">DB.withConnection { implicit c =&amp;gt;
      SQL("SELECT * FROM Products WHERE id={id};")
       .on('id -&amp;gt; id).executeQuery().singleOpt(defaultParser)
    }</pre>
<p id="e-b6yi">The following code snippet will retrieve a record:</p>
<pre id="e-frDE">DB.withConnection { implicit c =&amp;gt;
     SQL("SELECT * FROM Products;").executeQuery().list(defaultParser)
   }</pre>
<p id="e-JIs2">Finally, we can combine all of these functions in a companion object called Product:</p>
<pre id="e-v3V2">package models
     import play.api.db.DB
    import play.api.Play.current
    import anorm._
    import anorm.SqlParser.{str, int}
     case class Product(id: Long, name: String)
     object Product {
      val defaultParser = int("id") ~ str("name") map {
          case id ~ name  =&amp;gt; Product(id, name)
         }
       def save(product: Product) = {
        DB.withConnection { implicit c =&amp;gt;
      SQL("INSERT INTO Products(id, name) VALUES ({id}, {name});")
                  .on('id -&amp;gt; product.id, 'name -&amp;gt; product.name).executeInsert()
        }
          }
      
       def update(product: Product) = {
        DB.withConnection { implicit c =&amp;gt;
               SQL("UPDATE Products SET name = {name} WHERE id = {id}")
                .on('name -&amp;gt; product.name, 'id -&amp;gt; product.id).executeUpdate()
            }
          }
       
      def delete(id: Long) = {
        DB.withConnection { implicit c =&amp;gt;
               SQL("DELETE FROM Products WHERE id={id};")
           .on('id -&amp;gt; id).executeUpdate()
        }
          }
       
      def get(id: Long) = {
        DB.withConnection { implicit c =&amp;gt;
      SQL("SELECT * FROM Products WHERE id={id};")
        .on('id -&amp;gt; id).executeQuery().singleOpt(defaultParser)
        }
          }
      
      def all = {
        DB.withConnection { implicit c =&amp;gt;
      SQL("SELECT * FROM Products;").executeQuery().list(defaultParser)
        }
          }
    }</pre>

<h1 id="e-JaUF">Using a form template and web action</h1>
<p id="e-rgbF">As with the majority of web applications, there will always be a need to accept an HTTP form, be it a registration form or a login form. Play Framework provides helper classes to manage and process HTTP form submissions. In this recipe, we will go over the steps to create a simple form and map the web action assigned to handle this form submission. We will also utilize the flash scope, which allows us to use the flash object to send messages from the controller to the view template on a per-request basis.</p>
<h2 id="e-fxT3">How to do it...</h2>
<p id="e-GkWU">For Java, we need to take the following steps:</p>
<ol id="e-rJaV">
<li id="e-u2gA">Run the <code>foo_java</code> application with Hot-Reloading enabled.</li>
<li id="e-ZDxW">Create the form view template file <code>app/views/product/form.scala.html</code> and add the following contents:<pre id="e-uZST">@(productForm: Form[models.Product])
    
    @import common._
     @mainLayout(title = "New Product") {
      
      @if(flash.get("success") != null) {
        &amp;lt;p&amp;gt;@flash.get("success")&amp;lt;/p&amp;gt;
      }
       @if(productForm.hasGlobalErrors) {
        &amp;lt;ul&amp;gt;
        @for(error &amp;lt;- productForm.globalErrors) {
          &amp;lt;li&amp;gt;@error.message&amp;lt;/li&amp;gt;
        }
        &amp;lt;/ul&amp;gt;
      }
       @helper.form(action = routes.Products.postForm()) {
        @helper.inputText(productForm("id"))
        @helper.inputText(productForm("name"))
         &amp;lt;input type="submit"&amp;gt;
      }
    }</pre>
</li>
<li id="e-ngO5">Create the products controller <code>foo_java/app/controllers/Products.java</code> and add the following import, action, and Play form blocks:<pre id="e-aFpc">package controllers;
     import play.*;
    import play.mvc.*;
    import play.data.*;
    import views.html.*;
    import models.*;
     public class Products extends Controller {  
   public static Result create() {
      Form&amp;lt;Product&amp;gt; form = Form.form(Product.class);
           return ok(views.html.product.form.render(form));
       }
        public static Result postForm() {
          Form&amp;lt;Product&amp;gt; productForm = Form.form(Product.class).bindFromRequest();
          if (productForm.hasErrors()) {
          return badRequest(views.html.product.form.render(productForm));
      } else {
     Product product = productForm.get();
          product.save();
      flash("success", "Product saved!");
              return redirect(controllers.routes.Products.create());
      }
       }
    }</pre>
</li>
<li id="e-phxI">Edit <code>foo_java/conf/routes</code> by adding the following line:<pre id="e-gYtm">GET    /products/new    controllers.Products.create()
    POST   /products        controllers.Products.postForm()</pre>
</li>
<li id="e-rFB6">View your new product form using a web browser:<pre id="e-S6aF">&lt;code class="literal"&gt;http://localhost:9000/product/new&lt;/code&gt;</pre>
</li>
<li id="e-FtS2">Fill in a name for your new product and hit <strong>submit</strong>. You should now receive the success message:<img data-width="800" data-height="630" src="z7nu00LC.jpg"/>
</li>
</ol>
<p id="e-LAJE">For Scala, we need to take the following steps:</p>
<ol id="e-k0lW">
<li id="e-X7Tn">Run the <code>foo_scala</code> application with Hot-Reloading enabled.</li>
<li id="e-Ny9q">Create the form view template file <code>app/views/product/form.scala.html</code> and add the following contents:<pre id="e-AIyc">@(productForm: Form[models.Product])(implicit flash: Flash)
    
    @import common._
     @mainLayout(title = "New Product") {
      @flash.get("success").map { message =&amp;gt;
        &amp;lt;p&amp;gt;@message&amp;lt;/p&amp;gt;
      }
       @if(productForm.hasGlobalErrors) {
        &amp;lt;ul&amp;gt;
        @for(error &amp;lt;- productForm.globalErrors) {
          &amp;lt;li&amp;gt;@error.message&amp;lt;/li&amp;gt;
        }
        &amp;lt;/ul&amp;gt;
      }
       @helper.form(action = routes.Products.postForm()) {
        @helper.inputText(productForm("id"))
        @helper.inputText(productForm("name"))
         &amp;lt;input type="submit"&amp;gt;
      }
    }</pre>
</li>
<li id="e-Ndbr">Create the products controller <code>foo_scala/app/controllers/Products.scala</code> and add the following import, action, and Play form blocks:<pre id="e-ScW0">import play.api._
    import play.api.mvc._
    import models._
    import play.api.data._
    import play.api.data.Forms._
     val form = Form(
      mapping(
        "id" -&amp;gt; longNumber,
        "name" -&amp;gt; text
      )(Product.apply)(Product.unapply)
    )
    
    def create = Action { implicit request =&amp;gt;
      Ok(views.html.product.form(form))
    }
     def postForm = Action { implicit request =&amp;gt;
      form.bindFromRequest.fold(
        formWithErrors =&amp;gt; {
          BadRequest(views.html.product.form(formWithErrors))
        },
        product =&amp;gt; {Product.save(product)
          Redirect(routes.Products.create).flashing("success" -&amp;gt; "Product saved!")
        }
      )
    }</pre>
</li>
<li id="e-Jyyt">Edit <code>foo_scala/conf/routes</code> by adding the following lines:<pre id="e-bJCm">GET    /products/new    controllers.Products.create
    POST   /products        controllers.Products.postForm</pre>
</li>
<li id="e-PvKt">View your new Product form using a web browser:<pre id="e-yOct">&lt;code class="literal"&gt;http://localhost:9000/product/new&lt;/code&gt;</pre>
</li>
<li id="e-Jt0u">Fill in a name for your new product and click on <strong>submit</strong>. You should now receive the following success message:<img data-width="800" data-height="633" src="W1P99Ysq.jpg"/>
</li>
</ol>
<h2 id="e-oddb">How it works...</h2>
<p id="e-IWVP">In this recipe, we were able to create our first HTTP form using Play Framework. This recipe included steps in creating an HTML form view template and our Products controller. We declared two web actions and two URL routes and created the Play form object, which we used to bind request parameters to our model, Fruit. We were able to load the web form by accessing <code>http://localhost:9000/Products/new</code> on a web browser. After filling out our form details, we submitted the form itself and received a notification from the Products controller.</p>

<h1 id="e-L5S4">Using form validation</h1>
<p id="e-szb7">Play Framework provides an easy way to validate form submissions. For Play Java, we will add the validation to the model, which will check for a submitted field's length and return an error message if the validate condition is not satisfied. For Play Scala, we will add the form validation to the form object itself and define the validation parameters for each form field there.</p>
<h2 id="e-SGbk">How to do it...</h2>
<p id="e-qbyo">For Java, we need to take the following steps:</p>
<ol id="e-iPO6">
<li id="e-Qt6b">Edit the Product model, <code>foo_java/app/models/Product.java</code> and add the <code>validate()</code> method:<pre id="e-HjLy">public String validate() {
      if (name.length() &amp;lt; 3 || name.length() &amp;gt; 100) {
         return "Name must be at least 3 characters or a maximum of 100 characters";
   }
      return null;
    }</pre>
</li>
<li id="e-ImCv">Reload the Product form using a web browser:<pre id="e-JN3z">&lt;code class="literal"&gt;http://localhost:9000/products/new&lt;/code&gt;</pre>
</li>
<li id="e-dJ12">The product form should now accept only product names with a minimum of three characters and a maximum of 100, as shown in the following screenshot:<img data-width="800" data-height="560" src="JI0IYz2L.jpg"/>
</li>
</ol>
<p id="e-X3lS">For Scala, we need to take the following steps:</p>
<ol id="e-noJN">
<li id="e-bOIm">Edit the products controller <code>foo_scala/app/controllers/Products.scala</code> and modify how the form is declared:<pre id="e-t8hn">val form = Form(
      mapping(
        "id" -&amp;gt; longNumber,
        "name" -&amp;gt; nonEmptyText(minLength = 3, maxLength = 100)
      )(Product.apply)(Product.unapply)
    )</pre>
</li>
<li id="e-AMpj">Reload the Products form using a web browser:<pre id="e-xD33">&lt;code class="literal"&gt;http://localhost:9000/products/new&lt;/code&gt;</pre>
</li>
<li id="e-kpo3">The product form should now accept only fruit names with a minimum of three characters and a maximum of 100, as shown in the following screenshot:<img data-width="800" data-height="526" src="dQy6FzHw.jpg"/>
</li>
</ol>
<h2 id="e-ccJ8">How it works...</h2>
<p id="e-kbGQ">In this recipe, we added data validations for product name and the acceptable length submitted by users. For Java, we added a <code>validate()</code> method in the product model.</p>
<p id="e-E6xp">Our Java model can be validated by using JSR-303 JavaBean validation annotations and by defining a <code>validate()</code> method that Play invokes if it is present in the model class.</p>
<p id="e-wt40">For Scala, we added data validation directives to the <code>Form</code> object in the controller. We used Play form helpers to define the minimum and maximum character count for the name property of the product.</p>

<h1 id="e-MFlH">Securing form submission</h1>
<p id="e-kTSD">Play Framework has a CSRF filter module that developers can use to validate CSRF tokens during HTTP form submissions. This allows developers to be sure that the form was submitted with a valid session token and not tampered with in any way.</p>
<h2 id="e-d78u">How to do it...</h2>
<p id="e-uxck">For Java, we need to take the following steps:</p>
<ol id="e-UnTz">
<li id="e-PpOp">Add the Play filters module as a project dependency to <code>build.sbt</code>:<pre id="e-Zeew">libraryDependencies += filters</pre>
</li>
<li id="e-pXwI">Create a <code>Global.java</code> object file in the <code>app/</code> directory:<pre id="e-YpMw">import play.GlobalSettings;
    import play.api.mvc.EssentialFilter;
    import play.filters.csrf.CSRFFilter;
     public class Global extends GlobalSettings {
        @Override
        public &amp;lt;T extends EssentialFilter&amp;gt; Class&amp;lt;T&amp;gt;[] filters() {
            return new Class[]{CSRFFilter.class};
        }
    }</pre>
</li>
<li id="e-s1XB">Declare the <code>Global.java</code> object in <code>conf/application.conf</code>:<pre id="e-DFdw">application.global=Global</pre>
</li>
<li id="e-uZY3">Update the template declaration by adding an implicit request object for the product form file <code>app/views/product/form.scala.html</code>:<pre id="e-WS7u">@(productForm: Form[models.Product])</pre>
</li>
<li id="e-qSae">Add the CSRF token helper tag to the product form file <code>app/views/product/form.scala.html</code>:<pre id="e-YSWi">@helper.form(action = routes.Products.postForm()) {
        @helper.CSRF.formField @* -Add the CSRF Token Helper Tag- *@
    }</pre>
</li>
<li id="e-aVIA">Reload the product form using a web browser:<pre id="e-iBu1">&lt;code class="literal"&gt;http://localhost:9000/products/new&lt;/code&gt;</pre>
</li>
<li id="e-R3af">The product form should now contain a Play-generated CSRF token and should use this to validate form submissions, as shown in the following screenshot:<img data-width="800" data-height="551" src="mkHuCatJ.jpg"/>
</li>
</ol>
<p id="e-m2aU">For Scala, we need to take the following steps:</p>
<ol id="e-JmNF">
<li id="e-q2hN">Add the Play filters module as a project dependency to <code>build.sbt</code>:<pre id="e-DR3f">libraryDependencies += filters</pre>
</li>
<li id="e-mpIt">Create a <code>Global.scala</code> object file in the <code>app/</code>:<pre id="e-GdMg">import play.api._
     object Global extends GlobalSettings {
    }</pre>
</li>
<li id="e-H9NC">Declare the <code>Global.scala</code> object in <code>conf/application.conf</code>:<pre id="e-ANTK">application.global=Global</pre>
</li>
<li id="e-UccF">Add the Play global CSRF filter by modifying the object declaration in <code>app/Global.scala</code>:<pre id="e-C3Ma">import play.api.mvc._
    import play.filters.csrf._
     object Global extends WithFilters(CSRFFilter()) with GlobalSettings</pre>
</li>
<li id="e-tNxg">Update the template declaration by adding an implicit request object for the Product form file <code>app/views/product/form.scala.html</code>:<pre id="e-tSzF">@(productForm: Form[models.Product])(implicit flash: Flash, request: play.api.mvc.Request[Any])</pre>
</li>
<li id="e-CLpC">Add the CSRF token helper tag to the product form file <code>app/views/product/form.scala.html</code>:<pre id="e-c74d">@helper.form(action = routes.Products.postForm()) {
        @helper.CSRF.formField @* -Add the CSRF Token Helper Tag- *@
    }</pre>
</li>
<li id="e-AVkT">Reload the product form using a web browser:<pre id="e-vLgy">&lt;code class="literal"&gt;http://localhost:9000/products/new&lt;/code&gt;</pre>
</li>
<li id="e-acvT">The product form should now contain a Play-generated CSRF token and should use this to validate form submissions.</li>
</ol>
<h2 id="e-rduf">How it works...</h2>
<p id="e-wfH1">In this recipe, we added the Play Framework filters module, which includes CSRF helpers. We added global CSRF support by declaring the <code>CSRFFilter</code> in the Play application global settings class, <code>app/Global.java</code> and <code>app/Global.scala</code>. The last step was to insert a CSRF token helper tag in our tag that the filter uses to validate form submissions.</p>
<p id="e-TMZv">Modifying or tampering with a valid CSRF token will now result in an error and will be rejected by Play, as shown in the following screenshot:</p>
<img data-width="800" data-height="426" src="bnb5nrda.jpg"/>
<h1 id="e-HTNM">Testing with JUnit (Java) and specs2 (Scala)</h1>
<p id="e-KUoQ">It is quite important for a web framework to integrate testing as seamlessly as possible with the web framework itself. This minimizes the friction developers encounter when coding functional specs and writing tests to validate their work. For Play Java projects, we will be utilizing the popular test framework JUnit. We will be using it to do a simple unit test and to test our model and controller action. For Play Scala projects, we will be using specs2 to do a simple unit test and to test our model, a controller action, and a route mapping.</p>
<h2 id="e-OQU2">How to do it...</h2>
<p id="e-JjKX">For Java, we need to take the following steps:</p>
<ol id="e-Tz85">
<li id="e-WxBf">Create a new spec class, <code>ProductTest.java</code>, in <code>test/</code> and add the following content:<pre id="e-j0TB">import static org.junit.Assert.*;
    import org.junit.Test;
     public class ProductTest {
    
      @Test
      public void testString() {
        String str = "product";
        assertEquals(7, str.length());
      }
    }</pre>
</li>
<li id="e-L01i">Run the first spec using Activator by running the command <code>test-only ProductTest</code>:<pre id="e-Xy12">&lt;span class="strong"&gt;&lt;strong&gt;    $ activator&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    [info] Loading project definition from /private/tmp/foo_java/project&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    [info] Set current project to foo_java (in build file:/private/tmp/foo_java/)&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    [foo_java] $ test-only ProductTest&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    [info] Compiling 3 Java sources to /private/tmp/foo_java/target/scala-2.11/test-classes...&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    [info] Passed: Total 1, Failed 0, Errors 0, Passed 1&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    [success] Total time: 3 s, completed 09 29, 14 8:44:31 PM&lt;/strong&gt;&lt;/span&gt;</pre>
</li>
</ol>
<p id="e-mS0p">For Scala, we need to take the following steps:</p>
<ol id="e-kR6M">
<li id="e-v9dv">Create a new Spec class, <code>ProductSpec.scala</code>, in <code>test/</code> and add the following content:<pre id="e-MT2J">import org.specs2.mutable._
     class ProductSpec extends Specification {
       "The 'product' string" should {
        "contain seven characters" in {
          "product" must have size(7)
        }
      }
    }</pre>
</li>
<li id="e-s0po">Run the first spec using Activator by running the command <code>test-only ProductSpec</code>:<pre id="e-a0fR">&lt;span class="strong"&gt;&lt;strong&gt;    $ activator&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    [info] Loading project definition from /private/tmp/foo_scala/project&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    [info] Set current project to foo_scala (in build file:/private/tmp/foo_scala/)&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    [foo_scala] $ test-only ProductSpec&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    [info] ProductSpec&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    [info]&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    [info] The 'product' string should&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    [info] + contain seven characters&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    [info]&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    [info] Total for specification ProductSpec&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    [info] Finished in 24 ms&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    [info] 1 example, 0 failure, 0 error&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    [info] Passed: Total 1, Failed 0, Errors 0, Passed 1&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    [success] Total time: 2 s, completed 09 29, 14 12:22:57 PM&lt;/strong&gt;&lt;/span&gt;</pre>
</li>
</ol>
<h2 id="e-Ovbz">How it works...</h2>
<p id="e-qvAp">In this recipe, we created a brand new spec file that will contain our test specifications. We placed this file inside the <code>test/</code> directory and ran the test using <code>activator</code> with the <code>test-only</code> command. The <code>test</code> command is used to run the test and it displays the results of the test.</p>

<h1 id="e-X3hq">Testing models</h1>
<p id="e-mYiu">The following recipe focuses on writing a test for our model objects. We will create a new record and add assertions to validate the object's creation. We will then use the <code>Activator</code> command to run our test.</p>
<h2 id="e-hnEL">How to do it...</h2>
<p id="e-USK9">For Java, we need to take the following steps:</p>
<ol id="e-yVFE">
<li id="e-zdkG">Edit the <code>ProductTest.java</code> file and add the following content:<pre id="e-SOzH">// add new imports
    import static play.test.Helpers.*;
    import models.*;
    import play.test.*;
     // add new test
    @Test
    public void testSavingAProduct() {
      running(fakeApplication(), new Runnable() {
        public void run() {
          
     Product product = new Product();
          product.name = "Apple";
          product.save();
          assertNotNull(product.getId());
        }
      });
    }</pre>
</li>
<li id="e-Oi9l">Execute the new spec by running the command <code>test-only ProductTest</code>:<pre id="e-iHaQ">&lt;span class="strong"&gt;&lt;strong&gt;    [foo_java] $ test-only ProductTest&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    [info] Passed: Total 2, Failed 0, Errors 0, Passed 2&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    [success] Total time: 2 s, completed 09 29, 14 9:33:43 PM&lt;/strong&gt;&lt;/span&gt;</pre>
</li>
</ol>
<p id="e-Ukx0">For Scala, we need to take the following steps:</p>
<ol id="e-ghOx">
<li id="e-DeV6">Edit the <code>ProductSpec.scala</code> file and add the following content:<pre id="e-m6Vf">import models._
    import play.api.test.WithApplication
     "models.Product" should {
      "create a product with save()" in new WithApplication {
                val product = Product(1, "Apple")
        val productId = Product.save(product)
           productId must not be None
      }
    }</pre>
</li>
<li id="e-SOhk">Execute the new spec by running the command <code>test-only ProductSpec</code>:<pre id="e-LiXF">&lt;span class="strong"&gt;&lt;strong&gt;    [foo_scala] $ test-only ProductSpec&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    [info] Compiling 1 Scala source to /private/tmp/foo_scala/target/scala-2.11/test-classes...&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    [info] ProductSpec&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    [info]&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    [info] The 'product' string should&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    [info] + contain seven characters&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    [info]&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    [info] models.Product should&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    [info] + create a product with save()&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    [info]&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    [info] Total for specification ProductSpec&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    [info] Finished in 1 second, 90 ms&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    [info] 2 examples, 0 failure, 0 error&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    [info] Passed: Total 2, Failed 0, Errors 0, Passed 2&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    [success] Total time: 4 s, completed 09 29, 14 4:28:51 PM&lt;/strong&gt;&lt;/span&gt;</pre>
</li>
</ol>
<h2 id="e-zCuG">How it works...</h2>
<p id="e-JJ4S">In this recipe, we added a new spec, where we created a new product and invoked the <code>save()</code> method. We then added assertion statements to validate that the value returned by the <code>save()</code> method is not equal to none. The <code>test</code> command is used to run the test and displays the results of the test.</p>

<h1 id="e-fJst">Testing controllers</h1>
<p id="e-T30V">The following recipe focuses on writing a test for our controller objects. We will use a <code>FakeApplication</code> to create a mock HTTP request to the Product XML listing page and add assertions to validate that the response we receive is indeed an XML representing all of the products in our database. We will then use the <code>Activator</code> command to run our test.</p>
<h2 id="e-nBhy">How to do it...</h2>
<p id="e-wKpk">For Java, we need to take the following steps:</p>
<ol id="e-fEKL">
<li id="e-yMbY">Edit the <code>ProductTest.java</code> file and add the following content:<pre id="e-lxxE">// add new imports
    import play.mvc.*;
    import static org.fest.assertions.Assertions.*;
     //add new test
    @Test
    public void testProductListAsXml() {
      Result result = callAction(controllers.routes.ref.Application.listProductsAsXML());   
      assertThat(status(result)).isEqualTo(OK);
      assertThat(contentType(result)).isEqualTo("application/xml");
      assertThat(contentAsString(result)).contains("products");
    }</pre>
</li>
<li id="e-Bf7t">Execute the new spec by running the command <code>test-only ProductTest</code>:<pre id="e-uWgS">&lt;span class="strong"&gt;&lt;strong&gt;    [foo_java] $ test-only ProductTest&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    [info] Compiling 1 Java source to /private/tmp/foo_java/target/scala-2.11/test-classes...&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    [info] Passed: Total 3, Failed 0, Errors 0, Passed 3&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    [success] Total time: 3 s, completed 09 29, 14 9:37:03 PM&lt;/strong&gt;&lt;/span&gt;</pre>
</li>
</ol>
<p id="e-xm2o">For Scala, we need to take the following steps:</p>
<ol id="e-hDIf">
<li id="e-bW1S">Edit the Product<code>Spec.scala</code> file and add the following spec code:<pre id="e-cGC8">import controllers._
    import play.api.test.FakeRequest
    import play.api.test.Helpers._
     "controllers.Application" should {
      "respond with XML for /products.xml requests" in new WithApplication {
        val result = controllers.Application.listProductsAsXML()(FakeRequest())
         status(result) must equalTo(OK)
        contentType(result) must beSome("application/xml")
        contentAsString(result) must contain("products")
      }
    }</pre>
</li>
<li id="e-bZgu">Execute the new spec by running the <code>test-only ProductSpec</code> command:<pre id="e-IWR0">&lt;span class="strong"&gt;&lt;strong&gt;    $ test-only ProductSpec&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    [info] Compiling 1 Scala source to /private/tmp/foo_scala/target/scala-2.11/test-classes...&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    [info] ProductSpec&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    [info]&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    [info] The 'product' string should&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    [info] + contain seven characters&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    [info]&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    [info] models.Product should&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    [info] + create a product with save()&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    [info]&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    [info] controllers.Application should&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    [info] + respond with XML for /products.xml requests&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    [info]&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    [info] Total for specification ProductSpec&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    [info] Finished in 1 second, 333 ms&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    [info] 3 examples, 0 failure, 0 error&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    [info] Passed: Total 3, Failed 0, Errors 0, Passed 3&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    success] Total time: 4 s, completed 09 29, 14 5:23:41 PM&lt;/strong&gt;&lt;/span&gt;</pre>
</li>
</ol>
<h2 id="e-b2mi">How it works...</h2>
<p id="e-hylV">In this recipe, we created a new spec to test a URL route we created earlier. Then, we validated the <code>/products.xml</code> URL route by making sure that the response content type is <code>application/xml</code> and that it contains our root element products. The <code>test</code> command is used to run the test and it displays the results of the test.</p>
</body></html>