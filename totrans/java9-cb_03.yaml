- en: Modular Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Using jdeps to find dependencies in a Java application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a simple modular application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a modular JAR
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a module JAR with pre-JDK 9 applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bottom-up migration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Top-down migration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using services to create loose coupling between consumer and provider modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a custom modular runtime image using jlink
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compiling for older platform versions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating multirelease JARs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Maven to develop a modular application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Modular programming enables one to organize code into independent, cohesive
    modules, which can be combined together to achieve the desired functionality.
    This allows in creating code that is:'
  prefs: []
  type: TYPE_NORMAL
- en: More cohesive because the modules are built with a specific purpose, so the
    code that resides there tends to cater to that specific purpose.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Encapsulated because modules can interact with only those APIs that have been
    made available by the other modules.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reliable because the discoverability is based on the modules and not on the
    individual types. This means that if a module is not present, then the dependent
    module cannot be executed until it is discoverable by the dependent module. This
    helps in preventing runtime errors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loosely coupled. If you use service interfaces, then the module interface and
    the service interface implementation can be loosely coupled.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, the thought process in designing and organizing the code will now involve
    identifying the modules, code, and configuration files, which go into the module
    and the packages in which the code is organized within the module. After that,
    we have to decide the public APIs of the module, thereby making them available
    for use by dependent modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'Coming to the development of the Java Platform Module System, it is being governed
    by **Java Specification Request** (**JSR**) 376 ([https://www.jcp.org/en/jsr/detail?id=376](https://www.jcp.org/en/jsr/detail?id=376)).
    The JSR mentions the need for a module system is to address the following fundamental
    issues:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Reliable configuration**: Developers have long suffered from the brittle,
    error-prone classpath mechanism for configuring program components. The classpath
    cannot express relationships between components, so if a necessary component is
    missing, then that will not be discovered until an attempt is made to use it.
    The classpath also allows classes in the same package to be loaded from different
    components, leading to unpredictable behavior and difficult-to-diagnose errors.
    The proposed specification will allow a component to declare that it depends upon
    other components as other components depend upon it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Strong encapsulation**: The access-control mechanism of the Java programming
    language and the JVM provides no way for a component to prevent other components
    from accessing its internal packages. The proposed specification will allow a
    component to declare its packages that are accessible by other components and
    those that are not.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The JSR further goes to list the advantages that result from addressing the
    preceding issues, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**A scalable platform**: The ever-increasing size of the Java SE platform has
    made it increasingly difficult to use in small devices, despite the fact that
    many such devices are capable of running an SE-class JVM. The compact profiles
    introduced in Java SE 8 (JSR 337) help in this regard, but they are not nearly
    flexible enough. The proposed specification will allow the Java SE platform and
    its implementations to be decomposed into a set of components that can be assembled
    by developers into custom configurations that contain only the functionality actually
    required by an application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Greater platform integrity**: Casual use of APIs that are internal to Java
    SE platform implementations is both a security risk and a maintenance burden.
    The strong encapsulation provided by the proposed specification will allow components
    that implement the Java SE platform to prevent access to their internal APIs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Improved performance**: Many ahead-of-time, whole-program optimization techniques
    can be more effective when it is known that a class can refer only to classes
    in a few other specific components rather than to any class loaded at runtime.
    Performance is especially enhanced when the components of an application can be
    optimized in conjunction with the components that implement the Java SE platform.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, we will look at few important recipes that will help you get
    started with modular programming.
  prefs: []
  type: TYPE_NORMAL
- en: Using jdeps to find dependencies in a Java application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first step in modularizing your application is to identify its dependencies.
    A static analysis tool called `jdeps` was introduced in JDK 8 to enable developers
    to find the dependencies of their applications. There are multiple options supported
    in the command, which enables developers to check for dependencies to the JDK
    internal APIs, show the dependencies at the package level, show the dependencies
    at the class level, and filter the dependencies, among other options.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will look at how to make use of the `jdeps` tool by exploring
    its functionality and using the multiple command-line options it supports.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We need a sample application, which we can run against the `jdeps` command
    to find its dependencies. So, we thought of creating a very simple application
    that uses the Jackson API to consume JSON from the REST API: [http://jsonplaceholder.typicode.com/users](http://jsonplaceholder.typicode.com/users).'
  prefs: []
  type: TYPE_NORMAL
- en: In the sample code, we also added a call to the deprecated JDK internal API,
    called `sun.reflect.Reflection.getCallerClass()`. This way, we can see how `jdeps`
    helps in finding dependencies to the JDK internal APIs.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps will help you to set up the prerequisites for this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: You can get the complete code for the sample from the location, `chp3/1_json-jackson-sample`.
    We have built this code against Java 9 and it compiles well. So, you need not
    install something other than Java 9 to compile it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once you have the code, compile it by using the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: You will see a warning for the use of an internal API, which you can safely
    ignore. We added this with a purpose to demonstrate the capability of `jdeps`.
    Now, you should have your compiled class files in the classes directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can run the sample program by using the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We have provided the `run.bat` and `run.sh` scripts at `chp3/1_json-jackson-sample`.
    You can compile and run using these scripts as well.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s also create a JAR file for this sample so that we can run `jdeps` on
    the JAR file as well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'A `sample.jar` file gets created in the current directory. You can also run
    the JAR by issuing this command: `java -jar sample.jar`.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The simplest way to use `jdeps` is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command is equivalent to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The output for the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b28ed050-3259-48b4-9335-39711bd29a8d.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding command, we use `jdeps` to list the dependencies for the class
    file, `Sample.class`, at the package level. We have to provide `jdeps` with the
    path to search for the dependencies of the code being analyzed. This can be done
    by setting the `-classpath`, `-cp`, or `--class-path` option of the `jdeps` command.
  prefs: []
  type: TYPE_NORMAL
- en: The `-verbose:package` option lists the dependencies at the package level.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s list the dependencies at the class level:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding command is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c0bab155-4237-4b6f-ab35-4e24fdbc749d.png)'
  prefs: []
  type: TYPE_IMG
- en: In this case, we make use of the `-verbose:class` option to list the dependencies
    at the class level, which is why you can see that the `com.packt.Sample` class
    depends on `com.packt.model.Company`, `java.lang.Exception`, `com.fasterxml.jackson.core.type.TypeReference`,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s get the summary of the dependencies:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/96d306f0-8b73-49b2-8e09-abb1bee38ace.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s check for the dependency on the JDK internal API:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output of the preceding command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a4248c94-c0d2-4812-b7db-6b580e43f99a.png)'
  prefs: []
  type: TYPE_IMG
- en: The StackWalker API is the new API for traversing the call stack, introduced
    in Java 9\. This is the replacement for the `sun.reflect.Reflection.getCallerClass()`
    method. We will discuss this API in [Chapter 12](01ba0219-7bd3-4ad9-a856-ac2f81e98057.xhtml), *Memory
    Management and Debugging*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s run the `jdeps` on the JAR file, `sample.jar`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The output we get is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b60e2fc2-67c7-4bcf-8d66-a89bada43ac1.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding information obtained after investigating the `sample.jar` using
    `jdeps` is quite useful. It clearly states the dependencies of our JAR files and
    is very useful when we try to migrate this application to a modular application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s find if there are any dependencies to a given package name:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/447a9356-a643-4601-bd92-8a274416237a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `-p` option is used to find dependencies on the given package name. So,
    we get to know that our code depends on the `java.util` package. Let''s try with
    some other package name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: There is no output, which means that our code doesn't depend on the `java.util.concurrent`
    package.
  prefs: []
  type: TYPE_NORMAL
- en: 'We would want to run the dependency check only for our code. Yes, this is possible.
    Suppose we run `jdeps -cp lib/* sample.jar`, you will see even the library JARs
    being analyzed. We wouldn''t want that, right? Let''s just include the classes
    of the `com.packt` package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c8431335-f5b2-41ea-b850-f08cdd1e2994.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s check whether our code is dependent on a specific package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6c967f34-94fb-4550-b88f-8576d8d48846.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can use `jdeps` on analyzing the JDK modules. Let''s pick the `java.httpclient`
    module for analysis:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1cc0e943-a761-4690-befb-24426ef45fb6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can also find whether a given module is dependent on another module by using
    the `--require` option, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a8a641e8-d651-4838-9303-c697f5e10bcd.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding command, we tried to find out whether the `java.sql` module
    is dependent on the `java.logging` module. The output we get is the dependency
    summary of the `java.sql` module and the packages in the `java.sql` module, which
    make use of the code from the `java.logging` module.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `jdeps` command is a static class dependency analyzer and is used to analyze
    the static dependencies of the application and its libraries. The `jdeps` command by
    default shows the package-level dependencies of the input files, which can be
    `.class` files, a directory, or a JAR file. This is configurable and can be changed
    to show class-level dependencies. There are multiple options available to filter
    out the dependencies and to specify the class files to be analyzed. We have seen
    a regular use of the `-cp` command-line option. This option is used to provide
    the locations to search for the analyzed code's dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have analyzed the class file, JAR files, and the JDK modules, and we also
    tried out different options of the `jdeps` command. There are a few options, such
    as `-e`, `-regex`, `--regex`, `-f`, `--filter`, and `-include`, which accept a
    regular expression (regex). It''s important to understand the output of the `jdeps`
    command. There are two parts of information for every class/JAR file being analyzed:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The summary of the dependency for the analyzed file (JAR or class file). This
    consists of the name of the class or the JAR file on the left and the name of
    the dependent entity on the right. The dependent entity can be a directory, a
    JAR file, or a JDK module, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'A more verbose dependency information of the contents of the analyzed file
    at the package or class level ( depending on the command-line options). This consists
    of three columns: column 1 contains the name of the package/class, column 2 contains
    the name of the dependent package, and column 3 contains the name of the module/JAR
    where the dependency is found. A sample output looks like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have seen quite a few options of the `jdeps` command. There are a few more
    related to filtering the dependencies and filtering the classes to be analyzed.
    Apart from that, there are a few options that deal with module paths.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the options that can be tried out:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-e`, `-regex`, `--regex`: These find dependencies matching the given pattern.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-f`, `-filter`: These exclude dependencies matching the given pattern.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-filter:none`: This allows no filtering applied via `filter:package` or `filter:archive`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-filter:package`: This excludes dependencies within the same package. This
    is the default option. For example, if we added `-filter:none` to `jdeps sample.jar`,
    it would print the dependency of the package to itself.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-filter:archive`: This excludes dependencies within the same archive.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-filter:module`: This excludes dependencies in the same module.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-P`, `-profile`: This is used to show the profile of the package, whether
    it is in compact1, compact2, compact3, or Full JRE.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-R`, `-recursive`: These recursively traverse all the runtime dependencies;
    they are equivalent to the `-filter:none` option.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a simple modular application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You should be wondering what this modularity is all about and how to create
    a modular application in Java. In this recipe, we will try to clear the mystery
    around creating modular applications in Java by walking you through a simple example.
    Our goal is to show you how to create a modular application; hence, we picked
    a simple example so as to focus on our goal.
  prefs: []
  type: TYPE_NORMAL
- en: Our example is a simple advanced calculator, which checks whether a number is
    prime, calculates the sum of prime numbers, checks whether a number is even, and
    calculates the sum of even and odd numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will divide our application into two modules:'
  prefs: []
  type: TYPE_NORMAL
- en: The `math.util` module, which contains the APIs for performing the mathematical
    calculations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `calculator` module, which launches an advanced calculator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s implement the APIs in the `com.packt.math.MathUtil` class, starting
    with the `isPrime(Integer number)` API:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to implement the `sumOfFirstNPrimes(Integer count)` API:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s write a function to check whether the number is even:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The negation of `isEven` tells us whether the number is odd. We can have functions
    to find the sum of the first *N* even numbers and the first *N* odd numbers, as
    shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see in the preceding APIs that the following operations are repeated:'
  prefs: []
  type: TYPE_NORMAL
- en: An infinite sequence of numbers starting from 1
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filtering the numbers based on some condition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Limiting the stream of numbers to a given count
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding the sum of numbers thus obtained
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Based on our observation, we can refactor the preceding APIs and extract these
    operations into a method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Here, `count` is the limit of numbers we need to find the sum of and `filter`
    is the condition for picking the numbers for summing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s rewrite the APIs based on the refactoring we just did:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'You must be wondering about the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The `IntStream` class and the related chaining of the methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The use of `->` in the code base
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The use of the `IntPredicate` class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you are indeed wondering, then you need not worry, as we will cover these
    things in [Chapter](039b783d-d283-4205-b3d7-e8ba0baf1c76.xhtml) 4, *Going Functional*
    and [Chapter](ae1e93e7-8167-44cc-98dc-c87cede6e5df.xhtml) 5, *Stream Operations
    and Pipelines*.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have seen a few APIs around mathematical computations. These APIs
    are part of our `com.packt.math.MathUtil` class. The complete code for this class
    can be found at the location, `chp3/2_simple-modular-math-util/math.util/com/packt/math`,
    in the code base downloaded for this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s make this small utility class part of a module named `math.util`. The
    following are some conventions we use to create a module:'
  prefs: []
  type: TYPE_NORMAL
- en: Place all the code related to the module under a directory named `math.util`
    and treat this as our module root directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the root folder, place a file by the name `module-info.java`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We then place the packages and the code files under the root directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does `module-info.java` contain?
  prefs: []
  type: TYPE_NORMAL
- en: The name of the module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The packages it exports, that is, makes available for other modules to use
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The modules it depends on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The services it uses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The service for which it provides implementation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As mentioned in [Chapter 1](5cd0711b-a2f8-4129-9ec2-e80e4a0cf8db.xhtml), *Installation
    and a Sneak Peek into Java 9*, the JDK comes bundled with a lot of modules, that
    is, the existing Java SDK has been modularized! One of those modules is a module
    named `java.base`. All the user-defined modules implicitly depend (or require)
    the `java.base` module (think of every class implicitly extending the `Object`
    class ).
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `math.util` module doesn''t depend on any other module (except, of course,
    on the `java.base` module). However, it makes its API available for other modules
    (if not, then this module''s existence is questionable). Let''s go ahead and put
    this statement into code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: We are telling the Java compiler and runtime that our `math.util` module is
    *exporting* the code in the `com.packt.math` package to any module that depends
    on `math.util`.
  prefs: []
  type: TYPE_NORMAL
- en: The code for this module can be found at the location, `chp3/2_simple-modular-math-util/math.util`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s create another module calculator that uses the `math.util` module.
    This module has a `Calculator` class whose work is to accept the user''s choice
    for which mathematical operation to execute and then the inputs required to execute
    the operation. The user can choose from five available mathematical operations:'
  prefs: []
  type: TYPE_NORMAL
- en: Prime number check
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Even number check
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Sum of *N* primes
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Sum of *N* evens
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Sum of *N* odds
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s see this in code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, for each of the choice, we accept the required inputs and invoke the
    corresponding `MathUtil` API, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The complete code for the `Calculator` class can be found at `chp3/2_simple-modular-math-util/calculator/com/packt/calculator/Calculator.java`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create the module definition for our `calculator` module in the same
    way we created for the `math.util` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding module definition, we mention that the `calculator` module
    depends on the `math.util` module by using the keyword, `required`.
  prefs: []
  type: TYPE_NORMAL
- en: The code for this module can be found at `chp3/2_simple-modular-math-util/calculator`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now compile the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command has to be executed from `chp3/2_simple-modular-math-util`.
  prefs: []
  type: TYPE_NORMAL
- en: Also, you should have the compiled code from across both the modules, `math.util`
    and `calculator` in the `mods` directory. Was it not quite simple? Just a single
    command and everything including the dependency between the modules is taken care
    of by the compiler. We didn't require build tools such as `ant` to manage the
    compilation of modules.
  prefs: []
  type: TYPE_NORMAL
- en: The `--module-source-path` command is the new command-line option to `javac`,
    specifying the location of our module source code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now execute the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The `--module-path` command, similar to `--classpath`, is the new command-line
    option to `java`, specifying the location of the compiled modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'After running the preceding command, you will see the calculator in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e5375502-61aa-4aa0-9674-3da9489d9171.png)'
  prefs: []
  type: TYPE_IMG
- en: Congratulations! With this, we have a simple modular application up and running.
  prefs: []
  type: TYPE_NORMAL
- en: We have provided scripts to test out the code on both Windows and Linux platforms.
    Please use `run.bat` for Windows and `run.sh` for Linux.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that you have been through the example, we will look at how to generalize
    it so that we can apply the same pattern in all our modules. We followed a particular
    convention to create the modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: We place the module-specific code within its folders with a corresponding `module-info.java`
    at the root of the folder. This way, the code is organized well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look into what `module-info.java` can contain. From the Java language
    specification ([http://cr.openjdk.java.net/~mr/jigsaw/spec/lang-vm.html](http://cr.openjdk.java.net/~mr/jigsaw/spec/lang-vm.html)),
    a module declaration is of the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the syntax, explained:'
  prefs: []
  type: TYPE_NORMAL
- en: '`{Annotation}`: This is any annotation of the form `@Annotation(2)`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`open`: This keyword is optional. An open module makes all its components accessible
    at runtime via reflection. However, at compile time and runtime, only those components
    that are explicitly exported are accessible.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`module`: This is keyword used to declare a module.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ModuleName`: This is the name of the module that is a valid Java identifier
    with a permissible dot (`.`) between the identifier names--similar to `math.util`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`{ModuleStatement}`: This is a collection of the permissible statements within
    a module definition. Let''s expand this next.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A module statement is of the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The module statement is decoded here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`requires`: This is used to declare a dependency on a module. `{RequiresModifier}`
    can be **transitive**, **static**, or both. Transitive means that any module that
    depends on the given module also implicitly depends on the module that is required
    by the given module transitively. Static means that the module dependence is mandatory
    at compile time, but optional at runtime. Some examples are `requires math.util`,
    `requires transitive math.util`, and `requires static math.util`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`exports`: This is used to make the given packages accessible to the dependent
    modules. Optionally, we can force the package accessibility to specific modules
    by specifying the module name, such as `exports com.package.math to claculator`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`opens`: This is used to open a specific package. We saw earlier that we can
    open a module by specifying the `open` keyword with the module declaration. But
    this can be less restrictive. So, to make it more restrictive, we can open a specific
    package for reflective access at runtime by using the `opens` keyword: `opens
    com.packt.math`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`uses`: This is used to declare a dependency on a service interface that is
    accessible via `java.util.ServiceLoader`. The service interface can be in the
    current module or in any module that the current module depends on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`provides`: This is used to declare a service interface and provide it with
    at least one implementation. The service interface can be declared in the current
    module or in any other dependent module. However, the service implementation must
    be provided in the same module; otherwise, a compile-time error would occur.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will look at the `uses` and `provides` clauses in more detail in our recipe,
    *Using services to create loose coupling between consumer and provider modules*.
  prefs: []
  type: TYPE_NORMAL
- en: The module source of all modules can be compiled at once using the `--module-source-path`
    command-line option. This way, all the modules will be compiled and placed in
    their corresponding directories under the directory provided by the `-d` option.
    For example, `javac -d mods --module-source-path . $(find . -name "*.java")`  compiles
    the code in the current directory into a `mods` directory.
  prefs: []
  type: TYPE_NORMAL
- en: Running the code is equally simple. We specify the path where all our modules
    are compiled into, using the command-line option, `--module-path`. Then, we mention
    the module name along with the fully qualified main class name using the command-line
    option, `-m`, for example, `java --module-path mods -m calculator/com.packt.calculator.Calculator`.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Look at the recipe, *Compiling and running a Java application* from [Chapter
    1](5cd0711b-a2f8-4129-9ec2-e80e4a0cf8db.xhtml), *Installation and a Sneak Peek
    into Java 9*, where we try out another modular application.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a modular JAR
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Compiling modules into a class is good, but it is not suitable for sharing binaries
    and deployment. JARs are better formats for sharing and deployment. We can package
    the compiled module into JARs, and the JARs that contain `module-info.class` at
    its top level are called **modular JARs**. In this recipe, we will look at how
    to create modular JARs, and we'll also look at how to execute the application,
    which is composed of multiple modular JARs
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have seen and created a simple modular application in the recipe, *Creating
    a simpler modular application*. In order to build a modular JAR, we will make
    use of the sample code available at `chp3/3_modular_jar`. This sample code contains
    two modules: `math.util` and `calculator`. We will create modular JARs for both
    the modules.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Compile the code and place the compiled classes in a directory, say `mods`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Build a modular JAR for the `math.util` module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Do not forget the dot (`.`) in the end in the preceding code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Build a modular JAR for the `calculator` module, specifying the main class
    to make the JAR executable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The critical piece in the preceding command is the `--main-class` option. This
    enables us to execute the JAR without providing the main class information during
    execution.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we have two JARs in the `mlib` directory: `math.util@1.0.jar` and `calculator@1.0.jar`.
    These JARs are called modular JARs. If you want to run the example, you can use
    the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'A new command-line option for the JAR command has been introduced in Java 9,
    called `-d` or  `--describe-module`. This prints the information about the module
    that the modular JAR contains:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of `jar -d` for `calculator@1.0.jar` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of `jar -d` for `math.util@1.0.jar` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'We have provided the following scripts to try out the recipe code on Windows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`compile-math.bat`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`compile-calculator.bat`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jar-math.bat`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jar-calculator.bat`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`run.bat`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We have provided the following scripts to try out the recipe code on Linux:'
  prefs: []
  type: TYPE_NORMAL
- en: '`compile.sh`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jar-math.sh`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jar-calculator.sh`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`run.sh`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You have to run the scripts in the order they have been listed.
  prefs: []
  type: TYPE_NORMAL
- en: Using a module JAR with pre-JDK 9 applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It would be amazing if our modular JARs could be run with pre-JDK 9 applications.
    This way, we will not be concerned with writing another version of our API for
    pre-JDK 9 applications. The good news is that we can use our modular JARs just
    as if they were ordinary JARs, that is, JARs without `module-info.class` at its
    root. We will see how to do so in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this recipe, we will need a modular jar and a non-modular application.
    Our modular code can be found at `chp3/4_modular_jar_with_pre_java9/math.util` (this
    is the same `math.util` module that we created in our recipe, *Creating a simple
    modular application*). Let''s compile this modular code and create a modular JAR
    by using the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'We have also provided a `jar-math.bat` script at `chp3/4_modular_jar_with_pre_java9`,
    which can be used to create modular JARs on Windows. We have our modular JAR.
    Let''s verify by using the `-d` option of the `jar` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's now create a simple application, which is non-modular. Our application
    will consist of one class named `NonModularCalculator`, which borrows its code
    from the class, `Calculator`, in the recipe *Creating a simple modular application*.
  prefs: []
  type: TYPE_NORMAL
- en: You can find the `NonModularCalculator` class definition in the `com.packt.calculator`
    package under the directory, `chp3/4_modular_jar_with_pre_java9/calculator`. As
    it is non-modular, it doesn't need a `module-info.java` file. This application
    makes use of our modular JAR `math.util.jar` to execute some mathematical calculations.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, you should have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A modular JAR named `math.util@1.0.jar`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A non-modular application consisting of the `NonModularCalculator` package
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now we need to compile our `NonModularCalculator` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'After running the previous command, you will see a list of errors saying that
    the `com.packt.math` package doesn''t exist, the `MathUtil` symbol cannot be found, and
    so on. You guessed it right; we missed providing the location of our modular JAR
    for the compiler. Let''s add the modular jar location using the `--class-path`
    option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we have successfully compiled our non-modular code, which was dependent
    on the modular JAR. Let''s run the compiled code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Congratulations! You have successfully used your modular JAR with a non-modular
    application. Amazing, right!
  prefs: []
  type: TYPE_NORMAL
- en: 'We have provided the following scripts at `chp3/4_modular_jar_with_pre_java9` 
    to run the code on the Windows platform:'
  prefs: []
  type: TYPE_NORMAL
- en: '`compile-calculator.bat`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`run.bat`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We recommend you to try out the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a simple modular application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a modular JAR
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bottom-up migration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that Java 9 is out of the door, the much-awaited modularity feature is
    now available to be adopted by developers. At some point or the other, you will
    be involved in migrating your application to Java 9 and, hence, trying to modularize
    it. A change of such magnitude, which involves third-party libraries and rethinking
    of the code structure, would require proper planning and implementation. The Java
    team has suggested two migration approaches:'
  prefs: []
  type: TYPE_NORMAL
- en: Bottom-up migration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Top-down migration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before going into learning about bottom-up migration, it's important to understand
    what unnamed module and automatic module are. Suppose you are accessing a type
    not available in any of the modules; in such a case, the module system will search
    for the type on the classpath, and if found, the type becomes part of an unnamed
    module. This is similar to the classes we write that do not belong to any package,
    but Java adds them to an unnamed package so as to simplify the creation of new
    classes.
  prefs: []
  type: TYPE_NORMAL
- en: So, an unnamed module is a catch-all module without a name, which contains all
    those types that are not part of any modules, but are found in the classpath.
    An unnamed module can access all the exported types of all the named modules (user-defined
    modules) and built-in modules (Java platform modules). On the other hand, a named
    module (user-defined module) will not be able to access the types in the unnamed
    module. In other words, a named module cannot declare dependency on an unnamed
    module. If at all you want to declare dependency, how would you do that? An unnamed
    module doesn't have a name!
  prefs: []
  type: TYPE_NORMAL
- en: With the concept of unnamed modules, you can take your Java 8 application as
    is and run it on Java 9 (except for any deprecated internal APIs, which might
    not be available for user code in Java 9).
  prefs: []
  type: TYPE_NORMAL
- en: You may have seen this if you have tried out the *Using jdeps to find dependencies
    in a Java application* recipe, where we had a non-modular application and were
    able to run it on Java 9\. However, running as is on Java 9 would defeat the purpose
    of introducing the modular system.
  prefs: []
  type: TYPE_NORMAL
- en: If a package is defined in both named and unnamed modules, the one in the named
    module would be given preference over the one in the unnamed module. This helps
    in preventing conflict of packages when they come from both named and unnamed
    modules.
  prefs: []
  type: TYPE_NORMAL
- en: Automatic modules are those that are automatically created by the JVM. These
    modules are created when we introduce the classes packaged in JARs in the module
    path instead of the classpath. The name of this module will be derived from the
    name of the JAR without the `.jar` extension and, hence, is different from unnamed
    modules. Alternatively, one can provide the name for these automatic modules by
    providing the module name against `Automatic-Module-Name` in the JAR manifest
    file. These automatic modules export all the packages present in it and also depend
    on all the automatic and named (user/JDK) modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'Based on this explanation, modules can be classified into the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Unnamed modules**: The code available on classpath and not available on the
    module path is placed in an unnamed module'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Named modules**: all those modules which have a name associated with it -
    this can be user defined modules and JDK modules.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Automatic modules**: all those modules which are implicitly created by JVM
    based on the jar files present in the module path'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Implicit modules**: modules which are implicitly created. They are same as
    automatic modules'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Explicit modules**: all modules which are created explicitly by user or JDK.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: But the unnamed module and automatic module are a good first step to start your
    migration. So let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We need a non-modular application which we will eventually modularize. We have
    already created a simple application whose source code is available at the location
    `chp3/6_bottom_up_migration_before`. This simple application has 3 parts to it:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A math utility library which contains our favorite mathematical APIs namely:
    prime checker, even number checker, sum of primes, sum of evens and sum of odds.
    The code for this is available at the location `chp3/6_bottom_up_migration_before/math_util`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A banking utility library which contains API to compute simple interest and
    compound interest. The code for this is available at the location `chp3/6_bottom_up_migration_before/banking_util`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Our calculator app which helps us with our mathematical and banking calculations.
    To make this more interesting we will output the results in JSON and for this,
    we will make use of Jackson JSON API. The code for this is available at the location `chp3/6_bottom_up_migration_before/calculator`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After you have copied or downloaded the code, we will compile and build respective
    jars. So use the following commands to compile and build jars:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Let's also create a JAR for this (we make use of the JAR to build the dependency
    graph but not for running the app)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Please note that our Jackson JARs are in the calculator/lib so you need not
    worry about downloading them. Let''s run our calculator using the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: You will see a menu asking for the choice of operation and then you can play
    around with different operations. Let's now modularize this application!
  prefs: []
  type: TYPE_NORMAL
- en: We have provided `package-*.bat` and run.bat to package and run the application
    on Windows. And `package-*.sh` and `run.sh` to package and run the application
    on Linux.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first step in modularizing your application is to understand its dependency
    graph. Let''s create a dependency graph for our application. And for that, we
    make use of `jdeps` tool. If you are wondering what `jdeps` tool is, stop right
    away and read the recipe: *Using jdeps to find dependencies in a Java application*.
    OK so let''s run the `jdeps` tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'We are asking `jdeps` to give us a summary of the dependencies of our `calculator.jar`
    and then do this recursively for each dependency of `calculator.jar`. And the
    output we get is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding output is not clear, hence we have put the same diagrammatically
    as shown which is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1b8dc10e-8e36-4770-9d4d-d19a518440f3.png)'
  prefs: []
  type: TYPE_IMG
- en: In bottom-up migration, we start with modularizing the leaf nodes. In our graph
    the leaf nodes namely `java.xml`, `java.sql`, `java.base` and `java.logging` are
    already modularized. Let's pick to modularize `banking.util.jar`.
  prefs: []
  type: TYPE_NORMAL
- en: All the code for this recipe is available at the location `chp3/6_bottom_up_migration_after`.
  prefs: []
  type: TYPE_NORMAL
- en: Modularizing banking.util.jar
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Copy `BankUtil.java` from `chp3/6_bottom_up_migration_before/banking_util/src/com/packt/banking`
    to the location `chp3/6_bottom_up_migration_after/src/banking.util/com/packt/banking`.
    Two things to take a note of:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We have renamed the folder from `banking_util` to `banking.util`. This is to
    follow the convention of placing module related code under the folder bearing
    module name.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We have placed the package directly under the `banking.util` folder and not
    under `src`, again this is to follow the convention. And we would be placing all
    our modules under the `src` folder.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Create the module definition file `module-info.java` under `chp3/6_bottom_up_migration_after/src/banking.util` with
    the following definition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'From within the folder `6_bottom_up_migration_after`, compile the java code
    of the modules by running the command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: You will see that the java code in the module `banking.util` is compiled into
    the mods directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s create a modular JAR for this module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: If you are wondering what a modular JAR is, feel free to read through the recipe,
    *Creating a modular JAR*in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have modularized `banking.util.jar`, let's use this modular jar
    in place of the non-modular JAR used in *Getting ready* section earlier. You should
    execute the following from the `6_bottom_up_migration_before` folder because we
    haven't yet completely modularized the app.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '`--add-modules` option tells the Java runtime to include the modules either
    by module name or by predefined constants namely: `ALL-MODULE-PATH`, `ALL-DEFAULT`,
    `ALL-SYSTEM`. We made use of `ALL-MODULE-PATH` to add module which is available
    on our module path'
  prefs: []
  type: TYPE_NORMAL
- en: '`--module-path`  option tells the Java runtime the location of our modules.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You will see that our calculator is running as usual. Try out simple interest
    calculation, compound interest calculation to check if the `BankUtil` class is
    found. So our dependency graph now looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a6e33359-f3ec-4f7d-b1bd-cff778e74833.png)'
  prefs: []
  type: TYPE_IMG
- en: Modularizing math.util.jar
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Copy `MathUtil.java` from `chp3/6_bottom_up_migration_before/math_util/src/com/packt/math`
    to the location `chp3/6_bottom_up_migration_after/src/math.util/com/packt/math`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the module definition file `module-info.java` under `chp3/6_bottom_up_migration_after/src/math.util` with
    the following definition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'From within the folder `6_bottom_up_migration_after`, compile the Java code
    of the modules by running the command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: You will see that the Java code in the module `math.util` and `banking.util`
    is compiled into the `mods` directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s create a modular JAR for this module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: If you are wondering what a modular jar is, feel free to read through the recipe,
    *Creating a modular JAR* in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have modularized `math.util.jar`, let''s use this modular jar in
    place of the non-modular jar used in *Getting ready* section earlier. You should
    execute the below from the `6_bottom_up_migration_before` folder because we haven''t
    yet completely modularized the app:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'This time as well our app is running fine. And the dependency graph looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/171013b6-8812-4c30-b072-dfa719db87e4.png)'
  prefs: []
  type: TYPE_IMG
- en: We cannot modularize calculator.jar because it depends on one another non-modular
    code jackson-databind. And we cannot modularize `jackson-databind` as it is not
    maintained by us. So we cannot achieve 100% modularity for our application. We
    introduced you to Unnamed modules at the beginning of this recipe. All our non-modular
    code in the classpath are grouped in unnamed modules which means all jackson related
    code can still remain in the unnamed module and we can try to modularize `calculator.jar`. But we
    cannot do so because `calculator.jar` cannot declare dependency on `jackson-databind-2.8.4.jar`
    (because it is an unnamed module and named modules cannot declare dependency on
    unnamed modules).
  prefs: []
  type: TYPE_NORMAL
- en: 'A way to get around this is to make the jackson related code as automatic modules.
    We can do this by moving the jars related to jackson namely:'
  prefs: []
  type: TYPE_NORMAL
- en: '`jackson-databind-2.8.4.jar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jackson-annotations-2.8.4.jar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jackson-core-2.8.4.jar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To our mods folder under the folder `6_bottom_up_migration_after` using the
    following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: The reason for renaming the jars is that the name of the module has to be a
    valid identifier (should not be only numeric, should not contain `-` and other
    rules) separated with `.` and as the names are derived from the name of the JAR
    files, we had to rename the JAR files to conform to Java identifier rules.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new `mlib` directory if it is not present under `6_bottom_up_migration_after`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now run our calculator program again using the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'The application will run as usual. You will notice that our `-cp` option value
    is getting smaller as all the dependent libraries have been moved as modules in
    the module path. The dependency graph now looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ea7cc038-75e9-4a7e-b9c4-8c44c61a4367.png)'
  prefs: []
  type: TYPE_IMG
- en: Modularizing calculator.jar
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The last step in the migration is to modularize `calculator.jar`. Follow the
    below steps to modularize it:'
  prefs: []
  type: TYPE_NORMAL
- en: Copy the folder `com` from `chp3/6_bottom_up_migration_before/calculator/src`
    to the location `chp3/6_bottom_up_migration_after/src/calculator`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the module definition file `module-info.java` under `chp3/6_bottom_up_migration_after/src/calculator` with
    the following definition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'From within the folder `6_bottom_up_migration_after`, compile the Java code
    of the modules by running the command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: You will see that the Java code in all our modules is compiled into the mods
    directory. Please note that you should have the automatic modules (that is, jackson
    related JARs) already placed  in `mlib` directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s create a modular JAR for this module and also mention which is the `main`
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we have a modular JAR for our calculator module which is our main module
    as it contains the `main` class. With this, we have also modularized our complete
    application. Let''s run the following command from the folder: `6_bottom_up_migration_after`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'So we have seen how we modularized a non-modular application using a bottom-up
    migration approach. The final dependency graph looks something like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d2bbb80a-6a7b-477f-aa43-0a7dc543480d.png)'
  prefs: []
  type: TYPE_IMG
- en: The final code for this modular application can be found in the location: `chp3/6_bottom_up_migration_after`.
  prefs: []
  type: TYPE_NORMAL
- en: We could have done modification in line that is, modularize the code in the
    same directory `6_bottom_up_migration_before`. But we prefer to do it separately
    in a different directory `6_bottom_up_migration_after` so as to keep it clean
    and not disturb the existing code base.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The concept of unnamed modules helped us to run our non-modular application
    on Java 9\. The use of both module path and classpath helped us to run the partly
    modular application while we were doing the migration. We started with modularizing
    those code base which were not dependent on any non-modular code. And any code
    base which we couldn't modularize, we converted them into automatic modules. And
    thereby enabling us to modularize the code which was dependent on such code base.
    Eventually, we ended up with a completely modular application.
  prefs: []
  type: TYPE_NORMAL
- en: Top-down migration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The other technique for migration is the top-down migration. In this approach,
    we start with the root JAR in the dependency graph of the JARs.
  prefs: []
  type: TYPE_NORMAL
- en: JARs indicate a code base. We have assumed that the code base is available in
    the form of JARs and hence the dependency graph which we get has nodes which are
    JARs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Modularizing the root of the dependency graph would mean that all other JARs
    on which this root depends have to be modular. Otherwise, this modular root cannot
    declare a dependency on unnamed modules. Let''s consider the example non-modular
    application we introduced in our previous recipe. The dependency graph looks something
    like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/27abb22e-5ff1-4ecb-b9ad-5320522b7106.png)'
  prefs: []
  type: TYPE_IMG
- en: We extensively make use of automatic modules in top-down migration. Automatic
    modules are those modules which are implicitly created by the JVM. These are created
    based on the non-modular JARs available in the module path.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will make use of the calculator example which we introduced in the previous
    recipe *Bottom-up migration*. Go ahead and copy the non-modular code from the
    location: `chp3/7_top_down_migration_before`. Use the following commands if you
    wish to run it and see if it''s working:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: We have provided `package-*.bat` and `run.bat` to package and run the code on
    Windows. And `package-*.sh` and `run.sh` to package and run the code on Linux.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will be modularizing the application under the directory `chp3/7_top_down_migration_after`.
    Create two directories `src` and `mlib` under `chp3/7_top_down_migration_after`.
  prefs: []
  type: TYPE_NORMAL
- en: Modularizing the calculator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We cannot modularize the calculator until we have modularized all its dependencies.
    But modularizing its dependencies might be easier at times and not so at other
    times especially in cases where the dependency is from a third party. In such
    scenarios, we make use of automatic modules. We copy the non-modular JARs under
    the folder `mlib` and ensuring the name of the JAR is of the form `<identifier>(.<identifier>)*`
    where `<identifier>` is a valid Java identifier:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: We have provided script `copy-non-mod-jar.bat` and `copy-non-mod-jar.sh` to
    copy the jars easily.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see what all we copied into `mlib`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: The `banking.util.jar` and `math.util.jar` will exist only if you have compiled
    and JAR'd the code in the `chp3/7_top_down_migration_before/banking_util` and
    `chp3/7_top_down_migration_before/math_util` directories. We did this in the *Getting
    ready*section earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new folder `calculator` under `src`. This will contain the code for
    the `calculator` module.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create `module-info.java` under the `chp3/7_top_down_migration_after/src/calculator`
    directory that contains the following**:**
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Copy the directory `chp3/7_top_down_migration_before/calculator/src/com` and
    all the code under it to `chp3/7_top_down_migration_after/src/calculator`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Compile the calculator module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the modular JAR for `calculator` module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the `calculator` module :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: We will see that our calculator is executing correctly. You can try out different
    operations to verify if all of them are executing correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Modularizing banking.util
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As this doesn''t depend on other non-module code we can directly convert this
    into a module by following the steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new folder `banking.util` under `src`. This will contain the code for
    `banking.util` module.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create `module-info.java` under the directory `chp3/7_top_down_migration_after/src/banking.util`which
    contains the following**:**
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Copy the directory `chp3/7_top_down_migration_before/banking_util/src/com` and
    all the code under it to `chp3/7_top_down_migration_after/src/banking.util`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Compile the modules:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Create modular JAR for `banking.util` module. This will replace the non-modular
    `banking.util.jar` already present in `mlib`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the `calculator` module to test if the `banking.util` modular JAR has been
    created successfully:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: You should see the calculator getting executed. Play around with different operations
    to ensure there is no class not found issues.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Modularizing math.util
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Create a new folder `math.util` under `src`. This will contain the code for
    `math.util` module.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create `module-info.java` under the directory `chp3/7_top_down_migration_after/src/math.util`which
    contains the following**:**
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Copy the directory `chp3/7_top_down_migration_before/math_util/src/com` and
    all the code under it to `chp3/7_top_down_migration_after/src/math.util`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Compile the modules:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Create modular JAR for `banking.util` module. This will replace the non-modular
    `banking.util.jar` already present in `mlib`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: Run the `calculator` module to test if the `math.util` modular JAR has been
    created successfully.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: You should see the calculator getting executed. Play around with different operations
    to ensure there is no class not found issues.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With this, we have completely modularized the application baring the Jackson
    libraries which we have converted to automatic modules.
  prefs: []
  type: TYPE_NORMAL
- en: We would prefer the top-down approach for migration. This is because we don't
    have to deal with classpath and module-path at the same time. We can make everything
    into automatic modules and then use the module-path as we keep migrating the non-modular
    JARs into modular JARs.
  prefs: []
  type: TYPE_NORMAL
- en: Using services to create loose coupling between consumer and provider modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Generally, in our applications, we have some interfaces and multiple implementations
    of those interfaces. Then at runtime depending on some condition, we make use
    of some specific implementation. This principle is called **Dependency Inversion**.
    This principle is used by the dependency injection frameworks like Spring to create
    objects of concrete implementations and assign (or inject) into the references
    of type abstract interface.
  prefs: []
  type: TYPE_NORMAL
- en: Java has for long (since Java 6) supported service-provider loading facility
    via the `java.util.ServiceLoader` class. Using Service Loader you can have a **service
    provider interface** (**SPI**) and multiple implementations of the SPI simply
    called service provider. These service providers are located in the classpath
    and loaded at run time. When these service providers are located within modules
    and as we no longer depend on the classpath scanning to load the service provider,
    we need a mechanism to tell our modules about the service provider and the SPI
    for which it is providing. In this recipe, we will look at that mechanism using
    a simple example.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is nothing specific we need to set up for this recipe. In this recipe,
    we will take a simple example. We have one `BookService` abstract class which
    supports CRUD operations. Now, these CRUD operations can work on a SQL DB or on
    MongoDB or on file system and so on. This flexibility can be provided by using
    service provider interface and `ServiceLoader` class to load the required service
    provider implementation.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have four modules in this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '`book.service`: This is the module which contains our service provider interface
    that is, the service'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`mongodb.book.service`: This is one of the service provider module'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`sqldb.book.service`: This is the other service provider module'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`book.manage`: This is the service consumer module'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following steps demonstrate how to make use of `ServiceLoader` to achieve
    loose coupling:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a folder `book.service` under the directory `chp3/8_services/src`. All
    our code for `book.service` module will be under this folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new package `com.packt.model` and a new class `Book` under the new
    package. This is our model class which contains the following properties:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new package `com.packt.service` and a new class `BookService` under
    the new package. This is our main service interface and the service providers
    will provide an implementation for this service. Apart from the abstract methods
    for CRUD operations, one method worth mentioning is the `getInstance()`. This
    method uses the `ServiceLoader` class to load any one service provider (the last one
    to be specific) and then use that service provider to get an implementation of
    the `BookService`. Let''s see the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: The first `while` loop is just for the demonstration that the `ServiceLoader`
    loads all the service providers and we pick one of the service providers. You
    can conditionally return the service provider as well, but that all depends on
    the requirements.
  prefs: []
  type: TYPE_NORMAL
- en: The other important part is the actual service provider interface. The responsibility
    of this is to return an appropriate instance of the service implementation. In
    our recipe, `BookServiceProvider` in the package `com.packt.spi` is a service
    provider interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Next is the main part which is module definition. We create `module-info.java`
    under the directory `chp3/8_services/src/book.service` which contains:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: The `uses` statement in the preceding module definition specifies the service
    interface which the module discovers using the `ServiceLoader`.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now create a service provider module called `mongodb.book.service`. This
    will provide an implementation for our `BookService` and `BookServiceProvider`
    interface in `book.service` module. Our idea is that this service provider will
    implement the CRUD operations using MongoDB datastore.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a folder `mongodb.book.service` under the directory `chp3/8_services/src`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a class `MongoDbBookService` in the package `com.packt.mongodb.service` which
    extends `BookService` abstract class and provides an implementation for our abstract
    CRUD operation methods.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a class `MongoDbBookServiceProvider` in the package `com.packt.mongodb`
    which implements the `BookServiceProvider` interface. This is our service discovery,
    class. Basically, it returns a relevant instance of `BookService` implementation.
    It overrides the method in `BookServiceProvider` interface as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'The module definition is quite interesting. We have to declare in the module
    definition that this module is a service provider for the interface `BookServiceProvider`
    and that can be done as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: '`provides .. with ..` statement is used to specify the service interface and
    one of the service provider.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's now create a service consumer module called `book.manage`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new folder `book.manage` under `chp3/8_services/src` which will contain
    the code for the module.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new class called `BookManager` in package `com.packt.manage`. The
    main aim of this class is to get an instance of `BookService` and then execute
    its CRUD operations. The instance returned is decided by the service providers
    loaded by the `ServiceLoader`. The `BookManager` class looks something like:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s now compile and run our main module by using the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding output, the first line says the service providers available
    and the second line says which `BookService` implementation we are using.
  prefs: []
  type: TYPE_NORMAL
- en: 'With one service provider, it looks simple. Let''s go ahead and add another
    module `sqldb.book.service` whose module definition would be:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'The `SqlDbBookServiceProvider` class in the `com.packt.sqldb` package is an
    implementation of the interface `BookServiceProvider` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: The implementation of CRUD operations is done by the class `SqlDbBookService`
    in the package `com.packt.sqldb.service`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s compile and run the main module, this time with two service providers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: The first two lines print the class names of the available service providers
    and the third line prints which `BookService` implementation we are using.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a custom modular runtime image using jlink
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Java comes in two flavors:'
  prefs: []
  type: TYPE_NORMAL
- en: Java runtime only also called as JRE - this supports execution of Java applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Java development kit with Java run time also called as JDK - this supports development
    and execution of Java applications.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apart from this, there were 3 compact profiles introduced in Java 8 with the
    aim of providing runtimes with a smaller footprint in order to run on embedded
    and smaller devices.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1157ca16-9696-454f-93f2-1a7f43cd9264.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding image shows the different profiles and the features supported
    by them.
  prefs: []
  type: TYPE_NORMAL
- en: A new tool called `jLink` is introduced in Java 9 which enables the creation
    of modular run time images. These run time images are nothing but a collection
    of a set of modules and their dependencies. There is a Java enhancement proposal,
    JEP 220, governing the structure of this run time image.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will use `jLink` to create a run time image consisting of
    our modules `math.util`, `banking.util`, and `calculator` along with the Jackson
    automatic modules.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the recipe *Creating a simple modular application* we created a simple modular
    application consisting of the following modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '`math.util`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`calculator` - consists of the main class'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will reuse the same set of modules and code to demonstrate the use of jLink
    tool. For the convenience of our readers the code can be found at the location: `chp3/9_jlink_modular_run_time_image`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s compile the modules:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s create the modular JAR for all the modules:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s use `jlink` to create a run time image consisting of the modules: `calculator`,
    `math.util` and its dependencies:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: The run time image gets created at the location specified with `--output` command
    line option.
  prefs: []
  type: TYPE_NORMAL
- en: 'The run time image created under the directory image contains `bin` directory
    among other directories. This `bin` directory consists of a shell script by name
    `calculator`. This can be used to launch our application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: We cannot create run time image of modules which contain automatic modules.
    jLink gives an error if the JAR files are not modular or if there is no `module-info.class`.
  prefs: []
  type: TYPE_NORMAL
- en: Compiling for older platform versions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have at some point used options `-source` and `-target` to create a java
    build. The `-source` option is used to indicate the version of java language accepted
    by the compiler and the `-target` option is used to indicate the version supported
    by the class files. Often we forget to use `-source` option and by default, `javac`
    compiles against the latest available Java version and due to this there are chances
    of newer APIs being used and as a result, the resultant build doesn't run as expected
    on the target version.
  prefs: []
  type: TYPE_NORMAL
- en: So as to overcome the confusion of providing two different command line options,
    a new command line option `--release` is introduced in Java 9\. This acts as a
    substitute to `-source`, `-target` and `-bootclasspath` options. The `-bootclasspath`
    is used to provide the location of the bootstrap class files for a given version
    *N*.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have created a simple module called demo which contains a very simple class
    called `CollectionsDemo` which just puts a few values in the map and iterate over
    them as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s compile and run it to see its output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'The output we get is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: Let's now compile this to run on Java 8 and then run it on Java 8.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As the older version of Java that is, Java 8 and before don''t support modules,
    we would have to get rid of the `module-info.java` while compiling on an older
    version. So what we did was to not include `module-info.java` during our compilation.
    So we compiled using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: You can see that we are using the `--release` option targeting Java 8 and not
    compiling the `module-info.java`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a JAR file because it becomes easier to transport the java build
    instead of copying all the class files:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s run the preceding JAR in Java 9:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s run the JAR in Java 8 :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: What if we did not use the `-release` option while building on Java 9? Let's
    try that as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Compile without using `--release` option and create a JAR out of the resulting
    class files:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s run the JAR on Java 9:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: Works as expected
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s run the JAR on Java 8:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: It is clearly stating that there is a mismatch in the version of the class file.
    As it was compiled for Java 9 (version 53.0), it doesn't run on Java 8 (version
    52.0)
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The data required for compiling to a target older version is stored in the `$JDK_ROOT/lib/ct.sym`
    file. This information is used by the `--release` option to locate the `bootclasspath`. The
    `ct.sym` file is a ZIP file containing stripped-down class files corresponding
    to class files from the target platform versions (taken verbatim from [http://openjdk.java.net/jeps/247](http://openjdk.java.net/jeps/247)).
  prefs: []
  type: TYPE_NORMAL
- en: Creating multirelease JARs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Prior to Java 9, it was hard for the developers of a library to adopt the new
    features introduced in the language without releasing a new library version. But
    in Java 9 multirelease JARs provide such a functionality where you can bundle
    certain class files to run when a higher version of Java is being used.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will show you how to create such a multirelease JAR.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create the required Java code for Java 8 platform. We will add two classes
    `CollectionUtil.java` and `FactoryDemo.java` in the directory `src\8\com\packt`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'We wish to make use of the `Collection` factory methods introduced in Java
    9\. So what we can do is create another sub directory under `src` to place our
    Java 9 related code: `src\9\com\packt` where we will add another `CollectionUtil`
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code uses the Java 9 collection factory methods. Compile the
    source code using the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: Make a note of the `--release` option used to compile the code for different
    java versions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now create the multirelease JAR:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: While creating the JAR we have also mentioned that when running on Java 9 make
    use of the Java 9 specific code.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will run the `mr.jar` on Java 9:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'We will run the `mr.jar` on Java 8:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s look at the layout of the content in `mr.jar`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'The contents of the JAR is as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c8a24d55-58f0-41d8-a6d8-c4b0d1d61727.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The preceding layout we have `META-INF/versions/9` which contains the Java
    9 specific code. Another important thing to note is the contents of the `META-INF/MANIFEST.MF`
    file. Let''s extract the JAR and view its contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: The new manifest attribute `Multi-Release` is used to indicate if the JAR is
    a multirelease JAR or not.
  prefs: []
  type: TYPE_NORMAL
- en: Using Maven to develop a modular application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will look at using Maven, most popular build tool in Java
    ecosystem, to develop a simple modular application. We will reuse the idea we
    had introduced in the Services recipe in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have the following modules in our example:'
  prefs: []
  type: TYPE_NORMAL
- en: '`book.manage`: This is the main module which interacts with the data source'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`book.service`: This is the module which contains the service provider interface'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mongodb.book.service`: This is the module which provides an implementation
    to the service provider interface'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sqldb.book.service`: This is the module which provides another implementation
    to the service provider interface'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the course of this recipe, we will create a maven project and include the
    preceding JDK modules as maven modules. So let's get started.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a folder to contain all the modules. We have called it `12_services_using_maven`
    with the following folder structure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'The `pom.xml` for the parent is:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s create the structure for the `book-service` Maven module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: 'The content of `pom.xml` for `book-service` Maven module is:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: 'The `module-info.java` is:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Book.java` is:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: 'The `BookService.java` is:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: 'The `BookServiceProvider.java` is:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: On similar lines, we define other three Maven modules namely `mongodb-book-service`,
    `sqldb-book-service` and `book-manager`. The code for this can be found at the
    location `chp3/12_services_using_maven`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can compile the classes and build the required JAR files using the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: We have provided `run-with-mongo.*` to use the `mongodb-book-service` as the
    service provider implementation and `run-with-sqldb.*` to use the `sqldb-book-service`
    as the service provider implementation.
  prefs: []
  type: TYPE_NORMAL
- en: The complete code for this recipe can be found at `chp3/12_services_using_maven`.
  prefs: []
  type: TYPE_NORMAL
