<html><head></head><body><div id="sbo-rt-content" class="calibre1"><div class="calibre2" title="Chapter 3. Multithreading and Reactive Programming"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h1 class="title"><a id="ch03" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Chapter 3. Multithreading and Reactive Programming</h1></div></div></div><p class="calibre11">In this lesson, we will look at an approach to support a high performance of an application by programmatically splitting the task between several workers. That was how the pyramids were built 4,500 years ago, and this method has not failed to deliver since then. But there is a limitation on how many laborers can be brought to work on the same project. The shared resources provide a ceiling to how much the workforce can be increased, whether the resources are counted in square feet and gallons (as the living quarters and water in the time of the pyramids) or in gigabytes and gigahertz (as the memory and processing power of a computer).</p><p class="calibre11">Allocation, usage, and limitations of a living space and computer memory are very similar. However, we perceive the processing power of the human workforce and CPU quite differently. Historians tell us that thousands of ancient Egyptians worked on cutting and moving massive stone blocks at the same time. We do not have any problem understanding what they mean even if we know that these workers rotated all the time, some of them resting or attending to other matters temporarily and then coming back to replace the ones who have finished their annual assignment, others died or got injured and were replaced by the new recruits.</p><p class="calibre11">But in case of computer data processing, when we hear about working threads executing at the same time, we automatically assume that they literally do what they are programmed to do in parallel. Only after we look under the hood of such a system we realize that such parallel processing is possible only when the threads are executed each by a different CPU. Otherwise, they time share the same processing power, and we perceive them working at the same time only because the time slots they use are very short--a fraction of the time units we have used in our everyday life. When the threads share the same resource, in computer science we say they do it concurrently.</p><p class="calibre11">In this lesson, we will discuss the ways to increase Java application performance by using the workers (threads) that process data concurrently. We will show how to use threads effectively by pooling them, how to synchronize the concurrently accessed data, how to monitor and tune worker threads at runtime, and how to take advantage of the reactive programming concept.</p><p class="calibre11">But before doing that, let's revisit the basics of creating and running multiple threads in the same Java process.</p><div class="calibre2" title="Prerequisites"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h1 class="title1"><a id="ch03lvl1sec19" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Prerequisites</h1></div></div></div><p class="calibre11">There are principally two ways to create worker threads--by extending the <code class="literal">java.lang.Thread</code> class and by implementing the <code class="literal">java.lang.Runnable</code> interface. While extending the <code class="literal">java.lang.Thread</code> class, we are not required to implement anything:</p><div class="calibre2"><pre class="programlisting">class MyThread extends Thread {
}</pre></div><p class="calibre11">Our <code class="literal">MyThread</code> class inherits the <code class="literal">name</code> property with an automatically generated value and the <code class="literal">start() </code>method. We can run this method and check the <code class="literal">name</code>:</p><div class="calibre2"><pre class="programlisting">System.out.print("demo_thread_01(): ");
MyThread t1 = new MyThread();
t1.start();
System.out.println("Thread name=" + t1.getName());</pre></div><p class="calibre11">If we run this code, the result will be as follows:</p><div class="mediaobject"><img src="Images/03_01.jpg" alt="Prerequisites" class="calibre52"/></div><p class="calibre11">As you can see, the generated <code class="literal">name</code> is <code class="literal">Thread-0</code>. If we created another thread in the same Java process, the <code class="literal">name</code> would be <code class="literal">Thread-1</code> and so on. The <code class="literal">start()</code> method does nothing. The source code shows that it calls the <code class="literal">run()</code> method if such a method is implemented.</p><p class="calibre11">We can add any other method to the <code class="literal">MyThread</code> class as follows:</p><div class="calibre2"><pre class="programlisting">class MyThread extends Thread {
    private double result;
    public MyThread(String name){ super(name); }
    public void calculateAverageSqrt(){
        result =  IntStream.rangeClosed(1, 99999)
                           .asDoubleStream()
                           .map(Math::sqrt)
                           .average()
                           .getAsDouble();
    }
    public double getResult(){ return this.result; }
}</pre></div><p class="calibre11">The <code class="literal">calculateAverageSqrt()</code> method calculates the average square root of the first 99,999 integers and assigns the result to a property that can be accessed anytime. The following code demonstrates how we can use it:</p><div class="calibre2"><pre class="programlisting">System.out.print("demo_thread_02(): ");
MyThread t1 = new MyThread("Thread01");
t1.calculateAverageSqrt();
System.out.println(t1.getName() + ": result=" + t1.getResult());</pre></div><p class="calibre11">Running this brings up the following result:</p><div class="mediaobject"><img src="Images/03_02.jpg" alt="Prerequisites" class="calibre53"/></div><p class="calibre11">As you would expect, the <code class="literal">calculateAverageSqrt()</code> method blocks until the calculations are completed. It was executed in the main thread without it taking advantage of multithreading. To do this, we move the functionality in the <code class="literal">run()</code> method:</p><div class="calibre2"><pre class="programlisting">class MyThread01 extends Thread {
    private double result;
    public MyThread01(String name){ super(name); }
    public void run(){
        result =  IntStream.rangeClosed(1, 99999)
                           .asDoubleStream()
                           .map(Math::sqrt)
                           .average()
                           .getAsDouble();
    }
    public double getResult(){ return this.result; }
}</pre></div><p class="calibre11">Now we call the <code class="literal">start()</code> method again, as in the first example and expect the result to be calculated:</p><div class="calibre2"><pre class="programlisting">System.out.print("demo_thread_03(): ");
MyThread01 t1 = new MyThread01("Thread01");
t1.start();
System.out.println(t1.getName() + ": result=" + t1.getResult());</pre></div><p class="calibre11">However, the output of this code may surprise you:</p><div class="mediaobject"><img src="Images/03_03.jpg" alt="Prerequisites" class="calibre54"/></div><p class="calibre11">This means that the main thread accessed (and printed) the <code class="literal">t1.getResult()</code> function before the new <code class="literal">t1</code> thread finished its calculations. We can experiment and change the implementation of the <code class="literal">run()</code> method to see if the <code class="literal">t1.getResult()</code> function can get a partial result:</p><div class="calibre2"><pre class="programlisting">public void run() {
    for (int i = 1; i &lt; 100000; i++) {
        double s = Math.sqrt(1. * i);
        result = result + s;
    }
    result = result / 99999;
}</pre></div><p class="calibre11">However, if we run the <code class="literal">demo_thread_03()</code> method again, the result remains the same:</p><div class="mediaobject"><img src="Images/03_04.jpg" alt="Prerequisites" class="calibre54"/></div><p class="calibre11">It takes time to create a new thread and get it going. Meanwhile, the <code class="literal">main</code> thread calls the <code class="literal">t1.getResult()</code> function immediately, thus getting no results yet.</p><p class="calibre11">To give the new (child) thread time to complete the calculations, we add the following code:</p><div class="calibre2"><pre class="programlisting">try {
     t1.join();
 } catch (InterruptedException e) { 
     e.printStackTrace();
 }</pre></div><p class="calibre11">The <code class="literal">join()</code> method tells the current thread to wait until the <code class="literal">t1</code> thread is finished executing. Let's run the following snippet of code:</p><div class="calibre2"><pre class="programlisting">System.out.print("demo_thread_04(): ");
MyThread01 t1 = new MyThread01("Thread01");
t1.start();
try {
    t1.join();
} catch (InterruptedException e) { 
    e.printStackTrace();
}
System.out.println(t1.getName() 
                + ": result=" + t1.getResult());
System.out.println("Thread name=" 
            + Thread.currentThread().getName());</pre></div><p class="calibre11">You have noticed that we have paused the main thread by 100 ms and added printing of the current thread name, to illustrate what we mean by <code class="literal">main</code> thread, the name that is assigned automatically to the thread that executes the <code class="literal">main()</code> method. The output of the previous code is as follows:</p><div class="mediaobject"><img src="Images/03_05.jpg" alt="Prerequisites" class="calibre55"/></div><p class="calibre11">The delay of 100 ms was enough for the <code class="literal">t1</code> thread to finish the calculations. That was the first of two ways of creating threads for multithreaded calculation. The second way is to implement the <code class="literal">Runnable</code> interface. It may be the only way possible if the class that does calculations already extends some other class and you cannot or don't want to use composition for some reasons. The <code class="literal">Runnable</code> interface is a functional interface (has only one abstract method) with the <code class="literal">run()</code> method that has to be implemented:</p><div class="calibre2"><pre class="programlisting">@FunctionalInterface
public interface Runnable {
    /**
     * When an object implementing interface &lt;code&gt;Runnable&lt;/code&gt; is used
     * to create a thread, starting the thread causes the object's
     * &lt;code&gt;run&lt;/code&gt; method to be called in that separately executing
     * thread.
     */
    public abstract void run();</pre></div><p class="calibre11">We implement this interface in the <code class="literal">MyRunnable</code> class:</p><div class="calibre2"><pre class="programlisting">class MyRunnable01 implements Runnable {
    private String id;
    private double result;
    public MyRunnable01(int id) {
        this.id = String.valueOf(id);
    }
    public String getId() { return this.id; }
    public double getResult() { return this.result; }
    public void run() {
        result = IntStream.rangeClosed(1, 99999)
                          .asDoubleStream()
                          .map(Math::sqrt)
                          .average()
                          .getAsDouble();
    }
}</pre></div><p class="calibre11">It has the same functionality as the <code class="literal">Thread01</code> class earlier plus we have added id that allows identifying the thread if necessary since the <code class="literal">Runnable</code> interface does not have the built-in <code class="literal">getName()</code> method like the <code class="literal">Thread</code> class has.</p><p class="calibre11">Similarly, if we execute this class without pausing the <code class="literal">main</code> thread, like this:</p><div class="calibre2"><pre class="programlisting">System.out.print("demo_runnable_01(): ");
MyRunnable01 myRunnable = new MyRunnable01(1);
Thread t1 = new Thread(myRunnable);
t1.start();
System.out.println("Worker " + myRunnable.getId() 
           + ": result=" + myRunnable.getResult());</pre></div><p class="calibre11">The output will be as follows:</p><div class="mediaobject"><img src="Images/03_06.jpg" alt="Prerequisites" class="calibre56"/></div><p class="calibre11">We will now add the pause as follows:</p><div class="calibre2"><pre class="programlisting">System.out.print("demo_runnable_02(): ");
MyRunnable01 myRunnable = new MyRunnable01(1);
Thread t1 = new Thread(myRunnable);
t1.start();
try {
    t1.join();
} catch (InterruptedException e) { 
    e.printStackTrace();
}
System.out.println("Worker " + myRunnable.getId() 
           + ": result=" + myRunnable.getResult());</pre></div><p class="calibre11">The result is exactly the same as the one produced by the <code class="literal">Thread01</code> class:</p><div class="mediaobject"><img src="Images/3_07.jpg" alt="Prerequisites" class="calibre57"/></div><p class="calibre11">All the previous examples stored the generated result in the class property. But it is not always the case. Typically, the worker thread either passes its value to another thread or stores it in a database or somewhere else externally. In such a case, one can take advantage of the <code class="literal">Runnable</code> interface being a functional interface and pass the necessary processing function into a new thread as a lambda expression:</p><div class="calibre2"><pre class="programlisting">System.out.print("demo_lambda_01(): ");
String id = "1";
Thread t1 = 
    new Thread(() -&gt; IntStream.rangeClosed(1, 99999)
         .asDoubleStream().map(Math::sqrt).average()
         .ifPresent(d -&gt; System.out.println("Worker " 
                            + id + ": result=" + d)));
t1.start();
try {
    t1.join();
} catch (InterruptedException e) { 
    e.printStackTrace();
}</pre></div><p class="calibre11">The result is going to be exactly the same, as shown here:</p><div class="mediaobject"><img src="Images/03_08.jpg" alt="Prerequisites" class="calibre58"/></div><p class="calibre11">Depending on the preferred style, you can re-arrange the code and isolate the lambda expression in a variable, as follows:</p><div class="calibre2"><pre class="programlisting">Runnable r = () -&gt; IntStream.rangeClosed(1, 99999)
       .asDoubleStream().map(Math::sqrt).average()
      .ifPresent(d -&gt; System.out.println("Worker " 
                           + id + ": result=" + d));
Thread t1 = new Thread(r);</pre></div><p class="calibre11">Alternatively, you can put the lambda expression in a separate method:</p><div class="calibre2"><pre class="programlisting">void calculateAverage(String id) {
    IntStream.rangeClosed(1, 99999)
        .asDoubleStream().map(Math::sqrt).average()
        .ifPresent(d -&gt; System.out.println("Worker " 
                            + id + ": result=" + d));
}
void demo_lambda_03() {
    System.out.print("demo_lambda_03(): ");
    Thread t1 = new Thread(() -&gt; calculateAverage("1"));
    ...
}</pre></div><p class="calibre11">The result is going to be the same, as shown here:</p><div class="mediaobject"><img src="Images/03_09.jpg" alt="Prerequisites" class="calibre59"/></div><p class="calibre11">With the basic understanding of threads creation in place, we can now return to the discussion about using the multithreading for building a high-performance application. In other words, after we understand the abilities and resources needed for each worker, we can now talk about logistics of bringing in many of them for such a big-scale project as the Great Pyramid of Giza.</p><p class="calibre11">To write code that manages the life cycle of worker threads and their access to the shared resources is possible, but it is quite the same from one application to another. That's why, after several releases of Java, the thread management plumbing became part of the standard JDK library as the <code class="literal">java.util.concurrent</code> package. This package has a wealth of interfaces and classes that support multithreading and concurrency. We will discuss how to use most of this functionality in the subsequent sections, while talking about thread pools, threads monitoring, thread synchronization, and the related subjects.</p></div></div></div>



  
<div id="sbo-rt-content" class="calibre1"><div class="calibre2" title="Thread Pools"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h1 class="title1"><a id="ch03lvl1sec20" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Thread Pools</h1></div></div></div><p class="calibre11">In this section, we will look into the <code class="literal">Executor</code> interfaces and their implementations provided in the <code class="literal">java.util.concurrent</code> package. They encapsulate thread management and minimize the time an application developer spends on the writing code related to threads' life cycles.</p><p class="calibre11">There are three <code class="literal">Executor</code> interfaces defined in the <code class="literal">java.util.concurrent</code> package. The first is the base <code class="literal">Executor</code> interface has only one <code class="literal">void execute(Runnable r)</code> method in it. It basically replaces the following:</p><div class="calibre2"><pre class="programlisting">Runnable r = ...;
(new Thread(r)).start()</pre></div><p class="calibre11">However, we can also avoid a new thread creation by getting it from a pool.</p><p class="calibre11">The second is the <code class="literal">ExecutorService</code> interface extends <code class="literal">Executor</code> and adds the following groups of methods that manage the life cycle of the worker threads and of the executor itself:</p><div class="calibre2"><ul class="itemizedlist"><li class="listitem"><code class="literal">submit()</code>: Place in the queue for the execution of an object of the interface <code class="literal">Runnable</code> or interface <code class="literal">Callable</code> (allows the worker thread to return a value); return object of <code class="literal">Future</code> interface, which can be used to access the value returned by the <code class="literal">Callable</code> and to manage the status of the worker thread</li><li class="listitem"><code class="literal">invokeAll()</code>: Place in the queue for the execution of a collection of interface <code class="literal">Callable</code> objects return, list of <code class="literal">Future</code> objects when all the worker threads are complete (there is also an overloaded <code class="literal">invokeAll()</code> method with timeout)</li><li class="listitem"><code class="literal">invokeAny()</code>: Place in the queue for the execution of a collection of interface <code class="literal">Callable</code> objects; return one <code class="literal">Future</code> object of any of the worker threads, which has completed (there is also an overloaded <code class="literal">invokeAny()</code> method with timeout)</li></ul></div><p class="calibre11">Methods that manage the worker threads status and the service itself:</p><div class="calibre2"><ul class="itemizedlist"><li class="listitem"><code class="literal">shutdown()</code>: This prevents new worker threads from being submitted to the service</li><li class="listitem"><code class="literal">isShutdown()</code>: This checks whether the shutdown of the executor was initiated</li><li class="listitem"><code class="literal">awaitTermination(long timeout, TimeUnit timeUnit)</code>: This waits until all worker threads have completed execution after a shutdown request, or the timeout occurs, or the current thread is interrupted, whichever happens first</li><li class="listitem"><code class="literal">isTerminated()</code>: This checks whether all the worker threads have completed after the shutdown was initiated; it never returns <code class="literal">true</code> unless either <code class="literal">shutdown()</code> or <code class="literal">shutdownNow()</code> was called first</li><li class="listitem"><code class="literal">shutdownNow()</code>: This interrupts each worker thread that is not completed; a worker thread should be written so that it checks its own status (using <code class="literal">Thread.currentThread().isInterrupted()</code>, for example) periodically and gracefully shuts down on its own; otherwise, it will continue running even after <code class="literal">shutdownNow()</code> was called</li></ul></div><p class="calibre11">The third interface is <code class="literal">ScheduledExecutorService</code> that extends <code class="literal">ExecutorService</code> and adds methods that allow scheduling of the execution (one-time and periodic one) of the worker threads.</p><p class="calibre11">A pool-based implementation of <code class="literal">ExecutorService</code> can be created using the <code class="literal">java.util.concurrent.ThreadPoolExecutor</code> or <code class="literal">java.util.concurrent.ScheduledThreadPoolExecutor</code> class. There is also a <code class="literal">java.util.concurrent.Executors</code> factory class that covers most of the practical cases. So, before writing a custom code for worker threads pool creation, we highly recommend looking into using the following factory methods of the <code class="literal">java.util.concurrent.Executors</code> class:</p><div class="calibre2"><ul class="itemizedlist"><li class="listitem"><code class="literal">newSingleThreadExecutor()</code>: This creates an <code class="literal">ExecutorService</code> (pool) instance that executes worker threads sequentially</li><li class="listitem"><code class="literal">newFixedThreadPool()</code>: This creates a thread pool that reuses a fixed number of worker threads; if a new task is submitted when all the worker threads are still executing, it will be set into the queue until a worker thread is available</li><li class="listitem"><code class="literal">newCachedThreadPool()</code>: This creates a thread pool that adds a new thread as needed, unless there is an idle thread created before; threads that have been idle for sixty seconds are removed from the cache</li><li class="listitem"><code class="literal">newScheduledThreadPool()</code>: This creates a thread pool of a fixed size that can schedule commands to run after a given delay, or to execute periodically</li><li class="listitem"><code class="literal">newSingleThreadScheduledExecutor()</code>: This creates a single-threaded executor that can schedule commands to run after a given delay, or to execute periodically</li><li class="listitem"><code class="literal">newWorkStealingThreadPool()</code>: This creates a thread pool that uses the same work-stealing mechanism used by <code class="literal">ForkJoinPool</code>, which is particularly useful in case the worker threads generate other threads, such as in recursive algorithms</li></ul></div><p class="calibre11">Each of these methods has an overloaded version that allows passing in a <code class="literal">ThreadFactory</code> that is used to create a new thread when needed. Let's see how it all works in a code sample.</p><p class="calibre11">First, we create a <code class="literal">MyRunnable02</code> class that implements <code class="literal">Runnable</code>—our future worker threads:</p><div class="calibre2"><pre class="programlisting">class MyRunnable02 implements Runnable {
    private String id;
    public MyRunnable02(int id) {
        this.id = String.valueOf(id);
    }
    public String getId(){ return this.id; }
    public void run() {
        double result = IntStream.rangeClosed(1, 100)
           .flatMap(i -&gt; IntStream.rangeClosed(1, 99999))
           .takeWhile(i -&gt; 
                 !Thread.currentThread().isInterrupted())
           .asDoubleStream()
           .map(Math::sqrt)
           .average()
           .getAsDouble();
        if(Thread.currentThread().isInterrupted()){
            System.out.println(" Worker " + getId() 
                       + ": result=ignored: " + result);
        } else {
            System.out.println(" Worker " + getId() 
                                + ": result=" + result);
        }
}</pre></div><p class="calibre11">Notice the important difference of this implementation from the previous examples--the <code class="literal">takeWhile(i -&gt; !Thread.currentThread().isInterrupted())</code> operation allows the stream flowing as long as the thread worker status is not set to interrupted, which happens when the <code class="literal">shutdownNow()</code> method is called. As soon as the predicate of the <code class="literal">takeWhile()</code> returns <code class="literal">false</code> (the worker thread is interrupted), the thread stops producing the result (just ignores the current <code class="literal">result</code> value). In a real system, it would equate to skipping storing <code class="literal">result</code> value in the database, for example.</p><p class="calibre11">It is worth noting here that using the <code class="literal">interrupted()</code> status method for checking the thread status in the preceding code may lead to inconsistent results. Since the <code class="literal">interrupted()</code> method returns the correct state value and then clears the thread state, the second call to this method (or the call to the method <code class="literal">isInterrupted()</code> after the call to the method <code class="literal">interrupted()</code>) always returns <code class="literal">false</code>.</p><p class="calibre11">Although it is not the case in this code, we would like to mention here a mistake some developers make while implementing <code class="literal">try/catch</code> block in a worker thread. For example, if the worker needs to pause and wait for an interrupt signal, the code often looks like this:</p><div class="calibre2"><pre class="programlisting">try {
    Thread.currentThread().wait();
} catch (InterruptedException e) {}
// Do what has to be done</pre></div><p class="calibre11">The problem with the preceding snippet is that the thread status never becomes interrupted, while the higher level code might be monitoring the worker thread and changes behavior depending on whether the worker has been interrupted or not.</p><p class="calibre11">The better implementation is as follows:</p><div class="calibre2"><pre class="programlisting">try {
    Thread.currentThread().wait();
} catch (InterruptedException e) {
    Thread.currentThread().interrupt();
}
// Do what has to be done</pre></div><p class="calibre11">This way the status <code class="literal">interrupted</code> is set on the thread and can be checked later by the <code class="literal">isInterrupted()</code> method. To be fair, in many applications, once the thread is interrupted, its code is not checked again. But setting the correct state is a good practice, especially in the cases when you are not the author of the client code.</p><p class="calibre11">In the snippet of code with the <code class="literal">join()</code> method, we did not need to do that because that was the main code (the highest level code) that had to be paused.</p><p class="calibre11">Now we can show how to execute the earlier <code class="literal">MyRunnable02</code> class with a cached pool implementation of the <code class="literal">ExecutiveService</code> pool (other types of thread pool are used similarly). First, we create the pool, submit three instances of the <code class="literal">MyRunnable02</code> class for execution and shut down the pool:</p><div class="calibre2"><pre class="programlisting">ExecutorService pool = Executors.newCachedThreadPool();
IntStream.rangeClosed(1, 3).
       forEach(i -&gt; pool.execute(new MyRunnable02(i)));
System.out.println("Before shutdown: isShutdown()=" 
          + pool.isShutdown() + ", isTerminated()=" 
                                + pool.isTerminated());
pool.shutdown(); // New threads cannot be submitted
System.out.println("After  shutdown: isShutdown()=" 
          + pool.isShutdown() + ", isTerminated()=" 
                                + pool.isTerminated());</pre></div><p class="calibre11">If we run these lines, we will see the following output:</p><div class="mediaobject"><img src="Images/03_10.jpg" alt="Thread Pools" class="calibre60"/></div><p class="calibre11">No surprises here! The <code class="literal">isShutdown()</code> method returns a <code class="literal">false</code> value before the <code class="literal">shutdown()</code> method is called and a <code class="literal">true</code> value afterward. The <code class="literal">isTerminated()</code> method returns a <code class="literal">false</code> value, because none of the worker threads has completed yet.</p><p class="calibre11">Let's test the <code class="literal">shutdown()</code> method by adding the following code after it:</p><div class="calibre2"><pre class="programlisting">try {
    pool.execute(new MyRunnable02(100));
} catch(RejectedExecutionException ex){
    System.err.println("Cannot add another worker-thread to the service queue:\n" + ex.getMessage());
}</pre></div><p class="calibre11">The output will now have the following message (the screenshot would be either too big for this page or not readable when fitting):</p><div class="calibre2"><pre class="programlisting">Cannot add another worker-thread to the service queue:
Task com.packt.java9hp.ch09_threads.MyRunnable02@6f7fd0e6 
    rejected from java.util.concurrent.ThreadPoolExecutor
    [Shutting down, pool size = 3, active threads = 3, 
    queued tasks = 0, completed tasks = 0]</pre></div><p class="calibre11">As expected, after the <code class="literal">shutdown()</code> method is called, no more worker threads can be added to the pool.</p><p class="calibre11">Now, let's see what we can do after the shutdown was initiated:</p><div class="calibre2"><pre class="programlisting">long timeout = 100;
TimeUnit timeUnit = TimeUnit.MILLISECONDS;
System.out.println("Waiting for all threads completion " 
                     + timeout + " " + timeUnit + "...");
// Blocks until timeout or all threads complete execution
boolean isTerminated = 
                pool.awaitTermination(timeout, timeUnit);
System.out.println("isTerminated()=" + isTerminated);
if (!isTerminated) {
    System.out.println("Calling shutdownNow()...");
    List&lt;Runnable&gt; list = pool.shutdownNow(); 
    printRunningThreadIds(list);
    System.out.println("Waiting for threads completion " 
                     + timeout + " " + timeUnit + "...");
    isTerminated = 
                pool.awaitTermination(timeout, timeUnit);
    if (!isTerminated){
        System.out.println("Some threads are running...");
    }
    System.out.println("Exiting.");
}</pre></div><p class="calibre11">The <code class="literal">printRunningThreadIds()</code> method looks like this:</p><div class="calibre2"><pre class="programlisting">void printRunningThreadIds(List&lt;Runnable&gt; l){
    String list = l.stream()
            .map(r -&gt; (MyRunnable02)r)
            .map(mr -&gt; mr.getId())
            .collect(Collectors.joining(","));
    System.out.println(l.size() + " thread"
       + (l.size() == 1 ? " is" : "s are") + " running"
            + (l.size() &gt; 0 ? ": " + list : "") + ".");
}</pre></div><p class="calibre11">The output of the preceding code will be as follows:</p><div class="mediaobject"><img src="Images/03_11.jpg" alt="Thread Pools" class="calibre61"/></div><p class="calibre11">This means that 100 ms was enough for each worker thread to complete the calculations. (Notice, if you try to reproduce this data on your computer, the results might be slightly different because of the difference in performance, so you would need to adjust the timeout.)</p><p class="calibre11">When we have decreased the wait time to 75 ms, the output became as follows:</p><div class="mediaobject"><img src="Images/03_12.jpg" alt="Thread Pools" class="calibre62"/></div><p class="calibre11">The 75 ms on our computer was not enough to let all the threads complete, so they were interrupted by <code class="literal">shutdownNow()</code> and their partial results were ignored.</p><p class="calibre11">Let's now remove the check of the interrupted status in the <code class="literal">MyRunnable01</code> class:</p><div class="calibre2"><pre class="programlisting">class MyRunnable02 implements Runnable {
    private String id;
    public MyRunnable02(int id) {
        this.id = String.valueOf(id);
    }
    public String getId(){ return this.id; }
    public void run() {
        double result = IntStream.rangeClosed(1, 100)
           .flatMap(i -&gt; IntStream.rangeClosed(1, 99999))
           .asDoubleStream()
           .map(Math::sqrt)
           .average()
           .getAsDouble();
        System.out.println(" Worker " + getId() 
                                + ": result=" + result);
}</pre></div><p class="calibre11">Without the check, even if we decrease the timeout to 1 ms, the result will be as follows:</p><div class="mediaobject"><img src="Images/03_13.jpg" alt="Thread Pools" class="calibre63"/></div><p class="calibre11">That is because the worker threads have never noticed that somebody tried to interrupt them and completed their assigned calculations. This last test demonstrates the importance of watching for the interrupted state in a work thread in order to avoid many possible problems, namely, data corruption and memory leak.</p><p class="calibre11">The demonstrated cached pool works fine and poses no problem if the worker threads perform short tasks and their number cannot grow excessively large. If you need to have more control over the max number of worker threads running at any time, use the fixed size thread pool. We will discuss how to choose the pool size in one of the following sections of this lesson.</p><p class="calibre11">The single-thread pool is a good fit for executing tasks in a certain order or in the case when each of them requires so many resources that cannot be executed in parallel with another. Yet another case for using a single-thread execution would be for workers that modify the same data, but the data cannot be protected from the parallel access another way. The thread synchronization will be discussed in more detail in one of the following sections of this lesson, too.</p><p class="calibre11">In our sample code, so far we have only included the <code class="literal">execute()</code> method of the <code class="literal">Executor</code> interface. We will demonstrate the other methods of the <code class="literal">ExecutorService</code> pool in the following section while discussing threads monitoring.</p><p class="calibre11">And the last remark in this section. The worker threads are not required to be objects of the same class. They may represent completely different functionality and still be managed by one pool.</p></div></div>



  
<div id="sbo-rt-content" class="calibre1"><div class="calibre2" title="Monitoring Threads"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h1 class="title1"><a id="ch03lvl1sec21" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Monitoring Threads</h1></div></div></div><p class="calibre11">There are two ways to monitor threads, programmatically and using the external tools. We have already seen how the result of a worker calculation could be checked. Let's revisit that code. We will also slightly modify our worker implementation:</p><div class="calibre2"><pre class="programlisting">class MyRunnable03 implements Runnable {
  private String name;
  private double result;
  public String getName(){ return this.name; }
  public double getResult() { return this.result; }
  public void run() {
    this.name = Thread.currentThread().getName();
    double result = IntStream.rangeClosed(1, 100)
      .flatMap(i -&gt; IntStream.rangeClosed(1, 99999))
      .takeWhile(i -&gt; !Thread.currentThread().isInterrupted())
      .asDoubleStream().map(Math::sqrt).average().getAsDouble();
    if(!Thread.currentThread().isInterrupted()){
      this.result = result;
    }
  }
}</pre></div><p class="calibre11">For the worker thread identification, instead of custom ID, we now use the thread name assigned automatically at the time of the execution (that is why we assign the <code class="literal">name</code> property in the <code class="literal">run()</code> method that is called in the context of the execution when the thread acquires its name). The new class <code class="literal">MyRunnable03</code> can be used like this:</p><div class="calibre2"><pre class="programlisting">void demo_CheckResults() {
    ExecutorService pool = Executors.newCachedThreadPool();
    MyRunnable03 r1 = new MyRunnable03();
    MyRunnable03 r2 = new MyRunnable03();
    pool.execute(r1);
    pool.execute(r2);
    try {
        t1.join();
    } catch (InterruptedException e) { 
        e.printStackTrace();
    }
    System.out.println("Worker " + r1.getName() + ": result=" + r1.getResult());
    System.out.println("Worker " + r2.getName() + ": result=" + r2.getResult());
    shutdown(pool);
}</pre></div><p class="calibre11">The <code class="literal">shutdown()</code> method contains the following code:</p><div class="calibre2"><pre class="programlisting">void shutdown(ExecutorService pool) {
    pool.shutdown();
    try {
        if(!pool.awaitTermination(1, TimeUnit.SECONDS)){
            pool.shutdownNow();
        }
    } catch (InterruptedException ie) {}
}</pre></div><p class="calibre11">If we run the preceding code, the output will be as follows:</p><div class="mediaobject"><img src="Images/03_14.jpg" alt="Monitoring Threads" class="calibre64"/></div><p class="calibre11">If the result on your computer is different, try to increase the input value to the <code class="literal">sleepMs()</code> method.</p><p class="calibre11">Another way to get information about the application worker threads is by using the <code class="literal">Future</code> interface. We can access this interface using the <code class="literal">submit()</code> method of the <code class="literal">ExecutorService</code> pool, instead of the <code class="literal">execute()</code>, <code class="literal">invokeAll()</code>, or <code class="literal">invokeAny()</code> methods. This code shows how to use the <code class="literal">submit()</code> method:</p><div class="calibre2"><pre class="programlisting">ExecutorService pool = Executors.newCachedThreadPool();
Future f1 = pool.submit(new MyRunnable03());
Future f2 = pool.submit(new MyRunnable03());
printFuture(f1, 1);
printFuture(f2, 2);
shutdown(pool);</pre></div><p class="calibre11">The <code class="literal">printFuture()</code> method has the following implementation:</p><div class="calibre2"><pre class="programlisting">void printFuture(Future future, int id) {
    System.out.println("printFuture():");
    while (!future.isCancelled() &amp;&amp; !future.isDone()){
        System.out.println("    Waiting for worker " 
                                + id + " to complete...");
        sleepMs(10);
    }
    System.out.println("    Done...");
}</pre></div><p class="calibre11">The <code class="literal">sleepMs()</code> method contains the following code:</p><div class="calibre2"><pre class="programlisting">void sleepMs(int sleepMs) {
    try {
        TimeUnit.MILLISECONDS.sleep(sleepMs);
    } catch (InterruptedException e) {}
}</pre></div><p class="calibre11">We prefer this implementation instead of the traditional <code class="literal">Thread.sleep()</code> because it is explicit about the time units used.</p><p class="calibre11">If we execute the previous code, the result will be similar to the following:</p><div class="mediaobject"><img src="Images/03_15.jpg" alt="Monitoring Threads" class="calibre65"/></div><p class="calibre11">The <code class="literal">printFuture()</code> method has blocked the main thread execution until the first thread has completed. Meanwhile, the second thread has completed too. If we call the <code class="literal">printFuture()</code> method after the <code class="literal">shutdown()</code> method, both the threads would complete by that time already because we have set a wait time of 1 second (see the <code class="literal">pool.awaitTermination()</code> method), which is enough for them to finish their job:</p><div class="mediaobject"><img src="Images/03_16.jpg" alt="Monitoring Threads" class="calibre66"/></div><p class="calibre11">If you think it is not much information from a threads monitoring point of view, the <code class="literal">java.util.concurrent</code> package provides more capabilities via the <code class="literal">Callable</code> interface. It is a functional interface that allows returning any object (containing results of the worker thread calculations) via the <code class="literal">Future</code> object using <code class="literal">ExecutiveService</code> methods--<code class="literal">submit()</code>, <code class="literal">invokeAll()</code>, and <code class="literal">invokeAny()</code>. For example, we can create a class that contains the result of a worker thread:</p><div class="calibre2"><pre class="programlisting">class Result {
    private double result;
    private String workerName;
    public Result(String workerName, double result) {
        this.result = result;
        this.workerName = workerName;
    }
    public String getWorkerName() { return workerName; }
    public double getResult() { return result;}
}</pre></div><p class="calibre11">We have included the name of the worker thread too for monitoring which thread generated the result that is presented. The class that implements the <code class="literal">Callable</code> interface may look like this:</p><div class="calibre2"><pre class="programlisting">class MyCallable01&lt;T&gt; implements Callable {
  public Result call() {
    double result = IntStream.rangeClosed(1, 100)
       .flatMap(i -&gt; IntStream.rangeClosed(1, 99999))
       .takeWhile(i -&gt; !Thread.currentThread().isInterrupted())
       .asDoubleStream().map(Math::sqrt).average().getAsDouble();

    String workerName = Thread.currentThread().getName();
    if(Thread.currentThread().isInterrupted()){
        return new Result(workerName, 0);
    } else {
        return new Result(workerName, result);
    }
  }
}</pre></div><p class="calibre11">And here is the code that uses the <code class="literal">MyCallable01</code> class:</p><div class="calibre2"><pre class="programlisting">ExecutorService pool = Executors.newCachedThreadPool();
Future f1 = pool.submit(new MyCallable01&lt;Result&gt;());
Future f2 = pool.submit(new MyCallable01&lt;Result&gt;());
printResult(f1, 1);
printResult(f2, 2);
shutdown(pool);</pre></div><p class="calibre11">The <code class="literal">printResult()</code> method contains the following code:</p><div class="calibre2"><pre class="programlisting">void printResult(Future&lt;Result&gt; future, int id) {
    System.out.println("printResult():");
    while (!future.isCancelled() &amp;&amp; !future.isDone()){
        System.out.println("    Waiting for worker " 
                              + id + " to complete...");
        sleepMs(10);
    }
    try {
        Result result = future.get(1, TimeUnit.SECONDS);
        System.out.println("    Worker " 
                + result.getWorkerName() + ": result = " 
                                   + result.getResult());
    } catch (Exception ex) {
        ex.printStackTrace();
    }
}</pre></div><p class="calibre11">The output of this code may look like this:</p><div class="mediaobject"><img src="Images/03_17.jpg" alt="Monitoring Threads" class="calibre67"/></div><p class="calibre11">The earlier output shows, as in the previous examples, that the <code class="literal">printResult()</code> method waits until the first of the worker threads finishes, so the second thread manages to finish its job at the same time. The advantage of using <code class="literal">Callable</code>, as you can see, is that we can retrieve the actual result from a <code class="literal">Future</code> object, if we need it.</p><p class="calibre11">The usage of the <code class="literal">invokeAll()</code> and <code class="literal">invokeAny()</code> methods looks similar:</p><div class="calibre2"><pre class="programlisting">ExecutorService pool = Executors.newCachedThreadPool();
try {
    List&lt;Callable&lt;Result&gt;&gt; callables = 
              List.of(new MyCallable01&lt;Result&gt;(), 
                           new MyCallable01&lt;Result&gt;());
    List&lt;Future&lt;Result&gt;&gt; futures = 
                             pool.invokeAll(callables);
    printResults(futures);
} catch (InterruptedException e) {
    e.printStackTrace();
}
shutdown(pool);</pre></div><p class="calibre11">The <code class="literal">printResults()</code> method is using the <code class="literal">printResult()</code> method, which you already know:</p><div class="calibre2"><pre class="programlisting">void printResults(List&lt;Future&lt;Result&gt;&gt; futures) {
    System.out.println("printResults():");
    int i = 1;
    for (Future&lt;Result&gt; future : futures) {
        printResult(future, i++);
    }
}</pre></div><p class="calibre11">If we run the preceding code, the output will be as follows:</p><div class="mediaobject"><img src="Images/03_18.jpg" alt="Monitoring Threads" class="calibre68"/></div><p class="calibre11">As you can see, there is no more waiting for the worker thread completing the job. That is so because the <code class="literal">invokeAll()</code> method returns the collection of the <code class="literal">Future</code> object after all the jobs have completed.</p><p class="calibre11">The <code class="literal">invokeAny()</code> method behaves similarly. If we run the following code:</p><div class="calibre2"><pre class="programlisting">System.out.println("demo_InvokeAny():");
ExecutorService pool = Executors.newCachedThreadPool();
try {
    List&lt;Callable&lt;Result&gt;&gt; callables = 
                   List.of(new MyCallable01&lt;Result&gt;(), 
                            new MyCallable01&lt;Result&gt;());
    Result result = pool.invokeAny(callables);
    System.out.println("    Worker " 
                        + result.getWorkerName()
                  + ": result = " + result.getResult());
} catch (InterruptedException | ExecutionException e) {
    e.printStackTrace();
}
shutdown(pool);</pre></div><p class="calibre11">The following will be the output:</p><div class="mediaobject"><img src="Images/03_19.jpg" alt="Monitoring Threads" class="calibre69"/></div><p class="calibre11">These are the basic techniques for monitoring the threads programmatically, but one can easily extend our examples to cover more complicated cases tailored to the needs of a specific application. In <a class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2" href="ch05.xhtml" title="Chapter 5. Making Use of New APIs to Improve Your Code">Lesson 5</a>, <span class="emphasis"><em class="calibre12">Making Use of New APIs to Improve Your Code</em></span>, we will also discuss another way to programmatically monitor worker threads using the <code class="literal">java.util.concurrent.CompletableFuture</code> class introduced in JDK 8 and extended in JDK 9.</p><p class="calibre11">If necessary, it is possible to get information not only about the application worker threads, but also about all other threads in the JVM process using the <code class="literal">java.lang.Thread</code> class:</p><div class="calibre2"><pre class="programlisting">void printAllThreads() {
    System.out.println("printAllThreads():");
    Map&lt;Thread, StackTraceElement[]&gt; map = Thread.getAllStackTraces();
    for(Thread t: map.keySet()){
        System.out.println("    " + t);
    }</pre></div><p class="calibre11">Now, let's call this method as follows:</p><div class="calibre2"><pre class="programlisting">void demo_CheckResults() {
    ExecutorService pool = Executors.newCachedThreadPool();
    MyRunnable03 r1 = new MyRunnable03();
    MyRunnable03 r2 = new MyRunnable03();
    pool.execute(r1);
    pool.execute(r2);
    sleepMs(1000);
    printAllThreads();
    shutdown(pool);
}</pre></div><p class="calibre11">The result looks like this:</p><div class="mediaobject"><img src="Images/03_20.jpg" alt="Monitoring Threads" class="calibre70"/></div><p class="calibre11">We took advantage of the <code class="literal">toString()</code> method of the <code class="literal">Thread</code> class that prints only the thread name, priority, and the thread group it belongs to. And we see the two application threads we have created explicitly (in addition to the <code class="literal">main</code> thread) in the list under the names <code class="literal">pool-1-thread-1</code> and <code class="literal">pool-1-thread-2</code>. But if we call the <code class="literal">printAllThreads()</code> method after calling the <code class="literal">shutdown()</code> method, the output will be as follows:</p><div class="mediaobject"><img src="Images/03_21.jpg" alt="Monitoring Threads" class="calibre71"/></div><p class="calibre11">We do not see the <code class="literal">pool-1-thread-1</code> and <code class="literal">pool-1-thread-2</code> threads in the list anymore because the <code class="literal">ExecutorService</code> pool has been shut down.</p><p class="calibre11">We could easily add the stack trace information pulled from the same map:</p><div class="calibre2"><pre class="programlisting">void printAllThreads() {
    System.out.println("printAllThreads():");
    Map&lt;Thread, StackTraceElement[]&gt; map 
                               = Thread.getAllStackTraces();
    for(Thread t: map.keySet()){
        System.out.println("   " + t);
        for(StackTraceElement ste: map.get(t)){
            System.out.println("        " + ste);
        }
    }
}</pre></div><p class="calibre11">However, that would take too much space on the book page. In <a class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2" href="ch05.xhtml" title="Chapter 5. Making Use of New APIs to Improve Your Code">Lesson 5</a>, <span class="emphasis"><em class="calibre12">Making Use of New APIs to Improve Your Code</em></span>, while presenting new Java capabilities that came with JDK 9, we will also discuss a better way to access a stack trace via the <code class="literal">java.lang.StackWalker</code> class.</p><p class="calibre11">The <code class="literal">Thread</code> class object has several other methods that provide information about the thread, which are as follows:</p><div class="calibre2"><ul class="itemizedlist"><li class="listitem"><code class="literal">dumpStack()</code>: This prints a stack trace to the standard error stream</li><li class="listitem"><code class="literal">enumerate(Thread[] arr)</code>: This copies active threads in the current thread's thread group and its subgroups into the specified array <code class="literal">arr</code></li><li class="listitem"><code class="literal">getId()</code>: This provides the thread's ID</li><li class="listitem"><code class="literal">getState()</code>: This reads the state of the thread; the possible values from <code class="literal">enum Thread.State</code> can be one of the following:<div class="calibre2"><ul class="itemizedlist1"><li class="listitem"><code class="literal">NEW</code>: This is the thread that has not yet started</li><li class="listitem"><code class="literal">RUNNABLE</code>: This is the thread that is currently being executed</li><li class="listitem"><code class="literal">BLOCKED</code>: This is the thread that is blocked waiting for a monitor lock to be released</li><li class="listitem"><code class="literal">WAITING</code>: This is the thread that is waiting for an interrupt signal</li><li class="listitem"><code class="literal">TIMED_WAITING</code>: This is the thread that is waiting for an interrupt signal up to a specified waiting time</li><li class="listitem"><code class="literal">TERMINATED</code>: This is the thread that has exited</li></ul></div></li><li class="listitem"><code class="literal">holdsLock(Object obj)</code>: This indicates whether the thread holds the monitor lock on the specified object</li><li class="listitem"><code class="literal">interrupted()</code> or <code class="literal">isInterrupted()</code>: This indicates whether the thread has been interrupted (received an interrupt signal, meaning that the flag interrupted was set to <code class="literal">true</code>)</li><li class="listitem"><code class="literal">isAlive()</code>: This indicates whether the thread is alive</li><li class="listitem"><code class="literal">isDaemon()</code>: This indicates whether the thread is a daemon thread.</li></ul></div><p class="calibre11">The <code class="literal">java.lang.management</code> package provides similar capabilities for monitoring threads. Let's run this code snippet, for example:</p><div class="calibre2"><pre class="programlisting">void printThreadsInfo() {
    System.out.println("printThreadsInfo():");
    ThreadMXBean threadBean = 
                      ManagementFactory.getThreadMXBean();
    long ids[] = threadBean.getAllThreadIds();
    Arrays.sort(ids);
    ThreadInfo[] tis = threadBean.getThreadInfo(ids, 0);
    for (ThreadInfo ti : tis) {
        if (ti == null) continue;
        System.out.println("    Id=" + ti.getThreadId() 
                       + ", state=" + ti.getThreadState() 
                          + ", name=" + ti.getThreadName());
    }
}</pre></div><p class="calibre11">For better presentation, we took advantage of having thread IDs listed and, as you could see previously, have sorted the output by ID. If we call the <code class="literal">printThreadsInfo()</code> method before the <code class="literal">shutdown()</code> method the output will be as follows:</p><div class="mediaobject"><img src="Images/03_22.jpg" alt="Monitoring Threads" class="calibre72"/></div><p class="calibre11">However, if we call the <code class="literal">printThreadsInfo()</code> method after the <code class="literal">shutdown()</code> method, the output will not include our worker threads anymore, exactly as in the case of using the <code class="literal">Thread</code> class API:</p><div class="mediaobject"><img src="Images/03_23.jpg" alt="Monitoring Threads" class="calibre73"/></div><p class="calibre11">The <code class="literal">java.lang.management.ThreadMXBean</code> interface provides a lot of other useful data about threads. You can refer to the official API on the Oracle website about this interface for more information check this link: <a class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2" href="https://docs.oracle.com/javase/8/docs/api/index.html?java/lang/management/ThreadMXBean.html">https://docs.oracle.com/javase/8/docs/api/index.html?java/lang/management/ThreadMXBean.html</a>.</p><p class="calibre11">In the list of threads mentioned earlier, you may have noticed the <code class="literal">Monitor Ctrl-Break</code> thread. This thread provides another way to monitor the threads in the JVM process. Pressing the <span class="emphasis"><em class="calibre12">Ctrl</em></span> and <span class="emphasis"><em class="calibre12">Break</em></span> keys on Windows causes the JVM to print a thread dump to the application's standard output. On Oracle Solaris or Linux operating systems, the same effect has the combination of the <span class="emphasis"><em class="calibre12">Ctrl</em></span> key and the backslash <span class="emphasis"><em class="calibre12">\</em></span>. This brings us to the external tools for thread monitoring.</p><p class="calibre11">In case you don't have access to the source code or prefer to use the external tools for the threads monitoring, there are several diagnostic utilities available with the JDK installation. In the following list, we mention only the tools that allow for thread monitoring and describe only this capability of the listed tools (although they have other extensive functionality too):</p><div class="calibre2"><ul class="itemizedlist"><li class="listitem">The <code class="literal">jcmd</code> utility sends diagnostic command requests to the JVM on the same machine using the JVM process ID or the name of the main class: <code class="literal">jcmd &lt;process id/main class&gt; &lt;command&gt; [options]</code>, where the <code class="literal">Thread.print</code> option prints the stack traces of all the threads in the process.</li><li class="listitem">The JConsole monitoring tool uses the built-in JMX instrumentation in the JVM to provide information about the performance and resource consumption of running applications. It has a thread tab pane that shows thread usage over time, the current number of live threads, the highest number of live threads since the JVM started. It is possible to select the thread and its name, state, and stack trace, as well as, for a blocked thread, the synchronizer that the thread is waiting to acquire, and the thread owning the lock. Use the <span class="emphasis"><strong class="calibre13">Deadlock Detection</strong></span> button to identify the deadlock. The command to run the tool is <code class="literal">jconsole &lt;process id&gt;</code> or (for remote application) <code class="literal">jconsole &lt;hostname&gt;:&lt;port&gt;</code> , where <code class="literal">port</code> is the port number specified with the JVM start command that enabled the JMX agent.</li><li class="listitem">The <code class="literal">jdb</code> utility is an example command line debugger. It can be attached to the JVM process and allows you to examine threads.</li><li class="listitem">The <code class="literal">jstack</code> command line utility can be attached to the JVM process and print the stack traces of all threads, including JVM internal threads, and optionally native stack frames. It allows you to detect deadlocks too.</li><li class="listitem"><span class="emphasis"><strong class="calibre13">Java Flight Recorder</strong></span> (<span class="emphasis"><strong class="calibre13">JFR</strong></span>) provides information about the Java process, including threads waiting for locks, garbage collections, and so on. It also allows getting thread dumps, which are similar to the one generated by the <code class="literal">Thread.print</code> diagnostic command or by using the jstack tool. It is possible to set up <span class="emphasis"><strong class="calibre13">Java Mission Control</strong></span> (<span class="emphasis"><strong class="calibre13">JMC</strong></span>) to dump a flight recording if a condition is met. JMC UI contains information about threads, lock contention, and other latencies. Although JFR is a commercial feature, it is free for developer desktops/laptops, and for evaluation purposes in test, development, and production environments.</li></ul></div><div class="note" title="Note"><div class="inner"><h3 class="title5"><a id="note02" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Note</h3><p class="calibre18">You can find more details about these and other diagnostic tools in the official Oracle documentation at <a class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2" href="https://docs.oracle.com/javase/9/troubleshoot/diagnostic-tools.htm">https://docs.oracle.com/javase/9/troubleshoot/diagnostic-tools.htm</a>.</p></div></div></div></div>



  
<div id="sbo-rt-content" class="calibre1"><div class="calibre2" title="Sizing Thread Pool Executors"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h1 class="title1"><a id="ch03lvl1sec22" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Sizing Thread Pool Executors</h1></div></div></div><p class="calibre11">In our examples, we have used a cached thread pool that creates a new thread as needed or, if available, reuses the thread already used, but which completed its job and returned to the pool for a new assignment. We did not worry about too many threads created because our demo application had two worker threads at the most and they were quite short lived.</p><p class="calibre11">But in the case where an application does not have a fixed limit of the worker threads it might need or there is no good way to predict how much memory a thread may take or how long it can execute, setting a ceiling on the worker thread count prevents an unexpected degradation of the application performance, running out of memory or depletion of any other resources the worker threads use. If the thread behavior is extremely unpredictable, a single thread pool might be the only solution, with an option of using a custom thread pool executor (more about this last option is explained later). But in most of the cases, a fixed-size thread pool executor is a good practical compromise between the application needs and the code complexity. Depending on the specific requirements, such an executor might be one of these three flavors:</p><div class="calibre2"><ul class="itemizedlist"><li class="listitem">A straightforward, fixed-sized <code class="literal">ExecutorService.newFixedThreadPool(int nThreads)</code> pool that does not grow beyond the specified size, but does not adopt either</li><li class="listitem">Several <code class="literal">ExecutorService.newScheduledThreadPool(int nThreads)</code> pools that allow scheduling different groups of threads with a different delay or cycle of execution</li><li class="listitem"><code class="literal">ExecutorService.newWorkStealingPool(int parallelism)</code> that adapts to the specified number of CPUs, which you may set higher or smaller than the actual CPUs count on your computer</li></ul></div><p class="calibre11">Setting the fixed size in any of the preceding pools too low may deprive the application of the chance to utilize the available resources effectively. So, before selecting the pool size, it is advisable to spend some time on monitoring it and tuning JVM (see how to do it in one of the sections of this lesson) with the goal of the identification of the idiosyncrasy of the application behavior. In fact, the cycle deploy-monitor-tune-adjust has to be repeated throughout the application life cycle in order to accommodate and take advantage of the changes that happened in the code or the executing environment.</p><p class="calibre11">The first parameter you take into account is the number of CPUs in your system, so the thread pool size can be at least as big as the CPU's count. Then, you can monitor the application and see how much time each thread engages the CPU and how much of the time it uses other resources (such as I/O operations). If the time spent not using the CPU is comparable with the total executing time of the thread, then you can increase the pool size by <span class="emphasis"><strong class="calibre13">time not using CPU/total executing time</strong></span>. But that is in the case that another resource (disk or database) is not a subject of contention between the threads. If the latter is the case, then you can use that resource instead of the CPU as the delineating factor.</p><p class="calibre11">Assuming the worker threads of your application are not too big or too long executing and belong to the mainstream population of the typical working threads that complete their job in a reasonably short period of time, you can increase the pool size by adding the (rounded up) ratio of the desired response time and the time a thread uses CPU or another most contentious resource. This means that, with the same desired response time, the less a thread uses CPU or another concurrently accessed resource, the bigger the pool size should be. If the contentious resource has its own ability to improve concurrent access (like a connection pool in the database), consider utilizing that feature first.</p><p class="calibre11">If the required number of threads running at the same time changes at runtime under the different circumstances, you can make the pool size dynamic and create a new pool with a new size (shutting down the old pool after all its threads have completed). The recalculation of the size of a new pool might be necessary also after you add to remove the available resources. You can use <code class="literal">Runtime.getRuntime().availableProcessors()</code> to programmatically adjust the pool size based on the current count of the available CPUs, for example.</p><p class="calibre11">If none of the ready-to-use thread pool executor implementations that come with the JDK suit the needs of a particular application, before writing the thread managing code from scratch, try to use the <code class="literal">java.util.concurrent.ThreadPoolExecutor</code> class first. It has several overloaded constructors. </p><p class="calibre11">To give you an idea of its capabilities, here is the constructor with the biggest number of options:</p><div class="calibre2"><pre class="programlisting">ThreadPoolExecutor (int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler)</pre></div><p class="calibre11">The earlier mentioned parameters are (quoting from the JavaDoc):</p><div class="calibre2"><ul class="itemizedlist"><li class="listitem"><code class="literal">corePoolSize</code>: This is the number of threads to keep in the pool, even if they are idle unless <code class="literal">allowCoreThreadTimeOut</code> is set</li><li class="listitem"><code class="literal">maximumPoolSize</code>: This is the maximum number of threads to allow in the pool</li><li class="listitem"><code class="literal">keepAliveTime</code>: When the number of threads is greater than the core, this is the maximum time that excess idle threads will wait for new tasks before terminating</li><li class="listitem"><code class="literal">unit</code>: This is the time unit for the <code class="literal">keepAliveTime</code> argument</li><li class="listitem"><code class="literal">workQueue</code>: This is the queue to use for holding tasks before they are executed, this queue will hold only the <code class="literal">Runnable</code> tasks submitted by the execute method</li><li class="listitem"><code class="literal">threadFactory</code>: This is the factory to use when the executor creates a new thread</li><li class="listitem"><code class="literal">handler</code>: This is the handler to use when the execution is blocked because the thread bounds and queue capacities are reached</li></ul></div><p class="calibre11">Each of the previous constructor parameters except the <code class="literal">workQueue</code> parameter can also be set via the corresponding setter after the object of the <code class="literal">ThreadPoolExecutor</code> method has been created, thus allowing more flexibility in dynamic adjustment of the existing pool characteristics.</p></div></div>



  
<div id="sbo-rt-content" class="calibre1"><div class="calibre2" title="Thread Synchronization"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h1 class="title1"><a id="ch03lvl1sec23" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Thread Synchronization</h1></div></div></div><p class="calibre11">We have collected enough people and resources such as food, water, and tools for the pyramid building. We have divided people into teams and assigned each team a task. A number (a pool) of people are living in the nearby village on a standby mode, ready to replace the ones that got sick or injured on their assignment. We adjusted the workforce count so that there are only a few people who will remain idle in the village. We rotate the teams through the work-rest cycle to keep the project going at maximum speed. We monitored the process and have adjusted the number of teams and the flow of supplies they need so that there are no visible delays and there is steady measurable progress in the project as a whole. Yet, there are many moving parts overall and various small and big unexpected incidents and problems happen all the time.</p><p class="calibre11">To make sure that the workers and teams do not step on each other and that there is some kind of traffic regulation so that the next technological step does not start until the previous one is finished, the main architect sends his representatives to all the critical points of the construction site. These representatives make sure that the tasks are executed with the expected quality and in the prescribed order. They have the power to stop the next team from starting their job until the previous team has not finished yet. They act like traffic cops or the locks that can shut down the access to the workplace or allow it, if/when necessary.</p><p class="calibre11">The job these representatives are doing can be defined in the modern language as a coordination or synchronization of actions of the executing units. Without it, the results of the efforts of the thousands of workers would be unpredictable. The big picture from ten thousand feet would look smooth and harmonious, as the farmers' fields from the windows of an airplane. But without closer inspection and attention to the critical details, this perfect looking picture may bring a poor harvest, if any.</p><p class="calibre11">Similarly, in the quiet electronic space of the multithreaded execution environment, the working threads have to be synchronized if they share access to the same working place. For example, let's create the following class-worker for a thread:</p><div class="calibre2"><pre class="programlisting">class MyRunnable04 implements Runnable {
  private int id;
  public MyRunnable04(int id) { this.id = id; }
  public void run() {
    IntStream.rangeClosed(1, 5)
      .peek(i -&gt; System.out.println("Thread "+id+": "+ i))
      .forEach(i -&gt; Demo04Synchronization.result += i);
    }
}</pre></div><p class="calibre11">As you can see, it sequentially adds 1, 2, 3, 4, 5 (so, that the resulting total is expected to be 15) to the static property of the <code class="literal">Demo04Synchronization</code> class:</p><div class="calibre2"><pre class="programlisting">public class Demo04Synchronization {
    public static int result;
    public static void main(String... args) {
        System.out.println();
        demo_ThreadInterference();
    }
    private static void demo_ThreadInterference(){
        System.out.println("demo_ThreadInterference: ");
        MyRunnable04 r1 = new MyRunnable04(1);
        Thread t1 = new Thread(r1);
        MyRunnable04 r2 = new MyRunnable04(2);
        Thread t2 = new Thread(r2);
        t1.start();
        sleepMs(100);
        t2.start();
        sleepMs(100);
        System.out.println("Result=" + result);
    }
    private static void sleepMs(int sleepMs) {
        try {
            TimeUnit.MILLISECONDS.sleep(sleepMs);
        } catch (InterruptedException e) {}
    }
}</pre></div><p class="calibre11">In the earlier code, while the main thread pauses for 100 ms the first time, the thread <code class="literal">t1</code> brings the value of the variable result to 15, then the thread <code class="literal">t2</code> adds another 15 to get the total of 30. Here is the output:</p><div class="mediaobject"><img src="Images/03_24.jpg" alt="Thread Synchronization" class="calibre74"/></div><p class="calibre11">If we remove the first pause of 100 ms, the threads will work concurrently:</p><div class="mediaobject"><img src="Images/03_25.jpg" alt="Thread Synchronization" class="calibre75"/></div><p class="calibre11">The final result is still 30. We feel good about this code and deploy it to production as a well-tested code. However, if we increase the number of additions from 5 to 250, for example, the result becomes unstable and changes from run to run. Here is the first run (we commented out the printout in each thread in order to save space):</p><div class="mediaobject"><img src="Images/03_26.jpg" alt="Thread Synchronization" class="calibre76"/></div><p class="calibre11">And here is the output of another run:</p><div class="mediaobject"><img src="Images/03_27.jpg" alt="Thread Synchronization" class="calibre77"/></div><p class="calibre11">It demonstrates the fact that the <code class="literal">Demo04Synchronization.result += i</code> operation is not atomic. This means it consists of several steps, reading the value from the <code class="literal">result</code> property, adding a value to it, assigning the resulting sum back to the <code class="literal">result</code> property. This allows the following scenario, for example:</p><div class="calibre2"><ul class="itemizedlist"><li class="listitem">Both the threads have read the current value of <code class="literal">result</code> (so each of the threads has a copy of the same original <code class="literal">result</code> value)</li><li class="listitem">Each thread adds another integer to the same original one</li><li class="listitem">The first thread assigns the sum to the <code class="literal">result</code> property</li><li class="listitem">The second thread assigns its sum to the <code class="literal">result</code> property</li></ul></div><p class="calibre11">As you can see, the second thread did not know about the addition the first thread made and has overwritten the value assigned to the <code class="literal">result</code> property by the first thread. But such thread interleaving does not happen every time. It is just a game of chance. That's why we did not see such an effect with five numbers only. But the probability of this happening increases with the growth of the number of concurrent actions.</p><p class="calibre11">A similar thing could happen during the pyramid building too. The second team could start doing something before the first team has finished their task. We definitely need a <span class="emphasis"><strong class="calibre13">synchronizer</strong></span> and it comes with a <code class="literal">synchronized</code> keyword. Using it, we can create a method (an architect representative) in the <code class="literal">Demo04Synchronization</code> class that will control access to the <code class="literal">result</code> property and add to it this keyword:</p><div class="calibre2"><pre class="programlisting">private static int result;
public static synchronized void incrementResult(int i){
    result += i;
}</pre></div><p class="calibre11">Now we have to modify the <code class="literal">run()</code> method in the worker thread too:</p><div class="calibre2"><pre class="programlisting">public void run() {
    IntStream.rangeClosed(1, 250)
       .forEach(Demo04Synchronization::incrementResult);
}</pre></div><p class="calibre11">The output now shows the same final number for every run:</p><div class="mediaobject"><img src="Images/03_28.jpg" alt="Thread Synchronization" class="calibre78"/></div><p class="calibre11">The <code class="literal">synchronized</code> keyword tells JVM that only one thread at a time is allowed to enter this method. All the other threads will wait until the current visitor of the method exits from it.</p><p class="calibre11">The same effect could be achieved by adding the <code class="literal">synchronized</code> keyword to a block of code:</p><div class="calibre2"><pre class="programlisting">public static void incrementResult(int i){
    synchronized (Demo04Synchronization.class){
        result += i;
    }
}</pre></div><p class="calibre11">The difference is that the block synchronization requires an object--a class object in the case of static property synchronization (as in our case) or any other object in the case of an instance property synchronization. Each object has an intrinsic lock or monitor lock, often referred to simply as a monitor. Once a thread acquires a lock on an object, no other thread can acquire it on the same object until the first thread releases the lock after normal exit from the locked code or if the code throws an exception.</p><p class="calibre11">In fact, in the case of a synchronized method, an object (the one to which the method belongs) is used for locking, too. It just happens behind the scene automatically and does not require the programmer to use an object's lock explicitly.</p><p class="calibre11">In case you do not have access to the <code class="literal">main</code> class code (as in the example earlier) you can keep the <code class="literal">result</code> property public and add a synchronized method to the worker thread (instead of the class as we have done):</p><div class="calibre2"><pre class="programlisting">class MyRunnable05 implements Runnable {
    public synchronized void incrementResult(int i){
        Demo04Synchronization.result += i;
    }
    public void run() {
        IntStream.rangeClosed(1, 250)
                .forEach(this::incrementResult);
    }
}</pre></div><p class="calibre11">In this case, the object of the <code class="literal">MyRunnable05</code> worker class provides its intrinsic lock by default. This means, you need to use the same object of the <code class="literal">MyRunnable05</code> class for all the threads:</p><div class="calibre2"><pre class="programlisting">void demo_Synchronized(){
    System.out.println("demo_Synchronized: ");
    MyRunnable05 r1 = new MyRunnable05();
    Thread t1 = new Thread(r1);
    Thread t2 = new Thread(r1);
    t1.start();
    t2.start();
    sleepMs(100);
    System.out.println("Result=" + result);
}</pre></div><p class="calibre11">The output of the preceding code is the same as before:</p><div class="mediaobject"><img src="Images/03_29.jpg" alt="Thread Synchronization" class="calibre79"/></div><p class="calibre11">One can argue that this last implementation is preferable because it allocates the responsibility of the synchronization with the thread (and the author of its code) and not with the shared resource. This way the need for synchronization changes along with the thread implementation evolution, provided that the client code (that uses the same or different objects for the threads) can be changed as needed as well.</p><p class="calibre11">There is another possible concurrency issue that may happen in some operating systems. Depending on how the thread caching is implemented, a thread might preserve a local copy of the property <code class="literal">result</code> and not update it after another thread has changed its value. By adding the <code class="literal">volatile</code> keyword to the shared (between threads) property guarantees that its current value will be always read from the main memory, so each thread will see the updates done by the other threads. In our previous examples, we just set the <code class="literal">Demo04Synchronization</code> class property as <code class="literal">private static volatile int result</code>, add a synchronized <code class="literal">incrementResult()</code> method to the same class or to the thread and do not worry anymore about threads stepping on each other.</p><p class="calibre11">The described thread synchronization is usually sufficient for the mainstream application. But the higher performance and highly concurrent processing often require looking closer into the thread dump, which typically shows that method synchronization is more efficient than block synchronization. Naturally, it also depends on the size of the method and the block. Since all the other threads that try to access the synchronized method or block are going to stop execution until the current visitor of the method or block exits it, it is possible that despite the overhead a small synchronized block yields better performance than the big synchronized method.</p><p class="calibre11">For some applications, the behavior of the default intrinsic lock, which just blocks until the lock is released, maybe not well suited. If that is the case, consider using locks from the <code class="literal">java.util.concurrent.locks</code> package. The access control based on locks from that package has several differences if compared with using the default intrinsic lock. These differences may be advantageous for your application or provide the unnecessary complication, but it's important to know them, so you can make an informed decision:</p><div class="calibre2"><ul class="itemizedlist"><li class="listitem">The synchronized fragment of code does not need to belong to one method; it can span several methods, delineated by the calls to the <code class="literal">lock()</code> and <code class="literal">unlock()</code> methods (invoked on the object that implements the <code class="literal">Lock</code> interface)</li><li class="listitem">While creating an object of the <code class="literal">Lock</code> interface called <code class="literal">ReentrantLock</code>, it is possible to pass into the constructor a <code class="literal">fair</code> flag that makes the lock able to grant an access to the longest-waiting thread first, which helps to avoid starvation (when the low priority thread never can get access to the lock)</li><li class="listitem">Allows a thread to test whether the lock is accessible before committing to be blocked</li><li class="listitem">Allows interrupting a thread waiting for the lock, so it does not remain blocked indefinitely</li><li class="listitem">You can implement the <code class="literal">Lock</code> interface yourself with whatever features you need for your application</li></ul></div><p class="calibre11">A typical pattern of usage of the <code class="literal">Lock</code> interface looks like this:</p><div class="calibre2"><pre class="programlisting">Lock lock = ...;
...
    lock.lock();
    try {
        // the fragment that is synchronized
    } finally {
        lock.unlock();
    }
...
}</pre></div><p class="calibre11">Notice the <code class="literal">finally</code> block. It is the way to guarantee that the <code class="literal">lock</code> is released eventually. Otherwise, the code inside the <code class="literal">try-catch</code> block can throw an exception and the lock is never released.</p><p class="calibre11">In addition to the <code class="literal">lock()</code> and <code class="literal">unlock()</code> methods, the <code class="literal">Lock</code> interface has the following methods:</p><div class="calibre2"><ul class="itemizedlist"><li class="listitem"><code class="literal">lockInterruptibly()</code>: This acquires the lock unless the current thread is interrupted. Similar to the <code class="literal">lock()</code> method, this method blocks while waiting until the lock is acquired, in difference to the <code class="literal">lock()</code> method, if another thread interrupts the waiting thread, this method throws the <code class="literal">InterruptedException</code> exception</li><li class="listitem"><code class="literal">tryLock()</code>: This acquires the lock immediately if it is free at the time of invocation</li><li class="listitem"><code class="literal">tryLock(long time, TimeUnit unit)</code>: This acquires the lock if it is free within the given waiting time and the current thread has not been interrupted</li><li class="listitem"><code class="literal">newCondition()</code>: This returns a new <code class="literal">Condition</code> instance that is bound to this <code class="literal">Lock</code> instance, after acquiring the lock, the thread can release it (calling the <code class="literal">await()</code> method on the <code class="literal">Condition</code> object) until some other thread calls <code class="literal">signal()</code> or <code class="literal">signalAll()</code> on the same <code class="literal">Condition</code> object, it is also possible to specify the timeout period (by using an overloaded <code class="literal">await()</code> method), so the thread will resume after the timeout if there was no signal received, see the <code class="literal">Condition</code> API for more details</li></ul></div><p class="calibre11">The scope of this book does not allow us to show all the possibilities for thread synchronization provided in the <code class="literal">java.util.concurrent.locks</code> package. It would take several lessons to describe all of them. But even from this short description, you can see that one would be hard pressed to find a synchronization problem that cannot be solved using the <code class="literal">java.util.concurrent.locks</code> package.</p><p class="calibre11">The synchronization of a method or block of code makes sense when several lines of code have to be isolated as an atomic (all or nothing) operation. But in the case of a simple assignment to a variable or increment/decrement of a number (as in our earlier examples), there is a much better way to synchronize this operation by using classes from the <code class="literal">java.util.concurrent.atomic</code> package that support lock-free thread-safe programming on a single variable. The variety of classes covers all the numbers and even arrays and reference types such as <code class="literal">AtomicBoolean</code>, <code class="literal">AtomicInteger</code>, <code class="literal">AtomicIntegerArray</code>, <code class="literal">AtomicReference</code>, and <code class="literal">AtomicReferenceArray</code>.</p><p class="calibre11">There are 16 classes in total. Depending on the value type, each of them allows a full imaginable range of operations, that is, <code class="literal">set()</code>, <code class="literal">get()</code>, <code class="literal">addAndGet()</code>, <code class="literal">compareAndSet()</code>, <code class="literal">incrementAndGet()</code>, <code class="literal">decrementAndGet()</code>, and many others. Each operation is implemented much more efficiently than the same operations implemented with the <code class="literal">synchronized</code> keyword. And there is no need for the <code class="literal">volatile</code> keyword because it uses it under the hood.</p><p class="calibre11">If the concurrently accessed resource is a collection, the <code class="literal">java.util.concurrent</code> package offers a variety of thread-safe implementations that perform better than synchronized <code class="literal">HashMap</code>, <code class="literal">Hashtable</code>, <code class="literal">HashSet</code>, <code class="literal">Vector</code>, and <code class="literal">ArrayList</code> (if we compare the corresponding <code class="literal">ConcurrentHashMap</code>, <code class="literal">CopyOnWriteArrayList</code>, and <code class="literal">CopyOnWriteHashSet</code>). The traditional synchronized collections lock the whole collection while concurrent collections use such advanced techniques such as lock stripping to achieve thread safety. The concurrent collections especially shine with more reading and fewer updates and they are much more scalable than synchronized collections. But if the size of your shared collection is small and writes dominate, the advantage of concurrent collections is not as obvious.</p></div></div>



  
<div id="sbo-rt-content" class="calibre1"><div class="calibre2" title="Tuning JVM"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h1 class="title1"><a id="ch03lvl1sec24" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Tuning JVM</h1></div></div></div><p class="calibre11">Each pyramid building, as any big project, goes through the same life cycle of design, planning, execution, and delivery. And throughout each of these phases, a continuous tuning is going on, a complex project is called so for a reason. A software system is not different in this respect. We design, plan and build it, then change and tune continuously. If we are lucky, then the new changes do not go too far back to the initial stages and do not require changing the design. To hedge against such drastic steps, we use prototypes (if the waterfall model is used) or iterative delivery (if the agile process is adopted) for early detection of possible problems. Like young parents, we are always on alert, monitoring the progress of our child, day and night.</p><p class="calibre11">As we mentioned already in one of the previous sections, there are several diagnostic tools that come with each JDK 9 installation or can be used in addition to them for monitoring your Java application. The full list of these tools (and the recommendations how to create a custom tool, if needed) can be found in official Java SE documentation on the Oracle site: <a class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2" href="https://docs.oracle.com/javase/9/troubleshoot/diagnostic-tools.htm">https://docs.oracle.com/javase/9/troubleshoot/diagnostic-tools.htm</a>.</p><p class="calibre11">Using these tools one identifies the bottleneck of the application and addresses it either programmatically or by tuning the JVM itself or both. The biggest gain usually comes with the good design decisions and from using certain programming techniques and frameworks, some of which we have described in other sections. In this section, we are going to look at the options available after all possible code changes are applied or when changing code is not an option, so all we can do is to tune JVM itself.</p><p class="calibre11">The goal of the effort depends on the results of the application profiling and the nonfunctional requirements for:</p><div class="calibre2"><ul class="itemizedlist"><li class="listitem">Latency, or how responsive the application is to the input</li><li class="listitem">Throughput, or how much work the application is doing in a given unit of time</li><li class="listitem">Memory footprint, or how much memory the application requires</li></ul></div><p class="calibre11">The improvements in one of them often are possible only at the expense of the one or both of the others. The decrease in the memory consumption may bring down the throughput and latency, while the decrease in latency typically can be achieved only via the increase in memory footprint unless you can bring in faster CPUs thus improving all three characteristics.</p><p class="calibre11">Application profiling may show that one particular operation keeps allocating a lot of memory in the loop. If you have an access to the code, you can try to optimize this section of the code and thus ease the pressure on JVM. Alternatively, it may show that there is an I/O or another interaction with a low device is involved, and there is nothing you can do in the code to improve it.</p><p class="calibre11">Defining the goal of the application and JVM tuning requires establishing metrics. For example, it is well known already that the traditional measure of latency as the average response time hides more than it reveals about the performance. The better latency metrics would be the maximum response time in conjunction with 99% best response time. For throughput, a good metrics would be the number of transactions per a unit of time. Often the inverse of this metrics (time per transaction) closely reflects latency. For the memory footprint, the maximum allocated memory (under the load) allows for the hardware planning and setting guards against the dreaded <code class="literal">OutOfMemoryError</code> exception. Avoiding full (stop-the-world) garbage collection cycle would be ideal. In practice, though, it would be good enough if <span class="emphasis"><strong class="calibre13">Full GC</strong></span> happens not often, does not visibly affect the performance and ends up with approximately the same heap size after several cycles.</p><p class="calibre11">Unfortunately, such simplicity of the requirements does happen in practice. Real life brings more questions all the time as follows:</p><div class="calibre2"><ul class="itemizedlist"><li class="listitem">Can the target latency (response time) be ever exceeded?</li><li class="listitem">If yes, how often and by how much?</li><li class="listitem">How long can the period of the poor response time last?</li><li class="listitem">Who/what measures the latency in production?</li><li class="listitem">Is the target performance the peak performance?</li><li class="listitem">What is the expected peak load?</li><li class="listitem">How long is the expected peak load going to last?</li></ul></div><p class="calibre11">Only after all these and similar questions are answered and the metrics (that reflect the nonfunctional requirements) are established, we can start tweaking the code, running it and profiling again and again, then tweaking the code and repeating the cycle. This activity has to consume most of the efforts because tuning of the JVM itself can bring only the fraction of the performance improvements by comparison with the performance gained by the code changes.</p><p class="calibre11">Nevertheless, several passes of the JVM tuning must happen early in order to avoid wasting of the efforts and trying to force the code in the not well-configured environment. The JVM configuration has to be as generous as possible for the code to take advantage of all the available resources.</p><p class="calibre11">First of all, select garbage collector from the four that JVM 9 supports, which are as follows:</p><div class="calibre2"><ul class="itemizedlist"><li class="listitem"><span class="emphasis"><strong class="calibre13">Serial collector</strong></span>: This uses a single thread to perform all the garbage collection work</li><li class="listitem"><span class="emphasis"><strong class="calibre13">Parallel collector</strong></span>: This uses multiple threads to speed up garbage collection</li><li class="listitem"><span class="emphasis"><strong class="calibre13">Concurrent Mark Sweep (CMS) collector</strong></span>: This uses shorter garbage collection pauses at the expense of taking more of the processor time</li><li class="listitem"><span class="emphasis"><strong class="calibre13">Garbage-First (G1) collector</strong></span>: This is intended for multiprocessor machines with a large memory, but meets garbage collection pause-time goals with high probability, while achieving high throughput.</li></ul></div><p class="calibre11">The official Oracle documentation (<a class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2" href="https://docs.oracle.com/javase/9/gctuning/available-collectors.htm">https://docs.oracle.com/javase/9/gctuning/available-collectors.htm</a>) provides the following initial guidelines for the garbage collection selection:</p><div class="calibre2"><ul class="itemizedlist"><li class="listitem">If the application has a small dataset (up to approximately 100 MB), then select the serial collector with the <code class="literal">-XX:+UseSerialGC</code> option</li><li class="listitem">If the application will be run on a single processor and there are no pause-time requirements, then select the serial collector with the <code class="literal">-XX:+UseSerialGC</code> option</li><li class="listitem">If (a) peak application performance is the first priority and (b) there are no pause-time requirements or pauses of one second or longer are acceptable, then let the VM select the collector or select the parallel collector with <code class="literal">-XX:+UseParallelGC</code></li><li class="listitem">If the response time is more important than the overall throughput and garbage collection pauses must be kept shorter than approximately one second, then select a concurrent collector with <code class="literal">-XX:+UseG1GC or -XX:+UseConcMarkSweepGC</code></li></ul></div><p class="calibre11">But if you do not have particular preferences yet, let the JVM select garbage collector until you learn more about your application's needs. In JDK 9, the G1 is selected by default on certain platforms, and it is a good start if the hardware you use has enough resources.</p><p class="calibre11">Oracle also recommends using G1 with its default settings, then later playing with a different pause-time goal using the <code class="literal">-XX:MaxGCPauseMillis</code> option and maximum Java heap size using the <code class="literal">-Xmx</code> option. Increasing either the pause-time goal or the heap size typically leads to a higher throughput. The latency is affected by the change of the pause-time goal too.</p><p class="calibre11">While tuning the GC, it is beneficial to keep the <code class="literal">-Xlog:gc*=debug</code> logging option. It provides many useful details about garbage collection activity. The first goal of JVM tuning is to decrease the number of full heap GC cycles (Full GC) because they are very resource consuming and thus may slow down the application. It is caused by too high occupancy of the old generation area. In the log, it is identified by the words <code class="literal">Pause Full (Allocation Failure)</code>. The following are the possible steps to reduce chances of Full GC:</p><div class="calibre2"><ul class="itemizedlist"><li class="listitem">Bring up the size of the heap using <code class="literal">-Xmx</code>. But make sure it does not exceed the physical size of RAM. Better yet, leave some RAM space for other applications.</li><li class="listitem">Increase the number of concurrent marking threads explicitly using <code class="literal">-XX:ConcGCThreads</code>.</li><li class="listitem">If the humongous objects take too much of the heap (watch for <span class="emphasis"><strong class="calibre13">gc+heap=info</strong></span> logging that shows the number next to humongous regions) try to increase the region size using <code class="literal">-XX: G1HeapRegionSize</code>.</li><li class="listitem">Watch the GC log and modify the code so that almost all the objects created by your application are not moved beyond the young generation (dying young).</li><li class="listitem">Add or change one option at a time, so you can understand the causes of the change in the JVM's behavior clearly.</li></ul></div><p class="calibre11">These few steps will help you go and create a trial-and-error cycle that will bring you a better understanding of the platform you are using, the needs of your application, and the sensitivity of the JVM and the selected GC to different options. Equipped with this knowledge, you will then be able to meet the nonfunctional performance requirements whether by changing the code, tuning the JVM, or reconfiguring the hardware.</p></div></div>



  
<div id="sbo-rt-content" class="calibre1"><div class="calibre2" title="Reactive Programming"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h1 class="title1"><a id="ch03lvl1sec25" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Reactive Programming</h1></div></div></div><p class="calibre11">After several false starts and a few disastrous disruptions, followed by heroic recoveries, the process of pyramid building took shape and ancient builders were able to complete a few projects. The final shape sometimes did not look exactly as envisioned (the first pyramids have ended up bent), but, nevertheless, the pyramids still decorate the desert today. The experience was passed from generation to generation, and the design and the process were tuned well enough to produce something magnificent and pleasant to look at more than 4,000 years later.</p><p class="calibre11">The software practices also change over time, albeit we have had only some 70 years since Mr. Turing wrote the first modern program. In the beginning, when there were only a handful of programmers in the world, a computer program used to be a continuous list of instructions. Functional programming (pushing a function around like a first-class citizen) was introduced very early too but has not become a mainstream. Instead, the <span class="emphasis"><strong class="calibre13">GOTO</strong></span> instruction allowed you to roll code in a spaghetti bowl. Structural programming followed, then object-oriented programming, with functional programming moving along and even thriving in certain areas. Asynchronous processing of the events generated by the pressed keys became routine for many programmers. JavaScript tried to use all of the best practices and gained a lot of power, even if at the expense of programmers' frustration during the debugging (fun) phase. Finally, with thread pools and lambda expressions being part of JDK SE, adding reactive streams API to JDK 9 made Java part of the family that allows reactive programming with asynchronous data streams.</p><p class="calibre11">To be fair, we were able to process data asynchronously even without this new API--by spinning worker threads and using thread pools and callables (as we described in the previous sections) or by passing the callbacks (even if lost once in a while in the maze of the one who-calls-whom). But, after writing such a code a few times, one notices that most of such code is just a plumbing that can be wrapped inside a framework that can significantly simplify asynchronous processing. That's how the Reactive Streams initiative (<a class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2" href="http://www.reactive-streams.org">http://www.reactive-streams.org</a>) came to be created and the scope of the effort is defined as follows:</p><p class="calibre11">The scope of Reactive Streams is to find a minimal set of interfaces, methods and protocols that will describe the necessary operations and entities to achieve the goal--asynchronous streams of data with non-blocking back pressure.</p><p class="calibre11">The term <span class="emphasis"><strong class="calibre13">non-blocking back pressure</strong></span> is an important one because it identifies one of the problems of the existed asynchronous processing--coordination of the speed rate of the incoming data with the ability of the system to process them without the need of stopping (blocking) the data input. The solution would still include some back pressure by informing the source that the consumer has difficulty in keeping up with the input, but the new framework should react to the change of the rate of the incoming data in a more flexible manner than just blocking the flow, thus the name <span class="emphasis"><strong class="calibre13">reactive</strong></span>.</p><p class="calibre11">The Reactive Streams API consists of the five interfaces included in the class which are <code class="literal">java.util.concurrent.Flow</code>, <code class="literal">Publisher</code>, <code class="literal">Subscriber</code>, <code class="literal">Subscription</code>, and <code class="literal">Processor</code>:</p><div class="calibre2"><pre class="programlisting">@FunctionalInterface
public static interface Flow.Publisher&lt;T&gt; {
  public void subscribe(Flow.Subscriber&lt;? super T&gt; subscriber);
}

public static interface Flow.Subscriber&lt;T&gt; {
  public void onSubscribe(Flow.Subscription subscription);
  public void onNext(T item);
  public void onError(Throwable throwable);
  public void onComplete();
}

public static interface Flow.Subscription {
  public void request(long numberOfItems);
  public void cancel();
}

public static interface Flow.Processor&lt;T,R&gt; 
               extends Flow.Subscriber&lt;T&gt;, Flow.Publisher&lt;R&gt; {
}</pre></div><p class="calibre11">A <code class="literal">Flow.Subscriber</code> object becomes a subscriber of the data produced by the object of <code class="literal">Flow.Publisher</code> after the object of <code class="literal">Flow.Subscriber</code> is passed as a parameter into the <code class="literal">subscribe()</code> method. The publisher (object of <code class="literal">Flow.Publisher</code>) calls the subscriber's <code class="literal">onSubscribe()</code> method and passes as a parameter a <code class="literal">Flow.Subsctiption</code> object. Now, the subscriber can request <code class="literal">numberOffItems</code> of data from the publisher by calling the subscription's <code class="literal">request()</code> method. That is the way to implement the pull model when a subscriber decides when to request another item for processing. The subscriber can unsubscribe from the publisher services by calling the <code class="literal">cancel()</code> subscription method.</p><p class="calibre11">In return (or without any request, if the implementer has decided to do so, that would be a push model), the publisher can pass to the subscriber a new item by calling the subscriber's <code class="literal">onNext()</code> method. The publisher can also tell the subscriber that the item production has encountered a problem (by calling the subscriber's <code class="literal">onError()</code> method) or that no more data will be coming (by calling the subscriber's <code class="literal">onComplete()</code> method).</p><p class="calibre11">The <code class="literal">Flow.Processor</code> interface describes an entity that can act as both a subscriber and a publisher. It allows creating chains (pipelines) of such processors, so a subscriber can receive an item from a publisher, tweak it, and then pass the result to the next subscriber.</p><p class="calibre11">This is the minimal set of interfaces the Reactive Streams initiative has defined (and it is a part of JDK 9 now) in support of the asynchronous data streams with non-blocking back pressure. As you can see, it allows the subscriber and publisher to talk to each other and coordinate, if need be, the rate of incoming data, thus making possible a variety of solutions for the back pressure problem we discussed in the beginning.</p><p class="calibre11">There are many ways to implement these interfaces. Currently, in JDK 9, there is only one example of implementation of one of the interfaces--the <code class="literal">SubmissionPublisher</code> class implements <code class="literal">Flow.Publisher</code>. But several other libraries already exist that implemented Reactive Streams API: RxJava, Reactor, Akka Streams, and Vert.x are among the most known. We will use RxJava 2.1.3 in our examples. You can find the RxJava 2.x API on <a class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2" href="http://reactivex.io">http://reactivex.io</a> under the name ReactiveX, which stands for Reactive Extension.</p><p class="calibre11">While doing that, we would also like to address the difference between the streams of the <code class="literal">java.util.stream</code> package and Reactive Streams (as implemented in RxJava, for example). It is possible to write very similar code using any of the streams. Let's look at an example. Here is a program that iterates over five integers, selects even numbers only (2 and 4), transforms each of them (takes a square root of each of the selected numbers) and then calculates an average of the two square roots. It is based on the traditional <code class="literal">for</code> loop.</p><p class="calibre11">Let's start with the similarity. It is possible to implement the same functionality using any of the streams. For example, here is a method that iterates over five integers, selects even numbers only (2 and 4, in this case), transforms each of them (takes a square root of each of the even numbers) and then calculates an average of the two square roots. It is based on the traditional <code class="literal">for</code> loop:</p><div class="calibre2"><pre class="programlisting">void demo_ForLoop(){
    List&lt;Double&gt; r = new ArrayList&lt;&gt;();
    for(int i = 1; i &lt; 6; i++){
        System.out.println(i);
        if(i%2 == 0){
            System.out.println(i);
            r.add(doSomething(i));
        }
    }
    double sum = 0d;
    for(double d: r){ sum += d; }
    System.out.println(sum / r.size());
}
static double doSomething(int i){
    return Math.sqrt(1.*i);
}</pre></div><p class="calibre11">If we run this program, the result will be as follows:</p><div class="mediaobject"><img src="Images/03_30.jpg" alt="Reactive Programming" class="calibre80"/></div><p class="calibre11">The same functionality (with the same output) can be implemented using the package <code class="literal">java.util.stream</code> as follows:</p><div class="calibre2"><pre class="programlisting">void demo_Stream(){
    double a = IntStream.rangeClosed(1, 5)
        .peek(System.out::println)
        .filter(i -&gt; i%2 == 0)
        .peek(System.out::println)
        .mapToDouble(i -&gt; doSomething(i))
        .average().getAsDouble();
    System.out.println(a);
}</pre></div><p class="calibre11">The same functionality can be implemented with RxJava:</p><div class="calibre2"><pre class="programlisting">void demo_Observable1(){
    Observable.just(1,2,3,4,5)
        .doOnNext(System.out::println)
        .filter(i -&gt; i%2 == 0)
        .doOnNext(System.out::println)
        .map(i -&gt; doSomething(i))
        .reduce((r, d) -&gt; r + d)
        .map(r -&gt; r / 2)
        .subscribe(System.out::println);
}</pre></div><p class="calibre11">RxJava is based on the <code class="literal">Observable</code> object (which plays the role of <code class="literal">Publisher</code>) and <code class="literal">Observer</code> that subscribes to the <code class="literal">Observable</code> and waits for data to be emitted. Each item of the emitted data (on the way from the <code class="literal">Observable</code> to the <code class="literal">Observer</code>) can be processed by the operations chained in a fluent style (see the previous code). Each operation takes a lambda expression. The operation functionality is obvious from its name.</p><p class="calibre11">Despite being able to behave similarly to the streams, an <code class="literal">Observable</code> has significantly different capabilities. For example, a stream, once closed, cannot be reopened, while an <code class="literal">Observable</code> can be reused. Here is an example:</p><div class="calibre2"><pre class="programlisting">void demo_Observable2(){
    Observable&lt;Double&gt; observable = Observable
            .just(1,2,3,4,5)
            .doOnNext(System.out::println)
            .filter(i -&gt; i%2 == 0)
            .doOnNext(System.out::println)
            .map(Demo05Reactive::doSomething);

    observable
            .reduce((r, d) -&gt; r + d)
            .map(r -&gt; r / 2)
            .subscribe(System.out::println);

    observable
            .reduce((r, d) -&gt; r + d)
            .subscribe(System.out::println);
}</pre></div><p class="calibre11">In the previous code, we use <code class="literal">Observable</code> twice--for average value calculation and for the summing all the square roots of the even numbers. The output is as shown in the following screenshot:</p><div class="mediaobject"><img src="Images/03_31.jpg" alt="Reactive Programming" class="calibre81"/></div><p class="calibre11">If we do not want <code class="literal">Observable</code> to run twice, we can cache its data, by adding the <code class="literal">.cache()</code> operation:</p><div class="calibre2"><pre class="programlisting">void demo_Observable2(){
    Observable&lt;Double&gt; observable = Observable
            .just(1,2,3,4,5)
            .doOnNext(System.out::println)
            .filter(i -&gt; i%2 == 0)
            .doOnNext(System.out::println)
            .map(Demo05Reactive::doSomething)
            .cache();

    observable
            .reduce((r, d) -&gt; r + d)
            .map(r -&gt; r / 2)
            .subscribe(System.out::println);

    observable
            .reduce((r, d) -&gt; r + d)
            .subscribe(System.out::println);
}</pre></div><p class="calibre11">The result of the previous code is as follows:</p><div class="mediaobject"><img src="Images/03_32.jpg" alt="Reactive Programming" class="calibre82"/></div><p class="calibre11">You can see that the second usage of the same <code class="literal">Observable</code> took advantage of the cached data, thus allowing for better performance.</p><p class="calibre11">Another <code class="literal">Observable</code> advantage is that the exception can be caught by <code class="literal">Observer</code>:</p><div class="calibre2"><pre class="programlisting">subscribe(v -&gt; System.out.println("Result=" + v),
        e -&gt; {
            System.out.println("Error: " + e.getMessage());
            e.printStackTrace();
        },
        () -&gt; System.out.println("All the data processed"));</pre></div><p class="calibre11">The <code class="literal">subscribe()</code> method is overloaded and allows to pass in one, two, or three functions:</p><div class="calibre2"><ul class="itemizedlist"><li class="listitem">The first is to be used in case of success</li><li class="listitem">The second is to be used in case of an exception</li><li class="listitem">The third is to be called after all the data is processed</li></ul></div><p class="calibre11">The <code class="literal">Observable</code> model also allows more control over multithreaded processing. Using <code class="literal">.parallel()</code> in the streams does not allow you to specify the thread pool to be used. But, in RxJava, you can set the type of pool you prefer using the method <code class="literal">subscribeOn()</code> in <code class="literal">Observable</code>:</p><div class="calibre2"><pre class="programlisting">observable.subscribeOn(Schedulers.io())
        .subscribe(System.out::println);</pre></div><p class="calibre11">The <code class="literal">subscribeOn()</code> method tells <code class="literal">Observable</code> on which thread to put the data. The <code class="literal">Schedulers</code> class has methods that generate thread pools dealing mostly with I/O operations (as in our example), or heavy on computation (method <code class="literal">computation()</code>), or creating a new thread for each unit of work (method <code class="literal">newThread()</code>), and several others, including passing in a custom thread pool (method <code class="literal">from(Executor executor)</code>).</p><p class="calibre11">The format of this book does not allow us to describe all the richness of RxJava API and other Reactive Streams implementations. Their main thrust is reflected in Reactive Manifesto (<a class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2" href="http://www.reactivemanifesto.org/">http://www.reactivemanifesto.org/</a>) that describes Reactive Systems as a new generation of high performing software solutions. Built on asynchronous message-driven processes and Reactive Streams, such systems are able to demonstrate the qualities declared in the Reactive Manifesto:</p><div class="calibre2"><ul class="itemizedlist"><li class="listitem"><span class="emphasis"><strong class="calibre13">Elasticity</strong></span>: This has the ability to expand and contract as needed based on the load</li><li class="listitem"><span class="emphasis"><strong class="calibre13">Better responsiveness</strong></span>: Here, the processing can be parallelized using asynchronous calls</li><li class="listitem"><span class="emphasis"><strong class="calibre13">Resilience</strong></span>: Here, the system is broken into multiple (loosely coupled via messages) components, thus facilitating flexible replication, containment, and isolation</li></ul></div><p class="calibre11">Writing code for Reactive Systems using Reactive Streams for implementing the previously mentioned qualities constitutes reactive programming. The typical application of such systems today is microservices, which is described in the next lesson.</p></div></div>



  
<div id="sbo-rt-content" class="calibre1"><div class="calibre2" title="Summary"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h1 class="title1"><a id="ch03lvl1sec26" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Summary</h1></div></div></div><p class="calibre11">In this lesson, we have discussed the ways to improve Java application performance by using multithreading. We described how to decrease an overhead of creating the threads using thread pools and various types of such pools suited for different processing requirements. We also brought up the considerations used for selecting the pool size and how to synchronize threads so that they do not interfere with each other and yield the best performance results. We pointed out that every decision on the performance improvements has to be made and tested through direct monitoring of the application, and we discussed the possible options for such monitoring programmatically and using various external tools. The final step, the JVM tuning, can be done via Java tool flags that we listed and commented in the corresponding section. Yet more gains in Java application performance might be achieved by adopting the concept of reactive programming, which we presented as the strong contender among most effective moves toward highly scalable and highly performing Java applications.</p><p class="calibre11">In the next lesson, we will talk about adding more workers by splitting the application into several microservices, each deployed independently and each using multiple threads and reactive programming for better performance, response, scalability, and fault-tolerance.</p></div></div>



  
<div id="sbo-rt-content" class="calibre1"><div class="calibre2" title="Assessments"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h1 class="title1"><a id="ch03lvl1sec27" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Assessments</h1></div></div></div><div class="calibre2"><ol class="orderedlist"><li class="listitem1">Name the method that calculates the average square root of the first 99,999 integers and assigns the result to a property that can be accessed anytime.</li><li class="listitem1">Which of the following methods creates a thread pool of a fixed size that can schedule commands to run after a given delay, or to execute periodically:<div class="calibre2"><ol class="orderedlist1"><li class="listitem1"><code class="literal">newscheduledThreadPool()</code></li><li class="listitem1"><code class="literal">newWorkStealingThreadPool()</code></li><li class="listitem1"><code class="literal">newSingleThreadScheduledExecutor()</code></li><li class="listitem1"><code class="literal">newFixedThreadPool()</code></li></ol></div></li><li class="listitem1">State whether True or False: One can take advantage of the <code class="literal">Runnable</code> interface being a functional interface and pass the necessary processing function into a new thread as a lambda expression.</li><li class="listitem1">After the <code class="literal">__________</code> method is called, no more worker threads can be added to the pool.<div class="calibre2"><ol class="orderedlist1"><li class="listitem1"><code class="literal">shutdownNow()</code></li><li class="listitem1"><code class="literal">shutdown()</code></li><li class="listitem1"><code class="literal">isShutdown()</code></li><li class="listitem1"><code class="literal">isShutdownComplete()</code></li></ol></div></li><li class="listitem1">________ is based on the <code class="literal">Observable</code> object, which plays the role of a Publisher.</li></ol></div></div></div>



  </body></html>