<html><head></head><body><div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Behavioral Design Patterns – Part One</h1>
                </header>
            
            <article>
                
<p class="mce-root">Our journey through the Scala design patterns has arrived at the group of <strong>behavioral design patterns</strong>. There are more members in this group than the others we've already been through, so we will split it into two separate parts. In this chapter, we will focus on the following behavioral design patterns:</p>
<ul>
<li>Value object</li>
<li>Null object</li>
<li>Strategy</li>
<li>Command</li>
<li>Chain of responsibility</li>
<li>Interpreter</li>
</ul>
<p>This chapter and the next one will give some clarity about what behavioral design patterns are, where they are useful, and how to implement them in Scala. We will be following a path similar to the previous chapters where we presented the patterns, showed a class diagram and a code example, and finally, gave a few hints about what to watch out for and where certain patterns are preferred to be used. Hopefully, you will get a feel for them and be able to confidently identify situations where they are applicable.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Defining behavioral design patterns</h1>
                </header>
            
            <article>
                
<p>Behavioral design patterns, as the name suggests, are to do with behavior. Their purpose is to identify and implement common communication patterns between objects in an application. They define object interaction in such a way that the communication between objects is easy and coupling is still kept at a low level.</p>
<p>Behavioral design patterns describe how objects and classes interact with each other using messages. Contrary to creational and structural design patterns, the behavioral design patterns describe a <strong>flow</strong> or a <strong>process</strong>. This means that a developer should be really familiar with the actual process they are trying to implement. As with every other type of design pattern, behavioral design patterns exist in order to increase the testability, maintainability, and flexibility of the produced code.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The value object design pattern</h1>
                </header>
            
            <article>
                
<p>In programming, there are different ways of comparing data. We can compare object identities or their values. These are useful in different scenarios and here, we will see what value objects are and when they can be used.</p>
<div class="packt_infobox">Value objects are small and simple immutable objects. Their equality is based not on identity, but on value equality.</div>
<p>Value objects are used to represent numbers, money, dates, and so on. They should be small and immutable; otherwise, changing values could cause bugs and unexpected behavior. They are quite useful in multithreaded applications due to their immutability. They are also commonly used as data transfer objects in enterprise applications.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">An example class diagram</h1>
                </header>
            
            <article>
                
<p>In languages such as Java, there is no direct support for value objects. What developers end up doing is to declare the fields as final and implement the <kbd>hashCode</kbd> and <kbd>equals</kbd> methods.</p>
<p>Immutability, however, is a concept that is pretty much enforced in Scala. We already saw the <strong>algebraic data types</strong> (<strong>ADTs</strong>) earlier—they also fall in the value object category. Case classes and tuples are also immutable and they are used to achieve the value object design pattern. The following class diagram shows an example of the value object design pattern in Scala:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/7245b962-065f-48a4-a276-328f2d2ca489.png" style="width:8.33em;height:6.67em;" width="233" height="186"/></div>
<p>This diagram really doesn't do anything special. It is a representation of a case class called <strong>Date</strong>. This is everything we need to do in order to achieve immutability and be able to implement the value object design pattern.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">A code example</h1>
                </header>
            
            <article>
                
<p>In our code example, we will use our <kbd>Date</kbd> class. Dates are quite commonly used in software products. Of course, there are libraries that provide complete functionality around date manipulations, but this should be good enough for an example. First of all, here is the <kbd>Date</kbd> class representation:</p>
<pre><span>case class </span>Date(<br/>  day: <span>Int,<br/></span><span>  </span>month: <span>String</span><span>,<br/></span><span>  </span>year: <span>Int<br/></span>)</pre>
<p>This is everything we need in order to get a value object. Scala does everything for us in the background by creating default implementations for the <kbd>hashCode</kbd>, <kbd>equals</kbd>, and <kbd>toString</kbd> methods. Case classes give us extra power, but this is out of this section's scope.</p>
<p>Now, let's use our <kbd>Date</kbd> class:</p>
<pre><span>object </span>DateExample {<br/>  <span>def </span><span>main</span>(args: Array[<span>String</span>]): <span>Unit </span>= {<br/>    <span>val </span>thirdOfMarch = <span>Date</span>(<span>3</span><span>, </span><span>"MARCH"</span><span>, </span><span>2016</span>)<br/>    <span>val </span>fourthOfJuly = <span>Date</span>(<span>4</span><span>, </span><span>"JULY"</span><span>, </span><span>2016</span>)<br/>    <span>val </span>newYear1 = <span>Date</span>(<span>31</span><span>, </span><span>"DECEMBER"</span><span>, </span><span>2015</span>)<br/>    <span>val </span>newYear2 = <span>Date</span>(<span>31</span><span>, </span><span>"DECEMBER"</span><span>, </span><span>2015</span>)<br/>    System.<span>out</span>.println(<span>s"The 3rd of March 2016 is the same as<br/>     the 4th of July 2016: </span><span>$</span>{thirdOfMarch == fourthOfJuly}<span>"</span>)<br/>    System.<span>out</span>.println(<span>s"The new year of 2015 is here twice:<br/>     </span><span>$</span>{newYear1 == newYear2}<span>"</span>)<br/>  }<br/>}</pre>
<p>As you can see, we used our object as values. We should note that here, we have absolutely no validation of the parameters; however, it is something easy to add, but not relevant for the current example. If we run our code now, we will see the following output:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/94f19c8a-5bd4-443e-b3d3-d092f2bba683.png" style="width:37.92em;height:4.75em;" width="721" height="90"/></div>
<p>Just to prove that case classes allow us to implement the value object design pattern easily and normal classes don't, let's try and change our <kbd>Date</kbd> class to a normal one and then use it in the same example. Our class will change to the following:</p>
<pre><span>class </span>BadDate(<br/>  day: <span>Int,<br/></span><span>  </span>month: <span>String</span><span>,<br/></span><span>  </span>year: <span>Int<br/></span>)</pre>
<p>Then, we will take the same example; however this time, we will use the <kbd>BadDate</kbd>, and since it's not a case class, we will create it with the <kbd>new</kbd> keyword:</p>
<pre><span>object </span>BadDateExample {<br/>  <span>def </span><span>main</span>(args: Array[<span>String</span>]): <span>Unit </span>= {<br/>    <span>val </span>thirdOfMarch = <span>new </span>BadDate(<span>3</span><span>, </span><span>"MARCH"</span><span>, </span><span>2016</span>)<br/>    <span>val </span>fourthOfJuly = <span>new </span>BadDate(<span>4</span><span>, </span><span>"JULY"</span><span>, </span><span>2016</span>)<br/>    <span>val </span>newYear1 = <span>new </span>BadDate(<span>31</span><span>, </span><span>"DECEMBER"</span><span>, </span><span>2015</span>)<br/>    <span>val </span>newYear2 = <span>new </span>BadDate(<span>31</span><span>, </span><span>"DECEMBER"</span><span>, </span><span>2015</span>)<br/>    System.<span>out</span>.println(<span>s"The 3rd of March 2016 is the same as the<br/>     4th of July 2016: </span><span>$</span>{thirdOfMarch == fourthOfJuly}<span>"</span>)<br/>    System.<span>out</span>.println(<span>s"The new year of 2015 is here twice:<br/>     </span><span>$</span>{newYear1 == newYear2}<span>"</span>)<br/>  }<br/>}</pre>
<p>The output of this example will be:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/71d761db-03fc-4bc4-b29b-534a6c6891d9.png" width="721" height="91"/></div>
<p>As you can see from the preceding output, normal classes do not work in the same way as case classes and some extra work needs to be performed in order to implement the value object design pattern with them. The reason for the preceding result is that classes, by default, are compared with each other by their reference identities and not by the values they carry. In order to change this, <kbd>hashCode</kbd> and <kbd>equals</kbd> should be implemented. Scala also allows us to override the <kbd>==</kbd> operator for the class.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Alternative implementation</h1>
                </header>
            
            <article>
                
<p>The value object design pattern can also be achieved with predefined tuple classes in Scala. In this case, we don't even need to create our class and we can write something like <kbd>(3, "March", 2016)</kbd>. This would automatically have the same characteristics as value objects. There are implementations of tuples of up to 22 elements, but using them in real applications is not recommended, as readability and quality can degrade dramatically. Moreover, two <em>n</em> element tuples can be considered equal, even if semantically they are different types of objects in our application. Last but not least, accessing elements using case classes is much easier and nicer to read than writing something like <kbd>tuple._3</kbd>.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">What it is good for</h1>
                </header>
            
            <article>
                
<p>As we already mentioned, the value object design pattern is good for multithreading and creating <strong>data transfer objects</strong> (<strong>DTOs</strong>). It is something extremely easy to achieve in Scala, and many people use it on a daily basis without even realizing that it actually is a design pattern. Value objects are another example of the fact that Scala is a really powerful language.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">What it is not so good for</h1>
                </header>
            
            <article>
                
<p>Other than using tuples to represent value objects in Scala, there are no other major drawbacks to using this pattern.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The null object design pattern</h1>
                </header>
            
            <article>
                
<p>Most object-oriented languages have a way of specifying the nonexistence of some value. In Scala and Java, for example, this could be the <kbd>null</kbd> value that can be assigned to an object. Calling any method on an object that is <kbd>null</kbd> would result in a <kbd>NullPointerException</kbd>, hence developers should be careful and check whether there is such a possibility. These checks, however, could make the source code hard to follow and extend as developers should always be aware. This is where the null object design pattern is helpful.</p>
<div class="packt_infobox">The purpose of the null object design pattern is to define an actual object that represents the <kbd>null</kbd> value and has neutral behavior.</div>
<p>Using null objects removes the need to check whether something is set to <kbd>null</kbd> or not. The code becomes much more readable and easy to understand and makes bug occurrence harder.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">An example class diagram</h1>
                </header>
            
            <article>
                
<p>For the class diagram, let's imagine that we have a system that has to poll a queue for messages. Of course, this queue might not always have anything to offer, so it would return nulls. Instead of checking for <kbd>null</kbd>, we could simply return special null objects that will have empty behavior. Let's show these message classes in a diagram:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/05ead116-8979-4772-b363-223aecce4e84.png" style="width:21.25em;height:14.92em;" width="542" height="381"/></div>
<p>Using the classes from the preceding diagram, whenever there is no number to print, we will return a <strong>NullMessage</strong> object with empty behavior. In some cases, for optimization purposes, people could have the <strong>NullMessage</strong> as a singleton instance.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">A code example</h1>
                </header>
            
            <article>
                
<p>Before we actually look at our code, we will note a few observations about the preceding diagram. It represents a classical case using the null object design pattern. However, nowadays, it is not really used this way in either Java or Scala. For example, Java now supports <kbd>Optional</kbd>, which is used instead (assuming people use new versions of the language). In Scala, things are similar—we can and do use <kbd>Option[Message]</kbd> instead of null objects. Additionally, we gain all the other nice features of <kbd>Option</kbd> such as the ability to use them in pattern matching.</p>
<p>So, as mentioned previously, our code is not really going to use the hierarchy of the preceding class diagram. It just doesn't need it and it will be much simpler. Instead, we will be using <kbd>Option[Message]</kbd>. First of all, let's see the <kbd>Message</kbd> class definition:</p>
<pre><span>case class </span>Message(number: <span>Int</span>) {<br/>  <span>def </span><span>print</span>(): <span>String </span>= <span>s"This is a message with number: </span><span>$</span>number<span>."<br/></span>}</pre>
<p>We mentioned that we will be polling a queue for messages and then displaying them. We have simulated a queue that is being randomly populated using a different thread in our application:</p>
<pre><span>import </span>java.util.concurrent.ConcurrentLinkedQueue<br/><span>import </span>scala.util.Random<span><br/><br/>class </span>DataGenerator <span>extends </span>Runnable {<br/>  <span>val </span><span>MAX_VAL </span>= <span>10<br/></span><span>  </span><span>val </span><span>MAX_TIME </span>= <span>10000<br/></span><span>  </span><span>private var </span><span>isStop </span>= <span>false<br/></span><span>  private val </span><span>queue</span>: ConcurrentLinkedQueue[<span>Int</span>] = <span>new</span><span> </span>ConcurrentLinkedQueue[<span>Int</span>]()<br/><br/>  <span>override def </span><span>run</span>(): <span>Unit </span>= {<br/>    <span>val </span>random = <span>new </span>Random()<br/>    <span>while </span>(!<span>isStop</span>) {<br/>      Thread.<span>sleep</span>(random.nextInt(<span>MAX_TIME</span>))<br/>      <span>queue</span>.add(random.nextInt(<span>MAX_VAL</span>))<br/>    }<br/>  }<br/><br/>  <span>def </span><span>getMessage</span>(): Option[Message] =<br/>    <span>Option</span>(<span>queue</span>.poll()).map {<br/>    <span>case </span>number =&gt; <span>Message</span>(number)<br/>  }<br/><br/>  <span>def </span><span>requestStop</span>(): <span>Unit </span>= <span>this</span>.synchronized {<br/>    <span>isStop </span>= <span>true<br/></span><span>  </span>}<br/>}</pre>
<p>The preceding code shows what will be run in a different thread. The queue will be populated with random values between 0 (inclusive) and 10 (exclusive) at random intervals. Then, <kbd>getMessage</kbd> can be called and whatever is in the queue can be read. Since it is possible for the queue to be empty, we return an <kbd>Option</kbd> of <kbd>Message</kbd> to the caller. It is probably worth mentioning that in Scala, <kbd>Option(null)</kbd> returns <kbd>None</kbd>. This is exactly what we took advantage of in the preceding code.</p>
<p>Let's see how everything comes together in our example:</p>
<pre><span>object </span>MessageExample {<br/>  <span>val </span><span>TIMES_TO_TRY </span>= <span>10<br/></span><span>  </span><span>val </span><span>MAX_TIME </span>= <span>5000<br/></span><span><br/></span><span>  </span><span>def </span><span>main</span>(args: Array[<span>String</span>]): <span>Unit </span>= {<br/>    <span>val </span>generator = <span>new </span>DataGenerator<br/>    <span>// start the generator in another thread<br/></span><span>    </span><span>new </span>Thread(generator).start()<br/>    <span>val </span>random = <span>new </span>Random()<br/>    (<span>0 </span>to <span>TIMES_TO_TRY</span>).foreach {<br/>      <span>case </span>time =&gt;<br/>        Thread.<span>sleep</span>(random.nextInt(<span>MAX_TIME</span>))<br/>        System.<span>out</span>.println(<span>"Getting next message..."</span>)<br/>        generator.getMessage().foreach(m =&gt;<br/>          System.<span>out</span>.println(m.print()))<br/>    }<br/>    generator.requestStop()<br/>  }<br/>}</pre>
<p>The preceding program creates a generator and makes it run on a different thread. Then, it randomly requests items from the generator and prints them if something is actually returned. Due to the use of random generators, the program will print different things every time. Here is an example run:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/c7704895-c3d7-4eaa-b5b8-1c68814f69b8.png" style="width:51.00em;height:23.25em;" width="742" height="338"/></div>
<p>As you can see from our example and the preceding output, we never actually check for nulls and our code just doesn't do anything when the queue returns <kbd>null</kbd>. This works nicely in large projects and it makes the source code look really elegant and easy to understand.</p>
<div class="packt_infobox">In real-life applications, code as in the previous example might not be a good idea. First of all, instead of calling <kbd>sleep</kbd> on a thread, we can use timers. Secondly, if we want to create producer–consumer applications, we can use libraries such as <strong>Akka</strong> (<a href="https://akka.io/">https://akka.io/</a>), which allow us to do reactive programming and have really optimal code.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">What it is good for</h1>
                </header>
            
            <article>
                
<p>As you already saw, the null object design pattern is already incorporated in Scala (and newer versions of Java) through the use of <kbd>Option</kbd> (<kbd>Optional</kbd> in Java). This makes it really easy to use and shows the power of the language once more. Using null objects makes our code look much more readable and removes the need to take extra care when a value is <kbd>null</kbd>. It also reduces the risk of bugs.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">What it is not so good for</h1>
                </header>
            
            <article>
                
<p>There are no drawbacks of this design pattern that we can think of. One thing probably worth mentioning is this—use it only when it is actually needed, not everywhere.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The strategy design pattern</h1>
                </header>
            
            <article>
                
<p>It is quite a common thing in enterprise applications to have different implementations of specific algorithms and choosing one to use while the application is running. Some examples might include different sorting algorithms that would have a different performance for different sizes or types of data, different parsers for various possible representations of data, and so on.</p>
<div class="packt_infobox">The strategy design pattern enables us to define a family of algorithms and select a specific one at runtime.</div>
<p>The strategy design pattern helps with encapsulation as each algorithm can be separately defined and then injected into the classes that use it. The different implementations are also interchangeable.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">An example class diagram</h1>
                </header>
            
            <article>
                
<p>For the class diagram, let's imagine that we are writing an application that needs to load some data from a file and then use this data somehow. Of course, the data could be represented in different formats (CSV or JSON, in this case), and depending on the file type, we will be using a different parsing strategy. The class diagram that represents our parser is shown in the following diagram:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/95f2cea4-955a-49ff-bb2e-91625b566eea.png" style="width:39.33em;height:14.50em;" width="938" height="346"/></div>
<p>We basically have an interface that the different classes implement, and then depending on which one is needed, <strong>PersonApplication</strong> gets injected with the right one.</p>
<p>The preceding class diagram looks really similar to the one we saw earlier in the book for the bridge design pattern. Even though this is the case, both patterns have different purposes—the builder is concerned with structure, while here it's all about behavior. Also, the strategy design pattern looks somewhat more coupled.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">A code example</h1>
                </header>
            
            <article>
                
<p>In the previous section, we showed the class diagram of the example we will show here. As you can see, we used a model class called <kbd>Person</kbd>. It is just a case class with the following definition:</p>
<pre><span>case class </span>Person(name: <span>String</span><span>, </span>age: <span>Int, </span>address: <span>String</span>)</pre>
<p>Since there will be different formats available in our application, we have defined a common interface that all parsers will implement:</p>
<pre><span>trait </span>Parser[<span>T</span>] {<br/>  <span>def </span><span>parse</span>(file: <span>String</span>): <span>List</span>[<span>T</span>]<br/>}</pre>
<p>Now, let's have a look at the implementations. First is the <kbd>CSVParser</kbd>:</p>
<pre><span><span class="pl-k">import</span> <span class="pl-smi">com.github.tototoshi.csv.</span><span class="pl-smi">CSVReader</span><br/><br/>class </span>CSVParser <span>extends </span>Parser[Person] {<br/>  <span>override def </span><span>parse</span>(file: <span>String</span>): <span>List</span>[Person] =<br/>    CSVReader.open(<span>new<br/></span><span>       </span><span> </span>InputStreamReader(<span>this</span>.getClass.getResourceAsStream(file))).all().map {<br/>          <span>case </span>List(name<span>, </span>age<span>, </span>address) =&gt;<br/>            Person(name<span>, </span>age.toInt<span>, </span>address)<br/>    }<br/>}</pre>
<p>It relies on a library called <kbd>scala-csv</kbd> (details in the <kbd>pom.xml/build.sbt</kbd> file), which reads each line as a list of strings. Then, they are mapped to the <kbd>Person</kbd> objects.</p>
<p>Next is the code for the <kbd>JsonParser</kbd> class:</p>
<pre><span>import </span>org.json4s._<br/><span>import </span>org.json4s.jackson.JsonMethods<br/><span><br/>class </span>JsonParser <span>extends </span>Parser[Person] {<br/>  <span>implicit val </span><span>formats </span>= DefaultFormats<br/>  <span>override def </span><span>parse</span>(file: <span>String</span>): <span>List</span>[Person] =<br/>    JsonMethods.parse(StreamInput(<span>this</span>.getClass.getResourceAsStream(file))).extract[<span>List</span>[Person]]<br/>}</pre>
<p>It reads a JSON file and parses it using the <kbd>json4s</kbd> library. As you can see, even though both implementations do the same thing, they are quite different. We cannot apply the CSV one when we have a JSON file and vice versa. The files also look really different. Here is the CSV file we are using in our example:</p>
<pre>Ivan,26,London<br/>Maria,23,Edinburgh<br/>John,36,New York<br/>Anna,24,Moscow</pre>
<p>This is the JSON file:</p>
<pre>[<br/>  {<br/>    "name": "Ivan",<br/>    "age": 26,<br/>    "address": "London"<br/>  },<br/>  {<br/>    "name": "Maria",<br/>    "age": 23,<br/>    "address": "Edinburgh"<br/>  },<br/>  {<br/>    "name": "John",<br/>    "age": 36,<br/>    "address": "New York"<br/>  },<br/>  {<br/>    "name": "Anna",<br/>    "age": 24,<br/>    "address": "Moscow"<br/>  }<br/>]</pre>
<p>Both the preceding datasets contain exactly the same data, but the formats make them look completely different and they require different approaches in parsing.</p>
<p>There is one extra thing we've done in our example. We've used a factory design pattern in order to pick the right implementation at runtime, depending on the file type:</p>
<pre><span>object </span>Parser {<br/>  <span>def </span><span>apply</span>(filename: <span>String</span>): Parser[Person] =<br/>    filename <span>match </span>{<br/>      <span>case </span>f <span>if </span>f.endsWith(<span>".json"</span>) =&gt; <span>new </span>JsonParser<br/>      <span>case </span>f <span>if </span>f.endsWith(<span>".csv"</span>) =&gt; <span>new </span>CSVParser<br/>      <span>case </span>f =&gt; <span>throw new </span>RuntimeException(<span>s"Unknown format: </span><span>$</span>f<span>"</span>)<br/>    }<br/>}</pre>
<p>The preceding factory is just an example. It only checks the file extension and of course, could be made much more robust. Using this factory, we can pick the right implementation of the parser for the application class to use, whose code is shown as follows:</p>
<pre><span>class </span>PersonApplication[<span>T</span>](parser: Parser[<span>T</span>]) {<br/>  <span>def </span><span>write</span>(file: <span>String</span>): <span>Unit </span>= {<br/>    System.<span>out</span>.println(<span>s"Got the following data </span><span>$</span>{parser.parse(file)}<span>"</span>)<br/>  }<br/>}</pre>
<p>The application class looks the same no matter what the implementation is. Different implementations could be plugged in, and as long as there are no errors, everything should run.</p>
<p>Now, let's see how we can use our strategy design pattern in our example:</p>
<pre><span>object </span>ParserExample {<br/>  <span>def </span><span>main</span>(args: Array[<span>String</span>]): <span>Unit </span>= {<br/>    <span>val </span>csvPeople = <span>Parser</span>(<span>"people.csv"</span>)<br/>    <span>val </span>jsonPeople = <span>Parser</span>(<span>"people.json"</span>)<br/>    <span>val </span>applicationCsv = <span>new </span>PersonApplication(csvPeople)<br/>    <span>val </span>applicationJson = <span>new </span>PersonApplication(jsonPeople)<br/>    System.<span>out</span>.println(<span>"Using the csv: "</span>)<br/>    applicationCsv.write(<span>"people.csv"</span>)<br/>    System.<span>out</span>.println(<span>"Using the json: "</span>)<br/>    applicationJson.write(<span>"people.json"</span>)<br/>  }<br/>}</pre>
<p>As you can see, it's pretty simple. The output of the preceding application is shown as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/73e1d7b4-dbec-40ec-8400-d8a67d54e516.png" style="width:41.92em;height:9.67em;" width="732" height="169"/></div>
<p>In both cases, our application coped just fine with the different formats. Adding new implementations for new formats is also straightforward—just implement the <kbd>Parser</kbd> interface and make sure the factory knows about them.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The strategy design pattern the Scala way</h1>
                </header>
            
            <article>
                
<p>In the preceding section, we showed the strategy design pattern using classes and traits. This is what it would look in a purely object-oriented language. However, Scala is also functional and provides more ways to achieve it by writing far less code. In this subsection, we will show the strategy design pattern by taking advantage of the fact that in Scala, functions are first-class objects.</p>
<p>The first thing that will change is that we will not need to have an interface and classes that implement it. Instead, our <kbd>Application</kbd> class will look like the following:</p>
<pre><span>class </span>Application[<span>T</span>](strategy: (<span>String</span>) =&gt; <span>List</span>[<span>T</span>]) {<br/>  <span>def </span><span>write</span>(file: <span>String</span>): <span>Unit </span>= {<br/>    System.<span>out</span>.println(<span>s"Got the following data </span><span>$</span>{strategy(file)}<span>"</span>)<br/>  }<br/>}</pre>
<p>The most important thing to note here is that the strategy parameter is a function instead of a normal object. This instantly allows us to pass any function we want there without the need to implement specific classes, as long as it satisfies these requirements—one <kbd>String</kbd> parameter and returns a <kbd>List[T]</kbd>. If we have multiple methods in our strategy, we can use a case class or a tuple to group them.</p>
<p>For the current example, we've decided to have the function implementations somewhere so that they are grouped with the factory, which will choose which one to use:</p>
<pre><span>import com.github.tototoshi.csv.CSVReader<br/>import org.json4s.{StreamInput, DefaultFormat}<br/>import org.json4s.jackson.JsonMethods<br/><br/>object </span>StrategyFactory {<br/>  <span>implicit val </span><span>formats </span>= DefaultFormats<br/>  <br/>  <span>def </span><span>apply</span>(filename: <span>String</span>): (<span>String</span>) =&gt; <span>List</span>[Person] =<br/>    filename <span>match </span>{<br/>      <span>case </span>f <span>if </span>f.endsWith(<span>".json"</span>) =&gt; <span>parseJson<br/></span><span>      </span><span>case </span>f <span>if </span>f.endsWith(<span>".csv"</span>) =&gt; <span>parseCsv<br/></span><span>      </span><span>case </span>f =&gt; <span>throw new </span>RuntimeException(<span>s"Unknown format: </span><span>$</span>f<span>"</span>)<br/>    }<br/>  <br/>  <span>def </span><span>parseJson</span>(file: <span>String</span>): <span>List</span>[Person] =<br/>    JsonMethods.parse(StreamInput(<span>this</span>.getClass.getResourceAsStream(file))).extract[<span>List</span>[Person]]<br/>  <br/>  <span>def </span><span>parseCsv</span>(file: <span>String</span>): <span>List</span>[Person] = CSVReader.open(<span>new<br/></span><span>      </span>InputStreamReader(<span>this</span>.getClass.getResourceAsStream(file))).all().map {<br/>        <span>case </span>List(name<span>, </span>age<span>, </span>address) =&gt; Person(name<span>, </span>age.toInt<span>, </span>address)<br/>  }<br/>}</pre>
<p>The preceding code has the same factory as before, but this time it returns methods, which can then be called.</p>
<p>Finally, here is how to use the application:</p>
<pre><span>object </span>StrategyExample {<br/>  <span>def </span><span>main</span>(args: Array[<span>String</span>]): <span>Unit </span>= {<br/>    <span>val </span>applicationCsv = <span>new </span>Application[Person](<span>StrategyFactory</span>(<span>"people.csv"</span>))<br/>    <span>val </span>applicationJson = <span>new </span>Application[Person](<span>StrategyFactory</span>(<span>"people.json"</span>))<br/>    System.<span>out</span>.println(<span>"Using the csv: "</span>)<br/>    applicationCsv.write(<span>"people.csv"</span>)<br/>    System.<span>out</span>.println(<span>"Using the json: "</span>)<br/>    applicationJson.write(<span>"people.json"</span>)<br/>  }<br/>}</pre>
<p>The output of the preceding example will be absolutely the same as before.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">What it is good for</h1>
                </header>
            
            <article>
                
<p>The strategy design pattern helps us when we want to be able to change implementations at runtime. Also, as we can see, the implementations live separately from the code that uses them, so it's quite easy to add new ones without the risk of introducing bugs in other parts of our system.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">What it is not so good for</h1>
                </header>
            
            <article>
                
<p>Even though, in the long run, the Scala way of implementing the strategy pattern that uses functions could save a lot on code, sometimes it affects readability and maintainability. The fact that the methods could be stored in an object, class, case class, trait, and so on, indicates the fact that different people could prefer different approaches, and this is not always good while working in a big team. Apart from that, the strategy design pattern doesn't have any major flaws as long as it's used in the right way and in the right places.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The command design pattern</h1>
                </header>
            
            <article>
                
<p>Sometimes in our applications, we might need to pass information to other objects about how to perform some action. Usually, this action will be executed at a later time based on some kind of event. The object that will execute our commands is called <strong>invoker</strong>, and it might not even be aware of the command it actually runs. It just knows about the interface, which means that it knows how to trigger the command. The command design pattern helps us to achieve this.</p>
<div class="packt_infobox">The purpose of the command design pattern is to encapsulate the information needed to perform an action at a later stage and pass this information to the object that will be running the actual code.</div>
<p>Usually, the command information will contain the object that owns the method, the method name, and the parameters that should be passed when invoking the method. The command design pattern is useful for many things, some of which include supporting undo actions, implementing parallel processing, or simply optimizing code by deferring, and possibly avoiding code execution.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">An example class diagram</h1>
                </header>
            
            <article>
                
<p>When talking about the command design pattern, there are usually a couple of objects, each of which has its specific role:</p>
<ul>
<li><strong>Command</strong>: We can think of this as the interface and its implementations that are being called by the invoker.</li>
<li><strong>Receiver</strong>: This is the object that actually knows how commands are executed. Think of this as an object that is being passed to the command and then used in the interface method.</li>
<li><strong>Invoker</strong>: It invokes the commands by calling their interface method. As we mentioned earlier, it might not even know what commands are being invoked.</li>
<li><strong>Client</strong>: It more or less guides which commands are executed when by using the invoker.</li>
</ul>
<p>Now that we know the most important objects and their roles in the command design pattern, we can take a look at an example. For the class diagram, let's imagine that we have a robot, which can cook. We connect to it through a controller and send commands to our robot. Things are pretty simplified, but should be good enough to understand how this pattern works. Here is the class diagram:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/f4631968-eec5-4de7-afa4-4e05bb6679da.png" width="1303" height="571"/></div>
<p>We can quickly identify that here, the <strong>RobotCommand</strong> interface and its implementations are the command. The receiver is the <strong>Robot</strong> class as it knows how to run all the commands issued to it. The <strong>RobotController</strong> class is the invoker. It doesn't know what types of commands it executes, just runs them whenever needed. We haven't shown our client class in the preceding diagram, as it is simply represented by the example application that runs the code, which implements the previously shown class diagram.</p>
<p>You can easily see that if the code representing the preceding diagram is changed, it could easily add multithreaded support and support for undo.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">A code example</h1>
                </header>
            
            <article>
                
<p>Now, it's time to see the interesting part representing the previous diagram—the code. As always, we will be going through the individual classes and giving brief explanations where necessary.</p>
<p>The first piece of code that we will look at is the <kbd>Robot</kbd> class. We already mentioned that it acts as the receiver and knows how to execute some specific functionality:</p>
<pre><span>case class </span>Robot() {<br/>  <span>def </span><span>cleanUp</span>(): <span>Unit </span>= System.<span>out</span>.println(<span>"Cleaning up."</span>)<br/>  <span>def </span><span>pourJuice</span>(): <span>Unit </span>= System.<span>out</span>.println(<span>"Pouring juice."</span>)<br/>  <span>def </span><span>makeSandwich</span>(): <span>Unit </span>= System.<span>out</span>.println(<span>"Making a sandwich."</span>)<br/>}</pre>
<p>We've kept the code simple and the methods just print different things to the command line. Next is the robot command with its different implementations:</p>
<pre><span>trait </span>RobotCommand {<br/>  <span>def </span><span>execute</span>(): <span>Unit<br/></span>}<br/><br/><span>case class </span>MakeSandwichCommand(robot: Robot) <span>extends </span>RobotCommand {<br/>  <span>override def </span><span>execute</span>(): <span>Unit </span>= robot.makeSandwich()<br/>}<br/><br/><span>case class </span>PourJuiceCommand(robot: Robot) <span>extends </span>RobotCommand {<br/>  <span>override def </span><span>execute</span>(): <span>Unit </span>= robot.pourJuice()<br/>}<br/><br/><span>case class </span>CleanUpCommand(robot: Robot) <span>extends </span>RobotCommand {<br/>  <span>override def </span><span>execute</span>(): <span>Unit </span>= robot.cleanUp()<br/>}</pre>
<p>There is absolutely nothing special about the preceding code. It is a simple trait, which is implemented by different classes. It relies on the <kbd>Robot</kbd> receiver, which knows how to execute methods.</p>
<p>The <kbd>RobotController</kbd> class is our invoker and issues commands given to it according to the <kbd>RobotCommand</kbd> interface. It doesn't need to know anything about the commands that it issues, as long as the interface is followed. We've decided to add some history of the commands that can be used for rollbacks later. The code for the invoker is shown as follows:</p>
<pre><span>class </span>RobotController {<br/>  <span>val </span><span>history </span>= ListBuffer[RobotCommand]()<br/><br/>  <span>def </span><span>issueCommand</span>(command: RobotCommand): <span>Unit </span>= {<br/>    command +=: <span>history<br/></span><span>    </span>command.execute()<br/>  }<br/><br/>  <span>def </span><span>showHistory</span>(): <span>Unit </span>= {<br/>    <span>history</span>.foreach(<span>println</span>)<br/>  }<br/>}</pre>
<p>Now, let's take a look at the example that uses all of the preceding classes. As we already mentioned earlier, it would actually act as a client. Here is the source code:</p>
<pre><span>object </span>RobotExample {<br/>  <span>def </span><span>main</span>(args: Array[<span>String</span>]): <span>Unit </span>= {<br/>    <span>val </span>robot = <span>Robot</span>()<br/>    <span>val </span>robotController = <span>new </span>RobotController<br/>    robotController.issueCommand(<span>MakeSandwichCommand</span>(robot))<br/>    robotController.issueCommand(<span>PourJuiceCommand</span>(robot))<br/>    System.<span>out</span>.println(<span>"I'm eating and having some juice."</span>)<br/>    robotController.issueCommand(<span>CleanUpCommand</span>(robot))<br/>    System.<span>out</span>.println(<span>"Here is what I asked my robot to do:"</span>)<br/>    robotController.showHistory()<br/>  }<br/>}</pre>
<p>The output of this application will be the same as in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/59a4ffe3-cc05-4d67-ba2e-ae2ce4a82a40.png" style="width:41.83em;height:11.67em;" width="726" height="203"/></div>
<p>We can see that our invoker successfully saves the history of the events. This means that as long as our commands and then the receiver (<kbd>Robot</kbd>) have the undo methods, we can implement these and have extra functionality.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The command design pattern the Scala way</h1>
                </header>
            
            <article>
                
<p>The command design pattern is another example of a design pattern that can be implemented differently in Scala compared to other languages. We will show another implementation of the preceding example. This time, we will use the <strong>by-name parameters</strong> feature of the language. It is replaceable with passing functions as parameters (something we've already seen before for the strategy design pattern), but more verbose. Let's see what it will look like.</p>
<p>Not much of the application actually has to change. We've only refactored and renamed the <kbd>RobotController</kbd> and <kbd>RobotExample</kbd> classes. Here is the former class, now called <kbd>RobotByNameController</kbd>:</p>
<pre><span>class </span>RobotByNameController {<br/>  <span>val </span><span>history </span>= ListBuffer[() =&gt; <span>Unit</span>]()<br/><br/>  <span>def </span><span>issueCommand</span>(command: =&gt; <span>Unit</span>): <span>Unit </span>= {<br/>    command _ +=: <span>history<br/></span><span>    </span>command<br/>  }<br/><br/>  <span>def </span><span>showHistory</span>(): <span>Unit </span>= {<br/>    <span>history</span>.foreach(<span>println</span>)<br/>  }<br/>}</pre>
<p>As you can see, we don't pass an actual command object but just a by-name parameter to the <kbd>issueCommand</kbd> method. What this method does is defer a call to whatever retrieves the value passed until it is actually needed. In order to make the preceding code work, we had to refactor our example code as well:</p>
<pre><span>object </span>RobotByNameExample {<br/>  <span>def </span><span>main</span>(args: Array[<span>String</span>]): <span>Unit </span>= {<br/>    <span>val </span>robot = <span>Robot</span>()<br/>    <span>val </span>robotController = <span>new </span>RobotByNameController<br/>    robotController.issueCommand(<span>MakeSandwichCommand</span>(robot).execute())<br/>    robotController.issueCommand(<span>PourJuiceCommand</span>(robot).execute())<br/>    System.<span>out</span>.println(<span>"I'm eating and having some juice."</span>)<br/>    robotController.issueCommand(<span>CleanUpCommand</span>(robot).execute())<br/>    System.<span>out</span>.println(<span>"Here is what I asked my robot to do:"</span>)<br/>    robotController.showHistory()<br/>  }<br/>}</pre>
<p>The by-name parameters method is useful when we don't want to write extra code for the command interface and its implementations. We could just pass any function call (in this case, directly from the receiver) and it will be held off until the data is needed, or not called at all. The output will be the same as before, but with the exception that now we have functions, and the history printout will look slightly different.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">What it is good for</h1>
                </header>
            
            <article>
                
<p>The command design pattern is useful for cases where we want to delay, log, or sequence method calls for one reason or another. Another advantage is that it decouples the invoker from the object that actually performs the specific operations. This allows us to have modifications and to add new functionality pretty easily.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">What it is not so good for</h1>
                </header>
            
            <article>
                
<p>Even though the by-name parameter method looks nice and could make our writing shorter, it might not be a great idea here. A big disadvantage compared with our previous example is that we could actually plug any <kbd>Unit</kbd> data there, which could possibly not be relevant to what the receivers are supposed to do. In other cases, though, the by-name parameter technique is quite useful and could dramatically improve our application performance.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The chain of responsibility design pattern</h1>
                </header>
            
            <article>
                
<p>Nowadays, with the growth of data sizes and the hype around big data, stream processing is something that many applications will have to be able to do. Stream processing is characterized by an endless stream of data, which is passed from one object to another while each of them could be doing some processing and then passing it on to the next one. In other cases, data could be moved on in the chain until it arrives at an object which knows how to process a certain command.</p>
<p>The preceding behavior is really suitable for the chain of responsibility design pattern.</p>
<div class="packt_infobox">The purpose of the chain of responsibility design pattern is to decouple the sender of a request from its receiver by giving multiple objects the chance to handle the request.</div>
<p>There could be some variations to the chain of responsibility design pattern. The original pattern is that whenever a request reaches an object that can process it, it doesn't go any further. However, in some cases, we might need to push the request further or even multiply it and broadcast to other receivers.</p>
<p>It is worth noting that the chain of responsibility is not data-specific at all, and it can be used in any scenario where the preceding characteristics emerge.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">An example class diagram</h1>
                </header>
            
            <article>
                
<p>A common example used to illustrate the chain of responsibility design pattern is about event handling in applications, depending on whether they come from a mouse or a keyboard action. For our class diagram and code example, let's take a look at something else that we use every day—ATMs. How do they return the right amount in different note combinations? The answer is, of course, the chain of responsibility.</p>
<p>We will present two diagrams here—one of the classes that allow us to achieve the chain of responsibility pattern and another that will show how those classes are used together to build our ATM.</p>
<p>First, let's take a look at our classes separately:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/17307c75-3a65-4533-83fa-1df092000a90.png" style="width:38.00em;height:13.58em;" width="1021" height="365"/></div>
<p>In the preceding diagram, we have a base class (represented as a trait in Scala), which is then extended by the different concrete dispensers. Each dispenser has an optional instance of the same class, and in this way, we can build a chain. The <kbd>dispense</kbd> method is the same for all the dispensers, and then each of the dispensers has a different amount and a different next element in the chain.</p>
<p>Things will get much clearer as we present our ATM implementation. It can be seen in the following diagram:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/12206287-a157-4b02-80da-3c36a10fa97c.png" style="width:18.58em;height:29.25em;" width="487" height="768"/></div>
<p>The preceding diagram shows the actual chain that we have in our ATM. Whenever someone requests money, the ATM will go to the dispenser for 50 pound notes, then to a lower dispenser and so on until the request of the user is satisfied. In the following subsection, we will present our code step by step.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">A code example</h1>
                </header>
            
            <article>
                
<p>Let's look at the code for the preceding example, one step at a time. First of all, we have defined a <kbd>Money</kbd> class that represents the amount the user requests. The definition looks like the following:</p>
<pre>case class Money(amount: Int)</pre>
<p>Now, let's have a look at the <kbd>Dispenser</kbd> trait. It is the one that the concrete dispensers extend, as shown here:</p>
<pre><span>trait </span>Dispenser {<br/>  <span>val </span>amount: <span>Int<br/></span><span>  </span><span>val </span>next: Option[Dispenser]<br/><br/>  <span>def </span><span>dispense</span>(money: Money): <span>Unit </span>= {<br/>    <span>if </span>(money.amount &gt;= amount) {<br/>      <span>val </span>notes = money.amount / amount<br/>      <span>val </span>left = money.amount % amount<br/>      System.<span>out</span>.println(<span>s"Dispensing </span><span>$</span>notes<span> note/s of </span><span>$</span>amount<span>."</span>)<br/>      <span>if </span>(left &gt; <span>0</span>) next.map(_.dispense(<span>Money</span>(left)))<br/>    } <span>else </span>{<br/>      next.foreach(_.dispense(money))<br/>    }<br/>  }<br/>}</pre>
<p>As we mentioned in the preceding section, the dispense method is the same for everyone who extends our <kbd>Dispenser</kbd>, but the amount and the next element of the chain are to be defined by whoever extends it. The <kbd>dispense</kbd> method tries to return as many notes as possible of the given nomination; after this, it passes the responsibility to the next dispenser if there is still money to be given.</p>
<p>The following code block shows our implementations of the different dispensers—for notes of <kbd>50</kbd>, <kbd>20</kbd>, <kbd>10</kbd>, and <kbd>5</kbd> pounds:</p>
<pre><span>class </span>Dispenser50(<span>val </span>next: Option[Dispenser]) <span>extends </span>Dispenser {<br/>  <span>override val </span><span>amount </span>= <span>50<br/></span>}<br/><br/><span>class </span>Dispenser20(<span>val </span>next: Option[Dispenser]) <span>extends </span>Dispenser {<br/>  <span>override val </span><span>amount</span>: <span>Int </span>= <span>20<br/></span>}<br/><br/><span>class </span>Dispenser10(<span>val </span>next: Option[Dispenser]) <span>extends </span>Dispenser {<br/>  <span>override val </span><span>amount</span>: <span>Int </span>= <span>10<br/></span>}<br/><br/><span>class </span>Dispenser5(<span>val </span>next: Option[Dispenser]) <span>extends </span>Dispenser {<br/>  <span>override val </span><span>amount</span>: <span>Int </span>= <span>5<br/></span>}</pre>
<p>What we have shown so far is the essence of the chain of responsibility design pattern. Using the defined classes, we will now build a chain that can be used easily.</p>
<p>Here is the code for our <kbd>ATM</kbd> class:</p>
<pre><span>class </span>ATM {<br/>  <span>val </span><span>dispenser</span>: Dispenser = {<br/>    <span>val </span>d1 = <span>new </span>Dispenser5(None)<br/>    <span>val </span>d2 = <span>new </span>Dispenser10(<span>Some</span>(d1))<br/>    <span>val </span>d3 = <span>new </span>Dispenser20(<span>Some</span>(d2))<br/>    <span>new </span>Dispenser50(<span>Some</span>(d3))<br/>  }<br/><br/>  <span>def </span><span>requestMoney</span>(money: Money): <span>Unit </span>= {<br/>    <span>if </span>(money.amount % <span>5 </span>!= <span>0</span>) {<br/>      System.<span>err</span>.println(<span>"The smallest nominal is 5 and we cannot<br/>       satisfy your request."</span>)<br/>    } <span>else </span>{<br/>      <span>dispenser</span>.dispense(money)<br/>    }<br/>  }<br/>}</pre>
<p>In the preceding code, we built the dispenser chain that will be used by our <kbd>ATM</kbd> class. The order here is really important for the correct functioning of the system. We have also done some sanity checks. The use of our <kbd>ATM</kbd> class is then pretty straightforward with the following application:</p>
<pre><span>object </span>ATMExample {<br/>  <span>def </span><span>main</span>(args: Array[<span>String</span>]): <span>Unit </span>= {<br/>    <span>val </span>atm = <span>new </span>ATM<br/>    <span>printHelp</span>()<br/>    Source.<span>stdin</span>.getLines().foreach {<br/>      <span>case </span>line =&gt;<br/>        <span>processLine</span>(line<span>, </span>atm)<br/>    }<br/>  }<br/><br/>  <span>def </span><span>printHelp</span>(): <span>Unit </span>= {<br/>    System.<span>out</span>.println(<span>"Usage: "</span>)<br/>    System.<span>out</span>.println(<span>"1. Write an amount to withdraw..."</span>)<br/>    System.<span>out</span>.println(<span>"2. Write EXIT to quit the application."</span>)<br/>  }<br/><br/>  <span>def </span><span>processLine</span>(line: <span>String</span><span>, </span>atm: ATM): <span>Unit </span>= {<br/>    line <span>match </span>{<br/>      <span>case </span><span>"EXIT" </span>=&gt;<br/>        System.<span>out</span>.println(<span>"Bye!"</span>)<br/>        System.<span>exit</span>(<span>0</span>)<br/>      <span>case </span>l =&gt;<br/>        <span>try </span>{<br/>          atm.requestMoney(<span>Money</span>(l.toInt))<br/>          System.<span>out</span>.println(<span>"Thanks!"</span>)<br/>        } <span>catch </span>{<br/>          <span>case </span>_: <span>Throwable </span>=&gt;<br/>            System.<span>err</span>.println(<span>s"Invalid input: </span><span>$</span>l<span>."</span>)<br/>            <span>printHelp</span>()<br/>        }<br/>    }<br/>  }<br/>}</pre>
<p>This is an interactive application that waits for the user input and then uses the ATM. Let's see how an example run of this will look in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/f5e575c8-c2b6-4caa-adec-859ffd0f7c2e.png" width="732" height="385"/></div>
<p>As you can see in the code, our ATM doesn't have the extra functionality that other ATMs have—check note availability. This, however, is a functionality that can be extended further.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The chain of responsibility design pattern the Scala way</h1>
                </header>
            
            <article>
                
<p>Looking more carefully at the code and the class diagram, you can see some similarities to the decorator design pattern. This means that here, we can use the same stackable traits, which use the <kbd>abstract override</kbd> construct. We've already seen an example of this and it will not provide you with any new information. However, there is another functionality of the Scala programming language that we can use in order to achieve the chain of responsibility design pattern—partial functions.</p>
<p>Using partial functions, we don't need to define the specific dispenser classes separately. Our dispenser will change to the following:</p>
<pre><span>trait </span>PartialFunctionDispenser {<br/>  <span>def </span><span>dispense</span>(dispenserAmount: <span>Int</span>): PartialFunction[Money<span>, </span>Money] = {<br/>    <span>case </span><span>Money</span>(amount) <span>if </span>amount &gt;= dispenserAmount =&gt;<br/>      <span>val </span>notes = amount / dispenserAmount<br/>      <span>val </span>left = amount % dispenserAmount<br/>      System.<span>out</span>.println(<span>s"Dispensing </span><span>$</span>notes<span> note/s of </span><span>$</span>dispenserAmount<span>."</span>)<br/>      <span>Money</span>(left)<br/>    <span>case </span>m @ <span>Money</span>(amount) =&gt; m<br/>  }<br/>}</pre>
<p>Of course, there are different ways to do this—we can have an abstract trait and then implement the partial function (something similar to the original example) and not specify the <kbd>dispenserAmount</kbd> parameter, or we can have one trait with different implementations of this function instead of passing the <kbd>dispenserAmount</kbd> parameter, and so on. Doing this, however, allows us to later simulate the existence of an infinite number of different notes.</p>
<p>After we have our new dispenser, which returns a <kbd>PartialFunction</kbd> instead of nothing (<kbd>Unit</kbd>), we can define our <kbd>ATM</kbd> class:</p>
<pre><span>class </span>PartialFunctionATM <span>extends </span>PartialFunctionDispenser {<br/>  <span>val </span><span>dispenser </span>=<br/>    dispense(<span>50</span>)<br/>      .andThen(dispense(<span>20</span>))<br/>      .andThen(dispense(<span>10</span>))<br/>      .andThen(dispense(<span>5</span>))<br/><br/>  <span>def </span><span>requestMoney</span>(money: Money): <span>Unit </span>= {<br/>    <span>if </span>(money.amount % <span>5 </span>!= <span>0</span>) {</pre>
<pre>      System.<span>err</span>.println(<span>"The smallest nominal is 5 and we cannot<br/>       satisfy your request."</span>)<br/>    } <span>else </span>{<br/>      <span>dispenser</span>(money)<br/>    }<br/>  }<br/>}</pre>
<p>The interesting part here is the <kbd>dispenser</kbd> field and the way we use it. In the preceding code, we chained multiple partial functions using the <kbd>andThen</kbd> method and finally, we used the result of them as a method.</p>
<div class="packt_tip">Depending on what chains the developer wants to create, they can use the <kbd>orElse</kbd> or <kbd>andThen</kbd> methods of the partial functions. The former is useful for single handlers and the latter for chaining.</div>
<p>Running the original example, but with substituted ATM implementations, will yield absolutely identical results.</p>
<p>As you saw in this subsection, using partial functions can make our application more flexible and will require us to write less code. However, it might be more demanding in terms of understanding advanced Scala language concepts.</p>
<p>Just for completeness, it is worth mentioning that we can also implement the chain of responsibility design pattern using the Akka library. We will be looking into this library in the later chapters of this book, and you will hopefully be able to see how this design pattern can be moved to reactive programming with Scala.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">What it is good for</h1>
                </header>
            
            <article>
                
<p>The chain of responsibility design pattern should be used when we want to decouple a sender of a request from the receivers and have these receivers separated into their own entities. It is good for creating pipelines and handling events.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">What it is not so good for</h1>
                </header>
            
            <article>
                
<p>As a negative and a possible pitfall of the chain of responsibility design pattern, we will talk about the implementation involving partial functions. This is because it might not always be able to achieve what the developers want, and this could further complicate code and affect readability.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The interpreter design pattern</h1>
                </header>
            
            <article>
                
<p>In modern programming, we sometimes have to deal with problems from well-understood and well-defined domains. In some cases, it makes sense to represent the domain with a language, which could then make it easy to solve problems using an interpreter.</p>
<div class="packt_infobox">The interpreter design pattern is useful for specifying how to evaluate sentences in a language by representing it using classes and building syntax trees to evaluate the language expressions.</div>
<p>The interpreter design pattern makes use of the composite design pattern as well. Some common uses of interpreters are for language parsing, protocols, and so on.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">An example class diagram</h1>
                </header>
            
            <article>
                
<p>Creating a language and grammar is a complicated task and before getting into it, developers should be confident that it is actually worth the effort. It requires a really good understanding of the domain that is being modeled and usually takes some time. In this section, we will present the class diagram concerning the interpreter part of a program that parses and evaluates an expression in <em>reverse Polish notation</em>. This is an important concept in computer science and it shows how computers actually work in performing different operations. The screenshot is shown as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/d8c5b38f-8863-4513-bb8c-e39f34a7fe82.png" style="width:41.42em;height:6.92em;" width="738" height="123"/></div>
<p>The main concept of our language is the <kbd>Expression</kbd>. Everything is an expression, which is being interpreted.</p>
<p>We can distinguish two main types of expressions in our diagram:</p>
<ul>
<li><strong>Terminal expression</strong>: This is the <kbd>Number</kbd> class. It is a terminal in the sense that when building the syntax tree of an expression, it has no other children (leaf node).</li>
<li><strong>Nonterminal expression</strong>: These are the <kbd>Add</kbd>, <kbd>Subtract</kbd>, and <kbd>Multiply</kbd> classes. They have children expressions and this is how the entire syntax tree is built.</li>
</ul>
<p>The preceding screenshot shows only those expressions into which the interpreter will be converting our language. In the following subsection, we will additionally show all the other classes that can make such an application work.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">A code example</h1>
                </header>
            
            <article>
                
<p>Here, we will show the code of our interpreter application step by step. We currently have some limitations such as only supporting integers, not having a good error reporting mechanism, and only having three operations, but it is easy to add new ones. You could try and build on top of what we already have.</p>
<p>First of all, let's see the base <kbd>Expression</kbd> trait:</p>
<pre><span>trait </span>Expression {<br/>  <span>def </span><span>interpret</span>(): <span>Int<br/></span>}</pre>
<p>It is really simple and contains one method that other expressions will have to implement. The terminal expression, which is our <kbd>Number</kbd> class, looks like the following:</p>
<pre><span>class </span>Number(n: <span>Int</span>) <span>extends </span>Expression {<br/>  <span>override def </span><span>interpret</span>(): <span>Int </span>= n<br/>}</pre>
<p>It doesn't do anything special—just returns the number it carries when <kbd>interpret</kbd> is called. The nonterminal expressions have a bit more code, but they are all really simple:</p>
<pre><span>class </span>Add(right: Expression<span>, </span>left: Expression) <span>extends </span>Expression {<br/>  <span>override def </span><span>interpret</span>(): <span>Int </span>= left.interpret() + right.interpret()<br/>}<br/><br/><span>class </span>Subtract(right: Expression<span>, </span>left: Expression) <span>extends </span>Expression {<br/>  <span>override def </span><span>interpret</span>(): <span>Int </span>= left.interpret() - right.interpret()<br/>}<br/><br/><span>class </span>Multiply(right: Expression<span>, </span>left: Expression) <span>extends </span>Expression {<br/>  <span>override def </span><span>interpret</span>(): <span>Int </span>= left.interpret() * right.interpret()<br/>}</pre>
<p>So far, this is everything that we showed in our diagram, and it is the essential part of the interpreter design pattern. Some people might notice that everywhere in the constructors, we have the right-hand expression first and then the left-hand one. This was done on purpose as it would make the code much cleaner later, when we actually implement our parser.</p>
<p>From now on, we will show how to parse and use the design pattern in real applications. First of all, we need to create a factory that is based on a token that decides which expression it should return:</p>
<pre><span>object </span>Expression {<br/>  <span>def </span><span>apply</span>(operator: <span>String</span><span>, </span>left: =&gt; Expression<span>, </span>right: =&gt; Expression): Option[Expression] =<br/>    operator <span>match </span>{<br/>      <span>case </span><span>"+" </span>=&gt; <span>Some</span>(<span>new </span>Add(right<span>, </span>left))<br/>      <span>case </span><span>"-" </span>=&gt; <span>Some</span>(<span>new </span>Subtract(right<span>, </span>left))<br/>      <span>case </span><span>"*" </span>=&gt; <span>Some</span>(<span>new </span>Multiply(right<span>, </span>left))<br/>      <span>case </span>i <span>if </span>i.matches(<span>"</span><span>\\</span><span>d+"</span>) =&gt; <span>Some</span>(<span>new </span>Number(i.toInt))<br/>      <span>case </span>_ =&gt; None<br/>    }<br/>}</pre>
<p>In the preceding code, we applied some of the techniques and design patterns that we already went through—factory and by-name parameters. The latter are really important, as based on which case our code hit determines whether they will be evaluated or not.</p>
<p>We have a parser class that looks like the following:</p>
<pre><span>class </span>RPNParser {<br/>  <span>def </span><span>parse</span>(expression: <span>String</span>): Expression = {<br/>    <span>val </span>tokenizer = <span>new </span>StringTokenizer(expression)<br/>    tokenizer.asScala.foldLeft(mutable.Stack[Expression]()) {<br/>      <span>case </span>(result<span>, </span>token) =&gt; <br/>        <span>val </span>item = <span>Expression</span>(token.toString<span>, </span>result.pop()<span>, </span>result.pop())<br/>        item.foreach(result.push)<br/>        result<br/>    }.pop()<br/>  }<br/>}</pre>
<p>Here, we relied on a <kbd>StringTokenizer</kbd> and a stack. We used the factory method we defined before, and this is where the interesting part is—<kbd>pop</kbd> will be called on the stack only if we fall in an operator case. It will be called in the order in which we use the parameters inside the factory.</p>
<div class="packt_tip"><span class="packt_screen">Popping elements from the stack</span><br/>
<br/>
As you can see from the preceding code, in the factory, we used by-name parameters and everywhere we first access the right parameter and then the left parameter. This, and the fact that our expression classes have the right parameter specified first, makes our code cleaner and makes sure that everything works as expected. The reason this is done is because of the fact that we rely on a stack and it reverses the operator order.</div>
<p>After we process an expression, if everything goes well, we should have only one element in the stack, which will have the complete tree. Then, we will have an interpreter class that just gets an expression and calls the <kbd>interpret</kbd> method on it:</p>
<pre><span>class </span>RPNInterpreter {<br/>  <span>def </span><span>interpret</span>(expression: Expression): <span>Int </span>= expression.interpret()<br/>}</pre>
<p>Finally, let's see an application that uses our language and the interpreter design pattern:</p>
<pre><span>object </span>RPNExample {<br/>  <span>def </span><span>main</span>(args: Array[<span>String</span>]): <span>Unit </span>= {<br/>    <span>val </span>expr1 = <span>"1 2 + 3 * 9 10 + -" </span><span>// (1 + 2) * 3 - (9 + 10) = -10<br/></span><span>    </span><span>val </span>expr2 = <span>"1 2 3 4 5 * * - +" </span><span>// 1 + 2 - 3 * 4 * 5 = -57<br/></span><span>    </span><span>val </span>expr3 = <span>"12 -" </span><span>// invalid<br/></span><span>    </span><span>val </span>parser = <span>new </span>RPNParser<br/>    <span>val </span>interpreter = <span>new </span>RPNInterpreter<br/>    System.<span>out</span>.println(<span>s"The result of '</span><span>$</span>{expr1}<span>' is:<br/>     </span><span>$</span>{interpreter.interpret(parser.parse(expr1))}<span>"</span>)<br/>    System.<span>out</span>.println(<span>s"The result of '</span><span>$</span>{expr2}<span>' is:<br/>     </span><span>$</span>{interpreter.interpret(parser.parse(expr2))}<span>"</span>)<br/>    <span>try </span>{<br/>      System.<span>out</span>.println(<span>s"The result is:<br/>       </span><span>$</span>{interpreter.interpret(parser.parse(expr3))}<span>"</span>)<br/>    } <span>catch </span>{<br/>      <span>case </span>_: <span>Throwable </span>=&gt; System.<span>out</span>.println(<span>s"'</span><span>$</span>expr3<span>' is invalid."</span>)<br/>    }<br/>  }<br/>}</pre>
<p>The output of this application will be the following:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/9480d85e-1b16-4b31-80ed-abe47cbdf2eb.png" style="width:36.42em;height:5.50em;" width="722" height="109"/></div>
<p>As you can see, our code correctly evaluates the expressions. There are, of course, some improvements that can be made and they are mainly related to error handling and parsing, but this is out of the scope of this subsection. In this subsection, we saw how to use the interpreter design pattern.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">What it is good for</h1>
                </header>
            
            <article>
                
<p>The interpreter design pattern is good for applications that deal with well-defined and well-understood domains. They could greatly simplify the application code. You should not confuse the interpreter design pattern with parsing, even though we needed parsing in order to build our expressions.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">What it is not so good for</h1>
                </header>
            
            <article>
                
<p>Creating languages and grammar is not an easy job. Developers should thoroughly evaluate the problems they are trying to solve before deciding to use this design pattern.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we went through the first group of behavioral design patterns. We looked at the value object, null object, strategy, command, the chain of responsibility, and interpreter. As in the previous chapters, we saw that some of these patterns have better alternatives that use the more powerful and flexible features of Scala. In many cases, there are multiple different ways to implement the same design pattern. We've tried to show some good ones and we've also tried to avoid repetition in the cases where more design patterns can use the same features of the Scala programming language. By now, you should have enough knowledge in order to actually use an alternative implementation by yourself when told which approach to use, based on what we've already shown.</p>
<p>We've given some pointers that should help in figuring out what to look for when writing software and identifying potential places to apply behavioral design patterns.</p>
<p>In the following chapter, we will look at the next group of behavioral design patterns, which also puts an end to the <em>Gang of Four</em> design patterns we've been focusing on.</p>


            </article>

            
        </section>
    </div>



  </body></html>