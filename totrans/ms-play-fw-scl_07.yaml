- en: Chapter 7. Playing with Globals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes web applications require application-wide objects that live beyond
    the request-response life cycle, such as database connections, application configuration,
    shared objects, and cross-cutting concerns (authentication, error handling, and
    so on). Consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Ensuring that the database used by the application is defined and accessible.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Notify through e-mail or any other service when the application is receiving
    unexpected heavy traffic.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logging the different requests served by the application. These logs can later
    be used to analyze user behavior.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Restricting certain facilities on the web application by time. For example,
    some food ordering apps take orders only between 11 a.m. to 8 p.m., while all
    requests to build orders at any other time will be blocked and a message about
    the timings will be displayed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generally, when a user sends an e-mail and the recipient's email ID is incorrect
    or not in use, the sender is notified about the failure in delivering the e-mail
    only after 12 to 24 hrs. In this duration, further attempts are made to send the
    e-mail.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applications with in-app sales allow users to retry with the same or different
    payment options when payment has been declined for various reasons.
  prefs: []
  type: TYPE_NORMAL
- en: In a Play Framework app, by convention, all of these various concerns can be
    managed through GlobalSettings.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will discuss the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: GlobalSettings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Application life cycle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Request-response life cycle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GlobalSettings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every Play application has a global object which can be used to define application-wide
    objects. It can also be used to customize the application's life cycle and the
    request-response life cycle.
  prefs: []
  type: TYPE_NORMAL
- en: 'The global object for an application can be defined by extending the trait
    `GlobalSettings`. By default, the name of the object is expected to be `Global`
    and it is assumed to be in the `app` directory. This can be changed by updating
    `application.global` in the `conf/application.conf` property. For example, if
    we wish to use a file with `AppSettings` in the `app/com/org` name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `GlobalSettings` trait has methods that can be used to interrupt both the
    application's life cycle and the request-response life cycle. We will see its
    methods as and when required in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's see how this works.
  prefs: []
  type: TYPE_NORMAL
- en: An app developed through the Play Framework is represented by an instance of
    the `Application` trait, since its creation and the build is to be handled by
    the framework itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Application` trait is extended by `DefaultApplication` and `FakeApplication`.
    `FakeApplication` is a helper that tests Play applications and we will see more
    of it in [Chapter 9](ch09.html "Chapter 9. Testing"), *Testing*. `DefaultApplication`
    is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The `WithDefaultConfiguration` and `WithDefaultPlugins` traits are used to
    initialize the application''s configuration and plugin objects, respectively.
    The `WithDefaultGlobal` trait is the one responsible for setting the correct global
    object for the application. It is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The `globalInstance` object is the `global` object to be used for this application.
    It is set to `javaGlobal` or `scalaGlobal`, whichever is applicable to the application.
    If the application does not have custom Global object configured for the application,
    the application''s `global` is set to `DefaultGlobal`. It is defined as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The life cycle of an application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An application''s life cycle has two states: **running** and **stopped**. These
    are times when the state of the application changes. At times, we need to perform
    some operations right before or after a state change has occurred or is about
    to occur.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Play applications use a Netty server. For this, a class with the same name
    is used. It is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This class is responsible for binding or bootstrapping the application to the
    server.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ApplicationProvider` trait is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'An implementation of `ApplicationProvider` must create and initialize an application.
    Currently, there are three different implementations of `ApplicationProvider`.
    They are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`StaticApplication`: This is to be used in the production mode (the mode where
    code changes do not affect an already running application).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ReloadableApplication`: This is to be used in the development mode (this is
    a mode where continuous compilation is enabled so that developers can see the
    impact of changes in an application as and when they are saved, if the application
    is up and running).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TestApplication`: This is to be used in the testing mode (the mode where a
    fake application is started through the tests).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`StaticApplication` and `ReloadableApplication` both initialize a `DefaultApplication`.
    `StaticApplication` is used in the production mode and is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '`ReloadableApplication` is used in the development mode but, since the class
    definition is huge, let''s see the relevant lines of code where `DefaultApplication`
    is used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: For `StaticApplication`, the application is created and started just once whereas,
    in the case of `ReloadableApplication`, the existing application is stopped and
    a new one is created and started. The `ReloadableApplication` is for the development
    mode, so as to allow developers to make changes and see them reflected without
    the hassle of reloading the application manually every time.
  prefs: []
  type: TYPE_NORMAL
- en: 'The usage of `ApplicationProvider` and `NettyServer` is similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In the following section, we will discuss the methods available in GlobalSettings,
    which enable us to hook into the application's life cycle.
  prefs: []
  type: TYPE_NORMAL
- en: Meddling with an application's life cycle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Consider that our application has the following specifications:'
  prefs: []
  type: TYPE_NORMAL
- en: Prior to starting the application, we need to ensure that the `/opt/dev/appName`
    directory exists and is accessible by the application. A method in our application
    called `ResourceHandler.initialize` does this task.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create the required schema on startup using the `DBHandler.createSchema` method.
    This method does not drop the schema if it already exists. This ensures that the
    application's data is not lost on restarting the application and the schema is
    generated only when the application is first started.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create e-mail application logs when the application is stopped using the `Mailer.sendLogs`
    method. This method sends the application logs as an attachment in an e-mail to
    the `emailId` set in a configuration file as `adminEmail`. This is used to track
    the cause for the application's shutdown.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Play provides methods that allow us to hook into the application's life cycle
    and complete such tasks. The `GlobalSettings` trait has methods that assist in
    doing so. These can be overridden by the `Global` object, if required.
  prefs: []
  type: TYPE_NORMAL
- en: 'To cater to the specifications of the application described earlier, all we
    need to do in a Play application is define a `Global` object, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `ResourceHandler.initialize`, `DBHandler.createSchema`, and `Mailer.sendLogs`
    methods are specific to our application and are defined by us, not provided by
    Play.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know how to hook into the application's life cycle, let's scrutinize
    how it works.
  prefs: []
  type: TYPE_NORMAL
- en: 'Digging deeper into the application''s life cycle we can see that all the implementations
    of `ApplicationProvider` use the `Play.start` method to initialize an application.
    The `Play.start` method is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This method ensures that each plugin''s `onStart` method is called right after
    the application is set as `_currentApp`. `GlobalPlugin`, is added by default to
    all the Play applications, and is defined as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding snippet, `app.global` refers to the GlobalSettings defined
    for the application. Therefore, the GlobalPlugin ensures that the appropriate
    methods of the application's GlobalSettings are called.
  prefs: []
  type: TYPE_NORMAL
- en: The `beforeStart` method is called on initialization of the plugin.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we just need to figure out how `onStop` is called. Once an application
    is stopped, `ApplicationProvider` does not have control, so the Java runtime shutdown
    hook is used to ensure that certain tasks are executed once the application is
    stopped. Here is a look at the relevant lines from the `NettyServer.createServer`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, runtime is java.lang.Runtime (Java docs for the same are available at
    [http://docs.oracle.com/javase/7/docs/api/java/lang/Runtime.html](http://docs.oracle.com/javase/7/docs/api/java/lang/Runtime.html))
    and the `server` is an instance of NettyServer. NettyServer''s `stop` method is
    defined as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `Invoker.lazySystem.close()` call is used to shut down the ActorSystem
    used internally within a Play application. The `Execution.lazyContext.close()`
    call is to shut down Play's internal `ExecutionContext`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Play.stop` method is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This method calls the `onStop` method of all the registered plugins in reverse
    order, so the GlobalPlugin's `onStop` method is called and it eventually calls
    the `onStop` method of the `GlobalSetting` defined for the application. Any errors
    encountered in this process are logged as warnings since the application is going
    to be stopped.
  prefs: []
  type: TYPE_NORMAL
- en: We can now add any task within the application's life cycle, such as creating
    database schemas before starting, initializing global objects, or scheduling jobs
    (using Akka Scheduler or Quartz, and so on) on starting and cleaning temporary
    data when stopping.
  prefs: []
  type: TYPE_NORMAL
- en: We've covered the application's life cycle, now let's look into the request-response
    life cycle.
  prefs: []
  type: TYPE_NORMAL
- en: The request-response life cycle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Play Framework uses Netty by default, so requests are received by NettyServer.
  prefs: []
  type: TYPE_NORMAL
- en: Netty allows a variety of actions including custom coding through handlers.
    We can define a handler that transforms a request into a desired response and
    provides it to Netty when bootstrapping the application. To integrate a Play app
    with Netty, `PlayDefaultUpstreamHandler` is used.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For additional information on requests used in Netty, refer to Netty docs at
    [http://netty.io/wiki/user-guide-for-4.x.html](http://netty.io/wiki/user-guide-for-4.x.html)
    and Netty ChannelPipeline docs at [http://netty.io/4.0/api/io/netty/channel/ChannelPipeline.html](http://netty.io/4.0/api/io/netty/channel/ChannelPipeline.html).
  prefs: []
  type: TYPE_NORMAL
- en: '`PlayDefaultUpstreamHandler` extends `org.jboss.netty.channel.SimpleChannelUpstreamHandler`
    to handle both HTTP and WebSocket requests. It is used when bootstrapping the
    application to Netty in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `messageReceived` method of `SimpleChannelUpStreamHandler` is responsible
    for acting on the received request. `PlayDefaultUpstreamHandler` overwrites this
    so that requests are sent to our application. This method is too long (around
    260 lines, including comments and blank lines), so we will only look at relevant
    blocks here.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, a Play `RequestHeader` is created for the message received and its corresponding
    action is found:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding snippet, the `tryToCreateRequest` method results in `RequestHeader`
    and any exceptions encountered in this process are handled. The action for the
    `RequestHeader rh` is then fetched through `server.getHandlerFor(rh)`. Here, a
    `server` is an instance of the server trait and the `getHandlerFor` method utilizes
    the application''s `global` object and its `onRequestReceived` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In the `messageReceived` method of `PlayDefaultUpstreamHandler`, the action
    obtained from `server.getHandlerFor` is eventually called, resulting in a response.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the interactions of `PlayDefaultUpStreamHandler` with the application
    are through its global object. In the following section, we will see the methods
    available in GlobalSettings related to the request-response life cycle.
  prefs: []
  type: TYPE_NORMAL
- en: Fiddling with the request-response life cycle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `GlobalSettings` trait has methods related to different stages of the application's
    life cycle as well as its request-response life cycle. Using the request-related
    hooks, we can define business logic when a request is received, when an action
    is not found for the request, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'The request-related methods are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`onRouteRequest`: This uses a router to identify the action for a given `RequestHeader`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onRequestReceived`: This results in `RequestHeader` and its action. Internally,
    it calls the `onRouteRequest` method'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`doFilter`: This adds a filter to the application'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onError`: This is a method that handles exceptions when processing'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onHandlerNotFound`: This is used when a RequestHeader''s corresponding action
    cannot be found'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onBadRequest`: This is used internally when the request body is incorrect'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onRequestCompletion`: This is used to perform operations after a request has
    been processed successfully'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manipulating requests and their responses
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In some applications, it is mandatory to filter, modify, redirect requests,
    and their responses. Consider these examples:'
  prefs: []
  type: TYPE_NORMAL
- en: Requests for any service must have headers that contain session details and
    user identities except for instances, such as logins, registers, and forgetting
    passwords
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All requests made for a path starting with `admin` must be restricted by the
    user role
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Redirect requests to regional sites if possible (such as Google)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add additional fields to the request or response
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `onRequestReceived`, `onRouteRequest`, `doFilter`, and `onRequestCompletion`
    methods can be used to intercept the request or its response and manipulate them
    as per requirements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the `onRequestReceived` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: It fetches the corresponding handler for a given `RequestHeader` using the `onRouteRequest`
    and `doFilter` methods. If no handler is found, the result from `onHandlerNotFound`
    is sent.
  prefs: []
  type: TYPE_NORMAL
- en: Since the `onRequestReceived` method plays a critical role in how the requests
    are processed, sometimes it may be simpler to override the `onRouteRequest` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `onRouteRequest` method is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Here, the router is the application's `router` object. By default, it is the
    generated object created from `conf/routes` on compilation. A router extends the
    `Router.Routes` trait and the `handlerFor` method is defined in this trait.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try to implement a solution for blocking requests to services other
    than `login`, `forgotPassword`, and `register` if the request header does not
    have the session and user details. We can do so by overriding `onRouteRequest`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: First, we check if the requested path has restricted access. If so, we check
    if the necessary headers are available and valid. Only then is the corresponding
    `Handler` returned, else `Handler` for an invalid session is returned. A similar
    approach can be followed if we need to control the access based on the user's
    role.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also use the `onRouteRequest` method to provide compatibility for older
    deprecated services. For example, if the older version of the application had
    a `GET /user/:userId` service that has now been modified to `/api/user/:userId`,
    and there are other applications that rely on this application, our application
    should support requests for both the paths. However, the routes file only lists
    the new paths and services, which means that we should handle these before attempting
    to access the application''s supported routes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The `getSupportedPath` is a custom method that gives a new path for a given
    old path. We create a new `RequestHeader` with the updated fields and forward
    this to the following methods instead of the original `RequestHeader`.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, we could add/modify the headers or any other field(s) of `RequestHeader`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `doFilter` method can be used to add filters, similar to those shown in
    [Chapter 2](ch02.html "Chapter 2. Defining Actions"), *Defining Actions*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, we can extend the `WithFilters` class instead of `GlobalSettings`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The `WithFilters` class extends `GlobalSettings` and overrides the `doFilter`
    method with the `Filter` passed in its constructor. It is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The `onRequestCompletion` method can be used to perform specific tasks after
    a request has been processed. For example, suppose that the application needs
    a requirement to persist data from specific GET requests, such as Search. This
    can come in handy to understand and analyze what the users are looking for in
    our application. Persisting information from requests prior to fetching data can
    considerably increase the response time and hamper user experience. Therefore,
    it will be better if this is done after the response has been sent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Tackling errors and exceptions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'An application cannot exist without handling errors and exceptions. Based on
    the business logic, the way they are handled may differ from application to application.
    Play provides certain standard implementations which can be overridden in the
    application''s global object. The `onError` method is called when an exception
    occurs and is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '`UsefulException` is an abstract class, which extends `RuntimeException`. It
    is extended by the `PlayException` helper. The default implementation of `onError`
    (in the previous code snippet) simply checks whether the application is in the
    production mode or in the development mode and sends the corresponding view as
    `Result`. This method results in the `defaultpages.error` or `defaultpages.devError`
    view.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose we want to send a response with a status 500 and the exception instead.
    We can easily do so by overriding the `onError` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The `onHandlerNotFound` method is called when a user sends a request with a
    path that is not defined in `conf/routes`. It is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: It sends a view as a response, depending on the mode in which the application
    was started. In the development mode, the view contains an error message, which
    tells us that an action is defined for the route and the list of supported paths
    with the request type. We can override this, if required.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `onBadRequest` method is called in the following situations:'
  prefs: []
  type: TYPE_NORMAL
- en: The request is sent and its corresponding action has a different content type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some of the parameters are missing in the request sent and, when parsing, the
    request throws an exception
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'This method also sends a view in response but, in most applications, we would
    like to send `BadRequest` with the error message and not the view. This can be
    achieved by overriding the default implementation, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we saw the features provided to a Play application through
    a global plugin. By extending `GlobalSettings`, we can hook into the application's
    life cycle and perform various tasks at different phases. Apart from hooks used
    for the application life cycle, we have also discussed hooks for the request-response
    life cycle, through which we can intercept requests and responses and modify them,
    if required.
  prefs: []
  type: TYPE_NORMAL
