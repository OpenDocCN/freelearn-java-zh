- en: '15'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Streams – Fundamentals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 14*](B19793_14.xhtml#_idTextAnchor355), we learned about lambda
    expressions. Lambda expressions enable us to write more concise code. Be aware,
    however, that the compiler is, in the background, inserting the code we omit.
    For that to work, the compiler must have no decisions to make. This is where “functional
    interfaces” come into play. A functional interface is an interface with just one
    `abstract` method; this is known as the “functional method.” Lambda expressions
    can only be used with functional interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: We saw that if a local variable is used in a lambda expression, that variable
    must be `final` or “effectively final.” This keeps both views (method and lambda)
    of the variable’s value in sync. In other words, both the method and the lambda
    have the same value for the variable at all times.
  prefs: []
  type: TYPE_NORMAL
- en: We also examined the more popular functional interfaces in the API, namely,
    `Predicate`, `BiPredicate`, `Supplier`, `Consumer`, `BiConsumer`, `Function`,
    and `BiFunction`. There are many other functional interfaces in the API, including
    variants that cater to primitives (as opposed to objects).
  prefs: []
  type: TYPE_NORMAL
- en: Next, we discussed method references, which can make your code even more concise
    than lambdas. A method reference is a shorthand for a lambda expression. For the
    compiler to generate the lambda from the method reference, the context is key.
    The context factors in the functional interface declared and the generic types
    used.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also explored the four types of method references: bound, unbound, static,
    and constructor. Bound method references bind, at compile time, to a variable
    from the method, whereas unbound rely on the object to be passed in at runtime.
    Static method references are unbound and invoke a `static` method. Constructor
    method references use the `::new` syntax to create objects.'
  prefs: []
  type: TYPE_NORMAL
- en: We finished the chapter by discussing an example where the same method reference
    was used in three different contexts. Each of the method references resulted in
    a different lambda due to the differing contexts. This demonstrated the importance
    of context when examining method references.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will start our coverage of streams. This is a large and
    important topic, requiring two chapters. Java 8 introduced both lambdas and streams
    to enable a more functional style of programming. This can lead to cleaner, more
    expressive code as we are not bogged down in how to do something; we just say
    we want it done.
  prefs: []
  type: TYPE_NORMAL
- en: We will start by discussing the stream pipeline. We will then discuss stream
    “laziness” before moving on to show ways of creating streams. Lastly, we will,
    with the aid of code examples, examine terminal operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding stream pipelines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring stream laziness
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating streams
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mastering terminal operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code for this chapter can be found on GitHub at [https://github.com/PacktPublishing/Learn-Java-with-Projects/tree/main/ch15](https://github.com/PacktPublishing/Learn-Java-with-Projects/tree/main/ch15).
  prefs: []
  type: TYPE_NORMAL
- en: Understanding stream pipelines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A *stream* in Java is a sequence of data that can be processed by operations.
    Streams are not another way to organize data, such as using an array or `Collection`,
    because streams do not hold data. Streams are all about efficiently processing
    data that is flowing by.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at the stream pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Stream pipeline
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A *stream pipeline* is a set of operations that run on a stream to produce a
    result. At a minimum, a stream pipeline consists of a source, zero or more intermediate
    operations, and a terminal operation, in that order. A pipeline is similar to
    an assembly line in a factory. Let’s look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: Assembly line analogy
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s assume we have a task of sharpening and stamping pencils that are currently
    sitting in a box (which contains 100 pencils). Stamping them means marking the
    pencil type on the pencil, such as 2B, 2H, and so forth. The pencils must be sharpened,
    stamped, and finally packed away, in that order. Declaring a stream is the same
    as giving instructions to the supervisor. In this assembly line, Java is the supervisor.
    Nobody does anything until the supervisor shouts “Start.” The supervisor examines
    the instructions and sets up workstations with workers – one to take pencils from
    the box, one to sharpen the pencil, one to stamp the sharpened pencil, and one
    to pack away the finished pencil.
  prefs: []
  type: TYPE_NORMAL
- en: The worker taking pencils from the box is the pipeline *source*. The pencils
    are the data. Sharpening and stamping the pencils are the *intermediate operations*.
    The last operation, packing away the pencils, is the *terminal operation*. The
    terminal operation is very important as the supervisor will not shout “Start”
    until they see the terminal operation. Upon seeing it, however, the supervisor
    will shout “Start” and the process will begin.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s examine this process.
  prefs: []
  type: TYPE_NORMAL
- en: The first worker takes a pencil out of the box and hands it to the second worker,
    who sharpens it. The second worker hands the sharpened pencil to the next worker,
    who stamps it and hands it to the final worker in the assembly line, who packs
    the pencil away.
  prefs: []
  type: TYPE_NORMAL
- en: Note that pencils (and data) can only proceed in one direction – once the worker
    passes on the pencil, they can’t get it back. From a Java perspective, this makes
    streams different from arrays and collections (where you can access the data at
    any time).
  prefs: []
  type: TYPE_NORMAL
- en: In addition, there is a principle of “lazy evaluation” in streams that we must
    be aware of here. We will discuss lazy evaluation in greater detail in the next
    section but for now, understand that data is *not* generated up front; it is only
    created *as and when needed*. This improves performance as you scale the amount
    of data you wish to process. Concerning our assembly line example, this means
    that the second pencil is not retrieved until required. What would be the point
    in having extra pencils sharpened and stamped if all you needed was one pencil?
    The supervisor, having the overall instructions, would be aware of this and ensure
    that the second pencil is never started.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s get back to our analogy where, at this point, we have one pencil packed
    away. Let’s say we only want two pencils sharpened and stamped. This will require
    a new worker to be on the assembly line to keep count. The supervisor will place
    this new worker after the worker who stamps the pencils. The new worker’s job
    is to count the pencils as they pass by (to be packed) and to inform the supervisor
    when two pencils have passed. The supervisor then instructs the first worker to
    take the second pencil out of the box. This pencil is sharpened and stamped. The
    new worker sees this second pencil pass by to be packed and informs the supervisor
    of this fact. The supervisor lets the last worker finish packing the second pencil
    and shouts “Stop.” Therefore, the other 98 pencils are never taken out of the
    box, as they were not needed. This is a lazy evaluation.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s discuss what makes up a stream pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Elements of a stream pipeline
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A stream pipeline consists of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`varargs`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Intermediate operations**: They transform the stream into another stream.
    We can have as many or as few as we like (zero or more). Due to lazy evaluation,
    they do not run until the terminal operation runs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Terminal operation**: This is required to start the whole process and produce
    a result. Streams can only be used once – after the terminal operation completes,
    the stream is no longer usable (regenerate the stream if necessary).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s discuss the pipeline with the aid of an example. *Figure 15**.1* presents
    a sample pipeline:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.1 – A sample pipeline](img/B19793_15_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.1 – A sample pipeline
  prefs: []
  type: TYPE_NORMAL
- en: The var keyword
  prefs: []
  type: TYPE_NORMAL
- en: The `var` keyword is known as `temps` is a `List<Double>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output from the previous figure is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In this figure, we are counting the number of temperatures `> 100`. As streams
    do not hold data, pipelines specify how we want to manipulate the source. The
    first thing we do is to create a `List<Double>` list represented by `temps`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We then stream the list – in other words, the list is our source:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we use the `peek(Consumer)` intermediate operation, which is useful for
    debugging a pipeline and also for demonstrating what data is where in the pipeline:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, we want to filter *in* temperatures that are greater than 100\.
    In other words, only temperatures `> 100` will make it past the filter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have a temperature > 100, we use `peek(Consumer)` again to ensure
    our filter is working properly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, we have the terminal operation, `count()`, which starts off the whole
    process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Let us discuss how the streaming process works here. Firstly, `98.4` is streamed.
    As `98.4` fails the filter, it is removed from the stream. Next, `100.2` is streamed;
    it passes the filter and Java sets the count to 1\. The next value `87.9`, is
    then streamed but it fails the filter. Lastly, `102.8` is streamed, which also
    passes the filter, thereby increasing the count to 2\. Therefore, the count of
    temperatures that are `> 100` is 2 (`100.2` and `102.8`). Notice the order in
    which the values come out of the stream is demonstrating stream laziness.
  prefs: []
  type: TYPE_NORMAL
- en: We will discuss the various operations from this example in due course. For
    the moment, we would like to cover stream laziness in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring stream laziness
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The principle of lazy evaluation is that you get what you need, only when you
    need it. For example, if shopping websites such as Amazon were to display 10,000
    records to a user, the principle of lazy evaluation would be to retrieve the first
    50 and while the user is viewing these, retrieve the next 50 in the background.
    An eager evaluation would be to retrieve all 10,000 records in one go. With regards
    to streams, this means that nothing happens until the terminal operation gets
    called.
  prefs: []
  type: TYPE_NORMAL
- en: 'The pipeline specifies what operations we want performed on the source and
    in what order. As nothing happens until the terminal operation runs, Java is aware
    of the full pipeline. This enables Java to introduce efficiencies whenever possible.
    For example, why run an operation on a piece of data if that operation is not
    required? This could arise in the following situations:'
  prefs: []
  type: TYPE_NORMAL
- en: We have already found the data item we are looking for
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We may have a limit set of the number of elements (as in the pencils analogy)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s examine an example where the order of processing elements from the source
    demonstrates lazy evaluation. *Figure 15**.2* (`Laziness.java`) shows this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.2 – Lazy evaluation – stream pipeline example](img/B19793_15_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.2 – Lazy evaluation – stream pipeline example
  prefs: []
  type: TYPE_NORMAL
- en: 'The algorithm in this figure obtains the first name that begins with ''B''
    or ''C'' that is longer than 3 characters. In this example, we initially create
    a `List<String>` called `names`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As Java does not do any streaming until the terminal operation is encountered;
    nothing happens in this example until the `forEach(Consumer)` operation (line
    31). This means that the code `names.stream()` at the start, is merely creating
    an object that knows where to go for the data when the streaming starts.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we do in this pipeline is output the current string, representing
    the person’s name using the `peek(Consumer)` intermediate operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we use the `filter(Predicate)` intermediate operation to filter in names
    that begin with “B” or “C.”:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Immediately following that, we filter in names that are longer than three characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, we use the `limit(long)` intermediate operation to keep track of
    how many names have passed the second filter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, once one name passes by, the JVM is informed and no other
    name will be streamed from the source. Lastly, we provide the (required) terminal
    operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '*Figure 15**.3* shows the output from the code in *Figure 15**.2*, which is
    very revealing:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.3 – Output from Figure 15.2 (with comments on the right)](img/B19793_15_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.3 – Output from Figure 15.2 (with comments on the right)
  prefs: []
  type: TYPE_NORMAL
- en: Line 35 shows the first name, `April`, being streamed from the list. `April`
    makes it to the first filter and is removed (as `April` does not start with “B”
    or “C”).
  prefs: []
  type: TYPE_NORMAL
- en: Line 37 shows the next name, `Ben`, being streamed. `Ben` passes the first filter
    and makes it to the second filter. However, as the length of `Ben` is only 3 characters,
    it is removed by the second filter.
  prefs: []
  type: TYPE_NORMAL
- en: Line 40 shows the next name, `Charlie`, being streamed. `Charlie` passes the
    first filter (as `Charlie` begins with “C”) and is passed to the second filter.
    `Charlie` also passes this filter as the length of `Charlie` is > 3 characters
    long. So, `Charlie` is passed to the `limit(long)` intermediate operation, which
    notes that this is the first name passing by. As the limit is set to 1, the JVM
    is informed. `Charlie` is processed by the `forEach(Consumer)` terminal operation
    printing out `Charlie` (line 43) and the stream is shut down.
  prefs: []
  type: TYPE_NORMAL
- en: Note that none of the other names – `David`, `Benildus`, or `Christian` – are
    streamed at all. This is a small example but you can imagine the efficiencies
    of scale when you are dealing with millions of data items.
  prefs: []
  type: TYPE_NORMAL
- en: We will now move on to discussing how to create streams.
  prefs: []
  type: TYPE_NORMAL
- en: Creating streams
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Streams, both finite and infinite, can be generated from various sources. For
    example, sources such as arrays, collections, `varargs`, and files can be used.
    Let’s examine these in turn. For the moment, we will deal with non-primitive types;
    all the streams will be serial (non-parallel). Both primitive and parallel streams
    will be discussed in [*Chapter 16*](B19793_16.xhtml#_idTextAnchor401).
  prefs: []
  type: TYPE_NORMAL
- en: Streaming from an array
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will use `Stream<T> Arrays.stream(T[] array)` for this. This `static` method
    accepts an array of type `T` and returns `Stream<T>`. *Figure 15**.4* (`CreatingStreams.java`)
    presents an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.4 – Streaming an array](img/B19793_15_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.4 – Streaming an array
  prefs: []
  type: TYPE_NORMAL
- en: In this figure, we declare a `Double` array (note that this is not a primitive
    `double` array). The stream object is created using the `Arrays.stream(T[] array)`
    method call. We start the stream off using the terminal operation `count()`. Lastly,
    we output the number of elements in the array. Note that this is just an example
    and that there is a more straightforward way (using the `length` property) of
    outputting the number of elements in an array.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s examine how we stream from a collection.
  prefs: []
  type: TYPE_NORMAL
- en: Streaming from a collection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By *collection*, we mean the `Collection` interface hierarchy. The `Collection`
    interface has a `default Stream<E> stream()` method. *Figure 15**.5* (`CreatingStreams.java`)
    presents code that generates a stream from a collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.5 – Streaming a collection](img/B19793_15_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.5 – Streaming a collection
  prefs: []
  type: TYPE_NORMAL
- en: 'In this figure, we initially create a `List<String>` using `Arrays.asList(T…
    a)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We then use the `Collection` `stream()` method to create the stream object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'To start the stream off, we use the terminal `count()` operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'What if you had a *Map* and wanted to stream it? Remember that `Map` is not
    a `Collection` as it does not implement it. This is what the second example shows.
    Firstly, let us declare and populate the map:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'To bridge across from a `Map` to a `Collection` we will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The `entrySet()` method in `Map` returns a `Set` view of the entries in the
    map. As `Set` is a sub-interface of `Collection`, `Set` “is-a” `Collection`. At
    this point, we can now stream the collection as normal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we start off the process using the terminal operation, `count()`, which
    returns `3`, showing that the stream worked.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s look at the `Stream.of()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Stream.of()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`static <T> Stream<T> of(T… values)` is a very useful method. While its signature
    can seem a little confusing, it is very straightforward to use. It is a `static`
    method that is generically typed, hence `<T>`. Thus, the compiler does not complain
    about the use of `T` in the signature. It returns `Stream<T>` and `T` depends
    on what is passed in. For example, if you pass in strings, then you get back `Stream<String>`.
    The parameters are a `varargs` list, which is very flexible.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at some examples. *Figure 15**.6* (BuildStreams.java) presents the
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.6 – Stream.of() examples](img/B19793_15_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.6 – Stream.of() examples
  prefs: []
  type: TYPE_NORMAL
- en: 'In this figure, we initially declare an array of strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the `Stream.of()` method, we declare the stream source to be the array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Once declared, we start the stream using the `count()` terminal operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, `Stream.of()` sources the stream from a `varargs` of integers passed
    in (boxed as `Integer`s):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We start the streaming process as before, using the `count()` terminal operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Following that, `Stream.of()` sources the stream from a `varargs` of strings
    and stream them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, we source the stream from a `varargs` of `Dog` (just one), and stream
    them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Now, let’s examine how to stream from a file.
  prefs: []
  type: TYPE_NORMAL
- en: Streaming from a file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To stream a file, we can use the `Files.lines()` method. Its signature is `public
    static Stream<String> lines(Path path)` `throws IOException`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Path` parameter refers to the file we want to process. This file needs
    to be delimited; for example, using the forward slash (`/`) character. The file
    we will use contains the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The returned `Stream<String>` refers to the lines from the file, one `String`
    for each line in the file. We can process the returned stream using the `forEach(Consumer)`
    terminal operation defined in the `Stream` interface. Inside the consumer block
    of code, each line from the file (a `String`) could be parsed into `String[]`
    using the `split()` method from the `String` class – where we pass in the delimiter
    and get back a `String[]` of the elements. Once we have this `String[]`, we can
    easily create our object and add it to a collection, such as `ArrayList`. This
    is an example of a `Consumer` side effect.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assuming a `Cat` class with `name` and `color` instance variables and an associated
    constructor (ProcessFile.java), we could do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: forEach(Consumer) versus forEach(Consumer)
  prefs: []
  type: TYPE_NORMAL
- en: In the Java API, these two versions of `forEach()` look very similar but they
    are in fact from two very different hierarchies. One is a `default` method in
    the `Iterable` interface (which `Collection` inherits). The other is a terminal
    operation in the `Stream` interface.
  prefs: []
  type: TYPE_NORMAL
- en: Infinite streams
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Infinite streams can easily be created using two `static` methods from the `Stream`
    interface, namely `generate()` and `iterate()`. Let’s examine these in turn.
  prefs: []
  type: TYPE_NORMAL
- en: Stream<T> generate(Supplier<T> s)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As per the API, it “returns an infinite, sequential unordered stream where
    each element is generated by the provided `Supplier`.” *Figure 15**.7* (`InfiniteStreamsGenerate.java`)
    presents some code that we can discuss:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.7 – Creating an infinite stream using generate()](img/B19793_15_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.7 – Creating an infinite stream using generate()
  prefs: []
  type: TYPE_NORMAL
- en: 'As this figure shows, the `Supplier` provided produces random numbers between
    0 and 9 inclusive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We start the streaming process using the `forEach(Consumer)` terminal operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '`Consumer` accepts a method reference to output the numbers generated. This
    stream will keep going until we terminate the application (for example, from within
    the IDE).'
  prefs: []
  type: TYPE_NORMAL
- en: Math.random()
  prefs: []
  type: TYPE_NORMAL
- en: Recall that `Math.random()` returns a `double` type between `0.0 <= x < 1.0`.
    In other words, a number between `0` and less than `1`. When we multiply this
    number by `10` and subsequently cast that number to an `int` type, we are, in
    effect, scaling it to `0 <= x <` `10`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s discuss the other method for generating infinite streams, namely
    `iterate()`.
  prefs: []
  type: TYPE_NORMAL
- en: Stream<T> iterate(T seed, UnaryOperator<T> fn)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This method gives you more control over the numbers generated. The first argument
    is the seed, which is the first number in the stream. The second parameter is
    a `UnaryOperator` (a `Function` where the input and output are the same type).
    This `UnaryOperator` function is a lambda that accepts the previous value and
    generates the next value. *Figure 15**.8* (`InfiniteStreamsIterate.java`) presents
    a code example for us to discuss this further:'
  prefs: []
  type: TYPE_NORMAL
- en: '![ Figure 15.8 – Creating an infinite stream using iterate()](img/B19793_15_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.8 – Creating an infinite stream using iterate()
  prefs: []
  type: TYPE_NORMAL
- en: As this figure shows, the seed is `2` and the lambda expression generates the
    next even number after `2` and so forth. Thus, this stream generates `2`, `4`,
    `6`, `8`, and so on, until we kill the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'What if we wanted only so many numbers? For example, what if we wanted only
    the even numbers up to `20` (starting at `2`)? There is an overloaded version
    of `iterate()` that caters to this – its second parameter is a `Predicate`, which
    states when to finish. *Figure 15**.9* (`InfiniteStreamsIterate.java`) presents
    an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![ Figure 15.9 – Creating an infinite/finite stream using iterate() and Predicate](img/B19793_15_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.9 – Creating an infinite/finite stream using iterate() and Predicate
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Predicate` condition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: is the important line here. that specifies when this stream stops. Thus, this
    is one way of creating a finite stream from an infinite stream. If the `Predicate`
    condition keeps returning `true`, the stream will keep generating numbers until
    you kill the application.
  prefs: []
  type: TYPE_NORMAL
- en: In this figure, `2`, `4`, `6`, `8`, `10`, `12`, `14`, `16`, `18`, and `20` all
    pass the `Predicate` condition and are output. Once `22` is generated and the
    `Predicate` fails, the stream stops.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way of turning an infinite stream into a finite stream is to use the
    `limit()` intermediate operation. *Figure 15**.10* (`InfiniteStreamsIterate.java`)
    presents this scenario:'
  prefs: []
  type: TYPE_NORMAL
- en: '![ Figure 15.10 – Creating a finite stream using limit()](img/B19793_15_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.10 – Creating a finite stream using limit()
  prefs: []
  type: TYPE_NORMAL
- en: In this figure, we restricted the numbers generated to 10 by using the `limit()`
    intermediate operation. We will discuss intermediate operations in [*Chapter 16*](B19793_16.xhtml#_idTextAnchor401).
    In this example, once the 10th number has passed by, `limit()` informs the JVM
    of this fact, and no further numbers are generated.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know how to create streams, let’s examine terminal operations.
  prefs: []
  type: TYPE_NORMAL
- en: Mastering terminal operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we discussed earlier, no streaming happens until the terminal operation executes.
    This gives the JVM an overall picture of the stream pipeline, thereby enabling
    efficiencies to be introduced in the background.
  prefs: []
  type: TYPE_NORMAL
- en: A terminal operation can be performed without any intermediate operation but
    not the other way around. *Reductions* are a special type of terminal operation
    where all of the contents of the stream are combined into a single primitive or
    *Object* (for example, a *Collection*).
  prefs: []
  type: TYPE_NORMAL
- en: '*Table 15.1* represents the terminal operations we will be discussing in this
    section:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 15.1 – Terminal operations](img/B19793_15_Table_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Table 15.1 – Terminal operations
  prefs: []
  type: TYPE_NORMAL
- en: Before we discuss them in turn, a brief discussion regarding the table. Remember,
    a reduction must look at all elements in the stream and then return a primitive
    or `Object`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of these terminal operations, such as `allMatch(Predicate)`, may not look
    at all of the elements in the stream. For example, let’s say we had the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The `Predicate` condition fails on `"Brian"`, as it does not start with `"A"`,
    and `allMatch()` returns `false`. Therefore, `"Colin"` is never examined and hence,
    `allMatch()` is not a reduction.
  prefs: []
  type: TYPE_NORMAL
- en: We will discuss `Optional`s later but for the moment, `Optional`s were introduced
    in Java 8 to replace `null` return values (and thereby help to reduce the number
    of `NullPointerException`s). If the stream is empty, an empty `Optional` is returned
    (and not `null`). Therefore, an `Optional` object either has a non-`null` value
    or is empty. One way of ending up with an empty stream is by filtering out all
    of its elements before calling the terminal operation.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s deal with the operations in turn.
  prefs: []
  type: TYPE_NORMAL
- en: count()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have already encountered `count()`, so a quick example has been provided
    in *Figure* *15**.11* (`TerminalOperations.java`):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.11 –  count() in code](img/B19793_15_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.11 – count() in code
  prefs: []
  type: TYPE_NORMAL
- en: The `count()` method works with finite streams as it will never terminate for
    an infinite stream. In this example, the two strings, `"dog"` and `"cat"`, are
    streamed and a count of `2` is returned. Note that `count()` is a reduction as
    it looks at each element in the stream and returns a single value.
  prefs: []
  type: TYPE_NORMAL
- en: min() and max()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Like `count()`, both `min()` and `max()` work with finite streams and hang on
    infinite streams (in case another value might be the minimum or maximum value).
    Both are reductions as they return a single value after processing the whole stream.
    Given that the stream could be empty, *Optional* is the return type.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 15**.12* (TerminalOperations.java) presents some code using `min()`
    and `max()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.12 – min() and max() in code](img/B19793_15_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.12 – min() and max() in code
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we initially define a custom `Comparator` that sorts the list
    of strings into ascending length-of-string order. This `Comparator` is then passed
    into the `min()` method, where `"pig"` is returned to `Optional`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We then use the functional-style `Optional` method, `ifPresent()`, to determine
    if there is a non-`null` value in `Optional`. As `"pig"` is there (present)),
    it is output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Next up is a different custom `Comparator` that sorts the list of numbers into
    ascending numeric order. This is then passed into the `max()` method, where `12`
    is stored in the `Optional` variable `max`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, we use the `ifPresent()` method to determine if there is a non-`null`
    value in `max`. As `12` is present, it is output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, we demonstrate that you can use `Stream.empty()` to create an empty
    stream:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, as the stream is empty, the comparator `(x1, x2) -> 0` is
    never called and as a result, there is no value in `Optional`. Thus, `isEmpty()`
    returns true and `isPresent()` returns false:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: findAny() and findFirst()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: These terminal operations are not reductions as they do not process the entire
    stream. As its name suggests, `findAny()` will return any element – typically,
    the first one is returned but this is not guaranteed. On the other hand, `findFirst()`
    does just that – it returns the first element. Not surprisingly, these methods
    can work with infinite streams (as they don’t process all of the stream). An *Optional*
    is returned in both cases (as the stream may be empty when they are called).
  prefs: []
  type: TYPE_NORMAL
- en: A *short-circuiting* terminal operation is defined as an operation that, when
    presented with infinite input, may terminate in finite time. Given that these
    operations can return before processing all of the stream, they are considered
    short-circuiting.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 15**.13* (TerminalOperationsFindAnyFindFirst.java) presents their use
    in code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.13 – findAny() and findFirst() in code](img/B19793_15_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.13 – findAny() and findFirst() in code
  prefs: []
  type: TYPE_NORMAL
- en: In this figure, we execute `findAny()` on the stream of strings `"John"` and
    `"Paul"`. This returns `"John"` usually but is not guaranteed; whereas when we
    execute `findFirst()` on the same stream, `"John"` is returned all the time. As
    this example demonstrates, neither operation processes `"Paul"` and therefore
    they are not considered reductions.
  prefs: []
  type: TYPE_NORMAL
- en: anyMatch(), allMatch, and noneMatch()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'These three terminal operations all accept a `Predicate` condition and return
    a `boolean` value. Like the `"find"` methods, they are not reductions either as
    they may not look at *all* of the elements. Depending on the data, these operations
    may or may not terminate when presented with infinite streams. That said, they
    are considered short-circuiting as they may terminate. *Figure 15**.14* (`TerminalOperations.java`)
    presents an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.14 – anyMatch(), allMatch(), and noneMatch() in code](img/B19793_15_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.14 – anyMatch(), allMatch(), and noneMatch() in code
  prefs: []
  type: TYPE_NORMAL
- en: 'In this figure, we define a finite stream of `String` names as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'A predicate is defined to see if a name begins with `"A"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'We then stream the (source) list of names and check, using `anyMatch()`, if
    any of the names begin with `"A"` – as `"Alan"` does, `true` is returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we re-stream the list and check, using `allMatch()`, if all of the names
    begin with `"A"` – as `"Brian"` does not, `false` is returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'We then re-stream the list and check, using `noneMatch()`, if none of the names
    begin with `"A"` – as `"Alan"` does, `false` is returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we have to re-stream the source twice (for `allMatch()` and `noneMatch()`).
    This is because, once a terminal operation is performed, a stream is considered
    consumed and can no longer be used. If you need the same data, then you must return
    to the source and get a new stream. This is what we have done here. Attempting
    an operation on a closed source generates an `IllegalStateException` error.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s delve a little deeper into the short-circuiting nature of these operations
    when presented with infinite data. The following example (*Figure 15**.15*) presents
    code (`TerminalOperations.java`) where each of these operations, given an infinite
    stream, may or may not terminate. Whether they terminate or not is determined
    by the data (and the predicate being tested against that data):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.15 – Short-circuiting nature of anyMatch(), allMatch(), and noneMatch()
    in code](img/B19793_15_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.15 – Short-circuiting nature of anyMatch(), allMatch(), and noneMatch()
    in code
  prefs: []
  type: TYPE_NORMAL
- en: In this figure, we generated an infinite stream of `"abc"` strings and defined
    two predicates; one checks if the string begins with `"a"` and the other checks
    if the string begins with `"b"`. Note that, as explained previously, a closed
    stream must be reopened before being used. Therefore, lines 137-144 are *mutually
    exclusive* – you can only use one of them at a time. We have left them all uncommented
    as this aids the clarity of the diagram. When we run the code, we must comment
    out five of the six lines.
  prefs: []
  type: TYPE_NORMAL
- en: '`infStr.anyMatch(startsWithA)` checks if any of the strings start with `"a"`
    – as the first one does, it short-circuits with `true`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`infStr.anyMatch(startsWithB)` checks if any of the strings start with `"b"`
    – the first one does not, so it checks the next one; it does not either, and so
    on. We had to kill the program in this instance.'
  prefs: []
  type: TYPE_NORMAL
- en: '`infStr.noneMatch(startsWithA)` checks if none of the strings start with `"a"`
    – as `"abc"` begins with `"a"`, `noneMatch()` short-circuits with `false`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`infStr.noneMatch(startsWithB)` checks if none of the strings start with `"b"`
    – the first one does not, so it checks the next one; it does not either, and so
    on. This goes on forever, so we had to kill the program. So, when does `noneMatch()`
    return `true`? If you have a finite stream where none of the elements match the
    given predicate.'
  prefs: []
  type: TYPE_NORMAL
- en: '`infStr.allMatch(startsWithA)` checks if all the strings begin with `"a"`.
    In this instance, this will go on forever as we keep generating strings that do
    begin with `"a"`, ensuring `allMatch()` needs to check the next one and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: '`infStr.allMatch(startsWithB)` can short-circuit as `"abc"` does not begin
    with `"b"`, enabling `allMatch()` to return `false`.'
  prefs: []
  type: TYPE_NORMAL
- en: forEach()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As `forEach(Consumer)` has no return value (returns `void`), it is not considered
    a reduction. As it returns nothing, any changes you wish to make must occur inside
    `Consumer` as side effects. We covered several examples of `forEach()` already,
    so *Figure 15**.16* (TerminalOperations.java) shows just a simple one:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.16 – The forEach() terminal operation in code](img/B19793_15_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.16 – The forEach() terminal operation in code
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we are streaming a list of *strings*, representing peoples’
    names and echoing them to the screen.
  prefs: []
  type: TYPE_NORMAL
- en: reduce()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `reduce()` method combines a stream into a single object. As it processes
    all the elements, it is a reduction. There are three overloaded versions. We will
    discuss them in turn with examples.
  prefs: []
  type: TYPE_NORMAL
- en: T reduce(T identity, BinaryOperator<T> accumulator)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is the most common way of doing a reduction – start with an initial value
    (identity) and keep merging it with the next value. As well as the identity being
    the initial value, it is also the value returned if the stream is empty. This
    means that there will always be a result and thus `Optional` is not the return
    type (in this version).
  prefs: []
  type: TYPE_NORMAL
- en: The accumulator combines the current result with the current value in the stream.
    As it is a `BinaryOperator`, this means it is a function where the two inputs
    and the return type are all the same type.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 15**.17* (`TerminalOperations.java`) presents some examples to help
    explain this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.17 – T reduce(T identity, BinaryOperator<T> acc) in code](img/B19793_15_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.17 – T reduce(T identity, BinaryOperator<T> acc) in code
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us examine the first reduction in this figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: This reduction defines the empty string as the identity. This is both the string
    we start with and the string returned if the stream is empty. The accumulator
    takes in two strings, namely, `s1` and `s2`. The first time round, `s1` is `""`
    and `s2` is `"s"`, resulting in `"s"`. The next time round, `s1` is the result
    from the previous run, which is `"s"`, and `s2` is `"e"`, resulting in `"se"`.
    After that, `s1` is `"se"` and `s2` is `"a"`, resulting in `"sea"`. Finally, `s1`
    is `"sea"` and `s2` is `"n"`, resulting in `"sean"`. That’s how accumulators work.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second reduction starts by re-streaming the source:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: However, a filter intermediate operation is applied. This filter ensures only
    strings with a length of `> 2` are kept, resulting in an empty stream for `reduce()`.
    Thus, `reduce()` returns the `"``nothing"` identity.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last reduction gives another example of an identity and an accumulator
    in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The sequence of values is `n1` is `1`, `n2` is `2`, and the result is `2`; `n1`
    is `2`, `n2` is `3`, and the result is `6`; `n1` is `6`, `n2` is `4` and the result
    is `24`.
  prefs: []
  type: TYPE_NORMAL
- en: Optional<T> reduce(BinaryOperator<T> accumulator)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This is very similar to the first version except that no identity is provided.
    As no identity is provided, `Optional` is the return type (given that, the stream
    may be empty before this method is called). There are three possible returns:'
  prefs: []
  type: TYPE_NORMAL
- en: An empty stream – results in an empty `Optional`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: One element in the stream – that element is returned (in `Optional`)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Multiple elements in the stream – the accumulator is applied
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why are there two versions that are so similar? Why not just have the first
    version, with its identity? Well, there may be a situation, however unlikely,
    that the accumulator returns with the same value as the identity. In that scenario,
    you would not know whether the stream was empty (identity returned) or not (accumulator
    applied). This second version, with its use of `Optional`, ensures that you know
    when the stream is empty.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s examine the third version of `reduce()`.
  prefs: []
  type: TYPE_NORMAL
- en: <U> reduce(U identity, BiFunction accumulator, BinaryOperator combiner)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This version is used when we are dealing with different types where intermediate
    reductions are created that are combined at the end. This version is useful in
    parallel streams as the stream can be decomposed and reassembled by different
    threads. *Figure 15**.18* (`TerminalOperations.java`) presents an example in code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.18 - U reduce(U identity, BiFunction accumulator, BinaryOperator
    combiner) in code](img/B19793_15_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.18 - U reduce(U identity, BiFunction accumulator, BinaryOperator combiner)
    in code
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we are streaming a list of strings and we want to total the
    overall number of characters in all of the strings. The `reduce()` method is coded
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'and has 3 elements:'
  prefs: []
  type: TYPE_NORMAL
- en: 0 is the identity, which represents our starting value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`(n, str) -> n + str.length()` is the `BiFunction` accumulator. In this case,
    the first parameter is `Integer` and the second parameter is `String`. The return
    type matches the first parameter – in other words, `Integer`. We did not highlight
    this in the method signature as all the letters can sometimes confuse the issue.
    This accumulator adds the length of the current `String` to the current total.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`(n1, n2) -> n1 + n2` represents the combiner `BinaryOperator` (a function
    where the types are the same). Its lambda simply adds the two numbers and returns
    the sum. This function adds the intermediate results from the accumulators.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thus, with parallel streams, one thread could return the accumulated value of
    6, which is the sum of the lengths of `"car"` and `"bus"`, whereas another thread
    could return the accumulated value of 14, which is the sum of the lengths of `"train"`
    and `"aeroplane"`. These two values are then combined by the combiner, resulting
    in 20.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will move on to a powerful terminal operation, namely `collect()`.
  prefs: []
  type: TYPE_NORMAL
- en: collect()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is a special type of reduction called a mutable reduction because we are
    using the same mutable object while accumulating. This makes it more efficient
    than regular reductions. Common mutable objects include `StringBuilder` and `ArrayList`.
  prefs: []
  type: TYPE_NORMAL
- en: This operation is extremely useful for getting data `Map`, `List`, or `Set`.
  prefs: []
  type: TYPE_NORMAL
- en: There are two versions – one that gives you complete control over the collecting
    process and another that gives you predefined collectors from the API. We will
    start with the first one, where you can specify everything yourself.
  prefs: []
  type: TYPE_NORMAL
- en: collect(Supplier, BiConsumer, BiConsumer)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This method is best explained with a code example, see *Figure 15**.19*, which
    is taken from `TerminalOperations.java` on the repo.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.19 – The collect(Supplier, BiConsumer, BiConsumer) operation in
    code](img/B19793_15_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.19 – The collect(Supplier, BiConsumer, BiConsumer) operation in code
  prefs: []
  type: TYPE_NORMAL
- en: In this figure, we are building up one long word from a list of smaller words.
    Note that the equivalent method references (to the lambdas used), are in comments
    on the right-hand side of each line.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first argument to `collect()` is a `Supplier` which specifies that we want
    to work with a `StringBuilder`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The accumulator adds the current `String` to the `StringBuilder`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The combiner takes the two `StringBuilder`''s and merges them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: This is useful in parallel processing, where different threads can perform accumulations
    and have their results combined. In this example, thread 1 could return `"adjud"`,
    the result of accumulating `"ad"` and `"jud"`; and thread 2 could return `"icate"`,
    the result of accumulating `"i"` and `"cate"`. These two results combine into
    `"adjudicate"`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s look at the version of `collect()` where we pass in pre-defined API
    collectors.
  prefs: []
  type: TYPE_NORMAL
- en: collect(Collector)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is the version that accepts a pre-defined API collector. We access these
    collectors via `static` methods in the `Collectors` class. These collectors do
    nothing on their own – they exist to be passed into the `collect(Collector)` method.
  prefs: []
  type: TYPE_NORMAL
- en: We will examine many of them, particularly the ones that help us extract data
    out of the stream into collections for subsequent processing. In addition, we
    will look at how to group and partition information. Let’s start with some of
    the more basic collectors.
  prefs: []
  type: TYPE_NORMAL
- en: Collectors.joining(CharSequence delimiter)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This collector returns a `Collector` that concatenates the input elements, separated
    by the specified delimiter. The order of the stream is maintained. *Figure 15**.20*
    presents an example (taken from CollectorsExamples.java on the repo).
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.20 - Collectors.joining() in code](img/B19793_15_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.20 - Collectors.joining() in code
  prefs: []
  type: TYPE_NORMAL
- en: In this example, the strings are appended together and delimited by `", "`.
  prefs: []
  type: TYPE_NORMAL
- en: Collectors.averagingInt(ToIntFunction)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This returns a `Collector` that produces the average of the integers produced
    by the function supplied. *Figure 15**.21* (CollectorsExamples.java) presents
    an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.21 – Collectors.averagingInt(ToIntFunction) in code](img/B19793_15_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.21 – Collectors.averagingInt(ToIntFunction) in code
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we are streaming strings, representing desserts. Each string
    has a length and we want to calculate the average of the lengths. The function,
    `s -> s.length()` takes in a `String`, namely `s`, and returns its integer length.
    The method reference version is in a comment on the right. The average is then
    output.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s examine how we can extract the stream contents into a `List`, `Set`,
    or `Map`. We will start with `List`.
  prefs: []
  type: TYPE_NORMAL
- en: Collectors.toList()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This returns a `Collector` operation that accumulates the elements into a new
    `List`. There is no guarantee on the type of `List`. For example, there is no
    guarantee that the `List` is an `ArrayList` or a `LinkedList`. To gain that level
    of control, you must use the `toCollection(Supplier)` method (which we will be
    using in the `Set` example). *Figure 15**.22* presents the `Car` type (`CollectorsExamples.java`)
    that we will use in the next few examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.22 – The Car class](img/B19793_15_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.22 – The Car class
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 15**.23* presents an example of `Collectors.toList()` in code (from
    `CollectorsExamples.java` in the repo):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.23 – Collectors.toList() in code](img/B19793_15_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.23 – Collectors.toList() in code
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we added three `Car`s to our `List`. Recall that `List`s maintain
    insertion order. The `map(Function)` method is an intermediate operation that
    takes in one stream and transforms it into another stream. We will discuss the
    `map()` method in more detail in [*Chapter 16*](B19793_16.xhtml#_idTextAnchor401),
    but for now, realize that there is `Stream<Car>` coming into `map()` and `Stream<String>`
    coming out. This is because `brand` in `Car` is a `String`. Now, we have a `Stream<String>`
    for `collect()` to extract in `List` format.
  prefs: []
  type: TYPE_NORMAL
- en: As stated earlier, the implementation type is not guaranteed. What if we wanted
    a specific implementation and not just that, but an implementation that sorted
    the elements as they were added? `TreeSet` will do this. Let’s look at that now.
  prefs: []
  type: TYPE_NORMAL
- en: Collectors.toSet() and Collectors.toCollection(Supplier)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`Collectors.toSet()` returns a `Collector` that accumulates the elements into
    a new `Set`. There is no guarantee on the type of `Set`. In this example, however,
    we want a specific `Set`, namely `TreeSet`. We can use `Collectors.toCollection(Supplier)`
    when we want a specific implementation. *Figure 15**.24* presents the code (`CollectorsExamples.java`):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.24 – Collectors.toCollection(Supplier) in code](img/B19793_15_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.24 – Collectors.toCollection(Supplier) in code
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, the cars have been deliberately added to our `ArrayList` in
    unsorted brand order. The following line is where the magic happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'We are passing in a `Supplier` method reference to create a `TreeSet` that
    is, in turn, passed to the `Collectors.toCollection()` method. This results in
    a `TreeSet` implementation. When we output `treeSet` we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the brands are now sorted alphabetically (the default sort order
    for strings). We can also extract data out of a stream into a `Map`. Let us examine
    that now.
  prefs: []
  type: TYPE_NORMAL
- en: Collectors.toMap(Function keyMapper, Function valueMapper)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This returns a `Collector` that gathers elements into a `Map` where the keys
    and values are the result of applying the provided mapping function to the stream
    elements. Again, there are no guarantees of the type of `Map` returned. *Figure
    15**.25* presents an example in code (`CollectorsExamples.java`):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.25 – Collectors.toMap(Function keyMapper, Function valueMapper)
    in code](img/B19793_15_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.25 – Collectors.toMap(Function keyMapper, Function valueMapper) in
    code
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we are streaming a list of desserts (as strings). The declared
    `Map` states that our key is a `String` type and that the value is an `Integer`
    type. This is because we want to set up a `Map` so that the dessert name is the
    key and the number of characters in the dessert name is the value.
  prefs: []
  type: TYPE_NORMAL
- en: 'The keys in the `Map` are set up using the following `Function`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Recall that `Function<T, R>` takes in one parameter of type `T` and returns
    a result of type `R`. In this example, our function will be `Function<String,
    String>` as we are streaming a dessert (`String`) and this dessert is what we
    want to use as the key. We can simply use the lambda `s -> s` or use the `String::toString`
    method reference. Either version will work.
  prefs: []
  type: TYPE_NORMAL
- en: 'The values in the Map are set up using the following `Function`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Our function in this case is `Function<String, Integer>` as we want our function
    to return the length of the dessert. We can use the lambda `s -> s.length()` or
    the `String::length` method reference.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output that’s generated is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we present the next version, let’s look at an example that generates
    an exception. *Figure 15**.26* presents the example in code (CollectorsExamples.java):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.26 – The Collectors.toMap(Function keyMapper, Function valueMapper)
    exception](img/B19793_15_26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.26 – The Collectors.toMap(Function keyMapper, Function valueMapper)
    exception
  prefs: []
  type: TYPE_NORMAL
- en: In this figure, we are trying to set up a `Map` where the key is the length
    of the dessert name and the value is the dessert name itself. Note that the dessert
    names are subtly different from the previous figure. Now, instead of `"apple tart"`,
    we have `"tart"`. This is going to lead to problems. Maps cannot have duplicate
    keys and both `"cake"` and `"tart"` are 4 characters long. This leads to an `IllegalStateException`
    error.
  prefs: []
  type: TYPE_NORMAL
- en: To fix this issue, we need to use the second version of `toMap()`.
  prefs: []
  type: TYPE_NORMAL
- en: Collectors.toMap(Function, Function, BinaryOperator mergeFunction)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This collector operates similarly to the previous collector, except when we
    encounter duplicate keys. In that scenario, the merge function is applied to the
    *values*. The merge function is a `BinaryOperator<T`,`>`, which is-a `BiFunction<T,T,T>`.
    In other words, there are two inputs and one result, and they are all the same
    type. *Figure 15**.27* presents the code (`CollectorsExamples.java`) with the
    merge function present to handle duplicate keys:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.27 – Collectors.toMap(Function, Function, BinaryOperator)](img/B19793_15_27.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.27 – Collectors.toMap(Function, Function, BinaryOperator)
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, the only difference is the merge function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The merge function takes in `s1` and `s2`, the values for the two colliding
    keys. In this example, the values are appended with a comma between them.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output generated is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: The colliding key was `4` and their values were `"cake"` and `"tart"`, resulting
    in `"``4=cake, tart"`.
  prefs: []
  type: TYPE_NORMAL
- en: The next version enables us to specify the `Map` implementation we desire.
  prefs: []
  type: TYPE_NORMAL
- en: Collectors.toMap(Function, Function, BinaryOperator, Supplier mapFactory)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As we know, the `Map` implementations that are returned are not guaranteed.
    You could get a `HashMap` or `TreeMap` implementation. This `toMap()` version
    is very similar to the previous one except there is an extra argument where we
    can specify our implementation type. *Figure 15**.28* presents the code (`CollectorsExamples.java`)
    with the constructor method reference used to ensure a `TreeMap` implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.28 – Collectors.toMap(Function, Function, BinaryOperator, Supplier)](img/B19793_15_28.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.28 – Collectors.toMap(Function, Function, BinaryOperator, Supplier)
  prefs: []
  type: TYPE_NORMAL
- en: In this figure, the dessert name is the key and the length of the dessert name
    is the value. `"cake"` is in the source twice, causing a duplicate keys issue
    and a reason to invoke the merge function. In this instance, the values for the
    duplicate keys are to be added. As `"cake"` appears just twice, this means that
    `"cake=8"` will be in `Map`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we want a `TreeMap` implementation. To ensure this, we specify
    an extra argument, the following `Supplier`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Thus, our keys will be sorted. When we output our map we can see that the keys
    are alphabetically sorted, as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Also, note that `"cake"` maps to 8 (4 + 4).
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also use the `getClass()` method to prove that we have indeed a `TreeMap`
    implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Now, let’s examine the `groupingBy` terminal operations.
  prefs: []
  type: TYPE_NORMAL
- en: Collectors.groupingBy(Function classifier)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `groupingBy()` operation tells `collect()` to group all the elements into
    a `Map` implementation. The `Function` parameter determines the keys in `Map`.
    The values are a `List` (the default) of all entries that match that key. Having
    the values returned as a `List` can, as we shall see, be changed. There is no
    guarantee as to the `Map` or `List` implementations used. *Figure 15**.29* presents
    an example in code, taken from `CollectorsExamples.java` in the repo:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.29 – Collectors.groupingBy(Function) in code](img/B19793_15_29.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.29 – Collectors.groupingBy(Function) in code
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we are streaming a list of names and are extracting a `Map<Integer,
    List<String>` from the stream (as per the declaration). The `Function` parameter
    `String::length` that’s passed into `groupingBy()`, tells `collect()` that the
    key in the map is the length of the `String` (in effect, the number of characters
    in the name). The values are organized into a `List`, and each entry in the list
    is a `String` where the length of the `String` matches the key. For example, as
    per the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '`5` maps to `"Peter"` and `6` maps to `"Martin"`. Note that in the output,
    `"Tom"` appears in the list twice. This is because lists allow duplicates.'
  prefs: []
  type: TYPE_NORMAL
- en: What if we wanted `"Tom"` to appear only once in the output list? There is an
    overloaded version of `groupingBy()` that will help us here.
  prefs: []
  type: TYPE_NORMAL
- en: Collectors.groupingBy(Function keyMapper, Collector downstreamCollector)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Recall that a `Set` implementation does not allow duplicates, so using a `Set`
    implementation for the values, as opposed to the default `List`, will solve this.
    The second parameter here is known as a *downstream collector*. The function of
    a downstream collector is to do something special with the *values*. In this example,
    we want the values organized as a `Set` implementation. *Figure 15**.30* presents
    the code (`CollectorsExamples.java`) adjustments:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.30 – Using Collectors.groupingBy(Function, Collector) for a Set
    implementation](img/B19793_15_30.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.30 – Using Collectors.groupingBy(Function, Collector) for a Set implementation
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, the type for the values in the `Map` is `Set<String>` and
    not `List<String>`. The downstream collector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'states that we want the values organized as a `Set`. The output shows that
    `"Tom"` is now listed only once:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the implementation type for our `Map` happens to be a `HashMap` implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: This implementation is not guaranteed. What if we wanted to guarantee a `TreeMap`
    implementation? There is an overloaded version to help us here also.
  prefs: []
  type: TYPE_NORMAL
- en: Collectors.groupingBy(Function, Supplier mapFactory, Collector)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This version accepts a `Supplier` as its second parameter. This `Supplier` returns
    the implementation that you desire.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 15**.31* presents the code adjustments (`CollectorsExamples.java`):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.31 – Using Collectors.groupingBy(Function, Supplier, Collector)
    for a TreeMap implementation](img/B19793_15_31.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.31 – Using Collectors.groupingBy(Function, Supplier, Collector) for
    a TreeMap implementation
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we are reverting to a `List` type for the values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'To extract the stream data as a `List` type, we must use the appropriate downstream
    collector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'As can be seen from the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '`"Tom"` is now duplicated again (as lists allow duplicates).'
  prefs: []
  type: TYPE_NORMAL
- en: 'We also pass a `Supplier` argument to `groupingBy()`, stating we want a `TreeMap`
    implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'The `map.getClass()` call outputs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: showing that we have a `TreeMap` implementation.
  prefs: []
  type: TYPE_NORMAL
- en: We will now look at a special case of grouping, called partitioning.
  prefs: []
  type: TYPE_NORMAL
- en: Collectors.partitioningBy(Predicate)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Partitioning is a special case of grouping where there are only two groups –
    true and false. Thus, the keys in the `Map` implementation will be of the `Boolean`
    type. The values will default to a `List` type. There is no guarantee as to the
    `Map` or `List` implementations returned.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 15**.32* presents a code example (CollectorsExamples.java):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.32 – Collectors.partitioningBy(Predicate) in code](img/B19793_15_32.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.32 – Collectors.partitioningBy(Predicate) in code
  prefs: []
  type: TYPE_NORMAL
- en: In this figure, we are extracting data from the stream into a `Map<Boolean,
    List<String>`. The keys will be true and false. The values will be the elements
    in the stream that are either true or false based on the predicate provided.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the following line of code, we tell `collect()` to partition the stream
    based on whether the `String` name begins with `"T"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'As can be seen from the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: the true partition contains `"Thomas"` and `"Teresa"` and the false partition
    contains all the other names. Note that `"Alan"` is in the false partition twice,
    as lists allow duplicates.
  prefs: []
  type: TYPE_NORMAL
- en: There is an overloaded version of `partitioningBy()` that enables us to pass
    in a downstream collector.
  prefs: []
  type: TYPE_NORMAL
- en: Collectors.partitioningBy(Predicate, Collector downstreamCollector)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A downstream collector is useful for specifying a different collection for
    our values. For example, instead of a `List` view, we may want a `Set` view so
    that duplicates are automatically removed. *Figure 15**.33* presents a code example
    (CollectorsExamples.java):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.33 – Collectors.partitioningBy(Predicate, Collector) in code](img/B19793_15_33.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.33 – Collectors.partitioningBy(Predicate, Collector) in code
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, note that the name `"Alan"` is in the source twice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: In addition, we are collecting data into a `Map<Boolean,` *Set*`<String>>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also changed the predicate just to do something different:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Thus, if the number of characters in the string is `> 4`, the string is placed
    in the true partition; otherwise, the string is placed in the false partition.
  prefs: []
  type: TYPE_NORMAL
- en: 'We specify the required downstream collector as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'This means that the values are to be returned as a `Set`. As can be seen in
    the output, `"Alan"` appears only once (in the `false` partition):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: That completes our discussion on the terminal operations section and also concludes
    [*Chapter 15*](B19793_15.xhtml#_idTextAnchor377). Now, let’s put that knowledge
    into practice to reinforce the concepts we’ve learned.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Create a stream of dinosaur names (use a List or an array). Use the `filter`
    method to create a new stream that only includes the names of carnivorous dinosaurs.
    Then, use the `forEach` method to print out these names..
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Demonstrate stream laziness by creating a stream from a list of dinosaur ages.
    Use the `filter` method to filter out ages greater than 100, and then use a `map`
    method to increase each remaining age by 10\. However, do not use any terminal
    operation. Explain why nothing is printed or no operation is performed until a
    terminal operation (like `forEach`) is called..
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using a stream of dinosaur weights (as doubles), count the number of dinosaurs
    that weigh more than 5000 kg using the filter and count terminal operations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Given a stream of dinosaur species names (String), use the `findFirst` terminal
    operation to retrieve the first name on the list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Project – dynamic dinosaur care system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Integrate the Stream API into your dinosaur care system to process large volumes
    of dinosaur data, such as health records, feeding schedules, and so on. The system
    should also incorporate `Optional` and parallel streams where appropriate, optimizing
    data processing and minimizing potential null pointer exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the steps to get you there:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Dinosaur` class with properties such as `name`, `species`, `healthStatus`,
    and so on. There should also be a `DinosaurCareSystem` class for implementing
    the main functionalities.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Stream` from the list of records and use the `filter` method to get these
    records. Here’s an example: `List<HealthRecord> criticalRecords = records.stream().filter(r
    -> r.getHealthStatus() <` `CRITICAL_THRESHOLD).collect(Collectors.toList())`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Stream` to filter the schedules. Here’s an example: `List<FeedingSchedule>
    morningFeeds = schedules.stream().filter(s ->` `s.getTime().isBefore(LocalTime.NOON)).collect(Collectors.toList())`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`NullPointerException``Optional` to avoid a `NullPointerException` error. Here’s
    an example: `Optional.ofNullable(dinosaur.getTrainer()).map(Trainer::getName).orElse("No`
    `trainer assigned").`*   `stream()` with `parallelStream()` in the previous examples.
    Be aware, though, that not every problem is suitable for parallel processing.
    If the tasks have dependencies or need to be processed in a specific order, stick
    with regular streams.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored the fundamentals of streams and stream terminal
    operations. Streams (along with lambda expressions) enable a style of programming
    known as functional-style programming, where you state what you want to solve
    rather than how to solve it (imperative style). Functional-style programming tends
    to be easier to read because, with imperative programming, the details of how
    to solve the problem can get mixed up in the implementation.
  prefs: []
  type: TYPE_NORMAL
- en: We discussed stream pipelines using the analogy of an assembly line. A stream
    pipeline consists of a data source, zero or more intermediate operations, and
    a terminal operation, in that order. Streams are lazily evaluated, which means
    that data is only provided as and when needed. This is possible because the JVM
    has an overall view of the pipeline, as nothing happens until the terminal operation
    is executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Stream sources can vary from arrays (`Arrays.stream(arrayToUse)`), collections
    (`collectionToUse.stream()`), and files (`Files.lines(Path)`) to a variable number
    of arguments (`Stream.of(varargs)`). Infinite streams can be generated using two
    `static` methods from the Stream API: `Stream.generate()` and `Stream.iterate()`.'
  prefs: []
  type: TYPE_NORMAL
- en: Terminal operations kickstart the whole pipeline and every pipeline must have
    a terminal operation. Once a terminal operation executes on a stream, the stream
    is closed and must be re-streamed to be reused. Popular terminal operations include
    `forEach()`, `count()`, `min()`, `max()`, `findAny()`, `findFirst()`, `allMatch()`,
    `anyMatch()`, `noneMatch()`, `reduce()`, and `collect()`.
  prefs: []
  type: TYPE_NORMAL
- en: A reduction is a special type of terminal operation where all of the stream
    items are combined into one primitive or `Object`. The `reduce()` method has overloaded
    versions to facilitate this. The `collect()` method is very useful for extracting
    data out of the stream and into a collection, such as a `List` or `Map` delete
    The `collect()` method accepts collectors, which you can define yourself, or you
    can simply use one of the many pre-defined collectors in the API.
  prefs: []
  type: TYPE_NORMAL
- en: That completes our discussion on the fundamentals of streams. In the next chapter,
    we will expand into more advanced streaming concepts.
  prefs: []
  type: TYPE_NORMAL
