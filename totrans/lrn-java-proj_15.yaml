- en: '15'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '15'
- en: Streams – Fundamentals
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 流 - 基础知识
- en: In [*Chapter 14*](B19793_14.xhtml#_idTextAnchor355), we learned about lambda
    expressions. Lambda expressions enable us to write more concise code. Be aware,
    however, that the compiler is, in the background, inserting the code we omit.
    For that to work, the compiler must have no decisions to make. This is where “functional
    interfaces” come into play. A functional interface is an interface with just one
    `abstract` method; this is known as the “functional method.” Lambda expressions
    can only be used with functional interfaces.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第14章*](B19793_14.xhtml#_idTextAnchor355)中，我们学习了lambda表达式。Lambda表达式使我们能够编写更简洁的代码。然而，请注意，编译器在后台正在插入我们省略的代码。为了使其工作，编译器必须没有决策要做。这就是“函数式接口”发挥作用的地方。函数式接口是一个只有一个`abstract`方法的接口；这被称为“函数方法”。Lambda表达式只能与函数式接口一起使用。
- en: We saw that if a local variable is used in a lambda expression, that variable
    must be `final` or “effectively final.” This keeps both views (method and lambda)
    of the variable’s value in sync. In other words, both the method and the lambda
    have the same value for the variable at all times.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到，如果一个局部变量在lambda表达式中被使用，那么这个变量必须是`final`或“实际上是final”的。这保持了变量值（方法和lambda）的两个视图的一致性。换句话说，方法和lambda在所有时间对变量的值都是相同的。
- en: We also examined the more popular functional interfaces in the API, namely,
    `Predicate`, `BiPredicate`, `Supplier`, `Consumer`, `BiConsumer`, `Function`,
    and `BiFunction`. There are many other functional interfaces in the API, including
    variants that cater to primitives (as opposed to objects).
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还检查了API中更流行的函数式接口，包括`Predicate`、`BiPredicate`、`Supplier`、`Consumer`、`BiConsumer`、`Function`和`BiFunction`。API中还有许多其他函数式接口，包括针对原始数据类型（而不是对象）的变体。
- en: Next, we discussed method references, which can make your code even more concise
    than lambdas. A method reference is a shorthand for a lambda expression. For the
    compiler to generate the lambda from the method reference, the context is key.
    The context factors in the functional interface declared and the generic types
    used.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们讨论了方法引用，这可以使你的代码比lambda表达式更加简洁。方法引用是lambda表达式的简写。为了从方法引用生成lambda表达式，上下文是关键。上下文包括声明的函数式接口和使用的泛型类型。
- en: 'We also explored the four types of method references: bound, unbound, static,
    and constructor. Bound method references bind, at compile time, to a variable
    from the method, whereas unbound rely on the object to be passed in at runtime.
    Static method references are unbound and invoke a `static` method. Constructor
    method references use the `::new` syntax to create objects.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还探讨了四种方法引用类型：绑定、非绑定、静态和构造器。绑定方法引用在编译时绑定到方法中的一个变量，而非绑定方法则依赖于在运行时传入的对象。静态方法引用是非绑定的，并调用一个`static`方法。构造器方法引用使用`::new`语法来创建对象。
- en: We finished the chapter by discussing an example where the same method reference
    was used in three different contexts. Each of the method references resulted in
    a different lambda due to the differing contexts. This demonstrated the importance
    of context when examining method references.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过讨论一个在三个不同上下文中使用相同方法引用的例子来结束本章。由于上下文的不同，每个方法引用都导致了不同的lambda。这证明了在检查方法引用时上下文的重要性。
- en: In this chapter, we will start our coverage of streams. This is a large and
    important topic, requiring two chapters. Java 8 introduced both lambdas and streams
    to enable a more functional style of programming. This can lead to cleaner, more
    expressive code as we are not bogged down in how to do something; we just say
    we want it done.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将开始对流的介绍。这是一个庞大且重要的主题，需要两章来涵盖。Java 8引入了lambda和流，以实现更函数式的编程风格。这可以导致代码更加清晰、更具表现力，因为我们不必纠结于如何做某事；我们只需表达我们想要它完成。
- en: We will start by discussing the stream pipeline. We will then discuss stream
    “laziness” before moving on to show ways of creating streams. Lastly, we will,
    with the aid of code examples, examine terminal operations.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先讨论流管道。然后，我们将讨论流的“惰性”，接着展示创建流的方法。最后，我们将借助代码示例来检查终端操作。
- en: 'This chapter covers the following main topics:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了以下主要主题：
- en: Understanding stream pipelines
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解流管道
- en: Exploring stream laziness
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索流的惰性
- en: Creating streams
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建流
- en: Mastering terminal operations
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 精通终端操作
- en: Technical requirements
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code for this chapter can be found on GitHub at [https://github.com/PacktPublishing/Learn-Java-with-Projects/tree/main/ch15](https://github.com/PacktPublishing/Learn-Java-with-Projects/tree/main/ch15).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在GitHub上找到，地址为[https://github.com/PacktPublishing/Learn-Java-with-Projects/tree/main/ch15](https://github.com/PacktPublishing/Learn-Java-with-Projects/tree/main/ch15)。
- en: Understanding stream pipelines
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解流管道
- en: A *stream* in Java is a sequence of data that can be processed by operations.
    Streams are not another way to organize data, such as using an array or `Collection`,
    because streams do not hold data. Streams are all about efficiently processing
    data that is flowing by.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Java中的*流*是一系列可以由操作处理的数据。流不是另一种组织数据的方式，例如使用数组或`Collection`，因为流不持有数据。流全部关于高效处理流动的数据。
- en: Let’s look at the stream pipeline.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看流管道。
- en: Stream pipeline
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 流管道
- en: A *stream pipeline* is a set of operations that run on a stream to produce a
    result. At a minimum, a stream pipeline consists of a source, zero or more intermediate
    operations, and a terminal operation, in that order. A pipeline is similar to
    an assembly line in a factory. Let’s look at an example.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '*流管道*是一组在流上运行的运算，以产生结果。至少，流管道由一个源、零个或多个中间操作和一个终端操作组成，顺序如下。管道类似于工厂中的装配线。让我们看一个例子。'
- en: Assembly line analogy
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 装配线类比
- en: Let’s assume we have a task of sharpening and stamping pencils that are currently
    sitting in a box (which contains 100 pencils). Stamping them means marking the
    pencil type on the pencil, such as 2B, 2H, and so forth. The pencils must be sharpened,
    stamped, and finally packed away, in that order. Declaring a stream is the same
    as giving instructions to the supervisor. In this assembly line, Java is the supervisor.
    Nobody does anything until the supervisor shouts “Start.” The supervisor examines
    the instructions and sets up workstations with workers – one to take pencils from
    the box, one to sharpen the pencil, one to stamp the sharpened pencil, and one
    to pack away the finished pencil.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个任务，需要削和盖章目前放在盒子里的铅笔（盒子里有100支铅笔）。盖章意味着在铅笔上标记铅笔类型，例如2B、2H等等。铅笔必须按照顺序削尖、盖章，最后打包。声明一个流就是向主管下达指令。在这个装配线上，Java是主管。没有人会做任何事情，直到主管喊“开始”。主管检查指令，并设置工作站和工人——一个从盒子里拿铅笔，一个削铅笔，一个盖章削好的铅笔，一个打包完成的铅笔。
- en: The worker taking pencils from the box is the pipeline *source*. The pencils
    are the data. Sharpening and stamping the pencils are the *intermediate operations*.
    The last operation, packing away the pencils, is the *terminal operation*. The
    terminal operation is very important as the supervisor will not shout “Start”
    until they see the terminal operation. Upon seeing it, however, the supervisor
    will shout “Start” and the process will begin.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 从盒子里拿铅笔的工人是管道的*源*。铅笔是数据。削铅笔和盖章是*中间操作*。最后一个操作，将铅笔打包，是*终端操作*。终端操作非常重要，因为主管不会在看到终端操作之前喊“开始”。然而，一旦看到，主管会喊“开始”，然后流程就会开始。
- en: Let’s examine this process.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查这个过程。
- en: The first worker takes a pencil out of the box and hands it to the second worker,
    who sharpens it. The second worker hands the sharpened pencil to the next worker,
    who stamps it and hands it to the final worker in the assembly line, who packs
    the pencil away.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个工人从盒子里拿出铅笔，交给第二个工人，第二个工人将其削尖。第二个工人将削好的铅笔交给下一个工人，下一个工人盖章，然后交给装配线上的最后一个工人，他将铅笔打包。
- en: Note that pencils (and data) can only proceed in one direction – once the worker
    passes on the pencil, they can’t get it back. From a Java perspective, this makes
    streams different from arrays and collections (where you can access the data at
    any time).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，铅笔（和数据）只能单向移动——一旦工人传递了铅笔，他们就不能再取回。从Java的角度来看，这使得流与数组或集合（你可以随时访问数据）不同。
- en: In addition, there is a principle of “lazy evaluation” in streams that we must
    be aware of here. We will discuss lazy evaluation in greater detail in the next
    section but for now, understand that data is *not* generated up front; it is only
    created *as and when needed*. This improves performance as you scale the amount
    of data you wish to process. Concerning our assembly line example, this means
    that the second pencil is not retrieved until required. What would be the point
    in having extra pencils sharpened and stamped if all you needed was one pencil?
    The supervisor, having the overall instructions, would be aware of this and ensure
    that the second pencil is never started.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在流中还有一个“懒惰评估”的原则，我们必须在这里注意。我们将在下一节更详细地讨论懒惰评估，但就现在而言，请理解数据不是预先生成的；它只在实际需要时创建。这提高了性能，因为当你扩展要处理的数据量时。关于我们的装配线示例，这意味着第二支铅笔只有在需要时才会被检索。如果你只需要一支铅笔，为什么要多磨几支铅笔并盖章呢？主管拥有整体指令，会意识到这一点并确保第二支铅笔永远不会开始。
- en: Let’s get back to our analogy where, at this point, we have one pencil packed
    away. Let’s say we only want two pencils sharpened and stamped. This will require
    a new worker to be on the assembly line to keep count. The supervisor will place
    this new worker after the worker who stamps the pencils. The new worker’s job
    is to count the pencils as they pass by (to be packed) and to inform the supervisor
    when two pencils have passed. The supervisor then instructs the first worker to
    take the second pencil out of the box. This pencil is sharpened and stamped. The
    new worker sees this second pencil pass by to be packed and informs the supervisor
    of this fact. The supervisor lets the last worker finish packing the second pencil
    and shouts “Stop.” Therefore, the other 98 pencils are never taken out of the
    box, as they were not needed. This is a lazy evaluation.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们的类比，在这个点上，我们已经有了一支铅笔被收好。假设我们只想磨两支铅笔并盖章。这需要一个新的工人在装配线上计数。主管会将这个新工人安排在盖章工人的后面。新工人的工作是数过（要打包）的铅笔，并在有两支铅笔通过时通知主管。主管随后指示第一个工人从盒子里取出第二支铅笔。这支铅笔被磨尖并盖章。新工人看到第二支铅笔通过并被打包，并通知主管这一事实。主管让最后一个工人完成第二支铅笔的打包，然后喊道“停止。”因此，其他98支铅笔从未从盒子里取出，因为它们并不需要。这是一种懒惰评估。
- en: Now, let’s discuss what makes up a stream pipeline.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们讨论构成流管道的内容。
- en: Elements of a stream pipeline
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 流管道的元素
- en: 'A stream pipeline consists of the following:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 流管道由以下内容组成：
- en: '`varargs`.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`varargs`。'
- en: '**Intermediate operations**: They transform the stream into another stream.
    We can have as many or as few as we like (zero or more). Due to lazy evaluation,
    they do not run until the terminal operation runs.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**中间操作**：它们将流转换成另一个流。我们可以有任意多或任意少（零个或多个）。由于懒惰评估，它们不会运行，直到终端操作运行。'
- en: '**Terminal operation**: This is required to start the whole process and produce
    a result. Streams can only be used once – after the terminal operation completes,
    the stream is no longer usable (regenerate the stream if necessary).'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**终端操作**：这是启动整个过程并产生结果所必需的。流只能使用一次——在终端操作完成后，流就不再可用（如果需要，重新生成流）。'
- en: 'Let’s discuss the pipeline with the aid of an example. *Figure 15**.1* presents
    a sample pipeline:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个例子来讨论管道。*图15.1*展示了样本管道：
- en: '![Figure 15.1 – A sample pipeline](img/B19793_15_01.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图15.1 – 样本管道](img/B19793_15_01.jpg)'
- en: Figure 15.1 – A sample pipeline
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.1 – 样本管道
- en: The var keyword
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`var`关键字'
- en: The `var` keyword is known as `temps` is a `List<Double>`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`var`关键字被称为`temps`是一个`List<Double>`。'
- en: 'The output from the previous figure is as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 上一图输出的结果如下：
- en: '[PRE0]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In this figure, we are counting the number of temperatures `> 100`. As streams
    do not hold data, pipelines specify how we want to manipulate the source. The
    first thing we do is to create a `List<Double>` list represented by `temps`:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图中，我们正在计算温度`> 100`的数量。由于流不保存数据，管道指定了我们想要如何操作源。我们首先做的事情是创建一个由`temps`表示的`List<Double>`列表：
- en: '[PRE1]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We then stream the list – in other words, the list is our source:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们流式传输列表——换句话说，列表是我们的源：
- en: '[PRE2]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Next, we use the `peek(Consumer)` intermediate operation, which is useful for
    debugging a pipeline and also for demonstrating what data is where in the pipeline:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用`peek(Consumer)`中间操作，这对于调试管道以及展示管道中的数据位置非常有用：
- en: '[PRE3]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'At this point, we want to filter *in* temperatures that are greater than 100\.
    In other words, only temperatures `> 100` will make it past the filter:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们想要过滤出大于100的温度。换句话说，只有大于`100`的温度才能通过过滤器：
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now that we have a temperature > 100, we use `peek(Consumer)` again to ensure
    our filter is working properly:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个大于100的温度，我们再次使用`peek(Consumer)`来确保我们的过滤器工作正常：
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Lastly, we have the terminal operation, `count()`, which starts off the whole
    process:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有终端操作`count()`，它启动了整个过程：
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Let us discuss how the streaming process works here. Firstly, `98.4` is streamed.
    As `98.4` fails the filter, it is removed from the stream. Next, `100.2` is streamed;
    it passes the filter and Java sets the count to 1\. The next value `87.9`, is
    then streamed but it fails the filter. Lastly, `102.8` is streamed, which also
    passes the filter, thereby increasing the count to 2\. Therefore, the count of
    temperatures that are `> 100` is 2 (`100.2` and `102.8`). Notice the order in
    which the values come out of the stream is demonstrating stream laziness.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论一下流处理过程是如何工作的。首先，`98.4`被流处理。由于`98.4`没有通过过滤器，它被从流中移除。接下来，`100.2`被流处理；它通过了过滤器，Java将计数设置为1。然后，下一个值`87.9`被流处理，但它没有通过过滤器。最后，`102.8`被流处理，它也通过了过滤器，因此计数增加到2。因此，大于`100`的温度计数是2（`100.2`和`102.8`）。注意值从流中出来的顺序展示了流的惰性。
- en: We will discuss the various operations from this example in due course. For
    the moment, we would like to cover stream laziness in more detail.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在适当的时候讨论这个例子中的各种操作。目前，我们想更详细地介绍流惰性。
- en: Exploring stream laziness
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索流惰性
- en: The principle of lazy evaluation is that you get what you need, only when you
    need it. For example, if shopping websites such as Amazon were to display 10,000
    records to a user, the principle of lazy evaluation would be to retrieve the first
    50 and while the user is viewing these, retrieve the next 50 in the background.
    An eager evaluation would be to retrieve all 10,000 records in one go. With regards
    to streams, this means that nothing happens until the terminal operation gets
    called.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 惰性求值的原则是，你只在你需要的时候得到你需要的东西。例如，如果像亚马逊这样的购物网站要向用户显示10,000条记录，那么惰性求值的原则就是先检索前50条，当用户查看这些记录时，在后台检索下一条50条。急切求值就是一次性检索所有10,000条记录。对于流来说，这意味着直到终端操作被调用之前，不会发生任何事情。
- en: 'The pipeline specifies what operations we want performed on the source and
    in what order. As nothing happens until the terminal operation runs, Java is aware
    of the full pipeline. This enables Java to introduce efficiencies whenever possible.
    For example, why run an operation on a piece of data if that operation is not
    required? This could arise in the following situations:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 管道指定了我们想要在源上执行的操作以及它们的顺序。由于直到终端操作运行之前不会发生任何事情，Java知道整个管道。这使得Java能够在可能的情况下引入效率。例如，为什么要在不需要操作的数据上运行操作呢？这可能会出现在以下情况下：
- en: We have already found the data item we are looking for
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们已经找到了我们正在寻找的数据项
- en: We may have a limit set of the number of elements (as in the pencils analogy)
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可能设置了一个元素数量的限制（就像铅笔的类比一样）
- en: 'Let’s examine an example where the order of processing elements from the source
    demonstrates lazy evaluation. *Figure 15**.2* (`Laziness.java`) shows this:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考察一个示例，其中处理源中元素顺序展示了惰性求值。*图15*.*2*（`Laziness.java`）展示了这一点：
- en: '![Figure 15.2 – Lazy evaluation – stream pipeline example](img/B19793_15_02.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![图15.2 – 惰性求值 – 流管道示例](img/B19793_15_02.jpg)'
- en: Figure 15.2 – Lazy evaluation – stream pipeline example
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.2 – 惰性求值 – 流管道示例
- en: 'The algorithm in this figure obtains the first name that begins with ''B''
    or ''C'' that is longer than 3 characters. In this example, we initially create
    a `List<String>` called `names`:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图中的算法获取以'B'或'C'开头且长度超过3个字符的第一个名字。在这个例子中，我们最初创建了一个名为`names`的`List<String>`：
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As Java does not do any streaming until the terminal operation is encountered;
    nothing happens in this example until the `forEach(Consumer)` operation (line
    31). This means that the code `names.stream()` at the start, is merely creating
    an object that knows where to go for the data when the streaming starts.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Java在遇到终端操作之前不会进行任何流操作；在这个例子中，直到`forEach(Consumer)`操作（第31行）发生之前，没有任何事情发生。这意味着在开始时，`names.stream()`代码仅仅创建了一个对象，当流开始时，这个对象知道数据在哪里。
- en: 'The first thing we do in this pipeline is output the current string, representing
    the person’s name using the `peek(Consumer)` intermediate operation:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个管道中，我们首先使用`peek(Consumer)`中间操作输出当前字符串，该字符串代表使用的人名：
- en: '[PRE8]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Next, we use the `filter(Predicate)` intermediate operation to filter in names
    that begin with “B” or “C.”:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用`filter(Predicate)`中间操作来过滤出以“B”或“C”开头的名字：
- en: '[PRE9]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Immediately following that, we filter in names that are longer than three characters:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 紧接着，我们过滤出长度超过三个字符的名字：
- en: '[PRE10]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'After that, we use the `limit(long)` intermediate operation to keep track of
    how many names have passed the second filter:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们使用`limit(long)`中间操作来跟踪通过第二个过滤器的名字数量：
- en: '[PRE11]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In this example, once one name passes by, the JVM is informed and no other
    name will be streamed from the source. Lastly, we provide the (required) terminal
    operation:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，一旦一个名字通过，JVM就会得到通知，并且不会从源中流式传输其他名字。最后，我们提供（必需的）终端操作：
- en: '[PRE12]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '*Figure 15**.3* shows the output from the code in *Figure 15**.2*, which is
    very revealing:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '*图15**.3* 展示了来自 *图15**.2* 代码的输出，这非常具有启发性：'
- en: '![Figure 15.3 – Output from Figure 15.2 (with comments on the right)](img/B19793_15_03.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![图15.3 – 图15.2的输出（右侧有注释）](img/B19793_15_03.jpg)'
- en: Figure 15.3 – Output from Figure 15.2 (with comments on the right)
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.3 – 图15.2的输出（右侧有注释）
- en: Line 35 shows the first name, `April`, being streamed from the list. `April`
    makes it to the first filter and is removed (as `April` does not start with “B”
    or “C”).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 第35行显示了第一个名字，`April`，从列表中流式传输。`April`通过了第一个过滤器并被移除（因为`April`不以“B”或“C”开头）。
- en: Line 37 shows the next name, `Ben`, being streamed. `Ben` passes the first filter
    and makes it to the second filter. However, as the length of `Ben` is only 3 characters,
    it is removed by the second filter.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 第37行显示了下一个名字，`Ben`，正在流式传输。`Ben`通过了第一个过滤器并到达第二个过滤器。然而，由于`Ben`的长度只有3个字符，它被第二个过滤器移除。
- en: Line 40 shows the next name, `Charlie`, being streamed. `Charlie` passes the
    first filter (as `Charlie` begins with “C”) and is passed to the second filter.
    `Charlie` also passes this filter as the length of `Charlie` is > 3 characters
    long. So, `Charlie` is passed to the `limit(long)` intermediate operation, which
    notes that this is the first name passing by. As the limit is set to 1, the JVM
    is informed. `Charlie` is processed by the `forEach(Consumer)` terminal operation
    printing out `Charlie` (line 43) and the stream is shut down.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 第40行显示了下一个名字，`Charlie`，正在流式传输。`Charlie`通过了第一个过滤器（因为`Charlie`以“C”开头）并被传递到第二个过滤器。`Charlie`也通过了这个过滤器，因为`Charlie`的长度大于3个字符。因此，`Charlie`被传递到`limit(long)`中间操作，该操作指出这是第一个通过的名字。由于限制设置为1，JVM被通知。`Charlie`通过`forEach(Consumer)`终端操作打印出`Charlie`（第43行），并且流被关闭。
- en: Note that none of the other names – `David`, `Benildus`, or `Christian` – are
    streamed at all. This is a small example but you can imagine the efficiencies
    of scale when you are dealing with millions of data items.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，其他名字 – `David`、`Benildus`或`Christian` – 都没有进行流式传输。这是一个小例子，但你可以想象当你处理数百万数据项时的效率。
- en: We will now move on to discussing how to create streams.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将讨论如何创建流。
- en: Creating streams
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建流
- en: Streams, both finite and infinite, can be generated from various sources. For
    example, sources such as arrays, collections, `varargs`, and files can be used.
    Let’s examine these in turn. For the moment, we will deal with non-primitive types;
    all the streams will be serial (non-parallel). Both primitive and parallel streams
    will be discussed in [*Chapter 16*](B19793_16.xhtml#_idTextAnchor401).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 流可以从各种来源生成，无论是有限的还是无限的。例如，可以使用数组、集合、`varargs`和文件等作为来源。我们将依次检查这些来源。目前，我们将处理非原始类型；所有流都将串行（非并行）。在第[*第16章*](B19793_16.xhtml#_idTextAnchor401)中，我们将讨论原始流和并行流。
- en: Streaming from an array
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从数组中流式传输
- en: 'We will use `Stream<T> Arrays.stream(T[] array)` for this. This `static` method
    accepts an array of type `T` and returns `Stream<T>`. *Figure 15**.4* (`CreatingStreams.java`)
    presents an example:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`Stream<T> Arrays.stream(T[] array)`来完成这个操作。这个`static`方法接受一个类型为`T`的数组，并返回`Stream<T>`。*图15**.4*
    (`CreatingStreams.java`) 展示了一个示例：
- en: '![Figure 15.4 – Streaming an array](img/B19793_15_04.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![图15.4 – 流式传输数组](img/B19793_15_04.jpg)'
- en: Figure 15.4 – Streaming an array
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.4 – 流式传输数组
- en: In this figure, we declare a `Double` array (note that this is not a primitive
    `double` array). The stream object is created using the `Arrays.stream(T[] array)`
    method call. We start the stream off using the terminal operation `count()`. Lastly,
    we output the number of elements in the array. Note that this is just an example
    and that there is a more straightforward way (using the `length` property) of
    outputting the number of elements in an array.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图中，我们声明了一个`Double`数组（注意这不是一个原始的`double`数组）。流对象是通过调用`Arrays.stream(T[] array)`方法创建的。我们使用终端操作`count()`开始流。最后，我们输出数组中的元素数量。请注意，这只是一个示例，而且有更直接的方法（使用`length`属性）来输出数组中的元素数量。
- en: Let’s examine how we stream from a collection.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何从集合中流式传输。
- en: Streaming from a collection
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 流式传输集合
- en: 'By *collection*, we mean the `Collection` interface hierarchy. The `Collection`
    interface has a `default Stream<E> stream()` method. *Figure 15**.5* (`CreatingStreams.java`)
    presents code that generates a stream from a collection:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 通过“集合”，我们指的是`Collection`接口层次结构。`Collection`接口有一个`default Stream<E> stream()`方法。*图15.5*
    (`CreatingStreams.java`)展示了从集合生成流的代码：
- en: '![Figure 15.5 – Streaming a collection](img/B19793_15_05.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![图15.5 – 流式传输集合](img/B19793_15_05.jpg)'
- en: Figure 15.5 – Streaming a collection
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.5 – 流式传输集合
- en: 'In this figure, we initially create a `List<String>` using `Arrays.asList(T…
    a)`:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图中，我们最初使用`Arrays.asList(T… a)`创建了一个`List<String>`：
- en: '[PRE13]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We then use the `Collection` `stream()` method to create the stream object:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用`Collection`的`stream()`方法创建流对象：
- en: '[PRE14]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'To start the stream off, we use the terminal `count()` operation:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始流，我们使用终端操作`count()`：
- en: '[PRE15]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'What if you had a *Map* and wanted to stream it? Remember that `Map` is not
    a `Collection` as it does not implement it. This is what the second example shows.
    Firstly, let us declare and populate the map:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有`Map`并想流式传输它怎么办？记住，`Map`不是一个`Collection`，因为它没有实现它。这就是第二个示例所展示的。首先，让我们声明并填充这个映射：
- en: '[PRE16]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'To bridge across from a `Map` to a `Collection` we will do the following:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 要从`Map`转换到`Collection`，我们将执行以下操作：
- en: '[PRE17]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `entrySet()` method in `Map` returns a `Set` view of the entries in the
    map. As `Set` is a sub-interface of `Collection`, `Set` “is-a” `Collection`. At
    this point, we can now stream the collection as normal:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`Map`中的`entrySet()`方法返回映射中条目的`Set`视图。由于`Set`是`Collection`的子接口，`Set`“是”`Collection`。在这个点上，我们现在可以像平常一样流式传输集合：'
- en: '[PRE18]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Finally, we start off the process using the terminal operation, `count()`, which
    returns `3`, showing that the stream worked.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用终端操作`count()`开始过程，它返回`3`，表明流已成功工作。
- en: Now, let’s look at the `Stream.of()` method.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看`Stream.of()`方法。
- en: Stream.of()
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Stream.of()
- en: '`static <T> Stream<T> of(T… values)` is a very useful method. While its signature
    can seem a little confusing, it is very straightforward to use. It is a `static`
    method that is generically typed, hence `<T>`. Thus, the compiler does not complain
    about the use of `T` in the signature. It returns `Stream<T>` and `T` depends
    on what is passed in. For example, if you pass in strings, then you get back `Stream<String>`.
    The parameters are a `varargs` list, which is very flexible.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`static <T> Stream<T> of(T… values)`是一个非常有用的方法。虽然它的签名可能看起来有点令人困惑，但它非常容易使用。这是一个`static`方法，它具有泛型类型，因此是`<T>`。因此，编译器不会对签名中`T`的使用提出异议。它返回`Stream<T>`，而`T`取决于传入的内容。例如，如果你传入字符串，那么你将得到`Stream<String>`。参数是一个`varargs`列表，它非常灵活。'
- en: 'Let’s look at some examples. *Figure 15**.6* (BuildStreams.java) presents the
    code:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些示例。*图15.6* (`BuildStreams.java`)展示了代码：
- en: '![Figure 15.6 – Stream.of() examples](img/B19793_15_06.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![图15.6 – Stream.of()示例](img/B19793_15_06.jpg)'
- en: Figure 15.6 – Stream.of() examples
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.6 – Stream.of()示例
- en: 'In this figure, we initially declare an array of strings:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图中，我们最初声明了一个字符串数组：
- en: '[PRE19]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Using the `Stream.of()` method, we declare the stream source to be the array:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Stream.of()`方法，我们声明流源为数组：
- en: '[PRE20]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Once declared, we start the stream using the `count()` terminal operation:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 声明后，我们使用`count()`终端操作开始流：
- en: '[PRE21]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Next, `Stream.of()` sources the stream from a `varargs` of integers passed
    in (boxed as `Integer`s):'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`Stream.of()`从传入的整数`varargs`（作为`Integer`装箱）中获取流源：
- en: '[PRE22]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We start the streaming process as before, using the `count()` terminal operation:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们像以前一样开始流式传输过程，使用`count()`终端操作：
- en: '[PRE23]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Following that, `Stream.of()` sources the stream from a `varargs` of strings
    and stream them:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，`Stream.of()`从字符串的`varargs`中获取流源并将它们流式传输：
- en: '[PRE24]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Lastly, we source the stream from a `varargs` of `Dog` (just one), and stream
    them:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们从`Dog`的`varargs`（只有一个）中获取流源并将它们流式传输：
- en: '[PRE25]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Now, let’s examine how to stream from a file.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何从文件中流式传输数据。
- en: Streaming from a file
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从文件流式传输
- en: To stream a file, we can use the `Files.lines()` method. Its signature is `public
    static Stream<String> lines(Path path)` `throws IOException`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 要流式传输文件，我们可以使用 `Files.lines()` 方法。它的签名是 `public static Stream<String> lines(Path
    path)` `throws IOException`。
- en: 'The `Path` parameter refers to the file we want to process. This file needs
    to be delimited; for example, using the forward slash (`/`) character. The file
    we will use contains the following lines:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`Path` 参数指的是我们想要处理的文件。这个文件需要被分隔；例如，使用正斜杠（`/`）字符。我们将使用的文件包含以下行：'
- en: '[PRE26]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The returned `Stream<String>` refers to the lines from the file, one `String`
    for each line in the file. We can process the returned stream using the `forEach(Consumer)`
    terminal operation defined in the `Stream` interface. Inside the consumer block
    of code, each line from the file (a `String`) could be parsed into `String[]`
    using the `split()` method from the `String` class – where we pass in the delimiter
    and get back a `String[]` of the elements. Once we have this `String[]`, we can
    easily create our object and add it to a collection, such as `ArrayList`. This
    is an example of a `Consumer` side effect.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的 `Stream<String>` 指的是文件的行，每行一个 `String`。我们可以使用在 `Stream` 接口中定义的 `forEach(Consumer)`
    终端操作来处理返回的流。在消费者代码块内部，每行文件（一个 `String`）可以使用 `String` 类的 `split()` 方法解析为 `String[]`
    – 其中我们传递分隔符并返回一个包含元素的 `String[]`。一旦我们有了这个 `String[]`，我们就可以轻松地创建我们的对象并将其添加到集合中，例如
    `ArrayList`。这是一个 `Consumer` 副作用示例。
- en: 'Assuming a `Cat` class with `name` and `color` instance variables and an associated
    constructor (ProcessFile.java), we could do the following:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 假设有一个 `Cat` 类，它有 `name` 和 `color` 实例变量以及一个相关构造函数（ProcessFile.java），我们可以做以下操作：
- en: '[PRE27]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: forEach(Consumer) versus forEach(Consumer)
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`forEach(Consumer)` 与 `forEach(Consumer)`'
- en: In the Java API, these two versions of `forEach()` look very similar but they
    are in fact from two very different hierarchies. One is a `default` method in
    the `Iterable` interface (which `Collection` inherits). The other is a terminal
    operation in the `Stream` interface.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java API中，这两个版本的 `forEach()` 看起来非常相似，但实际上它们来自两个非常不同的层次结构。一个是 `Iterable` 接口（`Collection`
    继承自它）中的 `default` 方法。另一个是 `Stream` 接口中的终端操作。
- en: Infinite streams
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 无限流
- en: Infinite streams can easily be created using two `static` methods from the `Stream`
    interface, namely `generate()` and `iterate()`. Let’s examine these in turn.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 无限流可以很容易地使用 `Stream` 接口中的两个 `static` 方法创建，即 `generate()` 和 `iterate()`。让我们逐一考察它们。
- en: Stream<T> generate(Supplier<T> s)
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Stream<T> generate(Supplier<T> s)
- en: 'As per the API, it “returns an infinite, sequential unordered stream where
    each element is generated by the provided `Supplier`.” *Figure 15**.7* (`InfiniteStreamsGenerate.java`)
    presents some code that we can discuss:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 根据API，它“返回一个无限、顺序的无序流，其中每个元素都是由提供的 `Supplier` 生成的。”*图15.7* (`InfiniteStreamsGenerate.java`)
    展示了一些我们可以讨论的代码：
- en: '![Figure 15.7 – Creating an infinite stream using generate()](img/B19793_15_07.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![图15.7 – 使用 generate() 创建无限流](img/B19793_15_07.jpg)'
- en: Figure 15.7 – Creating an infinite stream using generate()
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.7 – 使用 generate() 创建无限流
- en: 'As this figure shows, the `Supplier` provided produces random numbers between
    0 and 9 inclusive:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如此图所示，提供的 `Supplier` 生成介于0和9（包括0和9）之间的随机数：
- en: '[PRE28]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We start the streaming process using the `forEach(Consumer)` terminal operation:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `forEach(Consumer)` 终端操作开始流处理过程：
- en: '[PRE29]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '`Consumer` accepts a method reference to output the numbers generated. This
    stream will keep going until we terminate the application (for example, from within
    the IDE).'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`Consumer` 接受一个方法引用以输出生成的数字。此流将持续进行，直到我们终止应用程序（例如，从IDE内部）。'
- en: Math.random()
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: Math.random()
- en: Recall that `Math.random()` returns a `double` type between `0.0 <= x < 1.0`.
    In other words, a number between `0` and less than `1`. When we multiply this
    number by `10` and subsequently cast that number to an `int` type, we are, in
    effect, scaling it to `0 <= x <` `10`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，`Math.random()` 返回一个介于 `0.0 <= x < 1.0` 的 `double` 类型。换句话说，一个介于 `0` 和小于
    `1` 之间的数字。当我们把这个数字乘以 `10`，然后将其转换为 `int` 类型时，实际上是将它缩放到 `0 <= x <` `10`。
- en: Now, let’s discuss the other method for generating infinite streams, namely
    `iterate()`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们讨论生成无限流的另一种方法，即 `iterate()`。
- en: Stream<T> iterate(T seed, UnaryOperator<T> fn)
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Stream<T> iterate(T seed, UnaryOperator<T> fn)
- en: 'This method gives you more control over the numbers generated. The first argument
    is the seed, which is the first number in the stream. The second parameter is
    a `UnaryOperator` (a `Function` where the input and output are the same type).
    This `UnaryOperator` function is a lambda that accepts the previous value and
    generates the next value. *Figure 15**.8* (`InfiniteStreamsIterate.java`) presents
    a code example for us to discuss this further:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法让你对生成的数字有更多的控制。第一个参数是种子，它是流中的第一个数字。第二个参数是一个`UnaryOperator`（一个输入和输出类型相同的`Function`）。这个`UnaryOperator`函数是一个lambda表达式，它接受前一个值并生成下一个值。*图15**.8*
    (`InfiniteStreamsIterate.java`)展示了我们进一步讨论这个问题的代码示例：
- en: '![ Figure 15.8 – Creating an infinite stream using iterate()](img/B19793_15_08.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![图15.8 – 使用iterate()创建无限流](img/B19793_15_08.jpg)'
- en: Figure 15.8 – Creating an infinite stream using iterate()
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.8 – 使用iterate()创建无限流
- en: As this figure shows, the seed is `2` and the lambda expression generates the
    next even number after `2` and so forth. Thus, this stream generates `2`, `4`,
    `6`, `8`, and so on, until we kill the application.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如此图所示，种子是`2`，lambda表达式生成`2`之后的下一个偶数，依此类推。因此，这个流生成`2`、`4`、`6`、`8`，等等，直到我们终止应用程序。
- en: 'What if we wanted only so many numbers? For example, what if we wanted only
    the even numbers up to `20` (starting at `2`)? There is an overloaded version
    of `iterate()` that caters to this – its second parameter is a `Predicate`, which
    states when to finish. *Figure 15**.9* (`InfiniteStreamsIterate.java`) presents
    an example:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只想得到这么多的数字呢？例如，如果我们只想得到`20`（从`2`开始）以内的偶数呢？`iterate()`有一个重载版本可以满足这个需求——它的第二个参数是一个`Predicate`，它指定何时结束。*图15**.9*
    (`InfiniteStreamsIterate.java`)展示了这个示例：
- en: '![ Figure 15.9 – Creating an infinite/finite stream using iterate() and Predicate](img/B19793_15_09.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![图15.9 – 使用iterate()和Predicate创建无限/有限流](img/B19793_15_09.jpg)'
- en: Figure 15.9 – Creating an infinite/finite stream using iterate() and Predicate
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.9 – 使用iterate()和Predicate创建无限/有限流
- en: 'The `Predicate` condition:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`Predicate`条件：'
- en: '[PRE30]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: is the important line here. that specifies when this stream stops. Thus, this
    is one way of creating a finite stream from an infinite stream. If the `Predicate`
    condition keeps returning `true`, the stream will keep generating numbers until
    you kill the application.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行在这里很重要，它指定了流何时停止。因此，这是从无限流创建有限流的一种方法。如果`Predicate`条件持续返回`true`，流将不断生成数字，直到你终止应用程序。
- en: In this figure, `2`, `4`, `6`, `8`, `10`, `12`, `14`, `16`, `18`, and `20` all
    pass the `Predicate` condition and are output. Once `22` is generated and the
    `Predicate` fails, the stream stops.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图中，`2`、`4`、`6`、`8`、`10`、`12`、`14`、`16`、`18`和`20`都通过了`Predicate`条件并被输出。一旦生成`22`并且`Predicate`失败，流就会停止。
- en: 'Another way of turning an infinite stream into a finite stream is to use the
    `limit()` intermediate operation. *Figure 15**.10* (`InfiniteStreamsIterate.java`)
    presents this scenario:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 将无限流转换为有限流的另一种方法是使用`limit()`中间操作。*图15**.10* (`InfiniteStreamsIterate.java`)展示了这种情况：
- en: '![ Figure 15.10 – Creating a finite stream using limit()](img/B19793_15_10.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![图15.10 – 使用limit()创建有限流](img/B19793_15_10.jpg)'
- en: Figure 15.10 – Creating a finite stream using limit()
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.10 – 使用limit()创建有限流
- en: In this figure, we restricted the numbers generated to 10 by using the `limit()`
    intermediate operation. We will discuss intermediate operations in [*Chapter 16*](B19793_16.xhtml#_idTextAnchor401).
    In this example, once the 10th number has passed by, `limit()` informs the JVM
    of this fact, and no further numbers are generated.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图中，我们通过使用`limit()`中间操作将生成的数字限制为10。我们将在[*第16章*](B19793_16.xhtml#_idTextAnchor401)中讨论中间操作。在这个例子中，一旦第10个数字通过，`limit()`就会通知JVM这一事实，并且不再生成更多的数字。
- en: Now that we know how to create streams, let’s examine terminal operations.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道了如何创建流，让我们来检查终端操作。
- en: Mastering terminal operations
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 掌握终端操作
- en: As we discussed earlier, no streaming happens until the terminal operation executes.
    This gives the JVM an overall picture of the stream pipeline, thereby enabling
    efficiencies to be introduced in the background.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前讨论的，直到终端操作执行之前不会发生流操作。这给了JVM一个流管道的整体视图，从而使得在后台引入效率成为可能。
- en: A terminal operation can be performed without any intermediate operation but
    not the other way around. *Reductions* are a special type of terminal operation
    where all of the contents of the stream are combined into a single primitive or
    *Object* (for example, a *Collection*).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 终端操作可以在没有任何中间操作的情况下执行，但不能反过来。*归约*是终端操作的一种特殊类型，其中流的所有内容都被组合成一个单一的原语或*Object*（例如，一个*Collection*）。
- en: '*Table 15.1* represents the terminal operations we will be discussing in this
    section:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '*表15.1* 代表我们将在本节中讨论的终端操作：'
- en: '![Table 15.1 – Terminal operations](img/B19793_15_Table_01.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![表15.1 – 终端操作](img/B19793_15_Table_01.jpg)'
- en: Table 15.1 – Terminal operations
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 表15.1 – 终端操作
- en: Before we discuss them in turn, a brief discussion regarding the table. Remember,
    a reduction must look at all elements in the stream and then return a primitive
    or `Object`.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们依次讨论它们之前，先简要讨论一下表格。记住，归约必须查看流中的所有元素，然后返回一个原始类型或`Object`。
- en: 'Some of these terminal operations, such as `allMatch(Predicate)`, may not look
    at all of the elements in the stream. For example, let’s say we had the following
    code:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 一些终端操作，如`allMatch(Predicate)`，可能不会查看流中的所有元素。例如，假设我们有以下代码：
- en: '[PRE31]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The `Predicate` condition fails on `"Brian"`, as it does not start with `"A"`,
    and `allMatch()` returns `false`. Therefore, `"Colin"` is never examined and hence,
    `allMatch()` is not a reduction.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`Predicate`条件在`"Brian"`上失败，因为它不以`"A"`开头，因此`allMatch()`返回`false`。因此，`"Colin"`永远不会被检查，因此`allMatch()`不是归约操作。'
- en: We will discuss `Optional`s later but for the moment, `Optional`s were introduced
    in Java 8 to replace `null` return values (and thereby help to reduce the number
    of `NullPointerException`s). If the stream is empty, an empty `Optional` is returned
    (and not `null`). Therefore, an `Optional` object either has a non-`null` value
    or is empty. One way of ending up with an empty stream is by filtering out all
    of its elements before calling the terminal operation.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在稍后讨论`Optional`，但到目前为止，`Optional`是在Java 8中引入的，以替换`null`返回值（从而有助于减少`NullPointerException`的数量）。如果流为空，则返回一个空的`Optional`（而不是`null`）。因此，`Optional`对象要么具有非`null`值，要么为空。导致空流的一种方式是在调用终端操作之前过滤掉其所有元素。
- en: Let’s deal with the operations in turn.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们依次处理这些操作。
- en: count()
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: count()
- en: 'We have already encountered `count()`, so a quick example has been provided
    in *Figure* *15**.11* (`TerminalOperations.java`):'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经遇到了`count()`，因此已经在*图* *15**.11* (`TerminalOperations.java`)中提供了一个快速示例：
- en: '![Figure 15.11 –  count() in code](img/B19793_15_11.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![图15.11 – 代码中的count()](img/B19793_15_11.jpg)'
- en: Figure 15.11 – count() in code
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.11 – 代码中的count()
- en: The `count()` method works with finite streams as it will never terminate for
    an infinite stream. In this example, the two strings, `"dog"` and `"cat"`, are
    streamed and a count of `2` is returned. Note that `count()` is a reduction as
    it looks at each element in the stream and returns a single value.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`count()`方法与有限流一起工作，因为它永远不会为无限流终止。在这个例子中，两个字符串`"dog"`和`"cat"`被流式传输，并返回计数`2`。请注意，`count()`是一个归约操作，因为它查看流中的每个元素，并返回一个单一值。'
- en: min() and max()
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: min()和max()
- en: Like `count()`, both `min()` and `max()` work with finite streams and hang on
    infinite streams (in case another value might be the minimum or maximum value).
    Both are reductions as they return a single value after processing the whole stream.
    Given that the stream could be empty, *Optional* is the return type.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 与`count()`一样，`min()`和`max()`都与有限流一起工作，并挂起无限流（以防可能还有其他值是最小值或最大值）。两者都是归约操作，因为它们在处理整个流之后返回一个单一值。鉴于流可能为空，*Optional*是返回类型。
- en: '*Figure 15**.12* (TerminalOperations.java) presents some code using `min()`
    and `max()`:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '*图* *15**.12* (TerminalOperations.java)展示了使用`min()`和`max()`的一些代码：'
- en: '![Figure 15.12 – min() and max() in code](img/B19793_15_12.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![图15.12 – 代码中的min()和max()](img/B19793_15_12.jpg)'
- en: Figure 15.12 – min() and max() in code
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.12 – 代码中的min()和max()
- en: 'In this example, we initially define a custom `Comparator` that sorts the list
    of strings into ascending length-of-string order. This `Comparator` is then passed
    into the `min()` method, where `"pig"` is returned to `Optional`:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们最初定义了一个自定义的`Comparator`，该`Comparator`将字符串列表按字符串长度升序排序。然后，这个`Comparator`被传递到`min()`方法中，其中`"pig"`被返回到`Optional`：
- en: '[PRE32]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We then use the functional-style `Optional` method, `ifPresent()`, to determine
    if there is a non-`null` value in `Optional`. As `"pig"` is there (present)),
    it is output:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后使用函数式风格的`Optional`方法`ifPresent()`，以确定`Optional`中是否存在非`null`值。由于`"pig"`存在（存在），因此输出如下：
- en: '[PRE33]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Next up is a different custom `Comparator` that sorts the list of numbers into
    ascending numeric order. This is then passed into the `max()` method, where `12`
    is stored in the `Optional` variable `max`:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Again, we use the `ifPresent()` method to determine if there is a non-`null`
    value in `max`. As `12` is present, it is output:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Lastly, we demonstrate that you can use `Stream.empty()` to create an empty
    stream:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'In this example, as the stream is empty, the comparator `(x1, x2) -> 0` is
    never called and as a result, there is no value in `Optional`. Thus, `isEmpty()`
    returns true and `isPresent()` returns false:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: findAny() and findFirst()
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: These terminal operations are not reductions as they do not process the entire
    stream. As its name suggests, `findAny()` will return any element – typically,
    the first one is returned but this is not guaranteed. On the other hand, `findFirst()`
    does just that – it returns the first element. Not surprisingly, these methods
    can work with infinite streams (as they don’t process all of the stream). An *Optional*
    is returned in both cases (as the stream may be empty when they are called).
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: A *short-circuiting* terminal operation is defined as an operation that, when
    presented with infinite input, may terminate in finite time. Given that these
    operations can return before processing all of the stream, they are considered
    short-circuiting.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 15**.13* (TerminalOperationsFindAnyFindFirst.java) presents their use
    in code:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.13 – findAny() and findFirst() in code](img/B19793_15_13.jpg)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
- en: Figure 15.13 – findAny() and findFirst() in code
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: In this figure, we execute `findAny()` on the stream of strings `"John"` and
    `"Paul"`. This returns `"John"` usually but is not guaranteed; whereas when we
    execute `findFirst()` on the same stream, `"John"` is returned all the time. As
    this example demonstrates, neither operation processes `"Paul"` and therefore
    they are not considered reductions.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: anyMatch(), allMatch, and noneMatch()
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'These three terminal operations all accept a `Predicate` condition and return
    a `boolean` value. Like the `"find"` methods, they are not reductions either as
    they may not look at *all* of the elements. Depending on the data, these operations
    may or may not terminate when presented with infinite streams. That said, they
    are considered short-circuiting as they may terminate. *Figure 15**.14* (`TerminalOperations.java`)
    presents an example:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.14 – anyMatch(), allMatch(), and noneMatch() in code](img/B19793_15_14.jpg)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
- en: Figure 15.14 – anyMatch(), allMatch(), and noneMatch() in code
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: 'In this figure, we define a finite stream of `String` names as follows:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'A predicate is defined to see if a name begins with `"A"`:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We then stream the (source) list of names and check, using `anyMatch()`, if
    any of the names begin with `"A"` – as `"Alan"` does, `true` is returned:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Next, we re-stream the list and check, using `allMatch()`, if all of the names
    begin with `"A"` – as `"Brian"` does not, `false` is returned:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We then re-stream the list and check, using `noneMatch()`, if none of the names
    begin with `"A"` – as `"Alan"` does, `false` is returned:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Notice that we have to re-stream the source twice (for `allMatch()` and `noneMatch()`).
    This is because, once a terminal operation is performed, a stream is considered
    consumed and can no longer be used. If you need the same data, then you must return
    to the source and get a new stream. This is what we have done here. Attempting
    an operation on a closed source generates an `IllegalStateException` error.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s delve a little deeper into the short-circuiting nature of these operations
    when presented with infinite data. The following example (*Figure 15**.15*) presents
    code (`TerminalOperations.java`) where each of these operations, given an infinite
    stream, may or may not terminate. Whether they terminate or not is determined
    by the data (and the predicate being tested against that data):'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.15 – Short-circuiting nature of anyMatch(), allMatch(), and noneMatch()
    in code](img/B19793_15_15.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
- en: Figure 15.15 – Short-circuiting nature of anyMatch(), allMatch(), and noneMatch()
    in code
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: In this figure, we generated an infinite stream of `"abc"` strings and defined
    two predicates; one checks if the string begins with `"a"` and the other checks
    if the string begins with `"b"`. Note that, as explained previously, a closed
    stream must be reopened before being used. Therefore, lines 137-144 are *mutually
    exclusive* – you can only use one of them at a time. We have left them all uncommented
    as this aids the clarity of the diagram. When we run the code, we must comment
    out five of the six lines.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '`infStr.anyMatch(startsWithA)` checks if any of the strings start with `"a"`
    – as the first one does, it short-circuits with `true`.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '`infStr.anyMatch(startsWithB)` checks if any of the strings start with `"b"`
    – the first one does not, so it checks the next one; it does not either, and so
    on. We had to kill the program in this instance.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '`infStr.noneMatch(startsWithA)` checks if none of the strings start with `"a"`
    – as `"abc"` begins with `"a"`, `noneMatch()` short-circuits with `false`.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '`infStr.noneMatch(startsWithB)` checks if none of the strings start with `"b"`
    – the first one does not, so it checks the next one; it does not either, and so
    on. This goes on forever, so we had to kill the program. So, when does `noneMatch()`
    return `true`? If you have a finite stream where none of the elements match the
    given predicate.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '`infStr.allMatch(startsWithA)` checks if all the strings begin with `"a"`.
    In this instance, this will go on forever as we keep generating strings that do
    begin with `"a"`, ensuring `allMatch()` needs to check the next one and so on.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '`infStr.allMatch(startsWithB)` can short-circuit as `"abc"` does not begin
    with `"b"`, enabling `allMatch()` to return `false`.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: forEach()
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As `forEach(Consumer)` has no return value (returns `void`), it is not considered
    a reduction. As it returns nothing, any changes you wish to make must occur inside
    `Consumer` as side effects. We covered several examples of `forEach()` already,
    so *Figure 15**.16* (TerminalOperations.java) shows just a simple one:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.16 – The forEach() terminal operation in code](img/B19793_15_16.jpg)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
- en: Figure 15.16 – The forEach() terminal operation in code
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we are streaming a list of *strings*, representing peoples’
    names and echoing them to the screen.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: reduce()
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `reduce()` method combines a stream into a single object. As it processes
    all the elements, it is a reduction. There are three overloaded versions. We will
    discuss them in turn with examples.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: T reduce(T identity, BinaryOperator<T> accumulator)
  id: totrans-245
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is the most common way of doing a reduction – start with an initial value
    (identity) and keep merging it with the next value. As well as the identity being
    the initial value, it is also the value returned if the stream is empty. This
    means that there will always be a result and thus `Optional` is not the return
    type (in this version).
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: The accumulator combines the current result with the current value in the stream.
    As it is a `BinaryOperator`, this means it is a function where the two inputs
    and the return type are all the same type.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 15**.17* (`TerminalOperations.java`) presents some examples to help
    explain this:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.17 – T reduce(T identity, BinaryOperator<T> acc) in code](img/B19793_15_17.jpg)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
- en: Figure 15.17 – T reduce(T identity, BinaryOperator<T> acc) in code
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us examine the first reduction in this figure:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This reduction defines the empty string as the identity. This is both the string
    we start with and the string returned if the stream is empty. The accumulator
    takes in two strings, namely, `s1` and `s2`. The first time round, `s1` is `""`
    and `s2` is `"s"`, resulting in `"s"`. The next time round, `s1` is the result
    from the previous run, which is `"s"`, and `s2` is `"e"`, resulting in `"se"`.
    After that, `s1` is `"se"` and `s2` is `"a"`, resulting in `"sea"`. Finally, `s1`
    is `"sea"` and `s2` is `"n"`, resulting in `"sean"`. That’s how accumulators work.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: 'The second reduction starts by re-streaming the source:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: However, a filter intermediate operation is applied. This filter ensures only
    strings with a length of `> 2` are kept, resulting in an empty stream for `reduce()`.
    Thus, `reduce()` returns the `"``nothing"` identity.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: 'The last reduction gives another example of an identity and an accumulator
    in action:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The sequence of values is `n1` is `1`, `n2` is `2`, and the result is `2`; `n1`
    is `2`, `n2` is `3`, and the result is `6`; `n1` is `6`, `n2` is `4` and the result
    is `24`.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: Optional<T> reduce(BinaryOperator<T> accumulator)
  id: totrans-260
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This is very similar to the first version except that no identity is provided.
    As no identity is provided, `Optional` is the return type (given that, the stream
    may be empty before this method is called). There are three possible returns:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: An empty stream – results in an empty `Optional`
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: One element in the stream – that element is returned (in `Optional`)
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Multiple elements in the stream – the accumulator is applied
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why are there two versions that are so similar? Why not just have the first
    version, with its identity? Well, there may be a situation, however unlikely,
    that the accumulator returns with the same value as the identity. In that scenario,
    you would not know whether the stream was empty (identity returned) or not (accumulator
    applied). This second version, with its use of `Optional`, ensures that you know
    when the stream is empty.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s examine the third version of `reduce()`.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: <U> reduce(U identity, BiFunction accumulator, BinaryOperator combiner)
  id: totrans-267
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This version is used when we are dealing with different types where intermediate
    reductions are created that are combined at the end. This version is useful in
    parallel streams as the stream can be decomposed and reassembled by different
    threads. *Figure 15**.18* (`TerminalOperations.java`) presents an example in code:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.18 - U reduce(U identity, BiFunction accumulator, BinaryOperator
    combiner) in code](img/B19793_15_18.jpg)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
- en: Figure 15.18 - U reduce(U identity, BiFunction accumulator, BinaryOperator combiner)
    in code
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we are streaming a list of strings and we want to total the
    overall number of characters in all of the strings. The `reduce()` method is coded
    as follows:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'and has 3 elements:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: 0 is the identity, which represents our starting value.
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`(n, str) -> n + str.length()` is the `BiFunction` accumulator. In this case,
    the first parameter is `Integer` and the second parameter is `String`. The return
    type matches the first parameter – in other words, `Integer`. We did not highlight
    this in the method signature as all the letters can sometimes confuse the issue.
    This accumulator adds the length of the current `String` to the current total.'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`(n1, n2) -> n1 + n2` represents the combiner `BinaryOperator` (a function
    where the types are the same). Its lambda simply adds the two numbers and returns
    the sum. This function adds the intermediate results from the accumulators.'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thus, with parallel streams, one thread could return the accumulated value of
    6, which is the sum of the lengths of `"car"` and `"bus"`, whereas another thread
    could return the accumulated value of 14, which is the sum of the lengths of `"train"`
    and `"aeroplane"`. These two values are then combined by the combiner, resulting
    in 20.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will move on to a powerful terminal operation, namely `collect()`.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: collect()
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is a special type of reduction called a mutable reduction because we are
    using the same mutable object while accumulating. This makes it more efficient
    than regular reductions. Common mutable objects include `StringBuilder` and `ArrayList`.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: This operation is extremely useful for getting data `Map`, `List`, or `Set`.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: There are two versions – one that gives you complete control over the collecting
    process and another that gives you predefined collectors from the API. We will
    start with the first one, where you can specify everything yourself.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: collect(Supplier, BiConsumer, BiConsumer)
  id: totrans-283
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This method is best explained with a code example, see *Figure 15**.19*, which
    is taken from `TerminalOperations.java` on the repo.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.19 – The collect(Supplier, BiConsumer, BiConsumer) operation in
    code](img/B19793_15_19.jpg)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
- en: Figure 15.19 – The collect(Supplier, BiConsumer, BiConsumer) operation in code
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: In this figure, we are building up one long word from a list of smaller words.
    Note that the equivalent method references (to the lambdas used), are in comments
    on the right-hand side of each line.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: 'The first argument to `collect()` is a `Supplier` which specifies that we want
    to work with a `StringBuilder`:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The accumulator adds the current `String` to the `StringBuilder`:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The combiner takes the two `StringBuilder`''s and merges them:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: This is useful in parallel processing, where different threads can perform accumulations
    and have their results combined. In this example, thread 1 could return `"adjud"`,
    the result of accumulating `"ad"` and `"jud"`; and thread 2 could return `"icate"`,
    the result of accumulating `"i"` and `"cate"`. These two results combine into
    `"adjudicate"`.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s look at the version of `collect()` where we pass in pre-defined API
    collectors.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: collect(Collector)
  id: totrans-296
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is the version that accepts a pre-defined API collector. We access these
    collectors via `static` methods in the `Collectors` class. These collectors do
    nothing on their own – they exist to be passed into the `collect(Collector)` method.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: We will examine many of them, particularly the ones that help us extract data
    out of the stream into collections for subsequent processing. In addition, we
    will look at how to group and partition information. Let’s start with some of
    the more basic collectors.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: Collectors.joining(CharSequence delimiter)
  id: totrans-299
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This collector returns a `Collector` that concatenates the input elements, separated
    by the specified delimiter. The order of the stream is maintained. *Figure 15**.20*
    presents an example (taken from CollectorsExamples.java on the repo).
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.20 - Collectors.joining() in code](img/B19793_15_20.jpg)'
  id: totrans-301
  prefs: []
  type: TYPE_IMG
- en: Figure 15.20 - Collectors.joining() in code
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: In this example, the strings are appended together and delimited by `", "`.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: Collectors.averagingInt(ToIntFunction)
  id: totrans-304
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This returns a `Collector` that produces the average of the integers produced
    by the function supplied. *Figure 15**.21* (CollectorsExamples.java) presents
    an example:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.21 – Collectors.averagingInt(ToIntFunction) in code](img/B19793_15_21.jpg)'
  id: totrans-306
  prefs: []
  type: TYPE_IMG
- en: Figure 15.21 – Collectors.averagingInt(ToIntFunction) in code
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we are streaming strings, representing desserts. Each string
    has a length and we want to calculate the average of the lengths. The function,
    `s -> s.length()` takes in a `String`, namely `s`, and returns its integer length.
    The method reference version is in a comment on the right. The average is then
    output.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s examine how we can extract the stream contents into a `List`, `Set`,
    or `Map`. We will start with `List`.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: Collectors.toList()
  id: totrans-310
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This returns a `Collector` operation that accumulates the elements into a new
    `List`. There is no guarantee on the type of `List`. For example, there is no
    guarantee that the `List` is an `ArrayList` or a `LinkedList`. To gain that level
    of control, you must use the `toCollection(Supplier)` method (which we will be
    using in the `Set` example). *Figure 15**.22* presents the `Car` type (`CollectorsExamples.java`)
    that we will use in the next few examples:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.22 – The Car class](img/B19793_15_22.jpg)'
  id: totrans-312
  prefs: []
  type: TYPE_IMG
- en: Figure 15.22 – The Car class
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 15**.23* presents an example of `Collectors.toList()` in code (from
    `CollectorsExamples.java` in the repo):'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.23 – Collectors.toList() in code](img/B19793_15_23.jpg)'
  id: totrans-315
  prefs: []
  type: TYPE_IMG
- en: Figure 15.23 – Collectors.toList() in code
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we added three `Car`s to our `List`. Recall that `List`s maintain
    insertion order. The `map(Function)` method is an intermediate operation that
    takes in one stream and transforms it into another stream. We will discuss the
    `map()` method in more detail in [*Chapter 16*](B19793_16.xhtml#_idTextAnchor401),
    but for now, realize that there is `Stream<Car>` coming into `map()` and `Stream<String>`
    coming out. This is because `brand` in `Car` is a `String`. Now, we have a `Stream<String>`
    for `collect()` to extract in `List` format.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: As stated earlier, the implementation type is not guaranteed. What if we wanted
    a specific implementation and not just that, but an implementation that sorted
    the elements as they were added? `TreeSet` will do this. Let’s look at that now.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: Collectors.toSet() and Collectors.toCollection(Supplier)
  id: totrans-319
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`Collectors.toSet()` returns a `Collector` that accumulates the elements into
    a new `Set`. There is no guarantee on the type of `Set`. In this example, however,
    we want a specific `Set`, namely `TreeSet`. We can use `Collectors.toCollection(Supplier)`
    when we want a specific implementation. *Figure 15**.24* presents the code (`CollectorsExamples.java`):'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.24 – Collectors.toCollection(Supplier) in code](img/B19793_15_24.jpg)'
  id: totrans-321
  prefs: []
  type: TYPE_IMG
- en: Figure 15.24 – Collectors.toCollection(Supplier) in code
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, the cars have been deliberately added to our `ArrayList` in
    unsorted brand order. The following line is where the magic happens:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'We are passing in a `Supplier` method reference to create a `TreeSet` that
    is, in turn, passed to the `Collectors.toCollection()` method. This results in
    a `TreeSet` implementation. When we output `treeSet` we get:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Notice that the brands are now sorted alphabetically (the default sort order
    for strings). We can also extract data out of a stream into a `Map`. Let us examine
    that now.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: Collectors.toMap(Function keyMapper, Function valueMapper)
  id: totrans-328
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This returns a `Collector` that gathers elements into a `Map` where the keys
    and values are the result of applying the provided mapping function to the stream
    elements. Again, there are no guarantees of the type of `Map` returned. *Figure
    15**.25* presents an example in code (`CollectorsExamples.java`):'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.25 – Collectors.toMap(Function keyMapper, Function valueMapper)
    in code](img/B19793_15_25.jpg)'
  id: totrans-330
  prefs: []
  type: TYPE_IMG
- en: Figure 15.25 – Collectors.toMap(Function keyMapper, Function valueMapper) in
    code
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we are streaming a list of desserts (as strings). The declared
    `Map` states that our key is a `String` type and that the value is an `Integer`
    type. This is because we want to set up a `Map` so that the dessert name is the
    key and the number of characters in the dessert name is the value.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: 'The keys in the `Map` are set up using the following `Function`:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Recall that `Function<T, R>` takes in one parameter of type `T` and returns
    a result of type `R`. In this example, our function will be `Function<String,
    String>` as we are streaming a dessert (`String`) and this dessert is what we
    want to use as the key. We can simply use the lambda `s -> s` or use the `String::toString`
    method reference. Either version will work.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: 'The values in the Map are set up using the following `Function`:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Our function in this case is `Function<String, Integer>` as we want our function
    to return the length of the dessert. We can use the lambda `s -> s.length()` or
    the `String::length` method reference.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: 'The output that’s generated is:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Before we present the next version, let’s look at an example that generates
    an exception. *Figure 15**.26* presents the example in code (CollectorsExamples.java):'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.26 – The Collectors.toMap(Function keyMapper, Function valueMapper)
    exception](img/B19793_15_26.jpg)'
  id: totrans-342
  prefs: []
  type: TYPE_IMG
- en: Figure 15.26 – The Collectors.toMap(Function keyMapper, Function valueMapper)
    exception
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: In this figure, we are trying to set up a `Map` where the key is the length
    of the dessert name and the value is the dessert name itself. Note that the dessert
    names are subtly different from the previous figure. Now, instead of `"apple tart"`,
    we have `"tart"`. This is going to lead to problems. Maps cannot have duplicate
    keys and both `"cake"` and `"tart"` are 4 characters long. This leads to an `IllegalStateException`
    error.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: To fix this issue, we need to use the second version of `toMap()`.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: Collectors.toMap(Function, Function, BinaryOperator mergeFunction)
  id: totrans-346
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This collector operates similarly to the previous collector, except when we
    encounter duplicate keys. In that scenario, the merge function is applied to the
    *values*. The merge function is a `BinaryOperator<T`,`>`, which is-a `BiFunction<T,T,T>`.
    In other words, there are two inputs and one result, and they are all the same
    type. *Figure 15**.27* presents the code (`CollectorsExamples.java`) with the
    merge function present to handle duplicate keys:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.27 – Collectors.toMap(Function, Function, BinaryOperator)](img/B19793_15_27.jpg)'
  id: totrans-348
  prefs: []
  type: TYPE_IMG
- en: Figure 15.27 – Collectors.toMap(Function, Function, BinaryOperator)
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, the only difference is the merge function:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The merge function takes in `s1` and `s2`, the values for the two colliding
    keys. In this example, the values are appended with a comma between them.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: 'The output generated is:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The colliding key was `4` and their values were `"cake"` and `"tart"`, resulting
    in `"``4=cake, tart"`.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: The next version enables us to specify the `Map` implementation we desire.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: Collectors.toMap(Function, Function, BinaryOperator, Supplier mapFactory)
  id: totrans-357
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As we know, the `Map` implementations that are returned are not guaranteed.
    You could get a `HashMap` or `TreeMap` implementation. This `toMap()` version
    is very similar to the previous one except there is an extra argument where we
    can specify our implementation type. *Figure 15**.28* presents the code (`CollectorsExamples.java`)
    with the constructor method reference used to ensure a `TreeMap` implementation:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.28 – Collectors.toMap(Function, Function, BinaryOperator, Supplier)](img/B19793_15_28.jpg)'
  id: totrans-359
  prefs: []
  type: TYPE_IMG
- en: Figure 15.28 – Collectors.toMap(Function, Function, BinaryOperator, Supplier)
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: In this figure, the dessert name is the key and the length of the dessert name
    is the value. `"cake"` is in the source twice, causing a duplicate keys issue
    and a reason to invoke the merge function. In this instance, the values for the
    duplicate keys are to be added. As `"cake"` appears just twice, this means that
    `"cake=8"` will be in `Map`.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we want a `TreeMap` implementation. To ensure this, we specify
    an extra argument, the following `Supplier`:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Thus, our keys will be sorted. When we output our map we can see that the keys
    are alphabetically sorted, as expected:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Also, note that `"cake"` maps to 8 (4 + 4).
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also use the `getClass()` method to prove that we have indeed a `TreeMap`
    implementation:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Now, let’s examine the `groupingBy` terminal operations.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: Collectors.groupingBy(Function classifier)
  id: totrans-370
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `groupingBy()` operation tells `collect()` to group all the elements into
    a `Map` implementation. The `Function` parameter determines the keys in `Map`.
    The values are a `List` (the default) of all entries that match that key. Having
    the values returned as a `List` can, as we shall see, be changed. There is no
    guarantee as to the `Map` or `List` implementations used. *Figure 15**.29* presents
    an example in code, taken from `CollectorsExamples.java` in the repo:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.29 – Collectors.groupingBy(Function) in code](img/B19793_15_29.jpg)'
  id: totrans-372
  prefs: []
  type: TYPE_IMG
- en: Figure 15.29 – Collectors.groupingBy(Function) in code
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we are streaming a list of names and are extracting a `Map<Integer,
    List<String>` from the stream (as per the declaration). The `Function` parameter
    `String::length` that’s passed into `groupingBy()`, tells `collect()` that the
    key in the map is the length of the `String` (in effect, the number of characters
    in the name). The values are organized into a `List`, and each entry in the list
    is a `String` where the length of the `String` matches the key. For example, as
    per the output:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '`5` maps to `"Peter"` and `6` maps to `"Martin"`. Note that in the output,
    `"Tom"` appears in the list twice. This is because lists allow duplicates.'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: What if we wanted `"Tom"` to appear only once in the output list? There is an
    overloaded version of `groupingBy()` that will help us here.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: Collectors.groupingBy(Function keyMapper, Collector downstreamCollector)
  id: totrans-378
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Recall that a `Set` implementation does not allow duplicates, so using a `Set`
    implementation for the values, as opposed to the default `List`, will solve this.
    The second parameter here is known as a *downstream collector*. The function of
    a downstream collector is to do something special with the *values*. In this example,
    we want the values organized as a `Set` implementation. *Figure 15**.30* presents
    the code (`CollectorsExamples.java`) adjustments:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.30 – Using Collectors.groupingBy(Function, Collector) for a Set
    implementation](img/B19793_15_30.jpg)'
  id: totrans-380
  prefs: []
  type: TYPE_IMG
- en: Figure 15.30 – Using Collectors.groupingBy(Function, Collector) for a Set implementation
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, the type for the values in the `Map` is `Set<String>` and
    not `List<String>`. The downstream collector:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'states that we want the values organized as a `Set`. The output shows that
    `"Tom"` is now listed only once:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Note that the implementation type for our `Map` happens to be a `HashMap` implementation:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: This implementation is not guaranteed. What if we wanted to guarantee a `TreeMap`
    implementation? There is an overloaded version to help us here also.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: Collectors.groupingBy(Function, Supplier mapFactory, Collector)
  id: totrans-389
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This version accepts a `Supplier` as its second parameter. This `Supplier` returns
    the implementation that you desire.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 15**.31* presents the code adjustments (`CollectorsExamples.java`):'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.31 – Using Collectors.groupingBy(Function, Supplier, Collector)
    for a TreeMap implementation](img/B19793_15_31.jpg)'
  id: totrans-392
  prefs: []
  type: TYPE_IMG
- en: Figure 15.31 – Using Collectors.groupingBy(Function, Supplier, Collector) for
    a TreeMap implementation
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we are reverting to a `List` type for the values:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'To extract the stream data as a `List` type, we must use the appropriate downstream
    collector:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'As can be seen from the output:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '`"Tom"` is now duplicated again (as lists allow duplicates).'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: 'We also pass a `Supplier` argument to `groupingBy()`, stating we want a `TreeMap`
    implementation:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The `map.getClass()` call outputs:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: showing that we have a `TreeMap` implementation.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: We will now look at a special case of grouping, called partitioning.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: Collectors.partitioningBy(Predicate)
  id: totrans-407
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Partitioning is a special case of grouping where there are only two groups –
    true and false. Thus, the keys in the `Map` implementation will be of the `Boolean`
    type. The values will default to a `List` type. There is no guarantee as to the
    `Map` or `List` implementations returned.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 15**.32* presents a code example (CollectorsExamples.java):'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.32 – Collectors.partitioningBy(Predicate) in code](img/B19793_15_32.jpg)'
  id: totrans-410
  prefs: []
  type: TYPE_IMG
- en: Figure 15.32 – Collectors.partitioningBy(Predicate) in code
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: In this figure, we are extracting data from the stream into a `Map<Boolean,
    List<String>`. The keys will be true and false. The values will be the elements
    in the stream that are either true or false based on the predicate provided.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the following line of code, we tell `collect()` to partition the stream
    based on whether the `String` name begins with `"T"`:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'As can be seen from the output:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: the true partition contains `"Thomas"` and `"Teresa"` and the false partition
    contains all the other names. Note that `"Alan"` is in the false partition twice,
    as lists allow duplicates.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: There is an overloaded version of `partitioningBy()` that enables us to pass
    in a downstream collector.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: Collectors.partitioningBy(Predicate, Collector downstreamCollector)
  id: totrans-419
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A downstream collector is useful for specifying a different collection for
    our values. For example, instead of a `List` view, we may want a `Set` view so
    that duplicates are automatically removed. *Figure 15**.33* presents a code example
    (CollectorsExamples.java):'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.33 – Collectors.partitioningBy(Predicate, Collector) in code](img/B19793_15_33.jpg)'
  id: totrans-421
  prefs: []
  type: TYPE_IMG
- en: Figure 15.33 – Collectors.partitioningBy(Predicate, Collector) in code
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, note that the name `"Alan"` is in the source twice:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: In addition, we are collecting data into a `Map<Boolean,` *Set*`<String>>`.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: 'We also changed the predicate just to do something different:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Thus, if the number of characters in the string is `> 4`, the string is placed
    in the true partition; otherwise, the string is placed in the false partition.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: 'We specify the required downstream collector as follows:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'This means that the values are to be returned as a `Set`. As can be seen in
    the output, `"Alan"` appears only once (in the `false` partition):'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: That completes our discussion on the terminal operations section and also concludes
    [*Chapter 15*](B19793_15.xhtml#_idTextAnchor377). Now, let’s put that knowledge
    into practice to reinforce the concepts we’ve learned.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  id: totrans-434
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Create a stream of dinosaur names (use a List or an array). Use the `filter`
    method to create a new stream that only includes the names of carnivorous dinosaurs.
    Then, use the `forEach` method to print out these names..
  id: totrans-435
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Demonstrate stream laziness by creating a stream from a list of dinosaur ages.
    Use the `filter` method to filter out ages greater than 100, and then use a `map`
    method to increase each remaining age by 10\. However, do not use any terminal
    operation. Explain why nothing is printed or no operation is performed until a
    terminal operation (like `forEach`) is called..
  id: totrans-436
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using a stream of dinosaur weights (as doubles), count the number of dinosaurs
    that weigh more than 5000 kg using the filter and count terminal operations.
  id: totrans-437
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Given a stream of dinosaur species names (String), use the `findFirst` terminal
    operation to retrieve the first name on the list.
  id: totrans-438
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Project – dynamic dinosaur care system
  id: totrans-439
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Integrate the Stream API into your dinosaur care system to process large volumes
    of dinosaur data, such as health records, feeding schedules, and so on. The system
    should also incorporate `Optional` and parallel streams where appropriate, optimizing
    data processing and minimizing potential null pointer exceptions.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the steps to get you there:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
- en: '`Dinosaur` class with properties such as `name`, `species`, `healthStatus`,
    and so on. There should also be a `DinosaurCareSystem` class for implementing
    the main functionalities.'
  id: totrans-442
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Stream` from the list of records and use the `filter` method to get these
    records. Here’s an example: `List<HealthRecord> criticalRecords = records.stream().filter(r
    -> r.getHealthStatus() <` `CRITICAL_THRESHOLD).collect(Collectors.toList())`.'
  id: totrans-443
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Stream` to filter the schedules. Here’s an example: `List<FeedingSchedule>
    morningFeeds = schedules.stream().filter(s ->` `s.getTime().isBefore(LocalTime.NOON)).collect(Collectors.toList())`.'
  id: totrans-444
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`NullPointerException``Optional` to avoid a `NullPointerException` error. Here’s
    an example: `Optional.ofNullable(dinosaur.getTrainer()).map(Trainer::getName).orElse("No`
    `trainer assigned").`*   `stream()` with `parallelStream()` in the previous examples.
    Be aware, though, that not every problem is suitable for parallel processing.
    If the tasks have dependencies or need to be processed in a specific order, stick
    with regular streams.'
  id: totrans-445
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  id: totrans-446
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored the fundamentals of streams and stream terminal
    operations. Streams (along with lambda expressions) enable a style of programming
    known as functional-style programming, where you state what you want to solve
    rather than how to solve it (imperative style). Functional-style programming tends
    to be easier to read because, with imperative programming, the details of how
    to solve the problem can get mixed up in the implementation.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
- en: We discussed stream pipelines using the analogy of an assembly line. A stream
    pipeline consists of a data source, zero or more intermediate operations, and
    a terminal operation, in that order. Streams are lazily evaluated, which means
    that data is only provided as and when needed. This is possible because the JVM
    has an overall view of the pipeline, as nothing happens until the terminal operation
    is executed.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
- en: 'Stream sources can vary from arrays (`Arrays.stream(arrayToUse)`), collections
    (`collectionToUse.stream()`), and files (`Files.lines(Path)`) to a variable number
    of arguments (`Stream.of(varargs)`). Infinite streams can be generated using two
    `static` methods from the Stream API: `Stream.generate()` and `Stream.iterate()`.'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
- en: Terminal operations kickstart the whole pipeline and every pipeline must have
    a terminal operation. Once a terminal operation executes on a stream, the stream
    is closed and must be re-streamed to be reused. Popular terminal operations include
    `forEach()`, `count()`, `min()`, `max()`, `findAny()`, `findFirst()`, `allMatch()`,
    `anyMatch()`, `noneMatch()`, `reduce()`, and `collect()`.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
- en: A reduction is a special type of terminal operation where all of the stream
    items are combined into one primitive or `Object`. The `reduce()` method has overloaded
    versions to facilitate this. The `collect()` method is very useful for extracting
    data out of the stream and into a collection, such as a `List` or `Map` delete
    The `collect()` method accepts collectors, which you can define yourself, or you
    can simply use one of the many pre-defined collectors in the API.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
- en: That completes our discussion on the fundamentals of streams. In the next chapter,
    we will expand into more advanced streaming concepts.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
