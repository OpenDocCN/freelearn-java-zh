- en: 17\. Reactive Programming with Java Flow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overview
  prefs: []
  type: TYPE_NORMAL
- en: This chapter covers the Java Flow API and the advantages of the Reactive Streams
    specification. It will first define, in general terms, the motivation for Flow
    and Reactive Streams, as well as the respective functions of Publishers, Subscribers,
    and Processors in Java. You will then learn to use the basic `SubmissionPublisher`
    to build a reactive application and, in the final sections, practice implementing
    a simple Subscriber and Processor using Flow.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Reactive Streams specification presents an ongoing development within software
    architecture, referred to as Reactive Systems. These systems, ideally, have the
    following advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: A faster response
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More controlled responses in relation to one another
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Increased reliability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A natively supported API for developing Reactive Systems or applications was
    introduced in Java 9, called Flow.
  prefs: []
  type: TYPE_NORMAL
- en: The Java 9 Flow API was not intended to compete with the already developed,
    highly adopted, and appreciated reactive libraries or APIs available out there.
    The biggest reason for the advent of the Flow API was the need for a common denominator
    amongst these libraries; to ensure that the core of reactive programming would
    be the same regardless of which implementation you use. That way, you can easily
    translate from one implementation to another.
  prefs: []
  type: TYPE_NORMAL
- en: To achieve this, the Java Flow API adheres to the Reactive Streams specification—the
    specification that most of the libraries available use as a blueprint for their
    design. The Reactive Streams initiative, which designed the specification, was
    started in 2013 by Netflix and several other large corporations with a vested
    interest in delivering content reliably.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: While they may share a lot of the same lingo, the Flow API is not in any way
    related to the Streams API of Java 8\. They are focused on solving different kinds
    of problems.
  prefs: []
  type: TYPE_NORMAL
- en: In simple terms, reactive programming is a way to write programs using components
    that communicate with each other by streaming events. These events are often asynchronous
    in nature and should never overwhelm the receiving party. Within a reactive system,
    there are two main components—publishers and subscribers. This is similar to a
    networked pub/sub system, but on a micro-scale.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Java Flow API (or rather Reactive Streams, which Flow adheres to) has three
    main actors:'
  prefs: []
  type: TYPE_NORMAL
- en: The Publisher has the knowledge of the available data and pushes it on-demand
    to any interested subscriber.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Subscriber is the one demanding the data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Processor may sit between a publisher and a subscriber. Processors can intercept
    and transform the published data before releasing it to a subscriber or another
    processor. Thus, the processor can act as both a subscriber and a publisher.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Communication between these components is of both a push and pull nature. The
    subscriber first asks the publisher to send, at most, `n` messages. That's the
    pull part of the communication. Following that request, the publisher will begin
    to send messages to the subscriber, but it will never exceed `n` messages.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 17.1: Communication between the Subscriber and the Publisher'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C13927_17_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 17.1: Communication between the Subscriber and the Publisher'
  prefs: []
  type: TYPE_NORMAL
- en: When the publisher has sent the final message, it will provide a notification
    that the sending of messages is complete, and the subscriber may then act as needed—probably
    requesting more messages or aborting the communication entirely.
  prefs: []
  type: TYPE_NORMAL
- en: The entire Flow API, which we will look into further in this chapter, is defined
    in a single Java class. It contains one interface for each of the actors, and
    an extra interface describing the subscription object, which is the messaging
    link between the publisher and subscriber.
  prefs: []
  type: TYPE_NORMAL
- en: Publisher
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The publisher holds the data that other components are interested in getting.
    The publisher will wait until a subscriber who is interested in the data requests
    n-number of items to be sent, and will only then start sending those items to
    the subscriber.
  prefs: []
  type: TYPE_NORMAL
- en: Asking for a specific number of items, rather than asking for everything, is
    called backpressure, and is very important in the Reactive Streams specification.
    This backpressure lets listeners request only as many items as they can handle
    at a time, ensuring that the application will not stall or crash.
  prefs: []
  type: TYPE_NORMAL
- en: 'The interface for `Publisher` in Flow, and Reactive Streams looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: You'll notice that it's a functional interface, which can be implemented as
    a lambda, should you wish.
  prefs: []
  type: TYPE_NORMAL
- en: SubmissionPublisher
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Creating a fully functional Publisher can be quite a complicated endeavor. Luckily,
    Flow includes a complete implementation called `SubmissionPublisher`. We'll use
    this class in several examples in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use `SubmissionPublisher` either directly, as a component, or as a
    superclass for your extended `Publisher`. `SubmissionPublisher` requires an `Executor`
    and a buffer size. By default, it will use the common `ForkJoinPool` and a buffer
    size of 256:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The choice of executor should be based on how your application is designed
    and the tasks it is supposed to handle. In some cases, the common `ForkJoinPool`
    is the best choice, while in other situations, a scheduled thread pool may work
    better. You may need to try different executors and buffer sizes to find the combination
    that best suits your needs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: You may also use `SubmissionPublisher` as a superclass for your own implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, `MyPublisher` extends `SubmissionPublisher`, but
    defines a fixed `threadpool` executor rather than the common `ForkJoinPool` executor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Subscriber
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The subscriber represents the end-user. It receives the data at the very end
    of the stream and acts on it. The action may include updating a user interface,
    pushing it to another component, or transforming it in any way.
  prefs: []
  type: TYPE_NORMAL
- en: 'The interface of the subscribers contains four different callbacks, each of
    which represents a message of some type from the publisher or the subscriber itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '`onSubscribe:` The `onSubscribe` method is invoked as soon as the subscriber
    has a valid subscription. Generally, this is used to kick-start the delivery of
    items from the publisher. The `Subscriber` will typically inform the `Publisher`
    here, by requesting another item.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onNext:` The `onNext` method is invoked when another item is made available
    from the `Publisher`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onError:` The `onError` method is invoked when an error occurs. This usually
    means that the subscriber will no longer receive any more messages and should
    be closed down.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onComplete:` The `onComplete` method is invoked by the publisher when the
    final item has been sent.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following example illustrates all of these callbacks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Subscription
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A `Subscriber` may use the Subscription API to control a publisher, either
    by requesting more items, or by canceling the subscription altogether:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: It is the `Publisher` who creates the subscriptions. It does this whenever a
    `Subscriber` has subscribed to that `Publisher`. If a `Subscriber` happens to
    subscribe twice to one publisher, it will fire the `onError()` callback with `IllegalStateException`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 1: A Simple Application with a Single Publisher and a Single Subscriber'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we will build an application with a single `Publisher` and
    a single `Subscriber`. The `Publisher` will send a string of messages to the `Subscriber`,
    which will then print it to the terminal. The messages are found in the `lipsum.txt`
    file, which should be placed in your `projects /res` folder. For this exercise,
    we will use the common `ForkJoinPool` to generate the executor:'
  prefs: []
  type: TYPE_NORMAL
- en: If IntelliJ is already started, but no project is open, select `Create New Project`.
    If IntelliJ already has a project opened, select `File` à `New` à `Project` from
    the menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In `New Project` dialog, select a Java project, and then click `Next`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check the box to create the project from a template. Select `Command Line App`,
    and then click `Next`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the new project `Chapter17`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: IntelliJ will give you a default project location. If you wish to select a different
    one, you may enter it here.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the package name to `com.packt.java.chapter17`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click `Finish`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: IntelliJ will create your project, called `Chapter17`, with the standard folder
    structure. IntelliJ will also create a main entry point called `Main.java`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Rename this file to `Exercise1.java`. When you''re done, it should look like
    this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will use `SubmissionPublisher` in this exercise. This is a fully functional
    implementation of the `Publisher` interface, which you can use to demonstrate
    the basic functionality of a reactive application. Declare a default `SubmissionPublisher`,
    as shown here, and then initialize it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Flow doesn''t come with any already available implementations of `Subscriber`,
    so we will need to implement our own `Subscriber`. Create a new class called `LipsumSubscriber`,
    and allow it to implement the `Flow.Subscriber` interface. Your new class should
    look something like the following example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The subscriber has four methods to implement. The `onSubscribe` method will
    be called by the publisher when the `Subscription` object has been created. Usually,
    you''ll store a reference to that subscription so that you can issue requests
    to the publisher, create a `Flow.Subscription` member variable in your `LipsumSubscriber`
    class, and store the reference from the `onSubscribe` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Usually, you''ll also request at least one item when the subscription has been
    created. Use the `request` method to ask for one item from the publisher:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Looking at the next method in the class, called `onNext`, this is the callback
    executed by the `Publisher` whenever an item is issued to all subscribers. In
    this example, we will simply print the contents of the item:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To keep getting more items from the publisher, we need to keep requesting them;
    this is what is called backpressure. It''s the subscriber who is in control in
    terms of how many items it can handle at a time. In this exercise, we''ll handle
    one item at a time and then request another. Request another item after you''ve
    printed the current item to the console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The subscriber can use the methods `onError` and `onComplete` to perform a
    cleanup and make sure that no resources are kept in vain. In this example, we
    will simply print the error and a completion message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Back in the `main` method, create a new subscriber and allow it to subscribe
    to the publisher:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'However, this will not actually do anything. The publisher still has no data
    to send, so we need to provide the data to the publisher as well. We''ll use the
    `lipsum.txt` file as the source. Copy the file to the `res/` folder in your project.
    Create the folder if it doesn''t already exist:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To send the words from the `lipsum.txt` file to the `Publisher`, you need to
    load the file into some kind of container. We will use the `Stream` API to load
    the words, and then push them to the publisher immediately. Wrap the stream in
    a try-with-resources block to enable the JVM to auto-close the resource after
    loading it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we are loading the file as a stream of strings. It will load the lines
    from the file into one string each. Since every line may contain multiple words,
    we need to apply a flat mapping to each line to extract the words. We are using
    a simple regular expression to split the lines into words, looking for one or
    more whitespaces, punctuation items, or a new line.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You can read more about the Streams API, and the different methods used here,
    in *Chapter 15*, *Processing Data with Streams*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'At this point, the program will execute and print all the words available in
    the file. However, you may notice that it does not print any completion messages.
    That is because we haven''t actually notified the subscribers that the stream
    has ended. Send the completion signal, as seen here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Running this program should yield the following output in the console:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Having built your first reactive application, you may notice that it doesn't
    really make much sense to use this extra logic in a very simple program, as shown
    in this example. Applying the Reactive Streams concept to a simple example makes
    very little sense as it is meant to be used in asynchronous applications, where
    you may not be sure when, or if, a Subscriber can currently receive messages.
  prefs: []
  type: TYPE_NORMAL
- en: Processor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Processor is something of a chameleon in Flow; it may act as both a `Subscriber`
    and a `Publisher`.
  prefs: []
  type: TYPE_NORMAL
- en: There are several different reasons for adding an interface such as the Processor.
    One reason may be that you have a stream of data that you do not fully trust.
    Imagine an asynchronous flow of data from a server, where data is delivered over
    a UDP connection that lacks promises of delivery; this data will eventually be
    corrupted and you need to handle that. A simple way would be to inject a filter
    of some kind between the publisher and subscriber. This is where a `Processor`
    excels.
  prefs: []
  type: TYPE_NORMAL
- en: Another reason for using a Processor could be to separate a polymorphic data
    stream between different subscribers so that alternative actions may be taken
    based on the data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 2: Using a Processor to Convert a Stream of Strings to Numbers'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, we will first build a Publisher that periodically publishes
    a string from a text file. Then, we will use a scheduler to control the timer.
    The Subscriber should then attempt to transform a certain string to a number.
    The `numbers.txt` file will be used to build this application. In this example,
    we will also show how to clean up the handling of the data using a Supplier implementation
    to make the data source abstract.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `numbers.txt` file contains intentional errors that we will handle by applying
    a processor before the subscriber:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `Chapter17` project in IDEA if it's not already opened.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new Java class, using the `File` | `New` |`Java Class` menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `Create New Class` dialog, enter `Exercise2` as `Name`, and select `OK`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'IntelliJ will create your new class. It should look something like the following
    snippet:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a `main` method to this class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will continue using the basic `SubmissionPublisher` supplied in the Flow
    library, but in this exercise, we''ll create our own subclass. Create a new class
    called `NumberPublisher`. This should extend `SubmissionPublisher`, as shown in
    the following code block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Our new `NumberPublisher` should publish numbers periodically to any interested
    `Subscriber`. There are several different options in terms of how to accomplish
    this, but probably the easiest solution is to use a `Timer`. Add a `Timer`, and
    a `TimerTask` to your publisher:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When the publisher is shutting down, so should `Timer`. Override the publisher''s
    `close()` method, and add a call to the `cancel()` method of `Timer` just before
    the publisher is about to shut down:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'There are two different ways to let the publisher send items to the connected
    subscribers. Using either `submit()` or `offer()`. `submit()` works in a fire-and-forget
    fashion, while `offer()` lets the publisher retry sending the item once using
    a handler. In our case, `submit()` would work just fine. But, before you can submit,
    you need some data. Add a `Supplier` to the `Publisher` using dependency injection:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: A supplier is a functional interface that is often used to deliver results –
    to anyone and anything.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now that we know how to get the data we need using `Supplier`, we can actually
    send it to the subscribers. Inside the `run()` method of `TimerTask`, add a call
    to `submit()` and get the data from the supplier:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'One last thing remains, because the publisher may run into trouble when attempting
    to either get items from the supplier or send items onward. We need to catch any
    exception when attempting to execute the `submit()` method. Add a try-catch clause,
    and use a `closeExceptionally()` method to inform any subscriber that we ran into
    difficulty. Executing `closeExceptionally()` will force the publisher into a state
    where it cannot send anything else out:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, `TimerTask` is fully implemented. The data is injected into `Publisher`
    using `Supplier`, and shutdown handling is ready. All that remains to do is to
    actually schedule periodic publishing. Using `Timer`, schedule `TimerTask` for
    repeat execution every 1 second. Since `TimerTask` accepts only milliseconds,
    we need to remember to multiply the delay by `1000`. We''re also setting the initial
    delay to `1000` milliseconds:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now that our `NumberPublisher` is ready, we need to start feeding it data, but
    in order to feed it the data that should be published, we need to load the data.
    The data we're going to send is located in the `numbers.txt` file. Copy the `numbers.txt`
    file to the `/res` folder, creating the folder if it doesn't already exist.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `Exercise2` class, create a new method called `getStrings()`, which
    will return the numbers from the `numbers.txt` file as `Strings`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In this new method, create a variable called `filePath`. Let it point to the
    `numbers.txt` file, located in the `/res` folder. We will use this `filePath`
    variable to load the file contents in the next step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Load the file contents into a `String` stream, and then wrap the load in a
    try-with-resources block so that we don''t need to care about releasing the file
    resources when we''re done:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `numbers.txt` file contains lots of numbers and some other characters that
    might cause trouble later on. But, in order to actually decode the file to single
    words, we need to review the structure of the file. Let''s open it, and you should
    see something like this—multiple rows with a column-like structure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The stream of strings we''ve just loaded will not be of much help. Each item
    in the stream will represent a whole line, and we need to transform the stream
    before it will be useful to us. First of all, apply a `flatMap` operator to create
    a new stream for each item in the original stream. This will let us split each
    line up into multiple items, and return them to the main stream:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You can read more about processing data with Streams in *Chapter 15*, *Processing
    Data with Streams*, and regular expressions in *Chapter 12*, *Regular Expressions*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The stream now contains items representing each column for each line. But,
    in order to use the data, we need to filter it based on length as we don''t want
    any `0` length words, and then we need to turn the stream into an array of strings.
    Filter the items of the stream, allowing only words with a length in excess of
    `0` to pass:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, turn the whole stream into an array of strings. This will return an array
    of strings to the caller of the method. However, if we do have an error in reading
    the file, we need to return something too. Return `null` at the very end of the
    `getStrings()` method. The publisher will interpret `null` as an error and throw
    `NullPointerException`, closing the connection to the subscriber:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The data for our little program is ready for pushing into the publisher so
    that it can send it to any interested subscriber. Now, we need to build a supplier
    that will take these strings and send them to the publisher, one by one, when
    the publisher requests them. Create a supplier in the `main` method of the `Exercise2`
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let the Supplier call `getStrings()` to retrieve the full array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The supplier, however, cannot return the entire dataset; it is designed to
    return one string at a time. For this to work, we need to keep an index of the
    last string sent to `Supplier`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will constantly return the first number in the file, and that''s not what
    we want. So, we need to increment the index every time someone asks the supplier
    for a string:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This, however, will throw an exception when we reach the final number in the
    file. So, we need to protect against that. In this case, we''ll return `null`
    when we reach the end. Add an `if` statement, checking that we haven''t gone too
    far:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The supplier is now ready to be used by our `NumberPublisher`. Create an instance
    of `NumberPublisher` in the `main()` method of `Exercise2`, passing the supplier
    as an argument:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a Subscriber and allow it to request an item on subscription success.
    Then, request a new item every time it receives an item—backpressure. While implementing
    the subscriber, add printouts for every method so that we can easily see what''s
    happening:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Running this code, you should get an output to the console, and the entire
    file should print:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'However, in the subscriber, we expect to get data we can easily transform into
    integers. If we apply simple integer parsing to the text, we''ll end up in trouble:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will stop, with a parse exception, when reaching the second item, `2e`,
    which, of course, is not an integer:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To rectify the problem with the broken subscriber, you can, of course, catch
    the exception right there. But, in this exercise, we will involve a filter processor
    in the mix. `Processor` will subscribe to `Publisher`, and `Subscriber` will subscribe
    to `Processor`. In essence, `Processor` is both a Publisher and a Subscriber.
    To make this simple for us, allow `NumberProcessor` to extend `SubmissionPublisher`,
    just like `NumberPublisher` does.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 17.2: Communication between the Subscriber, the Processor, and the
    Publisher'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/C13927_17_02.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 17.2: Communication between the Subscriber, the Processor, and the Publisher'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create a class called `NumberProcessor`, allow it to extend `SubmissionPublisher`,
    and implement the `Flow.Processor` interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`NumberProcessor` will subscribe to `NumberPublisher`, and, just like the subscriber,
    it needs to store a reference to the publisher so that it can control when to
    request new items. Store the reference received in `onSubscribe()` as a private
    field in the processor. Also, take this opportunity to request the first item
    from the publisher:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Whenever you receive an item from the publisher, you need to also request the
    next item, just like the subscriber would:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If the subscription to `NumberPublisher` is closed, we also need to inform
    the subscriber that there was a problem. Likewise, we need to inform the subscriber
    when the subscription ended. In the `onError()` callback, add a call to `closeExceptionally()`,
    and, in `onComplete()`, add a call to `close()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The processor is almost done. The one thing that is missing is communicating
    the received items back to the subscriber. We will do this in the `onNext()` callback
    method. However, since we know that there may be invalid values, we want to filter
    those. We''ll use a predicate for this, declaring a predicate to the `NumberProcessor`
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The predicate is a simple functional interface that is used to verify the input
    using a `test()` method. The `test()` method should always return `true` if the
    value was acceptable, or `false` if it was faulty. In our predicate, we will attempt
    to parse the string supplied. If the parsing is successful, we will return true;
    otherwise, we will return `false`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Back in the `onNext()` callback, we can now use our predicate to verify the
    value supplied before we submit it to the subscribers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You can read more about predicates and how to use them in *Chapter 16*, *Predicates
    and Other Functional Interfaces*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now that your `Processor` is ready, inject it between `NumberPublisher` and
    `Subscriber`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After running this example, you should see that the processor filters the faulty
    number values from the file before they reach the subscriber:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This example shows how to take content from a publisher and pass it through
    a processor to ensure that the values are valid.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 1: Let NumberProcessor Format Values as Integers'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Improve `NumberProcessor` further. Let it not only verify that the values can
    be parsed as integers, but also publish them to the subscriber as integers. The
    subscriber should only accept integer values, and no longer need to parse the
    received values.
  prefs: []
  type: TYPE_NORMAL
- en: Change the processors published item type to Integer. Make the necessary changes
    in the implementation to match the new type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the subscriber for the processor, it should accept only Integer values
    in the `onNext` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The solution for this activity can be found on page 568.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you've learned the basics of Reactive Streams components, how
    they communicate, and their respective roles in a reactive application.
  prefs: []
  type: TYPE_NORMAL
- en: In most cases, you should avoid using the Flow API to build reactive applications
    as there are much more advanced and user-friendly reactive libraries available
    out there. The Flow API provides only the basic building blocks for reactive applications,
    while implementations such as Akka or RxJava will give you a richer experience,
    providing essential functionality such as throttling, filtering, and debouncing,
    to name a few. If you're interested in delving further into reactive programming,
    there are entire books devoted to the subject.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned before, Flow provides the basis for building your own Reactive
    Streams library, however complex that may be. Should you wish to implement a Reactive
    Streams library of your own, you should start by reviewing the Reactive Streams
    Technology Compatibility Kit. This test-based kit will help you to ensure that
    your implementation follows the Reactive Streams rules.
  prefs: []
  type: TYPE_NORMAL
- en: After the next chapter, which focuses on unit testing, you should be all set
    to start looking at the compatibility kit and build your own Reactive Streams
    library.
  prefs: []
  type: TYPE_NORMAL
