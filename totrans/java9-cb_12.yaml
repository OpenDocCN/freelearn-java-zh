- en: Memory Management and Debugging
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存管理和调试
- en: 'This chapter deals with managing the memory of your Java application. Understanding
    the garbage collection process is crucial to developing memory-efficient applications.
    We will introduce you to the garbage collection algorithm being used in Java 9\.
    Then, we will introduce you to some new features of Java 9, which help in advanced
    application diagnostics. We''ll also show you how to manage the resources by using
    the new *try with resources* construct. Later, we''ll show you the new stack walking
    API introduced in Java 9\. Тhe following recipes will be covered:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论了管理Java应用程序的内存。理解垃圾收集过程对于开发内存效率高的应用程序至关重要。我们将向您介绍Java 9中使用的垃圾收集算法。然后，我们将介绍Java
    9的一些新特性，这些特性有助于高级应用程序诊断。我们还将向您展示如何使用新的“使用资源”构造来管理资源。稍后，我们将向您展示Java 9中引入的新堆栈跟踪API。以下内容将涵盖：
- en: Understanding the G1 garbage collector
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解G1垃圾收集器
- en: Unified logging for JVM
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JVM的统一日志记录
- en: Using the new diagnostic commands for the JVM
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用JVM的新诊断命令
- en: Try with resources for better resource handling
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试使用资源以更好地处理资源
- en: Stack walking for improved debugging
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 改进调试的堆栈跟踪
- en: Some best practices for better memory usage
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些提高内存使用效率的最佳实践
- en: Introduction
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Memory management is the process of memory allocation (for program execution)
    and memory reuse (after some of the allocated memory is not used anymore). In
    Java, this process happens automatically and is called **Garbage Collection**
    (**GC**). The effectiveness of GC affects two major application characteristics--responsiveness
    and throughput.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 内存管理是内存分配（用于程序执行）和内存重用（在分配的某些内存不再使用后）的过程。在Java中，这个过程是自动发生的，称为**垃圾收集**（**GC**）。GC的有效性影响两个主要的应用程序特性——响应性和吞吐量。
- en: Responsiveness is measured by how quickly an application responds (brings necessary
    data) to the request. For example, how quickly a website returns a page or how
    quickly a desktop application responds to an event. Naturally, the lower the response
    time, the better the user experience, which is the goal of design and implementation
    for many applications.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 响应性是通过应用程序对请求的响应速度（提供必要的数据）来衡量的。例如，网站返回页面或桌面应用程序对事件的响应速度有多快。自然地，响应时间越低，用户体验就越好，这是许多应用程序设计和实现的目标。
- en: Throughput indicates the amount of work an application can do in a unit of time.
    For example, how many requests a web application can serve or how many transactions
    a database can support. The bigger the number, the more value the application
    can potentially generate and the greater number of users it can accommodate.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 吞吐量表示应用程序在单位时间内可以完成的工作量。例如，一个Web应用程序可以服务多少请求或数据库可以支持多少事务。数字越大，应用程序可能产生的价值就越大，它可以容纳的用户数量也越多。
- en: Not every application needs to have the minimal possible responsiveness and
    the maximum achievable throughput. An application may be an asynchronous submit-and-go-do-something-else,
    which does not require much user interaction. There may be a few potential application
    users too, so a lower than average throughput could be more than enough. Yet,
    there are applications that have high requirements to one or both of these characteristics
    and cannot tolerate long pauses imposed by the GC process.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 并非每个应用程序都需要具有尽可能小的响应性和最大的吞吐量。一个应用程序可能是一个异步提交并执行其他任务的程序，这不需要太多的用户交互。也可能只有少数潜在的应用程序用户，因此低于平均的吞吐量可能已经足够。然而，有些应用程序对这两个特征中的一个或两个都有很高的要求，并且不能容忍GC过程强加的长时间暂停。
- en: GC, on the other hand, needs to stop any application execution to reassess the
    memory usage and to release it from data not used anymore. Such periods of GC
    activity are called stop-the-world. The longer they are, the quicker the GC does
    its job and the longer an application freeze lasts, which can eventually grow big
    enough to affect both the application responsiveness and throughput. If that is
    the case, the GC tuning and JVM optimization become important and require an understanding
    of the GC principles and its modern implementations.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: GC，另一方面，需要停止任何应用程序的执行以重新评估内存使用情况，并从不再使用的旧数据中释放它。这样的GC活动期间被称为“停止世界”。它们越长，GC完成其工作的速度就越快，应用程序冻结的时间就越长，最终可能会足够大，以至于影响应用程序的响应性和吞吐量。如果出现这种情况，GC调整和JVM优化就变得很重要，并且需要理解GC原则及其现代实现。
- en: Unfortunately, this step is often missed. Trying to improve responsiveness and/or
    throughput, companies and individuals just add memory and other computing capacities,
    thus providing the originally small existing problem with the space to grow. The
    enlarged infrastructure, in addition to hardware and software costs, requires
    more people to maintain it and eventually justifies the building of a whole new
    organization dedicated to keeping up the system. By then, the problem reaches
    the scale of becoming virtually unsolvable and feeds on those who have created
    it by forcing them to do the routine--almost menial--work for the rest of their
    professional lives.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这一步常常被忽略。为了提高响应速度和/或吞吐量，公司和个人只是增加内存和其他计算能力，从而为原本微小的现有问题提供了成长的空间。除了硬件和软件成本外，扩大后的基础设施还需要更多的人来维护，最终证明建立一个专门致力于维护系统的全新组织是合理的。到那时，问题已经达到几乎无法解决的规模，并依赖于那些创造了它的人，迫使他们在其余的专业生涯中做那些例行——几乎是琐事——的工作。
- en: In this chapter, we will focus on **Garbage-First** (**G1**) garbage collector
    that is going to be the default one in Java 9\. However, we'll also refer to a
    few other available GC implementations to contrast and explain some design decisions
    that have brought G1 to life. Besides, they might be more appropriate than G1
    for some of the systems.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将重点关注即将成为Java 9默认垃圾回收器的**Garbage-First**（**G1**）垃圾回收器。然而，我们也会参考一些其他可用的GC实现，以便对比和解释一些使G1得以实现的设计决策。此外，它们可能比G1更适合某些系统。
- en: Memory organization and management are very specialized and complex areas of
    expertise in JVM development. This book is not intended to address the implementation
    details on such a level. Our focus is on those aspects of GC that can help an
    application developer to tune it for the application needs by setting the corresponding
    parameters of the JVM runtime.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 内存组织和管理工作是JVM开发中非常专业和复杂的领域。本书的目的不是处理此类级别的实现细节。我们的重点是那些可以帮助应用程序开发者通过设置JVM运行时的相应参数来调整以适应应用程序需求的GC方面。
- en: There are two memory areas that are used by GC, heap and stack, which illustrate
    the main principle of any GC implementation. The first one is used by the JVM
    to allocate memory and store objects created by the program. When an object is
    created with the `new` keyword, it is allocated on the heap, and the reference
    to it is stored on the stack. The stack also stores primitive variables and references
    to heap objects that are used by the current method or thread. The stack operates
    in **Last-In-First-Out** (**LIFO**). The stack is much smaller than the heap,
    and only the GC reads it.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: GC使用两个内存区域，堆和栈，这说明了任何GC实现的主要原理。第一个区域由JVM用于分配内存并存储由程序创建的对象。当一个对象使用`new`关键字创建时，它被分配在堆上，而对其的引用则存储在栈上。栈还存储原始变量和当前方法或线程使用的堆对象的引用。栈以**后进先出**（**LIFO**）的方式操作。栈比堆小得多，只有GC读取它。
- en: 'Here is a slightly simplistic, but good enough for our purpose, high-level
    view of the main activity of any GC: walking through objects in the heap and removing
    those that don’t have any references in the stack.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个稍微简单化，但对我们目的来说足够好的，对任何GC主要活动的概述：遍历堆中的对象，并移除那些在栈中没有任何引用的对象。
- en: Understanding the G1 garbage collector
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解G1垃圾回收器
- en: 'The previous GC implementations include **Serial GC**, **Parallel GC**, and
    **Concurrent Mark-Sweep** (**CMS**) collector. They divide the heap into three
    sections: young generation, old or tenured generation, and humongous regions for
    holding the objects that are 50% the size of a standard region or larger. The
    young generation contains most of the newly created objects; this is the most
    dynamic area because a majority of the objects are short-lived and soon (as they
    age) become eligible for collection. The term age refers to the number of collection
    cycles the object has survived. The young generation has three collection cycles:
    an *Eden space* and two survivor spaces, such as survivor 0 (*S0*) and survivor
    1 (*S1*). The objects are moved through them (according to their age and some
    other characteristics) until they are eventually discarded or placed in the old
    generation.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: The old generation contains objects that are older than a certain age. This
    area is bigger than the young generation, and because of this, the garbage collection
    here is more expensive and happens not as often as in the young generation.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: The permanent generation contains metadata that describes the classes and methods
    used in applications. It also stores strings, library classes, and methods.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: When the JVM starts, the heap is empty and then the objects are pushed into
    Eden. When it is filling up, a minor GC process starts. It removes the unreferenced
    and circular referred objects and moves the others to the *S0* area.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: First, any new object is allocated to the Eden space. Both the survivor spaces
    start out empty. When the Eden space fills up, a minor garbage collection is triggered.
    Referenced objects are moved to the S0 space. Unreferenced objects are deleted.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: The next minor GC process migrates the referenced objects to *S1* and increments
    the age of those that survived the previous minor collection. After all the surviving
    objects (of different ages) are moved to *S1*, both *S0* and Eden become empty.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: In the next minor collection, *S0* and *S1* switch their roles. The referenced
    objects are moved from Eden to *S1* and *S1* to *S0*.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: In each of the minor collections, the objects that have reached a certain age
    are moved to the old generation. As we mentioned earlier, the old generation is
    checked eventually (after several minor collections), the unreferenced objects
    are removed from there, and the memory is defragmented. This cleaning of the old
    generation is considered a major collection.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: The permanent generation is cleaned at different times by different GC algorithms.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: The G1 GC does it somewhat differently. It divides the heap into equal-sized
    regions and assigns each of them one of the same roles--Eden, survivor, or old--but
    changes the number of regions with the same role dynamically, depending on the
    need. It makes the memory cleaning process and the memory defragmentation more
    predictable.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The serial GC cleans the young and the old generations in the same cycle (serially,
    thus the name). During the task, it stops the world. That is why it is used for
    non-server applications with one CPU and a heap size of a few hundred MB.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 序列GC在同一周期内清理年轻代和旧代（序列化，因此得名）。在任务期间，它会停止世界。这就是为什么它用于具有一个CPU和几百MB堆栈大小的非服务器应用程序。
- en: The parallel GC works in parallel on all available cores, although the number
    of threads can be configured. It also stops the world and is appropriate only
    for applications that can tolerate long freezing times.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 并行GC在所有可用核心上并行工作，尽管线程数可以配置。它也会停止世界，仅适用于可以容忍长时间冻结时间的应用程序。
- en: The CMS collector was designed to address this very issue of long pauses. It
    does it at the expense of not defragmenting the old generation and doing some
    analysis in parallel to the application execution (typically using 25% of CPU).
    The collection of old generation starts when it is 68% full (by default, but this
    value can be configured).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: CMS收集器是为了解决这个非常问题——长时间暂停。它是通过不碎片化旧代和与应用程序执行并行进行一些分析（通常使用25%的CPU）来实现的。当旧代达到68%满时（默认值，但此值可以配置）开始收集旧代。
- en: The G1 GC algorithm is similar to the CMS collector. First, it concurrently
    identifies all the referenced objects in the heap and marks them correspondingly.
    Then it collects the emptiest regions first, thus releasing a lot of free space.
    That's why it is called *Garbage-First*. Because it uses many small dedicated
    regions, it has a better chance in predicting the amount of time it needs to clean
    one of them and in fitting a user-defined pause time (G1 may exceed it occasionally,
    but it is pretty close most of the times).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: G1 GC算法与CMS收集器类似。首先，它并发地识别堆中所有引用的对象，并相应地标记它们。然后它首先收集最空旷的区域，从而释放大量空闲空间。这就是为什么它被称为*垃圾优先*。因为它使用许多小专用区域，它有更好的机会预测清理其中一个所需的时间，并适应用户定义的暂停时间（G1偶尔可能会超过它，但大多数时候非常接近）。
- en: The main beneficiaries of G1 are applications that require large heaps (6 GB
    or more) and that do not tolerate long pauses (0.5 sec or less). If an application
    encounters an issue of too many and/or too long pauses, it can benefit from switching
    from the CMS or parallel GC (especially the parallel GC of the old generation)
    to the G1 GC. If that is not the case, switching to the G1 collector is not a
    requirement for using JDK 9.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: G1的主要受益者是那些需要大堆栈（6 GB或更多）且不能容忍长时间暂停（0.5秒或更少）的应用程序。如果一个应用程序遇到太多和/或太长的暂停问题，它可以从切换到CMS或并行GC（尤其是旧代并行GC）到G1
    GC中受益。如果不是这种情况，切换到G1收集器不是使用JDK 9的必要条件。
- en: 'The G1 GC starts with the young generation collection using stop-the-world
    pauses for evacuation (moving objects inside the young generation and out to the
    old generation). After the occupancy of the old generation reaches a certain threshold,
    it is collected too. The collection of some of the objects in the old generation
    is done concurrently and some objects are collected using stop-the-world pauses. The
    steps include the following:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: G1 GC从使用停止世界暂停进行驱逐（将年轻代内部的对象移动到旧代）的年轻代收集开始。当旧代的占用达到一定阈值时，它也会被收集。旧代中一些对象的收集是并行的，一些对象是使用停止世界暂停收集的。步骤包括以下内容：
- en: The initial marking of the survivor regions (root regions), which may have references
    to objects in the old generation, done using stop-the-world pauses
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用停止世界暂停进行的幸存区域（根区域）的初始标记，这些区域可能引用旧代中的对象。
- en: The scanning of survivor regions for references to the old generation, done
    concurrently while the application continues to run
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在应用程序继续运行的同时，扫描幸存区域以查找对旧代对象的引用，这是并行的。
- en: The concurrent marking of live objects over the entire heap, done concurrently
    while the application continues to run
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在应用程序继续运行的同时，在整个堆上并发标记活对象。
- en: The remark step completes the marking of live objects, done using stop-the-world
    pauses
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 备注步骤完成了使用停止世界暂停进行的活对象标记。
- en: The cleanup process calculates the age of live objects, frees the regions (using
    stop-the-world pauses), and returns them to the free list (concurrently)
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 清理过程计算活对象的年龄，使用停止世界暂停释放区域，并将它们返回到空闲列表（并发）。
- en: The preceding sequence might be interspersed with young generation evacuations
    because most of the objects are short-lived and it is easier to free a lot of
    memory by scanning the young generation more often.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 由于大多数对象是短命的，并且通过更频繁地扫描年轻代可以更容易地释放大量内存，因此前面的序列可能会与年轻代撤离混合。
- en: There is also a mixed phase, when G1 collects the regions already marked as
    mostly garbage in both the young and old generations, and humongous allocation,
    when large objects are moved to or evacuated from humongous regions.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在混合阶段，当 G1 收集年轻代和旧生代中已标记为大部分垃圾的区域，以及巨大分配阶段，当大对象被移动到或从巨大区域撤离时，也存在混合阶段。
- en: 'There are a few occasions when full GC is performed, using stop-the-world pauses:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下情况下会执行完全垃圾收集，使用停止世界暂停：
- en: '**Concurrent failure**: This happens if the old generation gets full during
    the marking phase'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**并发失败**：如果在标记阶段旧生代已满，则发生这种情况。'
- en: '**Promotion failure**: This happens if the old generation runs out of space
    during the mixed phase'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**提升失败**：如果在混合阶段旧生代空间不足，则发生这种情况。'
- en: '**Evacuation failure**: This happens when the collector cannot promote objects
    to the survivor space and the old generation'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**撤离失败**：当收集器无法将对象提升到幸存空间以及旧生代时发生这种情况。'
- en: '**Humongous allocation**: This happens when an application tries to allocate
    a very big object'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**巨大分配**：当应用程序尝试分配一个非常大的对象时发生这种情况。'
- en: If tuned properly, your applications should avoid full GC.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果调整得当，您的应用程序应该避免完全垃圾收集。
- en: To help with GC tuning, the JVM documentation describes *ergonomics*--the process
    by which "*the JVM and garbage collection tuning, such as behavior-based tuning,
    improve application performance. The JVM provides platform-dependent default selections
    for the garbage collector, heap size, and runtime compiler. These selections match
    the needs of different types of applications while requiring less command-line
    tuning. In addition, behavior-based tuning dynamically tunes the sizes of the
    heap to meet a specified behavior of the application*" (from the JVM documentation).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助进行垃圾收集器调优，JVM 文档描述了**人体工程学**——这个过程是指“通过 JVM 和垃圾收集器调优，例如基于行为的调优，来提高应用程序性能。JVM
    为垃圾收集器、堆大小和运行时编译器提供了平台相关的默认选择。这些选择符合不同类型应用程序的需求，同时需要较少的命令行调整。此外，基于行为的调优会动态调整堆的大小以满足应用程序指定的行为”（来自
    JVM 文档）。
- en: How to do it...
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To see how GC works, write the following program:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要了解 GC 的工作原理，编写以下程序：
- en: '[PRE0]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As you can see, it creates 99,888,999 objects and adds them to the `List<AnObject>
    list` collection. You might tune it by decreasing the maximum number of objects
    (`max`) to match the configuration of your computer.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，它创建了 99,888,999 个对象并将它们添加到 `List<AnObject> list` 集合中。您可以通过减少最大对象数（`max`）来调整它，以匹配您计算机的配置。
- en: 'The G1 GC is the default collector in Java 9, so you don''t have to set anything
    if it is good enough for your application. Nevertheless, you can explicitly enable
    G1 by providing `-XX:+UseG1GC` on the command line (run in the same folder, where
    the executable `.jar` file is located, which contains the `com.packt.cookbook.ch12_memory.Chapter12Memory` class
    with the `main()` method):'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: G1 GC 是 Java 9 的默认收集器，所以如果它对您的应用程序足够好，您就不需要设置任何东西。不过，您可以通过在命令行上提供 `-XX:+UseG1GC`
    来显式启用 G1（在包含 `com.packt.cookbook.ch12_memory.Chapter12Memory` 类和 `main()` 方法的可执行
    `.jar` 文件所在的同一文件夹中运行）：
- en: '[PRE1]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note that we assume you can build an executable `.jar` file and understand the
    basic Java execution command. If not, please refer to the JVM documentation.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们假设您能够构建一个可执行的 `.jar` 文件并理解基本的 Java 执行命令。如果不能，请参阅 JVM 文档。
- en: 'Other available GCs can be used by setting one of the following options:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过设置以下选项之一来使用其他可用的垃圾收集器：
- en: '`-XX:+UseSerialGC` for using a Serial collector.'
  id: totrans-59
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `-XX:+UseSerialGC` 来使用串行收集器。
- en: '`-XX:+UseParallelGC` for using parallel collector with parallel compaction
    (which enables the parallel collector to perform major collections in parallel).
    Without parallel compaction, major collections are performed using a single thread,
    which can significantly limit the scalability. Parallel compaction is disabled
    by the `-XX:+UseParallelOldGC` option.'
  id: totrans-60
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `-XX:+UseParallelGC` 来使用具有并行压缩的并行收集器（这使并行收集器能够并行执行主要收集）。如果没有并行压缩，主要收集将使用单个线程执行，这可能会显著限制可伸缩性。通过
    `-XX:+UseParallelOldGC` 选项禁用并行压缩。
- en: '`-XX:+UseConcMarkSweepGC` for using the CMS collector.'
  id: totrans-61
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `-XX:+UseConcMarkSweepGC` 来使用 CMS 收集器。
- en: 'To see the log messages of GC, set `-Xlog:gc`. You can also use the Unix utility, `time`,
    to measure the time it took to do the job (the utility publishes the last three
    lines of the output, so you do not need to use it if you cannot or do not want
    to do it):'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要查看GC的日志消息，设置`-Xlog:gc`。您还可以使用Unix实用程序`time`来测量完成任务所需的时间（实用程序发布输出中的最后三行，因此如果您不能或不想这样做，则不需要使用它）：
- en: '[PRE2]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Run the preceding command, the result may look as follows (the actual values
    may be different on your computer):'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行前面的命令，结果可能如下（实际值可能因您的计算机而异）：
- en: '![](img/cfe1bbe4-a376-451b-8a77-0f84e2042647.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cfe1bbe4-a376-451b-8a77-0f84e2042647.png)'
- en: You can see that the GC went through most of the steps we have described. It
    has started with collecting the young generation. Then, when the `List<AnObject>
    list` object (see the preceding code) becomes too big (more than 50% of a young
    generation region), the memory for it is allocated in the *humongous* region.
    You can also see the initial mark step and the following remark and other steps
    described earlier.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到GC走过了我们描述的大多数步骤。它从收集年轻代开始。然后，当`List<AnObject> list`对象（参见前面的代码）变得太大（超过年轻代区域的50%）时，为其分配的内存位于*巨大*区域。您还可以看到初始标记步骤以及随后的重标记和其他之前描述的步骤。
- en: 'Each line starts with an accumulative time amount (in seconds) the JVM was
    running for and ends with the time (in milliseconds) that every step took. At
    the bottom of the screenshot we see three lines printed by the `time` utility:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 每一行都以JVM运行的总时间（以秒为单位）开始，并以每个步骤花费的时间（以毫秒为单位）结束。在截图底部，我们看到由`time`实用程序打印的三个行：
- en: '`real` is the amount of wall clock time spent--all the time elapsed (should
    align with the first column of the JVM uptime value) since the command was run'
  id: totrans-68
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`real`表示花费的墙钟时间——自命令运行以来经过的所有时间（应与JVM运行时间的第一列对齐）'
- en: '`user` is the amount of time all the CPUs spent in the user-mode code (outside
    the kernel) within the process; it is bigger because GC worked concurrently with
    the application'
  id: totrans-69
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`user`表示进程在用户模式代码（内核外）中所有CPU花费的时间；它更大是因为GC与应用程序并发工作'
- en: '`sys` is the amount of time the CPU spent in the kernel within the process'
  id: totrans-70
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sys`表示CPU在进程内核中花费的时间'
- en: '`user`+`sys` is the amount of CPU time the process used'
  id: totrans-71
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`user`+`sys`表示进程使用的CPU时间'
- en: 'Set the `-XX:+PrintGCDetails` option (or just add a `*` to the log option `-Xlog:gc*`)
    to see more details about GC activity (in the following screenshot, we provide
    only the beginning of the log related to GC step 0):'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置`-XX:+PrintGCDetails`选项（或只需在日志选项`-Xlog:gc*`中添加一个`*`）以查看GC活动的更多细节（在以下截图，我们只提供了与GC步骤0相关的日志开头）：
- en: '![](img/4548fcf5-7594-422b-98d0-4d6f6570523b.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4548fcf5-7594-422b-98d0-4d6f6570523b.png)'
- en: Now the log has more than a dozen entries for each of the GC steps and ends
    up with logging the `User`, `Sys`, and `Real` amount of time (the amounts accumulated
    by the `time` utility) each step took. You can modify the program (by adding more
    short-lived objects, for example) and see how the GC activity changes.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在日志中每个GC步骤都有十几个条目，并以记录每个步骤所花费的`User`、`Sys`和`Real`时间（由`time`实用程序累积的数量）结束。您可以通过添加更多短生命周期的对象（例如）来修改程序，并查看GC活动如何变化。
- en: 'Get even more information with the `-Xlog:gc*=debug` option (the following
    is a fragment only):'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`-Xlog:gc*=debug`选项（以下仅为片段）获取更多信息：
- en: '![](img/7e2430e5-bac7-4cdc-9758-b1f48116cd4c.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7e2430e5-bac7-4cdc-9758-b1f48116cd4c.png)'
- en: So, it is up to you to choose how much info you need for the analysis.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，选择您需要多少信息进行分析取决于您。
- en: We will discuss more details of the logging format and other log options in
    the following recipe, *Unified logging for JVM*, of this chapter.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章的下一个配方“JVM的统一日志”中讨论日志格式和其它日志选项的更多细节。
- en: How it works...
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'As we had mentioned earlier, the G1 GC uses default ergonomic values that probably
    would be good enough for most applications. Here is the list of the most important
    ones (`<ergo>` means that the actual value is determined ergonomically depending
    on the environment):'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前提到的，G1 GC使用默认的人体工程学值，这可能是大多数应用程序足够好的。以下是其中最重要的列表（`<ergo>`表示实际值根据环境以人体工程学方式确定）：
- en: '`-XX:MaxGCPauseMillis=200` holds the value for the maximum pause time'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-XX:MaxGCPauseMillis=200`保存最大暂停时间的值'
- en: '`-XX:GCPauseTimeInterval=<ergo>` holds the maximum pause time between GC steps
    (not set by default, allowing G1 to perform garbage collections back to back if
    need be)'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-XX:GCPauseTimeInterval=<ergo>`保存GC步骤之间的最大暂停时间（默认未设置，允许G1在需要时连续执行垃圾回收）'
- en: '`-XX:ParallelGCThreads=<ergo>` holds the maximum number of threads used for
    parallel work during garbage collection pauses (by default, derived from the number
    of available threads; if the number of CPU threads available to the process is
    less than or equal to 8, it uses this number; otherwise, it adds five-eighths
    of the threads greater than 8 to the final number of threads)'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-XX:ParallelGCThreads=<ergo>` 保存在垃圾收集暂停期间用于并行工作的最大线程数（默认情况下，从可用的线程数派生；如果进程可用的
    CPU 线程数小于或等于 8，则使用此数量；否则，将大于 8 的线程的八分之五添加到最终的线程数）。'
- en: '`-XX:ConcGCThreads=<ergo>` holds the maximum number of threads used for concurrent
    work (set by default as `-XX:ParallelGCThreads` divided by 4).'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-XX:ConcGCThreads=<ergo>` 保存用于并发工作的最大线程数（默认设置为 `-XX:ParallelGCThreads` 除以
    4）。'
- en: '`-XX:+G1UseAdaptiveIHOP` indicates that the initiating heap occupancy should
    be adaptive'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-XX:+G1UseAdaptiveIHOP` 表示初始化堆占用应该是自适应的。'
- en: '`-XX:InitiatingHeapOccupancyPercent=45` sets the first few collection cycles;
    G1 will use an occupancy of 45% of the old generation as the mark start threshold'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-XX:InitiatingHeapOccupancyPercent=45` 设置前几个收集周期；G1 将使用旧生代的 45% 占用率作为标记开始阈值。'
- en: '`-XX:G1HeapRegionSize=<ergo>` holds the heap region size based on the initial
    and maximum heap sizes (by default, because heap contains roughly 2048 heap regions,
    the size of a heap region can vary from 1 to 32 MB and must be a power of 2)'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-XX:G1HeapRegionSize=<ergo>` 保存基于初始和最大堆大小的堆区域大小（默认情况下，因为堆包含大约 2048 个堆区域，堆区域的大小可以从
    1 MB 到 32 MB 不等，且必须是 2 的幂）。'
- en: '`-XX:G1NewSizePercent=5` and`-XX:XX:G1MaxNewSizePercent=60` define the size
    of the young generation in total, which varies between these two values as percentages
    of the current JVM heap in use'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-XX:G1NewSizePercent=5` 和 `-XX:G1MaxNewSizePercent=60` 定义了年轻代的总大小，这两个值作为当前使用的
    JVM 堆大小的百分比之间变化。'
- en: '`-XX:G1HeapWastePercent=5` holds the allowed unreclaimed space in the collection
    set candidates as a percentage (G1 stops the space reclamation if the free space
    in the collection set candidates is lower than that)'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-XX:G1HeapWastePercent=5` 保存收集集合候选者中允许未回收空间的比例（如果收集集合候选者的空闲空间低于此值，G1 将停止空间回收）。'
- en: '`-XX:G1MixedGCCountTarget=8` holds the expected length of the space-reclamation
    phase in a number of collections)'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-XX:G1MixedGCCountTarget=8` 保存空间回收阶段预期的长度，以收集次数计。'
- en: '`-XX:G1MixedGCLiveThresholdPercent=85` holds the percentage of the live object
    occupancy of the old generation regions, after which a region won''t to be collected
    in this space-reclamation phase'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-XX:G1MixedGCLiveThresholdPercent=85` 保存旧生代区域中活动对象占用的百分比，在此之后，该区域将不会在此空间回收阶段被收集。'
- en: In general, the G1 goals in the default configuration are *to provide relatively
    small, uniform pauses at high throughput *(from the G1 documentation). If these
    default settings do not fit your application, you can change the pause time (using
    `-XX:MaxGCPauseMillis`) and the maximum Java heap size (using the `-Xmx` option).
    Note, though, that the actual pause time will not be an exact match at runtime,
    but G1 will try its best to meet the goal.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，G1 在默认配置中的目标是*在高吞吐量下提供相对较小、均匀的暂停时间*（来自 G1 文档）。如果这些默认设置不适合您的应用程序，您可以更改暂停时间（使用
    `-XX:MaxGCPauseMillis`）和最大 Java 堆大小（使用 `-Xmx` 选项）。请注意，尽管如此，实际暂停时间在运行时可能不会完全匹配，但
    G1 将尽力达到目标。
- en: If you would like to increase the throughput, decrease the pause time goal or
    request a larger heap. To increase responsiveness, change the pause time value.
    Note, though, that the limiting of the young generation size (using the `-Xmn`,
    `-XX:NewRatio`, or other options) can impede the pause time control because *the
    young generation size is the main means for G1 to allow it to meet the pause time *(from
    the G1 documentation).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想提高吞吐量，可以降低暂停时间目标或请求更大的堆。为了提高响应性，可以更改暂停时间值。请注意，尽管如此，使用 `-Xmn`、`-XX:NewRatio`
    或其他选项限制年轻代大小可能会妨碍暂停时间控制，因为*年轻代大小是 G1 允许其满足暂停时间的主要手段*（来自 G1 文档）。
- en: 'One of the first possible causes of poor performance can be full GC in the
    presence of pause full (allocation failure) in the log. It usually happens when
    too many objects are created in a quick succession (and cannot be collected quickly
    enough) or many large (humongous) objects cannot be allocated in a timely manner.
    There are several recommended ways to handle this condition:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 一个可能的原因是，在日志中出现暂停全 GC（分配失败）时性能不佳。这通常发生在短时间内创建了太多对象（并且不能快速收集）或者许多大（巨大）对象不能及时分配的情况下。有几种推荐的处理此情况的方法：
- en: In the case of an excessive number of humongous objects, try to reduce their
    count by increasing the region size, using the `-XX:G1HeapRegionSize` option (the
    currently selected heap region size is printed at the beginning of the log).
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在大量巨型对象过多的情况下，尝试通过增加区域大小，使用 `-XX:G1HeapRegionSize` 选项（当前选定的堆区域大小在日志开头打印）来减少它们的数量。
- en: Increase the size of the heap.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 增加堆的大小。
- en: Increase the number of concurrent marking threads by setting `-XX:ConcGCThreads`.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过设置 `-XX:ConcGCThreads` 来增加并发标记线程的数量。
- en: Facilitate the beginning of marking earlier (using the fact that G1 makes the
    decisions based on earlier application behavior). Increase the buffer used in
    an adaptive IHOP calculation by modifying `-XX:G1ReservePercent`, or disable the
    adaptive calculation of the IHOP by setting it manually using `-XX:-G1UseAdaptiveIHOP`
    and `-XX:InitiatingHeapOccupancyPercent`.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 促进标记开始得更早（利用 G1 基于早期应用程序行为做出决策的事实）。通过修改 `-XX:G1ReservePercent` 来增加自适应 IHOP 计算中使用的缓冲区，或者通过使用
    `-XX:-G1UseAdaptiveIHOP` 和 `-XX:InitiatingHeapOccupancyPercent` 手动设置来禁用自适应的 IHOP
    计算。
- en: 'Only after addressing full GC can one start tuning the JVM for better responsiveness
    and/or throughput. The JVM documentation identifies the following cases for responsiveness
    tuning:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 仅在解决完全 GC 之后，才能开始调整 JVM 以获得更好的响应性和/或吞吐量。JVM 文档确定了以下响应性调整案例：
- en: Unusual system or real-time usage
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不寻常的系统或实时使用
- en: Reference processing takes too long
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引用处理时间过长
- en: Young-only collections take too long
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅年轻代收集耗时过长
- en: Mixed collections take too long
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 混合收集耗时过长
- en: High update RS and scan RS times
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高更新 RS 和扫描 RS 时间
- en: Better throughput can be achieved by decreasing the overall pause times and
    the frequency of the pauses. Refer to the JVM documentation for the identification
    and recommendations of mitigating the issues.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 通过减少整体暂停时间和暂停频率，可以获得更好的吞吐量。请参考 JVM 文档以识别和获得缓解问题的建议。
- en: See also
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'Do refer to the following recipes in this chapter:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考本章中的以下食谱：
- en: Unified logging for JVM
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JVM 统一日志
- en: Using the new diagnostic commands for the JVM
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 JVM 的新诊断命令
- en: Some best practices for better memory usage
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些提高内存使用效率的最佳实践
- en: Unified logging for JVM
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JVM 统一日志
- en: 'Java 9 implemented *JEP 158: Unified JVM Logging*, which requested to *introduce
    a common logging system for all the components of the JVM.* The main components
    of JVM include the following:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 'Java 9 实现了 *JEP 158: Unified JVM Logging*，该提案要求 *为 JVM 的所有组件引入一个共同的日志系统*。JVM
    的主要组件包括以下内容：'
- en: Class loader
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类加载器
- en: Runtime data area
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行时数据区域
- en: Stack area
  id: totrans-115
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 栈区域
- en: Method area
  id: totrans-116
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法区
- en: Heap area
  id: totrans-117
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 堆区域
- en: PC registers
  id: totrans-118
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: PC 寄存器
- en: Native method stack
  id: totrans-119
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原生方法栈
- en: Execution engine
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行引擎
- en: Interpreter
  id: totrans-121
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释器
- en: The JIT compiler
  id: totrans-122
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: JIT 编译器
- en: Garbage collection
  id: totrans-123
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 垃圾收集
- en: Native method interface JNI
  id: totrans-124
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原生方法接口 JNI
- en: Native method library
  id: totrans-125
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原生方法库
- en: The log message of all these components can now be captured and analyzed using
    unified logging, turned on by the `-Xlog` option.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些组件的日志消息现在都可以通过统一日志捕获和分析，统一日志由 `-Xlog` 选项开启。
- en: 'The main features of the new logging system are as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 新的日志系统的主要特点如下：
- en: Usage of the log levels: `trace`, `debug`, `info`, `warning`, `error`
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用日志级别：`trace`、`debug`、`info`、`warning`、`error`
- en: Message tags that identify the JVM component, action, or message of a specific
    interest
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消息标签，用于标识 JVM 组件、动作或特定感兴趣的消息
- en: 'Three output types: `stdout`, `stderr`, and `file`'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 三种输出类型：`stdout`、`stderr` 和 `file`
- en: The enforcement of the one-message-per-line limit
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对每行一条消息的限制执行
- en: Getting ready
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To see all the logging possibilities at a glance, you can run the following
    command:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 要快速查看所有日志可能性，您可以运行以下命令：
- en: '[PRE3]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Here is the output:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是输出：
- en: '![](img/258604c0-9b0a-475b-9910-ef90d7eb1de8.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/258604c0-9b0a-475b-9910-ef90d7eb1de8.png)'
- en: 'As you can see, the format of the `-Xlog` option is defined as follows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`-Xlog` 选项的格式定义如下：
- en: '[PRE4]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Let''s explain the option in detail:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细解释这个选项：
- en: The `what` is a combination of tags and levels of the form, `tag1[+tag2...][*][=level][,...]`.
    We have already demonstrated how this construct works when we used the `gc` tag
    in the `-Xlog:gc*=debug` option. The wildcard (`*`) indicates that you'd like to
    see all the messages that have the `gc` tag (maybe among other tags). An absence
    of the `-Xlog:gc=debug` wildcard indicates that you would like to see messages
    marked by one tag (`gc`, in this case) only. If only `-Xlog` is used, the log
    will show all the messages at the `info` level.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `output` sets the type of output (the default is `stdout`).
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `decorators` indicate what will be placed at the beginning of each line
    of the log (before the actual log message comes from a component). Default decorators
    are `uptime`, `level`, and `tags`, each included in square brackets.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `output_options` may include `filecount=file count` and/or `filesize=file
    size with optional K, M or G suffix`.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To summarize, the default log configuration is as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: How to do it...
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s run some of the log settings, which are as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: There are no messages because the JVM does not log messages with the `cpu` tag
    only. The tag is used in combination with other tags.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a `*` sign and run the command again:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The result will look as follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/16f1ff6c-ca64-4b7f-82ac-69c0d9b95fda.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
- en: As you can see, the tag `cpu` brings only messages that log time it took a garbage
    collection task to execute. Even if we set the log level to `trace` or `debug`
    (`-Xlog:cpu*=debug`, for example), no other messages will be shown.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: 'Now run the command with the `heap` tag:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You will only get heap-related messages:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4d03c1fc-819c-4465-9633-831172e782c5.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
- en: But let's look closer at the first line. It starts with three decorators--`uptime`,
    `log` level, and `tags`--and then with the message itself, which starts with the
    collection cycle number (0 in this case) and the information that the number of
    Eden regions dropped from 24 to 0 (and their count now is 9). It happened because
    (as we see in the next line) the count of survivor regions grew from 0 to 3 and
    the count of the old generation (the third line) grew to 18, while the count of
    humongous regions (23) did not change. These are all the heap-related messages
    in the first collection cycle. Then, the second collection cycle starts.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `cpu` tag again and run:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'As you can see, the `cpu` message shows how long each cycle took:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5fd27d43-9a39-4bcb-bcb3-c63004018638.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
- en: Try and use two tags combined via sign `+` (`-Xlog:gc+heap`, for example). It
    brings up only the messages that have both tags (similar to the binary `AND` operation).
    Notice that a wildcard will not work together with the `+` sign (`-Xlog:gc*+heap` ,
    for example, does not work).
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You can also select the output type and decorators. In practice, the decorator
    level does not seem very informative and can be easily omitted by explicitly listing
    only the decorators that are needed. Consider the following example:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Note how the two colons (`:`) were inserted to preserve the default setting
    of the output type. We could also show it explicitly:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'To remove any decoration, one can set them to `none`:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The most useful aspect of a new logging system is tag selection. It allows a
    better analysis of the memory evolution of each JVM component and its subsystems
    or to find the performance bottleneck, analyzing the time spent in each collection
    phase--both are critical for the JVM and application tuning.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Do refer to the other recipes of this chapter:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: Using the new diagnostic commands for the JVM
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stack walking for improved debugging
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some best practices for better memory usage
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the new diagnostic commands for the JVM
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you open the `bin` folder of the Java installation, you can find there quite
    a few command-line utilities that can be used to diagnose issues and monitor an
    application deployed with the **Java Runtime Environment** (**JRE**). They use
    different mechanisms to get the data they report. The mechanisms are specific
    to the **Virtual Machine** (**VM**) implementation, operating systems, and release.
    Typically, only a subset of the tools is applicable to a given issue at a particular
    time.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: 'In this recipe, we will focus on the new diagnostic commands introduced in
    Java 9, some of them listed in *JEP 228: Add More Diagnostic Commands* (the actual
    command names are slightly different than in JEP). The new diagnostic commands
    were implemented as commands of the command-line utility, `jcmd`. You can find
    this utility in the same `bin` folder of the Java installation and can invoke
    it (if this folder is on the path) just by typing `jcmd` on the command prompt.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: 'If you do type it and there is no Java process currently running on the machine,
    you will get back only one line, which looks as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: It shows that only one Java process is currently running (the `jcmd` utility
    itself) and it has the **process identifier** (**PID**) 87863 (which will be different
    with each run).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s run another Java program, for example:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The output of `jcmd` will show (with different PIDs) the following:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'As you can see, if entered without any options, the `jcmd` utility reports
    the PIDs of all the currently running Java processes. After getting the PID, you
    can then use `jcmd` to request data from the JVM that runs the process:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Alternatively, you can avoid using PID (and calling `jcmd` without parameters)
    by referring to the process by the main class of the application:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: You can read the JVM documentation for more details about the `jcmd` utility
    and how to use it. In this recipe, we will focus only on the new diagnostic commands
    that came with Java 9.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Get the full list of the available `jcmd` commands by running the following
    line:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Instead of `PID/main-class`, put the process identifier or the main class name. The
    list is specific to the JVM, so the command requests the data from the specific
    process.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: 'If you can, compile the same class with JDK 8 and with JDK 9 and run the preceding
    command for each of the JSK versions. This way, you can compare the lists and
    see that JDK 9 introduced the following new `jcmd` commands:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Compiler.queue`: This prints the methods queued for compilation with either
    C1 or C2 (separate queues)'
  id: totrans-198
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Compiler.codelist`: This prints n-methods (compiled) with full signature,
    address range, and state (alive, non-entrant, and zombie) and allows the selection
    of printing to `stdout` , a file, XML, or text printout'
  id: totrans-199
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Compiler.codecache`: This prints the content of the code cache, where the
    JIT compiler stores the generated native code to improve performance'
  id: totrans-200
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Compiler.directives_add file`: This adds compiler directives from a file to
    the top of the directives stack'
  id: totrans-201
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Compiler.directives_clear`: This clears the compiler directives stack (leaves
    the default directives only)'
  id: totrans-202
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Compiler.directives_print`: This prints all the directives on the compiler
    directives stack from top to bottom'
  id: totrans-203
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Compiler.directives_remove`: This removes the top directive from the compiler
    directives stack'
  id: totrans-204
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GC.heap_info`: This prints the current heap parameters and status'
  id: totrans-205
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GC.finalizer_info`: This shows the status of the finalizer thread, which collects
    objects with a finalizer (that is, a `finalize()` method)'
  id: totrans-206
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`JFR.configure`: This allows configuring the Java Flight Recorder'
  id: totrans-207
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`JVMTI.data_dump`: This prints the Java Virtual Machine Tool Interface data
    dump'
  id: totrans-208
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`JVMTI.agent_load`: This loads (attaches) the Java Virtual Machine Tool Interface agent'
  id: totrans-209
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ManagementAgent.status`: This prints the status of the remote JMX agent'
  id: totrans-210
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Thread.print`: This prints all the threads with stack traces'
  id: totrans-211
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VM.log [option]`: This allows setting the JVM log configuration (which we
    described in the previous recipe) at runtime, after the JVM has started (the availability
    can be seen by using `VM.log list`)'
  id: totrans-212
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VM.info`: This prints the unified JVM info (version and configuration), a
    list of all threads and their state (without thread dump and heap dump), heap
    summary, JVM internal events (GC, JIT, safepoint, and so on), memory map with
    loaded native libraries, VM arguments and environment variables, and details of
    the operation system and hardware'
  id: totrans-213
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VM.dynlibs`: This prints information about dynamic libraries'
  id: totrans-214
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VM.set_flag`: This allows setting the JVM *writable* (also called *manageable*)
    flags (see the JVM documentation for a list of the flags)'
  id: totrans-215
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VM.stringtable` and `VM.symboltable`: These print all UTF-8 string constants'
  id: totrans-216
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VM.class_hierarchy [full-class-name]`: This prints all the loaded classes
    or just a specified class hierarchy'
  id: totrans-217
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VM.classloader_stats`: This prints information about the classloader'
  id: totrans-218
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VM.print_touched_methods`: This prints all the methods that have been touched
    at runtime'
  id: totrans-219
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see, these new commands belong to several groups, denoted by the
    prefix compiler, **garbage collector** (**GC**), **Java Flight Recorder** (**JFR**), **Java
    Virtual Machine Tool Interface** (**JVMTI**),  **Management Agent** (related to
    remote JMX agent), thread, and VM. In this book, we do not have enough space to
    go through each command in detail. We will only demonstrate the usage of a few
    most practical ones.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To get help for the `jcmd` utility, run the following command:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Here is the result of the command:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e7685cf9-19f1-4481-89a9-bc91acfa45bb.png)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
- en: It tells us that the commands can also be read from the file specified after
    `-f` and that there is a `PerfCounter.print` command, which prints all the performance
    counters (statistics) of the process.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s run the following command:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The output may look as follows:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/771a97b3-6d9b-47bd-abc0-f7646c33df72.png)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
- en: It shows the total heap size and how much of it was used, the size of a region
    in the young generation and how many regions are allocated, and the parameters
    of `Metaspace` and `class space`.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: 'The following command is very helpful in case you are looking for runaway threads
    or would like to know what else is going on behind the scenes:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Here is a fragment of the possible output:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/12ccab5c-ce62-486b-836a-46a9e2d45970.png)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
- en: 'The following command is probably used most often, as it produces a wealth
    of information about the hardware, the JVM process as a whole, and the current
    state of its components:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'It starts with a summary, as follows:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/07ee898d-cf7c-497d-a978-d155e6463417.png)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
- en: 'Then the general process description follows:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b42a94c1-15af-4c1c-bdc0-8a8d9d6bca9d.png)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
- en: 'Then come the details of the heap (this is only a tiny fragment of it):'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/37456028-8bd0-4b9b-bdb4-21b7724e6d9a.png)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
- en: It then prints the compilation events, GC heap history, deoptimization events,
    internal exceptions, events, dynamic libraries, logging options, environment variables, VM
    arguments, and many parameters of the system running the process.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: The `jcmd` commands give a deep insight into the JVM process, which helps us
    debug and tune the process for best performance and optimal resource usage.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Do refer to the other recipes of this chapter:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: Stack walking for improved debugging
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some best practices for better memory usage
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Try with resources for better resource handling
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Managing resources is important. Here is an excerpt from the JDK 7 documentation:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '"The typical Java application manipulates several types of resources such as
    files, streams, sockets, and database connections. Such resources must be handled
    with great care, because they acquire system resources for their operations. Thus,
    you need to ensure that they get freed even in case of errors. Indeed, incorrect
    resource management is a common source of failures in production applications,
    with the usual pitfalls being database connections and file descriptors remaining
    opened after an exception has occurred somewhere else in the code. This leads
    to application servers being frequently restarted when resource exhaustion occurs,
    because operating systems and server applications generally have an upper-bound
    limit for resources."'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: 'The phrase *because they acquire system resources for their operations* is
    the key. It means that mishandling (not releasing) the resources can exhaust the
    system''s capability to operate. That''s why, in JDK 7  the *try-with-resources*
    statement was introduced and we used it in the examples of [Chapter 6](41632f15-3abe-4f59-8ce9-009aacfbe1cf.xhtml),
    *Database Programming*:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Another variation of the same statement is to include the acquisition of both
    the resources into the same `try` block:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'As a reminder, we used the `getDbConnection()` and `createStatement()` methods.
    Here is the `getDbConnection()` method:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Here is the `createStatement()` method:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This was very helpful, but in some cases, we were still required to write extra
    code in old style. For example, if there is an  `execute()` method that accepts
    a `Statement` object as a parameter, and we would like to release (close) it as
    soon as it was used. In such a case, the code will look as follows:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: As you can see, most of it is just boilerplate copy-and-paste code.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: The new *try-with-resources* statement (coming with Java 9) addresses this case
    by allowing effectively-final variables to be used as resources in the *try-with-resources*
    statement.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Rewrite the previous example using the new *try-with-resources* statement:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: As you can see, it is much more concise and focused, without the need of repeatedly
    writing trivial code that closes the resource. No more `finally` and extra `try...catch`
    in it.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: 'Try and write it so that it closes the connection as soon as it was used:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: It may or may not fit your application connection handling, but often, this
    capability is handy.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: 'Try a different combination, such as the following:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'You can also try this combination:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The new statement provides more flexibility to write code that fits the needs
    without writing lines to close the resource.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: 'The only requirements are as follows:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: The variable included in the `try` statement has to be final or effectively
    final
  id: totrans-278
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The resource has to implement the `AutoCloseable` interface , which includes
    only one method:'
  id: totrans-279
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: How it works...
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To demonstrate how the new statement works, let's create our own resources that
    implement `AutoCloseable` and use them in a fashion similar to the resources of
    the previous examples.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is one resource:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Here is the second resource:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Let''s use them in the code example:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'If we run it, the result will be as follows:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1b617582-087d-4a90-996f-04c642c55a41.png)'
  id: totrans-290
  prefs: []
  type: TYPE_IMG
- en: 'Note that the resource listed first in the `try` statement is closed last.
    If we make only one change and switch the order in the `try` statement:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The output confirms it:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/aeb523cc-3d63-4076-843a-a827cbb6c280.png)'
  id: totrans-294
  prefs: []
  type: TYPE_IMG
- en: This rule of closing the resources in the reverse order addresses the most important
    possible issue of dependency between resources, but it is up to the programmer
    to define the sequence of closing the resources (by listing them in the `try` statement
    in the correct order). Fortunately, the closing of most standard resources is
    handled by the JVM gracefully, and the code does not break if the resources are
    listed in incorrect order. Still, it is a good idea to list them in the same sequence
    as they were created.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Do refer to the other recipes of this chapter:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: Some best practices for better memory usage
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stack walking for improved debugging
  id: totrans-299
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Stack trace can be very helpful in figuring out the source of the problem, although
    the need to read it is usually caused by some unpleasant surprise. Once in a while,
    especially in a big and complex system, the need arises to read it programmatically
    when an automatic correction is possible.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: 'Since Java 1.4, the current stack trace can be accessed via the `java.lang.Thread`
    and `java.lang.Throwable` classes. To any method of your code, you can add the
    following line:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'You can also add the following line:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'It will print the stack trace to the standard output. Alternatively, since
    Java 8, you can use any of the following lines for the same effect:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'You can use the stack trace to find the fully qualified name of the caller
    class, using one of these lines:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'All the aforementioned lines are possible because of the `java.lang.StackTraceElement` class,
    which represents a stack frame in a stack trace. This class provides other methods
    that describe the execution point represented by this stack trace element, which
    allows programmatic access to the stack trace information. For example, you can
    run this code snippet from anywhere in your program:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'You can also run this one from anywhere in the program:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: In either case, you can see how much information you get. Unfortunately, this
    wealth of data comes with a price. The JVM captures the entire stack (except for
    hidden stack frames), and it may affect the performance, while the chances are
    that you only need a fraction of this data (like in the preceding example where
    we use only one element of the stack trace array).
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: This is where the new Java 9 class, `java.lang.StackWalker`, with its nested
    `Option` class and `StackFrame` interface, comes in handy.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-315
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `StackWalker` class has four variants of the static factory method, `getInstance()`,
    which are different only in their ability to take one of the following several
    options or no options at all:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: '`StackWalker getInstance()`: This is configured to skip all the hidden frames
    and no caller class reference.'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`StackWalker getInstance(StackWalker.Option option)`: This creates an instance
    with the given option, specifying the stack frame information it can access.'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`StackWalker getInstance(Set<StackWalker.Option> options)`: This creates an
    instance with the given set of options, specifying the stack frame information
    it can access. If the given set is empty, the instance is configured exactly like
    an instance of `StackWalker getInstance()`.'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`StackWalker getInstance(Set<StackWalker.Option> options, int estimatedDepth)`:
    This creates a similar instance as the preceding one and accepts the `estimatedDepth`
    parameter, which specifies the estimated number of stack frames this instance
    will traverse so that it can estimate the buffer size it might need.'
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'One of the following values is passed as an option:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: '`StackWalker.Option.RETAIN_CLASS_REFERENCE`'
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`StackWalker.Option.SHOW_HIDDEN_FRAMES`'
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`StackWalker.Option.SHOW_REFLECT_FRAMES`'
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `StackWalker` class also has three methods:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: '`T walk(Function<Stream<StackWalker.StackFrame>, T> function)`: This applies
    the given function to the stream of `StackFrames` for the current thread, traversing
    from the top frame of the stack, which is the method calling this walk method.'
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void forEach(Consumer<StackWalker.StackFrame> action)`: This performs the
    given action on each element of the `StackFrame` stream of the current thread,
    traversing from the top frame of the stack, which is the method calling the `forEach`
    method. This method is equivalent to calling `walk(s -> { s.forEach(action); return
    null; })`.'
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Class<?> getCallerClass()`: This gets the `Class` object of the caller that
    invoked the method that invoked `getCallerClass()`. This method throws `UnsupportedOperationException`
    if this `StackWalker` instance is not configured with the `RETAIN_CLASS_REFERENCE`
    option.'
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-329
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Create several classes and methods that will call each other, so you can perform
    stack trace processing.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `Clazz01` class:'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Create a `Clazz02` class:'
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Create a `Clazz03` class:'
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Write a `demo4_StackWalk()` method:'
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Call this method from the main method of the `Chapter12Memory` class:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'If we run now the `Chapter12Memory` class, the result will be as follows:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e3941b47-746b-4bdc-8b6f-6685b1ec985a.png)'
  id: totrans-342
  prefs: []
  type: TYPE_IMG
- en: The message, `Do something`, is passed from `Clazz01` and printed out in `Clazz03`.
    Then `Clazz02` passes null to `Clazz03`, and the message, `Throw the exception:`,
    is printed out before the stack trace caused by the `NullPointerException` from
    the `action.toString();` line.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-344
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For a deeper understanding of the concepts here, let''s modify `Clazz03`:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The result will be the following:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c0289bc5-b946-4518-b1c2-b60fe74ac929.png)'
  id: totrans-348
  prefs: []
  type: TYPE_IMG
- en: 'Alternatively, we can get a similar output by using `Throwable` instead of
    `Thread`:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'It does look very familiar:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ec4edfae-5d60-48ce-9241-401f08f00299.png)'
  id: totrans-352
  prefs: []
  type: TYPE_IMG
- en: 'A similar result will produce each of the following two lines:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Now with Java 9, the same output is achieved by using the `StackWalker` class.
    Let''s look at what happens if we modify `Clazz03` as follows:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The result will be the same:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/80e70b00-e7ae-4f08-ab66-e8c67621b1ad.png)'
  id: totrans-358
  prefs: []
  type: TYPE_IMG
- en: 'However, contrary to the full stack trace generated and stored in an array
    in the memory, the `StackWalker` class only brings the requested elements. This
    is already a big plus. However, `StackWalker` shows the biggest advantage when
    we need the caller class name only. Instead of getting all the arrays and using
    only one element, we can now get the info we need by using the following two lines:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'We will get the result:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0109fd66-5daa-48ef-9bdb-95645c0b7d8a.png)'
  id: totrans-362
  prefs: []
  type: TYPE_IMG
- en: See also
  id: totrans-363
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Do refer to the other recipes of this chapter:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: Some best practices for better memory usage
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some best practices for better memory usage
  id: totrans-366
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Memory management may never become an issue for you, or it can be a haunting
    never-ending story of your life, and anything in between. It is probably going
    to be a non-issue for a majority of programmers, especially with the constantly
    improving garbage collection algorithms. The G1 garbage collector (default in
    JVM 9) is definitely a step in the right direction. But there is also a chance
    you will be called (or will notice yourself) about the degrading application performance,
    and that is when you'll learn how well you are equipped to meet the challenge.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: This recipe is an attempt to help you avoid such a situation or to get out of
    it successfully.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: How it  works...
  id: totrans-369
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first line of defense is the code itself. In the previous recipes, we have
    already discussed the need to release resources as soon as they are not needed
    anymore and the usage of `StackWalker` to consume less memory. There are plenty
    of recommendations on the internet, but they might not apply to your application.
    You'll have to monitor the memory consumption and test your design decisions,
    especially if your code handles a lot of data before deciding where to concentrate
    your attention.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: For example, the choice of the collection (different collections use more or
    less memory) may be irrelevant if your collection is going to be small. However,
    programmers usually use the same coding pattern, and one can identify the code's
    author by their style. That's why it pays back in a long run to figure the most
    efficient constructs and use them routinely. However, try to avoid making your
    code difficult to understand; readability is an important aspect of the code quality.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are a few most popular pieces of advice on memory-aware coding style:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: Use lazy initialization and create an object just before the usage, especially
    if there is a good chance, this need may never materialize at all
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `StringBuilder` instead of the `+` operator
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `ArrayList` if it fits your needs, before using `HashSet` (the memory usage
    increases from `ArrayList` to `LinkedList`, `HashTable`, `HashMap`, and `HashSet`,
    in this sequence)
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoid regular expressions and cache `Pattern` references if you cannot avoid
    them
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prefer primitives over the class wrappers (use autoboxing)
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Don't forget to clean the cache and remove unnecessary entries
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pay attention to the object created inside the loop
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test and profile your code as soon as it starts doing what it was supposed to
    do. You might need to change your design or some details of implementation. It
    will also inform your future decisions. There are many profilers and diagnostic
    tools available for any environment. We described one of them (`jcmd`) in the *Using
    the new diagnostic commands for the JVM *recipe of this chapter.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: Learn how your garbage collector works (see the recipe, *Understanding the G1
    garbage collector*) and do not forget to use JVM logging (described in the recipe, *Unified
    logging for JVM*).
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: 'After that, you might need to tune the JVM and garbage collector. Here are
    a few most often used JVM parameters (the size is specified in bytes by default,
    but you can append the letter k or K to indicate kilobytes, m or M to indicate
    megabytes, g or G to indicate gigabytes):'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: '`-Xms size`: This sets the initial size of the heap, which must be a multiple
    of 1024 and greater than 1 MB.'
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-Xmx size`: This sets the maximum size of the heap, which must be a multiple
    of 1024 and greater than 2 MB. The default value is chosen at runtime based on
    the system configuration. For server deployments, `-Xms size` and `-Xmx size`
    are often set to the same value. The actual memory usage may exceed the amount
    you have set by `-Xmx size`, because it limits the Java heap size only, while
    the JVM allocates memory for other purposes too, including a stack for each thread.'
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-Xmn size`: This sets the initial and maximum size of the heap for the young
    generation (nursery). If the size for the young generation is too small, then
    a lot of minor garbage collections will be performed. If the size is too large,
    then only full garbage collections will be performed, which can take a long time
    to complete. Oracle recommends that you keep the size for the young generation
    greater than 25% and less than 50% of the overall heap size. This parameter is
    equivalent to `-XX:NewSize=size`. For efficient garbage collection, `-Xmn size` should
    be lower than `-Xmx size`.'
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-XX:MaxNewSize=size`: This sets the maximum size of the heap for the young
    generation (nursery). The default value is set ergonomically. Oracle advises that
    after the total available memory, the second most influential factor is the proportion
    of the heap reserved for the young generation. By default, the minimum size of
    the young generation is 1310 MB, and the maximum size is unlimited.'
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-XX:NewRatio=ratio`: This sets the ratio between the young and old generation
    sizes; the default is set to 2.'
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-Xss size`: This sets the thread stack size, the default value depends on
    the platform:'
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Linux/ARM (32-bit): 320 KB'
  id: totrans-389
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Linux/ARM (64-bit): 1024 KB'
  id: totrans-390
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Linux/x64 (64-bit): 1024 KB'
  id: totrans-391
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'OS X (64-bit): 1024 KB'
  id: totrans-392
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Oracle Solaris/i386 (32-bit): 320 KB'
  id: totrans-393
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Oracle Solaris/x64 (64-bit): 1024 KB'
  id: totrans-394
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Windows: The default value depends on virtual memory'
  id: totrans-395
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Each thread has a stack, so the stack size will limit the number of threads
    the JVM can have. If the stack size is too small, you can get the `java.lang.StackOverflowError` exception.
    However, making the stack size too big can exhaust the memory too, as each thread
    will allocate more memory than it needs.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: '`-XX:MaxMetaspaceSize=size`: This sets the upper limit of the memory allocated
    for class metadata, not limited by default.'
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The tell-tell sign of a memory leak is the growing of the old generation causing
    the full GC to run more often. To investigate, you can use the JVM parameters
    that dump heap memory into a file:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: '`-XX:+HeapDumpOnOutOfMemoryError`: This saves the Java heap into a file in
    the current directory when a `java.lang.OutOfMemoryError` exception is thrown.
    You can explicitly set the heap dump file path and name using the `-XX:HeapDumpPath=path`
    option. By default, this option is disabled and the heap is not dumped when an
    `OutOfMemoryError` exception is thrown.'
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-XX:HeapDumpPath=path`: This sets the path and filename for writing the heap
    dump provided by the heap profiler (`hprof`) when the `-XX:+HeapDumpOnOutOfMemoryError` parameter
    is set. By default, the file is created in the current working directory, and
    it is named `java_pidpid.hprof` where `pid` is the identifier of the process that
    caused the error.'
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-XX:OnOutOfMemoryError="< cmd args >;< cmd args >"`: This sets a custom command
    or a series of semicolon-separated commands to run when an `OutOfMemoryError`
    exception is first thrown. If the string contains spaces, then it must be enclosed
    in quotation marks. For an example of a command string, see the description of
    the `-XX:OnError` parameter.'
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-XX:+UseGCOverheadLimit`: This enables the use of a policy that limits the
    proportion of time spent by the JVM on GC before an `OutOfMemoryError` exception
    is thrown. This option is enabled by default, and the parallel GC will throw an
    `OutOfMemoryError` exception if more than 98% of the total time is spent on garbage
    collection and less than 2% of the heap is recovered. When the heap is small,
    this feature can be used to prevent applications from running for long periods
    of time with little or no progress. To disable this option, specify `-XX:-UseGCOverheadLimit`.'
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  id: totrans-403
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Do refer to the other recipes of this chapter:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the G1 garbage collector
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unified logging for JVM
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the new diagnostic commands for the JVM
  id: totrans-407
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Try with resources for better resource handling
  id: totrans-408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stack walking for improved debugging
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
