- en: '*Chapter 12*: Beyond Functional Requirements'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第12章*：超越功能需求'
- en: Sometimes I feel like I am being forgotten.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候我感觉自己被遗忘了。
- en: — Anonymous
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: —— 匿名
- en: While the functional requirements of the core of the system may be met adequately,
    it is just as important to place focus on the operational characteristics of the
    system. In this chapter, we will look at common pitfalls and how to get past them.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然系统核心的功能需求可能得到充分满足，但同样重要的是关注系统的操作特性。在本章中，我们将探讨常见的陷阱以及如何克服它们。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Observability
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可观察性
- en: Consistency
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一致性
- en: Performance and scale
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能和规模
- en: Trunk-based development
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于主干线的开发
- en: Continuous testing
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持续测试
- en: Deployment automation
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署自动化
- en: Refactoring
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重构
- en: Invocation style
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用风格
- en: Logging
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日志记录
- en: Versioning
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 版本控制
- en: By the end of this chapter, we will have learned about various aspects of the
    software life cycle to create a robust solution from a cross-functional perspective.
    We will also discuss additional features that we will need to add to make our
    solution performant, scalable, resilient to failure, and gain the ability to make
    changes reliably, repeatably, and rapidly. Furthermore, we will also examine the
    implications of making these changes and the potential impacts this may have on
    our bounded contexts and their boundaries.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，我们将了解软件生命周期各个方面的各种方面，从跨职能的角度创建一个健壮的解决方案。我们还将讨论需要添加的额外功能，以使我们的解决方案具有性能、可扩展性、容错性，并能够可靠、重复和快速地进行更改。此外，我们还将检查这些更改的影响，以及这些更改可能对我们边界上下文及其边界产生的潜在影响。
- en: Let’s begin!
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Observability
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可观察性
- en: In previous chapters, we saw how it is possible to break down an existing application
    along bounded context boundaries. We also saw how it is possible to split bounded
    contexts to be extremely fine-grained, often as physically disparate components.
    Failure in any of these components can cause disruptions in others that are dependent
    on them. Obviously, early detection and more importantly attribution to specific
    components through a combination of proactive and reactive monitoring can ideally
    prevent or, at the very least, minimize business disruption.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们看到了如何根据边界上下文来分解现有应用程序，以及如何将边界上下文分割成非常细粒度的部分，通常作为物理上不同的组件。任何这些组件的故障都可能导致依赖它们的其他组件出现中断。显然，通过主动和被动监控的组合，及早检测并归因于特定组件，可以理想地防止或至少最小化业务中断。
- en: When it comes to monitoring, most teams seem to think of **technology runtime
    metrics** that we associate with components (such as CPU utilization, memory consumed,
    queue depths, exception count, and so on).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当谈到监控时，大多数团队似乎会想到与组件相关的**技术运行时指标**（如CPU利用率、内存消耗、队列深度、异常计数等）。
- en: Lending Objectivity to Metrics
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 为指标提供客观性
- en: 'To make it more formal, we use the terms **Service-Level Objectives** (**SLOs**)
    and **Service-Level Indicators** (**SLIs**) specified within a **Service-Level
    Agreement** (**SLA**) to mean the following:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使其更加正式，我们使用**服务级别目标**（**SLOs**）、**服务级别指标**（**SLIs**）和**服务级别协议**（**SLA**）中的术语来表示以下内容：
- en: '**SLO**: An agreement between the provider and customer about a specific measurable
    metric. For example, 99.99% uptime, 100 ms response time for 1,000 concurrent
    users for requests in the 99th percentile, and so on.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SLO**：供应商和客户之间关于特定可衡量指标的协议。例如，99.99%的可用性，对于99百分位数的请求，1000个并发用户的响应时间为100毫秒等。'
- en: '**SLA**: A collection of SLOs.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SLA**：一组SLOs（服务级别目标）。'
- en: '**SLI**: The actual numbers against an SLO. For example, your system might
    have an uptime SLI of 99.95%.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SLI**：实际数字与SLO的对比。例如，您的系统可能有一个99.95%的可用性SLI。'
- en: Technology metrics
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 技术指标
- en: When it comes to monitoring, most teams seem to think of technology runtime
    metrics that we associate with components (such as CPU utilization, memory consumed,
    queue depths, exception count, and so on).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当谈到监控时，大多数团队似乎会想到与组件（如CPU利用率、内存消耗、队列深度、异常计数等）相关的技术运行时指标。
- en: However, it is just as much if not more important to be able to associate a
    set of business-relevant metrics (such as the number of LC applications submitted
    in the last hour, the number of LC applications rejected, and so on) and DevOps
    metrics (such as lead time, mean time to restore, and so on).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，能够将一组与业务相关的指标（如过去一小时提交的LC申请数量、被拒绝的LC申请数量等）和DevOps指标（如领先时间、平均恢复时间等）关联起来，同样重要，甚至可能更重要。
- en: Business metrics
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 业务指标
- en: An inability to associate and monitor business SLIs with a component may be
    an indicator of the component being too fine-grained. On the flip side, if there
    are too many business SLIs associated with a single component that is of interest
    to a multitude of business stakeholder groups, it may be an indicator that a more
    fine-grained decomposition may be justified. At the end of the day, the monitoring
    apparatus we have in place should be able to tell us if we are violating/meeting/exceeding
    SLOs.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 无法将业务服务级别指标（SLIs）与组件关联和监控可能表明该组件过于细粒度。另一方面，如果与单个组件关联的业务SLIs太多，而这个组件对众多业务利益相关者群体都感兴趣，那么这可能表明进行更细粒度的分解是合理的。最终，我们设置的监控设备应该能够告诉我们是否违反/满足/超出服务级别目标（SLOs）。
- en: DevOps metrics
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: DevOps指标
- en: 'The **DevOps Research and Assessment** (**DORA**) research foundation has published
    an online quickcheck ([https://www.devops-research.com/quickcheck.html](https://www.devops-research.com/quickcheck.html))
    tool and report ([https://www.devops-research.com/research.html](https://www.devops-research.com/research.html))
    to quickly provide information on how organizations compare with industry peers
    and how to make progress toward elite status. While discussing the full nuance
    of what it takes to establish a long-term culture of continuous improvement is
    out of scope for this book, we reference the four key metrics highlighted in the
    research paper as indicators of software delivery performance:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**DevOps研究和评估**（**DORA**）研究基金会发布了一个在线快速检查工具（[https://www.devops-research.com/quickcheck.html](https://www.devops-research.com/quickcheck.html)）和报告（[https://www.devops-research.com/research.html](https://www.devops-research.com/research.html)），以快速提供有关组织与行业同行相比的情况以及如何向精英地位迈进的信息。虽然讨论建立长期持续改进文化的全部细微差别超出了本书的范围，但我们引用了研究论文中突出的四个关键指标，作为软件交付性能的指标：'
- en: '**Lead time**: How long does it take to go from code committed to code successfully
    running in production?'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**领先时间**：从代码提交到代码成功运行在生产环境中的时间有多长？'
- en: '**Deployment frequency**: How often does your organization deploy code to production
    or release it to end users?'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**部署频率**：您的组织多久将代码部署到生产环境或发布给最终用户？'
- en: '**Time to restore**: How long does it generally take to restore service when
    a service incident or a defect that impacts users occurs?'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**恢复时间**：当发生影响用户的服务事件或缺陷时，通常需要多长时间来恢复服务？'
- en: '**Change failure percentage**: What percentage of changes to production or
    releases to users results in degraded service?'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**变更失败率**：有多少比例的生产或用户发布变更导致服务降级？'
- en: 'When it comes to observability, there is the risk of focusing on specific metrics
    in isolation and missing the forest for the trees. To avoid metrics being misused
    and, more importantly, running the risk of drawing incorrect conclusions, we recommend
    the following:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在可观察性方面，存在专注于特定指标而忽略整体森林的风险。为了避免指标被误用，更重要的是，避免得出错误结论的风险，我们建议以下做法：
- en: '**Take a holistic view**: Focusing more or less equally on all aspects of the
    delivery life cycle as opposed to focusing on just a particular area can go a
    long way. If you are able to include information from planning, requirements intake,
    development, build, test, deploy, and feedback from running production systems,
    then you may be able to conclude reasonably that you have a high-performing team.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**采取全面视角**：相对于只关注特定区域，在交付生命周期的各个方面投入更多或更少的关注可以大有裨益。如果您能够包括规划、需求收集、开发、构建、测试、部署以及运行生产系统的反馈信息，那么您可能可以合理地得出结论，您有一个表现优异的团队。'
- en: '**Employ ratcheting**: Having recognized an improvement area, how do you go
    about setting yourself up for improvement? Setting clear, objective goals that
    are measurable and trackable (no pun intended) for improvement is paramount to
    be able to subsequently meet them. In order to ensure that there is continuous
    incremental improvement, ratcheting is a technique that can be employed. A ratchet
    is a device that resembles a wrench but is unique in that it only turns in one
    direction. In this context, ratcheting involves doing the following:'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**采用阶梯式方法**：在识别出改进区域后，你如何为自己设定改进的基础？设定明确、客观、可衡量且可追踪的改进目标对于随后实现它们至关重要（无意中用了双关语）。为了确保持续进行增量改进，阶梯式方法是一种可以采用的技术。阶梯是一种类似于扳手的装置，但它的独特之处在于它只能朝一个方向转动。在此背景下，阶梯式方法包括以下步骤：'
- en: Set the current level as the minimum starting point.
  id: totrans-39
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将当前级别设置为最小起始点。
- en: Make a small incremental improvement in a relatively small amount of time.
  id: totrans-40
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在相对较短的时间内进行小的增量改进。
- en: Re-adjust the baseline to the new level attained as part of step 2.
  id: totrans-41
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将基线调整到步骤2中达到的新水平。
- en: If levels descend below the baseline, take stop-the-line action until baselines
    are restored.
  id: totrans-42
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果水平下降到基线以下，则采取停止生产线措施，直到基线恢复。
- en: Repeat from step 1.
  id: totrans-43
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从步骤1重新开始。
- en: Ratcheting allows teams to set incremental milestones as intermediate goals
    while moving closer to a much better place all the time.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 逐步改进允许团队在接近一个更好的地方的同时，设定增量里程碑作为中间目标。
- en: Adopting an attitude of constant learning and incremental improvement through
    ratcheting as opposed to one that looks to police and penalize can go a long way
    toward instituting a system that can be effective.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 采用持续学习和通过逐步改进来代替试图监督和惩罚的态度，可以大大有助于建立一个有效的系统。
- en: Consistency
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一致性
- en: In the previous chapters, we have spent a lot of energy splitting our system
    into multiple, fine-grained independent components. For example, the LC application
    is submitted against the command-side component, whereas the status of the LC
    application is serviced by the query side. Because these are distinct components,
    there will be a time lag during which the two systems are not consistent with
    each other. So, querying the status of an LC application immediately after submitting
    may produce a stale response until the time that the query side processes the
    submit event and updates its internal state. In other words, the command side
    and the query side are considered to be *eventually consistent*. This is one of
    the trade-offs that we need to embrace when working with distributed systems.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们投入了大量精力将我们的系统分解成多个细粒度的独立组件。例如，LC应用程序是针对命令端组件提交的，而LC应用程序的状态则由查询端提供服务。因为这些是不同的组件，所以在两个系统不一致的这段时间内会有时间延迟。因此，在提交LC应用程序后立即查询其状态可能会产生过时的响应，直到查询端处理提交事件并更新其内部状态。换句话说，命令端和查询端被认为是*最终一致*的。这是我们与分布式系统合作时需要接受的权衡之一。
- en: Eric Brewer (professor emeritus of computer science at the University of California,
    Berkeley) formalized the trade-offs involved in building distributed systems in
    what is called the *CAP theorem*. The theorem postulates that distributed systems
    can either be highly available or consistent in the event of a network partition,
    not both at the same time. Given the three characteristics, **c**onsistency, **a**vailability,
    and **p**artition tolerance, the theorem postulates that distributed systems can
    either be highly available or consistent in the event of a network partition,
    not both at the same time. This means that distributed applications that are expected
    to be highly available will have to forsake strong consistency.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 埃里克·布赖尔（加州大学伯克利分校计算机科学名誉教授）在所谓的*CAP定理*中正式化了构建分布式系统所涉及的权衡。该定理假设在发生网络分区的情况下，分布式系统要么高度可用，要么一致，但不能同时两者都是。考虑到三个特性，**一致性**、**可用性**和**分区容错性**，该定理假设在发生网络分区的情况下，分布式系统要么高度可用，要么一致，但不能同时两者都是。这意味着预期高度可用的分布式应用程序将不得不放弃强一致性。
- en: This may make it appear that this is a deal-breaker, but in reality, most real-world
    business problems are tolerant to being eventually consistent. For example, there
    may be a requirement that an order cannot be canceled after it has shipped. In
    an eventually consistent system, there may exist a time window (albeit small)
    where we may allow a shipped order to be canceled. To deal with such scenarios,
    we may need to enhance the business process to account for these inconsistencies.
    For example, before issuing a refund for a canceled order, we may need to validate
    that the order has not physically shipped or has been returned. Even in the extreme
    case where we may have erroneously issued a refund for a shipped order, we can
    request the customer to return it before an expiry period to avoid getting charged.
    If the customer fails to return the order, we may charge the customer or write
    off the amount as lost business. Obviously, all this adds a level of complexity
    to the solution because we may need to account for edge conditions through a series
    of compensating actions. If none of this complexity is acceptable and strong consistency
    is non-negotiable, then shipping and order cancellation functionality will have
    to be part of the same bounded context.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能让人看起来这是一个决定性的因素，但事实上，大多数现实世界的业务问题最终都是可以容忍不一致性的。例如，可能存在一个要求订单一旦发货就不能取消的要求。在一个最终一致性的系统中，可能存在一个时间窗口（尽管很小），我们可以允许已发货的订单被取消。为了处理这种场景，我们可能需要增强业务流程来考虑这些不一致性。例如，在发出取消订单的退款之前，我们可能需要验证订单尚未实际发货或已退货。即使在极端情况下，我们可能错误地发放了已发货订单的退款，我们也可以要求客户在到期前退货以避免被收费。如果客户未能退货，我们可能向客户收费或将其作为损失的业务冲销。显然，所有这些都增加了解决方案的复杂性，因为我们可能需要通过一系列补偿行动来考虑边缘情况。如果所有这些复杂性都不被接受，并且强一致性是不可或缺的，那么发货和订单取消功能将必须属于同一个边界上下文。
- en: Performance and scale
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性能和规模
- en: In previous chapters, we saw how it is possible and sometimes even necessary
    to break functionality down into fine-grained components that are physically separated
    from each other – requiring a network to collaborate. Let’s assume that this collaboration
    is achieved in a loosely coupled manner – justifying the need for disparate bounded
    contexts from a logical perspective.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们看到了将功能分解成彼此物理上分离的细粒度组件是如何成为可能，有时甚至是必要的——这需要网络进行协作。让我们假设这种协作是以松散耦合的方式实现的——从逻辑角度来看，这为不同边界上下文的存在提供了合理性。
- en: 'Performance is a very important SLO that is typically associated with most
    applications. When it comes to performance, it is essential to understand the
    basic terms. This is best illustrated using an example as shown here:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 性能是一个非常重要的SLO，通常与大多数应用程序相关联。当谈到性能时，理解基本术语至关重要。这最好通过以下示例来说明：
- en: '![Figure 12.1 – The elements of network performance'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 12.1 – The elements of network performance]'
- en: '](img/B16716_Figure_12.1.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B16716_Figure_12.1.jpg]'
- en: Figure 12.1 – The elements of network performance
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.1 – 网络性能的要素
- en: 'As shown here, the following terms are relevant in the context of performance:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如此所示，以下术语在性能的背景下是相关的：
- en: '**Latency**: The delay introduced by the network (A + B)'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**延迟**：网络引入的延迟（A + B）'
- en: '**Response Time**: the total time taken by the system to respond to the user
    (A + B + C)'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**响应时间**：系统响应用户所需的总时间（A + B + C）'
- en: '**Bandwidth**: The maximum capacity of the network (D)'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**带宽**：网络的最高容量（D）'
- en: '**Throughput**: The amount of data processed in a given amount of time'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**吞吐量**：在给定时间内处理的数据量'
- en: The introduction of a network between two components introduces constraints
    in the form of network latency and bandwidth. Even if processing time on the server
    is theoretically reduced to zero, latency and bandwidth constraints cannot be
    avoided. This problem can only get worse as the number of network hops increases.
    This means that it is impossible for networked applications to provide the same
    level of performance as their non-networked counterparts.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在两个组件之间引入网络会在网络延迟和带宽方面引入约束。即使服务器上的处理时间理论上减少到零，延迟和带宽约束也无法避免。随着网络跳数的增加，这个问题只会变得更糟。这意味着网络应用程序无法提供与未联网的同类应用程序相同的性能水平。
- en: The need to scale to support a larger number of requests can further complicate
    things. Given that Moore’s law has slowed down considerably in the last decade
    or so, it is less feasible to continue scaling up by using more and more powerful
    machines. This means that beyond a point, scaling out by using multiple instances,
    and thereby (re-)introducing a reliance on the network, is inevitable.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 需要扩展以支持更多的请求可能会使问题更加复杂。鉴于过去十年左右摩尔定律的显著放缓，继续通过使用越来越强大的机器来扩展规模变得越来越不可行。这意味着超过某个点，通过使用多个实例进行扩展，从而（重新）引入对网络的依赖，是不可避免的。
- en: This makes it evident that performance and scale requirements can have a significant
    impact on how we choose to distribute our components. Having a clear understanding
    of performance and scale SLOs is a necessary prerequisite before attempting to
    distribute distinct components. On the flip side, if you are in a situation where
    you already have distributed components that are not meeting performance and scale
    SLOs, one option is to aggregate them back together. If that is not feasible,
    it may be worth embracing alternative customer experiences along with a non-blocking,
    event-driven style of architecture to create a perception of better performance.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得很明显，性能和扩展要求可以对我们选择如何分配我们的组件产生重大影响。在尝试分配不同的组件之前，对性能和扩展SLO有清晰的理解是一个必要的先决条件。另一方面，如果你已经处于这样一种情况，即你已经有分布式组件，但它们没有达到性能和扩展SLO，一个选择是将它们重新聚合在一起。如果这不可行，那么值得接受替代的客户体验，以及非阻塞的事件驱动架构风格，以创造更好的性能感知。
- en: Trunk-based development
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于主干线的开发
- en: Eric Evans, the inventor of DDD, talks about how **continuous integration**
    (**CI**) helps preserve the sanctity of the domain model within a bounded context.
    When more than one person works in the same bounded context, it tends to fragment.
    Obviously, the bigger the team, the higher the likelihood of this problem occurring.
    Even a team as small as three or four people can encounter serious issues. We
    have also seen that beyond a point, there may be diminishing returns if we try
    to break the system into extremely fine-grained bounded contexts.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: DDD的发明者埃里克·埃文斯（Eric Evans）讨论了如何**持续集成**（**CI**）帮助在有限范围内保持领域模型的神圣性。当多个人在同一个有限范围内工作时，它往往会变得碎片化。显然，团队越大，这种问题发生的可能性就越高。即使是三四个人的小团队也可能遇到严重的问题。我们也看到，超过某个点，如果我们试图将系统分解成极其细粒度的有限范围，可能会出现收益递减的情况。
- en: This makes it very important to institute a process of merging/integrating all
    code and other implementation artifacts frequently, aided by **automated tests**
    to flag such fragmentation. In addition, this allows the team to apply the ubiquitous
    language relentlessly, each time refining the domain model to represent the problem
    more accurately. In other words, it is critical to practice continuous integration.
    Many teams make use of a CI server to run tests but tend to postpone integration
    until very late making use of an excessive number of long-living branches (popularized
    by Gitflow; [https://www.atlassian.com/git/tutorials/comparing-workflows/gitflow-workflow](https://www.atlassian.com/git/tutorials/comparing-workflows/gitflow-workflow)
    and merge requests – practicing an anti-pattern known as CI theatre ([https://www.gocd.org/2017/05/16/its-not-CI-its-CI-theatre.html](https://www.gocd.org/2017/05/16/its-not-CI-its-CI-theatre.html)).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得定期合并/集成所有代码和其他实现工件的过程变得非常重要，借助**自动化测试**来标记这种碎片化。此外，这还允许团队不懈地应用通用语言，每次都进一步细化领域模型以更准确地表示问题。换句话说，实践持续集成是至关重要的。许多团队使用CI服务器来运行测试，但往往推迟集成，直到非常晚才使用过多的长期分支（Gitflow推广；[https://www.atlassian.com/git/tutorials/comparing-workflows/gitflow-workflow](https://www.atlassian.com/git/tutorials/comparing-workflows/gitflow-workflow)和合并请求——实践一种被称为CI剧院的反模式[https://www.gocd.org/2017/05/16/its-not-CI-its-CI-theatre.html](https://www.gocd.org/2017/05/16/its-not-CI-its-CI-theatre.html))。
- en: An alternative to branch-based development is *trunk-based development* where
    each developer works in incremental batches and merges that work into the main
    (also called trunk) branch at least once (and potentially several times) a day.
    The DORA team has published research ([https://services.google.com/fh/files/misc/state-of-devops-2021.pdf#page=27](https://services.google.com/fh/files/misc/state-of-devops-2021.pdf#page=27))
    that shows that elite performers practice trunk-based development to maximize
    the effectiveness of their CI practice and by extension their ability to continuously
    enhance their domain models and keep up with changing business needs.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 基于分支的开发的一个替代方案是*基于主干分支的开发*，其中每个开发者以增量批次工作，并将这些工作至少每天（有时是几次）合并到主分支（也称为主干分支）。DORA团队发布了一项研究([https://services.google.com/fh/files/misc/state-of-devops-2021.pdf#page=27](https://services.google.com/fh/files/misc/state-of-devops-2021.pdf#page=27))，该研究显示，精英团队通过实践基于主干分支的开发来最大化他们CI实践的有效性，进而扩展到他们持续增强领域模型和满足不断变化业务需求的能力。
- en: In an ideal world, every commit to the trunk would constitute finished, production-ready
    work. But it is also fairly normal for certain pieces of work to take longer to
    complete. This may make it appear that there is a need to forsake trunk-based
    development and resort to branch-based development. However, there is no need
    to compromise the continuous integration flow to accommodate for such eventualities.
    Paul Hammant ([https://paulhammant.com/](https://paulhammant.com/)) talks about
    this technique called *branch by abstraction* where the effects of unfinished
    pieces of work are hidden behind an abstraction layer. This abstraction layer
    is typically implemented by either making the new piece of functionality hidden
    from the end user or in more sophisticated cases, using feature flags ([https://martinfowler.com/articles/feature-toggles.html](https://martinfowler.com/articles/feature-toggles.html)).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个理想的世界里，对主干分支的每一次提交都应构成已完成、可用于生产的作品。但某些工作需要更长的时间来完成也是相当正常的。这可能会让人觉得有必要放弃基于主干分支的开发，转而采用基于分支的开发。然而，没有必要为了应对这种可能性而妥协持续集成的流程。保罗·汉曼特([https://paulhammant.com/](https://paulhammant.com/))讨论了这种称为*抽象分支*的技术，其中未完成的工作的影响被隐藏在一个抽象层之后。这个抽象层通常是通过使新的功能对最终用户不可见来实现的，或者在更复杂的情况下，使用功能标志([https://martinfowler.com/articles/feature-toggles.html](https://martinfowler.com/articles/feature-toggles.html))。
- en: Continuous testing
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持续测试
- en: In an ideal world, continuous integration will enable us to adopt continuous
    testing, which provides us with constant and early feedback. This is essential
    because our bounded contexts and the resulting domain models are in a constant
    state of evolution. Without the bedrock of a stable suite of tests, it can become
    very hard to sustain a reliable process. Approaches such as the test pyramid,
    testing trophy, honeycomb, and so on are acknowledged as reasonable ways to implement
    a sound continuous testing strategy. All of these approaches are based on the
    premise that a large number of cheap (computationally and cognitively) unit tests
    form the foundation of the strategy, with the number of tests in other categories
    (service, UI, manual, and so on) reducing as we move through the chain.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个理想的世界里，持续集成将使我们能够采用持续测试，这为我们提供了持续和早期的反馈。这是至关重要的，因为我们的边界上下文和由此产生的领域模型处于不断演化的状态。如果没有稳定测试套件的基础，维持可靠的过程会变得非常困难。测试金字塔、测试奖杯、蜂巢等方法被认为是实施合理的持续测试策略的合理方式。所有这些方法都是基于这样一个前提：大量的低成本（计算和认知）单元测试构成了策略的基础，随着我们沿着链条前进，其他类别（服务、UI、手动等）的测试数量逐渐减少。
- en: However, we are in this new world of fine-grained components that work by communicating
    with each other. Hence, there is a bigger need to verify interactions at the periphery
    in a robust manner. Unit tests alone that rely mostly on mocks and stubs may not
    suffice because the behavior of collaborators may change inadvertently. This may
    lead to a situation where unit tests may run successfully, but the overall functionality
    may be broken. This may cause teams to lose faith in the practice of unit testing
    as a whole and resort to using more end-to-end functional tests. However, these
    styles of tests can be extremely expensive ([https://www.youtube.com/watch?v=VDfX44fZoMc](https://www.youtube.com/watch?v=VDfX44fZoMc))
    to set up and maintain, especially when we are looking to automate them. Consequently,
    most teams ignore the results of a majority of automated testing methods and rely
    almost exclusively on manual testing to verify anything but the most trivial functionality.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们处在一个由相互通信的细粒度组件组成的新世界中。因此，有必要以稳健的方式验证外围的交互。仅仅依赖于模拟和存根的单元测试可能不足以满足需求，因为合作者的行为可能会意外地改变。这可能导致单元测试运行成功，但整体功能可能已损坏。这可能导致团队对单元测试的整体实践失去信心，并转而使用更多端到端的功能测试。然而，这些测试风格可能极其昂贵([https://www.youtube.com/watch?v=VDfX44fZoMc](https://www.youtube.com/watch?v=VDfX44fZoMc))，尤其是在我们试图自动化它们的时候。因此，大多数团队忽略了大多数自动化测试方法的结果，几乎完全依赖于手动测试来验证除最简单功能之外的所有内容。
- en: Any manual testing requires most if not all functionality to be ready before
    any meaningful testing can commence. Furthermore, it is time-consuming, error-prone,
    and usually not repeatable. Consequently, almost all testing can be carried out
    only when it is very close to the end, rendering the idea of continuous testing
    a pipe dream. Despite all its limitations, teams continue to rely on manual testing
    because it seems to provide the most psychological safety in comparison to its
    automated counterparts.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 任何手动测试都需要在有意义测试开始之前，大多数情况下是所有功能都准备好。此外，它耗时、易出错，通常不可重复。因此，几乎所有测试只能在非常接近结束时进行，使得持续测试的想法成为空想。尽管存在所有这些局限性，团队仍然依赖于手动测试，因为它似乎比其自动化的对应物提供了更多的心理安全感。
- en: In an ideal world, what we need is the speed of unit tests and the confidence
    provided by manual testing. We will look at a few specific forms of testing that
    can help restore the balance.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个理想的世界里，我们需要的是单元测试的速度和手动测试提供的信心。我们将探讨几种具体的测试形式，这些形式可以帮助恢复平衡。
- en: Contract testing
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 合同测试
- en: 'The limitation of unit testing is that the assumptions made in mocks/stubs
    can be invalid or become stale as producers make changes to the contract. On the
    other hand, manual tests suffer from being slow and wasteful. Contract tests can
    provide a means to bridge the gap by providing a happy medium where the producer
    and consumer share an executable contract that both producer and consumer can
    rely on as functionality changes/evolves. At a high level, this works in the manner
    depicted here:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试的局限性在于，模拟/存根中做出的假设可能无效或随着生产者对合同的更改而变得过时。另一方面，手动测试由于速度慢和浪费而受到困扰。合同测试可以通过提供一个双方都可以依赖的、可执行的合同来提供一种快乐的中庸之道，从而弥合这一差距，该合同在功能变化/发展时双方都可以依赖。从高层次来看，这就像下面描述的那样工作：
- en: '![Figure 12.2 – Contract testing: high-level flow'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.2 – 合同测试：高级流程'
- en: '](img/B16716_Figure_12.2.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16716_Figure_12.2.jpg)'
- en: 'Figure 12.2 – Contract testing: high-level flow'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.2 – 合同测试：高级流程
- en: This allows the consumers and the producers to work collaboratively, and get
    feedback a lot earlier in the cycle. For the consumer, they get to participate
    in sharing their expectations with the producer and make use of versioned, producer-approved
    stubs for their own testing without having to depend on the producer’s real system.
    Likewise, producers gain a deeper understanding of how their services are consumed,
    setting them free to make bolder changes as long as they remain compatible.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得消费者和生产者能够协作工作，并在周期早期就获得反馈。对于消费者来说，他们有机会参与与生产者分享他们的期望，并使用经过版本控制的生产者批准的存根进行自己的测试，而无需依赖于生产者的真实系统。同样，生产者也能更深入地了解他们的服务是如何被消费的，这使他们能够自由地做出更大胆的更改，只要它们保持兼容。
- en: Test-First Design
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 测试驱动设计
- en: The essence of domain-driven design is all about gaining as thorough an understanding
    of the problem in order to solve the problem right. Test-first design enables
    gaining a better understanding of the problem because it mitigates the risk of
    becoming biased by the solution we have built. In addition, it also promotes the
    automated verification of these requirements, which allows them to be used as
    an effective aid to regression testing. We are strong proponents of this practice
    for this reason and encourage you to consider adopting TDD as a core practice
    to accentuate your effectiveness with DDD.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 领域驱动设计的本质在于尽可能彻底地理解问题，以便正确地解决问题。测试优先设计通过减少我们构建的解决方案导致的偏差风险，使得更好地理解问题成为可能。此外，它还促进了这些要求的自动化验证，这使得它们可以作为回归测试的有效辅助工具。正因为如此，我们强烈支持这一实践，并鼓励您考虑采用TDD作为核心实践，以增强您在DDD中的有效性。
- en: Mutation testing
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 突变测试
- en: A lot of teams author a variety of tests to ensure that they are building a
    high-quality solution. Test coverage is typically used as a quantitative measure
    to assess the quality of testing. However, test coverage is a necessary but not
    sufficient condition to establish test quality. Low test coverage almost definitely
    means there is a test quality problem, whereas high coverage does not imply better
    tests. In an ideal world, even a single line change in production code (caused
    by a change in business requirements), without changing test code, will result
    in a test failure. If this can be guaranteed for every single change across the
    code base, you may be able to safely rely on such a test suite.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 许多团队编写各种测试以确保他们构建的是高质量的解决方案。测试覆盖率通常用作评估测试质量的定量指标。然而，测试覆盖率是建立测试质量的一个必要但不充分的条件。低测试覆盖率几乎肯定意味着存在测试质量问题，而高覆盖率并不一定意味着更好的测试。在一个理想的世界里，即使是在生产代码中（由于业务需求的变化）的单行更改，如果没有更改测试代码，也会导致测试失败。如果可以保证代码库中的每个更改都能保证这一点，那么可能可以安全地依赖这样的测试套件。
- en: Mutation testing is a practice that automatically inserts small bugs in production
    code (called *mutants*) and reruns an existing suite of tests to ascertain the
    quality of tests. If your tests failed, the mutant is killed. Whereas if your
    tests passed, the mutant survives. The higher the number of mutants killed, the
    more effective your tests are.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 突变测试是一种实践，它会自动在生产代码中插入小的错误（称为*突变*），然后重新运行现有的测试套件以确定测试的质量。如果你的测试失败了，突变就会被杀死。而如果你的测试通过了，突变就会存活。被杀死的突变越多，你的测试就越有效。
- en: For example, it may apply mutations such as inverting conditionals, replacing
    relational operators, returning nulls from methods, and so on, and then you can
    check the effect this has on your existing tests. If no tests fail despite these
    mutations, these tests may not be as helpful as you hoped them to be. This allows
    us to draw more objective conclusions about the quality of our tests. Given how
    it works (by mutating code), it is computationally intensive and hence may take
    a long time to run. If you employ a test-first design and have a fast suite of
    unit tests, mutation testing can be a great complement that can help discover
    missed requirements and/or test cases earlier in the development cycle. From that
    perspective, we see it as an invaluable tool to augment the adoption of DDD within
    teams. Tools such as PITest ([https://pitest.org/](https://pitest.org/)) are a
    great tool to perform mutation testing in your Java applications.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，它可能应用诸如反转条件、替换关系运算符、从方法返回null等突变，然后你可以检查这些突变对现有测试的影响。如果尽管这些突变没有测试失败，这些测试可能没有你希望的那样有帮助。这使我们能够更客观地得出关于测试质量的结论。鉴于它是通过突变代码来工作的，因此计算密集，可能需要很长时间才能运行。如果你采用测试优先设计并且有一套快速的单元测试，突变测试可以是一个很好的补充，有助于在开发周期早期发现遗漏的需求和/或测试用例。从这个角度来看，我们认为它是增强团队中DDD采用的一个无价工具。例如，PITest
    ([https://pitest.org/](https://pitest.org/)) 是在Java应用程序中执行突变测试的一个很好的工具。
- en: Chaos testing
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 混沌测试
- en: As we have seen earlier, mutation testing can help point out chinks in the functional
    aspects of your application. Chaos testing plays a similar role to help identify
    shortcomings in meeting non-functional requirements caused by reliance on network
    and infrastructure. It started becoming popular through the use of large-scale
    distributed, cloud-based architectures pioneered by companies such as Amazon,
    Netflix, and so on. Netflix initially released a tool called Chaos Monkey ([https://netflix.github.io/chaosmonkey/](https://netflix.github.io/chaosmonkey/))
    that randomly terminated instances in production(!) to ensure that engineers implement
    services that are resilient to failure. They followed this by releasing a set
    of related tools, collectively called the Simian Army (which is now defunct) to
    test a variety of non-functional aspects such as latency, security compliance,
    unused resources, and so on.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前所见，突变测试可以帮助指出应用程序功能方面的漏洞。混沌测试在帮助识别由对网络和基础设施的依赖引起的非功能性要求不足方面发挥着类似的作用。它通过使用由亚马逊、Netflix等公司开创的大规模分布式、基于云的架构而开始流行。Netflix最初发布了一个名为Chaos
    Monkey的工具([https://netflix.github.io/chaosmonkey/](https://netflix.github.io/chaosmonkey/))，该工具在生产环境中随机终止实例(!)以确保工程师实现能够抵御失败的服务。随后，他们发布了一系列相关的工具，统称为Simian
    Army（现已停用），以测试各种非功能性方面，如延迟、安全合规性、未使用资源等。
- en: While Netflix performs this style of testing in production, the rest of us will
    benefit immensely if we adopt these practices even in lower environments at the
    outset. From a strategic perspective, chaos testing can provide feedback on the
    amount of coupling between components and whether the boundaries of these components
    are appropriate. For example, if a component that you are dependent on goes down
    or experiences problems, does this take you down as well? If so, are there ways
    to mitigate this? It can also provide feedback about your monitoring and alerting
    apparatus. From a tactical perspective, it can provide insights into the shortcomings
    of the invocation style being used to communicate among components.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当Netflix在生产环境中执行这种测试风格时，如果我们一开始就在较低的环境中采用这些实践，我们所有人都能从中受益匪浅。从战略角度来看，混沌测试可以提供关于组件之间耦合程度的反馈，以及这些组件的边界是否适当。例如，如果你依赖的组件出现故障或遇到问题，这也会让你受到影响吗？如果是这样，有没有缓解这种影响的方法？它还可以提供关于你的监控和警报系统的反馈。从战术角度来看，它可以提供关于正在使用的组件间通信调用风格的不足之处。
- en: In this section, we have chosen to highlight contract testing, mutation testing,
    and chaos testing because we see them as game-changers in the application of DDD.
    Teams will benefit by looking at these methods as augmentations to other testing
    methods when coming up with a well-rounded testing strategy.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们选择突出显示契约测试、突变测试和混沌测试，因为我们认为它们是领域驱动设计应用中的颠覆性变革。当团队在制定全面的测试策略时，将这些方法视为其他测试方法的补充将受益匪浅。
- en: Deployment automation
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署自动化
- en: 'The intent of applying domain-driven design is to create an ecosystem of loosely
    coupled components – so that each of these components can evolve independently
    of each other. This includes how these components are deployed to production.
    At a high level, we have at least three styles of deployment:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 应用领域驱动设计的目的是创建一个松散耦合的组件生态系统——这样每个组件都可以独立于彼此进化。这包括这些组件如何部署到生产环境中。在较高层次上，我们至少有三种部署风格：
- en: '**Single-process monolith**: Where large portions of the application are deployed
    as a single unit, with all components that are included in the deployment running
    in a single process'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单进程单体**：应用的大部分内容作为一个单一单元部署，其中包含在部署中包含的所有组件都在单个进程中运行'
- en: '**Distributed monolith**: Where the application is split into multiple components
    with each running in its own process and/or host, but deployed as a single unit
    and/or requiring non-trivial amounts of coordination and tight coupling among
    components and their owners'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分布式单体**：应用被分割成多个组件，每个组件在自己的进程和/或主机上运行，但作为一个单一单元部署，或需要组件及其所有者之间的大量协调和紧密耦合'
- en: '**Independent components**: Where the application is split into multiple components
    with each running in its own process and/or host, deployed independently of each
    other and requiring minimal to no coordination among component owners'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**独立组件**：应用被分割成多个组件，每个组件在自己的进程和/或主机上运行，独立于彼此部署，并且组件所有者之间需要最小化到没有协调'
- en: 'We also have a number of deployment strategies that we can employ. We list
    some of the more popular ones in order of increasing complexity and richness:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有许多可以采用的部署策略。我们按复杂性和丰富程度递增的顺序列出了一些更受欢迎的：
- en: '**Basic**: Likely the oldest style of deployment where the newer version of
    the application replaces the old, usually with some amount of downtime. Rollback
    typically means redeploying the previously live version, again taking some amount
    of downtime. This is a fairly common deployment strategy for those applications
    where a certain amount of downtime is acceptable. This may include non-business
    critical applications and/or third-party packages where we do not have a say in
    how those applications manage their deployments. In the case of certain monoliths,
    this may be the only feasible option due to the overall complexity of the system
    as a whole. This style of deployment typically starts out being fairly simple
    and well understood and may suffice for non-critical applications. On the flip
    side, it requires the deployment and release to happen in one single tightly coupled
    step and may involve some amount of downtime.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基本**: 这可能是最古老的部署方式，其中新版本的应用程序替换旧版本，通常伴随着一定程度的停机时间。回滚通常意味着重新部署之前运行版本，这同样会带来一定程度的停机时间。这种部署策略对于可以接受一定停机时间的应用程序来说相当常见。这可能包括非业务关键应用程序和/或第三方包，在这些情况下，我们没有发言权来决定这些应用程序如何管理它们的部署。在某些单体架构的情况下，这可能是唯一可行的选项，因为整个系统的复杂性很高。这种部署方式通常开始时相当简单且易于理解，可能适用于非关键应用程序。另一方面，它要求部署和发布在一个紧密耦合的步骤中完成，可能涉及一定程度的停机时间。'
- en: '**Blue-green**: A deployment strategy that makes use of two identical environments,
    a “blue” and a “green” environment, with one representing the current production
    and another representing the newer version. The current version continues to service
    traffic, while testing and acceptance are carried out on the new version without
    exposing it to end users. User traffic is switched to the newer version once testing
    activities are deemed to be successfully completed. It is pertinent to note that
    live user traffic is directed only to one environment at any given time. This
    style of deployment enables deployment with (near) zero downtime and also allows
    decoupling of the process of deployment and release. Rollbacks are easier because
    it simply means redirecting traffic to the older version. On the other hand, it
    requires double the amount of capacity at least during the time of deployment.
    This may make it cost-prohibitive for monolithic applications.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**蓝绿部署**: 一种利用两个相同环境（“蓝”环境和“绿”环境）的部署策略，一个代表当前生产环境，另一个代表新版本。当前版本继续服务流量，而测试和验收在新版本上进行，不会向最终用户暴露。一旦测试活动被认为成功完成，用户流量就会切换到新版本。值得注意的是，在任何给定时间，实时用户流量只会被导向一个环境。这种部署方式可以实现（几乎）零停机时间的部署，并允许部署和发布过程解耦。回滚更容易，因为它仅仅意味着将流量重定向到旧版本。另一方面，它至少在部署期间需要双倍容量。这可能会使单体应用程序的成本变得过高。'
- en: '**Rolling**: A deployment strategy where a small subset of current version
    instances is incrementally replaced by newer version instances. Both old and new
    versions of the software continue to run in parallel until all instances of the
    old are replaced with new ones. In simple cases, rollback typically means replacing
    the newer version instances with older ones. This style of deployment also enables
    zero-downtime deployment, while also allowing side-by-side testing of old and
    new versions with real users. Rolling deployments can make rollbacks relatively
    easy by aborting the introduction of instances of the new version and re-introducing
    the old version and hence can reduce the *blast radius* of a bad release. Unlike
    the case with blue-green deployments, here deployment and release cannot be decoupled.
    Deployment means that the system is released (at least for a subset of users).'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**滚动部署**: 一种策略，其中当前版本实例的小部分逐渐被新版本实例替换。旧版本和新版本软件将继续并行运行，直到所有旧实例都被新实例替换。在简单情况下，回滚通常意味着用旧版本实例替换新版本实例。这种部署方式也实现了零停机时间的部署，同时允许与真实用户并行测试新旧版本。滚动部署可以通过中止新版本实例的引入并重新引入旧版本来使回滚相对容易，从而可以减少不良发布的“影响范围”。与蓝绿部署不同，这里的部署和发布不能解耦。部署意味着系统被发布（至少对于用户子集）。'
- en: '**Canary**: A variation of the rolling deployment where traffic is routed to
    newer instances in a controlled and phased manner, typically an increasing proportion
    of request volume (for example, 2% → 25% → 75% → 100% of users). This deployment
    style enables more fine-grained control of the extent of the release as compared
    to rolling deployment.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**金丝雀部署**：这是一种滚动部署的变体，流量以受控和分阶段的方式路由到新实例，通常是一个递增的比例的请求量（例如，2% → 25% → 75% →
    100%的用户）。这种部署风格与滚动部署相比，能够更精细地控制发布范围。'
- en: '**A/B deployment**: A variation of canary deployment where multiple versions
    (with one or more variations) of new functionality may run simultaneously as “experiments”
    along with the current version. Further, these variations may be targeted to specific
    sets of users. It allows for testing more than two combinations at the same time
    with real users.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**A/B 部署**：这是一种金丝雀部署的变体，其中多个版本（带有一个或多个变体）的新功能可以与当前版本同时作为“实验”运行。此外，这些变体可以针对特定的用户组。这允许同时测试超过两个组合，并使用真实用户进行测试。'
- en: When working with monolithic applications, teams are usually forced to restrict
    themselves to either basic or at the most blue-green deployments because the cost
    and complexity involved in adopting more sophisticated deployment strategies are
    a lot higher. On the other hand, distributed monoliths make this even more complicated
    because it now requires coordination among physically disparate components and
    teams. As long as we are able to maintain a balance between component granularity
    and coupling, we should be able to support a variety of advanced deployment strategies.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当与单体应用一起工作时，团队通常被迫限制自己仅使用基本部署或最多蓝绿部署，因为采用更复杂的部署策略的成本和复杂性要高得多。另一方面，分布式单体使这个问题变得更加复杂，因为它现在需要协调物理上分散的组件和团队。只要我们能够在组件粒度和耦合之间保持平衡，我们就应该能够支持各种高级部署策略。
- en: In today’s modern ecosystem where there is a tremendous amount of competition
    to deliver new features and innovate faster, there is a need to support more complex
    forms of deployment with the least amount of risk and disruption to the business.
    If supporting flexible deployment strategies proves to be too hard, there is very
    likely a need to re-examine your context boundaries.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在今天这个现代生态系统中，为了在竞争中提供新功能和更快地创新，我们需要以最小的风险和业务中断来支持更复杂的部署形式。如果支持灵活的部署策略证明过于困难，那么很可能需要重新审视你的上下文边界。
- en: Refactoring
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重构
- en: Over a period of time, there will be a need to realign context boundaries, domain
    events, APIs, and so on. There tends to be a stigma associated with things not
    working perfectly the first time and justifying the need for refactoring at the
    inter-component scale. However, this may be required for multiple reasons outside
    our control, ranging from competitor ecosystem changes, evolving/misunderstood
    requirements, inability to meet non-functional requirements, organizational and
    team responsibility changes, and so on. Hence, refactoring is a core discipline
    that software teams will need to embrace as a first-class practice.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在一段时间内，将需要重新调整上下文边界、领域事件、API 等等。通常，与第一次不完美工作相关的事情和需要在组件间规模上进行重构的需要会带来一种耻辱感。然而，这可能是由于我们无法控制的多重原因所必需的，包括竞争对手生态系统变化、不断演变/误解的需求、无法满足非功能性要求、组织和个人责任的变化等等。因此，重构是软件团队需要接受的核心学科，作为一项一级实践。
- en: Note
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: We are covering only the strategic (inter-component) aspects of refactoring
    in this chapter. There are several great works on the tactical (intra-component)
    aspects of refactoring, such as Martin Fowler’s *Refactoring* ([https://refactoring.com/](https://refactoring.com/))
    book and Michael Feathers’ *Working Effectively with Legacy Code*, among others.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中仅涵盖重构的战略（组件间）方面。关于重构的战术（组件内）方面有许多优秀的作品，例如马丁·福勒的《重构》（[https://refactoring.com/](https://refactoring.com/)）一书和迈克尔·费瑟斯的《与遗留代码高效工作》，以及其他作品。
- en: From a strategic perspective, this may mean having to break an existing monolith
    into finer-grained bounded contexts or merge fine-grained bounded contexts into
    more coarse-grained ones. Let’s look at each of these in turn.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 从战略角度来看，这可能意味着必须将现有的单体分解成更细粒度的边界上下文，或者将细粒度的边界上下文合并成更粗粒度的上下文。让我们逐一探讨这些内容。
- en: Breaking an existing monolith
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 打破现有的单体
- en: 'In previous chapters (10 and 11), we have looked at how it is possible to break
    an existing monolith into finer-grained components. However, it is arguable that
    the monolith was relatively well-structured to start with. Lots of teams may not
    be as fortunate. In such a case, here are some prerequisites that may need to
    be fulfilled:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节（第10章和第11章）中，我们探讨了如何将现有的单体拆分成更细粒度的组件。然而，可以说单体一开始的结构相对较好。许多团队可能没有这么幸运。在这种情况下，以下是一些可能需要满足的先决条件：
- en: '**Perform tactical refactorings**: This will allow you to gain a better understanding
    of the existing system. To do this, start with a set of fitness functions ([https://en.wikipedia.org/wiki/Fitness_function](https://en.wikipedia.org/wiki/Fitness_function))
    and a set of black-box functional tests, perform a refactor, and then replace
    the functional tests with faster-running unit tests. Finally, use the fitness
    functions to evaluate the success of the effort. Repeat this process until there
    is a level of comfort to attempt more complex refactorings.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**执行战术重构**：这将帮助你更好地理解现有系统。为此，从一个健身函数集([https://en.wikipedia.org/wiki/Fitness_function](https://en.wikipedia.org/wiki/Fitness_function))和一个黑盒功能测试集开始，执行重构，然后用运行速度更快的单元测试替换功能测试。最后，使用健身函数来评估这项工作的成功程度。重复此过程，直到达到尝试更复杂重构的舒适度。'
- en: '![Figure 12.3 – Continuous improvement loop'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.3 – 持续改进循环](img/B16716_Figure_12.3_NEW.jpg)'
- en: '](img/B16716_Figure_12.3_NEW.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.3 – 持续改进循环](img/B16716_Figure_12.3_NEW.jpg)'
- en: Figure 12.3 – Continuous improvement loop
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.3 – 持续改进循环
- en: '**Introduce domain events**: Identify software seams ([http://wiki.c2.com/?SoftwareSeam](http://wiki.c2.com/?SoftwareSeam))
    and publish domain events along those seams. Use the domain events to start decoupling
    the producers and the consumers.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**引入领域事件**：识别软件缝隙([http://wiki.c2.com/?SoftwareSeam](http://wiki.c2.com/?SoftwareSeam))并沿着这些缝隙发布领域事件。使用领域事件来开始解耦生产者和消费者。'
- en: '**Pick low-hanging components**: If possible, pick areas with low afferent
    coupling and low to medium complexity at the outset. This will allow you to get
    a firmer grasp of applying these techniques before attempting more complex ones.
    Please refer to [*Chapter 10*](B16716_10_Final_NM_ePub.xhtml#_idTextAnchor150),
    *Beginning the Decomposition Journey* and [*Chapter 11*](B16716_11_Final_NM_ePub.xhtml#_idTextAnchor164),
    *Decomposing into Finer-Grained Components* for details on how to proceed.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**选择低垂的组件**：如果可能的话，一开始选择具有低输入耦合和低到中等复杂性的区域。这将使你在尝试更复杂的组件之前，对这些技术的应用有更牢固的把握。请参阅[*第10章*](B16716_10_Final_NM_ePub.xhtml#_idTextAnchor150)《开始分解之旅》和[*第11章*](B16716_11_Final_NM_ePub.xhtml#_idTextAnchor164)《分解为更细粒度的组件》以了解如何进行下一步。'
- en: Merging into coarse-grained bounded contexts
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 合并到粗粒度边界上下文
- en: 'Merging two distinct bounded contexts can be relatively less complex than breaking
    down an existing one. However, there are a few nuances that are worth paying attention
    to, in the following order:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 将两个不同的边界上下文合并可能比拆解现有的一个要简单一些。然而，有几个细微之处值得注意，顺序如下：
- en: '**Unification of the ubiquitous language**: In [*Chapter 9*](B16716_09_Final_NM_ePub.xhtml#_idTextAnchor138),
    *Integrating with External Systems*, we examined a variety of ways in which bounded
    contexts can integrate with each other. If the relationship between these bounded
    contexts is symmetric, there may be less work to do. This is because, in a symmetric
    relationship, there likely exists a lot of synergies in the first place. However,
    if the relationship is asymmetric, for example, through an open-host service on
    the producer side and an anti-corruption layer on the consuming side, it means
    that there are possibly two varying ubiquitous languages and likely distinct domain
    models at play. Careful thought will need to be applied to arrive at a ubiquitous
    language that is applicable across the newly merged bounded context.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通用语言的统一**：在[*第9章*](B16716_09_Final_NM_ePub.xhtml#_idTextAnchor138)《与外部系统集成》中，我们探讨了各种边界上下文之间相互集成的多种方式。如果这些边界上下文之间的关系是对称的，那么可能需要做的工作会少一些。这是因为，在对称关系中，一开始很可能存在很多协同效应。然而，如果关系是不对称的，例如，通过生产侧的开放主机服务和消费侧的反腐败层，这意味着可能存在两种不同的通用语言和可能不同的领域模型。为了达到适用于新合并的边界上下文的通用语言，需要仔细思考。'
- en: '**Adjust internal domain models**: Adoption of a common ubiquitous language
    primarily means making use of a common domain model across the newly merged bounded
    context. This means that the aggregates, entities, and value objects will need
    to be unified, which may then require changes at the persistence layer as well.
    If there are domain events that are published and consumed exclusively between
    these components, those domain events may be candidates to be retired. At this
    stage, it may not be prudent to make any changes to any public interfaces – specifically
    those exposed using an open-host service (for example, public HTTP APIs and other
    domain events).'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**调整内部领域模型**：采用通用通用语言的主要意义在于，在刚刚合并的边界上下文中使用一个通用的领域模型。这意味着聚合、实体和值对象需要统一，这可能会要求在持久化层进行更改。如果存在仅在组件之间发布和消费的领域事件，那么这些领域事件可能是退休的候选者。在这个阶段，对任何公共接口进行更改可能并不明智——特别是那些使用开放主机服务（例如，公共HTTP
    API和其他领域事件）公开的接口。'
- en: '**Adjust the public API design**: As a final step, it will be prudent to refactor
    redundant and/or inefficient public interfaces to conclude the exercise and derive
    the intended benefits.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**调整公共API设计**：作为最后一步，重构冗余和/或低效的公共接口，以完成练习并获得预期的收益。'
- en: It is pertinent to note that this style of continuous improvement can be extremely
    challenging to adopt without the solid bedrock of a sound set of engineering practices,
    specifically the testing and deployment automation practices that we discussed
    in this section.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 有必要指出，没有一套坚实的工程实践作为坚实基础，这种持续改进的风格可能极具挑战性，特别是我们在本节中讨论的测试和部署自动化实践。
- en: Invocation style
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调用风格
- en: 'When integrating two bounded contexts that are running in distinct processes,
    there are two ways to consummate interactions: synchronous and asynchronous.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 当将运行在不同进程中的两个边界上下文集成时，有两种方式来完成交互：同步和异步。
- en: Synchronous invocation
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 同步调用
- en: 'The client blocks until the server provides a response. Optionally, implementations
    can choose to wait for an amount of time for the invoked operation to complete
    before timing out. An example of such an interaction is a blocking HTTP call made
    to start a new LC application like so:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端会阻塞，直到服务器提供响应。实现可以选择等待一定时间，以便在超时之前完成被调用的操作。这种交互的一个例子是，像这样对一个启动新LC应用的HTTP调用进行阻塞：
- en: '![Figure 12.4 – Synchronous invocation'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.4 – 同步调用](img/B16716_Figure_12.4.jpg)'
- en: '](img/B16716_Figure_12.4.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.4](img/B16716_Figure_12.4.jpg)'
- en: Figure 12.4 – Synchronous invocation
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.4 – 同步调用
- en: When the call returns successfully, the client is sure that their request to
    create a new LC application has worked. If the server is slow to respond, it can
    result in a performance bottleneck, especially in high-scale scenarios. To cope
    with this, the client and the server may agree on a response time SLO for that
    interaction. The client can choose to wait for a response from the server for
    the agreed amount of time after which the client times out the request and considers
    it a failure. Given that the client blocks on a server response, it is not able
    to do anything else while it waits, even though it may have the resources to do
    other things. To deal with this, the client can employ an asynchronous invocation.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用成功返回时，客户端可以确信他们创建新LC应用的请求已经成功。如果服务器响应缓慢，可能会导致性能瓶颈，尤其是在高规模场景中。为了应对这种情况，客户端和服务器可以就那个交互的响应时间SLO达成一致。客户端可以选择等待服务器响应，等待约定的时间后，客户端超时请求并认为它失败。鉴于客户端在服务器响应上阻塞，它在等待期间无法做其他任何事情，尽管它可能拥有做其他事情的资源。为了处理这种情况，客户端可以采用异步调用。
- en: Asynchronous invocation
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异步调用
- en: 'In an asynchronous style of invocation, the client interacts with the server
    in a manner that frees it to perform other activities. There are a few ways to
    do this:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在异步调用风格中，客户端以使其能够执行其他活动的方式与服务器交互。有几种方法可以做到这一点：
- en: '**Fire and forget**: The client initiates a request with the server, but does
    not wait for a response from the server and also does not care about the outcome.
    Such a style of interaction may suffice for *low-priority* activities such as
    logging to a remote server, push notifications, and so on.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**触发并忘记**：客户端向服务器发起请求，但不等待服务器的响应，也不关心结果。这种交互风格可能适用于*低优先级*活动，如向远程服务器记录日志、推送通知等。'
- en: '![Figure 12.5 – Fire and forget'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.5 – 触发并忘记](img/B16716_Figure_12.5.jpg)'
- en: '](img/B16716_Figure_12.5.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.5](img/B16716_Figure_12.5.jpg)'
- en: Figure 12.5 – Fire and forget
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.5 – 火速遗忘
- en: '**Deferred response**: In some (many?) cases, the client may need to know the
    outcome of the request they had previously made. If the server supports it, the
    client can submit a request, just wait for a confirmation that the request was
    received along with an identifier of the resource to be tracked, and then poll
    the server to track the status of its original request as shown here:'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**延迟响应**：在某些（很多？）情况下，客户端可能需要知道他们之前发出的请求的结果。如果服务器支持，客户端可以提交一个请求，只需等待确认请求已被接收，并附带要跟踪的资源标识符，然后轮询服务器以跟踪其原始请求的状态，如下所示：'
- en: '![Figure 12.6 – Deferred response using poll'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 12.6 – 使用轮询的延迟响应'
- en: '](img/B16716_Figure_12.6.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B16716_Figure_12.6.jpg)'
- en: Figure 12.6 – Deferred response using poll
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.6 – 使用轮询的延迟响应
- en: '**Request with callback**: When the client polls for the response, the server
    may not be finished with processing the original request. This means that the
    client may need to poll the server more than once to understand the status of
    the request, which can be wasteful. An alternative is for the server to push a
    response back to the client when it has finished processing by invoking a callback
    that the client provided when making the request.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**带有回调的请求**：当客户端轮询响应时，服务器可能还没有完成对原始请求的处理。这意味着客户端可能需要多次轮询服务器才能了解请求的状态，这可能是浪费的。一种替代方案是，当服务器完成处理时，通过调用客户端在发出请求时提供的回调函数，将响应推回客户端。'
- en: '![Figure 12.7 – Deferred response using callback'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 12.7 – 使用回调的延迟响应'
- en: '](img/B16716_Figure_12.7.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B16716_Figure_12.7.jpg)'
- en: Figure 12.7 – Deferred response using callback
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.7 – 使用回调的延迟响应
- en: Given that these interactions happen over a network that can be unreliable,
    clients and servers need to employ a variety of techniques to achieve some semblance
    of reliability. For example, clients may need to implement support for timeouts,
    retries, compensating transactions, client-side load balancing, and so on. Similarly,
    the server may need to protect itself from errant clients by making use of techniques
    such as rate limiters, circuit breakers, bulkheads, fallbacks, health endpoints,
    and so on.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些交互发生在可能不可靠的网络中，客户端和服务器需要采用各种技术来实现某种程度的可靠性。例如，客户端可能需要实现超时、重试、补偿事务、客户端负载均衡等功能的支持。同样，服务器可能需要通过使用速率限制器、断路器、防护舱、回退、健康端点等技术来保护自己免受错误客户端的影响。
- en: Note
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Elaborating on the specific techniques mentioned here is out of scope for this
    book. Books such as *Release It* and *Mastering Non-Functional Requirements* cover
    these patterns in a lot more depth.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 对这里提到的具体技术进行详细阐述超出了本书的范围。像《Release It》和《Mastering Non-Functional Requirements》这样的书籍对这些模式进行了更深入的探讨。
- en: In a lot of cases, there is usually a need to employ a combination of several
    of the preceding techniques to provide a resilient solution. Just as we discussed
    in the logging section, mixing these concerns with core business logic can obscure
    the original intent of the problem. In order to avoid this, it is advisable to
    apply these patterns in a manner that is peripheral to core business logic. It
    may also be prudent to consider the use of libraries such as Resilience4j ([https://resilience4j.readme.io/](https://resilience4j.readme.io/))
    or Sentinel ([https://github.com/alibaba/Sentinel](https://github.com/alibaba/Sentinel)).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在很多情况下，通常需要结合使用前面提到的几种技术来提供一种弹性解决方案。正如我们在日志记录部分讨论的那样，将这些关注点与核心业务逻辑混合可能会模糊问题的原始意图。为了避免这种情况，建议将这些模式应用于核心业务逻辑之外。也可能明智地考虑使用Resilience4j
    ([https://resilience4j.readme.io/](https://resilience4j.readme.io/)) 或 Sentinel
    ([https://github.com/alibaba/Sentinel](https://github.com/alibaba/Sentinel)) 等库。
- en: Logging
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 日志记录
- en: 'Application logging is one of the most fundamental aids when it comes to diagnosing
    issues in running code. In a lot of code bases, logging tends to be an after-thought
    where developers add log statements only after they encounter problems. This results
    in log statements being strewn almost randomly throughout the code base. Here
    is a simple example of code within a command handler to log its execution time
    among other things:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 应用日志记录是诊断运行代码问题时最基本的支持之一。在许多代码库中，日志记录往往是在遇到问题后才被考虑的，开发者只在遇到问题时才添加日志语句。这导致日志语句几乎随机地散布在整个代码库中。以下是一个简单的示例，展示了命令处理器中的代码，用于记录其执行时间等：
- en: '![](img/ch12-1.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ch12-1.jpg)'
- en: There is no doubt that this logging code can be invaluable when troubleshooting
    issues. However, when we look at the preceding code, the logging code seems to
    dominate the entire method obscuring the domain logic. This might feel innocuous,
    but when this is done in multiple places, it can get quite repetitive, cumbersome,
    and error-prone – compromising readability. In fact, we have seen cases where
    seemingly innocent log statements have introduced performance issues (for example,
    within a loop with an expensive argument evaluation) or even bugs (for example,
    the dreaded `NullPointerException` when trying to evaluate arguments). In our
    opinion, it is very important to treat logging as a first-class citizen and afford
    it the same rigor as core domain logic. This means that it needs to obey all the
    good practices that we associate with well-factored production code.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 毫无疑问，这段日志代码在调试问题时非常有价值。然而，当我们查看前面的代码时，日志代码似乎占据了整个方法，掩盖了领域逻辑。这可能会感觉无害，但当这种做法在多个地方进行时，它可能会变得相当重复、繁琐且容易出错——影响可读性。实际上，我们见过看似无害的日志语句引入了性能问题（例如，在具有昂贵参数评估的循环中）或甚至错误（例如，在尝试评估参数时可怕的`NullPointerException`）。在我们看来，将日志视为一等公民，并给予它与核心领域逻辑相同的严谨性非常重要。这意味着它需要遵守我们与良好设计的生产代码相关联的所有良好实践。
- en: Segregating logging code
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分离日志代码
- en: 'Ideally, we will be able to maintain a balance between readability and debuggability.
    This can be achieved if we can segregate these two concerns. One way to segregate
    this cross-cutting logic is to use aspect-oriented programming (read more about
    AOP at [https://www.eclipse.org/aspectj/](https://www.eclipse.org/aspectj/) and
    [https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#aop](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#aop))
    as shown here:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，我们将能够在可读性和可调试性之间保持平衡。如果我们能够分离这两个关注点，就可以实现这一点。分离这种横切逻辑的一种方法是通过使用面向切面编程（了解更多关于AOP的信息，请参阅[https://www.eclipse.org/aspectj/](https://www.eclipse.org/aspectj/)和[https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#aop](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#aop)）如下所示：
- en: '![](img/ch12-2.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ch12-2.jpg)'
- en: Note
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: A pointcut defines an `around` aspect for all methods annotated with the `@CommandHandler`
    annotation. In this example, we are using compile-time weaving as opposed to runtime
    weaving available through the Spring Framework, to inject execution time logic
    using AspectJ. You can find more details on the pros and cons of using specific
    weaving techniques in this article ([https://www.baeldung.com/spring-aop-vs-aspectj](https://www.baeldung.com/spring-aop-vs-aspectj)).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 一个切入点定义了所有使用`@CommandHandler`注解的方法的`around`方面。在这个例子中，我们使用编译时织入，而不是通过Spring框架提供的运行时织入，来使用AspectJ注入执行时间逻辑。你可以在本文中找到更多关于使用特定织入技术的优缺点的详细信息（[https://www.baeldung.com/spring-aop-vs-aspectj](https://www.baeldung.com/spring-aop-vs-aspectj)）。
- en: In the style shown here, we have separated logging code from application code
    through the use of aspect-oriented programming. In the example, the logging code
    applies to all methods annotated with the `@CommandHandler` annotation. This has
    the advantage that all such methods will now produce consistent entry/exit logging
    statements. On the flip side, if there is a need for additional logging for a
    specific command handler, it will still have to be done within the body of that
    method. If you see yourself requiring lots of ad hoc logging statements in addition
    to simple entry/exit logs, it might be a smell and a sign that your methods may
    need to be refactored.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里所示的风格中，我们通过使用面向切面编程将日志代码与应用程序代码分离。在示例中，日志代码适用于所有使用`@CommandHandler`注解的方法。这有一个优点，即所有这样的方法现在都将产生一致的进入/退出日志语句。另一方面，如果需要对特定命令处理器进行额外的日志记录，仍然需要在那个方法的主体内完成。如果你发现自己需要大量临时的日志语句，除了简单的进入/退出日志之外，这可能是一个信号，表明你的方法可能需要重构。
- en: Dealing with sensitive data
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理敏感数据
- en: In general, when adding logging code, it helps to include as much context as
    possible. This can be challenging in certain domains such as healthcare or finance
    where there may be legal/regulatory requirements to restrict access to sensitive
    information. For example, during the LC application process, we may need to perform
    a credit check for the applicant using their government-issued identifier such
    as the `toString` method of an `SSN` value type can ensure that the sanctity of
    the business need is met uniformly within the bounded context.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，在添加日志代码时，包括尽可能多的上下文信息是有帮助的。在某些领域，如医疗保健或金融，可能存在法律/监管要求限制对敏感信息的访问，这可能会带来挑战。例如，在LC申请过程中，我们可能需要使用申请人的政府颁发的标识符（例如`toString`方法）对申请人的信用进行检查，以确保在有限上下文中满足业务需求的完整性。
- en: While masking may suffice in a majority of use cases, it suffers from the limitation
    of not being able to access the original information even by authorized users.
    If this is a requirement, it may be necessary to make use of **tokenization**
    (the process of replacing a sensitive piece of information with a non-sensitive
    placeholder value called a **token**) solution. This can allow logging tokenized
    values in an unrestricted manner within the bounded context and in general, can
    be a lot more secure. But this can mean having to deal with the additional complexity
    of another bounded context to provide tokenized values and authorization controls
    when the real value needs to be accessed.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然掩码可能在大多数用例中足够使用，但它存在一个限制，即即使是有权限的用户也无法访问原始信息。如果这是一个要求，可能需要利用**令牌化**（用一个称为**令牌**的非敏感占位符值替换敏感信息的过程）解决方案。这可以在有限上下文中不受限制地记录令牌化值，并且通常可以提供更高的安全性。但这可能意味着必须处理另一个有限上下文的额外复杂性，以提供令牌化值和授权控制，当需要访问真实值时。
- en: Log format
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 日志格式
- en: 'Thus far, we have focused on just the log message. However, logging is more
    than just that. It is typical to include additional information such as the time
    of occurrence, log level, and so on to aid in rapid troubleshooting. For example,
    Spring Boot uses the following log format by default:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只关注了日志消息。然而，日志不仅仅是这些。通常还会包括其他信息，如发生时间、日志级别等，以帮助快速故障排除。例如，Spring Boot默认使用以下日志格式：
- en: '`2022-06-05 10:57:51.253 INFO 45469 --- [ost-startStop-1] c.p.lc.app.domain.LCApplication
    : Root WebApplicationContext: Ending StartNewLCApplication in 1200495 ns.`'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`2022-06-05 10:57:51.253 INFO 45469 --- [ost-startStop-1] c.p.lc.app.domain.LCApplication
    : Root WebApplicationContext: Ending StartNewLCApplication in 1200495 ns.`'
- en: 'While this is an excellent default, it still is primarily unstructured text
    with certain information being lost in order to improve readability (for example,
    the logger name is abbreviated). While logs are primarily meant to be consumed
    by humans, a large volume of logs can get in the way of being able to locate the
    relevant logs. So it is important to produce logs that are also machine-friendly
    so that they can be easily indexed, searched, filtered, and so on. In other words,
    using a *structured logging* format like the one shown next can go a long way
    toward meeting the goals of both machine and human readability:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这是一个很好的默认设置，但它仍然主要是非结构化文本，为了提高可读性而丢失了一些信息（例如，记录器名称被缩写）。虽然日志主要是供人类消费的，但大量日志可能会妨碍找到相关的日志。因此，生成既适合机器又适合人类阅读的日志非常重要，这样它们就可以轻松地进行索引、搜索、过滤等操作。换句话说，使用如以下所示的结构化日志格式可以大大有助于满足机器和人类可读性的目标：
- en: '![](img/ch12-3.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ch12-3.jpg)'
- en: Making use of a structured log format elevates their use from being just a debugging
    tool to becoming yet another rich and cheap source to derive actionable business
    insights.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 利用结构化日志格式可以将日志的使用从仅仅是一个调试工具提升为另一个丰富且廉价的业务洞察来源。
- en: Note
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: While it may be tempting to pick a custom log format, we strongly recommend
    picking formats that are compatible with popular ones such as Apache’s **Common
    Log Format** (**CLF**) ([https://httpd.apache.org/docs/current/logs.html#common](https://httpd.apache.org/docs/current/logs.html#common))
    or Logstash’s default format ([https://github.com/logfellow/logstash-logback-encoder#standard-fields](https://github.com/logfellow/logstash-logback-encoder#standard-fields)).
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然选择自定义日志格式可能很有吸引力，但我们强烈建议选择与流行的格式兼容的格式，例如 Apache 的**通用日志格式**（**CLF**）（[https://httpd.apache.org/docs/current/logs.html#common](https://httpd.apache.org/docs/current/logs.html#common)）或
    Logstash 的默认格式（[https://github.com/logfellow/logstash-logback-encoder#standard-fields](https://github.com/logfellow/logstash-logback-encoder#standard-fields)）。
- en: Log aggregation
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 日志聚合
- en: The fact that our applications are decomposed into multiple components with
    each usually running multiple instances means that this can produce a lot of logs
    that are disconnected from each other. To be able to work with these logs meaningfully,
    we need to aggregate and sequence them chronologically. It may be worth considering
    the use of a formal log aggregation solution for this purpose. Using a structured
    logging solution as previously discussed can go a long way when working with logs
    from multiple systems.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 事实是我们的应用程序被分解成多个组件，每个组件通常运行多个实例，这意味着这可能会产生大量的日志，这些日志彼此之间是断开的。为了能够有意义地处理这些日志，我们需要按时间顺序聚合和排序它们。考虑使用正式的日志聚合解决方案可能是值得的。正如之前讨论的那样，使用结构化日志解决方案在处理来自多个系统的日志时可以大有裨益。
- en: Note
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: For more information on logging best practices, please refer to this logging
    cheatsheet from OWASP ([https://github.com/OWASP/CheatSheetSeries/blob/master/cheatsheets/Logging_Cheat_Sheet.md](https://github.com/OWASP/CheatSheetSeries/blob/master/cheatsheets/Logging_Cheat_Sheet.md))
    and also this article on the art of logging ([https://www.codeproject.com/Articles/42354/The-Art-of-Logging](https://www.codeproject.com/Articles/42354/The-Art-of-Logging)).
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 关于日志最佳实践的更多信息，请参阅 OWASP 的这个日志备忘单（[https://github.com/OWASP/CheatSheetSeries/blob/master/cheatsheets/Logging_Cheat_Sheet.md](https://github.com/OWASP/CheatSheetSeries/blob/master/cheatsheets/Logging_Cheat_Sheet.md)）以及关于日志艺术的这篇文章（[https://www.codeproject.com/Articles/42354/The-Art-of-Logging](https://www.codeproject.com/Articles/42354/The-Art-of-Logging)）。
- en: Aggregating logs in one place allows us to view diagnostic information from
    multiple applications. However, we still need to correlate this information when
    in the midst of a flow. Distributed tracing solutions can help with this. Let’s
    look at this next.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个地方聚合日志允许我们查看来自多个应用程序的诊断信息。然而，在流程进行中，我们仍然需要关联这些信息。分布式追踪解决方案可以帮助我们做到这一点。让我们看看下一个例子。
- en: Tracing
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 追踪
- en: 'Imagine a situation where an applicant submitted an LC application through
    the UI. When all goes well, within a few milliseconds, the applicant should get
    a notification of successful submission as shown here:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个场景，申请者通过用户界面提交了 LC 申请。如果一切顺利，在几毫秒内，申请者应该会收到成功提交的通知，如下所示：
- en: '![Figure 12.8 – Submit LC application flow'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 12.8 – 提交 LC 应用流程'
- en: '](img/B16716_Figure_12.8.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 12.8 – 提交 LC 应用流程](img/B16716_Figure_12.8.jpg)'
- en: Figure 12.8 – Submit LC application flow
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.8 – 提交 LC 应用流程
- en: Even in this simple example, there are several components involved, each of
    which produces logs of its own. When an engineer is looking to diagnose an issue,
    there is a need to correlate log entries from multiple components. In order to
    accomplish this, there is a need to introduce a correlation identifier as close
    to the start of the interaction and propagate it across component boundaries.
    Furthermore, log entries in each component need to carry this correlation identifier
    as they produce logs. Doing this will allow us to view log entries spanning process
    boundaries using the correlation identifier as a unifying thread. In technical
    terms, the entire flow is called a *trace*, and each segment within the flow is
    called a *span*. This process of instrumenting log entries with such information
    is termed *distributed tracing*.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在这个简单的例子中，也有几个组件参与，每个组件都会产生自己的日志。当工程师试图诊断问题时，需要关联来自多个组件的日志条目。为了实现这一点，需要在交互开始时尽可能早地引入一个关联标识符，并将其传播到组件边界之外。此外，每个组件中的日志条目在产生日志时需要携带这个关联标识符。这样做将允许我们通过关联标识符作为统一线索来查看跨越进程边界的日志条目。从技术角度来说，整个流程被称为*追踪*，流程中的每个部分被称为*跨度*。在日志条目上添加此类信息的这个过程被称为*分布式追踪*。
- en: As is evident here, user flows may – and usually do – span more than one bounded
    context. For this to work effectively, bounded contexts need to agree on propagating
    trace and span identifiers uniformly. Tools such as Spring Cloud Sleuth and OpenTracing
    can help simplify implementation for teams using disparate technology stacks.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如此明显，用户流程可能——并且通常确实——跨越多个边界上下文。为了有效地工作，边界上下文需要就统一传播跟踪和跨度标识符达成一致。例如，Spring Cloud
    Sleuth和OpenTracing等工具可以帮助简化使用不同技术栈的团队的实施。
- en: Fundamentally, distributed tracing visualizations can aid in diagnosing performance
    bottlenecks and chattiness between components. But what may not be obvious is
    the insights it can provide in gaining a richer understanding of how components
    interact in an end-to-end user journey. In a lot of ways, this can be thought
    of as a near real-time context map visualization of your system, and how components
    are coupled with each other. From a DDD perspective, this can provide greater
    insights into re-evaluating bounded context boundaries if necessary. For this
    reason, we strongly recommend making it easy to set up and configure distributed
    tracing apparatus painlessly right from the outset.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，分布式跟踪可视化可以帮助诊断性能瓶颈和组件之间的嘈杂度。但可能不那么明显的是，它可以在获取对组件在端到端用户旅程中如何交互的更深入理解方面提供洞察。在许多方面，这可以被视为您系统的一个近实时上下文映射可视化，以及组件之间是如何相互耦合的。从领域驱动设计（DDD）的角度来看，这可以在必要时提供对重新评估边界上下文边界的更深入见解。因此，我们强烈建议从一开始就轻松设置和配置分布式跟踪设备，以便无痛苦地完成。
- en: Versioning
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 版本化
- en: When we are working with a monolithic application, we have large portions bundled
    as a single cohesive unit. This means that other than third-party dependencies,
    we don’t have to worry about explicitly versioning our own components. However,
    when we start breaking components into their individual deployable units, there
    is a need to pay careful attention to how the components, APIs, and data elements
    of our solution are versioned. Let’s look at each in turn.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们与单体应用程序一起工作时，大部分内容都捆绑成一个单一的统一单元。这意味着除了第三方依赖项之外，我们不必担心显式版本化我们的组件。然而，当我们开始将组件分解成它们各自的部署单元时，我们需要仔细注意我们的解决方案的组件、API和数据元素是如何进行版本化的。让我们逐一来看。
- en: Components
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组件
- en: When we create components, there are two broad categories – those that are **deployed**
    on their own and those that are **embedded** within another component. In the
    case of deployable components, there is a need to use an explicit version to identify
    specific instances of the component, even if only for deployment purposes. In
    the case of the embedded component, again there is a need to use an explicit version
    because other components need to understand what instance they depend upon. In
    other words, *all components* need to have a version to uniquely identify themselves.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建组件时，有两个广泛的类别——那些**独立部署**的组件和那些嵌入在其他组件中的组件。对于可部署组件，需要使用显式版本来标识组件的具体实例，即使只是为了部署目的。对于嵌入式组件，同样需要使用显式版本，因为其他组件需要理解它们依赖于哪个实例。换句话说，*所有组件*都需要有一个版本来唯一标识它们。
- en: 'It follows that we then need to choose a sound versioning strategy for our
    components. We recommend the use of semantic versioning ([https://semver.org/](https://semver.org/)),
    which uses a version identifier that uses three numeric components that match
    the **MAJOR.MINOR.PATCH** scheme:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要为我们的组件选择一个合理的版本化策略。我们推荐使用语义版本化（[https://semver.org/](https://semver.org/)），它使用一个版本标识符，该标识符采用三个数字组件，符合**主版本.次版本.修补版本**的方案：
- en: '**MAJOR**: Increment when you make backward-incompatible changes.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主版本（MAJOR）**：当你进行向后不兼容的更改时进行增量。'
- en: '**MINOR**: Increment when you add functionality in a backward-compatible manner.'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**次版本（MINOR）**：以向后兼容的方式添加功能时进行增量。'
- en: '**PATCH**: Increment when you make backward-compatible bug fixes.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**修补（PATCH）**：当你进行向后兼容的错误修复时进行增量。'
- en: In addition, we can make use of optional extensions to indicate pre-release
    and build metadata. For example, the version identifier for our component might
    read 3.4.1-RC1 to reflect that this is a release candidate for version 3.4.1 of
    our component. Using a standard versioning scheme enables the use of build tools
    such as Maven and Gradle to declare fine-grained upgrade rules and constraints
    for direct and transitive dependencies. A good practice here is to declare dependencies
    without versions and make use of dependency management ([https://maven.apache.org/guides/introduction/introduction-to-dependency-mechanism.html#Dependency_Management](https://maven.apache.org/guides/introduction/introduction-to-dependency-mechanism.html#Dependency_Management))
    or dependency constraints (https://docs.gradle.org/current/userguide/dependency_constraints.html#sec:adding-constraints-transitive-deps)
    to centralize version management of dependent components.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可以利用可选扩展来指示预发布和构建元数据。例如，我们组件的版本标识符可能为3.4.1-RC1，以反映这是我们组件3.4.1版本的发布候选。使用标准的版本控制方案可以启用构建工具（如Maven和Gradle）来声明对直接和间接依赖的细粒度升级规则和约束。这里的良好实践是声明不带版本的依赖项，并使用依赖管理([https://maven.apache.org/guides/introduction/introduction-to-dependency-mechanism.html#Dependency_Management](https://maven.apache.org/guides/introduction/introduction-to-dependency-mechanism.html#Dependency_Management))或依赖约束(https://docs.gradle.org/current/userguide/dependency_constraints.html#sec:adding-constraints-transitive-deps)来集中管理依赖组件的版本。
- en: APIs
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: API
- en: As producers, we expose APIs in a number of ways. In this case, we are specifically
    referring to APIs made available over remote interfaces such as HTTP, events,
    and so on. When it comes to APIs, first and foremost, it is important to keep
    consuming applications functionally. One effective way of making this possible
    is by thinking from the consumer’s standpoint and embracing consumer-driven contracts
    ([https://martinfowler.com/articles/consumerDrivenContracts.html](https://martinfowler.com/articles/consumerDrivenContracts.html)).
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 作为生产者，我们以多种方式公开API。在这种情况下，我们特别指的是通过远程接口（如HTTP、事件等）提供的API。当涉及到API时，最重要的是保持消费应用的功能性。实现这一点的有效方法是从消费者的角度思考，并采用消费者驱动的契约([https://martinfowler.com/articles/consumerDrivenContracts.html](https://martinfowler.com/articles/consumerDrivenContracts.html))。
- en: 'From a consumer’s perspective, the robustness principle (Postel’s law) applies:
    *be conservative in what you send, be liberal in what you accept*. In other words,
    when sending requests to providers, strictly obey the constraints laid down by
    the producer. For example, don’t send unexpected data in the request. Whereas,
    when receiving responses, be tolerant towards what you get from the producer.
    For example, ignore unknown attributes in the response as long as all the attributes
    you expect are present. This will allow producers to evolve without breaking existing
    consumers.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 从消费者的角度来看，稳健性原则（Postel定律）适用：*发送时要保守，接受时要宽容*。换句话说，当向提供者发送请求时，严格遵循生产者设定的约束。例如，不要在请求中发送意外数据。而当我们接收响应时，对来自生产者的内容要宽容。例如，只要所有期望的属性都存在，就可以忽略响应中的未知属性。这将允许生产者在不破坏现有消费者的情况下进行演变。
- en: 'Our recommendation is to keep APIs versionless for as long as possible by continuing
    to maintain backward compatibility. Despite all our efforts, there may come a
    need to make breaking changes to our APIs. Breaking changes include the following:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的建议是在尽可能长的时间内保持API无版本，通过继续维护向后兼容性。尽管我们付出了所有努力，但仍可能需要对我们API进行破坏性变更。破坏性变更包括以下内容：
- en: Removing/renaming one or more attributes
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除/重命名一个或多个属性
- en: Changing the type of one or more existing attributes
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改一个或多个现有属性的类型
- en: Changing the format of the request/response
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改请求/响应的格式
- en: In such cases, make use of a version identifier to indicate major version changes
    (for example, v2 to v3). Common options include specifying the version in the
    URI, in a header, or in the payload. But as we have mentioned earlier, API versioning
    needs to be used sparingly. If you find yourself in a situation where you are
    required to introduce backward-incompatible changes frequently, it might be an
    indicator of requirements being misunderstood and whether DDD principles are truly
    being applied.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，使用版本标识符来指示主要版本变更（例如，从v2到v3）。常见的选项包括在URI、标题或有效载荷中指定版本。但正如我们之前提到的，API版本化需要谨慎使用。如果你发现自己经常需要引入不向后兼容的变更，这可能表明需求被误解，以及DDD原则是否真正得到应用。
- en: Data
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据
- en: In a world of well-defined bounded contexts, we should no longer be in a situation
    where we need to expose data directly to our consumers. However, there may be
    situations where we may need to integrate by directly exposing data to our consumers.
    For example, we may have to expose a reporting database for analytical purposes.
    All the good practices that we outlined for APIs apply to data as well.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义明确的边界上下文中，我们不应再处于需要直接向消费者暴露数据的情况。然而，可能存在需要通过直接向消费者暴露数据来集成的情况。例如，我们可能需要为了分析目的而暴露一个报告数据库。我们为API概述的所有良好实践也适用于数据。
- en: In addition, from a producer’s perspective, there will be a need to evolve the
    data schema to accommodate changing business requirements. When working with relational
    databases, using good schema migration tools such as Liquibase ([https://liquibase.org/](https://liquibase.org/))
    or Flyway ([https://flywaydb.org/](https://flywaydb.org/)) can go a long way.
    NoSQL databases also have similar tools such as MongoBee ([https://github.com/mongobee/mongobee](https://github.com/mongobee/mongobee))
    and Cassandra-Migration ([https://cassandra.tools/cassandra-migration](https://cassandra.tools/cassandra-migration)).
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，从生产者的角度来看，将需要演进数据模式以适应不断变化的企业需求。当与关系型数据库一起工作时，使用如Liquibase ([https://liquibase.org/](https://liquibase.org/))
    或 Flyway ([https://flywaydb.org/](https://flywaydb.org/)) 这样的良好模式迁移工具可以大有裨益。NoSQL数据库也有类似的工具，如MongoBee
    ([https://github.com/mongobee/mongobee](https://github.com/mongobee/mongobee))
    和 Cassandra-Migration ([https://cassandra.tools/cassandra-migration](https://cassandra.tools/cassandra-migration))。
- en: In this context, it is pertinent to think about data as a product and apply
    product thinking to domain-aligned data. For more information, please refer to
    this article on how to move from a monolithic data lake to a distributed data
    mesh ([https://martinfowler.com/articles/data-monolith-to-mesh.html#DomainDataAsAProduct](https://martinfowler.com/articles/data-monolith-to-mesh.html#DomainDataAsAProduct)).
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个背景下，将数据视为产品并将产品思维应用于领域对齐的数据是相关的。有关如何从单体数据湖迁移到分布式数据网格的更多信息，请参阅这篇文章（[https://martinfowler.com/articles/data-monolith-to-mesh.html#DomainDataAsAProduct](https://martinfowler.com/articles/data-monolith-to-mesh.html#DomainDataAsAProduct)）。
- en: It is not uncommon to find ourselves in situations where there may be a need
    to support more than one active version of a given component, API, or data. This
    can add significant levels of complexity to the solution. To keep complexity in
    check, it is important to make provisions for deprecating and eventually ending
    support for older versions.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在可能需要支持给定组件、API或数据的一个以上活动版本的情况下，这种情况并不少见。这可能会给解决方案增加显著程度的复杂性。为了控制复杂性，重要的是要为废弃和最终停止对旧版本的支持做出规定。
- en: Summary
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we looked at aspects purely beyond functional requirements
    – each of which can have a profound impact on our ability to apply domain-driven
    design effectively. Specifically, we looked at how each of these is interrelated
    and they have to be looked at holistically to achieve and sustain high levels
    of success.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了纯粹超出功能需求方面的内容——每一方面都可能对我们有效应用领域驱动设计的能力产生深远影响。具体来说，我们探讨了这些方面的相互关系，以及为了实现和维持高水平成功，我们必须从整体上看待它们。
- en: Closing thoughts
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 收尾思考
- en: Domain-driven design, although conceived in the early 2000s, was way ahead of
    its time. We are in the age of solving the most complex problems yet. Given the
    advancements in technology, there is an expectation to build these solutions a
    lot faster. While the overall cognitive complexity of the solution is directly
    proportional to the complexity of the problem, there is a need to effectively
    manage this complexity. DDD and its principles enable us to achieve this by breaking
    down complex problems into smaller, manageable parts. In this book, we have made
    an attempt to distill our experiences and provide a set of concrete techniques
    to apply DDD in your respective contexts.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管领域驱动设计是在2000年代初构思的，但它远远领先于时代。我们现在处于解决最复杂问题的时代。鉴于技术的进步，人们期望以更快的速度构建这些解决方案。虽然解决方案的整体认知复杂性直接与问题的复杂性成正比，但我们需要有效地管理这种复杂性。DDD及其原则通过将复杂问题分解为更小、更易于管理的部分，使我们能够实现这一点。在这本书中，我们试图提炼我们的经验，并提供一套具体的技术，以在您各自的上下文中应用DDD。
