- en: Chapter 3. Developing the UI with Play Framework
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we performed bootstrapping on our application using
    Activator. In this chapter, we will continue developing our web application using
    Scala and Play framework. Play framework is great for web development because
    it is simple to use, and at the same time, very powerful. This is because it uses
    top-notch reactive solutions like spray, Akka, and Akka Stream under the hood.
    For this chapter, we will create the basic UI for some parts of our reactive web
    solution by adding validation and an in-memory store so you can feel the application
    working. We will use a little bit of CSS for styling, and JavaScript for some
    simple visualizations.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Basics of web development with Scala and Play frameworks
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating your models
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with views and validations
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with session scopes
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting started
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's have a look at the preview of `Reactive Web Store`--the application that
    we will build.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting started](img/image00256.jpeg)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
- en: For now, we will build three simple operations--**Create, Retrieve, Update,**
    and **Delete** (**CRUD**) in order to manage products, product reviews, and product
    images. We will create models, controllers, views, and routes for each CRUD.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: Let's get started. First of all, we need to define our models. The models need
    to be located at `ReactiveWebStore/app/models`. Models are the CORE of the system
    and they represent the entity. We will use this entity later to store and retrieve
    data from a database later on in [Chapter 6](part0071.xhtml#aid-23MNU1 "Chapter 6. 
    Persistence with Slick"), *Persistence with Slick*. Our models should not have
    any UI logic, since we should use controllers for UI logic.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: Creating our models
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For our product model, we have a simple Scala case class in `Product.scala`
    as follows:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: A product can have an optional ID, a name, details, and a price. We also override
    the `toString` method just for the sake of simplicity for logging. We also need
    to define models for image and review.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the review model from `Review.scala`:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: For a review model, we have an optional ID, an optional `productId`, one author,
    and a comment. Validations will be done on the views. Now let's go for the image
    model.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: 'The image model can be found in `Image.scala` as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: For an image model, we have an optional ID, an optional `productId`, and the
    image URL.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: The Play framework does the routing, and we need to define the routes at `ReactiveWebStore/conf/routes`.
    Keep in mind that the Play framework will validate all the routes, so you need
    to specify valid packages and classes. Play also creates something called reverse
    controller, which we will use later in the chapter. For now, let's define the
    routes. Reverse controller is generated by the Play framework with an action method
    which is the same as that of the original controller with the same signature,
    but it returns `play.api.mvc.Call` instead of `play.api.mvc.Action`.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: Creating routes
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Play framework CRUD operations'' routes for product, image, and review
    are as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The routes work like this--First you need to define the rest verb such as `GET`,
    `POST`, `PUT`, `DELETE`, and then you put in a `PATH` like `/image`. Finally,
    you specify which controller function will handle that route. Now we have the
    routes in place, we can move to the controllers. We will define the controllers
    for product, image and review.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: All the routes follow the same logic. First we send the user to the web page
    where we list all the items (products, images, reviews)--this is represented by
    `GET /resource`, where the resource can be an image, product, or review, for instance.
    In order to get a specific resource, often by ID, we give the command `GET /resource
    (product, review or image)/ID. POST /resource` is used to perform the `UPDATE`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: In order to create a new item (product, review, or image), the pattern is `GET
    /resource/add` and `POST /resource/`. You may wonder why there are two routes
    to perform an insert. Well, that's because first of all we need to load the web
    page, and secondly, when the form is submitted, we need a new route to handle
    the values. There are two routes for an update as well for the same reason. If
    you want to `DELETE` a resource, the pattern is `POST /resource/ID/remove`. Lastly,
    we have the details of the operation, which is used to show detailed information
    with regard to a specific item--the pattern is `GET /resource/details/ID`. With
    six routes, we can do a complete CRUD for a resource such as product, image, and
    review, or any other future resource that you may add to this application or your
    own applications.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: Creating our controllers
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now let's move to the controllers used on the previous routes. The controllers
    need to be located at `ReactiveWebStore/app/controllers`. Controllers are bound
    between views (UI), models and service, which are responsible for business operations.
    It's always important to separate UI logic, which tends to be specific, from business
    logic, which tends to be more generic, and often, way more important.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have a look at the product controller in `ProductController.scala` in
    the following code:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The Play framework uses dependency injection and inversion of control using
    Google Guice. So, you can see at the top of the controller that we have the annotations
    `@Singleton` and `@Inject`. Singleton means that Guice will create a single instance
    of the class to handle all requests. Inject means we are injecting other dependencies
    into our controller, for instance, we inject `MessagesApi` in order to have the Play
    framework internalization support for string messages, and `IProductService`,
    that is, the product service that we will cover later in this chapter.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: We also need to extend the Play class, `play.api.mvc.Controller`. Each function
    in a controller needs to return an action. This action could be a view.The Play
    framework compiles all the views into Scala classes, so you can safely reference
    them into your controllers code.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: All business operations are delegated to a trait called `IProductService`, which
    we will cover later in this chapter. We also log some information using the Logger
    class. Play Framework uses `Logback` as the default logging solution. Let's take
    a closer look at each controller function now.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: The index function calls `IProductService`, and finds all the available products.
    If there are no products available, it returns an empty sequence, and then calls
    the product UI passing the collection of products.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: The blank function renders a blank product form, so the user can have a blank
    product form on the UI in order to add data (insert operation). Play framework
    works with form binding. So, in each controller, you need to define how your form
    looks on the UI. That form mapping is done using `play.api.data.Form`. You can
    see the mapping on the immutable variable called `productForm`. The mapping is
    between the view(UI) and the model called product. Keep in mind that the name
    field is mapped as `NonEmptyText`, which means Play won't accept null or blank
    values. This is a great future, because we can do validations in a declarative
    way without having to write code. Price is defined as `BigDecimal`, so Play won't
    accept text, but only numbers.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: The details function retrieves a product using `IProductService`, and redirects
    to the view. However, before doing the redirect, it binds the data with the form
    so the UI will load with all the data into the HTML inputs.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: 'We also have the insert and update methods. They are all constructed with a
    `fold` method. The `fold` method has left and right, which means error or ok.
    The `fold` function is called from the mapped form and if there are no validation
    errors, it goes right, but if there are validations errors, it goes left. That''s
    a very simple and clean way to code the `update` and `insert` flows. With `fold`,
    we don''t need code for an `if` statement. Once the validation is OK, we call
    `IProductService` to do an insert or update, and then we perform a redirect to
    the view. Messages are passed via scope. Play has options for scope--session or
    Flash. Session is for multiple requests, and the value will be stored in the client
    side. Flash is a request scope, and most of the times that is what you need to
    use. Here we are using the `Flash` scope, so it will only exit during that specific
    request. This feature is used to pass **Internationalization messages** (**i18n**),
    which are the result of the action. All the i18n messages need to be defined at
    `ReactiveWebStore/conf/messages` as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Lastly, we have the remove method. First of all, we need to make sure the product
    exists, so we do a `findById` using `IProductService`, and then we apply a map
    function. If the product doesn't exist, the Play framework has prebuilt HTTP error
    code messages like `NotFound`. If the product exists, we remove it using `IProductService`,
    and then we redirect to the UI with a flashing message. Now let's see the image
    and review controllers.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: 'The review controller, `ReviewController.scala`, is as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The review controller follows the same ideas and structure as the product controller.
    The only main difference is that here we need to Inject `IProductService`, because
    a review needs to belong to a product. Then we need to use `IProductService` in
    order to `findAllProduct`, because in the review view, we will have `SelectBox`
    with all the available products.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: 'The image controller, `ImageController.scala`, is as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Image review works in a similar way to `ReviewController`. We need `IProductService`
    to get all the services.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: Working with services
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Services are where we put the business logic. We will look at reactive persistence
    in [Chapter 6](part0071.xhtml#aid-23MNU1 "Chapter 6.  Persistence with Slick"),
    *Persistence with Slick*. Right now, we don't have a database to persist information,
    so, for now, we will do an in-memory persistence.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: 'First we will define the contract of our services. This is the Base API that
    we will use in the controllers. Let''s take a look at the following trait in `BaseService.scala`:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the preceding code, we have an in-memory mutable `HashMap`, which is in our
    memory database where we will store products, images, and reviews. We also have
    an atomic counter with which we can generate IDs for our models. This is a trait
    using Generics--as you can see, here we have all the operations with `A`, which
    will be specified later. Now we can move the service implementation for product,
    review, and image.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ProductService.scala` package is as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the last code, we defined a trait called `IProductService`, which extends
    `BaseService` with a generic apply to product. The `ProductService` package implements
    `IProductService`. In Scala, we can have multiple classes in the same Scala file,
    so there is no need to create different files.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: 'The code is very straightforward. There is a utility method here called `findAllProducts`,
    which is used by review and image controllers. Here we get all the elements on
    the in-memory hash map. If there are no elements, we return a list with empty
    product. Then we map the list to a `Seq` of tuple, which is required by the `SelectBox`
    checkbox that we will have in the view(UI). Now let''s go for the image and review
    services  as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In the preceding code, we have something pretty similar to that of `ProductService`.
    We have a trait called `IImageService` and the `ImageService` implementation.
    Now let''s go for the review service implementation in `ReviewService.scala`as
    follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the preceding code, we have the `IReviewService` trait and the `ReviewService`
    implementation. We have validations on the service as well as a good practice.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the Guice module
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We injected classes using `@Inject` in our controllers. The injection happens
    based on a trait; we need to define a concrete implementation for the traits we
    injected. The Play framework looks for Guice injections at the location `ReactiveWebStore/app/Module.scala`.
    Okay, so let's define our injections for the three controllers we just created.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: 'The Guice module is found in `Module.scala`as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'So we just need to add `bind` with our traits for the controllers, and then
    point to the controller implementation. They should also be created as singletons,
    as the Play framework starts our application. Here you also can define any other
    configuration or injection that our application may need. The last code defines
    three services: product service, `IReviewService`, and `IImageService`.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: Working with views(UI)
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Play framework works with a Scala-based templating engine called Twirl.
    Twirl was inspired by ASP.NET Razor. Twirl is compact and expressive; you will
    see we can do more with less. Twirl template files are simple text files, however,
    the Play framework compiles the templates and turns them into Scala classes. You
    can mix HTML with Scala smoothly in Twirl.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: The UI will be compiled into a Scala class, that can and will be referenced
    at our controllers, because we can route to a view. The nice thing about it is
    that this makes our coding way safer, since we have the compiler checking for
    us. The bad news is that you need to compile your UI, otherwise, your controllers
    won't find it.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: 'Previously in this chapter, we defined controllers for products, images, and
    reviews, and we wrote the following code:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'With the preceding code, we redirect the user to a blank page for products
    so that the user can create a new product. We also can pass parameters to the
    UI. Since it is all Scala code, you are actually just calling a function as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the preceding code, we call the service to retrieve a product by ID, and
    then pass the object to the UI with the form being filled.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s continue building our application and create the UI for the products,
    reviews, and images. Since we are doing a CRUD, we will need more than one template
    file per CRUD. We will need the following structure:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: Index Template
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: List all items
  id: totrans-76
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Link to edit one item
  id: totrans-77
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Link to remove one item
  id: totrans-78
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Link to create a new Item
  id: totrans-79
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Detail Template
  id: totrans-80
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: HTML Form to create a new Item
  id: totrans-81
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: HTML form to edit an existing item(for update)
  id: totrans-82
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Having said that, we will have the following files:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: 'For Products:'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: product_index.scala.html
  id: totrans-85
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: product_details.scala.html
  id: totrans-86
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For Image:'
  id: totrans-87
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: image_index.scala.html
  id: totrans-88
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: image_details.scala.html
  id: totrans-89
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For Reviews:'
  id: totrans-90
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: review_index.scala.html
  id: totrans-91
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: review_details.scala.html
  id: totrans-92
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For the sake of code reuse, we will create another file containing the basic
    structure of our UI, like CSS imports (CSS needs to be located at `ReactiveWebStore\public\stylesheets`),
    JavaScript imports, and page title so that we don''t need to repeat that in all
    the templates for each CRUD. This page will be called: `main.scala.html`.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: All the UI code should be located at `ReactiveWebStore/app/views`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: 'The main Scala with the UI index for all CRUD operations is in `main.scala.html`,
    as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In the preceding code, first of all, there is the following line at the very
    top:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This means that we define the parameters this UI can receive. Here we expect
    a string title, which will be the page title, and there are some currying variables
    as well. You can get more details about currying in [Chapter 1](part0015.xhtml#aid-E9OE1
    "Chapter 1. Introduction to FP, Reactive, and Scala"), *Introduction to FP, Reactive,
    and Scala*. So in currying, there are two things: First is HTML, which means you
    can pass HTML code to this function, and second, we have `Flash` which the Play
    framework will pass for us. `Flash` is used to get parameters between requests.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, later in the code we have `@title`, which means we retrieve
    the title of the parameters, and add the value to the HTML. We also print any
    error message or any validations issues, if present, with `@alert`. We import
    JQuery and Twitter Bootstrap, but we do not put hard-coded paths. Instead, we
    use the routers like `@routes.Assets.at`. The Javascripts still need to be located
    at `ReactiveWebStore\public\javascripts`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，在代码的后面我们有`@title`，这意味着我们检索参数的标题，并将其添加到HTML中。我们还使用`@alert`打印任何错误消息或验证问题，如果有的话。我们导入JQuery和Twitter
    Bootstrap，但我们不使用硬编码的路径。相反，我们使用路由器如`@routes.Assets.at`。JavaScript仍然需要位于`ReactiveWebStore\public\javascripts`。
- en: Now other templates can work with `@main(..),` and they don't need any declaration
    of Javascript or CSS. They can add an extra HTML code, which will be rendered
    on the previous code by `@content`. So, for the products, the content will be
    HTML product content, and so on for reviews, and images. Now we can move for the
    products UI.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在其他模板可以使用`@main(..)`，并且它们不需要任何JavaScript或CSS的声明。它们可以添加额外的HTML代码，这些代码将通过`@content`在之前的代码上渲染。因此，对于产品，内容将是HTML产品内容，对于评论和图片也是如此。现在我们可以转向产品的UI。
- en: 'Product index: ­ UI index for products `product_index.scala.html`'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 产品索引：产品的UI索引`product_index.scala.html`
- en: '[PRE17]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'As you can see, there is HTML mixed with Scala code. Every time you need to
    run HTML, you just run it, and when you need run Scala code, you need use a special
    character, `@`. At the very top of the template, you can see the following code:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，Scala代码中混合了HTML。每次需要运行HTML时，只需运行它，需要运行Scala代码时，需要使用特殊字符`@`。在模板的顶部，您可以看到以下代码：
- en: '[PRE18]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Since this is Scala code in the end, and will be compiled, we need to define
    what parameters this UI template can receive. Here we expect a sequence of products.
    There is also a currying implicit variable called `Flash`, which will be provided
    by the Play framework, and we will use it for the message display. We also have
    the code-`@main("Products") { .. }`. This means that we call the main Scala template
    and add extra HTML--the product HTML. For this product UI, we list all the products
    based on the sequence of products. As you can see, we define an HTML table. We
    also validate if the sequence is not empty before listing all the products.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是最终的Scala代码，并且将被编译，我们需要定义这个UI模板可以接收哪些参数。在这里，我们期望一个产品序列。还有一个名为`Flash`的currying隐式变量，它将由Play框架提供，我们将用它来显示消息。我们还有代码`@main("Products")
    { .. }`。这意味着我们调用主Scala模板并添加额外的HTML——产品HTML。对于这个产品UI，我们根据产品序列列出所有产品。如您所见，我们定义了一个HTML表格。在列出所有产品之前，我们还验证序列是否为空。
- en: 'Now we can go for the details page for products in `product_details.scala.html` as
    follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以进入`product_details.scala.html`中的产品详情页面，如下所示：
- en: '[PRE19]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'For this preceding UI, at the very top, we have the following line:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个先前的UI，在最顶部，我们有以下一行：
- en: '[PRE20]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This means that we expect an ID which is completely optional. This ID is used
    to know if we are dealing with an insert scenario or an update scenario, because
    we use the same UI for both insert and update. We also get the product form, which
    will be passed through `ProductController`, and we receive `Flash`, which will
    be provided by the Play framework.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们期望一个完全可选的ID。这个ID用于知道我们是在处理插入场景还是更新场景，因为我们使用相同的UI来处理插入和更新。我们还获取产品表单，它将通过`ProductController`传递，并且我们接收`Flash`，它将由Play框架提供。
- en: 'We need to do some imports on the UI so that we can get access to the Play
    framework i18n support. This is done by the following:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在UI上进行一些导入，以便我们可以访问Play框架的i18n支持。这是通过以下方式完成的：
- en: '[PRE21]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Like the previous UI, we render this UI within the main Scala UI. So we don''t
    need to specify JavaScript and CSS again. This is done by the following code:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的UI一样，我们在主Scala UI中渲染这个UI。因此，我们不需要再次指定JavaScript和CSS。这是通过以下代码完成的：
- en: '[PRE22]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Next we check if there are any validation errors. If there are, the users will
    need to fix the errors before moving on. This is done by the following code:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们检查是否有任何验证错误。如果有，用户在继续之前需要修复这些错误。这是通过以下代码完成的：
- en: '[PRE23]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now is the time to create the product form, which, in the end, will be mapped
    to HTML input boxes. We do this with the following code:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是创建产品表单的时候了，最终它将被映射到HTML输入框。我们通过以下代码来完成：
- en: '[PRE24]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '`@helper.form` is a special helper provided by the Play framework to create
    HTML forms easily. So, the action is the target where the form will be submitted.
    We need to do an `if` here, since we need to know if it is an update or an insert.
    Then we map all the fields we have for our product model with this code:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Remember, the product form comes from the product controller. For the helper,
    we just need to tell it which product field is for which HTML label, and that's
    it. This will produce the following UIs.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: 'The following image shows the blank product index UI:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '![Working with views(UI)](img/image00257.jpeg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
- en: 'The insert UI form for product details looks as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '![Working with views(UI)](img/image00258.jpeg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
- en: 'With products added, the product index UI appears as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '![Working with views(UI)](img/image00259.jpeg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
- en: Now we can move to reviews. Let's go for the UIs.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: 'The review index UI in `review_index.scala.html` is as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: So here we have the same things as we had for the products. Let's take a look
    at the details page for review now. You can find it in `review_details.scala.html`.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Here, in this last code, we have almost everything similar to what we had for
    products, however, there is one big difference. Review needs to be associated
    with a product ID. That's why, we need to have a select for the products, which
    is fulfilled by `products:Seq[(String,String)]`. This comes from the `ReviewController`
    code. This code produces the following UIs.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: 'The blank review index UI is shown as follows:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '![Working with views(UI)](img/image00260.jpeg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
- en: 'The insert review details UI looks as follows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '![Working with views(UI)](img/image00261.jpeg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
- en: 'The review index UI with reviews will look like the following image:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '![Working with views(UI)](img/image00262.jpeg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
- en: 'Now we can move to the last one: the image UI. The image UI is very similar
    to the review UI, because it depends on the product ID too. Let''s go for it.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: 'The image index UI has the following code in `image_index.scala.html`:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This UI template will create the following HTML Pages:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: 'The blank image index UI is shown in the following image:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '![Working with views(UI)](img/image00263.jpeg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
- en: 'The insert UI for image details looks as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '![Working with views(UI)](img/image00264.jpeg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
- en: 'The following is the image index UI with items:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '![Working with views(UI)](img/image00265.jpeg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
- en: Now we have a complete working UI application. There are controllers, models,
    views, and simple services as well. We also have all validations in place.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to create controllers, models, services, views
    (using Twirl templating), Guice injections, and routing. We covered the principles
    of Scala Web Development using the Play framework. By the end of the chapter,
    we got the application with the Play framework up and running.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn more about services. As you may realize,
    we did some simple services in this chapter for products, reviews, and images,
    but now we will continue working with services.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
