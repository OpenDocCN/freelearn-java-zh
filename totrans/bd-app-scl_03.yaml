- en: Chapter 3. Developing the UI with Play Framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we performed bootstrapping on our application using
    Activator. In this chapter, we will continue developing our web application using
    Scala and Play framework. Play framework is great for web development because
    it is simple to use, and at the same time, very powerful. This is because it uses
    top-notch reactive solutions like spray, Akka, and Akka Stream under the hood.
    For this chapter, we will create the basic UI for some parts of our reactive web
    solution by adding validation and an in-memory store so you can feel the application
    working. We will use a little bit of CSS for styling, and JavaScript for some
    simple visualizations.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Basics of web development with Scala and Play frameworks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating your models
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with views and validations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with session scopes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting started
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's have a look at the preview of `Reactive Web Store`--the application that
    we will build.
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting started](img/image00256.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: For now, we will build three simple operations--**Create, Retrieve, Update,**
    and **Delete** (**CRUD**) in order to manage products, product reviews, and product
    images. We will create models, controllers, views, and routes for each CRUD.
  prefs: []
  type: TYPE_NORMAL
- en: Let's get started. First of all, we need to define our models. The models need
    to be located at `ReactiveWebStore/app/models`. Models are the CORE of the system
    and they represent the entity. We will use this entity later to store and retrieve
    data from a database later on in [Chapter 6](part0071.xhtml#aid-23MNU1 "Chapter 6. 
    Persistence with Slick"), *Persistence with Slick*. Our models should not have
    any UI logic, since we should use controllers for UI logic.
  prefs: []
  type: TYPE_NORMAL
- en: Creating our models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For our product model, we have a simple Scala case class in `Product.scala`
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: A product can have an optional ID, a name, details, and a price. We also override
    the `toString` method just for the sake of simplicity for logging. We also need
    to define models for image and review.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the review model from `Review.scala`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: For a review model, we have an optional ID, an optional `productId`, one author,
    and a comment. Validations will be done on the views. Now let's go for the image
    model.
  prefs: []
  type: TYPE_NORMAL
- en: 'The image model can be found in `Image.scala` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: For an image model, we have an optional ID, an optional `productId`, and the
    image URL.
  prefs: []
  type: TYPE_NORMAL
- en: The Play framework does the routing, and we need to define the routes at `ReactiveWebStore/conf/routes`.
    Keep in mind that the Play framework will validate all the routes, so you need
    to specify valid packages and classes. Play also creates something called reverse
    controller, which we will use later in the chapter. For now, let's define the
    routes. Reverse controller is generated by the Play framework with an action method
    which is the same as that of the original controller with the same signature,
    but it returns `play.api.mvc.Call` instead of `play.api.mvc.Action`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating routes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Play framework CRUD operations'' routes for product, image, and review
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The routes work like this--First you need to define the rest verb such as `GET`,
    `POST`, `PUT`, `DELETE`, and then you put in a `PATH` like `/image`. Finally,
    you specify which controller function will handle that route. Now we have the
    routes in place, we can move to the controllers. We will define the controllers
    for product, image and review.
  prefs: []
  type: TYPE_NORMAL
- en: All the routes follow the same logic. First we send the user to the web page
    where we list all the items (products, images, reviews)--this is represented by
    `GET /resource`, where the resource can be an image, product, or review, for instance.
    In order to get a specific resource, often by ID, we give the command `GET /resource
    (product, review or image)/ID. POST /resource` is used to perform the `UPDATE`.
  prefs: []
  type: TYPE_NORMAL
- en: In order to create a new item (product, review, or image), the pattern is `GET
    /resource/add` and `POST /resource/`. You may wonder why there are two routes
    to perform an insert. Well, that's because first of all we need to load the web
    page, and secondly, when the form is submitted, we need a new route to handle
    the values. There are two routes for an update as well for the same reason. If
    you want to `DELETE` a resource, the pattern is `POST /resource/ID/remove`. Lastly,
    we have the details of the operation, which is used to show detailed information
    with regard to a specific item--the pattern is `GET /resource/details/ID`. With
    six routes, we can do a complete CRUD for a resource such as product, image, and
    review, or any other future resource that you may add to this application or your
    own applications.
  prefs: []
  type: TYPE_NORMAL
- en: Creating our controllers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now let's move to the controllers used on the previous routes. The controllers
    need to be located at `ReactiveWebStore/app/controllers`. Controllers are bound
    between views (UI), models and service, which are responsible for business operations.
    It's always important to separate UI logic, which tends to be specific, from business
    logic, which tends to be more generic, and often, way more important.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have a look at the product controller in `ProductController.scala` in
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The Play framework uses dependency injection and inversion of control using
    Google Guice. So, you can see at the top of the controller that we have the annotations
    `@Singleton` and `@Inject`. Singleton means that Guice will create a single instance
    of the class to handle all requests. Inject means we are injecting other dependencies
    into our controller, for instance, we inject `MessagesApi` in order to have the Play
    framework internalization support for string messages, and `IProductService`,
    that is, the product service that we will cover later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: We also need to extend the Play class, `play.api.mvc.Controller`. Each function
    in a controller needs to return an action. This action could be a view.The Play
    framework compiles all the views into Scala classes, so you can safely reference
    them into your controllers code.
  prefs: []
  type: TYPE_NORMAL
- en: All business operations are delegated to a trait called `IProductService`, which
    we will cover later in this chapter. We also log some information using the Logger
    class. Play Framework uses `Logback` as the default logging solution. Let's take
    a closer look at each controller function now.
  prefs: []
  type: TYPE_NORMAL
- en: The index function calls `IProductService`, and finds all the available products.
    If there are no products available, it returns an empty sequence, and then calls
    the product UI passing the collection of products.
  prefs: []
  type: TYPE_NORMAL
- en: The blank function renders a blank product form, so the user can have a blank
    product form on the UI in order to add data (insert operation). Play framework
    works with form binding. So, in each controller, you need to define how your form
    looks on the UI. That form mapping is done using `play.api.data.Form`. You can
    see the mapping on the immutable variable called `productForm`. The mapping is
    between the view(UI) and the model called product. Keep in mind that the name
    field is mapped as `NonEmptyText`, which means Play won't accept null or blank
    values. This is a great future, because we can do validations in a declarative
    way without having to write code. Price is defined as `BigDecimal`, so Play won't
    accept text, but only numbers.
  prefs: []
  type: TYPE_NORMAL
- en: The details function retrieves a product using `IProductService`, and redirects
    to the view. However, before doing the redirect, it binds the data with the form
    so the UI will load with all the data into the HTML inputs.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also have the insert and update methods. They are all constructed with a
    `fold` method. The `fold` method has left and right, which means error or ok.
    The `fold` function is called from the mapped form and if there are no validation
    errors, it goes right, but if there are validations errors, it goes left. That''s
    a very simple and clean way to code the `update` and `insert` flows. With `fold`,
    we don''t need code for an `if` statement. Once the validation is OK, we call
    `IProductService` to do an insert or update, and then we perform a redirect to
    the view. Messages are passed via scope. Play has options for scope--session or
    Flash. Session is for multiple requests, and the value will be stored in the client
    side. Flash is a request scope, and most of the times that is what you need to
    use. Here we are using the `Flash` scope, so it will only exit during that specific
    request. This feature is used to pass **Internationalization messages** (**i18n**),
    which are the result of the action. All the i18n messages need to be defined at
    `ReactiveWebStore/conf/messages` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Lastly, we have the remove method. First of all, we need to make sure the product
    exists, so we do a `findById` using `IProductService`, and then we apply a map
    function. If the product doesn't exist, the Play framework has prebuilt HTTP error
    code messages like `NotFound`. If the product exists, we remove it using `IProductService`,
    and then we redirect to the UI with a flashing message. Now let's see the image
    and review controllers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The review controller, `ReviewController.scala`, is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The review controller follows the same ideas and structure as the product controller.
    The only main difference is that here we need to Inject `IProductService`, because
    a review needs to belong to a product. Then we need to use `IProductService` in
    order to `findAllProduct`, because in the review view, we will have `SelectBox`
    with all the available products.
  prefs: []
  type: TYPE_NORMAL
- en: 'The image controller, `ImageController.scala`, is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Image review works in a similar way to `ReviewController`. We need `IProductService`
    to get all the services.
  prefs: []
  type: TYPE_NORMAL
- en: Working with services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Services are where we put the business logic. We will look at reactive persistence
    in [Chapter 6](part0071.xhtml#aid-23MNU1 "Chapter 6.  Persistence with Slick"),
    *Persistence with Slick*. Right now, we don't have a database to persist information,
    so, for now, we will do an in-memory persistence.
  prefs: []
  type: TYPE_NORMAL
- en: 'First we will define the contract of our services. This is the Base API that
    we will use in the controllers. Let''s take a look at the following trait in `BaseService.scala`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we have an in-memory mutable `HashMap`, which is in our
    memory database where we will store products, images, and reviews. We also have
    an atomic counter with which we can generate IDs for our models. This is a trait
    using Generics--as you can see, here we have all the operations with `A`, which
    will be specified later. Now we can move the service implementation for product,
    review, and image.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ProductService.scala` package is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In the last code, we defined a trait called `IProductService`, which extends
    `BaseService` with a generic apply to product. The `ProductService` package implements
    `IProductService`. In Scala, we can have multiple classes in the same Scala file,
    so there is no need to create different files.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code is very straightforward. There is a utility method here called `findAllProducts`,
    which is used by review and image controllers. Here we get all the elements on
    the in-memory hash map. If there are no elements, we return a list with empty
    product. Then we map the list to a `Seq` of tuple, which is required by the `SelectBox`
    checkbox that we will have in the view(UI). Now let''s go for the image and review
    services  as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we have something pretty similar to that of `ProductService`.
    We have a trait called `IImageService` and the `ImageService` implementation.
    Now let''s go for the review service implementation in `ReviewService.scala`as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we have the `IReviewService` trait and the `ReviewService`
    implementation. We have validations on the service as well as a good practice.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the Guice module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We injected classes using `@Inject` in our controllers. The injection happens
    based on a trait; we need to define a concrete implementation for the traits we
    injected. The Play framework looks for Guice injections at the location `ReactiveWebStore/app/Module.scala`.
    Okay, so let's define our injections for the three controllers we just created.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Guice module is found in `Module.scala`as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'So we just need to add `bind` with our traits for the controllers, and then
    point to the controller implementation. They should also be created as singletons,
    as the Play framework starts our application. Here you also can define any other
    configuration or injection that our application may need. The last code defines
    three services: product service, `IReviewService`, and `IImageService`.'
  prefs: []
  type: TYPE_NORMAL
- en: Working with views(UI)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Play framework works with a Scala-based templating engine called Twirl.
    Twirl was inspired by ASP.NET Razor. Twirl is compact and expressive; you will
    see we can do more with less. Twirl template files are simple text files, however,
    the Play framework compiles the templates and turns them into Scala classes. You
    can mix HTML with Scala smoothly in Twirl.
  prefs: []
  type: TYPE_NORMAL
- en: The UI will be compiled into a Scala class, that can and will be referenced
    at our controllers, because we can route to a view. The nice thing about it is
    that this makes our coding way safer, since we have the compiler checking for
    us. The bad news is that you need to compile your UI, otherwise, your controllers
    won't find it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Previously in this chapter, we defined controllers for products, images, and
    reviews, and we wrote the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'With the preceding code, we redirect the user to a blank page for products
    so that the user can create a new product. We also can pass parameters to the
    UI. Since it is all Scala code, you are actually just calling a function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we call the service to retrieve a product by ID, and
    then pass the object to the UI with the form being filled.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s continue building our application and create the UI for the products,
    reviews, and images. Since we are doing a CRUD, we will need more than one template
    file per CRUD. We will need the following structure:'
  prefs: []
  type: TYPE_NORMAL
- en: Index Template
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: List all items
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Link to edit one item
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Link to remove one item
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Link to create a new Item
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Detail Template
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: HTML Form to create a new Item
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: HTML form to edit an existing item(for update)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Having said that, we will have the following files:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For Products:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: product_index.scala.html
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: product_details.scala.html
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For Image:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: image_index.scala.html
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: image_details.scala.html
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For Reviews:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: review_index.scala.html
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: review_details.scala.html
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For the sake of code reuse, we will create another file containing the basic
    structure of our UI, like CSS imports (CSS needs to be located at `ReactiveWebStore\public\stylesheets`),
    JavaScript imports, and page title so that we don''t need to repeat that in all
    the templates for each CRUD. This page will be called: `main.scala.html`.'
  prefs: []
  type: TYPE_NORMAL
- en: All the UI code should be located at `ReactiveWebStore/app/views`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main Scala with the UI index for all CRUD operations is in `main.scala.html`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, first of all, there is the following line at the very
    top:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This means that we define the parameters this UI can receive. Here we expect
    a string title, which will be the page title, and there are some currying variables
    as well. You can get more details about currying in [Chapter 1](part0015.xhtml#aid-E9OE1
    "Chapter 1. Introduction to FP, Reactive, and Scala"), *Introduction to FP, Reactive,
    and Scala*. So in currying, there are two things: First is HTML, which means you
    can pass HTML code to this function, and second, we have `Flash` which the Play
    framework will pass for us. `Flash` is used to get parameters between requests.'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, later in the code we have `@title`, which means we retrieve
    the title of the parameters, and add the value to the HTML. We also print any
    error message or any validations issues, if present, with `@alert`. We import
    JQuery and Twitter Bootstrap, but we do not put hard-coded paths. Instead, we
    use the routers like `@routes.Assets.at`. The Javascripts still need to be located
    at `ReactiveWebStore\public\javascripts`.
  prefs: []
  type: TYPE_NORMAL
- en: Now other templates can work with `@main(..),` and they don't need any declaration
    of Javascript or CSS. They can add an extra HTML code, which will be rendered
    on the previous code by `@content`. So, for the products, the content will be
    HTML product content, and so on for reviews, and images. Now we can move for the
    products UI.
  prefs: []
  type: TYPE_NORMAL
- en: 'Product index: ­ UI index for products `product_index.scala.html`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, there is HTML mixed with Scala code. Every time you need to
    run HTML, you just run it, and when you need run Scala code, you need use a special
    character, `@`. At the very top of the template, you can see the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Since this is Scala code in the end, and will be compiled, we need to define
    what parameters this UI template can receive. Here we expect a sequence of products.
    There is also a currying implicit variable called `Flash`, which will be provided
    by the Play framework, and we will use it for the message display. We also have
    the code-`@main("Products") { .. }`. This means that we call the main Scala template
    and add extra HTML--the product HTML. For this product UI, we list all the products
    based on the sequence of products. As you can see, we define an HTML table. We
    also validate if the sequence is not empty before listing all the products.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can go for the details page for products in `product_details.scala.html` as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'For this preceding UI, at the very top, we have the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This means that we expect an ID which is completely optional. This ID is used
    to know if we are dealing with an insert scenario or an update scenario, because
    we use the same UI for both insert and update. We also get the product form, which
    will be passed through `ProductController`, and we receive `Flash`, which will
    be provided by the Play framework.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to do some imports on the UI so that we can get access to the Play
    framework i18n support. This is done by the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Like the previous UI, we render this UI within the main Scala UI. So we don''t
    need to specify JavaScript and CSS again. This is done by the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Next we check if there are any validation errors. If there are, the users will
    need to fix the errors before moving on. This is done by the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Now is the time to create the product form, which, in the end, will be mapped
    to HTML input boxes. We do this with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '`@helper.form` is a special helper provided by the Play framework to create
    HTML forms easily. So, the action is the target where the form will be submitted.
    We need to do an `if` here, since we need to know if it is an update or an insert.
    Then we map all the fields we have for our product model with this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Remember, the product form comes from the product controller. For the helper,
    we just need to tell it which product field is for which HTML label, and that's
    it. This will produce the following UIs.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following image shows the blank product index UI:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Working with views(UI)](img/image00257.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The insert UI form for product details looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Working with views(UI)](img/image00258.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'With products added, the product index UI appears as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Working with views(UI)](img/image00259.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Now we can move to reviews. Let's go for the UIs.
  prefs: []
  type: TYPE_NORMAL
- en: 'The review index UI in `review_index.scala.html` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: So here we have the same things as we had for the products. Let's take a look
    at the details page for review now. You can find it in `review_details.scala.html`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Here, in this last code, we have almost everything similar to what we had for
    products, however, there is one big difference. Review needs to be associated
    with a product ID. That's why, we need to have a select for the products, which
    is fulfilled by `products:Seq[(String,String)]`. This comes from the `ReviewController`
    code. This code produces the following UIs.
  prefs: []
  type: TYPE_NORMAL
- en: 'The blank review index UI is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Working with views(UI)](img/image00260.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The insert review details UI looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Working with views(UI)](img/image00261.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The review index UI with reviews will look like the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Working with views(UI)](img/image00262.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now we can move to the last one: the image UI. The image UI is very similar
    to the review UI, because it depends on the product ID too. Let''s go for it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The image index UI has the following code in `image_index.scala.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'This UI template will create the following HTML Pages:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The blank image index UI is shown in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Working with views(UI)](img/image00263.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The insert UI for image details looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Working with views(UI)](img/image00264.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following is the image index UI with items:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Working with views(UI)](img/image00265.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Now we have a complete working UI application. There are controllers, models,
    views, and simple services as well. We also have all validations in place.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to create controllers, models, services, views
    (using Twirl templating), Guice injections, and routing. We covered the principles
    of Scala Web Development using the Play framework. By the end of the chapter,
    we got the application with the Play framework up and running.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn more about services. As you may realize,
    we did some simple services in this chapter for products, reviews, and images,
    but now we will continue working with services.
  prefs: []
  type: TYPE_NORMAL
