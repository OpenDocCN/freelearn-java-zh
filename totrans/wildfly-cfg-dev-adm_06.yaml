- en: Chapter 6. Application Structure and Deployment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Deployment is the process of uploading resources or applications on the application
    server. During the software development life cycle, it is the step that logically
    follows the development phase and can be performed either manually or in an automated
    fashion.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will explore both approaches using the tools that are provided
    by the server distribution. We will also cover how to deploy resources on the
    application server using the WildFly plugin for Eclipse. This is the preferred
    choice for Java developers due to the quick deployment time.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the last part of this chapter, we cover the details of the WildFly classloader
    architecture. In short, our agenda for this chapter includes the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The type of resources that can be deployed on WildFly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying applications on a WildFly standalone instance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying applications on a WildFly domain
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding WildFly's classloading architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying resources on the application server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are basically three file types that we work with in Java Enterprise applications,
    which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**JAR**: This is the most basic package, which can be used for both application
    and common resources'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**WAR**: This is used to package web applications'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**EAR**: This packages multiple WAR files or contains a set of modules'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Besides these, WildFly is able to process the following archives, which provide
    the application server with additional functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '**RAR**: This is the resource adapter file, which is used to define a resource
    adapter component (the resource adapter subsystem is provided by the `IronJacamar`
    project; for more information, visit [http://www.jboss.org/ironjacamar](http://www.jboss.org/ironjacamar))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SAR**: This file enables the deployment of service archives containing the
    `MBean` services, as supported by previous versions of the application server'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, we will discuss the first three kinds of archives, all of which
    constitute the typical packaging solution for Java Enterprise applications. Before
    discussing application deployment, let's look at the single archives in a little
    more detail.
  prefs: []
  type: TYPE_NORMAL
- en: The JAR file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A **Java** **Archive** (**JAR**) file is used to package multiple files into
    a single archive. Its internal physical layout is similar to a ZIP file, and as
    a matter of fact, it uses the same algorithm as the zip utility for compressing
    files.
  prefs: []
  type: TYPE_NORMAL
- en: A JAR file is generally used to distribute Java classes and associated metadata.
    In Java EE applications, the JAR file often contains utility code, shared libraries,
    and Enterprise JavaBeans (EJBs).
  prefs: []
  type: TYPE_NORMAL
- en: The WAR file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A **Web** **Application** **Archive** (**WAR**) file is essentially an archive
    used to encapsulate a web application. The web application usually includes a
    collection of web-related resources, such as **Java** **Server** **Pages** (**JSP**),
    servlets, XHTML/HTML files, and so on. It also includes Java class files, and
    possibly other file types, depending on the technology used. Since Java EE 6,
    EJBs can be packaged within a WAR archive using the same packaging guidelines
    that apply to web application classes. This means that you can place EJB classes,
    along with the other class files, under the `classes` directory under `WEB-INF`.
    Alternatively, you can package your EJBs within a JAR file and then place this
    JAR file in the `WEB-INF\lib` directory of WAR.
  prefs: []
  type: TYPE_NORMAL
- en: Because of this, it's more common for developers to use the WAR file to distribute
    Java EE applications.
  prefs: []
  type: TYPE_NORMAL
- en: The EAR file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An **Enterprise** **Archive** (**EAR**) file represents an application archive,
    which acts as a container for a set of modules or WAR files. An EAR file can contain
    any of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: One or more web modules packaged in WAR files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One or more EJB modules packaged in JAR files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One or more application client modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any additional JAR files required by the application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JBoss-specific archives such as the SAR file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are two distinct advantages of using an Enterprise Archive file. First,
    it helps to distribute all application components using a single archive instead
    of distributing every single module. Second, and most important, is the fact that
    applications within an EAR file are loaded by a single classloader. This means
    that each module has visibility on other modules packed within the same archive.
  prefs: []
  type: TYPE_NORMAL
- en: 'The isolation level of application modules contained in the EAR file can be
    modified by adding the `ear-subdeployments-isolated` element to the main configuration
    file (`domain.xml` or `standalone.xml`). The default value is `false`, which means
    that the classes in the WAR file can access the classes in the `ejb.jar` file.
    Likewise, the classes in the `ejb.jar` file can access each other. If, for some
    reason, you do not want this behavior and want to restrict the visibility of your
    classes, add the following lines to your configuration file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the *Explaining WildFly classloading* section, we will discuss the application
    server classloading architecture in depth. We will also show you how to override
    this configuration setting at the application level.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying applications on a standalone WildFly server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Deploying applications on JBoss has traditionally been a fairly simple task,
    so you might wonder why a full chapter has been dedicated to it. The answer to
    this is that deploying applications on WildFly can be achieved in several ways,
    each of which we are going to look at.
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, we are going to look at automatic deployment of applications
    via the `deployments` folder, but before we do this, we need to explain the two
    modes available when deploying applications:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Automatic** **deployment mode**: This mode is triggered by the deployment
    scanner when a resource within the `deployments` folder is modified'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Manual deployment mode**: This mode does not rely on the deployment scanner
    to trigger a deployment, but rather on a set of marker files to decide if the
    application needs to be deployed/redeployed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automatic application deployment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Automatic application deployment consists of placing your application in the
    `deployments` folder, which is located at the following path:'
  prefs: []
  type: TYPE_NORMAL
- en: '`JBOSS_HOME\standalone\deployments`'
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, every application archive (WAR, JAR, EAR, and SAR) that is placed
    in this folder is automatically deployed on the server, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Automatic application deployment](img/6232OS_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The service that scans for deployed resources is called the **deployment scanner**,
    and it is configured within the `standalone.xml` configuration file. You can find
    it by searching for the `deployment-scanner` domain. The following snippet shows
    the default deployment scanner configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, by default, the server scans in the `deployments` folder every
    `5000` ms. This service can be customized in many ways. Next, we will look at
    how we can further configure the deployment scanner.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying applications to a custom folder
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you want to change the location of the deployment folder, you need to modify
    the `relative-to` and `path` properties. If you provide both properties, the `deployments`
    folder is a sum of both properties. For example, considering that you have defined
    the `wildfly8deployments` path, you can later reference it as a relative path
    for your deployments, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In this configuration, the deployment scanner looks for applications within
    the `deployments` folder under `/opt/applications`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The same effect can be achieved using an absolute path for your deployments,
    leaving out the `relative-to` property and configuring the `path` element, as
    shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Changing the behavior of the deployment scanner
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: By default, every packaged archive that is placed in the `deployments` folder
    is automatically deployed. On the other hand, exploded applications need one more
    step to be deployed (see the *Manual application deployment* section).
  prefs: []
  type: TYPE_NORMAL
- en: 'We can easily change this behavior of the deployment scanner. The properties
    that control the `auto-deploy` feature are `auto-deploy-zipped` and `auto-deploy-exploded`,
    respectively, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'You can set the `auto-deploy-exploded` property to `true` to achieve automatic
    deployment of exploded archives, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Deployment rollback
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'WildFly 8 introduces a new option to roll back a failed deployment. To do this,
    simply update the `runtime-failure-causes-rollback` property to `true`, as shown
    in the following code snippet. The default behavior is `false`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If the `failure-causes-rollback` property is set to `true`, a deployment failure
    also triggers the rollback of any other deployment that was processed as part
    of the same scan.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying an application using the CLI
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Copying the application archives is often favored by many developers, as it
    can be performed automatically by the development environment. However, we lay
    stress on the advantages of using the CLI interface, which offers a wide choice
    of additional options when deploying and also allows you to deploy applications
    remotely.
  prefs: []
  type: TYPE_NORMAL
- en: 'All it takes to deploy an application archive is to log in to the CLI, either
    a local or remote instance, and issue the `deploy` command. When used without
    arguments, the `deploy` command prints a list of applications that are currently
    deployed. Take a look at the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'To deploy your application to the standalone server, pass through the relative
    (or absolute) path of your archive. This path obviously relates to the client
    machine if you are connected to a remote server. This immediately deploys your
    application to the server. Take a look at the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'When you specify a relative path, it is relative to the location you started
    the CLI utility from. You can, however, use absolute paths when specifying the
    location of your archives. The CLI auto-complete functionality (using the *Tab*
    key) makes light work of this. Have a look at the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, when you deploy via the CLI, the application is deployed and enabled
    so that the user can access it. If you want to just perform the deployment of
    the application and enable it at a later time, you can add the `--disabled` switch,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to enable the application, simply issue another `deploy` command without
    the `--disabled` switch, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Did you notice the optional `--name` switch that has been added? When using
    this switch, you are able to use the **tab completion** feature so that you can
    automatically find the inactive deployment unit.
  prefs: []
  type: TYPE_NORMAL
- en: 'Redeploying the application requires an additional flag to the `deploy` command.
    You will get an error if you try to deploy the same application twice without
    using this flag. The `–f` argument forces the redeployment of the application,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Undeploying the application can be done through the `undeploy` command, which
    takes the name of the deployment as an argument, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Upon checking the configuration file, `standalone.xml`, you notice that the
    `deployment` element for your application has been removed.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying an application using the web admin console
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Application deployment can also be completed using the web admin console:'
  prefs: []
  type: TYPE_NORMAL
- en: Start the console hyperlink, `http://localhost:9990/console`, in your browser.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You need to add at least one management user to access the web console. To add
    a new user, execute the `add-user.bat` or `add-user.sh` script within the `bin`
    folder of your WildFly installation, and enter the requested information. See
    [Chapter 10](ch10.html "Chapter 10. Securing WildFly"), *Securing WildFly*, for
    more details.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Server deployment is managed by the application server by selecting **Runtime**
    in the top menu and then choosing the **Manage Deployments** option. If you want
    to add a new application to WildFly, just click on the **Add** button of your
    console, as shown in the following screenshot:![Deploying an application using
    the web admin console](img/6232OS_06_02.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'An intuitive wizard guides you through selecting your application and providing
    a runtime name for it, as shown in the following screenshot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Deploying an application using the web admin console](img/6232OS_06_03.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'There are two properties shown in the wizard that may cause some confusion:'
  prefs: []
  type: TYPE_NORMAL
- en: The **Name** property is the name by which the deployment should be known within
    a server's runtime, for example, `MyApp-1.0.0.war`. This is used as the basis
    for the module names and is usually the name of the archive.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Runtime Name** is typically the same as the **Name**, but there may be
    instances where you wish to have two deployments with the same runtime name. For
    example, you may have `MyApp-1.0.0.war` and `MyApp-1.0.1.war` within the content
    repository but have the runtime name of `MyApp.war` for both archives. They cannot
    be deployed at the same time, and one of them would need to be disabled.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The admin console, by default, deploys the application but does not enable
    it. By clicking on the **Enable** button, the application can now be accessed,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Deploying an application using the web admin console](img/6232OS_06_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Deploying an application using the WildFly Eclipse plugin
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Eclipse is the most widely used application development environment for Java
    developers, and it's also the favorite IDE for JBoss developers, as the JBoss
    Tools project ([http://www.jboss.org/tools](http://www.jboss.org/tools)) supports
    the Eclipse environment by providing a set of plugins for JBoss projects.
  prefs: []
  type: TYPE_NORMAL
- en: In the first chapter of this book, we outlined the installation steps for Eclipse,
    along with JBoss tools. We also set up the WildFly server adapter, which allows
    you to start, stop, debug, and deploy applications on WildFly using the standalone
    mode.
  prefs: []
  type: TYPE_NORMAL
- en: 'Deploying applications to WildFly is easy once you have your WildFly Eclipse
    plugin installed:'
  prefs: []
  type: TYPE_NORMAL
- en: Simply navigate to the **Server** tab, right-click on the **WildFly Runtime
    Server**, and select **Add and Remove**. You are presented with a window, as shown
    in the following screenshot:![Deploying an application using the WildFly Eclipse
    plugin](img/6232OS_06_05.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, click on your application, select **Add**, and then click on **Finish**.
    The project now publishes to the server. If you ever need to redeploy, click on
    the project you want to deploy, and choose **Full** **Publish**, as shown in the
    following screenshot:![Deploying an application using the WildFly Eclipse plugin](img/6232OS_06_06.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configuring Eclipse deployments
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'By double-clicking on the WildFly Runtime, you have access to a tabbed menu,
    which contains two options: **Overview** and **Deployment**. The **Deployment**
    option is specific to JBoss tools and lets you choose the deployment location
    and packaging style of deployment. Take a look at the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Configuring Eclipse deployments](img/6232OS_06_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Upon checking the **Deploy projects as compressed archives** option, your application
    is compressed and packaged.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you choose to deploy your application as an exploded archive, Eclipse adds
    a `.dodeploy` marker file once the application has been copied to the `deployments`
    folder. This triggers immediate application deployment. See the next section for
    more information about marker files.
  prefs: []
  type: TYPE_NORMAL
- en: Manual application deployment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When using the manual application deployment approach, the deployment scanner
    does not automatically deploy the applications that are placed in the `deployments`
    folder. Rather, it uses a set of marker files, which are used to trigger application
    redeployment and capture the result of the operation.
  prefs: []
  type: TYPE_NORMAL
- en: You might wonder why marker files are used by the application server and why
    the default server configuration is set to use exploded deployments.
  prefs: []
  type: TYPE_NORMAL
- en: Actually, there are several reasons for this choice, and all of them are related
    to how the operating system's filesystem works. Exploded archives involve moving/replacing
    files in your filesystem, which should be performed automatically. By atomic operation,
    we mean that a filesystem operation needs to be performed as a single operation.
    Unfortunately, some operating systems like Windows don't treat complex filesystem
    operations such as a file moving as atomic operations.
  prefs: []
  type: TYPE_NORMAL
- en: Most Windows users often experience deployment issues on releases of WildFly
    prior to JBoss AS 7\. This is due to the JVM refusing to release a file handle
    to `META-INF/application.xml` or an EJB descriptor file. That's because Windows
    uses a mandatory file lock, which prevents any application from accessing the
    file. On the other hand, operating systems such as UNIX use an advisory file lock,
    which means that unless an application checks for a file lock, it is not prevented
    from accessing the file.
  prefs: []
  type: TYPE_NORMAL
- en: Also, using marker files, the application server is able to solve a common issue
    related to large deployment files. If you've ever tried to deploy a large package
    unit (especially over a network), you might have experienced deployment errors
    because the deployment scanner starts deploying before the copy operation is completed,
    resulting in partially-completed deployments. Marker files are used by default
    for exploded deployments. They consist of empty files with a suffix, which are
    added either by the user or by the container to indicate the outcome of an operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most relevant marker file is `.dodeploy`, which triggers application redeployment.
    As a matter of fact, when we add an exploded deployment and the `auto-deploy-exploded`
    attribute is `false` in the deployment scanner configuration, the logs in the
    console warn us that the application is still not deployed, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Both Windows and Unix users can trigger deployment by simply running the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you have started the deployment process, the application server replies
    with two possible outcomes. A deployed marker file (for example, `MyApp.war.deployed`)
    is placed in the `deployments` directory by the deployment scanner service to
    indicate that the given content has been deployed to the server, and your logs
    should confirm the outcome, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you remove the `.deployed` file, the application is undeployed, and an `.undeployed`
    marker file is added to the `deployments` folder (for example, `MyApp.war.undeployed`).
    If you try to remove the `.undeployed` file, the application is deployed again.
    This is a useful shortcut to quickly undeploy (or redeploy) the application without
    deleting it on the filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: The other possible outcome is a deployment failure, which is indicated by a
    `.failed` marker. The content of the file includes some information about the
    cause of the failure; however, you should check the server logs for more detailed
    information regarding the cause of the error.
  prefs: []
  type: TYPE_NORMAL
- en: When using the autodeploy mode, you can remove the `.failed` marker file, which
    redeploys the application when the folder is rescanned by the deployment scanner.
    Additionally, the user can place the `.skipdeploy` marker file (for example, `MyApp.war.skipdeploy`),
    which disables `auto-deploy` of the content for as long as this marker file is
    present. Use this if you rely on automatic deployment and want to ensure that
    no deploy is triggered when updates are still incomplete.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see a sample script, which can be used to perform a safe redeployment
    of a web application named `MyApp.war`, when using the Linux operating system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The Windows equivalent is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the application server provides some additional temporary marker files,
    such as `.isdeploying`, `.isundeploying`, or `.pending`, that are placed by the
    deployment scanner to indicate the transition to the deployment or undeployment
    of a resource. Full details of marker files are provided in the `README.txt` file
    placed in the `deployments` folder of the server distribution. The following table
    displays a short summary of the available marker files used by the application
    server:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Marker | Created by | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `.dodeploy` | User | Creating this file triggers application deployment.
    Touching this file causes application redeployment. |'
  prefs: []
  type: TYPE_TB
- en: '| `.skipdeploy` | User | Application autodeployment is disabled as long as
    this file exists. |'
  prefs: []
  type: TYPE_TB
- en: '| `.deployed` | WildFly | The application is deployed. Removing it causes undeployment
    of the application. |'
  prefs: []
  type: TYPE_TB
- en: '| `.undeployed` | WildFly | The application has been undeployed. Removing it
    causes redeployment of the application. |'
  prefs: []
  type: TYPE_TB
- en: '| `.failed` | WildFly | The application deployment has failed. |'
  prefs: []
  type: TYPE_TB
- en: '| `.isdeploying` | WildFly | The application deployment is in progress. |'
  prefs: []
  type: TYPE_TB
- en: '| `.isundeploying` | WildFly | The application undeployment is in progress.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `.pending` | WildFly | One condition is preventing application deployment
    (for example, file copying in progress). |'
  prefs: []
  type: TYPE_TB
- en: Deploying applications on a WildFly domain
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Deploying applications on a WildFly domain is not as simple as deploying to
    a standalone server. There is no predefined `deployments` folder in the domain
    installation. The reason for this is that in the `domain` mode, there can be many
    servers belonging to different server groups, each one running different profiles.
    In this situation, a single `deployments` folder raises the obvious question:
    which server groups will use that folder?'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we are going to look at the options available when deploying applications
    to a WildFly domain. These two options are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The **command-line interface** (**CLI**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The admin web interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying to a domain using the CLI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s see how to deploy an application using the CLI. Start by launching the
    CLI, and connect to the domain controller, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'When you deploy an application using the domain mode, you have to specify to
    which server group the deployment is associated. The CLI lets you choose between
    the following two options:'
  prefs: []
  type: TYPE_NORMAL
- en: Deploy to all server groups
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploy to a single server group
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying to all server groups
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When choosing the option to deploy to all server groups, the application is
    deployed to all the available server groups. The `--all-server-groups` flag can
    be used to deploy to all the available server groups. For example, use the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'If, on the other hand, you want to undeploy an application from all server
    groups belonging to a domain, you have to issue the `undeploy` command, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: You might have noticed that the `undeploy` command uses `--all-relevant-server-groups`
    instead of `--all-server-groups`. The reason for this difference is that the deployment
    may not be enabled on all server groups, so by using this option, you actually
    undeploy it just from all those server groups in which the deployment is enabled.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Deploying an application as `disabled` can be useful if you have some startup
    beans (which are activated when the application is enabled) and you want to load
    them, but don't want to trigger their execution, for example, if the database
    or any other enterprise information system is temporarily unavailable.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying to a single server group
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The option of deploying to a single server group lets you perform a selective
    deployment of your application just on the server groups you have indicated, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'You are not limited to a single server group. To deploy to multiple server
    groups, separate them with a comma, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Remember, you can use the autocomplete functionality (the *Tab* key) to display
    the list of available `--server-groups`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, suppose we want to undeploy the application from just one server group.
    There can be two possible outcomes. If the application is available just on that
    server group, you successfully complete the undeployment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'On the other hand, if your application is available on other server groups,
    the following error is returned by the CLI:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Deploying to a single server group](img/6232OS_06_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This error occurs because when you are removing an application from a server
    group, the domain controller verifies that the application is not referenced by
    any other server group. If it is, the `undeploy` command fails.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you wish to remove your application from a single server group, you need
    to issue the `-keep-content` argument. This causes the domain controller to undeploy
    the application from the server group while retaining the content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We have covered many of the available options to deploy applications to a domain.
    Before moving to the admin console, let''s review the CLI deployment options,
    as shown in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Command | Options | Effect |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `deploy` | `--all-server-groups` | This deploys an application to all server
    groups. |'
  prefs: []
  type: TYPE_TB
- en: '| `undeploy` | `--server-groups` | This deploys an application to one or more
    server groups. |'
  prefs: []
  type: TYPE_TB
- en: '| `undeploy` | `--all-relevant-server-groups` | This undeploys and removes
    an application from all server groups. |'
  prefs: []
  type: TYPE_TB
- en: '| `undeploy` | `--server-groups` | This undeploys an application from one server
    group. This fails if it''s referenced in another server group. |'
  prefs: []
  type: TYPE_TB
- en: '| `undeploy` | `--server-groups -keep-content` | This undeploys an application
    from one server group without deleting it. |'
  prefs: []
  type: TYPE_TB
- en: Deploying to a domain using the Admin console
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Deploying applications using the **Admin** console is pretty intuitive and
    requires just a few simple steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start by logging in to the web application via the default address, `http://localhost:9990`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, select the **Runtime** tab in the top menu and select **Manage Deployments**
    in the left-hand side panel of the screen, as shown in the following screenshot:![Deploying
    to a domain using the Admin console](img/6232OS_06_09.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Before you can deploy your application to a server group, you need to upload
    it to the server, where it is stored in a content repository. To do this, click
    on **CONTENT REPOSITORY,** and then click on **Add**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This displays the following dialog, which allows you to upload your application:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Deploying to a domain using the Admin console](img/6232OS_06_10.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Once you are finished with the upload wizard, the application is uploaded to
    the domain repository. In order to deploy/undeploy it to the single server groups,
    you need to select the **SERVER GROUPS** tab, and then click on the **View** button
    on the server group you wish to deploy to, as shown in the following screenshot:![Deploying
    to a domain using the Admin console](img/6232OS_06_11.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The next screen shows you all the deployments for this server group. Now, click
    on the **Assign** button. This allows you to select from the applications that
    are currently stored within the content repository. Select the checkbox for your
    application and then click on **Save**, as shown in the following screenshot:![Deploying
    to a domain using the Admin console](img/6232OS_06_12.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At this point, the application is deployed but still not enabled. Choose the
    **En/Disable** button to complete the deployment of the application, as shown
    in the following screenshot:![Deploying to a domain using the Admin console](img/6232OS_06_13.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Clicking on the **Remove** button within the **SERVER GROUPS** tab removes the
    deployment from the server group selected, while the other **Remove** button within
    the **CONTENT** **REPOSITORY** tab actually deletes the deployment from the temporary
    domain repository where uploaded applications are bundled.
  prefs: []
  type: TYPE_NORMAL
- en: Explaining WildFly classloading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are two approaches to managing dependencies, the first being the **Class-Path**
    approach and the second, the **Dependencies** approach. We will cover both of
    these topics in this section, but before we do, let's take a look at the history
    of classloading in WildFly in order to understand why classloading works the way
    it does. As mandated by the Java EE specification, an application server needs
    to provide an environment where any deployed application can access any class,
    or library of classes, of a particular version.
  prefs: []
  type: TYPE_NORMAL
- en: This is also known as **Class Namespace Isolation** (Java EE 5 specification,
    section EE.8.4). However, loading classes from different namespaces can raise
    some issues that are not easy to solve. For example, what happens if you pack
    a newer version of a utility library with your application, while an older version
    of the same library was loaded by the application server? Or, how do you simultaneously
    use two different versions of the same utility library within the same instance
    of the application server?
  prefs: []
  type: TYPE_NORMAL
- en: The JBoss AS classloading strategy has changed sensibly through the years. The
    4.x releases of the application server used `UnifiedClassLoader`, which aimed
    to reduce communications overhead between running applications, as class data
    could be shared by reference or simple copies.
  prefs: []
  type: TYPE_NORMAL
- en: One of the major issues not resolved with `UnifiedClassLoader` is **classloading
    dependencies**. The idea is that if one application (A) uses the classes of another
    application (B), the system should know how to redeploy A when B gets redeployed;
    otherwise, it references stale classes. There were actually two different attempts
    to try to make this work without the user having to configure anything. Neither
    attempt really worked and both were dropped.
  prefs: []
  type: TYPE_NORMAL
- en: With JBoss AS 5.0, a new classloader was based on the new **Virtual File System**
    (**VFS**). The VFS was implemented to simplify and unify file handling within
    the application server. The new classloader, named the VFS classloader, uses VFS
    to locate JAR and class files. Even though this represented a significant change
    in how classes were loaded in JBoss AS 5.0, the resulting behavior is much the
    same as that of prior versions of JBoss AS.
  prefs: []
  type: TYPE_NORMAL
- en: A common source of errors was including API classes in a deployment that was
    also provided by the container. This could result in multiple versions of the
    class being created and the deployment failing to deploy properly.
  prefs: []
  type: TYPE_NORMAL
- en: Since JBoss AS 7, classloading marks a radical departure from previous attempts.
    Classloading is now based on the JBoss modules project, and any application that
    is deployed is, in effect, a module. This fact may raise some questions, such
    as what module name is to be assigned to a deployed application, and how dependencies
    between modules are handled by the application server.
  prefs: []
  type: TYPE_NORMAL
- en: These questions will be answered in the next few sections.
  prefs: []
  type: TYPE_NORMAL
- en: Getting to know module names
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Getting to know module names is not an academic exercise. We can even go so
    far as establishing dependencies between modules. So, in many cases, you need
    to know how module names are assigned to an application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Applications that are packaged as top-level archives (such as WAR, JAR, and
    SAR) are assigned the following module name:'
  prefs: []
  type: TYPE_NORMAL
- en: '`deployment.[archive name]`'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, a web application named `WebExample1.war` is deployed with the
    following module name:'
  prefs: []
  type: TYPE_NORMAL
- en: '`deployment.WebExample1.war`'
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, for applications that contain nested modules (such as EAR),
    each archive is assigned a module name using the following convention:'
  prefs: []
  type: TYPE_NORMAL
- en: '`deployment.[ear archive name].[sub deployment archive name]`'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, for example, the preceding web archive, if contained in an EAR file called
    `EnterpriseApp.ear`, would be deployed with the following name:'
  prefs: []
  type: TYPE_NORMAL
- en: '`deployment.EnterpriseApp.ear.WebExample1.war`'
  prefs: []
  type: TYPE_NORMAL
- en: Finding the isolation level
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A general rule in WildFly 8 is that every deployed application module is isolated
    from other modules, that is, by default, the application does not have visibility
    on the AS modules, nor do the AS modules have visibility on the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the application server modules is relatively easy and can be summarized
    in a single sentence: add a dependency to the required module and the AS will
    use it. Some dependencies are automatically added to the application server, while
    others need to be signaled by the user:'
  prefs: []
  type: TYPE_NORMAL
- en: The core module libraries (namely, the `Enterprise` classes) are qualified as
    implicit dependencies, so they are automatically added to your application when
    the deployer detects their usage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other module libraries need to be explicitly declared by the user in the application's
    `MANIFEST` file or in a custom JBoss deployment file named `jboss-deployment-structure.xml`
    (more about this file in the *Advanced deployment strategies* section)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implicit dependencies
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Repeatedly declaring commonly used dependencies for your enterprise application
    becomes very tedious. This is why the core modules are automatically added for
    you by the application server. Some of these core modules are only added when
    the application server detects annotations or configuration files for a particular
    technology. For example, adding a `beans.xml` file automatically triggers the
    **Weld** dependency (Weld is the Contexts and Dependency injection implementation
    used in WildFly).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table outlines the modules that are implicitly added to your
    application:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Subsystem | Automatic dependencies | Triggered dependencies | Trigger condition
    |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Core server | `javax.api``sun.jdk``org.jboss.vfs` |   |   |'
  prefs: []
  type: TYPE_TB
- en: '| EE | `javaee.api` |   |   |'
  prefs: []
  type: TYPE_TB
- en: '| EJB3 |   | `javaee.api` | Presence of `ejb-jar.xml` or EJB annotations |'
  prefs: []
  type: TYPE_TB
- en: '| JAX-RS | `javax.xml.bind.api` | `org.jboss.resteasy` | Presence of JAX-RS
    annotations |'
  prefs: []
  type: TYPE_TB
- en: '| JPA | `javax.persistence` | `javaee.api``org.jboss.as.jpa``org.hibernate`
    | Presence of `@PersistenceUnit` or `@PersistenceContext` or equivalent XML |'
  prefs: []
  type: TYPE_TB
- en: '| Logging | `org.jboss.logging``org.apache.commons.logging``org.apache.log4j``org.slf4j`
    |   |   |'
  prefs: []
  type: TYPE_TB
- en: '| Security | `org.picketbox` |   |   |'
  prefs: []
  type: TYPE_TB
- en: '| Web |   | `javaee.api``com.sun.jsf-impl``org.hibernate.validator``org.jboss.as.web``org.jboss.logging`
    | Deployment of WEB archive; JSF added if used |'
  prefs: []
  type: TYPE_TB
- en: '| Web services | `org.jboss.ws.api``org.jboss.ws.spi` |   |   |'
  prefs: []
  type: TYPE_TB
- en: '| Weld |   | `javax.persistence.api``javaee.api``org.javassist``org.jboss.interceptor``org.jboss.as.weld``org.jboss.logging``org.jboss.weld.core``org.jboss.weld.api``org.jboss.weld.spi`
    | Presence of `beans.xml` |'
  prefs: []
  type: TYPE_TB
- en: If your application uses any of the core modules indicated, then you don't need
    to specify its dependency, as the application server links the module automatically.
    If you are using Maven, then you can mark these dependencies as provided.
  prefs: []
  type: TYPE_NORMAL
- en: Explicit dependencies
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Modules that are not qualified as implicit dependencies need to be declared
    by the user. Let''s say you want to use the log4j library, which is bundled in
    the application server distribution. The simplest and recommended approach to
    achieve this is by including the `Dependencies: [module]` declaration within `META-INF/MANIFEST.MF`.
    The following example code for the chapter uses Maven to populate the `MANIFEST.MF`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This has the result of adding the following to your `MANIFEST.MF` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Explicit dependencies](img/6232OS_06_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Please note that the module name does not always match the package name of the
    library. The actual module name is specified in the `module.xml` file by the `name`
    attribute of the `module` element.
  prefs: []
  type: TYPE_NORMAL
- en: 'You are not limited to a single dependency, as you can add multiple dependencies
    separated by a comma. For example, in order to add a dependency on both log4j
    and Apache Velocity API, use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'You can even export the dependencies used by one application module to other
    applications by adding the `export` keyword. For example, in addition to the earlier
    example, we''re now exporting the dependencies to other modules, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Explicit dependencies](img/6232OS_06_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `export` parameter can also be used to export a dependency to all subdeployments
    contained in the EAR. Consequently, if you export a dependency from the top-level
    of the EAR (or by a JAR in the `ear/lib` directory), then the dependency is also
    available to all subdeployment units.
  prefs: []
  type: TYPE_NORMAL
- en: 'Applications that are marked as dependent to the `deployment.WebApp1.war` module
    also have access to its dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Explicit dependencies](img/6232OS_06_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Within `META-INF/MANIFEST.MF`, you can also specify additional commands that
    can modify the server deployer's behavior. For example, the `optional` attribute
    can be added to specify that the deployment does not fail if the module is not
    found at the deployment time.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, when the `services` keyword is specified, the deployer tries to load
    services that are placed within the `META-INF/services` directory of the archive.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `service` API has become `public` in Java SE 6\. A **service** can be defined
    as a set of programming interfaces and classes that provide access to some specific
    application functionality or feature. A **Service Provider Interface** (**SPI**)
    is the set of `public` interfaces and `abstract` classes that a service defines.
  prefs: []
  type: TYPE_NORMAL
- en: You can define a service provider by implementing the service provider API.
    Usually, you create a JAR file to hold your provider. To register your provider,
    you must create a provider configuration file in the JAR file's `META-INF/services`
    directory. When adding the `services` attribute to your `META-INF/MANIFEST.MF`
    file, you are actually able to load the services contained in the `META-INF/services`
    directory.
  prefs: []
  type: TYPE_NORMAL
- en: One excellent introduction to the SPI API is available at [http://www.oracle.com/technetwork/articles/javase/extensible-137159.html](http://www.oracle.com/technetwork/articles/javase/extensible-137159.html).
  prefs: []
  type: TYPE_NORMAL
- en: Setting up global modules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Setting up global modules resembles the old AS approach to loading common libraries,
    where you used to place them in the `lib` folder under `JBOSS_HOME/common`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you define a section named `global-modules` within `standalone.xml/domain.xml`,
    then you make the module accessible to other AS modules. For example, instead
    of declaring a dependency on log4j, you can alternatively use the following section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Although this approach is not generally recommended, as it brings us back to
    the concept of a monolithic application server, it can still yield some benefits,
    for example, when you migrate some older applications, and also when you don't
    want or simply cannot specify dependencies to the archive.
  prefs: []
  type: TYPE_NORMAL
- en: Advanced deployment strategies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The topics covered so far are sufficient for the vast majority of applications.
    If you are using a complex archive configuration, such as an EAR archive with
    several modules and dependencies, it might be useful to define your classloading
    strategy in a single file. The configuration file, `jboss-deployment-structure.xml`,
    does exactly this. Some of the advantages of using this file are outlined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: You can define the dependencies of all application modules in a single file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can load the module classes in a fine-grained manner by including/excluding
    all or some parts of modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can define the classloading isolation policy for your applications packaged
    in an enterprise archive
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's see what `jboss-deployment-structure.xml` can do for you by taking a look
    at some practical examples.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a single module dependency
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We have already learned how to activate a `log4j` dependency using the `Dependencies`
    attribute in the archive's `MANIFEST` file. The same effect can be achieved using
    the `jboss-deployment-structure.xml` file. Let's recap the archive structure,
    which is basically made up of a web application named `WebApp.war`.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see in the following diagram, the `jboss-deployment-structure.xml`
    file needs to be placed within the `META-INF` folder of the EAR:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up a single module dependency](img/6232OS_06_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following is the content of `jboss-deployment-structure.xml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The `jboss-deployment-structure` file is not for the exclusive use of EARs and
    can be used within a WAR archive by placing it within the `WEB-INF` folder. It
    is, however, applicable only as a top-level archive. Thus, if a `jboss-deployment-structure.xml`
    file is placed in the WAR's `WEB-INF` folder and the WAR is packaged in an EAR
    file, then the `jboss-deployment-structure.xml` file is ignored. The relevant
    part of this file is the subdeployment element, which references the web application,
    including the `dependencies` element. The expected outcome is that the application
    server triggers the dependency to the Log4J API, which is, therefore, visible
    by our web application.
  prefs: []
  type: TYPE_NORMAL
- en: Excluding the server's automatic dependencies
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Earlier in this chapter, we discussed how the application server can automatically
    trigger dependencies when certain conditions are met. For example, if you deploy
    a JSF application (containing the `faces-config.xml` file), then the JSF 2.2 API
    implementation is automatically added.
  prefs: []
  type: TYPE_NORMAL
- en: 'This might not always be the desired option, as you may want to provide another
    release implementation for that module. You can easily achieve this using the
    `exclusion` element in the `jboss-deployment-structure.xml` file, as shown in
    the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that in the `dependencies` section, we added our alternate JSF 2.1 implementation,
    which is used by your application. You need to install these two modules shown
    in the preceding code, as explained in [Chapter 2](ch02.html "Chapter 2. Configuring
    the Core WildFly Subsystems"), *Configuring the Core WildFly Subsystems*. They
    can be placed alongside the implementations provided by WildFly by creating a
    folder named `2.1`. The new folder for the JSF 2.1 archive is highlighted in bold
    in the following command lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'You also need to add the `slot` attribute to the `module.xml` file, as highlighted
    in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Isolating sub-deployments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Considering that you have an EAR application that is made up of a web application,
    an EJB module, and a JAR file containing utility classes, all subdeployments are
    placed at the root of the archive so that they can see each other. However, let''s
    suppose your web application contains some implementations of the same EJB. That''s
    absolutely possible since Java EE allows your web application to include EJB classes
    within the `WEB-INF/classes` or `WEB-INF/lib` folder, as the following diagram
    depicts:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Isolating sub-deployments](img/6232OS_06_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'How does the classloader resolve this conflict? The application server classloader
    has a priority list when loading classes, thus reducing any conflict between loaded
    classes, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The highest priority is automatically given to modules by the container, including
    the Java EE APIs. Libraries contained in the `modules` folder are included in
    this category.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next priority goes to libraries that are indicated by the user within `MANIFEST.MF`
    of the packaged archive as dependencies (or in the `jboss-deployment-structure.xml`
    file).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The penultimate priority is given to libraries that are packed within the application
    itself, such as classes contained in `WEB-INF/lib` or `WEB-INF/classes`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, the last priority goes to libraries that are packed within the same
    EAR archive (in the EAR's `lib` folder).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, in this example, the EJB libraries located in the `WEB-INF` folder hides
    the implementations of `EJB.jar` top-level deployment. If this is not the desired
    result, you can simply override it, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, we added a dependency to the `EJB.jar` deployment,
    which is placed at the root of the EAR and which overrides the implementation
    packed within the web application.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note the `ear-subdeployments-isolated` element placed at the top of the file.
    By setting the EAR isolation level, you will be able to indicate if the subdeployment
    modules are visible to each other.
  prefs: []
  type: TYPE_NORMAL
- en: The default value of the `ear-subdeployments-isolated` element is `false`, which
    means that the subdeployment modules can see each other. If you are setting isolation
    to `true`, each module is then picked up by a different classloader, which means
    that the web application is unable to find the classes contained in the `EJB.jar`
    and `Utility.jar` libraries).
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to keep the deployment isolated but allow visibility between some
    of your dependencies, then you have two choices available:'
  prefs: []
  type: TYPE_NORMAL
- en: Move the library to the `EAR/lib` folder so that it is picked up as a separate
    module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Specify a dependency using Dependencies or Class-Path in the `MANIFEST.MF` file
    of the calling application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the following diagram, you can see how to correctly set up your EAR, by
    placing common libraries in the `lib` folder and adding a dependency to the EJB
    classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Isolating sub-deployments](img/6232OS_06_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following is the corresponding configuration required in `jboss-deployment-structure.xml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Packaging libraries in a shared library within your EAR is an option. With
    Java EE 5 onward, it has been possible to place these files in a shared library
    folder called `lib`. You can override this default folder name using the `library-directory`
    element in the `META-INF/application.xml` file. For example, suppose you want
    to use the `common` folder to hold your shared libraries, in which case you can
    add the following line to your `application.xml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: As a side note, you should avoid placing component-declaring annotations (such
    as EJB3) in the shared folder, as it can have unintended consequences on the deployment
    process. For this reason, it is strongly recommended that you place your utility
    classes in the shared library folder.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Class-Path declaration to solve dependencies
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Until now, we have configured dependencies between modules using the JBoss way,
    which is the recommended choice. Nevertheless, we should also account for Java's
    portable way to reference one or more libraries included in the EAR file. This
    can be achieved by adding the `Class-Path` attribute to the `MANIFEST.MF` file.
    This allows a module to reference another library that is not otherwise visible
    to the application (think back to the earlier example of a deployment unit with
    the isolation set to `true`).
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, considering that you need to reference the `Utility.jar` application
    from within your web application, you can simply add the following to your `META-INF/MANIFEST.MF`
    file directly inside your EAR:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: You can actually include more than one library to the `Class-Path` attribute,
    separating them by a comma.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Unlike the `Dependencies` attribute, the `Class-Path` attribute points to the
    actual JAR filename (and not the module name) to reference the dependent libraries.
  prefs: []
  type: TYPE_NORMAL
- en: 'Choosing between the Class-Path approach and JBoss''s Dependencies approach
    depends on how your application is structured: using JBoss''s Dependencies approach
    buys you a richer set of options, in particular, the ability to export the dependencies
    to other deployments, as we have illustrated earlier. One more point in favor
    of JBoss''s Dependencies approach is the ability to reference modules that are
    not actually packaged within the application.'
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, the main advantage of the Class-Path approach relies on application
    portability. Thus, if a fully portable solution is a priority for you, you can
    consider switching to the `Class-Path` manifest attribute.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered a wide variety of functionalities related to the
    deployment of applications. Applications are deployed differently, depending on
    whether they are deployed to a standalone server or to a domain of servers.
  prefs: []
  type: TYPE_NORMAL
- en: As far as standalone servers are concerned, an application can be deployed either
    automatically or manually. By default, packaged archives are deployed automatically.
    This means that all you need to do is place the archive within the `standalone`/`deployments`
    folder of the application server. Applications that are deployed manually (by
    default, exploded archives) need marker files to activate the deployment.
  prefs: []
  type: TYPE_NORMAL
- en: As far as domain servers are concerned, since the application server cannot
    determine which server group you want to target the deployment to, you need to
    specify this information when using either the command-line interface or the web
    admin interface.
  prefs: []
  type: TYPE_NORMAL
- en: One of the great advantages of using a domain of servers is the ability to deploy
    applications on single or multiple server groups, which can even be created and
    equipped at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: In the later part of this chapter, we covered the classloading mechanism used
    by the application server. Every application deployed to WildFly is treated as
    a module, all of which are isolated from other modules contained in the application
    server distribution. Modules representing Java EE API classes are implicitly added
    to your application's classpath as dependencies, which means that you don't need
    any special configuration to deploy a Java EE application.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to reference other modules contained in the application server,
    you simply need to add a `Dependencies` property within the `META-INF/MANIFEST.MF`
    file of the application. Enterprise archives can also specify dependencies on
    other modules by setting the `Class-Path` attribute within the `META-INF/MANIFEST.MF`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to maintain all your dependencies in a single file, you can use
    the `jboss-deployment-structure.xml` file. This allows you to define all dependencies
    within an archive, including the ability to override the default EAR isolation
    level and filter in/out classes, which are part of the application server deployment.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will cover the management of the application server
    by taking a close look at the command-line interface and the web admin console.
  prefs: []
  type: TYPE_NORMAL
