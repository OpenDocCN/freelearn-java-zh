- en: '*Chapter 17*: Multitenancy in jOOQ'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes, our applications need to operate in a multitenant environment, that
    is, in an environment that operates on multiple tenants (different databases,
    different tables, or generally speaking, different instances that are logically
    isolated, but physically integrated). In this chapter, we will cover some common
    use cases of integrating jOOQ in a multitenant environment based on the following
    agenda:'
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to a separate database per role/login via the `RenderMapping` API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connecting to a separate database per role/login via a connection switch
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating code for two schemas of the same vendor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating code for two schemas of different vendors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code for this chapter can be found on GitHub at [https://github.com/PacktPublishing/jOOQ-Masterclass/tree/master/Chapter17](https://github.com/PacktPublishing/jOOQ-Masterclass/tree/master/Chapter17).
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to a separate database per role/login via the RenderMapping API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Connecting to a separate database per role/login is a classical use case of
    multitenancy. Commonly, you have a pillar database (let's call it the `development`
    database) and several other databases with the same schema (let's call them the
    `stage` database and the `test` database). All three databases belong to the same
    vendor (here, MySQL) and have the same schema, but they hold data for different
    roles, accounts, organizations, partners, and so on of the application.
  prefs: []
  type: TYPE_NORMAL
- en: For simplicity, the `development` database has a single table named `product`.
    This database is used for generating jOOQ artifacts, but we want to execute the
    queries depending on the current role (currently logged in user) against the `stage`
    or `test` databases.
  prefs: []
  type: TYPE_NORMAL
- en: 'The key to such implementation relies on juggling with the jOOQ `RenderMapping`
    API. jOOQ allows us to specify at runtime an input schema (for instance, `development`)
    and an output schema (for instance, `stage`), and, in queries, it will render
    the output schema. The climax of the code relies on these settings, as you can
    see here (the authentication is specific to the Spring Security API):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Depending on the role of the currently authenticated user, jOOQ renders the
    expected database name (for instance, `` `stage`.`product` `` or `` `test`.`product`
    ``). Basically, each user has a role (for instance, `ROLE_STAGE` or `ROLE_TEST`;
    for simplicity, a user has a single role), and we extract the output database
    name by removing `ROLE_` and lowercase the remaining text; by convention, the
    extracted text represents the name of the database as well. Of course, you can
    use the username, organization name, or whatever convention makes sense in your
    case.
  prefs: []
  type: TYPE_NORMAL
- en: You can test this example in the application named *MT* for MySQL.
  prefs: []
  type: TYPE_NORMAL
- en: The `withInput()` method takes the complete name of the input schema. If you
    want to match the name of the input schema against a regular expression, then
    instead of `withInput()`, use `withInputExpression(Pattern.compile("reg_exp"))`
    (for instance, `("development_(.*)")`).
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are in a database that supports catalogs (for instance, SQL Server),
    then simply use `MappedCatalog()` and `withCatalogs()`, as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'If you don''t need a runtime schema and instead need to hardwire mappings at
    code generation time (jOOQ will always render at runtime, conforming to these
    settings), then, for Maven, use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'For Gradle, use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the following for programmatic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: You can see such an example in *MTM* for MySQL. As you'll see, all accounts/roles
    act against the database that was hardwired at code generation time (the `stage`
    database).
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are using a database that supports catalogs (for instance, SQL Server),
    then simply rely on `<catalogs>`, `<catalog>`, `<inputCatalog>`, and `<outputCatalog>`.
    For Maven, use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'For Gradle, use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'For programmatic, use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'So far, the `development` database has a single table named `product`. This
    table has the same name in the `stage` and `test` databases but let''s assume
    that we decide to call it `product_dev` in the `development` database, `product_stage`
    in the `stage` database, and `product_test` in the `test` database. In this case,
    even if jOOQ renders the database name per role correctly, it doesn''t render
    the table''s names correctly. Fortunately, jOOQ allows us to configure this aspect
    via `withTables()` and `MappedTable()`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: You can check out this example in the application named *MTT* for MySQL.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to a separate database per role/login via a connection switch
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another quick solution for connecting to a separate database per role/login
    consists of switching to the proper connection at runtime. In order to accomplish
    this task, we have to suppress the jOOQ default behavior of rendering the schema/catalog
    name. This way, we don't risk connecting to database `A` but get database `B`
    rendered in front of our tables, and so on. In other words, we need unqualified
    names.
  prefs: []
  type: TYPE_NORMAL
- en: 'jOOQ allows us to turn off rendering the schema/catalog name via the `withRenderSchema(false)`
    and `withRenderCatalog(false)` settings. The following example connects to the
    database having the same name as the role of the logged in user and suppresses
    rendering the schema/catalog names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: You can check out this example in the application named *MTC* for MySQL.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, we can instruct jOOQ to remove any schema references from the
    generated code via the `outputSchemaToDefault` flag. For Maven, use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'For Gradle, use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'Since there are no more schema references in the generated code, the generated
    classes can run on all your schemas:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: You can test this example in the application named *MTCO* for MySQL.
  prefs: []
  type: TYPE_NORMAL
- en: Generating code for two schemas of the same vendor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Consider two schemas of the same vendor named `db1` and `db2`. In the first
    schema (`db1`), we have a table named `productline`, and in the second schema
    (`db2`), we have a table named `product`. Our goal is to generate the jOOQ artifacts
    (to run the jOOQ Code Generator) for these two schemas of the same vendor (here,
    MySQL) and to execute queries against one or another, and even join these two
    tables.
  prefs: []
  type: TYPE_NORMAL
- en: 'Basically, as long as we don''t specify any input schema, jOOQ generates code
    for all the schemas it can find. But since we want to instruct jOOQ to work only
    on the `db1` and `db2` schemas, we can do it as follows (here, for Maven):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: I am sure you have enough experience now to intuit how to write this for Gradle
    or programmatic, so I'll skip those examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we run the jOOQ Code Generator, we are ready to execute queries, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, here is a join between `PRODUCTLINE` and `PRODUCT`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: '`DB1` and `DB2` were statically imported, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: The complete example is available in the application named *MTJ* for MySQL.
  prefs: []
  type: TYPE_NORMAL
- en: Generating code for two schemas of different vendors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Consider two schemas of different vendors – for instance, our `classicmodels`
    schema for MySQL and PostgreSQL. Our goal is to generate the jOOQ artifacts for
    both schemas and execute queries against one or another.
  prefs: []
  type: TYPE_NORMAL
- en: 'Considering a Maven-based application, we can accomplish this task by using
    two `<execution>` entries, for the `flyway-maven-plugin` plugin and the `jooq-codegen-maven`
    plugin. Here is the skeleton code for `jooq-codegen-maven` (the complete code
    is available in the bundled code):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, jOOQ generates artifacts for both vendors and we can switch between connections
    and tables, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, considering that we have already programmatically configured our `DataSource`
    objects, we can configure two `DSLContext` as well (the complete code is available
    in the bundled code):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE189]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE193]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also inject these two `DSLContext` and use the one you want:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE194]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE195]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE196]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE197]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE198]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE199]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE200]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE201]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE202]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE203]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE204]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE205]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE206]'
  prefs: []
  type: TYPE_PRE
- en: The complete code is named *MT2DB*. If you want to generate the artifacts for
    only one vendor depending on the active profile, then you'll love the *MP* application.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Multitenancy is not a regular task but it is good to know that jOOQ is quite
    versatile and allows us to configure multiple databases/schemas in seconds. Moreover,
    as you just saw, the jOOQ + Spring Boot combo is a perfect match for accomplishing
    multitenancy tasks.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we talk about jOOQ SPI.
  prefs: []
  type: TYPE_NORMAL
