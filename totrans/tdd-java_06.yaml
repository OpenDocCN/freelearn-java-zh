- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Following the Rhythms of TDD
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跟随 TDD 的节奏
- en: We’ve seen how individual unit tests help us explore and capture design decisions
    about our code and keep our code defect-free and simple to use, but that’s not
    all they can do. TDD has rhythms that help us with the whole development cycle.
    By following the rhythms, we have a guide on what to do next at each step. It
    is helpful to have this technical structure that allows us to think deeply about
    engineering good code and then capture the results.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到单个单元测试如何帮助我们探索和捕捉关于代码的设计决策，并保持我们的代码无缺陷且易于使用，但这并不是它们能做的全部。TDD 有节奏可以帮助我们整个开发周期。通过遵循这些节奏，我们在每个步骤中都有一个下一步行动的指南。拥有这种技术结构，我们可以深入思考如何编写良好的代码，并捕捉结果，这非常有帮助。
- en: The first rhythm was covered in the last chapter. Inside each test, we have
    a rhythm of writing the Arrange, Act, and Assert sections. We’ll add some detailed
    observations on succeeding with this next. We’ll go on to cover the larger rhythm
    that guides us as we refine our code, known as the **red, green, refactor** (**RGR**)
    cycle. Together, they help us craft our code to be easy to integrate into the
    broader application and made of clean, simple-to-understand code. Applying these
    two rhythms ensures that we deliver high-quality code at pace. It provides us
    with several small milestones to hit during each coding session. This is highly
    motivating, as we gain a sense of steady progress toward our goal of building
    our application.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 上一章介绍了第一个节奏。在每个测试中，我们都有编写 Arrange、Act 和 Assert 部分的节奏。接下来，我们将对此进行一些详细的观察。我们将继续介绍一个更大的节奏，它指导我们在细化代码时进行操作，被称为**红、绿、重构**（**RGR**）循环。它们共同帮助我们编写易于集成到更广泛应用程序中的代码，并使其由简洁、易于理解的代码组成。应用这两个节奏确保我们以速度交付高质量的代码。它为我们提供了在每次编码会话期间要达到的几个小里程碑。这非常有动力，因为我们能感受到朝着构建应用程序目标稳步前进的感觉。
- en: 'In this chapter, we’re going to cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下主题：
- en: Following the RGR cycle
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跟随 RGR 循环
- en: Writing our next tests for Wordz
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为 Wordz 编写下一个测试
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The final code in this chapter can be found at [https://github.com/PacktPublishing/Test-Driven-Development-with-Java/tree/main/chapter06](https://github.com/PacktPublishing/Test-Driven-Development-with-Java/tree/main/chapter06).
    It is recommended to follow along with the exercise by typing the code in yourself
    – and thinking about all the decisions we will be making as we go.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的最终代码可以在[https://github.com/PacktPublishing/Test-Driven-Development-with-Java/tree/main/chapter06](https://github.com/PacktPublishing/Test-Driven-Development-with-Java/tree/main/chapter06)找到。建议您亲自输入代码并思考我们在进行过程中将做出的所有决策，以跟随练习。
- en: Following the RGR cycle
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跟随 RGR 循环
- en: We saw in the previous chapter how a single unit test is split into three parts,
    known as the Arrange, Act, and Assert sections. This forms a simple rhythm of
    work that guides us through writing every test. It forces us to design how our
    code is going to be used – the outside of our code. If we think of an object as
    being an encapsulation boundary, it makes sense to talk about what is inside and
    outside that boundary. The public methods form the outside of our object. The
    Arrange, Act and Assert rhythm helps us design those.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们看到了如何将单个单元测试分为三个部分，即 Arrange、Act 和 Assert 部分。这形成了一个简单的工作节奏，引导我们编写每个测试。它迫使我们设计代码的用法——代码的外部。如果我们把对象看作是一个封装边界，那么讨论边界内外的内容是有意义的。公共方法构成了我们对象的表面。Arrange、Act
    和 Assert 节奏帮助我们设计这些内容。
- en: We’re using the word *rhythm* here in an almost musical sense. It’s a constant,
    repeating theme that holds our work together. There is a regular flow of work
    in writing tests, writing code, improving that code, and then deciding which test
    to write next. Every test and piece of code will be different, but the rhythm
    of work is the same, as though it were a steady beat in an ever-changing song.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用“节奏”这个词，几乎是在音乐意义上的。它是一个恒定、重复的主题，将我们的工作统一起来。在编写测试、编写代码、改进代码以及决定下一个要编写的测试方面，都有一个常规的工作流程。每个测试和代码片段都将不同，但工作节奏是相同的，就像一首不断变化的歌中的稳定节拍一样。
- en: Once we have written our test, we turn to creating the code that is inside our
    object – the private fields and methods. For this, we make use of another rhythm
    called RGR. This is a three-step process that helps us to build confidence in
    our test, create a basic implementation of our code, and then refine it safely.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们编写了测试，我们就转向创建对象内部的代码 – 私有字段和方法。为此，我们利用另一种节奏，称为RGR。这是一个三步过程，帮助我们建立对测试的信心，创建代码的基本实现，然后安全地对其进行改进。
- en: In this section, we will learn what work needs to be done in each of the three
    phases.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习在每个三个阶段中需要完成哪些工作。
- en: Starting on red
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从红色阶段开始
- en: '![Figure 6.1 – The red phase](img/Figure_6.1_B18384.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![图6.1 – 红色阶段](img/Figure_6.1_B18384.jpg)'
- en: Figure 6.1 – The red phase
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1 – 红色阶段
- en: We always start with the first phase called the red phase. The goal of this
    phase is to use the Arrange, Act and Assert template to get our test up and running
    and ready to test the code we will write next. The most important part of this
    phase is to make sure that the test does not pass. We call this a failing test,
    or a red test, due to the color that most graphical test tools use to indicate
    a failing test.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们总是从第一个阶段开始，称为红色阶段。这个阶段的目标是使用 Arrange, Act 和 Assert 模板让我们的测试启动并运行，准备好测试我们接下来要编写的代码。这个阶段最重要的部分是确保测试不通过。我们称之为失败测试，或红色测试，因为大多数图形测试工具使用这种颜色来表示失败测试。
- en: That’s rather counter-intuitive, isn’t it? We normally aim to make things work
    right the first time in development. However, we want our test to fail at this
    stage to give us confidence that it is working correctly. If the test passes at
    this point, it’s a concern. Why does it pass? We know that we have not yet written
    any of the code we are testing. If the test passes now, that means we either do
    not need to write any new code or we have made a mistake in the test. The *Further
    reading* section has a link to eight reasons why a test might not be running correctly.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这相当反直觉，不是吗？我们通常在开发过程中力求第一次就能让事情运作正确。然而，我们希望在这个阶段测试失败，以增强我们对它正确工作的信心。如果测试在这个时候通过，那就令人担忧。为什么它会通过？我们知道我们还没有编写我们正在测试的任何代码。如果测试现在通过，这意味着我们可能不需要编写任何新代码，或者我们在测试中犯了错误。*进一步阅读*部分有一个链接，列出了八个可能导致测试无法正确运行的原因。
- en: The most common mistake here is getting the assertion wrong. Identify the error
    and fix it before moving on. We must have that red test in place so that we can
    see it change from failing to passing as we correctly add code.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这里最常见的错误是断言错误。在继续之前，识别错误并修复它。我们必须有那个红色测试，这样我们才能看到它从失败变为通过，因为我们正确地添加了代码。
- en: Keep it simple – moving to green
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保持简单 – 转向绿色
- en: '![Figure 6.2 – The green phase](img/Figure_6.2_B18384.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图6.2 – 绿色阶段](img/Figure_6.2_B18384.jpg)'
- en: Figure 6.2 – The green phase
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2 – 绿色阶段
- en: Once we have our failing test, we are free to write the code that will make
    it pass. We call this the production code – the code that will form part of our
    production system. We treat our production code as a *black-box* component. Think
    of an integrated circuit in electronics, or perhaps some kind of mechanical sealed
    unit. The component has an inside and an outside. The inside is where we write
    our production code. It is where we hide the data and algorithms of our implementation.
    We can do this using any approach we choose – object-oriented, functional, declarative,
    or procedural. Anything we fancy. The outside is the **Application Programming
    Interface** (**API**). This is the part we use to connect to our component and
    use it to build bigger pieces of software. If we choose an object-oriented approach,
    this API will be made of public methods on an object. With TDD, the first piece
    we connect to is our test, and that gives us fast feedback on how easy the connection
    is to use.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了失败的测试，我们就可以自由地编写使其通过的代码。我们称之为生产代码 – 将成为我们生产系统一部分的代码。我们将生产代码视为一个 *黑盒* 组件。想想电子中的集成电路，或者可能是一些机械密封单元。组件有内部和外部。内部是我们编写生产代码的地方。这是我们隐藏实现中的数据和算法的地方。我们可以使用我们选择的任何方法
    – 面向对象、函数式、声明式或过程式。任何我们喜欢的方法。外部是 **应用程序编程接口** (**API**)。这是我们用来连接我们的组件并使用它来构建更大软件的部分。如果我们选择面向对象的方法，这个API将由对象上的公共方法组成。在TDD中，我们首先连接的是我们的测试，这让我们能够快速得到关于连接使用难易程度的反馈。
- en: 'The following diagram shows the different pieces – the inside, outside, test
    code, and other users of our component:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图示显示了不同的部分 – 内部、外部、测试代码以及我们组件的其他用户：
- en: "![Figure 6.3 – The inside and outside a \uFEFFblack-box component](img/Figure_6.3_B18384.jpg)"
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图6.3 – 黑盒组件的内部和外部](img/Figure_6.3_B18384.jpg)'
- en: Figure 6.3 – The inside and outside a black-box component
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.3 – 黑盒组件的内部和外部
- en: Because our implementation is encapsulated, we can change our minds about it
    later as we learn more without breaking the test.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的实现是封装的，因此我们可以随着了解更多信息而改变主意，而不会破坏测试。
- en: 'There are two guidelines for this phase:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这个阶段有两个指导原则：
- en: '**Use the simplest code that could possibly work**: Using the simplest code
    is important. There can be a temptation to use over-engineered algorithms, or
    perhaps use the latest language feature just for an excuse to use it. Resist this
    temptation. At this stage, our goal is to get the test to pass and nothing more.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用最简单的代码即可工作**：使用最简单的代码非常重要。可能会有一种诱惑，想要使用过度设计的算法，或者可能仅仅为了使用它而使用最新的语言特性。抵制这种诱惑。在这个阶段，我们的目标是让测试通过，没有更多。'
- en: '**Don’t overthink the implementation details**: We don’t need to overthink
    this. We don’t need to write the perfect code on our first attempt. We can write
    a single line, a method, several methods, or entirely new classes. We will improve
    this code in the next step. Just remember to make the test pass and not go beyond
    what this test is covering in terms of functionality.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不要过度思考实现细节**：我们不需要过度思考这一点。我们不需要在第一次尝试时就写出完美的代码。我们可以写一行代码，一个方法，几个方法，或者完全新的类。我们将在下一步改进这段代码。只需记住让测试通过，不要超出这个测试在功能上的覆盖范围。'
- en: Refactoring to clean code
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重构以编写干净的代码
- en: '![Figure 6.4 – The refactor phase](img/Figure_6.4_B18384.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图6.4 – 重构阶段](img/Figure_6.4_B18384.jpg)'
- en: Figure 6.4 – The refactor phase
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.4 – 重构阶段
- en: 'This is the phase where we go into software engineering mode. We have some
    working, simple code with a test that passes. Now is the time to refine that into
    clean code – meaning code that will be easy to read later. With the confidence
    that a passing test provides, we are free to apply any valid refactoring technique
    to our code. Some examples of refactoring techniques we can use during this phase
    include the following:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这是进入软件工程模式的阶段。我们有一些工作简单且通过测试的代码。现在是时候将其精炼成干净的代码——这意味着代码将易于阅读。有了通过测试提供的信心，我们可以自由地应用任何有效的重构技术到我们的代码中。在这个阶段，我们可以使用的重构技术示例包括以下：
- en: Extracting a method to remove duplicated code
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提取一个方法以删除重复的代码
- en: Renaming a method to express what it does better
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重命名一个方法以更好地表达其功能
- en: Renaming a variable to express what it contains better
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重命名一个变量以更好地表达其内容
- en: Splitting a long method into several smaller ones
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将长方法拆分成几个更小的方法
- en: Extracting a smaller class
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提取一个更小的类
- en: Combining a long parameter list into its own class
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将长参数列表组合成它自己的类
- en: 'All these techniques have one goal: to make our code easier to understand.
    This will make it easier to maintain. Remember to keep that green test passing
    throughout these changes. By the end of this phase, we will have a unit test covering
    a piece of production code that we have engineered to be easy to work with in
    the future. That’s a good place to be.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些技术都有一个目标：使我们的代码更容易理解。这将使它更容易维护。记住在整个这些变化中保持绿色测试通过。到这个阶段结束时，我们将有一个单元测试覆盖了我们设计得在未来更容易工作的生产代码的一部分。这是一个很好的地方。
- en: Now we’re familiar with what to do in each phase of the RGR cycle, let’s apply
    that to our Wordz application.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经熟悉了RGR循环的每个阶段应该做什么，让我们将这一点应用到我们的Wordz应用程序中。
- en: Writing our next tests for Wordz
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为Wordz编写下一个测试
- en: So, what should we write for our next tests? What would be a useful and small-enough
    step so that we do not fall into the trap of writing beyond what our tests can
    support? In this section, we will continue building out the Wordz application
    scoring system using TDD. We will discuss how we choose to move forward at each
    step.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们接下来应该编写什么样的测试呢？应该采取一个有用且足够小的步骤，这样我们才不会陷入编写超出测试支持范围的陷阱？在本节中，我们将继续使用TDD构建Wordz应用程序的评分系统。我们将讨论在每个步骤中我们如何选择前进。
- en: 'For the next test, a good choice is to play it safe and move only a small step
    further. We will add a test for a single correct letter. This will drive out our
    first piece of genuine application logic:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 对于下一个测试，一个好的选择是保守行事，只向前迈出很小的一步。我们将添加一个测试来检查单个正确的字母。这将驱使我们编写第一段真正的应用程序逻辑：
- en: 'Let’s start on red. Write a failing test for a single, correct letter:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从红色开始。编写一个针对单个正确字母的失败测试：
- en: '[PRE0]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This test is intentionally similar to the one before. The difference is that
    it tests for a letter being correct, rather than being incorrect. We have used
    the same word – a single letter, `"A"` – intentionally. This is important when
    writing tests – use test data that helps to tell the story of what we are testing
    and why. The story here is that the same word with a different guess will lead
    to a different score – obviously key to the problem we are solving. Our two test
    cases completely cover both possible outcomes of any guess of a single-letter
    word.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试故意与之前的测试相似。不同之处在于它测试的是字母是否正确，而不是不正确。我们故意使用了同一个单词——一个单独的字母，“A”。在编写测试时这一点很重要——使用有助于讲述我们正在测试的内容及其原因的测试数据。这里的情节是，同一个单词的不同猜测将导致不同的分数——这显然是我们正在解决的问题的关键。我们的两个测试案例完全覆盖了任何单字母词猜测的所有可能结果。
- en: Using our IDE auto-completion features, we quickly arrive at changes to `class
    Word`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们的IDE自动完成功能，我们很快对`class Word`进行了修改。
- en: 'Now let’s move to green by adding the production code to make the test pass:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们通过添加使测试通过的生产代码来转向绿色：
- en: '[PRE7]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The goal here is to get the new test to pass while keeping the existing test
    passing. We don’t want to break any existing code. We’ve added a field called
    `word`, which will store the word we are supposed to be guessing. We’ve added
    a public constructor to initialize this field. We have added code into the `guess()`
    method to create a new `Score` object. We decide to add a method to this `Score`
    class called `assess()`. This method has the responsibility of assessing what
    our guess should score. We decide that `assess()` should have two parameters.
    The first parameter is a zero-based index for which letter of the word we wish
    to assess a score. The second parameter is our guess at what the word might be.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的目标是让新的测试通过，同时保持现有的测试通过。我们不希望破坏任何现有的代码。我们添加了一个名为`word`的字段，用于存储我们应猜测的单词。我们添加了一个公共构造函数来初始化这个字段。我们在`guess()`方法中添加了代码来创建一个新的`Score`对象。我们决定在这个`Score`类中添加一个名为`assess()`的方法。这个方法负责评估我们的猜测应该得到多少分数。我们决定`assess()`应该有两个参数。第一个参数是我们希望评估分数的单词中字母的零基索引。第二个参数是我们对单词可能是什么的猜测。
- en: 'We use the IDE to help us write `class Score`:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用IDE帮助我们编写`class Score`：
- en: '[PRE18]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: To cover the new behavior tested by the `oneCorrectLetter()` test, we add the
    preceding code. Instead of the `assess()` method always returning `Letter.INCORRECT`
    as it did previously, the new test has forced a new direction. The `assess()`
    method must now be able to return the correct score when a guessed letter is correct.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 为了覆盖`oneCorrectLetter()`测试所测试的新行为，我们添加了前面的代码。与之前`assess()`方法总是返回`Letter.INCORRECT`不同，新的测试迫使它转向一个新的方向。现在`assess()`方法必须能够在猜测的字母正确时返回正确的分数。
- en: To achieve this, we added a field called `result` to hold the latest score,
    code to return that result from the `letter()` method, and code into the `assess()`
    method to check whether the first letter of our guess matches the first letter
    of our word. If we have got this right, both of our tests should now pass.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们添加了一个名为`result`的字段来保存最新的分数，从`letter()`方法返回结果的代码，以及`assess()`方法中的代码来检查我们的猜测的第一个字母是否与我们的单词的第一个字母匹配。如果我们做对了，我们的两个测试现在都应该通过。
- en: 'Run all the tests to see how we are doing:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 运行所有测试以查看我们的进展：
- en: "![Figure 6.\uFEFF5 – Two tests passing](img/Figure_6.5_B18384.jpg)"
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图6.5 – 两个测试通过](img/Figure_6.5_B18384.jpg)'
- en: Figure 6.5 – Two tests passing
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.5 – 两个测试通过
- en: There’s a lot to review here. Notice how both of our tests are passing. By running
    all the tests so far, we have proven that we have not broken anything. The changes
    we made to our code added the new feature and did not break any existing features.
    That’s powerful. Take note of another obvious aspect – we know our code works.
    We do not have to wait until a manual test phase, wait until some integration
    point, or wait until the user interface is ready. We know our code works now.
    As a minor point, note the time duration of 0.103 seconds. The two tests were
    completed in one-tenth of one second, much faster than testing this manually.
    Not bad at all.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有很多东西需要回顾。注意我们的两个测试都是通过的。通过运行到目前为止的所有测试，我们已经证明我们没有破坏任何东西。我们对代码所做的更改添加了新功能，而没有破坏任何现有功能。这是强大的。注意另一个明显的方面——我们知道我们的代码是有效的。我们不必等到手动测试阶段，也不必等到某个集成点，或者等到用户界面准备好。我们知道我们的代码现在有效。作为一个小细节，注意0.103秒的时间长度。两个测试在一十分之一秒内完成，比手动测试快得多。一点也不差。
- en: Design-wise, we have moved on. We have moved past the hard-coded `Letter.INCORRECT`
    result with code that can detect both correct and incorrect guesses. We have added
    the important design concept of an `assess()` method into `class Score`. This
    is significant. Our code now reveals a design; the `Score` object will know the
    correct `word` and will be able to use the `assess()` method against the guess,
    `attempt`. The terminology used here forms a good description of the problem we
    are solving. We want to assess a guess to return a word score.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计方面，我们已经前进了一步。我们已经超越了使用代码检测正确和错误猜测的硬编码`Letter.INCORRECT`结果。我们在`Score`类中添加了重要的设计概念`assess()`方法。这是非常重要的。我们的代码现在揭示了一个设计；`Score`对象将知道正确的`word`，并且能够使用`assess()`方法对猜测`attempt`进行评估。这里使用的术语形成了对我们要解决的问题的良好描述。我们想要评估一个猜测并返回一个单词得分。
- en: Now that the test passes, we can move on – but an important part of TDD is continuously
    improving our code and working toward a better design, guided by tests. We now
    enter the refactor phase of the RGR cycle. Once again, TDD hands control back
    to us. Do we want to refactor? What things should we refactor? Why? Is it worth
    doing this right now or can we defer this until a later step?
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在测试通过了，我们可以继续前进——但TDD的一个重要部分是持续改进我们的代码，并朝着更好的设计努力，由测试来指导。我们现在进入了RGR周期的重构阶段。再次，TDD将控制权交还给我们。我们想要重构吗？我们应该重构什么？为什么？现在做这个值得吗，还是我们可以推迟到以后的步骤？
- en: Let’s review the code and look for **code smells**. A code smell is an indication
    that the implementation may need improving. The name comes from the idea of the
    smell that food has once it starts to go off.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下代码，寻找**代码异味**。代码异味是表明实现可能需要改进的一个迹象。这个名称来源于食物开始变质时产生的气味。
- en: One code smell is duplicated code. Alone, a little duplicated code might be
    okay. But it is an early warning that perhaps too much copy-and-paste has been
    used, and that we have failed to capture an important concept more directly. Let’s
    review our code to eliminate duplication. We can also look for two other common
    code smells – unclear naming, and blocks of code that would be easier to read
    if they were extracted out into their own method. Obviously, this is subjective,
    and we will all have different views on what to change.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 代码异味之一是代码重复。单独来看，一点代码重复可能没问题。但它是一个早期警告，表明可能使用了过多的复制粘贴，我们没有更直接地捕捉到一个重要的概念。让我们回顾我们的代码以消除重复。我们还可以寻找其他两种常见的代码异味——不清晰的命名，以及如果将它们提取到自己的方法中会更容易阅读的代码块。显然，这是主观的，我们都会对要做什么有不同的看法。
- en: Defining code smells
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 定义代码异味
- en: 'The term code smell originally appeared on the C2 wiki. It’s worth a read to
    see the given examples of code smells. It has a helpful definition that notes
    a code smell is something that needs review but may not necessarily need to be
    changed:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 术语代码异味最初出现在C2维基上。阅读一下给出的代码异味示例是值得的。它有一个有用的定义，指出代码异味是需要审查的东西，但可能不一定需要改变：
- en: '[https://wiki.c2.com/?CodeSmell](https://wiki.c2.com/?CodeSmell).'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://wiki.c2.com/?CodeSmell](https://wiki.c2.com/?CodeSmell).'
- en: Let’s reflect on the inside of the `assess()` method. It just seems cluttered
    with too much code. Let’s extract a helper method to add some clarity. We can
    always revert the change if we feel it doesn’t help.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们反思一下`assess()`方法内部。它似乎充满了太多的代码。让我们提取一个辅助方法来增加一些清晰度。如果我们觉得这个改动没有帮助，我们总是可以撤销它。
- en: 'Let’s refactor. Extract an `isCorrectLetter()` method for clarity:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们进行重构。为了清晰起见，提取一个`isCorrectLetter()`方法：
- en: '[PRE19]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Once more, we run all the tests to prove this refactoring has not broken anything.
    The tests pass. In the preceding code, we have split out a complex conditional
    statement into its own private method. The motivation was to get a method name
    into the code. This is an effective way of commenting on our code – in a way that
    the compiler helps us keep up to date. It helps the calling code in the `assess()`
    method tell a better story. The `if` statement now says “if this is a correct
    letter” more or less in English. That is a powerful aid to readability.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们运行所有测试以证明这次重构没有破坏任何东西。测试通过了。在前面的代码中，我们将一个复杂的条件语句拆分成了它自己的私有方法。这样做的原因是为了在代码中引入一个方法名。这是一种有效的代码注释方式——以编译器帮助我们保持代码更新。它有助于`assess()`方法中的调用代码讲述一个更好的故事。现在的`if`语句几乎可以说成是“如果这是一个正确的字母”。这是一个强大的可读性辅助工具。
- en: Readability happens during writing not reading
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 可读性发生在写作过程中，而不是阅读过程中
- en: A common question from coding beginners is “How can I improve my ability to
    read code?”
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 编程初学者常见的一个问题是“我如何提高阅读代码的能力？”
- en: This is a valid question, as any line of code will be read by human programmers
    many more times than it was written. Readability is won or lost when you write
    the code. Any line of code can be written either to be easy to read or hard to
    read. We get to choose as writers. If we consistently choose ease of reading over
    anything else, others will find our code easy to read.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个有效的问题，因为任何一行代码都将被人类程序员阅读得比它被编写时更多。可读性是在编写代码时赢得或失去的。任何一行代码都可以被编写成易于阅读或难以阅读。作为作者，我们有权选择。如果我们始终选择易于阅读而不是其他任何东西，其他人会发现我们的代码易于阅读。
- en: Badly written code is hard to read. Sadly, it is easy to write.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 写得不好的代码难以阅读。遗憾的是，编写这样的代码很容易。
- en: There are two more areas I want to refactor at this stage. The first is a simple
    method to improve test readability.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我还有两个区域想要重构。第一个是一个简单的提高测试可读性的方法。
- en: 'Let’s refactor the test code to improve its clarity. We will add a *custom*
    `assert` method:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重构测试代码以提高其清晰度。我们将添加一个*自定义*的`assert`方法：
- en: '[PRE29]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The preceding code has taken the `assertThat()` assertion and moved it into
    its own private method. We have called this method `assertScoreForLetter()` and
    given it a signature that describes what information is needed. This change provides
    a more direct description of what the test is doing while reducing some duplicated
    code. It also protects us against changes in the implementation of the assertion.
    This seems to be a step toward a more comprehensive assertion, which we will need
    once we support guesses with more letters. Once again, instead of adding a comment
    to the source code, we have used a method name to capture the intent of the `assertThat()`
    code. Writing *AssertJ custom matchers* are another way of doing this.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码已经将`assertThat()`断言移动到了它自己的私有方法中。我们称这个方法为`assertScoreForLetter()`，并给它一个描述所需信息的签名。这个改变提供了对测试正在做什么的更直接描述，同时减少了重复的代码。它还保护我们免受断言实现变化的影响。这似乎是朝着更全面的断言迈出的一步，一旦我们支持更多字母的猜测，我们就会需要这种断言。再一次，我们不是在源代码中添加注释，而是使用方法名来捕捉`assertThat()`代码的意图。编写*AssertJ自定义匹配器*是另一种实现方式。
- en: The next refactoring we may want to do is a little more controversial, as it
    is a design change. Let’s do the refactoring, discuss it, then possibly revert
    the code if we don’t like it. That will save hours of wondering about what the
    change would look like.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能想要做的下一个重构可能有点更具争议性，因为它是一个设计变更。让我们进行重构，讨论它，然后如果我们不喜欢它，可能重新调整代码。这样就可以节省数小时的时间，去思考这个变化会是什么样子。
- en: 'Let’s change how we specify the letter position to check in the `assess()`
    method:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们改变一下在`assess()`方法中指定要检查的字母位置的方式：
- en: '[PRE30]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: We’ve removed the `position` parameter from the `assess()` method and converted
    it into a field called `position`. The intention is to simplify the usage of the
    `assess()` method. It no longer needs to explicitly state which position is being
    assessed. That makes the code easier to call. The code we have just added will
    only work in the case where the position is zero. This is fine, as this is the
    only thing required by our tests at this stage. We will make this code work for
    non-zero values later.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经从`assess()`方法中移除了`position`参数，并将其转换为名为`position`的字段。我们的意图是简化`assess()`方法的用法。它不再需要明确指出正在评估哪个位置。这使得代码更容易调用。我们刚刚添加的代码只会在位置为零的情况下工作。这是可以的，因为在这个阶段，我们的测试只需要这一点。我们将在以后使这段代码适用于非零值。
- en: 'The reason this is a controversial change is that it requires us to change
    the test code to reflect that change in the method signature. I am prepared to
    accept this, knowing that I can use my IDE-automated refactoring support to do
    this safely. It also introduces a risk: we must ensure that position is set to
    the correct value before we call `isCorrectLetter()`. We’ll see how this develops.
    This may make the code more difficult to understand, in which case the simplified
    `assess()` method probably will not be worth it. We can change our approach if
    we find this to be the case.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这个改变之所以有争议，是因为它要求我们更改测试代码以反映方法签名中的变化。我已经准备好接受这一点，因为我可以使用我的IDE自动重构支持来安全地完成这项工作。这也引入了一个风险：在我们调用`isCorrectLetter()`之前，我们必须确保位置被设置为正确的值。我们将看看这会如何发展。这可能使代码更难以理解，在这种情况下，简化的`assess()`方法可能不值得。如果我们发现这种情况，我们可以改变我们的方法。
- en: We are now at a point where the code is complete for any single-letter word.
    What should we attempt next? It seems as though we should move on to two-letter
    words and see how that changes our tests and logic.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经到达了一个点，代码可以处理任何单个字母的单词。接下来我们应该尝试什么？看起来我们应该继续到两个字母的单词，看看这会如何改变我们的测试和逻辑。
- en: Advancing the design with two-letter combinations
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用两个字母组合推进设计
- en: 'We can proceed to add tests aimed at getting the code to handle two-letter
    combinations. This is an obvious step to take after getting the code to work with
    a single letter. To do this, we will need to introduce a new concept into the
    code: a letter can be present in the word, but not in the position we guessed
    it to be:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以继续添加测试，目的是让代码能够处理两个字母的组合。在代码能够处理单个字母之后，这是一个明显的下一步。为了做到这一点，我们需要在代码中引入一个新概念：一个字母可以存在于单词中，但不在我们猜测的位置：
- en: 'Let’s begin by writing a test for a second letter that is in the wrong position:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从编写一个测试开始，测试第二个字母是否在错误的位置：
- en: '[PRE49]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Let’s change the code inside the `assess()` method to make this pass and keep
    the existing tests passing.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更改`assess()`方法内部的代码，使其通过并保持现有测试通过。
- en: 'Let’s add initial code to check all the letters in our guess:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们添加初始代码来检查我们猜测中的所有字母：
- en: '[PRE56]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: The main change here is to assess all of the letters in `attempt` and not assume
    it only has one letter in it. That, of course, was the purpose of this test –
    to drive out this behavior. By choosing to convert the `attempt` string into an
    array of `char`, the code seems to read quite well. This simple algorithm iterates
    over each `char`, using the `current` variable to represent the current letter
    to be assessed. This requires the `isCorrectLetter()` method to be refactored
    for it to accept and work with the `char` input – well, either that or converting
    `char` to a `String`, and that looks ugly.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这里主要的改变是评估`attempt`中的所有字母，而不是假设它只有一个字母。当然，这就是这次测试的目的——消除这种行为。通过选择将`attempt`字符串转换为`char`数组，代码看起来读起来相当顺畅。这个简单的算法遍历每个`char`，使用`current`变量来表示要评估的当前字母。这要求对`isCorrectLetter()`方法进行重构，以便它能够接受并处理`char`输入——好吧，或者将`char`转换为`String`，这看起来很丑陋。
- en: The original tests for single-letter behaviors still pass, as they must. We
    know the logic inside our loop cannot possibly be correct – we are simply overwriting
    the `result` field, which can only store a result for one letter at most. We need
    to improve that logic, but we won’t do that until we have added a test for that.
    Working this way is known as **triangulation** – we make the code more general-purpose
    as we add more specific tests. For our next step, we will add code to detect when
    our attempted letter occurs in the word in some other position.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 单个字母行为的原始测试仍然通过，这是必须的。我们知道我们循环内部的逻辑不可能正确——我们只是在覆盖`result`字段，它最多只能存储一个字母的结果。我们需要改进这个逻辑，但我们不会在添加测试之前这么做。这种工作方式被称为**三角测量法**——我们通过添加更具体的测试来使代码更通用。对于我们的下一步，我们将添加代码来检测我们的尝试字母是否在单词中的其他位置出现。
- en: 'Let’s add code to detect when a correct letter is in the wrong position:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们添加代码来检测当正确字母在错误位置时：
- en: '[PRE66]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: We’ve added a call to a new private method, `occursInWord(),` which will return
    `true` if the current letter occurs anywhere in the word. We have already established
    that this current letter is not in the right place. This should give us a clear
    result for a correct letter not in the correct position.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了对一个新私有方法`occursInWord()`的调用，如果当前字母在任何位置出现在单词中，它将返回`true`。我们已经确定当前字母不在正确的位置。这应该为我们提供一个关于正确字母不在正确位置的清晰结果。
- en: This code makes all three tests pass. Immediately, this is suspicious, as it
    shouldn’t happen. We already know that our logic overwrites the single `result`
    field and this means that many combinations will fail. What has happened is that
    our latest test is fairly weak. We could go back and strengthen that test, by
    adding an extra assertion. Alternatively, we can leave it as it is and write another
    test. Dilemmas such as this are common in development and it’s not usually worth
    spending too much time thinking about them. Either way will move us forward.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码使所有三个测试都通过。这立即引起了怀疑，因为不应该发生这种情况。我们已知我们的逻辑会覆盖单个`result`字段，这意味着许多组合将失败。发生的事情是我们的最新测试相当薄弱。我们可以回过头来加强那个测试，添加一个额外的断言。或者，我们可以保持它不变，并编写另一个测试。这种困境在开发中很常见，通常不值得花太多时间去思考它们。无论哪种方式都会推动我们前进。
- en: Let’s add another test to completely exercise the behavior around the second
    letter being in the wrong position.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加另一个测试，以完全锻炼第二个字母位置错误的行为。
- en: 'Add a new test exercising all three scoring possibilities:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个新的测试，以锻炼所有三种评分可能性：
- en: '[PRE79]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: As expected, this test fails. The reason is obvious upon inspecting the production
    code. It’s because we were storing results in the same single-valued field. Now
    that we have a failing test for that, we can correct the scoring logic.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，这个测试失败了。原因在检查生产代码时很明显。是因为我们一直在同一个单值字段中存储结果。现在我们有了针对这个问题的失败测试，我们可以纠正评分逻辑。
- en: 'Add a `List` of results to store the result for each letter position separately:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为每个字母位置单独存储结果添加一个`List`：
- en: '[PRE88]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '[PRE100]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '[PRE105]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '[PRE106]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '[PRE107]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[PRE108]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '[PRE109]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '[PRE110]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '[PRE111]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '[PRE112]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '[PRE113]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '[PRE114]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '[PRE115]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '[PRE116]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '[PRE117]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '[PRE118]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE118]'
- en: '[PRE119]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE119]'
- en: '[PRE120]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE120]'
- en: This took a couple of attempts to get right, driven by failures in the test
    we just added. The preceding end result passes all four tests, proving it can
    correctly score all combinations in a three-letter word. The main change was to
    replace the single-valued `result` field with an `ArrayList` of `results` and
    change the `letter(position)` implementation method to use this new collection
    of results. Running that change caused a failure, as the code could no longer
    detect an incorrect letter. Previously, that had been handled by the default value
    of the `result` field. Now, we must do that explicitly for each letter. We then
    need to update the position within the loop to track which letter position we
    are assessing.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这需要尝试几次才能正确完成，因为我们刚刚添加的测试中出现了失败。前面的最终结果通过了所有四个测试，证明它能够正确地评分三字母词的所有组合。主要的变化是将单值的`result`字段替换为`results`的`ArrayList`，并将`letter(position)`实现方法更改为使用这个新的结果集合。运行这个更改导致了一个失败，因为代码不能再检测到错误的字母。之前，这已经被`result`字段的默认值处理了。现在，我们必须为每个字母显式地做这件事。然后我们需要在循环中更新位置，以跟踪我们正在评估的字母位置。
- en: We’ve added a test, watched it go red and fail, then added code to make the
    test go green and pass, so now it is time to refactor. There are things about
    both the test and the production code that don’t seem quite right.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了一个测试，看到它变红并失败，然后添加了代码使测试变绿并通过，所以现在是时候重构了。测试和生产代码中都有一些看起来不太对劲的地方。
- en: In the production code `class Score`, it is the loop body of the `assess()`
    method that seems unwieldy. It has a long loop body with logic in it and a set
    of `if`-`else`-`if` blocks. It feels as though the code could be made clearer.
    We can extract the loop body into a method. The method name then gives us a place
    to describe what is happening to each thing. The loop then becomes shorter and
    simpler to grasp. We can also replace the `if`-`else`-`if` ladders with a simpler
    construct.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产代码`class Score`中，`assess()`方法的循环体看起来很笨拙。它有一个逻辑和一系列`if`-`else`-`if`块的长的循环体。感觉代码可以更清晰。我们可以将循环体提取到一个方法中。方法名然后给我们一个地方来描述每个事物正在发生什么。循环然后变得更短，更容易理解。我们还可以用更简单的结构替换`if`-`else`-`if`层。
- en: 'Let’s extract the logic inside the loop body into a `scoreFor()` method:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们将循环体内的逻辑提取到一个`scoreFor()`方法中：
- en: '[PRE121]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE121]'
- en: '[PRE122]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE122]'
- en: '[PRE123]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '[PRE124]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '[PRE125]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE125]'
- en: '[PRE126]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE126]'
- en: '[PRE127]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE127]'
- en: '[PRE128]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE128]'
- en: '[PRE129]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE129]'
- en: '[PRE130]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE130]'
- en: '[PRE131]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE131]'
- en: '[PRE132]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE132]'
- en: '[PRE133]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE133]'
- en: '[PRE134]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE134]'
- en: '[PRE135]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE135]'
- en: This reads far more clearly. The body of the `scoreFor()` method is now a concise
    description of the rules for scoring each letter. We replaced the `if`-`else`-`if`
    construction with a simpler `if`-`return` construction. We work out what the score
    is, then exit the method immediately.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这读起来更清晰。`scoreFor()`方法的主体现在是对评分每个字母的规则的简洁描述。我们用更简单的`if`-`return`结构替换了`if`-`else`-`if`结构。我们计算出得分，然后立即退出方法。
- en: The next job is to clean up the test code. In TDD, test code is given equal
    priority to production code. It forms part of the documentation about the system.
    It needs to be maintained and extended alongside the production code. We treat
    test code readability with the same importance as production code.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个任务是清理测试代码。在TDD中，测试代码与生产代码具有相同的优先级。它是系统文档的一部分。它需要与生产代码一起维护和扩展。我们对待测试代码的可读性与对待生产代码一样重要。
- en: The code smell with the test code is around the asserts. Two things could be
    improved. There is an obvious duplication in the code that we could eliminate.
    There is also a question about how many assertions should be made in one test.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 测试代码中的代码异味主要集中在断言上。有两件事可以改进。代码中有一个明显的重复，我们可以消除。还有一个关于一个测试中应该有多少断言的问题。
- en: 'Let’s remove the duplicated assertion code by extracting a method:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们通过提取一个方法来删除重复的断言代码：
- en: '[PRE136]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE136]'
- en: '[PRE137]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE137]'
- en: '[PRE138]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE138]'
- en: '[PRE139]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE139]'
- en: '[PRE140]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE140]'
- en: '[PRE141]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE141]'
- en: '[PRE142]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE142]'
- en: '[PRE143]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE143]'
- en: '[PRE144]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE144]'
- en: '[PRE145]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE145]'
- en: '[PRE146]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE146]'
- en: '[PRE147]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE147]'
- en: '[PRE148]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE148]'
- en: '[PRE149]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE149]'
- en: '[PRE150]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE150]'
- en: '[PRE151]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE151]'
- en: '[PRE152]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE152]'
- en: By extracting the `assertScoreForGuess()` method, we create a way to check the
    scores for a variable number of letters. This eliminates those copy-pasted `assert`
    lines that we had and raises the level of abstraction. The test code reads more
    clearly as we now describe tests in terms of the order of `INCORRECT, PART_CORRECT,
    CORRECT` that we expect the score to be in. By adding a static import to those
    `enum`s, syntax clutter is also beneficially reduced.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: The earlier tests can now be manually modified to make use of this new assertion
    helper. This allows us to inline the original `assertScoreForLetter()` method,
    as it no longer adds value.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s take a look at the final set of tests following our refactoring:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE153]'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE153]'
- en: '[PRE154]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE154]'
- en: '[PRE155]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE155]'
- en: '[PRE156]'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE156]'
- en: '[PRE157]'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE157]'
- en: '[PRE158]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE158]'
- en: '[PRE159]'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE159]'
- en: '[PRE160]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE160]'
- en: '[PRE161]'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE161]'
- en: '[PRE162]'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE162]'
- en: '[PRE163]'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE163]'
- en: '[PRE164]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE164]'
- en: '[PRE165]'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE165]'
- en: '[PRE166]'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE166]'
- en: '[PRE167]'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE167]'
- en: '[PRE168]'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE168]'
- en: '[PRE169]'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE169]'
- en: '[PRE170]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE170]'
- en: '[PRE171]'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE171]'
- en: '[PRE172]'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE172]'
- en: '[PRE173]'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE173]'
- en: '[PRE174]'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE174]'
- en: '[PRE175]'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE175]'
- en: '[PRE176]'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE176]'
- en: '[PRE177]'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE177]'
- en: '[PRE178]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE178]'
- en: '[PRE179]'
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE179]'
- en: '[PRE180]'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE180]'
- en: '[PRE181]'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE181]'
- en: '[PRE182]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE182]'
- en: '[PRE183]'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE183]'
- en: '[PRE184]'
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE184]'
- en: '[PRE185]'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE185]'
- en: '[PRE186]'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE186]'
- en: '[PRE187]'
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE187]'
- en: '[PRE188]'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE188]'
- en: '[PRE189]'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE189]'
- en: '[PRE190]'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE190]'
- en: '[PRE191]'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE191]'
- en: '[PRE192]'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE192]'
- en: '[PRE193]'
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE193]'
- en: '[PRE194]'
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE194]'
- en: '[PRE195]'
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE195]'
- en: '[PRE196]'
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE196]'
- en: This appears to be a comprehensive set of test cases. Every line of production
    code has been driven out as a direct result of adding a new test to explore a
    new aspect of behavior. The test code seems easy to read and the production code
    also seems clearly implemented and simple to call. The test forms an executable
    specification of the rules for scoring a guess at a word.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: That’s achieved everything we set out to at the start of this coding session.
    We have grown the capability of our `Score` class using TDD. We have followed
    the RGR cycle to keep both our test code and production code following good engineering
    practices. We have robust code, validated by unit tests, and a design that makes
    this code easy to call from our wider application.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-304
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have applied the RGR cycle to our code. We’ve seen how this
    splits the work into separate tasks, which results in confidence in our test,
    a rapid path to simple production code, and less time spent to improve the maintainability
    of our code. We’ve looked at removing code smells from both the production code
    and the test code. As part of our work in this chapter, we’ve used ideas that
    help us move ahead and decide what tests we should write next. The techniques
    in this chapter enable us to write multiple tests and incrementally drive out
    the detailed logic in our production code.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’re going to learn about some object-oriented design
    ideas known as the SOLID principles, enabling us to use TDD to grow our application
    still further.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: Questions and answers
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What are the two key rhythms of TDD?
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Arrange, Act, Assert, and RGR. The first rhythm helps us write the body of the
    test while designing the interface to our production code. The second rhythm works
    to help us create and then refine the implementation of that production code.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: How can we write tests before code?
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Instead of thinking about how we are going to implement some code, we think
    about how we are going to call that code. We capture those design decisions inside
    a unit test.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: Should tests be throwaway code?
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: No. In TDD, unit tests are given equal weight to the production code. They are
    written with the same care and are stored in the same code repository. The only
    difference is that the test code itself will not be present in the delivered executable.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: Do we need to refactor after every test pass?
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: No. Use this time as an opportunity to decide what refactoring is needed. This
    applies to both the production code and the test code. Sometimes, none is needed
    and we move on. Other times, we sense that a larger change would be beneficial.
    We might choose to defer that larger change until later once we have more code
    in place.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  id: totrans-316
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Getting Green* *on Red*'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An article by Jeff Langr describing eight different ways a test can pass for
    the wrong reasons. If we’re aware of these issues, we can avoid them as we work.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: '[https://medium.com/pragmatic-programmers/3-5-getting-green-on-red-d189240b1c87](https://medium.com/pragmatic-programmers/3-5-getting-green-on-red-d189240b1c87)'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: '*Refactoring: Improving the design of existing code*, Martin Fowler (ISBN 978-0134757599)'
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The definitive guide to refactoring code. The book describes step-by-step transformations
    of code that preserve its behavior but improve clarity. Interestingly, most transformations
    come in pairs, such as the pair of techniques known as *Extract Method* and *Inline
    Method*. This reflects the trade-offs involved.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: AssertJ documentation for custom matchers
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This chapter briefly mentioned *AssertJ custom matchers*. These are very useful
    ways of creating reusable customized assertions for your code. These assertion
    classes are themselves unit-testable and can be written using test-first TDD.
    For that reason alone, they are superior to adding a private method to handle
    a customized assertion.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: The following link provides many examples provided by the AssertJ distribution
    on github.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/assertj/assertj-examples/tree/main/assertions-examples/src/test/java/org/assertj/examples/custom](https://github.com/assertj/assertj-examples/tree/main/assertions-examples/src/test/java/org/assertj/examples/custom)'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
