<html><head></head><body><div class="chapter" title="Chapter&#xA0;1.&#xA0;Programming Interactively within Your Project"><div class="titlepage"><div><div><h1 class="title"><a id="ch01"/>Chapter 1. Programming Interactively within Your Project</h1></div></div></div><p>Moving away from a well established and mature language such as Java requires some pretty good reasons. Before pragmatically trying out some of the apparent differences between Java and Scala in order to get acquainted with the Scala syntax, we are going to clarify what makes Scala so attractive.</p><p>In this chapter, we will cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The advantages of using Scala for Java projects</li><li class="listitem" style="list-style-type: disc">Getting familiar with the syntax of the language through a crash course following an interactive session, including case classes, operations on collections, and a glimpse of some useful features such as options, tuples, maps, pattern matching, and string interpolation</li></ul></div><div class="section" title="Advantages of using Scala for Java projects"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec08"/>Advantages of using Scala for Java projects</h1></div></div></div><p>The order of appearance and <a id="id0" class="indexterm"/>importance that we propose here only reflects our personal experience since every project and group of programmers usually have their own agenda when it comes to priorities.</p><div class="section" title="More concise and expressive"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec07"/>More concise and expressive</h2></div></div></div><p>The ultimate reason why you should adopt Scala is readability: code that is similar to plain English will make it easier for anyone (including yourself) to understand, maintain, and refactor it. Scala is unique in that it unifies the object-oriented side that Java has in order to make code modular with the power of functional languages to express transformations concisely. To illustrate how to achieve conciseness by the introduction of anonymous functions (also called <span class="strong"><strong>lambdas</strong></span>) <a id="id1" class="indexterm"/>into the language, take a look at the following line of code:</p><div class="informalexample"><pre class="programlisting">List(1,2,3,4,5) filter (element =&gt; element &lt; 4)</pre></div><p>As a Java programmer, the line might look awkward at first since it does not follow the usual pattern of invoking method signatures on classes. A possible Java translation of the previous code could be as follows:</p><div class="informalexample"><pre class="programlisting">import java.util.*;

public class ListFilteringSample {

  public static void main(String[] args) {

    List&lt;Integer&gt; elements = Arrays.asList(1, 2, 3, 4, 5);

    List&lt;Integer&gt; filteredElements = new ArrayList&lt;Integer&gt;();

    for (Integer element : elements)
      if (element &lt; 4) filteredElements.add(element);

    System.out.println("filteredElements:" + filteredElements);

  }
}</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip02"/>Tip</h3><p>
<span class="strong"><strong>Downloading the example code</strong></span>
</p><p>You can download the example code files for all books by Packt Publishing that you have purchased from your account at <a class="ulink" href="http://www.packtpub.com">http://www.packtpub.com</a>. If you purchased this book elsewhere, you can visit <a class="ulink" href="http://www.packtpub.com/support">http://www.packtpub.com/support</a> and register to have the files e-mailed directly to you.</p></div></div><p>We first create a <code class="literal">List</code> with five integers, then create an empty <code class="literal">List</code> that will hold the result of the filtering and then loop over the elements of the <code class="literal">List</code> to retain only the ones that match the <code class="literal">if</code> predicate (<code class="literal">element &lt; 4</code>) and finally print out the result. Even if this is straightforward to write, it requires a few lines of code, whereas the Scala line could just be read like the following:</p><p>"From the given <code class="literal">List</code>, filter each <a id="id2" class="indexterm"/>element such that this element is lower than <code class="literal">4</code>". </p><p>The fact that the code becomes really concise but expressive makes it easier for the programmer to comprehend at once a difficult or lengthy algorithm.</p></div><div class="section" title="Increased productivity"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec08"/>Increased productivity</h2></div></div></div><p>Having a compiler that performs a lot of type checking and works as a personal assistant, is in our opinion, a significant advantage over languages that check types dynamically at runtime, and the fact that Java is a statically-typed language is probably one of the main reasons that made it so popular in the first place. The Scala compiler belongs to this category as well and goes even further by <a id="id3" class="indexterm"/>finding out many of the types automatically, often relieving the programmer from specifying these types explicitly in the code. Moreover, the compiler in your IDE gives instant feedback, and therefore, increases your productivity.</p></div><div class="section" title="Natural evolution from Java"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec09"/>Natural evolution from Java</h2></div></div></div><p>Scala integrates seamlessly with Java, which is a very attractive feature, to avoid reinventing the wheel. You can start running Scala today in a production environment. Large corporations such as Twitter, LinkedIn, or Foursquare (to name a few) have done that on large-scale deployments for many years now, followed recently by other big players such as Intel or Amazon. Scala compiles to Java bytecode, which means that performance will be comparable. Most of the code that you are running while executing Scala programs is probably Java code, the major difference being what programmers see and the advanced type checking while compiling code.</p></div><div class="section" title="Better fit for asynchronous and concurrent code"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec10"/>Better fit for asynchronous and concurrent code</h2></div></div></div><p>To achieve better performance and handle more load, modern Java frameworks and libraries for web development are now tackling difficult problems that are tied to multi-core architectures and the integration with unpredictable external systems. Scala's incentive to use immutable data structures and functional programming constructs as well as its support for parallel collections has a better chance to succeed in writing concurrent code that will behave correctly. Moreover, Scala's superior type system and macro support enable DSLs for trivially safe asynchronous constructs, for example, composable futures and asynchronous language extensions.</p><p>In summary, Scala is the only language that has it all. It is statically typed, runs on the JVM and is totally Java compatible, is both object-oriented and functional, and is not verbose, thereby leading to better productivity, less maintenance, and therefore more fun.</p><p>If you are now getting impatient to start experimenting with the promising features of Scala that were briefly described previously, this is a good time to open a browser, access the Typesafe page <a id="id4" class="indexterm"/>URL at <a class="ulink" href="http://www.typesafe.com/platform/getstarted">http://www.typesafe.com/platform/getstarted</a>, and download the Typesafe Activator.</p><p>The intent of the rest of the chapter is to incrementally introduce some of the basic concepts of Scala by typing commands in an interactive shell and get direct feedback from the compiler. This method of learning by experimentation should feel like a breath of fresh air and has already proven to be a very effective way of learning the syntax and useful constructs of the language. While Scala continues to evolve at École Polytechnique Fédérale de Lausanne (EPFL), many large and small corporations are now taking advantage of the features of the Typesafe platform.</p><p>As stated on their website, the Typesafe Activator is "a local web and command-line tool that helps developers get started with the Typesafe platform". We will cover the Activator in more detail in a later chapter dedicated to programming tools, but for now, we will only take the shortest path in getting up and running and get familiar with some of the syntax of the language.</p><p>You should now be able to extract the downloaded zip archive to your system in a directory of your choice.</p><p>Locate the activator script within the extracted archive and either right-click on it and select <span class="strong"><strong>Open</strong></span> if you are running Windows <a id="id5" class="indexterm"/>or enter the following command in a terminal window if you are on Linux/Mac:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; ./activator ui </strong></span>
</pre></div><p>In both cases, this will start the Activator UI in a browser window.</p><p>In the <span class="strong"><strong>New application</strong></span> section of the HTML page of the Activator, click on the <code class="literal">[Basics] Hello-Scala!</code> template.</p><p>Notice the <span class="strong"><strong>Location</strong></span> field of the HTML <a id="id6" class="indexterm"/>form in the following screenshot. It indicates where your project will be created:</p><div class="mediaobject"><img src="graphics/3637OS_01_01.jpg" alt="Better fit for asynchronous and concurrent code"/></div><p>At present, you don't need to pay too much attention to all of the things that happen in the background nor to the generated structure of the project. Out of curiosity, you may click on the <span class="strong"><strong>Code view &amp; Open in IDE</strong></span> <a id="id7" class="indexterm"/>tab and then on the <span class="strong"><strong>Run</strong></span> tab to execute this Hello World Scala project, which should print, well, <span class="strong"><strong>"Hello, world !"</strong></span>.</p><p>Start a terminal window and navigate to the root directory of the <span class="emphasis"><em>hello-scala</em></span> project that we just created, by entering the following command on the command line (assuming our project is under <code class="literal">C:\Users\Thomas\hello-scala</code>):</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; cd C:\Users\Thomas\hello-scala</strong></span>
<span class="strong"><strong>C:\Users\Thomas\hello-scala&gt; activator console</strong></span>
</pre></div><p>This command will start the Scala <a id="id8" class="indexterm"/>interpreter, also known as <a id="id9" class="indexterm"/>Scala <span class="strong"><strong>REPL</strong></span> (<span class="strong"><strong>Read-Eval-Print-Loop</strong></span>), a <a id="id10" class="indexterm"/>simple command-line tool to program interactively.</p></div></div></div>
<div class="section" title="Learning Scala through the REPL"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec09"/>Learning Scala through the REPL</h1></div></div></div><p>As a Java developer, an REPL <a id="id11" class="indexterm"/>may be new to you since there is no such thing for the Java language. It used to refer to the Lisp language interactive environment, and today, equivalent tools are available for many programming languages such as <a id="id12" class="indexterm"/>JavaScript, Clojure, Ruby, and Scala. It consists of a command-line shell where you can enter one or more expressions rather than complete files and get immediate feedback by evaluating the result. The REPL is a fantastic tool that helps us to learn all the Scala syntax because it compiles and executes every statement that you write using the full power of the compiler. In such an interactive environment, you get instant feedback on every line of code you write.</p><p>If you are new to Scala, we recommend that you carefully follow this REPL session as it will give you a lot of useful knowledge for programming with Scala.</p><p>Let's dive into some of the most apparent differences between Java and Scala in order to get acquainted with the Scala syntax.</p><div class="section" title="Declaring val/var variables"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec11"/>Declaring val/var variables</h2></div></div></div><p>In Java, you would declare a <a id="id13" class="indexterm"/>new <a id="id14" class="indexterm"/>variable by putting in order its type, followed by the name, and then the optional value:</p><div class="informalexample"><pre class="programlisting">String yourPast = "Good Java Programmer";</pre></div><p>In Scala, the order of declaring the variable name and type is inverted, with the name appearing before its type. Let's enter the following line into the REPL:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; val yourPast : String = "Good Java Programmer"  [Hit Enter]</strong></span>
<span class="strong"><strong>yourPast : String = "Good Java Programmer"</strong></span>
</pre></div><p>Inverting the order of declaring the variables, type, and name as compared to Java might at first seem a strange idea if you want to make it as easy as possible for a Java developer to grab the Scala syntax. However, it makes sense for several reasons:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The Scala compiler, in this case, is able to deduct the type automatically. You could (and probably should, for conciseness) omit this type by entering the equivalent but shorter line of code instead:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; val yourPast = "Good Java Programmer"</strong></span>
<span class="strong"><strong>yourPast : String = "Good Java Programmer"</strong></span>
</pre></div><p>This is the most basic illustration of <a id="id15" class="indexterm"/>what is called <span class="strong"><strong>Type Inference</strong></span>, and you will see that the Scala compiler will try to deduct types whenever it can. If we had omitted this optional type but followed the Java syntax, the parsing done by the compiler would have been more difficult to implement.</p></li><li class="listitem" style="list-style-type: disc">In our opinion, it is more important to know a variable name than its type in order to understand the flow of a program (and therefore make it appear first); for instance, <a id="id16" class="indexterm"/>if you <a id="id17" class="indexterm"/>deal with a variable representing a <span class="strong"><strong>social security number</strong></span> (<span class="strong"><strong>ssn</strong></span>), we think the term ssn is more <a id="id18" class="indexterm"/>valuable than knowing if it is represented as a string or an integer or any other type.</li></ul></div><p>You probably noticed the <code class="literal">val</code> variable in front of the declaration; it means that we explicitly declare the variable as immutable. We can try to modify it as shown in the following code snippet:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; yourPast = "Great Scala Programmer"</strong></span>
<span class="strong"><strong>&lt;console&gt;:8: error: reassignment to val</strong></span>
<span class="strong"><strong>  yourPast = "Great Scala Programmer"</strong></span>
<span class="strong"><strong>           ^</strong></span>
</pre></div><p>The preceding code will not only give you a clear explanation of what was wrong but also the exact place where the parser did not agree (notice the <code class="literal">^</code> character precisely showing where the error lies in the line).</p><p>If we want to create a mutable variable instead, we should declare it with <code class="literal">var</code> as shown in the following code snippet:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; var yourFuture = "Good Java Programmer"</strong></span>
<span class="strong"><strong>yourFuture: String = "Good Java Programmer"</strong></span>
<span class="strong"><strong>scala&gt; yourFuture = "Great Scala Programmer"</strong></span>
<span class="strong"><strong>yourFuture: String = "Great Scala Programmer"</strong></span>
</pre></div><p>In summary, you cannot change <code class="literal">yourPast</code> but you can change <code class="literal">yourFuture</code>!</p><p>The semicolon at the end of the lines is optional in Scala; a small but pleasant feature of the language.</p><p>Let's move on to an important difference. In Java, you have primitive types such as <code class="literal">int</code>, <code class="literal">char</code>, or <code class="literal">boolean</code> (eight in total), as well as operators to manipulate data such as <code class="literal">+</code> or <code class="literal">&gt;</code>. In Scala, there are only classes and objects, making Scala more "object-oriented" than Java in some way. For instance, enter the following value into the REPL:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; 3</strong></span>
<span class="strong"><strong>res1: Int = 3</strong></span>
</pre></div><p>By default, the compiler created an immutable <code class="literal">Int</code> (integer) variable with the <code class="literal">res1</code> name (that is, result 1) in case you need to reuse it later on.</p><p>Now, enter the following line in REPL:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; 3 + 2</strong></span>
<span class="strong"><strong>res2: Int = 5</strong></span>
</pre></div><p>The preceding code resembles the usage of an operator (as in Java) but is in fact the invocation of a method named <code class="literal">+</code> called on object <code class="literal">3</code> with the input parameter <code class="literal">2</code>, equivalent to the slightly less clear statement:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; (3).+(2)</strong></span>
<span class="strong"><strong>res3: Int = 5</strong></span>
</pre></div><p>Syntactic sugar (that is, syntax <a id="id19" class="indexterm"/>designed to make things easier to read or express) was added here by removing the necessity to <a id="id20" class="indexterm"/>specify the parenthesis. This also means that we can now implement similar methods on our own defined types to express code elegantly. For example, we can express the addition of two <code class="literal">Money</code> objects of different currencies (note that the <code class="literal">Money</code> type does not exist in the default Scala library) by simply stating <code class="literal">Money(10,"EUR") + Money(15,"USD")</code>. Let's try to do that in the REPL.</p></div><div class="section" title="Defining classes"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec12"/>Defining classes</h2></div></div></div><p>First, we can <a id="id21" class="indexterm"/>define a new class <code class="literal">Money</code> that has a constructor parameter named <code class="literal">amount</code> of type <code class="literal">Int</code> as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; class Money(amount:Int)</strong></span>
<span class="strong"><strong>defined class Money</strong></span>
</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note02"/>Note</h3><p>Scala has a special syntax for declaring constructor parameters that will be explored in more depth later.</p></div></div><p>Now, we can create a <code class="literal">Money</code> instance as shown in the following code snippet:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; val notMuch = new Money(2)</strong></span>
<span class="strong"><strong>notMuch : Money = Money@76eb235</strong></span>
</pre></div><p>You get back an object with <a id="id22" class="indexterm"/>its displayed reference. The REPL provides you with <span class="strong"><strong>TAB completion</strong></span>, so type <code class="literal">notMuch.</code> and hit the <span class="emphasis"><em>Tab</em></span> key:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; notMuch. [Tab]</strong></span>
<span class="strong"><strong>asInstanceOf isInstanceOf toString</strong></span>
</pre></div><p>By using the preceding autocompletion, you will get suggestions of the available methods for that class, as you will get with most Java IDEs.</p><p>As shown previously, you can <a id="id23" class="indexterm"/>construct new instances of <code class="literal">Money</code> by invoking the constructor, but you do not have access to the <code class="literal">amount</code> variable since it is not a field. To make it a field of the <code class="literal">Money</code> class, you have to add a '<code class="literal">val</code>' or '<code class="literal">var</code>' declaration in front of it, as shown in the following code snippet:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; class Money(val amount:Int)</strong></span>
<span class="strong"><strong>defined class Money</strong></span>
</pre></div><p>This time, instead of again typing the line that created an instance, we will use the up arrow (the shortcut to display previous expressions: the history of the console) and navigate to it:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; val notMuch = new Money(2)</strong></span>
<span class="strong"><strong>notMuch : Money = Money@73cd15da</strong></span>
</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note03"/>Note</h3><p>The <span class="emphasis"><em>Tab</em></span> key can be pressed at any time in the REPL and provides autocompletion.</p></div></div><p>Invoking autocompletion on this new instance will display the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; notMuch. [Tab ]</strong></span>
<span class="strong"><strong>amount asInstanceOf isInstanceOf toString</strong></span>
</pre></div><p>So, we can simply read the value of the getter for this <code class="literal">amount</code> field by referring to it:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; notMuch.amount</strong></span>
<span class="strong"><strong>res4: Int = 2</strong></span>
</pre></div><p>Similarly, if we had declared the amount to be a <code class="literal">var</code> variable instead of <code class="literal">val</code>, we would also have access to <a id="id24" class="indexterm"/>the <code class="literal">setter</code> method:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; class Money(var amount:Int)</strong></span>
<span class="strong"><strong>defined class Money</strong></span>
<span class="strong"><strong>scala&gt; val notMuch = new Money(2)</strong></span>
<span class="strong"><strong>notMuch: Money = Money@6517ff0</strong></span>
<span class="strong"><strong>scala&gt; notMuch. [ Tab ]</strong></span>
<span class="strong"><strong>amount   amount_=   asInstanceOf   isInstanceOf   toString</strong></span>
</pre></div><p>The <code class="literal">setter</code> method is invoked when we use the following code snippet:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; notMuch.amount=3</strong></span>
<span class="strong"><strong>notMuch.amount: Int = 3</strong></span>
</pre></div></div><div class="section" title="Explaining case classes"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec13"/>Explaining case classes</h2></div></div></div><p>As Java developers, <a id="id25" class="indexterm"/>we are accustomed to the JavaBean style domain classes that not only include fields with getters and setters but also constructors as well as <code class="literal">hashCode</code>, <code class="literal">equals</code>, and <code class="literal">toString</code> methods, as shown in the following code snippet:</p><div class="informalexample"><pre class="programlisting">public class Money {

    private Integer amount;
    private String currency;

    public Money(Integer amount, String currency) {

        this.amount = amount;
        this.currency = currency;

    }

    public Integer getAmount() {
        return amount;
    }

    public void setAmount(Integer amount) {
        this.amount = amount;
    }

    public String getCurrency() {
        return currency;
    }
    public void setCurrency(String currency) {
        this.currency = currency;
    }

    @Override
    public int hashCode() {
        int hash = 5;
        hash = 29 * hash + (this.amount != null ? this.amount.hashCode() : 0);
        hash = 29 * hash + (this.currency != null ? this.currency.hashCode() : 0);
        return hash;
    }

    @Override
    public boolean equals(Object obj) {

        if (obj == null) {
            return false;
        }

        if (getClass() != obj.getClass()) {
            return false;
        }

        final Money other = (Money) obj;
        return true;
    }

    @Override
    public String toString() {
        return "Money{" + "amount=" + amount + ", currency=" + currency + '}';

    }
}</pre></div><p>Achieving this in Scala is very straightforward and only requires the addition of the <code class="literal">case</code> word in front of the class declaration:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; case class Money(amount:Int=1, currency:String="USD")</strong></span>
<span class="strong"><strong>defined class Money</strong></span>
</pre></div><p>We have just defined a class <code class="literal">Money</code> with two immutable fields named <code class="literal">amount</code> and <code class="literal">currency</code> with default values.</p><p>Without going too much into the details of the <code class="literal">case</code> classes, we can say that in addition to the preceding features of a traditional JavaBean style domain class, they have a powerful mechanism for pattern matching. <a id="id26" class="indexterm"/>The <code class="literal">case</code> word is analogous to the <code class="literal">switch</code> statement in Java, though it is more flexible, as we will see later on. The <code class="literal">case</code> classes contain additional features among which one is a factory method to create instances (no need to use the <code class="literal">new</code> keyword to create one).</p><p>By default, the fields declared in Scala classes are public, unlike Java, where they have a package-private scope, defined between private and protected. We could have written <code class="literal">case class Money(private val amount: Int, private val currency: String)</code> to make them private instead, or used <code class="literal">var</code> instead of <code class="literal">val</code> to make the fields mutable.</p><p>The shortest way to create an <a id="id27" class="indexterm"/>instance of <code class="literal">Money</code> is very straightforward:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; val defaultAmount = Money()</strong></span>
<span class="strong"><strong>defaultAmount: Money = Money(1,USD)</strong></span>
<span class="strong"><strong>scala&gt; val fifteenDollars = Money(15,"USD")</strong></span>
<span class="strong"><strong>fifteenDollars: Money = Money(15,USD)</strong></span>
<span class="strong"><strong>scala&gt; val fifteenDollars = Money(15)</strong></span>
<span class="strong"><strong>fifteenDollars: Money = Money(15,USD) </strong></span>
</pre></div><p>In the previous instance declaration, since only one parameter is given instead of two, the compiler matched it against the first declared field, that is, <code class="literal">amount</code>. Since the value <code class="literal">15</code> is of the same type as <code class="literal">amount</code> (that is, <code class="literal">Integer</code>), the compiler was able to populate the instance with this amount, using the default value <code class="literal">"USD"</code> as the currency.</p><p>Unlike the <code class="literal">amount</code> variable, invoking the <code class="literal">Money</code> constructor with the sole currency parameter will fail, as seen in the following statement:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; val someEuros = Money("EUR")</strong></span>
<span class="strong"><strong>&lt;console&gt;:9: error: type mismatch;</strong></span>
<span class="strong"><strong> found   : String("EUR")</strong></span>
<span class="strong"><strong> required: Int</strong></span>
<span class="strong"><strong>       val someEuros = Money("EUR")</strong></span>
<span class="strong"><strong>                             ^</strong></span>
</pre></div><p>The preceding code does not work because the compiler could not guess which parameter we were referring to, and therefore tried to match them in order of declaration. To be able to use the default value for <code class="literal">amount</code> with the given <code class="literal">"EUR"</code> string, we need to include the parameter name explicitly, as shown in the following code snippet:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; val someEuros = Money(currency="EUR")</strong></span>
<span class="strong"><strong>someEuros: Money = Money(1,EUR)</strong></span>
</pre></div><p>We could therefore also mark all parameters explicitly, which can be recommended when there are many parameters as shown in the following code snippet:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; val twentyEuros = Money(amount=20,currency="EUR")</strong></span>
<span class="strong"><strong>twentyEuros: Money = Money(20,EUR)</strong></span>
</pre></div><p>An additional useful method when constructing instances is the <code class="literal">copy</code> method, which creates a new instance out of the original and eventually  replaces given parameters:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; val tenEuros = twentyEuros.copy(10)</strong></span>
<span class="strong"><strong>tenEuros: Money = Money(10,EUR)</strong></span>
</pre></div><p>We can use the <code class="literal">copy</code> method with <a id="id28" class="indexterm"/>explicitly named parameters, as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; val twentyDollars = twentyEuros.copy(currency="USD")</strong></span>
<span class="strong"><strong>twentyDollars: Money = Money(20,USD)</strong></span>
</pre></div><p>The <code class="literal">copy</code> method can be very useful when writing test fixtures, in particular, when the mockup instances to be initialized have constructors with many fields that are similar.</p><p>Let's move on by creating an <code class="literal">addition</code> operation of our <code class="literal">Money</code> class. For simplicity, we will pretend for a moment that we only deal with amounts of the same currency, the default USD.</p><p>In Java, we would probably add such a <a id="id29" class="indexterm"/>method with the following signature and simple content:</p><div class="informalexample"><pre class="programlisting">public class Money {

    Integer amount;
    String currency;

    public Money(Integer amount, String currency) {
        this.amount = amount;
        this.currency = currency;
    }

    public Money add(Money other) {
        return new Money(this.amount +
        other.amount, this.currency);
    }
    ...
}</pre></div><p>In Scala, we use the <code class="literal">def</code> keyword to define a class method or a function. In the REPL, we can have multiline expressions. The following <code class="literal">case</code> class declaration, containing the implementation of a summing method <code class="literal">+</code> is an example of such features:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; case class Money(val amount:Int=1, val currency:String="USD"){</strong></span>
<span class="strong"><strong>     |   def +(other: Money) : Money = Money(amount + other.amount)</strong></span>
<span class="strong"><strong>     | }</strong></span>
<span class="strong"><strong>defined class Money</strong></span>
</pre></div><p>Notice that we can use <code class="literal">+</code> as a method name. We have also included the return type <code class="literal">Money</code> in the signature declaration, which is only optional since the type inference of Scala will deduct it, but including it explicitly is a good documentation practice for public methods (and methods are public by default if no other scope is specified). Moreover, in Scala, since the <code class="literal">return</code> word at the end of the method is optional, the last statement is always the one that is returned to the caller of the method. Furthermore, it is generally considered a good practice to omit the <code class="literal">return</code> keyword since it is not mandatory.</p><p>We can now write the addition of two <code class="literal">Money</code> instances with the following simple expression:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; Money(12) + Money(34)</strong></span>
<span class="strong"><strong>res5: Money = Money(46,USD)</strong></span>
</pre></div><p>Things start becoming exciting once we start manipulating collections of objects, and the functional programming part of Scala helps very much for that matter. Since generics are part of the language (Java 5 onwards), <a id="id30" class="indexterm"/>Java can, for example, iterate over a list of integers by writing the following code snippet:</p><div class="informalexample"><pre class="programlisting">List&lt;Integer&gt; numbers = new ArrayList&lt;Integer&gt;();
numbers.add(1);
numbers.add(2);
numbers.add(5);
for(Integer n: numbers) {
    System.out.println("Number "+n);
}</pre></div><p>The preceding code produces the following output:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Number 1</strong></span>
<span class="strong"><strong>Number 2</strong></span>
<span class="strong"><strong>Number 5</strong></span>
</pre></div><p>In Scala, the declaration of a list can be written as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; val numbers = List(1,2,5)</strong></span>
<span class="strong"><strong>numbers: List[Int] = List(1,2,5)</strong></span>
</pre></div><p>Scala collections systematically distinguish between immutable and mutable collections, but encourage immutability by constructing immutable collections by default. They simulate additions, updates, or removals by returning new collections from such operations instead of modifying them.</p><p>One way to print out the numbers is that we can follow Java's imperative style of programming and iterate over the collection by creating a <code class="literal">for</code> loop:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; for (n &lt;- numbers) println("Number "+n)</strong></span>
<span class="strong"><strong>Number 1</strong></span>
<span class="strong"><strong>Number 2</strong></span>
<span class="strong"><strong>Number 5</strong></span>
</pre></div><p>Another way to write the code in Scala (as well as many other languages on the JVM, such as Groovy, JRuby, or Jython) involves a more functional style, using lambda expressions (sometimes referred to as closures). In brief, lambdas are just functions that you can pass around as parameters. <a id="id31" class="indexterm"/>These functions take input parameters (in our case, the <code class="literal">n</code> integer) and return the last statement/line of their body. They are in the following form:</p><div class="informalexample"><pre class="programlisting">functionName { input =&gt;
                body
             }</pre></div><p>A typical example of lambda to iterate over the elements of the <code class="literal">numbers</code> list we have defined earlier, is given as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; numbers.foreach { n:Int =&gt;     </strong></span>
<span class="strong"><strong>   | println("Number "+n)</strong></span>
<span class="strong"><strong>   | }</strong></span>
<span class="strong"><strong>Number 1</strong></span>
<span class="strong"><strong>Number 2</strong></span>
<span class="strong"><strong>Number 5</strong></span>
</pre></div><p>In that case, the body consists of only one statement (<code class="literal">println...</code>), and therefore returns <code class="literal">Unit</code>, that is, an empty result roughly equivalent to <code class="literal">void</code> in Java, except that <code class="literal">void</code> does not return anything.</p><p>As the time of writing this book, lambda expressions in Java are around the corner and will be introduced very soon as part of the JDK8 release, adopting a Scala-like style. Some of the functional constructs will therefore soon be available to Java developers.</p><p>It should become possible to write our tiny example in the following way:</p><div class="informalexample"><pre class="programlisting">numbers.forEach(n -&gt; { System.out.println("Numbers "+n);});</pre></div><p>As we stated previously, Scala collections are, by default, immutable. This is a very important aspect for making them <a id="id32" class="indexterm"/>behave as expected when dealing with multiprocessor architectures. One unique feature of the Scala collections compared to Java is that they include support for running operations in parallel.</p></div></div>
<div class="section" title="Operations on collections"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec10"/>Operations on collections</h1></div></div></div><p>In this section, we are going to <a id="id33" class="indexterm"/>illustrate how the manipulation of collections in Scala can be expressed in a concise and expressive way.</p><div class="section" title="Transforming collections containing primitive types"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec14"/>Transforming collections containing primitive types</h2></div></div></div><p>The REPL is a <a id="id34" class="indexterm"/>great tool to try out the powerful operations that we can apply to the collection elements. Let's go back to our interpreter prompt:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; val numbers = List(1,2,3,4,5,6)</strong></span>
<span class="strong"><strong>numbers: List[Int] = List(1,2,3,4,5,6)</strong></span>
<span class="strong"><strong>scala&gt; val reversedList = numbers.reverse</strong></span>
<span class="strong"><strong>reversedList: List[Int] = List(6,5,4,3,2,1)</strong></span>
<span class="strong"><strong>scala&gt; val onlyAFew = numbers drop 2 take 3</strong></span>
<span class="strong"><strong>onlyAFew: List[Int] = List(3, 4, 5)</strong></span>
</pre></div><p>The <code class="literal">drop</code> method indicates <a id="id35" class="indexterm"/>that we get rid of the first two elements of the list, and the <code class="literal">take</code> method indicates that we keep only three elements from the result obtained after the <code class="literal">drop</code> method.</p><p>This last command is interesting for two reasons:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Since every method call is evaluated to an expression, we can chain several method calls at once (here, <code class="literal">take</code> is invoked on the result of <code class="literal">drop</code>)</li><li class="listitem" style="list-style-type: disc">As already stated before, the syntactic sugar added to the Scala syntax makes it equivalent to write <code class="literal">numbers drop 2</code> instead of the more traditional Java <code class="literal">numbers.drop(2)</code></li></ul></div><p>Another way of writing elements in a given list is by using the <code class="literal">::</code> method, generally referred to in Scala documentation as the "cons operator". This alternative syntax looks like the following expression:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; val numbers = 1 :: 2 :: 3 :: 4 :: 5 :: 6 :: Nil</strong></span>
<span class="strong"><strong>numbers: List[Int] = List(1, 2, 3, 4, 5, 6)</strong></span>
</pre></div><p>If you are wondering why there is a <code class="literal">Nil</code> value at the end of this expression, this is because there is a simple rule in Scala that says that a method whose last character is <code class="literal">:</code> (that is, a colon) is applied on <a id="id36" class="indexterm"/>its right side rather than the left side (such a method is called as right-associative). So, the evaluation of <code class="literal">6 :: Nil</code> is not equivalent to <code class="literal">6.::(Nil)</code> in that case, but rather <code class="literal">Nil.::(6)</code>. We can exhibit that into the REPL as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; val simpleList = Nil.::(6)</strong></span>
<span class="strong"><strong>simpleList: List[Int] = List(6)</strong></span>
</pre></div><p>The evaluation of <code class="literal">5 :: 6 :: Nil</code> is therefore done by applying the <code class="literal">::</code> method on the <code class="literal">simpleList</code> that we saw earlier, which is <code class="literal">List(6)</code>:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; val twoElementsList = List(6).::(5)</strong></span>
<span class="strong"><strong>twoElementsList: List[Int] = List(5, 6)</strong></span>
</pre></div><p>In this case, <code class="literal">5</code> was appended before <code class="literal">6</code>. Repeating this operation several times will give you the final <code class="literal">List(1,2,3,4,5,6)</code>.</p><p>This convenient way of expressing lists is not just for simple values such as integers but can be applied to any type. Moreover, we can concatenate two <code class="literal">List</code> instances by using the <code class="literal">:::</code> method in a similar way:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; val concatenatedList = simpleList ::: twoElementsList</strong></span>
<span class="strong"><strong>concatenatedList: List[Int] = List(6, 5, 6)</strong></span>
</pre></div><p>We can even mix elements of various types in the same <code class="literal">List</code>, for example, integers and Booleans, as shown in the following code snippet:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; val things = List(0,1,true)</strong></span>
<span class="strong"><strong>things: List[AnyVal] = List(0, 1, true) </strong></span>
</pre></div><p>However, as you probably noticed, the result type <code class="literal">AnyVal</code> chosen by the compiler in that case is the first common type between integers and Booleans encountered in their hierarchy. For instance, retrieving only the Boolean element (at index two in the list) will return an element of type <code class="literal">AnyVal</code> rather than a <code class="literal">Boolean</code> value:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; things(2)</strong></span>
<span class="strong"><strong>res6: AnyVal = true</strong></span>
</pre></div><p>Now, if we put an element of type <code class="literal">String</code> within the list as well, we will get a different common type:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; val things = List(0,1,true,"false")</strong></span>
<span class="strong"><strong>things: List[Any] = List(0, 1, true, false)</strong></span>
</pre></div><p>The reason for that can be directly visualized by looking at the hierarchy of Scala types. Classes representing primitive <a id="id37" class="indexterm"/>types such as <code class="literal">Int</code>, <code class="literal">Byte</code>, <code class="literal">Boolean</code>, or <code class="literal">Char</code> belong to value types of <code class="literal">scala.AnyVal,</code> whereas <code class="literal">String</code>, <code class="literal">Vector</code>, <code class="literal">List</code>, or <code class="literal">Set</code> belong to reference types of <code class="literal">scala.AnyRef</code>, both being subclasses of the common type <code class="literal">Any</code>, as shown in the following diagram:</p><div class="mediaobject"><img src="graphics/3637_01_02.jpg" alt="Transforming collections containing primitive types"/></div><p>The full hierarchy of Scala types is given in the official Scala documentation at <a class="ulink" href="http://docs.scala-lang.org/tutorials/tour/unified-types.html">http://docs.scala-lang.org/tutorials/tour/unified-types.html</a>.</p></div><div class="section" title="Collections of more complex objects"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec15"/>Collections of more complex objects</h2></div></div></div><p>Let's manipulate objects that are <a id="id38" class="indexterm"/>more complex than integers. We can, for <a id="id39" class="indexterm"/>instance, create some collections of <code class="literal">Money</code> instances that we made earlier and experiment with them:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; val amounts = List(Money(10,"USD"),Money(2,"EUR"),Money(20,"GBP"),Money(75,"EUR"),Money(100,"USD"),Money(50,"USD"))</strong></span>
<span class="strong"><strong>amounts: List[Money] = List(Money(10,USD), Money(2,EUR), Money(20,GBP), Money(75,EUR), Money(100,USD), Money(50,USD))</strong></span>
<span class="strong"><strong>scala&gt; val first = amounts.head</strong></span>
<span class="strong"><strong>first: Money = Money(10,USD)</strong></span>
<span class="strong"><strong>scala&gt; val amountsWithoutFirst = amounts.tail</strong></span>
<span class="strong"><strong>amountsWithoutFirst: List[Money] = List(Money(2,EUR), Money(20,GBP), Money(75,EUR), Money(100,USD), Money(50,USD))</strong></span>
</pre></div><div class="section" title="Filter and partition"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec01"/>Filter and partition</h3></div></div></div><p>Filtering elements of a <a id="id40" class="indexterm"/>collection is one of the most common operations and can be written as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; val euros = amounts.filter(money =&gt; money.currency=="EUR")</strong></span>
<span class="strong"><strong>euros: List[Money] = List(Money(2,EUR), Money(75,EUR))</strong></span>
</pre></div><p>The parameter given to the <code class="literal">filter</code> method is a function that takes a <code class="literal">Money</code> item as the input and returns a <code class="literal">Boolean</code> value (that is, a predicate), which is the result of evaluating <code class="literal">money.currency=="EUR"</code>.</p><p>The <code class="literal">filter</code> method <a id="id41" class="indexterm"/>iterates over the collection items and applies the function to each element, keeping only the elements for which the function returns <code class="literal">True</code>. Lambda expressions are also referred to as <a id="id42" class="indexterm"/>
<span class="strong"><strong>anonymous functions</strong></span> because we could give any name we want to the input argument, for example, <code class="literal">x</code> instead of the <code class="literal">money</code> used previously, and still get the same output:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; val euros = amounts.filter(x =&gt; x.currency=="EUR")</strong></span>
<span class="strong"><strong>euros: List[Money] = List(Money(2,EUR),Money(75,EUR))</strong></span>
</pre></div><p>A slightly shorter way of writing this one-liner can be done using an <code class="literal">_</code> sign, a character that one encounters often when reading Scala code and that might seem awkward for a Java developer at first sight. It simply means "that thing", or "the current element". It can be thought of as the blank space or gap used to fill paper-based inquiries or passport registration forms, in the olden days. Other languages that deal with anonymous functions reserve other keywords, such as <code class="literal">it</code> in Groovy, or <code class="literal">self</code> in Python. The previous lambda example can be rewritten with the short underscore notation as the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; val euros = amounts.filter(_.currency=="EUR")</strong></span>
<span class="strong"><strong>euros: List[Money] = List(Money(2,EUR),Money(75,EUR))</strong></span>
</pre></div><p>A <code class="literal">filterNot</code> method also exists to <a id="id43" class="indexterm"/>keep elements for which the evaluation of the function returns <code class="literal">False</code>. Moreover, a <code class="literal">partition</code> method is available to combine both the <code class="literal">filter</code> and <code class="literal">filterNot</code> methods into one single call that returns two collections, one evaluating to <code class="literal">True</code> and the other <a id="id44" class="indexterm"/>to its complement, as shown in the following code snippet:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; val allAmounts = amounts.partition(amt =&gt;</strong></span>
<span class="strong"><strong>     |   amt.currency=="EUR")</strong></span>
<span class="strong"><strong>allAmounts: (List[Money], List[Money]) = (List(Money(2,EUR), Money(75,EUR)),List(Money(10,USD), Money(20,GBP), Money(100,USD), Money(50,USD)))</strong></span>
</pre></div></div><div class="section" title="Dealing with tuples"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec02"/>Dealing with tuples</h3></div></div></div><p>Notice the return type of the <a id="id45" class="indexterm"/>partition result, <code class="literal">(List[Money],List[Money])</code>. Scala supports the concept of tuples. The preceding parenthesis notation denotes a <code class="literal">Tuple</code> <a id="id46" class="indexterm"/>type, which is a part of the standard Scala library and useful to manipulate several elements at once without having to create a more complex type for encapsulating them. In our case, <code class="literal">allAmounts</code> is a <code class="literal">Tuple2</code> pair containing two lists of <code class="literal">Money</code>. To access only one of the two collections, we just need to type the following expressions:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; val euros = allAmounts._1</strong></span>
<span class="strong"><strong>euros: List[Money] = List(Money(2,EUR),Money(75,EUR))</strong></span>
<span class="strong"><strong>scala&gt; val everythingButEuros= allAmounts._2</strong></span>
<span class="strong"><strong>everythingButEuros: List[Money] = List(Money(10,USD),Money(20,GBP),Money(100,USD),Money(50,USD))</strong></span>
</pre></div><p>A cleaner and more natural syntax to achieve this as a one-liner, is the one that expresses the <code class="literal">partition</code> method without referring to <code class="literal">._1</code> and <code class="literal">._2</code>, as shown in the following code snippet:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; val (euros,everythingButEuros) = amounts.partition(amt =&gt;</strong></span>
<span class="strong"><strong>     |   amt.currency=="EUR")</strong></span>
<span class="strong"><strong>euros: List[Money] = List(Money(2,EUR), Money(75,EUR))</strong></span>
<span class="strong"><strong>everythingButEuros: List[Money] = List(Money(10,USD), Money(20,GBP), Money(100,USD), Money(50,USD))</strong></span>
</pre></div><p>This time, as a result, we get two variables, <code class="literal">euros</code> and <code class="literal">everythingButEuros</code>, which we can reuse individually:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; euros</strong></span>
<span class="strong"><strong>res2: List[Money] = List(Money(2,EUR), Money(75,EUR))</strong></span>
</pre></div></div><div class="section" title="Introducing Map"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec03"/>Introducing Map</h3></div></div></div><p>Another elegant usage of tuples is <a id="id47" class="indexterm"/>related to the definition of a <code class="literal">Map</code> collection, another structure that is part of the Scala collections. Similar to Java, the <code class="literal">Map</code> collection <a id="id48" class="indexterm"/>stores key-value pairs. In Java, a trivial <code class="literal">HashMap</code> definition that populates and retrieves elements of a <code class="literal">Map</code> collection with a couple of values can be written with a few lines of code:</p><div class="informalexample"><pre class="programlisting">import java.util.HashMap;
import java.util.Map;

public class MapSample {
    public static void main(String[] args) {
        Map amounts = new HashMap&lt;String,Integer&gt;();
        amounts.put("USD", 10);
        amounts.put("EUR", 2);

        Integer euros = (Integer)amounts.get("EUR");
        Integer pounds = (Integer)amounts.get("GBP");

        System.out.println("Euros: "+euros);
        System.out.println("Pounds: "+pounds);
    }
}</pre></div><p>Since no amount of GBP currency has been inserted into the <code class="literal">Map</code> collection, running this sample will return a <code class="literal">null</code> value for the <code class="literal">Pounds</code> variable:</p><div class="informalexample"><pre class="programlisting">Euros: 2
Pounds: null</pre></div><p>Populating a <code class="literal">Map</code> collection in Scala can be elegantly written as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; val wallet = Map( "USD" -&gt; 10, "EUR" -&gt; 2 )</strong></span>
<span class="strong"><strong>wallet: scala.collection.immutable.Map[String,Int] = Map(USD -&gt; 10, EUR -&gt; 2)</strong></span>
</pre></div><p>The <code class="literal">"USD" -&gt; 10</code> expression is a <a id="id49" class="indexterm"/>convenient way of specifying a key-value pair and is equivalent to the definition of a <code class="literal">Tuple2[String,Integer]</code> object in this case, as illustrated directly in the REPL (which could infer the type automatically):</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; val tenDollars = "USD"-&gt; 10</strong></span>
<span class="strong"><strong>tenDollars : (String, Int) = (USD,10)</strong></span>
<span class="strong"><strong>scala&gt; val tenDollars = ("USD",10)</strong></span>
<span class="strong"><strong>tenDollars : (String, Int) = (USD,10)</strong></span>
</pre></div><p>The process of adding and retrieving an element is very straightforward:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; val updatedWallet = wallet + ("GBP" -&gt; 20)</strong></span>
<span class="strong"><strong>wallet: scala.collection.immutable.Map[String,Int] = Map(USD -&gt; 10, EUR -&gt; 2, GBP -&gt; 20)</strong></span>
<span class="strong"><strong>scala&gt; val someEuros = wallet("EUR")</strong></span>
<span class="strong"><strong>someEuros: Int = 2</strong></span>
</pre></div><p>However, accessing an element <a id="id50" class="indexterm"/>that is not included in the <code class="literal">Map</code> collection will throw <a id="id51" class="indexterm"/>an exception, as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; val somePounds = wallet("GBP")</strong></span>
<span class="strong"><strong>java.util.NoSuchElementException: key not found: GBP  (followed by a full stacktrace)</strong></span>
</pre></div></div><div class="section" title="Introducing the Option construct"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec04"/>Introducing the Option construct</h3></div></div></div><p>A safer way to retrieve an element <a id="id52" class="indexterm"/>from the <code class="literal">Map</code> collection that was <a id="id53" class="indexterm"/>introduced in the previous section is to invoke its <code class="literal">.get()</code> method, which will instead return an object of type <code class="literal">Option</code>, a feature that is not currently available in Java. Basically, an <code class="literal">Option</code> type wraps a value into an object that can either return the type <code class="literal">None</code> if the value is null, or <code class="literal">Some(value)</code> otherwise. Let's enter this in the REPL:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; val mayBeSomeEuros = wallet.get("EUR")</strong></span>
<span class="strong"><strong>mayBeSomeEuros: Option[Int] = Some(2)</strong></span>
<span class="strong"><strong>scala&gt; val mayBeSomePounds = wallet.get("GBP")</strong></span>
<span class="strong"><strong>mayBeSomePounds: Option[Int] = None</strong></span>
</pre></div></div><div class="section" title="A glimpse at pattern matching"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec05"/>A glimpse at pattern matching</h3></div></div></div><p>Avoiding the <a id="id54" class="indexterm"/>throwing of an exception makes it convenient to continue <a id="id55" class="indexterm"/>handling the flow of an algorithm as an evaluated expression. It not only gives the programmer the freedom of sophisticated chaining of the <code class="literal">Option</code> values without having to check for the existence of a value, but also enables one to handle the two different cases via <span class="strong"><strong>pattern matching</strong></span>:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; val status = mayBeSomeEuros match {</strong></span>
<span class="strong"><strong>     |   case None =&gt; "Nothing of that currency"</strong></span>
<span class="strong"><strong>     |   case Some(value) =&gt; "I have "+value+" Euros"</strong></span>
<span class="strong"><strong>     | }</strong></span>
<span class="strong"><strong>status: String = I have 2 Euros</strong></span>
</pre></div><p>Pattern matching is an essential and powerful feature of the Scala language. We will look at more examples of it later on.</p><p>The <code class="literal">filter</code> and <code class="literal">partition</code> methods <a id="id56" class="indexterm"/>were <a id="id57" class="indexterm"/>just two examples of the so-called "higher-order" functions on lists, since they <a id="id58" class="indexterm"/>operate on containers of collection <a id="id59" class="indexterm"/>types (such as lists, sets, and so on) rather than the types themselves.</p></div><div class="section" title="The map method"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec06"/>The map method</h3></div></div></div><p>Among the collections' methods <a id="id60" class="indexterm"/>that cannot be overlooked lies the <code class="literal">map</code> method (not to be confused with the <code class="literal">Map</code> object). Basically, it applies a function to every element of a collection, but instead of returning <code class="literal">Unit</code> for the <code class="literal">foreach</code> method, it <a id="id61" class="indexterm"/>returns a collection of a similar container type (for example, a <code class="literal">List</code> will return a <code class="literal">List</code> of the same size) that contains the result of transforming each element through the function. A very simple example is shown in the following code snippet:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; List(1,2,3,4).map(x =&gt; x+1)</strong></span>
<span class="strong"><strong>res6: List[Int] = List(2,3,4,5)</strong></span>
</pre></div><p>In Scala, you may define standalone functions as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; def increment = (x:Int) =&gt; x + 1</strong></span>
<span class="strong"><strong>increment: Int =&gt; Int</strong></span>
</pre></div><p>We have declared an <code class="literal">increment</code> function that takes an <code class="literal">Int</code> value as the input (denoted by <code class="literal">x</code>) and returns another <code class="literal">Int</code> value (<code class="literal">x+1</code>).</p><p>The previous <code class="literal">List</code> transformation can be rewritten slightly in a different manner as shown in the following code snippet:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; List(1,2,3,4).map(increment)</strong></span>
<span class="strong"><strong>res7: List[Int] = List(2,3,4,5)</strong></span>
</pre></div><p>Using a bit of syntactic sugar, the <code class="literal">.</code> sign in the method call, as well as the parenthesis on the function parameter can be omitted for readability, which leads to the following concise one-liner:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; List(1,2,3,4) map increment</strong></span>
<span class="strong"><strong>res8: List[Int] = List(2, 3, 4, 5)</strong></span>
</pre></div><p>Going back to our initial list of the <code class="literal">Money</code> amounts, we can, for example, transform them into strings as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; val printedAmounts =</strong></span>
<span class="strong"><strong>     |   amounts map(m=&gt; ""+  m.amount + " " + m.currency)</strong></span>
<span class="strong"><strong>printedAmounts: List[String] = List(10 USD, 2 EUR, 20 GBP, 75 EUR, 100 USD, 50 USD)</strong></span>
</pre></div></div><div class="section" title="Looking at String Interpolation"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec07"/>Looking at String Interpolation</h3></div></div></div><p>In Java, concatenating strings using a <code class="literal">+</code> operator, as we did in the previous line, is a very common operation. In <a id="id62" class="indexterm"/>Scala, a more elegant and efficient way to deal with the presentation of strings is a feature named <span class="strong"><strong>String Interpolation</strong></span>. Available <a id="id63" class="indexterm"/>since Scala Version 2.10, the new syntax involves prepending a <code class="literal">s</code> character to the string literal as shown in the following code snippet:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; val many = 10000.2345</strong></span>
<span class="strong"><strong>many: Double = 10000.2345</strong></span>
<span class="strong"><strong>scala&gt; val amount = s"$many euros"</strong></span>
<span class="strong"><strong>amount: String = 10000.2345 euros </strong></span>
</pre></div><p>Any variable in scope can be processed and embedded in a string. Formatting can even be more precise by using an <code class="literal">f</code> interpolator instead of <code class="literal">s</code>. In that case, the syntax follows the same style as that of the <code class="literal">printf</code> method of other languages, where, for instance, <code class="literal">%4d</code> means a four-digit formatting or <code class="literal">%12.2f</code> means a floating point notation with exactly twelve digits before the comma and two afterwards:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; val amount = f"$many%12.2f euros"</strong></span>
<span class="strong"><strong>amount: String = "    10000.23 euros"</strong></span>
</pre></div><p>Moreover, the String Interpolation syntax enables us to embed the full evaluation of an expression, that is, a full block of code performing a calculation. The following is an example, where we want to display the value of our <code class="literal">many</code> variable twice:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; val amount = s"${many*2} euros"</strong></span>
<span class="strong"><strong>amount: String = 20000.469 euros</strong></span>
</pre></div><p>The preceding block of code obeys the same rules as any method or function evaluation, meaning that the last statement in the block is the result. Although here we have a very simple computation, it is perfectly valid to include a multiline algorithm if needed.</p><p>Knowing the interpolation syntax, we can rewrite our previous <code class="literal">amounts</code> as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; val printedAmounts =</strong></span>
<span class="strong"><strong>     |   amounts map(m=&gt; s"${m.amount} ${m.currency}")</strong></span>
<span class="strong"><strong>printedAmounts: List[String] = List(10 USD, 2 EUR, 20 GBP, 75 EUR, 100 USD, 50 USD)</strong></span>
</pre></div></div><div class="section" title="The groupBy method"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec08"/>The groupBy method</h3></div></div></div><p>Another convenient operation <a id="id64" class="indexterm"/>is the <code class="literal">groupBy</code> method that <a id="id65" class="indexterm"/>transforms a collection into a <code class="literal">Map</code> collection:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; val sortedAmounts = amounts groupBy(_.currency)</strong></span>
<span class="strong"><strong>sortedAmounts: scala.collection.immutable.Map[String,List[Money]] = Map(EUR -&gt; List(Money(2,EUR), Money(75,EUR)), GBP -&gt; List(Money(20,GBP)), USD -&gt; List(Money(10,USD), Money(100,USD), Money(50,USD)))</strong></span>
</pre></div></div><div class="section" title="The foldLeft method"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec09"/>The foldLeft method</h3></div></div></div><p>One last method that we <a id="id66" class="indexterm"/>would like to introduce here is the <code class="literal">foldLeft</code> method, which propagates some state from one element to the next. For instance, <a id="id67" class="indexterm"/>to sum elements in a list, you need to accumulate them and keep track of the intermediate counter from one element to the next:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; val sumOfNumbers = numbers.foldLeft(0) { (total,element) =&gt;</strong></span>
<span class="strong"><strong>     |   total + element</strong></span>
<span class="strong"><strong>     | }</strong></span>
<span class="strong"><strong>sumOfNumbers: Int = 21</strong></span>
</pre></div><p>The value <code class="literal">0</code> given as the first argument to <code class="literal">foldLeft</code> is the initial value (which means <code class="literal">total=0</code> when applying the function for the first <code class="literal">List</code> element). The <code class="literal">(total,element)</code> notation represents a <code class="literal">Tuple2</code> pair. Note, however, that for summation, the Scala API provides a <code class="literal">sum</code> method, so the last statement could have been written as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; val sumOfNumbers = numbers.sum</strong></span>
<span class="strong"><strong>sumOfNumbers: Int = 21</strong></span>
</pre></div></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec11"/>Summary</h1></div></div></div><p>This interactive chapter that introduced some of the commonly used operations on objects and collections was only a glimpse to demonstrate some of the expressiveness and powerful constructs of Scala.</p><p>In the next chapter, we are going to increasingly blend Scala with an existing standard Java web application. Since there are so many ways by which one can create a standard web application, combining some of the many frameworks and database technologies available, irrespective of whether they involve Spring, Hibernate, JPA, SQL, or NoSQL, we will take the straightforward path of some of the well-established JavaEE tutorials.</p></div></body></html>