- en: Java Messaging Service
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java 消息服务
- en: The **Java** **Messaging** **API** (**JMS**) provides a mechanism for Java EE
    applications to send messages to each other. Java EE 7 introduced JMS 2.0, which
    greatly simplified the development of applications involving messaging functionality.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**Java** **消息** **API**（**JMS**）为 Java EE 应用程序之间发送消息提供了一个机制。Java EE 7 引入了 JMS
    2.0，它极大地简化了涉及消息功能的应用程序的开发。'
- en: JMS applications do not communicate directly; instead, message producers send
    messages to a destination, and message consumers receive messages from that destination.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: JMS 应用程序不直接通信；相反，消息生产者向目的地发送消息，而消息消费者从该目的地接收消息。
- en: A message destination is a message queue when the **Point-To-Point** (**PTP**)
    messaging domain is used, or a message topic when the Publish/Subscribe (pub/sub)
    messaging domain is used.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 **点对点**（**PTP**）消息域时，消息目的地是一个消息队列；当使用发布/订阅（pub/sub）消息域时，消息目的地是一个消息主题。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Working with message queues
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与消息队列一起工作
- en: Working with message topics
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与消息主题一起工作
- en: Most application servers need to be configured in order for JMS applications
    to work properly. The [Appendix](e125af24-9bf3-427d-a71c-22461bbf34fc.xhtml),
    *Configuring and deploying to GlassFish*, includes instructions for configuring
    GlassFish. Consult your application server documentation for instructions on configuring
    other Java EE 8 compliant application servers.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数应用程序服务器都需要进行配置，以便 JMS 应用程序能够正常工作。附录 *配置和部署到 GlassFish*（e125af24-9bf3-427d-a71c-22461bbf34fc.xhtml）中包含了配置
    GlassFish 的说明。请查阅您的应用程序服务器文档，以获取配置其他 Java EE 8 兼容应用程序服务器的说明。
- en: Message queues
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 消息队列
- en: As we mentioned earlier, Message queues are used when our JMS code uses the
    Point-To-Point (PTP) Messaging Domain. For the PTP Messaging Domain, there is
    usually one message producer and one message consumer. The message producer and
    the message consumer don't need to be running concurrently in order to communicate.
    The messages placed in the message queue by the message producer will stay in
    the message queue until the message consumer executes and requests the messages
    from the queue.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前提到的，当我们的 JMS 代码使用点对点（PTP）消息域时，会使用消息队列。对于 PTP 消息域，通常有一个消息生产者和一个消息消费者。消息生产者和消息消费者不需要同时运行才能进行通信。消息生产者放入消息队列中的消息将保持在消息队列中，直到消息消费者执行并从队列中请求这些消息。
- en: Sending messages to a message queue
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向消息队列发送消息
- en: 'The following example illustrates how to add messages to a message queue:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例说明了如何向消息队列添加消息：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `produceMessages()` method in the `MessageSender` class performs all the
    necessary steps to send messages to a message queue.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '`MessageSender` 类中的 `produceMessages()` 方法执行将消息发送到消息队列所需的所有必要步骤。'
- en: The first thing this method does is create an instance of `javax.jms.JMSContext`
    by invoking the `createContext()` method on the injected instance of `javax.jms.ConnectionFactory`.
    Notice that the `mappedName` attribute of the `@Resource` annotation decorating
    the connection factory object matches the JNDI name of the connection factory
    we set up in the GlassFish web console. Behind the scenes, a JNDI lookup is made
    using this name to obtain the connection factory object.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法首先通过在注入的 `javax.jms.ConnectionFactory` 实例上调用 `createContext()` 方法来创建一个 `javax.jms.JMSContext`
    实例。请注意，装饰连接工厂对象的 `@Resource` 注解的 `mappedName` 属性与我们在 GlassFish 网络控制台中设置的连接工厂的
    JNDI 名称相匹配。在幕后，使用此名称进行 JNDI 查找以获取连接工厂对象。
- en: Next, we create an instance of `javax.jms.JMSProducer` by invoking the `createProducer()`
    method on the `JMSContext` instance we just created.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们通过在刚刚创建的 `JMSContext` 实例上调用 `createProducer()` 方法来创建一个 `javax.jms.JMSProducer`
    实例。
- en: After obtaining an instance of `JMSProducer`, the code sends a series of text
    messages by invoking its `send()` method. This method takes the message destination
    as its first parameter, and a `String` containing the message text as its second
    parameter.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 获得一个 `JMSProducer` 实例后，代码通过调用其 `send()` 方法发送一系列文本消息。此方法将消息目的地作为其第一个参数，将包含消息文本的
    `String` 作为其第二个参数。
- en: There are several overloaded versions of the `send()` method in `JMSProducer`.
    The one we used in our example is a convenience method that creates an instance
    of `javax.jms.TextMessage` and sets its text to the `String` we provide as the
    second parameter in the method invocation.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: Although the above example sends only text messages to the queue, we are not
    limited to this type of message. The JMS API provides several types of messages
    that can be sent and received by JMS applications. All message types are defined
    as interfaces in the `javax.jms` package.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table lists all of the available message types:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '| **Message Type** | **Description** |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
- en: '| `BytesMessage` | Allows sending an array of bytes as a message. `JMSProducer`
    has a convenience `send()` method that takes an array of bytes as one of its parameters.
    This method creates an instance of `javax.jms.BytesMessage` on the fly as the
    message is being sent. |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
- en: '| `MapMessage` | Allows sending an implementation of `java.util.Map` as a message.
    `JMSProducer` has a convenience `send()` method that takes `Map` as one of its
    parameters. This method creates an instance of `javax.jms.MapMessage` on the fly
    as the message is being sent. |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
- en: '| `ObjectMessage` | Allows sending any Java object implementing `java.io.Serializable`
    as a message. `JMSProducer` has a convenience `send()` method that takes an instance
    of a class implementing `java.io.Serializable` as its second parameter. This method
    creates an instance of `javax.jms.ObjectMessage` on the fly as the message is
    being sent. |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
- en: '| `StreamMessage` | Allows sending an array of bytes as a message. Differs
    from `BytesMessage` in that it stores the type of each primitive type added to
    the stream. |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
- en: '| `TextMessage` | Allows sending a `java.lang.String` as a message. As seen
    in their above example, `JMSProducer` has a convenience `send()` method that takes
    a `String` as its second parameter, this method creates an instance of `javax.jms.TextMessage`
    on the fly as the message is being sent. |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
- en: For more information on all of the above message types, consult the JavaDoc
    documentation at [https://javaee.github.io/javaee-spec/javadocs/](https://javaee.github.io/javaee-spec/javadocs/).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving messages from a message queue
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Of course, there is no point in sending messages from a queue if nothing is
    going to receive them. The following example illustrates how to retrieve messages
    from a JMS message queue:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Just as in the previous example, an instance of `javax.jms.ConnectionFactory`
    and an instance of `javax.jms.Queue` are injected by using the `@Resource` annotation.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: In our code, we get an instance of `javax.jms.JMSContext` by invoking the `createContext()`
    method of `ConnectionFactory`, just as in the previous example.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we obtain an instance of `javax.jms.JMSConsumer` by calling
    the `createConsumer()` method on our `JMSContext` instance.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: Messages are received by invoking the `receiveBody()` method on our instance
    of `JMSConsumer`. This method takes the type of the message we are expecting as
    its sole parameter (`String.class` in our example) and returns an object of the
    type specified in its parameter (an instance of `java.lang.String` in our example).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在我们的`JMSConsumer`实例上调用`receiveBody()`方法来接收消息。此方法接受我们期望的消息类型作为其唯一参数（在我们的例子中是`String.class`）并返回其参数指定的类型的对象（在我们的例子中是一个`java.lang.String`实例）。
- en: In this particular example, we placed this method call in a `while` loop, since
    we are expecting a message that will let us know that no more messages are coming.
    Specifically, we are looking for a message containing the text `Good bye !` Once
    we receive said message, we break out of the loop and continue processing. In
    this particular case, there is no more processing to do, therefore, execution
    ends after we break out of the loop.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个特定的例子中，我们将这个方法调用放在了一个`while`循环中，因为我们期望一个消息会告诉我们没有更多的消息到来。具体来说，我们正在寻找包含文本`Good
    bye !`的消息。一旦我们收到这个消息，我们就跳出循环并继续处理。在这种情况下，没有更多的处理要做，因此，在跳出循环后执行结束。
- en: 'After executing the code, we should see the following output in the server
    log:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 执行代码后，我们应该在服务器日志中看到以下输出：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This, of course, assumes that the previous example was already executed and
    placed messages in the message queue.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这假设了之前的示例已经执行并将消息放入了消息队列。
- en: A disadvantage of processing JMS messages as discussed in this section is that
    message processing is synchronous. In a Java EE environment, we can process JMS
    messages asynchronously by employing message-driven beans, as discussed in [Chapter
    4](ec90b829-514a-4375-8ab7-dcd6a9aa9866.xhtml), *Enterprise JavaBeans*.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 本节讨论的将JMS消息处理作为缺点之一是消息处理是同步的。在Java EE环境中，我们可以通过使用消息驱动豆（message-driven beans），如第4章所述，来异步处理JMS消息，*企业JavaBeans*。
- en: Browsing message queues
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 浏览消息队列
- en: 'JMS provides a way to browse message queues without actually removing messages
    from those queues. The following example illustrates how to do this:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: JMS提供了一种在不实际从队列中删除消息的情况下浏览消息队列的方法。以下示例说明了如何做到这一点：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As we can see, the procedure to browse messages in a message queue is straightforward.
    We obtain a JMS connection factory, a JMS queue, and a JMS context in the usual
    way, then invoke the `createBrowser()` method on the JMS context object. This
    method returns an implementation of the `javax.jms.QueueBrowser` interface. This
    interface contains a `getEnumeration()` method that we can invoke to obtain an
    `Enumeration` containing all of the messages in the queue. To examine the messages
    in the queue, we simply traverse this enumeration and obtain the messages one
    by one. In the above example, we simply invoke the `getText()` method of each
    message in the queue.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，在消息队列中浏览消息的程序很简单。我们以通常的方式获取一个JMS连接工厂、一个JMS队列和一个JMS上下文，然后在JMS上下文对象上调用`createBrowser()`方法。此方法返回`javax.jms.QueueBrowser`接口的实现。此接口包含一个`getEnumeration()`方法，我们可以调用它来获取包含队列中所有消息的`Enumeration`。要检查队列中的消息，我们只需遍历这个枚举并逐个获取消息。在上面的例子中，我们简单地调用了队列中每个消息的`getText()`方法。
- en: Message topics
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 消息主题
- en: Message topics are used when our JMS code uses the Publish/Subscribe (pub/sub)
    messaging domain. When using this messaging domain, the same message can be sent
    to all subscribers to the topic.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的JMS代码使用发布/订阅（pub/sub）消息域时，使用消息主题。当使用此消息域时，相同的消息可以发送给所有订阅该主题的订阅者。
- en: Sending messages to a message topic
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向消息主题发送消息
- en: 'The following example illustrates how to send messages to a message topic:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例说明了如何向消息主题发送消息：
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As we can see, the preceding code is nearly identical to the `MessageSender`
    class we saw when we discussed Point-To-Point messaging. As a matter of fact,
    the only lines of code that are different are the ones that are highlighted. The
    JMS API was designed this way so that application developers do not have to learn
    two different APIs for the PTP and pub/sub domains.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，前面的代码几乎与我们在讨论点对点消息时看到的`MessageSender`类相同。实际上，唯一不同的代码行是那些被突出显示的。JMS API就是这样设计的，以便应用程序开发者不需要学习两个不同的API来处理PTP和pub/sub域。
- en: Since the code is nearly identical to the corresponding example in the *Message
    queues* section, we will only explain the differences between the two examples.
    In this example, instead of declaring an instance of a class implementing `javax.jms.Queue`,
    we declare an instance of a class implementing `javax.jms.Topic`. We then pass
    this instance of `javax.jms.Topic` as the first method of the `send()` method
    of our `JMSProducer` object, along with the message we wish to send.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 由于代码几乎与*消息队列*部分中的相应示例相同，我们只解释两个示例之间的差异。在这个例子中，我们不是声明一个实现`javax.jms.Queue`类的实例，而是声明一个实现`javax.jms.Topic`类的实例。然后，我们将这个`javax.jms.Topic`的实例作为我们`JMSProducer`对象的`send()`方法的第一参数传递，同时传递我们希望发送的消息。
- en: Receiving messages from a message topic
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从消息主题接收消息
- en: 'Just as sending messages to a message topic is almost identical to sending
    messages to a message queue, receiving messages from a message topic is almost
    identical to receiving messages from a message queue:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 正如向消息主题发送消息几乎与向消息队列发送消息相同一样，从消息主题接收消息几乎与从消息队列接收消息相同：
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Once again, the differences between this code and the corresponding code for
    PTP are trivial. Instead of declaring an instance of a class implementing `javax.jms.Queue`,
    we declare a class implementing `javax.jms.Topic`, and we use the `@Resource`
    annotation to inject an instance of this class into our code, using the JNDI name
    we used when configuring our application server. We then obtain an instance of
    `JMSContext` and `JMSConsumer`, as before, then receive the messages from the
    topic by invoking the `receiveBody()` method on `JMSConsumer`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，此代码与PTP对应代码之间的差异微乎其微。我们不是声明一个实现`javax.jms.Queue`类的实例，而是声明一个实现`javax.jms.Topic`类的类，并使用`@Resource`注解将此类的实例注入到我们的代码中，使用我们在配置应用服务器时使用的JNDI名称。然后，我们像之前一样获取`JMSContext`和`JMSConsumer`的实例，然后通过在`JMSConsumer`上调用`receiveBody()`方法从主题接收消息。
- en: Using the pub/sub messaging domain as illustrated in this section has the advantage
    that messages can be sent to several message consumers. This can be easily tested
    by concurrently executing two instances of the `MessageReceiver` class we developed
    in this section, then executing the `MessageSender` class we developed in the
    previous section. We should see console output for each instance, indicating that
    both instances received all messages.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如本节所示，使用pub/sub消息域的优势在于可以将消息发送到多个消息消费者。这可以通过同时执行本节中开发的`MessageReceiver`类的两个实例来轻松测试，然后执行上一节中开发的`MessageSender`类。我们应该看到每个实例的控制台输出，表明两个实例都接收到了所有消息。
- en: Creating durable subscribers
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建持久订阅者
- en: The disadvantage of using the pub/sub messaging domain is that message consumers
    must be executing when the messages are sent to the topic. If a message consumer
    is not executing at the time, it will not receive the messages, whereas, in PTP,
    messages are kept in the queue until the message consumer executes. Fortunately,
    the JMS API provides a way to use the pub/sub messaging domain and keep messages
    in the topic until all subscribed message consumers execute and receive the message.
    This can be accomplished by creating durable subscribers to a JMS Topic.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 使用pub/sub消息域的缺点是，消息消费者必须在消息发送到主题时正在执行。如果消息消费者在那时没有执行，它将不会收到消息，而在PTP中，消息将保留在队列中，直到消息消费者执行。幸运的是，JMS
    API提供了一种使用pub/sub消息域并保留消息在主题中直到所有已订阅的消息消费者执行并接收消息的方法。这可以通过为JMS主题创建持久订阅者来实现。
- en: In order to be able to service durable subscribers, we need to set the `ClientId`
    property of our JMS connection factory. Each durable subscriber must have a unique
    client ID, therefore, a unique connection factory must be declared for each potential
    durable subscriber.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够服务持久订阅者，我们需要设置我们的JMS连接工厂的`ClientId`属性。每个持久订阅者都必须有一个唯一的客户端ID，因此，必须为每个潜在的持久订阅者声明一个唯一的连接工厂。
- en: The procedure to set the `ClientId` property of a JMS connection factory varies
    depending on the application server being used. The [Appendix](e125af24-9bf3-427d-a71c-22461bbf34fc.xhtml),
    *Configuring and deploying to GlassFish* has instructions on setting this property
    on GlassFish. Consult your application server documentation for instructions on
    setting this property when using other Java EE compliant application servers.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 设置 JMS 连接工厂的 `ClientId` 属性的步骤取决于所使用的应用服务器。[附录](e125af24-9bf3-427d-a71c-22461bbf34fc.xhtml)，*配置和部署到
    GlassFish* 中有关于在 GlassFish 上设置此属性的说明。当使用其他 Java EE 兼容的应用服务器时，请查阅您的应用服务器文档以获取设置此属性的说明。
- en: Invalid ClientId Exception? Only one JMS client can connect to a topic for a
    specific client ID. If more than one JMS client attempts to obtain a JMS connection
    using the same connection factory, a `JMSException` stating that the Client ID
    is already in use will be thrown. The solution is to create a connection factory
    for each potential client that will be receiving messages from the durable topic.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 无效的 ClientId 异常？只有一个 JMS 客户端可以连接到特定客户端 ID 的主题。如果有多个 JMS 客户端尝试使用相同的连接工厂获取 JMS
    连接，将会抛出一个表示客户端 ID 已经被使用的 `JMSException`。解决方案是为每个可能接收来自持久主题消息的潜在客户端创建一个连接工厂。
- en: 'Once we have set up our application server to be able to provide durable subscriptions,
    we are ready to write some code to take advantage of them:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们设置了我们的应用服务器以能够提供持久订阅，我们就可以编写一些代码来利用它们：
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'As we can see, the preceding code is not much different from previous examples
    whose purpose was to retrieve messages. There are only two differences from previous
    examples: The instance of `ConnectionFactory` we are injecting is set up to handle
    durable subscriptions, and instead of calling the `createConsumer()` method on
    the JMS context object, we are calling `createDurableConsumer()`. The `createDurableConsumer()`
    method takes two arguments: a JMS `Topic` object to retrieve messages from, and
    a `String` designating a name for this subscription. This second parameter must
    be unique for all subscribers to the durable topic.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，前面的代码与之前用于检索消息的示例没有太大区别。与之前的示例相比，只有两个不同之处：我们注入的 `ConnectionFactory` 实例被设置为处理持久订阅，并且我们不是在
    JMS 上下文对象上调用 `createConsumer()` 方法，而是在调用 `createDurableConsumer()`。`createDurableConsumer()`
    方法接受两个参数：一个用于检索消息的 JMS `Topic` 对象，以及一个指定此订阅名称的 `String`。这个第二个参数对于所有订阅持久主题的订阅者必须是唯一的。
- en: Summary
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered how to set up JMS connection factories, JMS message
    queues, and JMS message topics in GlassFish, by using the GlassFish web console.
    We also covered how to send messages to a message queue via the `javax.jms.JMSProducer`
    interface. Additionally, we covered how to receive messages from a message queue
    via the `javax.jms.JMSConsumer` interface. We also covered how to asynchronously
    receive messages from a message queue by implementing the `javax.jms.MessageListener`
    interface and saw how to use the above interfaces to send and receive messages
    to and from a JMS message topic. We also looked at how to browse messages in a
    message queue without removing those messages from the queue via the `javax.jms.QueueBrowser`
    interface. Finally, we saw how to set up and interact with durable subscriptions
    to JMS topics.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了如何在 GlassFish 中使用 GlassFish 网络控制台设置 JMS 连接工厂、JMS 消息队列和 JMS 消息主题。我们还介绍了如何通过
    `javax.jms.JMSProducer` 接口向消息队列发送消息。此外，我们还介绍了如何通过 `javax.jms.JMSConsumer` 接口从消息队列接收消息。我们还介绍了如何通过实现
    `javax.jms.MessageListener` 接口异步地从消息队列接收消息，并展示了如何使用上述接口向和从 JMS 消息主题发送和接收消息。我们还探讨了如何通过
    `javax.jms.QueueBrowser` 接口浏览消息队列中的消息而不从队列中删除这些消息。最后，我们看到了如何设置和与 JMS 主题的持久订阅进行交互。
