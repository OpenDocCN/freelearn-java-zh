- en: Java Messaging Service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Java** **Messaging** **API** (**JMS**) provides a mechanism for Java EE
    applications to send messages to each other. Java EE 7 introduced JMS 2.0, which
    greatly simplified the development of applications involving messaging functionality.
  prefs: []
  type: TYPE_NORMAL
- en: JMS applications do not communicate directly; instead, message producers send
    messages to a destination, and message consumers receive messages from that destination.
  prefs: []
  type: TYPE_NORMAL
- en: A message destination is a message queue when the **Point-To-Point** (**PTP**)
    messaging domain is used, or a message topic when the Publish/Subscribe (pub/sub)
    messaging domain is used.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Working with message queues
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with message topics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Most application servers need to be configured in order for JMS applications
    to work properly. The [Appendix](e125af24-9bf3-427d-a71c-22461bbf34fc.xhtml),
    *Configuring and deploying to GlassFish*, includes instructions for configuring
    GlassFish. Consult your application server documentation for instructions on configuring
    other Java EE 8 compliant application servers.
  prefs: []
  type: TYPE_NORMAL
- en: Message queues
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we mentioned earlier, Message queues are used when our JMS code uses the
    Point-To-Point (PTP) Messaging Domain. For the PTP Messaging Domain, there is
    usually one message producer and one message consumer. The message producer and
    the message consumer don't need to be running concurrently in order to communicate.
    The messages placed in the message queue by the message producer will stay in
    the message queue until the message consumer executes and requests the messages
    from the queue.
  prefs: []
  type: TYPE_NORMAL
- en: Sending messages to a message queue
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following example illustrates how to add messages to a message queue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `produceMessages()` method in the `MessageSender` class performs all the
    necessary steps to send messages to a message queue.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing this method does is create an instance of `javax.jms.JMSContext`
    by invoking the `createContext()` method on the injected instance of `javax.jms.ConnectionFactory`.
    Notice that the `mappedName` attribute of the `@Resource` annotation decorating
    the connection factory object matches the JNDI name of the connection factory
    we set up in the GlassFish web console. Behind the scenes, a JNDI lookup is made
    using this name to obtain the connection factory object.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create an instance of `javax.jms.JMSProducer` by invoking the `createProducer()`
    method on the `JMSContext` instance we just created.
  prefs: []
  type: TYPE_NORMAL
- en: After obtaining an instance of `JMSProducer`, the code sends a series of text
    messages by invoking its `send()` method. This method takes the message destination
    as its first parameter, and a `String` containing the message text as its second
    parameter.
  prefs: []
  type: TYPE_NORMAL
- en: There are several overloaded versions of the `send()` method in `JMSProducer`.
    The one we used in our example is a convenience method that creates an instance
    of `javax.jms.TextMessage` and sets its text to the `String` we provide as the
    second parameter in the method invocation.
  prefs: []
  type: TYPE_NORMAL
- en: Although the above example sends only text messages to the queue, we are not
    limited to this type of message. The JMS API provides several types of messages
    that can be sent and received by JMS applications. All message types are defined
    as interfaces in the `javax.jms` package.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table lists all of the available message types:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Message Type** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `BytesMessage` | Allows sending an array of bytes as a message. `JMSProducer`
    has a convenience `send()` method that takes an array of bytes as one of its parameters.
    This method creates an instance of `javax.jms.BytesMessage` on the fly as the
    message is being sent. |'
  prefs: []
  type: TYPE_TB
- en: '| `MapMessage` | Allows sending an implementation of `java.util.Map` as a message.
    `JMSProducer` has a convenience `send()` method that takes `Map` as one of its
    parameters. This method creates an instance of `javax.jms.MapMessage` on the fly
    as the message is being sent. |'
  prefs: []
  type: TYPE_TB
- en: '| `ObjectMessage` | Allows sending any Java object implementing `java.io.Serializable`
    as a message. `JMSProducer` has a convenience `send()` method that takes an instance
    of a class implementing `java.io.Serializable` as its second parameter. This method
    creates an instance of `javax.jms.ObjectMessage` on the fly as the message is
    being sent. |'
  prefs: []
  type: TYPE_TB
- en: '| `StreamMessage` | Allows sending an array of bytes as a message. Differs
    from `BytesMessage` in that it stores the type of each primitive type added to
    the stream. |'
  prefs: []
  type: TYPE_TB
- en: '| `TextMessage` | Allows sending a `java.lang.String` as a message. As seen
    in their above example, `JMSProducer` has a convenience `send()` method that takes
    a `String` as its second parameter, this method creates an instance of `javax.jms.TextMessage`
    on the fly as the message is being sent. |'
  prefs: []
  type: TYPE_TB
- en: For more information on all of the above message types, consult the JavaDoc
    documentation at [https://javaee.github.io/javaee-spec/javadocs/](https://javaee.github.io/javaee-spec/javadocs/).
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving messages from a message queue
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Of course, there is no point in sending messages from a queue if nothing is
    going to receive them. The following example illustrates how to retrieve messages
    from a JMS message queue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Just as in the previous example, an instance of `javax.jms.ConnectionFactory`
    and an instance of `javax.jms.Queue` are injected by using the `@Resource` annotation.
  prefs: []
  type: TYPE_NORMAL
- en: In our code, we get an instance of `javax.jms.JMSContext` by invoking the `createContext()`
    method of `ConnectionFactory`, just as in the previous example.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we obtain an instance of `javax.jms.JMSConsumer` by calling
    the `createConsumer()` method on our `JMSContext` instance.
  prefs: []
  type: TYPE_NORMAL
- en: Messages are received by invoking the `receiveBody()` method on our instance
    of `JMSConsumer`. This method takes the type of the message we are expecting as
    its sole parameter (`String.class` in our example) and returns an object of the
    type specified in its parameter (an instance of `java.lang.String` in our example).
  prefs: []
  type: TYPE_NORMAL
- en: In this particular example, we placed this method call in a `while` loop, since
    we are expecting a message that will let us know that no more messages are coming.
    Specifically, we are looking for a message containing the text `Good bye !` Once
    we receive said message, we break out of the loop and continue processing. In
    this particular case, there is no more processing to do, therefore, execution
    ends after we break out of the loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'After executing the code, we should see the following output in the server
    log:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This, of course, assumes that the previous example was already executed and
    placed messages in the message queue.
  prefs: []
  type: TYPE_NORMAL
- en: A disadvantage of processing JMS messages as discussed in this section is that
    message processing is synchronous. In a Java EE environment, we can process JMS
    messages asynchronously by employing message-driven beans, as discussed in [Chapter
    4](ec90b829-514a-4375-8ab7-dcd6a9aa9866.xhtml), *Enterprise JavaBeans*.
  prefs: []
  type: TYPE_NORMAL
- en: Browsing message queues
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'JMS provides a way to browse message queues without actually removing messages
    from those queues. The following example illustrates how to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, the procedure to browse messages in a message queue is straightforward.
    We obtain a JMS connection factory, a JMS queue, and a JMS context in the usual
    way, then invoke the `createBrowser()` method on the JMS context object. This
    method returns an implementation of the `javax.jms.QueueBrowser` interface. This
    interface contains a `getEnumeration()` method that we can invoke to obtain an
    `Enumeration` containing all of the messages in the queue. To examine the messages
    in the queue, we simply traverse this enumeration and obtain the messages one
    by one. In the above example, we simply invoke the `getText()` method of each
    message in the queue.
  prefs: []
  type: TYPE_NORMAL
- en: Message topics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Message topics are used when our JMS code uses the Publish/Subscribe (pub/sub)
    messaging domain. When using this messaging domain, the same message can be sent
    to all subscribers to the topic.
  prefs: []
  type: TYPE_NORMAL
- en: Sending messages to a message topic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following example illustrates how to send messages to a message topic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, the preceding code is nearly identical to the `MessageSender`
    class we saw when we discussed Point-To-Point messaging. As a matter of fact,
    the only lines of code that are different are the ones that are highlighted. The
    JMS API was designed this way so that application developers do not have to learn
    two different APIs for the PTP and pub/sub domains.
  prefs: []
  type: TYPE_NORMAL
- en: Since the code is nearly identical to the corresponding example in the *Message
    queues* section, we will only explain the differences between the two examples.
    In this example, instead of declaring an instance of a class implementing `javax.jms.Queue`,
    we declare an instance of a class implementing `javax.jms.Topic`. We then pass
    this instance of `javax.jms.Topic` as the first method of the `send()` method
    of our `JMSProducer` object, along with the message we wish to send.
  prefs: []
  type: TYPE_NORMAL
- en: Receiving messages from a message topic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Just as sending messages to a message topic is almost identical to sending
    messages to a message queue, receiving messages from a message topic is almost
    identical to receiving messages from a message queue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Once again, the differences between this code and the corresponding code for
    PTP are trivial. Instead of declaring an instance of a class implementing `javax.jms.Queue`,
    we declare a class implementing `javax.jms.Topic`, and we use the `@Resource`
    annotation to inject an instance of this class into our code, using the JNDI name
    we used when configuring our application server. We then obtain an instance of
    `JMSContext` and `JMSConsumer`, as before, then receive the messages from the
    topic by invoking the `receiveBody()` method on `JMSConsumer`.
  prefs: []
  type: TYPE_NORMAL
- en: Using the pub/sub messaging domain as illustrated in this section has the advantage
    that messages can be sent to several message consumers. This can be easily tested
    by concurrently executing two instances of the `MessageReceiver` class we developed
    in this section, then executing the `MessageSender` class we developed in the
    previous section. We should see console output for each instance, indicating that
    both instances received all messages.
  prefs: []
  type: TYPE_NORMAL
- en: Creating durable subscribers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The disadvantage of using the pub/sub messaging domain is that message consumers
    must be executing when the messages are sent to the topic. If a message consumer
    is not executing at the time, it will not receive the messages, whereas, in PTP,
    messages are kept in the queue until the message consumer executes. Fortunately,
    the JMS API provides a way to use the pub/sub messaging domain and keep messages
    in the topic until all subscribed message consumers execute and receive the message.
    This can be accomplished by creating durable subscribers to a JMS Topic.
  prefs: []
  type: TYPE_NORMAL
- en: In order to be able to service durable subscribers, we need to set the `ClientId`
    property of our JMS connection factory. Each durable subscriber must have a unique
    client ID, therefore, a unique connection factory must be declared for each potential
    durable subscriber.
  prefs: []
  type: TYPE_NORMAL
- en: The procedure to set the `ClientId` property of a JMS connection factory varies
    depending on the application server being used. The [Appendix](e125af24-9bf3-427d-a71c-22461bbf34fc.xhtml),
    *Configuring and deploying to GlassFish* has instructions on setting this property
    on GlassFish. Consult your application server documentation for instructions on
    setting this property when using other Java EE compliant application servers.
  prefs: []
  type: TYPE_NORMAL
- en: Invalid ClientId Exception? Only one JMS client can connect to a topic for a
    specific client ID. If more than one JMS client attempts to obtain a JMS connection
    using the same connection factory, a `JMSException` stating that the Client ID
    is already in use will be thrown. The solution is to create a connection factory
    for each potential client that will be receiving messages from the durable topic.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have set up our application server to be able to provide durable subscriptions,
    we are ready to write some code to take advantage of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see, the preceding code is not much different from previous examples
    whose purpose was to retrieve messages. There are only two differences from previous
    examples: The instance of `ConnectionFactory` we are injecting is set up to handle
    durable subscriptions, and instead of calling the `createConsumer()` method on
    the JMS context object, we are calling `createDurableConsumer()`. The `createDurableConsumer()`
    method takes two arguments: a JMS `Topic` object to retrieve messages from, and
    a `String` designating a name for this subscription. This second parameter must
    be unique for all subscribers to the durable topic.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered how to set up JMS connection factories, JMS message
    queues, and JMS message topics in GlassFish, by using the GlassFish web console.
    We also covered how to send messages to a message queue via the `javax.jms.JMSProducer`
    interface. Additionally, we covered how to receive messages from a message queue
    via the `javax.jms.JMSConsumer` interface. We also covered how to asynchronously
    receive messages from a message queue by implementing the `javax.jms.MessageListener`
    interface and saw how to use the above interfaces to send and receive messages
    to and from a JMS message topic. We also looked at how to browse messages in a
    message queue without removing those messages from the queue via the `javax.jms.QueueBrowser`
    interface. Finally, we saw how to set up and interact with durable subscriptions
    to JMS topics.
  prefs: []
  type: TYPE_NORMAL
