- en: 4\. Mapping and Filtering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overview
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will begin our exploration of how to use sequential collections
    in Clojure by taking a look at two of the most useful patterns: mapping and filtering.
    We will work with the map and filter functions and handle sequential data without
    using a for loop. We will also use common patterns and idioms for Clojure collections
    and take advantage of lazy evaluation while avoiding the traps. We will load and
    process sequential datasets from **Comma-Separated Values** (**CSV**) files and
    extract and shape data from a large dataset.'
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be able to parse datasets and perform various
    types of transformations to extract and summarize data.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Dealing with collections of data is one of the most common and powerful parts
    of programming. Whether they are called lists, arrays, or vectors, sequential
    collections are at the heart of almost every program. Every programming language
    provides tools for creating, accessing, and modifying collections, and, often,
    what you've learned in one language will apply to the others. Clojure is different,
    however. We are accustomed to setting a variable and then controlling some other
    part of the system by changing the value of that variable.
  prefs: []
  type: TYPE_NORMAL
- en: This is what happens in a `for` loop in most procedural languages. Say that
    we have an iterator, `i`, that we increment by calling `i++`. Changing the value
    of the iterator controls the flow of the loop. By executing `i = i + 3`, we can
    make the loop skip two iterations. The value of `i` is like a remote control for
    the loop. In case we increment the iterator by three, what happens if we are just
    one item away from the end of the array we are looping over? The remote control
    doesn't prevent us from making mistakes with it.
  prefs: []
  type: TYPE_NORMAL
- en: Clojure has a completely different approach. It may take some practice and some
    experience to get used to it, depending on what kinds of programming you've done
    before. With Clojure, it's helpful to think of the functions you write as a way
    of describing the shape of the data we want to have. Often, you will need to reshape
    the data in several steps to get it to where you need it to go. Rather than using
    data, such as the iterator we mentioned previously, to keep track of the internal
    state of the program, Clojure invites you to write the functions that will be
    the bridge between the data you have and the data you want. That's at least one
    way of thinking about it.
  prefs: []
  type: TYPE_NORMAL
- en: 'From a 30,000-foot perspective, the fundamental pattern of Clojure programs
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Get the data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Shape the data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Do something with the data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The traditional `for` loop tends to roll these three phases into one. A typical
    example would be a `for` loop that reads a row of data from a database or a file
    (*get the data*), does some computations (*shape the data*), and writes data back
    or sends it somewhere else (*do something*), and then starts over again with the
    next row. A good design in Clojure usually means separating these three steps
    and moving as much logic as possible into the middle, which is the data-shaping
    step.
  prefs: []
  type: TYPE_NORMAL
- en: The techniques that we'll cover in this chapter will help you do that.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Clojure does have a `for` macro, but it is used for list comprehensions, which
    you can think of as an alternate syntax for many of the patterns in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: This approach to coding makes Clojure an excellent language for doing complicated
    things with complex data as simply as possible. Learning a functional approach
    to data collections is not just for processing large datasets, however. Clojure
    programs often tend to be data-centric, regardless of how much data they are actually
    processing. Much of the important work in a Clojure program is done by shaping
    your data, big or small. The techniques and patterns you'll learn about in this
    chapter will help you write any kind of Clojure code.
  prefs: []
  type: TYPE_NORMAL
- en: The `map` and `filter` functions are fundamentally quite simple, as you'll soon
    see. In this chapter, we will focus on how to use them to solve problems. At the
    same time, learning about `map` and `filter` and, more generally, how to handle
    sequential data, means learning lots of new things about the Clojure ecosystem
    – things such as immutability, lazy sequences, or the basics of functional programming.
    Toward the end of this chapter, we will start to use the techniques we learned
    along the way to manipulate a larger dataset, composed of the results of years
    and years of professional tennis matches. In subsequent chapters, we will continue
    to build on our experience with this data as we learn more and more about Clojure.
  prefs: []
  type: TYPE_NORMAL
- en: map and filter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `map` and `filter` functions are a key part of a much larger group of functions
    for dealing with sequences. Of that group, `map` is certainly the one you will
    use the most, and `filter` is a close second. Their role is to modify sequences.
  prefs: []
  type: TYPE_NORMAL
- en: 'They accept one or more sequences as input, and return a sequence: *sequence
    in*, *sequence out*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1: A schematic diagram of map and filter working together'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14502_04_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.1: A schematic diagram of map and filter working together'
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding diagram, we can see `map` and `filter` working together, where
    `filter` eliminates items from the original list while `map` changes them.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first question to ask when solving a problem involving collections is:
    "Do I want to obtain a list of values, or a single value?" If the answer is a
    list, then `map`, `filter`, or similar functions are what you need. If you need
    some other kind of value, the solution is probably a reduction of some kind, which
    we will discuss in the next chapter. But even then, as you break the problem down,
    there is a good chance that some component parts of the problem will require sequence-manipulating
    functions such as `map` and `filter`. If, for example, the problem at hand involves
    searching in a list of items for sale, perhaps `filter` would allow you to narrow
    the scope of the search to a certain category or price range. Then, you may use
    `map` to calculate a derived value for each item – maybe the item''s volume in
    cubic centimeters or the number of commentaries it has received on a website.
    And then, finally, you may extract the single item you are seeking, or the summary
    data that you need, from this transformed list.'
  prefs: []
  type: TYPE_NORMAL
- en: To get started, let's take a closer look at `map` and `filter` separately, before
    looking at how we will use them together.
  prefs: []
  type: TYPE_NORMAL
- en: map
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Like the majority of Clojure''s functions for working with sequences, the first
    argument of map is always a function. The function we provide will be called on
    each item in the sequence that we will iterate over. Here is a very simple use
    of `map` that uses Clojure''s `inc` function to add 1 to each value in the input
    sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The return value of each call to the `inc` function becomes a value in the new
    sequence that `map` returns.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The `map` function can take more sequences as arguments, as we'll see shortly.
    Like many of the sequence-handling functions, there is a single-argument form
    of `map`. When `map` is called with just one argument, that is, the function,
    it returns a special function called a `map`, the Clojure compiler won't complain
    about not having enough arguments. Instead, you'll see a strange error about a
    function that you don't remember writing. That function is the transducer you've
    produced by mistake.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 4.01: Working with map'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s get started! In this exercise, we''ll use `map` on a list of integers
    to obtain different kinds of results:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Try this in your REPL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This call to `map` simply applied the anonymous function known as `(fn [i]
    (* i 10))` to the list of integers, multiplying each one by 10\. In doing so,
    we end up with a new list of integers, one for each of the integers in the original
    input:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 4.2: Mapping one sequence to another'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14502_04_02.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 4.2: Mapping one sequence to another'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This one-to-one equivalence is obvious, but it is also a key feature of `map`.
    With `map`, the sequence of results is always exactly the same length as the input
    sequence so that each value in the input maps to the corresponding value in the
    result sequence, hence the name.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let''s measure word length now. When working with sequences, Clojure''s `count`
    function is invaluable. Since Clojure considers a string to be a sequence of characters,
    `count` can also be used to find the length of a string:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You should see the length of each word:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To make our output easier to read, we could add the word along with its length:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This example, of course, just scratches the surface of the different applications
    of `map`. At the same time, it shows how simple the concept of mapping really
    is: for each value in a list, produce a new value in a new list.'
  prefs: []
  type: TYPE_NORMAL
- en: filter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Unlike `map`, `filter` can, and often does, produce a sequence of results containing
    fewer items than the input sequence. A call to `filter` looks basically like a
    call to `map`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Like in `map`, the function that's supplied as the first argument to `filter`
    is called on each item in the sequence. The difference is that, in this case,
    the function is being used as a `true` or `false`. When a **truthy** value is
    returned, that item will be included in the sequence of results.
  prefs: []
  type: TYPE_NORMAL
- en: One key difference with `map` is that the predicate that's provided to `filter`
    only serves to decide whether the given item should be included or not. It does
    not change the items in any way. The result set of `filter` is always a subset
    of the input set.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 4.02: Getting Started with filter'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we''ll use `filter` on a list of integers to obtain different
    kinds of results. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `odd?` function is a predicate that returns `true` if a number is `odd`.
    Try it by itself in the REPL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, try passing an even number as input:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, use `odd?` with `filter`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We could also use the alter ego of filter, `remove`, which does the exact inverse
    of `filter`. When the predicate returns `true`, the item is removed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here is how we can visualize what `filter` does:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 4.3: The filter function uses a predicate to define a new sequence'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14502_04_03.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 4.3: The filter function uses a predicate to define a new sequence'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'With `filter`, we are limiting the original sequence, but the result is always
    a sequence. Consider these two extreme cases where each predicate always returns
    a single value (Clojure''s `constantly` function returns a function that does
    nothing but return a single value, regardless of the number of arguments that
    are passed to it):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Whether we keep everything or nothing, `filter` *always* returns a sequence.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Like `map`, `filter` is conceptually very simple: using a predicate, keep some
    or all of the items in a list. Despite this simplicity, or thanks to it, `filter`
    is an extremely useful function that can be used in countless circumstances.'
  prefs: []
  type: TYPE_NORMAL
- en: Other Members of the filter Family – take-while and drop-while
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `take-while` and `drop-while` functions follow the same logic as `filter`
    and `remove` – at least as far as their use of a predicate goes. The difference
    is that they only operate at the beginning of a sequence, much like `take` and
    `drop`. The `take` function returns the first `n` items of a list, while `drop`
    returns the original list minus the first `n` items:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, `take-while` starts at the beginning of the list and returns all
    the items as long as they satisfy the predicate, while `drop-while` removes those
    same items from the beginning of the sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Perhaps the most obvious application of `take-while` and `drop-while` is to
    subdivide sorted data. We can even use them together to find the exact point in
    a sequence where a predicate stops returning `true` and starts returning `false`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 4.03: Partitioning a Sequence with take-while and drop-while'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have a sorted list of students that we''d like to separate into two groups:
    those born before the year 2000 and those born after. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In your REPL, define a `students` variable. You can copy the list from this
    course''s GitHub repository at [https://packt.live/2sQyVYz](https://packt.live/2sQyVYz):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Write a predicate that translates the idea `before 2000`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This anonymous function extracts the `:year` value from the student map and
    compares it to `2000`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Use the predicate with `take-while` to find the students born before 2000:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use the same predicate with `drop-while` to find the students born in 2000
    or after:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You won't use the `take-while` and `drop-while` functions as much as `filter`
    itself, but they can be very useful in certain circumstances. Like `filter`, they
    are useful tools for shaping sequences.
  prefs: []
  type: TYPE_NORMAL
- en: Using map and filter Together
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Much of the power of Clojure''s sequence functions comes from combining them.
    Let''s combine the previous examples. How would we obtain a sequence such as 10,
    30, 50 from 1, 2, 3, 4, 5? It''s just a question of applying our functions in
    the right order. If we multiply by 10 first, all the resulting integers will be
    even. To meaningfully filter out the odd numbers, we have to do this first. Consider
    the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This is a little bit hard to read, especially if you aren't used to reading
    Lisp code with its nested parentheses. Even though `map` comes first in the source
    code, the evaluation starts with the call to `filter`. The result is then passed
    into `map` (we'll show you a better way to write this later in this chapter).
    First, though, let's look at what is happening.
  prefs: []
  type: TYPE_NORMAL
- en: 'Conceptually, the computation looks something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.4: Combining the two – filter, then map'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14502_04_04.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.4: Combining the two – filter, then map'
  prefs: []
  type: TYPE_NORMAL
- en: It may be helpful to think of this as data flowing through a pipeline. The functional
    arguments to `map` and `filter` are what shape your data as it flows along.
  prefs: []
  type: TYPE_NORMAL
- en: Threading Macros
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It''s possible to write the same expression in a way that reflects the logic
    of what we are doing to the data. If we write this in a very non-idiomatic style,
    using `def`, it''s a little clearer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, and much more idiomatically, we can use Clojure''s **threading
    macros** to make it easier to read:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: A macro is a construct that transforms code before it is executed. In *Chapter
    11*, *Macros*, we will explore macros in much more depth. For now, you can think
    of Clojure's threading macros as "syntactic sugar" that allows us to write more
    readable code by avoiding deep nesting.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how we will write our code throughout this chapter. Threading allows
    us to preserve the logical order of execution without having to name the return
    values. The `->>` macro rewrites your code so that the result of each form is
    inserted at the end of the next form. This way, we can write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'And the compiler really "sees" this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This is an extremely common pattern that helps immensely in writing easy-to-read
    code, especially when applying many different operations to sequences. In Clojure,
    when a function takes a sequence as an argument, that argument is generally the
    last argument. This is quite convenient, or rather, a great design decision, because
    it allows us to chain together transformations in an intuitive way using the `->>`
    macro, which happens to fill in the last argument in an expression. A complex
    transformation can be broken down into smaller, composable steps, which are easier
    to write, test, and understand.
  prefs: []
  type: TYPE_NORMAL
- en: Using Lazy Sequences
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we move on, it''s important to take a closer look at how lazy sequences
    work in Clojure. When using `map` and `filter`, lazy evaluation is often an important
    consideration. In the examples we''ve looked at so far, we have used a literal
    vector as input: `[1 2 3 4 5]`. Instead of typing out each number, we could use
    the `range` function and write `(range 1 6)`. If we type this in the REPL, we
    get basically the same thing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'So, is this just a shortcut to avoid typing out lots of integers? Well, it
    is, but `range` has another interesting characteristic: it''s lazy.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we go further, let''s revisit `(range 100)` is a `100`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'The REPL causes lazy sequences to be evaluated. This can be confusing sometimes
    if the problem you are debugging is caused by a lazy sequence not being fully
    evaluated: "This code works just fine in the REPL; why doesn''t it work correctly
    in my code?" When debugging in the REPL, if you want to avoid forcing the evaluation
    of a lazy sequence, assign it to a variable instead.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `range` function creates a list of integers by calling `inc` as many times
    as necessary. It''s easy enough to guess that the last integer in `our-seq` will
    be `99`, but the computer doesn''t know that until it has performed all the arithmetic.
    This means that when we look at the first item, only one item is known:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'But if we look at the last item, all the intermediate calculations will be
    performed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Now, the entire sequence has been realized, and for all practical purposes,
    it's no longer any different from a literal sequence of integers.
  prefs: []
  type: TYPE_NORMAL
- en: Functions such as `map`, `filter`, and `remove` are also lazy. This means that
    when we call them on a lazy sequence, they do not force the calculation of the
    entire sequence. Essentially, lazy functions just add new calculations to a virtual
    backlog of deferred calculations that will realize the sequence when needed. Functions
    such as `count`, `sort`, or `last`, on the other hand, are not lazy. Obviously,
    in order to count all the items in the list, we need the entire list first.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 4.04: Watching Lazy Evaluation'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can observe laziness in action by doing something that we never want to
    do in production code: introduce a side effect. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Define a simple version of `range` in the REPL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, the `iterate` function creates a lazy sequence by calling `inc` on `0`,
    then calling `inc` on the result of that, then on the result of that, and so on.
    `take-while` will stop consuming the sequence when the anonymous function, that
    is, `#(< % limit)`, stops returning `true`. This will then stop `iterate`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Test the function at the REPL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use `map` to multiply each integer by 10:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we''ll use a function with side effects to print `.` each time an integer
    is multiplied:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As predicted, there is a `.` operator for each integer. The exact position of
    the dots may be different when you try this: they may appear before or after the
    list of integers. They are not part of the result sequence; they are being printed
    simultaneously, just before each multiplication is executed. There is one dot
    for each integer because the entire sequence has been realized.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'This time, use `def` to store the lazy sequence, instead of viewing it in the
    REPL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The REPL returns the `by-ten` variable, but does not print any dots, so we know
    that none of the multiplications have been performed yet.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Evaluate the variable in the REPL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'What happened here? This is the same output as in *step 4*. The computations
    weren''t performed until we finally decided to consume the lazy sequences in the REPL.
    This is the essence of laziness in Clojure: deferring evaluation until it is necessary.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Lazy evaluation has some important benefits, both in terms of simplifying our
    programs and in terms of performance. Deferring computation on a sequence means
    that we can sometimes avoid the computation altogether, at least on part of the
    sequence. For now, the important thing to understand is how lazy evaluation can
    change the way we write and organize our code. Consider this expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'With no arguments, `range` returns all the integers from zero to the biggest
    number your system can handle. If you type this expression into your REPL, it
    will fill up the screen with numbers. Because there is a built-in limit regarding
    the number of items the REPL will display, it won''t increment all the way to
    infinity, or until your JVM blows up – whichever comes first. Now, imagine that
    we write something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'This expression tells the computer to multiply every integer from 1 to infinity
    by 10, and then, when that calculation is complete, keep the first five values.
    Without lazy evaluation, this would be crazy. It would fail on the first line.
    Then, why perform a calculation on a huge set of numbers when we''re only interested
    in the first five values? Yet, in Clojure, this is a perfectly reasonable way
    to write code. The calls to `range` and `map` are a description of the data that
    we want: positive integers multiplied by 10\. The call to take allows us to select,
    within that infinite set, the items that we actually need. Lazy evaluation means
    that only five calculations will be performed, so the preceding code is not only
    elegant, but perfectly efficient.'
  prefs: []
  type: TYPE_NORMAL
- en: There are dangers too, of course. In this example, if we replace `(take 5)`
    with `last`, it would mean trying to evaluate the entire sequence, with disastrous
    consequences as your machine tries, and fails, to calculate all the integers to
    infinity. Lazy evaluation is extremely useful, but it is important to understand
    how it works.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 4.05: Creating Our Own Lazy Sequence'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'From time to time, we need to create sequences of random numbers. This may
    be for a simulation or for writing tests. In a procedural language such as JavaScript,
    we may write something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: We could then wrap this in a function and parameterize the length of the array
    we wanted.
  prefs: []
  type: TYPE_NORMAL
- en: 'How can we do this in Clojure without a `for` loop? Clojure has a `rand-int`
    function that returns a single random integer. We can use the `repeatedly` function,
    which returns a lazy sequence of calls to whatever function we pass it. Let''s
    get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a lazy sequence with `repeatedly` and an anonymous function that calls
    `rand-int` with a fixed argument:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `parse-int` function just takes one argument that defines the upper bound
    of the value to be returned. It is common to use `partial` in cases like this,
    but we could have just as well written a literal anonymous function: `#(rand-int
    100)`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Use `take` to limit how many integers are returned:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Wrap this into a function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use it as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When moving from a procedural approach to Clojure's functional approach, this
    pattern can be useful. First, describe the data you want, and then delimit it
    or transform it as needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lazy sequences may seem unnecessarily confusing at first: why bother with a
    data structure that introduces uncertainty about whether something has been calculated
    or not? There are indeed some edge cases where this can be an issue, and we''ll
    see one of those later in this chapter. Most of the time, however, these problems
    can be avoided by writing code that does not produce or depend on side effects.
    And then you will start to reap the benefits of lazy sequences, which allow sequences
    to be defined in a declarative way that will ultimately simplify your code.'
  prefs: []
  type: TYPE_NORMAL
- en: Common Idioms and Patterns
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Functions such as `map` and `filter` are two of the most powerful tools in Clojure
    for extracting, selecting, and transforming data. The key to using them effectively
    is, of course, knowing what kind of function to use with them. Clojure tries to
    make writing functions easy, and there are many shortcuts for some of the most
    common situations. These techniques will help you to start writing code more quickly,
    and they will also give you some valuable practice in functional programming.
  prefs: []
  type: TYPE_NORMAL
- en: Anonymous Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we've been writing functional arguments as anonymous functions using
    the canonical `fn` form, or by using a named function such as `odd?`. Because
    sequence-handling functions in Clojure often make use of functions that are passed
    in as arguments, writing (and reading) anonymous functions is an extremely common
    task. This is why it's good to know the different shortcuts for writing them.
  prefs: []
  type: TYPE_NORMAL
- en: One of the most common ways to pass a function to `map` or `filter` is by using
    what's known as a `fn` form. The `fn` symbol and the argument list disappear,
    leaving only the heart of the function and a `#` operator just before the opening
    parenthesis.
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Exercise 4.01*, *Working with map*, instead of `(fn [n] (* 10 n))`, we
    could have written `#(* 10 %)`. The leading `#` operator identifies the form that
    follows as a function. We still don''t have an argument list, though, which would
    be a disastrous omission in a functional language! However, we are saved by a
    pattern: instead of naming the arguments freely, as in most functions, with function
    literals, the arguments are automatically named by following a simple pattern.
    The first argument is named `%` and all the other arguments are named `%2`, `%3`,
    `%4`, and so forth.'
  prefs: []
  type: TYPE_NORMAL
- en: There are some limits to the expressiveness of function literals. The pattern
    for argument names does not allow anything such as destructuring or any of the
    other interesting features of Clojure's argument lists. And, of course, not being
    able to name the arguments does make for inexpressive code. If you have more than
    two arguments, it may be time to switch back to `fn`. It may seem obvious what
    you meant by `%4` in the complex function literal you wrote this morning, but
    in a week, you will probably have forgotten. Function literals should be brief
    and simple.
  prefs: []
  type: TYPE_NORMAL
- en: The final limitation of functional literals is that they cannot be nested. In
    other words, if you have a function literal that calls `map`, then the function
    you provide to `map` cannot also be a function literal. The reason why nesting
    is impossible is quite simple. How would the compiler know which `%` goes with
    which function?
  prefs: []
  type: TYPE_NORMAL
- en: As soon as a function literal starts to become even a little bit complex, it's
    certainly time to switch to the `fn` form. Function literals should be used as
    simple wrappers for setting up calls to existing functions, rather than as a place
    to write complex code.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you become more familiar with some of the more advanced functional techniques
    in Clojure, you will start to use some of the other options that are now at your
    disposal. For multiplying by 10, we could have also written the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that there is no `#` in front of this form. Here, the `partial` function
    returns a new anonymous function, that is, `*`, with its first argument "preloaded."
    This is easier to understand in the REPL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Here, we've defined `apart`, which is a partially evaluated call to `*`. By
    calling that function, it behaves just like `*`, except that the first argument
    to `*` is already filled in. Writing `(partial * 10)` is essentially the same
    thing as writing `(fn [x] (* 10 x))`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Any function that's created with `partial` can always be rewritten as a function.
    The power of functions such as `partial` is their ability to create new functions
    programmatically. This is where a lot of the power of **functional programming**
    resides.
  prefs: []
  type: TYPE_NORMAL
- en: This is, in fact, the exact same function we've been writing. For now, you don't
    need to worry about `partial`. The other ways of writing functions like this are
    equivalent and sufficient.
  prefs: []
  type: TYPE_NORMAL
- en: Keywords as Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By now, you''re already familiar with using a **keyword** to get a value in
    a map, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: This works because Clojure keywords can be used as functions whose arguments
    are a map. It is also very useful when extracting a single field from a list of
    maps, as we'll see in the next exercise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 4.06: Extracting Data from a List of Maps'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Extracting information from a more complex structure is a common task. We are
    often presented with a sequence of Clojure maps, where each map has multiple keyword
    keys. We need a sequence of the values of just one key, one for each map. Let''s
    say we have a vector containing the players in a game. Each player may be represented
    by a map like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Imagine that the game requires us to get the current points of all the players,
    maybe to calculate an average or to find the maximum and minimum values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Copy the `game-users` vector into your REPL from [https://packt.live/36tHiI3](https://packt.live/36tHiI3).
    It contains a list of maps, with each map containing some information about a
    user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use `map` to return a vector of `:current-points` for each user. To do this,
    we could write something like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Rewrite this expression using a keyword:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The ability to extract lists of data with so little code is one of the benefits
    of the fact that Clojure keywords can also be functions. Shortcuts like this are
    not just convenient or faster to type: they help us write expressive code that
    says exactly what we want.
  prefs: []
  type: TYPE_NORMAL
- en: Sets as Predicates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another common task is to filter based on whether an item is a member of a
    set. Clojure sets are another form of collection that mimic the logic of mathematical
    sets. As a tool in programming, they have two important characteristics:'
  prefs: []
  type: TYPE_NORMAL
- en: An item is either part of a set or not part of a set. This means that there
    are never any duplicates in a set. Adding an item to a set more than once has
    no effect.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The main job of a set is to tell you whether something belongs or not. This
    is why sets can be used as functions, and why they can be useful when combined
    with `filter`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here, we''re defining a set with the `set` function, which takes a list as
    an argument. It can then be used as a function that returns `true` if called on
    a value that is already part of the set, or `false` otherwise. In this example,
    `(alpha-set :z)` returns `false` because `alpha-set` does not contain `:z`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `hash-set` also produces a set. Instead of a sequence, `hash-set` takes
    zero or more individual items as its arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The choice of one over the other will depend on what form of data you have.
    The resulting sets are identical.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The `clojure.set` library is built into Clojure. This extremely useful library
    contains functions for performing set arithmetic, such as intersections.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine we have a list of strings that are animal names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Say we want to remove all the mammals from the list. One solution would be
    to simply test for different values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'This works, but there is a lot of repetitive text. Let''s try using a set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'This is brief, clear, and reads almost like an English sentence: remove `horse`,
    `cat` [from] `animal-names`. There is another advantage, too. Our list of mammals
    to exclude is fairly limited. What happens if we need to update it? We have to
    alter the source code to add more tests. The set, on the other hand, is data,
    so it could be defined once and for all in a variable at the top of our namespace
    or be calculated at runtime from other data available to our program.'
  prefs: []
  type: TYPE_NORMAL
- en: Filtering on a Keyword with comp and a Set
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To compose functions means to create a new function out of one to more existing
    functions. This is what `comp` does. Like `partial`, it is a higher-order function
    that returns a new function. Functional `comp` means that in the returned function,
    each function provided to `comp` will be called on the results of the previous
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say we want to normalize an input string by doing two things: trimming
    whitespace from both ends of the string and converting the string into lowercase.
    The `clojure.string` library provides functions for both of those tasks: `trim`
    and `lower-case`. We could, of course, write a function that does what we need:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The `clojure.string` library is a standard library that provides many familiar
    string manipulation functions such as `split` and `join`. String behavior depends
    on how strings are implemented in the underlying platform, so `clojure.string`
    provides a unified interface that is the same for Clojure and ClojureScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'With `comp`, we can do exactly the same thing with fewer parentheses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'The functional arguments to `comp` are called from right to left. That might
    sound confusing. It means that the functions are called in the same order as if
    they were written out as normal function calls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code is equivalent to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: In both of these functions, `function-a` would be called first, then `function-b`
    on that result, and, finally, `function-c` on the result of that.
  prefs: []
  type: TYPE_NORMAL
- en: 'Composing functions on the fly can be useful whenever you need to define a
    function on the fly. With filter, we could use `comp` to quickly build a predicate.
    Let''s say we need to remove any strings from a list that are present in a normalized
    form set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Using `comp`, we are able to build a function that combines three separate steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 4.07: Using comp and a Set to Filter on a Keyword'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s go back to `game-users` from the previous exercise. This time, we need
    to narrow the scope of the users whose scores we want to calculate. In our imaginary
    game, users can have one of several statuses: `:active`, `:imprisoned`, `:speed-boost`,
    `:pending`, or `:terminated`. We only want scores for players who have the `:pending`
    or `:terminated` statuses. To do this, we will combine the techniques we''ve used
    so far.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The mapping part will stay the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: As in the previous exercise, copy the `game-users` vector into your REPL from
    [https://packt.live/36tHiI3](https://packt.live/36tHiI3).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Define a set with the statuses we want to keep:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Write a function to extract the `:status` field from each map and call the predicate
    on it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'There are several ways we could do this. Maybe the first thing that occurs
    to us would be to write something like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The difficulty here, compared to our previous examples, is that we need to
    do two things at the same time: get the field, and then test it. In this case,
    we could also use the `comp` function, which takes two functions and returns a
    new function, which is the result of calling the first function on the result
    of the second function. So, instead of writing `(fn [player] (statuses (:status
    player)))`, we would write the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use the `->>` threading macro to put the different pieces back together:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The result is uncluttered and easy to read. With a little imagination, it almost
    reads like an English sentence: start with `game-users`, and filter out the users
    whose `:status` is not one of `:active`, `:imprisoned`, or `:speed-boost`, and
    then return the `:current-points` of each of those.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Returning a List Longer than the Input with mapcat
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we've already said, `map` always returns the same number of items as the
    original input sequence. Sometimes, you may need to make a new list with more
    items if, for example, multiple items can be derived from a single input item.
    This is what `mapcat` is for.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a simple example. Suppose we have a list of letters of the alphabet,
    all in lowercase:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll stop at `"j"` to save space, but you get the idea. The output we want
    to obtain is a new list where each lowercase letter is followed by its uppercase
    counterpart. `mapcat` lets us do that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Here, the function we provided returns a two-item vector, such as `["a" "A"]`.
    `mapcat` simply unwraps each of these vectors so that, in the end, you have a
    single, flat list.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Clojure has many interesting, more specialized sequence manipulation functions
    that you may like to explore. We could have solved this problem with `interleave`
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: In situations where you have a one-to-many relationship between each item of
    the input list and the items in the output list, you probably want to consider
    `mapcat` first. Later in this book, we will use `mapcat` in situations where we
    need to flatten a list that contains a mix of individual items and sublists.
  prefs: []
  type: TYPE_NORMAL
- en: Mapping with Multiple Inputs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Among Clojure's sequence functions, `map` is unique in that it can accept more
    than one sequence as input. This can be useful when you need to stitch sequences
    together in some way or derive a combined value of some kind.
  prefs: []
  type: TYPE_NORMAL
- en: 'When `map` has more than one sequence as input, the mapping function must accept
    as many arguments as there are sequences. The basic pattern looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Clojure already has a `zipmap` function that takes two sequences and combines
    them together in a map:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The `into` function is extremely useful when moving data from one collection
    type to another. It can also convert a map into a vector of key-value tuples,
    any sequence into a set, or the other way around.
  prefs: []
  type: TYPE_NORMAL
- en: The mapping function here, `(fn [x y] [x y])`, simply wraps the value pairs
    in a vector, which functions as a `into` function then converts the sequence of
    two-item tuples into a Clojure map.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: A tuple is not a special Clojure data structure. Generally implemented as a
    short vector, a tuple is an alternative to a map with named fields. Instead of
    writing `{:x 5 :y 9}`, it is sometimes simpler to write `[5 9]`. A list is a tuple
    when the position of the items in the list determines what they mean. In theory,
    tuples can be of any length; in practice, if they are longer than three or four
    items, it becomes difficult to remember what each position in the list means.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another reason to use multiple inputs would be if we needed to know the offset
    of the item currently being processed. Let''s say we have a list of strings for
    our daily menu:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'We may want to add a number in front of each item when presenting the list
    to the users. We could use `range` to supply an endless supply of integers to
    match each meal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'The lazy sequence produced by `range` starts at zero, which is great inside
    a computer, but humans prefer lists to start with `1`, so we''ll write `(inc idx)`.
    This pattern is so useful, in fact, that there is already the convenient `map-indexed`
    function that does exactly the same thing. In the end, all we need to write is
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'In the examples so far, the functions supplied to `map` or `filter` only look
    at one item at a time. Even when using `map` with multiple sequences, we are still
    looking at each item separately. With a traditional `for` loop, however, we can
    look ahead or behind. For example, this is something that we may write in JavaScript
    if we had an array of values (`ourValues`) and a function that we wanted to call
    on each value and the next value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'We check to make sure that we aren''t at the last value in the array, and then
    we call `myFunction`. While it would be possible to write more or less the same
    thing in Clojure (and we''ll do some looping in *Chapter 7*, *Recursion II: Lazy
    Sequences*), there is a much more elegant way to do this, that is, by using `map`
    and multiple sequences.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The trick here is to use the same sequence more than once, but with an offset
    so that the second argument in the mapping function contains the item that follows
    the first argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: The second sequence here is, of course, the same as the first one, except that
    we start with the second element. The first time the anonymous function is called,
    its arguments will be the first and second items in `my-sequence`; the second
    time, the arguments will be the second and third items, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram represents this. The list from `0` to `5` is repeated
    with an offset. Each vertical pair corresponds to the two arguments that the mapping
    function will receive:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.5: A windowing or look-ahead effect with map'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14502_04_05.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.5: A windowing or look-ahead effect with map'
  prefs: []
  type: TYPE_NORMAL
- en: When using `map` with multiple collections, `map` stops iterating over them
    when it reaches the end of the shortest sequence. This ensures that there will
    always be enough arguments to supply to the mapping function. Depending on the
    context, when using offsets like this, it may be necessary to append data to the
    other end of the shortened function if it's important that the last item in the
    sequence is included in the results.
  prefs: []
  type: TYPE_NORMAL
- en: If the problem you are solving requires looking farther ahead, you can add more
    offset sequences, and thus more arguments to the mapping function. All sorts of
    creative possibilities are available. Just remember that the shortest sequence
    will limit the number of items that will be mapped over.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If you just need to break up a sequence into multiple parts and then map over
    those, you can just use `partition`. `(partition 2 my-sequence)` will break your
    input up into two-item sublists.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 4.08: Identifying Weather Trends'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we''ll pretend that we have a list of outdoor temperatures
    for a series of days. We want to determine whether each day was warmer, colder,
    or the same as the previous day. This information could then be used to add up
    or down arrows to a visualization. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In your REPL, define a variable with the vector of integers found in [https://packt.live/2tBRrnK](https://packt.live/2tBRrnK):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Write an expression that maps over this vector, starting at the second item,
    `23`, and outputs either `:warmer`, `:colder`, or `:unchanged`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Instead of looking ahead this time, we are really looking backward, so, for
    clarity, we've put `(rest temperature-by-day)` before `temperature-by-day` and
    `today` before `yesterday` in the arguments of the anonymous function. As long
    as you understand which sequence corresponds to which argument, the order doesn't
    really matter. Thanks to the offset between the two versions of the same sequence
    of days, we can compare `yesterday` and `today` to define a trend.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The expression should return the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Remember that our first day corresponds to the second temperature. 23 is warmer
    than 18, so we get `:warmer`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The "windows" that are created by offsetting a sequence against itself can
    be wider than two items: `map` can accept any number of lists.'
  prefs: []
  type: TYPE_NORMAL
- en: The windowing pattern makes `map` even more powerful because it gets around
    one of its inherent limitations. In its simplest form, `map` is limited to a one-to-one
    relationship between the input list and the output list. With windowing, more
    items in the list can participate in each calculation.
  prefs: []
  type: TYPE_NORMAL
- en: Consuming Extracted Data with apply
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Often, when `map` and `filter` are used to target and extract data in the form
    you need, the next step is producing some kind of summary. In *Chapter 7*, *Recursion
    II: Lazy Sequences*, we''ll go into this in much more depth. For now, though,
    we can build some simple summary data by calling a single function, such as `min`
    or `max`, on a list using `apply`.'
  prefs: []
  type: TYPE_NORMAL
- en: Functions such as `min`, `max`, and `+` accept an unlimited number of arguments.
    On the other hand, they don't accept lists. If you have a list of numbers and
    want to find the highest value, you may find yourself thinking "If only I could
    take these numbers out of this list and plug them directly into my call to `max`!"
    Well, with `apply`, you can do just that.
  prefs: []
  type: TYPE_NORMAL
- en: 'In its simplest form, a call to `apply` takes a function and a list, and calls
    the function on the list as if it were a simple multiple-arity function call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'This would be the same as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'There are many situations where this can be useful, even if you do know how
    many arguments you have:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'The `+` function did not appreciate the `nil` that was bound to `b`. With `apply`,
    we can use `filter` to remove any unwanted arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: The `apply` function is an important part of any functional programming toolkit.
    It is especially useful when dealing with sequential data that you can shape with
    `map` and `filter`.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one danger with this technique, however. Many functions that accept
    multiple arguments do not accept zero arguments. The `+` function can actually
    be called without any arguments. If you call `(+)`, it will return `0`. On the
    other hand, `min` and `max` will fail if we `apply` them to an empty list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'In situations like this, it''s important to be sure that an empty list is impossible.
    One way to do that is to supply at least one value. This is made easier by the
    fact that `apply` can accept non-list items before the list argument. This way,
    the call to `min` will always at least have a value of `0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'Exercise 4.09: Finding the Average Weather Temperature'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Using the same weather data as in the previous exercise, we''ll calculate the
    average temperature for the days listed. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Continue using the REPL from the previous exercise or start a new REPL and
    copy the data in from [https://packt.live/2tBRrnK](https://packt.live/2tBRrnK):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use `(apply +…)` and `count` to calculate the sum of the temperatures and count
    them, and then find the average:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Activity 4.01: Using map and filter to Report Summary Information'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In our imaginary game, we want to create a dashboard where users can compare
    themselves to other users in the same situation: active users should only be able
    to see other active users, and so forth. We want to know the maximum and minimum
    values in each case so that the current user can see how they have been placed
    relative to the extremes.'
  prefs: []
  type: TYPE_NORMAL
- en: This means that we need a function that accepts a field name (whichever field
    we want to display), a status (the status of the current user), and a list of
    `game-users`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Write two functions that report the minimum and maximum values for each of
    the numeric fields in `game-users` for all the users and for each status category.
    We want to be able to ask: What is the highest value of `:current-points` for
    all the `:active` users?'
  prefs: []
  type: TYPE_NORMAL
- en: 'The functions should take three arguments: the field we want, the status we
    want, and the list of users. They should be called like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'The call signature of the function will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: For simplicity, you should probably structure your code the same way we have
    done previously, that is, with the threading macro, `->>`, which can chain multiple
    function calls together.
  prefs: []
  type: TYPE_NORMAL
- en: 'These steps will help you complete this activity:'
  prefs: []
  type: TYPE_NORMAL
- en: Use `filter` to narrow down the users who have the status we are looking for.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use `map` to extract the value that you want.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the `min` and `max` functions with `apply` to find the minimums and maximums.
    Make sure your code will still work, even if there aren't any users who have the
    status you are looking for.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following is the expected outcome:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.6: Expected outcome'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14502_04_06.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.6: Expected outcome'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The solution to this activity can be found on page 689.
  prefs: []
  type: TYPE_NORMAL
- en: Importing a Dataset from a CSV File
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we''ve seen some basic patterns for manipulating data, it''s time
    to be more ambitious! We are going to start using a dataset that we will use in
    many of the following chapters as we build up our Clojure knowledge: ATP World
    Tour tennis data, a CSV file that includes, among other things, information about
    professional tennis matches going back to 1871\. Besides learning about new concepts
    and techniques, we will see that Clojure can be an interesting choice for exploring
    and manipulating large datasets. And, naturally, most of the datasets that are
    available to us are CSV files.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This dataset was created and is maintained at [https://packt.live/2Fq30kk](https://packt.live/2Fq30kk),
    and is available under the Creative Commons 4.0 International License. The files
    that we'll be using here are also available at [https://packt.live/37DCkZn](https://packt.live/37DCkZn).
  prefs: []
  type: TYPE_NORMAL
- en: In the rest of this chapter, we will import tennis match data from a CSV file
    and use our mapping and filtering techniques to extract interesting data from
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 4.10: Importing Data from a CSV File'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It''s time to imagine that you work for a sports journalism website specializing
    in data-centric reporting. Your role is to help the journalists analyze data and
    produce interesting visualizations for the site. In your new job, you need to
    be able to import large datasets that are usually published as CSV. Let''s get
    started:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a folder somewhere convenient on your computer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Download the `match_scores_1991-2016_UNINDEXED.csv` file to the folder you created.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In your editor, in the same folder, create a `deps.edn` file with the following
    contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: These are references to two libraries that we will use extensively. The first
    one, `clojure.data.csv`, is lower-level tool and deals with the mechanics of getting
    data in and out of a `.csv` file. `semantic-csv`, on the other hand, is a higher-level
    tool that makes it easier to work with `.csv` data.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Still in the same folder, with your editor or IDE, start a Clojure REPL.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Verify that everything is working by evaluating the following expression in
    your REPL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`clojure.data.csv` returns a vector of strings for each line in the file. This
    is the first line of the file, which is, of course, the column headers.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'When exploring a new dataset, it''s always good to know the size of the data.
    We can use `count` here to check that:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: These are the basics of opening and reading a CSV file in Clojure. All the other
    data analysis techniques we will examine will use this same basic pattern. But
    before we go any further, we need to take a look at lazy evaluation.
  prefs: []
  type: TYPE_NORMAL
- en: Real-World Laziness
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Did you notice how the code you evaluated in the previous exercise was rather
    fast? The data file is quite long, and it seems like it would take a long time
    to parse it. But `parse-csv` is lazy. Because we only asked for the first result,
    the evaluation stopped after one line. This is convenient because it allows us
    to process large files without loading them into memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because we are dealing with files, we have to be careful. Remember that lazy
    evaluation means that evaluation is deferred until it is needed. That is fine
    for sequences of integers, but with an external resource such as a file reader,
    if we wait too long, the resource may not be available anymore. To avoid problems,
    we will do two things:'
  prefs: []
  type: TYPE_NORMAL
- en: Most of our data work will happen inside the scope of the `with-open` macro.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We won't return any lazy sequences from the `with-open` macro.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In other words, inside the scope of `with-open`, we can use and combine all
    the lazy evaluation techniques we like. When we return sequences, we'll make sure
    that they are fully realized, often using the `doall` function. It may be tempting
    to immediately call `doall` to avoid having to worry about lazy evaluation at
    all. While there are cases where this may be appropriate, it is best to try to
    resist this temptation. Reading a large CSV file is a good example of why preserving
    the laziness of sequences is important. Calling `doall` too soon would force all
    of the rows of data to be loaded into memory, when maybe we only need a few rows.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at this in practice.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 4.11: Avoiding Lazy Evaluation Traps with Files'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the previous exercise, you successfully opened a CSV file and started to
    play with it a little bit. "It''s time," you say to yourself, "to look at some
    real data." The incoming data appears to be a sequence, since we can use `first`
    and `count` on it. Let''s try to extract some more data:'
  prefs: []
  type: TYPE_NORMAL
- en: In the same folder as before, open your REPL again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If necessary, load the dependencies again:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s try to extract the name of the winner of each of the first five matches.
    Starting from 0, the `winner_name` field is number `7`, so we want to call `#(nth
    % 7)` on each of the first five lines (after the initial header line). Maybe this
    will work:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: What happened? As the error message suggests, the file stream is closed when
    the REPL tries to print the results. `map` and `take` are both lazy. But why?
    We call `map` and `take` *inside* the scope of `with-open`. Shouldn't the file
    still be open? The problem is that because the evaluation is deferred, it has
    not happened yet when we exit the scope of the `with-open` macro. All we have
    at that point is an unevaluated sequence. When the REPL tried to evaluate the
    lazy expression returned by `take`, the scope where the file reader was available
    disappeared. Lazy sequences are not evaluated until they are consumed, and in
    this case, the sequence is consumed in your REPL.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, try again with `doall`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This time, you should see something like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can see, `doall` forces the evaluation of the lazy sequence. The closed
    stream is no longer a problem. The expression returns a simple list.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'While working with this dataset, we will use this basic pattern many times,
    often ending with `doall`. You can also see how it reproduces a familiar pattern:
    get the information (`csv/read-csv`), shape the information (`map, take`), and
    hand the information off (`doall`). Lazy evaluation combined with limited external
    resources, such as file I/O, in this case, does add an extra challenge. Maintaining
    a clear separation between data acquisition, data manipulation, and data output
    is not only good design or good practice—in a situation like this, it will really
    help avoid errors and bugs. Even in this case, however, there is an upside to
    lazy evaluation: some files may be too large to fit in memory. By evaluating the
    output from the file "lazily," the entire file doesn''t need to be loaded into
    memory simultaneously.'
  prefs: []
  type: TYPE_NORMAL
- en: You've now extracted some real data from the `.csv` file.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'Clojure''s `mapv` function is a replacement for `map`, with one key difference:
    instead of returning a lazy sequence, it returns a vector. Because vectors are
    not lazy, this can be a way of avoiding a call to `doall`. For clarity, however,
    it is often preferable to use `doall` explicitly.'
  prefs: []
  type: TYPE_NORMAL
- en: Convenient CSV Parsing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you can see from the previous example, `clojure.data.csv` returns a sequence
    of vectors, where each vector contains, as individual strings, the CSV files in
    a single line of the original file. There is still some work to do before we can
    really use that data, however. Because `.csv` is such a common format, there are
    libraries that can make things a little bit more convenient. We'll be using `semantic-csv`,
    which we've already included in our `deps.edn` file.
  prefs: []
  type: TYPE_NORMAL
- en: The main functions that we'll use from `semantic-csv` are `mappify` and `cast-with`.
    With `mappify`, each row becomes a Clojure map, where the keys are the column
    names from the CSV file, and with `cast-with`, we can transform strings containing
    numeric values in the source file into the correct types.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see how this works. After that, we'll be ready to do some more interesting
    things with the data in our `.csv` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 4.12: Parsing CSV with semantic-csv'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we''ll start by saving our work in a file so that we can
    come back to it later. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: In the same folder as before, create a new file, `tennis.clj`, in your text
    editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set up your namespace and use `:require` so that you have access to the necessary libraries:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Write a function that returns the first row of data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Evaluate your file, move to the `packt-clj.tennis` namespace in your REPL,
    and call the function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You should see a map with the data for the first match:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'That''s a lot of information. We don''t need all of those fields, so we''ll
    call `select-keys` on each `map` to keep only the values that interest us. This
    time, we''ll keep the first five rows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Evaluate your file again, and then call `five-matches` in the REPL:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You should see a list of maps:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To use the `:winner_sets_won` and `:loser_sets_won` fields in a calculation
    of some kind, we need to cast them as integers first. Use the `cast-with` function
    of `semantic-csv`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will return the same data as the previous function, except that the values
    for `:winner_sets_won` and `:loser_sets_won` won''t appear with quotation marks
    anymore:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, we have enough tools to start performing some interesting queries against
    our dataset. With `map`, `filter`, and a few simple tools, we are ready to write
    simple, yet sophisticated, queries. In the next section, we are going to look
    at some techniques that will be useful in their own right and will help you to
    think about using functions to describe the data you want.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 4.13: Querying the Data with filter'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If we think of this CSV data as a database, then writing queries is a question
    of writing and combining predicates. In this exercise, we will use `filter` to
    narrow our dataset down to the exact information we want. Imagine that the journalists
    on your team are working on a new project dedicated to famous tennis rivalries.
    As a first step, they''ve asked you to produce a list of all the tennis matches
    won by Roger Federer. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: Make sure that your project is set up the same way as it was in the previous
    exercises.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a function called `federer-wins` that provides the CSV processing steps
    we''ve already used. Add the calls to `select-keys` and `doall`, which will be
    applied to the data once it has been narrowed down:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Write a predicate that will decide whether Roger Federer won a match. Using
    the same pattern as in the previous examples, all we need to do is "plug in" a
    call to `filter` with the right predicate.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The predicate itself is rather simple. It''s just a question of matching one
    of the fields of each map:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use this predicate with `filter` in the function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Try calling `federer-wins`. You will receive the following output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 4.7: Printing the details'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14502_04_07.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.7: Printing the details'
  prefs: []
  type: TYPE_NORMAL
- en: This seems to work!
  prefs: []
  type: TYPE_NORMAL
- en: This exercise shows how writing a query is as simple as writing a new predicate.
    You have all the power and flexibility of the Clojure language at hand to describe
    exactly what results you need. In the next exercise, we will use a higher-order
    functional technique to write a dedicated query function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 4.14: A Dedicated Query Function'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Your team is happy with the initial results and now they have started asking
    you to run new queries all the time. You are tired of writing the same code each
    time, so you''ve decided to write a function that can accept any predicate. Let''s
    get started:'
  prefs: []
  type: TYPE_NORMAL
- en: Use the same environment as in the previous exercise.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Rewrite the `federer-wins` function as `match-query`, which takes a second
    argument, that is, `pred`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Write a predicate to search for all of Federer's matches, wins, and losses.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'One possibility would be to simply add an `or` operator:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We could also use a set as a predicate, as we saw earlier:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'First, we define a set that includes the `:winner_name` and `:loser_name` fields
    and then we ask: is `Roger Federer` a member of that set?'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We've written `hash-set` here instead of using the literal notation, `#{…}`,
    to avoid confusion with the `#(…)` of the anonymous function. `hash-set` and `set`
    do the same thing, that is, they create Clojure sets, except that `set` takes
    a single collection as an argument, while `hash-set` takes any number of items.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Test this by counting the number of matches played and the number of matches
    won using the predicate from the previous exercise:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.8: Number of matches played and won by Federer'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14502_04_08.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.8: Number of matches played and won by Federer'
  prefs: []
  type: TYPE_NORMAL
- en: Now, we know that, in our dataset, Federer played `1,290` matches and won `1,050`
    times!
  prefs: []
  type: TYPE_NORMAL
- en: Providing a predicate as an argument makes writing queries like this very convenient.
    It becomes easier to write more and more complex queries. In the next exercise,
    we will continue to build on this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 4.15: Using filter to Find a Tennis Rivalry'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As your team''s deadline approaches, the journalists are asking for more and
    more specific queries. They''ve decided to write an article about one of the most
    famous rivalries in modern tennis, that is, between Roger Federer and Rafael Nadal.
    They want you to write two queries: the first should return all the matches between
    the two players, while the second should return only the matches where the score
    was very close. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: Use the same environment as the previous exercises.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Write a predicate that will select all the matches between the two players.
    One possibility would be to use `or`, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This would work, but you can see that the logic is getting more complex because
    we have to account for two different possibilities. This is where sets can be
    very useful:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Sets are great for these kinds of situations. We don't care about the order,
    or, unlike the players themselves, which one is the winner or the loser.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Test this predicate using the `match-query` function from the previous exercise:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 4.9: Testing the predicate'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14502_04_09.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 4.9: Testing the predicate'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This seems to work. Now, we need to narrow down the results to the closest matches.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Update `match-query` so that we can do arithmetic on the fields. To know whether
    a match was close, we need to be able to subtract `:loser_sets_won` from `:winner_sets_won`.
    We have a problem, though: the values are strings here and not integers, so we
    can''t subtract. To fix this, we need to go back to `match-query` and reintroduce
    the type conversions that we used in the previous exercises. Here''s the new version
    of `match-query`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Write a predicate for close matches.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We''ll use `and` to combine the Federer-Nadal predicate with a test for the
    difference in sets won:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s test our new predicate:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.10: Printing the results'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14502_04_10.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.10: Printing the results'
  prefs: []
  type: TYPE_NORMAL
- en: The results tell the story of one of the great rivalries in sports!
  prefs: []
  type: TYPE_NORMAL
- en: 'As long as we are searching for lists of results, `map`, `filter`, and some
    carefully crafted predicates can accomplish a lot: `map` prepares the data while
    `filter` finds the items we are looking for.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 4.02: Arbitrary Tennis Rivalries'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Your data consultancy team is encouraged by what they could learn by looking
    at the Federer-Nadal rivalry data and they want to be able to expand the approach.
    They've asked you to write a function that will find some summary statistics about
    all the matches between any two players. They would also like to have a list of
    the most competitive matches between the players.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the tennis dataset, write a function that provides information about
    a tennis rivalry. The call signature should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: 'The function should return a map with the following fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: The values in the `:total-*` fields should be integers. The other fields should
    be (possibly empty) lists of matches. When displaying matches in the results,
    limit the fields to those displayed in the previous example, that is, `:winner_name`,
    `:loser_name`, `:winner_sets_won`, `:loser_sets_won`, `:winner_games_won`, `:loser_games_won`,
    `:tourney_year_id`, and `:tourney_slug`.
  prefs: []
  type: TYPE_NORMAL
- en: Save your function in the same file that you did for *Exercise 4.12*, *Parsing
    CSV with semantic-csv*.
  prefs: []
  type: TYPE_NORMAL
- en: 'These steps will help you to complete this activity:'
  prefs: []
  type: TYPE_NORMAL
- en: Don't forget to use the same calls to `sc/mappify` and `sc/cast-with` to make
    your data easy to work with.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Within the scope of a `with-open` macro, use `let` to bind the lazy sequence
    of all the matches between the two players to a local symbol. Use that binding
    later whenever you need to match data, rather than rereading from the `.csv` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To calculate each result field, you will need to filter the list of matches
    in a different way.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For the `:total-*` fields, obtain the correct sequences and then use `count`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For the fields that show matches, use `select-keys` to keep only the fields
    we are interested in.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following is the expected outcome:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For any two players who have actually played against each other, your function
    should produce summary data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The solution to this activity can be found on page 691.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have looked at how to use two of Clojure's most important
    and useful functions for handling sequential data. From a practical point of view,
    you have seen how to use `map` and `filter`, as well as some patterns and idioms
    for accomplishing common tasks and avoiding some common problems. You are starting
    to build your mental toolkit for working with collections.
  prefs: []
  type: TYPE_NORMAL
- en: Working with `map` and `filter` means we are working with lazy sequences, and
    so this chapter explored some of the ins and outs of lazy evaluation, which is
    one of Clojure's fundamental building blocks.
  prefs: []
  type: TYPE_NORMAL
- en: The techniques for reading and parsing files, extracting, querying, and manipulating
    data will also be useful right away as we continue to build on these data-handling
    techniques in the next chapter.
  prefs: []
  type: TYPE_NORMAL
