- en: 4\. Mapping and Filtering
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4. 映射和过滤
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: 'In this chapter, we will begin our exploration of how to use sequential collections
    in Clojure by taking a look at two of the most useful patterns: mapping and filtering.
    We will work with the map and filter functions and handle sequential data without
    using a for loop. We will also use common patterns and idioms for Clojure collections
    and take advantage of lazy evaluation while avoiding the traps. We will load and
    process sequential datasets from **Comma-Separated Values** (**CSV**) files and
    extract and shape data from a large dataset.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将通过查看两个最实用的模式：映射和过滤，开始探索如何在Clojure中使用顺序集合。我们将使用map和filter函数处理顺序数据，而不使用for循环。我们还将使用Clojure集合的常见模式和习惯用法，并利用惰性求值，同时避免陷阱。我们将从**逗号分隔值**（**CSV**）文件中加载数据并处理顺序数据集，从中提取和形塑数据。
- en: By the end of this chapter, you will be able to parse datasets and perform various
    types of transformations to extract and summarize data.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，你将能够解析数据集并执行各种类型的转换以提取和总结数据。
- en: Introduction
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Dealing with collections of data is one of the most common and powerful parts
    of programming. Whether they are called lists, arrays, or vectors, sequential
    collections are at the heart of almost every program. Every programming language
    provides tools for creating, accessing, and modifying collections, and, often,
    what you've learned in one language will apply to the others. Clojure is different,
    however. We are accustomed to setting a variable and then controlling some other
    part of the system by changing the value of that variable.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 处理数据集合是编程中最常见且功能强大的部分之一。无论它们被称为列表、数组还是向量，顺序集合几乎存在于每个程序的核心。每种编程语言都提供了创建、访问和修改集合的工具，而且通常，你在一种语言中学到的知识也会适用于其他语言。然而，Clojure却有所不同。我们习惯于设置一个变量，然后通过改变该变量的值来控制系统的其他部分。
- en: This is what happens in a `for` loop in most procedural languages. Say that
    we have an iterator, `i`, that we increment by calling `i++`. Changing the value
    of the iterator controls the flow of the loop. By executing `i = i + 3`, we can
    make the loop skip two iterations. The value of `i` is like a remote control for
    the loop. In case we increment the iterator by three, what happens if we are just
    one item away from the end of the array we are looping over? The remote control
    doesn't prevent us from making mistakes with it.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在大多数过程式语言中的`for`循环中发生的情况。假设我们有一个迭代器`i`，我们通过调用`i++`来增加它的值。改变迭代器的值控制着循环的流程。通过执行`i
    = i + 3`，我们可以使循环跳过两个迭代。`i`的值就像循环的遥控器。如果我们正在遍历的数组只差一个元素就到末尾，而我们通过增加迭代器三个单位，会发生什么？遥控器并不能阻止我们用错它。
- en: Clojure has a completely different approach. It may take some practice and some
    experience to get used to it, depending on what kinds of programming you've done
    before. With Clojure, it's helpful to think of the functions you write as a way
    of describing the shape of the data we want to have. Often, you will need to reshape
    the data in several steps to get it to where you need it to go. Rather than using
    data, such as the iterator we mentioned previously, to keep track of the internal
    state of the program, Clojure invites you to write the functions that will be
    the bridge between the data you have and the data you want. That's at least one
    way of thinking about it.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Clojure有完全不同的方法。根据你之前做过什么样的编程，可能需要一些练习和一些经验才能习惯它。在Clojure中，将你编写的函数视为描述我们想要的数据形状的方法是有帮助的。通常，你需要分几个步骤重塑数据，才能使其达到所需的位置。而不是使用像我们之前提到过的迭代器这样的数据来跟踪程序的内部状态，Clojure鼓励你编写将是你所拥有的数据和所希望的数据之间的桥梁的函数。这至少是一种思考方式。
- en: 'From a 30,000-foot perspective, the fundamental pattern of Clojure programs
    is as follows:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 从30,000英尺的高度来看，Clojure程序的基本模式如下：
- en: Get the data.
  id: totrans-9
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取数据。
- en: Shape the data.
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 形塑数据。
- en: Do something with the data.
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对数据做些处理。
- en: The traditional `for` loop tends to roll these three phases into one. A typical
    example would be a `for` loop that reads a row of data from a database or a file
    (*get the data*), does some computations (*shape the data*), and writes data back
    or sends it somewhere else (*do something*), and then starts over again with the
    next row. A good design in Clojure usually means separating these three steps
    and moving as much logic as possible into the middle, which is the data-shaping
    step.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的 `for` 循环往往将这三个阶段合并为一个。一个典型的例子是一个 `for` 循环，它从数据库或文件中读取一行数据（*获取数据*），进行一些计算（*处理数据*），然后将数据写回或发送到其他地方（*执行操作*），然后从头开始处理下一行。在
    Clojure 中，良好的设计通常意味着将这些三个步骤分开，尽可能地将逻辑移动到中间，也就是数据处理步骤。
- en: The techniques that we'll cover in this chapter will help you do that.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中我们将介绍的技巧将帮助您做到这一点。
- en: Note
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Clojure does have a `for` macro, but it is used for list comprehensions, which
    you can think of as an alternate syntax for many of the patterns in this chapter.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Clojure 确实有一个 `for` 宏，但它用于列表推导式，您可以将其视为本章中许多模式的替代语法。
- en: This approach to coding makes Clojure an excellent language for doing complicated
    things with complex data as simply as possible. Learning a functional approach
    to data collections is not just for processing large datasets, however. Clojure
    programs often tend to be data-centric, regardless of how much data they are actually
    processing. Much of the important work in a Clojure program is done by shaping
    your data, big or small. The techniques and patterns you'll learn about in this
    chapter will help you write any kind of Clojure code.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这种编码方法使得 Clojure 成为一个在尽可能简单的情况下处理复杂事物的优秀语言。学习数据集合的函数式方法不仅适用于处理大型数据集。Clojure
    程序通常倾向于以数据为中心，无论它们实际上处理多少数据。在 Clojure 程序中，大部分重要工作是通过处理数据（无论大小）来完成的。在本章中，您将学习的技巧和模式将帮助您编写任何类型的
    Clojure 代码。
- en: The `map` and `filter` functions are fundamentally quite simple, as you'll soon
    see. In this chapter, we will focus on how to use them to solve problems. At the
    same time, learning about `map` and `filter` and, more generally, how to handle
    sequential data, means learning lots of new things about the Clojure ecosystem
    – things such as immutability, lazy sequences, or the basics of functional programming.
    Toward the end of this chapter, we will start to use the techniques we learned
    along the way to manipulate a larger dataset, composed of the results of years
    and years of professional tennis matches. In subsequent chapters, we will continue
    to build on our experience with this data as we learn more and more about Clojure.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`map` 和 `filter` 函数在本质上非常简单，您很快就会看到。在本章中，我们将重点介绍如何使用它们来解决问题。同时，了解 `map` 和 `filter`
    以及更一般地如何处理序列数据，意味着您将学习到关于 Clojure 生态系统的大量新知识——例如不可变性、惰性序列或函数式编程的基础。在本章的结尾，我们将开始使用我们在旅途中学到的技术来操作一个更大的数据集，这个数据集由多年专业网球比赛的结果组成。在随后的章节中，我们将继续在这个数据集上构建我们的经验，随着我们对
    Clojure 了解得越来越多。'
- en: map and filter
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: map 和 filter
- en: The `map` and `filter` functions are a key part of a much larger group of functions
    for dealing with sequences. Of that group, `map` is certainly the one you will
    use the most, and `filter` is a close second. Their role is to modify sequences.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`map` 和 `filter` 函数是处理序列的更大函数组的关键部分。在该组中，`map` 是您将使用最多的一个，而 `filter` 则紧随其后。它们的作用是修改序列。'
- en: 'They accept one or more sequences as input, and return a sequence: *sequence
    in*, *sequence out*:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 它们接受一个或多个序列作为输入，并返回一个序列：*输入序列*，*输出序列*：
- en: '![Figure 4.1: A schematic diagram of map and filter working together'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.1：map 和 filter 一起工作的示意图'
- en: '](img/B14502_04_01.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B14502_04_01.jpg]'
- en: 'Figure 4.1: A schematic diagram of map and filter working together'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1：map 和 filter 一起工作的示意图
- en: In the preceding diagram, we can see `map` and `filter` working together, where
    `filter` eliminates items from the original list while `map` changes them.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，我们可以看到 `map` 和 `filter` 一起工作，其中 `filter` 从原始列表中删除项目，而 `map` 则改变它们。
- en: 'The first question to ask when solving a problem involving collections is:
    "Do I want to obtain a list of values, or a single value?" If the answer is a
    list, then `map`, `filter`, or similar functions are what you need. If you need
    some other kind of value, the solution is probably a reduction of some kind, which
    we will discuss in the next chapter. But even then, as you break the problem down,
    there is a good chance that some component parts of the problem will require sequence-manipulating
    functions such as `map` and `filter`. If, for example, the problem at hand involves
    searching in a list of items for sale, perhaps `filter` would allow you to narrow
    the scope of the search to a certain category or price range. Then, you may use
    `map` to calculate a derived value for each item – maybe the item''s volume in
    cubic centimeters or the number of commentaries it has received on a website.
    And then, finally, you may extract the single item you are seeking, or the summary
    data that you need, from this transformed list.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 解决涉及集合的问题时，首先要问的问题是：“我想要获得一个值的列表，还是一个单一值？” 如果答案是列表，那么 `map`、`filter` 或类似函数就是你需要的东西。如果你需要其他类型的值，解决方案可能是某种形式的归约，我们将在下一章讨论。但即使在这种情况下，当你分解问题，有很大可能性问题的一些组成部分将需要像
    `map` 和 `filter` 这样的序列操作函数。例如，如果当前的问题涉及在一个销售物品列表中进行搜索，也许 `filter` 可以让你将搜索范围缩小到某个类别或价格范围。然后，你可以使用
    `map` 为每个项目计算一个派生值——可能是项目的体积（以立方厘米为单位）或网站上的评论数量。然后，最后，你可以从这个转换后的列表中提取你正在寻找的单个项目，或者你需要的数据摘要。
- en: To get started, let's take a closer look at `map` and `filter` separately, before
    looking at how we will use them together.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，让我们先单独看看 `map` 和 `filter`，然后再看看我们将如何一起使用它们。
- en: map
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: map
- en: 'Like the majority of Clojure''s functions for working with sequences, the first
    argument of map is always a function. The function we provide will be called on
    each item in the sequence that we will iterate over. Here is a very simple use
    of `map` that uses Clojure''s `inc` function to add 1 to each value in the input
    sequence:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Clojure 的大多数序列处理函数一样，`map` 的第一个参数总是函数。我们提供的函数将应用于我们将要迭代的序列中的每个项目。以下是一个使用 Clojure
    的 `inc` 函数将 1 加到输入序列中每个值上的非常简单的 `map` 使用示例：
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The return value of each call to the `inc` function becomes a value in the new
    sequence that `map` returns.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 每次调用 `inc` 函数的返回值都成为 `map` 返回的新序列中的一个值。
- en: Note
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The `map` function can take more sequences as arguments, as we'll see shortly.
    Like many of the sequence-handling functions, there is a single-argument form
    of `map`. When `map` is called with just one argument, that is, the function,
    it returns a special function called a `map`, the Clojure compiler won't complain
    about not having enough arguments. Instead, you'll see a strange error about a
    function that you don't remember writing. That function is the transducer you've
    produced by mistake.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`map` 函数可以接受更多的序列作为参数，我们很快就会看到。像许多序列处理函数一样，`map` 有一个单参数形式。当 `map` 只用一个参数调用时，即函数，它返回一个特殊函数，称为
    `map`，Clojure 编译器不会因为参数不足而抱怨。相反，你会看到一个关于你记得没有写过的函数的奇怪错误。那个函数就是你错误产生的转换器。'
- en: 'Exercise 4.01: Working with map'
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 4.01：使用 map
- en: 'Let''s get started! In this exercise, we''ll use `map` on a list of integers
    to obtain different kinds of results:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！在这个练习中，我们将使用 `map` 对一个整数列表进行操作，以获得不同类型的结果：
- en: 'Try this in your REPL:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的 REPL 中尝试以下操作：
- en: '[PRE1]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The output is as follows:'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE2]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This call to `map` simply applied the anonymous function known as `(fn [i]
    (* i 10))` to the list of integers, multiplying each one by 10\. In doing so,
    we end up with a new list of integers, one for each of the integers in the original
    input:'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个 `map` 调用简单地应用了名为 `(fn [i] (* i 10))` 的匿名函数到整数列表上，将每个数乘以 10。在这个过程中，我们最终得到一个新整数列表，每个整数对应于原始输入中的一个整数：
- en: '![Figure 4.2: Mapping one sequence to another'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 4.2：将一个序列映射到另一个序列'
- en: '](img/B14502_04_02.jpg)'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B14502_04_02.jpg)'
- en: 'Figure 4.2: Mapping one sequence to another'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 4.2：将一个序列映射到另一个序列
- en: This one-to-one equivalence is obvious, but it is also a key feature of `map`.
    With `map`, the sequence of results is always exactly the same length as the input
    sequence so that each value in the input maps to the corresponding value in the
    result sequence, hence the name.
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这种一对一的等价性很明显，但这也是 `map` 的一个关键特性。使用 `map`，结果的序列长度总是与输入序列完全相同，这样输入中的每个值都会映射到结果序列中的对应值，因此得名。
- en: 'Let''s measure word length now. When working with sequences, Clojure''s `count`
    function is invaluable. Since Clojure considers a string to be a sequence of characters,
    `count` can also be used to find the length of a string:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们现在测量单词长度。当与序列一起工作时，Clojure 的 `count` 函数非常有价值。由于 Clojure 将字符串视为字符序列，因此 `count`
    也可以用来查找字符串的长度：
- en: '[PRE3]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You should see the length of each word:'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你应该看到每个单词的长度：
- en: '[PRE4]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'To make our output easier to read, we could add the word along with its length:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使输出更容易阅读，我们可以添加单词及其长度：
- en: '[PRE5]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The output is as follows:'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE6]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This example, of course, just scratches the surface of the different applications
    of `map`. At the same time, it shows how simple the concept of mapping really
    is: for each value in a list, produce a new value in a new list.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这个例子只是触及了 `map` 的不同应用表面。同时，它展示了映射概念的实际简单性：对于列表中的每个值，在新的列表中产生一个新的值。
- en: filter
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: filter
- en: 'Unlike `map`, `filter` can, and often does, produce a sequence of results containing
    fewer items than the input sequence. A call to `filter` looks basically like a
    call to `map`:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `map` 不同，`filter` 可以，并且通常会产生比输入序列更短的序列结果。对 `filter` 的调用基本上类似于对 `map` 的调用：
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Like in `map`, the function that's supplied as the first argument to `filter`
    is called on each item in the sequence. The difference is that, in this case,
    the function is being used as a `true` or `false`. When a **truthy** value is
    returned, that item will be included in the sequence of results.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `map` 一样，传递给 `filter` 的第一个参数作为函数对序列中的每个项目进行调用。区别在于，在这种情况下，该函数被用作 `true` 或
    `false`。当返回一个 **真值** 时，该项目将被包括在结果序列中。
- en: One key difference with `map` is that the predicate that's provided to `filter`
    only serves to decide whether the given item should be included or not. It does
    not change the items in any way. The result set of `filter` is always a subset
    of the input set.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `map` 的一个关键区别是，提供给 `filter` 的谓词仅用于决定给定的项目是否应该被包含。它不会以任何方式更改项目。`filter` 的结果集始终是输入集的子集。
- en: 'Exercise 4.02: Getting Started with filter'
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 4.02：开始使用 filter
- en: 'In this exercise, we''ll use `filter` on a list of integers to obtain different
    kinds of results. Let''s get started:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将使用 `filter` 对整数列表进行操作以获得不同类型的结果。让我们开始吧：
- en: 'The `odd?` function is a predicate that returns `true` if a number is `odd`.
    Try it by itself in the REPL:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`odd?` 函数是一个谓词，如果数字是奇数则返回 `true`。在 REPL 中单独尝试它：'
- en: '[PRE8]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The output is as follows:'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE9]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, try passing an even number as input:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，尝试传递一个偶数作为输入：
- en: '[PRE10]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The output is as follows:'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE11]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, use `odd?` with `filter`:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用 `odd?` 与 `filter` 结合使用：
- en: '[PRE12]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The output is as follows:'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE13]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We could also use the alter ego of filter, `remove`, which does the exact inverse
    of `filter`. When the predicate returns `true`, the item is removed:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还可以使用过滤器的替代品 `remove`，它执行 `filter` 的相反操作。当谓词返回 `true` 时，项目将被移除：
- en: '[PRE14]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The output is as follows:'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE15]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Here is how we can visualize what `filter` does:'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 下面是如何可视化 `filter` 的操作：
- en: '![Figure 4.3: The filter function uses a predicate to define a new sequence'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 4.3：过滤器函数使用谓词定义新的序列'
- en: '](img/B14502_04_03.jpg)'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![img/B14502_04_03.jpg]'
- en: 'Figure 4.3: The filter function uses a predicate to define a new sequence'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 4.3：过滤器函数使用谓词定义新的序列
- en: 'With `filter`, we are limiting the original sequence, but the result is always
    a sequence. Consider these two extreme cases where each predicate always returns
    a single value (Clojure''s `constantly` function returns a function that does
    nothing but return a single value, regardless of the number of arguments that
    are passed to it):'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `filter`，我们正在限制原始序列，但结果始终是一个序列。考虑这两种极端情况，其中每个谓词始终返回单个值（Clojure 的 `constantly`
    函数返回一个函数，该函数不做任何事情，只是返回一个值，无论传递给它多少参数）：
- en: '[PRE16]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Whether we keep everything or nothing, `filter` *always* returns a sequence.
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 无论我们保留一切还是什么都不保留，`filter` *总是* 返回一个序列。
- en: 'Like `map`, `filter` is conceptually very simple: using a predicate, keep some
    or all of the items in a list. Despite this simplicity, or thanks to it, `filter`
    is an extremely useful function that can be used in countless circumstances.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `map` 一样，`filter` 在概念上非常简单：使用谓词，保留列表中的某些或所有项目。尽管这种简单性，或者正因为这种简单性，`filter`
    是一个非常有用的函数，可以在无数情况下使用。
- en: Other Members of the filter Family – take-while and drop-while
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 过滤器家族的其他成员 – take-while 和 drop-while
- en: 'The `take-while` and `drop-while` functions follow the same logic as `filter`
    and `remove` – at least as far as their use of a predicate goes. The difference
    is that they only operate at the beginning of a sequence, much like `take` and
    `drop`. The `take` function returns the first `n` items of a list, while `drop`
    returns the original list minus the first `n` items:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`take-while`和`drop-while`函数的逻辑与`filter`和`remove`相同——至少就它们使用谓词而言。区别在于它们只操作序列的起始位置，就像`take`和`drop`一样。`take`函数返回列表的前`n`个项，而`drop`返回原始列表减去前`n`个项：'
- en: '[PRE17]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Similarly, `take-while` starts at the beginning of the list and returns all
    the items as long as they satisfy the predicate, while `drop-while` removes those
    same items from the beginning of the sequence:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，`take-while`从列表的起始位置开始，只要满足谓词就返回所有项目，而`drop-while`则从序列的起始位置移除这些相同的项：
- en: '[PRE18]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Perhaps the most obvious application of `take-while` and `drop-while` is to
    subdivide sorted data. We can even use them together to find the exact point in
    a sequence where a predicate stops returning `true` and starts returning `false`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`take-while`和`drop-while`最明显的应用可能是对排序数据的细分。我们甚至可以将它们一起使用来找到序列中谓词停止返回`true`并开始返回`false`的确切点。'
- en: 'Exercise 4.03: Partitioning a Sequence with take-while and drop-while'
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习4.03：使用`take-while`和`drop-while`对序列进行分区
- en: 'We have a sorted list of students that we''d like to separate into two groups:
    those born before the year 2000 and those born after. Let''s get started:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个按顺序排列的学生列表，我们希望将其分为两组：在2000年之前出生的和在之后出生的。让我们开始吧：
- en: 'In your REPL, define a `students` variable. You can copy the list from this
    course''s GitHub repository at [https://packt.live/2sQyVYz](https://packt.live/2sQyVYz):'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的REPL中定义一个`students`变量。你可以从这个课程的GitHub仓库复制列表：[https://packt.live/2sQyVYz](https://packt.live/2sQyVYz)：
- en: '[PRE19]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Write a predicate that translates the idea `before 2000`:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个谓词来翻译“在2000年之前”的概念：
- en: '[PRE20]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This anonymous function extracts the `:year` value from the student map and
    compares it to `2000`.
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个匿名函数从学生映射中提取`:year`值，并将其与`2000`进行比较。
- en: 'Use the predicate with `take-while` to find the students born before 2000:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用谓词与`take-while`一起查找在2000年之前出生的学生：
- en: '[PRE21]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Use the same predicate with `drop-while` to find the students born in 2000
    or after:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用相同的谓词与`drop-while`一起查找在2000年或之后出生的学生：
- en: '[PRE22]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: You won't use the `take-while` and `drop-while` functions as much as `filter`
    itself, but they can be very useful in certain circumstances. Like `filter`, they
    are useful tools for shaping sequences.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 你不会像使用`filter`本身那样经常使用`take-while`和`drop-while`函数，但它们在特定情况下可能非常有用。像`filter`一样，它们是塑造序列的有用工具。
- en: Using map and filter Together
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用map和filter一起使用
- en: 'Much of the power of Clojure''s sequence functions comes from combining them.
    Let''s combine the previous examples. How would we obtain a sequence such as 10,
    30, 50 from 1, 2, 3, 4, 5? It''s just a question of applying our functions in
    the right order. If we multiply by 10 first, all the resulting integers will be
    even. To meaningfully filter out the odd numbers, we have to do this first. Consider
    the following example:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: Clojure序列函数的大部分功能都来自于它们的组合。让我们结合前面的例子。我们如何从1, 2, 3, 4, 5得到一个如10, 30, 50的序列？这只是一个关于按正确顺序应用我们的函数的问题。如果我们首先乘以10，所有生成的整数都将为偶数。为了有意义地过滤掉奇数，我们必须先这样做。考虑以下示例：
- en: '[PRE23]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The output is as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE24]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This is a little bit hard to read, especially if you aren't used to reading
    Lisp code with its nested parentheses. Even though `map` comes first in the source
    code, the evaluation starts with the call to `filter`. The result is then passed
    into `map` (we'll show you a better way to write this later in this chapter).
    First, though, let's look at what is happening.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这有点难以阅读，尤其是如果你不习惯阅读具有嵌套括号的Lisp代码。即使`map`在源代码中排在第一位，评估也是从对`filter`的调用开始的。然后结果传递给`map`（我们将在本章后面展示更好的写法）。不过，首先让我们看看发生了什么。
- en: 'Conceptually, the computation looks something like this:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 从概念上讲，计算看起来像这样：
- en: '![Figure 4.4: Combining the two – filter, then map'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.4：结合两个操作 – 过滤后映射'
- en: '](img/B14502_04_04.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B14502_04_04.jpg](img/B14502_04_04.jpg)'
- en: 'Figure 4.4: Combining the two – filter, then map'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.4：结合两个操作 – 过滤后映射
- en: It may be helpful to think of this as data flowing through a pipeline. The functional
    arguments to `map` and `filter` are what shape your data as it flows along.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将此视为数据通过管道流动。`map`和`filter`的功能参数是塑造数据在流动过程中的形状。
- en: Threading Macros
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线程宏
- en: 'It''s possible to write the same expression in a way that reflects the logic
    of what we are doing to the data. If we write this in a very non-idiomatic style,
    using `def`, it''s a little clearer:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以以反映我们对数据进行操作逻辑的方式编写相同的表达式。如果我们用非常非习惯性的风格编写，使用`def`，它会稍微清晰一些：
- en: '[PRE25]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Alternatively, and much more idiomatically, we can use Clojure''s **threading
    macros** to make it easier to read:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，更习惯性地，我们可以使用Clojure的**线程宏**来使其更容易阅读：
- en: '[PRE26]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Note
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: A macro is a construct that transforms code before it is executed. In *Chapter
    11*, *Macros*, we will explore macros in much more depth. For now, you can think
    of Clojure's threading macros as "syntactic sugar" that allows us to write more
    readable code by avoiding deep nesting.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 宏是一种在执行之前转换代码的结构。在*第11章*，*宏*中，我们将更深入地探讨宏。现在，你可以将Clojure的线程宏视为“语法糖”，它通过避免深层嵌套来允许我们编写更易于阅读的代码。
- en: 'This is how we will write our code throughout this chapter. Threading allows
    us to preserve the logical order of execution without having to name the return
    values. The `->>` macro rewrites your code so that the result of each form is
    inserted at the end of the next form. This way, we can write the following:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们将在本章中编写代码的方式。线程允许我们在不命名返回值的情况下保留执行的逻辑顺序。`->>`宏重写你的代码，使得每个表达式的结果都插入到下一个表达式的末尾。这样，我们可以编写以下内容：
- en: '[PRE27]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'And the compiler really "sees" this:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器实际上“看到”的是这个：
- en: '[PRE28]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This is an extremely common pattern that helps immensely in writing easy-to-read
    code, especially when applying many different operations to sequences. In Clojure,
    when a function takes a sequence as an argument, that argument is generally the
    last argument. This is quite convenient, or rather, a great design decision, because
    it allows us to chain together transformations in an intuitive way using the `->>`
    macro, which happens to fill in the last argument in an expression. A complex
    transformation can be broken down into smaller, composable steps, which are easier
    to write, test, and understand.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个极其常见的模式，在编写易于阅读的代码时非常有帮助，尤其是在对序列应用许多不同操作时。在Clojure中，当一个函数接受一个序列作为参数时，该参数通常是最后一个参数。这非常方便，或者更确切地说，是一个伟大的设计决策，因为它允许我们使用`->>`宏以直观的方式链接转换，这个宏恰好填充了表达式中的最后一个参数。一个复杂的转换可以被分解成更小、可组合的步骤，这使得编写、测试和理解都更容易。
- en: Using Lazy Sequences
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用惰性序列
- en: 'Before we move on, it''s important to take a closer look at how lazy sequences
    work in Clojure. When using `map` and `filter`, lazy evaluation is often an important
    consideration. In the examples we''ve looked at so far, we have used a literal
    vector as input: `[1 2 3 4 5]`. Instead of typing out each number, we could use
    the `range` function and write `(range 1 6)`. If we type this in the REPL, we
    get basically the same thing:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续前进之前，重要的是要更仔细地看看Clojure中惰性序列的工作方式。当使用`map`和`filter`时，惰性评估通常是一个重要的考虑因素。在我们之前看到的例子中，我们已经使用了一个字面量向量作为输入：`[1
    2 3 4 5]`。我们不必逐个输入每个数字，可以使用`range`函数并编写`(range 1 6)`。如果我们将其输入到REPL中，我们会得到基本上相同的结果：
- en: '[PRE29]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'So, is this just a shortcut to avoid typing out lots of integers? Well, it
    is, but `range` has another interesting characteristic: it''s lazy.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这仅仅是一个避免输入大量整数的快捷方式吗？嗯，是的，但`range`还有一个有趣的特性：它是惰性的。
- en: 'Before we go further, let''s revisit `(range 100)` is a `100`:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续前进之前，让我们回顾一下`(range 100)`是一个`100`：
- en: '[PRE30]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Note
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The REPL causes lazy sequences to be evaluated. This can be confusing sometimes
    if the problem you are debugging is caused by a lazy sequence not being fully
    evaluated: "This code works just fine in the REPL; why doesn''t it work correctly
    in my code?" When debugging in the REPL, if you want to avoid forcing the evaluation
    of a lazy sequence, assign it to a variable instead.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: REPL会导致惰性序列被评估。有时这可能会让人困惑，如果你正在调试的问题是由一个没有完全评估的惰性序列引起的：“这段代码在REPL中运行得很好；为什么在我的代码中不能正确运行？”在REPL中调试时，如果你想避免强制评估一个惰性序列，可以将其分配给一个变量。
- en: 'The `range` function creates a list of integers by calling `inc` as many times
    as necessary. It''s easy enough to guess that the last integer in `our-seq` will
    be `99`, but the computer doesn''t know that until it has performed all the arithmetic.
    This means that when we look at the first item, only one item is known:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`range`函数通过多次调用`inc`来创建一个整数列表。很容易猜测`our-seq`中的最后一个整数将是`99`，但计算机不知道这一点，直到它完成了所有的算术。这意味着当我们查看第一个项目时，只有一个项目是已知的：'
- en: '[PRE31]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'But if we look at the last item, all the intermediate calculations will be
    performed:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果我们查看最后一个项目，所有中间的计算都将被执行：
- en: '[PRE32]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Now, the entire sequence has been realized, and for all practical purposes,
    it's no longer any different from a literal sequence of integers.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，整个序列已经被实现，从实际应用的角度来看，它不再与字面序列的整数有任何区别。
- en: Functions such as `map`, `filter`, and `remove` are also lazy. This means that
    when we call them on a lazy sequence, they do not force the calculation of the
    entire sequence. Essentially, lazy functions just add new calculations to a virtual
    backlog of deferred calculations that will realize the sequence when needed. Functions
    such as `count`, `sort`, or `last`, on the other hand, are not lazy. Obviously,
    in order to count all the items in the list, we need the entire list first.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`map`、`filter`和`remove`等函数也是惰性的。这意味着当我们对惰性序列调用它们时，它们不会强制计算整个序列。本质上，惰性函数只是将新的计算添加到虚拟的后备计算队列中，当需要时才会实现序列。另一方面，`count`、`sort`或`last`等函数不是惰性的。显然，为了计算列表中的所有项目，我们首先需要整个列表。'
- en: 'Exercise 4.04: Watching Lazy Evaluation'
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习4.04：观察惰性求值
- en: 'We can observe laziness in action by doing something that we never want to
    do in production code: introduce a side effect. Let''s get started:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过做一些在生产代码中永远不会做的事情来观察惰性求值的作用：引入副作用。让我们开始吧：
- en: 'Define a simple version of `range` in the REPL:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在REPL中定义`range`的简单版本：
- en: '[PRE33]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Here, the `iterate` function creates a lazy sequence by calling `inc` on `0`,
    then calling `inc` on the result of that, then on the result of that, and so on.
    `take-while` will stop consuming the sequence when the anonymous function, that
    is, `#(< % limit)`, stops returning `true`. This will then stop `iterate`.
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里，`iterate`函数通过在`0`上调用`inc`来创建一个惰性序列，然后在该结果上调用`inc`，然后在该结果上调用`inc`，依此类推。`take-while`将在匿名函数，即`#(<
    % limit)`停止返回`true`时停止消耗序列。这将停止`iterate`。
- en: 'Test the function at the REPL:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在REPL中测试该函数：
- en: '[PRE34]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Use `map` to multiply each integer by 10:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`map`将每个整数乘以10：
- en: '[PRE35]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now, we''ll use a function with side effects to print `.` each time an integer
    is multiplied:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将使用一个具有副作用的函数来打印每个整数乘法时的`.`：
- en: '[PRE36]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: As predicted, there is a `.` operator for each integer. The exact position of
    the dots may be different when you try this: they may appear before or after the
    list of integers. They are not part of the result sequence; they are being printed
    simultaneously, just before each multiplication is executed. There is one dot
    for each integer because the entire sequence has been realized.
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如预期的那样，每个整数都有一个`.`运算符。当你尝试这个时，点的确切位置可能不同：它们可能出现在整数列表之前或之后。它们不是结果序列的一部分；它们是在每次乘法执行之前同时打印的。每个整数都有一个点，因为整个序列已经被实现。
- en: 'This time, use `def` to store the lazy sequence, instead of viewing it in the
    REPL:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这次，使用`def`来存储惰性序列，而不是在REPL中查看它：
- en: '[PRE37]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The REPL returns the `by-ten` variable, but does not print any dots, so we know
    that none of the multiplications have been performed yet.
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: REPL返回`by-ten`变量，但没有打印任何点，因此我们知道还没有进行任何乘法运算。
- en: 'Evaluate the variable in the REPL:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在REPL中评估变量：
- en: '[PRE38]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'What happened here? This is the same output as in *step 4*. The computations
    weren''t performed until we finally decided to consume the lazy sequences in the REPL.
    This is the essence of laziness in Clojure: deferring evaluation until it is necessary.'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里发生了什么？这与*步骤4*中的输出相同。计算直到我们最终决定在REPL中消费惰性序列时才执行。这是Clojure中惰性的本质：延迟求值直到必要。
- en: 'Lazy evaluation has some important benefits, both in terms of simplifying our
    programs and in terms of performance. Deferring computation on a sequence means
    that we can sometimes avoid the computation altogether, at least on part of the
    sequence. For now, the important thing to understand is how lazy evaluation can
    change the way we write and organize our code. Consider this expression:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 惰性求值在简化我们的程序和性能方面都有一些重要的好处。对序列的延迟计算意味着我们有时可以完全避免计算，至少在序列的一部分上。现在，重要的是要理解惰性求值如何改变我们编写和组织代码的方式。考虑这个表达式：
- en: '[PRE39]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'With no arguments, `range` returns all the integers from zero to the biggest
    number your system can handle. If you type this expression into your REPL, it
    will fill up the screen with numbers. Because there is a built-in limit regarding
    the number of items the REPL will display, it won''t increment all the way to
    infinity, or until your JVM blows up – whichever comes first. Now, imagine that
    we write something like this:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 没有参数时，`range` 返回从零到系统可以处理的最大整数的所有整数。如果你将这个表达式输入到你的REPL中，它将用数字填满整个屏幕。因为REPL在显示项目数量方面有一个内置的限制，所以它不会一直递增到无限大，或者直到你的JVM崩溃——哪个先到算哪个。现在，想象一下我们写点像这样东西：
- en: '[PRE40]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This expression tells the computer to multiply every integer from 1 to infinity
    by 10, and then, when that calculation is complete, keep the first five values.
    Without lazy evaluation, this would be crazy. It would fail on the first line.
    Then, why perform a calculation on a huge set of numbers when we''re only interested
    in the first five values? Yet, in Clojure, this is a perfectly reasonable way
    to write code. The calls to `range` and `map` are a description of the data that
    we want: positive integers multiplied by 10\. The call to take allows us to select,
    within that infinite set, the items that we actually need. Lazy evaluation means
    that only five calculations will be performed, so the preceding code is not only
    elegant, but perfectly efficient.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这个表达式告诉计算机将1到无限大的每个整数乘以10，然后，当这个计算完成时，保留前五个值。如果没有懒加载，这将非常疯狂。它会在第一行失败。那么，当我们只对前五个值感兴趣时，为什么还要对一大堆数字进行计算呢？然而，在Clojure中，这是一种完全合理的写代码的方式。对`range`和`map`的调用是我们想要的数据的描述：正整数乘以10。对`take`的调用允许我们在无限集合中选择我们实际需要的项目。懒加载意味着只需执行五个计算，因此前面的代码不仅优雅，而且效率极高。
- en: There are dangers too, of course. In this example, if we replace `(take 5)`
    with `last`, it would mean trying to evaluate the entire sequence, with disastrous
    consequences as your machine tries, and fails, to calculate all the integers to
    infinity. Lazy evaluation is extremely useful, but it is important to understand
    how it works.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，也存在危险。在这个例子中，如果我们用 `last` 替换 `(take 5)`，这意味着尝试评估整个序列，这将导致灾难性的后果，因为你的机器会尝试计算所有整数到无限大，并最终失败。懒加载非常有用，但了解它是如何工作的重要。
- en: 'Exercise 4.05: Creating Our Own Lazy Sequence'
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习4.05：创建我们自己的懒序列
- en: 'From time to time, we need to create sequences of random numbers. This may
    be for a simulation or for writing tests. In a procedural language such as JavaScript,
    we may write something like this:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们需要创建随机数的序列。这可能是为了模拟或编写测试。在像JavaScript这样的过程式语言中，我们可能会写点像这样东西：
- en: '[PRE41]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: We could then wrap this in a function and parameterize the length of the array
    we wanted.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这个功能封装在一个函数中，并参数化我们想要的数组长度。
- en: 'How can we do this in Clojure without a `for` loop? Clojure has a `rand-int`
    function that returns a single random integer. We can use the `repeatedly` function,
    which returns a lazy sequence of calls to whatever function we pass it. Let''s
    get started:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何在Clojure中没有使用 `for` 循环来做这件事？Clojure有一个 `rand-int` 函数，它返回一个随机的单个整数。我们可以使用
    `repeatedly` 函数，它返回一个由我们传递给它的函数的调用组成的懒序列。让我们开始吧：
- en: 'Create a lazy sequence with `repeatedly` and an anonymous function that calls
    `rand-int` with a fixed argument:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `repeatedly` 和一个调用 `rand-int` 并带有固定参数的匿名函数来创建一个懒序列：
- en: '[PRE42]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The `parse-int` function just takes one argument that defines the upper bound
    of the value to be returned. It is common to use `partial` in cases like this,
    but we could have just as well written a literal anonymous function: `#(rand-int
    100)`.'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`parse-int` 函数只接受一个参数，该参数定义了要返回值的上限。在这种情况下使用 `partial` 是常见的，但我们可以同样简单地写一个字面匿名函数：`#(rand-int
    100)`。'
- en: 'Use `take` to limit how many integers are returned:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `take` 限制返回的整数数量：
- en: '[PRE43]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Wrap this into a function:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其封装成一个函数：
- en: '[PRE44]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Use it as follows:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如此使用它：
- en: '[PRE45]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The output is as follows:'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE46]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: When moving from a procedural approach to Clojure's functional approach, this
    pattern can be useful. First, describe the data you want, and then delimit it
    or transform it as needed.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 当从过程式方法转向Clojure的函数式方法时，这种模式可能很有用。首先，描述你想要的数据，然后根据需要对其进行界定或转换。
- en: 'Lazy sequences may seem unnecessarily confusing at first: why bother with a
    data structure that introduces uncertainty about whether something has been calculated
    or not? There are indeed some edge cases where this can be an issue, and we''ll
    see one of those later in this chapter. Most of the time, however, these problems
    can be avoided by writing code that does not produce or depend on side effects.
    And then you will start to reap the benefits of lazy sequences, which allow sequences
    to be defined in a declarative way that will ultimately simplify your code.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 懒惰序列一开始可能看起来没有必要地令人困惑：为什么要使用一个引入了是否已经计算过某物的不确定性的数据结构呢？确实有一些边缘情况可能会成为问题，我们将在本章后面看到其中之一。然而，大多数时候，通过编写不产生或依赖副作用的代码，可以避免这些问题。然后你将开始享受到懒惰序列的好处，它允许以声明性方式定义序列，这最终将简化你的代码。
- en: Common Idioms and Patterns
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 常见惯用和模式
- en: Functions such as `map` and `filter` are two of the most powerful tools in Clojure
    for extracting, selecting, and transforming data. The key to using them effectively
    is, of course, knowing what kind of function to use with them. Clojure tries to
    make writing functions easy, and there are many shortcuts for some of the most
    common situations. These techniques will help you to start writing code more quickly,
    and they will also give you some valuable practice in functional programming.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`map`和`filter`等函数是Clojure中用于提取、选择和转换数据的最强大的工具之一。有效使用它们的关键当然是知道与它们一起使用哪种类型的函数。Clojure试图使编写函数变得容易，并为一些最常见的情况提供了许多快捷方式。这些技术将帮助你更快地编写代码，并且它们还将为你提供一些函数式编程的宝贵实践。'
- en: Anonymous Functions
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 匿名函数
- en: So far, we've been writing functional arguments as anonymous functions using
    the canonical `fn` form, or by using a named function such as `odd?`. Because
    sequence-handling functions in Clojure often make use of functions that are passed
    in as arguments, writing (and reading) anonymous functions is an extremely common
    task. This is why it's good to know the different shortcuts for writing them.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直使用标准的`fn`形式或使用像`odd?`这样的命名函数来编写函数式参数作为匿名函数。由于Clojure中的序列处理函数通常使用作为参数传递的函数，因此编写（和阅读）匿名函数是一项极其常见的任务。这就是为什么了解编写它们的不同的快捷方式是很好的。
- en: One of the most common ways to pass a function to `map` or `filter` is by using
    what's known as a `fn` form. The `fn` symbol and the argument list disappear,
    leaving only the heart of the function and a `#` operator just before the opening
    parenthesis.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 将函数传递给`map`或`filter`的最常见方式之一是使用所谓的`fn`形式。`fn`符号和参数列表消失，只留下函数的核心和开括号前的`#`运算符。
- en: 'In *Exercise 4.01*, *Working with map*, instead of `(fn [n] (* 10 n))`, we
    could have written `#(* 10 %)`. The leading `#` operator identifies the form that
    follows as a function. We still don''t have an argument list, though, which would
    be a disastrous omission in a functional language! However, we are saved by a
    pattern: instead of naming the arguments freely, as in most functions, with function
    literals, the arguments are automatically named by following a simple pattern.
    The first argument is named `%` and all the other arguments are named `%2`, `%3`,
    `%4`, and so forth.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在*练习4.01* *使用map*中，我们本可以写成`#(* 10 %)`而不是`(fn [n] (* 10 n))`。前导的`#`运算符标识了其后的形式为一个函数。尽管如此，我们仍然没有参数列表，这在函数式语言中将是灾难性的遗漏！然而，我们得到了一个模式：与大多数函数中自由命名参数不同，函数字面量中的参数会自动按照一个简单的模式命名。第一个参数被命名为`%`，所有其他参数被命名为`%2`、`%3`、`%4`等等。
- en: There are some limits to the expressiveness of function literals. The pattern
    for argument names does not allow anything such as destructuring or any of the
    other interesting features of Clojure's argument lists. And, of course, not being
    able to name the arguments does make for inexpressive code. If you have more than
    two arguments, it may be time to switch back to `fn`. It may seem obvious what
    you meant by `%4` in the complex function literal you wrote this morning, but
    in a week, you will probably have forgotten. Function literals should be brief
    and simple.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 函数字面量的表现力有限。参数名称的模式不允许像解构或Clojure参数列表的其他有趣特性。当然，不能命名参数会使代码缺乏表现力。如果你有超过两个参数，可能该回到使用`fn`了。你今天早上写的复杂函数字面量中的`%4`可能看起来很明显，但一周后你可能会忘记。函数字面量应该是简短和简单的。
- en: The final limitation of functional literals is that they cannot be nested. In
    other words, if you have a function literal that calls `map`, then the function
    you provide to `map` cannot also be a function literal. The reason why nesting
    is impossible is quite simple. How would the compiler know which `%` goes with
    which function?
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 函数字面量的最终限制是它们不能嵌套。换句话说，如果你有一个调用`map`的函数字面量，那么提供给`map`的函数也不能是函数字面量。为什么嵌套不可能的原因非常简单。编译器如何知道哪个`%`与哪个函数相对应？
- en: As soon as a function literal starts to become even a little bit complex, it's
    certainly time to switch to the `fn` form. Function literals should be used as
    simple wrappers for setting up calls to existing functions, rather than as a place
    to write complex code.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦函数字面量开始变得稍微复杂一些，就肯定到了切换到`fn`形式的时候了。函数字面量应该用作设置对现有函数调用的简单包装器，而不是编写复杂代码的地方。
- en: 'As you become more familiar with some of the more advanced functional techniques
    in Clojure, you will start to use some of the other options that are now at your
    disposal. For multiplying by 10, we could have also written the following:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你对Clojure中一些更高级的函数技术越来越熟悉，你将开始使用现在可供你使用的其他一些选项。对于乘以10，我们也可以写成以下这样：
- en: '[PRE47]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Notice that there is no `#` in front of this form. Here, the `partial` function
    returns a new anonymous function, that is, `*`, with its first argument "preloaded."
    This is easier to understand in the REPL:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个表单前面没有`#`。在这里，`partial`函数返回一个新的匿名函数，即`*`，其第一个参数“预加载”。这在REPL中更容易理解：
- en: '[PRE48]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Here, we've defined `apart`, which is a partially evaluated call to `*`. By
    calling that function, it behaves just like `*`, except that the first argument
    to `*` is already filled in. Writing `(partial * 10)` is essentially the same
    thing as writing `(fn [x] (* 10 x))`.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了`apart`，这是一个对`*`的部分评估调用。通过调用该函数，它表现得就像`*`一样，除了`*`的第一个参数已经填满。编写`(partial
    * 10)`本质上等同于编写`(fn [x] (* 10 x))`。
- en: Note
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Any function that's created with `partial` can always be rewritten as a function.
    The power of functions such as `partial` is their ability to create new functions
    programmatically. This is where a lot of the power of **functional programming**
    resides.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 任何使用`partial`创建的函数都可以总是重写为一个函数。函数如`partial`的力量在于它们能够以编程方式创建新的函数。这正是函数式编程的许多力量所在。
- en: This is, in fact, the exact same function we've been writing. For now, you don't
    need to worry about `partial`. The other ways of writing functions like this are
    equivalent and sufficient.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上是我们一直在编写的完全相同的函数。目前，你不需要担心`partial`。像这样编写函数的其他方式是等效且足够的。
- en: Keywords as Functions
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关键字作为函数
- en: 'By now, you''re already familiar with using a **keyword** to get a value in
    a map, as follows:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经熟悉了使用**关键字**在映射中获取值，如下所示：
- en: '[PRE49]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: This works because Clojure keywords can be used as functions whose arguments
    are a map. It is also very useful when extracting a single field from a list of
    maps, as we'll see in the next exercise.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这之所以有效，是因为Clojure关键字可以用作函数，其参数是一个映射。当从映射列表中提取单个字段时，它也非常有用，正如我们将在下一个练习中看到的那样。
- en: 'Exercise 4.06: Extracting Data from a List of Maps'
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习4.06：从映射列表中提取数据
- en: 'Extracting information from a more complex structure is a common task. We are
    often presented with a sequence of Clojure maps, where each map has multiple keyword
    keys. We need a sequence of the values of just one key, one for each map. Let''s
    say we have a vector containing the players in a game. Each player may be represented
    by a map like this:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 从更复杂的数据结构中提取信息是一个常见的任务。我们经常遇到一系列Clojure映射，其中每个映射都有多个关键字键。我们需要一个只包含一个键的值的序列，每个映射一个。假设我们有一个包含游戏玩家的向量。每个玩家可能由一个像这样的映射表示：
- en: '[PRE50]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Imagine that the game requires us to get the current points of all the players,
    maybe to calculate an average or to find the maximum and minimum values.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，游戏要求我们获取所有玩家的当前分数，可能用于计算平均值或找到最大和最小值。
- en: 'Copy the `game-users` vector into your REPL from [https://packt.live/36tHiI3](https://packt.live/36tHiI3).
    It contains a list of maps, with each map containing some information about a
    user:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 将`game-users`向量从[https://packt.live/36tHiI3](https://packt.live/36tHiI3)复制到你的REPL中。它包含一个映射列表，每个映射包含有关用户的一些信息：
- en: '[PRE51]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Let''s get started:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧：
- en: 'Use `map` to return a vector of `:current-points` for each user. To do this,
    we could write something like this:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`map`返回每个用户的`:current-points`向量。为此，我们可以写点像这样：
- en: '[PRE52]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Rewrite this expression using a keyword:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用关键字重写这个表达式：
- en: '[PRE53]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The ability to extract lists of data with so little code is one of the benefits
    of the fact that Clojure keywords can also be functions. Shortcuts like this are
    not just convenient or faster to type: they help us write expressive code that
    says exactly what we want.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 能够用如此少的代码提取数据列表是Clojure关键字也可以作为函数的事实的一个好处。这样的快捷方式不仅方便或更快地输入：它们帮助我们编写表达性代码，确切地表达我们的意图。
- en: Sets as Predicates
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集合作为谓词
- en: 'Another common task is to filter based on whether an item is a member of a
    set. Clojure sets are another form of collection that mimic the logic of mathematical
    sets. As a tool in programming, they have two important characteristics:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常见的任务是根据一个项目是否是集合的成员来过滤。Clojure集合是模仿数学集合逻辑的另一种集合形式。作为编程工具，它们有两个重要的特性：
- en: An item is either part of a set or not part of a set. This means that there
    are never any duplicates in a set. Adding an item to a set more than once has
    no effect.
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个项目要么是集合的一部分，要么不是。这意味着集合中永远不会出现重复。将一个项目添加到集合中多次没有任何效果。
- en: The main job of a set is to tell you whether something belongs or not. This
    is why sets can be used as functions, and why they can be useful when combined
    with `filter`.
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集合的主要任务是告诉你某物是否属于集合。这就是为什么集合可以用作函数，并且为什么当与`filter`结合使用时非常有用。
- en: 'Here, we''re defining a set with the `set` function, which takes a list as
    an argument. It can then be used as a function that returns `true` if called on
    a value that is already part of the set, or `false` otherwise. In this example,
    `(alpha-set :z)` returns `false` because `alpha-set` does not contain `:z`:'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们使用`set`函数定义了一个集合，该函数接受一个列表作为参数。它可以用作一个函数，如果调用它并传入的值已经是集合的一部分，则返回`true`，否则返回`false`。在这个例子中，`(alpha-set
    :z)`返回`false`，因为`alpha-set`不包含`:z`：
- en: '[PRE54]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The `hash-set` also produces a set. Instead of a sequence, `hash-set` takes
    zero or more individual items as its arguments:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '`hash-set`也产生一个集合。与序列不同，`hash-set`接受零个或多个单独的项目作为其参数：'
- en: '[PRE55]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The choice of one over the other will depend on what form of data you have.
    The resulting sets are identical.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 选择其中一个还是另一个将取决于你拥有的数据形式。生成的集合是相同的。
- en: Note
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The `clojure.set` library is built into Clojure. This extremely useful library
    contains functions for performing set arithmetic, such as intersections.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '`clojure.set`库是Clojure内置的。这个极其有用的库包含执行集合算术的函数，如交集。'
- en: 'Imagine we have a list of strings that are animal names:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个包含动物名称的字符串列表：
- en: '[PRE56]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Say we want to remove all the mammals from the list. One solution would be
    to simply test for different values:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要从列表中移除所有哺乳动物。一个解决方案是简单地测试不同的值：
- en: '[PRE57]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'This works, but there is a lot of repetitive text. Let''s try using a set:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以工作，但有很多重复的文本。让我们尝试使用一个集合：
- en: '[PRE58]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The output is as follows:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE59]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'This is brief, clear, and reads almost like an English sentence: remove `horse`,
    `cat` [from] `animal-names`. There is another advantage, too. Our list of mammals
    to exclude is fairly limited. What happens if we need to update it? We have to
    alter the source code to add more tests. The set, on the other hand, is data,
    so it could be defined once and for all in a variable at the top of our namespace
    or be calculated at runtime from other data available to our program.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常简洁、清晰，读起来几乎像一句英文句子：从`animal-names`中移除`horse`、`cat`[的名称]。还有另一个优点。我们排除哺乳动物的列表相当有限。如果我们需要更新它怎么办？我们必须修改源代码以添加更多测试。另一方面，集合是数据，因此它可以在我们命名空间的最顶部定义一次，或者从程序可用的其他数据中在运行时计算。
- en: Filtering on a Keyword with comp and a Set
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用comp和集合进行关键字过滤
- en: To compose functions means to create a new function out of one to more existing
    functions. This is what `comp` does. Like `partial`, it is a higher-order function
    that returns a new function. Functional `comp` means that in the returned function,
    each function provided to `comp` will be called on the results of the previous
    function.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 组合函数意味着从一个或多个现有函数中创建一个新的函数。这就是`comp`所做的。像`partial`一样，它是一个高阶函数，返回一个新的函数。函数式的`comp`意味着在返回的函数中，提供给`comp`的每个函数都将调用前一个函数的结果。
- en: 'Let''s say we want to normalize an input string by doing two things: trimming
    whitespace from both ends of the string and converting the string into lowercase.
    The `clojure.string` library provides functions for both of those tasks: `trim`
    and `lower-case`. We could, of course, write a function that does what we need:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要通过以下两种方式规范化一个输入字符串：从字符串的两端去除空白字符，并将字符串转换为小写。`clojure.string`库提供了执行这两项任务的函数：`trim`和`lower-case`。当然，我们可以编写一个执行所需功能的函数：
- en: '[PRE60]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Note
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The `clojure.string` library is a standard library that provides many familiar
    string manipulation functions such as `split` and `join`. String behavior depends
    on how strings are implemented in the underlying platform, so `clojure.string`
    provides a unified interface that is the same for Clojure and ClojureScript.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '`clojure.string` 库是一个标准库，它提供了许多熟悉的字符串操作函数，例如 `split` 和 `join`。字符串的行为取决于底层平台中字符串的实现方式，因此
    `clojure.string` 提供了一个统一的接口，这个接口对 Clojure 和 ClojureScript 都是相同的。'
- en: 'With `comp`, we can do exactly the same thing with fewer parentheses:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `comp`，我们可以用更少的括号做同样的事情：
- en: '[PRE61]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The functional arguments to `comp` are called from right to left. That might
    sound confusing. It means that the functions are called in the same order as if
    they were written out as normal function calls:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '`comp` 的函数参数是从右到左调用的。这可能会听起来有些令人困惑。这意味着函数的调用顺序与它们被写成正常函数调用时的顺序相同：'
- en: '[PRE62]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The preceding code is equivalent to the following:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码等同于以下代码：
- en: '[PRE63]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: In both of these functions, `function-a` would be called first, then `function-b`
    on that result, and, finally, `function-c` on the result of that.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两个函数中，`function-a` 将首先被调用，然后是 `function-b` 在该结果上，最后是 `function-c` 在那个结果上。
- en: 'Composing functions on the fly can be useful whenever you need to define a
    function on the fly. With filter, we could use `comp` to quickly build a predicate.
    Let''s say we need to remove any strings from a list that are present in a normalized
    form set:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在需要即时定义函数的情况下，即时组合函数非常有用。使用 `filter`，我们可以使用 `comp` 快速构建一个谓词。假设我们需要从列表中移除任何存在于规范化形式集合中的字符串：
- en: '[PRE64]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Using `comp`, we are able to build a function that combines three separate steps.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `comp`，我们能够构建一个结合三个单独步骤的函数。
- en: 'Exercise 4.07: Using comp and a Set to Filter on a Keyword'
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 4.07：使用 comp 和集合对关键字进行过滤
- en: 'Let''s go back to `game-users` from the previous exercise. This time, we need
    to narrow the scope of the users whose scores we want to calculate. In our imaginary
    game, users can have one of several statuses: `:active`, `:imprisoned`, `:speed-boost`,
    `:pending`, or `:terminated`. We only want scores for players who have the `:pending`
    or `:terminated` statuses. To do this, we will combine the techniques we''ve used
    so far.'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到之前的练习中的 `game-users`。这次，我们需要缩小我们想要计算的用户的范围。在我们的想象游戏中，用户可以有几种状态之一：`:active`、`:imprisoned`、`:speed-boost`、`:pending`
    或 `:terminated`。我们只想为具有 `:pending` 或 `:terminated` 状态的玩家计算分数。为此，我们将结合我们迄今为止使用的技术。
- en: 'The mapping part will stay the same:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 映射部分将保持不变：
- en: '[PRE65]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Let''s get started:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧：
- en: As in the previous exercise, copy the `game-users` vector into your REPL from
    [https://packt.live/36tHiI3](https://packt.live/36tHiI3).
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与之前的练习一样，将 `game-users` 向量从 [https://packt.live/36tHiI3](https://packt.live/36tHiI3)
    复制到你的 REPL 中。
- en: 'Define a set with the statuses we want to keep:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个包含我们想要保留的状态的集合：
- en: '[PRE66]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Write a function to extract the `:status` field from each map and call the predicate
    on it.
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个函数来提取每个映射的 `:status` 字段并对它进行谓词调用。
- en: 'There are several ways we could do this. Maybe the first thing that occurs
    to us would be to write something like this:'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以以几种方式来做这件事。我们首先想到的可能就是写点这样的东西：
- en: '[PRE67]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The difficulty here, compared to our previous examples, is that we need to
    do two things at the same time: get the field, and then test it. In this case,
    we could also use the `comp` function, which takes two functions and returns a
    new function, which is the result of calling the first function on the result
    of the second function. So, instead of writing `(fn [player] (statuses (:status
    player)))`, we would write the following:'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 与我们之前的例子相比，这里的困难在于我们需要同时做两件事：获取字段，然后对其进行测试。在这种情况下，我们也可以使用 `comp` 函数，它接受两个函数并返回一个新的函数，该函数是调用第二个函数的结果上的第一个函数的结果。因此，我们不需要写
    `(fn [player] (statuses (:status player)))`，我们可以写以下内容：
- en: '[PRE68]'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Use the `->>` threading macro to put the different pieces back together:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `->>` 连接宏将不同的部分重新组合起来：
- en: '[PRE69]'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'The result is uncluttered and easy to read. With a little imagination, it almost
    reads like an English sentence: start with `game-users`, and filter out the users
    whose `:status` is not one of `:active`, `:imprisoned`, or `:speed-boost`, and
    then return the `:current-points` of each of those.'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 结果清晰易读。稍加想象，它几乎就像一个英文句子：从 `game-users` 开始，过滤掉那些 `:status` 不是 `:active`、`:imprisoned`
    或 `:speed-boost` 的用户，然后返回这些用户的 `:current-points`。
- en: Returning a List Longer than the Input with mapcat
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 `mapcat` 返回比输入更长的列表
- en: As we've already said, `map` always returns the same number of items as the
    original input sequence. Sometimes, you may need to make a new list with more
    items if, for example, multiple items can be derived from a single input item.
    This is what `mapcat` is for.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经说过的，`map` 总是返回与原始输入序列相同数量的项目。有时，你可能需要创建一个包含更多项目的新列表，例如，如果可以从单个输入项中推导出多个项目。这就是
    `mapcat` 的用途。
- en: 'Here''s a simple example. Suppose we have a list of letters of the alphabet,
    all in lowercase:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个简单的例子。假设我们有一个包含字母表字母的列表，全部都是小写：
- en: '[PRE70]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'We''ll stop at `"j"` to save space, but you get the idea. The output we want
    to obtain is a new list where each lowercase letter is followed by its uppercase
    counterpart. `mapcat` lets us do that:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将停止在 `"j"` 以节省空间，但你的想法应该很清楚。我们想要获得的新列表是每个小写字母后面跟着其对应的大写字母。`mapcat` 允许我们做到这一点：
- en: '[PRE71]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Here, the function we provided returns a two-item vector, such as `["a" "A"]`.
    `mapcat` simply unwraps each of these vectors so that, in the end, you have a
    single, flat list.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们提供的函数返回一个包含两个元素的向量，例如 `["a" "A"]`。`mapcat` 简单地展开这些向量，最终你将得到一个单一的、扁平的列表。
- en: Note
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Clojure has many interesting, more specialized sequence manipulation functions
    that you may like to explore. We could have solved this problem with `interleave`
    as well.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: Clojure 有许多有趣、更专业的序列操作函数，你可能想探索。我们也可以用 `interleave` 解决这个问题。
- en: In situations where you have a one-to-many relationship between each item of
    the input list and the items in the output list, you probably want to consider
    `mapcat` first. Later in this book, we will use `mapcat` in situations where we
    need to flatten a list that contains a mix of individual items and sublists.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在输入列表的每个项目与输出列表的项目之间存在一对一或多对多关系的情况下，你可能首先考虑使用 `mapcat`。在本书的后面部分，我们将使用 `mapcat`
    在需要将包含单个项目和子列表混合的列表展平时。
- en: Mapping with Multiple Inputs
  id: totrans-276
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于多个输入的映射
- en: Among Clojure's sequence functions, `map` is unique in that it can accept more
    than one sequence as input. This can be useful when you need to stitch sequences
    together in some way or derive a combined value of some kind.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Clojure 的序列函数中，`map` 是独一无二的，因为它可以接受多个序列作为输入。当你需要以某种方式拼接序列或推导某种类型的组合值时，这可能很有用。
- en: 'When `map` has more than one sequence as input, the mapping function must accept
    as many arguments as there are sequences. The basic pattern looks like this:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `map` 有多个序列作为输入时，映射函数必须接受与序列数量相等的参数。基本模式如下：
- en: '[PRE72]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Clojure already has a `zipmap` function that takes two sequences and combines
    them together in a map:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: Clojure 已经有一个 `zipmap` 函数，它接受两个序列并将它们组合成一个映射：
- en: '[PRE73]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Note
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The `into` function is extremely useful when moving data from one collection
    type to another. It can also convert a map into a vector of key-value tuples,
    any sequence into a set, or the other way around.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要将数据从一个集合类型移动到另一个集合类型时，`into` 函数非常有用。它还可以将映射转换为键值对的向量，将任何序列转换为集合，或者反过来。
- en: The mapping function here, `(fn [x y] [x y])`, simply wraps the value pairs
    in a vector, which functions as a `into` function then converts the sequence of
    two-item tuples into a Clojure map.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 这里使用的映射函数 `(fn [x y] [x y])` 简单地将值对包裹在一个向量中，然后作为 `into` 函数工作，将两个元素的元组序列转换为 Clojure
    映射。
- en: Note
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: A tuple is not a special Clojure data structure. Generally implemented as a
    short vector, a tuple is an alternative to a map with named fields. Instead of
    writing `{:x 5 :y 9}`, it is sometimes simpler to write `[5 9]`. A list is a tuple
    when the position of the items in the list determines what they mean. In theory,
    tuples can be of any length; in practice, if they are longer than three or four
    items, it becomes difficult to remember what each position in the list means.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 元组不是 Clojure 的特殊数据结构。通常作为短向量实现，元组是具有命名字段的映射的替代品。而不是写 `{:x 5 :y 9}`，有时简单地写 `[5
    9]` 会更简单。当列表中项目的位置决定了它们的意义时，列表就是一个元组。理论上，元组可以是任何长度；在实践中，如果它们包含三个或四个以上的项目，就很难记住列表中每个位置的意义。
- en: 'Another reason to use multiple inputs would be if we needed to know the offset
    of the item currently being processed. Let''s say we have a list of strings for
    our daily menu:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 使用多个输入的另一个原因可能是如果我们需要知道当前正在处理的项目偏移量。比如说，我们有一个包含我们每日菜单字符串的列表：
- en: '[PRE74]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'We may want to add a number in front of each item when presenting the list
    to the users. We could use `range` to supply an endless supply of integers to
    match each meal:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在向用户展示列表时，我们可能想在每个项目前添加一个数字。我们可以使用 `range` 来提供无限供应的整数以匹配每一项：
- en: '[PRE75]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'The lazy sequence produced by `range` starts at zero, which is great inside
    a computer, but humans prefer lists to start with `1`, so we''ll write `(inc idx)`.
    This pattern is so useful, in fact, that there is already the convenient `map-indexed`
    function that does exactly the same thing. In the end, all we need to write is
    the following:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 由`range`产生的懒序列从零开始，这在计算机内部是很好的，但人类更喜欢以`1`开始的列表，所以我们将写`(inc idx)`。这个模式实际上非常有用，因此已经有一个方便的`map-indexed`函数，它正好做同样的事情。最后，我们只需要写以下内容：
- en: '[PRE76]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'In the examples so far, the functions supplied to `map` or `filter` only look
    at one item at a time. Even when using `map` with multiple sequences, we are still
    looking at each item separately. With a traditional `for` loop, however, we can
    look ahead or behind. For example, this is something that we may write in JavaScript
    if we had an array of values (`ourValues`) and a function that we wanted to call
    on each value and the next value:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的例子中，提供给`map`或`filter`的函数一次只查看一个项目。即使在使用`map`和多个序列时，我们仍然分别查看每个项目。然而，使用传统的`for`循环，我们可以向前或向后查看。例如，如果我们有一个值数组（`ourValues`）和一个我们想要对每个值及其下一个值调用的函数，我们可能会在JavaScript中这样写：
- en: '[PRE77]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'We check to make sure that we aren''t at the last value in the array, and then
    we call `myFunction`. While it would be possible to write more or less the same
    thing in Clojure (and we''ll do some looping in *Chapter 7*, *Recursion II: Lazy
    Sequences*), there is a much more elegant way to do this, that is, by using `map`
    and multiple sequences.'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 我们检查确保我们不在数组的最后一个值，然后调用`myFunction`。虽然我们可以在Clojure中写类似的东西（我们将在*第7章*，*递归II：懒序列*中做一些循环），但有一种更优雅的方法来做这件事，那就是使用`map`和多个序列。
- en: 'The trick here is to use the same sequence more than once, but with an offset
    so that the second argument in the mapping function contains the item that follows
    the first argument:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的技巧是使用相同的序列多次，但带有偏移量，使得映射函数中的第二个参数包含第一个参数之后的项：
- en: '[PRE78]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: The second sequence here is, of course, the same as the first one, except that
    we start with the second element. The first time the anonymous function is called,
    its arguments will be the first and second items in `my-sequence`; the second
    time, the arguments will be the second and third items, and so on.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的第二个序列当然与第一个序列相同，只是我们从第二个元素开始。匿名函数第一次被调用时，其参数将是`my-sequence`中的第一个和第二个项目；第二次调用时，参数将是第二个和第三个项目，依此类推。
- en: 'The following diagram represents this. The list from `0` to `5` is repeated
    with an offset. Each vertical pair corresponds to the two arguments that the mapping
    function will receive:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表表示了这一点。从`0`到`5`的列表以偏移量重复。每一对垂直对应于映射函数将接收的两个参数：
- en: '![Figure 4.5: A windowing or look-ahead effect with map'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.5：使用map的窗口或前瞻效果'
- en: '](img/B14502_04_05.jpg)'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14502_04_05.jpg)'
- en: 'Figure 4.5: A windowing or look-ahead effect with map'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.5：使用map的窗口或前瞻效果
- en: When using `map` with multiple collections, `map` stops iterating over them
    when it reaches the end of the shortest sequence. This ensures that there will
    always be enough arguments to supply to the mapping function. Depending on the
    context, when using offsets like this, it may be necessary to append data to the
    other end of the shortened function if it's important that the last item in the
    sequence is included in the results.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`map`与多个集合时，`map`在达到最短序列的末尾时停止迭代它们。这确保了映射函数将始终有足够的参数提供。根据上下文，当使用这种偏移量时，可能需要在缩短的函数的另一端附加数据，如果重要的话，确保序列的最后一个项目包含在结果中。
- en: If the problem you are solving requires looking farther ahead, you can add more
    offset sequences, and thus more arguments to the mapping function. All sorts of
    creative possibilities are available. Just remember that the shortest sequence
    will limit the number of items that will be mapped over.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你解决的问题需要更远的前瞻，你可以添加更多的偏移序列，从而为映射函数提供更多的参数。各种创造性的可能性都是可用的。只需记住，最短的序列将限制映射的项目数量。
- en: Note
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you just need to break up a sequence into multiple parts and then map over
    those, you can just use `partition`. `(partition 2 my-sequence)` will break your
    input up into two-item sublists.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只需要将序列拆分成多个部分，然后对那些部分进行映射，你只需使用`partition`。`(partition 2 my-sequence)`将你的输入拆分成两项子列表。
- en: 'Exercise 4.08: Identifying Weather Trends'
  id: totrans-307
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习4.08：识别天气趋势
- en: 'In this exercise, we''ll pretend that we have a list of outdoor temperatures
    for a series of days. We want to determine whether each day was warmer, colder,
    or the same as the previous day. This information could then be used to add up
    or down arrows to a visualization. Let''s get started:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: 'In your REPL, define a variable with the vector of integers found in [https://packt.live/2tBRrnK](https://packt.live/2tBRrnK):'
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Write an expression that maps over this vector, starting at the second item,
    `23`, and outputs either `:warmer`, `:colder`, or `:unchanged`:'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Instead of looking ahead this time, we are really looking backward, so, for
    clarity, we've put `(rest temperature-by-day)` before `temperature-by-day` and
    `today` before `yesterday` in the arguments of the anonymous function. As long
    as you understand which sequence corresponds to which argument, the order doesn't
    really matter. Thanks to the offset between the two versions of the same sequence
    of days, we can compare `yesterday` and `today` to define a trend.
  id: totrans-313
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The expression should return the following:'
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Remember that our first day corresponds to the second temperature. 23 is warmer
    than 18, so we get `:warmer`.
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The "windows" that are created by offsetting a sequence against itself can
    be wider than two items: `map` can accept any number of lists.'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: The windowing pattern makes `map` even more powerful because it gets around
    one of its inherent limitations. In its simplest form, `map` is limited to a one-to-one
    relationship between the input list and the output list. With windowing, more
    items in the list can participate in each calculation.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: Consuming Extracted Data with apply
  id: totrans-319
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Often, when `map` and `filter` are used to target and extract data in the form
    you need, the next step is producing some kind of summary. In *Chapter 7*, *Recursion
    II: Lazy Sequences*, we''ll go into this in much more depth. For now, though,
    we can build some simple summary data by calling a single function, such as `min`
    or `max`, on a list using `apply`.'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: Functions such as `min`, `max`, and `+` accept an unlimited number of arguments.
    On the other hand, they don't accept lists. If you have a list of numbers and
    want to find the highest value, you may find yourself thinking "If only I could
    take these numbers out of this list and plug them directly into my call to `max`!"
    Well, with `apply`, you can do just that.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: 'In its simplest form, a call to `apply` takes a function and a list, and calls
    the function on the list as if it were a simple multiple-arity function call:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'This would be the same as the following:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'There are many situations where this can be useful, even if you do know how
    many arguments you have:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'The `+` function did not appreciate the `nil` that was bound to `b`. With `apply`,
    we can use `filter` to remove any unwanted arguments:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: The `apply` function is an important part of any functional programming toolkit.
    It is especially useful when dealing with sequential data that you can shape with
    `map` and `filter`.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one danger with this technique, however. Many functions that accept
    multiple arguments do not accept zero arguments. The `+` function can actually
    be called without any arguments. If you call `(+)`, it will return `0`. On the
    other hand, `min` and `max` will fail if we `apply` them to an empty list:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'In situations like this, it''s important to be sure that an empty list is impossible.
    One way to do that is to supply at least one value. This is made easier by the
    fact that `apply` can accept non-list items before the list argument. This way,
    the call to `min` will always at least have a value of `0`:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Exercise 4.09: Finding the Average Weather Temperature'
  id: totrans-335
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Using the same weather data as in the previous exercise, we''ll calculate the
    average temperature for the days listed. Let''s get started:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: 'Continue using the REPL from the previous exercise or start a new REPL and
    copy the data in from [https://packt.live/2tBRrnK](https://packt.live/2tBRrnK):'
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  id: totrans-338
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Use `(apply +…)` and `count` to calculate the sum of the temperatures and count
    them, and then find the average:'
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  id: totrans-340
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Activity 4.01: Using map and filter to Report Summary Information'
  id: totrans-341
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In our imaginary game, we want to create a dashboard where users can compare
    themselves to other users in the same situation: active users should only be able
    to see other active users, and so forth. We want to know the maximum and minimum
    values in each case so that the current user can see how they have been placed
    relative to the extremes.'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: This means that we need a function that accepts a field name (whichever field
    we want to display), a status (the status of the current user), and a list of
    `game-users`.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: 'Write two functions that report the minimum and maximum values for each of
    the numeric fields in `game-users` for all the users and for each status category.
    We want to be able to ask: What is the highest value of `:current-points` for
    all the `:active` users?'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: 'The functions should take three arguments: the field we want, the status we
    want, and the list of users. They should be called like this:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'The call signature of the function will look like this:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: For simplicity, you should probably structure your code the same way we have
    done previously, that is, with the threading macro, `->>`, which can chain multiple
    function calls together.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: 'These steps will help you complete this activity:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: Use `filter` to narrow down the users who have the status we are looking for.
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use `map` to extract the value that you want.
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the `min` and `max` functions with `apply` to find the minimums and maximums.
    Make sure your code will still work, even if there aren't any users who have the
    status you are looking for.
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following is the expected outcome:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.6: Expected outcome'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14502_04_06.jpg)'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.6: Expected outcome'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: The solution to this activity can be found on page 689.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: Importing a Dataset from a CSV File
  id: totrans-360
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we''ve seen some basic patterns for manipulating data, it''s time
    to be more ambitious! We are going to start using a dataset that we will use in
    many of the following chapters as we build up our Clojure knowledge: ATP World
    Tour tennis data, a CSV file that includes, among other things, information about
    professional tennis matches going back to 1871\. Besides learning about new concepts
    and techniques, we will see that Clojure can be an interesting choice for exploring
    and manipulating large datasets. And, naturally, most of the datasets that are
    available to us are CSV files.'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: This dataset was created and is maintained at [https://packt.live/2Fq30kk](https://packt.live/2Fq30kk),
    and is available under the Creative Commons 4.0 International License. The files
    that we'll be using here are also available at [https://packt.live/37DCkZn](https://packt.live/37DCkZn).
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: In the rest of this chapter, we will import tennis match data from a CSV file
    and use our mapping and filtering techniques to extract interesting data from
    it.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 4.10: Importing Data from a CSV File'
  id: totrans-365
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It''s time to imagine that you work for a sports journalism website specializing
    in data-centric reporting. Your role is to help the journalists analyze data and
    produce interesting visualizations for the site. In your new job, you need to
    be able to import large datasets that are usually published as CSV. Let''s get
    started:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: Create a folder somewhere convenient on your computer.
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Download the `match_scores_1991-2016_UNINDEXED.csv` file to the folder you created.
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In your editor, in the same folder, create a `deps.edn` file with the following
    contents:'
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  id: totrans-370
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: These are references to two libraries that we will use extensively. The first
    one, `clojure.data.csv`, is lower-level tool and deals with the mechanics of getting
    data in and out of a `.csv` file. `semantic-csv`, on the other hand, is a higher-level
    tool that makes it easier to work with `.csv` data.
  id: totrans-371
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Still in the same folder, with your editor or IDE, start a Clojure REPL.
  id: totrans-372
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Verify that everything is working by evaluating the following expression in
    your REPL:'
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE93]'
  id: totrans-374
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '`clojure.data.csv` returns a vector of strings for each line in the file. This
    is the first line of the file, which is, of course, the column headers.'
  id: totrans-375
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'When exploring a new dataset, it''s always good to know the size of the data.
    We can use `count` here to check that:'
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  id: totrans-377
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: These are the basics of opening and reading a CSV file in Clojure. All the other
    data analysis techniques we will examine will use this same basic pattern. But
    before we go any further, we need to take a look at lazy evaluation.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: Real-World Laziness
  id: totrans-379
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Did you notice how the code you evaluated in the previous exercise was rather
    fast? The data file is quite long, and it seems like it would take a long time
    to parse it. But `parse-csv` is lazy. Because we only asked for the first result,
    the evaluation stopped after one line. This is convenient because it allows us
    to process large files without loading them into memory.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: 'Because we are dealing with files, we have to be careful. Remember that lazy
    evaluation means that evaluation is deferred until it is needed. That is fine
    for sequences of integers, but with an external resource such as a file reader,
    if we wait too long, the resource may not be available anymore. To avoid problems,
    we will do two things:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: Most of our data work will happen inside the scope of the `with-open` macro.
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We won't return any lazy sequences from the `with-open` macro.
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In other words, inside the scope of `with-open`, we can use and combine all
    the lazy evaluation techniques we like. When we return sequences, we'll make sure
    that they are fully realized, often using the `doall` function. It may be tempting
    to immediately call `doall` to avoid having to worry about lazy evaluation at
    all. While there are cases where this may be appropriate, it is best to try to
    resist this temptation. Reading a large CSV file is a good example of why preserving
    the laziness of sequences is important. Calling `doall` too soon would force all
    of the rows of data to be loaded into memory, when maybe we only need a few rows.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at this in practice.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 4.11: Avoiding Lazy Evaluation Traps with Files'
  id: totrans-386
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the previous exercise, you successfully opened a CSV file and started to
    play with it a little bit. "It''s time," you say to yourself, "to look at some
    real data." The incoming data appears to be a sequence, since we can use `first`
    and `count` on it. Let''s try to extract some more data:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: In the same folder as before, open your REPL again.
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If necessary, load the dependencies again:'
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE95]'
  id: totrans-390
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Let''s try to extract the name of the winner of each of the first five matches.
    Starting from 0, the `winner_name` field is number `7`, so we want to call `#(nth
    % 7)` on each of the first five lines (after the initial header line). Maybe this
    will work:'
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE96]'
  id: totrans-392
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'The output is as follows:'
  id: totrans-393
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE97]'
  id: totrans-394
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: What happened? As the error message suggests, the file stream is closed when
    the REPL tries to print the results. `map` and `take` are both lazy. But why?
    We call `map` and `take` *inside* the scope of `with-open`. Shouldn't the file
    still be open? The problem is that because the evaluation is deferred, it has
    not happened yet when we exit the scope of the `with-open` macro. All we have
    at that point is an unevaluated sequence. When the REPL tried to evaluate the
    lazy expression returned by `take`, the scope where the file reader was available
    disappeared. Lazy sequences are not evaluated until they are consumed, and in
    this case, the sequence is consumed in your REPL.
  id: totrans-395
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, try again with `doall`:'
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE98]'
  id: totrans-397
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'This time, you should see something like this:'
  id: totrans-398
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE99]'
  id: totrans-399
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: As you can see, `doall` forces the evaluation of the lazy sequence. The closed
    stream is no longer a problem. The expression returns a simple list.
  id: totrans-400
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'While working with this dataset, we will use this basic pattern many times,
    often ending with `doall`. You can also see how it reproduces a familiar pattern:
    get the information (`csv/read-csv`), shape the information (`map, take`), and
    hand the information off (`doall`). Lazy evaluation combined with limited external
    resources, such as file I/O, in this case, does add an extra challenge. Maintaining
    a clear separation between data acquisition, data manipulation, and data output
    is not only good design or good practice—in a situation like this, it will really
    help avoid errors and bugs. Even in this case, however, there is an upside to
    lazy evaluation: some files may be too large to fit in memory. By evaluating the
    output from the file "lazily," the entire file doesn''t need to be loaded into
    memory simultaneously.'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: You've now extracted some real data from the `.csv` file.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: 'Clojure''s `mapv` function is a replacement for `map`, with one key difference:
    instead of returning a lazy sequence, it returns a vector. Because vectors are
    not lazy, this can be a way of avoiding a call to `doall`. For clarity, however,
    it is often preferable to use `doall` explicitly.'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: Convenient CSV Parsing
  id: totrans-405
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you can see from the previous example, `clojure.data.csv` returns a sequence
    of vectors, where each vector contains, as individual strings, the CSV files in
    a single line of the original file. There is still some work to do before we can
    really use that data, however. Because `.csv` is such a common format, there are
    libraries that can make things a little bit more convenient. We'll be using `semantic-csv`,
    which we've already included in our `deps.edn` file.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: The main functions that we'll use from `semantic-csv` are `mappify` and `cast-with`.
    With `mappify`, each row becomes a Clojure map, where the keys are the column
    names from the CSV file, and with `cast-with`, we can transform strings containing
    numeric values in the source file into the correct types.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: Let's see how this works. After that, we'll be ready to do some more interesting
    things with the data in our `.csv` file.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 4.12: Parsing CSV with semantic-csv'
  id: totrans-409
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we''ll start by saving our work in a file so that we can
    come back to it later. Let''s get started:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: In the same folder as before, create a new file, `tennis.clj`, in your text
    editor.
  id: totrans-411
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set up your namespace and use `:require` so that you have access to the necessary libraries:'
  id: totrans-412
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE100]'
  id: totrans-413
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Write a function that returns the first row of data:'
  id: totrans-414
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE101]'
  id: totrans-415
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Evaluate your file, move to the `packt-clj.tennis` namespace in your REPL,
    and call the function:'
  id: totrans-416
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE102]'
  id: totrans-417
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'You should see a map with the data for the first match:'
  id: totrans-418
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE103]'
  id: totrans-419
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'That''s a lot of information. We don''t need all of those fields, so we''ll
    call `select-keys` on each `map` to keep only the values that interest us. This
    time, we''ll keep the first five rows:'
  id: totrans-420
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE104]'
  id: totrans-421
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'Evaluate your file again, and then call `five-matches` in the REPL:'
  id: totrans-422
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE105]'
  id: totrans-423
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'You should see a list of maps:'
  id: totrans-424
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE106]'
  id: totrans-425
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'To use the `:winner_sets_won` and `:loser_sets_won` fields in a calculation
    of some kind, we need to cast them as integers first. Use the `cast-with` function
    of `semantic-csv`:'
  id: totrans-426
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE107]'
  id: totrans-427
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'This will return the same data as the previous function, except that the values
    for `:winner_sets_won` and `:loser_sets_won` won''t appear with quotation marks
    anymore:'
  id: totrans-428
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE108]'
  id: totrans-429
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE108]'
- en: Now, we have enough tools to start performing some interesting queries against
    our dataset. With `map`, `filter`, and a few simple tools, we are ready to write
    simple, yet sophisticated, queries. In the next section, we are going to look
    at some techniques that will be useful in their own right and will help you to
    think about using functions to describe the data you want.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 4.13: Querying the Data with filter'
  id: totrans-431
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If we think of this CSV data as a database, then writing queries is a question
    of writing and combining predicates. In this exercise, we will use `filter` to
    narrow our dataset down to the exact information we want. Imagine that the journalists
    on your team are working on a new project dedicated to famous tennis rivalries.
    As a first step, they''ve asked you to produce a list of all the tennis matches
    won by Roger Federer. Let''s get started:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
- en: Make sure that your project is set up the same way as it was in the previous
    exercises.
  id: totrans-433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a function called `federer-wins` that provides the CSV processing steps
    we''ve already used. Add the calls to `select-keys` and `doall`, which will be
    applied to the data once it has been narrowed down:'
  id: totrans-434
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE109]'
  id: totrans-435
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE109]'
- en: Write a predicate that will decide whether Roger Federer won a match. Using
    the same pattern as in the previous examples, all we need to do is "plug in" a
    call to `filter` with the right predicate.
  id: totrans-436
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The predicate itself is rather simple. It''s just a question of matching one
    of the fields of each map:'
  id: totrans-437
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE110]'
  id: totrans-438
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'Use this predicate with `filter` in the function:'
  id: totrans-439
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE111]'
  id: totrans-440
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'Try calling `federer-wins`. You will receive the following output:'
  id: totrans-441
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 4.7: Printing the details'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14502_04_07.jpg)'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.7: Printing the details'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
- en: This seems to work!
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
- en: This exercise shows how writing a query is as simple as writing a new predicate.
    You have all the power and flexibility of the Clojure language at hand to describe
    exactly what results you need. In the next exercise, we will use a higher-order
    functional technique to write a dedicated query function.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 4.14: A Dedicated Query Function'
  id: totrans-447
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Your team is happy with the initial results and now they have started asking
    you to run new queries all the time. You are tired of writing the same code each
    time, so you''ve decided to write a function that can accept any predicate. Let''s
    get started:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
- en: Use the same environment as in the previous exercise.
  id: totrans-449
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Rewrite the `federer-wins` function as `match-query`, which takes a second
    argument, that is, `pred`:'
  id: totrans-450
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE112]'
  id: totrans-451
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE112]'
- en: Write a predicate to search for all of Federer's matches, wins, and losses.
  id: totrans-452
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'One possibility would be to simply add an `or` operator:'
  id: totrans-453
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE113]'
  id: totrans-454
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'We could also use a set as a predicate, as we saw earlier:'
  id: totrans-455
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE114]'
  id: totrans-456
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'First, we define a set that includes the `:winner_name` and `:loser_name` fields
    and then we ask: is `Roger Federer` a member of that set?'
  id: totrans-457
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  id: totrans-458
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We've written `hash-set` here instead of using the literal notation, `#{…}`,
    to avoid confusion with the `#(…)` of the anonymous function. `hash-set` and `set`
    do the same thing, that is, they create Clojure sets, except that `set` takes
    a single collection as an argument, while `hash-set` takes any number of items.
  id: totrans-459
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Test this by counting the number of matches played and the number of matches
    won using the predicate from the previous exercise:'
  id: totrans-460
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.8: Number of matches played and won by Federer'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14502_04_08.jpg)'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.8: Number of matches played and won by Federer'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
- en: Now, we know that, in our dataset, Federer played `1,290` matches and won `1,050`
    times!
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
- en: Providing a predicate as an argument makes writing queries like this very convenient.
    It becomes easier to write more and more complex queries. In the next exercise,
    we will continue to build on this.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 4.15: Using filter to Find a Tennis Rivalry'
  id: totrans-466
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As your team''s deadline approaches, the journalists are asking for more and
    more specific queries. They''ve decided to write an article about one of the most
    famous rivalries in modern tennis, that is, between Roger Federer and Rafael Nadal.
    They want you to write two queries: the first should return all the matches between
    the two players, while the second should return only the matches where the score
    was very close. Let''s get started:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
- en: Use the same environment as the previous exercises.
  id: totrans-468
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Write a predicate that will select all the matches between the two players.
    One possibility would be to use `or`, like this:'
  id: totrans-469
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE115]'
  id: totrans-470
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'This would work, but you can see that the logic is getting more complex because
    we have to account for two different possibilities. This is where sets can be
    very useful:'
  id: totrans-471
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE116]'
  id: totrans-472
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE116]'
- en: Sets are great for these kinds of situations. We don't care about the order,
    or, unlike the players themselves, which one is the winner or the loser.
  id: totrans-473
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Test this predicate using the `match-query` function from the previous exercise:'
  id: totrans-474
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 4.9: Testing the predicate'
  id: totrans-475
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14502_04_09.jpg)'
  id: totrans-476
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 4.9: Testing the predicate'
  id: totrans-477
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This seems to work. Now, we need to narrow down the results to the closest matches.
  id: totrans-478
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Update `match-query` so that we can do arithmetic on the fields. To know whether
    a match was close, we need to be able to subtract `:loser_sets_won` from `:winner_sets_won`.
    We have a problem, though: the values are strings here and not integers, so we
    can''t subtract. To fix this, we need to go back to `match-query` and reintroduce
    the type conversions that we used in the previous exercises. Here''s the new version
    of `match-query`:'
  id: totrans-479
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE117]'
  id: totrans-480
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE117]'
- en: Write a predicate for close matches.
  id: totrans-481
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We''ll use `and` to combine the Federer-Nadal predicate with a test for the
    difference in sets won:'
  id: totrans-482
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE118]'
  id: totrans-483
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'Let''s test our new predicate:'
  id: totrans-484
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.10: Printing the results'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14502_04_10.jpg)'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.10: Printing the results'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
- en: The results tell the story of one of the great rivalries in sports!
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
- en: 'As long as we are searching for lists of results, `map`, `filter`, and some
    carefully crafted predicates can accomplish a lot: `map` prepares the data while
    `filter` finds the items we are looking for.'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 4.02: Arbitrary Tennis Rivalries'
  id: totrans-490
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Your data consultancy team is encouraged by what they could learn by looking
    at the Federer-Nadal rivalry data and they want to be able to expand the approach.
    They've asked you to write a function that will find some summary statistics about
    all the matches between any two players. They would also like to have a list of
    the most competitive matches between the players.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the tennis dataset, write a function that provides information about
    a tennis rivalry. The call signature should look like this:'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  id: totrans-493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'The function should return a map with the following fields:'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  id: totrans-495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: The values in the `:total-*` fields should be integers. The other fields should
    be (possibly empty) lists of matches. When displaying matches in the results,
    limit the fields to those displayed in the previous example, that is, `:winner_name`,
    `:loser_name`, `:winner_sets_won`, `:loser_sets_won`, `:winner_games_won`, `:loser_games_won`,
    `:tourney_year_id`, and `:tourney_slug`.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
- en: Save your function in the same file that you did for *Exercise 4.12*, *Parsing
    CSV with semantic-csv*.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
- en: 'These steps will help you to complete this activity:'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
- en: Don't forget to use the same calls to `sc/mappify` and `sc/cast-with` to make
    your data easy to work with.
  id: totrans-499
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Within the scope of a `with-open` macro, use `let` to bind the lazy sequence
    of all the matches between the two players to a local symbol. Use that binding
    later whenever you need to match data, rather than rereading from the `.csv` file.
  id: totrans-500
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To calculate each result field, you will need to filter the list of matches
    in a different way.
  id: totrans-501
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For the `:total-*` fields, obtain the correct sequences and then use `count`.
  id: totrans-502
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For the fields that show matches, use `select-keys` to keep only the fields
    we are interested in.
  id: totrans-503
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following is the expected outcome:'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
- en: 'For any two players who have actually played against each other, your function
    should produce summary data:'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: Note
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
- en: The solution to this activity can be found on page 691.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-509
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have looked at how to use two of Clojure's most important
    and useful functions for handling sequential data. From a practical point of view,
    you have seen how to use `map` and `filter`, as well as some patterns and idioms
    for accomplishing common tasks and avoiding some common problems. You are starting
    to build your mental toolkit for working with collections.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
- en: Working with `map` and `filter` means we are working with lazy sequences, and
    so this chapter explored some of the ins and outs of lazy evaluation, which is
    one of Clojure's fundamental building blocks.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
- en: The techniques for reading and parsing files, extracting, querying, and manipulating
    data will also be useful right away as we continue to build on these data-handling
    techniques in the next chapter.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
