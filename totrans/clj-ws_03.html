<html><head></head><body>
		<div>
			<div id="_idContainer023" class="Content">
			</div>
		</div>
		<div id="_idContainer024" class="Content">
			<h1 id="_idParaDest-52"><a id="_idTextAnchor054"/>3. Functions in Depth</h1>
		</div>
		<div id="_idContainer026" class="Content">
			<p class="callout-heading">Overview</p>
			<p class="callout">In this chapter, we will take a deep dive into Clojure's functions. We discover destructuring techniques and advanced call signatures. We take a closer look at the first-class aspect of functions and learn how it enables functional composition, as well as advanced polymorphism techniques. This chapter teaches techniques that will significantly improve the conciseness and readability of your code. It lays down a solid basis to prepare you for the second part of this book about manipulating collections.</p>
			<p class="callout">By the end of this chapter, you will be able to implement features such as destructuring, variadic functions and multimethods when writing functions.</p>
			<h1 id="_idParaDest-53"><a id="_idTextAnchor055"/>Introduction</h1>
			<p>Clojure is a functional programming language, and functions are of primordial importance to the Clojure programmer. In functional programming, we avoid mutating the state of a program, which, as we have seen in the previous chapter, is greatly facilitated by Clojure's immutable data structures. We also tend to do everything with functions, such that we need functions to be able to do pretty much everything. We say that Clojure functions are <strong class="bold">first-class citizens</strong> because we can pass them to other functions, store them in variables, or return them from other functions: we also call them first-class functions. Consider an e-commerce application, for example, where a user is presented with a list of items with different search filters and sorting options. Developing such a filtering engine with flags and conditions in an imperative programming way can quickly become unnecessarily complex; however, it can be elegantly expressed with functional programming. Functional composition is a great way to simply and efficiently implement such a filtering engine, for each filter (for example, the price, color, size of an item, and so on), the logic can be contained within a function and those functions could be simply combined or composed as a user interacts with an interface.</p>
			<p>In this chapter, you will learn how to master functions. We will start with destructuring techniques, which can notably be used in function parameters, then we will move on to advanced call signatures including functions with multiple arities and a variable number of arguments. Then, we will dive into the first-class aspect of functions and learn how they enable functional composition. Finally, we will explain advanced polymorphism techniques with multimethods and dispatch functions.</p>
			<h1 id="_idParaDest-54"><a id="_idTextAnchor056"/>Destructuring</h1>
			<p>Destructuring allows you to remove data elements from their structure or disassemble a structure. It is a technique that improves the readability and conciseness of your code by providing a better tool for a widely used pattern. There are two main ways of destructuring data: sequentially (with vectors) and associatively (with maps).</p>
			<p>Imagine that we need to write a function that prints a formatted string given a tuple of coordinates, for example, the tuple <strong class="source-inline">[48.9615, 2.4372]</strong>. We could write the following function:</p>
			<p class="source-code">(defn print-coords [coords]</p>
			<p class="source-code">  (let [lat (first coords)</p>
			<p class="source-code">        lon (last coords)]</p>
			<p class="source-code">    (println (str "Latitude: " lat " - " "Longitude: " lon))))</p>
			<p>This <strong class="source-inline">print-coords</strong> function takes a tuple of coordinates as a parameter and prints out the coordinates to the console in a nicely formatted string, for example, <strong class="source-inline">Latitude:</strong> <strong class="source-inline">48.9615</strong> – <strong class="source-inline">Longitude:</strong> <strong class="source-inline">2.4372</strong>.</p>
			<p>What we are essentially doing when binding the first element to <strong class="source-inline">lat</strong> and the second to <strong class="source-inline">lon</strong> is destructuring: we are taking each element out of their sequential data structure. This use case is very common, and Clojure provides a built-in syntax for destructuring data structures to bind their values to symbols.</p>
			<p>We could rewrite the <strong class="source-inline">print-coords</strong> function with a sequential destructuring technique as follows:</p>
			<p class="source-code">(defn print-coords [coords]</p>
			<p class="source-code">  (let [[lat lon] coords]</p>
			<p class="source-code">    (println (str "Latitude: " lat " - " "Longitude: " lon))))</p>
			<p>Observe how the preceding example is shorter and more expressive than the one before. We didn't need to use a function like <strong class="source-inline">first</strong> or <strong class="source-inline">last</strong>, we simply expressed the symbols we wanted to retrieve.</p>
			<p>The two functions are equivalent. <strong class="source-inline">lat</strong> is "mapped" to the first element of the vector and <strong class="source-inline">lon</strong> to the second. This other, simpler example might be more visually helpful:</p>
			<p class="source-code">user=&gt;(let</p>
			<p class="source-code">;;</p>
			<p class="source-code">;;     [1 2 3]</p>
			<p class="source-code">;;      | | |</p>
			<p class="source-code">      [[a b c] [1 2 3]] (println a b c))</p>
			<p class="source-code">1 2 3</p>
			<p class="source-code">nil</p>
			<p>Notice how the bindings are created according to both the sequential order of the vector and the order of the symbols defined in vector <strong class="source-inline">[a b c]</strong>. The symbol values are then printed out to the console.</p>
			<p>A list, which is a sequential data structure, can be similarly disassembled:</p>
			<p class="source-code">user=&gt; (let [[a b c] '(1 2 3)] (println a b c))</p>
			<p class="source-code">1 2 3</p>
			<p class="source-code">nil</p>
			<p>Consider the same example of printing the coordinates of an airport, but this time we receive the data as a map rather than a tuple. The data has the following shape: <strong class="source-inline">{:lat 48.9615, :lon 2.4372, :code 'LFPB', :name "Paris Le Bourget Airport"}</strong>.</p>
			<p>We could write the following function:</p>
			<p class="source-code">(defn print-coords [airport]</p>
			<p class="source-code">  (let [lat (:lat airport)</p>
			<p class="source-code">        lon (:lon airport)</p>
			<p class="source-code">        name (:name airport)]</p>
			<p class="source-code">    (println (str name " is located at Latitude: " lat " - " "Longitude: " lon))))</p>
			<p>This function retrieves the values from the <strong class="source-inline">airport</strong> map by using the keywords as functions in the <strong class="source-inline">let</strong> expression. We can spot the repetitive pattern when binding <strong class="source-inline">lat</strong>, <strong class="source-inline">lon</strong>, and <strong class="source-inline">name</strong>. Similarly, when the data structure we want to disassemble is associative (a <strong class="source-inline">map</strong>), we can use an associative <em class="italic">destructuring</em> technique. The function can be rewritten using associative destructuring, as follows:</p>
			<p class="source-code">(defn print-coords [airport]</p>
			<p class="source-code">  (let [{lat :lat lon :lon airport-name :name} airport]</p>
			<p class="source-code">    (println (str airport-name " is located at Latitude: " lat " - " "Longitude: " lon))))</p>
			<p>With this technique, we are creating bindings by mapping the symbols to the keys inside the map. The <strong class="source-inline">lat</strong> symbol now contains the value in the airport map at the key <strong class="source-inline">:lat</strong>, <strong class="source-inline">lon</strong> is mapped to the key <strong class="source-inline">:lon</strong>, and, finally, the <strong class="source-inline">airport-name</strong> symbol is mapped to the key <strong class="source-inline">:name</strong>.</p>
			<p>When the keys and symbols can all have the same name, there is a shorter syntax available:</p>
			<p class="source-code">(defn print-coords [airport]</p>
			<p class="source-code">  (let [{:keys [lat lon name]} airport]</p>
			<p class="source-code">    (println (str name " is located at Latitude: " lat " - " "Longitude: " lon))))</p>
			<p>The preceding destructuring syntax indicates looking for the <strong class="source-inline">lat</strong>, <strong class="source-inline">lon</strong>, and <strong class="source-inline">name</strong> keys inside the <strong class="source-inline">airport</strong> map and binding them to symbols with the same name. The syntax might look a little bit surprising, but it is a widely used technique in Clojure. We will use it in the next exercise so that you can learn how to use it.</p>
			<p>Let's see our final function in action:</p>
			<p class="source-code">user=&gt; (def airport {:lat 48.9615, :lon 2.4372, :code 'LFPB', :name "Paris Le Bourget Airport"})</p>
			<p class="source-code">#'user/airport</p>
			<p class="source-code">(defn print-coords [airport]</p>
			<p class="source-code">  (let [{:keys [lat lon name]} airport]</p>
			<p class="source-code">    (println (str name " is located at Latitude: " lat " - " "Longitude: " lon))))</p>
			<p class="source-code">#'user/print-coords</p>
			<p class="source-code">user=&gt; (print-coords airport)</p>
			<p class="source-code">Paris Le Bourget Airport is located at Latitude: 48.9615 - Longitude: 2.4372</p>
			<p class="source-code">nil</p>
			<p>In the preceding example, the <strong class="source-inline">print-coords</strong> function destructures the airport <strong class="source-inline">map</strong> in the <strong class="source-inline">let</strong> expression and binds the values <strong class="source-inline">48.9615</strong>, <strong class="source-inline">2.4372</strong>, and <strong class="source-inline">Paris Le Bourget Airport</strong> to the symbols (respectively) <strong class="source-inline">lat</strong>, <strong class="source-inline">lon</strong>, and <strong class="source-inline">name</strong>. Those values are then printed out to the console with the <strong class="source-inline">println</strong> function (which returns <strong class="source-inline">nil</strong>).</p>
			<p>Now that we've discovered the basics of destructuring and its utility, we can move on to the REPL, start practicing, and learn even more advanced destructuring techniques.</p>
			<h2 id="_idParaDest-55"><a id="_idTextAnchor057"/>Exercise 3.01: Parsing Fly Vector's Data with Sequential Destructuring</h2>
			<p>For the purpose of this exercise, imagine that we are building a flight-booking platform application. For our first prototype, we just want to parse and print flight data that we receive from our partners. Our first partner, Fly Vector, has not yet discovered the power of associative data structures and they send us all their data in the form of Vectors. Luckily, they have comprehensive documentation. I have done the heavy lifting of reading the hundreds of pages of the data format specification for you and here is what it boils down to:</p>
			<ul>
				<li>A coordinate point is a tuple of latitude and longitude, for example: <strong class="source-inline">[48.9615, 2.4372]</strong>.</li>
				<li>A flight is a tuple of two coordinate points, for example: <strong class="source-inline">[[48.9615, 2.4372], [37.742, -25.6976]]</strong>.</li>
				<li>A booking consists of some information followed by one or multiple flights (up to three). The first item is Fly Vector's internal ID for the booking, the second item is the name of the passenger, and the third is some sensitive information that Fly Vector asked us not to parse or even look at (they couldn't update their system to remove the information). Finally, the rest of the vector consists of the flight coordinates data, for example:<p class="source-code">[</p><p class="source-code">  1425,</p><p class="source-code">  "Bob Smith",</p><p class="source-code">  "Allergic to unsalted peanuts only",</p><p class="source-code">  [[48.9615, 2.4372], [37.742, -25.6976]],</p><p class="source-code">  [[37.742, -25.6976], [48.9615, 2.4372]]</p><p class="source-code">]</p></li>
			</ul>
			<p>That should be enough information for us to develop the prototype, so let's get started:</p>
			<ol>
				<li>Open a REPL and bind the sample booking data to the <strong class="source-inline">booking</strong> symbol:<p class="source-code">user=&gt; (def booking [1425, "Bob Smith", "Allergic to unsalted peanuts only", [[48.9615, 2.4372], [37.742, -25.6976]], [[37.742, -25.6976], [48.9615, 2.4372]]])</p><p class="source-code">#'user/booking</p></li>
				<li>Start developing our parsing function by experimenting with destructuring. Create a <strong class="source-inline">let</strong> block and define the binding as follows, printing out the result with <strong class="source-inline">println</strong>:<p class="source-code">user=&gt; (let [[id customer-name sensitive-info flight1 flight2 flight3] booking] (println id customer-name flight1 flight2 flight3))</p><p class="source-code">1425 Bob Smith [[48.9615 2.4372] [37.742 -25.6976]] [[37.742 -25.6976] [48.9615 2.4372]] nil</p><p class="source-code">nil</p><p>Notice that <strong class="source-inline">flight3</strong> was bound to the value <strong class="source-inline">nil</strong>. This is because the data is shorter than the bindings defined, and it is both valid and useful to be able to bind only values that exist.</p><p>Similarly, if the booking vector contained extra data, it would be ignored.</p></li>
				<li>Remember that <strong class="source-inline">conj</strong> takes a collection and some elements as arguments and returns a new collection with those elements added to the collection. Add two flights in the booking vector with <strong class="source-inline">conj</strong> and parse the data using the same destructuring expression:<p class="source-code">user=&gt; (let [big-booking (conj booking [[37.742, -25.6976], [51.1537, 0.1821]] [[51.1537, 0.1821], [48.9615, 2.4372]])</p><p class="source-code">       [id customer-name sensitive-info flight1 flight2 flight3] big-booking]</p><p class="source-code">  (println id customer-name flight1 flight2 flight3))</p><p class="source-code">1425 Bob Smith [[48.9615 2.4372] [37.742 -25.6976]] [[37.742 -25.6976] [48.9615 2.4372]] [[37.742 -25.6976] [51.1537 0.1821]]</p><p class="source-code">nil</p><p>Notice how the last flight was simply ignored and not printed out. That's another useful trait of destructuring and another sign of Clojure's dynamism and practicality.</p></li>
				<li>In the data received, we don't really care about the Fly Vector internal ID and we don't want to parse the sensitive information. This can be simply ignored by using an underscore, <strong class="source-inline">_</strong>, instead of a symbol:<p class="source-code">user=&gt; (let [[_ customer-name _ flight1 flight2 flight3] booking] (println customer-name flight1 flight2 flight3))</p><p class="source-code">Bob Smith [[48.9615 2.4372] [37.742 -25.6976]] [[37.742 -25.6976] [48.9615 2.4372]] nil</p><p class="source-code">nil</p><p>Great, we now understand how to ignore some parts of the data with destructuring. </p><p>Just printing the array of coordinates is not very readable, so until we have a better way of printing out flights, we would like to simply display the number of flights in the booking. Surely, we could test <strong class="source-inline">flight1</strong>, <strong class="source-inline">flight2</strong>, and <strong class="source-inline">flight3</strong> for the presence of a value but there's another aspect of destructuring that we could use: the "remaining" parts of the sequence. By using the <strong class="source-inline">&amp;</strong> character followed by a symbol, we can bind the remaining part of a sequence to a given symbol.</p></li>
				<li>Bind the <strong class="source-inline">flights</strong> sequence to a <strong class="source-inline">flights</strong> symbol by using the <strong class="source-inline">&amp;</strong> character, then display the number of flights as follows:<p class="source-code">user=&gt; (let [[_ customer-name _ &amp; flights] booking]</p><p class="source-code">  (println (str customer-name " booked " (count flights) " flights.")))</p><p class="source-code">Bob Smith booked 2 flights.</p><p class="source-code">nil</p><p>Notice that <strong class="source-inline">flights</strong> is now a collection and, therefore, we can use the <strong class="source-inline">count</strong> function with it.</p><p>Destructuring is very powerful and can also disassemble nested data structures. To parse and print the flight details, let's create a separate function to keep the code clear and readable.</p></li>
				<li>Create a <strong class="source-inline">print-flight</strong> function that disassembles a flight path using nested destructuring and print out a nicely formatted flight itinerary:<p class="source-code">user=&gt;</p><p class="source-code">(defn print-flight [flight]</p><p class="source-code">  (let [[[lat1 lon1] [lat2 lon2]] flight]</p><p class="source-code">    (println (str "Flying from: Lat " lat1 " Lon " lon1 " Flying to: Lat " lat2 " Lon " lon2))))</p><p class="source-code">#'user/print-flight</p><p class="source-code">user=&gt; (print-flight [[48.9615, 2.4372], [37.742 -25.6976]])</p><p class="source-code">Flying from: Lat 48.9615 Lon 2.4372 Flying to: Lat 37.742 Lon -25.6976</p><p>Notice how we dug into the nested vectors contained in <strong class="source-inline">flight</strong> to retrieve the coordinate values inside the coordinate tuples, by simply using nested vector literal notation. However, the nested vectors in the <strong class="source-inline">let</strong> bindings can be slightly hard to read. </p></li>
				<li>Rewrite the <strong class="source-inline">print-flight</strong> function by decomposing the steps in multiple <strong class="source-inline">let</strong> bindings:<p class="source-code">user=&gt;</p><p class="source-code">(defn print-flight [flight]</p><p class="source-code">  (let [[departure arrival] flight</p><p class="source-code">        [lat1 lon1] departure</p><p class="source-code">        [lat2 lon2] arrival]</p><p class="source-code">    (println (str "Flying from: Lat " lat1 " Lon " lon1 " Flying to: Lat " lat2 " Lon " lon2))))</p><p class="source-code">#'user/print-flight</p><p class="source-code">user=&gt; (print-flight [[48.9615, 2.4372], [37.742 -25.6976]])</p><p class="source-code">Flying from: Lat 48.9615 Lon 2.4372 Flying to: Lat 37.742 Lon -25.6976</p><p class="source-code">nil</p><p>In the preceding example, we have created two intermediate bindings using sequential destructuring: <strong class="source-inline">departure</strong> and <strong class="source-inline">arrival</strong>. Those two bindings contain coordinates tuples that we can destructure further to create the latitude and longitude bindings <strong class="source-inline">lat1</strong>, <strong class="source-inline">lon1</strong>, <strong class="source-inline">lat2</strong>, and <strong class="source-inline">lon2</strong>.</p></li>
				<li>Finally, let's write the <strong class="source-inline">print-booking</strong> function by combining the code we have written so far:<p class="source-code">(defn print-booking [booking]</p><p class="source-code">  (let [[_ customer-name _ &amp; flights] booking]</p><p class="source-code">    (println (str customer-name " booked " (count flights) " flights."))</p><p class="source-code">    (let [[flight1 flight2 flight3] flights]</p><p class="source-code">      (when flight1 (print-flight flight1))</p><p class="source-code">      (when flight2 (print-flight flight2))</p><p class="source-code">      (when flight3 (print-flight flight3)))))</p><p class="source-code">#'user/print-booking</p><p class="source-code">user=&gt; (print-booking booking)</p><p class="source-code">Bob Smith booked 2 flights.</p><p class="source-code">Flying from: Lat 48.9615 Lon 2.4372 Flying to: Lat 37.742 Lon -25.6976</p><p class="source-code">Flying from: Lat 37.742 Lon -25.6976 Flying to: Lat 48.9615 Lon 2.4372</p><p class="source-code">nil</p></li>
			</ol>
			<p>Great job! In this exercise, we've successfully used <em class="italic">sequential destructuring</em> to parse and retrieve data from a vector and improve the readability and conciseness of our code. Now, let's move on to the next exercise, where we will use <em class="italic">associative destructuring</em>.</p>
			<h2 id="_idParaDest-56"><a id="_idTextAnchor058"/>Exercise 3.02: Parsing MapJet Data with Associative Destructuring</h2>
			<p>Let's continue with our flight booking platform application. Now we would like to develop the same parser for another partner called MapJet. You might have guessed, MapJet has discovered the power of associative data structures and are sending us nice and intelligible data structures, which consist of both maps and vectors. Now, the data is self-explanatory and even if MapJet provides very detailed documentation, we won't even bother reading it.</p>
			<p>Let's have a look at the data shape of a sample booking:</p>
			<p class="source-code">  {</p>
			<p class="source-code">    :id 8773</p>
			<p class="source-code">    :customer-name "Alice Smith"</p>
			<p class="source-code">    :catering-notes "Vegetarian on Sundays"</p>
			<p class="source-code">    :flights [</p>
			<p class="source-code">      {</p>
			<p class="source-code">        :from {:lat 48.9615 :lon 2.4372 :name "Paris Le Bourget Airport"},</p>
			<p class="source-code">        :to {:lat 37.742 :lon -25.6976 :name "Ponta Delgada Airport"}},</p>
			<p class="source-code">      {</p>
			<p class="source-code">        :from {:lat 37.742 :lon -25.6976 :name "Ponta Delgada Airport"},</p>
			<p class="source-code">        :to {:lat 48.9615 :lon 2.4372 :name "Paris Le Bourget Airport"}}</p>
			<p class="source-code">    ]</p>
			<p class="source-code">  }</p>
			<p>First, let's agree on the fact that maps are a great way to exchange data. They are very readable for us humans, and simple to parse for our programs. Now, let's get back to the REPL and see how associative destructuring can help us manipulate the data:</p>
			<ol>
				<li value="1">Bind the sample booking map to the <strong class="source-inline">mapjet-booking</strong> symbol as follows:<p class="source-code">user=&gt;</p><p class="source-code">(def mapjet-booking</p><p class="source-code">  {</p><p class="source-code">    :id 8773</p><p class="source-code">    :customer-name "Alice Smith"</p><p class="source-code">    :catering-notes "Vegetarian on Sundays"</p><p class="source-code">    :flights [</p><p class="source-code">      {</p><p class="source-code">        :from {:lat 48.9615 :lon 2.4372 :name "Paris Le Bourget Airport"},</p><p class="source-code">        :to {:lat 37.742 :lon -25.6976 :name "Ponta Delgada Airport"}},</p><p class="source-code">      {</p><p class="source-code">        :from {:lat 37.742 :lon -25.6976 :name "Ponta Delgada Airport"},</p><p class="source-code">        :to {:lat 48.9615 :lon 2.4372 :name "Paris Le Bourget Airport"}}</p><p class="source-code">    ]</p><p class="source-code">  })</p><p class="source-code">#'user/mapjet-booking</p></li>
				<li>Using associative destructuring, print the booking summary as we did for Fly Vector (the name of the customer and the number of flights):<p class="source-code">user=&gt; (let [{:keys [customer-name flights]} mapjet-booking] (println (str customer-name " booked " (count flights) " flights.")))</p><p class="source-code">Alice Smith booked 2 flights.</p><p class="source-code">nil</p><p>By using the shorter and non-repetitive syntax with <strong class="source-inline">:keys</strong>, we were able to fetch the keys inside the map and bind their values to symbols with the same name.</p></li>
				<li> Let's write a <strong class="source-inline">print-mapjet-flight</strong> function to print the flight details:<p class="source-code">user=&gt; (defn print-mapjet-flight [flight]</p><p class="source-code">  (let [{:keys [from to]} flight</p><p class="source-code">        {lat1 :lat lon1 :lon} from</p><p class="source-code">        {lat2 :lat lon2 :lon} to]</p><p class="source-code">    (println (str "Flying from: Lat " lat1 " Lon " lon1 " Flying to: Lat " lat2 " Lon " lon2))))</p><p class="source-code">user=&gt; (print-mapjet-flight (first (:flights mapjet-booking)))</p><p class="source-code">Flying from: Lat 48.9615 Lon 2.4372 Flying to: Lat 37.742 Lon -25.6976</p><p class="source-code">nil</p><p>Notice that we cannot use the shorter syntax for extracting coordinates because the names <strong class="source-inline">lat</strong> and <strong class="source-inline">lon</strong> would conflict; therefore, we used the normal syntax, allowing us to explicitly declare a new binding to symbols with different names.</p><p>As with vectors, we can nest destructuring expressions, and even combine the two techniques.</p></li>
				<li>Let's rewrite the <strong class="source-inline">print-mapjet-flight</strong> function, but this time we are going to nest our associative destructuring expressions:<p class="source-code">user=&gt;(defn print-mapjet-flight [flight]</p><p class="source-code">  (let [{{lat1 :lat lon1 :lon} :from,</p><p class="source-code">         {lat2 :lat lon2 :lon} :to} flight]</p><p class="source-code">    (println (str "Flying from: Lat " lat1 " Lon " lon1 " Flying to: Lat " lat2 " Lon " lon2))))</p><p class="source-code">#'user/print-mapjet-flight</p><p class="source-code">user=&gt; (print-mapjet-flight (first (:flights mapjet-booking)))</p><p class="source-code">Flying from: Lat 48.9615 Lon 2.4372 Flying to: Lat 37.742 Lon -25.6976</p><p class="source-code">nil</p><p>The preceding example is slightly complicated to read so don't worry if it looks a bit confusing at first. Think of the key of a destructuring map as the target, and the source as the value, as follows: <strong class="source-inline">{target1 source1 target2 source2}</strong>. The target can either be a symbol, or another destructuring map like this: <strong class="source-inline">{{target3 source3} source1 {target4 source4} source2}</strong>. Notice, in this last expression, how we just bind values to the symbols in the innermost map (<strong class="source-inline">target3</strong> and <strong class="source-inline">target4</strong>). This is what we just did in the <strong class="source-inline">print-mapjet-flight</strong> function: we extracted the nested values of latitude and longitude for both coordinate points.</p></li>
				<li>Write the final function for printing MapJet bookings, using the code to print the booking summary to the console. It should produce a similar output to Fly Vector's <strong class="source-inline">print-booking</strong> function, first printing the number of flights and then printing each flight individually with <strong class="source-inline">print-mapjet-flight</strong> as follows:<p class="source-code">user=&gt;</p><p class="source-code">(defn print-mapjet-booking [booking]</p><p class="source-code">  (let [{:keys [customer-name flights]} booking]</p><p class="source-code">    (println (str customer-name " booked " (count flights) " flights."))</p><p class="source-code">    (let [[flight1 flight2 flight3] flights]</p><p class="source-code">      (when flight1 (print-mapjet-flight flight1)) flights</p><p class="source-code">      (when flight2 (print-mapjet-flight flight2))</p><p class="source-code">      (when flight3 (print-mapjet-flight flight3)))))</p><p class="source-code">user=&gt; (print-mapjet-booking mapjet-booking)</p><p>The output is as follows:</p><p class="source-code">Alice Smith booked 2 flights.</p><p class="source-code">Flying from: Lat 48.9615 Lon 2.4372 Flying to: Lat 37.742 Lon -25.6976</p><p class="source-code">Flying from: Lat 37.742 Lon -25.6976 Flying to: Lat 48.9615 Lon 2.4372</p></li>
			</ol>
			<p>It works! We have now finished our first prototype. In this exercise, we have implemented a <strong class="source-inline">Map</strong> parser that prints out data that has been destructured to the console. Well done!</p>
			<p>Destructuring techniques are essential because they can make our code more concise and more readable. Additionally, the data that our programs have to deal with often comes from external data sources, and we don't always own the shape of the data we need to handle. Having a powerful tool to dig into various data structures significantly improves our quality of life as programmers.</p>
			<p>However, the code we have written in the previous exercise feels somehow repetitive; the two <strong class="source-inline">print-booking</strong> functions, for example, have a lot in common. With what we currently know, it would be difficult to refactor this code. But don't worry, the techniques we are going to learn in the next topics will allow you to write even more elegant code, with less repetition, less code, and therefore fewer bugs.</p>
			<h1 id="_idParaDest-57"><a id="_idTextAnchor059"/>Advanced Call Signatures</h1>
			<p>So far, we have been declaring functions with one arity (with only a fixed number of arguments), and simply binding the arguments passed to a function to some parameter names. However, Clojure has a few techniques to allow more flexibility when calling functions.</p>
			<h2 id="_idParaDest-58"><a id="_idTextAnchor060"/>Destructuring Function Parameters</h2>
			<p>First, everything we have just learned about destructuring applies to function parameters. Yes, you read that correctly – we can use destructuring techniques right in the function parameter declaration! As promised, here's our first stab at refactoring the <strong class="source-inline">print-flight</strong> functions from the previous exercise. Observe, in the following example, how sequential destructuring is used directly in the function parameters:</p>
			<p class="source-code">user=&gt;</p>
			<p class="source-code">(defn print-flight</p>
			<p class="source-code">  [[[lat1 lon1] [lat2 lon2]]]</p>
			<p class="source-code">    (println (str "Flying from: Lat " lat1 " Lon " lon1 " Flying to: Lat " lat2 " Lon " lon2)))</p>
			<p class="source-code">#'user/print-flight</p>
			<p class="source-code">user=&gt; (print-flight [[48.9615, 2.4372], [37.742 -25.6976]])</p>
			<p class="source-code">Flying from: Lat 48.9615 Lon 2.4372 Flying to: Lat 37.742 Lon -25.6976</p>
			<p class="source-code">nil</p>
			<p>Notice how we got rid of the <strong class="source-inline">let</strong> expression. Similarly, we can do the same for <strong class="source-inline">print-mapjet-flight</strong>, with associative destructuring used in the function parameters:</p>
			<p class="source-code">user=&gt;</p>
			<p class="source-code">(defn print-mapjet-flight</p>
			<p class="source-code">  [{{lat1 :lat lon1 :lon} :from, {lat2 :lat lon2 :lon} :to}]</p>
			<p class="source-code">    (println (str "Flying from: Lat " lat1 " Lon " lon1 " Flying to: Lat " lat2 " Lon " lon2)))</p>
			<p class="source-code">#'user/print-mapjet-flight</p>
			<p class="source-code">user=&gt; (print-mapjet-flight { :from {:lat 48.9615 :lon 2.4372}, :to {:lat 37.742 :lon -25.6976} })</p>
			<p class="source-code">Flying from: Lat 48.9615 Lon 2.4372 Flying to: Lat 37.742 Lon -25.6976</p>
			<p>Once again, we got rid of the <strong class="source-inline">let</strong> expression and destructured the parameter right away from the function arguments. Great – that is one new way of defining function parameters and improving our code even further.</p>
			<h2 id="_idParaDest-59"><a id="_idTextAnchor061"/>Arity Overloading</h2>
			<p>Second, Clojure supports "arity overloading," which means that we can <em class="italic">overload</em> a function with another function of the same name by specifying extra parameters to the new function. Those two functions have the same name but different implementations, and the function body to execute is chosen based on the number of arguments provided upon a function call. Here is an example:</p>
			<p class="source-code">user=&gt;</p>
			<p class="source-code">(defn no-overloading []</p>
			<p class="source-code">  (println "Same old, same old..."))</p>
			<p class="source-code">#'user/no-overloading</p>
			<p class="source-code">user=&gt;</p>
			<p class="source-code">(defn overloading</p>
			<p class="source-code">  ([] "No argument")</p>
			<p class="source-code">  ([a] (str "One argument: " a))</p>
			<p class="source-code">  ([a b] (str "Two arguments: a: " a " b: " b)))</p>
			<p class="source-code">#'user/overloading</p>
			<p>Notice how the different function implementations are defined. In the <strong class="source-inline">no-overloading</strong> function, which is how we are used to creating functions, there are no extra parentheses around the parameter declaration (which comes just after the function name). Whereas in the <strong class="source-inline">overloading</strong> function, each implementation is surrounded by parentheses, starting with the parameter declaration.</p>
			<p>Let's see how the multi-arity <strong class="source-inline">overloading</strong> function plays out:</p>
			<p class="source-code">user=&gt; (overloading)</p>
			<p class="source-code">"No argument"</p>
			<p>In the preceding code, no arguments were passed; therefore, the first implementation of the <strong class="source-inline">overloading</strong> function is called.</p>
			<p>Consider the following code:</p>
			<p class="source-code">user=&gt; (overloading 1)</p>
			<p class="source-code">"One argument: 1"</p>
			<p>In this case, one argument is passed to the <strong class="source-inline">overloading</strong> function, so the second implementation is called.</p>
			<p class="source-code">user=&gt; (overloading 1 2)</p>
			<p class="source-code">"Two arguments: a: 1 b: 2"</p>
			<p class="source-code">user=&gt; (overloading 1 nil)</p>
			<p class="source-code">"Two arguments: a: 1 b: "</p>
			<p>In the preceding code, two arguments are passed, so the third implementation of the <strong class="source-inline">overloading</strong> function is called.</p>
			<p class="source-code">user=&gt; (overloading 1 2 3)</p>
			<p class="source-code">Execution error (ArityException) at user/eval412 (REPL:1).</p>
			<p class="source-code">Wrong number of args (3) passed to: user/overloading</p>
			<p>Finally, an incorrect number of arguments produce the usual arity exception.</p>
			<p>You might (legitimately) wonder how this is useful, and why not just declare different functions? In fact, when defining multiple arities for the same function, you are saying that the functions are essentially the same, that they are doing a similar job, but the execution slightly varies based on the number of arguments. It can also be useful to provide default values. </p>
			<p>Consider the following code for a new little fantasy game called <strong class="bold">Parenthmazes</strong>, declaring a map of weapons associated with their damage and a <strong class="source-inline">strike</strong> function to compute the new state of an <strong class="source-inline">enemy</strong> entity:</p>
			<p class="source-code">user=&gt; (def weapon-damage {:fists 10 :staff 35 :sword 100 :cast-iron-saucepan 150})</p>
			<p class="source-code">#'user/weapon-damage</p>
			<p class="source-code">user=&gt;</p>
			<p class="source-code">(defn strike</p>
			<p class="source-code">  ([enemy] (strike enemy :fists))</p>
			<p class="source-code">  ([enemy weapon]</p>
			<p class="source-code">    (let [damage (weapon weapon-damage)]</p>
			<p class="source-code">      (update enemy :health - damage))))</p>
			<p class="source-code">#'user/strike</p>
			<p>In the preceding example, we start by defining a <strong class="source-inline">HashMap</strong> and binding it to the <strong class="source-inline">weapon-damage</strong> symbol. The second expression is the definition of the <strong class="source-inline">strike</strong> function, which subtracts damage from an <strong class="source-inline">enemy</strong> entity, retrieving the amount of damage in the <strong class="source-inline">weapon-damage</strong> map. Observe that the <strong class="source-inline">strike</strong> function has two implementations. The first implementation contains only one parameter, <strong class="source-inline">enemy</strong>, and the second implementation has two parameters: <strong class="source-inline">enemy</strong> and <strong class="source-inline">weapon</strong>. Notice how the first implementation is calling the second one by providing an extra parameter. Therefore, when calling the <strong class="source-inline">strike</strong> function with only one argument, the default value, <strong class="source-inline">:fists</strong>, will be provided:</p>
			<p class="source-code">user=&gt; (strike {:name "n00b-hunter" :health 100})</p>
			<p class="source-code">{:name "n00b-hunter", :health 90}</p>
			<p>Observe that the function was called with one parameter only (the <strong class="source-inline">enemy</strong> entity), which therefore went through the one-parameter implementation of the function, using <strong class="source-inline">:fists</strong> as a default value and returning an enemy with 90 points of health left (because fists do 10 points worth of damage): </p>
			<p class="source-code">user=&gt; (strike {:name "n00b-hunter" :health 100} :sword)</p>
			<p class="source-code">{:name "n00b-hunter", :health 0}</p>
			<p class="source-code">user=&gt; (strike {:name "n00b-hunter" :health 100} :cast-iron-saucepan)</p>
			<p class="source-code">{:name "n00b-hunter", :health -50}</p>
			<p>In the preceding example, the <strong class="source-inline">strike</strong> function was called directly with the two-arity implementation, because the second parameter, <strong class="source-inline">weapon</strong>, was explicitly provided.</p>
			<h2 id="_idParaDest-60"><a id="_idTextAnchor062"/>Variadic Functions</h2>
			<p>There is a final secret left to reveal regarding function parameters. With what we have learned about function arity, how would you define the parameters of the <strong class="source-inline">str</strong> function, for example? </p>
			<p>It seems to take an infinite number of parameters. You might remember using <strong class="source-inline">str</strong> like this:</p>
			<p class="source-code">user=&gt; (str "Concatenating " "is " "difficult " "to " "spell " "but " "easy " "to " "use!")</p>
			<p class="source-code">"Concatenating is difficult to spell but easy to use!"</p>
			<p>But surely, it isn't implemented with overloading like this <strong class="source-inline">(defn str ([s] ...) ([s1 s2] ...) ([s1 s2 s3] ...) ([s1 s2 s3 s4] …))</strong> and so on… Then, what is happening in this case?</p>
			<p>This is the destructuring technique coming back into play. Remember that we can use the <strong class="source-inline">&amp;</strong> character to bind the remainder of a sequence to a data structure? It works similarly with function arguments, and we can create a data structure from the arguments passed to a function with the <strong class="source-inline">&amp;</strong> character. This is how you can create variadic functions (functions that take a variable number of arguments), and this is how the <strong class="source-inline">str</strong> function is implemented.</p>
			<p>Look at how the documentation describes the <strong class="source-inline">str</strong> function:</p>
			<p class="source-code">user=&gt; (doc str)</p>
			<p class="source-code">-------------------------</p>
			<p class="source-code">clojure.core/str</p>
			<p class="source-code">([] [x] [x &amp; ys])</p>
			<p class="source-code">  With no args, returns the empty string. With one arg x, returns</p>
			<p class="source-code">  x.toString().  <a id="_idTextAnchor063"/>(str nil) returns the empty string. With more than</p>
			<p class="source-code">  one arg, returns the concatenation of the str values of the args.</p>
			<p class="source-code">nil</p>
			<p>Notice the declaration of its different arities. It accepts either no element, <strong class="source-inline">[]</strong>, one element, <strong class="source-inline">[x]</strong>, or any number of elements, <strong class="source-inline">[x &amp; ys]</strong>.</p>
			<p>Let's try to use this new knowledge to create a function that prints a welcome message to the new player of <strong class="source-inline">Parenthmazes</strong>:</p>
			<p class="source-code">user=&gt;</p>
			<p class="source-code">(defn welcome</p>
			<p class="source-code">  [player &amp; friends]</p>
			<p class="source-code">  (println (str "Welcome to the Parenthmazes " player "!"))</p>
			<p class="source-code">  (when (seq friends)</p>
			<p class="source-code">    (println (str "Sending " (count friends) " friend request(s) to the following players: " (clojure.string/join ", " friends)))))</p>
			<p class="source-code">#'user/welcome</p>
			<p>Observe how we used the destructuring technique right in the function parameters, binding any arguments that come after <strong class="source-inline">player</strong> to the <strong class="source-inline">friends</strong> collection. Now, let's try to use our function with one and multiple arguments:</p>
			<p class="source-code">user=&gt; (welcome "Jon")</p>
			<p class="source-code">Welcome to the Parenthmazes Jon!</p>
			<p class="source-code">nil</p>
			<p class="source-code">user=&gt; (welcome "Jon" "Arya" "Tyrion" "Petyr")</p>
			<p class="source-code">Welcome to the Parenthmazes Jon!</p>
			<p class="source-code">Sending 3 friend request(s) to the following players: Arya, Tyrion, Petyr</p>
			<p class="source-code">nil</p>
			<p>Notice that when more than one argument is passed to the <strong class="source-inline">welcome</strong> function, the <strong class="source-inline">friends</strong> symbol is bound to a sequence containing the rest of the arguments.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The <strong class="source-inline">seq</strong> function can be used to get a sequence from a collection. In the <strong class="source-inline">welcome</strong> function, we use the <strong class="source-inline">seq</strong> function to test whether a collection contains elements. That's because <strong class="source-inline">seq</strong> returns <strong class="source-inline">nil</strong> when the collection passed as a parameter is empty. <strong class="source-inline">(if (seq (coll))</strong> is a commonly used pattern that you should use instead of <strong class="source-inline">(if (not (empty? coll)))</strong>.</p>
			<p>We could improve this function slightly. Instead of testing whether <strong class="source-inline">friends</strong> is empty, we could also take advantage of the multi-arity technique:</p>
			<p class="source-code">user=&gt;</p>
			<p class="source-code">(defn welcome</p>
			<p class="source-code">  ([player] (println (str "Welcome to Parenthmazes (single-player mode), " player "!")))</p>
			<p class="source-code">  ([player &amp; friends]</p>
			<p class="source-code">    (println (str "Welcome to Parenthmazes (multi-player mode), " player "!"))</p>
			<p class="source-code">    (println (str "Sending " (count friends) " friend request(s) to the following players: " (clojure.string/join ", " friends)))))</p>
			<p class="source-code">#'user/welcome</p>
			<p>Notice how, this time, two <strong class="source-inline">welcome</strong> functions were defined, one with only one <strong class="source-inline">player</strong> parameter, and a second one with an unlimited number of parameters that will be bound to the <strong class="source-inline">friends</strong> symbol. Separating the functions like this improves the clarity of the code by being more explicit about the intent of the function as well as removing the conditional expression with <strong class="source-inline">when</strong>.</p>
			<p>Let's try the <strong class="source-inline">welcome</strong> function one last time:</p>
			<p class="source-code">user=&gt; (welcome "Jon")</p>
			<p class="source-code">Welcome to Parenthmazes (single-player mode), Jon!</p>
			<p class="source-code">nil</p>
			<p class="source-code">user=&gt; (welcome "Jon" "Arya" "Tyrion" "Petyr")</p>
			<p class="source-code">Welcome to Parenthmazes (multi-player mode), Jon!</p>
			<p class="source-code">Sending 3 friend request(s) to the following players: Arya, Tyrion, Petyr</p>
			<p class="source-code">nil</p>
			<p>Great – the function call was dispatched to the right function according to the number of parameters.</p>
			<h2 id="_idParaDest-61"><a id="_idTextAnchor064"/>Exercise 3.03: Multi-arity and Destructuring with Parenthmazes</h2>
			<p>In this exercise, we will continue working on the <strong class="source-inline">Parenthmazes </strong>game by adding new features, notably improving our <strong class="source-inline">strike</strong> function to implement a healing mechanism. We would also like to add the concept of armor, which can reduce the damage suffered.</p>
			<p>Get ready for the great battle between Gnomes and Trolls in this new version of <strong class="source-inline">Parenthmazes</strong>.</p>
			<ol>
				<li value="1">To begin, start a REPL and your favorite code editor next to it, and create the <strong class="source-inline">weapon-damage</strong> map, which contains damage information for each weapon:<p class="source-code">user=&gt; (def weapon-damage {:fists 10.0 :staff 35.0 :sword 100.0 :cast-iron-saucepan 150.0})</p><p class="source-code">#'user/weapon-damage</p><p>We need this map to look up the amount of damage done when a player strikes an enemy.</p></li>
				<li>Now, let's create the <strong class="source-inline">strike</strong> function, which will handle healing when the enemy is in the same camp as us (let's assume for now that we picked the Gnomes' side):<p class="source-code">user=&gt;</p><p class="source-code">(defn strike</p><p class="source-code">  ([target weapon]</p><p class="source-code">    (let [points (weapon weapon-damage)]</p><p class="source-code">      (if (= :gnomes (:camp target))</p><p class="source-code">        (update target :health + points)</p><p class="source-code">        (update target :health - points)))))</p><p class="source-code">#'user/strike</p><p>In the preceding function, the new code of the <strong class="source-inline">strike</strong> function is to retrieve which side the target is on by looking up the <strong class="source-inline">:camp</strong> key in the <strong class="source-inline">target</strong> entity. If the <strong class="source-inline">target</strong> belongs to the Gnomes camp, we use the <strong class="source-inline">+</strong> function to increase the health in the <strong class="source-inline">target</strong> entity by x number of <strong class="source-inline">points</strong>. Otherwise, we use <strong class="source-inline">-</strong> to decrease the number of health points in the <strong class="source-inline">target</strong> entity.</p></li>
				<li>Create an <strong class="source-inline">enemy</strong> entity and test our newly created <strong class="source-inline">strike</strong> function as follows:<p class="source-code">user=&gt; (def enemy {:name "Zulkaz", :health 250, :camp :trolls})</p><p class="source-code">#'user/enemy</p><p class="source-code">user=&gt; (strike enemy :sword)</p><p class="source-code">{:name "Zulkaz", :health 150.0, :camp :trolls}</p><p>Health points were subtracted successfully. Let's see what happens with a friendly player.</p></li>
				<li>Create an <strong class="source-inline">ally</strong> entity that belongs to the <strong class="source-inline">:gnomes</strong> camp, and test our newly created <strong class="source-inline">strike</strong> function as follows:<p class="source-code">user=&gt; (def ally {:name "Carla", :health 80, :camp :gnomes})</p><p class="source-code">#'user/ally</p><p class="source-code">user=&gt; (strike ally :staff)</p><p class="source-code">{:name "Carla", :health 115.0, :camp :gnomes}</p><p>Health points were added successfully!</p><p>Now that we have got the shell of our <strong class="source-inline">strike</strong> function, let's amend it to implement the armor functionality. The <strong class="source-inline">target</strong> entity can contain an <strong class="source-inline">:armor</strong> key, which contains a coefficient used to calculate the final amount of damage. The bigger the number, the better the armor. For example, an armor value of 0.8 for a strike of 100 points results in 20 damage points being inflicted. An armor value of 0.1 results in 90 damage points being inflicted, 0 means no armor, and 1 means invincible.</p></li>
				<li>Change the amount of damage inflicted on the target by calculating the damage with the <strong class="source-inline">:armor</strong> value in the <strong class="source-inline">target</strong> entity. If the target has no armor value, set it to <strong class="source-inline">0</strong>. To improve readability, we will use a <strong class="source-inline">let</strong> binding to decompose the damage calculation:<p class="source-code">user=&gt;</p><p class="source-code">(defn strike</p><p class="source-code">  ([target weapon]</p><p class="source-code">    (let [points (weapon weapon-damage)]</p><p class="source-code">      (if (= :gnomes (:camp target))</p><p class="source-code">        (update target :health + points)</p><p class="source-code">        (let [armor (or (:armor target) 0)</p><p class="source-code">              damage (* points (- 1 armor))]</p><p class="source-code">          (update target :health - damage))))))</p><p class="source-code">#'user/strike</p><p>In the second branching of the <strong class="source-inline">if</strong> expression, we used a <strong class="source-inline">let</strong> expression to assign a default value to <strong class="source-inline">armor </strong>by using <strong class="source-inline">or</strong>. If <strong class="source-inline">(:armor target)</strong> is nil, the value of armor is 0. The second binding contains the reduced damage based on the armor value.</p></li>
				<li>Test the <strong class="source-inline">strike</strong> function to see if it still works with no armor:<p class="source-code">user=&gt; (strike enemy :cast-iron-saucepan)</p><p class="source-code">{:name "Zulkaz", :health 100.0, :camp :trolls}</p><p>A cast-iron saucepan does 150 damage, and 250 minus 150 is indeed <strong class="source-inline">100</strong>. Great – it works. Let's move on.</p></li>
				<li>Redefine the <strong class="source-inline">enemy</strong> binding to add an armor value and test our <strong class="source-inline">strike</strong> function once again:<p class="source-code">user=&gt; (def enemy {:name "Zulkaz", :health 250, :armor 0.8, :camp :trolls})</p><p class="source-code">#'user/enemy</p><p class="source-code">user=&gt; (strike enemy :cast-iron-saucepan)</p><p class="source-code">{:name "Zulkaz", :health 220.0, :armor 0.8, :camp :trolls}</p><p>Great – the damage seems to be reduced according to the armor coefficient. Now we would like to use our associative destructuring technique to retrieve the <strong class="source-inline">camp</strong> and <strong class="source-inline">armor</strong> values directly from the function parameters, and reduce the amount of code in the function's body. The only problem we have is that we still need to return an updated version of the <strong class="source-inline">target</strong> entity, but how could we both destructure the <strong class="source-inline">target</strong> entity and keep a reference of the <strong class="source-inline">target</strong> parameter? Clojure has your back – you can use the special key <strong class="source-inline">:as</strong> to bind the destructured map to a specific name.</p></li>
				<li>Modify the <strong class="source-inline">strike</strong> function to use associative destructuring in the function's parameters. Use the special key <strong class="source-inline">:as</strong> to bind the map passed as an argument to the symbol target:<p class="source-code">user=&gt;</p><p class="source-code">(defn strike</p><p class="source-code">  ([{:keys [camp armor] :as target} weapon]</p><p class="source-code">    (let [points (weapon weapon-damage)]</p><p class="source-code">      (if (= :gnomes camp)</p><p class="source-code">        (update target :health + points)</p><p class="source-code">        (let [damage (* points (- 1 (or armor 0)))]</p><p class="source-code">          (update target :health - damage))))))</p><p class="source-code">#'user/strike</p><p>There is one other useful feature in associative destructuring that we could take advantage of: the special key <strong class="source-inline">:or</strong>. It permits us to provide a default value for when a key that we want to extract isn't found (instead of binding to <strong class="source-inline">nil</strong>).</p></li>
				<li>Add the special key <strong class="source-inline">:or</strong> in the destructured map to provide a default value to the armor key in the target map, add an extra arity to make the <strong class="source-inline">weapon</strong> parameter optional, and finally add some documentation, as follows. Don't forget to wrap each function definition with its own set of parentheses:<p class="source-code">user=&gt;</p><p class="source-code">(defn strike</p><p class="source-code">  "With one argument, strike a target with a default :fists `weapon`. With two argument, strike a target with `weapon`.</p><p class="source-code">   Strike will heal a target that belongs to the gnomes camp."</p><p class="source-code">  ([target] (strike target :fists))</p><p class="source-code">  ([{:keys [camp armor], :or {armor 0}, :as target} weapon]</p><p class="source-code">    (let [points (weapon weapon-damage)]</p><p class="source-code">      (if (= :gnomes camp)</p><p class="source-code">        (update target :health + points)</p><p class="source-code">        (let [damage (* points (- 1 armor))]</p><p class="source-code">          (update target :health - damage))))))</p><p class="source-code">#'user/strike</p></li>
				<li>Ensure that your function still works as expected by testing the different scenarios as follows:<p class="source-code">user=&gt; (strike enemy)</p><p class="source-code">{:name "Zulkaz", :health 248.0, :armor 0.8, :camp :trolls}</p><p class="source-code">user=&gt; (strike enemy :cast-iron-saucepan)</p><p class="source-code">{:name "Zulkaz", :health 220.0, :armor 0.8, :camp :trolls}</p><p class="source-code">user=&gt; (strike ally :staff)</p><p class="source-code">{:name "Carla", :health 115.0, :camp :gnomes}</p></li>
			</ol>
			<p>That concludes this exercise. If you look again at the <strong class="source-inline">strike</strong> function you've just written, it is using some advanced Clojure features, including destructuring, multi-arity functions, and reading and updating maps. By passing a function as an argument in the <strong class="source-inline">update</strong> function, we also used the concept of higher-order functions, which we will explain further in the next section.</p>
			<h1 id="_idParaDest-62"><a id="_idTextAnchor065"/>Higher-Order Programming</h1>
			<p>Higher-order programming means that programs, and specifically functions, can operate on other programs or functions, as opposed to first-order programming, where functions operate on data elements such as strings, numbers, and data structures. In practice, it means that a function can take some programming logic as a parameter (another function) and/or return some programming logic to be eventually executed. It is a powerful feature that allows us to compose single, modular units of logic in our programs to reduce duplication and promote the reusability of code.</p>
			<p>Writing simpler functions increases their modularity. We want to create simple units of functionality that can be used as small bricks to build our programs with. Writing pure functions reduces the complexity of those bricks, and allows us to craft better, sturdier programs. Pure functions are functions that don't alter the state of our program – they produce no side effects; a pure function also always returns the same value when given the exact same parameters. This combination makes pure functions easy to reason about, build upon, and test. Although Clojure offers ways to modify the state of our program, we should write and use pure functions as much as possible.</p>
			<h2 id="_idParaDest-63"><a id="_idTextAnchor066"/>First-Class Functions</h2>
			<p>Let's demonstrate the use of functions as parameters. We used functions as parameters in <em class="italic">Exercise 2.01</em>, <em class="italic">The Obfuscation Machine</em> of <em class="italic">Chapter 2</em>, <em class="italic">Data Types and Immutability</em>, with the <strong class="source-inline">clojure.string/replace</strong> function, and also in the preceding exercise, with the <strong class="source-inline">update</strong> function. For example, to divide a value by <strong class="source-inline">2</strong> in a <strong class="source-inline">HashMap</strong>, you can pass an anonymous function that does the division as an argument to the <strong class="source-inline">update</strong> function:</p>
			<p class="source-code">user=&gt; (update {:item "Tomato" :price 1.0} :price (fn [x] (/ x 2)))</p>
			<p class="source-code">{:item "Tomato", :price 0.5}</p>
			<p>Even better, you could simply pass the divide function, <strong class="source-inline">/</strong>, with the argument <strong class="source-inline">2</strong>, as follows:</p>
			<p class="source-code">user=&gt; (update {:item "Tomato" :price 1.0} :price / 2)</p>
			<p class="source-code">{:item "Tomato", :price 0.5}</p>
			<p>Notice that <strong class="source-inline">update</strong> will pass the old value as the first argument to the <strong class="source-inline">/</strong> function (here, the old value is <strong class="source-inline">1.0</strong>) as well as all the extra arguments (here, <strong class="source-inline">2</strong>).</p>
			<p>You can operate on any kind of value. For example, to invert the value of a Boolean, use the <strong class="source-inline">not</strong> function:</p>
			<p class="source-code">user=&gt; (update {:item "Tomato" :fruit false} :fruit not)</p>
			<p class="source-code">{:item "Tomato", :fruit true}</p>
			<p>As we've just seen, <strong class="source-inline">update</strong> can take a function as a parameter, but we could also define our own function that takes a function and applies it to a given parameter:</p>
			<p class="source-code">user=&gt; (defn operate [f x] (f x))</p>
			<p class="source-code">#'user/operate</p>
			<p class="source-code">user=&gt; (operate inc 2)</p>
			<p class="source-code">3</p>
			<p class="source-code">user=&gt; (operate clojure.string/upper-case "hello.")</p>
			<p class="source-code">"HELLO."</p>
			<p>In the preceding example, <strong class="source-inline">operate</strong> takes a function, <strong class="source-inline">f</strong>, as a parameter and calls it with the second parameter, <strong class="source-inline">x</strong>. Not very useful, but it shows how simple it is to pass and call a function passed as a parameter. If we wanted to pass any number of arguments, we could use the <strong class="source-inline">&amp;</strong> character as we learned in the previous topic about destructuring:</p>
			<p class="source-code">user=&gt; (defn operate [f &amp; args] (f args))</p>
			<p class="source-code">#'user/operate</p>
			<p class="source-code">user=&gt; (operate + 1 2 3)</p>
			<p class="source-code">Execution error (ClassCastException) at java.lang.Class/cast (Class.java:3369).</p>
			<p class="source-code">Cannot cast clojure.lang.ArraySeq to java.lang.Number</p>
			<p>This time, <strong class="source-inline">operate</strong> seems to accept any number of arguments, but the function call fails because <strong class="source-inline">args</strong> is a sequence. That's because we applied the <strong class="source-inline">f</strong> function to the <strong class="source-inline">args</strong> sequence directly, when what we really wanted was to apply <strong class="source-inline">f</strong> using each element of the sequence as an argument. There is a special function to disassemble a sequence and apply a function to that sequence's elements – the <strong class="source-inline">apply</strong> function:</p>
			<p class="source-code">user=&gt; (+ [1 2 3])</p>
			<p class="source-code">Execution error (ClassCastException) at java.lang.Class/cast (Class.java:3369).</p>
			<p class="source-code">Cannot cast clojure.lang.PersistentVector to java.lang.Number</p>
			<p class="source-code">user=&gt; (apply + [1 2 3])</p>
			<p class="source-code">6</p>
			<p>Notice how <strong class="source-inline">+</strong> does not work on a vector, but by using apply, we call <strong class="source-inline">+</strong>, passing each element of the vector as an argument to <strong class="source-inline">+</strong>.</p>
			<p>We can, therefore, use <strong class="source-inline">apply</strong> in our <strong class="source-inline">operate</strong> function to have a fully working function that takes a function, <strong class="source-inline">f</strong>, as a parameter and calls <strong class="source-inline">f</strong> with the rest of the parameters, <strong class="source-inline">args</strong>:</p>
			<p class="source-code">user=&gt; (defn operate [f &amp; args] (apply f args))</p>
			<p class="source-code">#'user/operate</p>
			<p class="source-code">user=&gt; (operate str "It " "Should " "Concatenate!")</p>
			<p class="source-code">"It Should Concatenate!"</p>
			<p>It works! The <strong class="source-inline">str</strong> function was applied to the arguments passed to <strong class="source-inline">str</strong>.</p>
			<p>The ability to pass a function as a parameter is one aspect of higher-order functions, but another aspect is the ability of functions to <em class="italic">return</em> other functions. Consider the following code:</p>
			<p class="source-code">user=&gt; (defn random-fn [] (first (shuffle [+ - * /])))</p>
			<p class="source-code">#'user/random-fn</p>
			<p>The <strong class="source-inline">shuffle</strong> function shuffles an array by sorting its elements randomly, and we then take the first element out of it. In other words, the <strong class="source-inline">random-fn</strong> function returns a random function from the <strong class="source-inline">[+ - * /]</strong> collection. Notice that the <strong class="source-inline">random-fn</strong> function does not take any parameters:</p>
			<p class="source-code">user=&gt; (random-fn 2 3)</p>
			<p class="source-code">Execution error (ArityException) at user/eval277 (REPL:1).</p>
			<p class="source-code">Wrong number of args (2) passed to: user/random-fn</p>
			<p>But the function returned by <strong class="source-inline">random-fn</strong> expects parameters: </p>
			<p class="source-code">user=&gt; ((random-fn) 2 3)</p>
			<p class="source-code">-1</p>
			<p>In the preceding code, <strong class="source-inline">(random-fn)</strong> returned <strong class="source-inline">-</strong> so <strong class="source-inline">3</strong> was subtracted from <strong class="source-inline">2</strong>, which results in <strong class="source-inline">-1</strong>.</p>
			<p>You can use the <strong class="source-inline">fn?</strong> function to check whether a value passed as a parameter is a function:</p>
			<p class="source-code">user=&gt; (fn? random-fn)</p>
			<p class="source-code">true</p>
			<p class="source-code">user=&gt; (fn? (random-fn))</p>
			<p class="source-code">true</p>
			<p>In this case, observe that both <strong class="source-inline">random-fn</strong> and the value returned by <strong class="source-inline">random-fn</strong> are functions. So, we can call the function returned by <strong class="source-inline">random-fn</strong>, and even bind it to a symbol, as in the example that follows, where we bind the function to the <strong class="source-inline">mysterious-fn</strong> symbol:</p>
			<p class="source-code">user=&gt;</p>
			<p class="source-code">(let [mysterious-fn (random-fn)]</p>
			<p class="source-code">  (mysterious-fn 2 3))</p>
			<p class="source-code">6</p>
			<p class="source-code">user=&gt;</p>
			<p class="source-code">(let [mysterious-fn (random-fn)]</p>
			<p class="source-code">  (mysterious-fn 2 3))</p>
			<p class="source-code">2/3</p>
			<p class="source-code">user=&gt;</p>
			<p class="source-code">(let [mysterious-fn (random-fn)]</p>
			<p class="source-code">  (mysterious-fn 2 3))</p>
			<p class="source-code">6</p>
			<p class="source-code">user=&gt;</p>
			<p class="source-code">(let [mysterious-fn (random-fn)]</p>
			<p class="source-code">  (mysterious-fn 2 3))</p>
			<p class="source-code">5</p>
			<p>Notice how every call to <strong class="source-inline">random-fn</strong> returned a different function. On each step, calling <strong class="source-inline">mysterious-fn</strong> with the same arguments is processed by a different function. Based on the returned values, we can guess that the functions are respectively <strong class="source-inline">*</strong>, <strong class="source-inline">/</strong>, <strong class="source-inline">*</strong>, and <strong class="source-inline">+</strong>.</p>
			<p>It is conceivable but not very common to write functions that return other functions. However, you will often use some of Clojure's core utility functions, which return other functions, and which we are going to present next. Those are worth exploring because they enable functional composition, reusability, and conciseness.</p>
			<h2 id="_idParaDest-64"><a id="_idTextAnchor067"/>Partial Functions</h2>
			<p>The first of those core utility functions is <strong class="source-inline">partial</strong>, which takes a function, <strong class="source-inline">f</strong>, as a parameter and any number of arguments, <strong class="source-inline">args1</strong>. It returns a new function, <strong class="source-inline">g</strong>, that can take extra arguments, <strong class="source-inline">args2</strong>. When calling <strong class="source-inline">g</strong> with <strong class="source-inline">args2</strong>, <strong class="source-inline">f</strong> is called with <strong class="source-inline">args1</strong> + <strong class="source-inline">args2</strong>. It may sound complicated, but consider the following example:</p>
			<p class="source-code">user=&gt; (def marketing-adder (partial + 0.99))</p>
			<p class="source-code">#'user/marketing-adder</p>
			<p class="source-code">user=&gt; (marketing-adder 10 5)</p>
			<p class="source-code">15.99</p>
			<p>Calling <strong class="source-inline">(partial + 0.99)</strong> returns a new function that we bind to the <a id="_idTextAnchor068"/><strong class="source-inline">marketing-adder</strong> symbol. When <strong class="source-inline">marketing-adder</strong> is called, it will call <strong class="source-inline">+</strong> with <strong class="source-inline">0.99</strong> and any extra arguments passed to the function. Notice that we used <strong class="source-inline">def</strong> and not <strong class="source-inline">defn</strong>, because we don't need to build a new function – <strong class="source-inline">partial</strong> does it for us.</p>
			<p>Here is another example:</p>
			<p class="source-code">user=&gt; (def format-price (partial str "€"))</p>
			<p class="source-code">#'user/format-price</p>
			<p class="source-code">user=&gt; (format-price "100")</p>
			<p class="source-code">"€100"</p>
			<p class="source-code">user=&gt; (format-price 10 50)</p>
			<p class="source-code">"€1050"</p>
			<p>Calling <strong class="source-inline">format-price</strong> will call the <strong class="source-inline">str</strong> function with the first parameter, <strong class="source-inline">"€"</strong>, and then the rest of the parameters. Of course, you could write the same function like this: <strong class="source-inline">(fn [x] (str "€" x))</strong>, but using <strong class="source-inline">partial</strong> is a nice and expressive way of defining functions as functions of other functions.</p>
			<h2 id="_idParaDest-65"><a id="_idTextAnchor069"/>Composing Functions</h2>
			<p>Another core utility function is <strong class="source-inline">comp</strong>, short for compose. Take, for example, our <strong class="source-inline">random-fn</strong> function. To retrieve a random number from the collection, we call the <strong class="source-inline">shuffle</strong> function and then the <strong class="source-inline">first</strong> function. If we wanted to implement a <strong class="source-inline">sample</strong> function that does exactly that, we could write the following function:</p>
			<p class="source-code">user=&gt; (defn sample [coll] (first (shuffle coll)))</p>
			<p class="source-code">#'user/sample</p>
			<p class="source-code">user=&gt; (sample [1 2 3 4])</p>
			<p class="source-code">2</p>
			<p>But more elegantly, we could implement the <strong class="source-inline">sample</strong> function with the functional composition utility, <strong class="source-inline">comp</strong>:</p>
			<p class="source-code">user=&gt; (def sample (comp first shuffle))</p>
			<p class="source-code">#'user/sample</p>
			<p class="source-code">user=&gt; (sample [1 2 3 4])</p>
			<p class="source-code">4</p>
			<p><strong class="source-inline">comp</strong> is a utility that takes any number of functions as a parameter and returns a new function that calls those functions in order, passing the result of each to the other. Observe that the functions are composed from right to left, so in the preceding example, <strong class="source-inline">shuffle</strong> will be applied before <strong class="source-inline">first</strong>. This is important because the number and types of arguments passed to the chain of functions is often meaningful. For example, if you wanted to compose a function that multiplies numbers and increments the result by one, you would need to pass the <strong class="source-inline">inc</strong> function (increment) as a first argument of the function as follows:</p>
			<p class="source-code">user=&gt; ((comp inc *) 2 2)</p>
			<p class="source-code">5</p>
			<p class="source-code">user=&gt; ((comp * inc) 2 2)</p>
			<p class="source-code">Execution error (ArityException) at user/eval405 (REPL:1).</p>
			<p class="source-code">Wrong number of args (2) passed to: clojure.core/inc</p>
			<p>Notice that when providing <strong class="source-inline">inc</strong> as the last argument of the <strong class="source-inline">comp</strong> function, it calls <strong class="source-inline">(inc 2 2)</strong>, which does not work because <strong class="source-inline">inc</strong> takes only one argument.</p>
			<p>Now, let's see how we can combine the use of <strong class="source-inline">partial</strong> and <strong class="source-inline">comp</strong> to compose a <strong class="source-inline">checkout</strong> function with the <strong class="source-inline">format-price</strong> and <strong class="source-inline">marketing-adder</strong> functions that we defined previously. The <strong class="source-inline">checkout</strong> function will first add its parameters by reusing <strong class="source-inline">marketing-adder</strong>, then format the price with <strong class="source-inline">format-price</strong> and return the string concatenated with <strong class="source-inline">"Only"</strong> in front of it:</p>
			<p class="source-code">user=&gt; (def checkout (comp (partial str "Only ") format-price marketing-adder))</p>
			<p class="source-code">#'user/checkout</p>
			<p class="source-code">user=&gt; (checkout 10 5 15 6 9)</p>
			<p class="source-code">"Only €45.99"</p>
			<p>In the preceding example, we defined a <strong class="source-inline">checkout</strong> function as a composition of <strong class="source-inline">marketing-adder</strong>, <strong class="source-inline">format-price</strong>, and an anonymous function returned by <strong class="source-inline">partial</strong> to add the text <strong class="source-inline">"Only"</strong> before the price. This example shows the outstanding dynamism and expressivity of composing related functions in Clojure. The programmer's intent is clear and concise, skipping the technicality of defining functions and naming parameters.</p>
			<p>Before we jump into the exercise, let's present a new way of writing anonymous functions: the <strong class="source-inline">#()</strong> literal. <strong class="source-inline">#()</strong> is a shorter way of writing an anonymous function. Parameters are not named and therefore parameter values can be accessed in order with <strong class="source-inline">%1</strong>, <strong class="source-inline">%2</strong>, <strong class="source-inline">%3</strong>, and so on. When only one argument is provided, you can simply use <strong class="source-inline">%</strong> (omitting the argument number) to retrieve the value of the argument.</p>
			<p>For example, the two following expressions are equivalent:</p>
			<p class="source-code">(fn [s] (str "Hello" s))</p>
			<p class="source-code">;; is the same as</p>
			<p class="source-code">#(str "Hello" %)</p>
			<p>And the two following expressions are equivalent as well:</p>
			<p class="source-code">(fn [x y] (* (+ x 10) (+ y 20)))</p>
			<p class="source-code">;; is the same as</p>
			<p class="source-code">#(* (+ %1 10) (+ %2 20))</p>
			<p><strong class="source-inline">#()</strong> literal functions are just functions, called in the same way as other functions:</p>
			<p class="source-code">user=&gt; (#(str %1 " " %2 " " %3) "First" "Second" "Third")</p>
			<p class="source-code">"First Second Third"</p>
			<p>Observe that when more than one argument is provided, we need to use the <strong class="source-inline">%1</strong> and <strong class="source-inline">%2</strong> to refer to the values passed as a parameter.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The short literal notation of the <strong class="source-inline">#()</strong> function is convenient but should be used sparingly because numbered parameters can be hard to read. The rule of thumb is to use only short anonymous functions with a single argument and a single function call. For anything else, you should stick with the standard <strong class="source-inline">fn</strong> notation with named parameters to improve readability.</p>
			<p>Let's put these new techniques into practice in an exercise with <strong class="source-inline">Parenthmazes</strong> version 3.</p>
			<h2 id="_idParaDest-66"><a id="_idTextAnchor070"/>Exercise 3.04: High-Order Functions with Parenthmazes</h2>
			<p>In this exercise, we will demonstrate the benefit of functions being first-class citizens. We will use functions as values and compose them together.</p>
			<p>We would like to improve our fantasy game, Parenthmazes, even more, this time by changing weapons' mechanics to allow each weapon to have different behavior. For example, we would like "fists" to inflict damage only if an enemy is weak or has been weakened. Instead of implementing conditional branches in our <strong class="source-inline">strike</strong> function, we are going to implement a <em class="italic">dispatch table</em> using the <strong class="source-inline">weapon-damage</strong> <strong class="source-inline">HashMap</strong>, which we are going to rename <strong class="source-inline">weapon-fn-map</strong>, because this time each weapon will have an associated function (rather than a numeric value). A dispatch table is a table of pointers to functions. We can implement it with a <strong class="source-inline">HashMap</strong> where the pointers are keys and the functions are values.</p>
			<p>To allow our weapon functions to compose nicely, they will take a numeric value for health as a parameter and return a numeric value for health after the damage has been deducted. For the sake of simplicity, we will leave out the concept of armor this time. Let's start with the <strong class="source-inline">fist</strong> weapon:</p>
			<ol>
				<li value="1">Start a REPL next to your favorite code editor. Create a new <strong class="source-inline">HashMap</strong> with a <strong class="source-inline">:fists</strong> key and its associated function, which inflicts <strong class="source-inline">10</strong> damage only if the health of the enemy is less than <strong class="source-inline">100</strong>, and otherwise returns the <strong class="source-inline">health</strong> parameter. Bind the newly created function to the <strong class="source-inline">weapon-fn-map</strong> symbol as follows:<p class="source-code">user=&gt;</p><p class="source-code">(def weapon-fn-map</p><p class="source-code">  {:fists (fn [health] (if (&lt; health 100) (- health 10) health))})</p><p class="source-code">#'user/weapon-fn-map</p><p>A <strong class="source-inline">HashMap</strong> can have any type of value as a key or parameter, so a function as a value is perfectly fine.</p></li>
				<li>Try the function by retrieving it from <strong class="source-inline">weapon-fn-map</strong> and call it with <strong class="source-inline">150</strong> and then <strong class="source-inline">50</strong> as a parameter:<p class="source-code">user=&gt; ((weapon-fn-map :fists) 150)</p><p class="source-code">150</p><p class="source-code">user=&gt; ((weapon-fn-map :fists) 50)</p><p class="source-code">40</p><p>Observe that the function returned the new health correctly. It subtracted <strong class="source-inline">10</strong> when the <strong class="source-inline">health</strong> parameter was less than <strong class="source-inline">100</strong>.</p></li>
				<li>Now to the <strong class="source-inline">staff</strong> weapon. The <strong class="source-inline">staff</strong> is the only weapon that can be used to heal (<strong class="source-inline">35</strong> health points), so the associated function should simply call <strong class="source-inline">+</strong> instead of <strong class="source-inline">-</strong>. It seems like a good opportunity to generate this function using <strong class="source-inline">partial</strong>:<p class="source-code">(def weapon-fn-map</p><p class="source-code">  {</p><p class="source-code">    :fists (fn [health] (if (&lt; health 100) (- health 10) health))</p><p class="source-code">    :staff (partial + 35)</p><p class="source-code">  })</p><p>The value at the <strong class="source-inline">:staff</strong> key is now a function that will call <strong class="source-inline">+</strong> with <strong class="source-inline">35</strong> and any extra argument supplied.</p></li>
				<li>Try the function associated with <strong class="source-inline">staff</strong>, as follows:<p class="source-code">user=&gt; ((weapon-fn-map :staff) 150)</p><p class="source-code">185</p><p>For the <strong class="source-inline">sword</strong> weapon, we need to simply subtract <strong class="source-inline">100</strong> points from the health points passed as an argument. However, <strong class="source-inline">partial</strong> won't work because the parameters would not be in the correct order. For example, <strong class="source-inline">((partial - 100) 150)</strong> returns <strong class="source-inline">-50</strong>, because the function call is equivalent to <strong class="source-inline">(- 100 150)</strong>, but we need <strong class="source-inline">(- 150 100)</strong>.</p></li>
				<li>Create an anonymous function subtracting <strong class="source-inline">100</strong> from its argument and associate it with the <strong class="source-inline">sword</strong> key, as follows:<p class="source-code">(def weapon-fn-map</p><p class="source-code">  {</p><p class="source-code">    :fists (fn [health] (if (&lt; health 100) (- health 10) health))</p><p class="source-code">    :staff (partial + 35)</p><p class="source-code">    :sword #(- % 100)</p><p class="source-code">  })</p><p>Notice that we used <strong class="source-inline">%</strong> to retrieve the argument passed to the anonymous function, because we used the short literal syntax, <strong class="source-inline">#()</strong>, expecting only one argument.</p></li>
				<li>Test your newly created weapon function as follows:<p class="source-code">user=&gt; ((weapon-fn-map :sword) 150)</p><p class="source-code">50</p><p>It works!</p><p>The next weapon to add is <strong class="source-inline">cast-iron-saucepan</strong>. To spice things up, let's add a bit of randomness to the mix (a saucepan is not a very accurate weapon anyway).</p></li>
				<li>Add the <strong class="source-inline">cast-iron-saucepan</strong> function to the <strong class="source-inline">HashMap</strong> that subtracts <strong class="source-inline">100</strong> health points and a random number between <strong class="source-inline">0</strong> and <strong class="source-inline">50</strong> from the health points, as follows:<p class="source-code">(def weapon-fn-map</p><p class="source-code">  {</p><p class="source-code">    :fists (fn [health] (if (&lt; health 100) (- health 10) health))</p><p class="source-code">    :staff (partial + 35)</p><p class="source-code">    :sword #(- % 100)</p><p class="source-code">    :cast-iron-saucepan #(- % 100 (rand-int 50))</p><p class="source-code">  })</p><p>In the preceding example, we used the <strong class="source-inline">rand-int</strong> function, which generates a random integer between <strong class="source-inline">0</strong> and the supplied argument.</p></li>
				<li>Test the newly created function as follows:<p class="source-code">user=&gt; ((weapon-fn-map :cast-iron-saucepan) 200)</p><p class="source-code">77</p><p class="source-code">user=&gt; ((weapon-fn-map :cast-iron-saucepan) 200)</p><p class="source-code">90</p><p>Two subsequent calls might return a different value because of the <strong class="source-inline">rand-int</strong> function.</p></li>
				<li>Finally, we would like to introduce a new weapon (for the unfortunate adventurers) that doesn't do any damage: the sweet potato. For that purpose, we need a function that returns its argument (the health). We don't need to implement it as it already exists: <strong class="source-inline">identity</strong>. First, let's check out the source code of the function identity with the <strong class="source-inline">source</strong> function:<p class="source-code">user=&gt; (source identity)</p><p class="source-code">(defn identity</p><p class="source-code">  "Returns its argument."</p><p class="source-code">  {:added "1.0"</p><p class="source-code">   :static true}</p><p class="source-code">  [x] x)</p><p class="source-code">Nil</p><p>Observe how <strong class="source-inline">identity</strong> simply returns its argument. The <strong class="source-inline">source</strong> function is another handy tool to use interactively in the REPL, as it prints out a function definition to the console, which is sometimes more helpful than a function's documentation.</p></li>
				<li>Let's redefine our <strong class="source-inline">weapon-fn-map</strong> <strong class="source-inline">HashMap</strong> one last time by associating the function identity with the <strong class="source-inline">:sweet-potato</strong> key, as follows:<p class="source-code">(def weapon-fn-map</p><p class="source-code">  {</p><p class="source-code">    :fists (fn [health] (if (&lt; health 100) (- health 10) health))</p><p class="source-code">    :staff (partial + 35)</p><p class="source-code">    :sword #(- % 100)</p><p class="source-code">    :cast-iron-saucepan #(- % 100 (rand-int 50))</p><p class="source-code">    :sweet-potato identity</p><p class="source-code">  })</p><p>Now that we have our <strong class="source-inline">weapon-fn-map</strong> finalized, we should modify our <strong class="source-inline">strike</strong> function to handle the weapon functions stored as values in our <strong class="source-inline">HashMap</strong>. Remember that the <strong class="source-inline">strike</strong> function takes a <strong class="source-inline">target</strong> entity as a parameter and returns this entity with a new value for the health key. Therefore, updating the entity's health should be as simple as passing a <strong class="source-inline">weapon</strong> function to the <strong class="source-inline">update</strong> function, because our <strong class="source-inline">weapon</strong> functions take the health as a parameter and return the new health value.</p></li>
				<li>Rewrite the <strong class="source-inline">strike</strong> function from the previous exercise to use the weapon functions stored in the <strong class="source-inline">weapon-fn-map</strong>, as follows:<p class="source-code">user=&gt;</p><p class="source-code">(defn strike</p><p class="source-code">  "With one argument, strike a target with a default :fists `weapon`. With two argument, strike a target with `weapon` and return the target entity"</p><p class="source-code">  ([target] (strike target :fists))</p><p class="source-code">  ([target weapon]</p><p class="source-code">    (let [weapon-fn (weapon weapon-fn-map)]</p><p class="source-code">      (update target :health weapon-fn))))</p><p class="source-code">#'user/strike</p></li>
				<li>Now test your <strong class="source-inline">strike</strong> function by passing various weapons as a parameter. For convenience, you might want to create an <strong class="source-inline">enemy</strong> entity as well:<p class="source-code">user=&gt; (def enemy {:name "Arnold", :health 250})</p><p class="source-code">#'user/enemy</p><p class="source-code">user=&gt; (strike enemy :sweet-potato)</p><p class="source-code">{:name "Arnold", :health 250}</p><p class="source-code">user=&gt; (strike enemy :sword)</p><p class="source-code">{:name "Arnold", :health 150}</p><p class="source-code">user=&gt; (strike enemy :cast-iron-saucepan)</p><p class="source-code">{:name "Arnold", :health 108}</p><p>If we wanted to strike with more than one weapon at a time, instead of nesting a strike call like this: </p><p class="source-code">user=&gt; (strike (strike enemy :sword) :cast-iron-saucepan)</p><p class="source-code">{:name "Arnold", :health 42}</p><p>We could simply compose our weapon functions and just use the core update function.</p></li>
				<li>Write an <strong class="source-inline">update</strong> expression to strike with two weapons at a time using <strong class="source-inline">comp</strong>, as follows:<p class="source-code">user=&gt; (update enemy :health (comp (:sword weapon-fn-map) (:cast-iron-saucepan weapon-fn-map)))</p><p class="source-code">{:name "Arnold", :health 15}</p><p>Because the weapon functions that we wrote have a consistent interface (taking <strong class="source-inline">health</strong> as a parameter and returning the health), it is straightforward to compose them with <strong class="source-inline">comp</strong>. To finish this exercise, let's create a <strong class="source-inline">mighty-strike</strong> function that strikes with all of the weapons at once, also known as composing all the weapon functions. The <strong class="source-inline">keys</strong> and <strong class="source-inline">vals</strong> functions can be used on <strong class="source-inline">HashMaps</strong> to retrieve a collection of the map's keys or values. To retrieve all the weapon functions, we can simply retrieve all the values from <strong class="source-inline">weapon-fn-map</strong> using the <strong class="source-inline">vals</strong> function. Now that we have a collection of functions, how do we compose them? We need to pass each function of the collection to the <strong class="source-inline">comp</strong> function. Remember, to pass each element of a collection as a parameter of a function, we can use <strong class="source-inline">apply</strong>.</p></li>
				<li>Write a new function named <strong class="source-inline">mighty-strike</strong>, which takes a <strong class="source-inline">target</strong> entity as a parameter and uses all of the weapons on it. It should apply the <strong class="source-inline">comp</strong> function to the values of <strong class="source-inline">weapon-fn-map</strong> as follows:<p class="source-code">user=&gt;</p><p class="source-code">(defn mighty-strike</p><p class="source-code">  "Strike a `target` with all weapons!"</p><p class="source-code">  [target]</p><p class="source-code">  (let [weapon-fn (apply comp (vals weapon-fn-map))]</p><p class="source-code">      (update target :health weapon-fn)))</p><p class="source-code">#'user/mighty-strike</p><p class="source-code">user=&gt; (mighty-strike enemy)</p><p class="source-code">{:name "Arnold", :health 58}</p></li>
			</ol>
			<p>Now, if we pause to reflect on the <strong class="source-inline">mighty-strike</strong> function and think about how we would have to implement that without higher-order functions, we'll realize how simple and powerful the concept of functional composition is.</p>
			<p>In this section, we've learned how to use functions as simple values and as parameters or return values of other functions, as well as creating shorter anonymous functions with <strong class="source-inline">#()</strong>. We also explained how to use <strong class="source-inline">partial</strong>, <strong class="source-inline">comp</strong>, and <strong class="source-inline">apply</strong> to generate, compose, and discover new ways of using functions.</p>
			<h1 id="_idParaDest-67"><a id="_idTextAnchor071"/>Multimethods</h1>
			<p>Clojure offers a way to implement polymorphism with multimethods. Polymorphism is the ability of a unit of code (in our case, functions) to behave differently in different contexts, for example, based on the shape of the data received by the code. In Clojure, we also call it <em class="italic">runtime polymorphism</em> because the method to call is determined at runtime rather than at compile time. A multimethod is a combination of a dispatch function and of one or more methods. The two main operators for creating those multimethods are <strong class="source-inline">defmulti</strong> and <strong class="source-inline">defmethod</strong>. <strong class="source-inline">defmulti</strong> declares a multimethod and defines how the method is chosen with the dispatch function<span class="Annotation-reference">. </span><strong class="source-inline">defmethod</strong> creates the different implementations that will be chosen by the dispatch function. The dispatch function receives the arguments of the function call and returns a dispatch value. This dispatch value is used to determine which function, defined with <strong class="source-inline">defmethod</strong>, to invoke. Those are a lot of new terms but don't worry, the following examples will help you understand the new concepts.</p>
			<p>Let's see how we could implement Parenthmazes' <strong class="source-inline">strike</strong> function with multimethods. This time, the weapon is in the <strong class="source-inline">HashMap</strong> passed as a parameter: </p>
			<p class="source-code">user=&gt; (defmulti strike (fn [m] (get m :weapon)))</p>
			<p class="source-code">#'user/strike</p>
			<p>In the preceding code, we've created a multimethod called <strong class="source-inline">strike</strong>. The second argument is the dispatch function, which simply retrieves a weapon in a map passed as a parameter. Remember that keywords can be used as functions of a <strong class="source-inline">HashMap</strong>, so we can simply write <strong class="source-inline">defmulti</strong> as follows:</p>
			<p class="source-code">user=&gt; (defmulti strike :weapon)</p>
			<p class="source-code">nil</p>
			<p>Notice that, this time, the expression returned <strong class="source-inline">nil</strong>. This is because the multimethod was already defined. In that case, we need to <strong class="source-inline">unmap</strong> the <strong class="source-inline">strike</strong> var from the <strong class="source-inline">user</strong> namespace and re-evaluate the same expression again:</p>
			<p class="source-code">user=&gt; (ns-unmap 'user 'strike)</p>
			<p class="source-code">nil</p>
			<p class="source-code">user=&gt; (defmulti strike :weapon)</p>
			<p class="source-code">#'user/strike</p>
			<p>Now that we have our multimethod and our dispatch function defined (which is simply the <strong class="source-inline">:weapon</strong> keyword), let's create our <strong class="source-inline">strike</strong> functions for a couple of weapons, to demonstrate the usage of <strong class="source-inline">defmethod</strong>:</p>
			<p class="source-code">user=&gt; (defmethod strike :sword</p>
			<p class="source-code">[{{:keys [:health]} :target}]</p>
			<p class="source-code">(- health 100))</p>
			<p class="source-code">#object[clojure.lang.MultiFn 0xaa549e5 "clojure.lang.MultiFn@aa549e5"]</p>
			<p>Observe how we called <strong class="source-inline">defmethod</strong> with the function named <strong class="source-inline">strike</strong>, the second argument to <strong class="source-inline">defmethod</strong> is the dispatch value: <strong class="source-inline">:sword</strong>. When <strong class="source-inline">strike</strong> is called with a map containing a weapon key, the weapon value is retrieved from the arguments and then returned by the dispatch function (the <strong class="source-inline">:weapon</strong> keyword). Similarly, let's create another strike implementation for the <strong class="source-inline">:cast-iron-saucepan</strong> dispatch value:</p>
			<p class="source-code">user=&gt; (defmethod strike :cast-iron-saucepan</p>
			<p class="source-code">[{{:keys [:health]} :target}]</p>
			<p class="source-code">(- health 100 (rand-int 50)))</p>
			<p class="source-code">#object[clojure.lang.MultiFn 0xaa549e5 "clojure.lang.MultiFn@aa549e5"]</p>
			<p>This time, <strong class="source-inline">strike</strong> is called with a map containing <strong class="source-inline">:cast-iron-saucepan</strong> at the <strong class="source-inline">:weapon</strong> key. The function defined previously will be invoked. Let's test our newly created multimethod with the two different weapons:</p>
			<p class="source-code">user=&gt; (strike {:weapon :sword :target {:health 200}})</p>
			<p class="source-code">100</p>
			<p class="source-code">user=&gt; (strike {:weapon :cast-iron-saucepan :target {:health 200}})</p>
			<p class="source-code">77</p>
			<p>Notice how calling <strong class="source-inline">strike</strong> with different arguments lets us invoke two different functions.</p>
			<p>When the dispatch value doesn't map to any registered function, an exception is thrown: </p>
			<p class="source-code">user=&gt; (strike {:weapon :spoon :target {:health 200}})</p>
			<p class="source-code">Execution error (IllegalArgumentException) at user/eval217 (REPL:1).</p>
			<p class="source-code">No method in multimethod 'strike' for dispatch value: :spoon</p>
			<p>If we need to handle that case, we can add a method with the <strong class="source-inline">:default</strong> dispatch value:</p>
			<p class="source-code">user=&gt; (defmethod strike :default [{{:keys [:health]} :target}] health)</p>
			<p class="source-code">#object[clojure.lang.MultiFn 0xaa549e5 "clojure.lang.MultiFn@aa549e5"]</p>
			<p>In this case, we decided to handle any other weapon by simply returning the unmodified health value, inflicting no damage:</p>
			<p class="source-code">user=&gt; (strike {:weapon :spoon :target {:health 200}})</p>
			<p class="source-code">200</p>
			<p>Notice that, this time, no exception was thrown, and the original health value was returned. The dispatch function can be more elaborate. We could imagine a special behavior when the enemy's health is below 50 points and instantly eliminate it, no matter what weapon was used:</p>
			<p class="source-code">user=&gt; (ns-unmap 'user 'strike)</p>
			<p class="source-code">nil</p>
			<p class="source-code">user=&gt; (defmulti strike (fn</p>
			<p class="source-code">  [{{:keys [:health]} :target weapon :weapon}]</p>
			<p class="source-code">  (if (&lt; health 50) :finisher weapon)))</p>
			<p class="source-code">#'user/strike</p>
			<p class="source-code">user=&gt; (defmethod strike :finisher [_] 0)</p>
			<p class="source-code">#object[clojure.lang.MultiFn 0xf478a81 "clojure.lang.MultiFn@f478a81"]</p>
			<p>The preceding code first unmaps <strong class="source-inline">strike</strong> from the <strong class="source-inline">user</strong> namespace so that it can be redefined. We then redefine the dispatching function by looking in the parameter and dispatching to a <strong class="source-inline">:finisher</strong> function if the health of the enemy is below <strong class="source-inline">50</strong>. We then define the <strong class="source-inline">:finisher</strong> function (the <strong class="source-inline">strike</strong> function with the dispatch value finisher) to return, simply ignore its arguments, and return <strong class="source-inline">0</strong>. </p>
			<p>Because we've unmapped <strong class="source-inline">strike</strong>, we must add <strong class="source-inline">defmethods</strong> as they would have been removed too. Let's re-add a sword and the default method:</p>
			<p class="source-code">user=&gt; (defmethod strike :sword</p>
			<p class="source-code">[{{:keys [:health]} :target}]</p>
			<p class="source-code">(- health 100))</p>
			<p class="source-code">#object[clojure.lang.MultiFn 0xaa549e5 "clojure.lang.MultiFn@aa549e5"]</p>
			<p class="source-code">user=&gt; (defmethod strike :default [{{:keys [:health]} :target}] health)</p>
			<p class="source-code">#object[clojure.lang.MultiFn 0xaa549e5 "clojure.lang.MultiFn@aa549e5"]</p>
			<p>Now let's see our multimethod in action:</p>
			<p class="source-code">user=&gt; (strike {:weapon :sword :target {:health 200}})</p>
			<p class="source-code">100</p>
			<p>Great – our function still works as expected. Now let's see what happens when the health is below <strong class="source-inline">50</strong>:</p>
			<p class="source-code">user=&gt; (strike {:weapon :spoon :target {:health 30}})</p>
			<p class="source-code">0</p>
			<p>The <strong class="source-inline">finisher</strong> function has been called and the strike multimethod successfully returned <strong class="source-inline">0</strong>. </p>
			<p>Multimethods can do a few more things, such as dispatching on multiple values (using a vector as the dispatch value) or dispatching on types and hierarchies. This is useful but maybe a bit much to take on for now. Let's move on to the exercise and practice using multimethods by dispatching on values.</p>
			<h2 id="_idParaDest-68"><a id="_idTextAnchor072"/>Exercise 3.05: Using Multimethods</h2>
			<p>In this exercise, we want to extend our little game, Parenthmazes, with the ability to move a player. The game board is a simple two-dimensional space with the coordinates x and y. We will not implement any rendering or maintain any state of the game at this point as we simply want to practice the use of multimethods, so you will have to use your imagination.</p>
			<ol>
				<li value="1">Players' entities are now given an extra key, <strong class="source-inline">:position</strong>, which contains a <strong class="source-inline">HashMap</strong> with the coordinates at key x and y as well as the <strong class="source-inline">:facing</strong> key, which contains the direction in which the player is facing. The following code is an example of a player entity:<p class="source-code"> {:name "Lea" :health 200 :position {:x 10 :y 10 :facing :north}}</p><p>Moving north or south should change the y coordinate, and moving east and west should change the x coordinate. We will implement this with a new <strong class="source-inline">move</strong> function.</p></li>
				<li>Start a REPL and create the player entity as follows:<p class="source-code">user=&gt; (def player {:name "Lea" :health 200 :position {:x 10 :y 10 :facing :north}})</p><p class="source-code">#'user/player</p></li>
				<li>Create the <strong class="source-inline">move</strong> multimethod. The dispatch function should determine the dispatch value by retrieving the <strong class="source-inline">:facing</strong> value in the <strong class="source-inline">:position</strong> map of a player entity. The <strong class="source-inline">:facing</strong> value could be one of the following values <strong class="source-inline">:north</strong>, <strong class="source-inline">:south</strong>, <strong class="source-inline">:west</strong>, and <strong class="source-inline">:east</strong>:<p class="source-code">user=&gt; (defmulti move #(:facing (:position %)))</p><p class="source-code">#'user/move</p><p>You might have noticed that the two successive keyword function calls could be more elegantly expressed with functional composition.</p></li>
				<li>Redefine the <strong class="source-inline">move</strong> multimethod by first unmapping the var from the <strong class="source-inline">user</strong> namespace and then using <strong class="source-inline">comp</strong> to simplify its definition:<p class="source-code">user=&gt; (ns-unmap 'user 'move)</p><p class="source-code">nil</p><p class="source-code">user=&gt; (defmulti move (comp :facing :position))</p><p class="source-code">#'user/move</p></li>
				<li>Create the first implementation of the <strong class="source-inline">move</strong> function with the <strong class="source-inline">:north</strong> dispatch value. It should increment <strong class="source-inline">:y</strong> in the <strong class="source-inline">:position</strong> map:<p class="source-code">User=&gt; (defmethod move :north</p><p class="source-code">[entity]</p><p class="source-code">  (update-in entity [:position :y] inc))</p><p class="source-code">#object[clojure.lang.MultiFn 0x1d0d6318 "clojure.lang.MultiFn@1d0d6318"]</p></li>
				<li>Try your newly created function by calling <strong class="source-inline">move</strong> with the <strong class="source-inline">player</strong> entity and observe the result:<p class="source-code">user=&gt; (move player)</p><p class="source-code">{:name "Lea", :health 200, :position {:x 10, :y 11, :facing :north}}</p><p>Observe that the value at <strong class="source-inline">y</strong> successfully increased by 1.</p></li>
				<li>Create the other functions for the rest of the dispatch values <strong class="source-inline">:south</strong>, <strong class="source-inline">:west</strong>, and <strong class="source-inline">:east</strong>:<p class="source-code">User=&gt; (defmethod move :south</p><p class="source-code">[entity]</p><p class="source-code">  (update-in entity [:position :y] dec))</p><p class="source-code">#object[clojure.lang.MultiFn 0x1d0d6318 "clojure.lang.MultiFn@1d0d6318"]</p><p class="source-code">User=&gt; (defmethod move :west</p><p class="source-code">[entity]</p><p class="source-code">  (update-in entity [:position :x] inc))</p><p class="source-code">#object[clojure.lang.MultiFn 0x1d0d6318 "clojure.lang.MultiFn@1d0d6318"]</p><p class="source-code">User=&gt; (defmethod move :east</p><p class="source-code">[entity]</p><p class="source-code">  (update-in entity [:position :x] dec))</p><p class="source-code">#object[clojure.lang.MultiFn 0x1d0d6318 "clojure.lang.MultiFn@1d0d6318"]</p></li>
				<li>Test your newly created functions by providing <strong class="source-inline">player</strong> entities facing different directions:<p class="source-code">user=&gt; (move {:position {:x 10 :y 10 :facing :west}})</p><p class="source-code">{:position {:x 11, :y 10, :facing :west}}</p><p class="source-code">user=&gt; (move {:position {:x 10 :y 10 :facing :south}})</p><p class="source-code">{:position {:x 10, :y 9, :facing :south}}</p><p class="source-code">user=&gt; (move {:position {:x 10 :y 10 :facing :east}})</p><p class="source-code">{:position {:x 9, :y 10, :facing :east}}</p><p>Observe how the coordinates changed correctly when moving the players in different directions.</p></li>
				<li>Create an extra function for when the value at <strong class="source-inline">:facing</strong> is different from <strong class="source-inline">:north</strong>, <strong class="source-inline">:south</strong>, <strong class="source-inline">:west</strong>, and <strong class="source-inline">:east</strong>, using the <strong class="source-inline">:default</strong> dispatch value:<p class="source-code">user=&gt; (defmethod move :default [entity] entity)</p><p class="source-code">#object[clojure.lang.MultiFn 0x1d0d6318 "clojure.lang.MultiFn@1d0d6318"]</p></li>
				<li>Try your function and make sure it handles unexpected values by returning the original entity map:<p class="source-code">user=&gt; (move {:position {:x 10 :y 10 :facing :wall}})</p><p class="source-code">{:position {:x 10, :y 10, :facing :wall}}</p><p>Observe that the multimethod was dispatched to the default function, and that the position remained unchanged when the player was facing a <strong class="source-inline">:wall</strong>.</p></li>
			</ol>
			<p>In this section, we've learned how to use Clojure's polymorphism feature with multimethods.</p>
			<h2 id="_idParaDest-69"><a id="_idTextAnchor073"/>Activity 3.01: Building a Distance and Cost Calculator</h2>
			<p>Let's go back to the flight-booking platform application that we worked on in <em class="italic">Exercise 3.01</em>, <em class="italic">Parsing Fly Vector's Data with Sequential Destructuring</em>, and <em class="italic">Exercise 3.02</em>, <em class="italic">Parsing MapJet Data with Associative Destructuring</em>. In the time it took you to arrive at the end of this chapter, we have now developed the company into a proper start-up called WingIt, with serious investors, a weekly board meeting, and a ping pong table, which means that we now need to build the core services of the app: the itinerary and cost calculations between two locations. However, after looking into routing airways, airport fees, and complicated fuel calculations, we've come to realize that the algorithms that we need to develop might be too complicated for us at this stage. We've decided that for our <strong class="bold">Minimal Viable Product </strong>(<strong class="bold">MVP</strong>), we are just going to "wing it" and offer simpler modes of transportation such as driving and even walking. However, we want to keep the code easily extensible, because we'll eventually need to add flying (some employees even overheard the CEO talking about adding space flights to the roadmap soon!).</p>
			<p>The requirement of the WingIt MVP are as follows:</p>
			<ul>
				<li>For the prototype, we will interact with a Clojure REPL. The interface is an itinerary function taking a <strong class="source-inline">HashMap</strong> as a parameter. For now, the users will have to enter coordinates. It might not be very user-friendly but the user can look up coordinates on their own globe or map!</li>
				<li>The itinerary function returns a <strong class="source-inline">HashMap</strong> with the keys, <strong class="source-inline">:distance</strong>, <strong class="source-inline">:cost</strong>, and <strong class="source-inline">:duration</strong>. <strong class="source-inline">:distance</strong> is expressed in kilometers, <strong class="source-inline">:cost</strong> in euros, and <strong class="source-inline">:duration</strong> in hours.</li>
				<li>The only parameter to the itinerary function is a <strong class="source-inline">HashMap</strong> containing <strong class="source-inline">:from</strong>, <strong class="source-inline">:to</strong>, <strong class="source-inline">:transport</strong>, and <strong class="source-inline">:vehicle</strong>. <strong class="source-inline">:from</strong> and <strong class="source-inline">:to</strong> contain a <strong class="source-inline">HashMap</strong> with the <strong class="source-inline">:lat</strong> and <strong class="source-inline">:lon</strong> keys, representing the latitude and longitude of a location on our planet.</li>
				<li><strong class="source-inline">:transport</strong> can be either <strong class="source-inline">:walking</strong> or <strong class="source-inline">:driving</strong>.</li>
				<li><strong class="source-inline">:vehicle</strong> is only useful when <strong class="source-inline">:transport</strong> is <strong class="source-inline">:driving</strong>, and can be one of <strong class="source-inline">:sporche</strong>, <strong class="source-inline">:sleta</strong>, or <strong class="source-inline">:tayato</strong>.</li>
			</ul>
			<p><strong class="bold">To compute the distance</strong>, we are going to use the "Euclidian distance," which is normally used to calculate the distance between two points on a plan. For flying, we would have to use at least the haversine formula, and technically, for driving, we would need to use routes, but we just want rough estimates on relatively short distances, so the much simpler Euclidian distance should be enough for now. The only complicated bit in this calculation is that the length of a degree of longitude depends on the latitude, so we'll need to multiply the longitude by the cosine of the latitude. The final equation to compute the distance between two points (lat1, lon1) and (lat2, lon2) looks like this:</p>
			<p> </p>
			<div>
				<div id="_idContainer025" class="IMG---Figure">
					<img src="image/B14502_03_01.jpg" alt="Figure 3.1: Calculating the Euclidean distance&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.1: Calculating the Euclidean distance</p>
			<p><strong class="bold">To compute the cost</strong> in the case of the transport being <strong class="source-inline">:driving</strong>, we will look at the <strong class="source-inline">:vehicle</strong> chosen by the user in the <strong class="source-inline">HashMap</strong> parameter. The cost of each vehicle should be a function of the distance:</p>
			<ul>
				<li><strong class="source-inline">:sporche</strong> consumes, on average, 0.12 liters of petrol per kilometer, costing €1.5 per liter.</li>
				<li><strong class="source-inline">:tayato</strong> consumes, on average, 0.07 liters of petrol per kilometer, costing €1.5 per liter.</li>
				<li><strong class="source-inline">:sleta</strong> consumes, on average, 0.2 kilowatt hour (kwh) of electricity per kilometer, costing €0.1 per kwh.</li>
				<li>The cost should be 0 when transport is <strong class="source-inline">:walking</strong>.</li>
			</ul>
			<p><strong class="bold">To compute the duration</strong>, we consider an average driving speed of 70 km per hour, and an average walking speed of 5 km per hour. </p>
			<p>Here are a couple of examples of calls to the itinerary function, and the expected output:</p>
			<p class="source-code">user=&gt; (def paris {:lat 48.856483 :lon 2.352413})</p>
			<p class="source-code">#'user/paris</p>
			<p class="source-code">user=&gt; (def bordeaux {:lat 44.834999  :lon -0.575490})</p>
			<p class="source-code">#'user/bordeaux</p>
			<p class="source-code">user=&gt; (itinerary {:from paris :to bordeaux :transport :walking})</p>
			<p class="source-code">{:cost 0, :distance 491.61380776549225, :duration 122.90345194137306}</p>
			<p class="source-code">user=&gt; (itinerary {:from paris :to bordeaux :transport :driving :vehicle :tayato})</p>
			<p class="source-code">{:cost 44.7368565066598, :distance 491.61380776549225, :duration 7.023054396649889}</p>
			<p>These steps will help you complete this activity:</p>
			<ol>
				<li value="1">Start by defining the <strong class="source-inline">walking-speed</strong> and <strong class="source-inline">driving-speed</strong> constants.</li>
				<li>Create two other constants representing two locations with the coordinates, <strong class="source-inline">:lat</strong> and <strong class="source-inline">:lon</strong>. You can use the previous example with Paris and Bordeaux or look up your own. You will be using them to test your distance and itinerary functions.</li>
				<li>Create the <strong class="source-inline">distance</strong> function. It should take two parameters representing the two locations for which we need to calculate the distance. You can use a combination of sequential and associative destructuring right in the function parameters to disassemble the latitude and longitude from both locations. You can decompose the steps of the calculation in a <strong class="source-inline">let</strong> expression and use the <strong class="source-inline">Math/cos</strong> function to calculate the cosine of a number and <strong class="source-inline">Math/sqrt</strong> to calculate the square root of a number; for example, <strong class="source-inline">(Math/cos 0)</strong>, <strong class="source-inline">(Math/sqrt 9)</strong>.</li>
				<li>Create a <em class="italic">multimethod</em> called <strong class="source-inline">itinerary</strong>. It will offer the flexibility of adding more types of transport in the future. It should use the value at <strong class="source-inline">:transport</strong> as a <em class="italic">dispatch value</em>.</li>
				<li>Create the itinerary function for the <strong class="source-inline">:walking</strong> dispatch value. You can use associative destructuring in the function parameters to retrieve the <strong class="source-inline">:from</strong> and <strong class="source-inline">:to</strong> keys from the <strong class="source-inline">HashMap</strong> parameter. You can use a <strong class="source-inline">let</strong> expression to decompose the calculations of the distance and duration. The distance should simply use the <strong class="source-inline">distance</strong> function you created before. To calculate the duration, you should use the <strong class="source-inline">walking-speed</strong> constant that you defined in <em class="italic">Step 1</em>.</li>
				<li>For the <strong class="source-inline">:driving</strong> itinerary function, you could use a dispatch table that contains the vehicle associated with the costing function. Create a <strong class="source-inline">vehicle-cost-fns</strong> dispatch table. It should be a <strong class="source-inline">HashMap</strong> with the keys being the types of vehicles, and the values being cost calculation functions based on the distance.</li>
				<li>Create the itinerary function for the <strong class="source-inline">:driving</strong> dispatch value. You can use associative destructuring in the function parameters to retrieve the <strong class="source-inline">:from</strong>, <strong class="source-inline">:to</strong>, and <strong class="source-inline">:vehicle</strong> keys from the <strong class="source-inline">HashMap</strong> parameter. The driving distance and duration can be calculated similarly to the walking distance and duration. The cost can be calculated by retrieving the cost function from the dispatch table using the <strong class="source-inline">:vehicle</strong> key.</li>
			</ol>
			<p>Expected Output:</p>
			<p class="source-code">user=&gt; (def london {:lat 51.507351, :lon -0.127758})</p>
			<p class="source-code">#'user/london</p>
			<p class="source-code">user=&gt; (def manchester {:lat 53.480759, :lon -2.242631})</p>
			<p class="source-code">#'user/manchester</p>
			<p class="source-code">user=&gt; (itinerary {:from london :to manchester :transport :walking})</p>
			<p class="source-code">{:cost 0, :distance 318.4448148814284, :duration 79.6112037203571}</p>
			<p class="source-code">user=&gt; (<a id="_idTextAnchor074"/>itinerary {:from manchester :to london :transport :driving :vehicle :sleta})</p>
			<p class="source-code">{:cost 4.604730845743489, :distance 230.2365422871744, :duration 3.2890934612453484}</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The solution for this activity can be found on page 686.</p>
			<h1 id="_idParaDest-70"><a id="_idTextAnchor075"/>Summary</h1>
			<p>In this chapter, we took a closer look at Clojure's powerful functions. We learned how to simplify our functions with destructuring techniques, and then discovered the great benefits of higher-order functions: modularity, simplicity, and composability. We also introduced an advanced concept to write code that is more extensible with Clojure's polymorphism mechanism: multimethods. Now that you are familiar with the REPL, data types, and functions, you can move on to learning about tools and functional techniques to manipulate collections.</p>
			<p>In the next chapter, we will explore sequential collections in Clojure and take a look at two of the most useful patterns: mapping and filtering.</p>
		</div>
		<div>
			<div id="_idContainer027" class="Content">
			</div>
		</div>
	</body></html>