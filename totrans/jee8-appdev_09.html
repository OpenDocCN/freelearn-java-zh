<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Securing Java EE Applications</h1>
                </header>
            
            <article>
                
<p>Java EE 8 introduces a new security API that standardizes application security across all Java EE 8 compliant application servers. The API includes standardized access to identity stores, which allow a uniform way of retrieving user credentials from a relational or LDAP database, as well as allowing us to implement access to custom identity stores. The new Java EE 8 API includes support for authentication mechanisms, allowing us to authenticate users in a standard way. Several authentication mechanisms are supported such as basic HTTP authentication, client certificates, HTML forms, and more.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Identity stores</li>
<li>Authentication mechanisms</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Identity stores</h1>
                </header>
            
            <article>
                
<p>Identity stores provide access to a persistence storage system, such as a relational or <strong>LDAP</strong> (<strong>Lightweight Directory Access Protocol</strong>) database, where user credentials are stored. The Java EE Security API supports relational and LDAP databases directly, and it allows us to integrate with custom identity stores, if necessary.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Setting up an identity store stored in a relational database</h1>
                </header>
            
            <article>
                
<p>To authenticate a secured resource, such as a Servlet or JAX-RS RESTful web service, against credentials stored in a relational database, we need to annotate an application-scoped CDI bean with the <kbd>@DatabaseIdentityStoreDefinition</kbd> annotation, as illustrated in the following example.</p>
<pre style="padding-left: 60px">package net.ensode.javaee8book.httpauthdatabaseidentitystore.security; 
 
import javax.enterprise.context.ApplicationScoped; 
import javax.security.enterprise.identitystore.DatabaseIdentityStoreDefinition; 
 
<strong>@DatabaseIdentityStoreDefinition( 
        dataSourceLookup = "jdbc/userAuth", 
        callerQuery = "select password from users where name = ?", 
        groupsQuery = "select g.GROUP_NAME from " 
                + "USER_GROUPS ug, users u, " 
                + "GROUPS g where u.USERNAME=? " 
                + "and ug.USER_ID = u.user_id " 
                + "and g.GROUP_ID= ug.GROUP_ID" 
)</strong> 
@ApplicationScoped 
public class ApplicationConfig { 
 
} </pre>
<p>In our example, the JNDI name for the JDBC connection for the relational database containing user credentials is <kbd>jdbc/userAuth</kbd>, which is the value we provided to the <kbd>dataSourceLookup</kbd> attribute of the <kbd>@DatabaseIdentityStoreDefinition</kbd> annotation.</p>
<p>The <kbd>callerQuery</kbd> parameter of <kbd>@DatabaseIdentityStoreDefinition</kbd> is used to specify the SQL query used to retrieve the username and password for the user we are authenticating. The values retrieved from the database must match the values provided by the user (via an authentication mechanism, covered later in this chapter).</p>
<p>Most secured applications have different types of users separated into roles, for example, an application could have "regular" users plus administrators. Administrators would be allowed to perform certain actions that regular users would not. For example, administrators could be able to reset user passwords and add or remove users from the system. The <kbd>groupsQuery</kbd> attribute of <kbd>@DatabaseIdentityStoreDefinition</kbd> allows us to retrieve all roles for the user.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Setting up an identity store stored in an LDAP database</h1>
                </header>
            
            <article>
                
<p>To secure resources against credentials stored in an LDAP database, we need to annotate the resource to be secured (such as a servlet or JAX-RS RESTful web service) with the <kbd>@LdapIdentityStoreDefinition</kbd> annotation, the following example illustrates how to do this:</p>
<pre style="padding-left: 60px">package net.ensode.javaee8book.httpauthdatabaseidentitystore.servlet; 
import java.io.IOException; 
import javax.security.enterprise.identitystore.<br/>LdapIdentityStoreDefinition; 
import javax.servlet.ServletException; 
import javax.servlet.annotation.WebServlet; 
import javax.servlet.http.HttpServlet; 
import javax.servlet.http.HttpServletRequest; 
import javax.servlet.http.HttpServletResponse;  
 
<strong>@LdapIdentityStoreDefinition( 
        url = "ldap://myldapserver:33389/", 
        callerBaseDn = "ou=caller,dc=packtpub,dc=com", 
        groupSearchBase = "ou=group,dc=packtpub,dc=com")</strong> 
@WebServlet(name = "ControllerServlet", urlPatterns =   <br/> {"/controller"}) 
public class ControllerServlet extends HttpServlet { 
 
    @Override 
    protected void doGet(<br/>    HttpServletRequest req, HttpServletResponse res)  
            throws ServletException, IOException { 
        System.out.println("doGet() invoked"); 
    } 
} </pre>
<p>The <kbd>url</kbd> attribute of <kbd>@LdapIdentityStoreDefinition</kbd> is used to specify the URL of the LDAP server containing user credentials for our application, its <kbd>callerBaseDn</kbd> attribute is used to specify the LDAP base-distinguished name to verify user credentials supplied by the user. Finally, its <kbd>groupSearchBase</kbd> attribute is used to retrieve the roles for the user.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Custom identity stores</h1>
                </header>
            
            <article>
                
<p>In some cases, we may need to integrate our application security with an identity store not directly supported by the security API, for example, we may have a requirement to integrate with an existing commercial security product. For cases like this, the Java EE security API allows us to roll our own identity store definition.</p>
<p>To handle custom identity stores, we need to create an application-scoped CDI bean; the bean must implement the <kbd>IdentityStore</kbd> interface, as illustrated in the following example:</p>
<pre style="padding-left: 60px">package net.ensode.javaee8book.security.basicauthexample; 
 
import java.util.Arrays; 
import java.util.HashSet; 
import java.util.Set; 
import javax.annotation.PostConstruct; 
import javax.enterprise.context.ApplicationScoped; 
import javax.security.enterprise.credential.Credential; 
import javax.security.enterprise.credential.UsernamePasswordCredential; 
import javax.security.enterprise.identitystore.CredentialValidationResult; 
import javax.security.enterprise.identitystore.IdentityStore; 
 
@ApplicationScoped 
public class DummyIdentityStore implements IdentityStore { 
 
  Set&lt;String&gt; adminRoleSet; 
  Set userRoleSet; 
  Set userAdminRoleSet; 
 
  @PostConstruct 
  public void init() { 
    adminRoleSet = new HashSet&lt;&gt;(Arrays.asList("admin")); 
    userRoleSet = new HashSet&lt;&gt;(Arrays.asList("user")); 
    userAdminRoleSet = new HashSet&lt;&gt;(Arrays.asList("user",  <br/>     "admin")); 
  } 
 
  @Override 
 <strong> public CredentialValidationResult validate(Credential credential)</strong><br/><strong>   { 
    UsernamePasswordCredential usernamePasswordCredential =  
            (UsernamePasswordCredential) credential; 
 
    CredentialValidationResult credentialValidationResult; 
 
    if (usernamePasswordCredential.compareTo( 
            "david", "secret")) { 
      credentialValidationResult =  
              new CredentialValidationResult("david", <br/>              adminRoleSet); 
    } 
    else if (usernamePasswordCredential.compareTo("alan",</strong><br/><strong>         "iforgot")) { 
      credentialValidationResult =  
              new CredentialValidationResult("alan",</strong><br/><strong>                 userAdminRoleSet); 
    } 
    else { 
      credentialValidationResult = 
        CredentialValidationResult.INVALID_RESULT; 
    } 
 
    return credentialValidationResult; 
  }</strong> 
} </pre>
<p>The <kbd>validate()</kbd> method is defined in the <kbd>IdentityStore</kbd> interface provided by the security API; in our example, we implement this method so that we can implement custom validation for our application.</p>
<div class="packt_infobox">In our example, we are hardcoding valid credentials into the code, do not do this for real applications!</div>
<p>The <kbd>validate()</kbd> method defined in the <kbd>IdentityStore</kbd> interface accepts an instance of a class implementing the <kbd>Credential</kbd> interface as its sole argument. In the body of our method, we cast it down to <kbd>UserNamePasswordCredential</kbd>, then we invoke its <kbd>compareTo()</kbd> method, passing the expected username and password. If the provided credentials match either one of the expected sets of credentials, then we allow the user to successfully log in; we do this by returning an instance of <kbd>CredentialValidationResult</kbd> containing the username and a <kbd>Set</kbd> containing all the roles that the user has in our application.</p>
<p>If the supplied credentials don't match either of the expected credentials, then we prevent the user from logging in by returning <kbd>CredentialValidationResult.INVALID_RESULT</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Authentication mechanisms</h1>
                </header>
            
            <article>
                
<p>Authentication mechanisms provide a way for the user to provide their credentials so that they can be authenticated against an identity store.</p>
<p>The Java EE 8 Security API provides support for basic HTTP authentication, a standard authentication mechanism supported by most web browsers, as well as form authentication, where users provide their credentials via an HTML form. Form authentication, by default, submits a form to a security servlet provided by the Java EE implementation. If we need more flexibility or to better align with other Java EE technologies, the security API provides custom form authentication as well, which allows us, as application developers, to have more control over how to authenticate users attempting to access our application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Basic authentication mechanism</h1>
                </header>
            
            <article>
                
<p>Basic authentication mechanisms can be achieved by annotating the resource to secure (that is, a servlet or JAX-RS RESTful web service) with the <kbd>@BasicAuthenticationMechanismDefinition</kbd> annotation:</p>
<pre style="padding-left: 60px">package net.ensode.javaee8book.security.basicauthexample; 
 
import java.io.IOException; 
import javax.annotation.security.DeclareRoles; 
import javax.security.enterprise.authentication.mechanism.http.BasicAuthenticationMechanismDefinition; 
import javax.servlet.ServletException; 
import javax.servlet.annotation.HttpConstraint; 
import javax.servlet.annotation.ServletSecurity; 
import javax.servlet.annotation.WebServlet; 
import javax.servlet.http.HttpServlet; 
import javax.servlet.http.HttpServletRequest; 
import javax.servlet.http.HttpServletResponse; 
 
<strong>@BasicAuthenticationMechanismDefinition( 
        realmName = "Book Realm" 
)</strong> 
@WebServlet(name = "SecuredServlet", <br/>     urlPatterns = {"/securedServlet"}) 
@DeclareRoles({"user", "admin"}) 
@ServletSecurity( 
        @HttpConstraint(rolesAllowed = "admin")) 
public class SecuredServlet extends HttpServlet { 
 
    @Override 
    protected void doGet(HttpServletRequest request, <br/>         HttpServletResponse response) 
            throws ServletException, IOException { 
        response.getOutputStream().<br/>             print("Congratulations, login successful."); 
    } 
} </pre>
<p>The value of the <kbd>realmName</kbd> attribute of the <kbd>@BasicAuthenticationMechanismDefinition</kbd> annotation will be sent to the browser in the <kbd>WWW-Authenticate</kbd> response header.</p>
<p>Using basic authentication will cause the browser to pop up a window asking for a <span class="packt_screen">User Name</span> and a <span class="packt_screen">Password</span>:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/730b4861-a2d8-4f02-8ee3-24755e5695f9.png" style="width:35.33em;height:11.58em;"/></div>
<p>Once the user enters the correct credentials, then access is granted to the protected resource:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/ac27f484-9430-4bb0-9ae6-e6a27e7e4704.png" style="width:24.00em;height:10.83em;"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Form authentication mechanism</h1>
                </header>
            
            <article>
                
<p>Another way we can authenticate our users is to develop an HTML form to collect the user's credentials, then delegate authentication to the Java EE Security API. The first step when following this approach is to develop an HTML page where the user can log in to the application, as illustrated in the following example:</p>
<pre style="padding-left: 60px">&lt;!DOCTYPE html&gt; 
&lt;html&gt; 
    &lt;head&gt; 
        &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt; 
        &lt;title&gt;Login&lt;/title&gt; 
    &lt;/head&gt; 
    &lt;body&gt; 
        &lt;p&gt;Please enter your username and password to access the  <br/>          application&lt;/p&gt; 
       <strong> &lt;form method="POST" action="j_security_check"&gt;</strong> 
            &lt;table cellpadding="0" cellspacing="0" border="0"&gt; 
                &lt;tr&gt; 
                    &lt;td align="right"&gt;Username: &lt;/td&gt; 
                    &lt;td&gt; 
                         <strong>  &lt;input type="text" name="j_username"&gt;</strong> 
                    &lt;/td&gt; 
                &lt;/tr&gt; 
                &lt;tr&gt; 
                    &lt;td align="right"&gt;Password: &lt;/td&gt; 
                    &lt;td&gt; 
                         <strong>  &lt;input type="password" </strong><br/><strong>                            name="j_password"&gt;</strong> 
                  &lt;/td&gt; 
                &lt;/tr&gt; 
                &lt;tr&gt; 
                    &lt;td&gt;&lt;/td&gt; 
                    &lt;td&gt;&lt;input type="submit" value="Login"&gt;&lt;/td&gt; 
                &lt;/tr&gt; 
            &lt;/table&gt; 
        &lt;/form&gt; 
    &lt;/body&gt; 
&lt;/html&gt; </pre>
<p>As seen in the example, the HTML form used for logging in must submit an HTTP POST request, the value for its <kbd>action</kbd> attribute must be <kbd>j_security_check</kbd>. <kbd>j_security_check</kbd> maps to a servlet provided by the Java EE Security API, we don't need to develop any validation logic ourselves. The form must have a couple of input fields, one for the username and one for the password, names for these fields must be <kbd>j_username</kbd> and <kbd>j_password</kbd>, respectively; the security servlet provided by the Java EE API will retrieve these values and authenticate the user automatically.</p>
<p>Additionally, we need to provide an HTML page where the user will be redirected if login fails. The page can have any valid HTML markup; in our example, we simply provide an error message and a link to direct the user back to the login page so that they can try to log in again:</p>
<pre style="padding-left: 60px">&lt;!DOCTYPE html&gt; 
&lt;html&gt; 
    &lt;head&gt; 
        &lt;meta http-equiv="Content-Type" content="text/html; <br/>         charset=UTF-8"&gt; 
        &lt;title&gt;Login Error&lt;/title&gt; 
    &lt;/head&gt; 
    &lt;body&gt; 
        There was an error logging in. 
        &lt;br /&gt; 
        &lt;a href="login.html"&gt;Try again&lt;/a&gt; 
    &lt;/body&gt; 
&lt;/html&gt; </pre>
<p>On the server side, all we need to do is annotate the secured resource with the <kbd>@FormAuthenticationMechanismDefinition</kbd> annotation, which will let the Java EE Security API know we are using form-based authentication, and what HTML pages to use to log in or to display when logging in fails:</p>
<pre style="padding-left: 60px">package net.ensode.javaee8book.httpauthdbidentitystore; 
 
import java.io.IOException; 
import javax.annotation.security.DeclareRoles; 
import javax.security.enterprise.authentication.mechanism.http.FormAuthenticationMechanismDefinition; 
import javax.security.enterprise.authentication.mechanism.http.LoginToContinue; 
import javax.security.enterprise.identitystore.DatabaseIdentityStoreDefinition; 
import javax.security.enterprise.identitystore.Pbkdf2PasswordHash; 
import javax.servlet.ServletException; 
import javax.servlet.annotation.HttpConstraint; 
import javax.servlet.annotation.ServletSecurity; 
import javax.servlet.annotation.WebServlet; 
import javax.servlet.http.HttpServlet; 
import javax.servlet.http.HttpServletRequest; 
import javax.servlet.http.HttpServletResponse; 
 
<strong>@FormAuthenticationMechanismDefinition( 
        loginToContinue = @LoginToContinue( 
                loginPage = "/login.html", 
                errorPage = "/loginerror.html" 
        ) 
)</strong> 
 
@DatabaseIdentityStoreDefinition( 
        dataSourceLookup = "java:global/authDS", 
        callerQuery = "select password from users where USERNAME =     <br/>         ?", 
        groupsQuery = "select g.GROUP_NAME from USER_GROUPS ug, <br/>        users u, GROUPS g where ug.USER_ID = u.user_id and  <br/>        g.GROUP_ID= ug.GROUP_ID and u.USERNAME=?", 
        hashAlgorithm = Pbkdf2PasswordHash.class, 
        hashAlgorithmParameters = { 
            "Pbkdf2PasswordHash.Iterations=3072", 
            "Pbkdf2PasswordHash.Algorithm=PBKDF2WithHmacSHA512", 
            "Pbkdf2PasswordHash.SaltSizeBytes=64" 
        } 
) 
@DeclareRoles({"user", "admin"}) 
@WebServlet("/securedServlet") 
@ServletSecurity( 
        @HttpConstraint(rolesAllowed = {"admin"})) 
public class SecuredServlet extends HttpServlet { 
 
    @Override 
    protected void doGet(HttpServletRequest request, <br/>     HttpServletResponse response) 
            throws ServletException, IOException { 
        response.getWriter().write("Congratulations, login  <br/>        successful."); 
    } 
} </pre>
<p>The <kbd>@FormAuthenticationMechanismDefinition</kbd> annotation has a required <kbd>loginToContinue</kbd> attribute; the value of this attribute must be an instance of the <kbd>@LoginToContinue</kbd> annotation. <kbd>@LoginToContinue</kbd> has two required attributes, <kbd>loginPage</kbd> and <kbd>errorPage</kbd>; the value of these attributes must indicate the path for the login page, and the path of the page to display in case of authentication failure, respectively.</p>
<p>After building and deploying our code, then attempting to access a protected resource, the user is automatically redirected to our login page:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/04353674-1648-445d-99d7-59a4a19ac00b.png" style="width:28.33em;height:13.08em;"/></div>
<p>If the user enters the correct credentials, then access to the protected resource is granted:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/02ee8247-c7ed-4b3e-a7f3-314b8b4dbb17.png" style="width:29.58em;height:12.00em;"/></div>
<p>If invalid credentials are entered, then the user is directed to our error page:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/08c05df8-e57d-4a10-94c7-9b3d0a243295.png" style="width:28.33em;height:12.42em;"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Custom form authentication mechanism</h1>
                </header>
            
            <article>
                
<p>Another way we can authenticate users in our application is to use a custom form authentication mechanism; this type of authentication mechanism is useful when we want to integrate our application with a web framework, such as JSF. In our next example, we will illustrate how to do just that, integrating the Java EE Security API with JSF, via custom form authentication.</p>
<p>To use custom form authentication in our applications, we need to use the aptly named <kbd>@CustomFormAuthenticationMechanismDefinition</kbd> annotation, as illustrated in the following example:</p>
<pre style="padding-left: 60px">package net.ensode.javaee8book.httpauthdbidentitystore; 
 
import java.io.IOException; 
import javax.annotation.security.DeclareRoles; 
import javax.security.enterprise.authentication.mechanism.http.CustomFormAuthenticationMechanismDefinition; 
import javax.security.enterprise.authentication.mechanism.http.LoginToContinue; 
import javax.security.enterprise.identitystore.DatabaseIdentityStoreDefinition; 
import javax.security.enterprise.identitystore.Pbkdf2PasswordHash; 
import javax.servlet.ServletException; 
import javax.servlet.annotation.HttpConstraint; 
import javax.servlet.annotation.ServletSecurity; 
import javax.servlet.annotation.WebServlet; 
import javax.servlet.http.HttpServlet; 
import javax.servlet.http.HttpServletRequest; 
import javax.servlet.http.HttpServletResponse; 
 
<strong>@CustomFormAuthenticationMechanismDefinition( 
    loginToContinue = @LoginToContinue( 
        loginPage="/faces/login.xhtml", 
        errorPage="" 
    ) 
)</strong> 
 
@DatabaseIdentityStoreDefinition( 
        dataSourceLookup = "java:global/authDS", 
        callerQuery = "select password from users where USERNAME =  <br/>         ?", 
        groupsQuery = "select g.GROUP_NAME from USER_GROUPS ug, " 
                + "users u, GROUPS g where ug.USER_ID = u.user_id " 
                + "and g.GROUP_ID= ug.GROUP_ID and u.USERNAME=?", 
                 hashAlgorithm = Pbkdf2PasswordHash.class, 
        hashAlgorithmParameters = { 
            "Pbkdf2PasswordHash.Iterations=3072", 
            "Pbkdf2PasswordHash.Algorithm=PBKDF2WithHmacSHA512", 
            "Pbkdf2PasswordHash.SaltSizeBytes=64" 
        } 
) 
@DeclareRoles({"user", "admin"}) 
@WebServlet("/securedServlet") 
@ServletSecurity( 
        @HttpConstraint(rolesAllowed = {"admin"})) 
public class SecuredServlet extends HttpServlet { 
 
    @Override 
    protected void doGet(HttpServletRequest request,  <br/>     HttpServletResponse response) 
            throws ServletException, IOException { 
        response.getWriter().write("Congratulations, login  <br/>        successful."); 
    } 
} </pre>
<p>Just like the <kbd>@FormAuthenticationMechanismDefinition</kbd> annotation we saw previously, the <kbd>@CustomFormAuthenticationMechanismDefinition</kbd> annotation has a <kbd>loginToContinue</kbd> attribute that takes an instance of the <kbd>@LoginToContinue</kbd> annotation as its value. In this case, since we are integrating with JSF, the value of the <kbd>loginPage</kbd> attribute of <kbd>@LoginToContinue</kbd> must point to the path of a Facelets page used for the user to log in. When using JSF to authenticate the user, it is expected that the login page will display an error message if authentication fails, therefore we need to leave the <kbd>errorPage</kbd> attribute of <kbd>@LoginToContinue</kbd> blank.</p>
<p>Our login page is a standard Facelets page that collects user credentials and redirects to a CDI bean that acts as a controller:</p>
<pre style="padding-left: 60px">&lt;?xml version='1.0' encoding='UTF-8' ?&gt; 
&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt; 
&lt;html  
      &gt; 
    &lt;h:head&gt; 
        &lt;title&gt;Login&lt;/title&gt; 
    &lt;/h:head&gt; 
    &lt;h:body&gt; 
        &lt;h:form&gt; 
            &lt;h:messages/&gt; 
            &lt;h:panelGrid columns="2"&gt; 
                &lt;h:outputLabel for="userName"  
                   value="User Name:"/&gt; 
                  <strong>&lt;h:inputText id="userName"</strong><br/><strong>                      value="#{user.userName}"/&gt;</strong> 
                &lt;h:outputLabel for="password"  
                  value="Password: "/&gt; 
                 <strong> &lt;h:inputSecret id="password" 
                    value="#{user.password}"/&gt;</strong> 
                &lt;h:panelGroup/&gt; 
               <strong> &lt;h:commandButton  
                  action="#{loginController.login()}" </strong><br/><strong>                  value="Login"/&gt;</strong> 
            &lt;/h:panelGrid&gt; 
        &lt;/h:form&gt; 
    &lt;/h:body&gt; 
&lt;/html&gt; </pre>
<p>Our login page has input fields for username and password; it stores those values into a CDI named bean (not shown as it is trivial) via value-binding expressions. When the user clicks on the <span class="packt_screen">Login</span> button, controls go to a <kbd>LoginController</kbd> CDI named bean that performs the actual authentication:</p>
<pre style="padding-left: 60px">package net.ensode.javaee8book.httpauthdbidentitystore.customauth; 
 
import javax.enterprise.context.RequestScoped; 
import javax.faces.application.FacesMessage; 
import javax.faces.context.ExternalContext; 
import javax.faces.context.FacesContext; 
import javax.inject.Inject; 
import javax.inject.Named; 
import javax.security.enterprise.AuthenticationStatus; 
import javax.security.enterprise.SecurityContext; 
import javax.security.enterprise.authentication.mechanism.http.AuthenticationParameters; 
import javax.security.enterprise.credential.UsernamePasswordCredential; 
import javax.servlet.http.HttpServletRequest; 
import javax.servlet.http.HttpServletResponse; 
 
@Named 
@RequestScoped 
public class LoginController { 
 
    <strong>@Inject 
    private SecurityContext securityContext;</strong> 
 
    @Inject 
    private User user; 
 
    public void login() { 
        FacesContext facesContext = <br/>        FacesContext.getCurrentInstance(); 
        ExternalContext externalContext =<br/>             facesContext.getExternalContext(); 
        HttpServletRequest httpServletRequest = <br/>             (HttpServletRequest) externalContext.getRequest(); 
        HttpServletResponse httpServletResponse = <br/>             (HttpServletResponse) externalContext.getResponse(); 
       <strong> UsernamePasswordCredential uNamePasswordCredential = </strong><br/><strong>             new UsernamePasswordCredential(user.getUserName(),</strong><br/><strong>              user.getPassword()); 
 
        AuthenticationParameters authenticationParameters =</strong><br/><strong>             AuthenticationParameters.withParams().credential(</strong><br/><strong>            uNamePasswordCredential); 
 
        AuthenticationStatus authenticationStatus =</strong><br/><strong>             securityContext.authenticate(httpServletRequest,</strong><br/><strong>             httpServletResponse, authenticationParameters); 
 
        if (authenticationStatus.equals(</strong><br/><strong>             AuthenticationStatus.SEND_CONTINUE)) { 
            facesContext.responseComplete(); 
        } else if (authenticationStatus.equals(</strong><br/><strong>             AuthenticationStatus.SEND_FAILURE)) { 
            FacesMessage facesMessage = new FacesMessage(</strong><br/><strong>               "Login error"); 
            facesContext.addMessage(null, facesMessage); 
        }</strong> 
 
    } 
} </pre>
<p>In our <kbd>LoginController</kbd> class, we need to inject an instance of <kbd>javax.security.enterprise.SecurityContext</kbd>, since we will need it for authentication. Our <kbd>login()</kbd> method is where we implement the authentication logic. The first thing we need to do is create an instance of <kbd>UsernamePasswordCredential</kbd><span class="NormalPACKTChar">, passing the user-entered username and password as parameters to its constructor.</span></p>
<p><span class="NormalPACKTChar">We then create an instance of</span> <kbd>javax.security.enterprise.authentication.mechanism.http.AuthenticationParameters</kbd><span class="NormalPACKTChar">, by invoking the static</span> <kbd>withParams()</kbd> <span class="NormalPACKTChar">method on</span> <kbd>AuthenticationParameters</kbd><span class="NormalPACKTChar">, then invoking the</span> <kbd>credential()</kbd> <span class="NormalPACKTChar">method on the resulting instance of</span> <kbd>AuthenticationParameters</kbd><span class="NormalPACKTChar">. We then pass the instance of</span> <kbd>UserNamePasswordCredential</kbd> <span class="NormalPACKTChar">we just created as a parameter; this returns yet another instance of</span> <kbd>AuthenticationParameters</kbd><span class="NormalPACKTChar">, which we can use to actually validate the user-entered credentials.</span></p>
<p><span class="NormalPACKTChar">We validate user-entered credentials by invoking the</span> <kbd>authenticate()</kbd> <span class="NormalPACKTChar">method on our</span> <kbd>SecurityContext</kbd> <span class="NormalPACKTChar">instance, passing the HTTP Request and Response objects as parameters, as well as the instance of</span> <kbd>AuthenticationParameters</kbd> <span class="NormalPACKTChar">containing the user-entered credentials. This method invocation will return an instance of</span> <kbd>AuthenticationStatus</kbd><span class="NormalPACKTChar">, we need to check the returned instance to determine whether the user entered valid credentials.</span></p>
<p><span class="NormalPACKTChar">If</span> <kbd>SecurityContext.authenticate()</kbd> <span class="NormalPACKTChar">returns</span> <kbd>AuthenticationStatus.SEND_CONTINUE</kbd><span class="NormalPACKTChar">, then the user-entered credentials were valid and we can allow the user to access the requested resource. If, instead, the method returns</span> <kbd>AuthenticationStatus.SEND_FAILURE</kbd><span class="NormalPACKTChar">, then the user-entered credentials were invalid, and we need to prevent the user from accessing the protected resource.</span></p>
<p><span class="NormalPACKTChar">After deploying and running our application, when a user attempts to access a protected resource, they are automatically redirected to a login page, which in this case, since we are using custom form authentication, is implemented using JSF:</span></p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/70475373-3017-48be-8e98-12bb223766ea.png" style="width:32.75em;height:13.92em;"/></div>
<p class="mce-root CDPAlignLeft CDPAlign">Entering correct credentials will direct the user to the protected resource (not shown) while entering incorrect credentials directs the user back to the login page, which should show an appropriate error message:</p>
<div class="CDPAlignCenter CDPAlign"><img style="text-align: center;color: #333333;font-size: 1em;width:30.92em;height:15.58em;" class=" image-border" src="assets/60911cf2-0330-4be3-a9dc-f9a22e70de44.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we covered the new Security API introduced in Java EE 8. We covered how we can access different types of identity stores to retrieve user credentials, such as relational databases or LDAP databases. We also covered how the security API provides the ability to integrate with custom identity stores, in case we need to access one that is not directly supported.</p>
<p>Additionally, we saw how we can use different authentication mechanisms to allow access to our secured Java EE applications. This included how to implement the basic authentication mechanism provided by all web browsers, as well as how to implement form-based authentication mechanisms, where we provide custom HTML pages used for authentication. Additionally, we saw how we can use the custom form authentication mechanism provided by the security API so that we can integrate our application security with a web framework such as JSF.</p>


            </article>

            
        </section>
    </body></html>