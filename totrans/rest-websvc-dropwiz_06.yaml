- en: Chapter 6. Using a Database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our application is growing steadily. We now need a place to store the contacts
    we are going to manage, and an efficient way to do so. We will use the MySQL server,
    whose installation was outlined in the first chapter of the book, for our data
    storage needs. Dropwizard provides everything we will need to interact with it.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing the database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is time to actually store and retrieve data with our application. We are
    going to create a connection between our application and a MySQL database.
  prefs: []
  type: TYPE_NORMAL
- en: We will need an actual database to connect to and query. Since we have MySQL
    installed, we can also use the `mysql` command-line client in order to create
    a database and some tables in it.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Start the `mysql` client by executing the following command in your terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'As shown in the following screenshot, the MySQL shell will then prompt you
    to provide your password, which is the password of the MySQL root user that you
    set during the installation of MySQL:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/9530OS_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s follow the next steps in order to prepare our application''s database:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the database phonebook by running the following query:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will need an additional MySQL user with full rights to the newly created
    database. Create the user and grant appropriate access rights with the following
    commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Select the `phonebook` database with the `USE` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Create the contact table in order to store some contacts.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add some test data in the contact table:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have just set up our database. With the queries we ran, we created a database
    along with a database user and a table to hold contact-related information. Our
    application will be updated in order to store and retrieve information to and
    from this table.
  prefs: []
  type: TYPE_NORMAL
- en: Interacting with the database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we have a database and data in place. However, in order to be able to connect
    to the database, we need to include the `mysql jdbc` connector in the project.
    Also, we will need the `dropwizard-jdbi` module that will allow us to create a
    database connection and **Data Access Objects** (**DAO**) through which we will
    query the database, making use of the API provided by the JDBI project ([http://jdbi.org/](http://jdbi.org/)).
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s see what is needed in order to achieve this. First, add the following
    dependencies in `pom.xml` within the `<dependencies>` section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We are now ready to proceed and update our application. We are going to use
    JDBI's SQL object API mapping methods to predefine the SQL statements.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s see how to connect and interact with the database through our application
    by following the next steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new package, `com.dwbook.phonebook.dao`, and a `ContactDAO` interface
    in it with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Add the `#getContactById()`method, which will allow us to query the database
    and retrieve a list of contacts or a specific contact when its ID is given. Use
    the `@SqlQuery` annotation to specify the SQL query that will be executed when
    the method is called. You will need to import `org.skife.jdbi.v2.sqlobject.*`
    and `com.dwbook.phonebook.representations.Contact`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Create a `com.dwbook.phonebook.dao.mappers` package and the `ContactMapper`
    class that implements the map method, as shown in the following code snippet.
    Mapper classes facilitate the mapping of a `resultset` database row to an object.
    You will need to import `java.sql.ResultSet`, `java.sql.SQLException`, `org.skife.jdbi.v2.StatementContext`,
    `org.skife.jdbi.v2.tweak.ResultSetMapper`, and `com.dwbook.phonebook.representations.Contact`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In `ContactDAO`, register your mapper with the `#getContactById()` method by
    adding the `@Mapper` annotation to it (before the `@SqlQuery` annotation). Import
    the `com.dwbook.phonebook.dao.mappers.ContactMapper` and `org.skife.jdbi.v2.sqlobject.customizers.Mapper`
    classes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the `config.yaml` configuration file, add the section database consisting
    of the minimum set of properties required for establishing a database connection
    (indented according to the `YAML` syntax).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Add the database property in the `PhonebookConfiguration` class, and create
    a getter method for it. Import the `io.dropwizard.db.DataSourceFactory` class
    first.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Modify the `run` method in the `App` class in order to create a DBIFactory class
    that will be used to build a `DBI` instance, which we will then pass as a parameter
    to `ContactResource`. You will need to import `org.skife.jdbi.v2.DBI` and `io.dropwizard.jdbi.DBIFactory`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the previous step, we passed the `jdbi` instance as a parameter to the `ContactResource`
    constructor. However, the constructor `ContactResource(DBI)` does not exist (yet),
    so we need to create it. We will add a private final `ContactDAO` member in our
    resource class using the `onDemand` method and use JDBI to instantiate it. You
    will also need to add the necessary imports for `DBI` and `ContactDAO`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Modify the `ContactResource#getContact()` method class using the `contactDao`
    object so it returns an actual contact from the database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Rebuild and run the application, providing the updated configuration file as
    an argument.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open your browser and go to `http://localho``st:8080/contact/1`. You will see
    a JSON representation of the first row we inserted in the contact table, the one
    having `id` equal to `1`, that is, `John Doe`. Take a look at the following screenshot
    which outlines this:![How to do it…](img/9530OS_06_02.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Respectively, the following screenshot shows the output for `http://localhost:8080/contact/2`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it…](img/9530OS_06_03.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Now, let's add the methods for creating, updating, and deleting contacts in
    our DAO. For inserting new entries, add the `#createContact()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that since we are updating the database and not querying it (that is, retrieving
    information), we use the `@SqlUpdate` annotation for the SQL query instead of
    the `@SqlQuery` annotation we used in the `#getContact()` method. Also, the `@GetGeneratedKeys`
    annotation is used in order to retrieve the value of the primary key of the newly
    inserted row; in this case, the value of the `id` field.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'For updating existing entries, add the `#updateContact()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In order to delete existing entries, add the `#deleteContact()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that we have the database methods in place, let''s use them in the `Resource`
    class so that we actually insert, update, and delete contacts. Modify the `ContactResource#createContact()`
    method in order to insert the new contact in the database, retrieve its `id`,
    and use it to construct its URI, passing it as a parameter to the `Response#created()`
    method. For this, we will need to import `java.net.URI and java.net.URISyntaxException`
    first:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In a similar way, update the `ContactResource#deleteContact()` method so that
    the contacts can indeed be deleted:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, let''s also update the `ContactResource#updateContact()` method so
    that our application can update existing contacts while handling the relevant
    HTTP requests:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Thanks to JDBI, our phonebook application can now interact with a database,
    retrieving, storing, updating, and deleting contacts.
  prefs: []
  type: TYPE_NORMAL
- en: Let's create a new contact by performing an HTTP POST request with `curl`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The contact is created, and the value of the inserted row''s primary key, that
    is, the contact `id,` is `174`, as you can see (the `Location` response header)
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/9530OS_06_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: JDBI's SQL Object API simplifies the creation of `DAO`. We created the `DAO`
    interfaces on which we can map plain, parameterized SQL queries to specific methods
    using the `@SqlQuery` annotation; note that apart from the object mapper, no additional
    implementation is needed.
  prefs: []
  type: TYPE_NORMAL
- en: Since we are retrieving data from the database and returning a `Contact` instance,
    we needed to create a `Mapper` class, which is a class that implements the `org.skife.jdbi.v2.tweak.ResultSetMapper<T>`
    interface for the `Contact` class. Its implementation was fairly simple and straightforward.
    We created a `Contact` object with the values we got from the database `ResultSet`
    object using the `#getLong()` and `#getString()` methods and providing the column
    name.
  prefs: []
  type: TYPE_NORMAL
- en: We used `jdbi` to create our `DAO` instances within our resource class using
    the `DBI#onDemand()` method. However, in order to do that, we had to create a
    `DBI` factory and build the `DBI` instance prior to registering our resources.
    Again, this was pretty simple, and required minor modifications in the `App#run()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: The `DBI` factory requires the database connection settings in order to build
    the `DBI` instance. Going one step back, we had our configuration class updated
    to read and expose the `DatabaseConfiguration` settings, which were declared in
    the database section of the applications configuration file, that is, `config.yaml`.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: JDBI identifies itself as an SQL convenience library for Java. We used the JDBI
    SQL Object API where a particular method is mapped to a specific SQL statement.
    However, this is not the only way of using JDBI to interact with a database. JDBI
    exposes another API too, that is, the fluent style API.
  prefs: []
  type: TYPE_NORMAL
- en: The JDBI fluent style API
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The fluent style API allows us to open and use a database handle to create and
    execute SQL queries on demand on the fly, instead of using the predefined SQL
    statements that the SQL Object API utilizes.
  prefs: []
  type: TYPE_NORMAL
- en: Generally, the type of API that you should use depends on your personal taste,
    and you can even mix both APIs together.
  prefs: []
  type: TYPE_NORMAL
- en: The @MapResultAsBean annotation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this example, we have implemented a mapper and used the `@Mapper` annotation
    in order to map the result of an SQL query to a `Contact` instance. An alternative
    approach would be the use of the `MapResultAsBean` annotation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: By annotating `#getContactById()` in this example, we map the result of the
    SQL query directly to a `Contact` instance, without needing to implement a custom
    mapper. In order for this to work though, the `Contact` class should be updated
    with setters (that is, `setFirstName(String firstName){ .. }`). Due to this, the
    final keyword will have to be removed from the declaration of each member variable.
  prefs: []
  type: TYPE_NORMAL
