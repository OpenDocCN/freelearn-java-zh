- en: '*Chapter 9*: JVM Structure and Garbage Collection'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will provide you with an overview of the structure and behavior
    of a **Java virtual machine** (**JVM**), which are more complex than you may expect.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: A JVM executes instructions according to the coded logic. It also finds and
    loads the `.class` files that are requested by the application into memory, verifies
    them, interprets the bytecode (that is, it translates them into platform-specific
    binary code), and passes the resulting binary code to the central processor (or
    processors) for execution. It uses several service threads in addition to the
    application threads. One of the service threads, called **garbage collection**
    (**GC**), performs the important step of releasing the memory from unused objects.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: By completing this chapter, you will understand what constitutes Java application
    execution, the Java processes inside the JVM and GC, and how the JVM works in
    general.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: Java application execution
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Java processes
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JVM’s structure
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Garbage collection
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To execute the code examples provided in this chapter, you will need the following:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: A computer with Microsoft Windows, Apple macOS, or the Linux operating system
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Java SE version 17 or later
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An IDE or code editor of your choice
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The instructions on how to set up a Java SE and IntelliJ IDEA editor were provided
    in [*Chapter 1*](B18388_01_ePub.xhtml#_idTextAnchor015), *Getting Started with
    Java 17*. The files that contain the code examples for this chapter are available
    on GitHub in the [https://github.com/PacktPublishing/Learn-Java-17-Programming.git](https://github.com/PacktPublishing/Learn-Java-17-Programming.git)
    repository, in the `examples/src/main/java/com/packt/learnjava/ch09_jvm` folder.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: Java application execution
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we learn how the JVM works, let’s review how to run an application,
    bearing in mind that the following statements are used as synonyms:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: Run/execute/start the main class.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Run/execute/start the main method.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Run/execute/start/launch an application.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Run/execute/start/launch the JVM or a Java process.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are also several ways to do this. In [*Chapter 1*](B18388_01_ePub.xhtml#_idTextAnchor015),
    *Getting Started with Java 17*, we showed you how to run the `main(String[])`
    method using IntelliJ IDEA. In this chapter, we will just repeat some of what
    has been said already and add other variations that might be helpful for you.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: Using an IDE
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Any IDE allows you to run the `main()` method. In IntelliJ IDEA, it can be
    done in three ways:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the green triangle next to the `main()` method''s name:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B18388_Figure_9.1.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
- en: Once you have executed the `main()` method using the green triangle at least
    once, the name of the class will be added to the drop-down menu (on the top line,
    to the left of the green triangle):![](img/B18388_Figure_9.2.jpg)
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the **Run** menu and select the name of the class. There are several options
    you can select:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B18388_Figure_9.3.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
- en: 'In the previous screenshot, you can also see the `main()` method at the start,
    plus some other options:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18388_Figure_9.4.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
- en: 'The **Program arguments** field allows for setting a parameter in the java
    command. For example, let’s set one two three in this field:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18388_Figure_9.5.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
- en: 'This setting will result in the following java command:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We can read these parameters in the main() method:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Another possible setting on the **Edit Configurations** screen is in the **Environment
    variables** field. The environment variables that can be accessed from the application
    using System.getenv(). For example, let’s set the environment variables x and
    y , as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18388_Figure_9.6.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
- en: 'If done as shown in the preceding screenshot, the values of x and y can be
    read not only in the main() method, but anywhere in the application using the
    System.getenv(“varName”) method. In our case, the values of x and y can be retrieved
    as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `java` command options. For example, if you input `-Xlog:gc`, the IDE will
    form the following `java` command:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `-Xlog:gc` option requires the GC log to be displayed. We will use this
    option in the next section to demonstrate how GC works. The `-cp .` option (`.class`
    file is located in the `com/packt/learnjava/ch09_jvm` folder, where `com` is the
    subfolder of the current directory. The classpath can include many locations where
    the JVM has to look for the `.class` files that are necessary for the application’s
    execution.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: 'Use **Modify options** link to show **VM options** as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18388_Figure_9.7.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
- en: 'For this demonstration, let’s set the value `-DsomeParameter=42` in the **VM
    options** field as shown in the following screenshot:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18388_Figure_9.8.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
- en: 'Now the value of someParameter can be read not only in the `main()` method,
    but anywhere in the application code as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: There are other parameters of the java command that can be set on the **Edit
    Configurations** screen, too. We encourage you to spend some time on that screen
    and view the possible options.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: Using the command line with classes
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, let’s run `MyApplication` from the command line. To remind you, the main
    class looks as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'First, it must be compiled using the `javac` command. The command line looks
    as follows on Linux-type platforms (provided you open the Terminal window in the
    root of the project, in the folder where `pom.xml` resides):'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'On Windows, the command looks similar:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The compiled `MyApplication.class` file is placed in the same folder as `MyApplication.java`.
    Now, we can execute the compiled class with the `java` command:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Notice that `-cp` points to the `src/main/java` folder (the path is relative
    to the current folder), where the package of the main class starts. The result
    is as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18388_Figure_9.9.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
- en: We can also put both compiled classes in a `.jar` file and run them from there.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: Using the command line with JAR files
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Keeping the compiled files in a folder as `.class` files is not always convenient,
    especially when many compiled files of the same framework belong to different
    packages and are distributed as a single library. In such cases, the compiled
    `.class` files are usually archived together in a `.jar` file. The format of such
    an archive is the same as the format of a `.zip` file. The only difference is
    that a `.jar` file also includes a manifest file that contains metadata describing
    the archive (we will talk more about the manifest in the next section).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate how to use it, let’s create a `.jar` file with the `ExampleClass.class`
    file and another `.jar` file with `MyApplication.class` in it, using the following
    commands:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Notice that we need to run the `jar` command in the folder where the package
    of the `.class` file begins.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can run the application, as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The `.jar` files are in the current folder. If we would like to execute the
    application from another folder (let’s go back to the root directory, `cd ../../..`),
    the command should look like this:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Notice that every `.jar` file must be listed on the classpath individually.
    To specify just a folder where all the `.jar` files reside (as is the case with
    the `.class` files) is not good enough. You must add an asterisk (the wildcard
    symbol, `*`) too, as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Note the quotes around the path to the folder containing the `.jar` files. Without
    quotes, this will not work.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: Using the command line with an executable JAR file
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is possible to avoid specifying the main class in the command line. Instead,
    we can create an executable `.jar` file. This can be accomplished by placing the
    name of the main class – the one you need to run and that contains the `main()`
    method – into the manifest file. Here are the steps:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a text file called `manifest.txt` (the name doesn''t matter, but this
    name makes the intent clear) that contains the following line:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: There must be a space after the colon (`:`), and there must be an invisible
    newline symbol at the end, so make sure you have pressed the *Enter* key and your
    cursor has jumped to the beginning of the next line.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: 'Execute the following command:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Notice the sequence of `jar` command options (`fm`) and the sequence of the
    `myapp.jar manifest.txt` files. They must be the same because `f` stands for the
    file that the `jar` command is going to create, while `m` stands for the manifest
    source. If you include options with `mf`, then the files must be listed as `manifest.txt
    myapp.jar`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can run the application using the following command:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The other way to create an executable `.jar` file is much easier:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The preceding command generates a manifest with the specified main class name
    automatically: the `c` option stands for `f` option stands for `e` option indicates
    an **application entry point**.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: Java processes
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you may have already guessed, JVM does not know anything about the Java language
    and source code. It only knows how to read bytecode. It reads the bytecode and
    other information from `.class` files, transforms (interprets) the bytecode into
    a sequence of binary code instructions that are specific to the current platform
    (where JVM is running), and passes the resulting binary code to the microprocessor
    that executes it. When talking about this transformation, programmers often refer
    to it as a **Java process** or just **process**.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: The JVM is often referred to as a `java` command is executed, a new instance
    of JVM is launched that’s dedicated to running the particular application as a
    separate process with its own allocated memory (the size of the memory is set
    as a default value or passed in as a command option). Inside this Java process,
    multiple threads are running, each with its own allocated memory. Some are service
    threads that are created by the JVM; others are application threads that are created
    and controlled by the application.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: That is the big picture of the JVM executing the compiled code. But if you look
    closer and read the JVM specification, you will discover that the word *process*,
    concerning the JVM, is used to describe the JVM internal processes too. The JVM
    specification identifies several other processes running inside the JVM that are
    usually not mentioned by programmers, except maybe the **class loading process**.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: This is because most of the time, we can successfully write and execute Java
    programs without knowing anything about the internal JVM processes. But once in
    a while, some general understanding of the JVM’s internal workings helps us identify
    the root cause of certain issues. That is why in this section, we will provide
    a short overview of all the processes that happen inside the JVM. Then, in the
    following sections, we will discuss the JVM’s memory structure and other aspects
    of its functionality that may be useful to a programmer.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: 'Two subsystems run the JVM’s internal processes:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '`.class` file and populates a method area in JVM’s memory with the class-related
    data:'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Static fields
  id: totrans-127
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Method bytecode
  id: totrans-128
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Class metadata that describes the class
  id: totrans-129
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The execution engine**: This executes the bytecode using the following properties:'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A heap area for object instantiation
  id: totrans-131
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Java and native method stacks for keeping track of the methods that have been
    called
  id: totrans-132
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A GC process that reclaims memory
  id: totrans-133
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Some of the processes that run inside the main JVM process are as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: 'Processes that are performed by the classloader, such as the following:'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Classloading
  id: totrans-136
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Class linking
  id: totrans-137
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Class initialization
  id: totrans-138
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Processes that are performed by the execution engine, such as the following:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: Class instantiation
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Method execution
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GC
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Application termination
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The JVM Architecture
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The JVM architecture can be described as having two subsystems – the **classloader** and
    the **execution engine** – that run the service processes and application threads
    using runtime data memory areas such as the method area, heap, and application
    thread stacks. **Threads** are lightweight processes that require less resource
    allocation than the JVM execution process.
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This list may give you the impression that these processes are executed sequentially.
    To some degree, this is true, if we’re talking about one class only. It is not
    possible to do anything with a class before loading it. We can only execute a
    method after all the previous processes have been completed. However, GC, for
    example, does not happen immediately once an object has stopped being used (see
    the *Garbage collection* section). Also, an application can exit any time when
    an unhandled exception or some other error occurs.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: Only the classloader processes are regulated by the JVM specification. The execution
    engine’s implementation is largely at the discretion of each vendor. It is based
    on the language semantics and the performance goals that have been set by the
    implementation authors.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: The processes of the execution engine are in a realm that’s not regulated by
    the JVM specification. There is common sense, tradition, known and proven solutions,
    and a Java language specification that can guide a JVM vendor’s implementation
    decision. But there is no single regulatory document. The good news is that the
    most popular JVMs use similar solutions – or at least that’s how it looks at a
    high level.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: With this in mind, let’s discuss each of the seven processes listed previously
    in more detail.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: Classloading
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: According to the JVM specification, the loading phase includes finding the `.class`
    file by its name (in the locations listed on a classpath) and creating its representation
    in memory.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: The first class to be loaded is the one that’s passed in the command line, with
    the `main(String[])` method in it. The classloader reads the `.class` file, parses
    it, and populates the method area with static fields and method bytecode. It also
    creates an instance of `java.lang.Class` that describes the class. Then, the classloader
    links the class (see the *Class linking* section), initializes it (see the *Class
    initialization* section), and then passes it to the execution engine to run its
    bytecode.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: The `main(String[])` method is an entrance door into the application. If it
    calls a method of another class, that class has to be found on the classpath,
    loaded, and initialized; only then can its method be executed too. If this – just
    loaded – method calls a method of another class, that class has to be found, loaded,
    and initialized too, and so on. That is how a Java application starts and gets
    going.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: The main(String[]) Method
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: Every class can have a `main(String[])` method and often does. Such a method
    is used to run the class independently as a standalone application for testing
    or demonstration purposes. The presence of such a method does not make the class `main`.
    The class only becomes `main` if it's been identified as such in a `java` command
    line or a `.jar` file manifest.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 每个类都可以有一个`main(String[])`方法，并且通常都有。这样的方法用于将类独立运行作为独立的应用程序进行测试或演示。存在这样的方法并不会使类成为`main`。只有当在`java`命令行或`.jar`文件清单中将其识别为`main`时，类才成为`main`。
- en: That being said, let’s continue discussing the loading process.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，让我们继续讨论加载过程。
- en: If you look in the API of `java.lang.Class`, you will not see a public constructor
    there. The classloader creates its instance automatically. This is the same instance
    that is returned by the `getClass()` method, which you can invoke on any Java
    object.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看`java.lang.Class`的API，你将不会在那里看到一个公共构造函数。类加载器会自动创建其实例。这就是`getClass()`方法返回的实例，你可以在任何Java对象上调用它。
- en: It does not carry the class’s static data (which is maintained in the method
    area), nor state values (they are in an object that’s created during the execution).
    It does not contain method bytecode either (this is stored in the method area
    too). Instead, the `Class` instance provides metadata that describes the class
    – its name, package, fields, constructors, method signatures, and so on. This
    metadata is useful not only for the JVM but also for the application.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 它不携带类的静态数据（这些数据存储在方法区），也不携带状态值（它们存储在执行过程中创建的对象中）。它也不包含方法字节码（这些也存储在方法区）。相反，`Class`实例提供了描述类的元数据——它的名称、包、字段、构造函数、方法签名等。这些元数据不仅对JVM有用，对应用程序也有用。
- en: Note
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: All the data that's created by the classloader in memory and maintained by the
    execution engine is called a **binary representation of the type**.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 由类加载器在内存中创建并由执行引擎维护的所有数据称为**类型的二进制表示**。
- en: If the `.class` file contains errors or does not adhere to a certain format,
    the process is terminated. This means that the loaded class format and its bytecode
    have been validated by the loading process already. More verification follows
    at the beginning of the next process, called **class linking**.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`.class`文件包含错误或不符合某种格式，则终止该过程。这意味着加载过程已经验证了加载的类格式及其字节码。在下一个过程的开始处还有更多的验证，称为**类链接**。
- en: 'Here is a high-level description of the loading process. It performs three
    tasks:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是对加载过程的概述。它执行三个任务：
- en: Finds and reads the `.class` file
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查找并读取`.class`文件
- en: Parses it according to the internal data structure in the method area
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据方法区内部数据结构解析它
- en: Creates an instance of `java.lang.Class` with the class metadata
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个带有类元数据的`java.lang.Class`实例
- en: Class linking
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类链接
- en: According to the JVM specification, class linking resolves the references of
    the loaded class so that the methods of the class can be executed.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 根据JVM规范，类链接解决了加载类的引用，以便可以执行类的方法。
- en: 'Here is a high-level description of the linking process. It performs three
    tasks:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是对链接过程的概述。它执行三个任务：
- en: '`.class` file was produced by the Java compiler and all the instructions satisfy
    the constraints and requirements of the language, there is no guarantee that the
    loaded file was produced by the known compiler implementation or a compiler at
    all. That’s why the first step of the linking process is verification. This makes
    sure that the binary representation of the class is structurally correct, which
    means the following:'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.class`文件是由Java编译器生成的，并且所有指令都满足语言的约束和要求，但这并不能保证加载的文件是由已知的编译器实现生成的，或者是由编译器生成的。这就是为什么链接过程的第一步是验证。这确保了类的二进制表示在结构上是正确的，这意味着以下内容：'
- en: The arguments of each method's invocation are compatible with the method descriptor.
  id: totrans-170
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个方法调用的参数与方法描述符兼容。
- en: The return instruction matches the return type of its method.
  id: totrans-171
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回指令与其方法的返回类型匹配。
- en: Some other checks and verification processes, which vary depending on the JVM
    vendor.
  id: totrans-172
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些其他检查和验证过程，这些过程因JVM供应商而异。
- en: '**Prepares the static fields in the method area**: Once verification has been
    completed, the interface or class (static) variables are created in the method
    area and initialized to the default values of their types. The other kinds of
    initialization, such as the explicit assignments that are specified by a programmer
    and static initialization blocks, are deferred to the process called **class initialization**
    (see the *Class initialization* section).'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**准备方法区中的静态字段**：一旦验证完成，接口或类（静态）变量将在方法区中创建并初始化为其类型的默认值。其他类型的初始化，例如程序员指定的显式赋值和静态初始化块，将延迟到称为**类初始化**的过程（参见*类初始化*部分）。'
- en: '**Resolves symbolic references into concrete references that point to the method
    area**: If the loaded bytecode refers to other methods, interfaces, or classes,
    the symbolic references are resolved into concrete references that point to the
    method area, which is done by the resolution process. If the referred interfaces
    and classes haven’t been loaded yet, the classloader finds and loads them as needed.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**将符号引用解析为指向方法区的具体引用**：如果加载的字节码引用了其他方法、接口或类，符号引用将被解析为指向方法区的具体引用，这是通过解析过程完成的。如果引用的接口和类尚未加载，类加载器将根据需要找到并加载它们。'
- en: Class initialization
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类初始化
- en: According to the JVM specification, initialization is accomplished by executing
    the class initialization methods. This happens when the programmer-defined initialization
    (in static blocks and static assignments) is performed, unless the class was already
    initialized at the request of another class.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 JVM 规范，初始化是通过执行类初始化方法来完成的。这发生在程序员定义的初始化（在静态块和静态赋值中）执行时，除非类已经被另一个类的请求初始化。
- en: The last part of this statement is important because the class may be requested
    several times by different (already loaded) methods, and also because JVM processes
    are executed by different threads and may access the same class concurrently.
    So, **coordination** (also called **synchronization**) between different threads
    is required, which substantially complicates the JVM implementation.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这句话的最后部分很重要，因为类可能被不同的（已经加载的）方法多次请求，也因为 JVM 进程是由不同的线程执行的，并且可能并发访问同一个类。因此，需要在不同线程之间进行**协调**（也称为**同步**），这大大增加了
    JVM 实现的复杂性。
- en: Class instantiation
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类实例化
- en: This step may never happen. Technically, an instantiation process, triggered
    by the `new` operator, is the first step of the execution process. If the `main(String[])`
    method (which is static) uses only the static methods of other classes, this instantiation
    never happens. That’s why it is reasonable to identify this process as separate
    from the execution.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这一步可能永远不会发生。技术上，由`new`运算符触发的实例化过程是执行过程的第一步。如果`main(String[])`方法（它是静态的）只使用其他类的静态方法，则这种实例化永远不会发生。这就是为什么将这个过程识别为与执行过程分开是合理的。
- en: 'This activity has very specific tasks:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这个活动有非常具体的任务：
- en: Allocating memory for the object (its state) in the heap area
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在堆区域为对象（其状态）分配内存
- en: Initializing the instance fields to the default values
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将实例字段初始化为默认值
- en: Creating thread stacks for Java and native methods
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为 Java 和本地方法创建线程栈
- en: Execution starts when the first method (not a constructor) is ready to be executed.
    For every application thread, a dedicated runtime stack is created, where every
    method call is captured in a stack frame. For example, if an exception occurs,
    we get data from the current stack frames when we call the `printStackTrace()`
    method.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 当第一个方法（不是构造函数）准备好执行时，执行开始。对于每个应用程序线程，都会创建一个专用的运行时栈，其中每个方法调用都捕获在一个栈帧中。例如，如果发生异常，当我们调用`printStackTrace()`方法时，我们会从当前的栈帧中获取数据。
- en: Method execution
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方法执行
- en: The first application thread (called the `main(String[])` method starts executing.
    It can create other application threads.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个应用程序线程（称为`main(String[])`方法开始执行。它可以创建其他应用程序线程。
- en: The execution engine reads the bytecode, interprets it, and sends the binary
    code to the microprocessor for execution. It also maintains a count of how many
    times and how often each method was called. If the count exceeds a certain threshold,
    the execution engine uses a compiler, called the **just-in-time** (**JIT**) compiler,
    which compiles the method bytecode into native code. This way, the next time the
    method is called, it will be ready without needing an interpretation. This substantially
    improves code performance.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 执行引擎读取字节码，解释它，并将二进制代码发送到微处理器执行。它还维护了一个计数器，记录每个方法被调用的次数和频率。如果计数器超过某个阈值，执行引擎会使用一个称为**即时编译器**（**JIT**）的编译器，将方法字节码编译成本地代码。这样，下次调用该方法时，它将无需解释即可准备好。这大大提高了代码性能。
- en: The instruction that’s currently being executed and the address of the next
    instruction are maintained in the **program counter** (**PC**) registers. Each
    thread has dedicated PC registers. It also improves performance and keeps track
    of the execution.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 当前正在执行的指令和下一条指令的地址被保存在**程序计数器**（**PC**）寄存器中。每个线程都有专门的PC寄存器。这也提高了性能并跟踪执行情况。
- en: Garbage collection
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 垃圾收集
- en: The garbage collector identifies the objects that are not referenced anymore
    and can be removed from the memory.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 垃圾收集器识别出不再被引用的对象，并可以从内存中移除。
- en: There is a Java static method, `System.gc()`, that can be used programmatically
    to trigger the GC, but its immediate execution is not guaranteed. Every GC cycle
    affects the application’s performance, so the JVM must maintain a balance between
    memory availability and the ability to execute the bytecode quickly enough.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个Java静态方法`System.gc()`，可以用来程序化地触发GC，但其立即执行并不保证。每次GC周期都会影响应用程序的性能，因此JVM必须在内存可用性和快速执行字节码的能力之间保持平衡。
- en: Application termination
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用程序终止
- en: 'There are several ways an application can be terminated (and the JVM stopped
    or exited) programmatically:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序可以通过多种方式被终止（以及JVM停止或退出）：
- en: Normal termination, without an error status code
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正常终止，没有错误状态码
- en: Abnormal termination, because of an unhandled exception
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非正常终止，由于未处理的异常
- en: Forced programmatic exit, with or without an error status code
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 强制程序化退出，带或不带错误状态码
- en: If there are no exceptions and infinite loops, the `main(String[])` method completes
    with a return statement or after its last statement is executed. As soon as this
    happens, the main application thread passes the control flow to the JVM and the
    JVM stops executing too. That is the happy ending, and many applications enjoy
    it in real life. Most of our examples, except those when we have demonstrated
    exceptions or infinite loops, have exited successfully too.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有异常和无限循环，`main(String[])`方法会通过返回语句或在其最后一条语句执行后完成。一旦发生这种情况，主应用程序线程将控制流传递给JVM，JVM也会停止执行。这就是美好的结局，许多应用程序在现实生活中也享受到了它。我们的大部分示例，除了我们演示异常或无限循环的情况外，也都成功退出了。
- en: However, there are other ways a Java application can exit, some of them quite
    graceful too – others not so much. If the main application thread created child
    threads or, in other words, a programmer has written code that generates other
    threads, even a graceful exit may not be easy. It all depends on the kind of child
    threads that have been created.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Java应用程序还有其他退出方式，其中一些相当优雅——而另一些则不然。如果主应用程序线程创建了子线程，或者说，程序员编写的代码生成了其他线程，即使是优雅的退出也可能不容易。这完全取决于创建的子线程类型。
- en: If any of them is a user thread (the default), then the JVM instance continues
    to run even after the main thread exits. Only after all the user threads have
    been completed does the JVM instance stop. The main thread can request the child
    user thread to complete. But until it exits, the JVM continues running. And this
    means that the application is still running too.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如果其中任何一个是一个用户线程（默认），那么即使主线程退出后，JVM实例也会继续运行。只有当所有用户线程都完成后，JVM实例才会停止。主线程可以请求子用户线程完成。但在它退出之前，JVM会继续运行。这意味着应用程序仍在运行。
- en: But if all the child threads are daemon threads, or no child threads are running,
    the JVM instance stops running as soon as the main application thread exits.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果所有子线程都是守护线程，或者没有子线程正在运行，那么一旦主应用程序线程退出，JVM实例就会停止运行。
- en: 'How the application exits in the case of an exception depends on the code design.
    We touched on this in [*Chapter 4*](B18388_04_ePub.xhtml#_idTextAnchor110), *Exception
    Handling*, while discussing the best practices of exception handling. If the thread
    captures all the exceptions in a try-catch block in `main(String[])` or a similarly
    high-level method, then it is up to the application (and the programmer who wrote
    the code) to decide how best to proceed – to try to change the input data and
    repeat the block of code that generated the exception, to log the error and continue,
    or to exit. If, on the other hand, the exception remains unhandled and propagates
    into the JVM code, the thread (where the exception occurred) stops executing and
    exits. What happens next depends on the type of thread and some other conditions.
    The following are four possible options:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: If there are no other threads, the JVM stops executing and returns an error
    code and the stack trace.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the thread with an unhandled exception was not the main one, other threads
    (if present) continue running.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the main thread has thrown an unhandled exception and the child threads (if
    present) are daemons, they exit too.
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If there is at least one user child thread, the JVM continues running until
    all the user threads exit.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are also ways to programmatically force the application to stop:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '`System.exit(0);`'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Runtime.getRuntime().exit(0);`'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Runtime.getRuntime().halt(0);`'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All these methods force the JVM to stop executing any thread and exit with
    a status code passed in as the parameter (`0`, in our examples):'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: Zero indicates normal termination
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A nonzero value indicates an abnormal termination
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the Java command was launched by some script or another system, the value
    of the status code can be used to automate the decision-making regarding the next
    step. But that is already outside the application and Java code.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: 'The first two methods have identical functionality because this is how `System.exit()`
    is implemented:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: To see the source code in the IDE, just click on the method.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: The JVM exits when some thread invokes the `exit()` method of the `Runtime`
    or `System` classes, or the `halt()` method of the `Runtime` class, and the exit
    or halt operation is permitted by the security manager. The difference between
    `exit()` and `halt()` is that `halt()` forces the JVM to exit immediately, while
    `exit()` performs additional actions that can be set using the `Runtime.addShutdownHook()`
    method. But these options are rarely used by mainstream programmers.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: JVM’s structure
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The structure of the JVM can be described in terms of its runtime data structure
    in memory and the two subsystems that use the runtime data – the classloader and
    the execution engine.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: Runtime data areas
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Each of the runtime data areas of JVM memory belongs to one of two categories:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '**Shared areas**, which include the following:'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Method area**: Class metadata, static fields, and method bytecode'
  id: totrans-225
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Heap area**: Objects (states)'
  id: totrans-226
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Unshared areas** that are dedicated to a particular application thread, which
    include the following:'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Java stack**: Current and caller frames, with each frame keeping the state
    of Java (non-native) method invocation:'
  id: totrans-228
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Values of local variables
  id: totrans-229
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Method parameter values
  id: totrans-230
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Values of operands for intermediate calculations (operand stack)
  id: totrans-231
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Method return value (if any)
  id: totrans-232
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**PC register**: The next instruction to execute'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Native method stack**: The state of the native method invocations'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have already discussed that a programmer must be careful when using reference
    types and not modify the object itself unless it needs to be done. In a multi-threaded
    application, if a reference to an object can be passed between threads, we must
    be extra careful because of the possibility of the same data being modified concurrently.
    On the bright side, though, such a shared area can be – and often is – used as
    the method of communication between threads.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: Classloaders
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The classloader performs the following three functions:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: Reads a `.class` file
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Populates the method area
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Initializes static fields that haven’t been initialized by a programmer
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Execution engine
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The execution engine does the following:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: Instantiates objects in the heap area
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Initializes static and instance fields using initializers written by the programmer
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adds/removes frames to/from the Java stack
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updates the PC register with the next instruction to execute
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maintains the native method stack
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keeps count of method calls and compiles popular ones
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finalizes objects
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Runs GC
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Terminates the application
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Garbage collection
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Automatic memory management is an important aspect of the JVM that relieves
    the programmer from the need to do so programmatically. In Java, the process that
    cleans up memory and allows it to be reused is called **GC**.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: Responsiveness, throughput, and stop-the-world
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The effectiveness of GC affects two major application characteristics – **responsiveness**
    and **throughput**:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: '**Responsiveness**: This is measured by how quickly an application responds
    (brings the necessary data) to the request; for example, how quickly a website
    returns a page, or how quickly a desktop application responds to an event. The
    smaller the response time, the better the user experience.'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Throughput**: This indicates the amount of work an application can do in
    a unit of time; for example, how many requests a web application can serve, or
    how many transactions the database can support. The bigger the number, the more
    value the application can potentially generate and the more user requests it can
    support.'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Meanwhile, GC needs to move data around, which is impossible to accomplish while
    allowing data processing to occur because the references are going to change.
    That’s why GC needs to stop application thread execution once in a while for a
    while. This is called **stop-the-world**. The longer these periods are, the quicker
    GC does its job and the longer an application freeze lasts, which can eventually
    grow big enough to affect both the application’s responsiveness and throughput.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, it is possible to tune the GC’s behavior using Java command options,
    but that is outside the scope of this book. Instead, we will provide a high-level
    view of the main activity of GC – inspecting objects in the heap and removing
    those that don’t have references in any thread stack.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: Object age and generation
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The basic GC algorithm determines *how old* each object is. The term **age**
    refers to the number of collection cycles the object has survived.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: 'When the JVM starts, the heap is empty and is divided into three sections:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: The young generation
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The old or tenured generation
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Humongous regions for holding objects that are 50% the size of a standard region
    or larger
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The young generation has three areas:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: An Eden space
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Survivor 0 (S0)
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Survivor 1 (S1)
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The newly created objects are placed in Eden. When it is filling up, a minor
    GC process starts. It removes the unreferred and circular referred objects and
    moves the others to the S1 area. During the next minor collection, S0 and S1 switch
    roles. The referenced objects are moved from Eden and S1 to S0.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: During each of the minor collections, the objects that have reached a certain
    age are moved to the old generation. As a result of this algorithm, the old generation
    contains objects that are older than a certain age. This area is bigger than the
    young generation and, because of that, the GC process is more expensive and happens
    not as often as in the young generation. But it is checked eventually (after several
    minor collections). The unreferenced objects are removed and the memory is defragmented.
    Cleaning up the old generation is considered a major collection.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: When stop-the-world is unavoidable
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Some objects are collected in the old generation concurrently, while some are
    collected using stop-the-world pauses. The steps are as follows:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: '**Initial marking**: This marks the survivor regions (root regions) that may
    have references to objects in the old generation. This is done using a stop-the-world
    pause.'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Scanning**: This searches survivor regions for references to the old generation.
    This is done concurrently while the application continues to run.'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Concurrent marking**: This marks live objects over the entire heap and is
    done concurrently while the application continues to run.'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Remark**: At this stage, the live objects have been marked, which is done
    using a stop-the-world pause.'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Cleanup**: This calculates the age of live objects, frees regions (using
    stop-the-world), and returns them to the free list. This is done concurrently.'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To help with GC tuning, the JVM provides platform-dependent default selections
    for the garbage collector, heap size, and runtime compiler. But fortunately, the
    JVM vendors improve and tune the GC process all the time, so most of the applications
    work just fine with the default GC behavior.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how a Java application can be executed using an
    IDE or the command line. Now, you can write applications and launch them in a
    manner that’s appropriate for the given environment. Knowledge about the JVM structure
    and its processes – classloading, linking, initialization, execution, GC, and
    application termination – provided you with better control over the application’s
    execution and transparency regarding the performance and current state of the
    JVM.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will discuss and demonstrate how to manage – insert,
    read, update, and delete – data in a database from a Java application. We will
    also provide a short introduction to the SQL language and its basic database operations,
    including how to connect to a database, how to create the database’s structure,
    how to write database expressions using SQL, and how to execute them.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: Quiz
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Answer the following questions to test your knowledge of this chapter:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: 'Select all of the correct statements:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An IDE executes Java code without compiling it.
  id: totrans-286
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: An IDE uses installed Java to execute the code.
  id: totrans-287
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: An IDE checks the code without using the Java installation.
  id: totrans-288
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: An IDE uses the compiler of the Java installation.
  id: totrans-289
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select all of the correct statements:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: All the classes that are used by the application must be listed on the classpath.
  id: totrans-291
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The locations of all the classes that are used by the application must be listed
    on the classpath.
  id: totrans-292
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The compiler can find a class if it is in the folder that’s listed on the classpath.
  id: totrans-293
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The classes of the main package do not need to be listed on the classpath.
  id: totrans-294
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select all of the correct statements:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: All the `.jar` files that are used by the application must be listed on the
    classpath.
  id: totrans-296
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The locations of all the `.jar` files that are used by the application must
    be listed on the classpath.
  id: totrans-297
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The JVM can only find a class if it is in the `.jar` file that’s listed on the
    classpath.
  id: totrans-298
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Every class can contain the `main()` method.
  id: totrans-299
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select all of the correct statements:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Every `.jar` file that contains a manifest is executable.
  id: totrans-301
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: If the `-jar` option is used by the `java` command, the classpath option is
    ignored.
  id: totrans-302
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Every `.jar` file has a manifest.
  id: totrans-303
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: An executable `.jar` is a ZIP file with a manifest.
  id: totrans-304
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select all of the correct statements:'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Classloading and linking can work in parallel on different classes.
  id: totrans-306
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Classloading moves the class to the execution area.
  id: totrans-307
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Class linking connects two classes.
  id: totrans-308
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Class linking uses memory references.
  id: totrans-309
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select all of the correct statements:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Class initialization assigns values to instance properties.
  id: totrans-311
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Class initialization happens every time the class is referred to by another
    class.
  id: totrans-312
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Class initialization assigns values to static properties.
  id: totrans-313
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Class initialization provides data to the instance of `java.lang.Class`.
  id: totrans-314
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select all of the correct statements:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Class instantiation may never happen.
  id: totrans-316
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Class instantiation includes object property initialization.
  id: totrans-317
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Class instantiation includes memory allocation on a heap.
  id: totrans-318
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Class instantiation includes executing constructor code.
  id: totrans-319
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select all of the correct statements:'
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Method execution includes binary code generation.
  id: totrans-321
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Method execution includes source code compilation.
  id: totrans-322
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Method execution includes reusing the binary code that’s produced by the JIT
    compiler.
  id: totrans-323
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Method execution counts how many times every method was called.
  id: totrans-324
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select all of the correct statements:'
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Garbage collection starts immediately after the `System.gc()` method is called.
  id: totrans-326
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The application can be terminated with or without an error code.
  id: totrans-327
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The application exits as soon as an exception is thrown.
  id: totrans-328
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The main thread is a user thread.
  id: totrans-329
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select all of the correct statements:'
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The JVM has memory areas shared across all threads.
  id: totrans-331
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The JVM has memory areas not shared across threads.
  id: totrans-332
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Class metadata is shared across all threads.
  id: totrans-333
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Method parameter values are not shared across threads.
  id: totrans-334
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select all of the correct statements:'
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The classloader populates the method area.
  id: totrans-336
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The classloader allocates memory on a heap.
  id: totrans-337
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The classloader writes to the `.class` file.
  id: totrans-338
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The classloader resolves method references.
  id: totrans-339
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select all of the correct statements:'
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The execution engine allocates memory on a heap.
  id: totrans-341
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The execution engine terminates the application.
  id: totrans-342
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The execution engine runs garbage collection.
  id: totrans-343
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The execution engine initializes static fields that haven’t been initialized
    by a programmer.
  id: totrans-344
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select all of the correct statements:'
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The number of transactions per second that a database can support is a throughput
    measure.
  id: totrans-346
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: When the garbage collector pauses the application, it is called stop-all-things.
  id: totrans-347
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: How slowly the website returns data is a responsiveness measure.
  id: totrans-348
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The garbage collector clears the CPU queue of jobs.
  id: totrans-349
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select all of the correct statements:'
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Object age is measured by the number of seconds since the object was created.
  id: totrans-351
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The older the object, the more probable it is going to be removed from memory.
  id: totrans-352
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Cleaning the old generation is a major collection.
  id: totrans-353
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Moving an object from one area of the young generation to another area of the
    young generation is a minor collection.
  id: totrans-354
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select all of the correct statements:'
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The garbage collector can be tuned by setting the parameters of the `javac`
    command.
  id: totrans-356
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The garbage collector can be tuned by setting the parameters of the `java` command.
  id: totrans-357
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The garbage collector works with its logic and cannot change its behavior based
    on the set parameters.
  id: totrans-358
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Cleaning the old generation area requires a stop-the-world pause.
  id: totrans-359
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
