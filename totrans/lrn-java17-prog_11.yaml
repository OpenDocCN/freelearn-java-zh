- en: '*Chapter 9*: JVM Structure and Garbage Collection'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will provide you with an overview of the structure and behavior
    of a **Java virtual machine** (**JVM**), which are more complex than you may expect.
  prefs: []
  type: TYPE_NORMAL
- en: A JVM executes instructions according to the coded logic. It also finds and
    loads the `.class` files that are requested by the application into memory, verifies
    them, interprets the bytecode (that is, it translates them into platform-specific
    binary code), and passes the resulting binary code to the central processor (or
    processors) for execution. It uses several service threads in addition to the
    application threads. One of the service threads, called **garbage collection**
    (**GC**), performs the important step of releasing the memory from unused objects.
  prefs: []
  type: TYPE_NORMAL
- en: By completing this chapter, you will understand what constitutes Java application
    execution, the Java processes inside the JVM and GC, and how the JVM works in
    general.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Java application execution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Java processes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JVM’s structure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Garbage collection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To execute the code examples provided in this chapter, you will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A computer with Microsoft Windows, Apple macOS, or the Linux operating system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Java SE version 17 or later
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An IDE or code editor of your choice
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The instructions on how to set up a Java SE and IntelliJ IDEA editor were provided
    in [*Chapter 1*](B18388_01_ePub.xhtml#_idTextAnchor015), *Getting Started with
    Java 17*. The files that contain the code examples for this chapter are available
    on GitHub in the [https://github.com/PacktPublishing/Learn-Java-17-Programming.git](https://github.com/PacktPublishing/Learn-Java-17-Programming.git)
    repository, in the `examples/src/main/java/com/packt/learnjava/ch09_jvm` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Java application execution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we learn how the JVM works, let’s review how to run an application,
    bearing in mind that the following statements are used as synonyms:'
  prefs: []
  type: TYPE_NORMAL
- en: Run/execute/start the main class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Run/execute/start the main method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Run/execute/start/launch an application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Run/execute/start/launch the JVM or a Java process.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are also several ways to do this. In [*Chapter 1*](B18388_01_ePub.xhtml#_idTextAnchor015),
    *Getting Started with Java 17*, we showed you how to run the `main(String[])`
    method using IntelliJ IDEA. In this chapter, we will just repeat some of what
    has been said already and add other variations that might be helpful for you.
  prefs: []
  type: TYPE_NORMAL
- en: Using an IDE
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Any IDE allows you to run the `main()` method. In IntelliJ IDEA, it can be
    done in three ways:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the green triangle next to the `main()` method''s name:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B18388_Figure_9.1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Once you have executed the `main()` method using the green triangle at least
    once, the name of the class will be added to the drop-down menu (on the top line,
    to the left of the green triangle):![](img/B18388_Figure_9.2.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the **Run** menu and select the name of the class. There are several options
    you can select:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B18388_Figure_9.3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the previous screenshot, you can also see the `main()` method at the start,
    plus some other options:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18388_Figure_9.4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The **Program arguments** field allows for setting a parameter in the java
    command. For example, let’s set one two three in this field:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18388_Figure_9.5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This setting will result in the following java command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We can read these parameters in the main() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Another possible setting on the **Edit Configurations** screen is in the **Environment
    variables** field. The environment variables that can be accessed from the application
    using System.getenv(). For example, let’s set the environment variables x and
    y , as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18388_Figure_9.6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If done as shown in the preceding screenshot, the values of x and y can be
    read not only in the main() method, but anywhere in the application using the
    System.getenv(“varName”) method. In our case, the values of x and y can be retrieved
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The `java` command options. For example, if you input `-Xlog:gc`, the IDE will
    form the following `java` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The `-Xlog:gc` option requires the GC log to be displayed. We will use this
    option in the next section to demonstrate how GC works. The `-cp .` option (`.class`
    file is located in the `com/packt/learnjava/ch09_jvm` folder, where `com` is the
    subfolder of the current directory. The classpath can include many locations where
    the JVM has to look for the `.class` files that are necessary for the application’s
    execution.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use **Modify options** link to show **VM options** as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18388_Figure_9.7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'For this demonstration, let’s set the value `-DsomeParameter=42` in the **VM
    options** field as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18388_Figure_9.8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now the value of someParameter can be read not only in the `main()` method,
    but anywhere in the application code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: There are other parameters of the java command that can be set on the **Edit
    Configurations** screen, too. We encourage you to spend some time on that screen
    and view the possible options.
  prefs: []
  type: TYPE_NORMAL
- en: Using the command line with classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, let’s run `MyApplication` from the command line. To remind you, the main
    class looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'First, it must be compiled using the `javac` command. The command line looks
    as follows on Linux-type platforms (provided you open the Terminal window in the
    root of the project, in the folder where `pom.xml` resides):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'On Windows, the command looks similar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The compiled `MyApplication.class` file is placed in the same folder as `MyApplication.java`.
    Now, we can execute the compiled class with the `java` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that `-cp` points to the `src/main/java` folder (the path is relative
    to the current folder), where the package of the main class starts. The result
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18388_Figure_9.9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We can also put both compiled classes in a `.jar` file and run them from there.
  prefs: []
  type: TYPE_NORMAL
- en: Using the command line with JAR files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Keeping the compiled files in a folder as `.class` files is not always convenient,
    especially when many compiled files of the same framework belong to different
    packages and are distributed as a single library. In such cases, the compiled
    `.class` files are usually archived together in a `.jar` file. The format of such
    an archive is the same as the format of a `.zip` file. The only difference is
    that a `.jar` file also includes a manifest file that contains metadata describing
    the archive (we will talk more about the manifest in the next section).
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate how to use it, let’s create a `.jar` file with the `ExampleClass.class`
    file and another `.jar` file with `MyApplication.class` in it, using the following
    commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we need to run the `jar` command in the folder where the package
    of the `.class` file begins.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can run the application, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The `.jar` files are in the current folder. If we would like to execute the
    application from another folder (let’s go back to the root directory, `cd ../../..`),
    the command should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that every `.jar` file must be listed on the classpath individually.
    To specify just a folder where all the `.jar` files reside (as is the case with
    the `.class` files) is not good enough. You must add an asterisk (the wildcard
    symbol, `*`) too, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Note the quotes around the path to the folder containing the `.jar` files. Without
    quotes, this will not work.
  prefs: []
  type: TYPE_NORMAL
- en: Using the command line with an executable JAR file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is possible to avoid specifying the main class in the command line. Instead,
    we can create an executable `.jar` file. This can be accomplished by placing the
    name of the main class – the one you need to run and that contains the `main()`
    method – into the manifest file. Here are the steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a text file called `manifest.txt` (the name doesn''t matter, but this
    name makes the intent clear) that contains the following line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: There must be a space after the colon (`:`), and there must be an invisible
    newline symbol at the end, so make sure you have pressed the *Enter* key and your
    cursor has jumped to the beginning of the next line.
  prefs: []
  type: TYPE_NORMAL
- en: 'Execute the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice the sequence of `jar` command options (`fm`) and the sequence of the
    `myapp.jar manifest.txt` files. They must be the same because `f` stands for the
    file that the `jar` command is going to create, while `m` stands for the manifest
    source. If you include options with `mf`, then the files must be listed as `manifest.txt
    myapp.jar`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can run the application using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The other way to create an executable `.jar` file is much easier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command generates a manifest with the specified main class name
    automatically: the `c` option stands for `f` option stands for `e` option indicates
    an **application entry point**.'
  prefs: []
  type: TYPE_NORMAL
- en: Java processes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you may have already guessed, JVM does not know anything about the Java language
    and source code. It only knows how to read bytecode. It reads the bytecode and
    other information from `.class` files, transforms (interprets) the bytecode into
    a sequence of binary code instructions that are specific to the current platform
    (where JVM is running), and passes the resulting binary code to the microprocessor
    that executes it. When talking about this transformation, programmers often refer
    to it as a **Java process** or just **process**.
  prefs: []
  type: TYPE_NORMAL
- en: The JVM is often referred to as a `java` command is executed, a new instance
    of JVM is launched that’s dedicated to running the particular application as a
    separate process with its own allocated memory (the size of the memory is set
    as a default value or passed in as a command option). Inside this Java process,
    multiple threads are running, each with its own allocated memory. Some are service
    threads that are created by the JVM; others are application threads that are created
    and controlled by the application.
  prefs: []
  type: TYPE_NORMAL
- en: That is the big picture of the JVM executing the compiled code. But if you look
    closer and read the JVM specification, you will discover that the word *process*,
    concerning the JVM, is used to describe the JVM internal processes too. The JVM
    specification identifies several other processes running inside the JVM that are
    usually not mentioned by programmers, except maybe the **class loading process**.
  prefs: []
  type: TYPE_NORMAL
- en: This is because most of the time, we can successfully write and execute Java
    programs without knowing anything about the internal JVM processes. But once in
    a while, some general understanding of the JVM’s internal workings helps us identify
    the root cause of certain issues. That is why in this section, we will provide
    a short overview of all the processes that happen inside the JVM. Then, in the
    following sections, we will discuss the JVM’s memory structure and other aspects
    of its functionality that may be useful to a programmer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Two subsystems run the JVM’s internal processes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`.class` file and populates a method area in JVM’s memory with the class-related
    data:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Static fields
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Method bytecode
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Class metadata that describes the class
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The execution engine**: This executes the bytecode using the following properties:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A heap area for object instantiation
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Java and native method stacks for keeping track of the methods that have been
    called
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A GC process that reclaims memory
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Some of the processes that run inside the main JVM process are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Processes that are performed by the classloader, such as the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Classloading
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Class linking
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Class initialization
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Processes that are performed by the execution engine, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Class instantiation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Method execution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Application termination
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The JVM Architecture
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The JVM architecture can be described as having two subsystems – the **classloader** and
    the **execution engine** – that run the service processes and application threads
    using runtime data memory areas such as the method area, heap, and application
    thread stacks. **Threads** are lightweight processes that require less resource
    allocation than the JVM execution process.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This list may give you the impression that these processes are executed sequentially.
    To some degree, this is true, if we’re talking about one class only. It is not
    possible to do anything with a class before loading it. We can only execute a
    method after all the previous processes have been completed. However, GC, for
    example, does not happen immediately once an object has stopped being used (see
    the *Garbage collection* section). Also, an application can exit any time when
    an unhandled exception or some other error occurs.
  prefs: []
  type: TYPE_NORMAL
- en: Only the classloader processes are regulated by the JVM specification. The execution
    engine’s implementation is largely at the discretion of each vendor. It is based
    on the language semantics and the performance goals that have been set by the
    implementation authors.
  prefs: []
  type: TYPE_NORMAL
- en: The processes of the execution engine are in a realm that’s not regulated by
    the JVM specification. There is common sense, tradition, known and proven solutions,
    and a Java language specification that can guide a JVM vendor’s implementation
    decision. But there is no single regulatory document. The good news is that the
    most popular JVMs use similar solutions – or at least that’s how it looks at a
    high level.
  prefs: []
  type: TYPE_NORMAL
- en: With this in mind, let’s discuss each of the seven processes listed previously
    in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Classloading
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: According to the JVM specification, the loading phase includes finding the `.class`
    file by its name (in the locations listed on a classpath) and creating its representation
    in memory.
  prefs: []
  type: TYPE_NORMAL
- en: The first class to be loaded is the one that’s passed in the command line, with
    the `main(String[])` method in it. The classloader reads the `.class` file, parses
    it, and populates the method area with static fields and method bytecode. It also
    creates an instance of `java.lang.Class` that describes the class. Then, the classloader
    links the class (see the *Class linking* section), initializes it (see the *Class
    initialization* section), and then passes it to the execution engine to run its
    bytecode.
  prefs: []
  type: TYPE_NORMAL
- en: The `main(String[])` method is an entrance door into the application. If it
    calls a method of another class, that class has to be found on the classpath,
    loaded, and initialized; only then can its method be executed too. If this – just
    loaded – method calls a method of another class, that class has to be found, loaded,
    and initialized too, and so on. That is how a Java application starts and gets
    going.
  prefs: []
  type: TYPE_NORMAL
- en: The main(String[]) Method
  prefs: []
  type: TYPE_NORMAL
- en: Every class can have a `main(String[])` method and often does. Such a method
    is used to run the class independently as a standalone application for testing
    or demonstration purposes. The presence of such a method does not make the class `main`.
    The class only becomes `main` if it's been identified as such in a `java` command
    line or a `.jar` file manifest.
  prefs: []
  type: TYPE_NORMAL
- en: That being said, let’s continue discussing the loading process.
  prefs: []
  type: TYPE_NORMAL
- en: If you look in the API of `java.lang.Class`, you will not see a public constructor
    there. The classloader creates its instance automatically. This is the same instance
    that is returned by the `getClass()` method, which you can invoke on any Java
    object.
  prefs: []
  type: TYPE_NORMAL
- en: It does not carry the class’s static data (which is maintained in the method
    area), nor state values (they are in an object that’s created during the execution).
    It does not contain method bytecode either (this is stored in the method area
    too). Instead, the `Class` instance provides metadata that describes the class
    – its name, package, fields, constructors, method signatures, and so on. This
    metadata is useful not only for the JVM but also for the application.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: All the data that's created by the classloader in memory and maintained by the
    execution engine is called a **binary representation of the type**.
  prefs: []
  type: TYPE_NORMAL
- en: If the `.class` file contains errors or does not adhere to a certain format,
    the process is terminated. This means that the loaded class format and its bytecode
    have been validated by the loading process already. More verification follows
    at the beginning of the next process, called **class linking**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a high-level description of the loading process. It performs three
    tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: Finds and reads the `.class` file
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Parses it according to the internal data structure in the method area
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creates an instance of `java.lang.Class` with the class metadata
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Class linking
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: According to the JVM specification, class linking resolves the references of
    the loaded class so that the methods of the class can be executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a high-level description of the linking process. It performs three
    tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: '`.class` file was produced by the Java compiler and all the instructions satisfy
    the constraints and requirements of the language, there is no guarantee that the
    loaded file was produced by the known compiler implementation or a compiler at
    all. That’s why the first step of the linking process is verification. This makes
    sure that the binary representation of the class is structurally correct, which
    means the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The arguments of each method's invocation are compatible with the method descriptor.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The return instruction matches the return type of its method.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Some other checks and verification processes, which vary depending on the JVM
    vendor.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Prepares the static fields in the method area**: Once verification has been
    completed, the interface or class (static) variables are created in the method
    area and initialized to the default values of their types. The other kinds of
    initialization, such as the explicit assignments that are specified by a programmer
    and static initialization blocks, are deferred to the process called **class initialization**
    (see the *Class initialization* section).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Resolves symbolic references into concrete references that point to the method
    area**: If the loaded bytecode refers to other methods, interfaces, or classes,
    the symbolic references are resolved into concrete references that point to the
    method area, which is done by the resolution process. If the referred interfaces
    and classes haven’t been loaded yet, the classloader finds and loads them as needed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Class initialization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: According to the JVM specification, initialization is accomplished by executing
    the class initialization methods. This happens when the programmer-defined initialization
    (in static blocks and static assignments) is performed, unless the class was already
    initialized at the request of another class.
  prefs: []
  type: TYPE_NORMAL
- en: The last part of this statement is important because the class may be requested
    several times by different (already loaded) methods, and also because JVM processes
    are executed by different threads and may access the same class concurrently.
    So, **coordination** (also called **synchronization**) between different threads
    is required, which substantially complicates the JVM implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Class instantiation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This step may never happen. Technically, an instantiation process, triggered
    by the `new` operator, is the first step of the execution process. If the `main(String[])`
    method (which is static) uses only the static methods of other classes, this instantiation
    never happens. That’s why it is reasonable to identify this process as separate
    from the execution.
  prefs: []
  type: TYPE_NORMAL
- en: 'This activity has very specific tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: Allocating memory for the object (its state) in the heap area
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Initializing the instance fields to the default values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating thread stacks for Java and native methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Execution starts when the first method (not a constructor) is ready to be executed.
    For every application thread, a dedicated runtime stack is created, where every
    method call is captured in a stack frame. For example, if an exception occurs,
    we get data from the current stack frames when we call the `printStackTrace()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: Method execution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first application thread (called the `main(String[])` method starts executing.
    It can create other application threads.
  prefs: []
  type: TYPE_NORMAL
- en: The execution engine reads the bytecode, interprets it, and sends the binary
    code to the microprocessor for execution. It also maintains a count of how many
    times and how often each method was called. If the count exceeds a certain threshold,
    the execution engine uses a compiler, called the **just-in-time** (**JIT**) compiler,
    which compiles the method bytecode into native code. This way, the next time the
    method is called, it will be ready without needing an interpretation. This substantially
    improves code performance.
  prefs: []
  type: TYPE_NORMAL
- en: The instruction that’s currently being executed and the address of the next
    instruction are maintained in the **program counter** (**PC**) registers. Each
    thread has dedicated PC registers. It also improves performance and keeps track
    of the execution.
  prefs: []
  type: TYPE_NORMAL
- en: Garbage collection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The garbage collector identifies the objects that are not referenced anymore
    and can be removed from the memory.
  prefs: []
  type: TYPE_NORMAL
- en: There is a Java static method, `System.gc()`, that can be used programmatically
    to trigger the GC, but its immediate execution is not guaranteed. Every GC cycle
    affects the application’s performance, so the JVM must maintain a balance between
    memory availability and the ability to execute the bytecode quickly enough.
  prefs: []
  type: TYPE_NORMAL
- en: Application termination
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are several ways an application can be terminated (and the JVM stopped
    or exited) programmatically:'
  prefs: []
  type: TYPE_NORMAL
- en: Normal termination, without an error status code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Abnormal termination, because of an unhandled exception
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Forced programmatic exit, with or without an error status code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If there are no exceptions and infinite loops, the `main(String[])` method completes
    with a return statement or after its last statement is executed. As soon as this
    happens, the main application thread passes the control flow to the JVM and the
    JVM stops executing too. That is the happy ending, and many applications enjoy
    it in real life. Most of our examples, except those when we have demonstrated
    exceptions or infinite loops, have exited successfully too.
  prefs: []
  type: TYPE_NORMAL
- en: However, there are other ways a Java application can exit, some of them quite
    graceful too – others not so much. If the main application thread created child
    threads or, in other words, a programmer has written code that generates other
    threads, even a graceful exit may not be easy. It all depends on the kind of child
    threads that have been created.
  prefs: []
  type: TYPE_NORMAL
- en: If any of them is a user thread (the default), then the JVM instance continues
    to run even after the main thread exits. Only after all the user threads have
    been completed does the JVM instance stop. The main thread can request the child
    user thread to complete. But until it exits, the JVM continues running. And this
    means that the application is still running too.
  prefs: []
  type: TYPE_NORMAL
- en: But if all the child threads are daemon threads, or no child threads are running,
    the JVM instance stops running as soon as the main application thread exits.
  prefs: []
  type: TYPE_NORMAL
- en: 'How the application exits in the case of an exception depends on the code design.
    We touched on this in [*Chapter 4*](B18388_04_ePub.xhtml#_idTextAnchor110), *Exception
    Handling*, while discussing the best practices of exception handling. If the thread
    captures all the exceptions in a try-catch block in `main(String[])` or a similarly
    high-level method, then it is up to the application (and the programmer who wrote
    the code) to decide how best to proceed – to try to change the input data and
    repeat the block of code that generated the exception, to log the error and continue,
    or to exit. If, on the other hand, the exception remains unhandled and propagates
    into the JVM code, the thread (where the exception occurred) stops executing and
    exits. What happens next depends on the type of thread and some other conditions.
    The following are four possible options:'
  prefs: []
  type: TYPE_NORMAL
- en: If there are no other threads, the JVM stops executing and returns an error
    code and the stack trace.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the thread with an unhandled exception was not the main one, other threads
    (if present) continue running.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the main thread has thrown an unhandled exception and the child threads (if
    present) are daemons, they exit too.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If there is at least one user child thread, the JVM continues running until
    all the user threads exit.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are also ways to programmatically force the application to stop:'
  prefs: []
  type: TYPE_NORMAL
- en: '`System.exit(0);`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Runtime.getRuntime().exit(0);`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Runtime.getRuntime().halt(0);`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All these methods force the JVM to stop executing any thread and exit with
    a status code passed in as the parameter (`0`, in our examples):'
  prefs: []
  type: TYPE_NORMAL
- en: Zero indicates normal termination
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A nonzero value indicates an abnormal termination
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the Java command was launched by some script or another system, the value
    of the status code can be used to automate the decision-making regarding the next
    step. But that is already outside the application and Java code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first two methods have identical functionality because this is how `System.exit()`
    is implemented:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: To see the source code in the IDE, just click on the method.
  prefs: []
  type: TYPE_NORMAL
- en: The JVM exits when some thread invokes the `exit()` method of the `Runtime`
    or `System` classes, or the `halt()` method of the `Runtime` class, and the exit
    or halt operation is permitted by the security manager. The difference between
    `exit()` and `halt()` is that `halt()` forces the JVM to exit immediately, while
    `exit()` performs additional actions that can be set using the `Runtime.addShutdownHook()`
    method. But these options are rarely used by mainstream programmers.
  prefs: []
  type: TYPE_NORMAL
- en: JVM’s structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The structure of the JVM can be described in terms of its runtime data structure
    in memory and the two subsystems that use the runtime data – the classloader and
    the execution engine.
  prefs: []
  type: TYPE_NORMAL
- en: Runtime data areas
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Each of the runtime data areas of JVM memory belongs to one of two categories:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Shared areas**, which include the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Method area**: Class metadata, static fields, and method bytecode'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Heap area**: Objects (states)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Unshared areas** that are dedicated to a particular application thread, which
    include the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Java stack**: Current and caller frames, with each frame keeping the state
    of Java (non-native) method invocation:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Values of local variables
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Method parameter values
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Values of operands for intermediate calculations (operand stack)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Method return value (if any)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**PC register**: The next instruction to execute'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Native method stack**: The state of the native method invocations'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have already discussed that a programmer must be careful when using reference
    types and not modify the object itself unless it needs to be done. In a multi-threaded
    application, if a reference to an object can be passed between threads, we must
    be extra careful because of the possibility of the same data being modified concurrently.
    On the bright side, though, such a shared area can be – and often is – used as
    the method of communication between threads.
  prefs: []
  type: TYPE_NORMAL
- en: Classloaders
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The classloader performs the following three functions:'
  prefs: []
  type: TYPE_NORMAL
- en: Reads a `.class` file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Populates the method area
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Initializes static fields that haven’t been initialized by a programmer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Execution engine
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The execution engine does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Instantiates objects in the heap area
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Initializes static and instance fields using initializers written by the programmer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adds/removes frames to/from the Java stack
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updates the PC register with the next instruction to execute
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maintains the native method stack
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keeps count of method calls and compiles popular ones
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finalizes objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Runs GC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Terminates the application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Garbage collection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Automatic memory management is an important aspect of the JVM that relieves
    the programmer from the need to do so programmatically. In Java, the process that
    cleans up memory and allows it to be reused is called **GC**.
  prefs: []
  type: TYPE_NORMAL
- en: Responsiveness, throughput, and stop-the-world
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The effectiveness of GC affects two major application characteristics – **responsiveness**
    and **throughput**:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Responsiveness**: This is measured by how quickly an application responds
    (brings the necessary data) to the request; for example, how quickly a website
    returns a page, or how quickly a desktop application responds to an event. The
    smaller the response time, the better the user experience.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Throughput**: This indicates the amount of work an application can do in
    a unit of time; for example, how many requests a web application can serve, or
    how many transactions the database can support. The bigger the number, the more
    value the application can potentially generate and the more user requests it can
    support.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Meanwhile, GC needs to move data around, which is impossible to accomplish while
    allowing data processing to occur because the references are going to change.
    That’s why GC needs to stop application thread execution once in a while for a
    while. This is called **stop-the-world**. The longer these periods are, the quicker
    GC does its job and the longer an application freeze lasts, which can eventually
    grow big enough to affect both the application’s responsiveness and throughput.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, it is possible to tune the GC’s behavior using Java command options,
    but that is outside the scope of this book. Instead, we will provide a high-level
    view of the main activity of GC – inspecting objects in the heap and removing
    those that don’t have references in any thread stack.
  prefs: []
  type: TYPE_NORMAL
- en: Object age and generation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The basic GC algorithm determines *how old* each object is. The term **age**
    refers to the number of collection cycles the object has survived.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the JVM starts, the heap is empty and is divided into three sections:'
  prefs: []
  type: TYPE_NORMAL
- en: The young generation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The old or tenured generation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Humongous regions for holding objects that are 50% the size of a standard region
    or larger
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The young generation has three areas:'
  prefs: []
  type: TYPE_NORMAL
- en: An Eden space
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Survivor 0 (S0)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Survivor 1 (S1)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The newly created objects are placed in Eden. When it is filling up, a minor
    GC process starts. It removes the unreferred and circular referred objects and
    moves the others to the S1 area. During the next minor collection, S0 and S1 switch
    roles. The referenced objects are moved from Eden and S1 to S0.
  prefs: []
  type: TYPE_NORMAL
- en: During each of the minor collections, the objects that have reached a certain
    age are moved to the old generation. As a result of this algorithm, the old generation
    contains objects that are older than a certain age. This area is bigger than the
    young generation and, because of that, the GC process is more expensive and happens
    not as often as in the young generation. But it is checked eventually (after several
    minor collections). The unreferenced objects are removed and the memory is defragmented.
    Cleaning up the old generation is considered a major collection.
  prefs: []
  type: TYPE_NORMAL
- en: When stop-the-world is unavoidable
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Some objects are collected in the old generation concurrently, while some are
    collected using stop-the-world pauses. The steps are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Initial marking**: This marks the survivor regions (root regions) that may
    have references to objects in the old generation. This is done using a stop-the-world
    pause.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Scanning**: This searches survivor regions for references to the old generation.
    This is done concurrently while the application continues to run.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Concurrent marking**: This marks live objects over the entire heap and is
    done concurrently while the application continues to run.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Remark**: At this stage, the live objects have been marked, which is done
    using a stop-the-world pause.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Cleanup**: This calculates the age of live objects, frees regions (using
    stop-the-world), and returns them to the free list. This is done concurrently.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To help with GC tuning, the JVM provides platform-dependent default selections
    for the garbage collector, heap size, and runtime compiler. But fortunately, the
    JVM vendors improve and tune the GC process all the time, so most of the applications
    work just fine with the default GC behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how a Java application can be executed using an
    IDE or the command line. Now, you can write applications and launch them in a
    manner that’s appropriate for the given environment. Knowledge about the JVM structure
    and its processes – classloading, linking, initialization, execution, GC, and
    application termination – provided you with better control over the application’s
    execution and transparency regarding the performance and current state of the
    JVM.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will discuss and demonstrate how to manage – insert,
    read, update, and delete – data in a database from a Java application. We will
    also provide a short introduction to the SQL language and its basic database operations,
    including how to connect to a database, how to create the database’s structure,
    how to write database expressions using SQL, and how to execute them.
  prefs: []
  type: TYPE_NORMAL
- en: Quiz
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Answer the following questions to test your knowledge of this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Select all of the correct statements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An IDE executes Java code without compiling it.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: An IDE uses installed Java to execute the code.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: An IDE checks the code without using the Java installation.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: An IDE uses the compiler of the Java installation.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select all of the correct statements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: All the classes that are used by the application must be listed on the classpath.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The locations of all the classes that are used by the application must be listed
    on the classpath.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The compiler can find a class if it is in the folder that’s listed on the classpath.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The classes of the main package do not need to be listed on the classpath.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select all of the correct statements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: All the `.jar` files that are used by the application must be listed on the
    classpath.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The locations of all the `.jar` files that are used by the application must
    be listed on the classpath.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The JVM can only find a class if it is in the `.jar` file that’s listed on the
    classpath.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Every class can contain the `main()` method.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select all of the correct statements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Every `.jar` file that contains a manifest is executable.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: If the `-jar` option is used by the `java` command, the classpath option is
    ignored.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Every `.jar` file has a manifest.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: An executable `.jar` is a ZIP file with a manifest.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select all of the correct statements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Classloading and linking can work in parallel on different classes.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Classloading moves the class to the execution area.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Class linking connects two classes.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Class linking uses memory references.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select all of the correct statements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Class initialization assigns values to instance properties.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Class initialization happens every time the class is referred to by another
    class.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Class initialization assigns values to static properties.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Class initialization provides data to the instance of `java.lang.Class`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select all of the correct statements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Class instantiation may never happen.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Class instantiation includes object property initialization.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Class instantiation includes memory allocation on a heap.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Class instantiation includes executing constructor code.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select all of the correct statements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Method execution includes binary code generation.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Method execution includes source code compilation.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Method execution includes reusing the binary code that’s produced by the JIT
    compiler.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Method execution counts how many times every method was called.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select all of the correct statements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Garbage collection starts immediately after the `System.gc()` method is called.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The application can be terminated with or without an error code.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The application exits as soon as an exception is thrown.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The main thread is a user thread.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select all of the correct statements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The JVM has memory areas shared across all threads.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The JVM has memory areas not shared across threads.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Class metadata is shared across all threads.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Method parameter values are not shared across threads.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select all of the correct statements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The classloader populates the method area.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The classloader allocates memory on a heap.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The classloader writes to the `.class` file.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The classloader resolves method references.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select all of the correct statements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The execution engine allocates memory on a heap.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The execution engine terminates the application.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The execution engine runs garbage collection.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The execution engine initializes static fields that haven’t been initialized
    by a programmer.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select all of the correct statements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The number of transactions per second that a database can support is a throughput
    measure.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: When the garbage collector pauses the application, it is called stop-all-things.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: How slowly the website returns data is a responsiveness measure.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The garbage collector clears the CPU queue of jobs.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select all of the correct statements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Object age is measured by the number of seconds since the object was created.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The older the object, the more probable it is going to be removed from memory.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Cleaning the old generation is a major collection.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Moving an object from one area of the young generation to another area of the
    young generation is a minor collection.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select all of the correct statements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The garbage collector can be tuned by setting the parameters of the `javac`
    command.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The garbage collector can be tuned by setting the parameters of the `java` command.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The garbage collector works with its logic and cannot change its behavior based
    on the set parameters.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Cleaning the old generation area requires a stop-the-world pause.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
