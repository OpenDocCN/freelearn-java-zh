- en: '17'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Deploying Your Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will explain how to deploy your backend and frontend to a server.
    Successful deployment is a key part of the software development process, and it
    is important to learn how a modern deployment process works. There are a variety
    of cloud servers or **PaaS** (short for **Platform-as-a-Service**) providers available,
    such as **Amazon Web Services** (**AWS**), DigitalOcean, Microsoft Azure, Railway,
    and Heroku.
  prefs: []
  type: TYPE_NORMAL
- en: In this book, we are using AWS and Netlify, which support multiple programming
    languages that are used in web development. We will also show you how to use Docker
    containers in deployments.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Deploying the backend with AWS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying the frontend with Netlify
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Docker containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Spring Boot application that we created in *Chapter 5*, *Securing Your Backend*,
    is required ([https://github.com/PacktPublishing/Full-Stack-Development-with-Spring-Boot-3-and-React-Fourth-Edition/tree/main/Chapter05](https://github.com/PacktPublishing/Full-Stack-Development-with-Spring-Boot-3-and-React-Fourth-Edition/tree/main/Chapter05)),
    as is the React app that we used in *Chapter 16*, *Securing Your Application*
    ([https://github.com/PacktPublishing/Full-Stack-Development-with-Spring-Boot-3-and-React-Fourth-Edition/tree/main/Chapter16](https://github.com/PacktPublishing/Full-Stack-Development-with-Spring-Boot-3-and-React-Fourth-Edition/tree/main/Chapter16)).
  prefs: []
  type: TYPE_NORMAL
- en: A Docker installation is necessary for the final section of the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying the backend with AWS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you are going to use your own server, the easiest way to deploy a Spring
    Boot application is to use an executable **Java ARchive** (**JAR**) file. With
    Gradle, an executable JAR file can be created using the Spring Boot Gradle wrapper.
    You can build your project using the following Gradle wrapper command in your
    project folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can run a Gradle task in Eclipse by right-clicking **Project**
    in the Project Explorer, navigating to **Window | Show View | Other**, and selecting
    **Gradle | Gradle Tasks** from the list. This opens a list of Gradle tasks, and
    you can start the build process by double clicking the **build** task, as illustrated
    in the following screenshot. If the Gradle tasks window is empty, click the root
    folder of the project in Eclipse:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19818_17_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 17.1: Gradle tasks'
  prefs: []
  type: TYPE_NORMAL
- en: 'This creates a new `build/libs` folder to your project, where you will find
    JAR files. By default, two JAR files are created:'
  prefs: []
  type: TYPE_NORMAL
- en: The file with extension `.plain.jar` contains Java bytecode and other resources,
    but it doesn’t contain any application framework or dependencies.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The other `.jar` file is a fully executable archive that you can run using
    the `java -jar your_appfile.jar` Java command, as illustrated in the following
    screenshot:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/B19818_17_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 17.2: Running the executable JAR file'
  prefs: []
  type: TYPE_NORMAL
- en: Nowadays, cloud servers are the principal means of providing your application
    to end users. We are going to deploy our backend to **Amazon Web Services** (**AWS**)
    ([https://aws.amazon.com/](https://aws.amazon.com/)). The AWS Free Tier offers
    users an opportunity to explore products for free.
  prefs: []
  type: TYPE_NORMAL
- en: Create a Free Tier account and log in to AWS. You have to enter your contact
    information, including a functioning mobile phone number. AWS will send you an
    SMS confirmation message to verify your account. You must add a valid credit card,
    debit card, or another payment method for your accounts covered under the AWS
    Free Tier.
  prefs: []
  type: TYPE_NORMAL
- en: You can read about the reasons why a payment method is needed at [https://repost.aws/knowledge-center/free-tier-payment-method](https://repost.aws/knowledge-center/free-tier-payment-method).
  prefs: []
  type: TYPE_NORMAL
- en: Deploying our MariaDB database
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this first section, we will deploy our MariaDB database to AWS. **Amazon
    Relational Database Service** (**RDS**) can be used to set up and operate relational
    databases. Amazon RDS supports several popular databases, including MariaDB. The
    following steps will take you through the process that creates a database in RDS:'
  prefs: []
  type: TYPE_NORMAL
- en: 'After you have created a Free Tier account with AWS, log in to the AWS website.
    The AWS dashboard contains a search bar that you can use to find different services.
    Type `RDS` into the search bar and find RDS, as illustrated in the following screenshot.
    Click on **RDS** in the **Services** list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B19818_17_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 17.3: RDS'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the **Create database** button to begin the database creation process:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B19818_17_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 17.4: Create database'
  prefs: []
  type: TYPE_NORMAL
- en: 'Select **MariaDB** from the database engine options:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B19818_17_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 17.5: Engine options'
  prefs: []
  type: TYPE_NORMAL
- en: Select **Free tier** from the templates.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Type a name for your database instance and the password for the database master
    user. You can use the default username (*admin*):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B19818_17_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 17.6: Database instance name'
  prefs: []
  type: TYPE_NORMAL
- en: 'Select **Yes** under the **Public access** section to allow public access to
    your database:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B19818_17_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 17.7: Public access'
  prefs: []
  type: TYPE_NORMAL
- en: In the **Additional configuration** section at the bottom of the page, name
    your database `cardb:`![](img/B19818_17_08.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 17.8: Additional configuration'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note! The database will not be created if the name is left empty.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Finally, click the **Create database** button. RDS will start to create your
    database instance, which might take a few minutes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After your database is successfully created, you can press the **View connection
    details** button to open a window that shows the connection details to your database.
    The **Endpoint** is the address of your database. Copy the connection details
    for later use:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B19818_17_09.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 17.9: Connection details'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we are ready to test our database. In this phase, we will use our local
    Spring Boot application. For this, we have to allow access to our database from
    outside. To change this, click on your database in the RDS database list. Then,
    click **VPC security groups**, as shown in the next screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B19818_17_10.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 17.10: Connectivity & security'
  prefs: []
  type: TYPE_NORMAL
- en: 'On the opening page, click the **Edit inbound rules** button from the **Inbound
    rules** tab. Click the **Add rule** button to add a new rule. For the new rule,
    select the **MySQL/Aurora** type and the **My IP** destination under the **Source**
    column. The **My IP** destination automatically adds the current IP address of
    your local computer as an allowed destination:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B19818_17_11.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 17.11: Inbound rules'
  prefs: []
  type: TYPE_NORMAL
- en: After you have added a new rule, press the **Save rules** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the Spring Boot application that we created in *Chapter 5*, *Securing
    Your Backend*. Change the `url`, `username`, and `password` database settings
    in the `application.properties` file to match your Amazon RDS database. The format
    of the `spring.datasource.url` property value is `jdbc:mariadb://your_rds_db_domain:3306/your_db_name`,
    as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B19818_17_12.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 17.12: The application.properties file'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if you run your application, you can see from the console that database
    tables are created and demo data is inserted into our Amazon RDS database:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B19818_17_13.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 17.13: Console'
  prefs: []
  type: TYPE_NORMAL
- en: In this phase, you should build your Spring Boot application. Run a Gradle build
    task in Eclipse by right-clicking **Project** in the Project Explorer, navigating
    to **Window | Show View | Other**, and selecting **Gradle | Gradle Tasks** from
    the list. This opens a list of Gradle tasks, and you can start the build process
    by double-clicking the **build** task. It will create a new JAR file in the `build/libs`
    folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We now have proper database settings, and we can use our newly built application
    when we deploy our application to AWS.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying our Spring Boot application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After we have deployed our database to Amazon RDS, we can start to deploy our
    Spring Boot application. The Amazon service that we are using is **Elastic Beanstalk**,
    whichcan be used to run and manage web apps in AWS. There are other alternatives,
    such as AWS Amplify, that can be used as well. Elastic Beanstalk is available
    for the Free Tier, and it also supports a wide range of programming languages
    (for example, Java, Python, Node.js, and PHP).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps will take you through the process of deploying our Spring
    Boot application to Elastic Beanstalk:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we have to create a new **role** for our application deployment. The
    role is needed to allow Elastic Beanstalk to create and manage your environment.
    You can create a role using the Amazon **IAM** (**Identity and Access Management**)
    service. Use the AWS search bar to navigate to the IAM service. In the IAM service,
    select **Roles** and press the **Create role** button. Select **AWS Service**
    and **EC2**, as shown in the following screenshot, and press the **Next** button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B19818_17_14.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 17.14: Create role'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the **Add Permissions** step, select the following permission policies:
    **AWSElasticBeanstalkWorkerTier**, **AWSElasticBeanstalkWebTier**, and **AWSElasticBeanstalkMulticontainerDocker**,
    then press the **Next** button. You can use the search bar to find the correct
    policies:![](img/B19818_17_15.png)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 17.15: Add permissions'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You can read more about managing Elastic Beanstalk instance profiles and policies
    at [https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/iam-instanceprofile.html](https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/iam-instanceprofile.html).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Type a name for your role, as illustrated in the next screenshot, and finally
    press the **Create role** button:![](img/B19818_17_16.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 17.16: Role name'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The new role that we just created allows Elastic Beanstalk to create and manage
    our environment. Now, we can start to deploy our Spring Boot application.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Use the AWS dashboard search bar to find the **Elastic Beanstalk** service.
    Click the service to navigate to the Elastic Beanstalk page:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B19818_17_17.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 17.17: Elastic Beanstalk service'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click **Applications** in the left side menu, and press the **Create application**
    button to create a new application. Type a name for your application, as shown
    in the following screenshot, and press the **Create** button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B19818_17_18.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 17.18: Create application'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we have to create an **environment** for our application. An environment
    is a collection of AWS resources running an application version. You can have
    multiple environments for one application: for example, development, production,
    and testing environments. Click the **Create new environment** button to configure
    a new environment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B19818_17_19.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 17.19: Create new environment'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the environment configuration, you first have to set the platform. In the
    **Platform type** section, select **Java** and the first version **17** for the
    branch, as shown in the following screenshot. The **Platform version** is a combination
    of specific versions of an operating system, runtime, web server, application
    server, and Elastic Beanstalk components. You can use the recommended **Platform**
    **version**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B19818_17_20.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 17.20: Platform type'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, go to the **Application code** section in the configuration page. Select
    **Upload your code** and **Local file**. Click the **Choose file** button and
    select the Spring Boot `.jar` file that we built earlier. You also have to type
    in a unique **Version label**. Finally, press the **Next** button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B19818_17_21.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 17.21: Create new environment'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the **Configuration service access** step, select the role that you created
    earlier from the **EC2 instance profile** dropdown list, as shown in the following
    screenshot. Then, press the **Next** button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B19818_17_22.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 17.22: Service access'
  prefs: []
  type: TYPE_NORMAL
- en: You can skip the optional **Set up networking, database, and tags** and **Configure
    instance traffic and scaling** steps.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, move to the **Configure updates, monitoring, and logging** step. In the
    **Environment properties** section, we have to add the following environment properties.
    You can add new properties by pressing the **Add environment property** button
    at the bottom of the page. There are already some predefined properties that you
    don’t have to modify (`GRADLE_HOME`, `M2` and `M2_HOME`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`SERVER_PORT`: `5000` (Elastic beans have a Nginx reverse proxy that will forward
    incoming requests to internal port `5000`).'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SPRING_DATASOURCE_URL`: The database URL you need to use here is identical
    to the database URL value we previously configured in the `''application.properties''`
    file when we initially tested the AWS database integration.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SPRING_DATASOURCE_USERNAME`: The username of your database.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SPRING_DATASOURCE_PASSWORD`: The password of your database.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following screenshot shows the new properties:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B19818_17_23.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 17.23: Environment properties'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Finally, in the **Review** step, press the **Submit** button, and your deployment
    will start. You have to wait until your environment is successfully launched,
    as illustrated in the next screenshot. The **Domain** in the **Environment overview**
    is the URL of your deployed REST API:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated](img/B19818_17_24.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 17.24: Environment successfully launched'
  prefs: []
  type: TYPE_NORMAL
- en: Now, we have deployed our Spring Boot application, but the application can’t
    access the AWS database yet. For this, we have to allow access from the deployed
    application to our database. To do this, navigate to Amazon RDS and select your
    database from the RDS database list. Then, click **VPC security groups** and click
    the **Edit inbound rules** button, like we did earlier. Delete the rule that allows
    access from your local IP address.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a new rule whose **Type** is **MySQL/Aurora**. In the **Destination** field,
    type in `sg`. This will open a list of environments, as shown in the following
    screenshot. Select the environment where your Spring Boot application is running
    (it begins with the “awseb” text and has a subtitle that shows the name of your
    environment) and press the **Save rules** button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B19818_17_25.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 17.25: Inbound rules'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, your application is properly deployed, and you can log in to your deployed
    REST API using Postman and the URL that you got from the domain in *step 12*.
    The following screenshot shows the POST request that is sent to the `aws_domain_url/login`
    endpoint:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B19818_17_26.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 17.26: Postman authentication'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also configure a custom domain name for your Elastic Beanstalk environment,
    and then you can use HTTPS to allow users to connect to your website securely.
    If you don’t own a domain name, you can still use HTTPS with a self-signed certificate
    for development and testing purposes. You can find the configuration instructions
    in the AWS documentation: [https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/configuring-https.html](https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/configuring-https.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Note! You should delete AWS resources that you have created to avoid being charged
    unexpectedly. You will get a reminder email from AWS to delete resources before
    the end of your Free Tier period.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we are ready to deploy our frontend.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying the frontend with Netlify
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we deploy with Netlify, we will learn how you can build your React project
    locally. Move to your frontend project folder and execute the following `npm`
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: By default, your project is built in the `/dist` folder. You can change the
    folder by using the `build.outDir` property in your Vite configuration file.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, the build process compiles your TypeScript code; therefore, you have
    to fix all TypeScript errors or warnings, if there are any. A commonly encountered
    error occurs when you forget to remove unused imports, as illustrated in the example
    error below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This indicates that the `AddCar.tsx` file imports the `Snackbar` component,
    but the component isn’t actually utilized. Therefore, you should remove this unused
    import. Once all errors have been resolved, you can proceed to rebuilding your
    project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Vite uses **Rollup** ([https://rollupjs.org/](https://rollupjs.org/)) to bundle
    your code. Test files and development tools are *not* included in the production
    build. After you have built your app, you can test your local build using the
    following `npm` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The command starts a local static web server that serves your built app. You
    can test your app in a browser by using the URL that is shown in the terminal.
  prefs: []
  type: TYPE_NORMAL
- en: 'You could deploy your frontend to AWS as well, but we will use **Netlify**
    ([https://www.netlify.com/](https://www.netlify.com/)) for our frontend deployment.
    Netlify is a modern web development platform that is easy to use. You can use
    the Netlify **command-line interface** (**CLI**) or GitHub to deploy your project.
    In this section, we will use Netlify’s GitHub integration to deploy our frontend:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we have to change our REST API URL. Open your frontend project with
    VS Code and open the `.env` file in the editor. Change the `VITE_API_URL` variable
    to match your backend’s URL, as follows, and save the changes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a GitHub repository for your frontend project. Execute the following
    Git commands in your project folder using the command line. These Git commands
    create a new Git repository, make an initial commit, set up a remote repository
    on GitHub, and push the code to your remote repository:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Sign up and log in to Netlify. We will use a free **Starter** account that has
    limited features. With this account, you can build one concurrent build for free,
    and there is some limitation in bandwidth.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can read more about the Netlify free account features at [https://www.netlify.com/pricing/](https://www.netlify.com/pricing/).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Open the **Sites** from the left side menu and you should see the **Import
    an existing project** panel, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B19818_17_27.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 17.27: Import an existing project'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the **Import from Git** button and select **Deploy with GitHub**. In
    this phase, you have to authorize your GitHub to get access to your repositories.
    After you have authorized successfully, you should see your GitHub username and
    repository search field, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B19818_17_28.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 17.28: GitHub repository'
  prefs: []
  type: TYPE_NORMAL
- en: Search for your frontend repository and click it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, you will see the deployment settings. Continue with the default settings
    by pressing the **Deploy <your_repository_name>** button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B19818_17_29.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 17.29: Deployment settings'
  prefs: []
  type: TYPE_NORMAL
- en: 'After the deployment has finished, you will see the following dialog. Press
    the **View site deploy** button, as shown in the following figure, and you will
    be redirected to the **Deploys** page. Netlify generates a random site name for
    you, but you can use your own domain as well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B19818_17_30.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 17.30: Deploy success'
  prefs: []
  type: TYPE_NORMAL
- en: 'On the **Deploys** page, you will see your deployed site, and you can access
    your frontend by clicking the **Open production deploy** button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B19818_17_31.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 17.31: Deploys'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, you should see the login form, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B19818_17_32.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 17.32: Login screen'
  prefs: []
  type: TYPE_NORMAL
- en: You can delete your Netlify deployment from the **Site configuration** in the
    left side menu.
  prefs: []
  type: TYPE_NORMAL
- en: We have now deployed our frontend, and we can move on to learning about containers.
  prefs: []
  type: TYPE_NORMAL
- en: Using Docker containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Docker** ([https://www.docker.com/](https://www.docker.com/)) is a container
    platform that makes software development, deployment, and shipping easier. Containers
    are lightweight and executable software packages that include everything that
    is needed to run software. Containers can be deployed to cloud services, such
    as AWS, Azure, and Netlify, and they offer many benefits for deploying applications:'
  prefs: []
  type: TYPE_NORMAL
- en: Containers are isolated, which means each container runs independently of the
    host system and other containers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Containers are portable because they contain everything an application needs
    to run.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Containers can also be used to ensure consistency between development and production
    environments.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Note! To run Docker containers on Windows, you need the Windows 10 or 11 Professional
    or Enterprise versions. You read more about this in the Docker installation documentation:
    [https://docs.docker.com/desktop/install/windows-install/](https://docs.docker.com/desktop/install/windows-install/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we will create a container for our MariaDB database and Spring
    Boot application, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Install Docker on your workstation. You can find installation packages for multiple
    platforms at [https://www.docker.com/get-docker](https://www.docker.com/get-docker).
    If you have a Windows operating system, you can go through the installation wizard
    using the default settings.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you are having problems with the installation, you can read the Docker troubleshooting
    documentation at [https://docs.docker.com/desktop/troubleshoot/topics](https://docs.docker.com/desktop/troubleshoot/topics).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'After the installation, you can check the current version by typing the following
    command in the terminal. Note! When you run Docker commands, you should start
    Docker Engine if it is not running (on Windows and macOS, you start Docker Desktop):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'First, we create a container for our MariaDB database. You can pull the latest
    MariaDB database image version from Docker Hub using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After the `pull` command has finished, you can check that a new `mariadb` image
    exists by typing the `docker image ls` command, and the output should look as
    follows. A **Docker image** is a template that contains instructions for creating
    a container:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B19818_17_33.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 17.33: Docker images'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will run the `mariadb` container. The `docker run` command creates
    and runs a container based on the given image. The following command sets the
    root user password and creates a new database, called `cardb`, that we need for
    our Spring Boot application (Note! Use your own MariaDB root user password that
    you are using in your Spring Boot application):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we have created our database container, and we can start to create a container
    for the Spring Boot application. First, we have to change the data source URL
    of our Spring Boot application. Open the `application.properties` file of your
    application and change the `spring.datasource.url` value to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is because our database is now running in the `cardb` container and the
    port is `3306`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Then, we have to create an executable JAR file from our Spring Boot application,
    just as we did at the beginning of this chapter. You can also run a Gradle task
    in the Eclipse by right-clicking **Project** in the Project Explorer, selecting
    **Window | Show View | Gradle** and then **Gradle Tasks** from the list. This
    opens a list of Gradle tasks, and you can start the build process by double clicking
    the **build** task. Once the build is finished, you can find the executable JAR
    file from the `build/libs` folder inside your project folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Containers are defined by using **Dockerfiles**. Create a new Dockerfile using
    Eclipse in the `root` folder of your project (`cardatabase`) and name it `Dockerfile`.
    The following lines of code show the contents of the Dockerfile:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s examine each line:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`FROM` defines the **Java Development Kit** (**JDK**) version, and you should
    use the same version that you used to build your JAR file. We are using Eclipse
    Temurin, which is an open-source JDK, and version 17, which we used when we developed
    our Spring Boot application.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Volumes are used for persistent data generated by and used by Docker containers.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EXPOSE` defines the port that should be published outside of the container.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`COPY` copies the JAR file to the container’s filesystem and renames it `app.jar`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Lastly, `ENTRYPOINT` defines the command-line arguments that the Docker container
    runs.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: You can read more about the Dockerfile syntax at [https://docs.docker.com/engine/reference/builder/](https://docs.docker.com/engine/reference/builder/).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Build an image with the following command in the folder where your Dockerfile
    is located. With the `-t` argument, we can give a friendly name to our container:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'At the end of the build, you should see a **Building** [...] **FINISHED** message,
    as illustrated in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 15.25 – Docker build ](img/B19818_17_34.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 17.34: Docker build'
  prefs: []
  type: TYPE_NORMAL
- en: 'Check the list of images using the `docker image ls` command. You should see
    two images now, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B19818_17_35.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 17.35: Docker images'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can run our Spring Boot container and link the MariaDB container to
    it using the following command. This command specifies that our Spring Boot container
    can access the MariaDB container using the `mariadb` name:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When our application and database are running, we can access the Spring Boot
    application logs using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can see here that our application is up and running:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19818_17_36.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 17.36: Application log'
  prefs: []
  type: TYPE_NORMAL
- en: 'Our application has started successfully, and the demonstration data has been
    inserted into the database that exists in the MariaDB container. Now, you can
    use your backend, as seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19818_17_37.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 17.37: Application login'
  prefs: []
  type: TYPE_NORMAL
- en: 'We have learned a few different ways to deploy your full-stack application
    and how to containerize your Spring Boot application. As a next step, you could
    study how to deploy Docker containers. For example, AWS has a guide to deploying
    containers on Amazon ECS: [https://aws.amazon.com/getting-started/hands-on/deploy-docker-containers/](https://aws.amazon.com/getting-started/hands-on/deploy-docker-containers/).'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to deploy our application. We deployed the
    Spring Boot application to AWS Elastic Beanstalk. Next, we deployed our React
    frontend using Netlify. Finally, we used Docker to create containers for our Spring
    Boot application and the MariaDB database.
  prefs: []
  type: TYPE_NORMAL
- en: As we reach the final pages of this book, I hope you’ve had an exciting journey
    through the world of full-stack development with Spring Boot and React. As you
    continue your full-stack development journey, remember that technologies are evolving
    all the time. For a developer, life is constant learning and innovation – so stay
    curious and keep building.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How should you create a Spring Boot executable JAR file?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What AWS services you can use to deploy a database and Spring Boot application
    to AWS?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What command can you use to build your Vite React project?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is Docker?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How should you create a Spring Boot application container?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How should you create a MariaDB container?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Packt Publishing has other resources available for learning about React, Spring
    Boot, and Docker. A few of them are listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Docker Fundamentals for Beginners [Video]*, by Coding Gears | Train Your Brain
    ([https://www.packtpub.com/product/docker-fundamentals-for-beginners-video/9781803237428](https://www.packtpub.com/product/docker-fundamentals-for-beginners-video/9781803237428))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Docker* *for* *Developers*, by Richard Bullington-McGuire, Andrew K. Dennis,
    andMichael Schwartz ([https://www.packtpub.com/product/docker-for-developers/9781789536058](https://www.packtpub.com/product/docker-for-developers/9781789536058))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*AWS, JavaScript, React - Deploy Web Apps on the Cloud [Video]*, by YouAccel
    Training ([https://www.packtpub.com/product/aws-javascript-react-deploy-web-apps-on-the-cloud-video/9781837635801](https://www.packtpub.com/product/aws-javascript-react-deploy-web-apps-on-the-cloud-video/9781837635801))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn more on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To join the Discord community for this book – where you can share feedback,
    ask the author questions, and learn about new releases – follow the QR code below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/FullStackSpringBootReact4e](https://packt.link/FullStackSpringBootReact4e)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code10796108009382640.png)'
  prefs: []
  type: TYPE_IMG
