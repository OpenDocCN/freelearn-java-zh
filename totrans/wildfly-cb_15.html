<html><head></head><body><div class="chapter" title="Chapter&#xA0;15.&#xA0;Using WildFly with Docker"><div class="titlepage"><div><div><h1 class="title"><a id="ch15"/>Chapter 15. Using WildFly with Docker</h1></div></div></div><p>In this chapter, you will learn the following recipes:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Setting up the Docker environment</li><li class="listitem" style="list-style-type: disc">Running WildFly in Docker</li><li class="listitem" style="list-style-type: disc">Logging WildFly outside Docker</li><li class="listitem" style="list-style-type: disc">Running WildFly in domain mode in Docker using different Docker containers</li></ul></div><div class="section" title="Introduction"><div class="titlepage"><div><div><h1 class="title"><a id="ch15lvl1sec114"/>Introduction</h1></div></div></div><p>In this chapter, we will start learning the basics of Docker, and how you can take advantage of it by deploying your applications along with the environment.</p><p>Docker is an open source platform to develop, ship, and run applications. The basic idea of Docker is to get rid of the problems that occur when you promote your applications (actually the whole thing, such as the runtime environment) from environment to environment; that is, from development, to test, to pre-production, to quality, till production. There are so many variables involved that even if you do your best, something can go wrong in the traditional software life cycle.</p><p>With Docker, you can replicate your entire environment at every stage. The word "replicate" probably doesn't explain the concept well enough; "resubmit" would be better.</p><p>Docker is composed <a id="id1101" class="indexterm"/>of the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Images</strong></span>: A Docker <a id="id1102" class="indexterm"/>image is just like a template. Suppose you have an image with Fedora, Java 8, WildFly, and your installed application. Images can be downloaded or built with a descriptor file called <code class="literal">Dockerfile</code>. From images you can run your containers.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Registries</strong></span>: These <a id="id1103" class="indexterm"/>are the places where images are stored. There can be <a id="id1104" class="indexterm"/>private and public registries, such as Docker Hub (<a class="ulink" href="http://hub.docker.com">http://hub.docker.com</a>).</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Containers</strong></span>: They are, essentially, the running component of Docker. Basically, it's a running <a id="id1105" class="indexterm"/>instance of a Docker image. A container can be started, stopped, deleted, and so on. Each container is isolated from the host that is running it and from other containers as well.</li></ul></div><p>By the way, how can we achieve a no bad surprises result when promoting our application at various stages with Docker? Think of Docker as a tool for creating a stack of pluggable layers. The first layer is the OS layer, then comes your environment layer (it might be your specific Java runtime version), then your application layer—you can have as many layers as you want/need.</p><p>Once your stack is all filled in, what you get is your Docker image, which is ready to be committed into the registry. After that, you grab your image and install that exact image on the production hardware. You then get what you had before, when everything was working smoothly—hope you get the idea.</p><p>For a better understanding of what Docker is, I strongly suggest you read the default documentation and user <a id="id1106" class="indexterm"/>guide at the following URLs:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><a class="ulink" href="http://docs.docker.com/introduction/understanding-docker">http://docs.docker.com/introduction/understanding-docker</a></li><li class="listitem" style="list-style-type: disc"><a class="ulink" href="http://docs.docker.com/userguide">http://docs.docker.com/userguide</a></li></ul></div><p>Within this chapter, we will mainly use the Docker client, available for different operating systems, which is the tool that interfaces with the Docker daemon. There are so many settings and features to talk about that it would require another book. For this reason, I will focus on installing the client tool, and will explain the commands and parameters that we will use in our recipes, that is, in some basic WildFly scenarios.</p></div></div>
<div class="section" title="Setting up the Docker environment"><div class="titlepage"><div><div><h1 class="title"><a id="ch15lvl1sec115"/>Setting up the Docker environment</h1></div></div></div><p>In this recipe, you <a id="id1107" class="indexterm"/>will learn how to install Docker and get acquainted with the basic commands. You will see how to create and build an image based on Fedora, and how you can run it.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch15lvl2sec329"/>Getting ready</h2></div></div></div><p>We will need to have access to the Internet in order to download and install Docker and its dependencies.</p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch15lvl2sec330"/>How to do it…</h2></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">To install Docker on Fedora, issue the following commands:<div class="informalexample"><pre class="programlisting">$ sudo yum -y remove docker
$ sudo yum -y install docker-io</pre></div><p>The <a id="id1108" class="indexterm"/>installation should look like the following screenshot:</p><div class="mediaobject"><img src="graphics/3744_15_01.jpg" alt="How to do it…"/></div></li><li class="listitem">Okay, now that Docker is installed, let's run it:<div class="informalexample"><pre class="programlisting">$ sudo systemctl start docker</pre></div></li><li class="listitem">If you want to start Docker at boot time, use the following command:<div class="informalexample"><pre class="programlisting">$ sudo systemctl enable docker
Created symlink from /etc/systemd/system/multi-user.target.wants/docker.service to /usr/lib/systemd/system/docker.service.</pre></div></li><li class="listitem">Also, ensure that your user is in the <code class="literal">docker</code> group, by executing the following:<div class="informalexample"><pre class="programlisting">$ groups
luigi wheel docker</pre></div></li><li class="listitem">In case the <code class="literal">docker</code> group is not listed, add it with the following command:<div class="informalexample"><pre class="programlisting">$ sudo usermod -a -G docker luigi</pre></div><p>Obviously, replace the user <code class="literal">luigi</code> with yours.</p></li><li class="listitem">Check Docker's version by issuing the following command:<div class="informalexample"><pre class="programlisting">$ docker version
Client version: 1.6.0
Client API version: 1.18
Go version (client): go1.4.2
Git commit (client): 350a636/1.6.0
OS/Arch (client): linux/amd64
Server version: 1.6.0
Server API version: 1.18
Go version (server): go1.4.2
Git commit (server): 350a636/1.6.0</pre></div><p>Great, we are now ready to dockerize whatever we want!</p></li><li class="listitem">To do this, first <a id="id1109" class="indexterm"/>we need to check if there are any images available, as follows:<div class="informalexample"><pre class="programlisting">$ docker images
REPOSITORY          TAG                 IMAGE ID            CREATED             VIRTUAL SIZE</pre></div></li><li class="listitem">As there is no image available, we need to look for it by issuing the following command:<div class="informalexample"><pre class="programlisting">$ docker search fedora
NAME                         DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED
fedora                       Official Fedora 21 base image and semi-off...   128       [OK]       
fedora/apache                                                                28        [OK]
fedora/couchdb                                                               25        [OK]
fedora/mariadb                                                               22        [OK]
fedora/memcached                                                             19        [OK]
fedora/earthquake                                                            17        [OK]
fedora/ssh                                                                   16        [OK]
...</pre></div></li><li class="listitem">The Docker image we want is the official Fedora 21. We can download it as follows:<div class="informalexample"><pre class="programlisting">$ docker pull fedora:21
fedora:latest: The image you are pulling has been verified

511136ea3c5a: Pull complete
00a0c78eeb6d: Pull complete
834629358fe2: Downloading [&gt;                  ] 2.681 MB/250 MB 3m20s</pre></div></li><li class="listitem">When all the pulls <a id="id1110" class="indexterm"/>are complete, we get the following output:<div class="informalexample"><pre class="programlisting">$ docker pull fedora:21
fedora:latest: The image you are pulling has been verified

511136ea3c5a: Pull complete
00a0c78eeb6d: Pull complete
834629358fe2: Pull complete
Status: Downloaded newer image for fedora:latest</pre></div></li><li class="listitem">We can now use our first Fedora Docker image by executing the following command:<div class="informalexample"><pre class="programlisting">$ docker run -it --rm fedora /bin/bash
<span class="strong"><strong>bash-4.3# ls -la</strong></span>
total 60
drwxr-xr-x.  18 root root 4096 Jan 29 09:52 .
drwxr-xr-x.  18 root root 4096 Jan 29 09:52 ..
-rwxr-xr-x.   1 root root    0 Jan 29 09:52 .dockerenv
-rwxr-xr-x.   1 root root    0 Jan 29 09:52 .dockerinit
lrwxrwxrwx.   1 root root    7 Aug 16 09:24 bin -&gt; usr/bin
dr-xr-xr-x.   3 root root 4096 Dec  3 00:56 boot
drwxr-xr-x.   5 root root  380 Jan 29 09:52 dev
drwxr-xr-x.  47 root root 4096 Jan 29 09:52 etc
drwxr-xr-x.   2 root root 4096 Aug 16 09:24 home
lrwxrwxrwx.   1 root root    7 Aug 16 09:24 lib -&gt; usr/lib
lrwxrwxrwx.   1 root root    9 Aug 16 09:24 lib64 -&gt; usr/lib64
drwx------.   2 root root 4096 Dec  3 00:56 lost+found
drwxr-xr-x.   2 root root 4096 Aug 16 09:24 media
drwxr-xr-x.   2 root root 4096 Aug 16 09:24 mnt
drwxr-xr-x.   2 root root 4096 Aug 16 09:24 opt
dr-xr-xr-x. 233 root root    0 Jan 29 09:52 proc
dr-xr-x---.   2 root root 4096 Dec  3 00:58 root
drwxr-xr-x.   2 root root 4096 Dec  3 00:56 run
lrwxrwxrwx.   1 root root    8 Aug 16 09:24 sbin -&gt; usr/sbin
drwxr-xr-x.   2 root root 4096 Aug 16 09:24 srv
dr-xr-xr-x.  13 root root    0 Jan 19 06:57 sys
drwxrwxrwt.   7 root root 4096 Dec  3 00:58 tmp
drwxr-xr-x.  12 root root 4096 Dec  3 00:56 usr
drwxr-xr-x.  18 root root 4096 Dec  3 00:56 var
<span class="strong"><strong>bash-4.3# env</strong></span>
HOSTNAME=141b250d4361
TERM=xterm
PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
PWD=/
SHLVL=1
HOME=/root
_=/usr/bin/env
bash-4.3#</pre></div></li></ol></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch15lvl2sec331"/>How it works…</h2></div></div></div><p>How long did it take to <a id="id1111" class="indexterm"/>start the container with Fedora? Milliseconds? How long would it take to start a Fedora VM in a traditional virtualization environment? Tens of seconds? What about the overall installation? With Docker, everything gets extremely fast.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note41"/>Note</h3><p>We have finally installed the Docker tool and downloaded the latest Fedora image (which is version 21 while writing this book). We can use this as a base for our next recipe, <span class="emphasis"><em>Running WildFly into Docker</em></span>.</p></div></div><p>When you first install Docker, there are no images available, and you need to get them from the Docker registry. The default registry is the online Docker Hub, where you can also sign up for free and have your own space to share your Docker images.</p><p>Before you can pull (that is, download) a Docker image, you need to know at least its name. By issuing the command <code class="literal">docker search IMAGE_NAME</code>, you are essentially filtering all the images stored in the DockerHub that have the specified filter in the name or in the description.</p><p>Once you have pulled the <a id="id1112" class="indexterm"/>image of your choice, you can use it to run a container, as per the following command:</p><div class="informalexample"><pre class="programlisting">$ docker run -i -t fedora /bin/bash
bash-4.3#</pre></div><p>In the preceding command, we are using the Docker client tool to communicate with the Docker daemon, which is active and listening in our system.</p><p>Specifically, we instruct Docker to <code class="literal">run</code> a container based on the <code class="literal">fedora</code> image, and finally execute the <code class="literal">/bin/bash</code> command in it.</p><p>We also specified the following flags:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">-i</code>: Which enables the STDIN</li><li class="listitem" style="list-style-type: disc"><code class="literal">-t</code>: Which allocates a pseudo-tty, the terminal</li></ul></div></div></div>
<div class="section" title="Running WildFly in Docker"><div class="titlepage"><div><div><h1 class="title"><a id="ch15lvl1sec116"/>Running WildFly in Docker</h1></div></div></div><p>In this recipe, you <a id="id1113" class="indexterm"/>will learn how to run WildFly in a Docker container by <a id="id1114" class="indexterm"/>creating a <code class="literal">Dockerfile</code>, which describes how the image should be composed. To go through this recipe, you need to have a working Docker installation, along with a Fedora 21 image; if you don't have these installed, please follow the first recipe in this chapter.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch15lvl2sec332"/>Getting ready</h2></div></div></div><p>In this recipe, you will need an internet connection to download WildFly directly from the container. Also, we will need a Java web application to test our WildFly installation. If you want, you can use <a id="id1115" class="indexterm"/>one of my projects from my GitHub account, at <a class="ulink" href="https://github.com/foogaro/wildfly-cookbook.git">https://github.com/foogaro/wildfly-cookbook.git</a>.</p><p>You can <code class="literal">git-clone</code> the repository or just download it as a ZIP archive:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Place the source at <code class="literal">~/WFC/github</code>.</li><li class="listitem">There you will find a project called <code class="literal">docker-example</code>. To compile the project, run the following commands:<div class="informalexample"><pre class="programlisting">$ cd ~/WFC/github
$ cd wildfly-cookbook
$ cd docker-example
$ mvn clean package</pre></div><p>In the <code class="literal">target</code> folder generated by Maven, you should find the <code class="literal">docker-example.war</code> artifact, ready to be deployed.</p></li><li class="listitem">Next, create a <a id="id1116" class="indexterm"/>folder in which we will place all our Docker files that we will create along the way, as follows:<div class="informalexample"><pre class="programlisting">$ cd ~/WFC &amp;&amp; mkdir -p docker/wildfly</pre></div></li></ol></div><p>Let's Docker now!</p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch15lvl2sec333"/>How to do it…</h2></div></div></div><p>The first thing we <a id="id1117" class="indexterm"/>need to do is create the <code class="literal">Dockerfile</code> file in the <code class="literal">~/WFC/docker/wildfly</code> folder.</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Open a text editor and create a file named <code class="literal">Dockerfile</code>. Now copy and paste the following code:<div class="informalexample"><pre class="programlisting">FROM fedora:latest

MAINTAINER Luigi Fugaro l.fugaro@gmail.com

RUN yum -y install java-1.8.0-openjdk

RUN yum -y install tar net-tools

RUN cd /opt &amp;&amp; curl http://download.jboss.org/wildfly/9.0.0.Beta2/wildfly-9.0.0.Beta2.tar.gz | tar zx

RUN ln -s /opt/wildfly-9.0.0.Beta2 /opt/wildfly

RUN groupadd -r cookbook -g 12345 &amp;&amp; useradd -u 54321 -r -g cookbook -d /opt/wildfly -s /sbin/nologin -c "WildFly user" wildfly

RUN /opt/wildfly/bin/add-user.sh wildfly cookbook.2015 --silent

RUN chown -R wildfly:cookbook /opt/wildfly/*

EXPOSE 8080 9990

USER wildfly

CMD ["/opt/wildfly/bin/standalone.sh", "-b", "0.0.0.0", "-bmanagement", "0.0.0.0"]</pre></div><p>Save it in the previously mentioned folder.</p></li><li class="listitem">Now, with <code class="literal">Dockerfile</code>, we can build our image, specific for WildFly, and call it <code class="literal">foogaro/wildfly</code>, as follows:<div class="informalexample"><pre class="programlisting">$ cd ~/WFC/docker/wildfly
$ docker build -t foogaro/wildfly .
Sending build context to Docker daemon 5.12 kB
Sending build context to Docker daemon
Step 0 : FROM fedora:latest
 ---&gt; 834629358fe2
Step 1 : MAINTAINER Luigi Fugaro l.fugaro@gmail.com
 ---&gt; Running in 29c6d2ecbe12
 ---&gt; 54af5e1a15b6
Removing intermediate container 29c6d2ecbe12
Step 2 : RUN yum -y install java-1.8.0-openjdk
 ---&gt; Running in 7d73ef1137ea
Resolving Dependencies
--&gt; Running transaction check
---&gt; Package java-1.8.0-openjdk.x86_64 1:1.8.0.31-3.b13.fc21 will be installed
...
Complete!
Step 3 : RUN yum -y install tar net-tools
 ---&gt; Running in 6a147261f3a7
Resolving Dependencies
--&gt; Running transaction check
---&gt; Package net-tools.x86_64 0:2.0-0.31.20141124git.fc21 will be installed
---&gt; Package tar.x86_64 2:1.27.1-7.fc21 will be installed
...
Complete!
Step 4 : RUN cd /opt &amp;&amp; curl http://download.jboss.org/wildfly/9.0.0.Beta2/wildfly-9.0.0.Beta2.tar.gz | tar zx
 ---&gt; Running in 90738a7cb6c0
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
100  112M  100  112M    0     0   771k      0  0:02:29  0:02:29 --:--:--  778k
 ---&gt; 5e1138497058
Removing intermediate container 90738a7cb6c0
Step 5 : RUN ln -s /opt/wildfly-9.0.0.Beta2 /opt/wildfly
 ---&gt; Running in 34d760c4ba59
 ---&gt; 5c9b207bd2aa
Removing intermediate container 34d760c4ba59
Step 6 : RUN /opt/wildfly/bin/add-user.sh wildfly cookbook.2015 --silent
 ---&gt; Using cache
 ---&gt; 4cf96ff92355
Step 7 : EXPOSE 8080 9990
 ---&gt; Running in 51703bccf71e
 ---&gt; 7fbb535ab85a
Removing intermediate container 51703bccf71e
Step 8 : CMD /opt/wildfly/bin/standalone.sh -b 0.0.0.0 -bmanagement 0.0.0.0
 ---&gt; Running in e8537f97615a
 ---&gt; 56d5fea9c4ff
Removing intermediate container e8537f97615a
Successfully built 56d5fea9c4ff</pre></div></li><li class="listitem">Great! We have <a id="id1118" class="indexterm"/>successfully created our first Docker image <a id="id1119" class="indexterm"/>named <code class="literal">foogaro/wildfly</code>. Try issuing the following command now:<div class="informalexample"><pre class="programlisting">$ docker images
REPOSITORY      TAG     IMAGE ID        CREATED         VIRTUAL SIZE
foogaro/wildfly latest  56d5fea9c4ff    3 minutes ago   745.8 MB
fedora          latest  834629358fe2    4 weeks ago     250.2 MB</pre></div><p>As you can see, in addition to the other images, we have ours that has just been created.</p></li><li class="listitem">Now, let's run <a id="id1120" class="indexterm"/>WildFly as follows:<div class="informalexample"><pre class="programlisting">$ docker run -it -p 8080:8080 -p 9990:9990 --rm foogaro/wildfly</pre></div><p>You should get the following output:</p><div class="informalexample"><pre class="programlisting">==============================================================

  JBoss Bootstrap Environment

  JBOSS_HOME: /opt/wildfly

  JAVA: java

  JAVA_OPTS:  -server -Xms64m -Xmx512m -XX:MaxPermSize=256m -Djava.net.preferIPv4Stack=true -Djboss.modules.system.pkgs=org.jboss.byteman -Djava.awt.headless=true

==============================================================

OpenJDK 64-Bit Server VM warning: ignoring option MaxPermSize=256m; support was removed in 8.0
19:24:17,226 INFO  [org.jboss.modules] (main) JBoss Modules version 1.3.3.Final
19:24:17,448 INFO  [org.jboss.msc] (main) JBoss MSC version 1.2.2.Final
19:24:17,514 INFO  [org.jboss.as] (MSC service thread 1-5) JBAS015899: WildFly 8.2.0.Final "Tweek" starting
19:24:18,673 INFO  [org.jboss.as.server] (Controller Boot Thread) JBAS015888: Creating http management service using socket-binding (management-http)
19:24:18,694 INFO  [org.xnio] (MSC service thread 1-5) XNIO version 3.3.0.Final
19:24:18,726 INFO  [org.xnio.nio] (MSC service thread 1-5) XNIO NIO Implementation Version 3.3.0.Final
19:24:18,752 INFO  [org.jboss.as.clustering.infinispan] (ServerService Thread Pool -- 32) JBAS010280: Activating Infinispan subsystem.
19:24:18,768 INFO  [org.wildfly.extension.io] (ServerService Thread Pool -- 31) WFLYIO001: Worker 'default' has auto-configured to 8 core threads with 64 task threads based on your 4 available processors
19:24:18,788 INFO  [org.jboss.as.naming] (ServerService Thread Pool -- 40) JBAS011800: Activating Naming Subsystem
19:24:18,818 INFO  [org.jboss.as.connector.subsystems.datasources] (ServerService Thread Pool -- 27) JBAS010403: Deploying JDBC-compliant driver class org.h2.Driver (version 1.3)
19:24:18,840 INFO  [org.jboss.as.jsf] (ServerService Thread Pool -- 38) JBAS012615: Activated the following JSF Implementations: [main]
19:24:18,848 WARN  [org.jboss.as.txn] (ServerService Thread Pool -- 46) JBAS010153: Node identifier property is set to the default value. Please make sure it is unique.
19:24:18,865 INFO  [org.jboss.as.security] (ServerService Thread Pool -- 45) JBAS013171: Activating Security Subsystem
19:24:18,871 INFO  [org.jboss.as.connector.logging] (MSC service thread 1-8) JBAS010408: Starting JCA Subsystem (IronJacamar 1.1.9.Final)
19:24:18,914 INFO  [org.jboss.as.connector.deployers.jdbc] (MSC service thread 1-8) JBAS010417: Started Driver service with driver-name = h2
19:24:18,916 INFO  [org.jboss.as.security] (MSC service thread 1-3) JBAS013170: Current PicketBox version=4.0.21.Final
19:24:18,927 INFO  [org.jboss.as.webservices] (ServerService Thread Pool -- 48) JBAS015537: Activating WebServices Extension
19:24:19,017 INFO  [org.wildfly.extension.undertow] (MSC service thread 1-7) JBAS017502: Undertow 1.1.0.Final starting
19:24:19,023 INFO  [org.jboss.as.mail.extension] (MSC service thread 1-2) JBAS015400: Bound mail session [java:jboss/mail/Default]
19:24:19,027 INFO  [org.wildfly.extension.undertow] (ServerService Thread Pool -- 47) JBAS017502: Undertow 1.1.0.Final starting
19:24:19,034 INFO  [org.jboss.remoting] (MSC service thread 1-5) JBoss Remoting version 4.0.6.Final
19:24:19,050 INFO  [org.jboss.as.naming] (MSC service thread 1-4) JBAS011802: Starting Naming Service
19:24:19,155 INFO  [org.wildfly.extension.undertow] (ServerService Thread Pool -- 47) JBAS017527: Creating file handler for path /opt/wildfly/welcome-content
19:24:19,183 INFO  [org.wildfly.extension.undertow] (MSC service thread 1-7) JBAS017525: Started server default-server.
19:24:19,217 INFO  [org.wildfly.extension.undertow] (MSC service thread 1-1) JBAS017531: Host default-host starting
19:24:19,473 INFO  [org.wildfly.extension.undertow] (MSC service thread 1-3) JBAS017519: Undertow HTTP listener default listening on /0.0.0.0:8080
19:24:19,622 INFO  [org.jboss.as.server.deployment.scanner] (MSC service thread 1-3) JBAS015012: Started FileSystemDeploymentService for directory /opt/wildfly/standalone/deployments
19:24:19,730 INFO  [org.jboss.as.connector.subsystems.datasources] (MSC service thread 1-6) JBAS010400: Bound data source [java:jboss/datasources/ExampleDS]
19:24:19,887 INFO  [org.jboss.ws.common.management] (MSC service thread 1-1) JBWS022052: Starting JBoss Web Services - Stack CXF Server 4.3.2.Final
19:24:20,033 INFO  [org.jboss.as] (Controller Boot Thread) JBAS015961: Http management interface listening on http://0.0.0.0:9990/management
19:24:20,033 INFO  [org.jboss.as] (Controller Boot Thread) JBAS015951: Admin console listening on http://0.0.0.0:9990
19:24:20,034 INFO  [org.jboss.as] (Controller Boot Thread) JBAS015874: WildFly 8.2.0.Final "Tweek" started in 3113ms - Started 184 of 234 services (82 services are lazy, passive or on-demand)</pre></div></li><li class="listitem">Now try opening your browser, and point it to <code class="literal">http://127.0.0.1:9990/</code>.</li><li class="listitem">The browser <a id="id1121" class="indexterm"/>should prompt you for the username and <a id="id1122" class="indexterm"/>password for the WildFly <code class="literal">ManagementRealm</code>; just enter the following credentials:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Username</strong></span>: <code class="literal">wildfly</code></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Password</strong></span>: <code class="literal">cookbook.2015</code><p>The preceding credentials are those specified in the <code class="literal">Dockerfile</code> file used to build the image.</p></li></ul></div></li></ol></div><p>There you go; you are in your dockerized WildFly instance!</p><p>Now we have quite a few options to deploy our <code class="literal">docker-example</code> application. We can go to the <code class="literal">Deployments</code> page of the WildFly Admin Console, add our artifact, upload it, and enable it. Or we could ship our application along with Docker itself, which is much better, as you will soon find out:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">From the <span class="emphasis"><em>Getting ready</em></span> section, you should have my GitHub <code class="literal">wildfly-cookbook</code> repository installed in a path, which I named <code class="literal">CODE_PATH</code>. From there, you should create another <code class="literal">Dockerfile</code> in the <code class="literal">docker-example</code> folder. Fill in the <code class="literal">Dockerfile</code> with the following code:<div class="informalexample"><pre class="programlisting">FROM foogaro/wildfly:latest

MAINTAINER Luigi Fugaro l.fugaro@gmail.com

COPY target/docker-example.war /opt/wildfly/standalone/deployments/

EXPOSE 8080 9990

CMD ["/opt/wildfly/bin/standalone.sh", "-b", "0.0.0.0", "-bmanagement", "0.0.0.0"]</pre></div></li><li class="listitem">Once again, create <a id="id1123" class="indexterm"/>a Docker image from it by executing <a id="id1124" class="indexterm"/>the following command:<div class="informalexample"><pre class="programlisting">$ docker build -t foogaro/wildfly-docker-example .
Sending build context to Docker daemon 33.28 kB
Sending build context to Docker daemon
Step 0 : FROM foogaro/wildfly:latest
 ---&gt; 56d5fea9c4ff
Step 1 : MAINTAINER Luigi Fugaro l.fugaro@gmail.com
 ---&gt; Using cache
 ---&gt; ab0e63c8c1a9
Step 2 : COPY target/docker-example.war /opt/wildfly/standalone/deployments/
 ---&gt; 3b46d10fde74
Removing intermediate container 919ef5d6bc45
Step 3 : EXPOSE 8080 9990
 ---&gt; Running in 7a33da460750
 ---&gt; b741119c54bb
Removing intermediate container 7a33da460750
Step 4 : CMD /opt/wildfly/bin/standalone.sh -b 0.0.0.0 -bmanagement 0.0.0.0
 ---&gt; Running in 71e0fff696e4
 ---&gt; 0668770878ab
Removing intermediate container 71e0fff696e4
Successfully built 0668770878ab</pre></div></li><li class="listitem">Great! We have successfully created the preceding Docker image, which contains WildFly, along with our <code class="literal">docker-example</code> application. We can also see it listed as a Docker image, as follows:<div class="informalexample"><pre class="programlisting">$ docker images
REPOSITORY                     TAG     IMAGE ID      CREATED             VIRTUAL SIZE
foogaro/wildfly-docker-example latest  0668770878ab  7 seconds ago       745.8 MB
foogaro/wildfly                latest  56d5fea9c4ff  34 minutes ago      745.8 MB
fedora                         latest  834629358fe2  4 weeks ago         250.2 MB</pre></div></li><li class="listitem">Now we just need <a id="id1125" class="indexterm"/>to run this image in a container and <a id="id1126" class="indexterm"/>test our application, as follows:<div class="informalexample"><pre class="programlisting">$ docker run -i -t -p 8080:8080 -p 9990:9990 --rm foogaro/wildfly-docker-example</pre></div><p>You should get the following output:</p><div class="informalexample"><pre class="programlisting">==============================================================

  JBoss Bootstrap Environment

  JBOSS_HOME: /opt/wildfly

  JAVA: java

  JAVA_OPTS:  -server -Xms64m -Xmx512m -XX:MaxPermSize=256m -Djava.net.preferIPv4Stack=true -Djboss.modules.system.pkgs=org.jboss.byteman -Djava.awt.headless=true

==============================================================

OpenJDK 64-Bit Server VM warning: ignoring option MaxPermSize=256m; support was removed in 8.0
19:52:10,808 INFO  [org.jboss.modules] (main) JBoss Modules version 1.3.3.Final
19:52:11,037 INFO  [org.jboss.msc] (main) JBoss MSC version 1.2.2.Final
19:52:11,109 INFO  [org.jboss.as] (MSC service thread 1-6) JBAS015899: WildFly 8.2.0.Final "Tweek" starting
19:52:12,288 INFO  [org.jboss.as.server] (Controller Boot Thread) JBAS015888: Creating http management service using socket-binding (management-http)
19:52:12,308 INFO  [org.xnio] (MSC service thread 1-1) XNIO version 3.3.0.Final
19:52:12,320 INFO  [org.xnio.nio] (MSC service thread 1-1) XNIO NIO Implementation Version 3.3.0.Final
19:52:12,379 INFO  [org.jboss.remoting] (MSC service thread 1-1) JBoss Remoting version 4.0.6.Final
19:52:12,388 INFO  [org.wildfly.extension.io] (ServerService Thread Pool -- 31) WFLYIO001: Worker 'default' has auto-configured to 8 core threads with 64 task threads based on your 4 available processors
19:52:12,424 INFO  [org.jboss.as.clustering.infinispan] (ServerService Thread Pool -- 32) JBAS010280: Activating Infinispan subsystem.
19:52:12,453 INFO  [org.jboss.as.jsf] (ServerService Thread Pool -- 38) JBAS012615: Activated the following JSF Implementations: [main]
19:52:12,465 INFO  [org.jboss.as.naming] (ServerService Thread Pool -- 40) JBAS011800: Activating Naming Subsystem
19:52:12,467 INFO  [org.jboss.as.security] (ServerService Thread Pool -- 45) JBAS013171: Activating Security Subsystem
19:52:12,478 WARN  [org.jboss.as.txn] (ServerService Thread Pool -- 46) JBAS010153: Node identifier property is set to the default value. Please make sure it is unique.
19:52:12,494 INFO  [org.jboss.as.security] (MSC service thread 1-1) JBAS013170: Current PicketBox version=4.0.21.Final
19:52:12,518 INFO  [org.jboss.as.connector.logging] (MSC service thread 1-4) JBAS010408: Starting JCA Subsystem (IronJacamar 1.1.9.Final)
19:52:12,537 INFO  [org.jboss.as.webservices] (ServerService Thread Pool -- 48) JBAS015537: Activating WebServices Extension
19:52:12,552 INFO  [org.jboss.as.connector.subsystems.datasources] (ServerService Thread Pool -- 27) JBAS010403: Deploying JDBC-compliant driver class org.h2.Driver (version 1.3)
19:52:12,573 INFO  [org.jboss.as.connector.deployers.jdbc] (MSC service thread 1-4) JBAS010417: Started Driver service with driver-name = h2
19:52:12,617 INFO  [org.wildfly.extension.undertow] (MSC service thread 1-7) JBAS017502: Undertow 1.1.0.Final starting
19:52:12,618 INFO  [org.wildfly.extension.undertow] (ServerService Thread Pool -- 47) JBAS017502: Undertow 1.1.0.Final starting
19:52:12,687 INFO  [org.jboss.as.naming] (MSC service thread 1-1) JBAS011802: Starting Naming Service
19:52:12,689 INFO  [org.jboss.as.mail.extension] (MSC service thread 1-2) JBAS015400: Bound mail session [java:jboss/mail/Default]
19:52:12,814 INFO  [org.wildfly.extension.undertow] (ServerService Thread Pool -- 47) JBAS017527: Creating file handler for path /opt/wildfly/welcome-content
19:52:12,835 INFO  [org.wildfly.extension.undertow] (MSC service thread 1-5) JBAS017525: Started server default-server.
19:52:12,997 INFO  [org.wildfly.extension.undertow] (MSC service thread 1-4) JBAS017531: Host default-host starting
19:52:13,060 INFO  [org.wildfly.extension.undertow] (MSC service thread 1-5) JBAS017519: Undertow HTTP listener default listening on /0.0.0.0:8080
19:52:13,348 INFO  [org.jboss.as.server.deployment.scanner] (MSC service thread 1-8) JBAS015012: Started FileSystemDeploymentService for directory /opt/wildfly/standalone/deployments
19:52:13,356 INFO  [org.jboss.as.server.deployment] (MSC service thread 1-1) JBAS015876: Starting deployment of "docker-example.war" (runtime-name: "docker-example.war")
19:52:13,413 INFO  [org.jboss.as.connector.subsystems.datasources] (MSC service thread 1-8) JBAS010400: Bound data source [java:jboss/datasources/ExampleDS]
19:52:13,616 INFO  [org.jboss.ws.common.management] (MSC service thread 1-2) JBWS022052: Starting JBoss Web Services - Stack CXF Server 4.3.2.Final
<span class="strong"><strong>19:52:14,008 INFO  [org.wildfly.extension.undertow] (MSC service thread 1-4) JBAS017534: Registered web context: /docker-example</strong></span>
<span class="strong"><strong>19:52:14,082 INFO  [org.jboss.as.server] (ServerService Thread Pool -- 28) JBAS018559: Deployed "docker-example.war" (runtime-name : "docker-example.war")</strong></span>
19:52:14,157 INFO  [org.jboss.as] (Controller Boot Thread) JBAS015961: Http management interface listening on http://0.0.0.0:9990/management
19:52:14,157 INFO  [org.jboss.as] (Controller Boot Thread) JBAS015951: Admin console listening on http://0.0.0.0:9990
19:52:14,158 INFO  [org.jboss.as] (Controller Boot Thread) JBAS015874: WildFly 8.2.0.Final "Tweek" started in 3640ms - Started 249 of 304 services (92 services are lazy, passive or on-demand)</pre></div></li><li class="listitem">Reading the last <a id="id1127" class="indexterm"/>log entries, we can see that our <code class="literal">docker-example</code> application has been deployed. To see the application in <a id="id1128" class="indexterm"/>action, open the browser and point it to <code class="literal">http://127.0.0.1:8080/docker-example</code>.</li><li class="listitem">You should see the following page:<div class="mediaobject"><img src="graphics/3744_15_02.jpg" alt="How to do it…"/><div class="caption"><p>docker-example application running from a Docker container</p></div></div></li></ol></div><p>Excellent, we have just <a id="id1129" class="indexterm"/>deployed and run our first application in a Docker container running WildFly!</p></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch15lvl2sec334"/>How it works…</h2></div></div></div><p>Besides the Docker tool itself, and all that it comes with, there are some relevant things to talk about.</p><p>When running the WildFly container in the <code class="literal">docker run</code> command, we used a new flag <code class="literal">-p</code>, followed by some suspicious numbers. The flag <code class="literal">-p</code> is used to map the ports exposed by the container with the local ports; that is, the host's ports:</p><div class="informalexample"><pre class="programlisting">$ docker run -i -t -p 8080:8080 -p 9990:9990 --rm foogaro/wildfly</pre></div><p>In this case, we mapped the ports <code class="literal">8080</code> and <code class="literal">9990</code> with the same ones as in our host. That's why we could access the WildFly Admin Console with a local address. The same thing happened while accessing the <code class="literal">docker-example</code> application.</p><p>There is also another flag used in the preceding command: <code class="literal">--rm</code>.</p><p>The <code class="literal">--rm</code> flag instructs the Docker daemon to eliminate the container from the list of the container's history when the container gets stopped. To view all containers, even the non-running ones, you can give the following command:</p><div class="informalexample"><pre class="programlisting">$ docker ps -a
CONTAINER ID        IMAGE         COMMAND              CREATED       STATUS                    PORTS               NAMES
2f8fd2fbd0a0        ab0e63c8c1a9  "/bin/sh -c '#(nop)  38 hours ago                                                        hungry_brown         
794901deea3c        1816b615e0ce  "/bin/sh -c 'cd /opt 39 hours ago  Exited (2) 39 hours ago                         drunk_pike           
3fdc9d5c1680        1816b615e0ce  "/bin/sh -c 'cd /opt 39 hours ago  Exited (2) 39 hours ago                         adoring_mcclintock   
5035b7e0a76c        5200fb462c18  "/bin/sh -c 'cd /opt 39 hours ago  Exited (127) 39 hours ago                       prickly_hawking      
981dd5f92e24        5200fb462c18  "/bin/sh -c 'cd /opt 39 hours ago  Exited (127) 39 hours ago                       elegant_hawking      </pre></div><p>As you can see, after a while, the list can get very long. Eventually, you can manually remove old containers that you don't need anymore, by issuing the following command:</p><div class="informalexample"><pre class="programlisting">$ docker rm 981dd5f92e24
981dd5f92e24</pre></div><p>List all the containers <a id="id1130" class="indexterm"/>again, and the container with ID <code class="literal">981dd5f92e24</code> <a id="id1131" class="indexterm"/>should be gone, as follows:</p><div class="informalexample"><pre class="programlisting">$ docker ps -a
CONTAINER ID        IMAGE         COMMAND              CREATED       STATUS                    PORTS               NAMES
2f8fd2fbd0a0        ab0e63c8c1a9  "/bin/sh -c '#(nop)  38 hours ago                                                        hungry_brown         
794901deea3c        1816b615e0ce  "/bin/sh -c 'cd /opt 39 hours ago  Exited (2) 39 hours ago                         drunk_pike           
3fdc9d5c1680        1816b615e0ce  "/bin/sh -c 'cd /opt 39 hours ago  Exited (2) 39 hours ago                         adoring_mcclintock   
5035b7e0a76c        5200fb462c18  "/bin/sh -c 'cd /opt 39 hours ago  Exited (127) 39 hours ago                       prickly_hawking      </pre></div><p>So, if we try to run our <code class="literal">foogaro/wildfly</code> container without the <code class="literal">--rm</code> flag, when we stop the container it should appear in the container's history list.</p><p>There is still one more thing to talk about, and that's the second Dockerfile that we created, the one used to create the <code class="literal">foogaro/wildfly-docker-example</code> image.</p><p>The structure and the commands used in the file are pretty straightforward:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>FROM</strong></span>: It's used to declare the base or starting image.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>MAINTAINER</strong></span>: It's used to declare the owner of the Dockerfile; that is, the image.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>RUN</strong></span>: It's used to run commands in the container itself.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>EXPOSE</strong></span>: It's used to expose a set of ports from the container.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>CMD</strong></span>: It's typically used as the final instruction to run a service/command in the container when we start it. This instruction is basically an array of parameters, where even the command to execute is a parameter itself.</li></ul></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note42"/>Note</h3><p>There are many more instructions you can use, and they are all available and explained in detail <a id="id1132" class="indexterm"/>at the Docker site at <a class="ulink" href="https://docs.docker.com/reference/builder">https://docs.docker.com/reference/builder</a>.</p></div></div><p>Keep in mind that every <a id="id1133" class="indexterm"/>instruction in the Dockerfile is run <a id="id1134" class="indexterm"/>sequentially and is atomic. Each instruction starts its own temporary container, executes the task it has to do, when done it commits its work, and it destroys its temporary container. The next instruction will do the same, and so on.</p><p>This is a great feature because if something goes wrong while building an image, you don't need to restart once the bug has been fixed; the instructions previous to the error are cached, so you can quickly test and run your build again.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch15lvl2sec335"/>See also</h2></div></div></div><p>Keep in mind that, nowadays, there are plenty of official images in the DockerHub registries, such as the official WildFly docker image. To obtain and work on that image, you can simply search and pull it from the repository, as depicted in the following image:</p><div class="mediaobject"><img src="graphics/3744_15_03.jpg" alt="See also"/></div></div></div>
<div class="section" title="Logging WildFly outside Docker"><div class="titlepage"><div><div><h1 class="title"><a id="ch15lvl1sec117"/>Logging WildFly outside Docker</h1></div></div></div><p>When dealing <a id="id1135" class="indexterm"/>with an application server, and thus web applications, often we really need to look at the logs. As we have seen in the previous <a id="id1136" class="indexterm"/>recipe, we have run WildFly in a container and we have looked at the logs automatically because of the terminal flag being enabled (<code class="literal">-t</code> when executing the <code class="literal">docker run</code> command).</p><p>Without the terminal flag enabled, we would have needed to access the container (<code class="literal">docker attach</code> <code class="literal">CONTAINER_ID</code> or <code class="literal">docker logs CONTAINER_ID</code> command). That's not the most comfortable way to look at logs, and we would like to store our logs locally, on our host, and group them.</p><p>In this recipe, you will learn how to store your application logs outside the container, and store them on the host.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch15lvl2sec336"/>Getting ready</h2></div></div></div><p>To be able to follow this recipe, you need to have followed the previous one, which is about running WildFly in Docker.</p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch15lvl2sec337"/>How to do it…</h2></div></div></div><p>First of all, we need to create a directory on the host to store our logs, and enable the container-writable permissions to access the directory:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Open a terminal window and execute the following commands:<div class="informalexample"><pre class="programlisting">$ mkdir -p /opt/docker/wildfly/logs
$ groupadd -r cookbook -g 12345
$ useradd -u 54321 -r -g cookbook -s /sbin/nologin -c "WildFly user" wildfly
$ chcon -t svirt_sandbox_file_t /opt/docker/wildfly/logs</pre></div></li><li class="listitem">Now, in a <a id="id1137" class="indexterm"/>different terminal window, run <a id="id1138" class="indexterm"/>a container using our <code class="literal">foogaro/wildfly</code> Docker image, as follows:<div class="informalexample"><pre class="programlisting">$ docker run -d -v /opt/docker/wildfly/logs:/opt/wildfly/standalone/log -p 8080:8080 -p 9990:9990 --rm foogaro/wildfly</pre></div></li><li class="listitem">In the terminal where we created the <code class="literal">/opt/docker/wildfly/logs</code> folder, list the contents of the folder as follows:<div class="informalexample"><pre class="programlisting">$ cd /opt/docker/wildfly/logs
$ ls -la
total 32
drwxr-xr-x. 2 wildfly cookbook  4096 Feb  5 17:32 .
drwxr-xr-x. 4 wildfly cookbook  4096 Feb  5 12:43 ..
-rw-r--r--. 1 wildfly cookbook 10261 Feb  5 17:36 server.log</pre></div></li></ol></div><p>Great, our <code class="literal">server.log</code> file is there!!!</p><p>Obviously, this is not the best way to handle logs in general; you should look at integrating with <code class="literal">syslog</code>, <code class="literal">rsyslog</code>, <code class="literal">logstash</code>, and other tools with more powerful and higher performance features.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note43"/>Note</h3><p>Take this recipe as an example to deal with folders that are outside the container. Nonetheless, in a development environment, people might want to have the logs stored on their PCs.</p></div></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch15lvl2sec338"/>How it works…</h2></div></div></div><p>First of all, we needed to create a directory to store the WildFly logs, and then add the same user and group that we used in the <code class="literal">Dockerfile</code> to build the <code class="literal">foogaro/wildfly</code> Docker image. As a matter of fact, in the <code class="literal">Dockerfile</code> there was the following instruction:</p><div class="informalexample"><pre class="programlisting">RUN groupadd -r cookbook -g 12345 &amp;&amp; useradd -u 54321 -r -g cookbook -d /opt/wildfly -s /sbin/nologin -c "WildFly user" wildfly</pre></div><p>The preceding code adds a group and a user in the container environment, and it creates them using a fixed group ID and user ID. Thus, to allow the container to have read-write permissions on the host, we need to use the same user and group for the directory.</p><p>Once everything was configured, we launched the <code class="literal">docker run</code> command using the <code class="literal">-v</code> flag, which is about <a id="id1139" class="indexterm"/>mounting volumes with the <code class="literal">from:to</code> pattern. That <a id="id1140" class="indexterm"/>is, everything from the host <code class="literal">from</code> (at the specified path) will be present in the container environment in the specified path, <code class="literal">:to</code>. Furthermore, every update made in the specified folder would have persisted in the host folder.</p></div></div>
<div class="section" title="Running WildFly in domain mode in Docker using different Docker containers"><div class="titlepage"><div><div><h1 class="title"><a id="ch15lvl1sec118"/>Running WildFly in domain mode in Docker using different Docker containers</h1></div></div></div><p>In this <a id="id1141" class="indexterm"/>recipe, you will learn <a id="id1142" class="indexterm"/>how to run WildFly in the domain mode using containers. We will use one container to act as the domain-controller and two other containers, each to act as the servers of a server-group.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch15lvl2sec339"/>Getting ready</h2></div></div></div><p>To properly follow and understand the topics treated in this recipe, we need to know what the WildFly domain mode is, along with its principles. You can also refer to <a class="link" href="ch03.html" title="Chapter 3. Running WildFly in Domain Mode">Chapter 3</a>, <span class="emphasis"><em>Working with XAML</em></span>, which is about running WildFly in the domain mode.</p><p>Furthermore, you need to have followed the first two recipes of this chapter, of having a working Docker installation and a WildFly image available for use.</p><p>Nevertheless, to simplify our recipe, we will rely on the WildFly default configuration files: <code class="literal">domain.xml</code>, <code class="literal">host-master.xml</code> and <code class="literal">host-slave.xml</code>.</p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch15lvl2sec340"/>How to do it…</h2></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">First of all, we need to create a new <code class="literal">Dockerfile</code> based on the <code class="literal">foogaro/wildfly</code> image, which will contain the entire configuration needed to run WildFly in the domain mode. Following is the whole file:<div class="informalexample"><pre class="programlisting">FROM foogaro/wildfly

MAINTAINER Luigi Fugaro l.fugaro@gmail.com

RUN sed -i '/secret value/d' /opt/wildfly/domain/configuration/host-slave.xml
RUN sed -i '/&lt;server-identities&gt;/a &lt;secret value="Y29va2Jvb2suMjAxNQ==" \/&gt;' /opt/wildfly/domain/configuration/host-slave.xml
RUN sed -i 's/remote host/remote username="wildfly" host/' /opt/wildfly/domain/configuration/host-slave.xml
RUN sed -i 's/jboss.domain.master.address/env.DOMAIN_CONTROLLER_PORT_9999_TCP_ADDR/' /opt/wildfly/domain/configuration/host-slave.xml
RUN sed -i 's/jboss.domain.master.port/env.DOMAIN_CONTROLLER_PORT_9999_TCP_PORT/' /opt/wildfly/domain/configuration/host-slave.xml

EXPOSE 8080 9990 9999

USER wildfly

ENTRYPOINT ["/opt/wildfly/bin/domain.sh"]

CMD ["--host-config", "host-master.xml", "-b", "0.0.0.0", "-bmanagement", "0.0.0.0"]</pre></div></li><li class="listitem">To <a id="id1143" class="indexterm"/>build the <a id="id1144" class="indexterm"/>image, use the following command:<div class="informalexample"><pre class="programlisting">$ docker build -t foogaro/wildfly-domain .</pre></div></li><li class="listitem">Once the build process is done, we can run the <code class="literal">foogaro/wildfly-domain</code> image in a container. The first thing we are going to run is the domain controller without any operative servers, as follows:<div class="informalexample"><pre class="programlisting">$ docker run -i -t -p 9990:9990 -p 9999:9999 --name=DC --rm foogaro/wildfly-domain
...
[Host Controller] 10:05:17,590 INFO  [org.jboss.as] (Controller Boot Thread) WFLYSRV0025: WildFly Full 9.0.0.Beta2 (WildFly Core 1.0.0.Beta2) (Host Controller) started in 2830ms - Started 50 of 50 services (13 services are lazy, passive or on-demand)</pre></div></li><li class="listitem">Now you can access the Admin Console from the host at <code class="literal">http://localhost:9990/</code>.</li><li class="listitem">As we can see from the following image, in the <span class="strong"><strong>Domain</strong></span> | <span class="strong"><strong>Topology</strong></span> section, there is no running server:<div class="mediaobject"><img src="graphics/3744_15_04.jpg" alt="How to do it…"/><div class="caption"><p>WildFly in domain mode running into a Docker container</p></div></div><p>Let's run another container with the WildFly default configuration provided by the <code class="literal">host-slave.xml</code> file.</p></li><li class="listitem">Open a <a id="id1145" class="indexterm"/>new <a id="id1146" class="indexterm"/>terminal window and execute the following:<div class="informalexample"><pre class="programlisting">$ docker run -i -t -p 8080:8080 --link=DC:DOMAIN_CONTROLLER --name=HC-1 --rm foogaro/wildfly-domain --host-config host-slave.xml -b 0.0.0.0 -bmanagement 0.0.0.0</pre></div></li><li class="listitem">Once the container has successfully launched WildFly, refresh the topology overview section of the Admin Console that we loaded earlier, and you should now see two running servers, as depicted in the following image:<div class="mediaobject"><img src="graphics/3744_15_05.jpg" alt="How to do it…"/><div class="caption"><p>WildFly's domain mode topology showing two servers running on a different Docker container</p></div></div></li></ol></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch15lvl2sec341"/>How it works…</h2></div></div></div><p>In this recipe, we <a id="id1147" class="indexterm"/>saw some new <code class="literal">Dockerfile</code> instructions, such as <code class="literal">ENTRYPOINT</code>. This instruction is almost like the <code class="literal">CMD</code> one; it is used to run a service. The <code class="literal">ENTRYPOINT</code> instruction uses the <code class="literal">CMD</code> instruction to hold the command parameters. As a matter of fact, you can specify both the instructions with the option to override the <code class="literal">CMD</code> instruction from the command line, which is exactly what we have done when running the host-controller.</p><p>We used the <code class="literal">sed</code> command to modify the <code class="literal">host-slave.xml</code> file; further information on this command <a id="id1148" class="indexterm"/>is out of the scope of this book.</p><p>As you should already know, communication between the domain controller and the host controller needs to be verified. Thus, I inserted the hashed password of the <code class="literal">wildfly</code> user of <code class="literal">ManagementRealm</code>—the first and second <code class="literal">sed</code>. The third <code class="literal">sed</code> basically instructs the host controller to authenticate the domain controller with the <code class="literal">wildfly</code> user.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip19"/>Tip</h3><p>Remember that if you do not specify the <code class="literal">username</code> attribute in the <code class="literal">remote</code> XML element, the name of the host, <code class="literal">&lt;host name="slave"&gt;</code>, will be used instead.</p></div></div><p>The last two <a id="id1149" class="indexterm"/><code class="literal">sed</code> commands instruct which address and port to use to connect to the domain controller. As we don't know which IP the container would have, we can rely on Docker's environment variables, which it automatically sets when it starts. This particular mapping is due to the <code class="literal">--link</code> flag used when launching the second container.</p><div class="informalexample"><pre class="programlisting">$ docker run -i -t -p 8080:8080 --link=DC:DOMAIN_CONTROLLER --name=HC-1 --rm foogaro/wildfly-domain --host-config host-slave.xml -b 0.0.0.0 -bmanagement 0.0.0.0</pre></div><p>In the first <a id="id1150" class="indexterm"/>container, we used the <code class="literal">--name</code> flag to give it a significant name, like <code class="literal">DC</code>. Then we used that same name with the <code class="literal">--link</code> flag to bind that container with the second one and map it to the <code class="literal">DOMAIN_CONTROLLER</code> alias.</p></div><div class="section" title="There is more…"><div class="titlepage"><div><div><h2 class="title"><a id="ch15lvl2sec342"/>There is more…</h2></div></div></div><p>When running a container, you can specify the hostname that it will have. In our example, we could have run the slaves, as follows:</p><div class="informalexample"><pre class="programlisting">$ docker run -i -t -p 8080:8080 -h host-1 --link=DC:DOMAIN_CONTROLLER --name=HC-1 --rm foogaro/wildfly-domain --host-config host-slave.xml -b 0.0.0.0 -bmanagement 0.0.0.0</pre></div><p>And in the topology overview, we would have seen the following page:</p><div class="mediaobject"><img src="graphics/3744_15_06.jpg" alt="There is more…"/><div class="caption"><p>The slave running in a Docker container with a significant name host-1</p></div></div><p>This is a nice <a id="id1151" class="indexterm"/>feature that can be handy, instead of trying to remember which hash a host belongs to.</p><p>In conclusion, the <a id="id1152" class="indexterm"/>same kind of mechanism used in this recipe to configure and run the domain mode could be used to run a WildFly cluster.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch15lvl2sec343"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">More <a id="id1153" class="indexterm"/>information about linking Docker containers can be found at <a class="ulink" href="https://docs.docker.com/userguide/dockerlinks/">https://docs.docker.com/userguide/dockerlinks/</a></li></ul></div></div></div></body></html>