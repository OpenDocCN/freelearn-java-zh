<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:pls="http://www.w3.org/2005/01/pronunciation-lexicon" xmlns:ssml="http://www.w3.org/2001/10/synthesis">
<head>
  <meta charset="UTF-8"/>
  <title>Deployment and CI/CD Patterns</title>
  <link type="text/css" rel="stylesheet" media="all" href="style.css"/>
  <link type="text/css" rel="stylesheet" media="all" href="core.css"/>
</head>
<body>
  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Deployment and CI/CD Patterns</h1>
                </header>
            
            <article>
                
<p><span>One of the big advantages of serverless architectures is the ease, speed, and agility with which you can develop and deploy your application. While the various serverless frameworks out there give you tools to manage your application's lifecycle, there are still many questions to answer when it comes to managing deployments and environments. Additionally, the question of unit tests is sometimes more difficult to answer since serverless architectures often use managed services&#160;such as databases, queues, and the like.</span></p>
<p><span>In this chapter, you will learn deployment tooling, techniques, and considerations. We will also discuss <strong>continuous integration</strong>&#160;(<strong>CI</strong>) and <strong>continuous delivery</strong> (<strong>CD</strong>) systems and how they hook into unit testing and automated deployments.&#160;</span></p>
<p>By the end of this chapter, you will have learned the following:</p>
<ul>
<li><span>Deployment options and techniques for serverless applications</span></li>
<li><span>The landscape of CI/CD systems and how they work with serverless applications</span></li>
<li>General best practices in setting up serverless application code for unit testing</li>
<li><span>How to set up unit tests for a serverless Python REST application using Docker</span></li>
<li><span>How to set up CI with CircleCI to run unit tests and report test coverage on each commit</span></li>
<li><span>How to set up CI with</span>&#160;CircleCI to deploy our production application for every commit to the&#160;<kbd>production</kbd> branch when tests pass</li>
</ul>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Introduction to CI/CD</h1>
                </header>
            
            <article>
                
<p>CI and CD are often grouped in discussions around software development life cycles or software engineering best practices. However, CI and CD are distinct concepts with their own sets of best practices, challenges, and goals. This section will not attempt to cover the broad subject of CI and CD, but it is essential to talk about a few concepts and ideas to have a discussion that applies to serverless architectures and systems.</p>
<p>Most of these ideas were born out of the Agile and <strong>Extreme Programming</strong> (<strong>XP</strong>) communities. While these are not hard rules that every team needs to follow, they do come from groups of people who were looking to solve real-world problems. Adopting these practices can help any team and any project, whether the project is serverless or not.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">CI</h1>
                </header>
            
            <article>
                
<p>CI is the process of merging code changes into a mainline branch (for example, often a <kbd>master</kbd> branch if using Git) early and often. Before a merge from a development branch to a master branch, some preconditions should be met:</p>
<ol>
<li>Unit tests must be run and pass</li>
<li>New tests must cover the newly added code</li>
<li>Another team member must do a code review or be the result of a pair programming session</li>
</ol>
<p>In a serverless system, there aren't many special considerations when talking about CI. Pair programming, unit testing, and test coverage are ideas that are not unique to any particular architecture. However, there are a few tricks to setting up serverless application code that make testing easier and even fun. I'll discuss some specific scenarios and tips in the <em>Setting up unit tests</em> section.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">CD</h1>
                </header>
            
            <article>
                
<p>While CI is usually easily understood, I feel that CD&#160;is often conflated with continuous deployment. Traditional CD is the process of building, testing and releasing software rapidly. Since <em>testing</em>&#160;is wrapped up in this definition, there is, of course, a natural relationship with CI. I view CD more on the spectrum of setting up automated systems so that the process of fixing a bug and deploying that fix safely and reliably to production is as fast and easy to hand off as possible.</p>
<p>Continuous deployment is a particular feature wrapped up within CD, that is, every merge to the production branch results in a deployment to the production system. A good CD pipeline enables continuous deployments, but it's up to the team behind the software whether or not to enable or use continuous deployment. More specifically, continuous deployment requires CD, but just because a good CD system is in place does not mean that the team is utilizing continuous deployment.</p>
<p>A good CD system may look like the following:</p>
<ol>
<li>Teammates pair program to implement a feature on a branch named&#160;<kbd>feature/xyx</kbd></li>
<li>The code is checked in, and CI system runs unit tests and code coverage</li>
<li>The team is notified of test results and given code coverage results</li>
<li>Team merges <kbd>feature/xyz</kbd> branch to <kbd>master</kbd> branch</li>
<li>Tests are rerun on the&#160;<kbd>master</kbd> branch</li>
<li>The team is informed of test results on the&#160;<kbd>master</kbd> branch</li>
<li><kbd>master</kbd> branch code is automatically deployed to production</li>
</ol>
<p>Again, it's up to the team whether the final step of automatic deployment occurs or not. However, the entire CD pipeline should be set up so that it's <em>possible</em>. When you set up a CD pipeline to <em>enable</em>&#160;continuous deployments, you'll have solved most of the hard problems, which makes your software development life cycle that much faster and more efficient.</p>
<p>Like CI, serverless systems look mostly the same as traditional software systems when it comes to CD. One nice thing here is that the serverless frameworks give us tooling to perform deployments. In non-serverless systems, deployment scripts are often left as exercises for teams to undertake using a myriad of tooling, the choices of which are vast and not always obvious. In the serverless landscape, deployment options are usually limited by your framework of choice.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Setting up unit tests</h1>
                </header>
            
            <article>
                
<p>As I mentioned in the prior section, there are a few tricks and tips in setting up unit tests with a serverless system. The most important thing you can do is completely isolate your application code from the fact that it is running in a serverless context or within a given cloud provider. This&#160;strategy will lend other significant benefits other than making our tests easier to run, and I'll discuss those advantages in the course of this discussion on testing.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Code organization</h1>
                </header>
            
            <article>
                
<p>What does our code layout look like when we attempt to isolate application code from cloud provider-specific code? Let's take a look at the following diagram that shows the high-level structure of our REST or GraphQL API from <a href="svrls-dsnptn-bstprac_ch02.html">Chapter 2</a>, <em>A</em>&#160;<em>Three-Tier Web Application Using REST</em>, and <a href="svrls-dsnptn-bstprac_ch03.html">Chapter 3</a>, <em>A&#160;Three-Tier Web Application Pattern with GraphQL</em>, respectively:</p>
<div class="CDPAlignCenter CDPAlign"><img src="images/75276d11-2217-4e86-9dcc-9b148456d914.jpg" style="width:28.00em;height:24.33em;"/></div>
<p>Our example application was authored in Python, but this diagram shows how this general code organization can work for Node, Python, or any other language. In addition to being language-agnostic, this should be both framework- and cloud provider-agnostic. The primary goal of this layout is to isolate your application code from any vendor, framework, or other third-party systems.</p>
<p>The main ideas behind this code organization are the following:</p>
<ul>
<li>The primary handler or entry point that is invoked by the cloud provider contains any cloud-specific code and bootstraps the rest of the code (for instance, managing paths if necessary).</li>
<li>Any additional libraries are wrapped up alongside the handler file.</li>
<li>Tests are isolated in a <kbd>tests</kbd> directory. Only testing-related code goes in here, including mocks or factories.</li>
<li>All application logic is namespaced within a separate directory (<kbd>cupping</kbd>, in this example).</li>
</ul>
<p>With this setup, there are several advantages and no obvious disadvantages:</p>
<ul>
<li>If you ever decide to change cloud providers, no application code changes are necessary. The only changes needed would be in the <kbd>handler</kbd> file.</li>
<li>Tests are wholly isolated from application code and are not deployed with application code.</li>
<li>The structure is very trim and easy to navigate and understand for other developers.</li>
<li>If any path manipulation is needed to find packages (as is the case with Python) you only need to add a single directory to the runtime path.</li>
<li>It is trivial to point any test runner at the single <kbd>tests</kbd> directory to run unit tests.</li>
</ul>
<div class="packt_infobox">Anyone writing serverless functions with Node shouldn't need to deal with system paths explicitly, as is necessary for Python. Node.js will automatically resolve <kbd>node_modules</kbd> as you'd expect. Some of these tips are therefore applicable only to Python developers or those using other supported languages that don't resolve libraries via convention.</div>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Setting up unit tests</h1>
                </header>
            
            <article>
                
<p>With <kbd>py.test</kbd>, a single file named <kbd>conftest.py</kbd>&#160;controls testing setup and configuration. If you can remember back to our discussion on setting up the runtime in <kbd>handler.py</kbd>, we had a few lines of code that added <kbd>lib</kbd> to our system path, which is shown in the following code. The next code block is taken directly from our <kbd>handler.py</kbd> function:</p>
<pre style="padding-left: 30px">from pathlib import Path<br/><br/># Munge our sys path so libs can be found<br/>CWD = Path(__file__).resolve().cwd() / 'lib'<br/>sys.path.insert(0, str(CWD))</pre>
<p>When we run our tests using <kbd>py.test</kbd>, the main entry point will be our test code rather than <kbd>handler.py</kbd>. As such, any bootstrapping of our code needs to take place in a different location since <kbd>handler.py</kbd> will not always be imported before every test. In a testing context, <kbd>conftest.py</kbd>&#160;is the new entry point where any system bootstrapping and configuration&#160;will occur. In addition to managing our system path, which will now be relative to the <kbd>tests/</kbd> directory, our <kbd>conftest.py</kbd> file will also be responsible for setting up environment variables that were previously managed by our serverless framework stack. The following code from <kbd>conftest.py</kbd>&#160;shows the path manipulation and environment variable setup so that our tests can import application code and execute successfully during a test run:</p>
<pre style="padding-left: 30px">from pathlib import Path<br/><br/>CWD = Path(__file__).resolve().parent<br/>code_dir = CWD / '../serverless'<br/>lib_dir = CWD / '../serverless/lib'<br/><br/>sys.path.append(str(code_dir))<br/>sys.path.append(str(lib_dir))<br/><br/>ENV = os.environ['ENV']<br/>os.environ.update({<br/>    'CUPPING_DB_PASSWORD': '',<br/>    'CUPPING_DB_USERNAME': 'postgres',<br/>    'CUPPING_DB_HOST': 'cupping-%s-postgres' % ENV,<br/>})<br/><br/>if os.environ.get('CIRCLECI'):<br/>    os.environ['CUPPING_DB_HOST'] = 'localhost'</pre>
<p>Our test code will need to import two different types of code:</p>
<ul>
<li>Our application code</li>
<li>Third-party packages</li>
</ul>
<p>With this being the case, we need to add two directories to our system path. The first path we add to the system path (<kbd>code_dir</kbd>) corresponds to the location of our application code. The second path we add to the system path (<kbd>lib_dir</kbd>) corresponds to the directory for third-party libraries. In the previous code block, you can view how that path manipulation is being handled manually.</p>
<p>Next, we'll need to manage environment variables. In this project, there aren't many to contend with. All of the above environment variables deal with our PostgreSQL database, which happens to be running as a linked Docker container. You'll notice in the final <kbd>if</kbd> statement there is a check for an environment variable named <kbd>CIRCLECI</kbd>. If that is present, this setup code will change the host variable for our PostgreSQL database. I'll review this in more detail in the following section.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Setting up CI with CircleCI</h1>
                </header>
            
            <article>
                
<p>There is a reasonably extensive landscape when it comes to hosted CI systems. If you add in self-hosted systems, the list grows even longer. Tools such as Jenkins have been around for many years, initially as self-hosted systems. Inevitably, hosted versions of tools such as Jenkins have emerged from various companies. In this section, we'll walk through the steps of setting up CircleCI (<a href="https://circleci.com">https://circleci.com</a>) to run our unit tests and produce a code coverage report on every code commit.</p>
<div class="packt_tip">Since this is a book about serverless patterns, I'll encourage you to pick whatever tool works for your purposes with a very strong lean towards hosted CI/CD system. Using a hosted CI/CD systems means that you can focus more on your application code rather than the CI/CD system, which is just a tool we need to get our jobs done.</div>
<p>Setting up a brand new project with CircleCI is quite simple, and it has easy integration with both GitHub and Bitbucket. The first thing you'll need to do to set up a new project is log in with one of those two services. From there, you can go to the <span class="packt_screen">Projects</span> item in the left-hand-side navigation menu and click on the <span class="packt_screen">Add Project</span> button in the upper-right of the screen.</p>
<p>The following screenshot shows this navigation; however, I've already set up this example project, which is the reason it shows up in the list:</p>
<div class="CDPAlignCenter CDPAlign"><img src="images/0057c99a-d861-4a6e-9bf9-3bc67bb4e37d.png" style="width:48.00em;height:16.00em;"/></div>
<div class="packt_infobox">You can see that I also have my blog set up in CircleCI. CI can be used for any repository where you'd like to perform some automated set of steps when code is committed, or branches are merged. In the case of my blog, a script will deploy any new posts or changes out once they are checked in.</div>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Configuring CircleCI builds</h1>
                </header>
            
            <article>
                
<p>There is a plethora of options and controls that you can configure within CircleCI. There are only a few settings we'll need to control from within the CircleCI web interface. Everything else will be controlled via a <kbd>config.yml</kbd> configuration file, which we will add to the repository.</p>
<p>Our first step is putting together a <kbd>.circleci/config.yml</kbd> file. The <kbd>.circleci/</kbd> directory lives in the root of our repository. The following code block shows the configuration to run unit tests in for our REST API, which is located in the <kbd>ch2/</kbd> directory of the repository:</p>
<pre style="padding-left: 30px">version: 2 <br/>jobs:<br/><br/>  build:<br/>    docker:<br/>      - image: verypossible/serverless:1.25.0-python3<br/>      - image: postgres<br/>    environment:<br/>      - ENV: circleci<br/>    steps:<br/>      - checkout<br/>      - restore_cache:<br/>          key: dependency-cache-{{ checksum "ch2/requirements.txt" }}<br/>      - run:<br/>          name: Install python requirements<br/>          working_directory: ch2 <br/>          command: make libs<br/>      - save_cache:<br/>          key: dependency-cache-{{ checksum "ch2/requirements.txt" }}<br/>          paths:<br/>            - ch2/lib<br/>      - run:<br/>          name: py.test<br/>          working_directory: ch2 <br/>          command: make tests<br/>      - store_artifacts:<br/>          path: ch2/htmlcov/<br/>          destination: coverage</pre>
<div class="packt_infobox">There <span>is some extra work involved in this setup since our application code lives in the</span> <kbd>ch2/</kbd> <span>directory but commands always start from the root directory. In a regular repository where the code isn't contained in a subdirectory, dealing with the</span> <kbd>working_directory</kbd> <span>would be unnecessary.</span></div>
<p>CircleCI 2.0 uses Docker containers for their builds. What this means for us is that it's quite easy to pull in any additional resources our application code may need to run tests. In this case, we'll pull in the official <kbd>postgres</kbd>&#160;Docker image. Another benefit of this is that I use a Docker container for building libraries, running tests, and doing deployments. Since all of this functionality is possible using the <kbd>verypossible/serverless</kbd> images, which I built, we can just use the same image to run these tests and do deployments as we did during development. The first&#160;image listed under the <kbd>docker</kbd> key previously will be the primary container where the code will be checked out, and any commands will run.</p>
<p class="mce-root">The Docker image and Makefile that I'm using here are set up to use a variable named <kbd>ENV</kbd>. I'll set the <kbd>ENV</kbd> variable in this configuration file. After the environment section begins, a list of steps that run in sequence and make up the actual test run. The steps to set up and run the tests consist of:</p>
<ol>
<li>Check out code</li>
<li>Restore cache, so that the supporting packages are only downloaded when there is a change</li>
<li>Install supporting packages, in case they are not cached</li>
</ol>
<ol start="4">
<li>Save cache</li>
<li>Run unit tests with the <kbd>make tests</kbd>&#160;command</li>
<li>Store test coverage results, so they are viewable on CircleCI</li>
</ol>
<div class="packt_tip">A few different commands deal with saving and restoring the cache. These cache controls are specific to CircleCI, and I encourage you to read about it in detail in the CircleCI docs. At a high level, these steps are saving some CPU cycles by <span>caching</span> any installed libraries from previous runs rather than doing package downloads and installs for every test run.</div>
<p>There are two <kbd>run</kbd> directives, which perform the bulk of the work. Both <kbd>Install Python requirements</kbd> and <kbd>py.test</kbd>&#160;steps use <kbd>make</kbd> targets to do their work. We've already set up the actual logic of what those commands do, which you can review by inspecting the Makefile. Neither of these commands is incredibly complex (installing packages and running test). Since we've already done this work of wrapping up the details in the Makefile, we can take advantage of these and other&#160;make shortcuts.</p>
<p>Finally, after tests are run, I'll set up CircleCI to upload the test coverage output files to the build's artifacts. Build artifacts are another CircleCI-specific task, although I know other CI systems have something similar. After the HTML coverage output is uploaded as a CircleCI artifact, we'll be able to view the results via the CircleCI website.</p>
<p>The following screenshot shows all of the <kbd>coverage</kbd> output files listed in the <span class="packt_screen">Artifacts</span> tab for each build:</p>
<div class="CDPAlignCenter CDPAlign"><img src="images/eab05a9e-798f-4192-8f0b-017118c53857.png"/></div>
<p>Since the coverage report is created in HTML format, I can click on the <kbd>index.html</kbd> file to see the complete test results. The following screenshot shows the test coverage report after I clicked on <kbd>index.html</kbd>:</p>
<div class="CDPAlignCenter CDPAlign"><img src="images/8154614d-fd83-4ea8-8bab-725da7dd3c71.png" style="width:42.92em;height:32.75em;"/></div>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Setting up environment variables</h1>
                </header>
            
            <article>
                
<p>Earlier in this chapter, you'll remember that there were some environment variables that we needed to take care of in our tests. Additionally, there was a small switch in our <kbd>conftest.py</kbd> file that set the PostgreSQL host based on the presence of a particular environment variable. CircleCI is kind enough to inject a couple of environment variables during a build, one of which is named <kbd>CIRCLECI</kbd>. Using this variable, we'll update the database host during test runs, which happens to be <kbd>localhost</kbd>. When we're testing our code locally with Docker containers that we manage, the hostname will be that of our linked PostgreSQL container.</p>
<p>In addition to handling specific environment variables differently when running within a CircleCI build, we'll also need to manage any sensitive variables in preparation for deployments. Because those variables relate to the deployment of our stack, I'll cover this in the next section about continuous deployment.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Setting up CD and deployments with CircleCI</h1>
                </header>
            
            <article>
                
<p>As I mentioned in the introductory section of this chapter, the <strong>D</strong> in <strong>CD</strong> stands for <strong>Delivery</strong>. In this section, we'll walk through the details of setting up both delivery and deployment of our application via CircleCI. I will admit, the boundaries here between delivery and deployment are a bit blurred, and any such discussions can become difficult due to disagreements in terminology and details. For our purposes, our CD pipeline will focus on the following:</p>
<ul>
<li>Visibility</li>
<li>Feedback</li>
<li>Ease of automated deployments</li>
</ul>
<p>For visibility and feedback, we'll use Slack and GitHub badges. Our existing deployment script from the Makefile and the serverless framework will be hooked into CircleCI to make production deployments fast, simple, and reliable.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Setting up Slack notifications</h1>
                </header>
            
            <article>
                
<p>CircleCI has several integrations with various chat systems. Setting up test results to be posted to Slack (or your messaging platform of choice) is a straightforward and effective way to disseminate test results among team members.</p>
<p>In CircleCI, navigate to the <span class="packt_screen">Chat Notifications</span> menu item and click on the link in the <span class="packt_screen">Slack</span> section. From there, you'll be guided through the setup process for you Slack group. Ultimately, you'll get a webhook URL from Slack, which you will need to enter into CircleCI. Notification will be sent to this Slack webhook, which will post to a particular channel.</p>
<p>The following screenshot shows project settings for this repository within CircleCI&#160;and the page where you configure chat notifications:</p>
<div class="CDPAlignCenter CDPAlign"><img src="images/262832fb-0e9d-4766-b5d3-0adaf9198a2c.png" style="width:57.92em;height:36.75em;"/></div>
<p>After tests run, you'll see the results show up in Slack. The following two screenshots show success and failure messages in Slack, delivered by CircleCI:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="images/b709706f-41fc-42c2-bb75-d7ca6c9f2775.png" style="width:35.67em;height:4.92em;"/></div>
<p>If tests fail, the message will look slightly different. The following shows the message when tests fail from another project I work on:</p>
<div class="CDPAlignCenter CDPAlign"><img src="images/35568fe0-e410-4012-9f02-46f70e7a96a3.png" style="width:35.75em;height:6.25em;"/></div>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Setting up a CircleCI badge</h1>
                </header>
            
            <article>
                
<p>Current test results can also be displayed in markdown files. This&#160;badge is especially useful in GitHub or Bitbucket <kbd>README</kbd> files. In the <span class="packt_screen">Notifications</span>&#160;|&#160;<span class="packt_screen">Status Badges</span> section of CircleCI, you can find a markdown (or another format) snippet, which you can copy and put into your <kbd>README.md</kbd> file.</p>
<p>After putting that CircleCI-generated markdown snippet into the <kbd>README.md</kbd> file, GitHub will display the current status of the last build, as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="images/8d1d3232-708f-464d-aa4b-933d86aba3fd.png" style="width:39.00em;height:7.92em;"/></div>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Setting up deployments</h1>
                </header>
            
            <article>
                
<p>We now have our tests running automatically, as well as notifications about test results being pushed to Slack. Now, we can work on getting CircleCI to deploy our code to AWS for us automatically. I'll be working through the steps to enable automated deployments. You may not want to do automated deployments for each of your projects. However, you should work toward being <em>able</em> to perform continuous deployments. Even if you choose not to release production code like this, working toward continuous deployment as an end goal means that you will have automated the majority of your build pipeline.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Setting up AWS credentials</h1>
                </header>
            
            <article>
                
<p>Using AWS credentials is such a common task that CircleCI has a special section for it in each project's configuration. If you navigate to <span class="packt_screen">Permissions</span>&#160;|&#160;<span class="packt_screen">AWS Permissions,</span> you'll find two fields for your AWS Access Key ID and AWS Secret Key. Setting these here ensures you'll never need to check them into source control and that any AWS libraries you use (noted in the following screenshot) will automatically pick up the values as environment variables.</p>
<p>Setting these credentials in this section works as we would expect for the Serverless framework, allowing any <kbd>serverless</kbd> command to execute successfully provided the keys we attach have the correct IAM permissions:</p>
<div class="CDPAlignCenter CDPAlign"><img src="images/d1869cea-290d-4273-9489-a167700fe922.png" style="width:58.17em;height:26.33em;"/></div>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Setting up environment variables</h1>
                </header>
            
            <article>
                
<p><span>Some of the non-critical variables, such as the test</span> database <span>host and username, are easy to deal with in code or configuration files that are tracked in version control (such as <kbd>.circleci/config.yml</kbd>). When we turn our attention to deployments, however, there are inevitably variables that you would prefer to keep secret and never check into version control.</span></p>
<p>In cases like this, we can add variables via CircleCI from the <span class="packt_screen">Build Settings</span>&#160;|&#160;<span class="packt_screen">Environment Variables</span> section. In the following screenshot, you can see how I'm setting the database password for the PostgreSQL RDS instance:</p>
<div class="CDPAlignCenter CDPAlign"><img src="images/2afea326-5e1a-4e3c-89a3-406667f82e8a.png"/></div>
<p>As a quick review of how this entire system works, variables from the environment are picked up by the Serverless framework. In the case of some of the RDS variables, we inject the values into our Lambda functions via serverless and use the variables when creating and setting up an RDS instance. The related snippets of <kbd>serverless.yml</kbd> are as follows:</p>
<pre style="padding-left: 30px">provider:<br/>  environment:<br/>    CUPPING_DB_USERNAME: ${env:CUPPING_DB_USERNAME}<br/>    CUPPING_DB_PASSWORD: ${env:CUPPING_DB_PASSWORD}<br/>    CUPPING_DB_NAME: ${env:CUPPING_DB_NAME}<br/><br/>resources:<br/>  Resources:    <br/>    RDSPostgresInstance:<br/>      Type: AWS::RDS::DBInstance<br/>      Properties:<br/>        DBName: ${env:CUPPING_DB_NAME}<br/>        MasterUsername: ${env:CUPPING_DB_USERNAME}<br/>        MasterUserPassword: ${env:CUPPING_DB_PASSWORD} </pre>
<p>Any value we set in CircleCI for the <kbd>CUPPING_DB_PASSWORD</kbd> will be available during any <kbd>serverless</kbd> commands we execute from within CircleCI.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Executing deployments</h1>
                </header>
            
            <article>
                
<p>With all of the setup out of the way, we can update our CircleCI configuration to deploy code on our behalf. During the CI tasks, we utilized our various <kbd>make</kbd> targets to perform work that we were already doing manually. For deployments, we'll reuse another pre-existing <kbd>make</kbd> target that is already set up, <kbd>make deploy</kbd>.</p>
<p>Under the <kbd>jobs</kbd> key, we'll add another step named <kbd>deploy</kbd>, which comes after our build step. This new deploy job has the same configuration options available as the previous build step. Our goal in this deploy step is actually to perform the deployment out to our production environment. For that to work, there are different configuration options that we'll need to set up, the details of which you can see in the following YAML snippet from <kbd>.circleci/config.yml</kbd>.</p>
<div class="packt_tip">With CircleCI, each section under the jobs keys is a standalone body of work, which you may define and configure on its own. These steps can work together or in parallel, as we'll see shortly. In this case, we already have a <kbd>build/test</kbd> section, and we're now adding a <kbd>deploy</kbd> section. These two jobs will work together, so our code is deployed only after tests are run and pass.</div>
<p>We'll be using the same Docker image to perform our deployments, which you can see in the image section. For our deployments to work, some environment variables need to exist, as I mentioned earlier in this chapter. Here, we can set up those variables in our configuration file. The RDS password is missing from this list on purpose since it will be injected into our deployment phase by CircleCI because we defined it from the CircleCI web application. Finally, the steps for deploying our Serverless project are as follows:</p>
<ol>
<li>Check out code</li>
<li>Run <kbd>make libs</kbd> from the <kbd>ch2</kbd> directory</li>
<li>Run <kbd>make deploy</kbd> from the <kbd>ch2</kbd> directory</li>
</ol>
<p>The following code block shows the <kbd>deploy</kbd> step of <kbd>.circleci/config.yml</kbd> as well as the workflows, that chains together tests and deployments:</p>
<pre style="padding-left: 30px">jobs:<br/><br/>  build:<br/>    # build steps<br/><br/>  deploy:<br/>    docker:<br/>      - image: verypossible/serverless:1.25.0-python3<br/>    environment:<br/>      - ENV: production<br/>      - AWS_REGION: us-west-2<br/>      - VPC_ID: vpc-abc12345<br/>      - SUBNET_ID_A: subnet-11111111<br/>      - SUBNET_ID_B: subnet-22222222<br/>      - SUBNET_ID_C: subnet-33333333<br/>      - CUPPING_DB_USERNAME: root<br/>      - CUPPING_DB_NAME: cupping_log<br/>    steps:<br/>      - checkout<br/>      - run:<br/>          name: Build libs<br/>          working_directory: ch2 <br/>          command: make libs<br/>      - run:<br/>          name: Production deploy if tests pass and branch is production<br/>          working_directory: ch2 <br/>          command: make deploy<br/><br/>workflows:<br/>  version: 2<br/>  build-deploy:<br/>    jobs:<br/>      - build<br/>      - deploy:<br/>          requires:<br/>            - build<br/>          filters:<br/>            branches:<br/>              only: production </pre>
<div class="packt_tip"><span>These job keys can be named</span> anything you like and make sense to you. I happened to name them <kbd>build</kbd> and <kbd>deploy</kbd>. However, I could have called them <kbd>test</kbd> and <kbd>deploy</kbd>, or <kbd>build-test</kbd> and <kbd>rollout</kbd>.</div>
<p><span>With our deploy steps</span> defined<span>, we can instruct CircleCI to do our deployment under certain conditions via their workflows feature. The full capabilities of this feature are vast, but in our case the goal is simple; we want to do the deployment only when we are on the <kbd>production</kbd> branch and when tests have passed. You can see all of this logic in the <kbd>workflows</kbd> section in the previous configuration.</span></p>
<p>To see this in action, I performed the following steps:</p>
<ol>
<li>Checked in some changes to the <kbd>feature/circleci</kbd> branch</li>
<li>Created a GitHub pull request against the <kbd>production</kbd> branch</li>
<li>Merged the pull request</li>
</ol>
<div class="packt_infobox">Very often a deployment flow such as this will work off the <kbd>master</kbd> branch. Here, I've chosen to use a branch named <kbd>production</kbd>. This&#160;change in naming convention is because this book's repository may have several commits for the various chapters and I don't want every commit to <kbd>master</kbd> to trigger a CircleCI <kbd>build-deploy</kbd> workflow.</div>
<div class="CDPAlignCenter CDPAlign"><img src="images/afbbc5ed-ffa4-4fdf-9579-e40f395c9801.png" style="width:42.00em;height:37.92em;"/></div>
<p>The previous screenshot shows the pull request details. With CircleCI set up, any pull request will show the details of the test run. Here, we can see our tests have successfully run. I also received a Slack notification of the successful tests.</p>
<p>Once I click <span class="packt_screen">Merge pull request</span>, another CircleCI build begins. In the following screenshot you can see that, because the <kbd>production</kbd> branch was updated, our <kbd>build-deploy</kbd> workflow is running:</p>
<div class="CDPAlignCenter CDPAlign"><img src="images/0331668d-1885-43a7-87da-5239f3b1ec8d.png"/></div>
<p>After the build job runs and tests pass, the deploy step will commence. We can see this in CircleCI with their workflows visualization, shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="images/a77a2113-b08a-4a9c-b4c0-3417a108fe00.png"/></div>
<p>By clicking on the <span class="packt_screen">deploy</span> box, we can watch or see the details of the <kbd>deploy</kbd> phase:</p>
<div class="CDPAlignCenter CDPAlign"><img src="images/013489ab-7648-4f9a-9176-2c6346df9d36.png"/></div>
<p>Success! Since our <kbd>make deploy</kbd> command works for creating a brand new stack or updating an existing one, there is nothing more we need to do from here on. Any merges or commits to our <kbd>production</kbd> branch will trigger this flow, and we now have continuous deployment working.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we reviewed the meaning and high-level details of CI and CD. I also discussed some best practices on how to organize application code in serverless projects to help set up and run unit tests. From there, I covered how to set up our unit tests to run on every commit using CircleCI.</p>
<p>Finally, we worked through the entire process of setting up CircleCI to perform automated deployments triggered by changes to the <kbd>production</kbd> branch.&#160;<span>You learned some of the nuances of controlling CI execution via environment variables and where to configure sensitive settings such as database passwords and AWS keys.</span></p>


            </article>

            
        </section>
    </div>
</body>
</html>