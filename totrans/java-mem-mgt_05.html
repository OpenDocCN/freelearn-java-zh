<html><head></head><body>
<div id="sbo-rt-content" class="calibre1"><div id="_idContainer067" class="calibre2">
<h1 class="chapter-number" id="_idParaDest-78" lang="en-GB"><a id="_idTextAnchor077" class="pcalibre pcalibre2 pcalibre1 calibre6"/>5</h1>
<h1 id="_idParaDest-79" lang="en-GB" class="calibre5"><a id="_idTextAnchor078" class="pcalibre pcalibre2 pcalibre1 calibre6"/>Zooming in on the Metaspace</h1>
<p lang="en-GB" class="calibre4">In <a href="B18762_04.xhtml#_idTextAnchor057" class="pcalibre pcalibre2 pcalibre1 calibre6"><span lang=""><em class="italic" lang="">Chapter 4</em></span></a>, we examined garbage collection in detail. We discovered that objects without a reference are eligible for garbage collection. In effect, the garbage collector marks the objects that have a connection back to the stack, annotating them as live objects. The sweep phase of the garbage collector then reclaims the memory of the objects that are not marked (the <span lang="">dead objects).</span></p>
<p lang="en-GB" class="calibre4">We also examined the various garbage collection implementations. Based on your specific criteria, an evaluation of each implementation <span lang="">is required.</span></p>
<p lang="en-GB" class="calibre4">This chapter focuses on an area known as the <strong class="bold" lang="">Metaspace</strong>. We will examine the Metaspace under the <span lang="">following headings:</span></p>
<ul class="calibre10">
<li lang="en-GB" class="calibre11">JVM usage of <span lang="">the Metaspace</span></li>
<li lang="en-GB" class="calibre11"><span lang="">Class loading</span></li>
<li lang="en-GB" class="calibre11">Releasing <span lang="">Metaspace memory</span></li>
</ul>
<p lang="en-GB" class="calibre4">Let us start with the JVM usage of <span lang="">the Metaspace.</span></p>
<h1 id="_idParaDest-80" lang="en-GB" class="calibre5"><a id="_idTextAnchor079" class="pcalibre pcalibre2 pcalibre1 calibre6"/>JVM usage of the Metaspace</h1>
<p lang="en-GB" class="calibre4">The <a id="_idIndexMarker216" class="pcalibre pcalibre2 pcalibre1 calibre6"/>Metaspace is a special area of native memory outside of the heap. Native memory is memory provided by the operating system to an application for its own use. The JVM uses the Metaspace to store class-related information, that is, the class’s runtime representation. This is the class’s metadata; hence the <em class="italic" lang="">meta</em>data is stored in <span lang="">the </span><span lang=""><em class="italic" lang="">Meta</em></span><span lang="">space.</span></p>
<p class="callout-heading" lang="en-GB">Metadata</p>
<p class="callout" lang="en-GB">Metadata is information about data. For example, columns in a database are metadata about the data in the columns. Thus, if a column name is <strong class="source-inline1" lang="">Name</strong> and a specific row value is <strong class="source-inline1" lang="">John</strong>, then <strong class="source-inline1" lang="">Name</strong> is metadata <span lang="">about </span><span lang=""><strong class="source-inline1" lang="">John</strong></span><span lang="">.</span></p>
<p lang="en-GB" class="calibre4">This metadata <a id="_idIndexMarker217" class="pcalibre pcalibre2 pcalibre1 calibre6"/>consists of <span lang="">the following:</span></p>
<ul class="calibre10">
<li lang="en-GB" class="calibre11"><span lang="">Class files</span></li>
<li lang="en-GB" class="calibre11">Structure and methods of <span lang="">the class</span></li>
<li lang="en-GB" class="calibre11"><span lang="">Constants</span></li>
<li lang="en-GB" class="calibre11"><span lang="">Annotations</span></li>
<li lang="en-GB" class="calibre11"><span lang="">Optimizations</span></li>
</ul>
<p lang="en-GB" class="calibre4">Thus, in metadata, the JVM has everything it requires to work with <span lang="">the class.</span></p>
<p class="callout-heading" lang="en-GB">PermGen</p>
<p class="callout" lang="en-GB">Prior to Java 8, the metadata was stored in an area (contiguous with the heap) known as <strong class="bold" lang="">PermGen</strong>, or <strong class="bold" lang="">permanent generation</strong>. PermGen <a id="_idIndexMarker218" class="pcalibre pcalibre2 pcalibre1 calibre6"/>stored the class metadata, interned strings, and the class’s static variables. As of Java 8, the class metadata is now stored in the Metaspace, and interned strings and class/static variables are stored on <span lang="">the heap.</span></p>
<p lang="en-GB" class="calibre4">Let us now examine <span lang="">class loading.</span></p>
<h1 id="_idParaDest-81" lang="en-GB" class="calibre5"><a id="_idTextAnchor080" class="pcalibre pcalibre2 pcalibre1 calibre6"/>Class loading</h1>
<p lang="en-GB" class="calibre4">When a<a id="_idIndexMarker219" class="pcalibre pcalibre2 pcalibre1 calibre6"/> class is accessed for the first time (for example, when an object of the class is created), the class loader locates the class file and allocates its metadata in the Metaspace. The class loader owns this allocated Metaspace and the class loader instance itself is loaded onto the heap. Once loaded, subsequent references reuse the metadata of that <span lang="">same class.</span></p>
<p lang="en-GB" class="calibre4">There are two class loaders worth mentioning at this point: the bootstrap class loader (which is responsible for loading the class loaders themselves) and the application class loader. Both of these class loaders’ metadata reside permanently in Metaspace and consequently, are never garbage collected. Dynamic class loaders (and the classes they load) are, on the<a id="_idIndexMarker220" class="pcalibre pcalibre2 pcalibre1 calibre6"/> other hand, eligible for <span lang="">garbage collection.</span></p>
<p lang="en-GB" class="calibre4">This leads us to the release of memory from <span lang="">the Metaspace.</span></p>
<h1 id="_idParaDest-82" lang="en-GB" class="calibre5"><a id="_idTextAnchor081" class="pcalibre pcalibre2 pcalibre1 calibre6"/>Releasing Metaspace memory</h1>
<p lang="en-GB" class="calibre4">One of the<a id="_idIndexMarker221" class="pcalibre pcalibre2 pcalibre1 calibre6"/> major changes from PermGen (pre-Java 8) to Metaspace (Java 8 onwards) is that the Metaspace can now grow in size. By default, the amount of memory allocated for the Metaspace is unbounded, as it is part of native memory. The size of the Metaspace can be customized using the JVM <strong class="source-inline" lang="">–</strong><span lang=""><strong class="source-inline" lang="">XX:MetaspaceSize</strong></span><span lang=""> flag.</span></p>
<p lang="en-GB" class="calibre4">The Metaspace can trigger garbage collection in only <span lang="">two scenarios:</span></p>
<ul class="calibre10">
<li lang="en-GB" class="calibre11">Metaspace runs out <span lang="">of memory</span></li>
<li lang="en-GB" class="calibre11">Metaspace size exceeds a <span lang="">JVM-set threshold</span></li>
</ul>
<p lang="en-GB" class="calibre4">Let us examine these <span lang="">in turn.</span></p>
<h2 id="_idParaDest-83" lang="en-GB" class="calibre7"><a id="_idTextAnchor082" class="pcalibre pcalibre2 pcalibre1 calibre6"/>Metaspace runs out of memory</h2>
<p lang="en-GB" class="calibre4">As stated, by <a id="_idIndexMarker222" class="pcalibre pcalibre2 pcalibre1 calibre6"/>default, the native memory available to the Metaspace is unlimited. If you run out of memory, you get an <strong class="source-inline" lang="">OutOfMemoryError</strong> message, and this will trigger a run of the garbage collector. You can limit the Metaspace size with the JVM <strong class="source-inline" lang="">–XX:MaxMetaspaceSize</strong> flag. If you reach this limit, that will also trigger a run of the <span lang="">garbage collector.</span></p>
<h2 id="_idParaDest-84" lang="en-GB" class="calibre7"><a id="_idTextAnchor083" class="pcalibre pcalibre2 pcalibre1 calibre6"/>Metaspace size exceeds a JVM-set threshold</h2>
<p lang="en-GB" class="calibre4">We can<a id="_idIndexMarker223" class="pcalibre pcalibre2 pcalibre1 calibre6"/> configure the JVM to trigger a garbage collection when the Metaspace reaches a certain threshold, known as the <strong class="bold" lang="">high-water mark</strong>. In <a id="_idIndexMarker224" class="pcalibre pcalibre2 pcalibre1 calibre6"/>addition, we can adjust this threshold dynamically based on garbage collection results. Raising the high-water mark prevents inducing another garbage collection too quickly. Lowering the high-water mark does the opposite; it helps induce another garbage collection more quickly. The threshold or high-water mark is initially set to the value of the JVM <strong class="source-inline" lang="">-XX:MetaspaceSize</strong> flag. We use the <strong class="source-inline" lang="">–XX:MinMetaspaceFreeRatio</strong> and <strong class="source-inline" lang="">–XX:MaxMetaspaceFreeRatio</strong> flags to raise or lower the high-water <span lang="">mark, respectively.</span></p>
<p lang="en-GB" class="calibre4">Now that <a id="_idIndexMarker225" class="pcalibre pcalibre2 pcalibre1 calibre6"/>we know when garbage collection runs in the Metaspace, let us examine how garbage collection works regarding <span lang="">the Metaspace.</span></p>
<h2 id="_idParaDest-85" lang="en-GB" class="calibre7"><a id="_idTextAnchor084" class="pcalibre pcalibre2 pcalibre1 calibre6"/>Garbage collection of the Metaspace</h2>
<p lang="en-GB" class="calibre4">As the<a id="_idIndexMarker226" class="pcalibre pcalibre2 pcalibre1 calibre6"/> class loader owns the metadata for a class, the garbage collector can only reclaim this metadata when the class loader itself is dead. The class loader is only dead when there are no instances of any classes loaded by <span lang="">that loader.</span></p>
<p lang="en-GB" class="calibre4">Let us look at an example to help explain this further. The example assumes a dynamic class loader and uses simplified diagrams for ease <span lang="">of explanation.</span></p>
<p lang="en-GB" class="calibre4"><span lang=""><em class="italic" lang="">Figure 5</em></span><em class="italic" lang="">.1</em> details the situation in memory after we have created two objects of the <strong class="bold" lang="">O</strong> type and one object of the <span lang=""><strong class="bold" lang="">P</strong></span><span lang=""> type.</span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer063">
<img alt="Figure 5.1 – Metaspace allocation" src="image/Figure_5.1_B18762.jpg" class="calibre69"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 5.1 – Metaspace allocation</p>
<p lang="en-GB" class="calibre4">In the preceding figure, initially, the JVM creates the class loader object (dark blue), two objects of the <strong class="bold" lang="">O</strong> type (light blue), and one object of the <strong class="bold" lang="">P</strong> type (yellow) on the heap. The <strong class="bold" lang="">O</strong> and <strong class="bold" lang="">P</strong> references are on the stack. Upon creating the first <strong class="bold" lang="">O</strong> and <strong class="bold" lang="">P</strong> instances, the class loader loads the metadata for both <strong class="bold" lang="">O</strong> and <strong class="bold" lang="">P</strong> in the Metaspace. However, when creating the second instance of <strong class="bold" lang="">O</strong>, nothing happens in the Metaspace because the metadata for <strong class="bold" lang="">O</strong> is <span lang="">already loaded.</span></p>
<p lang="en-GB" class="calibre4"><span lang=""><em class="italic" lang="">Figure 5</em></span><em class="italic" lang="">.2</em> will show the situation in memory when both of the <strong class="bold" lang="">O</strong> references go out of scope but garbage collection has not <span lang="">yet run:</span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer064">
<img alt="Figure 5.2 – Metaspace (both O references out of scope)" src="image/Figure_5.2_B18762.jpg" class="calibre70"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 5.2 – Metaspace (both O references out of scope)</p>
<p lang="en-GB" class="calibre4">As you can <a id="_idIndexMarker227" class="pcalibre pcalibre2 pcalibre1 calibre6"/>see, the JVM has popped both of the <strong class="bold" lang="">O</strong> references from the stack. Garbage collection has not yet run so the instances remain on the heap. <span lang=""><em class="italic" lang="">Figure 5</em></span><em class="italic" lang="">.3</em> shows the situation after the first run of <span lang="">garbage collection:</span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer065">
<img alt="Figure 5.3 – Metaspace after garbage collection (run #1)" src="image/Figure_5.3_B18762.jpg" class="calibre71"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 5.3 – Metaspace after garbage collection (run #1)</p>
<p lang="en-GB" class="calibre4">In the <a id="_idIndexMarker228" class="pcalibre pcalibre2 pcalibre1 calibre6"/>preceding figure, we can see that the garbage collector reclaimed the two (dead) <strong class="bold" lang="">O</strong> objects from the heap. In addition, the garbage collector moved both the class loader and <strong class="bold" lang="">P</strong> objects to the <span lang="">survivor space.</span></p>
<p lang="en-GB" class="calibre4">Note that the metadata for <strong class="bold" lang="">O</strong> remains in the Metaspace even though no objects of the <strong class="bold" lang="">O</strong> type are on the heap. This is because the garbage collector could not reclaim the class loader for <strong class="bold" lang="">O</strong> due to the existence of the object of the <strong class="bold" lang="">P</strong> type on the heap (the same class loader loaded both <strong class="bold" lang="">O</strong> <span lang="">and </span><span lang=""><strong class="bold" lang="">P</strong></span><span lang="">).</span></p>
<p lang="en-GB" class="calibre4"><span lang=""><em class="italic" lang="">Figure 5</em></span><em class="italic" lang="">.4</em> shows the situation in memory when the <strong class="bold" lang="">P</strong> reference goes out of scope and garbage collection <span lang="">runs again:</span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer066">
<img alt="Figure 5.4 – Metaspace after garbage collection (run #2)" src="image/Figure_5.4_B18762.jpg" class="calibre72"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 5.4 – Metaspace after garbage collection (run #2)</p>
<p lang="en-GB" class="calibre4">We can <a id="_idIndexMarker229" class="pcalibre pcalibre2 pcalibre1 calibre6"/>see that the JVM has popped the reference of <strong class="bold" lang="">P</strong> from the stack. As a result, the garbage collector reclaimed the object of the <span lang=""><strong class="bold" lang="">P</strong></span><span lang=""> type.</span></p>
<p lang="en-GB" class="calibre4">As the garbage collector has now reclaimed all instances of <strong class="bold" lang="">O</strong> and <strong class="bold" lang="">P</strong> types, it can reclaim the class loader that loaded <strong class="bold" lang="">O</strong> and <strong class="bold" lang="">P</strong>. Now, finally, the garbage collector can reclaim the metadata for <strong class="bold" lang="">O</strong> and <strong class="bold" lang="">P</strong> classes in <span lang="">the Metaspace.</span></p>
<p lang="en-GB" class="calibre4">That wraps up this chapter. Let us recap the <span lang="">major points.</span></p>
<h1 id="_idParaDest-86" lang="en-GB" class="calibre5"><a id="_idTextAnchor085" class="pcalibre pcalibre2 pcalibre1 calibre6"/>Summary</h1>
<p lang="en-GB" class="calibre4">In this chapter, we zoomed in on the Metaspace (formerly known as PermGen). The Metaspace is a special area of non-heap memory reserved for a class’s metadata. The metadata consists of information enabling the JVM to work with the class: for example, method bytecode, constants, and annotations. When a class is first used, its metadata is loaded into the Metaspace. An example is the creation of an object for the <span lang="">first time.</span></p>
<p lang="en-GB" class="calibre4">By default, the native memory available to the Metaspace is unlimited. A maximum Metaspace size is configurable using the JVM <strong class="source-inline" lang="">–XX:MaxMetaspaceSize</strong> flag. A threshold value or high-water mark can be set initially using the <strong class="source-inline" lang="">–XX:MetaspaceSize</strong> flag. If a threshold value is set and reached, this induces a run of the garbage collector. Using both JVM flags, <strong class="source-inline" lang="">–XX:MinMetaspaceFreeRatio</strong> and <strong class="source-inline" lang="">–XX:MaxMetaspaceFreeRatio</strong>, in conjunction with garbage collection results, we can dynamically influence the high-water mark and, therefore, the interval to the next run of the <span lang="">garbage collector.</span></p>
<p lang="en-GB" class="calibre4">We saw, using an example, how the metadata for a class remains in Metaspace until the garbage collector deallocates the class loader that loaded that class. This cannot occur until all classes loaded by that class loader have <span lang="">no instances.</span></p>
<p lang="en-GB" class="calibre4">Now that we have zoomed in on the Metaspace, we will turn our attention to the next chapter, which focuses on configuring and monitoring the memory management of <span lang="">the JVM.</span></p>
</div>
<div class="calibre2">
<div id="_idContainer068" class="calibre2">
</div>
</div>
</div></body></html>