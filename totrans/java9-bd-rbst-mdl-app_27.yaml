- en: Taking Notes with Monumentum
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For our eighth project, we will again do something new--we'll build a web app.
    Whereas all of our other projects have been command lines, GUIs, or some combination
    thereof, this project will be a single module consisting of a REST API and a JavaScript
    frontend, all built with an eye toward the current microservice trend.
  prefs: []
  type: TYPE_NORMAL
- en: 'To build the application, you''ll learn about the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Some of the Java options to build microservice applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Payara Micro and `microprofile.io`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Java API for RESTful Web Services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Document data stores and MongoDB
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OAuth authentication (against Google, specifically)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**JSON Web Tokens** (**JWT**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see, this will be, in many ways, a much different type of project
    than what we've looked at to this point.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most of us have likely used some sort of note-taking application such as EverNote,
    OneNote, or Google Keep. They're an extremely handy way of jotting down notes
    and thoughts, and having them available from just about every environment imaginable--desktop,
    mobile, and web. In this chapter, we'll build a fairly basic clone of these industry
    giants in order to exercise a number of concepts. We will call this app Monumentum,
    which is Latin for a reminder or memorial, an apt name for this type of application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we get into those, let''s take some time to list the requirements for
    our application:'
  prefs: []
  type: TYPE_NORMAL
- en: Be able to create notes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Be able to list notes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Be able to edit notes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Be able to delete notes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note bodies must be capable of storing/displaying rich text
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Be able to create a user account
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Must be able to log into the application using OAuth2 credentials against an
    existing system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Our non-functional requirements are fairly modest:'
  prefs: []
  type: TYPE_NORMAL
- en: Must have a RESTful API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Must have an HTML 5/JavaScript frontend
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Must have a flexible, scalable data store
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Must be easily deployable on resource-constrained systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Of course, this list of non-functional requirements was chosen in part because
    they reflect real-world requirements, but they also set us up very nicely to discuss
    some of the technologies I'd like to cover in this chapter. To cut to the chase,
    we'll create a web application that provides both a REST-based API and a JavaScript
    client. It will be backed by a document data store, and built using one of the
    many microservice libraries/frameworks available to the JVM.
  prefs: []
  type: TYPE_NORMAL
- en: So what does this stack look like? Let's take a quick survey of our options
    before we settle on a particular choice. Let's start with a look at the microservice
    frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: Microservice frameworks on the JVM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While I am reluctant to spend a great deal of time on what a microservice is
    given that most people are familiar with the topic at this point, I think it would
    be a remiss not to give at least a brief description in case you are not familiar
    with the idea. With that said, here is a nice, concise definition of microservice
    from SmartBear, a provider of software quality tools perhaps best known for their
    stewardship of the Swagger API and related libraries:'
  prefs: []
  type: TYPE_NORMAL
- en: Essentially, microservice architecture is a method of developing software applications
    as a suite of independently deployable, small, modular services in which each
    service runs a unique process and communicates through a well-defined, lightweight
    mechanism to serve a business goal.
  prefs: []
  type: TYPE_NORMAL
- en: To put it another way, rather than the older, more established approach of bundling
    several related systems in one web application and deploying it to a large application
    server, such as GlassFish/Payara Server, Wildfly, WebLogic Server, or WebSphere,
    each of these systems would instead be run separately in their own JVM process.
    The benefits of this approach include easier, piecemeal upgrades, increased stability
    through process isolation, smaller resource requirements, greater machine utilization,
    and so on. The concept itself is not necessarily new, but it has certainly gained
    popularity in recent years, and continues to grow at a rapid pace.
  prefs: []
  type: TYPE_NORMAL
- en: 'So what do our options look like on the JVM? We have several, including, in
    no particular order, the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Eclipse Vert.x**: This is officially *a tool-kit for building reactive applications
    on the JVM*. It provides an event-driven application framework that lends itself
    well to writing microservices. Vert.x can be used in a number of languages, including
    Java, Javascript, Kotlin, Ceylon, Scala, Groovy, and Ruby. More information can
    be found at [http://vertx.io/](http://vertx.io/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Spring Boot**: This is a library to build stand alone Spring applications.
    Spring Boot applications have full access to the entire Spring ecosystem, and
    can be run using a single fat/uber JAR. Spring Boot lives at [https://projects.spring.io/spring-boot/](https://projects.spring.io/spring-boot/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Java EE MicroProfile**: This is a community and vendor-led effort to create
    a new profile for Java EE, specifically tailored to microservices. At the time
    of writing, the profile includes **Java API for RESTful Web Services** (**JAX-RS**),
    CDI, and JSON-P, and is sponsored by several companies including Tomitribe, Payara,
    Red Hat, Hazelcast, IBM, and Fujitsu, and user groups such as London Java Community
    and SouJava. The MicroProfile home page is [http://microprofile.io/](http://microprofile.io/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lagom**: This fairly new framework is a reactive microservices framework
    from Lightbend, the company behind Scala. It is described as an opinionated microservice
    framework, and is built using two of Lightbend''s more famous libraries--Akka
    and Play. Lagom applications can be written either in Java or Scala. More details
    can be found at [https://www.lightbend.com/platform/development/lagom-framework](https://www.lightbend.com/platform/development/lagom-framework).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dropwizard**: This is a Java framework to develop ops-friendly, high-performance,
    RESTful web services. It is a framework that offers Jetty for HTTP, Jersey for
    REST services, and Jackson for JSON. It also provides support for other libraries
    such as Guava, Hibernate Validator, Freemarker, and others. You can find Dropwizard
    at [http://www.dropwizard.io/](http://www.dropwizard.io/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are a few other options, but it should be clear that, as JVM developers,
    we have a myriad of choices, which is almost always good. Since we can only build
    using one, I have chosen to use the MicroProfile. Specifically, we'll base our
    application on Payara Micro, Payara's implementation, which is based on the GlassFish
    sources (plus Payara's bug fixes, enhancements, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: By choosing the MicroProfile and Payara Micro, we choose, implicitly, JAX-RS
    as the basis for our REST services. We are free, of course, to use whatever we
    want, but deviating from what the framework offers lessens the value of the framework
    itself.
  prefs: []
  type: TYPE_NORMAL
- en: That leaves us with our choice of data store. One option we've already seen
    is the relational database. It is a tried and true choice that powers a wide swath
    of the industry. They are, however, not without their limitations and problems.
    While databases themselves can be complicated in terms of classifications and
    functionality, perhaps the most popular alternatives to relational databases are
    NoSQL databases. While these have existed for half a century, the idea had not
    gained any significant market traction until sometime in the last decade or so
    with the advent of **Web 2.0**.
  prefs: []
  type: TYPE_NORMAL
- en: While the term **NoSQL** is very broad, most examples of this type of database
    tend to be key-value, document, or graph data stores, each offering distinct performance
    and behavior characteristics. A full treatment of each type of NoSQL database
    and its various implementations is beyond the scope of this book, so, in the interest
    of time and space, we'll just get straight to our selection--MongoDB. Its scalability
    and flexibility, especially in regard to document schemas, meshes well with our
    target use case.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, on the client side, we have a myriad of options again. Among the most
    popular are ReactJS from Facebook and Angular from Google. There is a variety
    of other frameworks, including older options such as Knockout and Backbone, as
    well as newer ones such as Vue.js. It is this latter option that we'll use. Not
    only is it a very powerful and flexible option, it also presents the least amount
    of friction getting started. Since this book is focused on Java, I felt it prudent
    to select an option that will require the least amount of setup while meeting
    our needs.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To use Payara Micro, we create a Java web application like we normally would.
    In NetBeans, we will select File | New Project | Maven | Web Application and click
    on Next. For the project name, enter `monumentum`, select the appropriate Project
    Location, and fix up the Group ID and Package as desired:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c894fa8c-00bf-4de2-96ac-97152a4d040d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The next window will ask us to choose a server, which we can leave blank, and
    a Java EE version, which we want to set to Java EE 7 Web:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3ec66cd8-47ee-46b0-926c-298c456cddf7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After a few moments, we should have our project created and ready to go. Since
    we created a Java EE 7 web application, NetBeans has already added the Java EE
    API dependency to the project. Before we jump into coding, let''s add Payara Micro
    to the build to get that part ready. To do that, we need to add a plugin to the
    build. That will look something like this (though we''ve only shown the highlights
    here):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This sets up the Maven exec plugin, which is used to execute either an external
    application or, as we''ll do here, a Java application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we''re associating the execution of this plugin with Maven''s package
    phase. This means that when we run Maven to build our project, the plugin''s java
    goal will be run as Maven starts to package the project, allowing us to alter
    exactly what gets packaged in the JAR:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This last section configures the plugin. It will run the `PayaraMicro` class,
    passing the `--deploy <path> --outputUberJar ...` command. Effectively, we're
    telling Payara Micro how to run our application, but, rather than executing the
    package right now, we want it to create an uber JAR that will run the application
    later.
  prefs: []
  type: TYPE_NORMAL
- en: Typically, when you build your project, you get a jar file that contains only
    the classes and resources that are directly included in your project. Any external
    dependencies are left as something that the execution environment has to provide.
    With an uber JAR, all of the dependencies are included in our project's jar as
    well, which is then configured in such a way that the execution environment can
    find them as needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The problem with the setup is that, left as is, when we build, we''ll get an
    uber JAR, but we won''t have any easy way to run the application from NetBeans.
    To fix that, we need a slightly different plugin configuration. Specifically,
    it needs these lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'These replace the preceding `deploy` and `outputUberJar` options. To help speed
    up our builds, we also don''t want the uber JAR created until we ask for it, so
    we can separate these two plugin configurations into two separate profiles, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'When we''re ready to build the deployment artifact, we activate the uber profile
    when we execute Maven, and we''ll get our executable jar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The `exploded-war` profile is the configuration that we''ll use from the IDE,
    which runs Payara Micro, pointing it at the exploded war in our build directory.
    To instruct NetBeans to use that, we need to modify a couple of action configurations.
    To do that, right-click on the project in NetBeans and select Properties from
    the bottom of the context menu. Under Actions, find Run Project and select it,
    then enter `exploded-war` under Activate Profiles:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6555e9a8-b1b4-4d90-aeaf-d5a687ea786a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If we run the application now, NetBeans will complain because we haven''t selected
    a server. While this is a web application and those have typically needed a server,
    we''re using Payara Micro, so we don''t need an application server defined. Fortunately,
    NetBeans will let us tell it that, as demonstrated in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8e5a2763-76d4-49ae-a724-cf30cd2fbb8e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Select Ignore, I don''t want IDE managed deployment and click on OK, then watch
    the output window. You should see a fair amount of text scroll by, and after a
    few seconds, you should see text like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Once you see that, we're ready to test our application, such as it is at this
    point. In your browser, open `http://localhost:8080/monumentum-1.0-SNAPSHOT/index.html`
    and you should see a large and exciting *Hello World!* message on the page. If
    you see this, you have successfully bootstrapped a Payara Micro project. Take
    a moment to congratulate yourself, and then we'll make the application do something
    useful.
  prefs: []
  type: TYPE_NORMAL
- en: Creating REST Services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This being basically a Java EE application, albeit one that it is packaged and
    deployed a bit differently, everything you may have learned about writing Java
    EE applications most likely still applies. Of course, you may not have ever written
    such an application, so we'll walk through the steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'REST applications in Java EE are written using JAX-RS, and our starting point
    for JAX-RS is an `Application`. The `Application` is a deployment-agnostic means
    for declaring root-level resources to the runtime. How the runtime finds the `Application`
    is, of course, dependent on the runtime itself. For a MicroProfile application
    like ours, we''ll be running in a Servlet 3.0 environment, so we need not do anything
    special, as Servlet 3.0 supports a descriptor-less deployment option. The runtime
    will scan for a class of type `Application` that is annotated with `@ApplicationPath`
    and uses that to configure the JAX-RS application, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'With the `@ApplicationPath` annotation, we specify the root URL of our application''s
    REST endpoints, which is, of course, relative to the web application''s root context
    itself. `Application` has three methods we can override, but we''re only interested
    in the one listed here: `getClasses()`. We''ll provide more details on this method
    shortly, but, for now, keep in mind that this is how we will describe to JAX-RS
    what our top-level resources are.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Monumentum will have a very simple API, with the primary endpoint being that
    to interact with notes. To create that endpoint, we create a simple Java class
    and mark it up with the appropriate JAX-RS annotations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: With this class, we're describing an endpoint that will live at `/api/notes`
    and will produce JSON results. JAX-RS supports, for example, XML, but most REST
    developers are accustomed to JSON and are expecting nothing else, so we need not
    support anything other than JSON. The needs of your application may vary, of course,
    so you can adjust the list of supported media types as needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'While this will compile and run, and JAX-RS will attempt to handle requests
    to our endpoint, we haven''t actually defined it yet. To do that, we need to add
    some methods to our endpoint that will define the inputs and outputs of the endpoint,
    as well as the HTTP verb/method we''ll use. Let''s start with the notes collection
    endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We now have an endpoint that answers `GET` requests at `/api/notes` and returns
    a `List` of `Note` instances. There is some debate among REST developers on the
    proper return from methods like these. There are some who prefer to return the
    actual type the client will see, for example `List<Note>` in our case, as it makes
    it clear to developers reading the source, or documentation generated from it.
    Others prefer, as we've done here, to return a JAX-RS `Response` object, as that
    gives greater control over the response, including HTTP headers, status code,
    and more. I tend to prefer this second approach as we've done here. You, of course,
    are free to use either approach.
  prefs: []
  type: TYPE_NORMAL
- en: 'One last thing to note here is the way in which we build the response body:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Typically, at runtime, the parameterized type of the List is lost due to type
    erasure. Using a `GenericEntity` like this allows us to capture the parameterized
    type, allowing the runtime to marshal the data. Using this allows us to avoid
    writing our own `MessageBodyWriter`. Less code is almost always a good thing.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we run our application now, we''ll get the following response, albeit a
    very boring one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: That's both satisfying, and it's not, but it does demonstrate that we're on
    the right track. Clearly, we want that endpoint to return data, but we have no
    way of adding a note, so let's fix that now.
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating a new entity via REST is accomplished by POSTing a new entity to its
    collection. That method looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `@POST` annotation indicates the use of the HTTP POST verb. The method takes
    a `Note` instance, and returns a `Response` as we saw in the preceding code. Notice
    that we don't deal with JSON directly. By specifying a `Note` in the method signature,
    we can take advantage of one of JAX-RS's great features--POJO mapping. We've already
    seen a hint of it in the previous code with `GenericEntity`. JAX-RS will attempt
    to unmarshal--that is, convert from a serialized form to a model object--the JSON
    request body. If the client sends a JSON object in the correct format, we get
    a usable `Note` instance. If the client sends an improperly built object, it gets
    a response. This feature allows us to deal solely with our domain objects and
    not worry about JSON encoding and decoding, which can save considerable time and
    energy.
  prefs: []
  type: TYPE_NORMAL
- en: Adding MongoDB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the body of the method, we get our first glimpse of the integration with
    MongoDB. To make this compile, we need to add a dependency on the MongoDB Java
    Driver:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'MongoDB deals with documents, so we need to convert our domain model to a `Document`,
    which we accomplish via a method on our model class. We haven''t looked at the
    details of the `Note` class, so let''s do that now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This is mostly just a normal POJO. We have added a constructor and an instance
    method to handle converting to and from MongoDB's `Document` type.
  prefs: []
  type: TYPE_NORMAL
- en: There are a couple of things to call out here. The first is how the ID of the
    MongoDB `Document` is handled. Every document stored in a MongoDB database gets
    `_id` assigned to it. In the Java API, this `_id` is represented as `ObjectId`.
    We don't want that detail exposed in our domain model, so we convert it to a `String`
    and back again.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need to do some special handling for our date fields. We''ve chosen
    to represent the `created` and `modified` properties as `LocalDateTime` instances
    since the new date/time API is superior to the old `java.util.Date`. Unfortunately,
    the MongoDB Java Driver does not yet support Java 8, so we need to handle the
    conversion ourselves. We''ll store these dates as strings and convert them as
    needed. That conversion is handled via the `LocalDateTimeAdapter` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This is probably a bit more complicated than you might expect, and that's because
    it's doing more than we've discussed so far. The usage we're looking at now, that
    from our model class, is not this class' primary purpose, but we'll get to that
    in a moment. That aside, the class' behavior is pretty straightforward--take a
    `String`, determine which of the two supported formats it represents, and convert
    it to a `LocalDateTime`. It also goes the other way.
  prefs: []
  type: TYPE_NORMAL
- en: This class' primary purpose is for JAX-RS' use. When we pass `Note` instances
    across the wire, `LocalDateTime` needs to be unmarshalled as well, and we can
    tell JAX-RS how to do this via an `XmlAdapter`.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the class defined, we need to tell JAX-RS about it. We can do that in
    a couple of different ways. We could use an annotation on each property in our
    model like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'While this works, it''s a fairly large annotation, as far as these kinds of
    things go, and you have to put this on every `LocalDateTime` property. If you
    have several models with fields of this type, you will have to touch each property.
    Fortunately, there''s a way to associate the type with the adapter once. We can
    do that in a special Java file called `package-info.java`. Most people have never
    heard of this file, and even fewer use it, but it is simply a place for package-level
    documentation and annotations. It is this latter use case that interests us. In
    the package for our model class, create `package-info.java` and put this in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We have the same annotation we saw in the preceding code, but it's wrapped in
    `@XmlJavaTypeAdapters`. The JVM allows only annotation of a given type on an element,
    so this wrapper allows us to work around that limitation. We also need to specify
    the type parameter on the `@XmlJavaTypeAdapter` annotation since it is no longer
    on the target property. With this in place, every `LocalDateTime` property will
    be handled correctly without any additional work.
  prefs: []
  type: TYPE_NORMAL
- en: 'That''s quite a bit of setup, but we''re still not quite ready. We have everything
    set up on the REST side. We now need to get the MongoDB classes in place. To connect
    to a MongoDB instance, we start with a `MongoClient`. From the `MongoClient`,
    we then acquire a reference to a `MongoDatabase` from which we get a `MongoCollection`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The `@PostConstruct` method runs on the bean after the constructor has run.
    In this method, we initialize our various MongoDB classes and store them in instance
    variables. With these classes ready, we can revisit, for example, `getAll()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now query the database for our notes, and with the implementation of
    `createNote()` shown in the preceding code, we can create the following notes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: For this to work on your machine, you'll need an instance of MongoDB running.
    You can download an installer appropriate for your operating system as well as
    find installation instructions on the MongoDB website ([https://docs.mongodb.com/manual/installation/](https://docs.mongodb.com/manual/installation/)).
  prefs: []
  type: TYPE_NORMAL
- en: Before we move on to the other resource methods, let's take one last look at
    our MongoDB API instances. While instantiating the instances like we have works,
    it also puts a fair amount of work on the resource itself. Ideally, we should
    be able to move those concerns elsewhere and inject the instances. Hopefully,
    this sounds familiar to you, as this is exactly the type of concern that **dependency
    injection** (**DI**) or **inversion of control** (**IoC**) frameworks were created
    to solve.
  prefs: []
  type: TYPE_NORMAL
- en: Dependency injection with CDI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Java EE provides a framework such as CDI. With CDI, we can inject any container-controlled
    object into another with compile-time type safety. The problem, though, is the
    objects in question need to be container controlled, which our MongoDB API objects
    are not. Fortunately, CDI provides a means by which the container can create these
    instances, a facility known as producer methods. What might this look like? Let''s
    start with the injection point, as that is the simplest piece:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'When the CDI container sees `@Inject`, it inspects the element the annotation
    is on to determine the type. It will then attempt to look up an instance that
    will satisfy the injection request. If there is more than one, the injection would
    typically fail. Although, we have used a qualifier annotation to help CDI determine
    what to inject. That annotation is defined like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'With this annotation, we can pass hints to the container that will help it
    select an instance for injection. As we''ve mentioned, `MongoCollection` is not
    container-managed, so we need to fix that, which we do via the following producer
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The `@Produces` method tells CDI that this method will produce instances needed
    by the container. CDI determines the type of the injectable instance from the
    method signature. We also place the qualifier annotation on the method as an additional
    hint to the runtime as it tries to resolve our injection request.
  prefs: []
  type: TYPE_NORMAL
- en: In the method itself, we add `InjectionPoint` to the method signature. When
    CDI calls this method, it will provide an instance of this class, from which we
    can get information about each particular injection point as they are processed.
    From `InjectionPoint`, we get the `Collection` instance from which we can get
    the name of the MongoDB collection we're interested in. We are now ready to get
    the `MongoCollection` instance we saw earlier. The `MongoClient` and `MongoDatabase`
    instantiation is handled internally in the class and is not changed significantly
    from our earlier usage.
  prefs: []
  type: TYPE_NORMAL
- en: There is one small setup step for CDI. In order to avoid potentially expensive
    classpath scanning by the CDI container, we need to tell the system that we want
    the CDI turned on, so to speak. To do that, we need a `beans.xml` file, which
    can either be full of CDI configuration elements, or completely empty, which is
    what we'll do. For Java EE web applications, `beans.xml` needs to be in the `WEB-INF`
    directory, so we create the file in `src/main/webapp/WEB-INF`.
  prefs: []
  type: TYPE_NORMAL
- en: Make sure that the file is truly empty. If there's even a blank line, Weld,
    Payara's CDI implementation, will attempt to parse the file, giving you an XML
    parsing error.
  prefs: []
  type: TYPE_NORMAL
- en: Finish the notes resource
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we can move on from the `Note` resource, we need to finish up a few
    operations, namely, read, update, and delete. Reading a single note is very straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We've specified the use of the HTTP verb `GET` as we've already seen, but we
    have an additional annotation on this method, `@Path`. Using this annotation,
    we tell JAX-RS that this endpoint has additional path segments that the request
    needs to be matched against. In this case, we specify one additional segment,
    but we've wrapped it in curly braces. Without those braces, the match would be
    a literal match, that is to say, "Does this URL have the string 'id' on the end?"
    With the braces, though, we're telling JAX-RS that we want to match the additional
    segment, but its contents can be anything, and we want to capture that value and
    give it the name `id`. In our method signature, we instruct JAX-RS to inject the
    value via the `@PathParam` annotation, giving us access to the user-specified
    `Note` ID in our method.
  prefs: []
  type: TYPE_NORMAL
- en: 'To retrieve the note from MongoDB, we get our first real glimpse of how one
    queries MongoDB:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'In a nutshell, pass `BasicDBObject` to the `find()` method on `collection`,
    which returns a `FindIterable<?>` object, on which we call `first()` to get what
    should be the only element returned (assuming there is one, of course). The interesting
    bits here are hidden in `buildQueryById()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Our query filter is defined using this `BasicDBObject`, which we initialize
    with a key and value. In this case, we want to filter by the `_id` field in the
    document, so we use that as a key, but note that we pass `ObjectId` as the value,
    and not just `String`. If we want to filter by more fields, we would append more
    key/value pairs to the `BasicDBObject` variable, which we will see later.
  prefs: []
  type: TYPE_NORMAL
- en: Once we've queried the collection and gotten the document the user requested,
    we convert it from `Document` to `Note` using the helper method on `Note`, and
    return it with a status code of 200 or `OK`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Updating a document in the database is a bit more complicated, but not excessively
    so, as you can see here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The first thing to notice is the HTTP method--`PUT`. There is some debate on
    what verb to use for updates. Some, such as Dropbox and Facebook, say `POST`,
    while others, such as Google (depending on which API you look at), say `PUT`.
    I would contend that the choice is largely up to you. Just be consistent in your
    choice. We will be completely replacing the entity on the server with what the
    client passes in, so the operation is idempotent. By choosing `PUT`, we can signal
    this fact to the client, making the API a bit more self-describing for clients.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the method, we start by setting the modified date to reflect the operation.
    Next, we call `Collection.updateOne()` to modify the document. The syntax is a
    little odd, but here's what's happening--we're querying the collection for the
    note we want to modify, then telling MongoDB to replace the loaded document with
    the new one we're providing. Finally, we query `UpdateResult` to see how many
    documents were updated. If none were, then the requested document doesn't exist,
    so we return `NOT_FOUND` (`404`). If it's non-zero, we return `OK` (`200`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, our delete method looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: We tell MongoDB to filter the collection using the same query filter we've seen
    before, then delete one document, which should be all it finds, of course, given
    our filter, but `deleteOne()` is a sensible safeguard. We could do a check like
    we did above in `updateNote()` to see if something was actually deleted, but there's
    little point--whether the document was there at the start of the request or not,
    it's not there at the end and that's our goal, so there's little to be gained
    from returning an error response.
  prefs: []
  type: TYPE_NORMAL
- en: We can now create, read, update, and delete notes, but the eagle-eyed among
    you may have noticed that anyone can read every note in the system. For a multi-user
    system, that's not a good thing, so let's fix that.
  prefs: []
  type: TYPE_NORMAL
- en: Adding authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Authentication systems can easily get extremely complex. From homegrown systems,
    complete with custom user management screens, to sophisticated single sign-on
    solutions, we have a lot of options. One of the more popular options is OAuth2,
    and there are a number of options. For Monumentum, we'll implement sign in using
    Google. To do that, we need to create an application in Google's Developer Console,
    which can be found at [https://console.developers.google.com](https://console.developers.google.com).
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you''ve logged in, click on the project dropdown at the top of page and
    click on Create Project, which should present this screen to you:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0b47b3bc-b9b4-459b-b9eb-89daf802242d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Provide Project Name, make your choices for the next two questions, then click
    on CREATE. Once the project has been created, you should be redirected to the
    Library page. Click on the Credentials link on the left, then click on Create
    credentials and select OAuth Client ID. If needed, fill out the OAuth Consent
    screen as directed. Select Web Application for Application Type, enter Name, and
    provide Authorized redirect URIs as shown in this screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dd5f9e8d-fedf-476c-bcf6-c0b60e913720.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Before this is moved to production, we will need to add a production URI to
    this screen, but this configuration will work in development just fine. When you
    click on Save, you will be shown your new client ID and client secret. Make note
    of these:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/38a25359-1dc1-4c80-acfc-ccd9054bf5f9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'With this data (note that these are not my actual ID and secret, so you''ll
    have to generate your own), we are ready to start working on our authentication
    resource. We''ll start by defining the resource as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to register this in our `Application`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'To work with the Google OAuth provider, we''ll need to declare a few instance
    variables and instantiate a few Google API classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The variables `clientId` and `clientSecret` will hold the values that Google
    just gave us. The other two classes are necessary for the process we''re about
    to walk through, and `SCOPES` holds the permissions we want from Google, which
    is just access to the user''s profile and email. The class constructor finishes
    the setup of these items:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The first part of the authentication flow is to create an authentication URL,
    which is done like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the JAX-RS class, `UriInfo`, we create a `URI` that points to another
    endpoint in our application, `/api/auth/callback`. We then pass that to `GoogleAuthorizationCodeFlow`
    to finish building our login URL. When the user clicks on the link, the browser
    will be directed to a login dialog from Google. Upon successful authentication,
    the user will be redirected to our callback URL, which is handled by this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'When Google redirects to our `callback` endpoint, it will provide a code that
    we can use to finish the authentication. We do that in the `getUserInfoJson()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Using the authentication code we just got from Google, we send another request
    to Google, this time to get the user information. When the request returns, we
    take the JSON object in the response body and use it to build a `User` object,
    which we return.
  prefs: []
  type: TYPE_NORMAL
- en: 'Back in our REST endpoint method, we call this method to save the user to the
    database, if needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Once we've gotten the user's information from Google, we no longer need the
    code as we do not need to interact with any other Google resources, so we do not
    persist it anywhere.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we want to return something to the client --some kind of token -- which
    can be used to prove the client's identity. To do that, we'll use a technology
    called a JSON Web Token, or JWT for short. JWT is *a JSON-based open standard
    (RFC 7519) for creating access tokens that assert some number of claims*. We'll
    create a JWT using the user's email address. We'll sign it with a key only the
    server uses, so we can safely pass it to the client, which will pass it back with
    each request. Since it must be encrypted/signed with the server key, untrustworthy
    clients will not be able to alter or forge the token successfully.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create JWTs, we need to add the library to our project as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then write this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The subject of the token is the email address, our API''s base address is the
    issuer, the expiration date and time is 12 hours in the future, and the token
    is signed by a key we generate with a new class, `KeyGenerator`. When we call
    `compact()`, a URL-safe String is generated, which we return to the caller. We
    can use the JWT debugger at [http://jwt.io](http://jwt.io/) to look inside the
    token:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2dbc46c7-26b5-4130-b8e1-3608c342acf1.png)'
  prefs: []
  type: TYPE_IMG
- en: Clearly, the claims in the token are readable, so don't store anything sensitive
    in them. What makes this secure is the use of a secret key when signing the token,
    making it impossible, in theory, to change its contents without detection.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `KeyGenerator` class used to give us our signing key looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The class is annotated with `@Singleton`, so the container guarantees that one
    and only one instance of this bean will exist in the system. The `getKey()` method
    will use the system property `signing.key` as the key, allowing the user to specify
    a unique secret when starting the system. Of course, completely random keys are
    safer, but that adds some complexity should we ever try to scale this system out
    horizontally. We would need all instances to use the same signing key so that
    JWTs can be validated regardless of what server the client is directed to. A data
    grid solution, such as Hazelcast, would be an appropriate tool for those situations.
    As it is now, this is sufficient for our needs here.
  prefs: []
  type: TYPE_NORMAL
- en: Our authentication resource is now complete, but our system has not actually
    been secured yet. To do that, we need to tell JAX-RS how to authenticate requests,
    and we'll do that with a new annotation and `ContainerRequestFilter`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we were to install a request filter with no additional information, it would
    apply to every resource, including our authentication resource. That would mean
    we''d have to authenticate in order to authenticate. Clearly that doesn''t make
    sense, so we need a way to discriminate between requests so that only requests
    for certain resources have this filter applied, and that means a new annotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ve defined an annotation that is semantically meaningful. The `@NameBinding`
    annotation tells JAX-RS to apply the annotation only to certain resources, which
    are bound by name (as opposed to dynamically bound at runtime). With the annotation
    defined, we need to define the other side of things, the request filter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: We start by defining a class that implements the `ContainerRequestFilter` interface.
    We have to annotate it with `@Provider` so that JAX-RS will recognize and load
    the class. We apply the `@Secure` annotation to associate the filter with the
    annotation. We'll apply this to the resource in a moment. Finally, we apply the
    `@Priority` annotation to instruct the system that this filter should be applied
    earlier in the request cycle.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the filter, we inject the same `KeyGenerator` we looked at earlier.
    Since this is a singleton, we are guaranteed that the key used here and in the
    authentication method are the same. The only method on the interface is `filter()`,
    and in this method, we get the Authorization header from the request, extract
    the Bearer token, which is the JWT, and validate it using the JWT API. If we can
    decode and validate the token, then we know the user has successfully authenticated
    against the system. To tell the system about this new filter, we need to modify
    our JAX-RS `Application` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The system knows about the filter now, but before it will do anything, we need
    to apply it to the resources that we want to secure. We do that by applying the
    `@Secure` annotation to the appropriate resources. It can either be applied at
    class level, which means that every endpoint in the class will be secured, or
    at the resource method level, which means that only those particular endpoints
    will be secured. In our case, we want every `Note` endpoint secured, so put the
    following annotation on the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Just a few more steps, and our application will be secured. We need to make
    some modifications to `NoteResource` so that it knows who is logged in, and so
    that notes are associated with the authenticated user. We will start by injecting
    `User`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'This is obviously not a container-managed class, so we need to write another
    `Producer` method. There''s a small bit of work to do there, so we''ll wrap that
    in its own class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'We define this as a request-scoped CDI bean, and inject our `KeyGenerator`,
    the `HttpServletRequest`, and our users collection. The actual work is done in
    the `Producer` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the Servlet request, we retrieve the `AUTHORIZATION` header. If it''s
    present and contains the `Bearer` string, we can process the token. If that condition
    is not true, we return null. To process the token, we extract the token value
    from the header, and then have `Jwts` parse the claims for us, which returns an
    object of type `Jws<Claims>`. We build the user in the `getUser()` method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: With the claims parsed, we can extract the subject and use it to query our `Users`
    collection, returning either the `User` if it is found, or `null` if not.
  prefs: []
  type: TYPE_NORMAL
- en: 'Back in our `NoteResource`, we need to modify our resource methods to be `User-aware`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: We now have a complete and secured REST API. Other than a command-line tool
    like curl, we don't have any nice way to use it, so let's build a user interface.
  prefs: []
  type: TYPE_NORMAL
- en: Building the user interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For a UI, we have a number of options. We''ve already looked at JavaFX and
    the NetBeans RCP in this book. While those are great options, we''ll do something
    a little different for this app and build a web-based interface. Even here, we
    have many, many options: JSF, Spring MVC, Google Web Toolkit, Vaadin, and more.
    Oftentimes, in real-world applications, while we may have a Java backend, we may
    have a JavaScript frontend, so that''s what we''ll do here, and that''s where
    your choices can get really dizzying.'
  prefs: []
  type: TYPE_NORMAL
- en: The two biggest players in that market at the time of the writing of this book
    are React from Facebook and Angular from Google. There are several smaller contenders,
    such as React API-compatible Preact, VueJS, Backbone, Ember, and so on. Which
    you choose will have a significant impact on the application, everything from
    architecture to the more mundane things such as building the project itself, or
    you could let architecture drive the framework if there's a compelling need for
    a specific architecture. As always, your particular environment will vary and
    should drive that decision more than what you read in a book or online.
  prefs: []
  type: TYPE_NORMAL
- en: Since this is a Java book, and I'd like to avoid getting too far into the intimate
    details of JavaScript build systems and alternate **JavaScript VM** languages,
    transpiling, and so on, I've chosen to use Vue, as it is a fast, modern, and popular
    framework that meets our needs, yet still allows us to build a simple system without
    requiring complicated build configurations. If you have experience with, or a
    preference for, another framework, it should be fairly simple for you to build
    a comparable system using the framework of your choice.
  prefs: []
  type: TYPE_NORMAL
- en: Note that I am *not* a JavaScript developer. The application we'll build in
    this part of the chapter should not be construed to be an example of best practices.
    It is merely an attempt to build a usable, albeit plain, JavaScript frontend to
    demonstrate a full stack application. Please consult the documentation for Vue
    or your framework of choice for details on how to build idiomatic applications
    with the tool.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with the index page. In the project explorer window in NetBeans,
    expand the Other Sources node, right-click on the webapp node, and select New
    | Empty File, giving it the name `index.html`. The bare minimum we need in the
    file at this point is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'This will display a blank page at the moment, but it does import the source
    for Vue, as well as the JavaScript for our client app, `index.js`, which we need
    to create:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'If we deploy those changes (HINT: If the app is already running, just press
    *F11* to tell NetBeans to build; that won''t make any Java changes take effect,
    but it will copy these static resources to the output directory) and refresh the
    page in the browser, we should now see *Hello, World!* on the page.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Roughly put, what''s happening is that we''re creating a new `Vue` object,
    anchoring to the (`el`) element with the `app` ID. We''re also defining some state
    for this component (`data`), which includes the single property, `message`. On
    the page, anywhere inside the element `app`, we can access the component''s state
    using the Mustache syntax we see in the index page--`{{ message }}`. Let''s expand
    our component a bit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ve added three items here:'
  prefs: []
  type: TYPE_NORMAL
- en: We've introduced a global data store, aptly called `store`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We've added a new property called `isLoggedIn`, which gets its value from a
    method call
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We've added a lifecycle method, `created`, which will load `Note` from the server
    when the component is created on the page
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Our data store is based on Vuex, a state-management pattern + library for `Vue.js`
    applications. It serves as a centralized store for all the components in an application,
    with rules ensuring that the state can only be mutated in a predictable fashion.
    ([https://vuex.vuejs.org](https://vuex.vuejs.org/)). To add it to our application,
    we need to add the following line of code to our page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'We then add a field called `store` to our component, which you can see in the
    preceding code. Most of the work so far takes place in the `NotesActions` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: When the page loads, the application will immediately send a request to the
    backend for Notes, sending the bearer token, if there is one, in the `Authorization`
    header. When the response returns, we update the state of the `isLoggedIn` property
    in the store, and, if the request was successful, we update the list of `Notes`
    on the page. Note that we're using `fetch()`. That is the new, experimental API
    for sending XHR, or Ajax, requests in browsers. As of the writing of this book,
    it is supported in every major browser except Internet Explorer, so be careful
    using this in production apps if you can't dictate the client's browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ve seen the store used a few times, so let''s take a look at it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The store is of type `Vuex.Store`, and we specify the various state fields
    in its `state` property. Handled properly, any Vue component bound to one of these
    state fields is automatically updated for you. You don''t need to track and manage
    state, manually reflecting changes on the page as the application state changes.
    Vue and Vuex handle that for you. Mostly. There are some situations, such as array
    mutation (or replacement), that require some special handling. Vuex offers **mutations**
    to help with that. For example, `NotesAction.fetchNotes()`, upon a successful
    request, we will make this call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code tells the store to `commit` a mutation called `setNotes`,
    with `notes` as the payload. We define mutations like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: What we are passing into this mutation (you can probably think of this as a
    function or a method with a peculiar invocation syntax if that helps) is a JSON
    array (hopefully, we show no type checking here), so we start by clearing out
    the current list of notes, then iterating over this array, creating and storing
    new objects, and reformatting some of the data as we do so. Strictly using only
    this mutation to replace the set of notes, we can guarantee that the user interface
    is kept in sync with the changing state of the application, all for free.
  prefs: []
  type: TYPE_NORMAL
- en: 'So how are these notes displayed? To do that, we define a new Vue component
    and add it to the page, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we''ve referenced a new component called `note-list`. We''ve bound the
    template variable `notes` to the application variable of the same name, and specified
    that the component is only displayed if the user is logged. The actual component
    definition happens in JavaScript. Back in `index.js`, we have this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'This component is named `note-list`; its template is found in an element with
    the `note-list-template` ID; it has two computed values: `notes` and `isLoggedIn`;
    and it provides two methods. In a typical Vue application, we would have a number
    of files, all ultimately compiled together using something like Grunt or Gulp,
    and one of these files would be our component''s template. Since we are trying
    to make this as simple as possible by avoiding the JS build processes, we have
    everything declared right on our page. In `index.html`, we can find the template
    for our component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Using a `script` tag with with the `text/x-template` type, we can add the template
    to the DOM without it rendering on the page. Inside this template, the interesting
    part is the `div` tag with the `note-list` class. We have the `v-` attribute on
    it, which means the Vue template processor will iterate over the `notes` list
    using this `div` as a template for displaying each `note` in the array.
  prefs: []
  type: TYPE_NORMAL
- en: Each note will be rendered using the `span` tag. Using the template markup `:title`,
    we are able to create a value for the title tag using our application state (we
    can't say because string interpolation was deprecated in Vue 2.0). The sole child
    of the `span` tag is the `{{ note.title }}` expression, which renders the title
    of the `note` list as a string. When the user clicks on the note title on the
    page, we want to react to that, so we bind the `onClick` handler to the DOM element
    via `v-on:click`. The function referenced here is the `loadNote()` function that
    we defined in the `methods` block of our component definition.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `loadNote()` function calls a mutation we haven''t looked at yet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'This mutation modifies the state to reflect the note that the user clicked
    on, then fires (or emits) an event called `note-clicked`. The event system is
    really quite simple. It is set up like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: That's literally it. This is just a bare bones, globally scoped Vue component.
    We fire events by calling `bus.$emit()` method, and register event listeners by
    calling the `bus.$on()` method. We'll see what that looks like in the note form.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will add the note form component to the page like we did the `note-list`
    component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'And, again, the component is defined in `index.js` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'The template is also in `index.html`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: This is mostly normal HTML form. The interesting bit is the v-model that ties
    the form element to the component's property. Changes made on the form are automatically
    reflected in the component, and changes made in the component (for example, via
    an event handler) are automatically reflected in the UI. We also attach an `onClick`
    handler via the now familiar `v-on:click` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: 'Did you notice the reference to `CKEDITOR` in our component definition? We''ll
    use the rich text editor `CKEditor` to provide a better experience. We could go
    to `CKEditor` and download the distribution bundle, but we have a better way--WebJars.
    The WebJars project takes popular client-side web libraries and packages them
    as JARs. This makes adding supported libraries to the project very simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'When we package the application, this binary jar is added to the web archive.
    However, if it''s still archived, how do we access the resources? There are a
    number of options depending on the type of application you are building. We''ll
    make use of Servlet 3''s static resource handling (anything under `META-INF/resources`
    that''s packaged in the web application''s `lib` directory are automatically exposed).
    In `index.html`, we add `CKEditor` to the page with this simple line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '`CKEditor` is now ready to use.'
  prefs: []
  type: TYPE_NORMAL
- en: 'One last major piece on the frontend is enabling the user to log in. To do
    that, we''ll create another component as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we will add the following component definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'And, finally, we will add the template as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: When this component is **mounted** (or attached to the element in the DOM),
    we call the `getAuthUrl()` function that sends an Ajax request to the server for
    our Google login URL. Once that's fetched, the login anchor tag is updated to
    refer to the URL.
  prefs: []
  type: TYPE_NORMAL
- en: There are a few more details in the JavaScript file we've not covered here explicitly,
    but interested parties can check out the source code in the repository and read
    through it for the remaining details. We do have a working JavaScript frontend
    for our note-taking app that supports listing, creating, updating, and deleting
    notes, as well as supporting multiple users. It's not a pretty application, but
    it works. Not bad for a Java guy!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we're back to the familiar refrain--our application is **finished**. What
    have we covered in the chapter? We've created a REST API using JAX-RS that doesn't
    require direct JSON manipulation. We've learned how to apply request filters to
    JAX-RS endpoints to restrict access to authenticated users, which we authenticate
    against their Google accounts using Google's OAuth2 workflow. We've packaged the
    application using Payara Micro, a great option to develop microservices, and we've
    integrated MongoDB into our application using the MongoDB Java API. Finally, we
    built a very basic JavaScript client using Vue.js to access our application.
  prefs: []
  type: TYPE_NORMAL
- en: There are a lot of new concepts and technologies interacting in this application,
    which makes it interesting from a technical perspective, but there's still more
    that could be done. The application could use a great deal of styling, and support
    for embedded images and videos would be nice, as would a mobile client. There
    is lots of room for improvements and enhancements with the app, but interested
    parties have a solid foundation to start from. Although, for us, it's time to
    turn to the next chapter and a new project, where we'll jump into the world of
    cloud computing with Functions as a Service.
  prefs: []
  type: TYPE_NORMAL
