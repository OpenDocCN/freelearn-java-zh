- en: '13'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Socket API and Simple Web Server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter includes 11 problems covering the Socket API and 8 problems covering
    JDK 18 **Simple Web Server** (**SWS**). In the first 11 problems we will discuss
    implementing socket-based applications such as blocking/non-blocking server/client
    applications, datagram-based applications, and multicast applications. In the
    second part of this chapter, we discuss SWS as a command-line tool and a suite
    of API points.
  prefs: []
  type: TYPE_NORMAL
- en: At the end of this chapter, you’ll know how to write applications via the Socket
    API and how to use SWS for testing, debugging, and prototyping tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Problems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Use the following problems to test your advanced programming prowess in Socket
    API and SWS. I strongly encourage you to give each problem a try before you turn
    to the solutions and download the example programs:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Introducing socket basics**: Provide a brief but meaningful introduction
    to socket basics and related context (TCP, UDP, IP, etc.).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Introducing TCP server/client applications**: Introduce the knowledge needed
    for writing a blocking/non-blocking TCP server/client application.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Introducing the Java Socket API**: Highlight the main Socket API (NIO.2)
    needed for writing socket-based applications in Java.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Writing a blocking TCP server/client application**: Provide a detailed example
    (theory and code) of a blocking TCP server/client application.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Writing a non-blocking TCP server/client application**: Provide a detailed
    example (theory and code) of a non-blocking TCP server/client application.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Writing UDP server/client applications**: Write a UDP server/client application
    including a connectionless client and a connected client.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Introducing multicasting**: Explain in simple terms the meaning of multicast.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Exploring network interfaces**: Write a snippet of code that displays details
    about the network interfaces available on your machine.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Writing a UDP multicast server/client application**: Explain and exemplify
    the implementation of a UDP multicast-based application.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Adding Key Encapsulation Mechanism (KEM) to a TCP server/client application**:
    Explain and exemplify the usage of JDK 21 KEM for encrypting/decrypting the communication
    in a TCP server/client application.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Reimplementing the legacy Socket API**: Provide a quick overview of the Socket
    API evolution among JDK releases.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Quick overview of SWS**: Provide a brief introduction to the JDK 18 SWS.
    Explain how it works and what its key abstractions are.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Exploring the SWS command-line tool**: Provide a step-by-step guide for starting,
    using, and stopping SWS via the command line.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Introducing the com.sun.net.httpserver API**: Describe the pillars of the
    SWS API.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Adapting request/exchange**: Provide a few snippets of code that adapt the
    SWS request/exchange for custom scenarios.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Complementing a conditional HttpHandler with another handler**: Write an
    example that shows how to conditionally choose between two `HttpHandler` instances.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Implementing SWS for an in-memory file system**: Write an SWS implementation
    that serves resources from an in-memory file system (for instance, the Google
    Jimfs in-memory file system or other similar solutions).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Implementing SWS for a zip file system**: Write an SWS implementation that
    serves resources from a ZIP archive.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Implementing SWS for a Java runtime directory**: Write an SWS implementation
    that serves resources from a Java runtime directory (JEP 220).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The following sections describe solutions to the preceding problems. Remember
    that there usually isn’t a single correct way to solve a particular problem. Also,
    remember that the explanations shown here include only the most interesting and
    important details needed to solve the problems. Download the example solutions
    to see additional details and to experiment with the programs at [https://github.com/PacktPublishing/Java-Coding-Problems-Second-Edition/tree/main/Chapter13](https://github.com/PacktPublishing/Java-Coding-Problems-Second-Edition/tree/main/Chapter13).
  prefs: []
  type: TYPE_NORMAL
- en: 258\. Introducing socket basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The socket notion was introduced in the ‘80s. This notion was introduced on
    **Berkeley Software Distribution** (**BSD**) (a Unix flavor) as a solution for
    network communication between processes via **Internet Protocol** (**IP**). Java
    introduced its first cross-platform API for sockets in 1996 (JDK 1.0). As you’ll
    see soon, with just a few notions such as network interface, IP address and port,
    a Java developer can write applications that communicate via sockets.
  prefs: []
  type: TYPE_NORMAL
- en: At the IP level, data travels from source to destination in chunks (*packets*)
    of data. Each packet is seen as an individual entity and there is no guarantee
    that all packets sent from a source will hit the destination. Nevertheless, on
    top of IP, we have other protocols that are more popular such as **Transmission
    Control Protocol** (**TCP**) and **User Datagram Protocol** (**UDP**). Moreover,
    on top of these protocols, we have the well-known HTTP, DNS, Telnet, and so on.
    Machine communication via sockets works on IP, so Java applications that use the
    Socket API can communicate with other socket-based applications (servers) based
    on their predefined protocol.
  prefs: []
  type: TYPE_NORMAL
- en: 'Every machine connected to the Internet is represented by a number or numerical
    label, which is commonly named the *IP address* of that machine. As Java developers,
    we should know that there are categories of IP addresses:'
  prefs: []
  type: TYPE_NORMAL
- en: IPv4 – IP addresses represented on 32 bits (for instance, `89.165.254.108`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: IPv6 – IP addresses represented on 128 bits (for instance, `2001:db8:3333:4444:5555:6666:7777:8888`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition, IP addresses are split into classes A, B, C, D, and E. For instance,
    class D of IP addresses ranges from `224.0.0.0` to `239.255.255.255` and is reserved
    for multicasting applications. And, of course, the `127.0.0.1` is a special IP
    reserved for *localhost*.
  prefs: []
  type: TYPE_NORMAL
- en: Now, speaking about ports, you should know that Java represents them as integers
    in the range `0`-`65535`. Some of the ports are famous and commonly associated
    with a certain type of server – for instance, port `80` is associated with an
    HTTP server, port `23` with a Telnet server, port `21` with an FTP server, and
    so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'While these notions have books that go deep into detail dedicated to them,
    we have enough information here to start writing server/client applications that
    rely on sockets. Practically, in such a server/client application, we have a server
    that runs on a host (a remote or localhost identified via an IP address and a
    port). While running, the server listens for incoming clients on a certain port.
    A client can locate the server via these two coordinates: the server IP address
    and the port. A client needs to present to the server a local port (automatically
    assigned by the kernel or explicitly set by us) that is used by the server to
    locate the client. A socket (client socket) is associated or bound to this local
    port and is used for communicating with the server. Upon acceptance, the server
    gets a socket (server socket) as well that is bound to a new local port (not the
    server port used for listening for incoming clients). Now, bidirectional communication
    can take place via these two sockets (endpoints).'
  prefs: []
  type: TYPE_NORMAL
- en: 259\. Introducing TCP server/client applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We don’t need to be TCP experts in order to write a Java server/client TCP-based
    application. While this topic (TCP) is detailed (very well-documented) in dedicated
    books and articles, let’s have a brief overview of TCP principles.
  prefs: []
  type: TYPE_NORMAL
- en: 'TCP’s goal is to provide a point-to-point communication mechanism between two
    endpoints. Once the connection between these two endpoints is established (via
    sockets) it remains open during the communication until one of the sides closes
    it (usually, the client). In other words, two processes that are on different
    machines or the same machine can communicate with each other as in a telephone
    connection. In the following figure, you can see a classical server-client session
    based on sockets:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.1.png](img/B19655_13_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.1: Server/client session based on sockets (TCP)'
  prefs: []
  type: TYPE_NORMAL
- en: 'A server/client TCP connection is represented by certain coordinates as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The server side is represented by its IP address and port
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The client side is represented by its IP address and port
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The server and client communicate via a protocol (UDP, TCP/IP, etc.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see in *Figure 13.1*, the server’s socket is bound and it listens
    for clients’ requests (the server can communicate with many clients at the same
    time). The client’s socket is bound and is ready to request a connection to the
    server. Once the connection is accepted, they can bidirectionally communicate
    (complete read/write operations) until the client closes the connection. The client
    can connect again later.
  prefs: []
  type: TYPE_NORMAL
- en: TCP (in contrast to UDP) is specialized in handling data packets being able
    to break data into packets, buffer data, and track-resend the lost or out-of-order
    data packets. Moreover, TCP is capable of controlling the speed of sending data
    in order to accommodate the processing capabilities of the receiver. TCP can send
    data as I/O streams of data or as byte arrays.
  prefs: []
  type: TYPE_NORMAL
- en: Blocking vs. non-blocking mechanisms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A Java TCP-based server/client application can be *blocking* or *non-blocking*.
    In a blocking application, a given thread is blocked until the I/O is completely
    received. So, the thread cannot do anything else until the I/O is ready to be
    processed – it will just hang on. On the other hand, in a non-blocking application,
    the I/O requests are queued and the thread is free to do other tasks. The queued
    requests will be processed later by the kernel.
  prefs: []
  type: TYPE_NORMAL
- en: From the Java implementation perspective, writing blocking applications is much
    easier than writing non-blocking applications. However, non-blocking applications
    are more performant and sustain scalability. NIO.2 supports both and we will implement
    both as well, but after a brief introduction to the Java Socket API.
  prefs: []
  type: TYPE_NORMAL
- en: 260\. Introducing the Java Socket API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Java Socket API support in Java has constantly evolved from JDK 1.0 to JDK 7\.
    Starting with JDK 7 and NIO.2, sockets support has been seriously improved with
    a new API (new classes and interfaces) for easily writing complex TCP/UDP-based
    applications. For instance, the `NetworkChannel` interface was introduced as a
    common implementation point for all network channel classes. Any class that implements
    `NetworkChannel` has access to common methods useful for handling channels to
    network sockets. Such classes are `SocketChannel`, `ServerSocketChannel`, and
    `DatagramChannel`. These classes take advantage of methods for handling local
    addresses and for configuring socket options via `SocketOption<T>` (interface)
    and `StandardSocketOptions` (class). Moreover, this API exposes methods for accessing
    remote addresses, checking connection status, and shutting down sockets.
  prefs: []
  type: TYPE_NORMAL
- en: One of the most important subinterfaces of `NetworkChannel` is `MulticastChannel`.
    This interface is implemented only by `DatagramChannel` and it knows how to map
    a network channel that is capable of providing IP multicasting. Anybody can get
    a membership key (like a token) that can be used to join a multicast group and
    become a member. The membership key is useful for customizing your presence in
    the multicast group (for instance, block or unblock datagrams based on their sender
    addresses).
  prefs: []
  type: TYPE_NORMAL
- en: Introducing NetworkChannel
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`NetworkChannel` provides methods that are common to all sockets, so `NetworkChannel`
    is a pillar of the Socket API. One of the most important methods exposed by `NetworkChannel`
    is `bind()`. As its name suggests, this method binds a socket channel to a local
    address (or in short, a socket is associated with a local address). More precisely,
    a socket is bound to a local address via an instance of `InetSocketAddress` –
    this class extends the `SocketAddress` (abstract class) and it maps a socket address
    as a hostname (IP)-port pair. The `bind()` method returns the bound socket channel
    (server socket channel, datagram socket channel, and so on). The returned channel
    was explicitly/manually bound to the given host port or automatically (if no host
    port is given):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The bound local address can be obtained via `getLocalAddress()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: If no address is present then this method returns `null`.
  prefs: []
  type: TYPE_NORMAL
- en: Tackling socket options
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A socket has several options represented via the `SocketOption<T>` interface.
    NIO.2 provides an implementation of `SocketChannel<T>` as a set of standard options
    via `StandardSocketOptions` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`IP_MULTICAST_IF`: Via this option, we set the `NetworkInterface` used by a
    bounded datagram-oriented socket (or simply, datagram socket) for multicast datagrams.
    We can set this option explicitly or allow the **operating system** (**OS**) to
    choose one (if any is available) by leaving this option as default (`null`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IP_MULTICAST_LOOP`: This is a flag option (defaults to `true`) that can be
    set for a bounded datagram socket to control the *loopback* (`true` means that
    the sent data should be looped back to your host) of multicast datagrams.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IP_MULTICAST_TTL`: This option applies to a bounded datagram socket. It is
    known as **time-to-live** (**TTL**) and is useful for setting the scope of multicast
    datagrams (setting the TTL for the multicast packets). By default, the value of
    this option is `1`, which means that multicast datagrams are not sent beyond the
    local network. The value of this option ranges between `0` and `255`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IP_TOS`: Via this option, we set the value of the **type-of-service** (**ToS**)
    octet in IP packets for IPv4\. It can be set anytime for a bounded datagram socket
    and its default value is `0`. Further information on the ToS octet can be found
    in RFC 2474 and RFC 1349 (the interpretation of the ToS octet is network-specific).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SO_BROADCAST`: This is a flag option that applies to a bounded datagram socket
    sending data to IPv4 broadcast addresses (defaults to `false`). When it is `true`,
    this option allows the transmission of broadcast datagrams.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SO_KEEPALIVE`: This is a flag option (defaults to `false`) that applies to
    a bounded socket for indicating if the connection should be kept alive by the
    OS or not.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SO_LINGER`: This option defines the so-called *linger interval* as an integer
    (timeout in seconds). The linger interval is specific to sockets that work in
    blocking mode only and it represents the timeout applied to the `close()` method.
    In other words, when the `close()` method is called on a socket, its execution
    will be blocked for this timeout (linger interval) while the OS attempts to transmit
    the unsent data (if it is possible). This option can be set at any time (by default,
    it has a negative value that is interpreted as disabled) and the maximum timeout
    is OS-specific.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SO_RCVBUF`: This option is a positive integer that can be set before the socket
    is bound/connected (defaults to an OS-dependent value). You need this option if
    you want to set the size of the networking input buffer (in bytes).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SO_SNDBUF`: This option is a positive integer that can be set before the socket
    is bound/connected (defaults to an OS-dependent value). You need this option if
    you want to set the size of the networking output buffer (in bytes).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SO_REUSEADDR`: Via this integer option, we can indicate if an address can
    be reused or not. For datagram multicasting (datagram sockets), this means that
    multiple programs can use (can be bound to) the same address. In the case of stream-oriented
    sockets (or simply, stream sockets), an address can be reused only if the previous
    connection is in the `TIME_WAIT` state (the socket is about to be closed by the
    OS but it still waits for the client side to send possible late communications).
    The default value for this option is OS-dependent and it should be set before
    the socket is bound/connected.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SO_REUSEPORT`: Via this integer option (available from JDK 9), we can indicate
    if a port can be reused or not. For datagram multicasting (datagram sockets) and
    stream sockets, this means that multiple sockets can use (can be bound to) the
    same port and address. The `SO_REUSEPORT` should be set before connecting/binding
    the socket; otherwise, the OS will deliver its default value for it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TCP_NODELAY`: This flag option (defaults to `false`) is used for enabling/disabling
    Nagle’s algorithm ([http://en.wikipedia.org/wiki/Nagle%27s_algorithm](http://en.wikipedia.org/wiki/Nagle%27s_algorithm)).
    It can be set at any time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Setting an option can be done via `NetworkChannel.getOption()` while getting
    an option can be done via `NetworkChannel.setOption()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Moreover, via `NetworkChannel`, we can obtain the options supported by a specific
    network socket via `supportedOptions()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Having this information in your hands, it is time to start writing out our first
    client/server socket-based application.
  prefs: []
  type: TYPE_NORMAL
- en: 261\. Writing a blocking TCP server/client application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this problem, we will write a blocking TCP server/client application. More
    precisely, let’s start with a single-thread blocking TCP echo server.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a single-thread blocking TCP echo server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to write a single-thread blocking TCP echo server, we will follow
    these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new server socket channel
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure the blocking mechanism
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the server socket channel options
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Bind the server socket channel
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Accept connections
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Transmit data over a connection
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Close the channel
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: So, let’s start with the first step.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new server socket channel
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Creating and opening a new server socket channel (stream-oriented listening
    socket) can be done via the thread-safe `java.nio.channels.ServerSocketChannel`
    API as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The resulting server socket channel is not bound/connected. However, it is
    open, and this can be verified via the `isOpen()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Next, let’s configure the blocking mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the blocking mechanism
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Once the server socket channel has been successfully opened, we can decide
    on the blocking mechanism. This can be done via the `configureBlocking()` method,
    which gets a boolean argument (`true` means a blocking server socket channel):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: A special type of channel (covered in subsequent problems) is `SelectableChannel`.
    Such a channel is returned by the `configureBlocking()` method (inherited from
    `AbstractSelectableChannel`) and is useful for achieving *multiplexing* via the
    `Selector` API. But, as I said, this is covered later.
  prefs: []
  type: TYPE_NORMAL
- en: Setting server socket channel options
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Since all options have default values, we can go with them out of the box or
    explicitly set only the ones that we need. For instance, let’s set the `SO_RCVBUF`
    and `SO_REUSEADDR` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The options supported for a server socket channel are available via `supportedOptions()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, you can simply print the supported options on the console.
  prefs: []
  type: TYPE_NORMAL
- en: Binding the server socket channel
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Binding the server socket channel to a local address is a very important step.
    We accomplish this via the `bind()` method – for instance, let’s bind our `serverSC`
    to localhost (`127.0.0.1`) and to the arbitrarily chosen port, `4444`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'If we omit the IP address and use the `InetSocketAddress` constructor that
    takes only the port argument then Java will rely on the *wildcard* IP address.
    This address is a special local IP dedicated for bind operations only and typically
    it is interpreted as *any*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: However, when you decide to use the wildcard IP address keep in mind the following
    note.
  prefs: []
  type: TYPE_NORMAL
- en: '**Important note**'
  prefs: []
  type: TYPE_NORMAL
- en: Pay attention that IP wildcard addresses may lead to undesirable complications
    in the presence of multiple network interfaces with separate IP addresses. If
    you are not prepared to handle such complications, then it is better to bind the
    socket to a specific network address, rather than to the IP wildcard.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we need to specify the socket address (`local_addr`) and the number of pending
    connections (`pending_c`), then we should rely on the following `bind()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Getting the bound local address (`SocketAddress`) can be done via `getLocalAddress()`.
    This method returns `null` if the socket has not been bound yet.
  prefs: []
  type: TYPE_NORMAL
- en: Accepting connections
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: So far, the server socket channel is open and bound. We are ready to accept
    the incoming clients. Since we set up the blocking mode, the application will
    be blocked until a connection is established (a client connection request is accepted)
    or an I/O error occurs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Accepting connections can be done via the `accept()` method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This method returns a `SocketChannel` representing the client socket channel
    (or simply, the socket channel associated with the new connection). The returned
    `SocketChannel` is a selectable channel for stream sockets.
  prefs: []
  type: TYPE_NORMAL
- en: '**Important note**'
  prefs: []
  type: TYPE_NORMAL
- en: If we call the `accept()` method for a server socket channel that it was not
    bound to yet, then we will get back a `NotYetBoundException` exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'The remote address (`SocketAddress`) to which this channel’s socket is connected
    is available via the `getRemoteAddress()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Next, let’s see how we can transmit data over this connection.
  prefs: []
  type: TYPE_NORMAL
- en: Transmitting data over a connection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'At this point, the two-way connection between the server and client is established
    and they can start transmitting data to each other. Each part can send/receive
    data packets mapped using the Java I/O streams or byte arrays. Implementing the
    communication protocol and choosing the proper API is quite flexible. For instance,
    we can rely on `ByteBuffer` to implement our echo server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'To support data transmission via `ByteBuffer`, `SocketChannel` exposes a set
    of `read()`/`write()` methods as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Read from a channel into the given buffer and return the number of bytes read
    (`-1` if the end of stream has been reached):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Write the bytes of a buffer into a channel and return the number of written
    bytes:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you prefer using the Java I/O API instead of manipulating multiple instances
    of `ByteBuffer`, then go for it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'When I/O streams are involved, we have to talk about shutting down a connection
    for I/O as well. Without closing the channel, a connection for I/O can be shut
    down via `shutdownInput()` and `shutdownOutput()`. The `shutdownInput()` method
    shuts down the connection for reading, while the `shutdownOutput()` method shuts
    down the connection for writing. Attempting to read from a closed reading connection
    (end of stream) will result in `-1`. On the other hand, attempting to write on
    a closed writing connection will result in a `ClosedChannelException` exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'On the other hand, if all you need is to check if a connection for I/O is open
    or not, this can be done via the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: These checks are useful before attempting to perform read/write operations via
    this connection for I/O.
  prefs: []
  type: TYPE_NORMAL
- en: Closing the channel
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Closing a channel can be done via the `close()` method. If we want to close
    a certain client socket channel, then we rely on `SocketChannel.close()` – this
    will not close the server (stop it listening for incoming clients). On the other
    hand, if we want to close the server to stop it listening for incoming clients,
    then simply call `ServerSocketChannel.close()` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Typically, you’ll close these resources in a *try-with-resources* block.
  prefs: []
  type: TYPE_NORMAL
- en: Putting it all together into the echo server
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The source code of our echo server can be obtained by chaining the previous
    snippets of code and adding some gluing code and comments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Next, let’s focus on developing a client for our echo server.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a single-thread blocking TCP client
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before writing a client, we have to define how it works. For instance, our
    client connects to the server and sends the *Hey!* text. Afterward, it continues
    sending random integers in the range 0-100 until the number 50 is generated and
    sent. Once 50 are sent, the client will close the channel. The server will simply
    echo each message received from the client. Now, based on this scenario, we can
    develop a client by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new (client) socket channel
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure the blocking mechanism
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the client socket channel
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Transmit data over a connection
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Close the channel
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let’s tackle the first step.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new (client) socket channel
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Creating and opening a new client socket channel (stream-oriented connecting
    socket) can be done via the thread-safe `java.nio.channels.SocketChannel` API
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The resulting client socket channel is not connected. However, it is open,
    and this can be verified via the `isOpen()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: However, a client socket channel can be opened and connected in a single step
    via the `open(SocketAddress)` flavor. Next, let’s configure the blocking mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the blocking mechanism
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Once the client socket channel has been successfully opened, we can decide
    on the blocking mechanism. This can be done via the `configureBlocking()` method,
    which gets a boolean argument (`true` means a blocking client socket channel):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Next, we set a few options for this client socket channel.
  prefs: []
  type: TYPE_NORMAL
- en: Setting client socket channel options
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following options are specific to a client socket channel: `IP_TOS`, `SO_RCVBUF`,
    `SO_LINGER`, `SO_OOBINLINE`, `SO_REUSEADDR`, `TCP_NODELAY`, `SO_KEEPALIVE`, and
    `SO_SNDBUF`. These options come with default values but they can be explicitly
    set as in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'A client socket channel reveals the supported options via `supportedOptions()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, you can simply print the supported options to the console.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting the client socket channel
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'After opening the client socket channel, we have to connect it to the server
    that listens for incoming clients on `127.0.0.1` and port `4444`. This can be
    done via the `connect()` method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Since this is a blocking client, the application blocks until a connection to
    this remote address is established or an I/O error occurs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Until transmitting data (sending/receiving data packets), you should ensure
    that the connection is available via `isConnected()` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Moreover, keep in mind the following note:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Important note**'
  prefs: []
  type: TYPE_NORMAL
- en: In our simple example, the server and the client run on the same machine (`localhost/127.0.0.1`).
    However, in reality, you should avoid hard-coding IP addresses and use the server
    hostname in place of its IP address. Since IP addresses can be changed and/or
    dynamically assigned via services such as DHCP, you should rely on hostnames (eventually
    configured via DNS).
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s see how we can send and receive data to/from the server.
  prefs: []
  type: TYPE_NORMAL
- en: Transmitting data over a connection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'First, we send the text *Hey!*. Afterward, we send integers between 0 and 100
    until the integer 50 is generated. At the API level, we rely on `ByteBuffer`/`CharBuffer`
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we use `ByteBuffer` for sending/receiving data and `CharBuffer`
    for decoding the data received from the server.
  prefs: []
  type: TYPE_NORMAL
- en: Closing the channel
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Disconnecting the client from the server (closing the client socket channel)
    can be done via the `close()` method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Typically, you’ll close these resources in a *try-with-resources* block.
  prefs: []
  type: TYPE_NORMAL
- en: Putting it all together into the client
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The source code of our client can be obtained by chaining the previous snippets
    of code and adding some gluing code and comments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Finally, let’s test our server/client application.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the blocking echo application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, start the server application. Second, start the client application and
    check out the console output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: You can even start a few clients at the same time to see how it works. The server
    will display the remote address of each client.
  prefs: []
  type: TYPE_NORMAL
- en: 262\. Writing a non-blocking TCP server/client application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this problem, we will write a non-blocking TCP server/client application.
  prefs: []
  type: TYPE_NORMAL
- en: A non-blocking socket (or a socket in non-blocking mode) allows us to perform
    I/O operations on socket channels without blocking the processes that are using
    it. The major steps of a non-blocking application are exactly the same as for
    a blocking application. The server is opened and bound to a local address ready
    to handle incoming clients. A client is opened and connected to the server. From
    this point forward, the server and the client can exchange data packets in a non-blocking
    fashion.
  prefs: []
  type: TYPE_NORMAL
- en: When we refer to exchanging data in a non-blocking fashion, we refer to the
    pillar of non-blocking technology, which is the `java.nio.channels.Selector` class.
    The role of the `Selector` is to orchestrate data transfer across multiple available
    socket channels. Basically, a `Selector` can monitor every single recorded socket
    channel and detect the channels that are available for data transfer in order
    to handle the clients’ requests. In addition, a `Selector` is capable of handling
    multiple sockets’ I/O operations via a single thread. This is possible via a concept
    known as *multiplexing*. So, instead of having a thread per socket connection,
    *multiplexing* allows the usage of a single thread for multiple socket connections.
    The `Selector` is known and referred to as the *multiplexor* of a `SelectableChannel`
    that is registered via the `register()` method of `SocketChannel` or `ServerSocketChannel`
    (subclasses of `SelectableChannel`). The `Selector` and the `SelectableChannel`
    are deregistered/deallocated together.
  prefs: []
  type: TYPE_NORMAL
- en: Using the SelectionKey class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is time to take a step further and introduce the `SelectionKey` class. A
    channel is registered with a `Selector` via an instance of `java.nio.channels.SelectionKey`
    and all the `SelectionKey` instances are known as selection keys. A selection
    key acts as a helper for the selector being used to sort the requests of a client.
    Practically, a selection key carries information (metadata) about a single client
    subrequest such as the type of subrequest (connect, write, read, and so on) and
    information needed to uniquely identify the client.
  prefs: []
  type: TYPE_NORMAL
- en: 'During the registration of a `SelectableChannel` with a `Selector`, we point
    out the set of operations for which the key’s channel will be monitored by this
    selector – this is known as the *interest set*. When an operation becomes eligible
    to be performed, it becomes part of the so-called *ready set* (this set is initialized
    with 0 when the key is created). So, a selection key handles two operation sets
    (*interest set* and *ready set*) represented as integer values. Each bit of an
    operation set represents a category of selectable operations that are supported
    by the key’s channel. A key can be of one of the following types:'
  prefs: []
  type: TYPE_NORMAL
- en: '`SelectionKey.OP_ACCEPT` (*acceptable*): Bit for marking socket-accept operations'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SelectionKey.OP_CONNECT` (*connectable*): Bit for marking socket-connect operations'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SelectionKey.OP_READ` (*readable*): Bit for marking read operations'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SelectionKey.OP_WRITE` (*writable*): Bit for marking write operations'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A selector must handle three sets of selection keys as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*key-set*: Contains all the keys of the currently registered channel.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*selected-key*: Every key that is ready for at least one of the operations
    from the key’s *interest set* is part of the *selected-key*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*canceled-key*: This contains all the keys that have been canceled but still
    have registered channels.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Important note**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: When a selector is created, these three sets are empty. Pay attention that the
    `Selector` instances are thread-safe, but their key sets however are not.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: When some action takes place, the selector wakes up. It starts creating the
    `SelectionKey`, where each such key contains information about the current request.
  prefs: []
  type: TYPE_NORMAL
- en: The selector waits for the recorded events (for instance, incoming connection
    requests) in an infinite loop. Commonly, the first line of this loop is `Selector.select()`.
    This is a blocking call that takes place until the `Selector.wakeup()` method
    is called, at least one channel is selectable, or the current thread gets interrupted.
    There is also a `select(long timeout)` method that works as `select()` but with
    a timeout. In addition, we have `selectNow()`, which is non-blocking – if there
    are no selectable channels, then `selectNow()` returns `0` immediately.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s assume that the selector waits for a connection attempt. When a client
    attempts to connect, the server checks the type of each key created by the selector.
    If the type is `OP_ACCEPT` (acceptable key) then the `SelectionKey.isAcceptable()`
    method takes action. When this method returns `true` the server locates the client
    socket channel via the `accept()` methods. In addition, it sets this socket channel
    as non-blocking and registers it to the selector as eligible for `OP_READ` and/or
    `OP_WRITE` operations. While processing the keys created by the selector the server
    removes them from the list (an `Iterator` over these keys) in order to prevent
    the re-evaluation of the same key.
  prefs: []
  type: TYPE_NORMAL
- en: So far, the client socket channel is registered to the selector for read/write
    operations. Now, if the client sends (writes to the channel) some data on the
    socket channel then the selector will inform the server side that it should/can
    read that data (in this scenario, the `SelectionKey.isReadable()` method, returns
    `true`). On the other hand, when the client receives (reads) some data from the
    server, the `SelectionKey.isWritable()` method returns `true`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram highlights the selector-based non-blocking flow:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.2.png](img/B19655_13_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.2: The selector-based non-blocking flow'
  prefs: []
  type: TYPE_NORMAL
- en: '**Important note**'
  prefs: []
  type: TYPE_NORMAL
- en: In non-blocking mode, we may face the so-called *partial read/write*. This means
    that an I/O operation has partially transferred (read or written) some data (fewer
    bytes) or no data at all (0 bytes).
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s briefly cover the `Selector` methods.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Selector methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before coding a non-blocking TCP server/client application, we have to know
    a few built-in methods that sustain our goal:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Selector.open()`: This creates and opens a new selector.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Selector.select()`: This is a blocking operation that selects a set of keys.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Selector.select(long t)`: This works exactly as `select()`, but with a timeout
    specified in milliseconds. If there is nothing to select during `t`, then this
    method returns `0`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Selector.selectNow()`: This is a non-blocking version of `select()`. If there
    is nothing to select, then this method returns `0`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Selector.keys()`: This returns `Set<SelectionKey>` (selector’s key set).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Selector.selectedKeys()`: This returns `Set<SelectionKey>` (selector’s selected
    key set).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Selector.wakeup()`: The first selection operation (which has not yet returned)
    will return immediately.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SelectionKey.isReadable()`: This checks if this key’s channel is ready for
    reading.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SelectionKey.isWritable()`: This checks if this key’s channel is ready for
    writing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SelectionKey.isValid()`: This checks this key’s validity. An invalid key is
    canceled, its selector is closed, or its channel is closed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SelectionKey.isAcceptable()`: If this method returns `true`, then a new socket
    connection will be accepted by this key’s channel.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SelectionKey.isConnectable()`: This checks if this key’s channel has successfully
    finished or failed to finish its current socket connection operation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SelectionKey.interestOps()`: This returns this key’s *interest set*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SelectionKey.interestOps(t)`: This sets this key’s *interest set* to `t`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SelectionKey.readyOps()`: This returns this key’s *ready-operation set*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SelectionKey.cancel()`: This cancels the registration of this key’s channel
    with its selector.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Registering a channel with a given selector can be done via the `register()`
    method of `ServerSocketChannel` and `SocketChannel`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The `s` argument is the given selector. The `p` argument is the *interest set*
    for the selection key, and the `a` argument is the attachment for the selection
    key (may be `null`).
  prefs: []
  type: TYPE_NORMAL
- en: Writing the non-blocking server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Based on the previous information, we can write the following non-blocking
    echo server (the code may look a little bit large, but it is sprinkled with helpful
    comments):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have the infinite loop of the `Selector`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Further, we have a set of helpers responsible for accepting connections and
    performing read/write operations. First, we have the `acceptOperation()` helper:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The helpers for read/write operations are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have to call the `startEchoServer()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Next, let’s focus on writing the client for our non-blocking echo server.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the non-blocking client
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The main structure of the non-blocking client is the same as the structure
    of the non-blocking server. However, there are a few things that are not the same
    and they deserve a brief overview as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The client socket channel must be registered with the `SelectionKey.OP_CONNECT`
    operation. This is needed because the client must be informed by the selector
    when the non-blocking server accepts its connection request.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While the server side may wait for incoming clients infinitely, a client cannot
    attempt to connect in the same way. In other words, a client will rely on `Selector.select(long
    timeout)`. A timeout that ranges from 500 to 1,000 ms should do the job.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The client is also responsible for checking if the key is connectable via `SelectionKey.isConnectable()`.
    If this method returns `true`, then the client joins the `isConnectionPending()`
    and `finishConnect()` APIs in a conditional statement. This construction is needed
    for closing any pending connections. Practically, the `isConnectionPending()`
    method tells us if there is any connection operation in progress on the current
    client channel, while the `finishConnect()` method will finish the process of
    connecting a socket channel.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, we are ready to list the client code, which follows the same scenario
    as in the previous problem (we send the *Hey!* text followed by random integers
    ranging from 0 to 100 until the number 50 is generated):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we are ready to wait to connect to the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the client is connected, it can read/write data from/to the server side:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Finally, let’s test our non-blocking application.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the non-blocking echo application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, start the server side. Afterward, start a few clients and check each
    console output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.3.png](img/B19655_13_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.3: A possible output of our non-blocking server'
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that this is not a multithreading application. It is just a single-threaded
    application that relies on the *multiplexing* technique.
  prefs: []
  type: TYPE_NORMAL
- en: 263\. Writing UDP server/client applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: UDP is a protocol built on top of IP. Via UDP, we can send data packets of at
    most 65,507 bytes (that is, 65,535-byte IP packet size – plus the minimum IP header
    of 20 bytes – plus the 8-byte UDP header = 65,507 bytes total). In UDP, data packets
    are seen as individual entities. In other words, no packet is aware of others.
    Data packets may arrive in any order or may not arrive at all. The sender will
    not be informed about the lost packets, so it will not know what to resend. Moreover,
    data packets may arrive too fast or too slow, so processing them may be a real
    challenge.
  prefs: []
  type: TYPE_NORMAL
- en: While TCP is famous for high-reliability data transmissions, UDP is famous for
    low-overhead transmissions. So, UDP is more like sending a letter (remember that
    TCP is like a phone call). You write on the envelope the address of the receiver
    (here, the remote IP and port) and your address (here, local IP and port) and
    send it (here, over the wires). You don’t know if the letter will ever arrive
    at the receiver (here, the sender cannot trace the routes of the packets) and
    if you send more letters you cannot control the order of their arrival (here,
    an old packet can arrive after a more recent packet). In this context, UDP fits
    well if all you care about is speed. So, if you can afford losing packets and
    the order of receiving them is not important then UDP might be the right choice.
    For instance, an application that should send the state of a sensor every *n*
    milliseconds may take advantage of the UDP protocol.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a single-thread blocking UDP echo server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to write a single-thread blocking UDP echo server, we will follow
    these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a server datagram-oriented socket channel
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set datagram-oriented socket channel options
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Bind the server datagram-oriented socket channel
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Transmit data packets
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Close the channel
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let’s start with the first step.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a server datagram-oriented socket channel
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The climax of a server/client UDP application is represented by a thread-safe
    selectable channel dedicated to working with datagram-oriented sockets (or simply,
    datagram sockets). In API terms, this is referred to as `java.nio.channels.DatagramChannel`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Such a channel can be obtained via `DatagramChannel.open()`, which gets a single
    parameter of the type `java.net.ProtocolFamily`. The protocol family implementation
    (`java.net.StandardProtocolFamily`) has two possible values:'
  prefs: []
  type: TYPE_NORMAL
- en: '`StandardProtocolFamily.INET`: IP version 4 (IPv4)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`StandardProtocolFamily.INET6`: IP version 6 (IPv6)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next, we focus on the datagram socket for IPv4, so we call the `open()` method
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: If you don’t care about the protocol family, then you can call the `open()`
    method without arguments. In that case, the protocol family is platform-dependent.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before going further, we can check if a datagram socket is open via the `isOpen()`
    flag method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: A client datagram socket can be opened in the same manner as a server datagram
    socket.
  prefs: []
  type: TYPE_NORMAL
- en: Setting datagram-oriented socket channel options
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The options supported by a datagram socket channel are `SO_BROADCAST`, `IP_TOS`,
    `IP_MULTICAST_LOOP`, `IP_MULTICAST_TTL`,`SO_SNDBUF`, `SO_REUSEADDR`, `IP_MULTICAST_IF`,
    and `SO_RCVBUF`. Here are some examples of setting a few of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The supported options are available via `supportedOptions()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Next, let’s bind the server datagram socket.
  prefs: []
  type: TYPE_NORMAL
- en: Binding the server datagram-oriented socket channel
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Before listening for connections, the server datagram socket channel should
    be bound to a local address via the `bind()` method. Here, we have *localhost*
    (`127.0.0.1`) and the arbitrarily chosen port `4444`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: If we go for `bind(null)`, then the local address will be automatically assigned.
    We can discover the local address via the `getLocalAddress()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Transmitting data packets
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The datagram-based echo server is almost ready. We can start sending and receiving
    packets in a connectionless fashion (UDP is a connectionless network protocol).
    This can be done via `send()` and `receive()` methods. The `send()` method gets
    the data to be sent as a `ByteBuffer` and the remote address and returns the number
    of bytes sent. The official documentation gives us the best explanation of how
    it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '*If this channel is in non-blocking mode and there is sufficient room in the
    underlying output buffer, or if this channel is in blocking mode and sufficient
    room becomes available, then the remaining bytes in the given buffer are transmitted
    as a single datagram to the given target address. This method may be invoked at
    any time. If another thread has already initiated a write operation upon this
    channel, however, then an invocation of this method will block until the first
    operation is complete. If this channel’s socket is not bound then this method
    will first cause the socket to be bound to an address that is assigned automatically,
    as if by invoking the* *bind() method with a parameter of null.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, the `receive()` method gets the `ByteBuffer` where you are
    expecting to find the received datagram. The datagram’s source address is the
    return of this method and it can be used to send back an answer packet (if this
    method returns `null`, it means that the channel is in non-blocking mode and no
    datagram is immediately available). Again, the official documentation gives us
    the best explanation of how this method will act:'
  prefs: []
  type: TYPE_NORMAL
- en: '*If a datagram is immediately available, or if this channel is in blocking
    mode and one eventually becomes available, then the datagram is copied into the
    given byte buffer and its source address is returned. If this channel is in non-blocking
    mode and a datagram is not immediately available then this method immediately
    returns null. This method may be invoked at any time. If another thread has already
    initiated a read operation upon this channel, however, then an invocation of this
    method will block until the first operation is complete. If this channel’s socket
    is not bound then this method will first cause the socket to be bound to an address
    that is assigned automatically, as if by invoking the bind() method with a parameter
    of null.*'
  prefs: []
  type: TYPE_NORMAL
- en: The remote address can be discovered via `getRemoteAddress()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our blocking echo server listens for packets in an infinite loop. When a packet
    is available (has arrived on the server), we extract from it the data and the
    address of the sender (the remote address). We use this address to send back the
    same data (to echo):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Closing the channel
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Disconnecting the datagram socket channel can be done via the `close()` method
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Typically, you’ll close these resources in a *try-with-resources* block.
  prefs: []
  type: TYPE_NORMAL
- en: Putting it all together into the client
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The source code of our server can be obtained by chaining the previous snippets
    of code and adding some gluing code and comments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Next, let’s focus on writing a client for the echo server.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a connectionless UDP client
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In implementation terms, writing a connectionless UDP client is almost the
    same as writing the server side. We create a `DatagramChannel`, set the needed
    options, and we are ready to go (ready to send/receive data packets). Notice that
    a datagram client doesn’t need to be bound (but it can be) to a local address
    because the server can extract the IP/port pair from each data packet – the server
    knows where the client lives. However, if the server was bound via `bind(null)`
    (so, automatically bound) then the client should know the assigned server IP/port
    pair (server address). Of course, the reverse is also true: if the server is the
    first one sending a data packet (in this case, the client should be bound).'
  prefs: []
  type: TYPE_NORMAL
- en: 'In our case, the client is aware that the echo server listens on `127.0.0.1`/`4444`,
    so it can send the first data packet via the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Finally, let’s test our blocking server/client datagram-based application.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the UDP connectionless echo application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For testing our application, we start the server, which will output these messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we start the client, which sends the text *Echo: I’m a great server!*
    to the server. The client will output the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The server will receive this datagram and send it back:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The client will wait for the server to echo for 5 seconds (arbitrarily chosen
    timeout). Since the server will echo the received datagram, the client will get
    it back and print it to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: At this moment, the client is stopped and the server continues to wait for incoming
    datagrams. So, don’t forget to manually stop the server.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a connected UDP client
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Besides the connectionless `send()` and `receive()` methods, the Java API also
    supports the `read()` and `write()` methods. These methods work only for a connected
    UDP client and are based on `ByteBuffer` for holding the read/write data. A connected
    UDP client (in contrast with a connectionless one) relies on a socket channel
    that allows interactions (sending/receiving datagrams) only with the given remote
    peer address. The client datagram socket remains connected. It must be explicitly
    closed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Connecting a UDP client is accomplished via the `connect()` method, which takes
    as arguments the server-side remote address:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Since UDP is a connectionless protocol, the `connect()` method doesn’t exchange
    any data packets with the server across the network. The method returns immediately
    without actually blocking the application. Mainly, the `connect()` method can
    be called at any time since it doesn’t affect the currently processed read/write
    operations. Its goal is to bind this socket channel (if it is not) to an automatically
    assigned address (it’s like calling `bind(null)`).
  prefs: []
  type: TYPE_NORMAL
- en: 'The connection status can be obtained via `isConnected()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'In this context, writing a UDP-connected client for our UDP echo server can
    be done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Testing this client is straightforward. First, start the server. Second, start
    the client and check out the console output.
  prefs: []
  type: TYPE_NORMAL
- en: 264\. Introducing multicasting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Multicasting is like a flavor of internet broadcasting. We know that a TV station
    can broadcast (share) its signal from the source to all its subscribers or to
    everybody in a certain area. The exceptions are represented by the people who
    don’t have the proper receiver (equipment) or aren’t interested in this TV station.
  prefs: []
  type: TYPE_NORMAL
- en: From a computer perspective, the TV station can be considered a source that
    sends datagrams to a group of listeners/subscribers or simply destination hosts.
    While point-to-point communication is possible via the *unicast transport service*,
    in multicasting (sending datagrams from a source to multiple destinations in a
    single call) we have the *multicast transport service*. In the case of the *unicast
    transport service*, sending the same data to multiple points is possible via the
    so-called *replicated unicast* (practically each point receives a copy of the
    data).
  prefs: []
  type: TYPE_NORMAL
- en: In multicasting terms, the receivers of multicasted datagrams are known as a
    *group*. This group is uniquely identified by an IP of class D (224.0.0.0-239.255.255.255).
    A new client can listen and receive the multicasted datagrams only after it gets
    connected to the group via the corresponding IP address. There are multiple domains
    where multicasting is useful such as data-sharing management, conferencing, email
    groups, advertising, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Java (NIO.2) shapes multicasting via the `MulticastChannel` interface (a subinterface
    of `NetworkChannel`), which has a single implementation named `DatagramChannel`.
    This interface exposes two `join()` methods as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: A client who wants to join a multicast group must call one of these `join()`
    methods. The first `join()` method requires the IP address of the multicasting
    group and a network interface capable of performing multicasting. The second `join()`
    method has an additional argument (`InetAddress s`) for indicating a source address
    from which group members can begin receiving datagrams. Since membership is *cumulative*,
    we can use multiple sources with the same group and network interface.
  prefs: []
  type: TYPE_NORMAL
- en: If a client manages to join a multicasting group, then it gets back a `MembershipKey`
    instance, which acts as a token, useful for performing different actions in that
    group.
  prefs: []
  type: TYPE_NORMAL
- en: '**Important note**'
  prefs: []
  type: TYPE_NORMAL
- en: A multicast channel can join multiple groups. Moreover, a multicast channel
    can join the same group on more than one network interface.
  prefs: []
  type: TYPE_NORMAL
- en: Leaving a multicast group can be done at any moment via the `close()` method.
  prefs: []
  type: TYPE_NORMAL
- en: A brief overview of MembershipKey
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The most common actions that can be performed by a client of a multicast group
    via the `MembershipKey` instance are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Block/unblock**: By calling the `block()` method with a source address, we
    can block datagrams sent from that source. On the other hand, we can unblock a
    source via the `unblock()` method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Get group**: The `group()` method returns the source address (`InetAddress`)
    of the group where the current membership key was created.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Get channel**: The `channel()` method returns the channel (`MulticastChannel`)
    of the group where the current membership key was created.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Get source address**: For a source-specific membership key (receive datagrams
    only from that source), the `sourceAddress()` method returns the source address
    (`InetAddress`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Get network interface**: The network interface of this membership key (`NetworkInterface`)
    is available via `networkInterface()`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Check validity**: If a membership key is valid, then the `isValid()` method
    returns `true`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Drop**: Dropping membership (no longer receiving datagrams from this group)
    can be done via the `drop()` method. Typically, a membership key becomes valid
    after creation and remains like this until the `drop()` method is called or the
    channel is closed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, let’s talk about network interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: 265\. Exploring network interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Java, a network interface is represented by the `NetworkInterface` API. Basically,
    a network interface is identified by a name and a list of IPs that are assigned
    to it. Via this information, we can associate a network interface with different
    network tasks such as a multicast group.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following snippet of code lists all network interfaces that are available
    on your machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'For each network interface, we print at the console the display name (this
    is just a human-readable text that describes the network interface) and the name
    (this is useful to identify the network interface by name). In addition, we check
    if the network interface is virtual (if it is practically a subinterface), supports
    multicast, and is up and running. Running this application on my machine has returned
    multiple network interfaces, and in the following figure, there is a screenshot
    that shows a network interface that supports multicast (`ethernet_32775`):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.4.png](img/B19655_13_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.4: A multicast network interface'
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s see how we can use `ethernet_32775`to write a server/client multicast
    application.
  prefs: []
  type: TYPE_NORMAL
- en: 266\. Writing a UDP multicast server/client application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In *Problem 263*, we developed a UDP server/client application. So, based on
    that experience, we can go further and highlight the main aspects that can transform
    a classical UDP-based application into a multicast one.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, let’s assume that we want to write a multicast server that sends
    to the group (to all members interested in receiving datagrams from this server)
    a datagram that encapsulates the current date-time on the server. This datagram
    is sent every 10 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a UDP multicast server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Writing a UDP multicast server starts with a new `DatagramChannel` instance
    obtained via the `open()` method. Next, we set the `IP_MULTICAST_IF` option (used
    to indicate the multicast network interface) and the `SO_REUSEADDR` option (used
    to allow multiple members to bind to the same address – this should be done before
    binding the socket):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we call the `bind()` method to bind the channel’s socket to the local
    address:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we need the code for transmitting the datagram containing the date-time
    of the server. We have arbitrarily chosen `225.4.5.6` as the IP address of the
    multicast group. Gluing everything together results in the following server code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Next, let’s write a client interested in receiving datagrams from this server.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a UDP multicast client
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Writing a UDP multicast client is not very different from writing a multicast
    server. However, there are some differences – for instance, we may want to check
    via `isMulticastAddress()` if the remote address (the address from where we receive
    datagrams) is a multicast address. Next, a client must join the multicast group,
    so it must call one of the `join()` methods described earlier in *Problem 264*.
    Finally, the implementation should be written to receive datagrams as in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Next, let’s talk about blocking/unblocking datagrams.
  prefs: []
  type: TYPE_NORMAL
- en: Blocking/unblocking datagrams
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As you already know, blocking datagrams from a certain multicast group can
    be done via the `block()` method, while unblocking via the `unblock()` method.
    Here is a snippet of code that blocks a list of addresses that we don’t like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, if you have a list of addresses that you like, then you can connect to
    all of them as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Finally, let’s test our application.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the multicasting server/client application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, start the server and wait until you see the following message in the
    console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you can start one or more instances of the client. At every 10 seconds,
    the server will send a datagram marked by the *Sending date-time ...* message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Every client that joined this multicast group will receive the datagrams from
    the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Done! Notice that this application suffers from some shortcomings. For instance,
    the server and the client are not aware of each other. The server sends datagrams
    even if no client is listening, and the client may wait for datagrams even if
    the server is offline. Challenge yourself to address these shortcomings by adding
    more control to each side. Moreover, feel free to experiment with blocking/non-blocking
    modes and connectionless/connected features for multicast applications.
  prefs: []
  type: TYPE_NORMAL
- en: 267\. Adding KEM to a TCP server/client application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this problem, we attempt to write a TCP server/client application that communicates
    with each other via encrypted messages. The server side is referred to as the
    sender and the client as the receiver.
  prefs: []
  type: TYPE_NORMAL
- en: In this context, a sender can encrypt a message using its private key, and the
    receiver decrypts it using the sender’s public key. In case you didn’t recognize
    this scenario, then allow me to mention that we are talking about **Authenticated
    Key Exchange** (**AKE**) within **Public Key Encryption** (**PKE**) or, in short,
    about encrypting/decrypting messages based on the key exchange algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: AKE within PKE is a popular choice, but it is not secure. In other words, AKE
    vulnerabilities can be speculated by quantum computers that are capable of altering
    most key exchange algorithms. JDK 21 can prevent such issues via the newly introduced
    KEM ([https://en.wikipedia.org/wiki/Key_encapsulation_mechanism](https://en.wikipedia.org/wiki/Key_encapsulation_mechanism)).
    This is a final feature delivered as JEP 452.
  prefs: []
  type: TYPE_NORMAL
- en: KEM schemes rely on a private-public keypair and, additionally, on a common
    secret key. KEM works on the following steps.
  prefs: []
  type: TYPE_NORMAL
- en: Generating a public-private keypair by the receiver
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The receiver (client) generates a private-public keypair via the old-school
    approach known as the `KeyPairGenerator` API. The public key is obtained via `getPublic()`
    and the private key via `getPrivate()`. Here, we generate the keypairs for **Diffie-Hellman**
    (**DH**) key exchange with *Curve25519* as defined in RFC 7748:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: For now, we need only the public key.
  prefs: []
  type: TYPE_NORMAL
- en: Transmitting the public key to the sender
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Next, the receiver sends the previously generated public key to the sender.
    This is done via the receiver’s `SocketChannel`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: The sender needs the receiver’s public key to generate a secret key.
  prefs: []
  type: TYPE_NORMAL
- en: Generating the common secret key by the sender
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, the sender needs to reconstruct the receiver’s `PublicKey` instance
    from the received `byte[]` and for this, it can use the `KeyFactory` API as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'The `buffer.array()` represents the `byte[]` containing the bytes of the public
    key. With the `PublicKey` in hand, the sender can rely on the KEM scheme to obtain
    the secret key. It starts by using the `KEM` class from JDK 21, which provides
    the functionality of a KEM:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: The DHKEM built-in algorithm is an advanced version of the DH algorithm ([https://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange](https://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, the sender creates an `Encapsulator` and calls the `encapsulate()` method
    (known as the key encapsulation function), which generates (at each call) a secret
    key and a key encapsulation message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: If we call the `encapsulate()` method without arguments, then this is equivalent
    to `encapsulate(0, encorSender.secretSize(), "Generic")`. But, as you can see,
    we preferred the `AES` algorithm instead of `Generic`.
  prefs: []
  type: TYPE_NORMAL
- en: At this moment, the sender has the secret key and the encapsulation message
    via `encedSender`.
  prefs: []
  type: TYPE_NORMAL
- en: Sending the encapsulation message to the receiver
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, the sender will transmit the key encapsulation message to the receiver
    via the `encapsulation()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'The receiver is the only one capable of using their private key to decapsulate
    the received packet via a new `Decapsulator`. Once it does this, the receiver
    has the secret key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: The secret key of the sender (`secretKeySender`) and the secret key of the receiver
    (`secretKeyReceiver`) are identical.
  prefs: []
  type: TYPE_NORMAL
- en: Using the secret key to encrypt/decrypt messages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, the sender and receiver can continue the communication by encrypting/decrypting
    messages using the secret key and the well-known `Cipher` API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'For instance, the receiver can send an encrypted token to the sender:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'The sender may generate a password based on this token and send it back to
    the receiver:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: Finally, the receiver decrypts the received password. In the bundled code, you
    can find the complete code.
  prefs: []
  type: TYPE_NORMAL
- en: 268\. Reimplementing the legacy Socket API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Socket API has been improved over time and it is still receiving attention
    for potential further improvements.
  prefs: []
  type: TYPE_NORMAL
- en: Prior to JDK 13, the Socket API (`java.net.ServerSocket` and `java.net.Socket`)
    relied on `PlainSocketImpl`. Starting with JDK 13 (JEP 353), this API has been
    replaced by `NioSocketImpl`.
  prefs: []
  type: TYPE_NORMAL
- en: As its name suggests, `NioSocketImpl` is based on the NIO infrastructure. The
    new implementation doesn’t rely on the thread stack being capable of taking advantage
    of buffer cache mechanisms. Moreover, sockets can be closed via the `java.lang.ref.Cleaner`
    mechanism, which gives special attention to how socket objects are garbage collected.
  prefs: []
  type: TYPE_NORMAL
- en: Starting with JDK 15 (JEP 373, follow-on of JEP 353), the internal Socket API
    has been reimplemented at `DatagramSocket` and `MulticastSocket` APIs. The goal
    was to make these APIs simpler and easier to adapt to work with Project Loom (virtual
    threads).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever you prefer to go for the old `PlainSocketImpl`, you should run your
    code with the JVM `-Djdk.net.usePlainSocketImpl=true` option.
  prefs: []
  type: TYPE_NORMAL
- en: 269\. Quick overview of SWS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SWS was added in JDK 18 under JEP 408 in the `jdk.httpserver` module. Basically,
    SWS is a minimalist implementation of a static file server capable of serving
    a single directory hierarchy. If the request points to a file, then SWS will serve
    that file. If the request points to a directory containing an index file, then
    the index file will be served; otherwise, the directory content will be listed.
  prefs: []
  type: TYPE_NORMAL
- en: SWS is very easy to set up and is available as a command-line tool (`jwebserver`)
    and as a suite of programmatic API points (`com.sun.net.httpserver`). SWS supports
    HTTP 1.1 only (not HTTPS or HTTP/2) and it can respond only to the idempotent
    `HEAD` and `GET` requests (any other request type will return a 405 or 501 HTTP
    code).
  prefs: []
  type: TYPE_NORMAL
- en: In addition, MIME types are set up automatically by SWS and no security mechanism
    (for instance, OAuth) is available.
  prefs: []
  type: TYPE_NORMAL
- en: Key abstractions of SWS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To better understand how SWS works behind the scenes, consider the following
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.10.png](img/B19655_13_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.5: SWS key abstractions'
  prefs: []
  type: TYPE_NORMAL
- en: On the left-hand side, we have a client for SWS (for instance, a browser) that
    triggers the HTTP requests and gets back HTTP responses. An HTTP request-response
    cycle is also known as an *exchange* – a client triggers a request and gets a
    response in exchange). On the right-hand side, there is an SWS containing the
    server, and a few *handlers* and *filters*. The server listens for incoming TCP
    connections. Next, each HTTP request is delegated to the proper handler (there
    can be one or more handlers). Here is where the request is practically handled
    by SWS. Finally, we have some filters. These are optional and they can be executed
    before processing the request (pre-processing filters) or after processing the
    request (post-processing filters – for instance, for logging purposes).
  prefs: []
  type: TYPE_NORMAL
- en: 'Going further, an HTTP request flows through SWS as in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.11.png](img/B19655_13_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.6: SWS handlers and filters'
  prefs: []
  type: TYPE_NORMAL
- en: One of the abstractions used by SWS is *context*. A context is a mapping between
    a root URI part and a handler `(/context/`). For instance, the URL `http://localhost:9009/a/file.txt`
    has the context `/a/`, which is associated with a certain handler. This way, SWS
    knows how to dispatch requests to handlers. In other words, SWS inspects the incoming
    request, extracts the context, and tries to find a handler with a matching context.
    That handler will serve the requested resource (`file.txt`). Finally, after the
    request is handled, a post-processing filter will log the request details.
  prefs: []
  type: TYPE_NORMAL
- en: 270\. Exploring the SWS command-line tool
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The only prerequisite for running the SWS command-line tool (`jwebserver`)
    is JDK 18 and the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.5.png](img/B19655_13_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.7: jwebserver command-line tool syntax'
  prefs: []
  type: TYPE_NORMAL
- en: 'The options of `jwebserver` are straightforward. Here is a short description
    of the most useful ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-b addr`: This is the binding address. It defaults to the loopback, `127.0.0.1`
    or `::1`. For all interfaces, we can use `-b 0.0.0.0` or `-b ::`. The `–b addr`
    is similar to`--bind-address addr`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-p port`: This specifies the port on which the SWS will listen for incoming
    requests. The default port is `8000`. The `–p` port option is similar to`--port
    port`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-d dir`: The `dir` variable points out the directory to be served. The default
    is the current directory. The `–d dir` is similar to`--directory dir`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-o level`: The `level` variable can be `none`, `info` (default), or `verbose`
    and it specifies the output format. The `–o level` is similar to `--output level`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can list all options and their description via the `jwebsever –h` command.
    Keeping these options in mind, let’s start an SWS instance.
  prefs: []
  type: TYPE_NORMAL
- en: Starting SWS from the command line
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s assume that we want to serve the files from a directory named `docs`,
    which contains a text file and a few image files (you’ll find this folder in the
    bundled code). For this, we open a command prompt (in Windows) and navigate to
    the `docs` folder. Next, from this folder, we launch the `jwebserver` command
    as in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.6.png](img/B19655_13_08.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.8: Starting SWS via jwebserver command'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to copy the URL displayed on the command prompt into a browser
    address bar (here, the URL is `http://127.0.0.1:8000/`). Since our request points
    to the current directory (`docs`), we get back the listing of this directory in
    the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.7.png](img/B19655_13_09.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.9: SWS serving the current directory listing'
  prefs: []
  type: TYPE_NORMAL
- en: If we click on `books.txt` or on any of the images then we will trigger a request
    to a file, so SWS will return the file content and the browser will render it
    accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a screenshot of clicking on `books.txt` and `Java Coding Problems 2nd
    Edition.png`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.8.png](img/B19655_13_10.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.10: SWS serving two files (a text file and an image)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Meanwhile, SWS has logged each of our requests in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.9.png](img/B19655_13_11.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.11: SWS has logged the GET requests'
  prefs: []
  type: TYPE_NORMAL
- en: Done! Next, let’s see how we can configure the server.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring SWS from the command line
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Configuring SWS from the command line can be done via the options listed earlier.
    For instance, if we want to change the default port then we use `–p port` (or
    `--port port`). In the following example, we use port `9009` instead of the default
    `8000`. Moreover, we make our server available only to the address `172.27.128.1`
    via `–b addr` (this is an address specific to my machine representing a *Hyper-V
    virtual Ethernet adapter* supporting multicast):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: This time, we open the browser and point it to `http://172.27.128.1:9009/`.
  prefs: []
  type: TYPE_NORMAL
- en: Feel free to test other options as well.
  prefs: []
  type: TYPE_NORMAL
- en: Stopping SWS from the command line
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A SWS instance runs until it is explicitly stopped. In Unix/Windows, we can
    stop SWS from the command line by simply typing *Ctrl* + *C*. Sometimes, you have
    to wait a few seconds until the server is stopped and the command prompt is available
    for other commands.
  prefs: []
  type: TYPE_NORMAL
- en: 271\. Introducing the com.sun.net.httpserver API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since 2006, next to the SWS command-line tool, we have the programmatic bridge
    represented by the `com.sun.net.httpserver` API. Practically, the goal of this
    API is to allow us to programmatically launch an SWS instance in a very easy way.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we have the `SimpleFileServer`, which is the main API for creating an
    SWS instance via three static methods, `createFileServer()`, `createFileHandler()`,
    and `createOutputFilter()`. We are especially interested in the `createFileServer(InetSocketAddress
    addr, Path rootDirectory, SimpleFileServer.OutputLevel outputLevel)` method. As
    you can see, via this method, we can create an SWS instance with a given port,
    root directory (this should be an absolute path), and output level as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: After running this application, an SWS will be available at `http://localhost:9009/`.
  prefs: []
  type: TYPE_NORMAL
- en: The default address is the loopback address, so you can also express the `InetSocketAddress`
    as `new InetSocketAddress(InetAddress.getLoopbackAddress(), 9009)`. Moreover,
    we can bind the server after creation via `bind(InetSocketAddress addr, int backlog)`.
  prefs: []
  type: TYPE_NORMAL
- en: For programmatically starting and stopping the SWS instance, we have the `start()`
    and `stop()` methods.
  prefs: []
  type: TYPE_NORMAL
- en: Using a custom HttpHandler
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another approach for programmatically creating a custom SWS instance relies
    on creating a file handler and passing it to the overloaded `HttpServer.create()`
    method. The file handler can be created as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'This file handler can be passed to `HttpServer.create(InetSocketAddress addr,
    int backlog, String path, HttpHandler handler, Filter... filters)` next to the
    port, socket backlog (*maximum number of queued incoming connections to allow
    on the listening socket*), context path, and optional filters as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, the server will be available at `http://localhost:9009/mybooks/`.
    If you want to achieve the same thing and still use `createFileServer()`, then
    you need to explicitly set the context and the file handler via `setContext()`
    and `setHandler()` after creating an SWS as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: There is also a `createContext(String path, HttpHandler handler)`.
  prefs: []
  type: TYPE_NORMAL
- en: Using a custom filter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Adding a post-processing filter for SWS logging can be done via `createOutputFilter(OutputStream
    out, OutputLevel outputLevel)`. So, we have to specify an output stream and the
    level of logging.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can have multiple filters (via the filters array, `Filter...`), but here
    we create a single one that sends the log into a text file named `swslog.txt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: This time, each request solved by our SWS will be logged into `swslog.txt`.
  prefs: []
  type: TYPE_NORMAL
- en: Using a custom executor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By default, all HTTP requests of an SWS instance are handled by the thread
    that was created by the `start()` method. But, we can specify any `Executor` for
    handling the HTTP requests via the `setExecutor()` method. For instance, we can
    rely on `newVirtualThreadPerTaskExecutor()` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: Getting the current `Executor` can be done via the `getExecutor()` method. If
    no `Executor` was previously set, then `getExecutor()` returns `null`.
  prefs: []
  type: TYPE_NORMAL
- en: 272\. Adapting request/exchange
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Adapting a request can be useful for testing and debugging purposes. Practically,
    we can adapt the request (`com.sun.net.httpserver.Request`) before the handler
    sees it, so we can modify the initial request and pass the result to the handler.
    For this, we can rely on the pre-processing `Filter.adaptRequest(String description,
    UnaryOperator<Request> requestOperator)` method. Besides the description, this
    method gets the effective request state of the exchange as `UnaryOperator<Request>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example that adds to each request the header `Author` next to a
    post-processing filter that logs the request details to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see that the `Author` header is added to each request directly in the
    logs. In the following figure, you can see this header among other headers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.12.png](img/B19655_13_12.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.12: The Author header was added'
  prefs: []
  type: TYPE_NORMAL
- en: 'Besides `adaptRequest()`, the `Filter` class defines the `beforeHandler(String
    description, Consumer<HttpExchange> operation)` pre-processing filter and the
    `afterHandler(String description, Consumer<HttpExchange> operation)` post-processing
    filter. In both cases, the `operation` argument represents the effective implementation
    of the filter. As you can see, these filters are acting as hooks for `com.sun.net.httpserver.HttpExchange`,
    which represents an *exchange* (an HTTP request and the response in exchange):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: Via the `exchange` object, we have access to request/response headers and body.
  prefs: []
  type: TYPE_NORMAL
- en: 273\. Complementing a conditional HttpHandler with another handler
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let’s assume that we want to choose between two `HttpHandler` instances based
    on a condition. For instance, for all `GET` requests, we want to use the following
    well-known `HttpHandler`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'For all other requests, we want to use an `HttpHandler` that always returns
    the same resource (for instance, the text *No data available*). Defining a `HttpHandler`
    that always returns the same code and resource (so, a *canned response*) can be
    done via the `HttpHandlers.of(int statusCode, Headers headers, String body)` method
    as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition, the `HttpHandler` class exposes a method that can decide between
    two `HttpHandler` instances based on a condition. This method is `handleOrElse(Predicate<Request>
    handlerTest, HttpHandler handler, HttpHandler fallbackHandler)`. As you can see,
    the condition is expressed as `Predicate<Request>`, so in our case, we can write
    it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, all we have to do is to pass this `Predicate<Request>` and the two handlers
    to the `handleOrElse()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'If `predicate` is evaluated to `true` (so, an HTTP `GET` request was received),
    then `fileHandler` will be used; otherwise, `complementHandler` will be used.
    Finally, we create and start an SWS instance as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the passed `HttpHandler` is `handler`.
  prefs: []
  type: TYPE_NORMAL
- en: 274\. Implementing SWS for an in-memory file system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We already know that SWS can serve files from the default local file system.
    While this file system fits many scenarios, there are also use cases (for instance,
    testing scenarios) where it will be more practical to mock a directory structure
    in order to simulate certain expectations. In such scenarios, an in-memory file
    system will be more suitable than the local file system since we can avoid the
    creation/deletion of resources and we can use different platforms.
  prefs: []
  type: TYPE_NORMAL
- en: 'An in-memory file system implementation for Java 8 (based on the `java.nio.file`
    API) is provided by the Google project named *Jimfs* ([https://github.com/google/jimfs](https://github.com/google/jimfs)).
    By following the instructions from the GitHub example, we wrote the following
    code for a simple in-memory file system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'The path returned by the previous code is `/docs/books.txt` (you can easily
    create any kind of directory/files hierarchy). Since the SWS file handler supports
    any kind of path’s file system that implements the `java.nio.file` API, we should
    be able to start an SWS instance for the in-memory path returned via `inMemoryDirectory()`
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: For testing, point the browser to `http://localhost:9009`.
  prefs: []
  type: TYPE_NORMAL
- en: 275\. Implementing SWS for a zip file system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: The result is an archive named `docs.zip` with a single file named `bookszipped.txt`—this
    file was copied into the archive from the external `/docs` folder where it is
    stored under the name `books.txt`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we can write our SWS instance as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: After starting the SWS instance, just point the browser to the `http://localhost:9009/bookszipped.txt`
    URL and you should see the content of the text file.
  prefs: []
  type: TYPE_NORMAL
- en: 276\. Implementing SWS for a Java runtime directory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Starting with JDK 9 (JEP 220), the runtime images have been restructured to
    support modules and become more performant and secure. Moreover, naming stored
    modules, classes, and resources has received a new URI scheme (`jrt`). Via the
    `jrt` scheme, we can reference modules, classes, and resources contained in runtime
    images without touching the internal structure of the image. A `jrt` URL looks
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `$MODULE` is a module name (optional) and `$PATH` (optional) represents
    the path to a certain class/resource file within that module. For instance, to
    point out the `File` class, we write the following URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `jrt` file system, there is a top-level `modules` directory that contains
    one subdirectory for each module in the image. So, we can fetch the proper path
    for SWS as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, SWS can serve the `modules` directory of the given runtime image as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: Finally, start SWS and point out the URL to a class/resource. For instance,
    the `http://localhost:9009/java.base/java/io/File.class` URL will download the
    `File.class` for local inspection.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter covered 19 problems with Socket API and SWS. In the first part
    of this chapter, we covered NIO.2 features dedicated to TCP/UDP server/client
    applications. In the second part, we covered JDK 18 SWS as a command-line tool
    and as a suite of API points.
  prefs: []
  type: TYPE_NORMAL
- en: Leave a review!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Enjoyed this book? Help readers like you by leaving an Amazon review. Scan the
    QR code below for a 20% discount code.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Leave_Reivew_QR.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Limited Offer*'
  prefs: []
  type: TYPE_NORMAL
