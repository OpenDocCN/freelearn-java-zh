["```java\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n```", "```java\n<settings>\n```", "```java\n  <renderCatalog>false</renderCatalog>\n```", "```java\n  <renderSchema>false</renderSchema>\n```", "```java\n  <!-- more settings added here -->\n```", "```java\n</settings>\n```", "```java\n@org.springframework.context.annotation.Configuration\n```", "```java\npublic class JooqConfig {\n```", "```java\n  @Bean\n```", "```java\n  public Settings jooqSettings() {\n```", "```java\n    return new Settings()\n```", "```java\n      .withRenderSchema(Boolean.FALSE) // this is a setting\n```", "```java\n      ... // more settings added here\n```", "```java\n   }  \n```", "```java\n  ...\n```", "```java\n}\n```", "```java\nctx.configuration().set(new Settings()\n```", "```java\n   .withMaxRows(5)\n```", "```java\n   ... // more settings added here\n```", "```java\n   ).dsl()\n```", "```java\n   . // some query\n```", "```java\nctx.configuration().settings()\n```", "```java\n   .withRenderKeywordCase(RenderKeywordCase.UPPER); \n```", "```java\nctx. // some query\n```", "```java\nctx.configuration().derive(new Settings()\n```", "```java\n   .withMaxRows(5)\n```", "```java\n   ... // more settings added here\n```", "```java\n   ).dsl()\n```", "```java\n   . // some query\n```", "```java\nctx.configuration().settings()\n```", "```java\n   .withRenderMapping(new RenderMapping()\n```", "```java\n      .withSchemata(\n```", "```java\n         new MappedSchema()\n```", "```java\n            .withInput(\"classicmodels\")\n```", "```java\n            .withOutput(\"classicmodels_test\")));                \n```", "```java\n// 'derivedCtx' inherits settings of 'ctx'\n```", "```java\nDSLContext derivedCtx = ctx.configuration().derive(\n```", "```java\n    ctx.settings() // using here new Settings() will NOT \n```", "```java\n                   // inherit 'ctx' settings\n```", "```java\n       .withRenderKeywordCase(RenderKeywordCase.UPPER)).dsl();\n```", "```java\n@org.springframework.context.annotation.Configuration\n```", "```java\npublic class JooqConfig {       \n```", "```java\n  @Bean\n```", "```java\n  @ConditionalOnMissingBean(org.jooq.Configuration.class)\n```", "```java\n  public DefaultConfiguration jooqConfiguration(\n```", "```java\n       JooqProperties properties, DataSource ds, \n```", "```java\n       ConnectionProvider cp, TransactionProvider tp) {\n```", "```java\n    final DefaultConfiguration defaultConfig = \n```", "```java\n      new DefaultConfiguration();\n```", "```java\n    defaultConfig               \n```", "```java\n     .set(cp)                                  // must have\n```", "```java\n     .set(properties.determineSqlDialect(ds))  // must have\n```", "```java\n     .set(tp) // for using SpringTransactionProvider\n```", "```java\n     .set(new Settings().withRenderKeywordCase(\n```", "```java\n          RenderKeywordCase.UPPER)); // optional\n```", "```java\n       // more configs ...\n```", "```java\n    return defaultConfig;\n```", "```java\n}\n```", "```java\n@org.springframework.context.annotation.Configuration\n```", "```java\npublic class JooqConfig \n```", "```java\n     implements DefaultConfigurationCustomizer {\n```", "```java\n  @Override\n```", "```java\n  public void customize(DefaultConfiguration configuration) {\n```", "```java\n     configuration.set(new Settings()\n```", "```java\n       .withRenderKeywordCase(RenderKeywordCase.UPPER)); \n```", "```java\n       ... // more configs\n```", "```java\n    }\n```", "```java\n}\n```", "```java\npublic class MyTransactionProvider \n```", "```java\n        implements TransactionProvider {\n```", "```java\n  private final PlatformTransactionManager transactionManager;\n```", "```java\n  public MyTransactionProvider(\n```", "```java\n       PlatformTransactionManager transactionManager) {\n```", "```java\n   this.transactionManager = transactionManager;\n```", "```java\n }\n```", "```java\n @Override\n```", "```java\n public void begin(TransactionContext context) {\n```", "```java\n  DefaultTransactionDefinition definition = \n```", "```java\n   new DefaultTransactionDefinition(\n```", "```java\n    TransactionDefinition.PROPAGATION_REQUIRES_NEW);\n```", "```java\n  definition.setIsolationLevel(\n```", "```java\n   TransactionDefinition.ISOLATION_READ_COMMITTED);\n```", "```java\n  definition.setName(\"TRANSACTION_\" + Math.round(1000));\n```", "```java\n  definition.setReadOnly(true);\n```", "```java\n  definition.setTimeout(1);\n```", "```java\n  TransactionStatus status =    \n```", "```java\n   this.transactionManager.getTransaction(definition);\n```", "```java\n  context.transaction(new SpringTransaction(status));\n```", "```java\n }\n```", "```java\n ...\n```", "```java\n}\n```", "```java\n@org.springframework.context.annotation.Configuration\n```", "```java\npublic class JooqConfig \n```", "```java\n       implements DefaultConfigurationCustomizer {\n```", "```java\n  private final PlatformTransactionManager txManager;\n```", "```java\n  public JooqConfig(PlatformTransactionManager txManager) {\n```", "```java\n   this.txManager = txManager;\n```", "```java\n  }        \n```", "```java\n  @Override\n```", "```java\n  public void customize(DefaultConfiguration configuration) {\n```", "```java\n   configuration.set(newMyTransactionProvider(txManager));\n```", "```java\n  }\n```", "```java\n}\n```", "```java\nctx.configuration().set(\n```", "```java\n   new MyTransactionProvider(txManager)).dsl() ...;\n```", "```java\nctx.configuration().derive(\n```", "```java\n  new MyTransactionProvider(txManager)).dsl() ...;\n```", "```java\npublic class MyExecuteListener extends \n```", "```java\n    DefaultExecuteListener{\n```", "```java\n  private static final Logger logger = \n```", "```java\n    Logger.getLogger(MyExecuteListener.class.getName());\n```", "```java\n  @Override\n```", "```java\n  public void renderEnd(ExecuteContext ecx) {\n```", "```java\n    if (ecx.configuration().data()\n```", "```java\n        .containsKey(\"timeout_hint_select\") &&\n```", "```java\n                 ecx.query() instanceof Select) {\n```", "```java\n      String sql = ecx.sql();\n```", "```java\n      if (sql != null) {\n```", "```java\n        ecx.sql(sql.replace(\n```", "```java\n         \"select\",\n```", "```java\n         \"select \" + ecx.configuration().data()\n```", "```java\n            .get(\"timeout_hint_select\")\n```", "```java\n      ));\n```", "```java\n      logger.info(() -> {\n```", "```java\n        return \"Executing modified query : \" + ecx.sql();\n```", "```java\n      });\n```", "```java\n   }\n```", "```java\n  }\n```", "```java\n }\n```", "```java\n}\n```", "```java\nConfiguration derived = ctx.configuration().derive();\n```", "```java\nderived.data(\"timeout_hint_select\", \n```", "```java\n             \"/*+ MAX_EXECUTION_TIME(5) */\");\n```", "```java\nderived.dsl().select(...).fetch();\n```", "```java\nctx.configuration().derive(new CallbackExecuteListener()\n```", "```java\n                   .onRenderEnd(ecx -> {\n```", "```java\n   ...}))\n```", "```java\n   .dsl()\n```", "```java\n   .select(...).fetch();\n```", "```java\n@Query(value = \"SELECT c.customer_name as customerName, \"\n```", "```java\n  + \"d.address_line_first as addressLineFirst, \n```", "```java\n     d.address_line_second as addressLineSecond \"\n```", "```java\n  + \"FROM customer c JOIN customerdetail d \"\n```", "```java\n  + \"ON c.customer_number = d.customer_number \"\n```", "```java\n  + \"WHERE (NOT d.address_line_first <=>\n```", "```java\n    d.address_line_second)\", nativeQuery=true)\n```", "```java\n    List<SimpleCustomer> fetchCustomerNotSameAddress();\n```", "```java\n@Configuration\n```", "```java\npublic class SqlInspector implements StatementInspector {\n```", "```java\n  @Override\n```", "```java\n  public String inspect(String sql) {\n```", "```java\n    Query query = DSL.using(SQLDialect.POSTGRES)\n```", "```java\n      .parser()\n```", "```java\n      .parseQuery(sql);\n```", "```java\n    if (query != null) {\n```", "```java\n        return query.getSQL();\n```", "```java\n    }\n```", "```java\n    return null; // interpreted as the default SQL string\n```", "```java\n  }\n```", "```java\n}\n```", "```java\nSELECT c.customer_name AS customername,\n```", "```java\n       d.address_line_first AS addresslinefirst,\n```", "```java\n       d.address_line_second AS addresslinesecond\n```", "```java\nFROM customer AS c\n```", "```java\nJOIN customerdetail AS d \n```", "```java\n  ON c.customer_number = d.customer_number\n```", "```java\nWHERE NOT (d.address_line_first IS NOT DISTINCT\n```", "```java\n           FROM d.address_line_second)\n```", "```java\ntry (Connection c = DSL.using(url, user, pass)\n```", "```java\n      .configuration()\n```", "```java\n      .set(new Settings()\n```", "```java\n          .withParseDialect(SQLDialect.MYSQL)) \n```", "```java\n      .dsl()\n```", "```java\n      .parsingConnection();  // this does the trick  \n```", "```java\n      PreparedStatement ps = c.prepareStatement(sql);\n```", "```java\n    ) {\n```", "```java\n     ...\n```", "```java\n}\n```", "```java\nSELECT concat_ws('|', city, address_line_first, \n```", "```java\n  address_line_second, country, territory) AS address \n```", "```java\nFROM office\n```", "```java\nctx.resultQuery(\"SELECT concat_ws('|', city, \n```", "```java\n  address_line_first, address_line_second, country, territory) \n```", "```java\nAS address FROM office\").fetch();\n```", "```java\npublic class MyParseListener extends DefaultParseListener {\n```", "```java\n @Override\n```", "```java\n public Field parseField(ParseContext pcx) {\n```", "```java\n  if (pcx.parseFunctionNameIf(\"CONCAT_WS\")) {\n```", "```java\n   pcx.parse('(');\n```", "```java\n   String separator = pcx.parseStringLiteral();            \n```", "```java\n   pcx.parse(',');\n```", "```java\n   // extract the variadic list of fields\n```", "```java\n   List<Field<?>> fields = pcx.parseList(\",\", \n```", "```java\n       c -> c.parseField()); \n```", "```java\n   pcx.parse(')'); // the function CONCAT_WS() was parsed      \n```", "```java\n   ...\n```", "```java\n   ...\n```", "```java\n   // prepare the Oracle emulation\n```", "```java\n   return CustomField.of(\"\", SQLDataType.VARCHAR, f -> {\n```", "```java\n    switch (f.family()) {\n```", "```java\n     case ORACLE -> {\n```", "```java\n      Field result = inline(\"\");\n```", "```java\n      for (Field<?> field : fields) {\n```", "```java\n       result = result.concat(DSL.nvl2(field,\n```", "```java\n                  inline(separator).concat(\n```", "```java\n                    field.coerce(String.class)), field));\n```", "```java\n      }\n```", "```java\n      f.visit(result); // visit this QueryPart\n```", "```java\n     }\n```", "```java\n     // case other dialect ...    \n```", "```java\n     }\n```", "```java\n   });\n```", "```java\n  }\n```", "```java\n  // pass control to jOOQ\n```", "```java\n  return null;\n```", "```java\n }\n```", "```java\n}\n```", "```java\nString sql = ctx.configuration().derive(SQLDialect.ORACLE)\n```", "```java\n  .dsl()\n```", "```java\n  .render(ctx.parser().parseQuery(\"\"\"\n```", "```java\n   SELECT concat_ws('|', city, address_line_first,  \n```", "```java\n     address_line_second, country, territory) AS address \n```", "```java\n   FROM office\"\"\"));\n```", "```java\nctx.resultQuery(sql).fetch();\n```", "```java\nSELECT ((((('' || nvl2(CITY, ('|' || CITY), CITY)) || \n```", "```java\n  nvl2(ADDRESS_LINE_FIRST, ('|' || ADDRESS_LINE_FIRST),   \n```", "```java\n       ADDRESS_LINE_FIRST)) || \n```", "```java\n  nvl2(ADDRESS_LINE_SECOND, ('|' || ADDRESS_LINE_SECOND), \n```", "```java\n       ADDRESS_LINE_SECOND)) || \n```", "```java\n  nvl2(COUNTRY, ('|' || COUNTRY), COUNTRY)) || \n```", "```java\n  nvl2(TERRITORY, ('|' || TERRITORY), TERRITORY)) ADDRESS\n```", "```java\nFROM OFFICE\n```", "```java\npublic class MyRecordListener extends DefaultRecordListener {\n```", "```java\n @Override\n```", "```java\n public void insertStart(RecordContext rcx) {\n```", "```java\n  if (rcx.record() instanceof EmployeeRecord employee) {\n```", "```java\n   // call the secret algorithm that produces the PK\n```", "```java\n   long secretNumber = (long) (10000 * Math.random());\n```", "```java\n   employee.setEmployeeNumber(secretNumber);\n```", "```java\n   employee.setExtension(\"x\" + secretNumber);\n```", "```java\n  }\n```", "```java\n }\n```", "```java\n} \n```", "```java\n@Override\n```", "```java\npublic void insertEnd(RecordContext rcx) {\n```", "```java\n  if (rcx.record() instanceof EmployeeRecord employee) {\n```", "```java\n   EmployeeStatusRecord status = \n```", "```java\n      rcx.dsl().newRecord(EMPLOYEE_STATUS);\n```", "```java\n   status.setEmployeeNumber(employee.getEmployeeNumber());\n```", "```java\n   status.setStatus(\"REGULAR\");\n```", "```java\n   status.setAcquiredDate(LocalDate.now());\n```", "```java\n   status.insert();\n```", "```java\n }        \n```", "```java\n}        \n```", "```java\n@Transactional(readOnly = true)\n```", "```java\npublic void fetchProductlinesAndProducts() {\n```", "```java\n  List<Productline> productlines \n```", "```java\n   = productlineRepository.findAll();\n```", "```java\n  for (Productline : productlines) {\n```", "```java\n   List<Product> products = productline.getProducts();\n```", "```java\n   System.out.println(\"Productline: \" \n```", "```java\n    + productline.getProductLine()\n```", "```java\n    + \" Products: \" + products);\n```", "```java\n  }\n```", "```java\n}\n```", "```java\npublic class MyDiagnosticsListener \n```", "```java\n         extends DefaultDiagnosticsListener {    \n```", "```java\n private static final Logger = ...;   \n```", "```java\n @Override\n```", "```java\n public void repeatedStatements(DiagnosticsContext dcx) {\n```", "```java\n  log.warning(() ->\n```", "```java\n   \"These queries are prone to be a N+1 case: \\n\" \n```", "```java\n     + dcx.repeatedStatements());        \n```", "```java\n }\n```", "```java\n}\n```", "```java\n@Override\n```", "```java\npublic void updateStart(RecordContext rcx) {\n```", "```java\n  if (rcx.record() instanceof EmployeeRecord) {\n```", "```java\n   EmployeeRecord employee = \n```", "```java\n    (EmployeeRecord) rcx.record().original();\n```", "```java\n  rcx.configuration().data(\"employee\", employee);\n```", "```java\n  }\n```", "```java\n}\n```", "```java\npublic class MyTransactionListener \n```", "```java\n      extends DefaultTransactionListener {\n```", "```java\n @Override\n```", "```java\n public void commitEnd(TransactionContext tcx) {\n```", "```java\n  EmployeeRecord employee = \n```", "```java\n    (EmployeeRecord) tcx.configuration().data(\"employee\");\n```", "```java\n  if (employee != null) {\n```", "```java\n    // write to file corresponding to this employee\n```", "```java\n  }\n```", "```java\n }\n```", "```java\n}\n```", "```java\npublic class MyVisitListener extends DefaultVisitListener {\n```", "```java\n @Override\n```", "```java\n public void clauseEnd(VisitContext vcx) {\n```", "```java\n  if (vcx.clause().equals(CREATE_VIEW_AS)) {\n```", "```java\n    vcx.context().formatSeparator()\n```", "```java\n       .sql(\"WITH CHECK OPTION\");\n```", "```java\n  }\n```", "```java\n }\n```", "```java\n}\n```", "```java\npublic class CustomJavaGenerator extends JavaGenerator {\n```", "```java\n   @Override\n```", "```java\n   protected void generateDaoClassFooter(\n```", "```java\n         TableDefinition table, JavaWriter out) {\n```", "```java\n      ...\n```", "```java\n   }\n```", "```java\n}\n```", "```java\n01:@Override\n```", "```java\n02:protected void generateDaoClassFooter(\n```", "```java\n03:            TableDefinition table, JavaWriter out) {\n```", "```java\n04:\n```", "```java\n05:   final String pType = \n```", "```java\n06:    getStrategy().getFullJavaClassName(table, Mode.POJO);\n```", "```java\n07:\n```", "```java\n08:   // add a method common to all DAOs\n```", "```java\n09:   out.tab(1).javadoc(\"Fetch the number of records \n```", "```java\n10:                limited by <code>value</code>\");\n```", "```java\n11:   out.tab(1).println(\"public %s<%s> findLimitedTo(\n```", "```java\n12:         %s value) {\", List.class, pType, Integer.class);\n```", "```java\n13:   out.tab(2).println(\"return ctx().selectFrom(%s)\",  \n```", "```java\n14:              getStrategy().getFullJavaIdentifier(table));\n```", "```java\n15:   out.tab(3).println(\".limit(value)\");\n```", "```java\n16:   out.tab(3).println(\".fetch(mapper());\");\n```", "```java\n17:   out.tab(1).println(\"}\");\n```", "```java\n18:}\n```", "```java\n/**\n```", "```java\n * Fetch the number of records limited by <code>value</code>\n```", "```java\n */\n```", "```java\npublic List<jooq.generated.tables.pojos.Order>\n```", "```java\n                    findLimitedTo(Integer value) {\n```", "```java\n   return ctx().selectFrom(jooq.generated.tables.Order.ORDER)\n```", "```java\n               .limit(value)\n```", "```java\n               .fetch(mapper());\n```", "```java\n}\n```", "```java\n@Override\n```", "```java\nprotected void generateDaoClassFooter(\n```", "```java\n           TableDefinition table, JavaWriter out) {\n```", "```java\n   final String pType \n```", "```java\n      = getStrategy().getFullJavaClassName(table, Mode.POJO);\n```", "```java\n   // add a method specific to Order DAO\n```", "```java\n   if (table.getName().equals(\"order\")) {\n```", "```java\n      out.println(\"public %s<%s>\n```", "```java\n         findOrderByStatusAndOrderDate(\n```", "```java\n            %s statusVal, %s orderDateVal) {\",\n```", "```java\n               List.class, pType, \n```", "```java\n                    String.class, LocalDate.class);\n```", "```java\n      ...\n```", "```java\n   }\n```", "```java\n}\n```", "```java\n/**\n```", "```java\n * Fetch orders having status <code>statusVal</code>\n```", "```java\n *  and order date after <code>orderDateVal</code>\n```", "```java\n */\n```", "```java\npublic List<jooq.generated.tables.pojos.Order>\n```", "```java\n      findOrderByStatusAndOrderDate(String statusVal,    \n```", "```java\n         LocalDate orderDateVal) {\n```", "```java\n   return ctx().selectFrom(jooq.generated.tables.Order.ORDER)\n```", "```java\n      .where(jooq.generated.tables.Order.ORDER.STATUS\n```", "```java\n         .eq(statusVal))\n```", "```java\n         .and(jooq.generated.tables.Order.ORDER.ORDER_DATE\n```", "```java\n            .ge(orderDateVal))\n```", "```java\n      .fetch(mapper());\n```", "```java\n}\n```", "```java\nctx.select(concat(EMPLOYEE.FIRST_NAME, inline(\" \"),        \n```", "```java\n        EMPLOYEE.LAST_NAME).as(\"employee\"),\n```", "```java\n        concat(EMPLOYEE.employee().FIRST_NAME, inline(\" \"), \n```", "```java\n               EMPLOYEE.employee().LAST_NAME).as(\"reports_to\"))\n```", "```java\n   .from(EMPLOYEE)\n```", "```java\n   .where(EMPLOYEE.JOB_TITLE.eq(\n```", "```java\n          EMPLOYEE.employee().JOB_TITLE))\n```", "```java\n   .fetch();\n```", "```java\npublic class MyGeneratorStrategy \n```", "```java\n        extends DefaultGeneratorStrategy {\n```", "```java\n  @Override\n```", "```java\n  public String getJavaMethodName(\n```", "```java\n        Definition, Mode mode) {\n```", "```java\n   if (definition.getQualifiedName()\n```", "```java\n         .equals(\"classicmodels.employee\") \n```", "```java\n            && mode.equals(Mode.DEFAULT)) {\n```", "```java\n       return \"reportsTo\";\n```", "```java\n   }\n```", "```java\n   return super.getJavaMethodName(definition, mode);\n```", "```java\n  }\n```", "```java\n}\n```", "```java\n<generator>\n```", "```java\n <strategy>\n```", "```java\n  <name>\n```", "```java\n   com.classicmodels.strategy.MyGeneratorStrategy\n```", "```java\n  </name>\n```", "```java\n </strategy>\n```", "```java\n</generator>\n```", "```java\nctx.select(concat(EMPLOYEE.FIRST_NAME, inline(\" \"), \n```", "```java\n         EMPLOYEE.LAST_NAME).as(\"employee\"),\n```", "```java\n         concat(EMPLOYEE.reportsTo().FIRST_NAME, inline(\" \"), \n```", "```java\n            EMPLOYEE.reportsTo().LAST_NAME).as(\"reports_to\"))\n```", "```java\n   .from(EMPLOYEE)\n```", "```java\n   .where(EMPLOYEE.JOB_TITLE.eq(gma\n```", "```java\n          EMPLOYEE.reportsTo().JOB_TITLE))\n```", "```java\n   .fetch();\n```"]