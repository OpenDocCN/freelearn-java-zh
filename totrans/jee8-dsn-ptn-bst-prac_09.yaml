- en: Security Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will look at security pattern concepts and how they can
    help us to implement better security applications. We will also learn about the
    single-sign-on pattern and how this can help us to provide a secure application.
    In addition, we will learn about the authentication mechanism and authentication
    interceptor, focusing on how to implement those concepts. After reading this chapter,
    we will be able to create a security application and implement it using Java EE
    8\. The topics covered in this chapter are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Explaining the concept of security patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explaining the concept of the single-sign-on pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the single-sign-on pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explaining the authentication mechanism
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the authentication mechanism
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explaining the authentication interceptor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the authentication interceptor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explaining the concept of security patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Applications have a close relationship with data and its storage. This is because
    applications basically consist of managing data in order to make it possible to
    optimize the business using automation tasks, helping with decision-making, organizing
    tasks, and managing certain areas. Also, many companies need to store delicate
    data and validate access control. Over time, the demand for security software
    grew significantly, and many companies increasingly invested in creating safe applications.
    An integral element of security is security information, which follows these basic
    principles:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Confidentiality**: The data should not be accessible to non-authorized users
    or to any entities that request access to the data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Integrity**: The data cannot be updated or modified in a non-authorized manner.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Availability**: The data should be available when it is needed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Non-repudiation**: Users cannot repudiate or deny the relation using data
    or any other process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For an application to be safe, it needs to provide at least these basic principles.
  prefs: []
  type: TYPE_NORMAL
- en: Security patterns are a set of solutions to common security problems that occur
    over and over. A large part of these security patterns works to solve problems
    about authentication, which is associated with confidentiality and integrity principles.
    With security patterns, the developer can write software with a high level of
    security for targeting known problems and issues using solutions that are tested
    and validated.
  prefs: []
  type: TYPE_NORMAL
- en: Explaining the concept of the single-sign-on pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a business environment, it is very common that, when a user logs in to a
    system, they are automatically logged into various other systems within the business
    without having to input their login details more than once. One example of this
    is Google services. Here, if a user logs in to one Google application (Gmail,
    YouTube, Google Drive), they are logged in to all the available Google services. For
    example, if we log in to Gmail, we can access YouTube without having to log in
    again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Single-sign-on is a security pattern that creates an authentication service
    that is shared with several applications of a domain to make the centered validation
    of authentication and authenticates a user only once in this domain. The user
    can then access all applications of this domain without having to authenticate
    again. All applications that depend on this type communicate with service authentication
    in order to validate the authentication of a user and log in if they are not yet logged
    in. These applications can be made in any language or technology and can stay
    in several networks or separate physical locations. In the following diagram,
    we can see the process of authentication using single-sign-on:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0df504d4-646b-43aa-913f-356b740f00f1.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding figure, we have three applications that are accessed by a user
    as well as a single point to log in and validate authentication. This single point
    is shown in our diagram by **Authentication Service**. When a user (represented
    by **Actor** in the diagram) sends a request to an application (**Application
    1**, **Application 2**, or **Application 3**), this application waits for **Authentication
    Service** to validate whether the user is logged in. If not, they are redirected
    to the login page, and the user can log in there. After the user logs in, when
    they access **Application 1**, **Application 2**, or **Application 3**, they will
    not need to log in again.
  prefs: []
  type: TYPE_NORMAL
- en: The single-sign-off pattern is a process that occurs when a user logs out of
    something. At this point, they are then logged out from all applications that
    they were logged in to by the authentication service. This is a good pattern because
    it makes it possible to log in and out of all applications only once, and it also
    separates all authentication logic from business logic, putting it into a separate
    service. This then promotes the decoupling of authentication logic and business
    logic, making it possible to change the logic authentication without impacting
    the business logic. This pattern can be done using OAuth, SAML, or a custom process
    of authentication. In a real-world situation, it is very common to use third-party
    solutions, such as OAuth0 and **Red Hat single-sign-on** (**RH-SSO**). In our
    example, we will complete a custom authentication process.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the single-sign-on pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In our example of implementing **single-sign-on** (**SSO**), we will create
    the authentication service through a custom process to authenticate the users
    and we will also allow the user to log in using their login credentials. After
    this, one token will be generated and sent to the user. Further, we will create
    two applications (`App1` and `App2`), and when the user tries to access these
    applications when not logged in, the application will authenticate the user on
    the authentication service and the user will access `App1` and `App2` without
    having to log in again. The authentication service will be a REST application
    written using JAX-RS, and `App1` and `App2` will be applications that implement
    a JAX-RS client to validate user access. With this, the following classes will
    be created to use with our example:'
  prefs: []
  type: TYPE_NORMAL
- en: '`AuthenticationResource`: This is responsible for processing the login request
    and validating the authentication of a user. This class is written using JAX-RS
    and is inside the authentication service application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AuthSession`: This is a session that contains data and information about logins.
    This class has the application scope, that is, a Java EE scope.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Auth`: This is a bean that represents the logged-in user. This class contains
    the user''s login details, password, and date of the last login.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TokenUtils`: This is a class that contains a method for generating tokens.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`App1`: This app sends the `Welcome to App1` text if the user is logged in.
    If the user is not logged in, this application launches an error.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`App2`: This app sends the `Welcome to App2` text if the user is logged in.
    If the user is not logged in, this application launches an error.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Auth`: This is an interface with methods responsible for calling the authentication
    services.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AuthImpl`: This is a class that implements the `Auth` interface. This class
    is an EJB.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `App1` and `App2` applications don't have any process or logic that is required
    in order to log a user in; this is the responsibility of the authentication service
    (the resource that validates the authentication), which has the `AuthenticationResource`
    class with this responsibility.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the AuthenticationResource class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`AuthenticationResource` is a JAX-RS resource, which makes it possible to log
    in and validates the authentication of an application. In the following code,
    we have its implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code block, we have `AuthenticationResource`, which contains
    the `authSession` attribute that is used to persist the information about the
    login on the data source and obtain access to data sources that contain users''
    information used to validate login credentials. Further, `AuthenticationResource`
    has two methods: `login(String login, String password)`, which is used to process
    the login request, and `checkAuthentication( String token)`, which is used to
    allow clients to check whether a user is authenticated. In the following code
    block, we have the `login` method which is used to log a user in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code block, we can see that if a user is already logged in,
    the token is returned as a response. If the user is not logged in, the login and
    password details are validated and a new token is generated and returned as a
    response. Note that this method is called when the client sends a `POST` request
    to this resource.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other method is `checkAuthentication( String token)`, which is used to
    allow clients to check whether a user is authenticated. In the preceding code
    block, we have this method. This method returns the 200 HTTP status code to the
    client if it is logged in, or returns the 401 HTTP status code if it is not logged
    in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Note that the `checkAuthentication(String token)` method is called when the
    client sends a `HEAD` request.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `AuthSession` class is used in the `AuthenticationResource` class. The `AuthSession`
    class has an application scope and is used to persist information about users
    that are logged in and has a data source that contains all users'' login credentials:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '`Auth` is a bean that contains information about users'' login details:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'As demonstrated, `TokenUtils` is a class that uses the `generateToken()` method to
    generate a new token:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Implementing the App1 and App2 classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the preceding code block, we have the code of the `App1` application. When
    this application is accessed by a `GET` request, a request is sent to the authentication
    service to validate whether the user has already logged in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we have the `App1` class, which contains the `auth` parameter,
    which is an EJB used to integrate with the authentication service. Further, this
    class has two methods, called `helloWorld`, with different signatures. In `helloWorld(
    String login, String password )`, the login is completed and then the `Hello World.
    Welcome to App1!` message is sent to the user. In `helloWorld( String token )`,
    the token is validated, and if it is a valid token and the user is logged in,
    the `Hello World. Welcome to App1!` message is sent to the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code block, we have the `App2` class. This has the same code
    as `App1`, but prints another message to the user. This class stays in another
    application, known as `App2` to us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following code block, we have the `Auth` interface. This interface contains
    the contract with the methods responsible for integrating with the authentication
    service, validating the authentication, and logging in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following code block, we have the `AuthImpl` class, which is an implementation
    of the `Auth` interface as well as a stateless EJB:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code block, we have three methods, called `isLogged`, `login`,
    and `logout`, with the signatures `isLogged(String token)`, `login(String login,
    String password)`, and `logout(String token)`, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: When a user logs in to an application (either `App1` or `App2`), and when the
    user navigates to another application using the token, this user will not need
    to log in again.
  prefs: []
  type: TYPE_NORMAL
- en: Explaining the authentication mechanism
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In an enterprise environment, every application or resource needs to validate
    the user access and guarantee that all users that access these applications or
    resources will be identified and validated to prevent non-authorized access. When
    a user requests access to a protected area, they need to be authenticated and
    then their permissions will be validated by the server. To allow a developer to
    authenticate and validate users, Java EE 8 has to have an Authentication Mechanism,
    which is a common solution in Java EE 8 that allows developers to authenticate
    and validate users in a fast and easy way. The Java EE 8 has five mechanisms to
    authenticate users:'
  prefs: []
  type: TYPE_NORMAL
- en: Basic authentication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Form-based authentication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Digest authentication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Client authentication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mutual authentication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The authentication mechanism works by identifying the roles that define user
    permissions. Identity is generally defined by logging in with a username and password.
    This information about a user needs to be kept in a database, generally called
    a *realm*, to allow the server to validate the information. To use the authentication
    mechanism, we configure it with the deployment descriptor file, using annotation
    or the programmatic way. Usually, we will specify an authentication mechanism
    using annotation or a deployment descriptor file.
  prefs: []
  type: TYPE_NORMAL
- en: Explaining basic authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Basic authentication is the default mechanism if the developer uses an authentication
    mechanism without defining it. With this authentication mechanism, if the user
    is not authenticated when they send a request, then a dialog box requesting a
    username and password is returned. This mechanism is not completely safe, because
    the username and password are easily captured, making *man-in-the-middle* attacks
    possible. To use this authentication mechanism, it is recommended to use a secure
    transport mechanism, such as SSL (HTTPS) or a VPN. The following figure represents
    a Java EE tutorial showing what happens when basic authentication is used:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0de03f79-aab7-42f8-9961-51b7d45f1665.png)'
  prefs: []
  type: TYPE_IMG
- en: Explaining form authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Form-based authentication is an authentication mechanism that uses forms to
    request a username and password, allowing the developer to customize the login
    and error screen. When a user requests access to a protected resource, the authentication
    mechanism sends a login page to the user, who then inputs the username and password
    and sends them to the server. If the username or password is not correct, the
    server will return the error page or return the requested resource. This mechanism
    is not safe either, because the username and password are also easily captured
    in this way, making a *man-in-the-middle* attack possible. As mentioned in the
    previous section, it is recommended to use a secure transport mechanism, such
    as SSL (HTTPS) or a VPN, when using this authentication mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram represents a Java EE tutorial, showing what happens when
    form-based authentication is used:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/570365ca-b6b7-449e-bb7b-f3ea8108ee46.png)'
  prefs: []
  type: TYPE_IMG
- en: Explaining digest authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Digest authentication is an authentication mechanism that uses a one-way cryptographic
    hash of the password and additional data. With this mechanism, the developer does
    not need to use a secure transport mechanism to protect login credentials. This
    is because this mechanism already provides the security. When a user sends a digest
    to a server, the digest authentication needs a clear-text password available in
    order to digest and validate the access, comparing the clear-text password sent
    with the password saved on the server.
  prefs: []
  type: TYPE_NORMAL
- en: Explaining client authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Client authentication is a mechanism that authenticates the client by using
    its public key certificate instead of a username and password, such as in basic
    and form-based authentication. This mechanism is considered more secure because
    it uses HTTP over SSL (HTTPS) and uses the client's public key certificate.
  prefs: []
  type: TYPE_NORMAL
- en: Explaining mutual authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Mutual authentication is an authentication mechanism where a server authenticates
    a client and a client authenticates a server. Mutual authentication works with
    *certificate-based* or *username/password-based*. With *certificate-based*, the
    client requests access to a protected resource, then the server responds, sending
    its certificate to the client. After this, the client verifies the server certificate
    and, if the server''s certificate is valid, the client sends its certificate to
    the server. The server then verifies the client''s certificate and, if the client''s
    certificate is valid, the server grants the client access to the protected resource.
    The following diagram shows what happens when mutual authentication with *certificate-**based*
    works:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c6542b6a-f37d-4898-84aa-5ac99109d97c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In *username/password-**bas**ed*, the client requests access to a protected
    resource, then the server responds, sending its certificate to the client. The
    client then verifies the server certificate and if it is valid, the client sends
    its username and password to the server. Following this, the server verifies the
    credentials and, if these are valid, the server grants the client access to the
    protected resource. The following diagram shows what happens when mutual authentication
    with *username/password-**based* works:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d0141b09-7f02-40e9-a963-2d9d360fcc66.png)'
  prefs: []
  type: TYPE_IMG
- en: When to use the deployment descriptor, annotation, or programmatic configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To specify and configure the authentication mechanism, we can either use the deployment
    descriptor file, use annotation, or programmatically define the configuration.
    Generally, we choose annotation because it is easy to use in Java EE projects.
    However, sometimes it easier and more interesting to use deployment descriptors
    or programmatic configuration. If this is the case, what are the appropriate scenarios
    in which to use each?
  prefs: []
  type: TYPE_NORMAL
- en: When we use a deployment descriptor, we define a file of configurations and
    create a configuration to a set of resources. This makes it possible to create
    a single location to configure our security policies and associate it with a set
    of resources. However, when we use an annotation, we define a policy on the specific
    resource and it overrides the deployment descriptor, if it exists. Using annotations,
    we create an authentication's configurations because it doesn't need to set up
    an XML file. However, when we use a programmatic configuration, we can authenticate
    other characteristics that don't exist and we can use the authentication mechanism
    in a dynamic way. Further, when we want to create configurations for a set of
    resources, we can use the deployment descriptor file. When we want to create an
    authentication using dynamic behavior, we use programmatic configuration, and
    when we need to create a configuration in an easy manner, we use annotation.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the authentication mechanism
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In our example of implementing an authentication mechanism, we will create
    an application with resources that receive a request and return *hello world*
    messages to the user. However, this resource is protected and the user needs to
    be authenticated in order to access this resource. Further, we will set up some
    security policies and associations through the deployment descriptor file, some
    security policies to some resources using annotation, and some security policies
    to some resources using the programmatic configuration. We will also use basic
    authentication. To configure the security policies using the deployment descriptor
    file and programmatic configuration, we will use a JAX-RS resource. To configure
    the security policies using annotation, we will use a servlet. All of the examples
    used here are secure in a web application, but Java EE 8 permits the use of authentication
    mechanisms on the enterprise application. In this example, the following classes
    are used:'
  prefs: []
  type: TYPE_NORMAL
- en: '`web.xml`: This is a deployment descriptor file that is used to configure the
    authentication mechanism.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HelloWorld`: This is a JAX-RS resource class that contains the authentication
    mechanism used by the deployment descriptor file and the programmatic configuration.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HelloWorldServlet`: This is a servlet class that contains the authentication
    mechanism used by the annotation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the web.xml file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`web.xml` is a deployment descriptor of a web application and it contains many
    configurations about the web application. In the following deployment descriptor,
    we have the security configurations for our web application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Implementing the HelloWorld class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `HelloWorld` class is a JAX-RS resource that responds to requests sent
    to the `/helloworld` path*.* This class has two methods with the respective `helloWorldWithDeploymentDescriptor()`
    and `helloWorldWithProgrammatically()` signatures. In `helloWorldWithDeploymentDescriptor()`,
    the authentication validation is oriented by the deployment descriptor configuration,
    and in `helloWorldWithProgrammatically()`, the authentication validation is oriented
    by codes written by the developer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'To show the dialog box in the browser in a programmatic manner, use the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Implementing the HelloWordServlet class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `HelloWorldServlet` class is a servlet class that responds to requests
    sent to the `/helloworld/annotation`path. This class has a `doGet(HttpServletRequest
    request, HttpServletResponse response)` method that responds to all `GET` requests.
    After this method is processed, a validation of authentication is done, and if
    the user is associated with the `user` role, the method is processed. If not,
    the dialog box is returned to the user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Explaining the authentication interceptor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In an enterprise application, authentication is a very important process and
    this can be done using many techniques. In Java EE 8, one of these techniques
    is the interceptor pattern.
  prefs: []
  type: TYPE_NORMAL
- en: The interceptor pattern is an advanced programming technique that makes it possible
    to intercept an object call and process algorithms before or after processing
    the call. This works as **aspect-oriented programming** (**AOP**), which makes
    it possible to include behavior in a process without altering its logic. To implement
    this using Java EE 8, we can use either the EJB interceptor or the CDI interceptor.
    We can also select which kind of interceptor to use, depending on whether we are
    intercepting an EJB class/method or a CDI class/method.
  prefs: []
  type: TYPE_NORMAL
- en: The authentication interceptor is a technique that uses an interceptor pattern
    either through an EJB interceptor or a CDI interceptor. This is done to add authentication
    logic before or after using the business logic aspect of oriented programming.
    We can then validate the authentication without having to couple the authentication
    logic with the business logic. It is better to use the EJB interceptor with business
    logic in an EJB class, and it is better to use the CDI interceptor with the CDI
    class in a web tier.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the authentication interceptor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In our final example of implementing the authentication interceptor, we will
    create an application with resources that receives a user request and returns *hello
    world* messages to the user, but this resource is protected and the user needs
    to be authenticated in order to access the resource. However, this protection
    is achieved by authenticating the interceptor implemented using the CDI interceptor,
    which captures a call to a resource and validates the user access. Further, we
    will use the basic authentication mechanism to do an authentication validation;
    the source of the user data will not be managed by the application server and
    Java EE, but by a custom data source. In this example, the following classes are
    used:'
  prefs: []
  type: TYPE_NORMAL
- en: '`DataSource`: This is the data source that contains security user information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Auth`: This is the interface used to define a method to validate authentication
    and authorization.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AuthImpl`: This is the class that implements the `Auth` interface.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Authentication`: This is the qualifier used to configure the method to be
    intercepted.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AuthenticationInterceptor`: This is the interceptor that intercepts a call
    to the `HelloWorld` methods and validates the user access.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HelloWorld`: This is the JAX-RS resource class that contains the authentication
    mechanism used by the deployment descriptor file and programmatic configuration.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AuthUtils`: This is the utility class for authentication.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the CDI interceptor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To implement the CDI interceptor, we need to create a qualifier to be used
    to configure a class or method to be intercepted. In the following code block,
    we have a qualifier, called `Authentication`, with a parameter, called roles,
    and these are used to declare the roles that are permitted to access a resource:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following code block, we have the `AuthenticationInteceptor` class,
    which is used as an interceptor. This class is annotated with the `@Authentication` annotation,
    indicating that this class will intercept all calls to methods annotated with
    `@Authentication` and will process the method annotated with `@AroundInvoke`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Note that this interceptor expects `HttpServletRequest` and `HttpServletResponse`
    as parameters of the target method. This is done in order to allow for the validation
    of authentication and authorization.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code block, we have a snippet of the interceptor. This configures
    a method to process when a call has been intercepted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code block, we have the `Auth` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code block, we have the class that implements an `Auth` interface.
    In this class, we will consult information about the user from a data source.
    This class is an EJB:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code block, we have a `DataSource` class. This class has the
    logic to read information about users, and all information in this data source
    stays as maps. However, we can save this information in a relational database,
    non-relational database, filesystem, or LDAP. This class has the application scope
    and maintains all security data in memory for all the application life cycles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following code block, we have `AuthUtils`. This is an authentication
    utility class. This class uses the `readBasicHeader` method, which receives `HttpServletRequest`
    as a parameter and extracts a username and password if the request uses basic
    authorization:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following code block, we have `beans.xml`, which contains an `<interceptors>` tag with
    a declaration of all CDI interceptors. Its configuration is needed for the CDI
    interceptor to work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Implementing the JAX-RS resource
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the `helloWorld(@Context HttpServletRequest request, @Context HttpServletResponse
    response)` method has the `@Authentication(roles={"user})` annotation, along with
    the `HttpServletRequest` and `HttpServletResponse` parameters. With `@Authentication(roles={"user})`,
    we configured the `helloWorld(@Context HttpServletRequest request, @Context HttpServletResponse
    response)` method to be intercepted by `AuthenticationInterceptor`. As previously
    mentioned, the target method must have `HttpServletRequest` and `HttpServletResponse`
    as parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered security patterns as well as how to implement a
    security application using Java EE and its best practices. We also looked at single-sign-on
    (SSO), authentication mechanisms, and an authentication interceptor. Further,
    we demonstrated how to implement each of these using Java EE 8.
  prefs: []
  type: TYPE_NORMAL
- en: On the topic of a single-sign-on, we implement SSO using JAX-RS and create a
    service to deal with all authentication and authorization logic. As discussed,
    implementing a single-sign-on is generally done by a third-party application,
    such as Red Hat single-sign-on (RH-SSO) or Oracle Enterprise single-sign-on, but
    we can also create our own solution.
  prefs: []
  type: TYPE_NORMAL
- en: We learned about authentication mechanisms and how to use this HTTP tool with
    Java EE 8\. Using Java EE 8, we implemented a basic mechanism, and saved user
    information on an application server at the realm. Further, we demonstrated how
    to implement authentication mechanisms in a servlet and REST resource.
  prefs: []
  type: TYPE_NORMAL
- en: We implemented an authentication interceptor using a CDI interceptor and configured
    it to intercept a JAX-RS resource. The JAX-RS resource authentication interceptor
    tends to be a better solution, but we can use this solution in a servlet or in
    an EJB class.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will explore deployment patterns, why these are important
    for the success of a project, what blue/green deployment is, why it is important
    to use blue/green deployment, what continuous deployment is, and why we should
    use continuous deployment.
  prefs: []
  type: TYPE_NORMAL
