<html><head></head><body><div class="chapter" title="Chapter&#xA0;6.&#xA0;Securing Your Application"><div class="titlepage"><div><div><h1 class="title"><a id="ch06"/>Chapter 6. Securing Your Application</h1></div></div></div><p>In this chapter, we'll learn how to secure our web application and also how to cope with the security challenges of modern, distributed web applications.</p><p>This chapter will be broken up into five parts:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">First, we will set up basic HTTP authentication in a few minutes</li><li class="listitem" style="list-style-type: disc">Then, we will design a form-based authentication for the web pages, keeping the basic authentication for the RESTful API</li><li class="listitem" style="list-style-type: disc">We will allow the users to sign up via the Twitter OAuth API</li><li class="listitem" style="list-style-type: disc">Then, we will leverage Spring Session to make sure our application can scale using a distributed session mechanism</li><li class="listitem" style="list-style-type: disc">Finally, we will configure Tomcat to use a secured connection through SSL</li></ul></div><div class="section" title="Basic authentication"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec54"/>Basic authentication</h1></div></div></div><p>The simplest possible <a id="id342" class="indexterm"/>authentication mechanism is basic authentication (<a class="ulink" href="http://en.wikipedia.org/wiki/Basic_access_authentication">http://en.wikipedia.org/wiki/Basic_access_authentication</a>). In a nutshell, our pages will not be<a id="id343" class="indexterm"/> available without username and password.</p><p>Our server will indicate our resources are secured by sending the <code class="literal">401 Not Authorized</code> HTTP status code and generate a <code class="literal">WWW-Authenticate</code> header.</p><p>To successfully pass the security check, the client must send an <code class="literal">Authorization</code> header containing the <code class="literal">Basic</code> value followed by a base 64 encoding of the <code class="literal">user:password</code> string. A browser window will prompt the user for a username and a password, granting them access to the secured pages if authentication is successful.</p><p>Let's add Spring Security to our dependencies:</p><div class="informalexample"><pre class="programlisting">compile 'org.springframework.boot:spring-boot-starter-security'</pre></div><p>Relaunch your application and navigate to any URL in your application. You will be prompted for a username and a password:</p><div class="mediaobject"><img src="graphics/2117_06_01.jpg" alt="Basic authentication"/></div><p>If you fail to <a id="id344" class="indexterm"/>authenticate, you will see that a <code class="literal">401</code> error is thrown. The default username is <code class="literal">user</code>. The correct password for authentication will be randomly generated each time the application launches and will be displayed in the server log:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Using default security password: 13212bb6-8583-4080-b790-103408c93115</strong></span>
</pre></div><p>By default, Spring Security secures every resource except a handful of classic routes such as <code class="literal">/css/</code>, <code class="literal">/js/</code>, <code class="literal">/images/</code>, and <code class="literal">**/favicon.ico</code>.</p><p>If you wish to configure the default credentials, you can add the following properties to the <code class="literal">application.properties</code> file:</p><div class="informalexample"><pre class="programlisting">security.user.name=admin
security.user.password=secret</pre></div><div class="section" title="Authorized users"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec44"/>Authorized users</h2></div></div></div><p>Having only <a id="id345" class="indexterm"/>one user in our application does not allow<a id="id346" class="indexterm"/> fine-grained security. If we wanted more control over the user credentials, we could add the following <code class="literal">SecurityConfiguration</code> class in the <code class="literal">config</code> package:</p><div class="informalexample"><pre class="programlisting">package masterSpringMvc.config;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;
import org.springframework.security.config.annotation.method.configuration.EnableGlobalMethodSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;

@Configuration
@EnableGlobalMethodSecurity(securedEnabled = true)
public class SecurityConfiguration extends WebSecurityConfigurerAdapter {

    @Autowired
    public void configureAuth(AuthenticationManagerBuilder auth)
            throws Exception {
        auth.inMemoryAuthentication()
                .withUser("user").password("user").roles("USER").and()
                .withUser("admin").password("admin").roles("USER", "ADMIN");
    }
}</pre></div><p>This snippet<a id="id347" class="indexterm"/> will set up an in-memory system containing<a id="id348" class="indexterm"/> our application's users as well as their roles. It will override the security name and password previously defined in the application's properties.</p><p>The <code class="literal">@EnableGlobalMethodSecurity</code> annotation will allow us to annotate our application's method and classes to define their security level.</p><p>For example, let's say that only the administrators of our application can access the user API. In this case, we just have to add the <code class="literal">@Secured</code> annotation to our resource to allow access only to ADMIN roles:</p><div class="informalexample"><pre class="programlisting">@RestController
@RequestMapping("/api")
<span class="strong"><strong>@Secured("ROLE_ADMIN")</strong></span>
public class UserApiController {
  // ... code omitted
}</pre></div><p>We can easily test that with httpie by using the <code class="literal">-a</code> switch to use basic authentication and the <code class="literal">-p=h</code> switch, which will only display the response headers.</p><p>Let's try this with a user without the admin profile:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; http GET 'http://localhost:8080/api/users' -a user:user -p=h</strong></span>
<span class="strong"><strong>HTTP/1.1 403 Forbidden</strong></span>
<span class="strong"><strong>Cache-Control: no-cache, no-store, max-age=0, must-revalidate</strong></span>
<span class="strong"><strong>Content-Type: application/json;charset=UTF-8</strong></span>
<span class="strong"><strong>Date: Sat, 23 May 2015 17:40:09 GMT</strong></span>
<span class="strong"><strong>Expires: 0</strong></span>
<span class="strong"><strong>Pragma: no-cache</strong></span>
<span class="strong"><strong>Server: Apache-Coyote/1.1</strong></span>
<span class="strong"><strong>Set-Cookie: JSESSIONID=2D4761C092EDE9A4DB91FA1CAA16C59B; Path=/; HttpOnly</strong></span>
<span class="strong"><strong>Transfer-Encoding: chunked</strong></span>
<span class="strong"><strong>X-Content-Type-Options: nosniff</strong></span>
<span class="strong"><strong>X-Frame-Options: DENY</strong></span>
<span class="strong"><strong>X-XSS-Protection: 1; mode=block</strong></span>
</pre></div><p>Now, <a id="id349" class="indexterm"/>with the administrator:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; http GET 'http://localhost:8080/api/users' -a admin:admin -p=h</strong></span>
<span class="strong"><strong>HTTP/1.1 200 OK</strong></span>
<span class="strong"><strong>Cache-Control: no-cache, no-store, max-age=0, must-revalidate</strong></span>
<span class="strong"><strong>Content-Type: application/json;charset=UTF-8</strong></span>
<span class="strong"><strong>Date: Sat, 23 May 2015 17:42:58 GMT</strong></span>
<span class="strong"><strong>Expires: 0</strong></span>
<span class="strong"><strong>Pragma: no-cache</strong></span>
<span class="strong"><strong>Server: Apache-Coyote/1.1</strong></span>
<span class="strong"><strong>Set-Cookie: JSESSIONID=CE7A9BF903A25A7A8BAD7D4C30E59360; Path=/; HttpOnly</strong></span>
<span class="strong"><strong>Transfer-Encoding: chunked</strong></span>
<span class="strong"><strong>X-Content-Type-Options: nosniff</strong></span>
<span class="strong"><strong>X-Frame-Options: DENY</strong></span>
<span class="strong"><strong>X-XSS-Protection: 1; mode=block</strong></span>
</pre></div><p>You will also <a id="id350" class="indexterm"/>notice that Spring Security automatically added some <a id="id351" class="indexterm"/>common security headers:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Cache Control</code>: This prevents the user from caching secured resources</li><li class="listitem" style="list-style-type: disc"><code class="literal">X-XSS-Protection</code>: This tells the browser to block what looks like CSS</li><li class="listitem" style="list-style-type: disc"><code class="literal">X-Frame-Options</code>: This disallows our site from being embedded in an IFrame</li><li class="listitem" style="list-style-type: disc"><code class="literal">X-Content-Type-Options</code>: This prevents browsers from guessing the MIME types of malicious resources used to forge XSS attacks</li></ul></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note14"/>Note</h3><p>A comprehensive<a id="id352" class="indexterm"/> list of these headers is available at <a class="ulink" href="http://docs.spring.io/spring-security/site/docs/current/reference/htmlsingle/#headers">http://docs.spring.io/spring-security/site/docs/current/reference/htmlsingle/#headers</a>.</p></div></div></div><div class="section" title="Authorized URLs"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec45"/>Authorized URLs</h2></div></div></div><p>Annotating <a id="id353" class="indexterm"/>our controller is very easy but isn't always <a id="id354" class="indexterm"/>the most viable option. Sometimes, we just want total control over our authorization.</p><p>Remove the <code class="literal">@Secured</code> annotation; we will come up with something better.</p><p>Let's see what Spring Security will allow us to do by modifying the <code class="literal">SecurityConfiguration</code> class:</p><div class="informalexample"><pre class="programlisting">@Configuration
@EnableGlobalMethodSecurity(securedEnabled = true)
public class SecurityConfiguration extends WebSecurityConfigurerAdapter {

    @Autowired
    public void configureAuth(AuthenticationManagerBuilder auth)
        throws Exception {
        auth.inMemoryAuthentication()
            .withUser("user").password("user").roles("USER").and()
            .withUser("admin").password("admin").roles("USER", "ADMIN");
    }

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
            .httpBasic()
            .and()
            .csrf().disable()
            .authorizeRequests()
            .antMatchers("/login", "/logout").permitAll()
            .antMatchers(HttpMethod.GET, "/api/**").hasRole("USER")
            .antMatchers(HttpMethod.POST, "/api/**").hasRole("ADMIN")
            .antMatchers(HttpMethod.PUT, "/api/**").hasRole("ADMIN")
            .antMatchers(HttpMethod.DELETE, "/api/**").hasRole("ADMIN")
            .anyRequest().authenticated();
    }
}</pre></div><p>In the preceding code sample, we configured our application's security policy by using Spring Security's fluent API.</p><p>This API allows us to configure Spring Security globally by invoking methods associated with different security concerns and chaining with the <code class="literal">and()</code> method.</p><p>What we just defined is a basic authentication, without CSRF protection. Requests on <code class="literal">/login</code> and <code class="literal">/logout</code> will be allowed for all users. <code class="literal">GET</code> requests on the API will only be permitted for <a id="id355" class="indexterm"/>users with the <code class="literal">USER</code> role, whereas <code class="literal">POST</code>, <code class="literal">PUT</code>, and <code class="literal">DELETE</code> requests on the API will only be accessible to users with the<a id="id356" class="indexterm"/> ADMIN roles. Finally, every other request will require authentication with any role.</p><p>CSRF stands for <span class="strong"><strong>Cross Site Request Forgery</strong></span> and refers to an attack where a malicious website would <a id="id357" class="indexterm"/>display a form on its website and post the form data on yours. If the user of your site is not signed out, the <code class="literal">POST</code> request would retain the user cookies and would therefore be authorized.</p><p>CSRF protection will generate short-lived tokens that will be posted along with the form data. We will <a id="id358" class="indexterm"/>see how to properly enable it in the next section; for now, let's just disable it. See <a class="ulink" href="http://docs.spring.io/spring-security/site/docs/current/reference/htmlsingle/#csrf">http://docs.spring.io/spring-security/site/docs/current/reference/htmlsingle/#csrf</a> for more details.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note15"/>Note</h3><p>To learn more about the authorize request API, have a look at <a class="ulink" href="http://docs.spring.io/spring-security/site/docs/current/reference/htmlsingle/#authorize-requests">http://docs.spring.io/spring-security/site/docs/current/reference/htmlsingle/#authorize-requests</a>.</p></div></div></div><div class="section" title="Thymeleaf security tags"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec46"/>Thymeleaf security tags</h2></div></div></div><p>Sometimes, you <a id="id359" class="indexterm"/>will need to display data <a id="id360" class="indexterm"/>coming from the authentication layer, for example the user's name and roles, or hide and display part of a web page according to users' authorities. The <code class="literal">thymeleaf-extras-springsecurity</code> module will allow us to do so.</p><p>Add the following dependency to your <code class="literal">build.gradle</code> file:</p><div class="informalexample"><pre class="programlisting">compile 'org.thymeleaf.extras:thymeleaf-extras-springsecurity3'</pre></div><p>With this library, we can add a little block under our navigation bar in <code class="literal">layout/default.html</code> to display the logged-in user:</p><div class="informalexample"><pre class="programlisting">&lt;!DOCTYPE html&gt;
&lt;html 
      
      <span class="strong"><strong>&gt;</strong></span>
&lt;head&gt;
  &lt;!-- content trimmed --&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;!-- content trimmed --&gt;
&lt;nav&gt;
    &lt;div class="nav-wrapper indigo"&gt;
        &lt;ul class="right"&gt;
        &lt;!-- content trimmed --&gt;
        &lt;/ul&gt;
    &lt;/div&gt;
&lt;/nav&gt;
<span class="strong"><strong>&lt;div&gt;</strong></span>
<span class="strong"><strong>    You are logged as &lt;b sec:authentication="name" /&gt; with roles &lt;span sec:authentication="authorities" /&gt;</strong></span>
<span class="strong"><strong>    -</strong></span>
<span class="strong"><strong>    &lt;form th:action="@{/logout}" method="post" style="display: inline-block"&gt;</strong></span>
<span class="strong"><strong>        &lt;input type="submit" value="Sign Out" /&gt;</strong></span>
<span class="strong"><strong>    &lt;/form&gt;</strong></span>
<span class="strong"><strong>    &lt;hr/&gt;</strong></span>
<span class="strong"><strong>&lt;/div&gt;</strong></span>

&lt;section layout:fragment="content"&gt;
    &lt;p&gt;Page content goes here&lt;/p&gt;
&lt;/section&gt;

&lt;!-- content trimmed --&gt;
&lt;/body&gt;
&lt;/html&gt;</pre></div><p>Note the new <a id="id361" class="indexterm"/>namespace in the HTML declaration <a id="id362" class="indexterm"/>and the <code class="literal">sec:authentication</code> attributes. It allows access to the properties of the <code class="literal">org.springframework.security.core.Authentication</code> object, which represents the user who is currently logged in, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/2117_06_02.jpg" alt="Thymeleaf security tags"/></div><p>Don't click on the logout link just yet as it doesn't work with basic authentication. We will get it to work in the next part.</p><p>The <code class="literal">lib</code> tag also <a id="id363" class="indexterm"/>has a handful of other<a id="id364" class="indexterm"/> tags, such as the one to check user authorizations:</p><div class="informalexample"><pre class="programlisting">&lt;div sec:authorize="hasRole('ROLE_ADMIN')"&gt;
    You are an administrator
&lt;/div&gt;</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note16"/>Note</h3><p>Please refer to<a id="id365" class="indexterm"/> the documentation available at <a class="ulink" href="https://github.com/thymeleaf/thymeleaf-extras-springsecurity">https://github.com/thymeleaf/thymeleaf-extras-springsecurity</a> to learn more about the library.</p></div></div></div></div></div>
<div class="section" title="The login form"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec55"/>The login form</h1></div></div></div><p>Basic authentication is good for our RESTful API, but we would rather have a login page carefully <a id="id366" class="indexterm"/>designed by our team to improve the web experience.</p><p>Spring Security allows us to define as many <code class="literal">WebSecurityConfigurerAdapter</code> classes as we need. We will split our <code class="literal">SecurityConfiguration</code> class into two parts:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">ApiSecurityConfiguration</code>: This will be configured first. This will secure the RESTful endpoints with basic authentication.</li><li class="listitem" style="list-style-type: disc"><code class="literal">WebSecurityConfiguration</code>: This will then configure login form for the rest of our application.</li></ul></div><p>You can remove or rename <code class="literal">SecurityConfiguration</code> and create <code class="literal">ApiSecurityConfiguration</code> instead:</p><div class="informalexample"><pre class="programlisting">@Configuration
<span class="strong"><strong>@Order(1)</strong></span>
public class ApiSecurityConfiguration extends WebSecurityConfigurerAdapter {

    @Autowired
    public void configureAuth(AuthenticationManagerBuilder auth)
        throws Exception {
        auth.inMemoryAuthentication()
            .withUser("user").password("user").roles("USER").and()
            .withUser("admin").password("admin").roles("USER", "ADMIN");
    }

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
            .antMatcher("/api/**")
            .httpBasic().and()
            .csrf().disable()
            .authorizeRequests()
            .antMatchers(HttpMethod.GET).hasRole("USER")
            .antMatchers(HttpMethod.POST).hasRole("ADMIN")
            .antMatchers(HttpMethod.PUT).hasRole("ADMIN")
            .antMatchers(HttpMethod.DELETE).hasRole("ADMIN")
            .anyRequest().authenticated();
    }
}</pre></div><p>Note the <code class="literal">@Order(1)</code> annotation, which will ensure that this configuration is executed before the<a id="id367" class="indexterm"/> other one. Then, create a second configuration for the web, called <code class="literal">WebSecurityConfiguration</code>:</p><div class="informalexample"><pre class="programlisting">package masterSpringMvc.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;

@Configuration
public class WebSecurityConfiguration extends WebSecurityConfigurerAdapter {

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
                .formLogin()
                .defaultSuccessUrl("/profile")
                .and()
                .logout().logoutSuccessUrl("/login")
                .and()
                .authorizeRequests()
                .antMatchers("/webjars/**", "/login").permitAll()
                .anyRequest().authenticated();
    }
}</pre></div><p>The result of this<a id="id368" class="indexterm"/> code is that anything matching <code class="literal">/api/**</code> will be secured with basic authentication, without CSRF protection. Then, the second configuration will be loaded. It will secure anything else. Everything in this part of the application requires the client to be authenticated, except requests on WebJars and on the login page (this will avoid the redirection loop).</p><p>If an unauthenticated user tries to access a protected resource, they will automatically be redirected to the login page.</p><p>By default, the login URL is <code class="literal">GET /login</code>. The default login will be posted via a <code class="literal">POST /login</code> request that will contain three values: a user name (<code class="literal">username</code>), a password (<code class="literal">password</code>) and a CSRF token (<code class="literal">_csrf</code>). If the login is unsuccessful, the user will be redirected to <code class="literal">/login?error</code>. The default logout page is a <code class="literal">POST /logout</code> request with a CSRF token.</p><p>Now, if you try to navigate on your application, this form will be generated automatically!</p><p>If you are already logged in from a previous attempt, close your browser; this will clear up the session.</p><div class="mediaobject"><img src="graphics/2117_06_03.jpg" alt="The login form"/></div><p>We can now log in and out of our application!</p><p>This is lovely but we can do a lot better with very little effort. First, we will define a login page on <code class="literal">/login</code> in the <code class="literal">WebSecurityConfiguration</code> class:</p><div class="informalexample"><pre class="programlisting">@Override
protected void configure(HttpSecurity http) throws Exception {
    http
        .formLogin()
        <span class="strong"><strong>.loginPage("/login")</strong></span> // &lt;= custom login page
        .defaultSuccessUrl("/profile")
        // the rest of the configuration stays the same
}</pre></div><p>This will let us <a id="id369" class="indexterm"/>create our own login page. To do that, we will need a very simple controller to handle the <code class="literal">GET login</code> request. You can create one in the <code class="literal">authentication</code> package:</p><div class="informalexample"><pre class="programlisting">package masterSpringMvc.authentication;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;

@Controller
public class LoginController {

    @RequestMapping("/login")
    public String authenticate() {
        return "login";
    }
}</pre></div><p>This will trigger the display of the <code class="literal">login.html</code> page located in the template directory. Let's create it:</p><div class="informalexample"><pre class="programlisting">&lt;!DOCTYPE HTML&gt;
&lt;html 
      
      layout:decorator="layout/default"&gt;
&lt;head&gt;
    &lt;title&gt;Login&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div class="section no-pad-bot" layout:fragment="content"&gt;
    &lt;div class="container"&gt;

        &lt;h2 class="header center orange-text"&gt;Login&lt;/h2&gt;

        &lt;div class="row"&gt;
            &lt;div id="errorMessage" class="card-panel red lighten-2" th:if="${param.error}"&gt;
                &lt;span class="card-title"&gt;Invalid user name or password&lt;/span&gt;
            &lt;/div&gt;

            &lt;form class="col s12" action="/login" method="post"&gt;
                &lt;div class="row"&gt;
                    &lt;div class="input-field col s12"&gt;
                        &lt;input id="username" name="username" type="text" class="validate"/&gt;
                        &lt;label for="username"&gt;Username&lt;/label&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
                &lt;div class="row"&gt;
                    &lt;div class="input-field col s12"&gt;
                        &lt;input id="password" name="password" type="password" class="validate"/&gt;
                        &lt;label for="password"&gt;Password&lt;/label&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
                &lt;div class="row center"&gt;
                    &lt;button class="btn waves-effect waves-light" type="submit" name="action"&gt;Submit
                        &lt;i class="mdi-content-send right"&gt;&lt;/i&gt;
                    &lt;/button&gt;
                &lt;/div&gt;
                &lt;input type="hidden" th:name="${_csrf.parameterName}" th:value="${_csrf.token}"/&gt;
            &lt;/form&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;</pre></div><p>Note that we<a id="id370" class="indexterm"/> handle the error message and that we post a CSRF token. We also use the default username and password input names, but those are configurable if needed. The result looks much better already!</p><div class="mediaobject"><img src="graphics/2117_06_04.jpg" alt="The login form"/></div><p>You can<a id="id371" class="indexterm"/> see right away that Spring Security assigns anonymous credentials to all non-authenticated users by default.</p><p>We shouldn't show the sign-out button to an anonymous user so we can wrap the corresponding HTML part in <code class="literal">sec:authorize="isAuthenticated()"</code> to display it to authenticated users only, like so:</p><div class="informalexample"><pre class="programlisting">&lt;div <span class="strong"><strong>sec:authorize="isAuthenticated()"</strong></span>&gt;
    You are logged as &lt;b sec:authentication="name"/&gt; with roles &lt;span sec:authentication="authorities"/&gt;
    -
    &lt;form th:action="@{/logout}" method="post" style="display: inline-block"&gt;
        &lt;input type="submit" value="Sign Out"/&gt;
    &lt;/form&gt;
    &lt;hr/&gt;
&lt;/div&gt;</pre></div></div>
<div class="section" title="Twitter authentication"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec56"/>Twitter authentication</h1></div></div></div><p>Our application is strongly integrated with Twitter, so it seems logical that we would allow <a id="id372" class="indexterm"/>authentication through Twitter.</p><p>Before going <a id="id373" class="indexterm"/>further, make sure that you have enabled Twitter sign in on your app on Twitter (<a class="ulink" href="https://apps.twitter.com">https://apps.twitter.com</a>):</p><div class="mediaobject"><img src="graphics/2117_6_5.jpg" alt="Twitter authentication"/></div><div class="section" title="Setting up social authentication"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec47"/>Setting up social authentication</h2></div></div></div><p>Spring social enables authentication through an OAuth provider such as Twitter through a signin/signup scenario. It will intercept a <code class="literal">POST</code> request on <code class="literal">/signin/twitter</code>. If the user is not known to the <code class="literal">UsersConnectionRepository</code> interface, the <code class="literal">signup</code> endpoint will be called. It will allow us to<a id="id374" class="indexterm"/> take the necessary measures to register the user on our system and maybe ask them for additional details.</p><p>Let's get to work. The first thing we need to do is to add the <code class="literal">signin/**</code> and <code class="literal">/signup</code> URLs as publicly available resources. Let's modify our <code class="literal">WebSecurityConfiguration</code> class, changing the <code class="literal">permitAll</code> line:</p><div class="informalexample"><pre class="programlisting">.antMatchers("/webjars/**", "/login", "/signin/**", "/signup").permitAll()</pre></div><p>To enable the signin/signup scenario, we also need a <code class="literal">SignInAdapter</code> interface, a simple listener that will be called when an already known user signs in again.</p><p>We can create an <code class="literal">AuthenticatingSignInAdapter</code> class right next to our <code class="literal">LoginController</code>:</p><div class="informalexample"><pre class="programlisting">package masterSpringMvc.authentication;

import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.social.connect.Connection;
import org.springframework.social.connect.UserProfile;
import org.springframework.social.connect.web.SignInAdapter;
import org.springframework.stereotype.Component;
import org.springframework.web.context.request.NativeWebRequest;

@Component
public class AuthenticatingSignInAdapter implements SignInAdapter {

    public static void authenticate(Connection&lt;?&gt; connection) {
        UserProfile userProfile = connection.fetchUserProfile();
        String username = userProfile.getUsername();
        UsernamePasswordAuthenticationToken authentication = new UsernamePasswordAuthenticationToken(username, null, null);
        SecurityContextHolder.getContext().setAuthentication(authentication);
        System.out.println(String.format("User %s %s connected.", userProfile.getFirstName(), userProfile.getLastName()));
    }

    @Override
    public String signIn(String userId, Connection&lt;?&gt; connection, NativeWebRequest request) {
        authenticate(connection);
        return null;
    }
}</pre></div><p>As you can <a id="id375" class="indexterm"/>see, this handler is called at the perfect time to allow user authentication with Spring Security. We'll come back to that in just a moment. For now, we need to define our <code class="literal">SignupController</code> class in the same package, the one in charge of first-time visiting users:</p><div class="informalexample"><pre class="programlisting">package masterSpringMvc.authentication;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.social.connect.Connection;
import org.springframework.social.connect.ConnectionFactoryLocator;
import org.springframework.social.connect.UsersConnectionRepository;
import org.springframework.social.connect.web.ProviderSignInUtils;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.context.request.WebRequest;

@Controller
public class SignupController {
    private final ProviderSignInUtils signInUtils;

    @Autowired
    public SignupController(ConnectionFactoryLocator connectionFactoryLocator, UsersConnectionRepository connectionRepository) {
        signInUtils = new ProviderSignInUtils(connectionFactoryLocator, connectionRepository);
    }

    @RequestMapping(value = "/signup")
    public String signup(WebRequest request) {
        Connection&lt;?&gt; connection = signInUtils.getConnectionFromSession(request);
        if (connection != null) {
            AuthenticatingSignInAdapter.authenticate(connection);
            signInUtils.doPostSignUp(connection.getDisplayName(), request);
        }
        return "redirect:/profile";
    }
}</pre></div><p>First, this <a id="id376" class="indexterm"/>controller retrieves the current connection from the session. Then, it authenticates the user through the same method as before. Lastly, it will trigger the <code class="literal">doPostSignUp</code> event, which will allow Spring Social to store information relative to our user in the <code class="literal">UsersConnectionRepository</code> interface that we mentioned earlier.</p><p>The last thing we need to do is add a triumphant "login with twitter" button to our login page, right below the previous form:</p><div class="informalexample"><pre class="programlisting">&lt;form th:action="@{/signin/twitter}" method="POST" class="center"&gt;
    &lt;div class="row"&gt;
        &lt;button class="btn indigo" name="twitterSignin" type="submit"&gt;Connect with Twitter
            &lt;i class="mdi-social-group-add left"&gt;&lt;/i&gt;
        &lt;/button&gt;
    &lt;/div&gt;
&lt;/form&gt;</pre></div><div class="mediaobject"><img src="graphics/2117_06_06.jpg" alt="Setting up social authentication"/></div><p>When the <a id="id377" class="indexterm"/>user clicks on the <span class="strong"><strong>CONNECT WITH TWITTER</strong></span> button, they will be redirected to a Twitter sign in page:</p><div class="mediaobject"><img src="graphics/2117_06_07.jpg" alt="Setting up social authentication"/></div></div><div class="section" title="Explanation"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec48"/>Explanation</h2></div></div></div><p>There isn't much code, but it is a bit tricky to understand all the parts. The first step to getting what's going <a id="id378" class="indexterm"/>on is to have a look at the <code class="literal">SocialWebAutoConfiguration</code> class of Spring Boot.</p><p>The <code class="literal">SocialAutoConfigurationAdapter</code> class declared in this class contains the following bean:</p><div class="informalexample"><pre class="programlisting">@Bean
@ConditionalOnBean(SignInAdapter.class)
@ConditionalOnMissingBean(ProviderSignInController.class)
public ProviderSignInController signInController(
        ConnectionFactoryLocator factoryLocator,
        UsersConnectionRepository usersRepository, SignInAdapter signInAdapter) {
    ProviderSignInController controller = new ProviderSignInController(
            factoryLocator, usersRepository, signInAdapter);
    <span class="strong"><strong>if (!CollectionUtils.isEmpty(this.signInInterceptors)) {</strong></span>
<span class="strong"><strong>        controller.setSignInInterceptors(this.signInInterceptors);</strong></span>
    }
    return controller;
}</pre></div><p>The <code class="literal">ProviderSignInController</code> class will automatically be set up if one <code class="literal">ProviderSignInController</code> class is detected in our configuration. This controller is the cornerstone<a id="id379" class="indexterm"/> of the sign-in process. Have a look at what it does (I will only summarize the important parts):</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">It will handle the <code class="literal">POST /signin/{providerId}</code> from our connect button</li><li class="listitem" style="list-style-type: disc">It will redirect the user to the appropriate sign-in URL of our identification provider</li><li class="listitem" style="list-style-type: disc">It will be notified of the OAuth token by a <code class="literal">GET /signin/{providerId}</code> from the identification provider</li><li class="listitem" style="list-style-type: disc">It will then handle the sign in</li><li class="listitem" style="list-style-type: disc">If the user is not found in the <code class="literal">UsersConnectionRepository</code> interface, it will use a <code class="literal">SessionStrategy</code> interface to store the pending login request and will then redirect to the <code class="literal">signupUrl</code> page</li><li class="listitem" style="list-style-type: disc">If the user is found, the <code class="literal">SignInAdapter</code> interface is called and the user is redirected to the <code class="literal">postSignupUrl</code> page</li></ul></div><p>The two important components of this identification are the <code class="literal">UsersConnectionRepository</code> interface in charge of storing and retrieving users from some kind of storage and the <code class="literal">SessionStrategy</code> interface that will temporarily store the user connection so it can be retrieved from the <code class="literal">SignupController</code> class.</p><p>By default, Spring Boot creates an <code class="literal">InMemoryUsersConnectionRepository</code> interface for each authentication provider, which means that our user connection data will be stored in memory. If we restart the server, the user will become unknown and will go through the sign-up process again.</p><p>The <code class="literal">ProviderSignInController</code> class defaults to <code class="literal">HttpSessionSessionStrategy</code>, which will store the connection in the HTTP session. The <code class="literal">ProviderSignInUtils</code> class that we use in our <code class="literal">SignupController</code> class also uses this strategy by default. If we were distributing our application on multiple servers, this would be problematic because the session would likely not be available on every server.</p><p>It is easy enough to override these defaults by providing a custom <code class="literal">SessionStrategy</code> interface to both the <code class="literal">ProviderSignInController</code> and <code class="literal">ProviderSignInUtils</code> classes to store data somewhere other than in the HTTP session.</p><p>Likewise, we can use another kind of storage for our user connection data by providing another implementation of the <code class="literal">UsersConnectionRepository</code> interface.</p><p>Spring Social provides a <code class="literal">JdbcUsersConnectionRepository</code> interface that will automatically save authenticated users in a <code class="literal">UserConnection</code> table in your database. This won't be covered in this book extensively, but you should be able to configure it easily by adding the following<a id="id380" class="indexterm"/> bean to your configuration:</p><div class="informalexample"><pre class="programlisting">@Bean
@Primary
public UsersConnectionRepository getUsersConnectionRepository(
  DataSource dataSource, ConnectionFactoryLocator connectionFactoryLocator) {
    return new JdbcUsersConnectionRepository(
      dataSource, connectionFactoryLocator, Encryptors.noOpText());
}</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note17"/>Note</h3><p>Check <a id="id381" class="indexterm"/>out this article <a class="ulink" href="http://geowarin.github.io/spring/2015/08/02/social-login-with-spring.html">http://geowarin.github.io/spring/2015/08/02/social-login-with-spring.html</a> on my blog for more details.</p></div></div></div></div>
<div class="section" title="Distributed sessions"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec57"/>Distributed sessions</h1></div></div></div><p>As we have seen in the preceding section, there are several moments when Spring Social stores things <a id="id382" class="indexterm"/>in the HTTP session. Our user profile is also stored in the session. This is a classical approach to keeping things in memory as long as a user is navigating the site.</p><p>However, this can prove troublesome if we want to scale our application and distribute the load to multiple backend servers. We have now entered the cloud era, and <a class="link" href="ch08.html" title="Chapter 8. Optimizing Your Requests">Chapter 8</a>, <span class="emphasis"><em>Optimizing Your Requests</em></span> will be about deploying our application to the cloud.</p><p>To make our <a id="id383" class="indexterm"/>session work in a distributed environment, we have a few options:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">We could use sticky sessions. This will ensure that a specific user will always be redirected to the same server and keep its session. It requires additional configuration for the deployment and isn't a particularly elegant approach.</li><li class="listitem" style="list-style-type: disc">Refactor our code to put data in a database instead of the session. We can then load the user's data from the database if we associate it with a cookie or a token sent by the client with each request.</li><li class="listitem" style="list-style-type: disc">Use the Spring Session project to transparently use a distributed database such as Redis as the underlying session provider.</li></ul></div><p>In this chapter, we will see how to set up the third approach. It is really easy to set up and provides the amazing benefit that it can be turned off without impacting the functionality of our application.</p><p>The first thing we need to do is to install Redis. To install it on Mac, use the <code class="literal">brew</code> command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>brew install redis</strong></span>
</pre></div><p>For other platforms, follow <a id="id384" class="indexterm"/>the instructions at <a class="ulink" href="http://redis.io/download">http://redis.io/download</a>.</p><p>You can then start the server by using the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>redis-server</strong></span>
</pre></div><p>Add the following dependencies to your <code class="literal">build.gradle</code> file:</p><div class="informalexample"><pre class="programlisting">compile 'org.springframework.boot:spring-boot-starter-redis'
compile 'org.springframework.session:spring-session:1.0.1.RELEASE'</pre></div><p>Create a new <a id="id385" class="indexterm"/>configuration file next to <code class="literal">application.properties</code> called <code class="literal">application-redis.properties</code>:</p><div class="informalexample"><pre class="programlisting">spring.redis.host=localhost
spring.redis.port=6379</pre></div><p>Spring Boot provides a convenient way of associating configuration files with a profile. In this case, the <code class="literal">application-redis.properties</code> file will only be loaded if the Redis profile is active.</p><p>Then, create a <code class="literal">RedisConfig</code> class in the <code class="literal">config</code> package:</p><div class="informalexample"><pre class="programlisting">package masterSpringMvc.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Profile;
import org.springframework.session.data.redis.config.annotation.web.http.EnableRedisHttpSession;

@Configuration
@Profile("redis")
@EnableRedisHttpSession
public class RedisConfig {
}</pre></div><p>As you can see, this configuration will only be active if the <code class="literal">redis</code> profile is on.</p><p>We're done! We can now launch our app with the following flag:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>-Dspring.profiles.active=redis</strong></span>
</pre></div><p>You can also generate the JAR with <code class="literal">gradlew build</code> and launch it with the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>java -Dserver.port=$PORT -Dspring.profiles.active=redis -jar app.jar</strong></span>
</pre></div><p>Alternatively, you can launch it with Gradle in Bash, as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>SPRING_PROFILES_ACTIVE=redis ./gradlew bootRun</strong></span>
</pre></div><p>You can also simply set it up as a JVM option in the run configuration of your IDE.</p><p>And that's it! You now have a server storing the details of your logged-in users. This means that we can scale and have multiple servers for our web resources and our users won't notice. And we didn't have to write any code on our side.</p><p>This also<a id="id386" class="indexterm"/> means that you will keep your session even if you restart your server.</p><p>To see that it works, connect to Redis with the <code class="literal">redis-cli</code> command. At the beginning, it will not contain any keys:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; redis-cli</strong></span>
<span class="strong"><strong>127.0.0.1:6379&gt; KEYS *</strong></span>
<span class="strong"><strong>(empty list or set)</strong></span>
</pre></div><p>Navigate to your app and start putting things in the session:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>127.0.0.1:6379&gt; KEYS *</strong></span>
<span class="strong"><strong>1) "spring:session:expirations:1432487760000"</strong></span>
<span class="strong"><strong>2) "spring:session:sessions:1768a55b-081a-4673-8535-7449e5729af5"</strong></span>
<span class="strong"><strong>127.0.0.1:6379&gt; HKEYS spring:session:sessions:1768a55b-081a-4673-8535-7449e5729af5</strong></span>
<span class="strong"><strong>1) "sessionAttr:SPRING_SECURITY_CONTEXT"</strong></span>
<span class="strong"><strong>2) "sessionAttr:org.springframework.security.web.csrf.HttpSessionCsrfTokenRepository.CSRF_TOKEN"</strong></span>
<span class="strong"><strong>3) "lastAccessedTime"</strong></span>
<span class="strong"><strong>4) "maxInactiveInterval"</strong></span>
<span class="strong"><strong>5) "creationTime"</strong></span>
</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note18"/>Note</h3><p>You can consult the list of available commands at <a class="ulink" href="http://redis.io/commands">http://redis.io/commands</a>.</p></div></div></div>
<div class="section" title="SSL"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec58"/>SSL</h1></div></div></div><p>
<span class="strong"><strong>Secure Sockets Layer</strong></span> (<span class="strong"><strong>SSL</strong></span>) is a security protocol in which data is encrypted and sent to a trusted party via a<a id="id387" class="indexterm"/> certificate. In this part, I will show you the different ways to create a secured connection with Spring Boot. The completion of these steps is not mandatory to start the next chapter. They are included for completeness, so feel free to skip them if you are in a hurry to deploy your application to the cloud.</p><p>In <a class="link" href="ch09.html" title="Chapter 9. Deploying Your Web Application to the Cloud">Chapter 9</a>, <span class="emphasis"><em>Deploying Your Web Application to the Cloud</em></span>, we will see that most cloud platforms already handle SSL so we don't have to configure it at our end.</p><div class="section" title="Generating a self-signed certificate"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec49"/>Generating a self-signed certificate</h2></div></div></div><p>Normally, X.509 certificates are delivered by a Certificate Authority. They generally bill you for the <a id="id388" class="indexterm"/>service, so for testing purposes, we can create our own self-signed keystore file.</p><p>The JDK comes <a id="id389" class="indexterm"/>with a binary called keytool, which is used to manage certificates. With it, you can create a keystore and import certificates into an existing keystore. You can issue the following command inside your project root to create one:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ keytool -genkey -alias masterspringmvc -keyalg RSA -keystore src/main/resources/tomcat.keystore</strong></span>
<span class="strong"><strong>Enter keystore password: password</strong></span>
<span class="strong"><strong>Re-enter new password: password</strong></span>
<span class="strong"><strong>What is your first and last name?</strong></span>
<span class="strong"><strong>  [Unknown]:  Master Spring MVC</strong></span>
<span class="strong"><strong>What is the name of your organizational unit?</strong></span>
<span class="strong"><strong>  [Unknown]:  Packt</strong></span>
<span class="strong"><strong>What is the name of your organization?</strong></span>
<span class="strong"><strong>  [Unknown]:  Packt</strong></span>
<span class="strong"><strong>What is the name of your City or Locality?</strong></span>
<span class="strong"><strong>  [Unknown]:  Paris</strong></span>
<span class="strong"><strong>What is the name of your State or Province?</strong></span>
<span class="strong"><strong>  [Unknown]:  France</strong></span>
<span class="strong"><strong>What is the two-letter country code for this unit?</strong></span>
<span class="strong"><strong>  [Unknown]:  FR</strong></span>
<span class="strong"><strong>Is CN=Master Spring MVC, OU=Packt, O=Packt, L=Paris, ST=France, C=FR correct?</strong></span>
<span class="strong"><strong>  [no]:  yes</strong></span>

<span class="strong"><strong>Enter key password for &lt;masterspringmvc&gt;</strong></span>
<span class="strong"><strong>        (RETURN if same as keystore password): password2</strong></span>
<span class="strong"><strong>Re-enter new password: password2</strong></span>
</pre></div><p>This will generate a keystore named <code class="literal">masterspringmvc</code> with the RSA algorithm and will store it in a keystore in <code class="literal">src/main/resources</code>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip19"/>Tip</h3><p>Do not push the keystore to your repository. It can be brute-forced, which would void the security of your website. You should also generate keystores with strong, randomly generated passwords.</p></div></div></div><div class="section" title="The easy way"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec50"/>The easy way</h2></div></div></div><p>If all you care about is <a id="id390" class="indexterm"/>having one secure https channel and no http channel, it is as easy as it gets:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>server.port = 8443</strong></span>
<span class="strong"><strong>server.ssl.key-store = classpath:tomcat.keystore
 server.ssl.key-store-password = password</strong></span>
<span class="strong"><strong>server.ssl.key-password = password2</strong></span>
</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip20"/>Tip</h3><p>Do not push <a id="id391" class="indexterm"/>your passwords to your repository. Use the <code class="literal">${}</code> notation to import environment variables.</p></div></div></div><div class="section" title="The dual way"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec51"/>The dual way</h2></div></div></div><p>If you want to have both the http and the https channels available in your application, you should add <a id="id392" class="indexterm"/>this kind of configuration to your application:</p><div class="informalexample"><pre class="programlisting">@Configuration
public class SslConfig {

    @Bean
    public EmbeddedServletContainerFactory servletContainer() throws IOException {
        TomcatEmbeddedServletContainerFactory tomcat = new TomcatEmbeddedServletContainerFactory();
        tomcat.addAdditionalTomcatConnectors(createSslConnector());
        return tomcat;
    }

    private Connector createSslConnector() throws IOException {
        Connector connector = new Connector(Http11NioProtocol.class.getName());
        Http11NioProtocol protocol =
                (Http11NioProtocol) connector.getProtocolHandler();
        connector.setPort(8443);
        connector.setSecure(true);
        connector.setScheme("https");
        protocol.setSSLEnabled(true);
        protocol.setKeyAlias("masterspringmvc");
        protocol.setKeystorePass("password");
        protocol.setKeyPass("password2");
        protocol.setKeystoreFile(new ClassPathResource("tomcat.keystore").getFile().getAbsolutePath());
        protocol.setSslProtocol("TLS");
        return connector;
    }
}</pre></div><p>This will load the previously generated keystore to create an additional channel on port 8443 in addition to port 8080.</p><p>You can use Spring Security to automatically redirect connections from <code class="literal">http</code> to <code class="literal">https</code> with the<a id="id393" class="indexterm"/> following configuration:</p><div class="informalexample"><pre class="programlisting">@Configuration
public class WebSecurityConfiguration extends WebSecurityConfigurerAdapter {

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
            .requiresChannel().anyRequest().requiresSecure()
            .and()
            /* rest of the configuration */;
    }
}</pre></div></div><div class="section" title="Behind a secured server"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec52"/>Behind a secured server</h2></div></div></div><p>The most convenient way to secure your application with SSL is often to put it behind an SSL-enabled <a id="id394" class="indexterm"/>web server such as Apache or CloudFlare. These will often use de facto headers to indicate that the connection was previously initiated with SSL.</p><p>Spring Boot can understand this protocol if you tell it what the correct headers are in your <code class="literal">application.properties</code> file:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>server.tomcat.remote_ip_header=x-forwarded-for</strong></span>
<span class="strong"><strong>server.tomcat.protocol_header=x-forwarded-proto</strong></span>
</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note19"/>Note</h3><p>See the<a id="id395" class="indexterm"/> documentation here for more details at <a class="ulink" href="http://docs.spring.io/spring-boot/docs/current/reference/html/howto-embedded-servlet-containers.html#howto-use-tomcat-behind-a-proxy-server">http://docs.spring.io/spring-boot/docs/current/reference/html/howto-embedded-servlet-containers.html#howto-use-tomcat-behind-a-proxy-server</a>.</p></div></div></div></div>
<div class="section" title="The check point"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec59"/>The check point</h1></div></div></div><p>In this chapter, we added three pieces of configuration: <code class="literal">ApiSecurityConfiguration</code>, which configures our REST API to use basic HTTP authentication; <code class="literal">WebSecurityConfiguration</code>, which sets up a login form for our web users to sign in with either an account or with Twitter; and <code class="literal">RedisConfig</code>, which allows our sessions to be stored and retrieved from a Redis server.</p><p>In the authentication package, we added a <code class="literal">LoginController</code> class that redirects to our login page, a <code class="literal">SignupController</code> class that will be called the first time a user signs up with Twitter, and an <code class="literal">AuthenticatingSignInAdapater</code> class that will be called on every login with Twitter:</p><div class="mediaobject"><img src="graphics/2117_06_08.jpg" alt="The check point"/></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec60"/>Summary</h1></div></div></div><p>Securing our web application with Spring is really simple. The possibilities are endless, and advanced configurations such as social sign in are at your fingertips. Distributing sessions and scaling also take a matter of minutes.</p><p>In the next chapter, we will see how to test our application and ensure it never regresses.</p></div></body></html>