<html><head></head><body><div class="chapter" title="Chapter&#xA0;9.&#xA0;Design Your REST API" id="aid-38STS1"><div class="titlepage"><div><div><h1 class="title"><a id="ch09"/>Chapter 9. Design Your REST API</h1></div></div></div><p>In the previous chapter, we added a new chat feature in our app using Akka. Our web application is close to the end. This chapter will add the REST API in our Play framework application.</p><p>We will also create a Scala client using the <code class="literal">ws</code> library from the Play framework in order to call our REST API. Later in this chapter, we will add Swagger support and embed the Swagger UI in our app.</p><p>In this chapter, we will cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">REST and API design</li><li class="listitem">Creating our API with REST and JSON</li><li class="listitem">Creating a Scala client</li><li class="listitem">Adding validations</li><li class="listitem">Adding back pressure</li><li class="listitem">Adding Swagger support</li></ul></div><div class="section" title="Introduction to REST"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec102"/>Introduction to REST</h1></div></div></div><p>
<span class="strong"><strong>Representational State Transfer</strong></span> (<span class="strong"><strong>REST</strong></span>) is an architectural style. It was defined by Roy Fielding in his doctoral dissertation. REST happens over the HTTP 1.1 protocol using HTTP verbs, such as <code class="literal">GET</code>, <code class="literal">POST</code>, <code class="literal">DELETE</code>, <code class="literal">PUT</code>, and <span class="strong"><strong>Uniform Resource Identifier</strong></span> (<span class="strong"><strong>URI</strong></span>), for instance, <code class="literal">/users/profile/1</code> or <code class="literal">sales/cart/add/2</code>.</p><p>The REST architecture has the following properties:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong>Simplicity</strong></span>: Pretty much all languages have libraries to manipulate HTTP URIs.</li><li class="listitem"><span class="strong"><strong>Interoperability</strong></span>: REST is language, platform, and OS agnostic.</li><li class="listitem"><span class="strong"><strong>Scalable and Reliable</strong></span>: As REST is based on HTTP, you can use the HTTP server to scale up your application in conjunction with HTTP load balancer, the HTTP caches, and HTTP DNS.</li><li class="listitem"><span class="strong"><strong>Separation of Concerns</strong></span> (<span class="strong"><strong>SOC</strong></span>): As you have a URI, that's your contract, not the code, underlying backend, or database. This means that you can change the database or language without affecting the code.</li><li class="listitem"><span class="strong"><strong>Client</strong></span>/<span class="strong"><strong>Server</strong></span>: There is a server that provides the REST interface and the clients, which call the REST endpoints.</li></ul></div><p>Web services that embrace the REST principles are often called RESTful.</p></div></div>
<div class="section" title="REST API design"><div class="titlepage" id="aid-39REE2"><div><div><h1 class="title"><a id="ch09lvl1sec103"/>REST API design</h1></div></div></div><p>When you are working with REST, there are some principles that you should keep in mind, and these principles should provide guidance for your design choices when you are doing API design.</p><div class="section" title="HTTP verbs design"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec106"/>HTTP verbs design</h2></div></div></div><p>These are the following verbs found in HTTP:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">GET</code>: This is often used to answer queries</li><li class="listitem"><code class="literal">PUT</code>: This is often used to insert data</li><li class="listitem"><code class="literal">POST</code>: This is often used to update data</li><li class="listitem"><code class="literal">DELETE</code>: This is often used to remove data</li></ul></div><p>Why do we keep saying often? Well, there are some exceptions in regards of size limitations. For instance, for the <code class="literal">GET</code> verb, we can't have a request bigger than 8192 bytes or 8 KB. If you need to send a bigger payload, we will need to use the <code class="literal">POST</code> verb.</p></div><div class="section" title="Uniform API"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec107"/>Uniform API</h2></div></div></div><p>REST uses a uniform API. For example, consider the following piece of code:</p><pre class="programlisting">    GET          /users/1   = List information about user id 1 &#13;
    PUT          /users/1   = Insert user 1 &#13;
    POST         /users/1   = Update user 1 &#13;
    DELETE       /users/1   =  Delete user 1 &#13;
    GET          /users/    = Lists All users &#13;
</pre><p>If we change the resource from users to sales, the API would almost be the same. Retrieving data is done using <code class="literal">GET</code> and update is done via <code class="literal">POST</code>, so it's a uniform API.</p></div><div class="section" title="Response with HTTP status codes"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec108"/>Response with HTTP status codes</h2></div></div></div><p>REST runs the error handler using the HTTP 1.1 status codes. For instance:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong>200 -&gt; OK</strong></span>: This is often used with the <code class="literal">GET</code> verb</li><li class="listitem"><span class="strong"><strong>201 -&gt; Created</strong></span>: This is often used by the <code class="literal">PUT/POST</code> verbs</li><li class="listitem"><span class="strong"><strong>204 -&gt; No Content</strong></span>: This is often for the <code class="literal">DELETE</code> verb</li><li class="listitem"><span class="strong"><strong>400 -&gt; Invalid Request</strong></span>: This often means an invalid request for the <code class="literal">POST/PUT</code> verbs</li><li class="listitem"><span class="strong"><strong>404 -&gt; Not Found</strong></span>: This is often used with the <code class="literal">GET</code> verb</li><li class="listitem"><span class="strong"><strong>500 -&gt; Internal Server Error -</strong></span> <span class="strong"><strong>Unexpected Server Error</strong></span>: This is often used by all the verbs</li></ul></div></div><div class="section" title="REST API patterns"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec109"/>REST API patterns</h2></div></div></div><p>There are some commons patterns for good and clear REST API designs, as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong>Use nouns; do not use verbs</strong></span>: Often, you can use standard URIs, such as <code class="literal">/cars/</code> or <code class="literal">/members/</code>. You should not use <code class="literal">/getCars/</code> or <code class="literal">getMembers/</code> because you are using the URI with a verb, and the verb already tells the actions.</li><li class="listitem"><span class="strong"><strong>GET method should not change state</strong></span>: If you want to change the state of the server, you will need to use verbs such as <code class="literal">PUT</code>, <code class="literal">POST</code>, or <code class="literal">DELETE</code>. <code class="literal">GET</code> should not change the state of the server, so it should always be safe calling <code class="literal">GET</code> as many times as you want. This is called idempotent.</li><li class="listitem"><span class="strong"><strong>Prefer sub-resource relation</strong></span>: Let's say we have a resource called <code class="literal">/users/</code>, and a user has projects. It's always a good idea to use sub-resources, such as <code class="literal">/users/1/projects/2</code>, because we have a relationship between users and projects.</li><li class="listitem"><span class="strong"><strong>Use HTTP headers</strong></span>: HTTP headers should be used for serialization, security, and all the kinds of metadata your application needs. The HTTP Headers are often used for content negotiation. For instance, you might do the following:</li></ul></div><pre class="programlisting">    HTTP HEADER Content-Type = XML - GET /cars/1  &#13;
    HTTP HEADER Content-Type = JSON - GET /cars/1  &#13;
</pre><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">The URI is the same; however, based on the header type, it will return data in XML or JSON format.</li><li class="listitem"><span class="strong"><strong>Filter, Sorting and Pagination</strong></span>: Sometimes, your data may be big. It's always a good idea to provide mechanisms to sort, filter, and paginate as follows:</li></ul></div><pre class="programlisting">    GET /projects/1/tasks?by=priority             -&gt; Sorting  &#13;
    GET /projects/1/tasks?status=done             -&gt; Filter &#13;
    GET /projects/1/tasks?limit=30&amp;offset=5       -&gt; Pagination &#13;
</pre></div><div class="section" title="API versioning"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec110"/>API versioning</h2></div></div></div><p>There are two ways to perform API versioning. First strategy is to version by the endpoint explicit such as <code class="literal">/v1/cars</code>. The second strategy is based on metadata such as <code class="literal">/cars/</code>, but then you will pass an HTTP HEADER version as v1.</p><p>Both strategies have pros and cons. Explicit versioning is more clear, and you can always create a new version and don't break your consumers. Header strategy is more elegant; however, it can get tricky to manage.</p></div><div class="section" title="Some anti-patterns to be avoided"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec111"/>Some anti-patterns to be avoided</h2></div></div></div><p>There are several traps in the REST API design, but the following things need to be avoided:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">GET</code> verb for everything</li><li class="listitem">Ignoring HTTP headers such as MIME-types</li><li class="listitem">Returning 200 when an error happens</li><li class="listitem">Returning 500 for an invalid parameter or a missing parameter</li></ul></div></div></div>
<div class="section" title="Creating our API with REST and JSON"><div class="titlepage" id="aid-3APV02"><div><div><h1 class="title"><a id="ch09lvl1sec104"/>Creating our API with REST and JSON</h1></div></div></div><p>Alright, now is the time to design a REST API for your Play framework application. We will create an API to export all data in the system. This API will be READ only; however, you can add write operations if you like.</p><p>Later on in this chapter, we will add some back pressure to limit the API REST rate for consumers and create a Scala client application for our REST API. So, first of all, let's get started with the Play framework (server) first.</p><p>We don't need any extra library in order to create a REST API in our Play framework application. We will just need a new controller and new routes. Additionally, we will leverage most of the code we made in the previous chapters.</p><div class="section" title="RestApiContoller"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec112"/>RestApiContoller</h2></div></div></div><p>Let's create a new controller located at <code class="literal">ReactiveWebStore/app/controllers</code>.</p><div class="section" title="REST API Front Controller implementation"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec0"/>REST API Front Controller implementation</h3></div></div></div><p>
<code class="literal">RestApiController.scala</code> file should look something like this:</p><pre class="programlisting">    package controllers  &#13;
    @Singleton &#13;
    class RestAPIController @Inject() &#13;
    (val productService:IProductService, &#13;
      val reviewService:IReviewService, &#13;
    val imageService:IImageService) extends Controller {  &#13;
      import play.api.libs.concurrent.Execution.&#13;
      Implicits.defaultContext  &#13;
      def listAllProducts = Action { &#13;
        val future = productService.findAll() &#13;
        val products = Awaits.get(5,future) &#13;
        val json = ProductsJson.toJson(products) &#13;
        Ok(json) &#13;
      }  &#13;
      def listAllReviews = Action { &#13;
        val future = reviewService.findAll() &#13;
        val reviews = Awaits.get(5,future) &#13;
        val json = ReviewsJson.toJson(reviews) &#13;
        Ok(json) &#13;
      } &#13;
      def processImages = { &#13;
        val future = imageService.findAll() &#13;
        val images = Awaits.get(5,future) &#13;
        val json = ImagesJson.toJson(images) &#13;
        json &#13;
      } &#13;
      def listAllImages = Action { &#13;
        Ok(processImages) &#13;
      }&#13;
    } &#13;
</pre><p>Basically, we have three functions here. These functions list all products, images, and reviews. As you can see at the top of the controller, we are injecting the three services that we have for products, images, and reviews.</p><p>The code is pretty much straightforward for all functions. First, we will call the proper service, and then we will wait for the result with the <code class="literal">await</code> object. Once we have the data, we will call a function to convert the data to JSON.</p><p>Let's take a look at the JSON helpers objects that we used here.</p></div></div><div class="section" title="JSON mapping"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec113"/>JSON mapping</h2></div></div></div><p>Our REST controller used JSON helper objects to map objects to JSON. First, we will start with the Products JSON helper.</p><p>
<code class="literal">ProductsJson</code> is located at <code class="literal">ReactiveWebStore/app/controllers/Product.scala</code>:</p><pre class="programlisting">    object ProductsJson {  &#13;
      import play.api.libs.json._ &#13;
      import play.api.libs.json.Reads._ &#13;
      import play.api.libs.functional.syntax._  &#13;
      implicit val productWrites: Writes[Product] = ( &#13;
        (JsPath \ "id").write[Option[Long]] and &#13;
        (JsPath \ "name").write[String] and &#13;
        (JsPath \ "details").write[String] and &#13;
        (JsPath \ "price").write[BigDecimal] &#13;
      )(unlift(Product.unapply)) &#13;
      implicit val productReads: Reads[Product] = ( &#13;
        (JsPath \ "id").readNullable[Long] and &#13;
        (JsPath \ "name").read[String] and &#13;
        (JsPath \ "details").read[String] and &#13;
        (JsPath \ "price").read[BigDecimal] &#13;
      )(Product.apply _)  &#13;
      def toJson(products:Option[Seq[Product]]) = Json.toJson(products) &#13;
    } &#13;
</pre><p>Basically, there are three important concepts here. First, we have <code class="literal">productsWrites</code> , which maps from JSON to <code class="literal">model</code>, and <code class="literal">Product</code> for writes, which is also known as deserialization. We have another mapping for serialization called <code class="literal">productsReads</code>, which converts objects to JSON.</p><p>As you can see, we need to map all fields existing in our model, such as ID, name, details, and price. This mapping must match proper types as well. ID mapping uses <code class="literal">readNullable</code> because ID is optional.</p><p>Finally, we have a function to convert from JSON to object, called <code class="literal">toJson</code>, which uses a generic Play framework library called JSON. Let's move for the next helper--the review.</p><p>
<code class="literal">ReviewsJson</code> is located at <code class="literal">ReactiveWebStore/app/controllers/Review.scala</code> and should look something like this:</p><pre class="programlisting">    object ReviewsJson {  &#13;
      import play.api.libs.json._ &#13;
      import play.api.libs.json.Reads._ &#13;
      import play.api.libs.functional.syntax._  &#13;
      implicit val reviewWrites: Writes[Review] = ( &#13;
        (JsPath \ "id").write[Option[Long]] and &#13;
        (JsPath \ "productId").write[Option[Long]] and &#13;
        (JsPath \ "author").write[String] and &#13;
        (JsPath \ "comment").write[String] &#13;
      )(unlift(Review.unapply)) &#13;
      implicit val reviewReads: Reads[Review] = ( &#13;
        (JsPath \ "id").readNullable[Long] and &#13;
        (JsPath \ "productId").readNullable[Long] and &#13;
        (JsPath \ "author").read[String] and &#13;
        (JsPath \ "comment").read[String] &#13;
      )(Review.apply _)  &#13;
      def toJson(reviews:Option[Seq[Review]]) = Json.toJson(reviews) &#13;
    } &#13;
</pre><p>Here, we have the same concepts that we saw earlier in the Products JSON helper. We have a mapping for reads and writes and a function which converts a <code class="literal">model.Review</code> to JSON. Let's move to the last helper, the <code class="literal">ImageJson</code>.</p><p>
<code class="literal">ImagesJson</code> is located at <code class="literal">ReactiveWebStore/app/controllers/Image.scala</code>, which should look something like this:</p><pre class="programlisting">    object ImagesJson {  &#13;
      import play.api.libs.json._ &#13;
      import play.api.libs.json.Reads._ &#13;
      import play.api.libs.functional.syntax._  &#13;
      implicit val imagesWrites: Writes[Image] = ( &#13;
        (JsPath \ "id").write[Option[Long]] and &#13;
        (JsPath \ "productId").write[Option[Long]] and &#13;
        (JsPath \ "url").write[String] &#13;
      )(unlift(Image.unapply))     &#13;
      implicit val imagesReads: Reads[Image] = ( &#13;
        (JsPath \ "id").readNullable[Long] and &#13;
        (JsPath \ "productId").readNullable[Long] and &#13;
        (JsPath \ "url").read[String] &#13;
      )(Image.apply _)  &#13;
      def toJson(images:Option[Seq[Image]]) = Json.toJson(images) &#13;
    } &#13;
</pre><p>Just as with the other two mappers, we have reads, writes, mappings, and the <code class="literal">toJson</code> function. We are done with mappers, so now the next step is to create the new routes.</p></div><div class="section" title="Configuring new routes"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec114"/>Configuring new routes</h2></div></div></div><p>We need to add the following three new routes for our REST API, which is located at <code class="literal">ReactiveWebStore/conf/routes</code>:</p><pre class="programlisting">    # &#13;
    # REST API &#13;
    # &#13;
    GET /REST/api/product/all &#13;
    controllers.RestAPIController.listAllProducts &#13;
    GET /REST/api/review/all &#13;
    controllers.RestAPIController.listAllReviews &#13;
    GET /REST/api/image/all controllers.RestAPIController.listAllImages &#13;
</pre><p>As you can see, we mapped all the list operations we just created.</p></div><div class="section" title="Testing the API using the browser"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec115"/>Testing the API using the browser</h2></div></div></div><p>Now we can run <code class="literal">$ activator run</code> and test our new REST API using our web browser.</p><p>Go to <code class="literal">http://localhost:9000/REST/api/product/all</code>; you should see something similar to the following screenshot:</p><p>
</p><div class="mediaobject"><img src="../Images/image00320.jpeg" alt="Testing the API using the browser"/></div><p style="clear:both; height: 1em;"> </p><p>
</p><p>Let's look at the review API.</p><p>Go to <code class="literal">http://localhost:9000/REST/api/review/all</code>; you should see results similar to the following screenshot:</p><p>
</p><div class="mediaobject"><img src="../Images/image00321.jpeg" alt="Testing the API using the browser"/></div><p style="clear:both; height: 1em;"> </p><p>
</p><p>Finally, let's check out the image of REST API.</p><p>Go to <code class="literal">http://localhost:9000/REST/api/image/all</code>; you should see results similar to the following screenshot:</p><p>
</p><div class="mediaobject"><img src="../Images/image00322.jpeg" alt="Testing the API using the browser"/></div><p style="clear:both; height: 1em;"> </p><p>
</p><p>OK. Now we will continue to work with REST. We just finished the server; however, it is important to create a REST client to consume these REST APIs.</p></div></div>
<div class="section" title="Creating a Scala client" id="aid-3BOFI1"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec105"/>Creating a Scala client</h1></div></div></div><p>First, you will need to create a new project. Go to your file system and create a folder called <code class="literal">rest-client</code>. Then, create another folder inside <code class="literal">rest-client</code> called <code class="literal">project</code>. Inside <code class="literal">project</code>, you will need to add the following two files:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">build.properties</code>: This contains an SBT configuration, such as version</li><li class="listitem"><code class="literal">Plugins.sbt</code>: This contains an SBT plugins configuration</li></ul></div><p>Let's start with <code class="literal">build.properties</code>:</p><pre class="programlisting">    sbt.version=0.13.11 &#13;
</pre><p>As you can see here, we are configuring this project to use SBT version 0.13.11. Now, we can move to the plugins file.</p><div class="section" title="Configuring plugins.sbt"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec116"/>Configuring plugins.sbt</h2></div></div></div><p>Your <code class="literal">plugins.sbt</code> file should look something like this:</p><pre class="programlisting">    addSbtPlugin("com.typesafe.sbteclipse" % "sbteclipse-plugin" % &#13;
      "2.5.0") &#13;
    addSbtPlugin("com.github.mpeltonen" % "sbt-idea" % "1.6.0") &#13;
</pre><p>Here, we are adding Eclipse and IntelliJ support. For this book, we are using Eclipse, but feel free to use anything you like.</p><p>Outside of the <code class="literal">project</code> folder, under <code class="literal">rest-client</code>, we will need to configure the <code class="literal">build.sbt</code> file.</p></div><div class="section" title="Configuring build.sbt"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec117"/>Configuring build.sbt</h2></div></div></div><p>Your <code class="literal">build.sbt</code> file should look something like this:</p><pre class="programlisting">    name := "rest-client"  &#13;
    version := "1.0" &#13;
    scalaVersion := "2.11.7" &#13;
    scalaVersion in ThisBuild := "2.11.7"  &#13;
    resolvers += DefaultMavenRepository &#13;
    resolvers += JavaNet1Repository &#13;
    resolvers += "OSSSonatype" at &#13;
    "https://oss.sonatype.org/content/repositories/releases" &#13;
    resolvers += "Sonatype OSS Snapshots" at &#13;
    "https://oss.sonatype.org/content/repositories/snapshots" &#13;
    resolvers += "Sonatype OSS Snapshots" at &#13;
    "https://oss.sonatype.org/content/repositories/snapshots" &#13;
    resolvers += "amateras-repo" at &#13;
    "http://amateras.sourceforge.jp/mvn/"  &#13;
    libraryDependencies += "com.typesafe.play" % "play-ws_2.11" % &#13;
    "2.5.6" &#13;
    libraryDependencies += "org.scalatest" % "scalatest_2.11" % "2.2.6" &#13;
    % Test &#13;
</pre><p>So here, we are using Scala version 2.11.7, and we are declaring just two dependencies. One dependency is for tests, which is <code class="literal">scala-test</code>, and the other dependency is on the Play framework <code class="literal">ws</code> library, which we will use to call our REST APIs.</p><p>Let's also create two source folders, as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">src/main/scala</code>: This is the Scala source code</li><li class="listitem"><code class="literal">src/test/scala</code>: This is the Scala test source code</li></ul></div><p>OK. Now we can run <code class="literal">$ sbt clean compile eclipse</code> in order to download the dependencies from the web and create all the Eclipse project files that we need.</p><p>
</p><div class="mediaobject"><img src="../Images/image00323.jpeg" alt="Configuring build.sbt"/></div><p style="clear:both; height: 1em;"> </p><p>
</p><p>Now we can import this code in Eclipse and move on.</p></div><div class="section" title="Scala client code"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec118"/>Scala client code</h2></div></div></div><p>First of all, we will need to create a <code class="literal">Factory</code> to instantiate the <code class="literal">WS</code> Play framework library to call <code class="literal">webservices</code>. Under the <code class="literal">rest-client/src/main/scala</code> location, let's create a package called <code class="literal">client</code> and add the following code under <code class="literal">WSFactory.scala</code>:</p><pre class="programlisting">    package client  &#13;
    object WSFactory {  &#13;
      import akka.actor.ActorSystem &#13;
      import akka.stream.ActorMaterializer  &#13;
      def ws = {  &#13;
        implicit val system = ActorSystem() &#13;
        implicit val materializer = ActorMaterializer()  &#13;
        import com.typesafe.config.ConfigFactory &#13;
        import play.api._ &#13;
        import play.api.libs.ws._ &#13;
        import play.api.libs.ws.ahc.{AhcWSClient, AhcWSClientConfig} &#13;
        import play.api.libs.ws.ahc.AhcConfigBuilder &#13;
        import org.asynchttpclient.AsyncHttpClientConfig &#13;
        import java.io.File  &#13;
        val configuration = Configuration.reference ++ &#13;
        Configuration(ConfigFactory.parseString( &#13;
          """ &#13;
          |ws.followRedirects = true &#13;
        """.stripMargin))  &#13;
        val parser = new WSConfigParser(configuration, &#13;
        play.api.Environment.simple(&#13;
        new File("/tmp/"), null)) &#13;
        val config = new AhcWSClientConfig(wsClientConfig = &#13;
        parser.parse()) &#13;
        val builder = new AhcConfigBuilder(config) &#13;
        val logging = new &#13;
        AsyncHttpClientConfig.AdditionalChannelInitializer() { &#13;
          override def initChannel(channel: io.netty.channel.Channel): &#13;
          Unit = { &#13;
            channel.pipeline.addFirst("log", new &#13;
            io.netty.handler.logging.LoggingHandler("debug")) &#13;
          }&#13;
        }  &#13;
        val ahcBuilder = builder.configure() &#13;
        ahcBuilder.setHttpAdditionalChannelInitializer(logging) &#13;
        val ahcConfig = ahcBuilder.build() &#13;
        new AhcWSClient(ahcConfig) &#13;
      }&#13;
    } &#13;
</pre><p>The preceding code is just technical. These are the steps needed to instantiate the WSClient outside the Play framework. If this client was a web application using the Play framework, it would be way easier as we can just use Google Guice and inject what we need.</p><p>The main idea you need to keep in mind is that you need to use Akka and ActorSystem in order to use this feature. As you can see, all this code is locked inside an object in a single function called <code class="literal">ws</code>.</p><p>We will need some utility class to work with futures. As we use <code class="literal">ws</code> library to call REST APIs, it returns Future. So, let's create a new package called <code class="literal">utils</code>:</p><p>Your <code class="literal">Awaits.scala</code> file should look like something like this:</p><pre class="programlisting">    package utils  &#13;
    import scala.concurrent.Future &#13;
    import scala.concurrent.duration._ &#13;
    import scala.concurrent.Await  &#13;
    object Awaits { &#13;
      def get[T](sec:Int,f:Future[T]):T = { &#13;
        Await.result[T](f, sec seconds) &#13;
      }&#13;
    } &#13;
</pre><p>The preceding code is pretty simple. We used the <code class="literal">Await</code> object and then used a generic <code class="literal">T</code> in order to convert the result to a generic parameterized type. By using this parameter, we will also receive how many seconds we should wait before the timeout.</p></div></div>
<div class="section" title="Creating our REST client proxies"><div class="titlepage" id="aid-3CN042"><div><div><h1 class="title"><a id="ch09lvl1sec106"/>Creating our REST client proxies</h1></div></div></div><p>We will now make REST calls; however, we will create a Scala API. So, the developers who use our <code class="literal">rest-client</code> won't need to deal with REST and just execute the Scala code. This is good for many reasons, some of which are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong>SOC</strong></span>: We still have separation of concerns between the Play framework and the client application</li><li class="listitem"><span class="strong"><strong>Isolation</strong></span>: If the REST API changes, we will need to deal with it on the proxy layer</li><li class="listitem"><span class="strong"><strong>Abstraction</strong></span>: The rest of the client code just uses Scala and does not know anything about REST or HTTP calls</li></ul></div><p>These techniques are very common nowadays with microservices. These techniques can also be known as drivers or thick clients. Right now, we will need to create three proxies, one for each resource, that we have on the REST API. Let's create a new package called <code class="literal">proxy</code>.</p><p>Your <code class="literal">ProductProxy.scala</code> file should look something like this:</p><pre class="programlisting">    package proxy  &#13;
    import client.WSFactory &#13;
    import utils.Awaits  &#13;
    case class Product &#13;
    ( var id:Option[Long], &#13;
      var name:String, &#13;
      var details:String, &#13;
    var price:BigDecimal ) { &#13;
      override def toString:String = { &#13;
        "Product { id: " + id.getOrElse(0) + ",name: " + name + ", &#13;
        details: "+ details + ", price: &#13;
        " + price + "}" &#13;
      }&#13;
    }  &#13;
    object ProductsJson {  &#13;
      import play.api.libs.json._ &#13;
      import play.api.libs.json.Reads._ &#13;
      import play.api.libs.functional.syntax._ &#13;
      implicit val productWrites: Writes[Product] = (  &#13;
        (JsPath \ "id").write[Option[Long]] and &#13;
        (JsPath \ "name").write[String] and &#13;
        (JsPath \ "details").write[String] and &#13;
        (JsPath \ "price").write[BigDecimal] &#13;
      )(unlift(Product.unapply)) &#13;
      implicit val productReads: Reads[Product] = ( &#13;
        (JsPath \ "id").readNullable[Long] and &#13;
        (JsPath \ "name").read[String] and &#13;
        (JsPath \ "details").read[String] and &#13;
        (JsPath \ "price").read[BigDecimal] &#13;
      )(Product.apply _)  &#13;
      def toJson(products:Option[Seq[Product]]) = Json.toJson(products) &#13;
    }  &#13;
    object ProductProxy {  &#13;
      import scala.concurrent.Future &#13;
      import play.api.libs.json._ &#13;
      import ProductsJson._  &#13;
      val url = "http://localhost:9000/REST/api/product/all" &#13;
      implicit val context = &#13;
      play.api.libs.concurrent.Execution.Implicits.defaultContext  &#13;
      def listAll():Option[List[Product]] = { &#13;
        val ws = WSFactory.ws &#13;
        val futureResult:Future[Option[List[Product]]] = &#13;
        ws.url(url).withHeaders("Accept" -&gt; &#13;
        "application/json").get().map( &#13;
          response =&gt; &#13;
          Json.parse(response.body).validate[List[Product]].asOpt &#13;
        )  &#13;
        val products = Awaits.get(10, futureResult) &#13;
        ws.close &#13;
        products &#13;
      }&#13;
    } &#13;
</pre><p>We have three big concepts in this code. First of all, we have a <code class="literal">case</code> class that represents the product. The preceding code is very similar to the code we have on the Play framework application. However, if you pay attention, you will see it is much cleaner because we don't have any metadata around persistence.</p><p>You might think, this is duplicated code! It is, and it is 100% okay. Duplicate code is decoupled. Remember that we have a REST interface and also a proxy between the rest of the client code, so we have at least two layers of indirection that we can deal with changes. If these two code bases share the same class, we would have coupling and less space to accommodate changes.</p><p>The second big concept here is mapping. We will receive JSON, and we will want to convert JSON to our case class, so we will have similar mapping that we did in the Play framework application.</p><p>Finally, we have the proxy implementation. We will instantiate the Play framework <code class="literal">WS</code> library using our factory and call the <code class="literal">ws</code> function. Then, we will use the <code class="literal">url</code> function passing the REST API URI for products and define a header in order to accept JSON. We are also doing this using the HTTP verb, <code class="literal">GET</code>. The response is mapped with <code class="literal">Json.parse</code> passing <code class="literal">response.body</code>. Additionally, we will call the validate function to make sure this JSON matches our <code class="literal">case</code> class. This validation is important because then we can be sure that the format did not change, and that everything works fine. <code class="literal">WS</code> will return this as a Future, so we will use our <code class="literal">Awaits</code> helper to get the result.</p><p>Let's move to the next proxy, the review.</p><p>Your <code class="literal">ReviewProxy.scala</code> file should look something like this:</p><pre class="programlisting">    package proxy  &#13;
    import client.WSFactory &#13;
    import utils.Awaits  &#13;
    case class Review &#13;
    (var id:Option[Long], &#13;
      var productId:Option[Long], &#13;
      var author:String, &#13;
    var comment:String) &#13;
    { &#13;
      override def toString:String = { &#13;
        "Review { id: " + id + " ,productId: " + productId.getOrElse(0) &#13;
        + ",author: " + author + &#13;
        ",comment: " + comment + " }" &#13;
      } &#13;
    }  &#13;
    object ReviewsJson {  &#13;
      import play.api.libs.json._ &#13;
      import play.api.libs.json.Reads._ &#13;
      import play.api.libs.functional.syntax._  &#13;
      implicit val reviewWrites: Writes[Review] = ( &#13;
        (JsPath \ "id").write[Option[Long]] and &#13;
        (JsPath \ "productId").write[Option[Long]] and &#13;
        (JsPath \ "author").write[String] and &#13;
        (JsPath \ "comment").write[String] &#13;
      )(unlift(Review.unapply))  &#13;
      implicit val reviewReads: Reads[Review] = ( &#13;
        (JsPath \ "id").readNullable[Long] and &#13;
        (JsPath \ "productId").readNullable[Long] and &#13;
        (JsPath \ "author").read[String] and &#13;
        (JsPath \ "comment").read[String] &#13;
      )(Review.apply _) &#13;
      def toJson(reviews:Option[Seq[Review]]) = Json.toJson(reviews) &#13;
    }  &#13;
    object ReviewProxy { &#13;
      import scala.concurrent.Future &#13;
      import play.api.libs.json._ &#13;
      import ReviewsJson._ &#13;
      val url = "http://localhost:9000/REST/api/review/all" &#13;
      implicit val context = &#13;
      play.api.libs.concurrent.Execution.Implicits.defaultContext &#13;
      def listAll():Option[List[Review]] = { &#13;
        val ws = WSFactory.ws &#13;
        val futureResult:Future[Option[List[Review]]] = &#13;
        ws.url(url).withHeaders("Accept" -&gt; &#13;
        "application/json").get().map( &#13;
          response =&gt; &#13;
          Json.parse(response.body).validate[List[Review]].asOpt &#13;
        ) &#13;
        val reviews = Awaits.get(10, futureResult) &#13;
        ws.close &#13;
        reviews &#13;
      }&#13;
    } &#13;
</pre><p>Here, we have the same principles that we had on the product proxy, but this time for review. As you can see, we will call a different URI. Now, let's move to the last proxy--the <code class="literal">ImageProxy.scala</code> file.</p><p>Your <code class="literal">ImageProxy.scala</code> file should look something like this:</p><pre class="programlisting">    package proxy  &#13;
    import client.WSFactory &#13;
    import utils.Awaits  &#13;
    case class Image &#13;
    (var id:Option[Long], &#13;
      var productId:Option[Long], &#13;
    var url:String) &#13;
    { &#13;
      override def toString:String = { &#13;
        "Image { productId: " + productId.getOrElse(0) + ",url: " + url &#13;
        + "}" &#13;
      } &#13;
    }  &#13;
    object ImagesJson {  &#13;
      import play.api.libs.json._ &#13;
      import play.api.libs.json.Reads._ &#13;
      import play.api.libs.functional.syntax._  &#13;
      implicit val imagesWrites: Writes[Image] = ( &#13;
        (JsPath \ "id").write[Option[Long]] and &#13;
        (JsPath \ "productId").write[Option[Long]] and &#13;
        (JsPath \ "url").write[String] &#13;
      )(unlift(Image.unapply))  &#13;
      implicit val imagesReads: Reads[Image] = ( &#13;
        (JsPath \ "id").readNullable[Long] and &#13;
        (JsPath \ "productId").readNullable[Long] and &#13;
        (JsPath \ "url").read[String] &#13;
      )(Image.apply _) &#13;
      def toJson(images:Option[Seq[Image]]) = Json.toJson(images) &#13;
    } &#13;
    object ImageProxy { &#13;
      import scala.concurrent.Future &#13;
      import play.api.libs.json._ &#13;
      import ImagesJson._ &#13;
      val url = "http://localhost:9000/REST/api/image/all" &#13;
      implicit val context =  &#13;
      play.api.libs.concurrent.Execution.Implicits.defaultContext &#13;
      def listAll():Option[List[Image]] = { &#13;
        val ws = WSFactory.ws &#13;
        val futureResult:Future[Option[List[Image]]] = &#13;
        ws.url(url).withHeaders("Accept" -&gt; &#13;
        "application/json").get().map( &#13;
          response =&gt; &#13;
          Json.parse(response.body).validate[List[Image]].asOpt &#13;
        ) &#13;
        val images = Awaits.get(10, futureResult) &#13;
        ws.close &#13;
        images &#13;
      }&#13;
    } &#13;
</pre><p>That's it. We have the same concepts as product and review. We have finished all our proxies. Now, it is time to test our proxy implementation. The best way to do this is via tests, so let's create Scala tests for these three implementations.</p><div class="section" title="Creating ScalaTest tests for the proxies"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec119"/>Creating ScalaTest tests for the proxies</h2></div></div></div><p>Under the <code class="literal">/src/test/scala</code> source folder, we will need to create a package called <code class="literal">proxy.test</code>.</p><p>Your <code class="literal">ProductProxtTestSpec.scala</code> should look something like this:</p><pre class="programlisting">    package proxy.test  &#13;
    import org.scalatest._ &#13;
    import proxy.ProductProxy  &#13;
    class ProductProxtTestSpec extends FlatSpec with Matchers {  &#13;
      "A Product Rest proxy " should "return all products" in { &#13;
        val products = ProductProxy.listAll().get &#13;
        products shouldNot(be(null)) &#13;
        products shouldNot(be(empty))  &#13;
      }&#13;
    } &#13;
</pre><p>The test is quite simple; we will just have to call the <code class="literal">listAll</code> operation in our product proxy and then add some assertions to make sure the result is not null. We will also show all the products in the console.</p><p>Now, we will need to create tests for the review proxy, which will be similar to the product.</p><p>Your <code class="literal">ReviewProxyTestSpec.scala</code> file should look something like this:</p><pre class="programlisting">    package proxy.test  &#13;
    import org.scalatest._ &#13;
    import proxy.ReviewProxy  &#13;
    class ReviewProxyTestSpec extends FlatSpec with Matchers {  &#13;
      "A Review REST Proxy " should "return all reviews" in { &#13;
        val reviews = ReviewProxy.listAll().get &#13;
        reviews shouldNot(be(null)) &#13;
        reviews shouldNot(be(empty)) &#13;
        for( r &lt;- reviews){ &#13;
          println(r) &#13;
        }&#13;
      }&#13;
    } &#13;
</pre><p>Here, we used the proxy ideas to test the review. We called the proxy using the <code class="literal">listAll</code> function to get all the reviews. Later, we will check to see if the review is not null. We will print all the reviews. Finally, it's time to move to the last proxy test--the image proxy.</p><p>Your <code class="literal">ImageProxyTestSpec.scala</code> should look something like this:</p><pre class="programlisting">    package proxy.test  &#13;
    import org.scalatest._ &#13;
    import proxy.ImageProxy &#13;
    import scala.concurrent.Future &#13;
    import play.api.libs.concurrent.Execution.Implicits.defaultContext &#13;
    import java.util.concurrent.CountDownLatch  &#13;
    class ImageProxyTestSpec extends FlatSpec with Matchers {  &#13;
      "A Image REST Proxy " should "return all images" in { &#13;
        val images = ImageProxy.listAll().get &#13;
        images shouldNot(be(null)) &#13;
        images shouldNot(be(empty)) &#13;
        for( i &lt;- images){ &#13;
          println(i) &#13;
        }&#13;
      }&#13;
    } &#13;
</pre><p>Same deal goes for the image proxy. We have all our tests; now, we can run the tests. You will need to make sure our <code class="literal">ReactiveWebStore</code> Play framework app is up and running.</p><p>Let's run this test with sbt:</p><p>open your console and type in<code class="literal"> $ sbt test </code>
</p><p>
</p><div class="mediaobject"><img src="../Images/image00324.jpeg" alt="Creating ScalaTest tests for the proxies"/></div><p style="clear:both; height: 1em;"> </p><p>
</p><p>Alright, it all works! Our next step will be to add back pressure.</p></div><div class="section" title="Adding back pressure"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec120"/>Adding back pressure</h2></div></div></div><p>Back pressure is a well-known concept in the automotive industry. Nowadays, this term is used in software engineering as well. Back pressure in the automotive world refers to the pressure opposed to the desired flow of gasses in a confined place, such as a pipe. For software engineering, it is often related to slowing down a producer, which can be an application, a stream processing engine, or even the user itself.</p><p>When we are executing REST, it's easy to reach a situation where the client can saturate the server. This can be a security breach too, which is also known as the <span class="strong"><strong>Denial Of Service</strong></span> (<span class="strong"><strong>DOS</strong></span>) attack.</p><p>There are two architectural scenarios. In the first scenario, your REST API is internal, and you just have consumers in your company. In the second scenario, you are making the REST API a public API so that it will be open to the whole Internet. For this scenario, you really should have back pressure, also known as throttling.</p><p>It's possible to scale our architecture in order to handle more users. We will discuss this, and the scalability techniques, in <a class="link" title="Chapter 10.  Scaling up" href="part0116.xhtml#aid-3EK181">Chapter 10</a>, <span class="emphasis"><em>Scaling Up</em></span>.</p><p>Currently, there are several ways to apply back pressure. For instance, if our code is pure RxScala/RxJava, we can apply back pressure on observables. More details can be found at <a class="ulink" href="https://github.com/ReactiveX/RxJava/wiki/Backpressure">https://github.com/ReactiveX/RxJava/wiki/Backpressure</a>.</p><p>As we are exposing a REST interface, we will add back pressure on the controller, so we will need to create a new class with the back pressure code.</p><p>There are some algorithms for back pressure; we will use the leaky bucket algorithm. The algorithm itself is very simple--just 30 lines of Scala code.</p><div class="section" title="The leaky bucket algorithm"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec1"/>The leaky bucket algorithm</h3></div></div></div><p>The leaky bucket metaphor is pretty simple. Let's take a look at it in the following diagram:</p><p>
</p><div class="mediaobject"><img src="../Images/image00325.jpeg" alt="The leaky bucket algorithm"/></div><p style="clear:both; height: 1em;"> </p><p>
</p><p>The metaphor behind the algorithm is based around a bucket with holes. The water flows or drips into the bucket and leaks through the holes of the bucket. If there is too much water, and the bucket is full of water, the water will spill out of the bucket--in other words, it will be discarded.</p><p>This algorithm is used in network programing, and also by the telecommunication industry. The API manager solutions are also use cases for this algorithm.</p><p>This concept allows RATE limit constraints. We can express the back pressure rate limits in requests per time. Time, in this case, is often measured in seconds or minutes, so we have <span class="strong"><strong>Requests Per Second</strong></span> (<span class="strong"><strong>RPS</strong></span>) or <span class="strong"><strong>Requests Per Minute</strong></span> (<span class="strong"><strong>RPM</strong></span>).</p><p>You can implement this algorithm with a queue. However, in our implementation, we will not use a queue; we will use time in order to control the flow. Our implementation will also be lock free, or non-blocking, as we won't use threads or external resources.</p><p>Now is the time to code a leaky bucket in Scala. First of all, we will create this code for the <code class="literal">ReactiveWebStore</code> application. We will need to create a new package located at <code class="literal">ReactiveWebStore/app</code>. The new package name will be <code class="literal">backpressure</code>.</p><div class="section" title="Scala leaky bucket implementation"><div class="titlepage"><div><div><h4 class="title"><a id="ch09lvl4sec0"/>Scala leaky bucket implementation</h4></div></div></div><p>Your <code class="literal">LeakyBucket.scala</code> file should have the following files:</p><pre class="programlisting">    package backpresurre  &#13;
    import scala.concurrent.duration._ &#13;
    import java.util.Date  &#13;
    class LeakyBucket(var rate: Int, var perDuration: FiniteDuration) {  &#13;
      var numDropsInBucket: Int = 0 &#13;
      var timeOfLastDropLeak:Date = null &#13;
      var msDropLeaks = perDuration.toMillis  &#13;
      def dropToBucket():Boolean = { &#13;
        synchronized { &#13;
          var now = new Date()  &#13;
          if (timeOfLastDropLeak != null) { &#13;
            var deltaT = now.getTime() - timeOfLastDropLeak.getTime() &#13;
            var numberToLeak:Long = deltaT / msDropLeaks  &#13;
              if (numberToLeak &gt; 0) { &#13;
                if (numDropsInBucket &lt;= numberToLeak) { &#13;
                  numDropsInBucket -= numberToLeak.toInt &#13;
                } else { &#13;
                numDropsInBucket = 0 &#13;
              } &#13;
              timeOfLastDropLeak = now &#13;
            } &#13;
          }else{ &#13;
            timeOfLastDropLeak = now   &#13;
          }  &#13;
          if (numDropsInBucket &lt; rate) { &#13;
            numDropsInBucket = numDropsInBucket + 1 &#13;
            return true; &#13;
          } &#13;
          return false; &#13;
        }&#13;
      }&#13;
    } &#13;
</pre><p>As you can see here, we created a Scala class that receives two parameters: <code class="literal">rate</code> and <code class="literal">perDuration</code>. Rate is an integer, which shows how many requests we are able to handle before applying back pressure. <code class="literal">PerDuration</code> is a Scala <code class="literal">FiniteDuration</code>, which can be any measure of time, such as milliseconds, seconds, minutes, or hours.</p><p>This algorithm keeps track of the time for the last drop in the bucket. As you can see, the code is synchronized, but it is fine because we won't call either external resources or threads.</p><p>First, we will get the current time with new a <code class="literal">Date()</code>. The first time we run the algorithm, we will fail on the <code class="literal">else</code> statement, and we will get the current time as last leak.</p><p>The second time it runs, it will enter on the first <code class="literal">If</code> statement. Then, we will calculate the delta (diff) between the last leak and now. This delta will be divided by the time in milliseconds that you passed on <code class="literal">perDuration</code>. If the delta is greater than 0, then we leak; otherwise we drop. Then, we will capture the time again for the last leak.</p><p>Finally, we will check the drop rate. If the rate is smaller, we will increment and return true, which means the request can proceed; otherwise, we will return false, and the request should not proceed.</p><p>Now that we have this algorithm coded in Scala, we can call for one of our controllers. We will add this back pressure on the image REST API.</p><p>Your <code class="literal">RestApiController.scala</code> should look something like this:</p><pre class="programlisting">    package controllers  &#13;
    class RestAPIController @Inject() &#13;
    (val productService:IProductService, &#13;
      val reviewService:IReviewService, &#13;
      val imageService:IImageService) extends Controller {  &#13;
        import &#13;
        play.api.libs.concurrent.Execution.Implicits.defaultContext  &#13;
        // REST of the Controller...  &#13;
        import scala.concurrent.duration._  &#13;
        var bucket = new LeakyBucket(5, 60 seconds)  &#13;
        def processImages = { &#13;
          val future = imageService.findAll() &#13;
          val images = Awaits.get(5,future) &#13;
          val json = ImagesJson.toJson(images) &#13;
          json &#13;
        }  &#13;
        def processFailure = { &#13;
          Json.toJson("Too Many Requests - Try Again later... ") &#13;
        } &#13;
        def listAllImages = Action { &#13;
          bucket.dropToBucket() match { &#13;
            case true =&gt; Ok(processImages) &#13;
            case false =&gt; &#13;
            InternalServerError(processFailure.toString()) &#13;
          }&#13;
        }&#13;
     } &#13;
</pre><p>Here, we will create a leaky bucket with five requests per minute. We have two functions: One to process images that will call the service and convert the objects to JSON, and the other to process failures. The <code class="literal">processFailure</code> method will just send a message saying that there are too many requests, and we can't accept requests right now.</p><p>So, for the <code class="literal">listAllImages</code> function, we will just call the bucket trying to drop and use the Scala pattern matcher in order to process the proper response. If the response is true, we will return JSON with a 200 HTTP code. Otherwise, we will return a 500 internal error and deny that request. Here, we implemented a global RATE limiter; however, most of the time, people perform this operation per user. Now, let's open the web browser and try more than five requests within a minute. You should see something like the following screenshot at <code class="literal">http://localhost:9000/REST/api/images/all</code>:</p><p>
</p><div class="mediaobject"><img src="../Images/image00326.jpeg" alt="Scala leaky bucket implementation"/></div><p style="clear:both; height: 1em;"> </p><p>
</p><p>Alright, it works! If you wait a minute and make requests again, you will see that the flow gets back to normal. The next step is to add a new client test, because we know that if we call an image too much in our REST API, we will be throttled.</p><p>We will need to add one more test in the <code class="literal">rest-client</code> Scala project. For that, we will need to change the <code class="literal">ImageProxyTestSpec</code>.</p></div><div class="section" title="Testing back pressure"><div class="titlepage"><div><div><h4 class="title"><a id="ch09lvl4sec1"/>Testing back pressure</h4></div></div></div><p>Your <code class="literal">ImageProxyTestSpec.scala</code> should look something like this:</p><pre class="programlisting">    package proxy.test  &#13;
    class ImageProxyTestSpec extends FlatSpec with Matchers {  &#13;
      // REST of the tests...  &#13;
      "A Image REST Proxy " should "suffer backpressure" in { &#13;
        val latch = new CountDownLatch(10) &#13;
        var errorCount:Int = 0 &#13;
        for(i &lt;- 1 to 10){ &#13;
          Future{ &#13;
            try{ &#13;
              val images = ImageProxy.listAll().get &#13;
              images shouldNot(be(null)) &#13;
              for( i &lt;- images){ &#13;
                println(i) &#13;
              } &#13;
            }catch{ &#13;
              case t:Throwable =&gt; errorCount += 1 &#13;
            } &#13;
            latch.countDown() &#13;
          }&#13;
        }     &#13;
        while( latch.getCount &gt;= 1 ) &#13;
        latch.await() &#13;
        errorCount should be &gt;=5 &#13;
      } &#13;
    } &#13;
</pre><p>So, for this test, we will call <code class="literal">ImageProxy</code> ten times. We know that not all requests will be served as we have back pressure on the server. Here, we can call the proxy with a try...catch block and have an error counter. Each time it fails, we can increment it. So, here, we are expected to fail at least five times.</p><p>We are creating the code with Features because we want the requests to happen at the same time. We will need to use <code class="literal">CountDownLatch</code> function, which is a Java utility class that lets us wait for all Futures to finish before moving on. This is done by the <code class="literal">countDown</code> function. Every time we execute <code class="literal">countdown</code>, we decrement the internal counter. As you can see, we created the <code class="literal">CountDownLatch</code> function with ten.</p><p>Finally, we have a <code class="literal">while</code> block to wait for until the counter has pending Futures. Now we wait. Once it's all done, we can check the error count; it should be at least five. That's it. We have tested our back pressure mechanism and it all works!</p><p>Now, it is time to move to the next feature that we will implement in our application: Swagger--we will add Swagger support to our REST API.</p></div></div></div><div class="section" title="Adding Swagger support"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec121"/>Adding Swagger support</h2></div></div></div><p>Swagger (<a class="ulink" href="http://swagger.io/">http://swagger.io/</a>) is a simple JSON and UI representation tool for REST APIs. It can generate code in several languages. It also creates a very nice documentation, which is also a runnable Swagger code that allows you to call REST web services from the documentation it generates. We will need to make some changes in our Play framework application in order to get Swagger up and running with the Play framework.</p><p>First of all, we will need to add the Swagger dependency to <code class="literal">build.sbt</code>:</p><pre class="programlisting">    // Rest of build file...   &#13;
    libraryDependencies ++= Seq( &#13;
      // Rest of other deps...  &#13;
      "io.swagger" %% "swagger-play2" % "1.5.2-SNAPSHOT" &#13;
    ) &#13;
</pre><p>As you can see, we are using a Snapshot version. Why use Snapshot? Right now, it is not supported on a stable version. In order to resolve this dependency, we will need to use Git and clone another project. You can get more details at <a class="ulink" href="https://github.com/CreditCardsCom/swagger-play">https://github.com/CreditCardsCom/swagger-play</a>. Basically, you will need to write a command as follows:</p><pre class="programlisting">
<span class="strong"><strong>$ git clone https://github.com/CreditCardsCom/swagger-play.git</strong></span>
<span class="strong"><strong>$ cd swagger-play/</strong></span>
<span class="strong"><strong>$ sbt publishLocal</strong></span>
</pre><p>Now, we will need to enable Swagger on <code class="literal">ReactiveWebStore/conf/application.conf</code>.</p><p>Your <code class="literal">application.conf</code> file should look something like this:</p><pre class="programlisting">    play.modules { &#13;
      enabled += "play.modules.swagger.SwaggerModule" &#13;
    } &#13;
</pre><p>Next, we can change our controller in order to add Swagger support. Swagger has annotation in order to map the REST operations.</p><p>Your <code class="literal">RestAPIController.scala</code> file should look something like this:</p><pre class="programlisting">    package controllers  &#13;
    @Singleton &#13;
    @Api(value = "/REST/api", description = "REST operations on &#13;
    Products, Images and Reviews. ") &#13;
    class RestAPIController @Inject() &#13;
    (val productService:IProductService, &#13;
      val reviewService:IReviewService, &#13;
      val imageService:IImageService) extends Controller { &#13;
        import &#13;
        play.api.libs.concurrent.Execution.Implicits.defaultContext  &#13;
        @ApiOperation( &#13;
          nickname = "listAllProducts", &#13;
          value = "Find All Products", &#13;
          notes = "Returns all Products", &#13;
          response = classOf[models.Product], &#13;
          httpMethod = "GET" &#13;
        ) &#13;
        @ApiResponses(Array( &#13;
          new ApiResponse(code = 500, message = "Internal Server &#13;
          Error"), &#13;
          new ApiResponse(code = 200, message = "JSON response with &#13;
          data") &#13;
        )&#13;
      ) &#13;
      def listAllProducts = Action { &#13;
        val future = productService.findAll() &#13;
        val products = Awaits.get(5,future) &#13;
        val json = ProductsJson.toJson(products) &#13;
        Ok(json) &#13;
      }  &#13;
      @ApiOperation( &#13;
        nickname = "listAllReviews", &#13;
        value = "Find All Reviews", &#13;
        notes = "Returns all Reviews", &#13;
        response = classOf[models.Review], &#13;
        httpMethod = "GET" &#13;
      ) &#13;
      @ApiResponses(Array( &#13;
        new ApiResponse(code = 500, message = "Internal Server Error"), &#13;
        new ApiResponse(code = 200, message = "JSON response with &#13;
        data") &#13;
      )&#13;
      ) &#13;
      def listAllReviews = Action { &#13;
        val future = reviewService.findAll() &#13;
        val reviews = Awaits.get(5,future) &#13;
        val json = ReviewsJson.toJson(reviews) &#13;
        Ok(json) &#13;
      }  &#13;
      import scala.concurrent.duration._ &#13;
      var bucket = new LeakyBucket(5, 60 seconds) &#13;
      def processImages = { &#13;
        val future = imageService.findAll() &#13;
        val images = Awaits.get(5,future) &#13;
        val json = ImagesJson.toJson(images) &#13;
        json &#13;
      }  &#13;
      def processFailure = { &#13;
        Json.toJson("Too Many Requests - Try Again later... ") &#13;
      }  &#13;
      @ApiOperation( &#13;
        nickname = "listAllImages", &#13;
        value = "Find All Images", &#13;
        notes = "Returns all Images - There is throttling of 5 &#13;
        reqs/sec", &#13;
        response = classOf[models.Image], &#13;
        httpMethod = "GET" &#13;
      ) &#13;
      @ApiResponses(Array( &#13;
        new ApiResponse(code = 500, message = "Internal Server Error"), &#13;
        new ApiResponse(code = 200, message = "JSON response with &#13;
        data") &#13;
      )&#13;
      )  &#13;
      def listAllImages = Action { &#13;
        bucket.dropToBucket() match { &#13;
          case true =&gt; Ok(processImages) &#13;
          case false =&gt; InternalServerError(processFailure.toString()) &#13;
        }&#13;
      }&#13;
    } &#13;
</pre><p>Here we have several annotations. First of all, we have an <code class="literal">@Api</code> annotation at the top of the class. With this annotation, we will define the root path of the REST API. Then, for each REST API operation, we have the <code class="literal">@ApiOperation</code> and <code class="literal">@ApiResponses</code> annotations. The <code class="literal">@ApiOperation</code> defines the REST API itself where you can define the parameters and the HTTP verb, and also put some notes (documentation). It's also possible to describe the result; in our case, it will be a JSON representation of the models.</p><p>That's it! We have the controller mapped to Swagger. The next step is to add a route for Swagger. This needs to be done by adding a new line as shown in the following piece of code which, is located at <code class="literal">ReactiveWebStore/conf/routes</code>:</p><pre class="programlisting">    // REST of the other routes..  &#13;
    GET     /swagger.json    controllers.ApiHelpController.getResources &#13;
</pre></div><div class="section" title="Swagger UI"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec122"/>Swagger UI</h2></div></div></div><p>Swagger will generate a JSON response for our REST API. It's possible to use the Swagger UI, which is very nice and gives lots of facilities to the developer. There are two ways we can work with the Swagger UI: We can use it as a standalone or we can embed the Swagger UI into our Play framework application.</p><p>The strategy we will pick here is embedding the Swagger UI in our application. If you have multiple REST APIs with multiple Play applications or microservices, it is a good idea to have the standalone installation of the swagger UI.</p><p>In the previous steps, we enabled Swagger in our application. Open your browser and type <code class="literal">http://localhost:9000/swagger.json</code>. You can follow the instructions at <a class="ulink" href="http://swagger.io/swagger-ui/">http://swagger.io/swagger-ui/</a>. In summary, you will get the following output:</p><p>
</p><div class="mediaobject"><img src="../Images/image00327.jpeg" alt="Swagger UI"/></div><p style="clear:both; height: 1em;"> </p><p>
</p><div class="section" title="Build and install Swagger Standalone"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec2"/>Build and install Swagger Standalone</h3></div></div></div><p>Now we will download, build, and install Swagger Standalone. Let's get started by writing the following lines of code:</p><pre class="programlisting">
<span class="strong"><strong>$ sudo apt-get update $ sudo apt-get install nodej $ sudo apt-get install npm &#13;
$ git clone https://github.com/swagger-api/swagger-ui.git $ cd swagger-ui/ $ sudo -E npm install -g $ sudo -E npm run build $ npm run serve $ GOTO: http://localhost:8080/</strong></span>
</pre><p>Once you start the Swagger UI, you can go to the browser, where you will see the following output:</p><p>
</p><div class="mediaobject"><img src="../Images/image00328.jpeg" alt="Build and install Swagger Standalone"/></div><p style="clear:both; height: 1em;"> </p><p>
</p><p>Now, let's embed the Swagger UI into our Play framework application.</p><p>We will need to copy the content from <code class="literal">/swagger-ui/dist/</code> into our Play framework application under <code class="literal">ReactiveWebStore/public</code>. Then, we will create a folder called <code class="literal">swaggerui</code>.</p><p>We will need to edit one file in order to put our swagger JSON URI. Open <code class="literal">ReactiveWebStore/public/swaggerui/index.html</code> and change the 40 to the following code line:</p><pre class="programlisting">    url = "http://localhost:9000/swagger.json"; &#13;
</pre><p>That's it. Now we will need to create a link from our application to embed the swagger UI. So, let's change <code class="literal">ReactiveWebStore/app/views/index.scala.html</code>.</p><p>Your <code class="literal">index.scala.html</code> file should look something like this:</p><pre class="programlisting">    @(message: String)(implicit flash:Flash)  &#13;
    @main("Welcome to Reactive Web Store"){ &#13;
      &lt;div class="row-fluid"&gt; &#13;
        &lt;BR&gt; &#13;
        &lt;div class="span12"&gt; &#13;
          &lt;div class="row-fluid"&gt; &#13;
            &lt;div class="span6"&gt; &#13;
              &lt;a href="/product"&gt;&lt;img height="42" width="42" &#13;
              src="@routes.Assets.at("images/product.png")"&gt; Manage &#13;
              Products&lt;/a&gt;&lt;BR&gt; &#13;
              &lt;a href="/review"&gt;&lt;img height="42" width="42" &#13;
              src="@routes.Assets.at("images/review.png")"&gt; Manage &#13;
              Reviews&lt;/a&gt;&lt;BR&gt; &#13;
              &lt;a href="/image"&gt;&lt;img height="42" width="42" &#13;
              src="@routes.Assets.at("images/image.png")"&gt; Manage &#13;
              Images&lt;/a&gt;&lt;BR&gt; &#13;
            &lt;/div&gt; &#13;
            &lt;div class="span6"&gt; &#13;
            &lt;a href="/reports"&gt;&lt;img height="42" width="42" &#13;
            src="@routes.Assets.at("images/reports.png")"&gt; Reports &lt;/a&gt;&#13;
            &lt;BR&gt; &#13;
            &lt;a href="/chat/index_socket"&gt;&lt;img height="42" width="42" &#13;
            src="@routes.Assets.at("images/chat.png")"&gt; Chat Room &lt;/a&gt;&#13;
            &lt;BR&gt; &#13;
            &lt;a href="/assets/swaggerui/index.html"&gt;&lt;img height="42" &#13;
            width="42" &#13;
            src="@routes.Assets.at("images/swagger.png")"&gt; Swagger REST &#13;
            API &lt;/a&gt;&lt;BR&gt; &#13;
          &lt;/div&gt; &#13;
        &lt;/div&gt; &#13;
      &lt;/div&gt;             &#13;
    &lt;/div&gt;} &#13;
</pre><p>Now we can run our Play application with <code class="literal">$ activator run</code>.</p><p>Open the browser and go to <code class="literal">http://localhost:9000/</code>. You will see the following screenshot:</p><p>
</p><div class="mediaobject"><img src="../Images/image00329.jpeg" alt="Build and install Swagger Standalone"/></div><p style="clear:both; height: 1em;"> </p><p>
</p><p>Now we can open the Swagger UI by clicking on the Swagger REST API link or by just going to <code class="literal">http://localhost:9000/assets/swaggerui/index.html</code>. It should look something like this:</p><p>
</p><div class="mediaobject"><img src="../Images/image00330.jpeg" alt="Build and install Swagger Standalone"/></div><p style="clear:both; height: 1em;"> </p><p>
</p><p>As you can see, the Swagger UI is very nice. You can click on each operation and see more details on how they work, which HTTP verb they use, and what the URI is. There is a <span class="strong"><strong>Try it out!</strong></span> button. Let's click on the <span class="strong"><strong>Try it out!</strong></span> button for products, which would look something like this:</p><p>
</p><div class="mediaobject"><img src="../Images/image00331.jpeg" alt="Build and install Swagger Standalone"/></div><p style="clear:both; height: 1em;"> </p><p>
</p><p>As you can see, we have our JSON result and also some CURL samples as well.</p></div></div></div>
<div class="section" title="Summary" id="aid-3DLGM1"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec107"/>Summary</h1></div></div></div><p>In this chapter, you learned how to design a REST API and changed your Play framework application in order to have Swagger support. You created a Scala client library using proxy techniques, as well as Scala tests for the APIs. Additionally, you were introduced to back pressure using the leaky bucket algorithm.</p><p>In the next chapter, which will be the final chapter, you will learn about software architecture and scalability/resiliency techniques, such as discoverability, load balancers, caches, Akka Cluster, and the Amazon Cloud.</p></div></body></html>