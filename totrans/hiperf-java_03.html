<html><head></head><body>
		<div id="_idContainer011">
			<h1 class="chapter-number" id="_idParaDest-58"><a id="_idTextAnchor057"/>3</h1>
			<h1 id="_idParaDest-59"><a id="_idTextAnchor058"/>Optimizing Loops</h1>
			<p>Loops are fundamental programming constructs that are not terribly difficult to understand or write. We use them to iterate through our application’s data structures and perform repetitive tasks. We often take loops for granted based on their simple syntax and readability. When performance is a concern, loops have a duality. On one side, loops serve as a fundamental construct for efficient data processing. On the other side, poorly optimized loops can introduce significant bottlenecks and degrade the overall performance of our <span class="No-Break">Java applications.</span></p>
			<p>Concepts covered in this chapter include loop overhead, loop unrolling, benchmarks, loop fusion, loop parallelization, and loop vectorization. We will use code examples to provide insights and demonstrate <span class="No-Break">best practices.</span></p>
			<p>This chapter covers the following <span class="No-Break">main topics:</span></p>
			<ul>
				<li>Types <span class="No-Break">of loops</span></li>
				<li>Testing loops <span class="No-Break">for performance</span></li>
				<li><span class="No-Break">Nested loops</span></li>
			</ul>
			<p>This chapter explores techniques, strategies, and best practices to help you get the best performance out of your loops and to prevent the unintentional introduction of substantial bottlenecks that undermine <span class="No-Break">runtime performance.</span></p>
			<h1 id="_idParaDest-60"><a id="_idTextAnchor059"/>Technical requirements</h1>
			<p>To follow the examples and instructions in this chapter, you will need the ability to load, edit, and run Java code. If you have not set up your development environment, please refer back to <a href="B21942_01.xhtml#_idTextAnchor014"><span class="No-Break"><em class="italic">Chapter 1</em></span></a><span class="No-Break">.</span></p>
			<p>The finished code for this chapter can be found <span class="No-Break">here: </span><a href="https://github.com/PacktPublishing/High-Performance-with-Java/tree/main/Chapter03"><span class="No-Break">https://github.com/PacktPublishing/High-Performance-with-Java/</span><span class="No-Break">tree/main/Chapter03</span></a></p>
			<h1 id="_idParaDest-61"><a id="_idTextAnchor060"/>Types of loops</h1>
			<p>Loops are indispensable constructs<a id="_idIndexMarker140"/> for iterating through data structures, controlling the flow of code, and performing repetitive tasks. They are central to many algorithms and applications. While loops can be used to efficiently process data and perform repetitive tasks, they can be equally problematic when we are concerned <span class="No-Break">with performance.</span></p>
			<p>It is important to understand different types of loops, their characteristics, and their performance implications. This section explores different loop types in Java, which include <strong class="source-inline">for</strong>, <strong class="source-inline">while</strong>, <strong class="source-inline">do</strong>-<strong class="source-inline">while</strong>, and <strong class="source-inline">for</strong>-<strong class="source-inline">each</strong>. Our goal is to understand each loop type’s purpose and impact on code readability and efficiency. Specifically, we will cover the <span class="No-Break">following topics:</span></p>
			<ul>
				<li>A loop’s impact <span class="No-Break">on performance</span></li>
				<li>Loop <span class="No-Break">optimization basics</span></li>
				<li><span class="No-Break">Loop unrolling</span></li>
			</ul>
			<p>Being armed with a deeper understanding of loop types can equip you to make the right loop selection for a <span class="No-Break">given requirement.</span></p>
			<h2 id="_idParaDest-62"><a id="_idTextAnchor061"/>A loop’s impact on performance</h2>
			<p>In order to understand a loop’s impact<a id="_idIndexMarker141"/> on performance, we must have a firm understanding of the different types of loops. This section provides information on each loop type to include use cases and advantages. Examples are used to provide <span class="No-Break">implementation details.</span></p>
			<h3>for loops</h3>
			<p><strong class="source-inline">for</strong> loops are the most basic<a id="_idIndexMarker142"/> loop type. They have a concise syntax with well-defined <a id="_idIndexMarker143"/>loop control. They are the unofficial default for iterating through a set of items. Let’s look at the following components of these loops: initialization, condition, iteration, <span class="No-Break">and efficiency.</span></p>
			<p>The syntax for a <strong class="source-inline">for</strong> loop is <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
for (int i = 0; i &lt; 5; i++); {}
{</pre>			<p>Dissecting the preceding syntax, we can identify <strong class="source-inline">int i =0;</strong> as the <strong class="bold">initialization </strong>component of the loop. The <strong class="bold">loop control variable</strong> is <strong class="source-inline">i</strong> and it is set to <strong class="source-inline">0</strong>. The <strong class="source-inline">i &lt; 5;</strong> <strong class="bold">condition</strong> checks if <strong class="source-inline">i</strong> is less than <strong class="source-inline">5</strong>. If the evaluation<a id="_idIndexMarker144"/> returns <strong class="source-inline">true</strong>, then the loop continues; otherwise, it ends. The final component is the <strong class="bold">iteration</strong> where we use <strong class="source-inline">i++</strong> to increase the <strong class="bold">control variable</strong> by 1 at the end of <span class="No-Break">each iteration.</span></p>
			<p>There are some performance-related issues with a <strong class="source-inline">for</strong> loop. When we initialize our loop, we should avoid initializing variables outside of the loop as it can sometimes degrade performance with redundant initializations within the loop. The <strong class="bold">condition expression</strong> directly impacts the number of iterations<a id="_idIndexMarker145"/> the loop will perform. Making this expression overly complex can slow down the loop. Lastly, the <strong class="bold">iteration expression</strong> should be properly designed<a id="_idIndexMarker146"/> to help prevent an infinite loop <span class="No-Break">and inefficiency.</span></p>
			<p>Let’s look at an inefficient example<a id="_idIndexMarker147"/> and then a second example with performance<a id="_idIndexMarker148"/> improvements. The following example counts how many corgis have names with the <span class="No-Break">letter “</span><span class="No-Break"><strong class="source-inline">e</strong></span><span class="No-Break">”:</span></p>
			<pre class="source-code">
Corgi[] corgis = getCorgiArray();
int count = 0;
for (int i = 0; i &lt; corgis.length; i++) {
  if (corgis[i].getName().contains("e")) {
    count++;
  }
}</pre>			<p>The preceding code has <span class="No-Break">two inefficiencies:</span></p>
			<ul>
				<li>The loop condition is checked using the <strong class="source-inline">length()</strong> method in each iteration. This means that, for each corgi in the array, the length of the array is accessed, which can lead to unnecessary <span class="No-Break">performance overhead.</span></li>
				<li>Our code snippet uses <strong class="source-inline">corgis[i].getName().contains("e")</strong> to check if the corgi’s name contains the letter “<strong class="source-inline">e</strong>.” So, for each corgi name, we are creating a new string and performing a string search. This will most assuredly be computationally expensive, especially with <span class="No-Break">long names.</span></li>
			</ul>
			<p>With these inefficiencies in mind, let’s look at a revised section of <span class="No-Break">that code:</span></p>
			<pre class="source-code">
Corgi[] corgis = getCorgiArray();
int count = 0;
int corgisLength = corgis.length;
for (int i = 0; i &lt; corgisLength; i++) {
  String name = corgis[i].getName();
  if (name.indexOf('e') != -1) {
    count++;
  }
}</pre>			<p>This code snippet<a id="_idIndexMarker149"/> is an improved<a id="_idIndexMarker150"/> version that has the following <span class="No-Break">performance enhancements:</span></p>
			<ul>
				<li>We cached the array’s length by storing it in the <strong class="source-inline">corgislength</strong> variable. Since we populate that variable outside of the loop, we avoid repeated access to the array’s length during each iteration. This can save tremendously on <span class="No-Break">computational effort.</span></li>
				<li>Instead of using the <strong class="source-inline">contains()</strong> method to check the names, we use the <strong class="source-inline">indexof()</strong> method. There is a significant difference here. When we use the <strong class="source-inline">contains()</strong> method, a new substring is created and a full search is conducted. Using the <strong class="source-inline">indexof()</strong> method returns the index position of the first occurrence of “<strong class="source-inline">e</strong>” or -1 if it is not found. This is a much more efficient way to check for a character’s existence in a string without creating <span class="No-Break">unnecessary substrings.</span></li>
			</ul>
			<p>With our exploration of <strong class="source-inline">for</strong> loops completed, let us look at how to use <strong class="source-inline">while</strong> loops in an <span class="No-Break">efficient manner.</span></p>
			<h3>while loops</h3>
			<p><strong class="source-inline">while</strong> loops are perhaps the second most<a id="_idIndexMarker151"/> common loop used<a id="_idIndexMarker152"/> in Java. They are fundamental flow control constructs that we can use to repeatedly execute a block of code, as long as a specified condition <span class="No-Break">remains </span><span class="No-Break"><strong class="source-inline">true</strong></span><span class="No-Break">.</span></p>
			<p>The syntax for a <strong class="source-inline">while</strong> loop is <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
int count = 0;
int number = 1;
while (number &lt;= 100) {
    count += number;
    number++;
}</pre>			<p>These loops do not require initialization, but when initialization is employed, care should be taken to ensure they are correct so as to prevent unintended application behavior such as an infinite loop. When the <strong class="bold">condition</strong> evaluates as <strong class="source-inline">true</strong>, the body of the loop is executed. The loop terminates when the <strong class="bold">condition</strong> evaluates <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">false</strong></span><span class="No-Break">.</span></p>
			<p class="callout-heading">Condition expressions</p>
			<p class="callout">We should strive<a id="_idIndexMarker153"/> to create straightforward condition expressions for loop efficiency. Overly complex condition expressions can increase processing overhead, resulting in <span class="No-Break">poor performance.</span></p>
			<p>Let’s look at an inefficient example and then a second example with performance improvements. The following example is of an online ordering system. We want to check each order ID to determine if it starts with the “<strong class="source-inline">OL</strong>” prefix. If it does not, it should <span class="No-Break">be added:</span></p>
			<pre class="source-code">
List&lt;String&gt; orderIDs = getOrderIDs();
int index = 0;
while (index &lt; orderIDs.size()) {
  String orderID = orderIDs.get(index);
  if (!orderID.startsWith("OL")) {
    orderID = "OL" + orderID;
    orderIDs.set(index, orderID);
  }
    index++;
}</pre>			<p>There are two inefficiencies in the preceding code snippet. First, the list size is repeatedly accessed; it is checked during each iteration. This can lead to unnecessary performance overhead. Secondly, the string concatenation, using the <strong class="source-inline">+</strong> operator, creates a new string, which can be inefficient when repeatedly performed within <span class="No-Break">a loop.</span></p>
			<p>The following code snippet is a modified version of the online <span class="No-Break">ordering system:</span></p>
			<pre class="source-code">
List&lt;String&gt; orderIDs = getOrderIDs();
int index = 0;
int orderCount = orderIDs.size();
while (index &lt; orderCount) {
  String orderID = orderIDs.get(index);
  if (!orderID.startsWith("OL")) {
    orderIDs.set(index, "OL" + orderID);
  }
  index++;
}</pre>			<p>The preceding updated code snippet stands to improve system performance due to two factors. First, the list size is now cached, and second, we are using a more efficient string modification approach. Here, we are modifying<a id="_idIndexMarker154"/> the strings without creating<a id="_idIndexMarker155"/> new <span class="No-Break">string objects.</span></p>
			<p>With our exploration of <strong class="source-inline">while</strong> loops completed, let us look at how to use <strong class="source-inline">do</strong>-<strong class="source-inline">while</strong> loops in an <span class="No-Break">efficient manner.</span></p>
			<h3>do-while loops</h3>
			<p><strong class="source-inline">do</strong>-<strong class="source-inline">while</strong> loops, as with the ones previously<a id="_idIndexMarker156"/> covered, are flow control structures<a id="_idIndexMarker157"/> that allow for the repeated execution of a code block while a specified condition remains <strong class="source-inline">true</strong>. The unique nature of this type of loop is that the condition is checked after the loop’s code block is executed. This ensures that the loop’s block of code is executed at <span class="No-Break">least once.</span></p>
			<p>The following example shows a simple <strong class="source-inline">do</strong>-<strong class="source-inline">while</strong> loop for a guessing game where the user continues to guess a number until they <span class="No-Break">guess correctly:</span></p>
			<pre class="source-code">
int secretNumber = generateSecretNumber();
int userGuess;
boolean correctGuess = false;
do {
  userGuess = getUserGuess();
  if (userGuess == secretNumber) {
    correctGuess = true;
  } else {
      System.out.println("Try again!");
    }
  } while (!correctGuess);
  System.out.println("You guessed the secret number: " + 
  secretNumber);</pre>			<p>As you can see in the preceding code snippet, we use a Boolean flag to control our loop. The flag is checked during each iteration. This approach is inefficient in that it adds unnecessary complexity and an extra variable. Let’s modify the code so that it is <span class="No-Break">more efficient:</span></p>
			<pre class="source-code">
import java.util.random;
int secretNumber = generateSecretNumber();
int userGuess;
  do {
    userGuess = getUserGuess();
    if (userGuess != secretNumber) {
      System.out.println("Try again!");
    }
  } while (userGuess != secretNumber);
  System.out.println("You guessed the secret number: " + 
  secretNumber);</pre>			<p>With our updated example, we use <strong class="source-inline">userGuess != secretNumber</strong> as the loop condition, negating the need for a Boolean flag. This both simplifies<a id="_idIndexMarker158"/> our code and can make our code<a id="_idIndexMarker159"/> <span class="No-Break">more efficient.</span></p>
			<h3>for-each loops</h3>
			<p>We introduced the <strong class="source-inline">for</strong>-<strong class="source-inline">each</strong> loop in <a href="B21942_02.xhtml#_idTextAnchor028"><span class="No-Break"><em class="italic">Chapter 2</em></span></a> and noted<a id="_idIndexMarker160"/> that this type<a id="_idIndexMarker161"/> of loop is also referred to as an enhanced <strong class="source-inline">for</strong> loop. We choose to implement this type of loop when we want to iterate over all elements in a dataset, without having to manage an iterator or index. Let’s look at an initial example and then refine it for <span class="No-Break">better performance.</span></p>
			<p>The following code snippet is an automotive parts <span class="No-Break">processing application:</span></p>
			<pre class="source-code">
List&lt;String&gt; autoParts = getAutoParts();
for (String part : autoParts) {
  processPart(part);
}</pre>			<p>The inefficiency in the preceding code stems from the sequential processing of each automotive part within the loop. This can be a time-consuming operation and lead to poor performance. Let’s look at an <span class="No-Break">improved version:</span></p>
			<pre class="source-code">
List&lt;String&gt; autoParts = getAutoParts();
processAutoParts(autoParts);</pre>			<p>In this improved version, we implement a <strong class="source-inline">processAutoParts()</strong> method that takes the entire parts list as a parameter. This permits batch processing<a id="_idIndexMarker162"/> of parts, which can significantly improve<a id="_idIndexMarker163"/> <span class="No-Break">overall performance.</span></p>
			<p>With our exploration of loop types completed, let us now review loop <span class="No-Break">optimization basics.</span></p>
			<h2 id="_idParaDest-63"><a id="_idTextAnchor062"/>Loop optimization basics</h2>
			<p>As we strive to ensure<a id="_idIndexMarker164"/> our Java applications are high-performing, we rightly focus on loop optimizations. Loops are equally ubiquitous in Java programming, making their inefficiencies especially problematic. Loop efficiency can vary significantly based on implementation and use. This section examines fundamental aspects of loop optimization, with the aim of equipping you with the knowledge and tools to boost the performance of your <span class="No-Break">Java applications.</span></p>
			<h3>Loop overhead</h3>
			<p>Loop overhead refers to the additional<a id="_idIndexMarker165"/> computational costs associated with the initialization, implementation, and termination of a loop. While loops are essential for achieving various programming tasks, they are not free from computational overhead. Understanding loop overhead is crucial because excessive overhead can degrade the overall performance of your <span class="No-Break">Java applications.</span></p>
			<p>The three main components of loop overhead are loop initialization, condition evaluation, and iteration. As previously illustrated, each type of loop can result in inefficiencies with one or more of these components. Fortunately, there are strategies we can adopt to help minimize loop overhead. First, we can optimize loop initialization. This can be done by initializing our control variables outside of the loop. The performance gained is due to avoiding redundant assignments within the loop. We can also minimize the number of variables declared within <span class="No-Break">the loop.</span></p>
			<p>A second strategy is to use simple and efficient condition expressions. We want to avoid complex conditions within loops. If our loop’s condition is dependent on a dataset’s length, that length should be cached outside of the loop to prevent <span class="No-Break">repeated access.</span></p>
			<p>Thirdly, we can streamline our iteration. To adopt this strategy, we should ensure the iteration is designed to update loop control variables correctly and efficiently. We also should use the appropriate expression increments/decrements in an efficient and correct manner. Lastly, we should consider alternative loop types for each set <span class="No-Break">of requirements.</span></p>
			<h3>Bottlenecks</h3>
			<p>Unoptimized loops can result<a id="_idIndexMarker166"/> in bottlenecks in the performance of our Java applications. Understanding the cause of these bottlenecks is a necessary first step to avoiding them. As previously covered in this chapter, the following are common performance bottlenecks associated with loops in <span class="No-Break">Java programming:</span></p>
			<ul>
				<li>Inefficient <span class="No-Break">condition expressions</span></li>
				<li>Inefficient <span class="No-Break">iteration steps</span></li>
				<li><span class="No-Break">Unnecessary computations</span></li>
				<li>Suboptimal data <span class="No-Break">access patterns</span></li>
				<li>Excessive <span class="No-Break">memory allocation</span></li>
			</ul>
			<p>We should strive to implement optimization strategies specific to each loop type, as detailed in the preceding sections. General loop optimization strategies<a id="_idIndexMarker167"/> are <span class="No-Break">the following:</span></p>
			<ul>
				<li>Profile our loops to identify <span class="No-Break">performance bottlenecks</span></li>
				<li>Avoid <span class="No-Break">premature optimization</span></li>
				<li>Choose appropriate <span class="No-Break">data structures</span></li>
				<li>Choose <span class="No-Break">appropriate algorithms</span></li>
			</ul>
			<p>Additionally, as you will learn later in this chapter, profiling tools and methodologies can be used to help us determine where bottlenecks are within <span class="No-Break">our loops.</span></p>
			<h3>Benchmarking</h3>
			<p>Optimizing loops beyond the basic strategies <a id="_idIndexMarker168"/>covered in this chapter requires a firm understanding of how they perform, their characteristics, and the ability to measure optimizations for performance. We accomplish this measurement through benchmarking. Our goal is to assess the effectiveness of our <span class="No-Break">loop optimizations.</span></p>
			<p>We should establish a benchmarking environment so that we can evaluate loop performance. This requires us to set up a consistent environment that facilitates accurate measurements and comparative analysis. Each optimization can be tested against the benchmark to determine if it increased or degraded <span class="No-Break">application performance.</span></p>
			<p>To establish a benchmarking<a id="_idIndexMarker169"/> environment, follow <span class="No-Break">these steps:</span></p>
			<ol>
				<li>Choose a benchmarking framework or library that provides tools for measuring the performance of our Java code. We will<a id="_idIndexMarker170"/> take a specific look at the <strong class="bold">Java Microbenchmarking Harness</strong> (<strong class="bold">JMH</strong>) tool in <a href="B21942_13.xhtml#_idTextAnchor227"><span class="No-Break"><em class="italic">Chapter 13</em></span></a><span class="No-Break">.</span></li>
				<li>Ensure your development environment is properly configured and up <span class="No-Break">to date.</span></li>
				<li>Write benchmarking classes that include the loops we want <span class="No-Break">to benchmark.</span></li>
				<li>Specify settings and parameters for our benchmarks. This can include measurement time, number of iterations, and <span class="No-Break">warm-up iterations.</span></li>
				<li>Ensure that the variables involved are consistent across <span class="No-Break">all tests.</span></li>
				<li>Conduct warm-up runs to account for any JVM-specific <span class="No-Break">warm-up effects.</span></li>
				<li>Measure <span class="No-Break">execution times.</span></li>
				<li><span class="No-Break">Analyze results.</span></li>
				<li>Repeat and validate multiple times to ensure the validity of <span class="No-Break">your findings.</span></li>
				<li>Interpret your results <span class="No-Break">and optimize.</span></li>
				<li>Document <span class="No-Break">your results.</span></li>
			</ol>
			<p>By following these steps for establishing<a id="_idIndexMarker171"/> a benchmarking environment, you can make informed decisions about your loop optimizations, identify performance bottlenecks, and fine-tune your Java applications to achieve <span class="No-Break">higher performance.</span></p>
			<h2 id="_idParaDest-64"><a id="_idTextAnchor063"/>Loop unrolling</h2>
			<p>Loop unrolling is an advanced optimization<a id="_idIndexMarker172"/> strategy. It is an optimization technique we can employ in Java to improve our loops. The approach involves replicating, or unrolling, the loop’s code block multiple times, to reduce the number of required iterations. More specifically, instead of executing our loop’s code block once per iteration, we expand the loop to execute the code block multiple times within a single iteration. While this may seem complex, it can reduce the loop overhead caused by condition checks and <span class="No-Break">updating variables.</span></p>
			<p>The benefits of loop unrolling include <span class="No-Break">the following:</span></p>
			<ul>
				<li>Reduced <span class="No-Break">loop overhead</span></li>
				<li>Improved CPU instruction <span class="No-Break">cache usage</span></li>
				<li>Enhanced <span class="No-Break">compiler optimization</span></li>
				<li>Opportunities <span class="No-Break">for parallelism</span></li>
			</ul>
			<p>There are two types of loop unrolling: manual and automatic. Let’s look at an example of each. This first example is of manual loop unrolling. Here, we must explicitly rewrite our loop code to unroll it. Here is <span class="No-Break">an example:</span></p>
			<pre class="source-code">
// Original loop
for (int i = 0; i &lt; 5; i++) {
  // loop's code block
}
// Manual loop unrolling
for (int i = 0; i &lt; 4; i += 2) {
  // loop's code block (iteration 1)
  // loop's code block (iteration 2)
  // ...
}</pre>			<p>The manual loop unrolling provides us with finite control over the unrolling process, but, because it is done manually, it is exceedingly difficult to maintain <span class="No-Break">the code.</span></p>
			<p>With automatic loop unrolling, we can leverage compiler optimization tools to automatically unroll our loop code. The compiler will reference compiler flags that we specify. Here is <span class="No-Break">an example:</span></p>
			<pre class="source-code">
// Original loop
for (int i = 0; i &lt; 5; i++) {
    // loop's code block
    // ...
}
// Compiler optimization flags</pre>			<p class="callout-heading">Compiler flags</p>
			<p class="callout">In Java, compiler flags are used to specify non-default settings or options at compile time. We pass flags (for example, <strong class="source-inline">-O</strong>, to enable optimization during compilation) to the <strong class="source-inline">javac</strong> <span class="No-Break">compiler command.</span></p>
			<p>Using automatic unrolling <a id="_idIndexMarker173"/>can simplify the optimization process and save us time. The disadvantage to this approach is that the unrolling results might not be the most efficient. As the complexity of our loops increases, the efficiency of the automatic unrolling <span class="No-Break">results decreases.</span></p>
			<p>It is considered a best practice to use loop unrolling when we have a known and fixed number of iterations. Also, if loop overhead is not a significant concern, then loop unrolling may not be necessary. A side effect of manual unrolling may be increased memory usage. Whenever unrolling loops, we should profile and measure optimizations <span class="No-Break">on performance.</span></p>
			<p>There are limitations of loop unrolling. First, not every loop is ideal for unrolling, such as when the dataset size is variable or dynamic. Another limitation or disadvantage of unrolling is that it can result in bloated code, increasing the binary size, which, in turn, can result in instruction cache mistakes. Lastly, automatically unrolling may not always produce the desired <span class="No-Break">loop optimization.</span></p>
			<p>You should now have a comprehensive <a id="_idIndexMarker174"/>understanding of loop types in Java, including their strengths and weaknesses and their ideal use cases. Your loop selection decisions can now be more informed and help ensure you are creating code that is performant <span class="No-Break">and maintainable.</span></p>
			<h1 id="_idParaDest-65"><a id="_idTextAnchor064"/>Testing loops for performance</h1>
			<p>Now that we have a firm grasp<a id="_idIndexMarker175"/> of the different types of loops and their advantages and disadvantages, we should feel empowered to make the best loop selections. Furthermore, we should be able to implement optimization strategies. But how do we know if our loop optimization strategies result in better or worse performance? That is where testing comes into play and is the focus of <span class="No-Break">this section.</span></p>
			<p>In this section, we will cover the <span class="No-Break">following concepts:</span></p>
			<ul>
				<li>Profiling tools <span class="No-Break">and methodology</span></li>
				<li>Benchmarking and <span class="No-Break">testing strategies</span></li>
				<li>Case studies <span class="No-Break">and examples</span></li>
			</ul>
			<p>Our goal is to obtain the knowledge and practical skills needed to evaluate, optimize, and harness the full potential of loops within our Java applications. Moreover, we want to have a testing strategy that will inform us of the efficacy of <span class="No-Break">our optimizations.</span></p>
			<h2 id="_idParaDest-66"><a id="_idTextAnchor065"/>Profiling tools and methodology</h2>
			<p>It is not enough to write optimized loops in our Java applications. We should have a clear understanding of profiling tools and methodologies. In our context, profiling is the practice of analyzing the execution of our loops to gain insights into their performance characteristics. We can glean crucial information on how much CPU time our <span class="No-Break">loops demand.</span></p>
			<h3>Why profiling is important</h3>
			<p>Profiling is considered<a id="_idIndexMarker176"/> a diagnostic tool used by developers who are concerned with the performance of their Java applications. Profiling is applicable to all sections of our code, and, in this section, our focus is on loops. We use profiling tools to get deep insights into the behavior of our code at runtime. Here are some insights we can gain <span class="No-Break">from profiling:</span></p>
			<ul>
				<li>How much CPU time do our <span class="No-Break">loops consume?</span></li>
				<li>Are memory <span class="No-Break">leaks present?</span></li>
				<li>Does our code result in excessive <span class="No-Break">memory allocation?</span></li>
				<li>How do our loops interact with the <span class="No-Break">CPU cache?</span></li>
				<li>How do our loops interact <span class="No-Break">with memory?</span></li>
			</ul>
			<p>We can write our loops in different<a id="_idIndexMarker177"/> ways and use profiling to help inform us of which method is the best from an overall runtime <span class="No-Break">performance perspective.</span></p>
			<h3>Profiling types</h3>
			<p>There are three basic<a id="_idIndexMarker178"/> profiling types: CPU, memory, and thread. In <strong class="bold">CPU profiling</strong>, the focus is on how our code uses<a id="_idIndexMarker179"/> the CPU. This profiling type is especially useful for identifying CPU bottlenecks created by <span class="No-Break">our loops.</span></p>
			<p><strong class="bold">Memory profiling</strong> gives us insights into memory-related<a id="_idIndexMarker180"/> issues. These can include excessive memory consumption, memory leaks, and excessive or inefficient object creation. This is one of the most useful profiling types when our focus is on <span class="No-Break">loop optimization.</span></p>
			<p>The <strong class="bold">thread profiling</strong> type is useful in identifying synchronization<a id="_idIndexMarker181"/> issues that can affect the performance of <span class="No-Break">our loops.</span></p>
			<h3>Profiling tools</h3>
			<p>Profiling tools are software <a id="_idIndexMarker182"/>applications that help automate profiling options for us. There are a plethora of tools available to Java developers, many of which are open source and free to use. These tools can be organized into three categories: those that come bundled with the JDK, those <a id="_idIndexMarker183"/>that come bundled with an <strong class="bold">integrated development environment</strong> (<strong class="bold">IDE</strong>), and commercial or <span class="No-Break">third-party tools.</span></p>
			<p>Let’s look at two examples of profiling tools that come bundled with the JDK. First, <strong class="bold">Java Flight Recorder</strong> (<strong class="bold">JFR</strong>) is a built-in tool that can record and analyze<a id="_idIndexMarker184"/> application behavior. This tool is lauded for its low processing overhead. <strong class="bold">VisualVM</strong> is another profiling tool that comes<a id="_idIndexMarker185"/> bundled with the JDK. It provides great insights into CPU usage and memory usage, as well<a id="_idIndexMarker186"/> as <span class="No-Break">thread activity.</span></p>
			<h3>Profiling methodologies</h3>
			<p>A profiling methodology is essentially<a id="_idIndexMarker187"/> your approach to profiling. This is more than simply selecting a profiler to use. In fact, you often will want to use more than one tool as part of your methodology. When asked what your profiling methodology is, consider what your overall <span class="No-Break">approach is.</span></p>
			<p>You might employ a <strong class="bold">sampling profiling</strong> methodology where you periodically<a id="_idIndexMarker188"/> pull data on your application’s execution. This sampling approach provides a quick view of code execution behavior and can provide insights into what might need <span class="No-Break">deeper profiling.</span></p>
			<p>Another common profiling methodology is <strong class="bold">instrumentation profiling</strong>. This approach requires us to add profiling<a id="_idIndexMarker189"/> code to our application. While this approach can provide the greatest level of fidelity regarding code execution behavior, it also commands the most <span class="No-Break">CPU overhead.</span></p>
			<p>A third popular<a id="_idIndexMarker190"/> profiling methodology is <strong class="bold">continuous profiling</strong>. This approach collects a lot of data over long periods of an application running. Developers who employ this methodology can gain insights into long-term trends and more easily detect <span class="No-Break">performance anomalies.</span></p>
			<p class="callout-heading">Identifying hotspots in our loops</p>
			<p class="callout">In the context of Java loops, a hotspot<a id="_idIndexMarker191"/> is a loop that consumes excessive CPU time or memory at runtime. It is imperative that we pinpoint these hotspots in our loops so that we can <span class="No-Break">optimize them.</span></p>
			<p>As a final note on profiling, we should<a id="_idIndexMarker192"/> realize that identifying a <strong class="bold">hotspot</strong> is just one step, and using a profiling tool is another. We need to address the issues we uncover and then reapply profiling tools to ensure our changes have the desired impact. Developers should have a continuous improvement mindset over their loops and other code. This requires the continual monitoring and profiling of <span class="No-Break">our code.</span></p>
			<h2 id="_idParaDest-67"><a id="_idTextAnchor066"/>Benchmarking and testing strategies</h2>
			<p>We have accepted that optimizing loops is a critical part of ensuring our Java applications perform at a high level. This high performance requires benchmarking and testing strategies. This section looks at both types of strategies and shares <span class="No-Break">best practices.</span></p>
			<h3>Benchmarking strategies</h3>
			<p>JMH is the most common toolkit<a id="_idIndexMarker193"/> used for conducting performance testing of Java code. It does a wonderful job of handling finite components of Java performance testing. As the name suggests, it is designed specifically to test Java code and is widely used in micro-level performance testing. Some features<a id="_idIndexMarker194"/> of JMH are <span class="No-Break">the following:</span></p>
			<ul>
				<li>It measures the performance characteristics of microbenchmarks (code segments). It is especially handy for loop <span class="No-Break">performance testing.</span></li>
				<li>JMH supports measurements of average time, sample time, single-shot time, and throughput. This gives developers <span class="No-Break">great flexibility.</span></li>
				<li>With JMH, developers have finite control of the <span class="No-Break">testing environment.</span></li>
				<li>Can be integrated with build tools (for <span class="No-Break">example, Maven).</span></li>
				<li>Provides detailed <span class="No-Break">microbenchmarking results.</span></li>
			</ul>
			<p>Regardless of which benchmarking tool we use, it is important to first establish a baseline. We can accomplish this by running our tools on unoptimized code. Once we have the results of that test, we have our baseline. Testing optimized code can be evaluated against <span class="No-Break">the baseline.</span></p>
			<h3>Testing strategies</h3>
			<p>There are three primary<a id="_idIndexMarker195"/> testing strategies. The first is unit testing. This strategy can help us ensure that any changes we make to our loops do not impact the expected code behavior. Unit testing can also help us test our loops with edge cases such as with <span class="No-Break">extreme values.</span></p>
			<p>Profiling and hotspot analysis is another testing strategy that has already been covered in this chapter. As a reminder, we use profiler tools such as JFR or VisualVM to help us analyze CPU and <span class="No-Break">memory usage.</span></p>
			<p>Lastly, we can use regression testing to test our loops after we make changes to the application. This can help ensure that our changes do not negatively impact any <span class="No-Break">other functionality.</span></p>
			<p>Regardless of our testing strategy, we should approach<a id="_idIndexMarker196"/> loop optimization testing in an iterative manner. This means we should make small, incremental changes to our loops, testing after <span class="No-Break">each change.</span></p>
			<h2 id="_idParaDest-68"><a id="_idTextAnchor067"/>Case studies and examples</h2>
			<p>This section covers practical case studies and examples of optimizing loops in Java. It can be powerful to review real-world scenarios as we stand to gain great insights into common challenges and best practices <span class="No-Break">for solutions.</span></p>
			<h3>Case studies</h3>
			<p>Consider a case study in which<a id="_idIndexMarker197"/> we need to process a large dataset and aggregate data based on a business requirement. Our challenge, in this scenario, is that our aggregation loop is very slow. Since we have a large dataset, we want to solve for the slow loop. What can we do? We can ensure we are using an <strong class="source-inline">ArrayList</strong> instead of a <strong class="source-inline">LinkedList</strong>. We can also use Java’s <strong class="bold">Stream API</strong> to implement parallel processing. This should make better use of multi-core CPUs. We can also minimize object creation within the loop. Given this scenario and the suggested solutions, we are likely to significantly reduce the aggregation loop operation time as well as the complexity of <span class="No-Break">the loop.</span></p>
			<p>Let’s look at another case study. This one features a banking application that calculates investment risk metrics over large datasets. The challenge, in this scenario, is that our main calculation loop is inefficient. We might take a three-pronged optimization strategy. First, we will examine our algorithm and see if it can be improved. Next, we will write <a id="_idIndexMarker198"/>our code so that it supports <strong class="bold">Just-In-Time</strong> (<strong class="bold">JIT</strong>) compilation. Lastly, we will look at our data structures and make any necessary changes to minimize memory access issues. This three-pronged approach can result in a significantly more <span class="No-Break">performant application.</span></p>
			<h3>Examples</h3>
			<p>Let’s look at two real-world applications<a id="_idIndexMarker199"/> of loop testing <span class="No-Break">and optimization.</span></p>
			<p>Our first example is data processing for healthcare analytics. The challenge is that processing large groups of patient data for analytical reports is slow. The solution is to implement multithreading and batch processing within our loops so that we can process data in parallel chunks. The result of this approach should be a significant reduction in data <span class="No-Break">processing time.</span></p>
			<p>Another example is inventory management as part of an e-commerce Java application. The challenge is to optimize the loop in our code that processes inventory updates. For this scenario, we will assume that the loop is slower than it has been in the past, most likely due to an ever-increasing inventory dataset. The solution would likely be to use efficient data structures and change our loop structure as appropriate. The result of this approach should be faster inventory processing and greater <span class="No-Break">response times.</span></p>
			<p>This section covered profiling tools, profiling methodologies, benchmarking, testing strategies, case studies, and examples. We can now confidently evaluate, optimize, and harness the full potential of loops within our Java applications, leading to high <span class="No-Break">runtime performance.</span></p>
			<h1 id="_idParaDest-69"><a id="_idTextAnchor068"/>Nested loops</h1>
			<p>Now, we’ll cover the fundamental<a id="_idIndexMarker200"/> concepts, practical optimization strategies, and technical intricacies involved in effectively optimizing nested loops in Java applications. We will tackle the concept of nested loops, as they relate to high-performance Java applications, in the <span class="No-Break">following sections:</span></p>
			<ul>
				<li>Introduction to <span class="No-Break">nested loops</span></li>
				<li>Loop fusion in <span class="No-Break">nested loops</span></li>
				<li>Parallelizing <span class="No-Break">nested loops</span></li>
				<li>Nested <span class="No-Break">loop vectorization</span></li>
			</ul>
			<p>It is important to understand when to use nested loops and, when we do, how to implement them in the most <span class="No-Break">optimal method.</span></p>
			<h2 id="_idParaDest-70"><a id="_idTextAnchor069"/>Introduction to nested loops</h2>
			<p>A nested loop is when<a id="_idIndexMarker201"/> one loop is located inside another. This creates a complex iteration scenario. Here is the syntax for a simple <span class="No-Break">nested loop:</span></p>
			<pre class="source-code">
for (int i = 0; i &lt; 10; i++) {          // Outer loop
    for (int j = 0; j &lt; 10; j++) {      // Inner loop
        System.out.println("i = " + i + ", j = " + j);
    }
}</pre>			<p>As you can see in the preceding syntax, the outer loop runs 10 times, and for each iteration, the inner loop also runs three times. This results in a total of 10 x 10 = <span class="No-Break">100 iterations.</span></p>
			<p>We can implement a finite number of levels in our nested loops. With each inner loop, our code becomes more complex, more difficult to read, and more frustrating to maintain. So, when would we use nested loops? One common implementation is when processing multi-dimensional arrays<a id="_idIndexMarker202"/> such as matrices. They are also used when performing operations <span class="No-Break">on tables.</span></p>
			<p class="callout-heading">Warning</p>
			<p class="callout">Be careful when implementing nested loops. They can very quickly become inefficient and make your application sluggish <span class="No-Break">and non-responsive.</span></p>
			<h2 id="_idParaDest-71"><a id="_idTextAnchor070"/>Loop fusion in nested loops</h2>
			<p>If we must implement nested <a id="_idIndexMarker203"/>loops in our Java applications, we should consider<a id="_idIndexMarker204"/> applying loop fusion to them for efficiency. Loop fusion is essentially an algorithmic approach where we combine adjacent loops, ones that perform operations on the same dataset, into a <span class="No-Break">single loop.</span></p>
			<p>We can also attempt to reduce redundant calculations and improve cache utilization. This is possible when we merge loops because it stands to minimize redundancy, thereby improving the use of cache. The technique involves reusing data that is loaded into the cache during the same iteration. The outcome is generally fewer <span class="No-Break">cache misses.</span></p>
			<p>Loop fusion can also prove beneficial<a id="_idIndexMarker205"/> when using complex algorithms<a id="_idIndexMarker206"/> such as matrix multiplication. There is a potential side effect, namely increased loop complexity. This greater complexity results in decreased code readability and makes the code more difficult <span class="No-Break">to maintain.</span></p>
			<h2 id="_idParaDest-72"><a id="_idTextAnchor071"/>Parallelizing nested loops</h2>
			<p>To parallelize nested loops<a id="_idIndexMarker207"/> in Java, we need to restructure our loops so they can execute concurrently across multiple CPU cores instead of on a single core. As you would expect, this is a component of parallel computing, which can result in significantly increased runtime performance. Strategies for parallelizing nested loops include chunking our dataset and processing each chunk in a <span class="No-Break">separate thread.</span></p>
			<p>The concept of multithreading is often discussed along with parallel streams in the context of nested loops. Comparing the two, we can learn that multithreading offers additional control but requires us to explicitly manage threads and tasks. Parallel streams, which are part of Java’s <strong class="bold">Stream API</strong>, provide us with an easier method to parallelize operations, but with less control over the <span class="No-Break">threading model.</span></p>
			<p>Lastly, when parallelizing, we must<a id="_idIndexMarker208"/> handle synchronization and thread safety. Synchronization becomes key as does ensuring thread safety. This is especially true when we deal with shared <span class="No-Break">data structures.</span></p>
			<h2 id="_idParaDest-73"><a id="_idTextAnchor072"/>Nested loop vectorization</h2>
			<p>You may recall from <a href="B21942_02.xhtml#_idTextAnchor028"><span class="No-Break"><em class="italic">Chapter 2</em></span></a> of this book<a id="_idIndexMarker209"/> that vectorization refers to the process of executing<a id="_idIndexMarker210"/> a single instruction simultaneously on multiple data points. We can leverage vectorization for nested loops to significantly increase computational speed, especially when dealing with complex data manipulations such as <span class="No-Break">a matrix.</span></p>
			<p><strong class="bold">Single Instruction, Multiple Data</strong> (<strong class="bold">SIMD</strong>) can be an important concept in nested<a id="_idIndexMarker211"/> loop optimization. SIMD is a key concept in vectorization where, as the name suggests, a single operation is performed on multiple data elements. This is an especially effective technique with repetitive nested loops. The efficacy of vectorization depends on compiler optimizations and hardware support. Not all CPUs have <span class="No-Break">SIMD capabilities.</span></p>
			<p>This section provided a structured overview of nested loop optimization with the goal of increasing Java application performance. Fundamental concepts were covered, as were practical optimization strategies, and some technical intricacies involved in effectively optimizing nested loops in <span class="No-Break">Java applications.</span></p>
			<h1 id="_idParaDest-74"><a id="_idTextAnchor073"/>Summary</h1>
			<p>This chapter focused on loops, fundamental programming constructs, and how to get the most out of them from a runtime performance perspective. Concepts covered included loop overhead, loop unrolling, benchmarks, loop fusion, loop parallelization, and loop vectorization. We used code examples to provide insights and demonstrate <span class="No-Break">best practices.</span></p>
			<p>We explored techniques, strategies, and best practices to help you get the best performance out of your loops and to prevent the unintentional introduction of substantial bottlenecks that undermine <span class="No-Break">runtime performance.</span></p>
			<p>The next chapter takes a specific look at Java object pooling, which is a design pattern used to manage reusable objects to conserve resources and improve <span class="No-Break">application performance.</span></p>
		</div>
	</body></html>