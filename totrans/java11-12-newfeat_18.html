<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Data Classes and Their Usage</h1>
                </header>
            
            <article>
                
<p>Concerning the data classes in Project Amber, work is in progress. It proposes to provide developers with a simplified method for modeling data, introducing special classes with the <kbd>record</kbd> keyword. The state of a data class could be captured by using the class header, which is in stark contrast to the existing <strong>Plain Old Java Objects</strong> (<strong>POJOs</strong>).</p>
<p>In this chapter, we'll cover the following topics:</p>
<ul>
<li>An introduction to data classes</li>
<li>The need for data classes, and their limitations</li>
<li>The aggregate and exploded forms of data classes</li>
<li>Pattern matching with data classes</li>
<li>Inheritance with abstract data classes and interfaces</li>
<li>Adding variables and methods</li>
<li>Overriding default behaviors</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">An introduction to data classes</h1>
                </header>
            
            <article>
                
<p>We know of two versions of data classes—POJO (the old, existing form) and the newly proposed data classes. To understand the data classes that are being worked on in Project Amber, you'll need to know the capabilities and limitations of the existing POJO classes and why we need the newly proposed classes.</p>
<div class="packt_infobox">POJO is not implemented using a language construct. The proposed data classes would include changes or additions to the programming language.</div>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">What is a data class?</h1>
                </header>
            
            <article>
                
<p>As a Java developer, you have probably used and created POJOs in some (or all) of your projects. A POJO is a class that encapsulates a set of data, without any additional behavior to manipulate its state. It usually includes constructors, accessors, mutators, and the overridden methods from the object class (<kbd>hashCode()</kbd>, <kbd>equals()</kbd>, and <kbd>toString()</kbd>). The accessors and mutators allow access and assignment to state variables. Additionally, the mutators might include code to check the range of values that are assigned to the instance state. The following is an example:</p>
<pre>final class Emp { 
    private String name; 
    private int age; 
 
    public Emp(String name, int age) { 
        this.name = name; 
        this.age = age; 
    } 
 
    // accessor methods - getName, getAge 
    public String getName() { 
        return name; 
    } 
 
    public int getAge() { 
        return age; 
    } 
 
    // mutator methods - setName, setAge 
    public void setName() { 
        this.name = name; 
    } 
 
    public void setAge() { 
        this.age = age; 
    } 
 
    public boolean equals(Object obj) { 
        if (obj == null || (!(obj instanceof Emp))) 
            return false; 
        else { 
            if ( ( ((Emp)obj).getName().equals(this.name) &amp;&amp; 
                 ( ((Emp)obj).getAge() ) == this.age)) { 
                return true; 
            } 
            else 
                return false; 
        } 
    } 
 
    public String toString() { 
        return name + ":" + age; 
    } 
    public int hashCode() { 
        // ..code 
    } 
} </pre>
<p>One scenario is using the <kbd>Emp</kbd> <span>class </span>to save employee data to your database. Here's an example:</p>
<pre>interface EmpDAO { 
    Emp read(); 
    void write(Emp emp); 
    List&lt;Emp&gt; getAllEmp(); 
} </pre>
<p>Similarly, you can use the <kbd>Emp</kbd> class to be passed in a message, sent over the network, inserted into a JSON object, and more.</p>
<p>All of this looks good. Most importantly, it has been working fine since Java was introduced to developers. So, what is the problem?</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The need to add data classes to the language</h1>
                </header>
            
            <article>
                
<p>Imagine securing the borders of a country, which are normally guarded by defense forces. Will the level of security change based on the relationships with the neighboring countries (cordial, neutral, or tense)? What happens if the borders are porous (<span>for example, the borders in Western Europe, for the Schengen countries)? Now, compare guarding the borders of a country with guarding our homes or securing the contents of a cabinet in a room.</span></p>
<p>Although each instance in the preceding example concerns the security of an entity and its protection from a physical attack, the instances have varying requirements.</p>
<p>Similarly, until now, the classes in Java have been used to model a wide range of requirements. While this works well for a lot of cases, it doesn't work for some. If you want to make the same size fit all, you'll need a lot of adjustments, for most of them.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Compare this to using the same trouser size for individuals with varying heights and waist sizes, as shown in the following diagram:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/ff9fc26c-c236-4f13-864d-12e26d343d9d.png" style="width:31.42em;height:29.25em;"/></p>
<p>In the past, enums were added to the Java language (version 5). Even though a class can be programmed to create an enumeration of primitives or objects, enums simplified the process for a developer.</p>
<div class="packt_infobox">Enums reduced the coding for developers. At the same time, they made the intent of each enum explicit to the users.</div>
<p>In the preceding section, the <kbd>Emp</kbd> <span>POJO </span>is just a carrier of its data. However, seasoning a class to behave like a data class requires a developer to define multiple methods—constructs, accessors, mutators, and other methods from the object class. You might argue that you can use an IDE to easily generate all of these methods for your class. You are right! And it's quite simple to do so.</p>
<p class="mce-root"/>
<p>However, that only takes care of the writing part of the code. What happens to the reading part of the code, for the users of the class? Us developers understand that a piece of code might be written just once, but will be read multiple times. That is why experienced programmers stress good coding practices, for comprehending, reading, and maintaining code.</p>
<p>When the definition of data classes is induced in the language, the readers of the code will know its explicit intent of being a data class. The developers need not dig their claws deep into finding the code that was in addition to being a data class, so that they don't miss any important information.</p>
<p>This will also prevent the developers from using half-baked classes as data classes. At times, developers use such classes as a data class, which do not include all of the relevant methods (such as <kbd>equals()</kbd> or <kbd>hashCode()</kbd>). This will surely lead to inserting subtle bugs in your applications. A collection class, such as <kbd>Map</kbd>, requires a class to implement its <kbd>equals()</kbd> and <kbd>hashCode()</kbd> methods to function properly and efficiently.</p>
<div class="packt_infobox">Introducing data classes with a change in the language would decrease the verbosity of the language, broadcasting the intent of the structure to all.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Diving into data classes</h1>
                </header>
            
            <article>
                
<p>The syntax to define a data class looks simple. However, both the syntax and semantics are important. Let's get started by looking at some examples, in the following sections.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Example of syntax and semantics</h1>
                </header>
            
            <article>
                
<p>Let's redefine the <kbd>Emp</kbd> class, which we used at the beginning of the chapter, as a data class:</p>
<pre>record Emp(String name, int age) { }      // data class - one liner <br/>                                          // code </pre>
<p>The preceding code uses the <kbd>record</kbd> <span>keyword </span>to define a data class, accepting a comma-separated variable <kbd>name</kbd> and type, required to store the state. The compiler automatically generates default implements for the object methods (<kbd>equals()</kbd>, <kbd>hashCode()</kbd>, and <kbd>toString()</kbd>) for data classes.</p>
<p>The code looks clear and compact. A reader would immediately know the intent of this single line of code—a carrier of the data <kbd>name</kbd> (type <kbd>String</kbd>) and <kbd>age</kbd> (type <kbd>int</kbd>). Another advantage for a reader is that they wouldn't have to read through constructors, accessors, mutators, or methods of the object class, just to ascertain that they are doing what they are supposed to.</p>
<p>Behind the scenes, the record class, <kbd>Emp</kbd>, is converted to the following code by the Java compiler:</p>
<pre>final class Emp extends java.lang.DataClass {<br/>     final String name; final int age; <br/>         public Emp(String name, int age) {<br/>         this.name = name; this.age = age; } // deconstructor // public        <br/>        // accessor methods // default implementation of equals,     <br/>       // hashCode, and toString } </pre>
<p>The preceding data class is an example of a non-abstract data class. A data class can also be defined as an abstract data class. A non-abstract data class is implicitly final. In both cases, a data class will get default implementations of <kbd>hashCode()</kbd>, <kbd>equals()</kbd>, and <kbd>toString()</kbd>, and accessor methods. For an abstract data class, the constructors would be protected.</p>
<p class="mce-root"/>
<p>In the following diagram, the compiler looks happy to convert the one line code for the data class to a full-fledged class:</p>
<p class="mce-root"/>
<p class="CDPAlignCenter CDPAlign"><img src="assets/597d2162-3fb1-4aa5-8812-2e596c742a27.png" style="width:32.75em;height:34.17em;"/></p>
<div class="packt_infobox">By default, a data class is <kbd>final</kbd>; you can't extend it.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The aggregate and exploded forms of data classes</h1>
                </header>
            
            <article>
                
<p>The aggregate form of a data class will be the name of the data class. Its exploded form would refer to the variables used to store its data. The conversion from aggregate to exploded form is referred to as the <strong>deconstruction pattern</strong>.</p>
<p>The following code refers to the example that we used in the preceding section:</p>
<pre>record Emp(String name, int age) { }       </pre>
<p><kbd>Emp</kbd> is the aggregate form of the <kbd>Emp</kbd> <span>data class. </span>Its exploded form would be <kbd>String name</kbd> and <kbd>int age</kbd>. The language would need easy conversion between the two, so that they can be used with other language constructs, such as <kbd>switch</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Limitations</h1>
                </header>
            
            <article>
                
<p>When you use the <kbd>record</kbd> <span>keyword </span>to define your data class, you'll be limited by what the language allows you to do. You'll no longer have fine control over whether your data class is extensible, whether its state is mutable, the range of values that can be assigned to your fields, the accessibility to your fields, and so on. You might also be limited when it comes to having additional fields or multiple constructors.</p>
<div class="packt_infobox">Data classes are still in progress at Oracle. The finer details are still being worked on. In March 2018, the <kbd>datum</kbd> <span>keyword </span>was used to define a data class but has now been changed to <kbd>record</kbd>.</div>
<p>Nowadays, developers aren't limited to working with a single programming language. Java programmers usually work with or are aware of, other programming languages that work on the JVM, such as Scala, Kotlin, or Groovy. The experience of working with varied languages brings a lot of expectations and assumptions about the capabilities and limitations of the data classes (defined using <kbd>record</kbd>).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Examples from the past – changes to define enums</h1>
                </header>
            
            <article>
                
<p>Prior to the introduction of enums, developers often used <kbd>public</kbd>, <kbd>static</kbd>, and <kbd>final</kbd> variables to define constants. The following is an example:</p>
<pre>class Size { 
    public final static int SMALL = 1; 
    public final static int MEDIUM = 2; 
    public final static int LARGE = 3; 
}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>
<p>The major drawback of using <kbd>public</kbd>, <kbd>static</kbd>, <kbd>final</kbd>, and <kbd>int</kbd> variables is type safety; any <kbd>int</kbd> value could be assigned to a variable of the type <kbd>int</kbd>, instead of the <kbd>Size.SMALL</kbd>, <kbd>Size.MEDIUM</kbd>, or <kbd>Size.LARGE</kbd> constants.</p>
<p>Java 5 introduced enums, an addition to the language construct, to enable developers to define an enumeration of constants. Here's a quick example:</p>
<pre>enum Size {SMALL, MEDIUM, LARGE} 
class SmallTShirt { 
    Size size = Size.SMALL; 
    //..other code 
} </pre>
<p>With a variable of the type <kbd>Size</kbd>, an assignment is limited to the constants defined in <kbd>Size</kbd>. An enum is a perfect example of how language can simplify the implementation of a model, at the cost of certain constraints. Enums limit the extensibility to interfaces. Other than that, enums are full-fledged classes. As a developer, you can add states and behaviors to them. Another benefit is that an enum can also <kbd>switch</kbd> constructs, which was previously limited to primitives and a <kbd>String</kbd> class.</p>
<div class="packt_infobox">A new language construct is like a new human relationship, biological or otherwise. It has its own share of joys and sorrows.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Pattern matching with data classes</h1>
                </header>
            
            <article>
                
<p>When you define your data classes using the <kbd>record</kbd> <span>keyword,</span> you get the added advantage of the conversion of aggregate and exploded forms of your data class. For example, the following code shows how the <kbd>switch</kbd> statement might explode the data:</p>
<pre>interface Garment {} 
record Button(float radius, Color color); 
record Shirt(Button button, double price); 
record Trousers(float length, Button button, double price); 
record Cap(..) 
 
switch (garment) { 
     case Shirt(Button(var a1, var a2), Color a3): ... 
     case Trousers(float a1, Button(var a2, var a3), double a4): ... 
     .... 
}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>The <kbd>switch</kbd> statement can use a data class, without using its exploded form. The following code is also effective:</p>
<pre>switch (garment) { 
     case Shirt(Button a1, Color a2): ... 
     case Trousers(float a1, Button a2, double a3): ... 
     .... 
}  </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Encapsulating the state</h1>
                </header>
            
            <article>
                
<p>The record classes encapsulate the fields, providing default implementations of JavaBean-style accessor methods (public methods to set the values of fields). The values can be assigned during the initialization of data class instances, using their constructors. </p>
<p>For example, let's revisit the <kbd>Emp</kbd> data class and its decompiled version from a previous section:</p>
<pre>record Emp(String name, int age) { }<br/><br/>final class Emp extends java.lang.DataClass { 
    final String name; 
    final int age; 
 
    public Emp(String name, int age) { 
        this.name = name; 
        this.age = age; 
    } 
 
    // deconstructor 
    // public accessor methods 
    // default implementation of equals, hashCode, and toString 
} <br/><br/></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Abstract and non-abstract data classes</h1>
                </header>
            
            <article>
                
<p>Data classes can be abstract or non-abstract. An abstract data class is defined by using the keyword <kbd>abstract</kbd> in its declaration. As an abstract class, you can't use abstract data classes directly. Here's an example of an abstract data class, <kbd>JVMLanguage</kbd>, and a non-abstract data class, <kbd>Conference</kbd>:</p>
<pre><strong>abstract</strong> record JVMLanguage(String name, int year); 
record Conference(String name, String venue, DateTime when); </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Data classes and inheritance</h1>
                </header>
            
            <article>
                
<p>Currently, the proposal is to drop the following inheritance cases:</p>
<ul>
<li>A data class extends a regular class</li>
<li>A regular class extends a data class</li>
<li>A data class extends another data class</li>
</ul>
<p>Allowing for any of the preceding cases would violate the contract of a data class being a carrier of data. At present, the following restrictions are proposed for data classes and inheritance, with interfaces and abstract data classes:</p>
<ul>
<li>Non-abstract and abstract data classes can extend other abstract data classes</li>
<li>An abstract or non-abstract data class can extend any interface</li>
</ul>
<p>The following figure sums up these inheritance rules:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/068c5647-5d02-4461-907a-d2f6da929031.png"/></p>
<p>Let's get started by extending an abstract data class.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Extending an abstract data class</h1>
                </header>
            
            <article>
                
<p>In the following example, the <kbd>Emp</kbd> <span>abstract data class </span>is being extended by the non-abstract <kbd>Manager</kbd> <span>data class: </span></p>
<pre>abstract record Emp(String name, int age); 
record Manager(String name, int age, String country) extends Emp(name, age); </pre>
<p>When a non-abstract data class extends an abstract data class, it accepts all of the data in its header—the ones that are required for itself, and for its base class.</p>
<div class="packt_infobox">A data class can extend a single abstract data class.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementing interfaces</h1>
                </header>
            
            <article>
                
<p>A data class can implement an interface and its abstract methods, or just inherit its default methods. The following is an example:</p>
<pre>interface Organizer {} 
interface Speaker { 
   abstract void conferenceTalk(); 
} 
 
abstract record Emp(String name, int age); 
 
record Manager(String name, int age, String country)  
   extends Emp(name, age)                    // subclass a record
   implements Organizer;                     // implement one interface
 
record Programmer(String name, int age, String programmingLang)  
   extends Emp(name, age)                    // subclass a record
   implements Organizer, Speaker {           // implementing multiple <br/>                                             // interfaces
        public void conferenceTalk() {       // implement abstract <br/>                                             // method
            //.. code                        // from interface Speaker
        } 
    };</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>
<p>The preceding code defines a tagging interface, <kbd>Organizer</kbd> (without any methods), and an interface, <kbd>Speaker</kbd>, with an abstract method, <kbd>conferenceTalk()</kbd>. We have two cases, as follows:</p>
<ul>
<li>A data class extending another data class, implementing an interface—the data class <kbd>Manager</kbd> extends the abstract <kbd>Emp</kbd> <span>data class </span>and implements the <kbd>Organizer</kbd> <span>interface. </span></li>
<li>A data class extending another data class and implementing multiple interfaces—the <kbd>Programmer</kbd>  data class extends the abstract <kbd>Emp</kbd> data class and implements two interfaces—<kbd>Organizer</kbd> and <kbd>Speaker</kbd>. The <kbd>Programmer</kbd> data class must implement the abstract <span><kbd>conferenceTalk()</kbd> method from the <kbd>Speaker</kbd> interface  to qualify as a non-abstract data class.</span></li>
</ul>
<div class="packt_infobox">A data class can implement a single or multiple interfaces.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Additional variables</h1>
                </header>
            
            <article>
                
<p>Although it is allowed, before adding variables or fields to a data class, ask yourself, <em>Are the fields derived from the state?</em> Fields that are not derived from the state pose a serious violation of the initial concept of the data classes. The following code is an example that defines an additional field, <kbd>style</kbd>, derived from the state of the <kbd>Emp</kbd> data class: </p>
<pre>record Emp(String name, int age) { 
    private String style; 
    Emp(String name, int age) { 
        //.. initialize name and age 
        if (age =&gt; 15 &amp;&amp; age =&lt; 30) style = "COOL"; 
        else if (age &gt;= 31 &amp;&amp; age &lt;= 50) style = "SAFE"; 
        else if (age &gt;= 51) style = "ELEGANT"; 
    } 
    public String getStyle() { 
        return style; 
    } 
}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>
<p>The preceding code works well because the state of the <kbd>Emp</kbd> data class is still derived from its state (the <kbd>name</kbd> and <kbd>age</kbd> fields). The <kbd>getStyle</kbd> method doesn't interfere with the state of <kbd>Emp</kbd>; it is purely an implementation detail.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Overriding implicit behaviors</h1>
                </header>
            
            <article>
                
<p>Suppose that you want to limit the values that can be passed to a field in your data class during its instantiation. This is feasible; just override the default constructor. The following is an example:</p>
<pre>record Emp(String name, int age) { 
    // override default constructor 
    @Override 
    public Emp(String name, int age) { 
        // validate age 
        if (age &gt; 70) 
            throw new IllegalArgumentException("Not employable above 70             <br/>            years"); 
        else { 
            // call default constructor 
            default.this(name, age); 
        } 
    } 
} </pre>
<p>Similarly, you can override the default implementations of object methods, such as <kbd>equals()</kbd>, <kbd>hashCode()</kbd>, and <kbd>toString()</kbd>, and other methods, such as the accessor methods.</p>
<p>Overriding the default behaviors of the methods of your data class doesn't defeat the purpose of their creation. They are still working as data classes, with finer control of their functionality. Let's compare this with POJOs, which were used to model data classes previously. The compiler doesn't auto-generate any methods for a POJO. So, a user still needs to read all of the code, looking for code that isn't the default implementation of its methods. In the case of data classes, this overridden behavior is very explicit. So, a user doesn't have to worry about reading all of the code; they can assume default implementation of the behavior, which hasn't been overridden by the developer.</p>
<div class="packt_infobox">Overriding behavior explicitly states the places where a data class diverts from its default behavior, reducing the amount of code that must be read by a user to understand its behavior.</div>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Additional methods and constructors</h1>
                </header>
            
            <article>
                
<p>The compiler generates a default constructor for a data class, along with accessor methods and the default implementation of the methods from the object class. A developer can overload the constructors and add more methods to a data class, as follows:</p>
<pre>record Emp(String name, int age) { 
    // overloading constructor 
    public Emp(String name, String style) { 
            this.name = name; 
            if (style.equals("COOL") age = 20; 
            else if (style.equals("SAFE") age = 30; 
            else if (style.equals("ELEGANT") age = 50; 
            else age = 70; 
        } 
    } 
    public String fancyOutput() {                 // additional method 
        return "My style is COOL"; 
    } 
} </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Mutability</h1>
                </header>
            
            <article>
                
<p>Concerning whether the data classes should be designated as mutable or immutable, work is still in progress. Both options have advantages and disadvantages. Immutable data works well in multithreaded, parallel, or concurrent systems. On the other hand, mutable data works well with cases that require frequent modifications to data. </p>
<div class="packt_infobox">Concerning thread safety, since the data classes are not yet designated to be immutable, it is the responsibility of the developers to use them in thread-safe configurations.</div>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we covered the challenges of using POJOs to model data. We covered how data classes provide a simple and concise way to model data. Implementation of data classes will include language changes, with the introduction of the <kbd>record</kbd> <span>keyword.</span> The main goal of using data classes is to model data as data, not to reduce the boilerplate code.</p>
<p class="mce-root">We also covered the aggregate and exploded forms of data classes. The data classes can be used with other language constructs, such as <kbd>switch</kbd>. By default, the data classes are not mutable, including the arrays defined as the data members. Since these structures are not immutable, a developer must include code to ensure thread safety when working with them.</p>
<p class="mce-root">In the next chapter, you'll learn more about an exciting language enhancement—raw string literals. Does this mean a pure, or untouched, string? Find out for yourself by reading on.</p>


            </article>

            
        </section>
    </body></html>