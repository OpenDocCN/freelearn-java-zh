- en: '*Chapter 2*: Where and How Does DDD Fit?'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: “We won’t be distracted by comparison if we are captivated with purpose.”
  prefs: []
  type: TYPE_NORMAL
- en: – Bob Goff
  prefs: []
  type: TYPE_NORMAL
- en: Software architecture refers to the fundamental structures of a software system
    and the discipline of creating such structures and systems. Over the years, we
    have accumulated a series of architecture styles and programming paradigms to
    help us deal with system complexity.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will examine how **Domain-Driven Design** (**DDD**) can
    be applied in a manner that is complementary to these architecture styles and
    programming paradigms. We will also look at how/where it fits in the overall scheme
    of things when crafting a software solution.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Architecture styles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Programming paradigms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Which paradigm should you choose?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have gained an appreciation of a variety
    of architecture styles and programming paradigms, along with some pitfalls to
    watch out for when applying them. You will also understand the role that DDD plays
    in augmenting each of these.
  prefs: []
  type: TYPE_NORMAL
- en: Architecture styles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Domain-driven design presents a set of architecture tenets in the form of strategic
    and tactical design elements. This enables you to decompose large, potentially
    unwieldy business subdomains into well-factored, independent bounded contexts.
  prefs: []
  type: TYPE_NORMAL
- en: One of the great advantages of DDD is that it does not require the use of any
    specific architecture. However, the software industry has been using a plethora
    of architecture styles over the last few years. Let’s look at how DDD can be used
    in conjunction with a set of popular architecture styles to arrive at better solutions.
  prefs: []
  type: TYPE_NORMAL
- en: Layered architecture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Layered architecture** is one of the most common architecture styles, where
    the solution is typically organized into four broad categories: **presentation**,
    **application**, **domain**, and **persistence**. Each of the layers provides
    a solution to a particular concern it represents, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.1 – The essence of layered architecture'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16716_Figure_2.1.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.1 – The essence of layered architecture
  prefs: []
  type: TYPE_NORMAL
- en: The main idea behind layered architecture is a separation of concerns – where
    the dependencies between layers are unidirectional (from top to bottom). For example,
    the domain layer can depend on the persistence layer, not the other way round.
    In addition, any given layer typically accesses the layer immediately beneath
    it without bypassing layers in between. For example, the presentation layer may
    access the domain layer only through the application layer.
  prefs: []
  type: TYPE_NORMAL
- en: 'This structure enables looser coupling between layers and allows them to evolve
    independently of each other. The idea of layered architecture fits very well with
    DDD’s tactical design elements, as depicted here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.2 – Layered architecture mapped to DDD’s tactical design elements'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16716_Figure_2.2.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.2 – Layered architecture mapped to DDD’s tactical design elements
  prefs: []
  type: TYPE_NORMAL
- en: DDD actively promotes the use of a layered architecture, primarily because it
    makes it possible to focus on the domain layer in isolation from other concerns,
    such as how information gets displayed, how end-to-end flows are managed, and
    how data is stored and retrieved. From that perspective, solutions that apply
    DDD naturally tend to be layered as well.
  prefs: []
  type: TYPE_NORMAL
- en: Notable variations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A variation of layered architecture was invented by Alistair Cockburn, which
    he originally called hexagonal architecture ([https://alistair.cockburn.us/hexagonal-architecture/](https://alistair.cockburn.us/hexagonal-architecture/)),
    alternatively called ports and adapters architecture. The idea behind this style
    was to avoid inadvertent dependencies between layers (which could occur in layered
    architecture), specifically between the core of a system and the peripheral layers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main idea here is to make use of interfaces (**ports**) exclusively within
    the core to enable modern drivers, such as testing and looser coupling. This allows
    the core to be developed and evolved independently of the non-core parts and the
    external dependencies. Integration with real-world components such as databases,
    filesystems, and web services is achieved through concrete implementations of
    the ports (**adapters**). The use of interfaces within the core enables much easier
    testing of the core in isolation from the rest of the system, using mocks and
    stubs. It is also common to use dependency injection frameworks to dynamically
    swap out implementations of these interfaces when working with a real system in
    an end-to-end environment. A visual representation of hexagonal architecture is
    shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.3 – Hexagonal architecture'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16716_Figure_2.3.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.3 – Hexagonal architecture
  prefs: []
  type: TYPE_NORMAL
- en: It turns out that the use of the term *hexagon* in this context was purely for
    visual purposes– not to limit the system to exactly six types of ports.
  prefs: []
  type: TYPE_NORMAL
- en: Similar to the hexagonal architecture, onion architecture ([https://jeffreypalermo.com/2008/07/the-onion-architecture-part-1/](https://jeffreypalermo.com/2008/07/the-onion-architecture-part-1/)),
    conceived by Jeffrey Palermo, is based on creating an application based on an
    independent object model within the core that can be compiled and run separately
    from the outer layers. This is done by defining interfaces (*ports* in hexagonal
    architecture) in the core and implementing them (*adapters* in hexagonal architecture)
    in the outer layers. From our perspective, the hexagonal and onion architecture
    styles have no perceptible differences that we could identify.
  prefs: []
  type: TYPE_NORMAL
- en: 'A visual representation of onion architecture is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.4 – Onion architecture'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16716_Figure_2.4.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.4 – Onion architecture
  prefs: []
  type: TYPE_NORMAL
- en: Yet another variation of layered architecture, popularized by Robert C. Martin
    (known endearingly as Uncle Bob), is clean architecture. This is based on adhering
    to the SOLID principles ([https://blog.cleancoder.com/uncle-bob/2020/10/18/Solid-Relevance.html](https://blog.cleancoder.com/uncle-bob/2020/10/18/Solid-Relevance.html)),
    also conceived by him. The fundamental message here (just like in the case of
    hexagonal and onion architecture) is to avoid dependencies between the core –
    the one that houses business logic – and other layers that tend to be volatile
    (such as frameworks, third-party libraries, UIs, and databases).
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.5 – Clean architecture'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16716_Figure_2.5.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.5 – Clean architecture
  prefs: []
  type: TYPE_NORMAL
- en: All these architecture styles are synergistic with DDD’s idea of developing
    a domain model for the core subdomain (and, by extension, its bounded context)
    independently of the rest of the system.
  prefs: []
  type: TYPE_NORMAL
- en: While each of these architecture styles provides additional guidance in terms
    of how to structure a layered architecture, any architecture approach we choose
    comes with its set of trade-offs and limitations you will need to be cognizant
    of. We will discuss some of these considerations in the next sub-sections.
  prefs: []
  type: TYPE_NORMAL
- en: The layer cake anti-pattern
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Sticking to a fixed set of layers provides a level of isolation, but in simpler
    cases, it may prove to be overkill without adding any perceptible benefit, other
    than adherence to the agreed-on architecture guidelines. In the layer cake anti-pattern,
    each layer merely proxies the call to the layer beneath it without adding any
    value. The following example illustrates this fairly common scenario:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.6 – An example of the layer cake anti-pattern to find an entity
    representation by ID'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16716_Figure_2.6.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.6 – An example of the layer cake anti-pattern to find an entity representation
    by ID
  prefs: []
  type: TYPE_NORMAL
- en: Here, the `findById` method is replicated in every layer and simply calls the
    method with the same name in the layer below, with no additional logic. This introduces
    a level of accidental complexity to the solution. Some amount of redundancy in
    the layering may be unavoidable for the purposes of standardization. It may be
    best to reexamine the layering guidelines if the *layer cake* occurs prominently
    in the code base.
  prefs: []
  type: TYPE_NORMAL
- en: Anemic translation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another variation of the layer cake we see commonly is one where layers refuse
    to share input and output types in the name of higher isolation and looser coupling.
    This makes it necessary to perform translations at the boundary of each layer.
    If the objects being translated are more or less structurally identical, we have
    an `findById` example we discussed previously.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.7 – An example of the anemic translation anti-pattern'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16716_Figure_2.7.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.7 – An example of the anemic translation anti-pattern
  prefs: []
  type: TYPE_NORMAL
- en: In this case, each layer defines an `Entity` type of its own, requiring a translation
    between types at each layer. To make matters worse, the structure of the `Entity`
    type may have seemingly minor variations (for example, `lastName` being referred
    to as `surname`). While such translations may be necessary across bounded contexts,
    teams should strive to avoid the need for variations in names and structures of
    the same concept within a single bounded context. The intentional use of *ubiquitous
    language* helps avoid such scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Layer bypass
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When working with a layered architecture, it is reasonable to start by being
    strict about layers only interacting with the layers immediately beneath them.
    As we saw earlier, such rigid enforcements may lead to an intolerable degree of
    accidental complexity, especially when applied generically to a large number of
    use cases. In such scenarios, it may be worth considering consciously allowing
    one or more layers to be bypassed.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the `controller` layer may be allowed to work directly with the
    `repository` without using the `service` layer. In many cases, we have found it
    useful to use a separate set of rules for *commands* versus *queries* as a starting
    point.
  prefs: []
  type: TYPE_NORMAL
- en: 'This can be a slippery slope. To continue maintaining a level of sanity, teams
    should consider the use of a lightweight architecture governance tool such as
    **ArchUnit** ([https://www.archunit.org/](https://www.archunit.org/)) to make
    agreements explicit and provide quick feedback. A simple example of how to use
    ArchUnit for this purpose is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ch2-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The `Repository` layer can be accessed by both the Services and Controllers
    layers – effectively allowing Controllers to bypass the use of the Services layer.
  prefs: []
  type: TYPE_NORMAL
- en: Vertical slice architecture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Layered architecture and its variants provide reasonably good guidance on how
    to structure complex applications. Vertical slice architecture, championed by
    Jimmy Boggard, recognizes that it may be too rigid to adopt a standard layering
    strategy for all use cases across an entire application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Furthermore, it is important to note that business value cannot be derived
    by implementing any of these horizontal layers in isolation. Doing so will only
    result in unusable inventory and lots of unnecessary context switching until all
    these layers are connected. Therefore, vertical slice architecture proposes minimizing
    coupling between slices and maximizing coupling in a slice ([https://jimmybogard.com/vertical-slice-architecture/](https://jimmybogard.com/vertical-slice-architecture/)),
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.8 – Vertical slice architecture'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16716_Figure_2.8.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.8 – Vertical slice architecture
  prefs: []
  type: TYPE_NORMAL
- en: In this example, **Place Order** might require us to coordinate with other components
    through the application layer and apply complex business invariants, while operating
    within the purview of an ACID transaction. Similarly, **Cancel Order** might require
    applying business invariants within an ACID transaction without any additional
    coordination – obviating the need for the application layer, in this case. However,
    **Search O****rders** might require us to simply fetch existing data from a query-optimized
    view. This style makes use of a horses-for-courses approach to layering that may
    help alleviate some anti-patterns listed previously when implementing a plain
    vanilla layered architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Considerations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Vertical slice architecture affords a lot of flexibility when implementing a
    solution – taking into consideration the specific needs of the use case being
    implemented. However, without some level of governance, this may quickly devolve
    into a big ball of mud, with layering decisions being made seemingly arbitrarily,
    based on personal preferences and experiences (or lack thereof). As a sensible
    default, you may want to consider using a distinct layering strategy for commands
    and queries. Beyond that, non-functional requirements may dictate how you may
    need to deviate from here. For example, you may need to bypass layers to meet
    performance SLAs for certain use cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'When used pragmatically, vertical slice architecture does enable you to apply
    DDD very effectively within each or a group of related vertical slices – allowing
    them to be treated as bounded contexts. Two possibilities using the place order
    and cancel order examples are shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.9 – Vertical slices used to evolve bounded contexts'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16716_Figure_2.9.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.9 – Vertical slices used to evolve bounded contexts
  prefs: []
  type: TYPE_NORMAL
- en: In the **(i)** example in the preceding diagram, place order and cancel order
    each use a distinct domain model, whereas in the **(ii)** example, both use cases
    share a common domain model and, by extension, become part of the same bounded
    context. This does pave the way to slice functionality when looking to adopt the
    serverless architecture along use case boundaries.
  prefs: []
  type: TYPE_NORMAL
- en: Service-oriented architecture (SOA)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Service-Oriented Architecture** (**SOA**) is an architecture style where
    software components expose (potentially) reusable functionality over standardized
    interfaces. The use of standardized interfaces (such as SOAP, REST, and gRPC,
    to name a few) enables easier interoperability when integrating heterogeneous
    solutions, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.10 – SOA – exposing reusable functionality over standard interfaces'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16716_Figure_2.10.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.10 – SOA – exposing reusable functionality over standard interfaces
  prefs: []
  type: TYPE_NORMAL
- en: Previously, the use of non-standard, proprietary interfaces made this kind of
    integration a lot more challenging. For example, a retail bank may expose inter-account
    transfer functionality in the form of SOAP web services. While SOA prescribes
    exposing functionality over standardized interfaces, the focus is more on integrating
    heterogeneous applications than implementing them.
  prefs: []
  type: TYPE_NORMAL
- en: Considerations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At one of the banks we worked at, we exposed a set of over 500 service interfaces
    over SOAP. Under the hood, we implemented these services using EJB 2.x (a combination
    of stateless session beans and message-driven beans), hosted on a commercial J2EE
    application server, which also did double duty as an **Enterprise Service Bus**
    (**ESB**). These services delegated most, if not all, of the logic to a set of
    underlying stored procedures within a single monolithic Oracle database, using
    a canonical data model for the entire enterprise! To the outside world, these
    services were *location-transparent*, stateless, *composable*, and *discoverable*.
    Indeed, we advertised this implementation as an example of SOA, and it would be
    hard to argue that it was not.
  prefs: []
  type: TYPE_NORMAL
- en: This suite of services had evolved organically over the years, with no explicit
    boundaries, concepts from various parts of the organization, and generations of
    people mixed in, each adding their own interpretation of how business functionality
    needed to be implemented. In essence, the implementation resembled the dreaded
    big ball of mud, which was extremely hard to enhance and maintain.
  prefs: []
  type: TYPE_NORMAL
- en: The intentions behind SOA are noble. However, the promises of *reuse* and *loose
    coupling* are hard to achieve in practice, given the lack of concrete implementation
    guidance on component granularity. It is also true that SOA means many things
    ([https://martinfowler.com/bliki/ServiceOrientedAmbiguity.html](https://martinfowler.com/bliki/ServiceOrientedAmbiguity.html))
    to different people. This ambiguity leads to most SOA implementations becoming
    complex, unmaintainable monoliths, centered around technology components such
    as a service bus, a persistence store, or both. This is where using DDD to solve
    a complex problem by breaking it down into subdomains and bounded contexts can
    be invaluable.
  prefs: []
  type: TYPE_NORMAL
- en: Microservices architecture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the last decade or so, microservices have gained quite a lot of popularity,
    with lots of organizations wanting to adopt this style of architecture. In a lot
    of ways, microservices are an extension of SOA – one where much emphasis is placed
    on creating focused components that deal with doing a limited number of things
    and doing them right. Sam Newman, the author of the *Building Microservices* book,
    defines microservices as *small-sized*, independently deployable components that
    maintain their own state and are *modeled around a business domain*. This affords
    benefits such as adopting a horses-for-courses approach when modeling solutions,
    limiting the blast radius, improved productivity and speed, autonomous cross-functional
    teams, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Microservices usually exist as a collective, working collaboratively to achieve
    desired business outcomes, as depicted here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.11 – A microservices ecosystem'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16716_Figure_2.11.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.11 – A microservices ecosystem
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, SOA and microservices are very similar from the perspective of
    the consumers, in that they access functionality through a set of standardized
    interfaces. The microservices approach is an evolution of SOA in that the focus
    now is on building smaller, self-sufficient, independently deployable components
    with the intent of avoiding single points of failure (such as an enterprise database
    or service bus), which was fairly common with a number of SOA-based implementations.
  prefs: []
  type: TYPE_NORMAL
- en: Considerations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While microservices have definitely helped, there still exists quite a lot of
    ambiguity when it comes to answering how big or small a microservice should be
    ([https://martinfowler.com/articles/microservices.html#HowBigIsAMicroservice](https://martinfowler.com/articles/microservices.html#HowBigIsAMicroservice)).
    Indeed, a lot of teams seem to struggle to get this balance right, resulting in
    a distributed monolith ([https://www.infoq.com/news/2016/02/services-distributed-monolith/](https://www.infoq.com/news/2016/02/services-distributed-monolith/)),
    which, in a lot of ways, can be much worse than even a single-process monolith
    from the SOA days. Again, applying the strategic design concepts of DDD can help
    create independent, loosely coupled components, making it an ideal companion for
    the microservices style of architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Event-driven architecture (EDA)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Irrespective of the granularity of components (monolith, microservices, or
    something in between), most non-trivial solutions have a boundary, beyond which
    there may be a need to communicate with external system(s). This communication
    usually happens through the exchange of messages between systems, causing them
    to become coupled with each other. Coupling comes in two broad flavors: *afferent*
    – who depends on you, and *efferent* – who you depend on. Excessive amounts of
    efferent coupling can make systems very brittle and hard to work with.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Event-driven systems enable authoring solutions that have a relatively low
    amount of efferent coupling by emitting events when they attain a certain state,
    without caring about who consumes those events. In this regard, it is important
    to differentiate between message-driven and event-driven systems, as mentioned
    in the *Reactive Manifesto*:'
  prefs: []
  type: TYPE_NORMAL
- en: “A message is an item of data that is sent to a specific destination. An event
    is a signal emitted by a component upon reaching a given state. In a message-driven
    system addressable recipients await the arrival of messages and react to them,
    otherwise lying dormant. In an event-driven system notification listeners are
    attached to the sources of events such that they are invoked when the event is
    emitted. This means that an event-driven system focuses on addressable event sources
    while a message-driven system concentrates on addressable recipients.”
  prefs: []
  type: TYPE_NORMAL
- en: – The Reactive Manifesto
  prefs: []
  type: TYPE_NORMAL
- en: In simpler terms, event-driven systems do not care who the downstream consumers
    are, whereas in a message-driven system, that may not necessarily be true. When
    we say event-driven in the context of this book, we mean the former.
  prefs: []
  type: TYPE_NORMAL
- en: Typically, event-driven systems eliminate the need for point-to-point messaging
    with the ultimate consumers by making use of an intermediary infrastructure component,
    usually known as a message broker, event bus, and so on. This effectively reduces
    efferent coupling from *n* consumers to 1\. There are a few variations on how
    event-driven systems can be implemented. In the context of publishing events,
    Martin Fowler talks about two broad styles (among other things), event notifications
    and event-carried state transfer, in his *What do you mean by “Event-Driven”?*
    article ([https://martinfowler.com/articles/201701-event-driven.html](https://martinfowler.com/articles/201701-event-driven.html)).
  prefs: []
  type: TYPE_NORMAL
- en: Considerations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of the main trade-offs when building an event-driven system is to decide
    the amount of state (payload) that should be embedded in each event. It may be
    prudent to consider embedding just enough state to indicate changes that occurred
    as a result of the emitted event to keep the various opposing forces, such as
    producer scaling, encapsulation, consumer complexity, and resiliency. We will
    discuss the related implications in more detail when we cover implementing events
    in [*Chapter 5*](B16716_05_Final_NM_ePub.xhtml#_idTextAnchor077), *Implementing
    Domain Logic*.
  prefs: []
  type: TYPE_NORMAL
- en: DDD is all about keeping complexity in check by creating these independent bounded
    contexts. However, *independent* does not mean *isolated*. Bounded contexts may
    still need to communicate with each other. One way to do that is through the use
    of a fundamental DDD building block – domain events. Event-driven architecture
    and DDD are thus complementary. It is typical to make use of an event-driven architecture
    to allow bounded contexts to communicate while continuing to loosely couple with
    each other.
  prefs: []
  type: TYPE_NORMAL
- en: Command Query Responsibility Segregation (CQRS)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In traditional applications, a single-domain, data/persistence model is used
    to handle all kinds of operations. With CQRS, we create distinct models to handle
    updates (commands) and inquiries. This is depicted in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.12 – Traditional versus CQRS architecture'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16716_Figure_2.12.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.12 – Traditional versus CQRS architecture
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: We depict multiple query models in the previous diagram because it is possible
    (but not necessary) to create more than one query model, depending on the kinds
    of query use cases that need to be supported.
  prefs: []
  type: TYPE_NORMAL
- en: For this to work predictably, the query model(s) need to be kept in sync with
    the write models (we will examine some of the techniques to do that in detail
    later).
  prefs: []
  type: TYPE_NORMAL
- en: Considerations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A traditional, single-model approach works well for simple, CRUD-style applications
    but starts to become unwieldy for more complex scenarios. We will discuss some
    of these scenarios in the next subsections.
  prefs: []
  type: TYPE_NORMAL
- en: Volume imbalance between reads and writes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In most systems, read operations often outnumber write operations by significant
    orders of magnitude. For example, consider the number of times a trader checks
    stock prices versus the number of times they actually transact (buy or sell stock
    trades). It is also usually true that write operations are the ones that make
    businesses money. Having a single model for both reads and writes in a system
    with a majority of read operations can overwhelm a system to an extent where write
    performance can become affected.
  prefs: []
  type: TYPE_NORMAL
- en: A need for multiple read representations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When working with relatively complex systems, it is not uncommon to require
    more than one representation of the same data. For example, when looking at personal
    health data, you may want to look at a daily, weekly, or monthly view. While these
    views can be computed on the fly from the *raw* data, each transformation (aggregation,
    summarization, and so on) adds to the cognitive load on a system. Often, it is
    not possible to predict ahead of time the nature of these requirements. By extension,
    it is not feasible to design a single canonical model that can provide answers
    to all these requirements. Creating domain models specifically designed to meet
    a focused set of requirements can be much easier.
  prefs: []
  type: TYPE_NORMAL
- en: Different security requirements
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Managing the authorization of and access requirements to data/APIs when working
    with a single model can start to become cumbersome. For example, higher levels
    of security may be desirable for debit operations in comparison to balance enquiries.
    Having distinct models can considerably ease the complexity of designing fine-grained
    authorization controls.
  prefs: []
  type: TYPE_NORMAL
- en: More uniform distribution of complexity
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Having a model dedicated to serving only command-side use cases means that they
    can now be focused toward solving a single concern. For query-side use cases,
    we create models as needed that are distinct from the command-side model. This
    helps spread complexity more uniformly over a larger surface area – as opposed
    to increasing the complexity on a single model that is used to serve all use cases.
    It is worth noting that the essence of DDD is mainly to work effectively with
    complex software systems, and CQRS fits well with this line of thinking.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: When working with a CQRS-based architecture, choosing the persistence mechanism
    for the command side is a key decision. When working in conjunction with event-driven
    architecture, you could choose to persist aggregates as a series of events (ordered
    in the sequence of their occurrence). This style of persistence is known as event
    sourcing. We will cover this in more detail in [*Chapter 5*](B16716_05_Final_NM_ePub.xhtml#_idTextAnchor077),
    *Implementing Domain Logic*, in the *Event-sourced aggregates* section.
  prefs: []
  type: TYPE_NORMAL
- en: Serverless architecture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Serverless architecture is an approach to software design that allows developers
    to build and run services without having to manage the underlying infrastructure.
    The advent of the AWS Lambda service has popularized this style of architecture,
    although several other services (such as S3 and DynamoDB for persistence, SNS
    for notifications, and SQS for message queuing) existed long before Lambda was
    launched. While AWS Lambda provides a compute solution in the form of **Functions
    as a Service** (**FaaS**), these other services are just as essential, if not
    more, in order to benefit from a serverless paradigm.
  prefs: []
  type: TYPE_NORMAL
- en: In conventional DDD, bounded contexts are formed by grouping related operations
    around an aggregate, which then informs how the solution is deployed as a unit
    – usually within the confines of a single process. With a serverless paradigm,
    each operation (task) is expected to be deployed as an independent unit of its
    own. This requires that we look at how we model aggregates and bounded contexts
    differently – now centered around individual tasks or functions, as opposed to
    a group of related tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Does that mean that the principles of DDD to arrive at a solution do not apply
    anymore? While a serverless paradigm introduces an additional dimension of having
    to treat fine-grained deployable units as first-class citizens in the modeling
    process, the overall process of applying DDD’s strategic and tactical design continues
    to apply. We will examine this in more detail in [*Chapter 11*](B16716_11_Final_NM_ePub.xhtml#_idTextAnchor164),
    *Decomposing into Finer-Grained Components*, when we will refactor the solution
    we build throughout this book to employ a serverless approach.
  prefs: []
  type: TYPE_NORMAL
- en: The big ball of mud
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Thus far, we have examined a catalog of named architecture styles along with
    their pitfalls and how applying DDD can help alleviate them. At the other extreme,
    we may encounter solutions that lack a perceivable architecture, infamously known
    as the *big ball of mud*:'
  prefs: []
  type: TYPE_NORMAL
- en: “A BIG BALL OF MUD is haphazardly structured, sprawling, sloppy, duct-tape and
    baling wire, spaghetti code jungle. We’ve all seen them. These systems show unmistakable
    signs of unregulated growth, and repeated, expedient repair. Information is shared
    promiscuously among distant elements of the system, often to the point where nearly
    all the important information becomes global or duplicated. The overall structure
    of the system may never have been well-defined. If it was, it may have eroded
    beyond recognition. Programmers with a shred of architectural sensibility shun
    these quagmires. Only those who are unconcerned about architecture, and, perhaps,
    are comfortable with the inertia of the day-to-day chore of patching the holes
    in these failing dikes, are content to work on such systems.”
  prefs: []
  type: TYPE_NORMAL
- en: – Brian Foote and Joseph Yoder
  prefs: []
  type: TYPE_NORMAL
- en: Although Foote and Yoder advise avoiding this style of architecture at all costs,
    software systems that resemble the big ball of mud continue to be a day-to-day
    inevitability for a lot of us. The strategic and tactical design elements of DDD
    provide a set of techniques to help deal with and recover from these near-hopeless
    situations in a pragmatic manner, without potentially having to adopt a big bang
    approach. Indeed, the focus of this book is to apply these principles to prevent
    or at least delay further devolution toward the big ball of mud.
  prefs: []
  type: TYPE_NORMAL
- en: Which architecture style should you use?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we have seen, there are a variety of architecture styles you can lean on
    when crafting a software solution. A lot of these architecture styles share quite
    a few common tenets. It can become difficult to conform to any single architecture
    style. DDD, with its emphasis on breaking down complex business problems into
    subdomains and bounded contexts, enables the use of more than one approach across
    bounded contexts. We would like to make a special mention of vertical slice architecture
    because it places an emphasis on dividing functionality into specific business
    outcomes and, thus, more naturally adheres to DDD’s ideas of subdomains and bounded
    contexts. In reality, you may find the need to extend and even deviate from pedantic
    definitions of architecture styles in order to meet real-world needs. But when
    we do make such compromises, it is important to do so *intentionally* and make
    it unambiguously clear why we are making such a decision (preferably using some
    lightweight mechanism, such as **ADRs** ([https://www.thoughtworks.com/de-de/radar/techniques/lightweight-architecture-decision-records](https://www.thoughtworks.com/de-de/radar/techniques/lightweight-architecture-decision-records)).
    This is important because it may become hard to justify this to others and even
    ourselves when we look at it in the future.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have examined popular architecture styles and how we can
    amplify their effectiveness when used in conjunction with DDD. Now, let’s look
    at how DDD can complement the use of existing programming paradigms.
  prefs: []
  type: TYPE_NORMAL
- en: Programming paradigms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The tactical elements of DDD introduce a specific vocabulary (aggregates, entities,
    value objects, repositories, services, factories, domain events, and so on) when
    arriving at a solution. At the end of the day, we need to translate these concepts
    into running software. Over the years, we have employed a variety of programming
    paradigms, including procedural, object-oriented, functional, and aspect-oriented.
    Is it possible to apply DDD in conjunction with one or more of these paradigms?
    In this section, we will explore how some common programming paradigms and techniques
    help us express tactical design elements in code.
  prefs: []
  type: TYPE_NORMAL
- en: Object-oriented programming
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'On the surface of it, DDD seems to simply replicate a set of OO terms and call
    them by different names. For example, the central concepts of tactical DDD such
    as aggregates, entities, and value objects could simply be referred to as objects
    in OO terms. Others such as services may not have a direct OO analog. So, how
    do you apply DDD in an OO world? Let’s look at a simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ch2-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'OO purists will be quick to point out that `PasswordService` is procedural
    and that a `Password` class might be needed to encapsulate related behaviors.
    Similarly, DDD enthusiasts might point out that this is an anemic domain model
    implementation. An arguably better OO version might look something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ch2-3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this case, the `Password` class stops exposing its internals and exposes
    the idea of a strong or weak password in the form of behavior (the `isStrong`
    and `isWeak` methods). From an OO perspective, the second implementation is arguably
    superior. If so, shouldn’t we be using the OO version at all times? As it turns
    out, the answer is nuanced and depends on what consumers desire and the ubiquitous
    language used in that context. If the concept of `Password` is in common usage
    within the domain, it perhaps warrants introducing such a concept in the implementation
    as well. If not, the first solution might suffice, even though it seems to violate
    OO principles of encapsulation.
  prefs: []
  type: TYPE_NORMAL
- en: Our default position is to apply good OO practices as a starting point. However,
    it is more important to mirror the language of the domain as opposed to applying
    OO in a dogmatic manner. So, we will be willing to compromise on OO purity if
    it appears unnatural to do so in that context. As mentioned earlier, clearly communicating
    the rationale for such decisions can go a long way.
  prefs: []
  type: TYPE_NORMAL
- en: Functional programming
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Functions are a fundamental building block to code organization that exists
    in all higher-order programming languages. Functional programming is a programming
    paradigm where programs are constructed by applying and composing functions. This
    is in contrast to imperative programming, which uses statements to change a program’s
    state. The most significant differences stem from the fact that functional programming
    avoids side effects, which are common in imperative programming. Pure functional
    programming completely prevents side effects and forces immutability. Embracing
    a functional style when designing a domain model to be more declarative expresses
    intent a lot more clearly while remaining terse. It also allows us to keep the
    complexity in check by enabling us to compose more complex concepts by using simpler
    ones. The functional implementation allows us to use a language closer to the
    problem domain, while having the added benefit of also being terse. Consider a
    simple example where we need to find the item with the least inventory across
    all our warehouses using a functional style, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ch2-4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The imperative style shown here does get the job done but is arguably a lot
    more verbose and harder to follow, sometimes even for technical team members!
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an imperative example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ch2-5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'From a DDD perspective, this yields a few benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Increased collaboration with domain experts** because the declarative style
    allows placing a bigger focus on the what, rather than the how. This makes it
    a lot less intimidating to technical and non-technical stakeholders alike to work
    with on an ongoing basis.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Better testability** because the use of pure functions (those that are side-effect-free)
    makes it easier to create data-driven tests. This has also afforded us an additional
    benefit of less mocking/stubbing. These characteristics make tests that are a
    lot easier to maintain and rationalize. This has the benefit of allowing even
    technical team members to visualize corner cases a lot earlier in the process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Which paradigm should you choose?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: DDD simply states that you should build your software around a domain model
    that represents the actual problem that the software is trying to solve. When
    encountering complex real-life problems, we often find it hard to conform to any
    single paradigm across the board. Looking to use a one-size-fits-all approach
    may work to our detriment. Our experience indicates that we will need to make
    use of a variety of techniques in order to solve the problem at hand elegantly.
    Java is inherently an OO language, but with the advent of Java 8, it has started
    to embrace a variety of functional constructs as well. This allows us to make
    use of a multitude of techniques to create elegant solutions. The most important
    thing is to agree on a ubiquitous language and allow it to guide the approach
    taken. It also largely depends on the talent and experience you have at your disposal.
    Making use of a style that is foreign to the majority of a team will likely prove
    counterproductive. Although we haven’t covered the procedural paradigm here in
    this chapter, there may be occasions where it might be the best solution given
    the current situation. As long as we are intentional about areas where we deviate
    from the accepted norm for a particular programming paradigm, we should be in
    a reasonably good place.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered a series of commonly used architecture patterns
    and how we can practice DDD when working with them. We also looked at common pitfalls
    and gotchas that we may need to be cognizant of when using these architectures.
    We also looked at popular programming paradigms and their influence on the tactical
    elements of DDD.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, you should have an appreciation of the various architecture styles
    that you need to employ when coming up with a solution. In addition, you should
    have an understanding of how DDD can play a role, no matter which style of architecture
    you choose to adopt.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will look to apply all we have learned in this and previous
    chapters to a real-world business use case. We will apply both the strategic and
    tactical patterns of DDD to break a complex domain into subdomains and bounded
    contexts and iteratively build a solution, using technologies that are based on
    the Java programming language.
  prefs: []
  type: TYPE_NORMAL
