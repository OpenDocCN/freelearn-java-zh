- en: 'Chapter 13: Exploring the Software Life Cycle'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第13章：探索软件生命周期
- en: In previous chapters, we explored many different aspects of Java application
    development. Starting from the **Software Development Life Cycle** (**SDLC**),
    which includes requirements collection and architecture design, we focused on
    many different technological aspects, including frameworks and middleware.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们探讨了Java应用程序开发的许多不同方面。从包括需求收集和架构设计在内的**软件开发生命周期**（**SDLC**）开始，我们关注了许多不同的技术方面，包括框架和中间件。
- en: At this point, several cross-cutting concerns need to be looked at, regardless
    of the kind of application we are building and the architectural style we choose.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们需要关注几个横切关注点，无论我们正在构建什么类型的应用程序以及我们选择什么架构风格。
- en: In this chapter, we are going to explore such aspects. We will start with things
    such as the maintenance of source code (including versioning and branching strategies),
    ranging through to some core topics related to deploying, **Continuous Integration/Continuous
    Delivery** (**CI/CD**), and other concepts related to the SDLC in its entirety.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨这些方面。我们将从诸如源代码维护（包括版本控制和分支策略）等问题开始，一直扩展到与整个SDLC相关的核心主题，如部署、**持续集成/持续交付**（**CI/CD**）以及其他相关概念。
- en: 'In this chapter, these are the topics we are going to cover:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Source Code Management
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 源代码管理
- en: Testing
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试
- en: Deploying
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署
- en: Continuous integration/continuous delivery (and deployment)
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持续集成/持续交付（及部署）
- en: Releasing
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发布
- en: Maintenance
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 维护
- en: I'm almost sure that in your professional life, you will already have had the
    opportunity to become familiar with these topics. Indeed, these are often taken
    for granted.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我几乎可以肯定，在你的职业生涯中，你已经有机会熟悉这些主题。实际上，这些通常被视为理所当然。
- en: Nevertheless, by the end of this chapter, you will have a complete view of the
    entire process, which will be really useful in structuring and maintaining a functional
    and efficient software toolchain.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在本章结束时，你将全面了解整个流程，这对于构建和维护一个功能强大且高效的软件工具链将非常有用。
- en: Now, let's start with **Source Code Management** (**SCM**).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们从**源代码管理**（**SCM**）开始。
- en: Technical requirements
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'You can find the source code used in this chapter here: [https://github.com/PacktPublishing/Hands-On-Software-Architecture-with-Java/tree/master/Chapter13](https://github.com/PacktPublishing/Hands-On-Software-Architecture-with-Java/tree/master/Chapter13).'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到本章使用的源代码：[https://github.com/PacktPublishing/Hands-On-Software-Architecture-with-Java/tree/master/Chapter13](https://github.com/PacktPublishing/Hands-On-Software-Architecture-with-Java/tree/master/Chapter13)。
- en: Source Code Management
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 源代码管理
- en: SCM is a pretty basic concept and should be considered, of course, mandatory
    in any software project (including very small ones). Nowadays, SCM is synonymous
    with Git (more on that soon); however, many alternatives have been used over the
    years, including **Concurrent Versions System** (**CVS**) and Apache **Subversion**
    (**SVN**).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: SCM是一个相当基本的概念，当然，在任何软件项目中（包括非常小的项目）都应该被认为是强制性的。如今，SCM与Git同义（关于这一点，我们很快就会讨论更多）；然而，多年来已经使用了许多替代方案，包括**并发版本系统**（**CVS**）和Apache
    **Subversion**（**SVN**）。
- en: The basic function of SCM is backing up, sharing, and versioning source code.
    However, there are many nuances to these features. So, let's have a closer look
    at Git.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: SCM（源代码管理）的基本功能包括备份、共享和版本控制源代码。然而，这些功能有许多细微之处。因此，让我们更深入地了解一下Git。
- en: Introducing Git
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Git简介
- en: Git was created by Linus Torvalds, the creator of the Linux OS, as a tool for
    supporting the development of the OS itself.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Git是由Linux OS的创造者林纳斯·托瓦兹（Linus Torvalds）创建的，作为支持操作系统本身开发的工具。
- en: 'Apart from the history of the project, Git has many interesting characteristics
    that make it a de facto standard:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 除了项目历史之外，Git有许多有趣的特性使其成为事实上的标准：
- en: It is heavily decentralized. With Git, every developer can work with a local
    repository, benefitting the versioning of files, branching, and more features,
    even in the absence of a remote server (such as in a disconnected environment).
    This also makes it really scalable from a performance point of view.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它高度去中心化。使用Git，每个开发者都可以使用本地仓库进行工作，这有利于文件版本控制、分支以及其他功能，即使在没有远程服务器的情况下（例如在断开连接的环境中）。这也使得它在性能方面具有真正的可扩展性。
- en: With Git, every version is associated with a cryptographical hash ID. In this
    way, the history of files can be easily reconstructed, and it makes it hard to
    tamper with them.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Git，每个版本都与一个加密哈希 ID 相关联。这样，文件的历史可以很容易地重建，并且使得篡改它们变得困难。
- en: Git relies on well-known and frequently used protocols, such as HTTP, SSH, and
    FTP. This makes it easy to use in existing environments.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Git 依赖于众所周知且经常使用的协议，如 HTTP、SSH 和 FTP。这使得它在现有环境中易于使用。
- en: 'Git encompasses a lot of different commands and features; however, the basics
    for using it are as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Git 包含了许多不同的命令和功能；然而，使用它的基本方法如下：
- en: '`git init [local folder]`: This is the command used to initialize a new repository
    locally.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`git init [本地文件夹]`：这是用于在本地初始化新仓库的命令。'
- en: '`git clone [repository]`: This creates a local copy of an existing repository.
    In the case of an authenticated repository, there are many different ways of authenticating,
    including passing the username and password as part of the URL (using something
    such as git clone: `https://username:password@remote`). However, better options
    (such as using tokens) are advisable.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`git clone [仓库]`：这个命令创建现有仓库的本地副本。在认证仓库的情况下，有多种不同的认证方式，包括将用户名和密码作为 URL 的一部分传递（使用类似
    git clone: `https://username:password@remote` 的方式）。然而，建议使用更好的选项（如使用令牌）。'
- en: '`git add [files to be added]`: This adds a set of files to a staging area (which
    is basically an intermediate step before committing to a repository).'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`git add [要添加的文件]`：这个命令将一组文件添加到暂存区（这基本上是在提交到仓库之前的中间步骤）。'
- en: '`git commit -m [commit message]`: This commits the files from the staging area
    to a repository.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`git commit -m [提交信息]`：这个命令将暂存区的文件提交到仓库。'
- en: '`git branch [branch name]`: This creates a new branch. A **branch** (which
    is a concept common to many SCM systems) is a way of storing a set of implementations
    that can potentially have an impact on the rest of the system (such as a new major
    version) in an isolated area. Such developments can then be merged with the main
    developments.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`git branch [分支名]`：这个命令创建一个新的分支。**分支**（这是一个许多版本控制系统中常见的概念）是在一个隔离区域存储一组实现的方式，这些实现可能对整个系统（如新的大版本）产生影响。然后，这些发展可以与主要发展合并。'
- en: '`git tag [tag name]`: This creates a new tag. A **tag** is similar to a branch,
    but it''s basically immutable. It is commonly used to mark a specified important
    event in the code (such as a release) to make it easier to identify the situation
    of the code in that particular moment, and potentially rebuild it.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`git tag [标签名]`：这个命令创建一个新的标签。**标签**类似于分支，但它基本上是不可变的。它通常用于标记代码中的特定重要事件（如发布），以便更容易地识别在那个特定时刻的代码状态，并可能重新构建它。'
- en: '`git push [remote] [branch]`: This pushes the local changes to a remote repository
    on the specified branch.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`git push [远程] [分支]`：这个命令将本地更改推送到指定分支的远程仓库。'
- en: These Git commands and, in particular, the concept of branching and tagging
    are very powerful tools. How they are used has become more and more structured
    over time, creating some specified workflows. In the next sections, we'll see
    some ideas on this.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这些 Git 命令，尤其是分支和标签的概念，是非常强大的工具。随着时间的推移，它们的使用方式变得越来越结构化，形成了一些特定的工作流程。在接下来的章节中，我们将看到一些关于这方面的想法。
- en: Git Flow
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Git Flow
- en: Despite the name, **Git Flow** (and other similar techniques) is not a prerequisite
    of Git, and, in theory, could also be implemented with SCM tools, which are different
    from Git. However, it is common to implement this kind of technique together with
    Git.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管名字叫 Git Flow（以及其他类似的技术），但这并不是 Git 的先决条件，从理论上讲，也可以使用与 Git 不同的版本控制工具（SCM 工具）来实现。然而，通常与
    Git 一起实现这类技术。
- en: Git Flow is an articulated way of managing and storing developments, creating
    releases, and, in general, structuring the way the code is handled.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Git Flow 是一种管理和发展、创建发布以及总体上结构化代码处理方式的方法。
- en: Git Flow is based on a number of branches coexisting constantly and can be implemented
    manually or by using some tools created to support such a way of working.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Git Flow 基于多个分支持续共存，可以手动实现或使用一些创建来支持这种工作方式的工具。
- en: 'The core line where the code is stored is called the **Main** branch. The developers
    are not supposed to work directly on this branch. Instead, a **develop** (**Dev**)
    branch is created from it to store the work in progress. In order to work on a
    feature, each developer copies the **Dev** branch into a purposely created **Feature**
    branch, which is created to contain a specific feature. When a feature is completed,
    it''s merged back into the **Dev** branch. In theory, since just a few features
    are developed, the merge operation should not be too difficult (since not much
    code has changed). The following diagram illustrates this:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 存储代码的核心分支被称为**主**分支。开发者不应该直接在这个分支上工作。相反，从它创建一个**开发**（**Dev**）分支来存储正在进行的工作。为了工作在一个特性上，每个开发者将**Dev**分支复制到一个专门创建的**特性**分支，该分支用于包含特定的特性。当一个特性完成时，它将被合并回**Dev**分支。理论上，由于只开发了少数几个特性，合并操作不应该太难（因为代码变化不大）。以下图表说明了这一点：
- en: '![Figure 13.1 – Feature development in Git Flow'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.1 – Git Flow中的特性开发'
- en: '](img/Figure_13.01_B16354.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.01_B16354.jpg)'
- en: Figure 13.1 – Feature development in Git Flow
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.1 – Git Flow中的特性开发
- en: As we can see, the simplest situation is when features are developed one after
    the other, hence the feature we just developed has to be merged back. However,
    in real situations, it's common to have more than one feature developed in parallel,
    so the merge back into the **Dev** branch can be slightly more difficult.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，最简单的情况是特性一个接一个地开发，因此我们刚刚开发的特性必须合并回。然而，在实际情况下，通常会有多个特性并行开发，因此合并回**Dev**分支可能会稍微困难一些。
- en: When enough features are developed (and have been merged into the **Dev** branch),
    a new branch is created from the **Dev** branch, called **Release**. The **Release**
    branch should have some kind of a *feature freeze*, meaning that all the code
    committed into this branch must only have the goal of releasing and not adding
    any new features. This means that while tests are going on against the code in
    the **Release** branch, developers are supposed to commit bug fixes (if any) in
    this branch.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当开发足够多的特性（并且已合并到**Dev**分支）时，从**Dev**分支创建一个新的分支，称为**发布**。**发布**分支应该有一种*特性冻结*，这意味着提交到这个分支的所有代码必须只具有发布的目标，而不添加任何新特性。这意味着当对**发布**分支中的代码进行测试时，开发者应该在这个分支中提交（如果有）错误修复。
- en: 'Other files needed for the release (such as documentation and scripts) can
    be added there. When the release is ready, the code in the branch will be tagged
    (that is, *freezed* to a specific version). Then, the **Release** branch is merged
    back into the **Main** and **Dev** branches so that the developments for the upcoming
    versions can begin, as shown in the following diagram:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 发布所需的其他文件（例如文档和脚本）可以添加到那里。当发布准备就绪时，分支中的代码将被标记（即，*冻结*到特定版本）。然后，**发布**分支合并回**主**分支和**开发**分支，以便开始为即将到来的版本的开发工作，如图所示：
- en: '![Figure 13.2 – Release management in Git Flow'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.2 – Git Flow中的发布管理'
- en: '](img/Figure_13.02_B16354.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.02_B16354.jpg)'
- en: Figure 13.2 – Release management in Git Flow
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.2 – Git Flow中的发布管理
- en: As we can see, when working on a release, all the code is supposed to be modified
    in the **Release** branch itself for fixing the issues that prevent this particular
    release from going into production. Once everything is ready and the production
    release is successful, the code in the **Release** branch (including the *freezed*
    code for that release plus the bug fixes, if any) is merged back into the **Main**
    and **Dev** branches.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，当进行发布工作时，所有代码都应该在**发布**分支本身中进行修改，以修复阻止该特定发布进入生产的错误。一旦一切准备就绪并且生产发布成功，**发布**分支中的代码（包括该发布的*冻结*代码以及任何错误修复）将被合并回**主**分支和**开发**分支。
- en: 'If an issue happens in production, an ad hoc **Hotfix** branch is created from
    the **Main** branch for the purpose of production fixes and merged back as soon
    as possible, as shown here:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果生产中出现问题，将从一个**主**分支创建一个临时的**热修复**分支，用于生产修复，并尽可能快地合并，如图所示：
- en: '![Figure 13.3 – Hotfix development in Git Flow'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.3 – Git Flow中的热修复开发'
- en: '](img/Figure_13.03_B16354.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.03_B16354.jpg)'
- en: Figure 13.3 – Hotfix development in Git Flow
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.3 – Git Flow中的热修复开发
- en: As seen in the diagram, in the case of a hotfix, the code should come from the
    **Main** branch and the fixes must be done in the **Hotfix** branch. The changes
    must then be merged back to both the **Main** and **Dev** branches.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如图中所示，在热修复的情况下，代码应来自**主**分支，修复必须在**热修复**分支上进行。然后必须将这些更改合并回**主**和**开发**分支。
- en: Git Flow seems a bit difficult, and indeed it requires a lot of different branches
    and merge operations. But it's also considered not very well suited for modern
    application development techniques, such as CI/CD and DevOps. For such situations,
    trunk-based development is considered a better choice.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Git Flow似乎有点复杂，确实需要很多不同的分支和合并操作。但它也被认为不太适合现代应用程序开发技术，如CI/CD和DevOps。在这种情况下，仓库式开发被认为是一个更好的选择。
- en: Trunk-based development
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 仓库式开发
- en: '**Trunk-based development** is much simpler than Git Flow. Basically, every
    developer works on the same branch (the main branch, usually). They are allowed
    to create branches for local developments, but it''s advised to make them as short-lived
    as possible, and merge them back to the main branch as soon as possible (at least
    daily). This needs to be done so that the developments are consistent, the tests
    should pass, and the changes should not break anything else in the project.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '**仓库式开发**比Git Flow简单得多。基本上，每个开发者都在同一个分支（通常是主分支）上工作。他们被允许为本地开发创建分支，但建议尽可能使这些分支的生命周期短暂，并尽快将它们合并回主分支（至少每天一次）。这样做是为了确保开发的一致性，测试应该通过，并且更改不应该破坏项目中的其他部分。'
- en: With this in mind, trunk-based development is often seen as a perfect pair with
    CI/CD (more on this later in the chapter). It is possible (and common) to have
    automated processes constantly checking for the integrity of the main branch (such
    as after every merge), and in the case of tests failing, changes could be reverted;
    or, someone in the team (usually the developer of such changes) should focus on
    fixing the issues. The main branch can be released in production at any time (carrying
    all the latest developments). Before each release, the code is tagged for traceability
    and reproducibility of the release.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，仓库式开发通常被视为与CI/CD（本章后面将详细介绍）的完美搭配。可能（且常见）是自动化流程不断检查主分支的完整性（例如，每次合并后），如果测试失败，则可以撤销更改；或者，团队中的某个人（通常是这些更改的开发者）应专注于修复问题。主分支可以随时在生产环境中发布（携带所有最新的开发成果）。在每次发布之前，代码都会被打上标签，以便进行维护的可追溯性和可重复性。
- en: Trunk-based development, other than being easier to implement and maintain,
    requires less effort for change management, as merges are smaller and they happen
    quite often.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 除了易于实施和维护外，仓库式开发在变更管理方面也要求付出更少的努力，因为合并较小且发生频率较高。
- en: On the other hand, it requires great experience and dedication from every project
    contributor as it increases the possibility of bugs or other bad code slipping
    into the main trunk (and, theoretically, into production). A related topic to
    branching strategies is the versioning standard.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，它需要每个项目贡献者有丰富的经验和奉献精神，因为它增加了错误或其他不良代码滑入主分支（理论上，进入生产环境）的可能性。与分支策略相关的一个相关主题是版本控制标准。
- en: Semantic versioning
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 语义版本控制
- en: As we said, during each release, the source code is *frozen* (usually with a
    tag) and uniquely identified for maintenance purposes.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所言，在每次发布期间，源代码会被**冻结**（通常使用标签），并为了维护目的进行唯一标识。
- en: However, there are many different theories on what the best way for versioning
    releases is, as in choosing a unique identifier.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，关于如何选择版本号的最佳方式，即选择一个唯一的标识符，存在许多不同的理论。
- en: A method that I find particularly elegant and effective is semantic versioning.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我发现的一种特别优雅且有效的方法是语义版本控制。
- en: '**Semantic versioning** is commonly used in open source projects and basically
    associates each release with three numbers, in the form of *x.y.z* (for example,
    *1.2.3*). Changes to each of these numbers have a precise meaning:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '**语义版本控制**在开源项目中普遍使用，基本上将每个版本与三个数字关联，形式为*x.y.z*（例如，*1.2.3*）。这些数字的任何变化都有精确的含义：'
- en: The first number (represented by *x* in our example) is called the **major version**.
    An increase in the major version implies major updates, including new features,
    re-architecture, technology changes, and, most importantly, potentially breaking
    changes (including changes in the APIs exposed).
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个数字（在我们的例子中用*x*表示）被称为**主版本**。主版本的提升意味着主要更新，包括新功能、重构、技术变更，最重要的是，可能包括破坏性更改（包括API的变化）。
- en: The second number (represented by *y* in our example) is called the **minor
    version**. An increase in the minor version implies new functionalities, which
    can also be non-trivial but are supposed to be backward compatible, so avoid changing
    the APIs exposed.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个数字（在我们的例子中用*y*表示）被称为**次要版本**。次要版本的升级意味着新的功能，这些功能也可以是非平凡的，但应该是向后兼容的，因此应避免更改公开的API。
- en: The third number (represented by *z* in our example) is called the **patch version**.
    An increase in this version just implies bug fixes. No new features should be
    included (unless very trivial) and, of course, no breaking changes in the APIs
    exposed.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三个数字（在我们的例子中用*z*表示）被称为**补丁版本**。该版本的升级仅意味着修复错误。不应包含新功能（除非非常简单），当然，公开的API中不应有破坏性更改。
- en: An increase in the major version implies that minor and patch versions are reset
    to *0*. So, if we make big changes for version *1.2.3* (by breaking the APIs),
    the next release should be *2.0.0*.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 主版本的增加意味着次要版本和补丁版本都会重置为*0*。因此，如果我们对版本*1.2.3*进行了重大更改（通过破坏API），下一个发布版本应该是*2.0.0*。
- en: Similarly, an increase in the minor version resets the patch version to *0*,
    so for version *1.2.3*, if there are new features that are backward compatible,
    we go to version *1.3.0*. Needless to say, each version can go to double figures
    with no impact on the other versions. Hence, an increase in the minor version
    of the software in version *1.9.3* means going to version *1.10.0*.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，次要版本的增加会将补丁版本重置为*0*，所以对于版本*1.2.3*，如果有向后兼容的新功能，我们将升级到版本*1.3.0*。不用说，每个版本都可以升级到两位数，而不会影响其他版本。因此，软件版本*1.9.3*中次要版本的升级意味着升级到版本*1.10.0*。
- en: After the three numbers compose the version, it is possible to add an optional
    label. Common labels are **RELEASE** (identifying a version released in production),
    **ALPHA** (identifying a preliminary version, not intended for production), and
    **Release Candidate** (**RC**) (this is something almost ready for production,
    but likely needs some more testing).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在三个数字组成版本号之后，可以添加一个可选的标签。常见的标签有**RELEASE**（标识已发布到生产的版本）、**ALPHA**（标识预发布版本，不打算用于生产）和**Release
    Candidate**（**RC**）（这几乎已经准备好用于生产，但可能还需要进行一些测试）。
- en: It is also a common convention to set the major version to *0* in order to identify
    the first project draft (such as a prototype not intended to be stable).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 也将主版本设置为*0*作为识别第一个项目草案（如原型，不打算稳定）的常见约定。
- en: In this section, we have learned some interesting concepts. Starting with Git,
    which is the de facto standard, and SCM, we learned about a couple of different
    branching strategies, and we had a look at a standard way for versioning releases.
    Now, our next step is to make some considerations about testing.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了一些有趣的概念。从事实上的标准Git和SCM开始，我们了解了几种不同的分支策略，并查看了一种标准的版本发布方式。现在，我们的下一步是考虑一些关于测试的问题。
- en: Testing
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试
- en: In [*Chapter 4*](B16354_04_Final_JM_ePUB.xhtml#_idTextAnchor089), *Best Practices
    for Design and Development*, we had a look at **Test-Driven Development** (**TDD**),
    quickly touching on the concept of **unit testing**. Now is the right time to
    make some deeper considerations around the concept of testing and return to some
    topics that we have taken for granted so far.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第4章*](B16354_04_Final_JM_ePUB.xhtml#_idTextAnchor089)“设计和开发的最佳实践”中，我们了解了**测试驱动开发**（**TDD**），简要地提到了**单元测试**的概念。现在是深入考虑测试概念并回到我们迄今为止已经视为理所当然的一些主题的正确时机。
- en: Unit testing
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单元测试
- en: '**Unit testing** is the most basic technique for software quality assurance
    and, as we have seen, the tool behind TDD.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '**单元测试**是软件质量保证的最基本技术，正如我们所见，是TDD背后的工具。'
- en: Unit testing aims to provide testing (usually automated) for the smallest unit
    of identifiable software. In the Java world, this means testing at a class and
    method level. The tests involve calling the method with a defined set of inputs
    and checking (with assertions) that the output complies with the expectation (including
    expected failures).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试旨在为可识别的最小软件单元提供测试（通常是自动化的）。在Java世界中，这意味着在类和方法级别进行测试。测试涉及使用定义好的输入集调用方法，并检查（使用断言）输出是否符合预期（包括预期的失败）。
- en: The reasoning behind it is that each method is tested individually, so the tests
    can be simple and pervasive. This also allows bugs to be identified early and
    in the exact spot where they are introduced (at least in the exact method). The
    limitation of this approach is that it doesn't easily detect bugs caused by corner
    cases or interaction between complex systems, or with external systems.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 其背后的原因是每个方法都是单独测试的，因此测试可以简单且无处不在。这也允许在引入（至少在确切的方法中）的精确位置早期识别错误。这种方法的局限性是它不容易检测由边缘情况或复杂系统之间的交互或与外部系统引起的错误。
- en: In the Java world, unit testing means JUnit, which is a very famous library
    widely used for implementing unit tests and more. Let's learn more about it.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java世界中，单元测试意味着JUnit，这是一个非常著名的库，广泛用于实现单元测试等。让我们更多地了解它。
- en: JUnit
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: JUnit
- en: '**JUnit** is the de facto standard for unit testing in Java. The current version
    at the time of writing is **version 5**. JUnit provides some standards and facilities
    for defining unit tests and integrating them into common toolchains, such as Maven
    and Gradle. JUnit is also easy to run from a common IDE, such as IntelliJ.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '**JUnit**是Java单元测试的事实标准。撰写本文时的当前版本是**版本5**。JUnit提供了一些标准和工具，用于定义单元测试并将它们集成到常见的工具链中，如Maven和Gradle。JUnit也易于从常见的IDE，如IntelliJ中运行。'
- en: The Maven standard defines that the test classes must be placed in the `src/test/java`
    folder, whereas the application code is supposed to stay in the `src/main/java`
    folder.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: Maven标准定义，测试类必须放置在`src/test/java`文件夹中，而应用程序代码应保留在`src/main/java`文件夹中。
- en: In this way, the test classes can mirror the same package structure as the application
    files, and in the release phase, the test classes can then be discarded and not
    be part of the release artifacts.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，测试类可以与应用程序文件相同的包结构相匹配，在发布阶段，测试类可以被丢弃，不成为发布工件的一部分。
- en: JUnit automatically considers (and runs) tests contained in classes whose name
    starts or ends with `Test`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: JUnit自动考虑（并运行）名称以`Test`开头或结尾的类中包含的测试。
- en: Each test method is identified by the `@Test` annotation. It's possible to annotate
    some method for setting up resources before tests, with annotations such as `@BeforeAll`
    and `@BeforeEach`. At the same time, it's possible to clean up things after tests,
    using `@AfterAll` and `@AfterEach`. Test execution can be controlled by using
    `@Order`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 每个测试方法都通过`@Test`注解来标识。可以使用`@BeforeAll`和`@BeforeEach`等注解来注解一些在测试之前设置资源的方法。同时，可以使用`@AfterAll`和`@AfterEach`来清理测试后的东西。测试执行可以通过使用`@Order`来控制。
- en: Moreover, JUnit provides a set of facility methods, such as `AssertEquals`,
    `AssertTrue`, and `AssertFalse`, which can be used to check for the expected results.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，JUnit提供了一套便利方法，如`AssertEquals`、`AssertTrue`和`AssertFalse`，可用于检查预期的结果。
- en: JUnit execution is commonly integrated as a step into a build chain (acting
    as a part of a Maven build or of a more complex pipeline). You can constantly
    have a view of what is working and what is failing, often with a visual representation
    with green and red lights for building reports.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: JUnit执行通常作为构建链中的一个步骤集成（作为Maven构建或更复杂管道的一部分）。你可以持续查看哪些正在工作，哪些失败，通常会有绿色和红色灯的视觉表示来生成报告。
- en: 'Now, we have a simple class such as the following:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有一个如下简单类：
- en: '[PRE0]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The preceding class basically has a field with a getter and setter, and a method
    to do the classic *hello world* (with a string concatenation). The unit test class
    associated with the preceding class is as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个类基本上有一个带有getter和setter的字段，以及一个执行经典*hello world*（使用字符串连接）的方法。与前面类相关联的单元测试类如下：
- en: '[PRE1]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'A few considerations about the preceding test are as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 关于前面测试的一些考虑如下：
- en: The `it.test` package, where the test resides, is the same as the package where
    the implementation is. As said, this is possible because the implementations stay
    in the `src/main/java` folder, while the tests stay in the `src/test/java` folder.
    During the testing phase, you can consider the preceding two folders as the source
    folders, while, when building the artifact, you can ditch the test folder. This
    allows us to access `protected` fields and methods on the class to be tested.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试所在的`it.test`包与实现所在的包相同。正如所说，这是可能的，因为实现保持在`src/main/java`文件夹中，而测试保持在`src/test/java`文件夹中。在测试阶段，你可以将前两个文件夹视为源文件夹，而在构建工件时，你可以丢弃测试文件夹。这允许我们访问要测试的类的`protected`字段和方法。
- en: The class name ends with `Test`. This will suggest to the JUnit framework that
    the class includes some tests.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类名以 `Test` 结尾。这将向JUnit框架暗示该类包含一些测试。
- en: The `buildHello` method is annotated with `@BeforeEach`, hence it's executed
    before each test method. In this case, of course, the implementation is straightforward
    for the example purpose, but in the real world, there are a lot of meaningful
    things to be done there, such as initializing fake data and connecting to external
    systems.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`buildHello` 方法使用 `@BeforeEach` 注解，因此它在每个测试方法之前执行。当然，在这个例子中，实现很简单，但在现实世界中，有很多有意义的事情要做，比如初始化模拟数据和连接到外部系统。'
- en: You can also use `@BeforeAll`, which is executed once before all tests. Also,
    it's worth noticing that `@AfterEach` and `@AfterAll` are available for the teardown
    of resources that need to be safely closed (such as database connections) or for
    cleaning up the necessary data IDs.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用 `@BeforeAll`，它在所有测试之前执行一次。值得注意的是，`@AfterEach` 和 `@AfterAll` 也可用于清理需要安全关闭的资源（如数据库连接）或清理必要的数据ID。
- en: 'Each test method is annotated with `@Test` and does some assertions on expected
    output by using the `Assertions.assertEquals` utility method. Other methods, such
    as `assertTrue` and `assertFalse`, are available as well. As it''s easy to spot,
    simple things such as setters are tested here, which are usually probably not
    so vulnerable to bugs:'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个测试方法都使用 `@Test` 注解，并通过使用 `Assertions.assertEquals` 工具方法对预期输出进行一些断言。其他方法，如
    `assertTrue` 和 `assertFalse`，也都可以使用。正如你所看到的，这里测试了一些简单的事情，例如设置器，这些通常可能不太容易出bug：
- en: '[PRE2]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The previous code can be made more readable by using a `static` import on `Assertions`,
    and then directly using the methods provided by the class.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 `Assertions` 的 `static` 导入，可以使之前的代码更易于阅读，然后直接使用该类提供的方法。
- en: 'When running these tests, you can easily see a recap of test execution. By
    way of an example, by running the `mvn clean test` command, you should see something
    similar to this screenshot:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行这些测试时，你可以轻松地看到测试执行的回顾。例如，通过运行 `mvn clean test` 命令，你应该会看到类似于这个屏幕截图的内容：
- en: '![Figure 13.4 – Test execution in the command line'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.4 – 命令行中的测试执行'
- en: '](img/Figure_13.04_B16354.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.04_B16354.jpg)'
- en: Figure 13.4 – Test execution in the command line
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.4 – 命令行中的测试执行
- en: As you can see, the build succeeds, and there is a recap of the executed tests
    (that were successful). If a test fails, by default, the build fails. If we know
    that there is a test intentionally failing (because, as an example, the method
    is not yet implemented, as it happens in the TDD methodology), we can skip that
    particular test (by annotating it with `@Disable`) or skip the testing phase completely
    (which is usually not advised).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，构建成功，并且有一个执行测试的回顾（这些测试都是成功的）。如果测试失败，默认情况下，构建会失败。如果我们知道有某个测试是故意失败的（例如，方法尚未实现，这在TDD方法中很常见），我们可以跳过那个特定的测试（通过使用
    `@Disable` 注解）或者完全跳过测试阶段（这通常不建议）。
- en: In the case of a big project, usually, the testing results are then saved and
    archived as part of a build process. This may simply mean saving the console output
    of the build with the test recap (as seen in the preceding screenshot) or using
    more sophisticated techniques. By using a widespread Maven plugin (`.xml` or `.html`
    files, although more complete commercial test suites are able to do similar things.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在大型项目中，通常会将测试结果保存并归档为构建过程的一部分。这可能只是简单地保存构建的控制台输出和测试回顾（如前一个屏幕截图所示）或使用更复杂的技术。通过使用广泛使用的Maven插件（`.xml`
    或 `.html` 文件，尽管更完整的商业测试套件也能做类似的事情）。
- en: But this was just about unit testing. To complete our view, it's useful to understand
    that more ways of testing are possible (and advised). Let's have a look at them
    in the following sections.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 但这仅仅是关于单元测试。为了完整地了解，了解还有更多测试方式是可能的（并且建议）。让我们在接下来的章节中看看它们。
- en: Beyond unit testing
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 超越单元测试
- en: Unit testing, indeed, can be seen as the (basic and essential) lowest step in
    the testing world. Indeed, as we have already said, unit testing is unable to
    catch some bugs that depend on more complex interactions between classes. To do
    so, more testing techniques are usually implemented, such as integration, end-to-end,
    performance, and **User Acceptance Testing** (**UAT**).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试，实际上可以看作是测试世界中的（基本和必要的）最低级步骤。确实，正如我们之前所说的，单元测试无法捕获一些依赖于类之间更复杂交互的bug。为了做到这一点，通常会实现更多的测试技术，例如集成测试、端到端测试、性能测试和**用户验收测试**（**UAT**）。
- en: Integration testing
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 集成测试
- en: '**Integration testing** is the immediate next step after unit testing. While
    unit testing tests the most atomic modules of software, such as methods and classes,
    integration testing focuses on the interaction of such modules with each other
    (but not on the entire system). So, the classes are put together and call each
    other to check (and realize) more complex testing scenarios. Each test involves
    more than one method call, usually from different classes.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '**集成测试**是单元测试之后的直接下一步。虽然单元测试测试的是软件中最基本的模块，如方法和类，但集成测试侧重于这些模块之间的交互（但不是整个系统）。因此，将这些类组合在一起并相互调用以检查（并实现）更复杂的测试场景。每个测试都涉及多个方法调用，通常来自不同的类。'
- en: There is no fixed rule for defining the granularity of each integration test,
    even if someone completely ditches this testing technique in favor of end-to-end
    testing (more on this in the next section). My personal suggestion is to at least
    add integration testing for the more complex functionalities by trying to involve
    at least two or three classes simulating the core features or at least the ones
    most impacted by changes (and by issues).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 对于定义每个集成测试的粒度并没有固定的规则，即使有人完全放弃这种测试技术而转向端到端测试（更多内容将在下一节中介绍）。我个人的建议是，至少通过尝试涉及至少两个或三个类来模拟核心功能或至少受更改影响最大的功能进行集成测试（以及问题）。
- en: While there are libraries that can be implemented specifically for integration
    testing (`arquillian` comes to mind), JUnit is perfectly usable (and widely used)
    for integration testing, too, by using the same facility (such as assertion and
    setup methods) as seen in the previous section. Of course, instead of building
    tests for testing each method and class, more complex interactions are supposed
    to be implemented by chaining method calls and plugging different classes together.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有专门用于集成测试的库可以实现（例如，`arquillian`），但JUnit也可以通过使用与上一节中相同的设施（如断言和设置方法）进行集成测试，并且被广泛使用。当然，而不是为每个方法和类构建测试，更复杂的交互应该通过链式方法调用和将不同的类连接起来来实现。
- en: End-to-end testing
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 端到端测试
- en: '**End-to-end testing**, also known as **system testing**, takes the integration
    testing ideas a bit further. End-to-end testing involves the testing of each functionality
    as a whole, including external systems (such as databases), which are commonly
    dedicated and maintained as part of the testing efforts. The functionality can
    be defined at many different times, but nowadays usually overlaps with the concept
    of an API.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '**端到端测试**，也称为**系统测试**，将集成测试的理念进一步扩展。端到端测试包括对每个功能作为一个整体的测试，包括外部系统（如数据库），这些系统通常作为测试工作的一部分进行专门化和维护。功能可以在许多不同的时间定义，但如今通常与API的概念重叠。'
- en: End-to-end testing includes calling an API (or triggering a functionality differently)
    by passing a known set of inputs and then checking the expected outputs. This
    will include, alongside the API response, also checking the status of external
    systems that are supposed to be changed (such as things edited in databases or
    external systems that are supposed to be contacted, such as sending emails).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 端到端测试包括通过传递一组已知的输入来调用API（或以不同的方式触发功能），然后检查预期的输出。这包括API响应，同时也会检查预期发生变化的系统状态（如数据库中编辑的内容或需要联系的外部系统，如发送电子邮件）。
- en: It is implied that the system is then tested *from the outside*, as opposed
    to the other testing techniques seen so far, which are more focused on the source
    code (and then more looking at the project *from the inside*).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着系统随后是从外部进行测试的，与迄今为止看到的其他测试技术相反，这些技术更侧重于源代码（然后更多是从项目的内部进行观察）。
- en: End-to-end testing provides a good idea of system behavior *as a whole*, and
    it's usually less stable than unit and integration testing because a small change
    in any of the methods can cause failures in many end-to-end tests depending on
    that specific method (and go undetected or have a smaller impact on unit and integration
    tests). However, it is also coarser-grained, so it can be a bit more difficult
    to understand where and why things are breaking.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 端到端测试提供了对系统整体行为的良好理解，并且它通常比单元测试和集成测试更不稳定，因为任何方法中的微小变化都可能导致许多端到端测试失败（取决于该方法，并且可能未被检测到或对单元测试和集成测试的影响较小）。然而，它也更粗糙，因此可能更难理解问题出在哪里以及为什么会出现这些问题。
- en: There are a lot of tools for end-to-end testing, both free and commercial. Such
    tools are usually more of a kind of standalone platform, as opposed to the tools
    seen so far (such as JUnit), which are more libraries and frameworks. Moreover,
    end-to-end testing is basically language-independent, hence, Java projects don't
    usually need any specific testing tool, as the entry points for testing are APIs
    or user interfaces. So, any tool capable of interacting at that level can be used.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多端到端测试的工具，既有免费的也有商业的。这类工具通常更像是独立平台，而不是之前看到的工具（如JUnit），它们更像是库和框架。此外，端到端测试基本上是语言无关的，因此Java项目通常不需要任何特定的测试工具，因为测试的入口点是API或用户界面。所以，任何能够在这个级别交互的工具都可以使用。
- en: Commonly used solutions include LoadRunner, a commercial solution originally
    built by HP and now part of Micro Focus, which is the standard in some projects.
    Other alternatives are the SmartBear testing suite and other free testing suites,
    such as JMeter, Cypress, Karate, Gatling, and Selenium. The last two tools are
    more focused on automating the user interface interactions, which means that there
    are basic ways to automate the programmatic use of web browsers, simulating a
    real user accessing a web application, checking all the expected behavior.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 常用的解决方案包括LoadRunner，这是一个由HP最初构建的商业解决方案，现在是Micro Focus的一部分，在某些项目中是标准。其他替代方案包括SmartBear测试套件和其他免费测试套件，如JMeter、Cypress、Karate、Gatling和Selenium。后两种工具更专注于自动化用户界面交互，这意味着有基本的方法可以自动化程序对网络浏览器的基本使用，模拟真实用户访问Web应用程序，检查所有预期的行为。
- en: Performance testing
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 性能测试
- en: '**Performance testing** is a special case of end-to-end testing. Instead of
    being exclusively focused on the correct implementation of each API (or feature)
    tested (which is basically taken for granted), performance tests focus on system
    capacity and the response time under different loads. While the tools can be (and
    often are) similar to end-to-end testing, the final goal is different. The metrics
    measured when doing performance testing are the ones described in [*Chapter 6*](B16354_06_Final_JM_ePUB.xhtml#_idTextAnchor141),
    *Exploring Essential Java Architectural Patterns*, in the *Designing for large-scale
    adoption* section, and include throughput, response time, and elapsed time.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '**性能测试**是端到端测试的特殊情况。它不是仅专注于测试的每个API（或功能）的正确实现（这基本上是理所当然的），而是关注系统容量和不同负载下的响应时间。虽然工具可以是（并且通常是）与端到端测试相似的，但最终目标不同。进行性能测试时测量的指标是[第6章](B16354_06_Final_JM_ePUB.xhtml#_idTextAnchor141)中描述的，即《探索关键Java架构模式》一书中“设计用于大规模采用”部分中的指标，包括吞吐量、响应时间和经过时间。'
- en: 'Performance testing can include the following scenarios:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 性能测试可以包括以下场景：
- en: '**Load testing**, which is measuring the performance of the system against
    a defined load, is usually similar to the one expected in production (or an exaggerated
    case of it, such as doubling the expected number of concurrent users).'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**负载测试**，即测量系统在定义的负载下的性能，通常与生产环境中的预期情况相似（或者是一个夸张的情况，例如将预期的并发用户数量加倍）。'
- en: '**Spike testing**, which is similar to the previous one (and indeed they are
    often run together), basically involves sudden changes in the load of traffic
    to simulate spikes. This test aims to check the scalability of the system and
    the time needed for recovery following a sudden traffic increase. In other words,
    it''s often allowed to have a slight slowdown after an unexpected increase in
    traffic (because the system is expected to adapt to such traffic, such as using
    an autoscaling technique), but it''s worth measuring how long it takes for the
    system to recover following such a slowdown.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**峰值测试**，与之前的测试类似（实际上它们经常一起运行），基本上涉及流量负载的突然变化来模拟峰值。这种测试的目的是检查系统的可扩展性和在突然流量增加后恢复所需的时间。换句话说，在流量意外增加后，系统可能会允许出现轻微的减速（因为系统预计会适应这种流量，例如使用自动扩展技术），但值得测量系统在减速后恢复所需的时间。'
- en: '**Stress testing**, which takes the previous test types to the extreme, aims
    to benchmark the system by measuring the maximum traffic that can be correctly
    handled by the system.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**压力测试**，将之前的测试类型推向极限，旨在通过测量系统能够正确处理的最高流量来基准测试系统。'
- en: During a performance test, regardless of the tools and objectives, it's strongly
    advised to observe the system *as a whole*, including OS parameters (such as memory,
    CPU, and network) and external systems, such as databases, in order to check for
    bottlenecks and understand how the system can be fine-tuned to perform better.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在性能测试期间，无论工具和目标如何，强烈建议观察系统作为一个整体，包括操作系统参数（如内存、CPU和网络）以及外部系统，如数据库，以便检查瓶颈并了解系统如何进行微调以更好地运行。
- en: User acceptance testing
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 用户验收测试
- en: UAT is a crucial step of the testing process, and I'd say of the whole software
    development process. Technically speaking, it is quite similar to end-to-end testing,
    by focusing on testing functionalities as a whole. There are, however, some crucial
    differences. The first one is that the test is supposed to be governed by a functional
    analyst, business people, or the project sponsor.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: UAT是测试过程中的关键步骤，可以说在整个软件开发过程中都是如此。从技术角度来说，它与端到端测试非常相似，因为它专注于整体测试功能。然而，也有一些关键的区别。第一个区别是，测试应该由功能分析师、业务人员或项目赞助人负责。
- en: This, of course, doesn't mean that these people should be running the tests
    themselves, but that the test structure (including the acceptance criteria and
    the priority of the features tested) should be set by those teams, and this is
    usually done by focusing on the point of view of the end user (hence the name
    of this phase).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这并不意味着这些人应该亲自运行测试，而是测试结构（包括验收标准和测试功能的优先级）应由这些团队设定，这通常是通过关注最终用户的观点来完成的（因此这个阶段得名）。
- en: It's accepted that part of this test is done manually, with users directly navigating
    the application feature as a final user is supposed to. A more deterministic approach
    is to also run the UAT using automated tools, similar to the ones used in end-to-end
    testing. Even in this case, it's common to still perform a small part of this
    phase manually, by doing what is called a **smoke test**, which is less structured
    and aimed at giving a general idea of how the application behaves.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 人们普遍认为，这部分测试中有一部分是手动完成的，用户直接导航应用程序功能，就像最终用户应该做的那样。更确定性的方法是在使用与端到端测试中使用的类似工具运行UAT。即使在这种情况，通常仍然会手动执行这一阶段的小部分，通过进行所谓的**烟雾测试**，这种测试不那么结构化，旨在给出应用程序行为的一般印象。
- en: Whether being done manually or automated, there is a core difference between
    UAT and the other tests seen so far, and this difference is that the tests need
    to be designed around business capabilities. Indeed, each test case is supposed
    to be related to a specific requirement in order to prove that this requirement
    is currently implemented in that particular software release. We already discussed
    this in [*Chapter 2*](B16354_02_Final_JM_ePUB.xhtml#_idTextAnchor034), *Software
    Requirements – Collecting, Documenting, Managing*, where we saw how each software
    requirement is supposed to be testable.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 不论是手动执行还是自动化执行，UAT（用户验收测试）与其他测试之间的核心区别在于，测试需要围绕业务能力来设计。实际上，每个测试用例都应该与一个特定的需求相关联，以便证明该需求目前在该特定软件版本中已实现。我们已经在[*第二章*](B16354_02_Final_JM_ePUB.xhtml#_idTextAnchor034)《软件需求
    – 收集、记录、管理》中讨论了这一点，我们看到了每个软件需求应该如何是可测试的。
- en: This is where that loop closes. The successful execution of UAT is the gateway
    for the production release (hence the word *acceptance*); if all the tests succeed,
    it is, of course, safe and accepted to release in production. In case of any failure,
    a choice needs to be made (usually discussed with an extended team).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是那个循环闭合的地方。UAT的成功执行是生产发布的门户（因此有“验收”这个词）；如果所有测试都成功，当然在生产中发布是安全且被接受的。如果出现任何失败，需要做出选择（通常与扩展团队讨论）。
- en: If minor issues occur, this may mean that the release will go into production
    anyway, with several known issues. Of course, if this is not the case and the
    issues are too many (or related to critical features), then the issues need to
    be fixed and the production release may be canceled or delayed. UAT is basically
    the higher rank of tests, but it's important to understand that it's crucial to
    have a strategy around every other testing technique seen so far; otherwise, it's
    likely to have software that is not completely tested and prone to errors. However,
    some other considerations around testing are worth noticing.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果出现小问题，这可能意味着发布仍然会进入生产环境，同时存在几个已知问题。当然，如果情况并非如此，问题太多（或与关键特性相关），那么这些问题需要得到解决，生产发布可能会被取消或推迟。UAT（用户验收测试）基本上是测试的最高级别，但重要的是要理解，围绕迄今为止看到的每一种其他测试技术都需要有一个策略；否则，很可能会得到一个没有完全测试且容易出错的软件。然而，还有一些关于测试的其他考虑因素值得关注。
- en: Further testing considerations
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进一步的测试考虑因素
- en: In the previous sections, we saw quite a few interesting things on testing,
    including the different testing phases and techniques. However, there are a number
    of other considerations that are worth a few words.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们看到了关于测试的许多有趣的事情，包括不同的测试阶段和技术。然而，还有一些其他值得讨论的考虑因素。
- en: Interacting with external systems
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 与外部系统交互
- en: As we have seen, in most of the phases of testing (sometimes even in unit testing),
    external systems may be involved. Databases, mail servers, and web services are
    common examples.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，在测试的大多数阶段（有时甚至在单元测试中），可能会涉及到外部系统。数据库、邮件服务器和Web服务是常见的例子。
- en: There are a number of different techniques for dealing with such external systems
    in a testing phase. The easiest one, better suited for some specific testing phases,
    such as unit tests, is to simply mock such systems. This means implementing special
    custom classes that simply simulate the interaction with such systems, instead
    of just providing fake values.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试阶段处理此类外部系统有许多不同的技术。最简单的一种，更适合某些特定的测试阶段，如单元测试，就是简单地模拟这些系统。这意味着实现特殊的自定义类，这些类简单地模拟与这些系统的交互，而不是仅仅提供虚假值。
- en: A very widespread library for mocking in Java is `Mockito`, which offers a simple
    but very complete setup to implement methods that react to the requests in a programmable
    way, simulating the behavior of external systems.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: Java中一个非常流行的模拟库是`Mockito`，它提供了一个简单但非常完整的设置，以编程方式实现响应请求的方法，模拟外部系统的行为。
- en: Mocking is handy to use because it's mostly driven by code and requires minimal
    maintenance. However, as it's easy to understand, it provides limited effectiveness
    in tests because it tests just a small part of the interaction, often neglecting
    some aspects such as the connection to the external system (and things that may
    go bad there), and in general, doesn't test against real (or close to real) systems.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟（Mocking）非常方便使用，因为它主要是由代码驱动的，并且需要最少的维护。然而，由于它易于理解，它在测试中提供的有效性有限，因为它只测试交互的一小部分，通常忽略一些方面，例如与外部系统的连接（以及可能在那里出错的事情），总的来说，它并不针对真实（或接近真实）的系统进行测试。
- en: A step further is to effectively use an external system in tests, but a simplified
    one. The most common example is using H2 (the embeddable database we saw in [*Chapter
    7*](B16354_07_Final_JM_ePUB.xhtml#_idTextAnchor164), *Exploring Middleware and
    Frameworks*) in place of a full-fledged database system. The reason behind it
    is that it may be harder (and more expensive) to use compared to the real system,
    while such simplified tools are usually easier to automate and use in a testing
    environment.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步的步骤是有效地在测试中使用外部系统，但使用的是简化的版本。最常见的例子是用H2（我们在[*第7章*](B16354_07_Final_JM_ePUB.xhtml#_idTextAnchor164)，*探索中间件和框架*)代替完整的数据库系统。这样做的原因是，与真实系统相比，它可能更难（且更昂贵）使用，而这样的简化工具通常更容易在测试环境中自动化和使用。
- en: However, as we discussed in [*Chapter 9*](B16354_09_Final_JM_ePUB.xhtml#_idTextAnchor230),
    *Designing Cloud-Native Architectures*, when talking about 12-factor applications,
    using external services (backing services, as defined in that context) different
    from the production ones should be considered a source of potential instability
    as, of course, the behavior may be different from real systems. So, especially
    in phases such as end-to-end testing and UAT, it's strongly advised to use external
    systems that are as close as possible to the production ones. This leads us to
    the next consideration on ephemeral testing.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，正如我们在 [*第9章*](B16354_09_Final_JM_ePUB.xhtml#_idTextAnchor230) 中讨论的，*设计云原生架构*，当谈到12因子应用程序时，使用与生产环境不同的外部服务（在该上下文中定义为后端服务）应被视为潜在不稳定性的来源，因为当然，其行为可能与真实系统不同。因此，特别是在端到端测试和UAT阶段，强烈建议使用尽可能接近生产环境的系统。这引出了关于临时测试的下一个考虑因素。
- en: Ephemeral testing
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 临时测试
- en: '**Ephemeral testing** is a technique for creating complete test environments
    when needed. This basically means that the set of components needed for testing,
    including the application and the external systems, is created on-demand before
    each test runs, populated with the data and the configuration needed for the test
    execution.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '**临时测试** 是一种在需要时创建完整测试环境的技术。这基本上意味着测试所需组件的集合，包括应用程序和外部系统，在每个测试运行之前按需创建，并填充测试执行所需的数据和配置。'
- en: Such environments can then be disposed of after each test runs, avoiding wasting
    computational resources when not needed. This paradigm is particularly suited
    for IaaS and PaaS environments (as seen in [*Chapter 9*](B16354_09_Final_JM_ePUB.xhtml#_idTextAnchor230),
    *Designing Cloud-Native Architectures*) because such infrastructures will facilitate
    the scripting and automation around environment creation and disposal. IaaS and
    PaaS are also suited to recreating not only the application components themselves
    but also the external services (such as databases), and so are a good way to overcome
    the limitations that we have described in the previous section, and in particular
    with mocks.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这些环境可以在每次测试运行后丢弃，避免在不需要时浪费计算资源。这种范式特别适合于 IaaS 和 PaaS 环境（如在第9章中所述，*设计云原生架构*），因为此类基础设施将促进环境创建和丢弃的脚本化和自动化。IaaS
    和 PaaS 还适合重新创建不仅包括应用程序组件，还包括外部服务（如数据库），因此是克服我们在上一节中描述的限制的好方法，特别是与模拟相关。
- en: Testcontainers ([www.testcontainers.org](https://www.testcontainers.org)) is
    an open source framework very well suited for this kind of scenario. It supports
    JUnit (as well as other testing frameworks) and provides throwaway containerized
    instances of testing utilities (such as common databases, Selenium browsers, and
    more).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: Testcontainers ([www.testcontainers.org](https://www.testcontainers.org)) 是一个非常适合此类场景的开源框架。它支持
    JUnit（以及其他测试框架），并提供测试工具的临时容器化实例（例如常见的数据库、Selenium 浏览器等）。
- en: But having all the right components is not the only consideration to be made
    in order to have a meaningful and complete testing strategy.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 但拥有所有正确的组件并不是制定有意义且完整的测试策略的唯一考虑因素。
- en: Code coverage, test coverage, and maintenance
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 代码覆盖率、测试覆盖率和维护
- en: A crucial topic of testing is coverage. `if` conditions, loops, and so on, is
    hit by at least a test case.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 测试的一个关键主题是覆盖率。`if` 条件、循环等至少被一个测试用例命中。
- en: These kinds of metrics are not easy to measure manually and indeed are commonly
    calculated by relying on external tools. The most commonly used technique by such
    tools is **bytecode instrumentation**, which uses special features of the JVM
    to check code execution per line, as a result of tests running. Common libraries
    used for calculating code coverage, such as Cobertura and JaCoCo, use a similar
    approach.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指标很难手动测量，实际上通常依赖于外部工具进行计算。这些工具最常用的技术是 **字节码插装**，它利用 JVM 的特殊功能来检查每行代码的执行情况，作为测试运行的结果。用于计算代码覆盖率的一些常见库，如
    Cobertura 和 JaCoCo，采用类似的方法。
- en: 'Code coverage is the baseline of test completeness: a certain threshold must
    be defined, and a lower coverage should be considered as incomplete testing, especially
    when creating new functions and modules. But code coverage doesn''t ensure that
    all the features are tested, nor that the data used for tests is complete and
    variable enough. Hence, a further concept—**test coverage**—must be introduced.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 代码覆盖率是测试完整性的基础：必须定义一个特定的阈值，低于该阈值的覆盖率应被视为不完整的测试，尤其是在创建新功能和模块时。但代码覆盖率并不能保证所有功能都经过测试，也不能保证用于测试的数据是完整且足够变化的。因此，必须引入一个进一步的概念——**测试覆盖率**。
- en: 'Test coverage is, in my opinion, a bit less *scientific* to calculate. Whether
    code coverage is exactly measurable (even if it requires tools) as the percentage
    of lines of code executed during tests versus the total lines of code, test coverage
    revolves around many different points of view. Some common ones are as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在我看来，测试覆盖率的计算稍微不那么**科学**。虽然代码覆盖率可以通过测试期间执行的代码行数与总代码行数的百分比来精确测量（即使需要工具），但测试覆盖率围绕许多不同的观点。以下是一些常见的观点：
- en: '**Features coverage**, as in the number of features tested versus the total
    features of the application.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**功能覆盖率**，即测试的功能数量与应用程序的总功能数量之比。'
- en: '**Requirements coverage**, as in the number of requirements effectively tested
    versus the total requirements that the software implements.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**需求覆盖率**，即有效测试的需求数量与软件实现的总需求数量之比。'
- en: '**Device coverage**, particularly meaningful in web and mobile applications,
    is related to the number of different configurations (different mobile devices,
    multiple OS versions, multiple browsers versions, and so on) that our application
    is tested against.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**设备覆盖率**，尤其是在Web和移动应用程序中特别有意义，它与我们的应用程序测试所针对的不同配置（不同的移动设备、多个操作系统版本、多个浏览器版本等）的数量相关。'
- en: '**Data coverage**, related to the different inputs and configuration that our
    application is tested against. This is, of course, very difficult to test against,
    as the combination can really be limitless. On the other hand, having a good variety
    of inputs to test ensures better protection against unexpected behaviors.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据覆盖率**，与我们的应用程序测试所针对的不同输入和配置相关。这当然是非常难以测试的，因为组合可以是无限的。另一方面，拥有多种测试输入确保了对意外行为的更好保护。'
- en: Both code coverage and test coverage should be constantly measured and possibly
    improved. That implies covering the code added with new features (if any), and
    checking against the bugs found in the current software releases in order to understand
    whether there is a way to improve test coverage to check for such bugs in the
    future. Customer reports are particularly useful in this sense.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 代码覆盖率和测试覆盖率都应该持续测量并可能进行改进。这意味着要覆盖添加的新功能（如果有）的代码，并检查当前软件版本中发现的错误，以便了解是否有方法提高测试覆盖率以检查未来的此类错误。客户报告在这方面特别有用。
- en: Most of us are familiar with issues in the applications we use (especially in
    mobile applications) when, following an error message, there is the opportunity
    to send details of the error to the application team. By doing so, the application
    team has the opportunity to check for the particular conditions (inputs used,
    device used, and software version) at the time of that particular error, and can
    potentially extend the test suite (and, hence, the test coverage) to check for
    similar situations and avoid this family of errors in the future.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们大多数人对我们使用的应用程序（尤其是在移动应用程序中）的问题都很熟悉，当出现错误消息时，有机会向应用团队发送错误详情。通过这样做，应用团队有机会检查特定错误发生时的特定条件（使用的输入、使用的设备、软件版本），并可能扩展测试套件（因此，测试覆盖率）以检查类似情况，并避免未来出现此类错误。
- en: Last but not least, it's important to understand when to run what kind of tests.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，了解何时运行何种类型的测试很重要。
- en: Since running a whole test suite (including acceptance tests run by human operators)
    could be expensive and time-intensive, it's a common choice to have different
    test suites run in different situations. If we are fixing a minor bug or adding
    a small functionality, then we can probably take the risk of not testing the whole
    application, but just a subset.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 由于运行整个测试套件（包括由人工操作员运行的验收测试）可能既昂贵又耗时，因此在不同情况下运行不同的测试套件是一种常见的做法。如果我们正在修复一个小的错误或添加一个小功能，那么我们可能可以承担不测试整个应用程序的风险，而只测试一个子集。
- en: However, with test automation becoming more and more pervasive and disposable
    test environments made possible by the cloud, the advice is to test as much as
    possible, especially for performance. In this way, it will become easier to understand
    whether the release we are testing introduces any performance issues. This concept,
    taken to the extreme, is called **continuous testing**, and basically implies
    running the complete suite of tests, in an automated way, after every code or
    configuration change (even the smallest one).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，随着测试自动化变得越来越普遍，以及云提供的可丢弃测试环境，建议尽可能多地测试，特别是性能测试。这样，将更容易理解我们正在测试的发布版本是否引入了任何性能问题。这种概念，如果推向极致，被称为**持续测试**，基本上意味着在每次代码或配置更改（即使是微小的更改）之后，以自动化的方式运行完整的测试套件。
- en: In this section, we have seen a complete overview of the different testing techniques
    and phases. Starting with unit testing, we also explored integration, end-to-end,
    and performance tests.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们已经看到了不同测试技术和阶段的全貌。从单元测试开始，我们还探讨了集成、端到端和性能测试。
- en: 'In the next section, we are going to talk about a step that is contiguous to
    (and mutually dependent on) testing: deployment.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论一个与测试（连续且相互依赖）相关的步骤：部署。
- en: Deploying
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署
- en: '**Software deployment** is a very broad term, and can extensively be used to
    refer to the whole software life cycle, from development to release into production.
    However, in this particular context, I am referring to the deployment phase as
    the one in which the software is compiled and opportunely packaged, and the right
    configurations are applied. The software is then supposedly run and made ready
    for users to access (which is part of the process of releasing; more on this in
    a couple of sections). While we already mentioned some of these topics in this
    book, I would like to highlight a couple of them, useful for the purpose of this
    chapter.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '**软件部署**是一个非常广泛的概念，可以广泛地用来指代整个软件生命周期，从开发到发布到生产。然而，在这个特定的上下文中，我指的是部署阶段，即软件被编译和适当地打包，并应用了正确的配置。然后，软件假定将被运行并准备好供用户访问（这是发布过程的一部分；在接下来的几节中将有更多介绍）。虽然我们已经在本书中提到了一些这些主题，但我希望强调其中的一些，这对本章的目的很有用。'
- en: Building the code
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建代码
- en: The phase of building the code, intended as compilation and packaging into a
    deployable artifact (`.jar`, `.war`, and `.ear` in the case of Java), is done
    by utilities shipped with the JDK (in particular, the `javac` tool).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 构建代码的阶段，即编译和打包成可部署的工件（在Java的情况下为`.jar`、`.war`和`.ear`），是由JDK附带的一些实用工具完成的（特别是`javac`工具）。
- en: However, this process often includes at the very least the management of dependencies,
    but in the real world, many other steps can be involved, such as code formatting,
    the parsing of resources or configuration files, and the execution of unit tests
    (as seen before).
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，此过程通常至少包括依赖项的管理，但在现实世界中，可能还会涉及许多其他步骤，例如代码格式化、资源或配置文件的解析，以及单元测试的执行（如之前所见）。
- en: A widely used technology to perform all of those steps, mentioned and used many
    times in this book, is Apache Maven.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 执行所有这些步骤的一个广泛使用的技术，在本书中多次提及和使用，是Apache Maven。
- en: 'While I assume that most of you already know and have used Maven, I think it
    is relevant to highlight some features that are useful to consider from an architect''s
    perspective:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我假设你们大多数人已经知道并使用过Maven，但我认为从架构师的角度来看，强调一些有用的特性是相关的：
- en: Maven uses a standard way (the `pom.xml` file) to define instructions about
    building the software. Indeed, the `pom` file collects the list of dependencies
    (including the one needed just for testing purposes and the one needed just at
    development time). It can also specify the steps needed for the compilation and
    packaging of the software and provide some configurations for each step.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Maven使用一种标准方式（`pom.xml`文件）来定义关于构建软件的指令。实际上，`pom`文件收集了依赖项列表（包括仅用于测试目的的依赖项和仅用于开发时间的依赖项）。它还可以指定编译和打包软件所需的步骤，并为每个步骤提供一些配置。
- en: It provides an extensible system, based on plugins. Hence, you can find (or
    implement) different plugins, to run tests, create documentation, generate code,
    and other steps that could be useful at deployment time.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它提供了一个基于插件的扩展性系统。因此，您可以找到（或实现）不同的插件，以运行测试、创建文档、生成代码，以及其他在部署时可能有用的步骤。
- en: It can define a hierarchy between different projects and provide a unique way
    to identify each software artifact (also called a Maven artifact) by setting what
    is called the `GroupId` (basically a namespace or package for the project), `ArtifactId`
    (the identifying name of the project), and the version.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以定义不同项目之间的层次结构，并通过设置所谓的`GroupId`（基本上是项目的命名空间或包）、`ArtifactId`（项目的标识名称）和版本来为每个软件工件（也称为Maven工件）提供一种唯一的方式来识别。
- en: As said, Maven is basically a standard technology for building in the Java world,
    though it's not the only one. **Ant** is another option that used to be widely
    used some years ago and is more similar to scripting and less flexible. It has
    been progressively abandoned for its verbosity and a number of shortcomings in
    dependency management.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 正如所说，Maven基本上是Java世界中的标准构建技术，尽管它不是唯一的。**Ant**是另一种曾经广泛使用的选项，它更类似于脚本且灵活性较低。由于其冗长性和依赖管理中的许多缺点，它已经被逐渐放弃。
- en: '`pom.xml` configuration files). Let''s have a quick overview of this concept.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`pom.xml`配置文件）。让我们快速概述一下这个概念。'
- en: Managing artifacts
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管理工件
- en: Software artifacts are essential, both as part of the building process of bigger
    components (as dependencies) and to be directly deployed (as an example, to production
    environments). While it's possible to directly manage such contents (which, in
    the Java world, are basically `.jar`, `.ear`, and `.war` files) in filesystem
    folders, it's way better to do so in optimized systems. Such systems are called
    **artifact repositories**.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 软件工件至关重要，既是构建更大组件（作为依赖项）的一部分，也可以直接部署（例如，到生产环境）。虽然可以直接在文件系统文件夹中管理此类内容（在Java世界中基本上是`.jar`、`.ear`和`.war`文件），但在优化系统中这样做会更好。这样的系统被称为**工件存储库**。
- en: 'An artifact repository often provides many advanced features, including the
    following:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 工件存储库通常提供许多高级功能，包括以下内容：
- en: '**Web interfaces**, to simplify the search of the artifacts and the management
    of them.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Web界面**，简化对工件及其管理的搜索。'
- en: '**Role-based access control and authenticated access**, providing differentiated
    access to different artifacts. A common example is that some artifacts can be
    changed only by certain groups, while others can be accessed in read-only mode,
    and maybe others have no access at all.'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基于角色的访问控制和认证访问**，为不同的工件提供差异化的访问。一个常见的例子是，某些工件只能由特定组更改，而其他工件可能只能以只读模式访问，也许还有其他完全无权访问。'
- en: Other **security features**, such as inspecting the code for known vulnerabilities
    (as we have seen in [*Chapter 12*](B16354_12_Final_JM_ePUB.xhtml#_idTextAnchor292),
    *Cross-Cutting Concerns*, when talking about security).
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他**安全功能**，例如检查代码中已知漏洞（正如我们在[*第12章*](B16354_12_Final_JM_ePUB.xhtml#_idTextAnchor292)，*横切关注点*，讨论安全问题时所看到的）。
- en: '**Versioning of the dependencies**, including the cleanup of older versions
    under configurable policies.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**依赖项的版本控制**，包括在可配置策略下清理旧版本。'
- en: '**Mirroring and hierarchy**, by providing the possibility of querying other
    artifact repositories over the internet to look up dependencies not available
    locally, and then mirroring it in order to avoid downloads when not necessary.
    A very famous repository available over the internet is **Maven Central**.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**镜像和层次结构**，通过提供通过互联网查询其他工件存储库以查找本地不可用的依赖项的可能性，然后镜像以避免在不需要时下载。互联网上可用的一个非常著名的存储库是**Maven
    Central**。'
- en: Two very famous implementations of Maven artifact repositories are JFrog Artifactory
    and Sonatype Nexus.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: Maven工件存储库的两个非常著名的实现是JFrog Artifactory和Sonatype Nexus。
- en: It's worth noting that the container technology (as discussed in [*Chapter 9*](B16354_09_Final_JM_ePUB.xhtml#_idTextAnchor230),
    *Designing Cloud-Native Architectures*) is often seen as an extension (but not
    a replacement) of Java artifacts. Indeed, a container image contains a complete
    application component, including dependencies at an OS level, where JVM and other
    middleware are needed. Moreover, a container image is immutable and can be uniquely
    identified (by using a version and a signature), so it is really similar to a
    Java artifact and raises similar needs in terms of management.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，容器技术（如在第[*第9章*](B16354_09_Final_JM_ePUB.xhtml#_idTextAnchor230)，*设计云原生架构*中讨论的）通常被视为Java工件的一个扩展（但不是替代品）。确实，容器镜像包含一个完整的应用程序组件，包括在需要JVM和其他中间件的操作系统的级别的依赖项。此外，容器镜像是不可变的，并且可以通过版本和签名唯一标识，因此它与Java工件非常相似，并在管理方面提出了类似的需求。
- en: For this reason, the ideas exposed about Java artifact repositories can be extended
    to container repositories. It's not incidental that both the mentioned technologies
    (Artifactory and Nexus) have extensions used for handling containers.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: Popular container repositories available online include Docker Hub and Quay.io.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: Completing the deployment
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we have looked at code compiling and the management of artifacts, it is
    now time to complete the deployment. This may include different steps, which ultimately
    aim to install the artifacts in the right places, perform some configurations,
    and execute the software. The details of these steps may vary heavily depending
    on the technology used:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: In the traditional Java world, there are custom ways to use Java application
    servers (such as WildFly, as seen in [*Chapter 7*](B16354_07_Final_JM_ePUB.xhtml#_idTextAnchor164),
    *Exploring Middleware and Frameworks*) depending on the application server used.
    Common ones are copying the application artifact in a specific folder or invoking
    a command-line utility that triggers the deployment process. More steps for configuring
    things (such as a connection to databases) may be needed and usually involve changes
    in configuration files or commands issued.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When using fat `.jar` applications (such as Spring Boot or Quarkus) in a non-containerized
    environment, the deployment process usually involves just copying the fat `.jar`
    in a specified location and running it using a command. This may be done with
    shell scripts, which can then address other steps (where relevant), such as the
    cleanup of the previous versions and the changes in configuration files.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In containerized environments, deployment basically involves copying the container
    (Kubernetes and Docker are usually configured to access remote container repositories)
    and executing a number of commands to make it run. In Kubernetes, this is almost
    entirely done by using `kubectl`.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we have seen, different technologies require slightly different ways to complete
    deployment and effectively distribute and run the software packages. If you consider
    that more steps can be required, including the configuration of external systems
    such as databases and IaaS or PaaS systems, it's often a good idea to orchestrate
    those steps in a unified way. This is one of the characteristics of CI/CD.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: Continuous integration/continuous delivery (and deployment)
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CI/CD is the process of automating most of the steps seen so far (and sometimes
    some more) in order to straighten the process and have a complete overview of
    it. Since the process includes many steps executed in a mostly sequential way,
    the tool providing it is commonly called a **pipeline**.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: 'A typical CI pipeline includes these steps, usually executed sequentially:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: Building the code (as seen in previous sections).
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Testing, usually limited to static code testing, unit testing, and some limited
    integration testing. Since deployment has not occurred yet, end-to-end testing
    is not possible in this phase.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'CD includes a few further steps, focused on deployment (also, in this case,
    usually executed in a sequence):'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: Versioning of software artifacts in repositories.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Deployment of artifacts from repositories to testing environments, including
    all the configuration needed. This may be done in ephemeral environments (as seen
    in previous sections).
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: End-to-end testing in such environments.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Deployment in other non-production environments, with the goal of user acceptance
    and/or performance testing.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here is a simplified sample pipeline:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.5 – A sample pipeline'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_13.05_B16354.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.5 – A sample pipeline
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding diagram, you can see a simplified pipeline example. There are
    a few steps (**Automated tests** and **Artifact archiving**) that are performed
    in parallel. Moreover, between **Staging Deployment** and **Prod Deployment**,
    some actions may happen, such as UAT and manual approval.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: CD is considered a further extension of the pipeline, and basically includes
    the deployment of the environments in production environments. This may happen
    in a completely automated way (with no manual intervention), or it may require
    manual approval by a release manager (in more traditional environments).
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: It's of course intended that a failure in any step usually means that the pipeline
    stops and the release fails. It's also worth noticing that deployment in production
    does not necessarily mean that the software is released and available to users,
    as we will see soon. But first, it is worth having a look at widespread pipeline
    implementations.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: Common CI/CD software implementations
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It's almost impossible to talk about CI/CD without mentioning Jenkins.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: Jenkins is a complete automation server, which is basically a synonym of CI/CD
    pipelines.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: It's written in Java and deployed in a servlet container (usually Tomcat). It's
    possible to define pipelines in Jenkins, using a domain-specific language, which
    describes each step with the required parameters. Through a system of plugins,
    steps in Jenkins can do many different things, including compilation using Maven,
    performing SSH commands, and executing test suites.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: Jenkins can then display the pipeline execution results, archive them, and optionally
    send notifications (as an example, in case of a build failure).
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: While still being widely used, Jenkins is nowadays famous for having a monolithic
    architecture (although some steps can be delegated to agents) and for being resource-intensive.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: Attempts to create alternative pipeline software, with a more modern design
    and better performances in a cloud environment, are currently underway. The most
    famous ones are Jenkins X and Tekton.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: Both of these software types, while created using different languages and frameworks,
    share the concept of implementing each step in a container, thereby improving
    horizontal scaling and reusability.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: Other famous implementations of CI/CD capabilities include Travis, GitLab, and,
    more recently, some cloud alternatives such as GitHub Actions.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: As we have said, regardless of the implementation, the CI/CD process can automate
    steps up to the production deployment. However, in order to make the software
    available to final users, the process requires some final steps.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: Releasing
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Releasing** is usually the final step of a complete CI/CD pipeline. The process
    can be performed, in simple environments, together with deployment in production.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: 'However, nowadays, it''s common to split deployment and releasing into two
    different steps, and this allows more sophisticated (and often safer) ways of
    releasing software versions to end users. To do so, the most basic ingredient
    is to have different versions of the software available in production at the same
    time and to route users to each version by following different criteria (which
    is done by operating at a network level, routing each request to the desired target
    version). Let''s look at some scenarios opened by this kind of technique:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '**Blue-green deployment**: Two versions of production environments (including
    database and other external systems) are released in production. This includes
    the version we want to release (identified as blue or green) and the previous
    version (identified by the color left, so either green or blue). The candidate
    release can then be tested in a real environment. If everything works as expected,
    the network traffic is then routed to the new version. A rollback can be easily
    performed at any time. In the next release, the same is done, replacing the previous
    version with the next one and changing the color-coding. The following diagram
    illustrates this:'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 13.6 – Blue-green deployment'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_13.06_B16354.jpg)'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.6 – Blue-green deployment
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '**Rolling releases**: This implies that our application components are provided
    on a set of identical instances (hosted on VMs or containers). When a release
    occurs, the **New version** is installed on a new instance and traffic starts
    to be sent to such new instances, too. Then, an **Old instance** is shut down
    (optionally draining all the pending connections). This process keeps going until
    all the instances are running on the new version, as shown here:'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 13.7 – Rolling releases'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_13.07_B16354.jpg)'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.7 – Rolling releases
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding diagram, each *circle* represents an instance (such as a VM
    or an application instance). The two steps are represented as a sample, but you
    can imagine that the **New version** starts from an instance, goes to two, and
    so on, and the **Old version** is progressively shut down, one instance at a time.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: While this can be a subtle difference, compared to the blue-green deployment,
    a rolling release can be seen as a kind of technical trick aiming to reduce downtime
    in releases, but it provides fewer guarantees if a rollback is needed. Moreover,
    since old and new instances coexist for a certain amount of time, issues may occur,
    both on the application and on the external systems (such as databases).
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '**Canary releases**: Basically, this is a variant of blue-green deployment.
    The new release is still provided alongside the previous version, but instead
    of switching traffic as a whole, this is done progressively, such as routing 1%
    of the users, then 2%, and so on, until all the users are running on the new release.
    This technique allows smoother releases and makes it easier to identify issues,
    if present (and optionally roll back), without impacting the whole customer base,
    as illustrated here:'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 13.8 – Canary releases'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_13.08_B16354.jpg)'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.8 – Canary releases
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding diagram, we can see just two sample phases, where we start
    routing **90%** of the traffic toward the **Old version**, and **10%** to the
    **New version**, and another one representing **1%** toward the **Old version**
    and **99%** toward the **New version**. Of course, in a real situation, you can
    imagine a constant flow going from 1% to 100% and vice versa. The name *canary*
    refers to the canary used by miners to identify gas leakages. In a similar way,
    bugs are identified sooner, by a small percentage of users, and it's possible
    to stop the release before impacting more users.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '**A/B testing**: Technically, this is identical to the blue-green deployment.
    The most important difference is that, in this case, we are evaluating two alternative
    versions. The two versions should not be considered as a previous one and a next
    one, but instead two slightly different variants of the same software that the
    business wants to test against real users. The following diagram shows this:'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 13.9 – A/B testing'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_13.09_B16354.jpg)'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.9 – A/B testing
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: Such variants are usually small changes in the user interface or other features,
    and the business aims to measure how those changes perform in the real world.
    The most common example is with online shops, where the business is willing to
    check whether changes in the purchase process (colors, position of the buttons,
    and the number of steps) enhance commercial performance.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: In A/B testing, the less performant version is usually discarded. It's also
    worth noticing that the users routed to each version can be chosen randomly, split
    by percentage (such as 50% for each version), or even selected by specific criteria
    (where available), such as the geographical location or the age of the user.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '**Traffic shadowing**: This is a bit less common than the other alternatives.
    It implies that a new release of the software is released in production, where
    users keep using the older version while the new version gets a copy of all the
    production traffic:'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 13.10 – Traffic shadowing'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_13.10_B16354.jpg)'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.10 – Traffic shadowing
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: It can be really useful for load testing in the case of major releases, but
    it may not work in some specific scenarios, and it's necessary to understand the
    impacts in any specific use case. As an example, if notifications (such as via
    email) are sent, we should ensure that they are not sent by both the old and the
    new systems, to minimize the impact on users.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: It's worth noticing that these kinds of release techniques (especially the simpler
    ones) are nothing new, and were also possible before modern cloud and microservice
    architectures. However, to use them in traditional environments, you may need
    to coordinate with external teams (such as the ones administering the network),
    while modern architectures (such as the ones based on public clouds, IaaS or PaaS)
    provide way more flexibility, allowing the creation of new instances on the fly,
    and changing network configurations favored by software-defined networking. In
    the next section, we are going to complete our view of the software life cycle
    by looking at some considerations regarding software maintenance.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: Maintenance
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Software maintenance** is usually a great part of software life. In my professional
    experience, it''s not uncommon for a project to be fully active (with a lot of
    new features and developments happening) for a couple of years, followed by many
    years of maintenance, which is focused on fixing bugs and keeping the product
    alive (without releasing any new features).'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: It goes without saying that the maintenance period can become more expensive
    than the building of the project. Moreover, but this is a consideration purely
    from an economic perspective, enterprises often find it easier to access the budget
    for building new applications (which is seen as money generating, or at least
    associated with business initiatives) than for maintaining and modernizing older
    ones (which is seen as IT for IT, which means that this is a project with no business
    impact, hence, purely a cost).
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: 'With that said, maintenance activities on existing applications can be roughly
    categorized into one of the following buckets:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '**Bug fixes** address defects in the software, which may be an existing issue
    in code or code behaving badly due to an external unforeseeable situation.'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Requests For Enhancement** (**RFEs**), which are targeted around covering
    new use cases that were not originally planned.'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Of course, both of these types of activities can then have an impact and an
    effort associated, which may help prioritize the implementation.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: 'The software maintenance process is then further categorized into four types,
    independent of the previous two categories:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: '**Corrective maintenance**, which must be done as a reaction to issues occurring
    and problems being reported. Think about a classic bug fixing activity as a consequence
    of the application behaving incorrectly.'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Adapting maintenance**, which aims at keeping the software correctly working
    in changing environments. Think about the application needing to be adapted to
    a newer version of the JVM, or to the release of a new browser.'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Perfecting maintenance**, which aims at making our application just better,
    in terms of performance, resource usage, maintainability, or other enhancements
    (such as a better user experience). This is often neglected, as it''s a proactive
    activity and nothing in the short term usually happens if it''s not done. However,
    it may have a big positive impact (also in terms of savings) because it can, of
    course, prevent issues in the future. Moreover, avoiding perfecting maintenance
    may mean growing the so-called *technical debt*, which means that more and more
    tasks (such as fine-tuning, refactoring, and enhancing test coverage) will pile
    up, becoming less and less manageable (and more expensive to tackle).'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Preventive maintenance**, which is really similar to the previous one, but
    revolves around fixing issues that have been identified (such as known bugs) before
    they become actual problems. As per the previous point, it risks being neglected
    and can cause technical debt if not handled properly.'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other than having a direct cost (because somebody needs to do it), all the maintenance
    categories may have several impacts. Indeed, such activities often involve software
    releases or configuration changes, and this may impact the application availability
    (and have a negative influence on the **Service Level Agreement** (**SLA**) established).
    There may even be legal agreements relegating maintenance activities to well-defined
    timeframes or allowing it only to solve high-severity issues.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, software maintenance can have an indirect impact because the activities
    (both enhancements and bug fixing) can change the application behavior and, in
    some cases, even leave the API exposed, hence, forcing the users to adapt to such
    changes or the developers to plan for implementing the retro compatibility.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: With that said, application maintenance should never be neglected. Instead,
    it should be planned (and financed) from the very beginning of the project and
    be constantly adjusted over time. Indeed, a project that is not correctly maintained
    can incur security issues or customer dissatisfaction, or also simply lose attractivity
    on the market. This will risk nullifying all the efforts made to design and implement
    the project.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: This was the last topic of this chapter. Let's now have a look at a summary
    of what we have learned.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have had an overview of many crucial phases of the software
    life cycle.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: Starting with SCM, we had a quick discussion of Git, which is the de facto standard
    over SCM. This allowed us to understand development models, with a focus on trunk-based
    development, which is common in CI/CD and DevOps-based projects.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: We also briefly discussed semantic versioning, which is a way to identify what
    changes to expect based on the release version numbering.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: We then entered the testing phase, starting with unit testing (and the inevitable
    description of JUnit, a standard for testing in Java). From unit testing, we moved
    on to other testing techniques, including integration, end-to-end, and UAT.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: Deploying was the next step. We discussed the steps needed to compile software
    and run it, including an overview of Apache Maven and artifact management. The
    next topic was CI/CD and pipelines with some consideration around automating most
    of the steps seen in this chapter.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: Then, we focused on releasing, which is the process of making the deployed software
    available to final users, and we saw many different options to do so, including
    blue-green and canary releases. Last but not least, we had an overview of maintenance
    activities (both bug fixes and enhancements) and why they are crucial for the
    overall success of our project.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to discuss monitoring and tracing, which are
    some core concepts for ensuring that our software is performing well in production,
    and for constantly understanding and governing what's happening.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Richard E. Silverman: *Git Pocket Guide*'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Konrad Gadzinowski: *Trunk-based Development vs. Git Flow* ([https://www.toptal.com/software/trunk-based-development-git-flow](https://www.toptal.com/software/trunk-based-development-git-flow))'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Hardik Shah: *Why Test Coverage is an Important Part of Software Testing?*
    ([https://www.simform.com/blog/test-coverage/](https://www.simform.com/blog/test-coverage/))'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Himanshu Sheth: *Code Coverage vs Test Coverage – Which Is Better?* ([https://dzone.com/articles/code-coverage-vs-test-coverage-which-is-better](https://dzone.com/articles/code-coverage-vs-test-coverage-which-is-better))'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Sten Pittet: *Continuous integration vs. continuous delivery vs. continuous
    deployment* ([https://www.atlassian.com/continuous-delivery/principles/continuous-integration-vs-delivery-vs-deployment](https://www.atlassian.com/continuous-delivery/principles/continuous-integration-vs-delivery-vs-deployment))'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Michael T. Nygard: *Release It!: Design and Deploy Production-Ready Software*'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Martin Fowler: *BlueGreenDeployment* ([https://martinfowler.com/bliki/BlueGreenDeployment.html](https://martinfowler.com/bliki/BlueGreenDeployment.html))'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
