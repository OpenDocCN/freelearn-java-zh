- en: Type inference
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Type inference with local variables, or `var`, is one of the most talked about,
    star feature of Java 10\. It reduces the verbosity of the language, without compromising
    on Java's dependable static binding and type safety. The compiler infers the type
    using the information that is already available in the code and adds it to the
    bytecode it generates.
  prefs: []
  type: TYPE_NORMAL
- en: Every new concept has its own set of benefits, limitations and complexities.
    Using type inference with `var` is no exception. As you work through this chapter,
    you'll see how using `var` will enthrall you, frustrate you and yet emerge triumphant.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What is type inference?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Type inference with `var`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do's and don'ts of working with `var`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Type inference versus dynamic binding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is type inference?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Imagine solving a riddle, like the one shown in the following image with multiple
    constraints in the form of hints. You resolve the constraints to derive the answer.
    You can compare type inference with generating constraints and then resolving
    them to determine the data types in a programming language. Type inference is
    the capability of compiler to determine the type of the data, by using the information
    that is already available in the code; literal values, method invocations and
    their declaration. For a developer, type inference reduces verbosity:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ddbd1594-2680-4b3f-b98f-efdeb5ac4bec.png)'
  prefs: []
  type: TYPE_IMG
- en: For your reference, answer to the preceding riddle is 87 (just invert the image
    and you'll find the numbers in a sequence).
  prefs: []
  type: TYPE_NORMAL
- en: Type inference is not new to Java. It has been taken to the next level with
    introduction of `var` with local variables in Java 10.
  prefs: []
  type: TYPE_NORMAL
- en: Let's deep dive using examples with `var`.
  prefs: []
  type: TYPE_NORMAL
- en: Type inference with var
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following lines of code show how you have been defining your local variable
    (and all other variables), prior to Java 10:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Starting with Java 10, using `var`, you can drop the mandatory explicit type
    in the declaration of local variables, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Do you think that the preceding code doesn't seem to offer a lot of benefits?
    What if, instead of the following?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'You could use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example drops quite a lot of letters on the left-hand side, making
    it leaner.
  prefs: []
  type: TYPE_NORMAL
- en: When you move away from stating the data type of the variables explicitly, the
    compiler takes over to determine or infer the variable type. Type inference is
    compiler's ability to evaluate the information already present in the code, like,
    the literal values, operations, method invocation or their declaration to determine
    the variable type. It follows a set of rules to infer the variable type. As a
    developer, when you choose type inference with `var`, you should be aware of compiler's
    inference algorithm and other rules, so that you don't get unexpected results.
  prefs: []
  type: TYPE_NORMAL
- en: With every new feature, you should adhere to a few rules, restrictions and try
    to follow best practices to benefit from it. Let's start with the compulsory initialization
    of the variables that are defined using `var`.
  prefs: []
  type: TYPE_NORMAL
- en: Type inference with `var` is not dynamic typing; Java is still a strong static
    typed language. Usage of var makes your code leaner; you can drop the type of
    the local variable from its definition.
  prefs: []
  type: TYPE_NORMAL
- en: Compulsory non-null initialization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A local variable defined with `var` must be initialized with its declaration,
    or else the code won''t compile. The compiler can''t infer the type of an uninitialized
    variable or a variable that is assigned a null value. The following code won''t
    compile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The following image illustrates what would happen if the un-initialized variable
    `age` went to seek entrance to Mr. Java compiler place. The compiler won''t let
    it in:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a6d20187-0b64-4afc-9f03-a0ffa1090cfc.png)'
  prefs: []
  type: TYPE_IMG
- en: Variable definition using `var` must always be accompanied with its initialization;
    or else the code will fail to compile.
  prefs: []
  type: TYPE_NORMAL
- en: Local variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The usage of `var` is limited to the local variables. These variables are used
    to store intermediate values and have the shortest life span, when compared to
    the instance and static variables. The local variables are defined within a method,
    constructor or initializer blocks (both instance or static). Within a method or
    initializer, they can be defined within constructs such as `if`-`else` loops,
    `switch` statements or `try-with-resources` construct. Here''s an example of `Person`
    class, which defines local variables, at multiple places:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Since that''s a lot of places, you might find it difficult to remember them.
    We just requested Google Maps to find all its possible occurrences and this is
    what we got:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/be886487-7f1d-4450-9f41-848e72490309.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This chapter includes a couple of code check exercises for you to quickly try
    out a new topic. The exercises use names of two hypothetical programmers Pavni
    and Aarav.
  prefs: []
  type: TYPE_NORMAL
- en: Code check – part 1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of our programmers, Aarav, refactored code by his team member, Pavni. The
    code no longer outputs the `char` and its corresponding ASCII numbers of the values
    stored by a `char` array. Can you help Aarav? Here''s the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Answer to code check—`var` type can't be used to specify the type of exceptions
    in the catch handler `(var e)`.
  prefs: []
  type: TYPE_NORMAL
- en: Using var with primitive data types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This seems to be simplest of all, but appearances can be deceptive. Try to
    execute the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'You might assume that an integer literal value (`9_009_998_992_887` in this
    case) that doesn''t fit into the range of primitive `int` type will be inferred
    to be a `long` type. However, this doesn''t happen. Since the default type of
    an integer literal value is `int`, you''ll need to append the preceding value
    with the suffix `L` or `l`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, for an `int` literal value to be inferred as a `char` type, you
    must use an explicit cast, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'What is the result when you divide `5` by `2`? Did you say `2.5`? But this
    isn''t how it (always) works in Java! When integer values are used as operands
    in division, the result is not a decimal number, but an integer value. The fraction
    part is dropped to get the result as an integer. Though this is usual, this might
    seem to be weird, when you expect the compiler to infer the type of your variable.
    Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Though these cases aren't specifically related to the `var` type, developer's
    assumption that the compiler will infer a specific type, results in a mismatch.
    Here's a quick image to help you remember this.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5e881452-9834-4f24-93d1-259747a883af.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The default type of integer literals is `int` and of floating point numbers
    is `double`. Assigning `100` to a variable defined with `var` will infer its type
    as `int`; not `byte` or `short`.
  prefs: []
  type: TYPE_NORMAL
- en: In an arithmetic operation, if either of the operand is `char`, `byte`, `short`
    or `int`, the result is at least promoted to an `int`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, for an arithmetic operation that includes at least one operand as
    a `long`, `float`, or `double` value, the result is promoted to type `long`, `float`
    or `double` respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Rules of implicit widening of primitive variables play an important role to
    understand how the Java compiler infers variables with primitive values.
  prefs: []
  type: TYPE_NORMAL
- en: Type inference with derived classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With JDK 9 and previous versions, you could define a variable of base class
    and assign to it an instance of its derived class. The members that you could
    access using this variable was limited to the ones that were defined in the base
    class. This is no longer the case with `var`; since the type of the variable is
    inferred using the specific type of the instance that is assigned to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine the `Child` class extends  the `Parent` class. When you create a local
    variable and assign it an instance of the `Child` class, the type of the variable
    is inferred as `Child`. This looks simple. Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'What happens, if you assign the value of the variable `obj` using a method
    that can return instance of class `Child` or `Parent`? Here''s the modified code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the type of the instance returned by method `getObject()`
    can't be determined before the code execution. During compilation, type of variable
    `obj` is inferred as `Parent`; return type of the `getObject()` method. Since
    the `Parent` class doesn't define the `stand()`, `main()` method fails to compile.
  prefs: []
  type: TYPE_NORMAL
- en: Type of variables defined using `var` are inferred at compile time. If the return
    type of a method is used to assign a variable defined using `var`, its inferred
    type is the return type of the method; not the type of instance returned during
    run time.
  prefs: []
  type: TYPE_NORMAL
- en: Type inference – with interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s extend our learning from the preceding section to usage of interfaces.
    Imagine a `Child` class implements an `MarathonRunner` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s define a `obj` local variable assigning it an instance of the `Child` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'If the same variable is initialized using a method whose return type is `MarathonRunner`,
    its inferred type is `MarathonRunner` (irrespective of the type of the instance
    returned by it):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Using var with arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Using `var` doesn''t imply just dropping the type of the local variable; what
    remains should enable the compiler to infer its type. Imagine a method which defines
    an array of `char` type as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'You can''t drop its type and define it using either of the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s one of the ways to include relevant information to enable the compiler
    to infer the type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Seems like the Java compiler is already struggling with this assumption by
    the programmers, as shown in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/474a407f-8ba4-4eb8-a9a0-edd3fcd0397f.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You can't just drop the data types to use `var`. What remains should enable
    the compiler to infer the type of the value being assigned.
  prefs: []
  type: TYPE_NORMAL
- en: Type inference with generics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The motivation of introducing generics was to include type safety. It enabled
    developers to specify their intention of using classes, interfaces and collection
    classes with fixed or range of types. Violations in these intentions were enforced
    with compilation errors, rather than runtime exception; raising compliance bar.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, here''s how you would define an `ArrayList` to store `String`
    values (repeating `<String>` is optional on the right-hand side of the assignment):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'However, replacing `List<String>` with `var` will put type safety in generics
    at stake:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code allows addition of multiple data types to `names`, which
    is not the intention. With generics, the preferred approach is to make relevant
    information available to the compiler, so that it can infer its type correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: When using `var` with generics, ensure you pass relevant data types within the
    angular brackets on the right-hand side of the assignment; so that you don't lose
    type safety.
  prefs: []
  type: TYPE_NORMAL
- en: Time for our next code check.
  prefs: []
  type: TYPE_NORMAL
- en: Code check – part 2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of our programmers, Pavni, tried using `var` with generics and collection
    classes, but her code doesn't seem to output the sorted collection of pens. Can
    you help?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Answer to code check—the issue is trying to modify the immutable collection,
    using `Collections.sort()`. This is to emphasize that all issues are not related
    to the usage of `var`.
  prefs: []
  type: TYPE_NORMAL
- en: Passing inferred variables to a method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Though the usage of `var` is limited to declaration of local variables, these
    variables (both primitive and reference) can be passed to methods as values. The
    inferred types and the types expected by the methods must match to let the code
    compile.
  prefs: []
  type: TYPE_NORMAL
- en: In the following example code, the `Child` class implements the `MarathonRunner`
    interface. The `start()` method in the `Marathon` class expects the `MarathonRunner`
    object (instances of class implementing this interface) as its method argument.
    Inferred type of variable, `aRunner` is `Child`. Since the `Child` class implements
    `MarathonRunner`, `aRunner` can be passed to the `start()` method, the inferred
    type of `aRunner` (`Child`) and expected type of `start()` (`MarathonRunner`)
    match, allowing the code to compile.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: As long as the inferred type of a variable matches with the type of method parameter,
    it can be passed to it as an argument.
  prefs: []
  type: TYPE_NORMAL
- en: Reassigning value to inferred variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As applicable to all non-final variables, you can reassign a value to inferred
    variables. Just ensure that the reassigned value matches with the its inferred
    type. The type of a variable is inferred just once.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The type of a local variable defined using `var` is inferred only once.
  prefs: []
  type: TYPE_NORMAL
- en: Explicit casting with inferred variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Imagine a co-programmer assigned `29` to an inferred local variable, say `age`,
    assuming the compiler would infer the type of variable `age` as `byte`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'However, the compiler would infer the type of the variable `age` as `int`,
    since the default type of an integer literal value is `int`.  To fix the preceding
    assumption, you can either use the explicit data type or override compiler''s
    default inference mechanism by using explicit casting, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: By using explicit casting type inference, you can override the compiler's default
    type inference mechanism. This might be required to fix the assumptions in existing
    code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, you can use explicit casting with other primitive data types like
    `char` and `float`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Without the explicit casting in the preceding examples, variables that are assigned
    integer literal values would be inferred as `int` and decimal as `double`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example is of explicit casting with reference variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Use explicit casting with type inference to fix any existing assumptions. I
    wouldn't recommend using explicit casting to initialize inferred variables; it
    beats the purpose of using `var`.
  prefs: []
  type: TYPE_NORMAL
- en: Assigning null with explicit casting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Again, though it doesn''t make sense to use explicit casting will null to assign
    it to a `var` type, it is a valid code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Though the preceding line of code is correct syntax wise, it is a bad coding
    practice. Avoid it!
  prefs: []
  type: TYPE_NORMAL
- en: Type inference in previous versions of Java
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Though `var` takes inference to a new level in Java 10, the concept of type
    inference existed in its previous versions. Let's see examples of type inference
    in the previous versions of Java.
  prefs: []
  type: TYPE_NORMAL
- en: Type inference in Java 5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Generics introduced a type system to enable the developers to abstract over
    types. It restricted a class, interface or method to work with instances of specified
    types, providing compile type safety. Generics were defined to add compile time
    safety to the Collection framework. Generics enables programs to detect certain
    bugs during compilation so they can't creep into the run time code. It's easier
    to fix a bug during development phase than fixing it in production.
  prefs: []
  type: TYPE_NORMAL
- en: 'Java used type inference for generic method type arguments in Java 5\. Instead
    of the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'You could use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Type inference in Java 7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Java 7 introduced type inference for constructor arguments with generics. This
    essentially means that the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'can be replaced with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding shouldn''t be confused with the following, which is trying to
    mix the generics with the raw types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Java 7 also allowed type inference to invoke generic methods. For a generic
    method, say, `print()` defined in a class, say, `MyClass`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'It can be called as follows in either of the following ways (the third line
    of code uses type inference to infer type of argument passed to the method `print()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Type inference in Java 8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Java 8 introduced functional programming in Java with lambda functions. The
    lambda expressions can infer the type of it''s formal parameters. So instead of
    the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'You can write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Challenges
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Usage of `var` isn't without its share of challenges, both for the developers
    of the Java language and for its users. Let's start with the reason why `var`
    has limited usage.
  prefs: []
  type: TYPE_NORMAL
- en: Limiting the scope of failed assumptions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you know, the usage of `var` types is limited to the local variables in Java.
    They are not allowed in public API, as method parameters or as return type of
    methods. Some languages support type inference for all types of variables. Java
    may allow you to do so in future (who knows? Will it happen? If yes, when?).
  prefs: []
  type: TYPE_NORMAL
- en: However, there are strong reasons for limiting the scope of the inferred variables,
    to spot the errors due to mismatch of assumptions and the actual, early on. The
    contracts of the public API's should be explicit. Type inference with public API
    would allow for these errors to be caught and corrected much later.
  prefs: []
  type: TYPE_NORMAL
- en: The contract of the public API should be explicit, they shouldn't depend on
    type inference.
  prefs: []
  type: TYPE_NORMAL
- en: Here's a practical example of how mismatch in the assumptions and actual can
    lead to errors.
  prefs: []
  type: TYPE_NORMAL
- en: Recently my child was travelling overseas with her school for a student exchange
    program. The school asked me to send back a set of photographs for her visa application.
    I called up my photographer, requesting him to print photos for visa (specifying
    the country). Two days later, the school asked me to resubmit the photos because
    the earlier photos didn't match the rules.
  prefs: []
  type: TYPE_NORMAL
- en: What went wrong? Neither the school nor I were explicit with the specifications
    of the photograph. The school assumed that I would know the specifications; I
    assumed that the photographer would know the specifications (because he was doing
    it for years). In this case, at least one person assumed the result to conform
    to a specific output, without explicitly specifying the output. Without an explicit
    contract, there is always a scope of mismatch of expectation and actual.
  prefs: []
  type: TYPE_NORMAL
- en: Despite the confusion, the mistake was spotted and corrected before the applications
    were submitted to the embassy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a fun image to reason why the usage of type inference is limited to
    local variables, when the local instance and static variables were competing in
    a race, only the local variables could make it to the finish line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/47bc58b4-f8ac-4287-a2cc-9d746f7e5a9b.png)'
  prefs: []
  type: TYPE_IMG
- en: Breaking existing code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Code that used `var` as name of a class, interface, method, method parameters
    or variables, will no longer compile with JDK 10 and later releases. Here''s an
    example of code that uses `var` at multiple places; and won''t compile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Its important to test your production code with the latest Java release versions,
    even if you are not planning to deploy your production code to them. It will help
    iron-out any compatibility issues with your production code; helping to migrate
    it to a future Java version release.
  prefs: []
  type: TYPE_NORMAL
- en: Non-denotable types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Java types that you can use in a program, like `int`, `Byte`, `Comparable` or
    `String` are called **denotable types**. The types used by a compiler internally,
    like, subclass of an anonymous class, which you can't write in your program, are
    called non-denotable types.
  prefs: []
  type: TYPE_NORMAL
- en: Till now, type inference with variables seemed to be quite easy to implement,
    just get the information about the values passed to a method, returned from a
    method, and infer the type. But it isn't as simple as that, when it comes to inference
    with non-denotable types—`null` type, intersection types, anonymous class type
    and the capture types.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, what do you think is the type of the following inferred variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The preceding cases are not one of the types. They are neither banned from being
    inferred, nor are they normalized to a denotable type.
  prefs: []
  type: TYPE_NORMAL
- en: Meaningful variable names
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A new feature should be used responsibly. When you drop the explicit data type
    with a variable name, the name takes the center stage. With inferred types, it
    is your responsibility to use descriptive and appropriate variable names, so that
    they make more sense in code. As you know, a piece of code is written once, but
    read many times.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following line of code won''t make much sense to you after
    some time, or to your team members (especially with a big or distributed team):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Key questions are - what is the variable `i` used for, what does the method
    `getData()` return? Imagine the plight of the maintenance team that will work
    with this code, after you leave.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, it doesn''t help to define variables names that are mismatched with their
    purpose. For example, it doesn''t make much sense to create a connection object
    named `database` and assign a `URL` instance to it, or, say, to define a variable
    with the name `query` and assign a `Connection` instance to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: When you drop the explicit type of a local variable, its name takes the center
    stage. Choose their name carefully and responsibly, which makes their purpose
    unambiguous.
  prefs: []
  type: TYPE_NORMAL
- en: Code refactoring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Type inference with `var` has been introduced to reduce the verbosity of the
    Java language. It will help the programmers to type less in their methods. The
    compiler infers the type of the variables declared using `var` and inserts it
    in the byte code.
  prefs: []
  type: TYPE_NORMAL
- en: I see no reason of refactoring existing or legacy code to replace explicit data
    types in the methods, replacing them with `var`. It won't offer any benefits in
    any dimension.
  prefs: []
  type: TYPE_NORMAL
- en: Don't refactor your existing or legacy code, replacing existing explicit types
    in methods with `var`. It doesn't offer any benefits.
  prefs: []
  type: TYPE_NORMAL
- en: Type inference versus dynamic binding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Type inference with `var` isn't pushing Java towards the dynamic binding domain.
    Java is still a strongly typed static language. Type inference in Java is syntactic
    sugar. The compiler infers the type and adds it to the byte code. In dynamic binding,
    a variable type is inferred at run time. This can lead to more errors being discovered,
    later.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging an application is a costly affair, in terms of the time and efforts
    required to find a bug and then fix it. The sooner you can detect a bug, the easier
    it is to fix it. It is easier to fix a bug during unit testing than it is to fix
    the same bug during integration testing, or say, when it shows up months later
    after an application goes live. A bug is easier to fix in the development phase
    than it is to fix in the production of maintenance stage.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you covered local variable inference, or `var`, introduced
    in Java 10\. The `var` type enables you to drop the explicit data type for a local
    variable in a method. You covered the various do's and don'ts for the usage of
    `var`. Limited to local variables, variables defined using `var` must be initialized
    with a non-null value. They can be used with all type of variables—primitives
    and objects. Variables defined with `var` can also be passed to methods and returned
    from methods, method declaration compatibility rules apply.
  prefs: []
  type: TYPE_NORMAL
- en: To avoid risking your type safety with generics, ensure you pass relevant information,
    while using `var` with generics. Though it doesn't make a lot of sense, using
    explicit casting is allowed with variables defined using `var`. You also covered
    type inference existed in previous versions of Java, namely, 5, 7, and 8\. Towards
    the end, you also covered why type inference is limited to the local variables
    and not allowed in the public API.
  prefs: []
  type: TYPE_NORMAL
- en: Usage of meaning variable names has always been recommended and it is important.
    With `var`, it becomes more important. Since `var` offers syntactic sugar, it
    doesn't make any sense to refactor your existing or legacy code to use `var` in
    it.
  prefs: []
  type: TYPE_NORMAL
