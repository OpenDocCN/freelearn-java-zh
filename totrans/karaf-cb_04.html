<html><head></head><body><div class="chapter" title="Chapter&#xA0;4.&#xA0;Hosting a Web Server with Pax Web"><div class="titlepage"><div><div><h1 class="title"><a id="ch04"/>Chapter 4. Hosting a Web Server with Pax Web</h1></div></div></div><p>In this chapter, we will cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Installing Pax modules in Apache Karaf</li><li class="listitem" style="list-style-type: disc">Installing extended Http Service in Apache Karaf</li><li class="listitem" style="list-style-type: disc">Configuring Pax Web modules deployed in Apache Karaf</li><li class="listitem" style="list-style-type: disc">Building a Http Service project to host in Apache Karaf</li><li class="listitem" style="list-style-type: disc">Building a Http Service with the Whiteboard pattern in Apache Karaf</li><li class="listitem" style="list-style-type: disc">Building an application with custom HttpContext with Apache Karaf</li><li class="listitem" style="list-style-type: disc">Building a standard web project to host in Apache Karaf</li><li class="listitem" style="list-style-type: disc">Configuring security for a web application in Apache Karaf</li><li class="listitem" style="list-style-type: disc">Binding a web project to a specific host in Apache Karaf</li><li class="listitem" style="list-style-type: disc">Building a Servlet 3.0 annotated web application with Apache Karaf</li><li class="listitem" style="list-style-type: disc">Creating a CDI web application with Apache Karaf</li></ul></div><div class="section" title="Introduction"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec41"/>Introduction</h1></div></div></div><p>This chapter explains how to enhance your Apache Karaf with Pax Web to serve as a web container. The OPS4j Pax Web project is an OSGi R4 Http Service and Web Application (refer to <span class="emphasis"><em>Chapter 128</em></span>, <span class="emphasis"><em>OSGi Enterprise Release 4</em></span>) implementation. It extends the Http Service with better support for servlet, filters, listeners, error pages, JavaServer Pages (JSPs), and more in order to support the latest Java Servlet spec.</p><p>The <a id="id279" class="indexterm"/>standard features of Karaf contain a set of options to install Pax Web in different flavors. There are options for:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A basic Http Service</li><li class="listitem" style="list-style-type: disc">An enhanced Http Service with support for the Whiteboard pattern and JSPs</li><li class="listitem" style="list-style-type: disc">A <a id="id280" class="indexterm"/>full-blown web container configuration <a id="id281" class="indexterm"/>with support for<a id="id282" class="indexterm"/> <span class="strong"><strong>Web Application Archive</strong></span> (<span class="strong"><strong>WAR</strong></span>) and <span class="strong"><strong>Web Application Bundle</strong></span> (<span class="strong"><strong>WAB</strong></span>) files</li></ul></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip22"/>Tip</h3><p>Readers interested in obtaining a deeper understanding of Apache Karaf in combination with Pax Web should consult the OPS4j community. You'll find a lot more samples concerning the usage of Pax Web in general and Apache Karaf specialties as a whole.</p></div></div></div></div>
<div class="section" title="Installing Pax modules in Apache Karaf"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec42"/>Installing Pax modules in Apache Karaf</h1></div></div></div><p>To <a id="id283" class="indexterm"/>start with Http Service, you will need to<a id="id284" class="indexterm"/> install one of the features mentioned earlier. This recipe will guide you through the installation of the different extensions of Pax Web and how it works.</p><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec126"/>How to do it…</h2></div></div></div><p>To install the basic Http Service, start your Apache Karaf server and install the Http Service feature via the console using the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>karaf@root()&gt; feature:install http</strong></span>
</pre></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec127"/>How it works…</h2></div></div></div><p>After installing this feature, list the bundles with an <code class="literal">la</code> command. This will show you the following additional bundles to your Karaf instance:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>78 | Active   |  30 | 2.2.0           | Apache ServiceMix :: Specs :: Activation API 1.4</strong></span>
<span class="strong"><strong>79 | Active   |  30 | 1.0            | Servlet 3.0</strong></span>
<span class="strong"><strong>80 | Active   |  30 | 1.4.4          | JavaMail API (compat)</strong></span>
<span class="strong"><strong>81 | Active   |  30 | 1.1.1          | geronimo-jta_1.1_spec</strong></span>
<span class="strong"><strong>82 | Active   |  30 | 1.0.1          | Annotation 1.1</strong></span>
<span class="strong"><strong>83 | Active   |  30 | 1.1            | Java Authentication SPI for Containers</strong></span>
<span class="strong"><strong>84 | Active   |  30 | 8.1.14         | Jetty :: Aggregate :: All Server</strong></span>
<span class="strong"><strong>85 | Active   |  30 | 1.6.0          | OPS4J Pax Swissbox :: OSGi Core</strong></span>
<span class="strong"><strong>86 | Active   |  30 | 1.6.0          | OPS4J Pax Swissbox :: Optional JCL</strong></span>
<span class="strong"><strong>87 | Active   |  20 | 3.16.0         | Apache XBean OSGI Bundle Utilities</strong></span>
<span class="strong"><strong>88 | Active   |  20 | 3.16.0         | Apache XBean :: ASM 4 shaded (repackaged)</strong></span>
<span class="strong"><strong>89 | Active   |  20 | 3.16           | Apache XBean :: Reflect</strong></span>
<span class="strong"><strong>90 | Active   |  20 | 3.16.0         | Apache XBean :: Finder shaded (repackaged)</strong></span>
<span class="strong"><strong>91 | Active   |  30 | 3.1.0          | OPS4J Pax Web - API</strong></span>
<span class="strong"><strong>92 | Active   |  30 | 3.1.0          | OPS4J Pax Web - Service SPI</strong></span>
<span class="strong"><strong>93 | Active   |  30 | 3.1.0          | OPS4J Pax Web - Runtime</strong></span>
<span class="strong"><strong>94 | Active   |  30 | 3.1.0          | OPS4J Pax Web - Jetty</strong></span>
<span class="strong"><strong>95 | Active   |  30 | 3.0.1          | Apache Karaf :: HTTP :: Core</strong></span>
<span class="strong"><strong>96 | Active   |  30 | 3.0.1          | Apache Karaf :: HTTP :: Commands</strong></span>
</pre></div><p>Of course, it <a id="id285" class="indexterm"/>will install the needed Jetty <a id="id286" class="indexterm"/>server to serve the web content and the four basic Pax Web bundles needed to have a minimal Http Service. These four bundles contain the API, Services SPI, runtime, and the Jetty server wrapper, which takes care of starting the underlying Jetty instance. All of these bundles installed by the HTTP feature give you a few possible ways to use the Http Service, but nothing else. This scenario is usually good enough for running simple servlets and the Felix Web Console.</p><p>On top of this basic installation, Karaf already provides a simple command to inspect the currently installed servlets. It will give you an overview of the servlets and the registered aliases. The following is the command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>karaf@root()&gt; http:list</strong></span>
<span class="strong"><strong>ID | Servlet | Servlet-Name | State | Alias | Url</strong></span>
<span class="strong"><strong>-------------------------------------------------</strong></span>
</pre></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec128"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Building a Http Service project to host in Apache Karaf</em></span> recipe</li></ul></div></div></div>
<div class="section" title="Installing extended Http Service in Apache Karaf"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec43"/>Installing extended Http Service in Apache Karaf</h1></div></div></div><p>Usually, just <a id="id287" class="indexterm"/>using the basic Http Service is<a id="id288" class="indexterm"/> not enough anymore these days, especially when it comes to serving JSP or complete web applications. So, a better usable container is needed.</p><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec129"/>How to do it…</h2></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">To install the HTTP Whiteboard feature, start your Apache Karaf server and install the HTTP Whiteboard feature via the console using the following command:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>karaf@root()&gt; feature:install http-whiteboard</strong></span>
</pre></div></li><li class="listitem">Transform your Apache Karaf server into a full-featured web container using the following command:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>karaf@root()&gt; feature:install war</strong></span>
</pre></div></li></ol></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec130"/>How it works…</h2></div></div></div><p>The <a id="id289" class="indexterm"/>Whiteboard feature installs another <a id="id290" class="indexterm"/>two Pax Web bundles. These bundles give you JSP and Whiteboard support. These two bundles are shown in the following command-line output:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>97 | Active   |  30 | 3.1.0       | OPS4J Pax Web - Jsp Support</strong></span>
<span class="strong"><strong>98 | Active   |  30 | 3.1.0       | OPS4J Pax Web - Extender - Whiteboard</strong></span>
</pre></div><p>This enables Pax Web to deploy and serve JSPs registered to the now available WebContainer interface. This interface is an extension to the standardized Http Service. The Whiteboard extender is another approach to register services in OSGi.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip23"/>Tip</h3><p>More <a id="id291" class="indexterm"/>details about the Whiteboard pattern can be found at <a class="ulink" href="http://www.osgi.org/wiki/uploads/Links/whiteboard.pdf">http://www.osgi.org/wiki/uploads/Links/whiteboard.pdf</a>.</p></div></div><p>With the WAR feature, the installation of Pax Web is complete. This includes the WAR extender, which is used to install OSGi WAB files, and the Pax URL WAR handler, which takes care of transforming WAR archives into WAB files. These additional bundles are listed as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>99  | Active   |  30 | 3.1.0       | OPS4J Pax Web - Extender - WAR</strong></span>
<span class="strong"><strong>100 | Active   |  30 | 3.1.0       | OPS4J Pax Web - FileInstall Deployer</strong></span>
<span class="strong"><strong>101 | Active   |  30 | 1.4.2       | OPS4J Pax Url - war</strong></span>
<span class="strong"><strong>102 | Active   |  30 | 1.4.2       | OPS4J Pax Url - Commons</strong></span>
<span class="strong"><strong>103 | Active   |  30 | 1.6.0       | OPS4J Pax Swissbox :: Bnd Utils</strong></span>
<span class="strong"><strong>104 | Active   |  30 | 1.6.0       | OPS4J Pax Swissbox :: Property</strong></span>
<span class="strong"><strong>105 | Active   |  30 | 1.43.0      | aQute Bundle Tool Library</strong></span>
<span class="strong"><strong>106 | Active   |  30 | 3.0.1       | Apache Karaf :: Web :: Core</strong></span>
<span class="strong"><strong>107 | Active   |  30 | 3.0.1       | Apache Karaf :: Web :: Commands</strong></span>
</pre></div><p>With the Karaf WAR feature comes another command; the <code class="literal">web:*</code> commands help to analyze the state of the installed WARs. An example command is as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>karaf@root()&gt; web:list</strong></span>
<span class="strong"><strong>ID | State | Web-State | Level | Web-ContextPath | Name</strong></span>
<span class="strong"><strong>-------------------------------------------------------</strong></span>
</pre></div><p>These <a id="id292" class="indexterm"/>commands also help to control the <a id="id293" class="indexterm"/>status of a web bundle. Consider the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>karaf@root()&gt; web:</strong></span>
<span class="strong"><strong>web:list     web:start    web:stop</strong></span>
</pre></div><p>The <code class="literal">web:list</code> command <a id="id294" class="indexterm"/>shows a list of the installed WAR files and gives a listing of the state and <code class="literal">Web-ContextPath</code>.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec131"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Building a Http Service with the Whiteboard pattern in Apache Karaf</em></span> recipe</li><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Building a standard web project to host in Apache Karaf</em></span> recipe</li><li class="listitem" style="list-style-type: disc">For more details on how the WAR URL handler works, visit <a class="ulink" href="https://github.com/jgoodyear/ApacheKarafCookbook/tree/master/chapter4">https://github.com/jgoodyear/ApacheKarafCookbook/tree/master/chapter4</a></li></ul></div></div></div>
<div class="section" title="Configuring Pax Web modules deployed in Apache Karaf"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec44"/>Configuring Pax Web modules deployed in Apache Karaf</h1></div></div></div><p>Pax Web<a id="id295" class="indexterm"/> uses Jetty as the underlying <a id="id296" class="indexterm"/>web container. The OSGi Http Service specification defines a set of parameters for configuration of the Http Service. In addition to these standard configuration parameters, the Pax Web-specific parameters are configurable. On top of those configuration parameters, it's also possible to configure Jetty itself for further needs.</p><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec132"/>How to do it…</h2></div></div></div><p>The configuration of the Http Service is done through the Configuration Admin service. During the installation of the Http Service, the configuration is also set for the service PID <code class="literal">org.ops4j.pax.web</code>, as shown in the following code snippet:</p><div class="informalexample"><pre class="programlisting">javax.servlet.context.tempdir = ${karaf.data}/pax-web-jsp
org.ops4j.pax.web.config.file = ${karaf.home}/etc/jetty.xml
org.osgi.service.http.port = 8181</pre></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec133"/>How it works…</h2></div></div></div><p>This<a id="id297" class="indexterm"/> basic set of configuration defines<a id="id298" class="indexterm"/> the HTTP port the Jetty server is listening to, the servlet <code class="literal">temp</code> directory to create JSP servlet files, and the location of the optional <code class="literal">jetty.xml</code> file for enhanced Jetty configuration.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip24"/>Tip</h3><p>Documentation <a id="id299" class="indexterm"/>on how to configure the <code class="literal">jetty.xml</code> file can be found at <a class="ulink" href="http://wiki.eclipse.org/Jetty/Reference/jetty.xml">http://wiki.eclipse.org/Jetty/Reference/jetty.xml</a>. Make sure that you also take a look at the specialties of running Jetty with Pax Web at <a class="ulink" href="https://ops4j1.jira.com/wiki/display/paxweb/Advanced+Jetty+Configuration">https://ops4j1.jira.com/wiki/display/paxweb/Advanced+Jetty+Configuration</a>.</p></div></div></div><div class="section" title="There's more…"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec134"/>There's more…</h2></div></div></div><p>Additionally, a configuration file for all configuration parameters can be placed in the <code class="literal">etc</code> folder. It's named like the service PID appended by the <code class="literal">.cfg</code> suffix. The following is an excerpt from the <code class="literal">org.ops4j.pax.web.cfg</code> configuration file. This complete configuration file and also the <code class="literal">jetty.xml</code> file can be found at <a class="ulink" href="https://github.com/jgoodyear/ApacheKarafCookbook/blob/master/chapter4/chapter4-recipe2">https://github.com/jgoodyear/ApacheKarafCookbook/blob/master/chapter4/chapter4-recipe2</a>.</p><div class="informalexample"><pre class="programlisting">org.osgi.service.http.enabled = true
org.osgi.service.http.port = 8181
org.osgi.service.http.connector.name = default
org.osgi.service.http.useNIO = true
org.osgi.service.http.secure.enabled = true
org.osgi.service.http.port.secure = 8443
org.osgi.service.http.secure.connector.name = secureDefault
javax.servlet.context.tempdir = ${karaf.data}/pax-web-jsp
org.ops4j.pax.web.config.file=${karaf.base}/etc/jetty.xml
…</pre></div><p>The following code configures extra JSP parameters:</p><div class="informalexample"><pre class="programlisting">org.ops4j.pax.web.jsp.scratch.dir = 
org.ops4j.pax.web.jsp.check.interval = 300
…
org.ops4j.pax.web.jsp.precompilation = false
…</pre></div><p>The<a id="id300" class="indexterm"/> following is the configuration<a id="id301" class="indexterm"/> for the NCSA log format:</p><div class="informalexample"><pre class="programlisting">org.ops4j.pax.web.log.ncsa.enabled = false
org.ops4j.pax.web.log.ncsa.format = yyyy_mm_dd.request.log
org.ops4j.pax.web.log.ncsa.retaindays = 90
org.ops4j.pax.web.log.ncsa.append = true
org.ops4j.pax.web.log.ncsa.extended = true
org.ops4j.pax.web.log.ncsa.dispatch = false
org.ops4j.pax.web.log.ncsa.logtimezone = GMT
org.ops4j.pax.web.log.ncsa.directory = 
org.ops4j.pax.web.log.ncsa.latency = false
org.ops4j.pax.web.log.ncsa.cookies = false
org.ops4j.pax.web.log.ncsa.server = false</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note06"/>Note</h3><p>For details <a id="id302" class="indexterm"/>about the NCSA log format, refer to <a class="ulink" href="http://en.wikipedia.org/wiki/Common_Log_Format">http://en.wikipedia.org/wiki/Common_Log_Format</a>.</p></div></div><p>The following configuration is used to have different virtual hosts and connectors:</p><div class="informalexample"><pre class="programlisting">org.ops4j.pax.web.default.virtualhosts = 
org.ops4j.pax.web.default.connectors = </pre></div><p>For more details, see the <span class="emphasis"><em>Binding a web project to a specific host in Apache Karaf</em></span> recipe.</p></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec135"/>How it works…</h2></div></div></div><p>This configuration excerpt shows you the default configuration that is already internally used by Pax Web. If needed, some or all of these configuration parameters can be set either in the Karaf shell or be placed in the <code class="literal">org.ops4j.pax.web.cfg</code> file in the <code class="literal">etc</code> folder. A quick example of how to set the HTTP port via shell commands is as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>karaf@root()&gt; config:edit org.ops4j.pax.web</strong></span>
<span class="strong"><strong>karaf@root()&gt; config:property-set org.osgi.service.http.port 8080</strong></span>
<span class="strong"><strong>karaf@root()&gt; config:update</strong></span>
</pre></div><p>More details on how to use the <code class="literal">config</code> commands can be found in <span class="emphasis"><em>Learning Apache Karaf</em></span>, <span class="emphasis"><em>Jamie Goodyear, Johan Edstrom, and Heath Kesler</em></span>, <span class="emphasis"><em>Packt Publishing</em></span>.</p><p>It is best practice to use the <code class="literal">karaf.data</code> environment variable when referencing external directories, for example, when enabling the NCSA logger by switching the <code class="literal">org.ops4j.pax.web.log.ncsa.enabled</code> option to <code class="literal">true</code>. It is necessary to also configure the directory to a specific folder, as described in the following code line:</p><div class="informalexample"><pre class="programlisting">org.ops4j.pax.web.log.ncsa.directory = ${karaf.data}/ncsa-log/</pre></div><p>The<a id="id303" class="indexterm"/> same is true for the <code class="literal">scratch</code> directory<a id="id304" class="indexterm"/> for JSP compilation—it is best to be configured as:</p><div class="informalexample"><pre class="programlisting">org.ops4j.pax.web.jsp.scratch.dir = ${karaf.data}/jsp-compile</pre></div></div></div>
<div class="section" title="Building a Http Service project to host in Apache Karaf"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec45"/>Building a Http Service project to host in Apache Karaf</h1></div></div></div><p>Building web applications only with the Http Service also means a reduction to servlet only services, as Http Service supports only servlets and no further web elements like filters and JSPs. With this<a id="id305" class="indexterm"/> reduced set, it is still possible<a id="id306" class="indexterm"/> to build modern web applications. For example, it just needs some JavaScript code and a servlet generating JSON to build a modern web application. Using these elements, along with OSGi, you get the perfect mixture for µ-services. The focus of this recipe, and the following ones, lies only on the usage of the Http Service; so, don't expect to create a fancy web application. After you're through, you will be able to build a single servlet application like the one in the following screenshot:</p><div class="mediaobject"><img src="graphics/5081OS_04_04.jpg" alt="Building a Http Service project to host in Apache Karaf"/></div><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec136"/>Getting ready</h2></div></div></div><p>To precondition the Http Service installed in Apache Karaf, see the <span class="emphasis"><em>Installing Pax modules in Apache Karaf</em></span> recipe. The sources can be found at <a class="ulink" href="https://github.com/jgoodyear/ApacheKarafCookbook/tree/master/chapter4/chapter4-recipe3">https://github.com/jgoodyear/ApacheKarafCookbook/tree/master/chapter4/chapter4-recipe3</a>.</p><p>It is best to always have a look at the complete sources, due to the limited amount of pages for this book and to spare you of the boilerplate code. This is why only the critical section is referenced here in this recipe. The example application used in this recipe can be installed and started with the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>install -s mvn:com.packt/chapter4-recipe3/1.0.0-SNAPSHOT/jar</strong></span>
</pre></div></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec137"/>How to do it…</h2></div></div></div><p>As we <a id="id307" class="indexterm"/>are using Http Service with this<a id="id308" class="indexterm"/> recipe, we need to get hold of the <code class="literal">HttpService</code> service. For this, it is very common to use a ServiceTracker mechanism. The steps are as follows:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">The first step is referencing the Http Service. In the activator of our sample application, a <code class="literal">ServiceTracker</code> object is created with a reference to the bundle creating this tracker and declaring the class of the service to be tracked. The third parameter is an implementation of the ServiceTrackerCustomizer interface. A default implementation is provided by the ServiceTracker itself, and therefore we use it as is. All of this takes place in the bundle activator code as follows:<div class="informalexample"><pre class="programlisting">public void start(BundleContext bc) throws Exception {
  bundleContext = bc;
  tracker = new ServiceTracker&lt;HttpService, HttpService&gt;(bc, HttpService.class, this);
  tracker.open();
}</pre></div></li><li class="listitem">The second step is registering the servlet as a service. The moment the service is available, the ServiceTracker will kick in and the <code class="literal">addingService</code> method of the bundle activator will be called. Here, the <code class="literal">HttpContext</code> function for the servlet is created together with the <code class="literal">init</code> parameter for the servlet to register, as shown in the following code:<div class="informalexample"><pre class="programlisting">HttpContext httpContext = httpService.createDefaultHttpContext();
Dictionary&lt;String, Object&gt; initParams = new Hashtable&lt;String, Object&gt;();</pre></div></li><li class="listitem">After this, we are ready to register the servlet as a service with the Http Service. This is done by the following simple API call:<div class="informalexample"><pre class="programlisting">httpService.registerServlet("/hello",
new HelloServlet(), initParams, httpContext);</pre></div></li></ol></div><p>The Http Service also supports registering of resources, for example, images and CSS files. The Felix Web Console is based on these two mechanisms.</p><p>To <a id="id309" class="indexterm"/>register resources, the Http Service <a id="id310" class="indexterm"/>API provides another method for registration, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">httpService.registerResources("/images", "/images", httpContext);</pre></div><p>The image should be contained within a JAR file in the <code class="literal">images</code> folder (as shown in the following screenshot), which is used when registering the image's alias:</p><div class="mediaobject"><img src="graphics/5081OS_04_13.jpg" alt="How to do it…"/></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip25"/>Tip</h3><p>The corresponding API can be found at <a class="ulink" href="http://www.osgi.org/javadoc/r4v42/org/osgi/service/http/HttpService.html">http://www.osgi.org/javadoc/r4v42/org/osgi/service/http/HttpService.html</a>.</p></div></div><p>To use this image, create a second servlet that uses this image and register it with a different alias, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">httpService.registerServlet("/hello/logo", new HelloImage(), initParams, httpContext);</pre></div><p>The servlet refers to the image as a resource from the root context, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">out.println("&lt;img src='/images/karaf-logo.png' border='0'/&gt;");</pre></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec138"/>How it works…</h2></div></div></div><p>The Http Service configures and registers the HelloServlet with the underlying Jetty server. From this point on, it is regarded as a classic servlet and handled accordingly. The resources take some extra handling, as the ResourceServlet needs to be aware of the OSGi class loading, and thus needs to know where to look for the resources in the bundle's class path.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec139"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The Http Service only provides basic HTTP services, such as to serve servlets and resources. If you want to serve dynamic content like JSPs, you'll need<a id="id311" class="indexterm"/> the Pax Web extension <a id="id312" class="indexterm"/>to the OSGi Http Service—the Pax Web web container. This is available together with the Whiteboard extender and is used in the <span class="emphasis"><em>Building a Http Service with the Whiteboard pattern in Apache Karaf</em></span> recipe.</li></ul></div></div></div>
<div class="section" title="Building a Http Service with the Whiteboard pattern in Apache Karaf"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec46"/>Building a Http Service with the Whiteboard pattern in Apache Karaf</h1></div></div></div><p>The <a id="id313" class="indexterm"/>Whiteboard pattern<a id="id314" class="indexterm"/> is a much easier approach to registering servlets, resources, JSPs, or filters. With the Whiteboard extender, the registration of services works in the opposite way to the last recipe. The bundle activator doesn't wait for the Http Service to show up; it just registers the servlets and the other resources as services while the Whiteboard extender picks up those services and makes sure that everything is ready to be served. With the Whiteboard feature, it is possible to use all web technologies available to the underlying Jetty server, as we are not bound to the restricted Http Service interface anymore. This recipe will guide you through this by using two different technologies; first, the standard way, which is via a bundle activator, and second, via Blueprint.</p><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec140"/>How to do it…</h2></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">The first step is<a id="id315" class="indexterm"/> registering a<a id="id316" class="indexterm"/> servlet as a service. First, register your servlet via the activator using the bundle context. As the servlet is registered as an OSGi service, the alias needs to be placed in the service properties. These properties are interpreted and partially used for a servlet's <code class="literal">init</code> parameters.<div class="informalexample"><pre class="programlisting">Hashtable&lt;String, String&gt; props = new Hashtable&lt;String, String&gt;();
props.put("alias", "/whiteboard");</pre></div><p>The servlet itself is registered as any usual OSGi service, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">servletReg = bundleContext.registerService(Servlet.class, new HelloServlet(), props);</pre></div></li><li class="listitem">The second step is registering resources. As this is not a standardized OSGi Http Service, a special Pax Web <code class="literal">ResourceMapping</code> class is needed to register a resource as a service, as shown in the following code:<div class="informalexample"><pre class="programlisting">DefaultResourceMapping resourceMapping = new DefaultResourceMapping();
resourceMapping.setAlias("/whiteboardresources");
resourceMapping.setPath("/images");
resourcesReg = bundleContext.registerService(ResourceMapping.class, resourceMapping, null);</pre></div><p>After the registration, it is possible to use these resources by the servlet, as follows:</p><div class="informalexample"><pre class="programlisting">out.println("&lt;img src='/whiteboardresources/karaf-logo.png' border='0'/&gt;");</pre></div><p>This pattern to register web components as services will repeat itself.</p></li><li class="listitem">The next step is registering a servlet with Blueprint. Instead of using an activator for registration, the Whiteboard pattern also gives you the freedom to use <a id="id317" class="indexterm"/>other means of <a id="id318" class="indexterm"/>registering services, like Blueprint or DS. With a Blueprint XML file, it is now only a configuration for the wiring of services, instead of creating the boilerplate code contained in the activator:<div class="informalexample"><pre class="programlisting">&lt;service id="filteredServletService" ref="filteredServlet" interface="javax.servlet.Servlet"&gt;
  &lt;service-properties&gt;
    &lt;entry key="alias" value="/filtered"/&gt;
  &lt;/service-properties&gt;
  &lt;bean class="com.packt.HelloServlet"/&gt;
&lt;/service&gt;</pre></div><p>This registers the servlet with the alias <code class="literal">/filtered</code>, which is used as the URL pattern for the matching filter.</p></li><li class="listitem">The last step is registering the filter with Blueprint. Registering a filter is just as easy as registering a servlet. Using Blueprint for this kind of registration uses less boilerplate code. This can be done using the following code:<div class="informalexample"><pre class="programlisting">&lt;service id="servletFilterService" interface="javax.servlet.Filter"&gt;
  &lt;service-properties&gt;
    &lt;entry key="urlPatterns" value="/filtered/*"/&gt;
  &lt;/service-properties&gt;
  &lt;bean class="com.packt.ServletFilter"/&gt;
&lt;/service&gt;</pre></div><p>As a result, the filtered call of Hello Servlet can be seen when navigating to <code class="literal">/filtered</code>, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/5081OS_04_05.jpg" alt="How to do it…"/></div></li></ol></div><p>There is<a id="id319" class="indexterm"/> more to the<a id="id320" class="indexterm"/> Whiteboard approach. It is possible to configure a complete web application just by registering services.</p><div class="section" title="Registering error pages"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec01"/>Registering error pages</h3></div></div></div><p>Registering <code class="literal">DefaultErrorPageMapping</code>, for example, easily configures an error page. The <a id="id321" class="indexterm"/>corresponding class is provided by Pax Web and is available through the Apache Karaf Http Whiteboard feature. Consider the following code:</p><div class="informalexample"><pre class="programlisting">&lt;service interface=" org.ops4j.pax.web.extender.whiteboard.ErrorPageMapping"&gt;
  &lt;bean class=" org.ops4j.pax.web.extender.whiteboard.runtime.DefaultErrorPageMapping"&gt;
    &lt;property name="error" value="java.lang.Exception"/&gt;
    &lt;property name="location" value="/uncaughtException.html"/&gt;
  &lt;/bean&gt;
&lt;/service&gt;</pre></div><p>This error page mapping defines that any exception thrown in the container will result in serving the <code class="literal">uncaughtException.html</code> page, as shown here in the following screenshot:</p><div class="mediaobject"><img src="graphics/5081OS_04_06.jpg" alt="Registering error pages"/></div></div><div class="section" title="Defining error page mapping"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec02"/>Defining error page mapping</h3></div></div></div><p>While at it, a <a id="id322" class="indexterm"/>custom 404 error code handling page can be registered with extra mapping, which again is registered as a service, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">&lt;!-- 404 mapping --&gt;
&lt;service id="errorPageMapping" interface="org.ops4j.pax.web.extender.whiteboard.ErrorPageMapping"&gt;
  &lt;bean class="org.ops4j.pax.web.extender.whiteboard.runtime.DefaultErrorPageMapping"&gt;
    &lt;property name="error" value="404"/&gt;
    &lt;property name="location" value="/404.html"/&gt;
  &lt;/bean&gt;
&lt;/service&gt;</pre></div><p>
<code class="literal">DefaultErrorPageMapping</code> provided by Pax Web just needs the HTTP error code and the location of the custom error code page.</p></div><div class="section" title="Registering a welcome page"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec03"/>Registering a welcome page</h3></div></div></div><p>The<a id="id323" class="indexterm"/> configuration and registration of a service for welcome pages is as easy as the previous registrations have been. Consider the following code:</p><div class="informalexample"><pre class="programlisting">&lt;service id="welcomeFileService" interface="org.ops4j.pax.web.extender.whiteboard.WelcomeFileMapping"&gt;
  &lt;bean class="org.ops4j.pax.web.extender.whiteboard.runtime.DefaultWelcomeFileMapping"&gt;
    &lt;property name="redirect" value="true" /&gt;
    &lt;property name="welcomeFiles"&gt;
      &lt;array&gt;
        &lt;value&gt;index.html&lt;/value&gt;
        &lt;value&gt;welcome.html&lt;/value&gt;
      &lt;/array&gt;
    &lt;/property&gt;
  &lt;/bean&gt;
&lt;/service&gt;</pre></div><p>The <a id="id324" class="indexterm"/>Whiteboard extender bundle provides a default implementation of <code class="literal">WelcomeFileMapping</code>. The following screenshot shows the welcome page:</p><div class="mediaobject"><img src="graphics/5081OS_04_07.jpg" alt="Registering a welcome page"/></div></div><div class="section" title="Register JSPs"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec04"/>Register JSPs</h3></div></div></div><p>The <a id="id325" class="indexterm"/>registration of a JSP is as simple as all the previous recipes. You just need to register <code class="literal">DefaultJspMapping</code> with the corresponding URL patterns. After this is done, you are set to serve JSPs right away. Consider the following code:</p><div class="informalexample"><pre class="programlisting">&lt;service id="jspMapping" interface="org.ops4j.pax.web.extender.whiteboard.JspMapping"&gt;
  &lt;bean class="org.ops4j.pax.web.extender.whiteboard.runtime.DefaultJspMapping"&gt;
    &lt;property name="urlPatterns"&gt;
      &lt;array&gt;
        &lt;value type="java.lang.String"&gt;/jsp&lt;/value&gt;
      &lt;/array&gt;
    &lt;/property&gt;
  &lt;/bean&gt;
&lt;/service&gt;</pre></div><p>Once <a id="id326" class="indexterm"/>you are set to serve the JSP, the following screen will appear:</p><div class="mediaobject"><img src="graphics/5081OS_04_08.jpg" alt="Register JSPs"/></div></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec141"/>How it works...</h2></div></div></div><p>The<a id="id327" class="indexterm"/> now available Whiteboard extender <a id="id328" class="indexterm"/>starts a ServiceListener that registers any incoming new service such as a servlet, filter, and JSP and hands them over to either the standard Http Service or the extended Http Service (the WebContainer interface).</p><p>Using the direct service approach has only one downside—all of the registered servlet services use the same <code class="literal">ServletContextPath</code>. This is due to the fact that the Http Service registered servlets neglect a way to register the servlet with a specialized ServletContextPath, and therefore are bound to<code class="literal">/</code>with an extra URL path for the servlet. For example, the first two servlets of this recipe register with <code class="literal">/whiteboard</code> and <code class="literal">/whiteboard/logo</code>, where the ServletContextPath is <code class="literal">/</code>. To distinguish between different ServletContextPaths, a WAB is needed.</p><p>All of the previous samples have one thing in common: all of them are registered within the <a id="id329" class="indexterm"/>same bundle. To separate servlets from <a id="id330" class="indexterm"/>filters, you need to make sure that you have the same HttpContext in use; this is handled in a later recipe.</p></div></div>
<div class="section" title="Building an application with custom HttpContext with Apache Karaf"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec47"/>Building an application with custom HttpContext with Apache Karaf</h1></div></div></div><p>All <a id="id331" class="indexterm"/>previous recipes have covered how to register <a id="id332" class="indexterm"/>servlets and filters, and all from within the same bundle bound to a default HttpContext. If no other HttpContext is defined, DefaultHttpContext is created while registering a servlet or resource. With this recipe, we will work with a custom HttpContext.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec142"/>Getting ready</h2></div></div></div><p>As this recipe is a specialization of the previous recipes, you'll find the source code for it in the <span class="emphasis"><em>Building a Http Service with the Whiteboard pattern in Apache Karaf</em></span> recipe. As usual, the recipe demands the successful installation of the <code class="literal">http-whiteboard</code> feature; how this can be achieved is explained in the <span class="emphasis"><em>Installing extended Http Service in Apache Karaf</em></span> recipe. The source code in this recipe is reduced to the important sections. The full sources can be found at <a class="ulink" href="https://github.com/jgoodyear/ApacheKarafCookbook/tree/master/chapter4/chapter4-recipe4">https://github.com/jgoodyear/ApacheKarafCookbook/tree/master/chapter4/chapter4-recipe4</a>.</p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec143"/>How to do it…</h2></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">The first step is defining properties. As with servlets, registering an HttpContext requires configuring a name for the HttpContext, as shown in the following code:<div class="informalexample"><pre class="programlisting">props = new Hashtable&lt;String, String&gt;();
props.put(ExtenderConstants.PROPERTY_HTTP_CONTEXT_ID, "forbidden");</pre></div></li><li class="listitem">The next step is registering, HttpContext. This will register the custom WhiteboardContext as HttpContext with a specialized ID <code class="literal">forbidden</code>. This way, other services are able to select this HttpContext. This is shown in the following code:<div class="informalexample"><pre class="programlisting">httpContextReg = bundleContext.registerService(HttpContext.class, new WhiteboardContext(), props);</pre></div></li><li class="listitem">The next step is registering the servlet. The servlet using this HttpContext is referencing<a id="id333" class="indexterm"/> the HttpContext by just being registered using the same HttpContext ID. Consider<a id="id334" class="indexterm"/> the following code:<div class="informalexample"><pre class="programlisting">props = new Hashtable&lt;String, String&gt;();
props.put(ExtenderConstants.PROPERTY_ALIAS, "/forbidden");
props.put(ExtenderConstants.PROPERTY_HTTP_CONTEXT_ID, "forbidden");
forbiddenServletReg = bundleContext.registerService(Servlet.class, new HelloServlet(), props);</pre></div><p>The custom HttpContext returns <code class="literal">false</code> for the <code class="literal">handleSecurity</code> method. Therefore, the request will return a 401 error as HTTP return code. Consider the following code:</p><div class="informalexample"><pre class="programlisting">public boolean handleSecurity(final HttpServletRequest request,final HttpServletResponse response) throws IOException {
  // Forbidden access!
  return false;
}</pre></div></li></ol></div><p>The following screenshot shows the HTTP error window:</p><div class="mediaobject"><img src="graphics/5081OS_04_09.jpg" alt="How to do it…"/></div></div><div class="section" title="There's more…"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec144"/>There's more…</h2></div></div></div><p>Till now, the registration of servlets, filters, and other resources always took place from the same bundle. How does this fit into the OSGi world? Doesn't it make sense to split this<a id="id335" class="indexterm"/> apart? It actually does, but it isn't easy and the OSGi spec doesn't require it to be possible. With Pax Web 3, it is possible <a id="id336" class="indexterm"/>to have this working but requires some specialties. First of all, it needs a shared HttpContext (its description and how to work with it you will find in the next set of steps). The following is a component diagram to give you an idea of the setup:</p><div class="mediaobject"><img src="graphics/5081OS_04_14.jpg" alt="There's more…"/></div><p>This can be done as follows:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">The first step is registering the SharedWebContainerContext. For the shared HttpContext, it is essential to have the SharedWebContainerContext, which is a specialized HttpContext. At this point, the WebContainer interface is our friend and helps us by providing a method for the creation of the SharedWebContainerContext, which is the <code class="literal">getDefaultSharedHttpContext</code> method. This is described in the following code:<div class="informalexample"><pre class="programlisting">WebContainer service = (WebContainer) context.getService(serviceReference);
HttpContext httpContext = service.getDefaultSharedHttpContext();</pre></div><p>This freshly created SharedWebContainerContext needs to be registered as a service, as the filter from the other bundle needs to refer to it. Consider the following code:</p><div class="informalexample"><pre class="programlisting">props = new Hashtable&lt;String, String&gt;();
props.put(ExtenderConstants.PROPERTY_HTTP_CONTEXT_ID, "shared");
httpContextReg = context.registerService(HttpContext.class,httpContext, props);</pre></div></li><li class="listitem">The next step is registering the servlet with the shared context. As we want to add <a id="id337" class="indexterm"/>a filter from a different<a id="id338" class="indexterm"/> bundle, we need to add a servlet first. We will do this using the following code:<div class="informalexample"><pre class="programlisting">props = new Hashtable&lt;String, String&gt;();
props.put( ExtenderConstants.PROPERTY_ALIAS, "/extfilter" );
props.put("servlet-name", "FilteredServlet");
props.put(ExtenderConstants.PROPERTY_HTTP_CONTEXT_ID, "shared");
registerService = context.registerService( Servlet.class, new HelloServlet(), props );</pre></div><p>At this point, the first bundle is set in our recipe, and we need to take care of the second bundle that only contains the filter.</p></li><li class="listitem">The next step is referencing the shared HttpContext. We need to get the <span class="emphasis"><em>shared</em></span> HttpContext first, though this time we don't create a new one; we just need to reference the one that the first bundle registered.<p>Find the service reference for the HttpContext service that matches the given LDAP filter <code class="literal">(httpContext.id=shared)</code>. Also, see step 1, where we registered the service with this property. Consider the following code:</p><div class="informalexample"><pre class="programlisting">Collection&lt;ServiceReference&lt;HttpContext&gt;&gt; serviceReferences = context.getServiceReferences(HttpContext.class, "(httpContext.id=shared)");

if (serviceReferences.size() &gt; 1) {
  throw new RuntimeException("should only be one http shared context");
}

HttpContext httpContext = context.getService(serviceReferences.iterator().next());</pre></div><p>From this service reference, we acquire the HttpContext instance, which in our case is the SharedWebContainerContext at this point.</p></li><li class="listitem">The next step is registering the filter for the shared context. From here on, it's quite<a id="id339" class="indexterm"/> simple. The registration<a id="id340" class="indexterm"/> of the servlet filter is done in the usual way.<div class="informalexample"><pre class="programlisting">Dictionary&lt;String, String&gt; props;
props = new Hashtable&lt;String, String&gt;();
props.put("pattern", ".*");
props.put(ExtenderConstants.PROPERTY_HTTP_CONTEXT_ID, "shared");

service.registerFilter(new ServletFilter(), new String[] { "/*" }, null, props, httpContext);</pre></div><p>Create the properties needed for registration and register the filter with the WebContainer service. It is important that the properties contain the reference to the right HttpContext, <code class="literal">shared</code> at this point. The most important part is that it needs to actually register the filter with the preregistered HttpContext.</p></li></ol></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip26"/>Tip</h3><p>
<span class="strong"><strong>Can't this be done easier?</strong></span>
</p><p>The not-yet-released version of Pax Web 4 helps with the sharing of contexts. It will especially help in working with the Whiteboard pattern. Since the release of Karaf 3 (which uses Pax Web 3), the <code class="literal">features.xml</code> file of Pax Web is maintained and released in the Pax Web release cycle. This will help to upgrade just this feature while Karaf itself might stay on another version.</p></div></div></div></div>
<div class="section" title="Building a standard web project to host in Apache Karaf"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec48"/>Building a standard web project to host in Apache Karaf</h1></div></div></div><p>As<a id="id341" class="indexterm"/> building a standard<a id="id342" class="indexterm"/> web application and WAR isn't really in the scope of this book, the focus of this recipe lies on the <span class="emphasis"><em>transformation</em></span> of a standard WAR into a WAB.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec145"/>Getting ready</h2></div></div></div><p>The sample code for this recipe is available at <a class="ulink" href="https://github.com/jgoodyear/ApacheKarafCookbook/tree/master/chapter4/chapter4-recipe6">https://github.com/jgoodyear/ApacheKarafCookbook/tree/master/chapter4/chapter4-recipe6</a>.</p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec146"/>How to do it…</h2></div></div></div><p>Transforming a standard WAR project into a WAB is simple. So, let's take a look at the specialties around WAR and WAB files. For simplicity, let's call this project web project from here on.</p><p>Contrasting with a standard bundle project, where the classes reside directly in the JAR file, the classes of a web project should be contained in the <code class="literal">classes</code> folder under the <code class="literal">WEB-INF</code> folder. The same is true for embedded libraries; in a web project, these libraries are required to be placed in the <code class="literal">lib</code> folder under the <code class="literal">WEB-INF</code> folder.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note07"/>Note</h3><p>Beware—embedding other JAR files should be done only if the JAR file is needed internally. Referencing other bundles should be your first choice.</p></div></div><p>The good news is that <code class="literal">maven-bundle-plugin</code> is capable of taking care of this special placement of classes and libraries. The <code class="literal">&lt;_wab&gt;</code> section takes care of this. Here, you define <a id="id343" class="indexterm"/>the base path of your <a id="id344" class="indexterm"/>web application folder. As this is a Maven project, the web application path resides in the <code class="literal">webapp</code> folder in the <code class="literal">src/main</code> folder. Consider the following code:</p><div class="informalexample"><pre class="programlisting">&lt;plugin&gt;
  &lt;groupId&gt;org.apache.felix&lt;/groupId&gt;
  &lt;artifactId&gt;maven-bundle-plugin&lt;/artifactId&gt;
  &lt;version&gt;2.4.0&lt;/version&gt;
  &lt;extensions&gt;true&lt;/extensions&gt;
  &lt;configuration&gt;
    &lt;instructions&gt;
<span class="strong"><strong>      &lt;_wab&gt;src/main/webapp&lt;/_wab&gt;</strong></span>
<span class="strong"><strong>      &lt;Web-ContextPath&gt;packt-sample&lt;/Web-ContextPath&gt;</strong></span>
    &lt;/instructions&gt;
  &lt;/configuration&gt;
&lt;/plugin&gt;</pre></div><p>As it is required for a web application bundle to have a <code class="literal">Web-ContextPath</code> manifest entry, this is set to <code class="literal">packt-sample</code> in this recipe.</p></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec147"/>How it works…</h2></div></div></div><p>The WAR feature installs the Pax Web War extender. The WAR extender waits for bundles containing the <code class="literal">Web-ContextPath</code> header and will scan this bundle for the <code class="literal">web.xml</code> and <code class="literal">jetty-web.xml</code> configuration files. It also takes care of the annotated servlet's classes. For each WAR file, there will be a unique servlet context with the path defined in the <code class="literal">Web-ContextPath</code> manifest header. This is different from registering servlets via the Http Service (with or without the Whiteboard extender), where it is all about the alias.</p></div><div class="section" title="There's more…"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec148"/>There's more…</h2></div></div></div><p>The only downside of the previously created WAB file is that it is not a WAR file anymore. As the POM file declares the resulting package to be of type bundle, the artifact is packaged as a JAR file. This surely will cause issues in the case of a WAR file that is supposed to be run on Apache Karaf or a non-OSGi container.</p><p>To make this work, the Maven POM file of the project needs to be adapted. First, set the packaging to WAR. This will use <code class="literal">maven-war-plugin</code> to package this bundle, and in turn, the WAR file is not a WAB file anymore, as it lacks a valid OSGi manifest.</p><p>It's necessary to combine the two plugins to create a valid OSGi WAB file. For this, we need <a id="id345" class="indexterm"/>to configure <code class="literal">maven-bundle-plugin</code> in the following manner:</p><div class="informalexample"><pre class="programlisting">…
&lt;executions&gt;
  &lt;execution&gt;
    &lt;id&gt;bundle-manifest&lt;/id&gt;
    &lt;phase&gt;process-classes&lt;/phase&gt;
    &lt;goals&gt;
<span class="strong"><strong>      &lt;goal&gt;manifest&lt;/goal&gt;</strong></span>
    &lt;/goals&gt;
  &lt;/execution&gt;
&lt;/executions&gt;
&lt;configuration&gt;
  &lt;supportedProjectTypes&gt;
    &lt;supportedProjectType&gt;jar&lt;/supportedProjectType&gt;
    &lt;supportedProjectType&gt;bundle&lt;/supportedProjectType&gt;
<span class="strong"><strong>    &lt;supportedProjectType&gt;war&lt;/supportedProjectType&gt;</strong></span>
  &lt;/supportedProjectTypes&gt;
…</pre></div><p>The <a id="id346" class="indexterm"/>plugin is configured just to produce a manifest file, and as the packaging is of the type WAR, <code class="literal">maven-bundle-plugin</code> needs to be configured to support the WAR format as valid packaging.</p><p>The <a id="id347" class="indexterm"/>manifest file generated from the preceding code will be merged into the WAR bundle explicitly using the <code class="literal">manifestFile</code> attribute, as <a id="id348" class="indexterm"/>shown in the following code:</p><div class="informalexample"><pre class="programlisting">&lt;configuration&gt;
  &lt;archive&gt;
    &lt;manifestFile&gt;${project.build.outputDirectory}/META-INF/MANIFEST.MF&lt;/manifestFile&gt;
  &lt;/archive&gt;
&lt;/configuration&gt;</pre></div><p>With<a id="id349" class="indexterm"/> these configurations, you'll generate a web application that can run in Apache Karaf and outside of OSGi.</p><p>For a complete sample, take a look at the source code at <a class="ulink" href="https://github.com/jgoodyear/ApacheKarafCookbook/tree/master/chapter4/chapter4-recipe6">https://github.com/jgoodyear/ApacheKarafCookbook/tree/master/chapter4/chapter4-recipe6</a>. Here, you will find a special POM file, <code class="literal">pom.war_xml</code>.</p></div></div>
<div class="section" title="Configuring security for a web application in Apache Karaf"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec49"/>Configuring security for a web application in Apache Karaf</h1></div></div></div><p>This<a id="id350" class="indexterm"/> recipe will handle how<a id="id351" class="indexterm"/> to build a web application with authentication enabled. As we are running within Apache Karaf and Karaf supports <span class="strong"><strong>Java Authentication and Authorization Service</strong></span> (<span class="strong"><strong>JAAS</strong></span>) out of the box, we <a id="id352" class="indexterm"/>will show you everything that is needed to run a basic authentication with JAAS on Karaf.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec149"/>Getting ready</h2></div></div></div><p>The<a id="id353" class="indexterm"/> prerequisite is to install the WAR feature. The source code for this recipe is available at <a class="ulink" href="https://github.com/jgoodyear/ApacheKarafCookbook/tree/master/chapter4/chapter4-recipe7">https://github.com/jgoodyear/ApacheKarafCookbook/tree/master/chapter4/chapter4-recipe7</a>.</p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec150"/>How to do it…</h2></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">The first step is configuring the user/password combination in Karaf. Let's start with the user configuration. Let's make sure that the <code class="literal">users.properties</code> file in the <code class="literal">/etc</code> folder contains the following setup (it's the default configuration):<div class="informalexample"><pre class="programlisting">karaf = karaf,_g_:admingroup
_g_\:admingroup = group,admin,manager,viewer</pre></div><p>The <code class="literal">users.properties</code> file follows the following syntax:</p><div class="informalexample"><pre class="programlisting">USER=PASSWORD, ROLE1, ROLE2, …</pre></div><p>It can also have the following syntax:</p><div class="informalexample"><pre class="programlisting">USER=PASSWORD, _g_:GROUP, …
_g_\:GROUP=ROLE1,ROLE2, …</pre></div></li><li class="listitem">The next step is configuring JAAS in Jetty. The <code class="literal">jetty.xml</code> file used by Pax Web needs to contain a valid authentication realm. This realm needs to be configured for the usage of JAAS. Configuration of the <code class="literal">JAASLoginService</code> class will look like the following:<div class="informalexample"><pre class="programlisting">&lt;Call name="addBean"&gt;
  &lt;Arg&gt;
<span class="strong"><strong>    &lt;New class="org.eclipse.jetty.plus.jaas.JAASLoginService"&gt;</strong></span>
      &lt;Set name="name"&gt;default&lt;/Set&gt;
      &lt;Set name="loginModuleName"&gt;karaf&lt;/Set&gt;
      &lt;Set name="roleClassNames"&gt;
        &lt;Array type="java.lang.String"&gt;
          &lt;Item&gt;org.apache.karaf.jaas.boot.principal.RolePrincipal
          &lt;/Item&gt;
        &lt;/Array&gt;
      &lt;/Set&gt;
    &lt;/New&gt;
  &lt;/Arg&gt;</pre></div><p>The key to accessing the realm of Karaf is to define the <code class="literal">loginModuleName</code> value to <code class="literal">karaf</code> and define the right principal. As we are running within Karaf, we need as configure the <code class="literal">roleClassNames</code> value to be <code class="literal">org.apache.karaf.jaas.boot.principal.RolePrincipal</code>. With this, the security handshake configuration between Jetty and Karaf is complete.</p></li><li class="listitem">The<a id="id354" class="indexterm"/> last step<a id="id355" class="indexterm"/> is configuring the web application to use JAAS. To use it from within the web application, the <code class="literal">web.xml</code> file needs to have security enabled and configured, as shown in the following code:<div class="informalexample"><pre class="programlisting">&lt;security-constraint&gt;
  &lt;web-resource-collection&gt;
    &lt;web-resource-name&gt;Protected Area&lt;/web-resource-name&gt;
    &lt;description&gt;Protect the Example Servlet&lt;/description&gt;
<span class="strong"><strong>    &lt;url-pattern&gt;/secured/*&lt;/url-pattern&gt;</strong></span>
    &lt;http-method&gt;GET&lt;/http-method&gt;
    &lt;http-method&gt;POST&lt;/http-method&gt;
  &lt;/web-resource-collection&gt;
  &lt;auth-constraint&gt;
    &lt;description&gt;Authorized Users Group&lt;/description&gt;
<span class="strong"><strong>    &lt;role-name&gt;admin&lt;/role-name&gt;</strong></span>
  &lt;/auth-constraint&gt;
&lt;/security-constraint&gt;</pre></div><p>The security for this application is set to secure the secured URL for both the <code class="literal">GET</code> and <code class="literal">POST</code> methods. The required role has to be of the name <code class="literal">admin</code>, as was configured in step 1. Consider the following code:</p><div class="informalexample"><pre class="programlisting">&lt;login-config&gt;
  &lt;auth-method&gt;BASIC&lt;/auth-method&gt;
  &lt;realm-name&gt;default&lt;/realm-name&gt;
&lt;/login-config&gt;</pre></div><p>The login configuration is set to be of the type <code class="literal">BASIC</code>, so the container takes care of the authentication and it's configured to use the default realm. This configuration points to the defined <code class="literal">JAASLoginService</code> class with the name <code class="literal">default</code> (configured in step 2).</p></li></ol></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec151"/>How it works…</h2></div></div></div><p>The<a id="id356" class="indexterm"/> key for authentication in a web application is the JAAS security mechanism provided by Karaf. It's just <a id="id357" class="indexterm"/>a matter of configuration to make sure all parts are connected appropriately.</p><p>When working with Karaf and JAAS security realms, it might be of interest to know which realms are currently available. There is a shell command available to list all realms—the <code class="literal">jaas:realm-list</code> command.</p><p>This command will show us the available realms, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/5081OS_04_10.jpg" alt="How it works…"/></div></div><div class="section" title="There's more…"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec152"/>There's more…</h2></div></div></div><p>Now that we have configured security in the web application, the only thing missing is a way of addressing the application in a secure way. To enable SSL, we need to take parts of the configuration from the <span class="emphasis"><em>Configuring Pax Web modules deployed in Apache Karaf</em></span> recipe and enable certain values that are off by default. All this is done to the <code class="literal">org.ops4j.pax.web.cfg</code> configuration file, as shown in the following code snippet:</p><div class="informalexample"><pre class="programlisting">org.osgi.service.http.secure.enabled = true
org.osgi.service.http.port.secure = 8443
org.osgi.service.http.secure.connector.name = secureDefault

org.ops4j.pax.web.ssl.keystore = ${karaf.base}/etc/keystore/.keystore
org.ops4j.pax.web.ssl.password = password
org.ops4j.pax.web.ssl.keypassword = password
org.ops4j.pax.web.ssl.clientauthwanted = false
org.ops4j.pax.web.ssl.clientauthneeded = false</pre></div><p>With this configuration, we enable listening on the secure port, which is <code class="literal">8443</code> in our case. The <code class="literal">keystore</code> value is stored at a location relative to the Karaf base directory.</p><p>The <code class="literal">clientauthwanted</code> and <code class="literal">clientauthneeded</code> properties are set to <code class="literal">true</code> if the client should send a certificate for authentication instead of login credentials.</p><p>Once <a id="id358" class="indexterm"/>the configurations <a id="id359" class="indexterm"/>have been saved, they will be picked up by the FileInstaller bundle and applied to running Jetty server through Pax Web.</p><p>For a fully working SSL, you'll need a certificate, and so we need to create one. The following steps will work on the Linux and Mac environments and most likely on Windows:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">The first step is the <code class="literal">keystore</code> setup. First of all, create the directory to contain the keystore that will be used with Karaf. It has to match the <code class="literal">org.ops4j.pax.web.ssl.keystore</code> property configured in the <code class="literal">org.ops4j.pax.web.cfg</code> file. This is shown in the following screenshot:<div class="mediaobject"><img src="graphics/5081OS_04_11.jpg" alt="There's more…"/></div><p>On the system shell, not the Karaf shell, you will need to use a tool to create SSH keys. We<a id="id360" class="indexterm"/> will be using the Java tool named <span class="strong"><strong>keytool</strong></span> to create keys and certificates. First, create the key to sign the certificate. Make sure that you're doing this in the <code class="literal">keystore</code> directory (<code class="literal">etc/keystore</code>). This can be done as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>keytool -genkey -keyalg RSA -validity 1024 -alias serverkey -keypass password -storepass password -keystore server.jks</strong></span>
</pre></div><p>We use a<a id="id361" class="indexterm"/> simple password <a id="id362" class="indexterm"/>as the password, as this is an example, but you shouldn't actually do this in production. As password, we use server. Have a look at the following screenshot:</p><div class="mediaobject"><img src="graphics/5081OS_04_12.jpg" alt="There's more…"/></div><p>Once you see the previous screenshot, you are already set to use SSL in your application. You will need to navigate your browser to the application with the SSL port configured previously; in our example, it is <code class="literal">8443</code>. Your browser will complain about an unsigned certificate of an unknown source. After accepting it, you'll have the login prompt from your authentication WAR file.</p></li><li class="listitem">The <a id="id363" class="indexterm"/>next step<a id="id364" class="indexterm"/> is importing the client certificate. It is also possible to connect to the server with a signed client certificate. The client needs to do the same as has been done for the server—create a self-signed certificate. This certificate needs to be imported to the keystore of the server so that the server knows which certificate to accept. This can be done as follows:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>keytool -import -trustcacerts -keystore server.jks -storepass password -alias clientkey -file client.cer</strong></span>
</pre></div><p>This client certificate needs to be transmitted by the HTTP client software, which may be a browser or some other means of communicating software.</p></li></ol></div></div></div>
<div class="section" title="Binding a web project to a specific host in Apache Karaf"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec50"/>Binding a web project to a specific host in Apache Karaf</h1></div></div></div><p>With<a id="id365" class="indexterm"/> Karaf 3 and Pax<a id="id366" class="indexterm"/> Web 3, it is possible to bind a web application to a specific HTTP connector. This is a feasible solution to separate internal and external applications on the same server.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec153"/>Getting ready</h2></div></div></div><p>The sample code for this recipe is available at <a class="ulink" href="https://github.com/jgoodyear/ApacheKarafCookbook/tree/master/chapter4/chapter4-recipe8">https://github.com/jgoodyear/ApacheKarafCookbook/tree/master/chapter4/chapter4-recipe8</a>. Here, you will find a <code class="literal">jetty.xml</code> file at the <code class="literal">src/main/etc</code> location. It can be used to add an extra connector. Two extra recipes are available to show how to use this with a standard WAB file or the Whiteboard extender.</p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec154"/>How to do it…</h2></div></div></div><p>First of all, the server needs to be configured to support different HTTP connectors. Therefore, it is necessary to configure the Jetty server by editing the <code class="literal">jetty.xml</code> file found in the <code class="literal">etc</code> folder, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">&lt;Call name="addConnector"&gt;
  &lt;Arg&gt;
    &lt;New class="org.eclipse.jetty.server.nio.SelectChannelConnector"&gt;
      &lt;Set name="host"&gt;&lt;Property name="jetty.host" /&gt;&lt;/Set&gt;
<span class="strong"><strong>      &lt;Set name="port"&gt;&lt;Property name="jetty.port" default="8282"/&gt;&lt;/Set&gt;</strong></span>
      &lt;Set name="maxIdleTime"&gt;300000&lt;/Set&gt;
      &lt;Set name="Acceptors"&gt;2&lt;/Set&gt;
      &lt;Set name="statsOn"&gt;false&lt;/Set&gt;
      &lt;Set name="confidentialPort"&gt;8443&lt;/Set&gt;
<span class="strong"><strong>      &lt;Set name="name"&gt;alternateConnector&lt;/Set&gt;</strong></span>
      &lt;Set name="lowResourcesConnections"&gt;20000&lt;/Set&gt;
      &lt;Set name="lowResourcesMaxIdleTime"&gt;5000&lt;/Set&gt;
    &lt;/New&gt;
  &lt;/Arg&gt;</pre></div><p>Changes to the <code class="literal">jetty.xml</code> file will take effect only on the restart of the server and will not be picked up by FileInstaller and applied at runtime.</p><p>The second connector is bound to port <code class="literal">8282</code> and named <code class="literal">alternateConnector</code>. This will be referenced by the application to be bound to this connector.</p><p>To do so, the WAB file needs two additional manifest entries, which are as follows:</p><div class="informalexample"><pre class="programlisting">&lt;plugin&gt;
  &lt;groupId&gt;org.apache.felix&lt;/groupId&gt;
  &lt;artifactId&gt;maven-bundle-plugin&lt;/artifactId&gt;
  &lt;version&gt;2.4.0&lt;/version&gt;
  &lt;extensions&gt;true&lt;/extensions&gt;
  &lt;configuration&gt;
    &lt;instructions&gt;
      &lt;_wab&gt;src/main/webapp&lt;/_wab&gt;
      &lt;Web-ContextPath&gt;packt-sample&lt;/Web-ContextPath&gt;
<span class="strong"><strong>      &lt;Web-Connectors&gt;alternateConnector&lt;/Web-Connectors&gt;</strong></span>
<span class="strong"><strong>      &lt;Web-VirtualHosts&gt;localhost&lt;/Web-VirtualHosts&gt;</strong></span>
    &lt;/instructions&gt;
  &lt;/configuration&gt;
&lt;/plugin&gt;</pre></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec155"/>How it works…</h2></div></div></div><p>The<a id="id367" class="indexterm"/> extra connector <a id="id368" class="indexterm"/>configured in the <code class="literal">jetty.xml</code> file is interpreted by Pax Web and is added to Jetty. With the special manifest entries, the web application bundle is bound to the configured HTTP connector. The number of connectors and applications bound to them are not limited.</p></div><div class="section" title="There's more…"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec156"/>There's more…</h2></div></div></div><p>With Pax Web 3, and therefore with Apache Karaf 3, it is not only possible to bind the WAB file to the web connector, but also to a normal bundle. This needs some special handling, as there is no <code class="literal">Web-ContextPath</code> manifest header to define the context path.</p><p>The best way to achieve this is to use the Whiteboard extender. For this, we need to register a specialized HttpContext, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">//preparing special HTTP Context with HTTP Connector
Hashtable&lt;String, String&gt; props = new Hashtable&lt;String, String&gt;();
props.put( ExtenderConstants.PROPERTY_HTTP_CONTEXT_ID, "httpConnector" );
HashMap&lt;String,String&gt; contextMappingParams = new HashMap&lt;String,String&gt;();
contextMappingParams.put(ExtenderConstants.PROPERTY_HTTP_VIRTUAL_HOSTS, "localhost");
contextMappingParams.put(ExtenderConstants.PROPERTY_HTTP_CONNECTORS, "alternateConnector");
<span class="strong"><strong>contextMappingReg = bundleContext.registerService( HttpContextMapping.class, new WhiteboardHttpContextMapping("httpConnector", "whiteboard", contextMappingParams), props );</strong></span>
</pre></div><p>The registered servlet just needs to use the following HttpContext:</p><div class="informalexample"><pre class="programlisting">props.put(ExtenderConstants.PROPERTY_ALIAS, "/connector");
<span class="strong"><strong>props.put( ExtenderConstants.PROPERTY_HTTP_CONTEXT_ID, "httpConnector" );</strong></span>
servletReg = bundleContext.registerService(Servlet.class, new HelloServlet(), props);</pre></div><p>That's it. Now you need to call the servlet with the <code class="literal">http://localhost:8282/whiteboard/connector</code> URL.</p><p>The <a id="id369" class="indexterm"/>servlet is registered<a id="id370" class="indexterm"/> with the alias/connector, but the HttpContext takes care of the Whiteboard context path.</p></div></div>
<div class="section" title="Building a Servlet 3.0 annotated web application with Apache Karaf"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec51"/>Building a Servlet 3.0 annotated web application with Apache Karaf</h1></div></div></div><p>With<a id="id371" class="indexterm"/> the Servlet 3.0 API, it's possible to have<a id="id372" class="indexterm"/> web archives only with annotated servlets and omit a <code class="literal">web.xml</code> file, or at least omit the configuration of the application within a <code class="literal">web.xml</code> file.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec157"/>Getting ready</h2></div></div></div><p>As usual, you will find the code for this recipe at the GitHub location at <a class="ulink" href="https://github.com/jgoodyear/ApacheKarafCookbook/tree/master/chapter4/chapter4-recipe9">https://github.com/jgoodyear/ApacheKarafCookbook/tree/master/chapter4/chapter4-recipe9</a>.</p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec158"/>How to do it…</h2></div></div></div><p>As with the <span class="emphasis"><em>Building a standard web project to host in Apache Karaf</em></span> recipe, we just build another WAB bundle. Only this time, we have a <code class="literal">web.xml</code> file containing only the definition for the <code class="literal">welcome-file-list</code> method and annotated servlets:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">The first step is defining the <code class="literal">web.xml</code> file. This can be done as follows:<div class="informalexample"><pre class="programlisting">&lt;web-app  
    xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd"
    version="3.0"&gt;

    &lt;welcome-file-list&gt;
      &lt;welcome-file&gt;welcome.html&lt;/welcome-file&gt;
    &lt;/welcome-file-list&gt;

&lt;/web-app&gt;</pre></div></li><li class="listitem">The next step is annotating the servlet. The servlet is simple and consists only of the usual servlet code and annotation. Consider the following code:<div class="informalexample"><pre class="programlisting">@WebServlet (value="/test", name="test")
public class HelloServlet extends HttpServlet {</pre></div></li><li class="listitem">The next step is annotating the filter. The filter also consists of the annotation to declare it to be a filter together with the <code class="literal">init</code> parameters, as shown in the following code:<div class="informalexample"><pre class="programlisting">@WebFilter(urlPatterns={"/*"}, servletNames = {"test"})
public class ServletFilter implements Filter {</pre></div></li></ol></div><p>With<a id="id373" class="indexterm"/> this assembly, you are all set to run <a id="id374" class="indexterm"/>Servlet 3.0 API applications in Apache Karaf.</p></div><div class="section" title="There's more…"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec159"/>There's more…</h2></div></div></div><p>Pax Web does go a step further. As long as the bundle contains a <code class="literal">Web-ContextPath</code> in its <code class="literal">MANIFEST.MF</code> file, it's considered as a WAB file, and therefore, the Pax Web WAR extender handles it as such.</p><p>Make sure that you have a <code class="literal">Web-ContextPath</code> in your manifest, as shown in the following line of code:</p><div class="informalexample"><pre class="programlisting">&lt;Web-ContextPath&gt;packt-sample&lt;/Web-ContextPath&gt;</pre></div><p>Next, make sure that you have an annotated servlet contained in your bundle, as shown in the following line of code:</p><div class="informalexample"><pre class="programlisting">@WebServlet (value="/test", name="test")
public class HelloServlet extends HttpServlet {</pre></div><p>Pointing the browser to <code class="literal">http://localhost:8181/packt-sample/test</code> will return the desired web content.</p></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec160"/>How it works…</h2></div></div></div><p>The <a id="id375" class="indexterm"/>Pax Web WAR extender usually<a id="id376" class="indexterm"/> looks for bundles containing a <code class="literal">Web-ContextPath</code> in the manifest and for a <code class="literal">web.xml</code> file to publish the web archive. From Pax Web 3.0 on, the WAR extender also accepts bundles containing a <code class="literal">Web-ContextPath</code> in their manifest only.</p></div></div>
<div class="section" title="Creating a CDI web application with Apache Karaf"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec52"/>Creating a CDI web application with Apache Karaf</h1></div></div></div><p>Nowadays, modern <a id="id377" class="indexterm"/>web applications <a id="id378" class="indexterm"/>use <span class="strong"><strong>Contexts and Dependency Injection</strong></span> (<span class="strong"><strong>CDI</strong></span>) to wire the application. In the context of OSGi, it would be nice to<a id="id379" class="indexterm"/> have this working together with OSGi services. Pax Web, together with Pax CDI, takes care of this scenario.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec161"/>Getting ready</h2></div></div></div><p>Besides the installation of the WAR feature, it is required to install Pax CDI. Use the following commands to install them:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>feature:install war</strong></span>
<span class="strong"><strong>feature:install pax-cdi-web-openwebbeans</strong></span>
</pre></div><p>Alternatively, you can use the <code class="literal">weld</code> command as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>feature:install pax-cdi-web-weld</strong></span>
</pre></div><p>The source code for this recipe can be found at <a class="ulink" href="https://github.com/jgoodyear/ApacheKarafCookbook/tree/master/chapter4/chapter4-recipe10">https://github.com/jgoodyear/ApacheKarafCookbook/tree/master/chapter4/chapter4-recipe10</a>.</p><p>This<a id="id380" class="indexterm"/> recipe needs the bundle and web <a id="id381" class="indexterm"/>submodules. The bundle submodule contains the OSGi service, and the web submodule contains the CDI web application.</p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec162"/>How to do it…</h2></div></div></div><p>Let's start with the web application. The <code class="literal">web.xml</code> file can either be empty or can contain the entry for a <code class="literal">welcome-file-list</code> method, as the application is a Servlet 3.0 application. For a CDI application, it is required to have a <code class="literal">beans.xml</code> definition in the class path. As this is a web application, the <code class="literal">beans.xml</code> file is expected to be in the <code class="literal">WEB-INF</code> folder. For our use, it is sufficient to keep an empty <code class="literal">beans.xml</code> file in this directory.</p><p>The servlet needs to be annotated with the <code class="literal">@WebServlet</code> annotation to be picked up by Pax Web. This is shown in the following code:</p><div class="informalexample"><pre class="programlisting">@WebServlet(urlPatterns = "/sample")
public class OsgiServiceServlet  extends HttpServlet {</pre></div><p>The servlet uses an OSGi service to retrieve simple quotes. This service is referenced via an injection, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">@Inject
@OsgiService (dynamic = true)
private MessageService messageService;</pre></div><p>The specialty of Pax CDI is the <code class="literal">@OsgiService</code> annotation. This annotation will wire the corresponding OSGi service to this servlet. The <code class="literal">dynamic = true</code> property makes sure that the dynamism of OSGi services is used.</p><p>For a smooth interaction between Pax Web and Pax CDI, a few more configurations are required. These are handled in the POM file, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">&lt;instructions&gt;
  &lt;_wab&gt;src/main/webapp/&lt;/_wab&gt;
  &lt;Bundle-SymbolicName&gt;${project.artifactId}&lt;/Bundle-SymbolicName&gt;
  &lt;Bundle-Version&gt;${project.version}&lt;/Bundle-Version&gt;
  &lt;Web-ContextPath&gt;cdi-sample&lt;/Web-ContextPath&gt;
  &lt;Pax-ManagedBeans&gt;WEB-INF/beans.xml&lt;/Pax-ManagedBeans&gt;
<span class="strong"><strong>  &lt;Require-Capability&gt;</strong></span>
<span class="strong"><strong>    org.ops4j.pax.cdi.extension;</strong></span>
<span class="strong"><strong>  &lt;/Require-Capability&gt;</strong></span>
&lt;/instructions&gt;</pre></div><p>Other than the already-known instructions such as <code class="literal">&lt;_wab&gt;</code> and <code class="literal">&lt;Web-ContextPath&gt;</code>, a CDI bundle requires the <code class="literal">&lt;Require-Capability&gt;</code> instruction. With this instruction, the resolver is informed of the fact that the web bundle requires the capability of the CDI bundle.</p></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec163"/>How it works…</h2></div></div></div><p>Pax Web registers all of the servlets of a CDI web application. These servlets wait for the initialization of the context through Pax CDI. The service is provided by another bundle. As long as this service isn't available, the servlet will not start. The other important part is the <code class="literal">&lt;Require-Capability&gt;</code> manifest entry. It helps the resolver to wire the WAR bundle<a id="id382" class="indexterm"/> to the Pax CDI extension<a id="id383" class="indexterm"/> bundle. This way, the Pax CDI extender is capable of taking care of the injections.</p><p>This <code class="literal">&lt;Require-Capability&gt;</code> header can also be bound to a specific version. To do so, the following needs to be configured instead:</p><div class="informalexample"><pre class="programlisting">&lt;Require-Capability&gt;
  org.ops4j.pax.cdi.extension;
  filter:="(&amp;amp;(extension=pax-cdi-extension)(version&amp;gt;=${version;==;${pax.cdi.osgi.version.clean}})(!(version&amp;gt;=${version;=+;${pax.cdi.osgi.version.clean}})))",osgi.extender; filter:="(osgi.extender=pax.cdi)"
&lt;/Require-Capability&gt;</pre></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec164"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Although this recipe gave you a brief overview of how to use CDI to wire services in OSGi, a lot more is possible. You can use CDI not only to wire an application within the same bundle but also to provide services through CDI and use it in another bundle. For more details about Pax CDI and the possibilities, refer<a id="id384" class="indexterm"/> to the Pax CDI project page at <a class="ulink" href="https://ops4j1.jira.com/wiki/display/PAXCDI/Documentation">https://ops4j1.jira.com/wiki/display/PAXCDI/Documentation</a>.</li><li class="listitem" style="list-style-type: disc">Some more samples can be found at <a class="ulink" href="https://github.com/ops4j/org.ops4j.pax.cdi/tree/master/pax-cdi-samples">https://github.com/ops4j/org.ops4j.pax.cdi/tree/master/pax-cdi-samples</a>.</li></ul></div></div></div></body></html>