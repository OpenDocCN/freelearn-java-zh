- en: Chapter 10. Securing WildFly
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Security is a key element of any enterprise application. You must be able to
    control and restrict who is permitted to access your applications and what operations
    users may perform.
  prefs: []
  type: TYPE_NORMAL
- en: The **Java Enterprise Edition** (**Java EE**) specification defines a simple,
    role-based security model for **Enterprise Java Beans** (**EJBs**) and web components.
    The implementation of JBoss security is delivered by the PicketBox framework (formerly
    known as the JBoss security), which provides authentication, authorization, auditing,
    and mapping capabilities to Java applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'As the number of topics concerned with security requires a book in its own
    right, this chapter will focus on the topics that are of interest to the majority
    of administrators and developers. We will cover the following topics in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: A short introduction to the Java security API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The basics of the WildFly security subsystem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining login modules and their integration with various enterprise components
    (for example, web application EJB)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Securing the management interfaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using **Secure Sockets Layer** (**SSL**) to encrypt network calls to web applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Approaching Java security API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Java EE security services provide a robust and easily configurable security
    mechanism to authenticate users and authorize access to application functions
    and associated data. To better understand the topics related to security, we will
    first provide some basic definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Authentication** is the process of ensuring that a person is who he claims
    to be. Authentication is usually performed by checking that a user''s login credentials
    match those stored in a datastore. Login credentials typically consist of a username
    and password but can also be in the form of an X.509 certificate or **one-time
    password** (**OTP**). The following figure demonstrates the flow of a login process.
    The end user provides a username and password, which is submitted to the application
    server. The login module checks the user''s details against those stored in a
    datastore. If the credentials match, the user is logged in; if the credentials
    do not match, then the login process will fail. Have a look at the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Approaching Java security API](img/6232OS_10_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Authorization** is the process by which you verify that a user has the permission
    to access a particular system resource. Authorization should occur after authentication
    has taken place. Have a look at the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Approaching Java security API](img/6232OS_10_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In Java EE, the component containers are responsible for providing application
    security. A container basically provides two types of security: **declarative**
    and **programmatic**.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Declarative security** defines an application component''s security requirements
    by means of deployment descriptors and/or annotations. A deployment descriptor
    is an external file that can be modified without the need to recompile the source
    code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For example, Enterprise JavaBeans components can use an EJB deployment descriptor
    that must be named `ejb-jar.xml` and placed in the `META-INF` folder of the EJB
    JAR file.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Web components use a web application deployment descriptor named `web.xml` located
    in the `WEB-INF` directory.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Annotations are specified within a class file, which means any changes will
    require the code to be recompiled.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Using annotations provides many benefits over deployment descriptors. First,
    it is clearer in the source code as to what is happening rather than having this
    information scattered over various XML files. Second, it is easier to maintain
    as there are fewer configuration files.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The use of annotations also means less boilerplate code for the developer.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Programmatic security** comes into the picture when security checks are embedded
    within an application code. It can be used when declarative security alone is
    not sufficient to express the security model of an application. For example, the
    Java EE security API allows the developer to test whether or not the current user
    has a specific role, using the following methods:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`isUserInRole()`: Use this method within servlets and JSPs (adopted in `javax.servlet.http.HttpServletRequest`)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`isCallerInRole()`: Use this method in EJBs (adopted in `javax.ejb.SessionContext`)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In addition, there are other API calls that provide access to the user''s identity,
    which are as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`getUserPrincipal()`: Use this method within servlets and JSPs (adopted in
    `javax.servlet.http.HttpServletRequest`)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getCallerPrincipal()`: Use this method in EJBs (adopted in `javax.ejb.SessionContext`)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Using these APIs, you can develop a complex authorization model programmatically.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While annotations themselves are programmatic, they enable a declarative style
    of security. For this reason, annotations are considered to encompass both the
    declarative and programmatic security concepts.
  prefs: []
  type: TYPE_NORMAL
- en: The Java EE security model is declarative, due to which embedding the security
    code into your business component is not an option. The term declarative here
    means that you describe the security roles and permissions in a standard XML descriptor.
    Declarative security allows the logic from this cross-cutting concern to be extracted
    away from core business logic. This results in a clearer and more readable code.
  prefs: []
  type: TYPE_NORMAL
- en: The default implementation of the declarative security model is based on **Java
    Authentication and Authorization Service** (**JAAS**) login modules and subjects.
    WildFly security has a security proxy layer that allows the developer to create
    custom security services if the default implementation does not suffice. This
    allows custom security to be built independently of the bean object using it,
    without polluting the business code.
  prefs: []
  type: TYPE_NORMAL
- en: WildFly uses the PicketBox framework, which builds on JAAS. PicketBox is used
    to secure all the Java EE technologies running in the application server.
  prefs: []
  type: TYPE_NORMAL
- en: The WildFly security subsystem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The WildFly security subsystem is an extension of the application server and
    is included by default in both the standalone servers and domain servers. Have
    a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the default security subsystem contained in the server configuration
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the configuration is pretty short, as it relies largely on default
    values, especially for high-level structures, such as the security management
    area.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A security domain does not explicitly require an authorization policy. If a
    security domain does not define an authorization module, the default `jboss-web-policy`
    and `jboss-ejb-policy` authorizations are used. In such a case, the delegating
    authorization policy is applied, which simply delegates the authorization to another
    module declared as `<module-option>`.
  prefs: []
  type: TYPE_NORMAL
- en: You can override the default authentication/authorization managers with your
    own implementation by defining your own security management configuration. It
    is unlikely that you will have to override these interfaces, so we will concentrate
    on the `security-domain` element, which is a core aspect of the WildFly security
    subsystem.
  prefs: []
  type: TYPE_NORMAL
- en: A **security domain** can be imagined as a customs office for foreigners. Before
    the request crosses the WildFly borders, the security domain performs all the
    required authorization and authentication checks and notifies the caller whether
    they can proceed or not.
  prefs: []
  type: TYPE_NORMAL
- en: Security domains are generally configured at server startup or in a running
    server and subsequently bound to the JNDI tree under the key `java:/jaas/`. Within
    the security domain, you can configure login authentication modules so that you
    can easily change your authentication provider by simply changing its login module.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table describes all the available login modules, including a
    short description of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Login module | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `Client` | This login module is designed to establish caller identity and
    credentials when AS is acting as a client. It should never be used as part of
    a security domain for actual server authentication. |'
  prefs: []
  type: TYPE_TB
- en: '| `Database` | This login module loads user/role information from a database.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `Certificate` | This login module is designed to authenticate users based
    on the X.509 certificates. |'
  prefs: []
  type: TYPE_TB
- en: '| `CertificateRoles` | This login module extends the `Certificate` login module
    to add role-mapping capabilities from a properties file. |'
  prefs: []
  type: TYPE_TB
- en: '| `DatabaseCertificate` | This login module extends the `Certificate` login
    module to add role-mapping capabilities from a database table. |'
  prefs: []
  type: TYPE_TB
- en: '| `DatabaseUsers` | This is a JDBC-based login module that supports authentication
    and role mapping. |'
  prefs: []
  type: TYPE_TB
- en: '| `Identity` | This login module simply associates the principles specified
    in the module options with any subject authenticated against the module. |'
  prefs: []
  type: TYPE_TB
- en: '| `Ldap` | This login module loads user/role information from an LDAP server.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `LdapExtended` | This login module is an alternate LDAP login module implementation
    that uses searches to locate both the user as well as the associated roles to
    bind the authentication. |'
  prefs: []
  type: TYPE_TB
- en: '| `RoleMapping` | This login module is used to map roles that are the end result
    of the authentication process to one or more declarative roles. |'
  prefs: []
  type: TYPE_TB
- en: '| `RunAs` | This login module can be used to allow another login module to
    interact with a secured EJB that provides authentication services. |'
  prefs: []
  type: TYPE_TB
- en: '| `Simple` | This login module is used to quickly set up the security for testing
    purposes. |'
  prefs: []
  type: TYPE_TB
- en: '| `ConfigureIdentity` | This is a login module that associates the principles
    specified in the module options with any subject authenticated against the module.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `PropertiesUsers` | This login module uses a properties file to store the
    username and password for authentication. No roles are mapped. |'
  prefs: []
  type: TYPE_TB
- en: '| `SimpleUsers` | This login module stores username and password as options.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `LdapUsers` | This login module authenticates users using a LDAP server.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `Kerberos` | This login module uses Sun''s `Kerberos` login module as a mechanism
    for authentication. |'
  prefs: []
  type: TYPE_TB
- en: '| `SPNEGOUsers` | This login module works in conjunction with `SPNEGOAuthenticator`
    to handle the authentication. |'
  prefs: []
  type: TYPE_TB
- en: '| `AdvancedLdap` | This login module is a refactoring of the `LdapExtLoginModule`,
    which is able to separate the login steps (find, authenticate, or map roles) so
    that any of the actions can be undertaken separately. |'
  prefs: []
  type: TYPE_TB
- en: '| `AdvancedADLdap` | This login module is an extension of the `AdvancedLdap`
    login module, which is also able to query the primary group of the user being
    authenticated. |'
  prefs: []
  type: TYPE_TB
- en: '| `UsersRoles` | This login module is a simple properties-map-based login module
    that consults two Java properties-formatted text files to map the username to
    the password (`users.properties`) and username to roles (`roles.properties`).
    |'
  prefs: []
  type: TYPE_TB
- en: 'Activating a login module is a two-step procedure, which is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: First, you need to define the login module within your `standalone.xml/domain.xml`
    configuration file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, you need to tell your applications to use a login module to perform authentication
    and authorization.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In earlier releases of the application server, the login module was configured
    in a separate file named `login-config.xml`. Porting earlier login modules into
    the new application server is not too complex, as the format of the login module
    is pretty much the same as the new application server.
  prefs: []
  type: TYPE_NORMAL
- en: We will now expand these points in more detail. Let's see first how to define
    some commonly-used login modules, and then we will apply them to the Java EE components,
    such as servlets, EJB, and web services.
  prefs: []
  type: TYPE_NORMAL
- en: Using the UsersRoles login module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `UsersRoles` login module is one of the simplest security domains that
    can be implemented for testing purposes in your applications. It is based on two
    files, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`users.properties`: This file contains the list of usernames and passwords'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`roles.properties`: This file contains the mapping between the users and the
    roles'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is a sample `UsersRoles` configuration that stores the security files
    in the application server''s configuration directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'All you need to do to start using your security domain is add the two properties
    files into the specified path (for a standalone system, the default is `JBOSS_HOME/standalone/configuration`)
    and add your username and password within it. This login module does not support
    hashed passwords; only clear passwords are supported. For example, the `users.properties`
    file can contain something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The `roles.properties` file contains the sets of roles for a given username.
    Adding a suffix to the username, as shown in the second line of the following
    code, allows you to assign the username roles to a group of roles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This means that authenticating with the admin/admin credentials will assign
    the role of manager to the user.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Database login module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A database security domain follows the same logic exposed in the earlier example,
    the difference being that it stores the credentials within the database. In order
    to run this example, we need to refer to the `MySqlDS` datasource that we created
    earlier, in [Chapter 3](ch03.html "Chapter 3. Configuring Enterprise Services"),
    *Configuring Enterprise Services*. Have a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You will notice in the `rolesQuery` module option that there is a second select
    item (`Roles`). This corresponds to a `RoleGroup` column and must always be supplied
    with "R" (in capital letters)..
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to start using this configuration, you first have to create the required
    tables and insert some sample data into it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the admin user will map to the `Manager` role. One caveat of
    this configuration is that it uses clear-text passwords in the database so, before
    rolling this module production, you should consider additional security for your
    login module. Let's see how you can do this in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Encrypting passwords
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Storing passwords in the database as clear-text strings is not considered a
    good practice. As a matter of fact, a database has even more potential security
    issues than a regular filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, securing application passwords is relatively easy and can be achieved
    by adding a few extra options to your login module. As a minimum, you need to
    specify that the stored passwords are encrypted using a **message digest algorithm**.
    For example, in the `mysqlLogin` module, you can add the highlighted lines at
    the end:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Here, we specified that the password will be hashed against an `MD5` hash algorithm;
    you can alternatively use any other algorithm allowed by your JCA provider, such
    as SHA.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For a production environment, you should avoid MD5 hashing, as it is a very
    weak hash. Ideally, you should use something like SHA-512 with a large number
    of hash iterations. You should also use a single, randomly generated salt per
    user. At the time of writing, one of the best hashing algorithms is bcrypt, which
    generates the salt for you. You should do your research before making a final
    decision. These encryptions are not supported by the `DatabaseServerLoginModule`,
    so you will need to create your own custom login module. Refer to the following
    link to write a custom login module: [https://docs.jboss.org/jbossas/docs/Server_Configuration_Guide/4/html/Writing_Custom_Login_Modules-A_Custom_LoginModule_Example.html](https://docs.jboss.org/jbossas/docs/Server_Configuration_Guide/4/html/Writing_Custom_Login_Modules-A_Custom_LoginModule_Example.html).'
  prefs: []
  type: TYPE_NORMAL
- en: 'For the sake of completeness, we include here a small application, which uses
    the `java.security.MessageDigest` and the `org.jboss.security.Base64Util` classes
    to generate the base-64 hashed password to be inserted in the database. Have a
    look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the main program with `admin` as the argument generates the hash **X8oyfUbUbfqE9IWvAW1/3**.
    This hash will be the updated password for the admin user of our database. Have
    a look at the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Encrypting passwords](img/6232OS_10_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are not using Java 8, you can use the `org.jboss.security.Base64Utils`
    library instead of `Java 8` as shown in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Using an LDAP login module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The **Lightweight Directory Access Protocol** (**LDAP**) is the *de facto*
    standard for providing directory services to applications. An LDAP server can
    provide central directory information for the following:'
  prefs: []
  type: TYPE_NORMAL
- en: User credentials (login and password)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User directory information (such as names and e-mail addresses)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Web directories
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The working of LDAP revolves around a data structure known as **entry**. An
    entry has a set of named component parts called **attributes** that hold the data
    for that entry. These attributes are like the fields in a database record.
  prefs: []
  type: TYPE_NORMAL
- en: An entry's content and structure are defined by its object class. The object
    class (along with server and user settings) specifies which attributes must exist
    and which may exist in that particular entry.
  prefs: []
  type: TYPE_NORMAL
- en: 'All entries stored in an LDAP directory have a unique **distinguished name**
    or **DN**. The DN for each LDAP entry is composed of two parts: the **relative
    distinguished name** (**RDN**) and the location within the LDAP directory where
    the record resides.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In practice, the RDN is the portion of your DN that is not related to the directory
    tree structure and, in turn, is composed of one or several attribute names/value
    pairs. Let''s see a concrete example of an organization, as shown in the following
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using an LDAP login module](img/6232OS_10_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding diagram, `cn=John Smith` (where `cn` stands for "common name")
    could be an RDN. The attribute name is `cn`, and the value is `John Smith`.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, the DN for `John Smith` would be `cn=John Smith`, `ou=Marketing`,
    `o=Acme`, and `c=US` (where `ou` is short for organizational unit, `o` is short
    for organization, and `c` is for country).
  prefs: []
  type: TYPE_NORMAL
- en: Connecting LDAP to WildFly
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Connecting WildFly and LDAP can be done by means of several LDAP login modules.
    The first and obvious thing we need to do is run an instance of an LDAP server.
    Today, there are a huge number of LDAP servers available (both commercial and
    open source), and maybe you already configured one to run in your company. Just
    in case you don't have one, or simply don't want to add sample data to it, we
    suggest you have a look at the Apache Directory project ([http://directory.apache.org/](http://directory.apache.org/)).
    It provides an excellent solution to get started with LDAP and to build complex
    directory infrastructures.
  prefs: []
  type: TYPE_NORMAL
- en: Once installed, we suggest that you use the Apache Directory Studio (available
    at the same link), as it allows you to quickly create a directory infrastructure.
    The simplest way to create a directory from scratch is by means of an **LDAP Data
    Interchange Format** (**LDIF**) file. Within this file, you can specify all entries
    that will be loaded by the LDAP engine.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A quick shortcut to import an LDIF file from the Apache studio is in the file
    menu **File** | **Import** | **LDIF** into **LDAP**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a basic LDIF file we will use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you import this information into the LDAP server, you will end up with
    a small directory, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Connecting LDAP to WildFly](img/6232OS_10_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Within this directory, we have just one user registered as `admin`, belonging
    to the `Manager` role, as in other login modules we have seen in the earlier sections.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will configure the LDAP connection on WildFly. For our purposes, we
    will use the `LdapExtended` login module implementation, as shown in the following
    code. This implementation uses searches to locate both the user and the associated
    roles to bind as per authentication. The `roles` query will follow distinguished
    names (DNs) recursively to navigate a hierarchical role structure. Have a look
    at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is a brief description of the `LdapExtended` module''s properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '`bindDN`: This is the DN used to bind against the LDAP server for the user
    and roles queries, which, in our case, is "`uid=admin,ou=system`".'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`baseCtxDN`: This is the fixed DN of the context to start the user search from.
    In our example, it is "`ou=People,dc=example,dc=com`.".'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`baseFilter`: This is a search filter used to locate the context of the user
    to be authenticated. The input `username` or `userDN`, as obtained from the login
    module, will be substituted into the filter anywhere a `{0}` expression is seen.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rolesCtxDN`: This is the fixed DN of the context to search for user roles.
    Consider that this is not the DN of the location of the actual roles; rather,
    this is the DN of where the objects containing the user roles are.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`roleFilter`: This is a search filter used to locate the roles associated with
    the authenticated user. An example search filter that matches on the input username
    is `(member={0})`. An alternative that matches on the authenticated user DN is
    `(member={1})`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`roleAttributeID`: This is the name of the role attribute of the context that
    corresponds to the name of the role.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`searchScope`: This sets the search scope to one of the following strings:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ONELEVEL_SCOPE`: This scope searches for users and associated roles directly
    under the named roles context.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SUBTREE_SCOPE`: If the role''s context is `DirContext`, this scope searches
    the subtree rooted at the named object, including the named object itself. If
    the role''s context is not `DirContext`, this scope searches only the object.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OBJECT_SCOPE`: This scope searches the named roles context only.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`allowEmptyPasswords`: This is a flag indicating whether `empty(length==0)`
    passwords should be passed to the LDAP server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Securing web applications
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Okay! So, we touched upon some of the commonly used login modules. These login
    modules can be used by any Java EE application, so it's time to show a concrete
    example. In this section, we will show you how to apply a login module to a web
    application in order to show an implementation of basic web authentication.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Basic access authentication is the simplest way to provide a username and password
    when making a request through a browser.
  prefs: []
  type: TYPE_NORMAL
- en: It works by sending an encoded string containing the user credentials. This
    Base64-encoded string is transmitted and decoded by the receiver, resulting in
    a colon-separated username and password string.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we need to do is turn on web authentication. This requires
    you to define the `security-constraints` in the web application configuration
    file (`web.xml`). Have a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The preceding configuration will add a security constraint to all URLs, which
    obviously includes all your JSP servlets. Access will be restricted to users authenticated
    with the `Manager` role.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Considering that we are using the `Database` login module, the `Manager` role
    will be granted to users that have authenticated with the admin credentials.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next configuration tweak needs to be performed in JBoss web deployment''s
    descriptor `WEB-INF/jboss-web.xml`. There, you need to declare the security domain
    that will be used to authenticate the users. Have a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Pay attention to the `security-domain` element. The value of this element must
    be exactly the same as the one you typed into the security domain's `name` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For an overview of which JNDI names are valid in WildFly, please refer to the
    following link: [https://docs.jboss.org/author/display/WFLY8/Developer+Guide#DeveloperGuide-ReviewtheJNDINamespaceRules](https://docs.jboss.org/author/display/WFLY8/Developer+Guide#DeveloperGuide-ReviewtheJNDINamespaceRules).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram outlines the whole configuration sequence as applied
    to a `Database` login module. Have a look at the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Securing web applications](img/6232OS_10_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Once you deploy your application, the outcome of this action should be a popup,
    requesting user authentication, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Securing web applications](img/6232OS_10_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Logging in with `admin`/`admin` will grant access to the application with the
    `Manager` role.
  prefs: []
  type: TYPE_NORMAL
- en: Securing EJBs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Securing applications by means of a web login form is the most frequent option
    in enterprise applications. Nevertheless, the HTTP protocol is not the only choice
    available to access applications. For example, EJBs can be accessed by remote
    clients using the RMI-IIOP protocol. In such a case, you should further refine
    your security policies by restricting access to the EJB components, which are
    usually involved in the business layer of your applications.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**How does security happen at EJB level?**'
  prefs: []
  type: TYPE_NORMAL
- en: Authentication must be performed before any EJB method is called, and authorization
    should be performed at the beginning of each EJB method call.
  prefs: []
  type: TYPE_NORMAL
- en: 'The basic security checks can be achieved using the following five annotations:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@org.jboss.ejb3.annotation.SecurityDomain`: This annotation specifies the
    security domain, which is associated with a specific class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@javax.annotation.security.RolesAllowed`: This annotation specifies the list
    of roles permitted to access a method(s) in an EJB.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@javax.annotation.security.RunAs`: This annotation assigns a role dynamically
    to the EJB during the invocation of a method. It can be used if you need to *temporarily*
    allow permission to access a certain method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@javax.annotation.security.PermitAll`: This annotation allows all roles to
    access a particular bean method. The purpose of this annotation is to widen security
    access to some methods in a situation where you don''t exactly know what role
    will access the EJB. (Imagine that some modules have been developed by a third
    party and they access your EJB with some poorly identified roles).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@javax.annotation.security.DenyAll`: This annotation denies access to all
    roles. It has a purpose similar to that of `PermitAll`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the following example, we are restricting access to the EJB named `SecureEJB`
    only to the authorized role of Manager:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Be careful! There is more than one `SecurityDomain` annotation available in
    the server's classpath. As shown here, you have to include `org.jboss.ejb3.annotation.SecurityDomain`.
    The `@RolesAllowed` annotation, on the other hand, calls for importing `javax.annotation.security.RolesAllowed`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Annotations can also be applied at the method level. For example, if we need
    a special role named `SuperUser` to insert a new user, then we tag the method,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Securing web services
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Web services authorization can be carried out in two ways, depending on whether
    we are dealing with a POJO-based web service or EJB-based web services.
  prefs: []
  type: TYPE_NORMAL
- en: Security changes to POJO web services are identical to those that we introduced
    for servlets or JSP, which include defining `security-constraints` into `web.xml`
    and login modules into `jboss-web.xml`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are using a web client to access your web service, that''s all you need
    to get authenticated. If you are using a standalone client, you will need to specify
    the credentials to the JAX-WS factory, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'What about EJB-based web services? The configuration is slightly different.
    As the security domain is not specified in the web descriptors, we have to provide
    it by means of annotations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the `@WebContext` annotation reflects the same configuration
    options as POJO-based web services, with BASIC authentication and unrestricted
    WSDL access.
  prefs: []
  type: TYPE_NORMAL
- en: The `@SecurityDomain` annotation should be familiar to you now, as we introduced
    it when showing you how to secure an EJB. As you can see in the preceding web
    service example, it is the equivalent of the information contained in the `jboss-web.xml`
    file (it references the `mysqldomain` security domain).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you prefer using XML deployment descriptors, the previous security configuration
    can also be specified by means of the `META-INF/ejb-jar.xml` and `META-INF/jboss-ejb3.xml`
    files.
  prefs: []
  type: TYPE_NORMAL
- en: Securing the management interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most important tasks for the system administrator is restricting
    access to the server management interfaces. Without a security policy, every user
    can gain access to the application server and modify its properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'The attribute that is used to switch on security on the management interface
    is a security realm that needs to be defined within the `security-realms` section.
    Have a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: With the default configuration, the user properties are stored in the `mgmt-users.properties`
    file and the group properties in the `mgmt-groups.properties` file. Both these
    files can be found in the `configuration` directory of your server.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Users and groups can be added to these property files at any time. Any updates
    after the server has started are detected automatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, this management realm expects the entries to be in the following
    format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This means that each user is associated with a hex-encoded hash that consists
    of the username, the name of the realm, and the password.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add new users, you can use the utility script contained in the `bin` folder
    of your WildFly installation named `add-user.sh` (Linux) or `add-user.bat` (Windows).
    As you can see from the following screenshot, the `add-user` script requires the
    following pieces of information:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Realm**: This is the name of the realm used to secure the management interfaces.
    If you just press *Enter*, the user will be added in the default realm named `ManagementRealm`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Username**: This is the username we are going to add (it needs to be alphanumeric).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Password**: This is the password field, which needs to be different from
    the username.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Groups**: This is the name of the group you want the user to be part of.
    If you leave this blank, you will not be added to any groups.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**AS process**: This determines whether you want the user to be used to connect
    to another WildFly instance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Securing the management interfaces](img/6232OS_10_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here, we have just added the user `chris` to the default realm. This resulted
    in the following property being added to `mgmt-users.properties` of your standalone
    and domain configurations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'You will now be able to connect to a remote WildFly management interface using
    this user, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Securing the management interfaces](img/6232OS_10_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'A much easier way to add users is to use a non-interactive shell. This approach
    works by passing the username, password, and optionally the realm name to the
    `add-user` script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Role-based access control
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Role-based access control** (**RBAC**) is a new feature introduced in WildFly
    8\. It allows system administrators to create users for the administration console
    but with restrictions to certain parts of the system. In JBoss AS 7, an admin
    console user had access to everything, which is equivalent to the SuperUser role
    in WildFly 8.'
  prefs: []
  type: TYPE_NORMAL
- en: 'RBAC is not enabled by default. To enable it, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, reload the server config:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'If you have existing users before enabling RBAC, you need to manually configure
    each user by mapping that user to a role. If we had a user called Yevai and wanted
    to assign her the role of SuperUser, we would do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: There are seven predefined roles in WildFly 8\. Each of them is outlined in
    the following table. They are ordered with the most restrictive roles at the top
    and the least restrictive at the bottom.
  prefs: []
  type: TYPE_NORMAL
- en: '| Role | Permissions |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Monitor | This user can read the configuration and the current runtime state
    |'
  prefs: []
  type: TYPE_TB
- en: '| Operator | This user has all the permissions of the preceding role, and can
    modify the runtime state, such as restarting or reloading the server, and flushing
    the database connection pool |'
  prefs: []
  type: TYPE_TB
- en: '| Maintainer | This user has all the permissions of all the preceding roles,
    and can modify the persistent state, such as deploying applications and setting
    up new datasources |'
  prefs: []
  type: TYPE_TB
- en: '| Deployer | This user has all the permissions of all the preceding roles,
    but with permissions to applications only. This user cannot change the configuration
    of the server |'
  prefs: []
  type: TYPE_TB
- en: '| Administrator | This user has all the permissions of all the preceding roles,
    and can view and modify sensitive data, such as the access control system |'
  prefs: []
  type: TYPE_TB
- en: '| Auditor | This user has all the permissions of all the preceding roles, and
    can view and modify resources to administer the audit-logging system |'
  prefs: []
  type: TYPE_TB
- en: '| SuperUser | This user has all permissions |'
  prefs: []
  type: TYPE_TB
- en: Configuring groups
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One of the new features in WildFly is the ability to assign users to groups.
    This means that you can assign a bunch of users to a group and then the group
    to a role. To create a new user and assign them to a group, you can run the following
    noninteractive command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Users can be managed via the admin console by a user who has the role of either
    Administrator or SuperUser. To do this, log in to the admin console, and navigate
    to the **Administration** tab. Here, you can add users to groups, create groups,
    and finally view members of each role. Have a look at the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Configuring groups](img/6232OS_10_09a.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Securing the transport layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you create a mission-critical application with just the bare concepts we
    covered until now, you will not be guaranteed to be shielded from all security
    threats. For example, if you need to design a payment gateway, where credit card
    information is transmitted by means of an EJB or servlet, using just the authorization
    and authentication stack is really not enough.
  prefs: []
  type: TYPE_NORMAL
- en: In order to prevent disclosure of information, you have to use a protocol that
    provides data **encryption**. Encryption is the conversion of data into a form
    that cannot be understood by people or systems eavesdropping on your network.
    Conversely, **decryption** is the process of converting encrypted data back into
    its original form, so it can be understood.
  prefs: []
  type: TYPE_NORMAL
- en: The protocols used to secure communication are SSL and TLS, the latter being
    considered a replacement for the older SSL.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The differences between the two protocols are minor. TLS uses *stronger* encryption
    algorithms and has the ability to work on different ports. For the rest of our
    chapter, we will refer to SSL for both protocols.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two basic techniques to encrypt information: **symmetric encryption**
    (also called **secret key** encryption) and **asymmetric encryption** (also called
    **public key** encryption).'
  prefs: []
  type: TYPE_NORMAL
- en: Symmetric encryption is the oldest and best-known technique. It is based on
    a secret key, which is applied to the text of a message to change the content
    in a particular way. As long as both the sender and recipient know the secret
    key, they can encrypt and decrypt all messages that use this key. These encryption
    algorithms typically work fast and are well-suited to encrypting blocks of messages
    at once.
  prefs: []
  type: TYPE_NORMAL
- en: One significant issue with symmetric algorithms is the requirement of an organization
    to distribute keys to users. This generally results in more overhead from the
    administrative aspect, while the keys remain vulnerable to unauthorized disclosure
    and potential misuse.
  prefs: []
  type: TYPE_NORMAL
- en: For this reason, a mission-critical enterprise system usually relies on asymmetric
    encryption algorithms. These tend to be easier to employ, manage, and make the
    system ultimately more secure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Asymmetric cryptography, also known as public key cryptography, is based on
    the concept that the key used to encrypt the message is not the one used to decrypt
    the message. Each user holds a couple of keys: the public key, which is distributed
    to other parties, and the private key, which is kept in secret. Each message is
    encrypted with the recipient''s public key and can only be decrypted (by the recipient)
    with their private key. Have a look at the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Securing the transport layer](img/6232OS_10_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Using asymmetric encryption, you can be sure that your message cannot be disclosed
    by a third party. However, you *still* have one vulnerability.
  prefs: []
  type: TYPE_NORMAL
- en: Let's suppose you want to exchange information with a business partner, so you
    are requesting their public key by telephone or by e-mail. A fraudulent user intercepts
    your e-mail or simply listens to your conversation and quickly sends you a fake
    e-mail with their public key. Now, even if your data transmission is secured,
    it will be directed to the wrong person! This type of eavesdropping is called
    the man-in-the-middle attack.
  prefs: []
  type: TYPE_NORMAL
- en: In order to solve this issue, we need a document that verifies that the public
    key belongs to an individual. This document is called a **digital certificate**
    or the public key certificate. A digital certificate consists of a formatted block
    of data that contains the name of the certificate holder (which may be either
    a username or a system name), the holder's public key, and the digital signature
    of a **Certification Authority** (**CA**) for authentication. The certification
    authority attests that the sender's name is the one associated with the public
    key in the document.
  prefs: []
  type: TYPE_NORMAL
- en: 'A prototype of a digital certificate is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Securing the transport layer](img/6232OS_10_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Public key certificates are commonly used for secure interaction with websites.
    By default, web browsers ship with a set of predefined CAs. They are used to verify
    that the public certificate served to the browser when you enter a secure site
    has been actually issued by the owner of the website. In short, if you connect
    your browser to `https://www.abc.com` and your browser doesn't give certificate
    warning, you can be sure that you can safely interact with the entity in charge
    of the site.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Simple authentication and client authentication**'
  prefs: []
  type: TYPE_NORMAL
- en: In the previous example, we depicted a simple server authentication. In this
    scenario, the only party that needs to prove its identity is the server.
  prefs: []
  type: TYPE_NORMAL
- en: However, SSL is also able to perform a **mutual** **authentication** (also called
    client or two-way authentication) in case the server requests a client certificate
    during the SSL handshake over the network.
  prefs: []
  type: TYPE_NORMAL
- en: The client authentication requires a client certificate in the X.509 format
    from a CA. The X.509 format is an industry-standard format for SSL certificates.
    In the next section, we will explore the available tools to generate digital certificates
    and also how you can have your certificates signed by a CA.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling the Secure Socket Layer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: WildFly uses the **Java Secure Socket Extension** (**JSSE**), which is bundled
    in the Java Standard Edition to leverage the SSL/TLS communication.
  prefs: []
  type: TYPE_NORMAL
- en: 'An enterprise application can secure two protocols: HTTP and RMI. HTTP communication
    is handled by the Undertow subsystem within the `standalone.xml`/`domain.xml`
    file. Securing the RMI transport is not always a compelling requirement for your
    applications as, in most production environments, WildFly is placed behind a firewall.'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see from the following diagram, your EJBs are not directly exposed
    to untrusted networks and are usually connected via a web server.
  prefs: []
  type: TYPE_NORMAL
- en: '![Enabling the Secure Socket Layer](img/6232OS_10_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In order to configure WildFly to use SSL, we need a tool that generates a public
    key/private key pair in the form of an X.509 certificate for use by the SSL server
    sockets. This is covered in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Certificate management tools
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One tool that can be used to set up a digital certificate is `keytool`, a key
    and certificate management utility that ships with the Java SE. It enables users
    to administer their own public/private key pairs and associated certificates for
    use in self-authentication (where the user authenticates himself or herself to
    other users or services) or data integrity and authentication services using digital
    signatures. It also allows users to cache the public keys (in the form of certificates)
    of their communicating peers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `keytool` certificate stores the keys and certificates in a file termed
    as `keystore`, a repository of certificates used to identify a client or a server.
    Typically, a `keystore` contains a single client or server''s identity, which
    is password protected. Let''s see an example of `keystore` generation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This command creates the `keystore` named `wildfly.keystore` in the working
    directory and assigns it the password `mypassword`. It generates a public/private
    key pair for the entity whose "distinguished name" has a common name `packtpub`,
    the organization `PacktPub`, and a two-letter country code of `GB`.
  prefs: []
  type: TYPE_NORMAL
- en: This results in a self-signed certificate (using the RSA signature algorithm)
    that includes the public key and the distinguished-name information. This certificate
    will be valid for 180 days and is associated with the private key in a `keystore`
    entry referred to by the alias as `wildflybook`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A self-signed certificate is a certificate that has not been verified by a CA
    and hence leaves you vulnerable to the classic man-in-the-middle attack. A self-signed
    certificate is only suitable for in-house use or for testing while you wait for
    the official certificate to arrive.
  prefs: []
  type: TYPE_NORMAL
- en: Securing HTTP communication with a self-signed certificate
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now let's see how you can use this `keystore` file to secure your WildFly web
    channel. Open the server configuration file (`standalone.xml/domain.xml`), and
    navigate to the undertow subsystem.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to add an `https-listener` element to the server configuration,
    as shown in bold in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, create a new security realm within the `management` element. The mandatory
    attributes are highlighted in bold in the following code. There is the path of
    the keystore, along with its password. The `keystore` element also takes `alias`,
    `relative-to`, and `key-password` attributes, all of which are optional:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Last of all, you will need to copy the `wildfly.keystore` file to your `JBOSS_HOME/standalone/configuration`
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: Restart WildFly to load these changes. At the bottom of your console logs, during
    server startup, you should see the following printout (**Undertow HTTPS listener
    https listening on /127.0.0.1:8443**).
  prefs: []
  type: TYPE_NORMAL
- en: '![Securing HTTP communication with a self-signed certificate](img/6232OS_10_12a.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If you try to access a web application via HTTPS on your SSL-configured WildFly
    server, for example, if you deploy `chapter4` and access it via `https://localhost:8443/chapter4`,
    you will be greeted by the following screen (the screen displayed will depend
    on your browser):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Securing HTTP communication with a self-signed certificate](img/6232OS_10_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you are unfamiliar with how certificates work, once the browser has established
    a secure connection with the web server, the web server sends a certificate back
    to the browser. Because the certificate we just installed has *not been* signed
    by any recognized CA, the browser security sandbox warns the user about the potential
    security threat.
  prefs: []
  type: TYPE_NORMAL
- en: As this is an in-house test, we can safely proceed by choosing **I Understand
    the Risks** | **Add Exception** | **Confirm Security Exception**. That's all you
    need to do in order to activate the SSL with a self-signed certificate.
  prefs: []
  type: TYPE_NORMAL
- en: Securing the HTTP communication with a certificate signed by a CA
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to get a certificate that your browser recognizes, you need to issue
    a **certificate-signing request** (**CSR**) to a CA. The CA will then return a
    signed certificate that can be installed on your server. Most of these services
    are not free. The cost depends on the number of certificates you are requesting,
    the encryption strength, and other factors. StartSSL provides a free, low assurance
    certificate for servers on a public domain name.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, to generate a CSR, you need to use the `keystore` that you created earlier
    and `keyentry`. Have a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'This will create a new certificate request named `certreq.csr`, with the format
    shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The following certificate needs to be sent to a CA assuming, for example, you
    have chosen **Verisign** ([http://www.verisign.com](http://www.verisign.com))
    as the CA:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Securing the HTTP communication with a certificate signed by a CA](img/6232OS_10_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'After submitting your CSR, the CA will return a signed certificate that needs
    to be imported into your keychain. Let''s suppose that you have saved your CA
    certificate in a file named `signed_ca.txt`. Have a look at the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `-import` option is used to add a certificate or certificate chain
    to the list of trusted certificates as specified by the `-keystore` parameter
    and identified by the `-alias` parameter. The parameter `-storepass` specifies
    the password that is used to protect the `keystore`. If the `-keypass` option
    is not provided, and the private key password is different from the `keystore`
    password, you will be prompted for it.
  prefs: []
  type: TYPE_NORMAL
- en: Now, your web browser will recognize your new certificate as being signed by
    a CA and will no longer complain that it cannot validate the certificate.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We began this chapter discussing the basic concepts of security and the difference
    between authentication and authorization.
  prefs: []
  type: TYPE_NORMAL
- en: Authentication is used to verify the identity of a user, while authorization
    is used to check if the user has the rights to access a particular resource.
  prefs: []
  type: TYPE_NORMAL
- en: WildFly uses the PicketBox framework. PicketBox sits at the top of the Java
    Authentication and Authorization Service (JAAS) and secures all the Java EE technologies
    running in the application. The core section of the security subsystem is contained
    in the security-domain element, which performs all the required authorization
    and authentication checks.
  prefs: []
  type: TYPE_NORMAL
- en: We then took a look at some of the login modules used to check user credentials
    against different datastores. Each login module can be used by enterprise applications
    in either a programmatic or a declarative way. While programmatic security can
    provide a fine-grained security model, you should consider using declarative security,
    which allows a clean separation between the business layer and the security policies.
  prefs: []
  type: TYPE_NORMAL
- en: Later in the chapter, you saw how you can secure the management interfaces,
    namely, the new command-line interface, by adding a security realm to them.
  prefs: []
  type: TYPE_NORMAL
- en: In the last section of this chapter, we looked at how you can encrypt the communication
    channel using the Secure Socket Layer and how you can use certificates produced
    by the `keytool` Java utility.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will end our discussion of WildFly by showing how you
    can configure and distribute enterprise applications on OpenShift, a JBoss cloud
    solution.
  prefs: []
  type: TYPE_NORMAL
