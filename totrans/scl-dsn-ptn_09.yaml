- en: Behavioral Design Patterns – Part Two
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The group of behavioral design patterns is a relatively big one. In the previous
    chapter, we looked at the first part of behavioral design patterns and understood
    what their purpose is. As we already know, these patterns are used to deal with
    behavior and modeling object communication in computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will continue going through the different behavioral design
    patterns as seen from the point of view of Scala. We will look at the following
    topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Iterator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mediator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memento
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Observer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: State
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Template method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visitor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The design patterns that we will cover in this chapter might not be as relevant
    to functional programming as some of the others we've seen earlier. They might
    look like Scala implementations of Java design patterns and this will actually
    be the case. However, this does not make them unnecessary and they are still important
    due to the hybrid nature of Scala.
  prefs: []
  type: TYPE_NORMAL
- en: As in the previous chapters, we will follow the same structure, give a pattern
    definition, show a class diagram and a code example, and talk about the pros and
    cons of the specific design pattern.
  prefs: []
  type: TYPE_NORMAL
- en: The iterator design pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We use iterators in software projects all the time. When we traverse a list
    or go through the items of a set or a map, we use an **iterator**.
  prefs: []
  type: TYPE_NORMAL
- en: The iterator design pattern provides a way to access the elements of an aggregate
    object (collection) in a sequential manner without exposing the underlying representation
    of the items.
  prefs: []
  type: TYPE_NORMAL
- en: When using the iterator design pattern, the developer doesn't need to know whether
    there is a linked list, array, tree, or a hash map underneath.
  prefs: []
  type: TYPE_NORMAL
- en: Example class diagram
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using the iterator design pattern, we can create our own objects that act as
    collections and we can use them in loops. In Java, there is an interface called
    `Iterator`, which we can implement for this purpose. In Scala, we can mix in the
    `Iterator` trait and implement its `hasNext` and `next` methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the class diagram and the example, let''s have a **ClassRoom** class that
    will support a foreach loop running through all students. The following diagram
    shows our class diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2c7a71c4-8afa-4b1a-8caf-e6f2ee9dd195.png)'
  prefs: []
  type: TYPE_IMG
- en: We've decided on our **ClassRoom** class to implement **Iterable**, which should
    return an **Iterator** and then return a new instance of our iterator when the
    method is called. The iterator design pattern is represented by the right-hand
    side of the diagram. The rest of the diagram is something we've done to make working
    with our class easier.
  prefs: []
  type: TYPE_NORMAL
- en: Code example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s see the code that implements the preceding diagram. First of all, the
    `Student` class is simply a case class that looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We have implemented the standard Scala `Iterator` trait in the `StudentIterator`
    class. Here is the implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: One thing to know about iterators is that they work in only one direction and
    you cannot go back. That's why we simply use a `currentPos` variable to remember
    how far we are in an iteration. We have used a mutable variable here, which is
    against the Scala principles; however, this is just an example and it is not too
    critical. In practice, you would probably use the iterator design pattern in conjunction
    with data structures, rather than in this form. The reason we've chosen the underlying
    structure of the iterator to be an `Array` is that indexing access of arrays is
    constant and it will improve the performance of large collections and keep our
    implementation simple.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding code is really enough to show the iterator design pattern. The
    rest of the code is here to help us show how it can be used. Let''s have a look
    at the `ClassRoom` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We mix in the `Iterable` trait in the preceding code and implement its `iterator`
    method. We return our `StudentIterator`.
  prefs: []
  type: TYPE_NORMAL
- en: We've created a custom iterator just as an example. However, in reality, you
    would just implement `Iterable` in the `ClassRoom` class and return the iterator
    of the underlying collection (students, in this case).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see an example that uses our `ClassRoom` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The fact that we have mixed in the `Iterable` trait allows us to use `foreach`,
    `map`, `flatMap`, and many others on an object of the `ClassRoom` type. The following
    screenshot shows the output of our example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2f0de080-e9ce-4cea-9d7a-39600bc53d73.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see in this example, the user of our `ClassRoom` class has no idea
    about the underlying data structure that holds our `Student` objects. We could
    replace it at any time (we can even get the data of the students from a database)
    and the entire code will keep working as long as we still have the `Iterable`
    trait in our class.
  prefs: []
  type: TYPE_NORMAL
- en: What it is good for
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The iterator design pattern is used all the time in software engineering. It
    is probably one of the most often used design patterns and everyone knows about
    it. It is used with almost all collections one can think of, it is pretty simple,
    and allows us to hide the details of how a composite object is internally organized.
  prefs: []
  type: TYPE_NORMAL
- en: What it is not so good for
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One obvious drawback of our implementation, which shows a possible problem with
    the iteration design pattern, is its use in parallel code. What would happen if
    another thread adds or removes objects to or from the original collection? Our
    iterator will not reflect that and it could lead to problems due to lack of synchronization.
    Making iterators capable of handling multithreaded environments is not a simple
    task.
  prefs: []
  type: TYPE_NORMAL
- en: The mediator design pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Real-world software projects usually contain a large number of different classes.
    This helps to distribute complexity and logic so that each class does one specific
    thing, which is simple, rather than many complex tasks. This, however, requires
    classes to communicate with each other in some way in order to realize some specific
    functionality, but then keeping the loose coupling principle in place could become
    a challenge.
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of the mediator design pattern is to define an object that encapsulates
    how a set of other objects interact with each other in order to promote loose
    coupling and allow us to vary class interactions independently.
  prefs: []
  type: TYPE_NORMAL
- en: The mediator design pattern defines a specific object called **mediator** that
    enables other ones to communicate with each other instead of doing this directly.
    This reduces dependencies between them, which makes a program easy to change and
    maintain in the future as well as have it properly tested.
  prefs: []
  type: TYPE_NORMAL
- en: Example class diagram
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's imagine that we are building a system for a school where each student
    can take multiple classes and each class is taken by multiple students. We might
    want to have a functionality that notifies all the students of a specific class
    that it is canceled, or we might want to easily add or remove users from classes.
    We can impulsively start writing our code and have a list of classes as a part
    of the `student` class and a list of students in the `group` class. This way,
    however, our objects will become interconnected and not really reusable. This
    is a good use case for the mediator pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at our class diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5b14b59f-2fc7-40fe-9160-bbf7c61ed3cb.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see from the preceding diagram, the school is the mediator and it
    contains information about users to groups and groups to users. It manages the
    interaction between these entities and allows us to make our **Student** and **Group**
    classes reusable and independent from each other.
  prefs: []
  type: TYPE_NORMAL
- en: We've given an example with students and classes; however, this could be easily
    applied to any many-to-many relationships—permission groups in software, taxi
    systems, air traffic control systems, and many more.
  prefs: []
  type: TYPE_NORMAL
- en: Code example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have presented our class diagram, let''s take a look at the source
    code for the example. First of all, let''s see the model classes we have:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `Notifiable` trait in the preceding code is not needed in the current example;
    however, for example, if we add teachers, then it would be useful in the cases
    where we want to send notifications to everyone in the same group. The classes
    in the previous code can have their own independent functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `Mediator` trait has the following definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the preceding code defines methods that allow interactions
    between students and groups. The implementation of these methods is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The `School` is the actual mediator that our application will be using. As
    you can see, it does exactly what the mediator design pattern is supposed to do—keeps
    the objects from directly referring to each other and internally defines their
    interactions. An application that uses our `School` class is shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding example application is really simple—it creates objects of the
    `Student` and `Group` types and uses the mediator object to wire them up and make
    it possible for them to interact. The output of the example is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/901246e8-42dc-40cc-b003-72274b151a20.png)'
  prefs: []
  type: TYPE_IMG
- en: As the output shows, our code does exactly what is expected, and it managed
    to keep the concepts loosely coupled in the application.
  prefs: []
  type: TYPE_NORMAL
- en: What it is good for
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The mediator design pattern is good for keeping coupling between classes loose
    in an application. It helps to achieve simplicity and maintainability, while still
    allowing us to model complex interactions between objects in our applications.
  prefs: []
  type: TYPE_NORMAL
- en: What it is not so good for
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A possible pitfall when using the mediator design pattern is to put a lot of
    different interaction functionalities in one class. Mediators tend to become more
    complex with time, and it will become hard to change or understand what our application
    can do at all. Moreover, if we actually have many more classes that have to interact
    with each other, it will imminently affect the mediator as well.
  prefs: []
  type: TYPE_NORMAL
- en: The memento design pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Depending on the software we are writing, we might have a requirement to be
    able to restore the state of an object back to its previous state.
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of the memento design pattern is to provide the ability to execute
    an undo action in order to restore an object to a previous state.
  prefs: []
  type: TYPE_NORMAL
- en: 'The original memento design pattern is implemented with the help of three main
    objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Originator`: The object whose state we want to be able to restore'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Caretaker`: The object that triggers the changes to the `originator` object
    and uses the `memento` objects for rollback, if needed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Memento`: The object that carries the actual state of the originator and can
    be used to restore to one of the previous states'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is important to know that the `memento` object can be handled only by the
    originator. The caretaker and all other classes can just store it and nothing
    else.
  prefs: []
  type: TYPE_NORMAL
- en: Example class diagram
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A classic example of the memento design pattern that comes to mind is text editors.
    We can always undo whatever we have changed. We will present something similar
    in our class diagram and example.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the class diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/149ecc52-915e-4584-bbc3-aab6c184eafc.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see in the preceding diagram, our caretaker is the **TextEditorManipulator**.
    It automatically saves the state in the states stack on every manipulation. The
    **TextEditor** implements the **Originator** and creates a `memento` object and
    restores from one. Finally, the **TextEditorMemento** is the concrete `memento`
    object that our text editor will be using to save the state. Our state is just
    the current string representation of the text in the editor.
  prefs: []
  type: TYPE_NORMAL
- en: Code example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this subsection, we will go through the text editor code one step at a time
    and see how the memento design pattern could be implemented in Scala.
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, let''s see the `Caretaker`, `Memento`, and `Originator` traits:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We have used generics, and this allows us to reuse those traits multiple times
    when we want to implement the memento design pattern. Now, let''s take a look
    at the specific implementations of the traits that are necessary in our application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code shows the actual `Originator` implementation as well as the
    `Memento` one. It is common to create the memento class as being private to the
    object, which will be creating and restoring from the class, and that's why we
    have done the same. The reason for this is that the originator should be the only
    one who knows how to create and restore from a `memento` object and how to read
    its state.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let''s take a look at the `Caretaker` implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In our implementation, the caretaker exposes methods to manipulate the `originator`
    object. Before every manipulation, we save the state to the stack in order to
    be able to rollback if needed at a future point.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we''ve seen all the code for our example, let''s see an application
    that uses it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we just manually added some text to our text editor,
    deleted some characters, and then did an undo of the deletions. The following
    screenshot shows the output of this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6e153bbc-6ed5-4353-a2f8-c4d2bc73f28b.png)'
  prefs: []
  type: TYPE_IMG
- en: One possible issue with our application design that might need improvement is
    the `states` stack—we have absolutely no limit and if a lot of changes are made,
    it could grow too much. In real text editors, we cannot go back infinitely, and
    this stack is limited to a certain number of operations. Another performance issue
    could be the fact that we call `toString` on the internal `StringBuilder` on each
    operation. Passing the actual `StringBuilder`, however, could have undesired effects
    on the application, as changes will affect all of the builder's references.
  prefs: []
  type: TYPE_NORMAL
- en: What it is good for
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The memento design pattern is useful for applications that want to support a
    revertable state. In our example, we used a stack of states; however, this is
    not necessary—some applications might need only the last operation to be saved.
  prefs: []
  type: TYPE_NORMAL
- en: What it is not so good for
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Developers should be careful when they use the memento design pattern. They
    should try to have the state saved in value objects if possible because if a mutable
    type is passed, it would be changed by reference and this will lead to unwanted
    results. Developers should also be careful about how far back in time they allow
    changes to be undoable because the more operations are saved in the stack, the
    more memory will be required. Finally, Scala is immutable and the memento design
    pattern does not always coincide with the language philosophy.
  prefs: []
  type: TYPE_NORMAL
- en: The observer design pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are sometimes cases where some objects are interested in the state change
    of another object and want to perform some specific action when this happens.
    A common example could be whenever you click a button in an app; some other objects
    subscribe to the click event and perform some actions. The observer design pattern
    helps us to achieve this.
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of the observer design pattern is to have an object (called **subject**)
    that automatically notifies all of its observers of any state change by calling
    one of their methods.
  prefs: []
  type: TYPE_NORMAL
- en: The observer design pattern is employed in most GUI toolkits. It is also part
    of the MVC architectural pattern where the view is an observer. Java even comes
    with the `Observable` class and the `Observer` interface.
  prefs: []
  type: TYPE_NORMAL
- en: Example class diagram
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For the class diagram, let''s focus on the following example—we have a website
    with posts, and people can subscribe to get notifications whenever a new comment
    is added. The following diagram shows how something like this could be represented
    using the observer design pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8a5ebb64-ca4e-4f47-91c7-c15754f0b16f.png)'
  prefs: []
  type: TYPE_IMG
- en: The **Post** class is our observable, and it has observers of the **User** type
    that are notified whenever the post changes (in our case, when a comment is added).
  prefs: []
  type: TYPE_NORMAL
- en: Note that the preceding scenario is just an example. In reality, subscriptions
    can be done in a database and people will receive an email notification. However,
    if we are talking about some kind of notification while you are on the site, then
    this example is valid.
  prefs: []
  type: TYPE_NORMAL
- en: The observer pattern in the example could and probably should be replaced with
    reactive programming in Scala using Akka and actors. This way, we could achieve
    much better scalability and implement a proper asynchronous publish-subscribe
    system.
  prefs: []
  type: TYPE_NORMAL
- en: In the following subsection, we will take a look at the code that represents
    the preceding diagram.
  prefs: []
  type: TYPE_NORMAL
- en: Code example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, let''s go through all the code that represents the preceding diagram.
    First, let''s see the `Observer` interface. We have decided to have it as a trait
    that can be mixed in any class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This is extremely simple. Next, we will take a look at the `Observable` class.
    It is a trait that can also be mixed in and can make classes observable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we have used a self-type in order to make sure that we
    limit how the `Observable` trait is mixed in. This makes sure that the parameterized
    type will be the same as that of the object we are mixing it into.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our implementation of the `Observer` interface will be our `User` class. It
    has the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: It is as simple as implementing one method and doing something with the changed
    `Post` subject.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Comment` class is just a simple model class that has nothing special about
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Post` class will be `Observable`. On every comment that is added, this
    class will notify all the registered observers. The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'All the preceding code snippets implement our observer design pattern. It is
    interesting to see how this works in an example. The following block of code has
    an example of how our classes can be used together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of our application is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8da265bf-706e-4497-9c27-6814a9f64a41.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see in the preceding screenshot, the observer design pattern is quite
    easy to implement. As we mentioned earlier, a better approach would be to use
    reactive programming in order to make things asynchronous and more scalable. It
    will be more functional as well. We will see an example of how this can be done
    with Akka in the future chapters of this book.
  prefs: []
  type: TYPE_NORMAL
- en: What it is good for
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The observer design pattern is easy to implement and allows us to add new observers
    or remove old observers at runtime. It helps to decouple logic and communication,
    which makes for some good quality classes that have only one responsibility.
  prefs: []
  type: TYPE_NORMAL
- en: What it is not so good for
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In functional programming with Scala, one would possibly prefer using Akka and
    creating a publish-subscribe design instead. Moreover, in the observer design
    pattern, object references are held in the observer's collection of the subject,
    which could cause memory leaks or unnecessary allocations during the lifetime
    of the application or the subject object. Finally, as with any other design pattern,
    the observer design pattern should be used only where necessary. Otherwise, we
    might end up complicating our application for no good reason.
  prefs: []
  type: TYPE_NORMAL
- en: The state design pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The state design pattern is really similar to the strategy design pattern that
    we looked at in the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of the state design pattern is to allow us to choose a different
    behavior of an object based on the object's internal state.
  prefs: []
  type: TYPE_NORMAL
- en: 'Basically, the difference between the state design pattern and the strategy
    design pattern comes from the following two points:'
  prefs: []
  type: TYPE_NORMAL
- en: The strategy design pattern is about *how* an action is performed. It is usually
    an algorithm that produces the same results as other algorithms.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The state design pattern is about *what* action is performed. Depending on the
    state, an object could be doing different things.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the state design pattern also closely resembles the implementation
    of the strategy design pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Example class diagram
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Imagine a media player. Most media players have a play button—when we activate
    it, it usually changes its appearance and becomes a pause button. Clicking the
    pause button now also does something different—it pauses the playback and reverts
    to a play button. This is a good candidate for the state design pattern, where
    depending on which state the player is in, a different action happens.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following class diagram shows the classes that are needed to implement
    this functionality for the play and pause buttons:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d6e6c64d-73fd-4078-88fe-dd5b1a99e71d.png)'
  prefs: []
  type: TYPE_IMG
- en: Our **Playing** and **Paused** implementations set the state to the opposite
    one and make our player functional. Using the state design pattern also makes
    our code much more elegant—we could, of course, use if statements and depending
    on the value, perform different actions. However, it could easily get out of control
    when there are many states.
  prefs: []
  type: TYPE_NORMAL
- en: Code example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s have a look at the code for the class diagram that we showed previously.
    First of all, let''s see the `State` trait:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'It is really simple and allows the extending classes to implement the `press`
    method. We have two implementations according to our class diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We have made them simple and they only print a relevant message and then change
    the current state to the opposite state.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our model defines a `MediaPlayer` class, which looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This really is everything we need. Now, we can use our media player in the
    following application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run the preceding code, we will see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a14359fd-0bc3-4a61-b240-a059bb6e8acd.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see in the example output, the state changes on every button press
    and it performs a different action, which we've illustrated using a different
    print message.
  prefs: []
  type: TYPE_NORMAL
- en: A possible improvement to our application would involve making the state objects
    singletons. As you can see, they are always the same, so there really is no need
    to create new ones every single time.
  prefs: []
  type: TYPE_NORMAL
- en: What it is good for
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The state design pattern is really useful for making code readable and getting
    rid of conditional statements.
  prefs: []
  type: TYPE_NORMAL
- en: What it is not so good for
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The state design pattern has no major drawbacks. One thing that developers should
    be careful about is the side effects caused by the change of the state of objects.
  prefs: []
  type: TYPE_NORMAL
- en: The template method design pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes when we implement some algorithm or a family of algorithms, we define
    a common skeleton. Then later, the different implementations deal with the specifics
    of each method in the skeleton. The template method design pattern allows us to
    achieve what we mentioned previously.
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of the template method design pattern is to defer algorithm steps
    to subclasses using template methods.
  prefs: []
  type: TYPE_NORMAL
- en: The template method design pattern seems really natural to object-oriented programming.
    Whenever polymorphism is used, this actually represents the design pattern itself.
    Usually, the template method is implemented using abstract methods.
  prefs: []
  type: TYPE_NORMAL
- en: Example class diagram
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The template method design pattern is suitable for implementing frameworks.
    A typical thing here is that algorithms usually perform the same set of steps,
    and then these steps are implemented differently by different clients. You can
    come up with various possible use cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'For our example, let''s imagine that we want to write an application that will
    read some data from a data source, parse it, and find whether there is an object
    that satisfies some condition and returns it. If we think about it, we have the
    following main operations:'
  prefs: []
  type: TYPE_NORMAL
- en: Read the data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parse the data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Search for items satisfying the condition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clean up any resources if needed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following diagram shows the class diagram of our code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8daa82f0-913c-41f8-b80f-4de4a9c2e8a4.png)'
  prefs: []
  type: TYPE_IMG
- en: We have used an example that we've shown before—reading data about people from
    files. Here, however, we use it in order to find data of the person that satisfies
    a filtering function. Using the template method design pattern, we can have the
    list of the people read from files with different formats from a server, database,
    or anything that comes to mind, really. Using polymorphism, our application makes
    sure that the right methods are called and everything works correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Code example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s go through the code that represents the preceding diagram and take a
    look at what it does. First of all, our model `Person` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'There is nothing special about it. Now, let''s move on to the interesting part—the
    `DataFinder` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: We have used generics in order to make this class usable for various types.
    As you can see in the preceding code, three of the methods of the `DataFinder`
    class have no implementations, but they are still referred to in the `find` method.
    The latter is the actual template method, and the abstract methods will be implemented
    in the different classes that extend the `DataFinder`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For our example, we have provided two different implementations, one for JSON and
    one for the CSV files. The JSON finder looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The CSV finder has the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Whenever we use it, depending on what specific instance we have, the `find`
    method will call the right implementations through polymorphism. It is possible
    to add new formats and data sources by extending the `DataFinder` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using our data finders is now straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We have provided some example data files. The CSV has the following contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The following data is for the JSON file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the preceding example against these datasets will produce the following
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b306141c-93fd-4717-8962-23606b69910f.png)'
  prefs: []
  type: TYPE_IMG
- en: The code in our example uses an abstract class. This makes it slightly limiting
    in the sense that we can only extend one class. However, it would be straightforward
    to change the abstract class to a trait and then mix it into classes.
  prefs: []
  type: TYPE_NORMAL
- en: What it is good for
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you can see, whenever we have a use case where the structure of an algorithm
    is the same and we provide different implementations, we can use the template
    method design pattern. This is a really good fit for creating frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: What it is not so good for
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Whenever the frameworks we implement using the template method design pattern
    become large, it is harder to simply extend a huge class and implement a few of
    its methods. In cases like these, passing an interface to the constructor and
    using it in the skeleton might be a better idea (strategy design pattern).
  prefs: []
  type: TYPE_NORMAL
- en: The visitor design pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are some applications out there where during design time, not all possible
    use cases are known. There might be new application features coming out from time
    to time, and in order to implement them, some refactoring has to be done.
  prefs: []
  type: TYPE_NORMAL
- en: The visitor design pattern helps us add new operations to existing object structures
    without modifying them.
  prefs: []
  type: TYPE_NORMAL
- en: This helps us to design our structures separately and then use the visitor design
    pattern to add functionality on top.
  prefs: []
  type: TYPE_NORMAL
- en: Another case where the visitor design pattern could be useful is if we are building
    a big object structure with many different types of nodes that support different
    operations. Instead of creating a base node that has all the operations and only
    a few of them are implemented by the concrete nodes or use type casting, we could
    create visitors that will add the functionality we need where we need it.
  prefs: []
  type: TYPE_NORMAL
- en: Example class diagram
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Initially, when a developer sees the visitor design pattern, it seems that it
    can be easily replaced using polymorphism and can rely on the dynamic types of
    the classes. However, what if we have a huge type hierarchy? In such a case, every
    single change will have to change an interface as well, which will lead to changing
    a whole bunch of classes, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'For our class diagram and example, let''s imagine that we are writing a text
    editor and we have documents. We want to be able to save each document in at least
    two data formats, but new ones could come. The following diagram shows the class
    diagram for our application that uses the visitor design pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d50c3004-14aa-4773-913b-260d42cede9b.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see in the preceding diagram, we have two seemingly disconnected
    hierarchies. The one to the left represents our document—each document is simply
    a list of different elements. All of them subclass the **Element** abstract class,
    which has an `accept` method that accepts a **Visitor**. To the right, we have
    the visitor hierarchy—each of our visitors will mix in the `Visitor` trait, which
    contains the `visit` methods with overrides for each of our document elements.
  prefs: []
  type: TYPE_NORMAL
- en: The way the visitor pattern will work is that it will create an instance of
    `Visitor` depending on what needs to be done, and then it will be passed to the
    `Document accept` method. This way, we can add extra functionality really easily
    (different formats, in our case), and the extra functionality will not involve
    any changes to the model.
  prefs: []
  type: TYPE_NORMAL
- en: Code example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s take a step-by-step look at the code that implements the visitor design
    pattern for the previous example. First of all, we have our model of the document
    and all the elements that can build it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: There is nothing special about the preceding code, just a simple subclassing
    for the different document elements and a composition for the `Document` class
    and the elements it contains. The important method here is `accept`. It takes
    a visitor, and since the trait type is given, we can pass different visitor implementations.
    In all the cases, it calls the `visit` method of the visitor with the current
    instance passed as a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s have a look on the other side—the `Visitor` trait and its implementations.
    The `Visitor` trait looks as simple as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: In this case, it has overloads of the visit method with different concrete element
    types. In the preceding code, the visitors and elements allow us to use **double
    dispatch** in order to determine which calls will be made.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s have a look at the concrete `Visitor` implementations. The first
    one is the `HtmlExporterVisitor`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: It simply provides different implementations depending on what type of `Element`
    it gets. There are no conditional statements, just overloads.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to save the document we have in plain text, we can use the `PlainTextExporterVisitor`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'After having the visitors and the document structure, wiring everything up
    is pretty straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding example shows how to use both the visitors we implemented. The
    output of our program is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8869ffc0-c488-49cd-90c5-aba15deaeb2e.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, using the visitor is simple. Adding new visitors and new formats
    in our case is even easier. We just need to create a class that implements all
    the visitor methods and use it.
  prefs: []
  type: TYPE_NORMAL
- en: The visitor design pattern the Scala way
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As with many other design patterns we saw earlier, the visitor design pattern
    could be represented in a way that is less verbose and closer to Scala. The way
    things can be done in order to implement a visitor in Scala is the same as the
    strategy design pattern—pass functions to the `accept` method. Moreover, we can
    also use pattern matching instead of having multiple different `visit` methods
    in the `Visitor` trait.
  prefs: []
  type: TYPE_NORMAL
- en: In this subsection, we will show both the improvement steps. Let's start with
    the latter.
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, we need to make the model classes case classes in order to be
    able to use them in pattern matching:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we change our `Visitor` trait to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we will be using pattern matching, we will only need one method to implement
    it. Finally, we can have our visitor implementations as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Pattern matching is similar to the `instanceOf` checks in Java; however, it
    is a powerful feature of Scala and it is quite commonly used. Our example, then,
    doesn't need to change at all and the output will be the same as before.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will show how we can pass functions instead of visitor objects. The
    fact that we will be passing functions means that now, we can change our model
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'We moved the `accept` method implementation to the base `Element` class (which
    can also be represented as a trait) and inside this, we simply called the function
    passed as parameter. Since we will be passing functions, we can get rid of the
    `Visitor` trait and its implementations. Everything we have now is the example,
    which looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: We have moved the visitor functionality inside the functions that are part of
    the `VisitorExample` object. In the initial examples, we had a `StringBuilder`
    as part of the visitor classes. We have used curried functions in order to be
    able to pass one here. Passing these functions to the `Document` structure is
    then straightforward. Again, the result here will be identical to the previous
    versions of the example. However, we can see how much code and boilerplate classes
    we have saved.
  prefs: []
  type: TYPE_NORMAL
- en: What it is good for
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The visitor design pattern is really good for applications that have large object
    hierarchies, where adding a new functionality will involve a lot of refactoring.
    Whenever we need to be able to do multiple different things with an object hierarchy
    and when changing the object classes could be problematic, the visitor design
    pattern is a useful alternative.
  prefs: []
  type: TYPE_NORMAL
- en: What it is not so good for
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you saw in the initial version of our example, the visitor design pattern
    could be bulky and include quite a lot of boilerplate code. Moreover, if some
    component is not designed to support the pattern, we cannot really use it if we
    are not allowed to change the original code.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we went through the second group of behavioral design patterns.
    You are now familiar with iterators, mediators, memento, observer, state, template
    method, and the visitor design pattern. You might feel that these are purely object-oriented
    design patterns that don't have much to do with functional programming, and you
    would be correct. However, they are still relevant to Scala due to its hybrid
    nature and it is important to be aware of them and to know when to use them.
  prefs: []
  type: TYPE_NORMAL
- en: Some of the design patterns in this chapter are quite commonly used and can
    be seen in many projects, while others are a bit more rare and specific to some
    use cases. These patterns, combined with all the other ones you learned about
    in the previous chapters, can be used together in order to build elegant and powerful
    solutions to real-world problems.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will dive deep into functional programming theory. We
    will cover some advanced concepts that will show us how powerful Scala and functional
    programming languages in general are.
  prefs: []
  type: TYPE_NORMAL
