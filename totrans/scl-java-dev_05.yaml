- en: Chapter 5. Getting Started with the Play Framework
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 5 章. Play 框架入门
- en: This chapter commences our journey into web development in Scala. Web development
    has become an area where the choice of architectures and frameworks is tremendous.
    Finding the right tool for the job is not always a straightforward task as it
    ranges from traditional Java EE or Spring-based architectural styles to more recent
    Ruby on Rails-like approaches. Most of the existing solutions still rely on the
    adoption of the servlet-container model, whether they use lightweight containers
    such as Jetty/Tomcat or support **EJBs** (**Enterprise JavaBeans**) such as JBoss,
    Glassfish, WebSphere, or WebLogic. Many online articles and conference talks have
    tried to compare some of the alternatives, and as these frameworks evolve rapidly
    and sometimes focus on different aspects (such as frontend versus backend), compiling
    a fair and accurate list remains difficult. In the Scala world, alternatives to
    create web applications range from lightweight frameworks such as Unfiltered,
    Spray, or Scalatra to full-featured solutions such as the Lift or the Play Frameworks.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章开始了我们在 Scala 中进行 Web 开发的旅程。Web 开发已经成为一个选择架构和框架非常多的领域。找到合适的工具并不总是件简单的事，因为它涵盖了从传统的
    Java EE 或 Spring 基础架构风格到更近期的类似 Ruby on Rails 的方法。大多数现有的解决方案仍然依赖于采用 servlet 容器模型，无论它们使用的是轻量级容器如
    Jetty/Tomcat，还是支持 **EJBs**（**企业 JavaBeans**）如 JBoss、Glassfish、WebSphere 或 WebLogic。许多在线文章和会议演讲都试图比较一些替代方案，但随着这些框架的快速发展以及有时关注不同的方面（如前端与后端），编制一个公平准确的列表仍然很困难。在
    Scala 世界中，创建 Web 应用的替代方案从轻量级框架如 Unfiltered、Spray 或 Scalatra 到功能齐全的解决方案如 Lift 或
    Play 框架都有。
- en: 'We have chosen to concentrate on the Play Framework, because it embraces important
    features that we think are the key to maintainable, modern software development.
    Some of the advantages of the Play Framework are:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择专注于 Play 框架，因为它包含了我们认为对可维护的现代软件开发至关重要的重要特性。Play 框架的一些优点包括：
- en: The Play Framework is scalable and robust. It can handle large loads because
    it is built on a fully asynchronous model on the top of technologies that are
    ready to handle multicore architectures such as Akka, a framework to build concurrent
    and distributed applications that we will cover in [Chapter 8](ch08.html "Chapter 8. Essential
    Properties of Modern Applications – Asynchrony and Concurrency"), *Essential Properties
    of Modern Applications – Asynchrony and Concurrency*.
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Play 框架可扩展且稳健。它能够处理大量负载，因为它建立在完全异步模型之上，该模型基于能够处理多核架构的技术，如 Akka，这是一个用于构建并发和分布式应用的框架，我们将在[第
    8 章](ch08.html "第 8 章. 现代应用的基本特性 – 异步性和并发性")《现代应用的基本特性 – 异步性和并发性》中进行介绍。
- en: It provides us with enhanced developer productivity by promoting ease of use,
    promoting the **DRY** (short for **Don't Repeat Yourself**) principle, and taking
    advantage of the expressiveness and conciseness of Scala. In addition to that,
    the hit refresh workflow of Play by which you can simply refresh your browser
    and get instant feedback on the changes you make is a real boost in the productivity,
    in contrast with the longer deployment cycles of the Java servlet and EJB containers.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过提高易用性，推广**DRY**（即**不要重复自己**）原则，并利用 Scala 的表达性和简洁性，它为我们提供了增强的开发者生产力。除此之外，Play
    的击中刷新工作流程，通过简单地刷新浏览器即可获得对所做更改的即时反馈，与 Java servlet 和 EJB 容器的较长的部署周期相比，这实际上提高了生产力。
- en: It provides good integration with the existing legacy of infrastructure based
    on the JVM.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它与基于 JVM 的现有基础设施遗产具有良好的集成。
- en: It provides good integration with modern, client-side development trends that
    heavily rely on JavaScript/CSS and their surrounding ecosystem, including frameworks
    such as AngularJS or WebJars. Moreover, the **LESS** (short for **Leaner CSS**)
    dynamic stylesheet language as well as CoffeeScript, a small and elegant language
    that compiles to JavaScript, are supported by Play Framework without any additional
    integration.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它与现代客户端开发趋势具有良好的集成，这些趋势高度依赖于 JavaScript/CSS 及其周边生态系统，包括 AngularJS 或 WebJars
    等框架。此外，Play 框架还支持**LESS**（即**更简洁的 CSS**）动态样式表语言以及 CoffeeScript，这是一种小型而优雅的语言，编译成
    JavaScript，而无需任何额外的集成。
- en: The Play Framework Version 2.*x* exists both for Java and Scala, which is an
    additional strength as Java developers will probably get acquainted with the differences
    more quickly and may have previous experience with the Java version before moving
    on to Scala.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Play 框架版本 2.*x* 既有 Java 版本，也有 Scala 版本，这对于 Java 开发者来说是一个额外的优势，因为他们可能会更快地熟悉这些差异，并且在转向
    Scala 之前可能已经对 Java 版本有了一些经验。
- en: Several alternatives are offered to rapidly get you started with the Play Framework
    and create a minimalistic `helloworld` project. Note that all these alternatives
    create projects based on SBT, as we mentioned briefly in [Chapter 3](ch03.html
    "Chapter 3. Understanding the Scala Ecosystem"), *Understanding the Scala Ecosystem*.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 提供了几个选择，以快速开始使用 Play 框架并创建一个极简的 `helloworld` 项目。请注意，所有这些选择都是基于 SBT 创建项目的，正如我们在第
    3 章[理解 Scala 生态系统](ch03.html "第 3 章。理解 Scala 生态系统")中简要提到的。
- en: Getting started with the classic Play distribution
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用经典 Play 发行版
- en: 'Download the classic Play distribution from [http://www.playframework.com/download](http://www.playframework.com/download),
    and unpack the `.zip` archive in a directory of your choice. Add this directory
    to your path (so that running the `play` command anywhere on your filesystem will
    create a new application). With this alternative, you can open a terminal window
    and enter the following command:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 从 [http://www.playframework.com/download](http://www.playframework.com/download)
    下载经典的 Play 发行版，并将 `.zip` 压缩包解压到您选择的目录中。将此目录添加到您的路径中（这样在文件系统上的任何位置运行 `play` 命令都会创建一个新的应用程序）。使用这种替代方案，您可以在终端窗口中输入以下命令：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The following output will be displayed:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 将显示以下输出：
- en: '![Getting started with the classic Play distribution](img/3637OS_05_01.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![开始使用经典 Play 发行版](img/3637OS_05_01.jpg)'
- en: 'We just need to press *Enter* as we have already given a project name on the
    previous command. The following will be displayed on pressing *Enter*:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要按 *Enter* 键，因为我们已经在之前的命令中给出了项目名称。按 *Enter* 键后，将显示以下内容：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'That''s all; in less than a minute, we already have a fully working web app
    that we can now execute. As it is an SBT project (where the `sbt` command has
    been renamed `play` instead), we can just navigate to the root of the created
    project and start our Play session as if we were working on an SBT project. This
    is done as follows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些；不到一分钟，我们已经有了一个完全工作的网络应用程序，现在我们可以执行它。由于这是一个 SBT 项目（其中 `sbt` 命令已被重命名为 `play`），我们可以直接导航到创建项目的根目录，并开始我们的
    Play 会话，就像我们在处理一个 SBT 项目一样。这可以按照以下步骤进行：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Notice that the application is started on port 9000 by default. If you want
    a different port, you can type the following command instead:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，应用程序默认在端口 9000 上启动。如果您想使用不同的端口，可以输入以下命令代替：
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This will bring you to the Play (SBT) session, and from there, you can choose
    the port to listen to. This can be done as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这将带您进入 Play (SBT) 会话，然后您可以从那里选择要监听的端口。这可以按照以下步骤进行：
- en: '[PRE4]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Another alternative is to enter `> play "run 9095"` in the terminal.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选择是在终端中输入 `> play "run 9095"`。
- en: 'Launch a browser at `http://localhost:9095/` (9000 if you are running using
    the default port), and you should see the **Welcome to Play** page on your running
    portal:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `http://localhost:9095/`（如果您使用的是默认端口则为 9000）启动浏览器，您应该在运行的门户上看到 **欢迎使用 Play**
    页面：
- en: '![Getting started with the classic Play distribution](img/3637OS_05_02.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![开始使用经典 Play 发行版](img/3637OS_05_02.jpg)'
- en: Getting started with the Typesafe Activator
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用 Typesafe Activator
- en: 'Using the same method that we used earlier in the book to create projects based
    on the Activator templates, getting started with a Play project through the Activator
    is very straightforward. Just go to the Typesafe Activator installation directory
    and enter the following command:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 使用本书前面提到的基于 Activator 模板创建项目的方法，通过 Activator 开始 Play 项目的操作非常简单。只需转到 Typesafe
    Activator 安装目录，并输入以下命令：
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This will launch the activator in a browser window. The most basic Scala Play
    project is found in the `hello-play-scala` template. Once you have selected the
    template, notice the default location that indicates where the project will be
    created and then click on **Create**.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在浏览器窗口中启动 activator。最基础的 Scala Play 项目位于 `hello-play-scala` 模板中。一旦您选择了模板，请注意默认位置指示了项目将被创建的位置，然后点击
    **创建**。
- en: 'Let''s run our sample project either directly from the activator browser view
    or from a terminal window by navigating to the root directory of the created project
    and entering the following command in the command prompt:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Once the server is listening on port 9000, you can open the `http://localhost:9000/`
    URL in a browser. Compilation is triggered only once you access the URL, so it
    may take a few seconds for the application to show up. What should come up in
    your browser is similar to the following screenshot:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting started with the Typesafe Activator](img/3637OS_05_03.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
- en: Architecture of a Play application
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To perceive in a better way how a Play application is built, we first need to
    understand a few of its architectural aspects.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: Visualizing the framework stack
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we start exploring the code behind a typical sample Play application,
    let''s visualize the architecture of the framework using a couple of diagrams.
    First, the overall diagram of the technology stack composed of Play is shown as
    follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '![Visualizing the framework stack](img/3637OS_05_12.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
- en: On top of the JVM resides the Akka Framework, a framework to manage concurrent
    operations based on the actor model, which we will cover later in [Chapter 8](ch08.html
    "Chapter 8. Essential Properties of Modern Applications – Asynchrony and Concurrency"),
    *Essential Properties of Modern Applications – Asynchrony and Concurrency*. While
    most web frameworks today still rely on servlet containers such as Tomcat or JBoss,
    the novelty of Play is to avoid following this model by focusing on making applications
    stateless when code can be **hot swapped**, that is, replaced at runtime. Although
    widely used and deployed in commercial environments, servlet containers suffer
    from additional overheads, such as the one thread per request problem, which can
    limit the scalability when handling large loads. For a developer, the time gained
    by avoiding the redeployment of a partial or full `.ear` or `.war` archive every
    time a change in the code is made can be significant.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: On top of Akka resides a REST/HTTP integration layer, based on Spray (an open
    source toolkit to build REST/HTTP-based integration layers, now called Akka-Http),
    which produces and consumes embeddable REST services. This makes Play pertinent
    to the modern ways of writing web applications, where the backend and frontend
    communicate through HTTP REST services, exchanging mostly JSON/XML messages that
    can be rendered as HTML5 and, therefore, embrace the full power of frontend JavaScript
    frameworks.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: Finally, to be able to integrate with many other technologies of all kinds,
    such as relational or NoSQL-based databases, security frameworks, social networks,
    cloud-based or Big Data solutions, a large list of Play plugins and modules are
    listed at [http://www.playmodules.net](http://www.playmodules.net).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the request-response lifecycle
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Play follows the well-known MVC pattern, and the lifecycle of the web request
    can be seen as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '![Exploring the request-response lifecycle](img/3637OS_05_05.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![探索请求-响应生命周期](img/3637OS_05_05.jpg)'
- en: To go through the various steps of this workflow, we are going to explore a
    sample `helloworld` application that is part of the Play distribution. This `helloworld`
    application is a little more sophisticated and, therefore, more interesting than
    the pure getting started examples that we launched previously either via the Typesafe
    Activator or the plain `> play new <project>` command to create a project from
    scratch.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解这个工作流程的各个步骤，我们将探索一个作为Play发行版一部分的示例`helloworld`应用程序。这个`helloworld`应用程序比我们之前通过Typesafe
    Activator或直接使用`> play new <project>`命令从头创建的项目示例要复杂一些，因此更有趣。
- en: The `helloworld` application that we consider here can be found under the `<play
    installation root>/samples/scala/helloworld` directory (we have used the Play
    2.2.1 distribution at the time of this writing).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里考虑的`helloworld`应用程序可以在`<play安装根目录>/samples/scala/helloworld`目录下找到（在撰写本文时，我们使用了Play
    2.2.1发行版）。
- en: 'As for any Play project within the distribution that already contains the `sbteclipse`
    plugin, we can directly generate Eclipse-related files by entering the following
    command in a command prompt (at the level of the project root directory):'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何已经包含`sbteclipse`插件的Play项目，我们可以在命令提示符中直接输入以下命令来生成Eclipse相关的文件（在项目根目录级别）：
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Note that as Play commands are just a thin layer on the top of SBT, we can
    reuse the same syntax, that is, `> play eclipse` rather than `> sbt eclipse`.
    Once these are imported into the IDE, you can see the general source layout of
    a Play application in the **Package Explorer** panel on the left-hand side, as
    shown in the following screenshot:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，由于Play命令只是SBT顶层的一个薄层，我们可以重用相同的语法，即`> play eclipse`而不是`> sbt eclipse`。一旦这些被导入到IDE中，你可以在左侧的**包资源管理器**面板中看到Play应用程序的一般源布局，如下面的截图所示：
- en: '![Exploring the request-response lifecycle](img/3637OS_05_06.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![探索请求-响应生命周期](img/3637OS_05_06.jpg)'
- en: 'Let''s first run the application to see what it looks like using the following
    command:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们使用以下命令运行应用程序，看看它的样子：
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Open a browser at `http://localhost:9000/` and you should see a small web form
    similar to the following screenshot:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在`http://localhost:9000/`打开浏览器，你应该会看到一个类似于以下截图的小型网页表单：
- en: '![Exploring the request-response lifecycle](img/3637OS_05_07.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![探索请求-响应生命周期](img/3637OS_05_07.jpg)'
- en: Enter the required information and click on **Submit** to verify that you get
    your name displayed a specified number of times.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 输入所需信息，然后点击**提交**以验证是否能够显示指定次数的您的名字。
- en: 'The first step in the request flow appears in the `conf/routes` file, which
    is shown as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 请求流程的第一步出现在`conf/routes`文件中，如下所示：
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This is the place where we can define a mapping between HTTP request URLs and
    the controller code that needs to handle the request on the Play server, shown
    in the following format:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们可以定义HTTP请求URL与需要在Play服务器上处理请求的控制器代码之间映射的地方，如下所示：
- en: '[PRE10]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'For instance, accessing the `http://localhost:9000/hello` URL in the browser
    matches the following route:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在浏览器中访问`http://localhost:9000/hello` URL与以下路由相匹配：
- en: '[PRE11]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `index` method, taking no arguments, will be called on the `controller.Application.scala`
    class.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 不带任何参数的`index`方法将在`controller.Application.scala`类上被调用。
- en: This way of presenting the routing of the URLs to the controllers is different
    from the standard Java way found, for instance, in JAX-RS or Spring MVC, where
    each controller is annotated instead. In our opinion, the routing file approach
    gives us a clear overview of what the API supports, that is, the documentation,
    and it makes a Play application RESTful by default.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这种将URL路由到控制器的方式与在JAX-RS或Spring MVC中找到的标准Java方式不同，在那里每个控制器都被注解。我们认为，路由文件方法给我们提供了一个清晰的概述，即API支持什么，也就是文档，并且它使得Play应用程序默认就是RESTful的。
- en: 'Even if it seems that the `routes` file is a configuration file, it is indeed
    compiled and any typo or reference to a nonexistent controller method will be
    quickly identified. Replace `controllers.Application.index` with `controllers.Application.wrongmethod`,
    save the file, and just click on the reload button in the browser (*Ctrl* + *R*).
    You should get the error nicely displayed in the browser, as seen in the following
    screenshot:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 即使看起来 `routes` 文件是一个配置文件，它实际上也是编译过的，任何拼写错误或对不存在的控制器方法的引用都会很快被识别。将 `controllers.Application.index`
    替换为 `controllers.Application.wrongmethod`，保存文件，然后在浏览器中点击重新加载按钮（*Ctrl* + *R*）。你应该会在浏览器中看到错误被很好地显示，如下面的屏幕截图所示：
- en: '![Exploring the request-response lifecycle](img/3637OS_05_08.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![探索请求-响应生命周期](img/3637OS_05_08.jpg)'
- en: 'Notice how precise the error message is and how the exact failing line in the
    file is pointed out. This great way to display error messages on reloading the
    browser is one of the many features that makes programmers more productive. Similarly,
    even if there is no mapping error in the routes file, accessing a nonmapped URL
    that is under development (such as `http://localhost:9000/hi)` will display an
    error as well as the content of the `routes` file to show us which URLs are possible
    to invoke. This can be seen in the following screenshot:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 注意错误消息的精确性和文件中失败行的确切指出。这种在浏览器重新加载时显示错误消息的出色方式是许多使程序员更高效的功能之一。同样，即使路由文件中没有映射错误，访问开发中的未映射
    URL（例如 `http://localhost:9000/hi`）也会显示错误以及 `routes` 文件的内容，以显示哪些 URL 可以调用。这可以在以下屏幕截图中看到：
- en: '![Exploring the request-response lifecycle](img/3637OS_05_09.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![探索请求-响应生命周期](img/3637OS_05_09.jpg)'
- en: Handling a request in the controller
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在控制器中处理请求
- en: 'Moving on, let''s take a look at the `Application` class that receives and
    processes the `GET` request:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看接收并处理 `GET` 请求的 `Application` 类：
- en: '[PRE12]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `index` method performs the `Action` block, which is a function (`Request[AnyContent]
    => Result`), that takes the request and returns a `Result` object. The input parameter
    of the `Request` type is not shown here in the `index` method as it is implicitly
    passed and we are not using it in the body of the function; we could have written
    `def index = Action { implicit request =>` instead, if we wanted to. The one liner
    `Ok(html.index(helloForm))` means that the returned result should have an HTTP
    status equal to 200, that is, `Ok`, and consist of binding the `html.index` view
    to the `helloForm` model.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`index` 方法执行 `Action` 块，这是一个函数（`Request[AnyContent] => Result`），它接受请求并返回一个
    `Result` 对象。`Request` 类型的输入参数在这里的 `index` 方法中没有显示，因为它被隐式传递，并且在函数体中没有使用；如果我们想的话，可以写成
    `def index = Action { implicit request =>`。单行 `Ok(html.index(helloForm))` 表示返回的结果应该有一个
    HTTP 状态码等于 200，即 `Ok`，并且将 `html.index` 视图绑定到 `helloForm` 模型。'
- en: 'The model in this tiny example consists of a `Form` object defined in `val`
    earlier in the file. This can be seen as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个小型示例中，模型由在文件中较早定义的 `Form` 对象组成。如下所示：
- en: '[PRE13]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Each parameter is described as a `key -> value` pair, where `key` is the name
    of the parameter and `value` is the result of a function applied to the parameter
    that will produce a `play.api.data.Mapping` object. Such mapping functions are
    very useful to be able to perform a validation on the form parameters. Here, the
    `Form` parameters are expressed as a tuple object, but we could create more complex
    objects such as case classes. The sample project named *forms* in the Play distribution
    contains examples of this more advanced way of handling validation. The `fold`
    method encountered in the `sayHello` method of the controller is a way to accumulate
    validation errors to be able to report all of these errors at once. Let''s enter
    a few mistakes (such as leaving the `name` field blank or entering characters
    when numbers are required) when filling out the form to verify how errors are
    displayed. This can be seen in the following screenshot:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 每个参数都描述为一个 `key -> value` 对，其中 `key` 是参数的名称，`value` 是应用于参数的函数的结果，该函数将生成一个 `play.api.data.Mapping`
    对象。这种映射函数非常有用，可以执行对表单参数的验证。在这里，`Form` 参数被表示为一个元组对象，但我们可以创建更复杂的对象，例如案例类。Play 分发中的名为
    *forms* 的示例项目包含了这种更高级处理验证方式的示例。在控制器中的 `sayHello` 方法中遇到的 `fold` 方法是一种累积验证错误的方法，以便能够一次性报告所有这些错误。让我们在填写表单时输入一些错误（例如，将
    `name` 字段留空或在需要数字时输入字符）来验证错误是如何显示的。这可以在以下屏幕截图中看到：
- en: '![Handling a request in the controller](img/3637OS_05_10.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![在控制器中处理请求](img/3637OS_05_10.jpg)'
- en: Rendering the view
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 渲染视图
- en: 'The template used to render the view is found under the `views/index.scala.html`
    file.This template is shown as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 用于渲染视图的模板位于`views/index.scala.html`文件下。该模板如下所示：
- en: '[PRE14]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: One of the strengths of the Play template engine is that it is based on the
    Scala language itself. This is good news because we do not need to learn any new
    templating syntax; we can reuse the Scala constructs, without any additional integration.
    Moreover, the templates are compiled so that we get compile-time errors whenever
    we make a mistake; the errors will show up in the browser in the same way that
    they showed up for routes or the plain controller Scala code. This fast feedback
    can save us a lot of time compared to the more traditional techniques of using
    **JSPs** (**JavaServer Pages**) in Java web development.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Play模板引擎的一个优点是它基于Scala语言本身。这是一个好消息，因为我们不需要学习任何新的模板语法；我们可以重用Scala结构，无需任何额外的集成。此外，模板被编译，以便我们每次犯错时都能在编译时得到错误提示；错误将以与路由或纯Scala控制器代码相同的方式显示在浏览器中。这种快速的反馈与使用Java
    Web开发中更传统的**JSPs**（JavaServer Pages）技术相比可以节省我们大量时间。
- en: The declarations at the top of the template contain the bound variables that
    will be populated throughout the template. The template markup can produce an
    output of any kind, such as HTML5, XML, or plain text. Templates can also include
    other templates.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 模板顶部的声明包含将在整个模板中填充的绑定变量。模板标记可以生成任何类型的输出，如HTML5、XML或纯文本。模板还可以包含其他模板。
- en: 'In the previous example, the `@main(title = "The ''helloworld'' application"){
    <block> ...}` statement refers to the `main.scala.html` view file itself, displayed
    as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例中，`@main(title = "The 'helloworld' application'){ <block> ...}`语句指的是`main.scala.html`视图文件本身，如下所示：
- en: '[PRE15]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'As you can see, `@(title: String)(content: Html)` at the top of this file matches
    `(title = "The ''helloworld'' application"){ <block of template with code> ...}`
    from the previous template. This is how templates call each other.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '如您所见，此文件顶部定义的`@(title: String)(content: Html)`与上一个模板中的`(title = "The ''helloworld''
    application''){ <block of template with code> ...}`相匹配。这就是模板相互调用的方式。'
- en: The `@` sign indicates that the Scala code follows either directly with the
    name of a variable or a method to be invoked, or with a full block of code given
    between brackets, that is, `@{ …code … }`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`@`符号表示Scala代码后面直接跟一个变量名或要调用的方法，或者是一个括号内给出的完整代码块，即`@{ …code … }`。'
- en: 'The response (`views/hello.scala.html`) template, once the web form has been
    submitted, contains a `for` loop to display the `name` field a number of times.
    This is shown as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在表单提交后，响应（`views/hello.scala.html`）模板包含一个`for`循环来显示`name`字段多次。如下所示：
- en: '[PRE16]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Playing with authentication
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与认证玩耍
- en: A frequent piece of functionality needed when designing a new web application
    involves authentication and authorization. Authentication usually requires that
    the user provide the credentials to log in to the application in the form of a
    username/password. Authorization is the mechanism by which the system can ensure
    that a user can perform only the operations that he/she is entitled to. In this
    section, we are going to extend our `helloworld` sample with security features
    that are part of the Play distribution, as a way to demonstrate how the usage
    of traits in Scala can provide an elegant solution to conventional problems.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计新的Web应用时，经常需要的功能之一涉及认证和授权。认证通常要求用户以用户名/密码的形式提供凭证以登录到应用程序。授权是系统确保用户只能执行其有权执行的操作的机制。在本节中，我们将通过扩展我们的`helloworld`示例，添加Play发行版中的安全功能，以展示Scala中特质的用法如何为传统问题提供优雅的解决方案。
- en: 'Let''s define a new controller that we will call `Authentication`, which contains
    common methods such as `login` to retrieve a sign-in page, `authenticate` and
    `check` to perform the verification of the authentication, and `logout` to go
    back to the login page. This is done as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义一个新的控制器，我们将称之为`Authentication`，它包含一些常用方法，如`login`用于获取登录页面，`authenticate`和`check`用于执行认证验证，以及`logout`用于返回登录页面。以下是实现方式：
- en: '[PRE17]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Similar to the `index` method that belongs to the `Application` controller
    from the previous section, the `login` method here consists of binding a form
    (named `loginForm`) to a view (named `html.login`, corresponding to the file `views/login.scala.html`).
    A simple template for a view that consists of two text fields to capture an e-mail/username
    and password is shown as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 与上一节中属于 `Application` 控制器的 `index` 方法类似，这里的 `login` 方法包括将一个表单（命名为 `loginForm`）绑定到一个视图（命名为
    `html.login`，对应于文件 `views/login.scala.html`）。以下是一个简单的视图模板，它包含两个文本字段来捕获电子邮件/用户名和密码：
- en: '[PRE18]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Notice how the `thomas@@home` username shows us that you can escape the special
    `@` character by entering it twice.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到 `thomas@@home` 用户名显示你可以通过输入两次来转义特殊的 `@` 字符。
- en: 'Now we have the logic to handle an HTML login page with the submission of the
    credentials to be authenticated, but we are still lacking the missing piece that
    will wrap a conventional invocation of a method from any controller that we want
    to protect. Moreover, this logic will redirect us to the login page in case the
    username (a property stored in our `request.session` object and retrieved from
    a cookie) is not present. It can be described in a trait as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了处理带有待验证凭据提交的 HTML 登录页面的逻辑，但我们仍然缺少将常规方法调用封装到任何我们想要保护的控制器的缺失部分。此外，如果用户名（存储在我们的
    `request.session` 对象中并从 cookie 中检索）不存在，此逻辑将重定向我们到登录页面。这可以用以下方式描述为特质：
- en: '[PRE19]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We can add this trait to the same `Authentication.scala` controller class.
    The `withAuth` method wraps our `Action` invocations by applying the `Security.Authenticated`
    method around them. To be able to use this trait, we just need to mix it in in
    our controller class as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这个特质添加到同一个 `Authentication.scala` 控制器类中。`withAuth` 方法通过在它们周围应用 `Security.Authenticated`
    方法来封装我们的 `Action` 调用。为了能够使用这个特质，我们只需要将其混合到我们的控制器类中，如下所示：
- en: '[PRE20]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Once the trait is part of our controller, we can replace an `Action` method
    with a `withAuth` method instead. For example, when invoking the `index` method,
    we replace the `Action` method, as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦特质成为我们控制器的一部分，我们可以用 `withAuth` 方法替换 `Action` 方法。例如，在调用 `index` 方法时，我们替换 `Action`
    方法，如下所示：
- en: '[PRE21]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'To be able to execute our new functionality, we should not forget to add the
    extra methods from the `Authentication.scala` controller to the routes'' definitions
    (the compiler will flag this if we omit them):'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够执行我们的新功能，我们不应该忘记将 `Authentication.scala` 控制器的额外方法添加到路由定义中（如果省略它们，编译器会标记出来）：
- en: '[PRE22]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Let''s rerun the application and invoke the `http://localhost:9000/` page.
    We should be routed to the `login.html` page rather than the `index.html` page.
    This is shown in the following screenshot:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重新运行应用程序并调用 `http://localhost:9000/` 页面。我们应该被路由到 `login.html` 页面而不是 `index.html`
    页面。这在上面的屏幕截图中有显示：
- en: '![Playing with authentication](img/3637OS_05_11.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![与认证玩耍](img/3637OS_05_11.jpg)'
- en: Try to log in with both the erroneous and correct e-mail/password combinations
    to verify that the authentication has been implemented correctly.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用错误和正确的电子邮件/密码组合进行登录，以验证认证是否已正确实现。
- en: This basic authentication mechanism is just an example of how you can easily
    extend the applications in Play. It demonstrates the use of the Action composition,
    a technique that can also be applied to many other aspects—for example, logging
    or modifying requests—and is a good alternative to interceptors.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这个基本的认证机制只是展示了你如何轻松扩展 Play 中的应用程序。它演示了使用动作组合技术，这项技术也可以应用于许多其他方面——例如，记录或修改请求——并且是拦截器的一个很好的替代方案。
- en: There are, of course, external modules that you can use with Play if you need
    to achieve authentication through other services; for instance, modules based
    on standards such as OAuth, OAuth2, or OpenID. The SecureSocial module is a good
    example to do this and is available at [http://securesocial.ws](http://securesocial.ws).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果你需要通过其他服务实现认证，你可以使用与 Play 兼容的外部模块；例如，基于 OAuth、OAuth2 或 OpenID 等标准的模块。SecureSocial
    模块是一个很好的例子，可在 [http://securesocial.ws](http://securesocial.ws) 获取。
- en: Practical tips when using Play
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Play 的实用技巧
- en: We will conclude this chapter with a couple of recommendations that will help
    with the daily usage of the Play Framework.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将以几条有助于 Play 每日使用的建议来结束这一章。
- en: Debugging with Play
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Play 进行调试
- en: 'Due to the declarative nature of functional programming and the powerful type
    checking mechanism of the compiler, debugging should happen less often when dealing
    with Scala code. However, if you need to debug a Play application in a situation,
    you might as well run a remote debugging session as you would in Java. To achieve
    this, just start your Play application with an extra debug command:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 由于函数式编程的声明性特性和编译器的强大类型检查机制，在处理Scala代码时，调试应该发生的频率较低。然而，如果你需要在某种情况下调试一个Play应用程序，你不妨像在Java中一样运行一个远程调试会话。为了实现这一点，只需使用额外的调试命令启动你的Play应用程序：
- en: '[PRE23]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'You should see an extra information line in the output that displays the following
    command line:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在输出中看到一条额外的信息行，显示以下命令行：
- en: '[PRE24]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: From here, you can add break points in your code and start a remote debugging
    configuration in Eclipse by navigating to the menu named **Run** | **Debug Configurations…**
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里，你可以在你的代码中添加断点，并通过导航到名为**运行** | **调试配置…**的菜单在Eclipse中启动远程调试配置。
- en: Right-click on **Remote Java Application** and select **New**. Just make sure
    that you enter `Port:9999` in the **Connection Properties** form and then start
    debugging by clicking on the **Debug** button.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 右键单击**远程Java应用程序**并选择**新建**。只需确保你在**连接属性**表单中输入`端口：9999`，然后通过点击**调试**按钮开始调试。
- en: Dealing with version control
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理版本控制
- en: 'Typical files that can be ignored when maintaining the code under version control
    tools such as GIT are located as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在维护代码时，可以忽略的典型文件位于以下位置，例如使用GIT等版本控制工具：
- en: '`logs`'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`logs`'
- en: '`project/project`'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`project/project`'
- en: '`project/target`'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`project/target`'
- en: '`target`'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`target`'
- en: '`tmp`'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tmp`'
- en: '`dist`'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dist`'
- en: '`.cache`'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.cache`'
- en: Summary
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we introduced the Play Framework and covered typical examples
    where requests are routed to controllers and rendered through views following
    the well-known MVC pattern. We saw that the usage of the Scala syntax inside the
    definition of routes and templates gives us the extra benefit of compile-time
    safety. Such help provided to the programmer largely increases productivity and
    avoids spelling mistakes while refactoring, making the whole experience more enjoyable.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了Play框架，并涵盖了请求按照众所周知的MVC模式路由到控制器并通过视图渲染的典型示例。我们看到了在路由和模板的定义中使用Scala语法的用法给我们带来了编译时安全性的额外好处。这种帮助极大地提高了程序员的效率，并在重构时避免了拼写错误，使整个体验更加愉快。
- en: We also added some basic HTTP authentication to a `helloworld` application sample.
    In the next chapter, we are going to tackle the issue of Persistence/ORM, a part
    that is essential in any web application, involving the usage of a database in
    the backend to store and retrieve data. We will see how to integrate the existing
    persistence standards used in Java, such as JPA, and will introduce a novel but
    powerful approach to Persistence through the Slick framework.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还向一个`helloworld`应用程序示例添加了一些基本的HTTP身份验证。在下一章中，我们将解决持久性/ORM的问题，这是任何Web应用程序中必不可少的部分，涉及到在后端使用数据库来存储和检索数据。我们将看到如何集成Java中使用的现有持久性标准，如JPA，并介绍通过Slick框架的持久性的一种新颖但强大的方法。
