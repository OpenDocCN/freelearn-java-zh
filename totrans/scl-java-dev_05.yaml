- en: Chapter 5. Getting Started with the Play Framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter commences our journey into web development in Scala. Web development
    has become an area where the choice of architectures and frameworks is tremendous.
    Finding the right tool for the job is not always a straightforward task as it
    ranges from traditional Java EE or Spring-based architectural styles to more recent
    Ruby on Rails-like approaches. Most of the existing solutions still rely on the
    adoption of the servlet-container model, whether they use lightweight containers
    such as Jetty/Tomcat or support **EJBs** (**Enterprise JavaBeans**) such as JBoss,
    Glassfish, WebSphere, or WebLogic. Many online articles and conference talks have
    tried to compare some of the alternatives, and as these frameworks evolve rapidly
    and sometimes focus on different aspects (such as frontend versus backend), compiling
    a fair and accurate list remains difficult. In the Scala world, alternatives to
    create web applications range from lightweight frameworks such as Unfiltered,
    Spray, or Scalatra to full-featured solutions such as the Lift or the Play Frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have chosen to concentrate on the Play Framework, because it embraces important
    features that we think are the key to maintainable, modern software development.
    Some of the advantages of the Play Framework are:'
  prefs: []
  type: TYPE_NORMAL
- en: The Play Framework is scalable and robust. It can handle large loads because
    it is built on a fully asynchronous model on the top of technologies that are
    ready to handle multicore architectures such as Akka, a framework to build concurrent
    and distributed applications that we will cover in [Chapter 8](ch08.html "Chapter 8. Essential
    Properties of Modern Applications – Asynchrony and Concurrency"), *Essential Properties
    of Modern Applications – Asynchrony and Concurrency*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It provides us with enhanced developer productivity by promoting ease of use,
    promoting the **DRY** (short for **Don't Repeat Yourself**) principle, and taking
    advantage of the expressiveness and conciseness of Scala. In addition to that,
    the hit refresh workflow of Play by which you can simply refresh your browser
    and get instant feedback on the changes you make is a real boost in the productivity,
    in contrast with the longer deployment cycles of the Java servlet and EJB containers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It provides good integration with the existing legacy of infrastructure based
    on the JVM.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It provides good integration with modern, client-side development trends that
    heavily rely on JavaScript/CSS and their surrounding ecosystem, including frameworks
    such as AngularJS or WebJars. Moreover, the **LESS** (short for **Leaner CSS**)
    dynamic stylesheet language as well as CoffeeScript, a small and elegant language
    that compiles to JavaScript, are supported by Play Framework without any additional
    integration.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Play Framework Version 2.*x* exists both for Java and Scala, which is an
    additional strength as Java developers will probably get acquainted with the differences
    more quickly and may have previous experience with the Java version before moving
    on to Scala.
  prefs: []
  type: TYPE_NORMAL
- en: Several alternatives are offered to rapidly get you started with the Play Framework
    and create a minimalistic `helloworld` project. Note that all these alternatives
    create projects based on SBT, as we mentioned briefly in [Chapter 3](ch03.html
    "Chapter 3. Understanding the Scala Ecosystem"), *Understanding the Scala Ecosystem*.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with the classic Play distribution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Download the classic Play distribution from [http://www.playframework.com/download](http://www.playframework.com/download),
    and unpack the `.zip` archive in a directory of your choice. Add this directory
    to your path (so that running the `play` command anywhere on your filesystem will
    create a new application). With this alternative, you can open a terminal window
    and enter the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The following output will be displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting started with the classic Play distribution](img/3637OS_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We just need to press *Enter* as we have already given a project name on the
    previous command. The following will be displayed on pressing *Enter*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s all; in less than a minute, we already have a fully working web app
    that we can now execute. As it is an SBT project (where the `sbt` command has
    been renamed `play` instead), we can just navigate to the root of the created
    project and start our Play session as if we were working on an SBT project. This
    is done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that the application is started on port 9000 by default. If you want
    a different port, you can type the following command instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This will bring you to the Play (SBT) session, and from there, you can choose
    the port to listen to. This can be done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Another alternative is to enter `> play "run 9095"` in the terminal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Launch a browser at `http://localhost:9095/` (9000 if you are running using
    the default port), and you should see the **Welcome to Play** page on your running
    portal:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting started with the classic Play distribution](img/3637OS_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting started with the Typesafe Activator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Using the same method that we used earlier in the book to create projects based
    on the Activator templates, getting started with a Play project through the Activator
    is very straightforward. Just go to the Typesafe Activator installation directory
    and enter the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This will launch the activator in a browser window. The most basic Scala Play
    project is found in the `hello-play-scala` template. Once you have selected the
    template, notice the default location that indicates where the project will be
    created and then click on **Create**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s run our sample project either directly from the activator browser view
    or from a terminal window by navigating to the root directory of the created project
    and entering the following command in the command prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the server is listening on port 9000, you can open the `http://localhost:9000/`
    URL in a browser. Compilation is triggered only once you access the URL, so it
    may take a few seconds for the application to show up. What should come up in
    your browser is similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting started with the Typesafe Activator](img/3637OS_05_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Architecture of a Play application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To perceive in a better way how a Play application is built, we first need to
    understand a few of its architectural aspects.
  prefs: []
  type: TYPE_NORMAL
- en: Visualizing the framework stack
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we start exploring the code behind a typical sample Play application,
    let''s visualize the architecture of the framework using a couple of diagrams.
    First, the overall diagram of the technology stack composed of Play is shown as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Visualizing the framework stack](img/3637OS_05_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: On top of the JVM resides the Akka Framework, a framework to manage concurrent
    operations based on the actor model, which we will cover later in [Chapter 8](ch08.html
    "Chapter 8. Essential Properties of Modern Applications – Asynchrony and Concurrency"),
    *Essential Properties of Modern Applications – Asynchrony and Concurrency*. While
    most web frameworks today still rely on servlet containers such as Tomcat or JBoss,
    the novelty of Play is to avoid following this model by focusing on making applications
    stateless when code can be **hot swapped**, that is, replaced at runtime. Although
    widely used and deployed in commercial environments, servlet containers suffer
    from additional overheads, such as the one thread per request problem, which can
    limit the scalability when handling large loads. For a developer, the time gained
    by avoiding the redeployment of a partial or full `.ear` or `.war` archive every
    time a change in the code is made can be significant.
  prefs: []
  type: TYPE_NORMAL
- en: On top of Akka resides a REST/HTTP integration layer, based on Spray (an open
    source toolkit to build REST/HTTP-based integration layers, now called Akka-Http),
    which produces and consumes embeddable REST services. This makes Play pertinent
    to the modern ways of writing web applications, where the backend and frontend
    communicate through HTTP REST services, exchanging mostly JSON/XML messages that
    can be rendered as HTML5 and, therefore, embrace the full power of frontend JavaScript
    frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, to be able to integrate with many other technologies of all kinds,
    such as relational or NoSQL-based databases, security frameworks, social networks,
    cloud-based or Big Data solutions, a large list of Play plugins and modules are
    listed at [http://www.playmodules.net](http://www.playmodules.net).
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the request-response lifecycle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Play follows the well-known MVC pattern, and the lifecycle of the web request
    can be seen as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Exploring the request-response lifecycle](img/3637OS_05_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To go through the various steps of this workflow, we are going to explore a
    sample `helloworld` application that is part of the Play distribution. This `helloworld`
    application is a little more sophisticated and, therefore, more interesting than
    the pure getting started examples that we launched previously either via the Typesafe
    Activator or the plain `> play new <project>` command to create a project from
    scratch.
  prefs: []
  type: TYPE_NORMAL
- en: The `helloworld` application that we consider here can be found under the `<play
    installation root>/samples/scala/helloworld` directory (we have used the Play
    2.2.1 distribution at the time of this writing).
  prefs: []
  type: TYPE_NORMAL
- en: 'As for any Play project within the distribution that already contains the `sbteclipse`
    plugin, we can directly generate Eclipse-related files by entering the following
    command in a command prompt (at the level of the project root directory):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that as Play commands are just a thin layer on the top of SBT, we can
    reuse the same syntax, that is, `> play eclipse` rather than `> sbt eclipse`.
    Once these are imported into the IDE, you can see the general source layout of
    a Play application in the **Package Explorer** panel on the left-hand side, as
    shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Exploring the request-response lifecycle](img/3637OS_05_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s first run the application to see what it looks like using the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Open a browser at `http://localhost:9000/` and you should see a small web form
    similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Exploring the request-response lifecycle](img/3637OS_05_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Enter the required information and click on **Submit** to verify that you get
    your name displayed a specified number of times.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step in the request flow appears in the `conf/routes` file, which
    is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the place where we can define a mapping between HTTP request URLs and
    the controller code that needs to handle the request on the Play server, shown
    in the following format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'For instance, accessing the `http://localhost:9000/hello` URL in the browser
    matches the following route:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `index` method, taking no arguments, will be called on the `controller.Application.scala`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: This way of presenting the routing of the URLs to the controllers is different
    from the standard Java way found, for instance, in JAX-RS or Spring MVC, where
    each controller is annotated instead. In our opinion, the routing file approach
    gives us a clear overview of what the API supports, that is, the documentation,
    and it makes a Play application RESTful by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'Even if it seems that the `routes` file is a configuration file, it is indeed
    compiled and any typo or reference to a nonexistent controller method will be
    quickly identified. Replace `controllers.Application.index` with `controllers.Application.wrongmethod`,
    save the file, and just click on the reload button in the browser (*Ctrl* + *R*).
    You should get the error nicely displayed in the browser, as seen in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Exploring the request-response lifecycle](img/3637OS_05_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Notice how precise the error message is and how the exact failing line in the
    file is pointed out. This great way to display error messages on reloading the
    browser is one of the many features that makes programmers more productive. Similarly,
    even if there is no mapping error in the routes file, accessing a nonmapped URL
    that is under development (such as `http://localhost:9000/hi)` will display an
    error as well as the content of the `routes` file to show us which URLs are possible
    to invoke. This can be seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Exploring the request-response lifecycle](img/3637OS_05_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Handling a request in the controller
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Moving on, let''s take a look at the `Application` class that receives and
    processes the `GET` request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `index` method performs the `Action` block, which is a function (`Request[AnyContent]
    => Result`), that takes the request and returns a `Result` object. The input parameter
    of the `Request` type is not shown here in the `index` method as it is implicitly
    passed and we are not using it in the body of the function; we could have written
    `def index = Action { implicit request =>` instead, if we wanted to. The one liner
    `Ok(html.index(helloForm))` means that the returned result should have an HTTP
    status equal to 200, that is, `Ok`, and consist of binding the `html.index` view
    to the `helloForm` model.
  prefs: []
  type: TYPE_NORMAL
- en: 'The model in this tiny example consists of a `Form` object defined in `val`
    earlier in the file. This can be seen as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Each parameter is described as a `key -> value` pair, where `key` is the name
    of the parameter and `value` is the result of a function applied to the parameter
    that will produce a `play.api.data.Mapping` object. Such mapping functions are
    very useful to be able to perform a validation on the form parameters. Here, the
    `Form` parameters are expressed as a tuple object, but we could create more complex
    objects such as case classes. The sample project named *forms* in the Play distribution
    contains examples of this more advanced way of handling validation. The `fold`
    method encountered in the `sayHello` method of the controller is a way to accumulate
    validation errors to be able to report all of these errors at once. Let''s enter
    a few mistakes (such as leaving the `name` field blank or entering characters
    when numbers are required) when filling out the form to verify how errors are
    displayed. This can be seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Handling a request in the controller](img/3637OS_05_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Rendering the view
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The template used to render the view is found under the `views/index.scala.html`
    file.This template is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: One of the strengths of the Play template engine is that it is based on the
    Scala language itself. This is good news because we do not need to learn any new
    templating syntax; we can reuse the Scala constructs, without any additional integration.
    Moreover, the templates are compiled so that we get compile-time errors whenever
    we make a mistake; the errors will show up in the browser in the same way that
    they showed up for routes or the plain controller Scala code. This fast feedback
    can save us a lot of time compared to the more traditional techniques of using
    **JSPs** (**JavaServer Pages**) in Java web development.
  prefs: []
  type: TYPE_NORMAL
- en: The declarations at the top of the template contain the bound variables that
    will be populated throughout the template. The template markup can produce an
    output of any kind, such as HTML5, XML, or plain text. Templates can also include
    other templates.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous example, the `@main(title = "The ''helloworld'' application"){
    <block> ...}` statement refers to the `main.scala.html` view file itself, displayed
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, `@(title: String)(content: Html)` at the top of this file matches
    `(title = "The ''helloworld'' application"){ <block of template with code> ...}`
    from the previous template. This is how templates call each other.'
  prefs: []
  type: TYPE_NORMAL
- en: The `@` sign indicates that the Scala code follows either directly with the
    name of a variable or a method to be invoked, or with a full block of code given
    between brackets, that is, `@{ …code … }`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The response (`views/hello.scala.html`) template, once the web form has been
    submitted, contains a `for` loop to display the `name` field a number of times.
    This is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Playing with authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A frequent piece of functionality needed when designing a new web application
    involves authentication and authorization. Authentication usually requires that
    the user provide the credentials to log in to the application in the form of a
    username/password. Authorization is the mechanism by which the system can ensure
    that a user can perform only the operations that he/she is entitled to. In this
    section, we are going to extend our `helloworld` sample with security features
    that are part of the Play distribution, as a way to demonstrate how the usage
    of traits in Scala can provide an elegant solution to conventional problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s define a new controller that we will call `Authentication`, which contains
    common methods such as `login` to retrieve a sign-in page, `authenticate` and
    `check` to perform the verification of the authentication, and `logout` to go
    back to the login page. This is done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Similar to the `index` method that belongs to the `Application` controller
    from the previous section, the `login` method here consists of binding a form
    (named `loginForm`) to a view (named `html.login`, corresponding to the file `views/login.scala.html`).
    A simple template for a view that consists of two text fields to capture an e-mail/username
    and password is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Notice how the `thomas@@home` username shows us that you can escape the special
    `@` character by entering it twice.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we have the logic to handle an HTML login page with the submission of the
    credentials to be authenticated, but we are still lacking the missing piece that
    will wrap a conventional invocation of a method from any controller that we want
    to protect. Moreover, this logic will redirect us to the login page in case the
    username (a property stored in our `request.session` object and retrieved from
    a cookie) is not present. It can be described in a trait as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We can add this trait to the same `Authentication.scala` controller class.
    The `withAuth` method wraps our `Action` invocations by applying the `Security.Authenticated`
    method around them. To be able to use this trait, we just need to mix it in in
    our controller class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the trait is part of our controller, we can replace an `Action` method
    with a `withAuth` method instead. For example, when invoking the `index` method,
    we replace the `Action` method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'To be able to execute our new functionality, we should not forget to add the
    extra methods from the `Authentication.scala` controller to the routes'' definitions
    (the compiler will flag this if we omit them):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s rerun the application and invoke the `http://localhost:9000/` page.
    We should be routed to the `login.html` page rather than the `index.html` page.
    This is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Playing with authentication](img/3637OS_05_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Try to log in with both the erroneous and correct e-mail/password combinations
    to verify that the authentication has been implemented correctly.
  prefs: []
  type: TYPE_NORMAL
- en: This basic authentication mechanism is just an example of how you can easily
    extend the applications in Play. It demonstrates the use of the Action composition,
    a technique that can also be applied to many other aspects—for example, logging
    or modifying requests—and is a good alternative to interceptors.
  prefs: []
  type: TYPE_NORMAL
- en: There are, of course, external modules that you can use with Play if you need
    to achieve authentication through other services; for instance, modules based
    on standards such as OAuth, OAuth2, or OpenID. The SecureSocial module is a good
    example to do this and is available at [http://securesocial.ws](http://securesocial.ws).
  prefs: []
  type: TYPE_NORMAL
- en: Practical tips when using Play
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will conclude this chapter with a couple of recommendations that will help
    with the daily usage of the Play Framework.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging with Play
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Due to the declarative nature of functional programming and the powerful type
    checking mechanism of the compiler, debugging should happen less often when dealing
    with Scala code. However, if you need to debug a Play application in a situation,
    you might as well run a remote debugging session as you would in Java. To achieve
    this, just start your Play application with an extra debug command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see an extra information line in the output that displays the following
    command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: From here, you can add break points in your code and start a remote debugging
    configuration in Eclipse by navigating to the menu named **Run** | **Debug Configurations…**
  prefs: []
  type: TYPE_NORMAL
- en: Right-click on **Remote Java Application** and select **New**. Just make sure
    that you enter `Port:9999` in the **Connection Properties** form and then start
    debugging by clicking on the **Debug** button.
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with version control
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Typical files that can be ignored when maintaining the code under version control
    tools such as GIT are located as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`logs`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`project/project`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`project/target`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`target`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tmp`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dist`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.cache`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we introduced the Play Framework and covered typical examples
    where requests are routed to controllers and rendered through views following
    the well-known MVC pattern. We saw that the usage of the Scala syntax inside the
    definition of routes and templates gives us the extra benefit of compile-time
    safety. Such help provided to the programmer largely increases productivity and
    avoids spelling mistakes while refactoring, making the whole experience more enjoyable.
  prefs: []
  type: TYPE_NORMAL
- en: We also added some basic HTTP authentication to a `helloworld` application sample.
    In the next chapter, we are going to tackle the issue of Persistence/ORM, a part
    that is essential in any web application, involving the usage of a database in
    the backend to store and retrieve data. We will see how to integrate the existing
    persistence standards used in Java, such as JPA, and will introduce a novel but
    powerful approach to Persistence through the Slick framework.
  prefs: []
  type: TYPE_NORMAL
