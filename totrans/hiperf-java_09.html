<html><head></head><body>
		<div id="_idContainer025">
			<h1 class="chapter-number" id="_idParaDest-160"><a id="_idTextAnchor159"/>9</h1>
			<h1 id="_idParaDest-161"><a id="_idTextAnchor160"/>Concurrency Strategies and Models</h1>
			<p>Today’s computing world consists of distributed systems, cloud-based architectures, and hardware accelerated by multi-core processors. These characteristics necessitate concurrency strategies. This chapter provides foundational information on concurrency concepts and provides hands-on opportunities to implement concurrency in Java programs. The underlying goal is to harness the benefits and advantages of concurrency to improve the performance of our <span class="No-Break">Java applications.</span></p>
			<p>The chapter starts with a review of different concurrency models and their practical uses. Concepts include the thread-based memory model and the message-passing model. Then, we will explore multithreading from both a theoretical perspective and a hands-on practical aspect. The thread life cycle, thread pools, and other related topics will be covered. Synchronization will also be covered to include how to ensure thread safety and strategies to avoid common pitfalls. Finally, the chapter introduces non-blocking algorithms, an advanced concurrency strategy, to improve application performance through atomic variables and specific <span class="No-Break">data structures.</span></p>
			<p>In this chapter, we’re going to cover the following <span class="No-Break">main topics:</span></p>
			<ul>
				<li><span class="No-Break">Concurrency models</span></li>
				<li><span class="No-Break">Multithreading</span></li>
				<li><span class="No-Break">Synchronization</span></li>
				<li><span class="No-Break">Non-blocking algorithms</span></li>
			</ul>
			<p>By the end of this chapter, you should have a thorough understanding of concurrency and related strategies and models. You should be prepared to implement concurrency in your Java applications, ensuring they perform at a <span class="No-Break">high level.</span></p>
			<h1 id="_idParaDest-162"><a id="_idTextAnchor161"/>Technical requirements</h1>
			<p>To follow the examples and instructions in this chapter, you will need the ability to load, edit, and run Java code. If you have not set up your development environment, refer to <a href="B21942_01.xhtml#_idTextAnchor014"><span class="No-Break"><em class="italic">Chapter 1</em></span></a><span class="No-Break">.</span></p>
			<p>The finished code for this chapter can be found <span class="No-Break">here: </span><a href="https://github.com/PacktPublishing/High-Performance-with-Java/tree/main/Chapter09"><span class="No-Break">https://github.com/PacktPublishing/High-Performance-with-Java/</span><span class="No-Break">tree/main/Chapter09</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-163"><a id="_idTextAnchor162"/>Concurrency models</h1>
			<p>One of the most<a id="_idIndexMarker416"/> exciting aspects of the Java programming language is its robustness. When addressing parallel execution challenges, Java supports multiple models, so the approach we take is up to us. Usually, there is not just one way of doing things, with each possible solution presenting both advantages and trade-offs. Our goal is to create Java applications that run efficiently and are scalable and maintainable. To that end, we will use the thread-based concurrency approach (detailed later in this chapter). Our selection is based on its <span class="No-Break">straightforward nature.</span></p>
			<p><strong class="bold">Concurrency</strong>, in the <a id="_idIndexMarker417"/>context of computer science, is the simultaneous execution of instructions. This is achieved through multithreading (think of multitasking). This programming paradigm includes the ability to access Java objects and other resources from multiple threads. Let’s look at three specific models (thread-based, message passing, and reactive) and then compare them to see which model might be more ideal, given a specific scenario, <span class="No-Break">than others.</span></p>
			<h2 id="_idParaDest-164"><a id="_idTextAnchor163"/>Thread-based model</h2>
			<p>The <strong class="bold">thread-based model</strong>, also referred to <a id="_idIndexMarker418"/>as the <strong class="bold">shared memory model</strong>, is the most used <a id="_idIndexMarker419"/>Java concurrency model. The notion of a <strong class="bold">thread</strong> is that all threads share the same physical memory <a id="_idIndexMarker420"/>and conduct their intercommunication via that memory. The Java language has deep support for threads, with the <strong class="source-inline">Thread</strong> class and <strong class="source-inline">Callable</strong> and <span class="No-Break"><strong class="source-inline">Runnable</strong></span><span class="No-Break"> interfaces.</span></p>
			<p>Let’s look at a simple<a id="_idIndexMarker421"/> implementation example. We will implement the <strong class="source-inline">increment</strong> method and mark it with the <strong class="source-inline">synchronized</strong> keyword. This tells Java to only execute one thread at any <span class="No-Break">given time:</span></p>
			<pre class="source-code">
public class MyCounter {
  private int count = 0;
  public synchronized void increment() {
    count++;
  }
  public int getCount() {
    return count;
  }</pre>			<p>This next <a id="_idIndexMarker422"/>section of code contains our <strong class="source-inline">main()</strong> method. In <a id="_idIndexMarker423"/>this method, we create two threads; both will increment <span class="No-Break">our counter:</span></p>
			<pre class="source-code">
  public static void main(String[] args) throws InterruptedException {
    MyCounter counter = new MyCounter();
    Thread t1 = new Thread(() -&gt; {
      for(int i = 0; i &lt; 1000; i++) {
        counter.increment();
      }
    });
    Thread t2 = new Thread(() -&gt; {
      for(int i = 0; i &lt; 1000; i++) {
        counter.increment();
      }
    });</pre>			<p>The next two lines of code start <span class="No-Break">the threads:</span></p>
			<pre class="source-code">
    t1.start();
    t2.start();</pre>			<p>In the next<a id="_idIndexMarker424"/> two lines of code, we wait for both threads <span class="No-Break">to finish:</span></p>
			<pre class="source-code">
    t1.join();
    t2.join();</pre>			<p>Lastly, we output the <span class="No-Break">final results:</span></p>
			<pre class="source-code">
    System.out.println("Final counter value: " + counter.getCount());
  }
}</pre>			<p>The <a id="_idIndexMarker425"/>straightforward nature of thread-based model implementation represents a tremendous advantage. This approach is typical for smaller applications. There <a id="_idIndexMarker426"/>are potential disadvantages to using this model, as <strong class="bold">deadlocks</strong> and <strong class="bold">race conditions</strong> can be introduced when multiple threads attempt to access shared, <span class="No-Break">mutable data.</span></p>
			<p class="callout-heading">Deadlocks and race conditions</p>
			<p class="callout">Deadlocks <a id="_idIndexMarker427"/><a id="_idIndexMarker428"/>occur when two threads wait for the other to release a needed resource. Race conditions<a id="_idIndexMarker429"/> occur when the sequence of the thread execution <span class="No-Break">is required.</span></p>
			<p>Both deadlocks and race conditions should be avoided as much as possible in <span class="No-Break">our applications.</span></p>
			<h2 id="_idParaDest-165"><a id="_idTextAnchor164"/>The message passing model</h2>
			<p>The <strong class="bold">message passing model</strong> is an<a id="_idIndexMarker430"/> interesting<a id="_idIndexMarker431"/> one in that it avoids <strong class="bold">shared states</strong>. This model requires threads to intercommunicate by <span class="No-Break">sending messages.</span></p>
			<p class="callout-heading">Shared states</p>
			<p class="callout">A shared state<a id="_idIndexMarker432"/> exists when more than one thread in an application can simultaneously <span class="No-Break">access data.</span></p>
			<p>The<a id="_idIndexMarker433"/> message passing model offers assurances against deadlocks and race conditions. A benefit of this model is that it <span class="No-Break">promotes scalability.</span></p>
			<p>Let’s look at <a id="_idIndexMarker434"/>how we can implement the message passing model. Our example includes a simple sender and receiver scenario. We start with our <strong class="source-inline">import</strong> statements and then create a <span class="No-Break"><strong class="source-inline">Message</strong></span><span class="No-Break"> class:</span></p>
			<pre class="source-code">
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.BlockingQueue;
public class MessagePassingExample {
  static class Message {
    private final String content;
    public Message(String content) {
      this.content = content;
    }
    public String getContent() {
      return content;
    }
  }</pre>			<p>Next, we will <a id="_idIndexMarker435"/>have our <strong class="source-inline">Sender</strong> class implement <a id="_idIndexMarker436"/>the <span class="No-Break"><strong class="source-inline">Runnable</strong></span><span class="No-Break"> interface:</span></p>
			<pre class="source-code">
static class Sender implements Runnable {
  private final BlockingQueue&lt;Message&gt; queue;
  public Sender(BlockingQueue&lt;Message&gt; q) {
    this.queue = q;
  }
  @Override
  public void run() {
    // Sending messages
    String[] messages = {"First message", "Second message", "Third 
    message", "Done"};
    for (String m : messages) {
      try {
        Thread.sleep(1000); // Simulating work
        queue.put(new Message(m));
        System.out.println("Sent: " + m);
      } catch (InterruptedException e) {
          Thread.currentThread().interrupt();
      }
    }
  }
}</pre>			<p>Next, we<a id="_idIndexMarker437"/> will have our <strong class="source-inline">Receiver</strong> class implement<a id="_idIndexMarker438"/> the <span class="No-Break"><strong class="source-inline">Runnable</strong></span><span class="No-Break"> interface:</span></p>
			<pre class="source-code">
static class Receiver implements Runnable {
  private final BlockingQueue&lt;Message&gt; queue;
  public Receiver(BlockingQueue&lt;Message&gt; q) {
    this.queue = q;
  }
  @Override
  public void run() {
    try {
      Message msg;
      // Receiving messages
      while (!((msg = queue.take()).getContent().equals("Done"))) {
        System.out.println("Received: " + msg.getContent());
        Thread.sleep(400); // Simulating work
      }
    } catch (InterruptedException e) {
        Thread.currentThread().interrupt();
    }
  }
}</pre>			<p>The last step is to create our <span class="No-Break"><strong class="source-inline">main()</strong></span><span class="No-Break"> method:</span></p>
			<pre class="source-code">
  public static void main(String[] args) {
    BlockingQueue&lt;Message&gt; queue = new ArrayBlockingQueue&lt;&gt;(10);
    Thread senderThread = new Thread(new Sender(queue));
    Thread receiverThread = new Thread(new Receiver(queue));
    senderThread.start();
    receiverThread.start();
  }
}</pre>			<p>Our <a id="_idIndexMarker439"/>example implemented <strong class="source-inline">Sender</strong> and <strong class="source-inline">Receiver</strong> as <strong class="source-inline">Runnable</strong> classes. They <a id="_idIndexMarker440"/>communicated using <strong class="source-inline">BlockingQueue</strong>. The queue is used for <strong class="source-inline">Sender</strong> to add messages and <strong class="source-inline">Receiver</strong> to take and process them. <strong class="source-inline">Sender</strong> sends <strong class="source-inline">Done</strong> to the queue so that <strong class="source-inline">Receiver</strong> knows when it can stop processing. The message passing model is often used in distributed systems, due to its support of highly <span class="No-Break">scalable systems.</span></p>
			<h2 id="_idParaDest-166"><a id="_idTextAnchor165"/>The Reactive model</h2>
			<p>The <strong class="bold">Reactive model</strong> is newer than <a id="_idIndexMarker441"/>the last two models we covered. Its focus is on <strong class="bold">non-blocking</strong>, <strong class="bold">event-driven programming</strong>. This model is usually evident <a id="_idIndexMarker442"/>in large-scale systems<a id="_idIndexMarker443"/> that process extensive input/output operations, especially when high scalability is needed. There are external libraries that we can use <a id="_idIndexMarker444"/>to implement <a id="_idIndexMarker445"/>this model, including <strong class="bold">Project Reactor</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="bold">RxJava</strong></span><span class="No-Break">.</span></p>
			<p>Let’s look at a simple implementation example using <strong class="bold">Project Reactor</strong>. We start by adding the <a id="_idIndexMarker446"/>Project Reactor <strong class="bold">dependency</strong> to our project. Here is how that looks<a id="_idIndexMarker447"/> using <strong class="bold">Maven</strong> as the <span class="No-Break">build tool:</span></p>
			<pre class="source-code">
&lt;dependency&gt;
    &lt;groupId&gt;io.projectreactor&lt;/groupId&gt;
    &lt;artifactId&gt;reactor-core&lt;/artifactId&gt;
    &lt;version&gt;3.4.0&lt;/version&gt;
&lt;/dependency&gt;</pre>			<p>The following <a id="_idIndexMarker448"/>example demonstrates how to create a reactive stream to process a sequence <span class="No-Break">of events:</span></p>
			<pre class="source-code">
import reactor.core.publisher.Flux;
public class ReactiveExample {
    public static void main(String[] args) {
        Flux&lt;String&gt; messageFlux = Flux.just("Hello", "Reactive", 
        "World", "with", "Java")
                .map(String::toUpperCase)
                .filter(s -&gt; s.length() &gt; 4);
        messageFlux.subscribe(System.out::println);
    }
}</pre>			<p>The <a id="_idIndexMarker449"/>Reactive model offers efficient resource use, blocking operation avoidance, and a unique approach to asynchronous programming. However, it can be more difficult to implement compared to the other models <span class="No-Break">we covered.</span></p>
			<p class="callout-heading">Comparative analysis</p>
			<p class="callout">Each of the three concurrency models offers different benefits, and understanding their individuality and differences can help you make an informed decision regarding which model <span class="No-Break">to adopt.</span></p>
			<h1 id="_idParaDest-167"><a id="_idTextAnchor166"/>Multithreading</h1>
			<p><strong class="bold">Multithreading</strong> is simply the <strong class="bold">synchronous execution</strong>, or <strong class="bold">concurrent execution</strong>, of two or <a id="_idIndexMarker450"/>more parts of a program, and it is a fundamental aspect of Java’s <a id="_idIndexMarker451"/>concurrent <a id="_idIndexMarker452"/>programming mechanism. We execute multiple parts of our programs, taking advantage of <a id="_idIndexMarker453"/>multi-core <strong class="bold">Central Processing Unit</strong> (<strong class="bold">CPU</strong>) resources to optimize the performance of <span class="No-Break">our applications.</span></p>
			<p>Before we get too far into multithreads, let’s <a id="_idIndexMarker454"/>focus on a single <strong class="bold">thread</strong>. In Java, a thread is a finite unit of execution within a method, function, or process. The <strong class="bold">Java Virtual Machine</strong> (<strong class="bold">JVM</strong>) handles the management of our threads. As you <a id="_idIndexMarker455"/>can see in the following code snippet, we extend the <strong class="source-inline">Thread</strong> class to create and <span class="No-Break">start threads:</span></p>
			<pre class="source-code">
class MyThread extends Thread {
    public void run() {
        System.out.println("Thread executed by extending Thread 
        class.");
    }
}
// This is how we create and start a thread.
MyThread thread = new MyThread();
thread.start();</pre>			<p>The next code snippet demonstrates how to implement the <span class="No-Break"><strong class="source-inline">Runnable</strong></span><span class="No-Break"> interface:</span></p>
			<pre class="source-code">
class MyRunnable implements Runnable {
    public void run() {
        System.out.println("Thread executed by implementing Runnable 
        interface.");
    }
}
// Here, we create and start a thread.
Thread thread = new Thread(new MyRunnable());
thread.start();</pre>			<p>Now that you understand <a id="_idIndexMarker456"/>how easy it is to create and start threads, let’s examine their <span class="No-Break">life cycles.</span></p>
			<h2 id="_idParaDest-168"><a id="_idTextAnchor167"/>Thread life cycles</h2>
			<p>Java threads <a id="_idIndexMarker457"/>have a definitive start and end state. They have additional <a id="_idIndexMarker458"/>states, as indicated in the <span class="No-Break">following diagram.</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer024">
					<img alt="Figure 9.1 – A Java thread life cycle" src="image/B21942_09_1.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.1 – A Java thread life cycle</p>
			<p>It is important to understand each of these states so that we can effectively manage our threads. Let’s briefly look at each state within the Java thread <span class="No-Break">life cycle:</span></p>
			<ol>
				<li><strong class="bold">New</strong>: Threads have this state when we create them but have not <span class="No-Break">started them.</span></li>
				<li><strong class="bold">Runnable</strong>: This state exists when a thread is being executed. Threads that have started and are waiting for CPU time also have <span class="No-Break">this state.</span></li>
				<li><strong class="bold">Blocked</strong>: A thread is blocked from accessing <span class="No-Break">a resource.</span></li>
				<li><strong class="bold">Waiting/Timed Waiting</strong>: Threads can wait on other threads. Sometimes, there can be a specific waiting time, while at other times, the wait might <span class="No-Break">be indefinite.</span></li>
				<li><strong class="bold">Terminated</strong>: A thread <a id="_idIndexMarker459"/>has this state after <span class="No-Break">execution completes.</span></li>
			</ol>
			<p>It is important to understand these states, especially with applications that rely on thread communication <span class="No-Break">and synchronization.</span></p>
			<h2 id="_idParaDest-169"><a id="_idTextAnchor168"/>Multithreading best practices</h2>
			<p>When <a id="_idIndexMarker460"/>working with multithreading, there are a few things we should keep in mind to ensure that our application performs as expected and that our threads <span class="No-Break">are safe.</span></p>
			<p>First, we<a id="_idIndexMarker461"/> want to ensure that each resource is only accessed by one thread at a time, using <strong class="bold">synchronization</strong>. Our goal is to prevent <strong class="bold">race conditions</strong>. Fortunately, Java <a id="_idIndexMarker462"/>makes this easy for us, as it has the <strong class="source-inline">java.util.concurrent</strong> package, which includes concurrent data structures and methods we can use for synchronization. Utilizing this package can help us implement <span class="No-Break">thread safety.</span></p>
			<p>Java’s <strong class="source-inline">Object</strong> class includes the <strong class="source-inline">wait()</strong>, <strong class="source-inline">notify()</strong>, and <strong class="source-inline">notifyAll()</strong> methods, which can be used to empower Java threads to communicate with each other. The following example application demonstrates how those methods can be used. Our example contains a <strong class="source-inline">Producer</strong> thread that creates a value for consumption by a <strong class="source-inline">Consumer</strong> thread. We do not want both operations to take place at the same time; in fact, we want <strong class="source-inline">Consumer</strong> to wait for <strong class="source-inline">Producer</strong> to create the value. Further, <strong class="source-inline">Producer</strong> must wait for <strong class="source-inline">Consumer</strong> to receive the last value before creating a new one. The first section defines our <span class="No-Break"><strong class="source-inline">WaitNotifyExample</strong></span><span class="No-Break"> class:</span></p>
			<pre class="source-code">
Public class WaitNotifyExample {
  private static class SharedResource {
    private String message;
    private boolean empty = true;
    public synchronized String take() {
      // Wait until the message is available.
      while (empty) {
        try {
          wait();
        } catch (InterruptedException e) {}
      }
      // Toggle status to true.
      empty = true;
      // Notify producer that status has changed.
      notifyAll();
      return message;
    }
    public synchronized void put(String message) {
      // Wait until the message has been retrieved.
      while (!empty) {
        try {
          wait();
        } catch (InterruptedException e) {}
      }
      // Toggle the status to false.
      empty = false;
      // Store the message.
      this.message = message;
      // Notify that consumer that the status has changed.
      notifyAll();
    }
  }
  private static class Producer implements Runnable {
    private SharedResource resource;
    public Producer(SharedResource resource) {
      this.resource = resource;
    }
    public void run() {
      String[] messages = {"Hello", "World", "Java", "Concurrency"};
      for (String message : messages) {
        resource.put(message);
        System.out.println("Produced: " + message);
        try {
          Thread.sleep(1000); // Simulate time passing
        } catch (InterruptedException e) {}
      }
      resource.put("DONE");
    }
  }</pre>			<p>Next, we need <a id="_idIndexMarker463"/>to create our <strong class="source-inline">Consumer</strong> class and implement the <span class="No-Break"><strong class="source-inline">Runnable</strong></span><span class="No-Break"> interface:</span></p>
			<pre class="source-code">
  private static class Consumer implements Runnable {
    private SharedResource resource;
    public Consumer(SharedResource resource) {
      this.resource = resource;
    }
    public void run() {
      for (String message = resource.take(); !message.equals("DONE"); 
      message = resource.take()) {
        System.out.println("Consumed: " + message);
        try {
          Thread.sleep(1000); // Simulate time passing
        } catch (InterruptedException e) {}
      }
    }
  }</pre>			<p>The last part <a id="_idIndexMarker464"/>of our application is the <span class="No-Break"><strong class="source-inline">main()</strong></span><span class="No-Break"> class:</span></p>
			<pre class="source-code">
  public static void main(String[] args) {
    SharedResource resource = new SharedResource();
    Thread producerThread = new Thread(new Producer(resource));
    Thread consumerThread = new Thread(new Consumer(resource));
    producerThread.start();
    consumerThread.start();
  }
}</pre>			<p>Our application’s output is <span class="No-Break">provided here:</span></p>
			<pre class="console">
Produced: Hello
Consumed: Hello
Produced: World
Consumed: World
Produced: Java
Consumed: Java
Produced: Concurrency
Consumed: Concurrency</pre>			<p>When we adhere to the best practices provided in this section, we increase the chances of having efficient <a id="_idIndexMarker465"/>multithreading, contributing to a high-performing <span class="No-Break">Java application.</span></p>
			<h1 id="_idParaDest-170"><a id="_idTextAnchor169"/>Synchronization</h1>
			<p><strong class="bold">Synchronization</strong> is another<a id="_idIndexMarker466"/> critical Java concept that we should grasp as we seek to fully understand concurrency. As we indicated earlier, we employ synchronization to avoid <span class="No-Break"><strong class="bold">race conditions</strong></span><span class="No-Break">.</span></p>
			<p class="callout-heading">Race conditions</p>
			<p class="callout">The condition when<a id="_idIndexMarker467"/> multiple threads attempt to modify a shared resource at the same time. The results of this situation are unpredictable and should <span class="No-Break">be avoided.</span></p>
			<p>Let’s look at how we <a id="_idIndexMarker468"/>can implement synchronization in our Java applications by looking at several code snippets. First, we demonstrated adding the <strong class="source-inline">synchronized</strong> keyword to a method’s declaration. This is how we can ensure that <a id="_idIndexMarker469"/>only one thread at a time can execute the method on a <span class="No-Break">specific object:</span></p>
			<pre class="source-code">
public class Counter {
    private int count = 0;
     public synchronized void increment() {
        count++;
    }
     public synchronized int getCount() {
        return count;
    }
}</pre>			<p>We can also<a id="_idIndexMarker470"/> implement <strong class="bold">synchronized blocks</strong>, which are a subset of a method. This level of granularity allows us to synchronize a block without having to lock out the <span class="No-Break">entire method:</span></p>
			<pre class="source-code">
public void increment() {
    synchronized(this) {
        count++;
    }
}</pre>			<p>Java also includes a <strong class="source-inline">Lock</strong> interface that can be used for a more refined approach to locking resources. Here’s how we can <span class="No-Break">implement it:</span></p>
			<pre class="source-code">
import java.util.concurrent.locks.ReentrantLock;
public class Counter {
    private final ReentrantLock lock = new ReentrantLock();
    private int count = 0;
    public void increment() {
        lock.lock();
        try {
            count++;
        } finally {
            lock.unlock();
        }
    }
}</pre>			<p>Java also <a id="_idIndexMarker471"/>includes the <strong class="source-inline">volatile</strong> keyword, which we can use to tell Java that a specific variable is subject to modification by multiple threads. When we declare our variables with this keyword, Java places the variable’s value in a memory location accessible by <span class="No-Break">all threads:</span></p>
			<pre class="source-code">
public class Flag {
    private volatile boolean flag = true;
    public boolean isFlag() {
        return flag;
    }
    public void setFlag(boolean flag) {
        this.flag = flag;
    }
}</pre>			<p>As you undoubtedly will come to understand, synchronization is key for successful concurrency programming <span class="No-Break">in Java.</span></p>
			<h1 id="_idParaDest-171"><a id="_idTextAnchor170"/>Non-blocking algorithms</h1>
			<p>As a final concept of <a id="_idIndexMarker472"/>concurrent programming, let’s look at <strong class="bold">non-blocking algorithms</strong>. These algorithms help us achieve thread safety without having to use the locking mechanisms we previously covered, such as <strong class="source-inline">synchronized</strong> methods<a id="_idIndexMarker473"/> and synchronized blocks. There are three types of non-blocking algorithms – <strong class="bold">lock-free</strong>, <strong class="bold">wait-free</strong>, and <strong class="bold">obstruction-free</strong>. Although<a id="_idIndexMarker474"/> their names are self-describing, let’s take a<a id="_idIndexMarker475"/> <span class="No-Break">closer look.</span></p>
			<p>Modern CPUs support atomic operations, and Java includes several atomic classes that we can use when<a id="_idIndexMarker476"/> implementing <span class="No-Break">non-blocking algorithms.</span></p>
			<p class="callout-heading">Atomic operations</p>
			<p class="callout">These are <a id="_idIndexMarker477"/>operations that are executed by modern CPUs as a single, finite step that ensures consistency without the need <span class="No-Break">for locks.</span></p>
			<p>Here is a code snippet that illustrates how to <span class="No-Break">use </span><span class="No-Break"><strong class="source-inline">AtomicInteger</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
import java.util.concurrent.atomic.AtomicInteger;
public class Counter {
    private AtomicInteger count = new AtomicInteger(0);
    public void increment() {
        count.incrementAndGet();
    }
    public int getCount() {
        return count.get();
    }
}</pre>			<p>The following <a id="_idIndexMarker478"/>example demonstrates how to implement a non-blocking stack. As you will see, our stack uses atomic references, which ensures <span class="No-Break">thread safety:</span></p>
			<pre class="source-code">
import java.util.concurrent.atomic.AtomicReference;
class Node&lt;T&gt; {
    final T item;
    Node&lt;T&gt; next;
    Node(T item) {
        this.item = item;
    }
}
public class ConcurrentStack&lt;T&gt; {
    AtomicReference&lt;Node&lt;T&gt;&gt; top = new AtomicReference&lt;&gt;();
    public void push(T item) {
        Node&lt;T&gt; newHead = new Node&lt;&gt;(item);
        Node&lt;T&gt; oldHead;
        do {
            oldHead = top.get();
            newHead.next = oldHead;
        } while (!top.compareAndSet(oldHead, newHead));
    }
    public T pop() {
        Node&lt;T&gt; oldHead;
        Node&lt;T&gt; newHead;
        do {
            oldHead = top.get();
            if (oldHead == null) {
                return null;
            }
            newHead = oldHead.next;
        } while (!top.compareAndSet(oldHead, newHead));
        return oldHead.item;
    }
}</pre>			<p>We can <a id="_idIndexMarker479"/>gain performance advantages when we use non-blocking algorithms, especially when our application deals with high concurrency. The advantages are counterbalanced by code complexity, which can result in errors and code that is more difficult <span class="No-Break">to maintain.</span></p>
			<h1 id="_idParaDest-172"><a id="_idTextAnchor171"/>Summary</h1>
			<p>This chapter focused on concurrency strategies and models, with the goal of providing insights into the concept of concurrency, the different models and strategies, and some implementation examples. We explored theoretical concepts and practical examples. The concepts covered included concurrency models, synchronization, and non-blocking algorithms. You should now have sufficient knowledge to start experimenting <span class="No-Break">with code.</span></p>
			<p>In the next chapter, we will explore connection pooling with a specific look at concepts, implementation, and best practices. You will have the opportunity to learn how to create and maintain a cache of database connection objects to help increase the performance of your <span class="No-Break">Java applications.</span></p>
		</div>
	</body></html>