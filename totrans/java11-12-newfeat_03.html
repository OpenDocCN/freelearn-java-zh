<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">AppCDS</h1>
                </header>
            
            <article>
                
<p><strong>Application Class-Data Sharing</strong>, or <strong>AppCDS</strong>, extends the capabilities of <strong>Class-Data Sharing </strong>(<strong>CDS</strong>). It enables programmers to include selected application classes in the shared archive file, along with the core library classes, to reduce the startup time of Java applications. It also results in a reduced memory footprint.</p>
<p>The shared archive file created with AppCDS can include classes from the runtime image, application classes from the runtime image, and application classes from the classpath.</p>
<p>In this chapter, we'll cover the following topics:</p>
<ul>
<li>Introduction to CDS</li>
<li>Creating a shared archive with CDS</li>
<li>Introduction to AppCDS</li>
<li>Identifying application files to be placed in the shared archive with AppCDS</li>
<li>Creating and using a shared application archive file</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p>To work with the code in this chapter, you should have JDK version 10 or later installed on your system.</p>
<p>All code in this chapter can be accessed at <a href="https://github.com/PacktPublishing/Java-11-and-12-New-Features">https://github.com/PacktPublishing/Java-11-and-12-New-Features</a>.</p>
<p>Since AppCDS extends the capabilities of CDS, it would help to have an understanding of CDS before starting with AppCDS. The next section introduces CDS, including where to find the shared archive file, how to create or recreate it, and the relevant commands to do so. You can skip the next section on CDS if you have practical experience of working with it.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">What is CDS?</h1>
                </header>
            
            <article>
                
<p>CDS has been a commercial feature with Oracle JVM since Java 8. CDS helps in two ways—it helps to reduce the startup time of a Java application and reduces its memory footprint with multiple <strong>Java Virtual Machines</strong> (<strong>JVMs</strong>).</p>
<p>When you start up your JVM, it performs multiple steps to prepare the environment for execution. This includes bytecode loading, verification, linking, and initializing of core classes and interfaces. The classes and interfaces are combined into the runtime state of JVM so that they can be executed. It also includes method areas and constant pools.</p>
<p>These sets of core classes and interfaces don't change unless you update your JVM. So, every time you start your JVM, it performs the <em>same</em> steps to get the environment up for execution. Imagine you could dump the result to a file, which could be read by your JVM at startup. The subsequent startups could get the environment up and running without performing the intermediate steps of loading, verification, linking, and initialization. Welcome to CDS.</p>
<p>When you <em>install</em> JRE, CDS creates a shared archive file from a set of predefined set of classes from the system <kbd>jar</kbd> file. Classes are verified by the class loaders before they can be used—and this process applies to all the classes. To speed up this process, the installation process loads these classes into an internal representation and then dumps that representation to <kbd>classes.jsa</kbd>—a shared archive file. When JVM starts or restarts, <kbd>classes.jsa</kbd> is memory-mapped to save loading those classes.</p>
<p>When JVM's metadata is shared among multiple JVM processes, it results in a smaller memory footprint. Loading classes from a populated cache is faster than loading them from the disk; they are also partially verified. This feature is also beneficial for Java applications that start new JVM instances.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Location of the shared archive file</h1>
                </header>
            
            <article>
                
<p>By default, the JDK installation process creates the class data-sharing file with the name <kbd>classes.jsa</kbd>. The default location of <kbd>classes.jsa</kbd> is as follows:</p>
<ul>
<li>Solaris/Linux/macOS: <kbd>/lib/[arch]/server/classes.jsa</kbd></li>
<li>Windows platforms: <kbd>/bin/server/classes.jsa</kbd> (as shown in the following screenshot):</li>
</ul>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/52ca0d36-5cfc-4b1c-bf8a-2751ee512629.png" style="width:34.25em;height:8.08em;"/></div>
<div class="packt_infobox">The size of the shared archived file, that is, <kbd>classes.jsa</kbd>, is approximately 17.2 MB on a Windows system.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Manual creation of classes.jsa</h1>
                </header>
            
            <article>
                
<p>This shared archive file can also be created manually using the following runtime command (you should have enough permissions to write to the target directory):</p>
<pre>    <strong>java -Xshare:dump </strong></pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Here's a sample output of the preceding command:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/8127266a-3eea-4d9a-9930-bddfc7875980.png"/></div>
<p>As you can see from the output messages in the preceding screenshot, this command performs a lot of operations—it loads classes, links them, counts the classes that are included in the shared archive, allocates read-write and read-only objects, and a lot more.</p>
<p>If the file already exists, the preceding command simply overrides the existing file.</p>
<div class="packt_infobox">The shared archive file that you create with the preceding command doesn't include <strong>all</strong> the system API classes or interfaces. It includes the ones that are required at startup.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Usage of CDS</h1>
                </header>
            
            <article>
                
<p>You can manually control usage of CDS by switching it on, switching it off, or putting it on automode. These are the command-line options to do so:</p>
<ul>
<li><kbd>java -Xshare:off</kbd>: Disables CDS</li>
<li><kbd>java -Xshare:on</kbd>: Enables CDS</li>
<li><kbd>java -Xshare:auto</kbd>: The default mode (it enables CDS whenever possible)</li>
</ul>
<p>Let's quickly define a class as follows:</p>
<pre>class ConquerWorld { 
    public static void main(String args[]) { 
        System.out.println("Go and conquer the world"); 
    } 
} </pre>
<p>Let's execute the preceding class (<kbd>ConquerWorld</kbd>) using the shared archive file, <kbd>classes.jsa</kbd>. To view the system class loading from the shared archive, you can use a <kbd>log</kbd> file with class execution, as follows:</p>
<pre>    <strong>java -Xlog:class+load:file=myCDSlog.log ConquerWorld</strong>  </pre>
<p>The preceding command outputs the following:</p>
<pre>    <strong>Go and conquer the world</strong>  </pre>
<p>Let's examine the contents of the <kbd>myCDSlog.log</kbd> file (I've highlighted text to draw your attention to specific lines; the highlighted text isn't included in the <kbd>log</kbd> file):</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/d7fac990-7cee-4e80-9315-c7078f2a5dcf.png" style="width:40.00em;height:16.17em;"/></div>
<p>The <kbd>classes.jsa</kbd> file is also referred to as the <strong>shared objects file</strong>. JVM loads approximately 500 classes or interfaces from <kbd>classes.jsa</kbd> to set up the execution environment. It loads the bytecodes of the <kbd>ConquerWorld</kbd> <span>class </span>from the relevant location on the system.</p>
<div class="packt_infobox">If you scrutinize the <kbd>myCDSlog.log</kbd> file, you'll notice that a few of the classes are not loaded from the shared objects file. This is because they couldn't be archived; this can happen in certain cases.</div>
<p>Let's see what happens if you execute the same class (<kbd>ConquerWorld</kbd>) by stating that you don't want to use the shared objects file. To do so, you can use the <kbd>-Xshare:off</kbd> command, as follows:</p>
<pre>    <strong>java -Xshare:off -Xlog:class+load:file=myCDSshareoff.log     <br/>    ConquerWorld</strong>  </pre>
<p>The preceding code will output the same result as it did previously. Let's examine the contents of the <kbd>myCDSshareoff.log</kbd> file:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/7dd91925-8ecc-43fb-96b3-b8d486459f9c.png"/></div>
<p>As you can see, since the preceding execution no longer uses the shared objects file (which was turned off using the <kbd>Xshare:off</kbd> option), the system or core API classes are loaded at runtime from their respective modules. As highlighted at the left bottom of the screenshot, you can also see that this execution takes a longer amount of time, that is, approximately <span class="packt_screen">0.110</span> seconds. This time exceeds the execution time of 0.083 seconds for similar execution, which used the shared archive (shown in previous screenshot).</p>
<p class="mce-root"/>
<p>With the basic information on how CDS can lower execution time for your code, let's get started with AppCDS.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">AppCDS</h1>
                </header>
            
            <article>
                
<p>Increased users and usage of technology are driving exploration or formulation of better ways to improve performance every day. JEP 310 proposed extension of CDS to support application files. In this section, you'll cover how AppCDS is improving the performance of Java applications and how to create and use it.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Benefits of AppCDS</h1>
                </header>
            
            <article>
                
<p>AppCDS extends the benefits of CDS to application classes, enabling you to place application classes with the shared archive of core library classes. This takes off the work of class loading, linking, and bytecode verification, leading to a reduced startup time of an application. Multiple JVMs can access a shared archive, resulting in a reduced overall memory footprint.</p>
<p>In the cloud, it is common for servers to scale a Java application, with multiple JVMs executing the same application. This is an excellent use case that would benefit from AppCDS. Such applications would benefit tremendously from reduced startup time and reduced memory footprint.</p>
<div class="packt_infobox">Serverless cloud services load thousands of application classes at startup. AppCDS will significantly reduce their startup time.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Enabling application class data archive</h1>
                </header>
            
            <article>
                
<p>With Java 10, the default configuration only enabled class data sharing for JVM's bootstrap class loader. Since the bootstrap class loader doesn't load your application's files, you were expected to explicitly enable it for the application class loader and other class loaders using the following command:</p>
<pre>    <strong>-XX:+UseAppCDS</strong></pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>With Java 11, however, AppCDS is automatically enabled with OpenJDK 64-bit systems. When including this option, you might get an error message like this:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/5f3002d9-ecba-4112-8bf6-6ac0a61fa056.png"/></div>
<p>If you are using Java version 11 or later, you can skip this option.</p>
<div class="packt_infobox">Java runtime options are case sensitive. The <kbd>-XX:+UseAppCDS</kbd> and <kbd>-XX:+useAppCDS</kbd> options <span>are not the same.</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Which application classes to archive</h1>
                </header>
            
            <article>
                
<p>The next step in creating a shared archive includes specifying the application classes to be included. Examine the <kbd>myCDSlog.log</kbd> file that you created in the preceding section. It doesn't include each class or interface that is defined in the core Java API.</p>
<p>Similarly, even though your application might include a lot of classes, you need not include <strong>all</strong> of them in the shared archive file, simply because <span>not </span>all of them are required at startup. This also reduces the size of the shared archive file.</p>
<p>Here's an example to find the application classes that should be added to the shared archive. To start with, create a <kbd>jar</kbd> file of your application files.</p>
<p>Let's create four skeleton class files in the <kbd>com.ejavaguru.appcds</kbd> <span>package</span><span>:</span></p>
<pre>// Contents of Cotton.java 
package com.ejavaguru.appcds; 
public class Cotton {} 
 
// Contents of Plastic.java 
package com.ejavaguru.appcds; 
public class Plastic {} 
 
// Contents of PlasticBottle.java 
package com.ejavaguru.appcds; 
public class PlasticBottle extends Plastic {}  
 
// Contents of Wood.java 
package com.ejavaguru.appcds; 
public class Wood {}</pre>
<p class="mce-root"/>
<p>And here's the content of the <kbd>AppCDS</kbd> class, which uses one of the preceding classes. It isn't defined in the same package:</p>
<pre>// Contents of class AppCDS.java 
import com.ejavaguru.appcds.*; 
class AppCDS { 
    public static void main(String args[]) { 
        System.out.println(new Plastic()); 
    } 
} </pre>
<p>If your directory structure matches your package structure, you can create a <kbd>jar</kbd> file using the following command:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/5a90851f-bffe-470c-888d-50de9ef5c47b.png" style="width:44.67em;height:7.17em;"/></div>
<p>To determine the application classes that should be placed in the shared archive, execute the following command:</p>
<pre><strong>java -Xshare:off  
     -XX:DumpLoadedClassList=myappCDS.lst 
     -cp appcds.jar 
      AppCDS</strong> </pre>
<p>On execution of the previous command, <kbd>myappCDS.lst</kbd> records the fully qualified name (separated using <kbd>\</kbd>) of all classes (approximately 500) that were loaded by JVM. It includes both the core API classes and your application classes.</p>
<p>The following screenshot includes a few of these class names from the <kbd>myappCDS.lst</kbd> file. I've highlighted the names of two application files included in this list—<kbd>AppCDS</kbd> and <kbd>com/ejavaguru/appcds/Plastic</kbd>:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/2b81c48e-240c-40c3-86e5-995bf8c2dece.png" style="width:16.42em;height:14.50em;"/></div>
<p>If you revisit the code of the <kbd>AppCDS</kbd> class, you'll notice that it uses just one class, that is, <kbd>Plastic</kbd>, from the <kbd>com.ejavaguru.appcds</kbd> <span>package. </span>The other classes from the same package are not loaded because they are not used. If you want to load other specific classes, you should use them in your application.</p>
<p>After accessing the list of application files to be included in the shared archive, you can move forward and create it.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating an application shared archive file</h1>
                </header>
            
            <article>
                
<p>To create the shared archive with the application files, you can execute the following command in Command Prompt:</p>
<pre>    <strong>java -Xshare:dump </strong>
    <strong>     -XX:+UseAppCDS </strong>
    <strong>     -XX:SharedClassListFile=myappCDS.lst</strong>
    <strong>     -XX:SharedArchiveFile=appCDS.jsa </strong>
    <strong>     -cp appcds.jar</strong>  </pre>
<p>As mentioned in the <em>Enabling application class data archive</em> <span>section</span>, if you are using Java 11 or a later version on your system, you can skip using the <kbd>-XX:+UseAppCDS</kbd> option (AppCDS was introduced in Java 10; with Java 11, you don't need to enable it explicitly). The preceding command uses the list of class names stored in <kbd>myappCDS.lst</kbd> to create the application shared archive file. It also specifies the name of the shared archive file as <kbd>appCDS.jsa</kbd>.</p>
<p class="mce-root"/>
<p>Here's a screenshot of the output from the preceding command:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/1f986e4e-e92f-414a-84b7-67d2db9593e3.png"/></div>
<p>Let's move to the final step—using the shared application archive file.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using the shared application archive file</h1>
                </header>
            
            <article>
                
<p>To use the shared application archive file (<kbd>appCDS.jsa</kbd>) with your AppCDS, execute the following command:</p>
<pre>    <strong>java -Xshare:on </strong>
    <strong>     -XX:+UseAppCDS </strong>
    <strong>     -XX:SharedArchiveFile=appCDS.jsa </strong>
    <strong>     -cp appcds.jar </strong>
    <strong>     AppCDS</strong>  </pre>
<p>The preceding code will use the shared application archive file to load the predefined core API classes and application classes to memory. This results in reduced startup time of user applications. The demo application used in this chapter included just four or five classes to demonstrate the process, without overwhelming you. You should be able to notice a considerable reduction in startup time for bigger user applications. Also, you can share the <kbd>.jsa</kbd> file between JVMs for a reduced memory footprint.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>This chapter started with an introduction to AppCDS, which extends the capabilities of CDS to your application files. AppCDS reduces the startup time for your applications and reduces the memory footprint.</p>
<p>You walked through the process of identifying the application classes to be included in the shared application archive file, creating the file, and using it.</p>
<p>AppCDS is just one of the ways to improve the performance of Java applications. In the next chapter, you'll discover how garbage collection optimizations will help to further improve the performance of Java applications.</p>
<p>In the next chapter, we will look at the various optimizations introduced in garbage collectors.</p>


            </article>

            
        </section>
    </body></html>