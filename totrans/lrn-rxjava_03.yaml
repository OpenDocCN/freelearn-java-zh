- en: Basic Operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, you learned a lot about the `Observable` and `Observer`.
    We also covered a small number of operators, particularly `map()` and `filter()`,
    to understand the role of operators as well. But there are hundreds of RxJava
    operators we can leverage to express business logic and behaviors. We will cover
    operators comprehensively throughout much of this book, so you know which ones
    to use and when. Being aware of the operators available and combining them is
    critical to being successful using ReactiveX. You should strive to use operators
    to express business logic so your code stays as reactive as possible.
  prefs: []
  type: TYPE_NORMAL
- en: It should be noted that operators themselves are Observers to the `Observable`
    they are called on. If you call `map()` on an `Observable`, the returned `Observable`
    will subscribe to it. It will then transform each emission and in turn be a producer
    for Observers downstream, including other operators and the terminal `Observer`
    itself.
  prefs: []
  type: TYPE_NORMAL
- en: You should strive to execute as much logic as possible using RxJava operators,
    and you should use an `Observer` to receive the end product emissions that are
    ready to be consumed. Try not to cheat or get creative by extracting values out
    of the `Observable` chain, or resort to blocking processes or imperative programming
    tactics. When you keep algorithms and processes reactive, you can easily leverage
    the benefits of reactive programming such as lower memory usage, flexible concurrency,
    and disposability.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Suppressing operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transforming operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reducing operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Error-recovery operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Action operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Suppressing operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a number of operators that will suppress emissions that fail to meet
    a specified criterion. These operators work by simply not calling the `onNext()`
    function downstream for a disqualified emission, and therefore does not go down
    the chain to `Observer`. We have already seen the `filter()` operator, which is
    probably the most common suppressing operator. We will start with this one.
  prefs: []
  type: TYPE_NORMAL
- en: filter()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The  `filter()` operator accepts `Predicate<T>` for a given `Observable<T>`.
    This means that you provide it a lambda that qualifies each emission by mapping
    it to a Boolean value, and emissions with false will not go forward.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance,  you can use `filter()` to only allow string emissions that are
    not five characters in length:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code snippet is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `filter()` function is probably the most commonly used operator to suppress
    emissions.
  prefs: []
  type: TYPE_NORMAL
- en: Note that if all emissions fail to meet your criteria, the returned `Observable`
    will be empty, with no emissions occurring before `onComplete()` is called.
  prefs: []
  type: TYPE_NORMAL
- en: take()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `take()` operator has two overloads. One will take a specified number of
    emissions and then call  `onComplete()` after it captures all of them. It will
    also dispose of the entire subscription so that no more emissions will occur.
    For instance, `take(3)` will emit the first three emissions and then call the `onComplete()`
    event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code snippet is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Note that if you receive fewer emissions than you specify in your `take()` function,
    it will simply emit what it does get and then call the `onComplete()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other overload will take emissions within a specific time duration and
    then call  `onComplete()`. Of course, our cold `Observable` here will emit so
    quickly that it would serve as a bad example for this case. Maybe a better example
    would be to use an `Observable.interval()` function. Let''s emit every `300` milliseconds,
    but `take()`emissions for only `2` seconds in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code snippet is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: You will likely get the output that's shown here (each print happening every
    `300` milliseconds). You can only get six emissions in `2` seconds if they are
    spaced out by `300` milliseconds.
  prefs: []
  type: TYPE_NORMAL
- en: Note that there is also a `takeLast()` operator, which will take the last specified
    number of emissions (or time duration) before the `onComplete()`  function is
    called. Just keep in mind that it will internally queue emissions until its `onComplete()`
    function is called, and then it can logically identify and emit the last emissions.
  prefs: []
  type: TYPE_NORMAL
- en: skip()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `skip()` operator does the opposite of the `take()` operator. It will ignore
    the specified number of emissions and then emit the ones that follow.  If I wanted
    to skip the first `90` emissions of an `Observable`, I could use this operator,
    as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the following code snippet is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Just like the `take()` operator, there is also an overload accepting a time
    duration. There is also a `skipLast()` operator, which will skip the last specified
    number of items (or time duration) before the `onComplete()` event is called.
    Just keep in mind that the `skipLast()` operator will queue and delay emissions
    until it confirms the last emissions in that scope.
  prefs: []
  type: TYPE_NORMAL
- en: takeWhile() and skipWhile()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another variant of the `take()` operator is the `takeWhile()` operator, which
    takes emissions while a condition derived from each emission is true. The following
    example will keep taking emissions while emissions are less than `5`. The moment
    it encounters one that is not, it will call the `onComplete()` function and dispose
    of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code snippet is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Just like the `takeWhile()` function, there is a `skipWhile()` function. It
    will keep skipping emissions while they qualify with a condition. The moment that
    condition no longer qualifies, the emissions will start going through. In the
    following code, we skip emissions as long as they are less than or equal to `95`.
    The moment an emission is encountered that does not meet this condition, it will
    allow all subsequent emissions going forward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code snippet is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `takeUntil()` operator is similar to `takeWhile()`, but it accepts another `Observable`
    as a parameter. It will keep taking emissions until that other `Observable` pushes
    an emission. The `skipUntil()` operator has similar behavior. It also accepts
    another `Observable` as an argument but it will keep skipping until the other `Observable`
    emits something.
  prefs: []
  type: TYPE_NORMAL
- en: distinct()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `distinct()` operator will emit each unique emission, but it will suppress
    any duplicates that follow. Equality is based on `hashCode()/equals()` implementation
    of the emitted objects. If we wanted to emit the distinct lengths of a string
    sequence, it could be done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code snippet is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Keep in mind that if you have a wide, diverse spectrum of unique values, `distinct()`
    can use a bit of memory. Imagine that each subscription results in a `HashSet`
    that tracks previously captured unique values.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also add a lambda argument that maps each emission to a key used for
    equality logic. This allows the emissions, but not the key, to go forward while
    using the key for distinct logic. For instance, we can key off each string''s
    length and use it for uniqueness, but emit the strings rather than their lengths:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code snippet is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '`Alpha` is five characters, and `Beta` is four. `Gamma` and `Delta` were ignored
    because `Alpha` was already emitted and is 5 characters. `Epsilon` is seven characters,
    and because no seven-character string was emitted yet, it was emitted forward.'
  prefs: []
  type: TYPE_NORMAL
- en: distinctUntilChanged()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `distinctUntilChanged()` function will ignore duplicate consecutive emissions.
    It is a helpful way to ignore repetitions until they change. If the same value
    is being emitted repeatedly, all the duplicates will be ignored until a new value
    is emitted. Duplicates of the next value will be ignored until it changes again,
    and so on. Observe the output for the following code to see this behavior in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code snippet is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We first receive an emission of `1`, which is allowed forward. But the next
    two `1` are ignored because they are consecutive duplicates. When it switches
    to `2`, that initial 2 is emitted, but the following duplicate is ignored. A `3`
    is emitted and its following duplicate is ignored as well. Finally, we switch
    back to a `2` that emits and then a `1` whose duplicate is ignored.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like `distinct()`, you can provide an optional argument for a key through
    a lambda mapping. In the following code snippet, we execute the `distinctUntilChanged()`
    operation with strings keyed on their lengths:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code snippet is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Note that `Zeta` was skipped because it comes right after `Beta`, which also
    is four characters. `Delta` is ignored as well because it follows `Gamma`, which
    is five characters as well.
  prefs: []
  type: TYPE_NORMAL
- en: elementAt()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can get a specific emission by its index specified by a Long, starting at
    `0`. After that item is found and emitted, `onComplete()` will be called and the
    subscription will be disposed of.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to get the fourth emission coming from an `Observable`, you can
    do it as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the following code snippet is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: You may not have noticed, but `elementAt()` returns `Maybe<T>` instead of `Observable<T>`.
    This is because it will yield one emission, but if there are fewer emissions than
    the sought index, it will be empty.
  prefs: []
  type: TYPE_NORMAL
- en: There are other flavors of `elementAt()`, such as `elementAtOrError()`, which
    return a `Single` and will emit an error if an element at that index is not found.
    `singleElement()` will turn an `Observable` into a `Maybe`, but will produce an
    error if there is anything beyond one element. Finally, `firstElement()` and `lastElement()`
    will yield, maybe emitting the first or last emission, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Transforming operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Next, we will cover various common operators that transform emissions. A series
    of operators in an `Observable` chain is a stream of transformations. You have
    already seen `map()`, which is the most obvious operator in this category. We
    will start with that one.
  prefs: []
  type: TYPE_NORMAL
- en: map()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For a given `Observable<T>`, the `map()` operator will transform a `T` emission
    into an `R` emission using the provided `Function<T,R>` lambda. We have already
    used this operator many times, turning strings into lengths. Here is a new example:
    we can take raw date strings and use the `map()` operator to turn each one into
    a `LocalDate` emission, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code snippet is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: We passed a lambda that turns each string into a `LocalDate` object. We created
    a `DateTimeFormatter` in advance in order to assist with the `LocalDate.parse()`
    operation, which returns a `LocalDate`. In turn, we pushed each `LocalDate` emission
    to our `Observer` to be printed.
  prefs: []
  type: TYPE_NORMAL
- en: The `map()` operator does a one-to-one conversion for each emission. If you
    need to do a one-to-many conversion (turn one emission into several emissions),
    you will likely want to use `flatMap()` or `concatMap()`, which we will cover
    in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: cast()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A simple, map-like operator to cast each emission to a different type is `cast()`.
    If we want to take `Observable<String>` and cast each emission to an object (and
    return an `Observable<Object>`), we could use the `map()` operator like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'But a shorthand we can use instead is `cast()`, and we can simply pass the
    class type we want to cast to, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: If you find that you are having typing issues due to inherited or polymorphic
    types being mixed, this is an effective brute-force way to cast everything down
    to a common base type. But strive to properly use generics and type wildcards
    appropriately first.
  prefs: []
  type: TYPE_NORMAL
- en: startWith()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For a given `Observable<T>`, the `startWith()` operator allows you to insert
    a `T` emission that precedes all the other emissions. For instance, if we have
    an `Observable<String>`that emits items on a menu we want to print, we can use
    `startWith()` to append a title header first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code snippet is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to start with more than one emission, use `startWithArray()` to
    accept `varargs` parameters. If we want to add a divider between our header and
    menu items, we can start with both the header and divider as emissions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code snippet is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The `startWith()` operator is helpful for cases like this, where we want to
    seed an initial value or precede our emissions with one or more emissions.
  prefs: []
  type: TYPE_NORMAL
- en: If you want an entire emissions of `Observable` to precede emissions of another `Observable`,
    you will want to use `Observable.concat()` or `concatWith()`, which we will cover
    in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: defaultIfEmpty()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If we want to resort to a single emission if a given `Observable` comes out
    empty, we can use `defaultIfEmpty()`. For a given `Observable<T>`, we can specify
    a default `T` emission if no emissions occur when `onComplete()` is called.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we have an `Observable<String>` and filter for items that start with `Z` but
    no items meet this criteria, we can resort to emitting `None`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code snippet is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Of course, if emissions were to occur, we would never see `None` emitted. It
    will only happen if the preceding `Observable` is empty.
  prefs: []
  type: TYPE_NORMAL
- en: switchIfEmpty()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Similar to `defaultIfEmpty()`, `switchIfEmpty()` specifies a different `Observable`
    to emit values from if the source `Observable` is empty. This allows you specify
    a different sequence of emissions in the event that the source is empty rather
    than emitting just one value.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could choose to emit three additional strings, for example, if the preceding
    `Observable` came out empty due to a `filter()` operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code snippet is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Of course, if the preceding `Observable` is not empty, then `switchIfEmpty()`
    will have no effect and not use that specified `Observable`.
  prefs: []
  type: TYPE_NORMAL
- en: sorted()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you have a finite `Observable<T>` emitting items that implement `Comparable<T>`,
    you can use `sorted()` to sort the emissions. Internally, it will collect all
    the emissions and then re-emit them in their sorted order. In the following code
    snippet, we sort emissions from `Observable<Integer>`so that they are emitted
    in their natural order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code snippet is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Of course, this can have some performance implications as it will collect all
    emissions in memory before emitting them again. If you use this against an infinite
    `Observable`, you may get an `OutOfMemory` error.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also provide `Comparator` as an argument to specify an explicit sorting
    criterion. We can provide `Comparator` to reverse the sorting order, such as the
    one shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code snippet is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Since `Comparator` is a single-abstract-method interface, you can implement
    it quickly with a lambda. Specify the two parameters representing two emissions,
    and then map them to their comparison operation. We can use this to sort string
    emissions by their lengths, for instance. This also allows us to sort items that
    do not implement Comparable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code snippet is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: delay()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can postpone emissions using the `delay()` operator. It will hold any received
    emissions and delay each one for the specified time period. If we wanted to delay
    emissions by three seconds, we could do it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code snippet is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Because `delay()` operates on a different scheduler (such as `Observable.interval()`),
    we need to leverage a `sleep()` method to keep the application alive long enough
    to see this happen. Each emission will be delayed by three seconds. You can pass
    an optional third Boolean argument indicating whether you want to delay error
    notifications as well.
  prefs: []
  type: TYPE_NORMAL
- en: For more advanced cases, you can pass another `Observable` as your `delay()`
    argument, and this will delay emissions until that other `Observable` emits something.
  prefs: []
  type: TYPE_NORMAL
- en: Note that there is a `delaySubscription()` operator, which will delay subscribing
    to the `Observable` preceding it rather than delaying each individual emission.
  prefs: []
  type: TYPE_NORMAL
- en: repeat()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `repeat()` operator will repeat subscription upstream after `onComplete()`
    a specified number of times.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, we can repeat the emissions twice for a given `Observable` by
    passing a long `2` as an argument for `repeat()`, as shown in the following code
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code snippet is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: If you do not specify a number, it will repeat infinitely, forever re-subscribing
    after every `onComplete()`. There is also a `repeatUntil()` operator that accepts
    a Boolean Supplier lambda argument and will continue repeating until it yields
    `true`.
  prefs: []
  type: TYPE_NORMAL
- en: scan()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `scan()` method is a rolling aggregator. For every emission, you add it
    to an accumulation. Then, it will emit each incremental accumulation.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, you can emit the rolling sum for each emission by passing a lambda
    to the`scan()` method that adds each `next` emission to the `accumulator`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code snippet is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: It emitted the initial value of `5`, which was the first emission it received.
    Then, it received `3` and added it to `5`, emitting `8`. After that, `7` was received,
    which was added to `8`, emitting `15`, and so on. This does not have to be used
    just for rolling sums. You can create many kinds of accumulations (even non-math
    ones such as string concatenations or Boolean reductions).
  prefs: []
  type: TYPE_NORMAL
- en: Note that `scan()` is very similar to `reduce()`, which we will learn about
    shortly. Be careful to not confuse the two. The `scan()`  method emits the rolling
    accumulation for each emission, whereas `reduce()` yields a single emission reflecting
    the final accumulation once `onComplete()` is called. `scan()`can be used on infinite
    Observables safely since it does not require an `onComplete()` call.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also provide an initial value for the first argument and aggregate
    into a different type than what is being emitted. If we wanted to emit the rolling
    count of emissions, we can provide an initial value of `0` and just add `1` to
    it for every emission. Keep in mind that the initial value will be emitted first,
    so use `skip(1)` after `scan()` if you do not want that initial emission:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code snippet is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Reducing operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will likely have moments where you want to take a series of emissions and
    consolidate them into a single emission (usually emitted through a `Single`).
    We will cover a few operators that accomplish this. Note that nearly all of these
    operators only work on a finite `Observable` that calls `onComplete()` because
    typically, we can consolidate only finite datasets. We will explore this behavior
    as we cover these operators.
  prefs: []
  type: TYPE_NORMAL
- en: count()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The simplest operator to consolidate emissions into a single one is `count()`.
    It will count the number of emissions and emit through a Single once `onComplete()`
    is called, shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code snippet is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Like most reduction operators, this should not be used on an infinite `Observable`.
    It will hang up and work infinitely, never emitting a count or calling `onComplete()`.
    You should consider using `scan()` to emit a rolling count instead.
  prefs: []
  type: TYPE_NORMAL
- en: reduce()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `reduce()` operator is syntactically identical to `scan()`, but it only
    emits the final accumulation when the source calls `onComplete()`. Depending on
    which overload you use, it can yield `Single` or `Maybe`. If you want to emit
    the sum of all integer emissions, you can take each one and add it to the rolling
    total. But it will only emit once it is finalized:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code snippet is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Similar to `scan()`, there is a seed argument that you can provide that will
    serve as the initial value to accumulate on. If we wanted to turn our emissions
    into a single comma-separated value string, we could use `reduce()` like this,
    shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code snippet is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: We provided an empty string as our seed value, and we maintain a rolling concatenation
    total and keep adding to it. We prevent a preceding comma using a ternary operator
    to check whether the `total` is the seed value and returning an empty string instead
    of a comma if it is.
  prefs: []
  type: TYPE_NORMAL
- en: Your seed value should be immutable, such as an integer or string. Bad side-effects
    can happen if it is mutable, and you should use `collect()` (or `seedWith()`)
    for these cases, which we will cover in a moment. For instance, if you want to
    reduce `T` emissions into a collection, such as `List<T>`, use `collect()` instead
    of `reduce()`. Using `reduce()` will have an undesired side-effect of using the
    same list for each subscription, rather than creating a fresh, empty one each
    time.
  prefs: []
  type: TYPE_NORMAL
- en: all()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `all()` operator verifies that each emission qualifies with a specified
    condition and return a `Single<Boolean>`. If they all pass, it will emit `True`.
    If it encounters one that fails, it will immediately emit `False`. In the following
    code snippet, we emit a test against six integers, verifying that they all are
    less than `10`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code snippet is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: When the `all()` operator encountered `11`, it immediately emitted `False` and
    called `onComplete()`. It did not even get to `2` or `14` because that would be
    unnecessary work. It already found an element that fails the entire test.
  prefs: []
  type: TYPE_NORMAL
- en: If you call `all()` on an empty `Observable`, it will emit true due to the principle
    of vacuous truth. You can read more about vacuous truth on Wikipedia at [https://en.wikipedia.org/wiki/Vacuous_truth](https://en.wikipedia.org/wiki/Vacuous_truth).
  prefs: []
  type: TYPE_NORMAL
- en: any()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `any()` method will check whether at least one emission meets a specific
    criterion and return a `Single<Boolean>`. The moment it finds an emission that
    qualifies, it will emit true and then call `onComplete()`. If it processes all
    emissions and finds that they all are false, it will emit false and call `onComplete()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code snippet, we emit four date strings, convert them into
    `LocalDate` emissions, and test for any that are in the month of June or later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code snippet is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: When it encountered the `2016-09-12` date, it immediately emitted true and called
    `onComplete()`. It did not proceed to process `2016-04-03`.
  prefs: []
  type: TYPE_NORMAL
- en: If you call `any()` on an empty `Observable`, it will emit false due to the
    principle of vacuous truth. You can read more about vacuous truth on Wikipedia
    at [https://en.wikipedia.org/wiki/Vacuous_truth](https://en.wikipedia.org/wiki/Vacuous_truth).
  prefs: []
  type: TYPE_NORMAL
- en: contains()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `contains()` operator will check whether a specific element (based on the
    `hashCode()/equals()` implementation) ever emits from an `Observable`. It will
    return a `Single<Boolean>` that will emit true if it is found and false if it
    is not.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code snippet, we emit the integers `1` through `10000`, and
    we check whether the number `9563` is emitted from it using `contains()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code snippet is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: As you can probably guess, the moment the element is found, it will emit true
    and call `onComplete()` and dispose of the operation. If the source calls `onComplete()`
    and the element was not found, it will emit `false`.
  prefs: []
  type: TYPE_NORMAL
- en: Collection operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Collection operators will accumulate all emissions into a collection such as
    a list or map and then emit that entire collection as a single emission. Collection
    operators are another form of reducing operators since they consolidate emissions
    into a single one. We will cover them separately since they are a significant
    category on their own, though.
  prefs: []
  type: TYPE_NORMAL
- en: Note that you should avoid reducing emissions into collections for the sake
    of it. It can undermine the benefits of reactive programming where items are processed
    in a beginning-to-end, one-at-a-time sequence. You only want to consolidate emissions
    into collections when you are logically grouping them in some way.
  prefs: []
  type: TYPE_NORMAL
- en: toList()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A common collection operator is `toList()`. For a given `Observable<T>`, it
    will collect incoming emissions into a `List<T>` and then push that entire `List<T>` as
    a single emission (through `Single<List<T>>`). In the following code snippet,
    we collect string emissions into a `List<String>`. After the preceding `Observable` signals
    `onComplete()`, that list is pushed forward to the `observer` to be printed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code snippet is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, `toList()` will use a standard `ArrayList` implementation. You
    can optionally specify an integer argument to serve as the `capacityHint`, and
    that will optimize the initialization of ArrayList to expect roughly that number
    of items:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to specify a different list implementation besides `ArrayList`,
    you can provide a `Callable` lambda as an argument to construct one. In the following
    code snippet, I provide a `CopyOnWriteArrayList` instance to serve as my list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: If you want to use Google Guava's immutable list, this is a little trickier
    since it is immutable and uses a builder. We will show you how to do this with `collect()`
    later in this section.
  prefs: []
  type: TYPE_NORMAL
- en: toSortedList()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A different flavor of `toList()` is `toSortedList()`. This will collect the
    emissions into a list that sorts the items naturally based on their `Comparator`
    implementation. Then, it will emit that sorted `List<T>` forward to the `Observer`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code snippet is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Like `sorted()`, you can provide a `Comparator` as an argument to apply a different
    sorting logic. You can also specify an initial capacity for the backing `ArrayList`
    just like `toList()`.
  prefs: []
  type: TYPE_NORMAL
- en: toMap() and toMultiMap()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For a given `Observable<T>`, the `toMap()` operator will collect emissions into
    `Map<K,T>`, where `K` is the key type derived off a lambda `Function<T,K>` argument
    producing the key for each emission.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to collect strings into `Map<Char,String>`, where each string is
    keyed off their first character, we can do it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code snippet is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: The `s -> s.charAt(0)` lambda argument takes each string and derives the key
    to pair it with. In this case, we are making the first character of that string
    the key.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we wanted to yield a different value other than the emission to associate
    with the key, we can provide a second lambda argument that maps each emission
    to a different value. We can, for instance, map each first letter key with the
    length of that string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code snippet is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, `toMap()` will use `HashMap`. You can also provide a third lambda
    argument that provides a different map implementation. For instance, I can provide
    `ConcurrentHashMap` instead of `HashMap` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that if I have a key that maps to multiple emissions, the last emission
    for that key is going to replace subsequent ones. If I make the string length
    the key for each emission, `Alpha` is going to be replaced by `Gamma`, which is
    going to be replaced by `Delta`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code snippet is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want a given key to map to multiple emissions, you can use `toMultiMap()`
    instead, which will maintain a list of corresponding values for each key. `Alpha`,
    `Gamma`, and `Delta` will then all be put in a list that is keyed off the length
    five:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code snippet is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: collect()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When none of the collection operators have what you need, you can always use
    the `collect()` operator to specify a different type to collect items into. For
    instance, there is no `toSet()` operator to collect emissions into a `Set<T>`,
    but you can quickly use `collect()` to effectively do this. You will need to specify
    two arguments that are built with lambda expressions: `initialValueSupplier`,
    which will provide a new `HashSet`for a new `Observer`, and `collector`, which
    specifies how each emission is added to that `HashSet`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code snippet is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: Now our `collect()` operator will emit a single `HashSet<String>` containing
    all the emitted values.
  prefs: []
  type: TYPE_NORMAL
- en: Use `collect()` instead of `reduce()` when you are putting emissions into a
    mutable object, and you need a new mutable object seed each time. We can also
    use `collect()` for trickier cases that are not straightforward collection implementations.
  prefs: []
  type: TYPE_NORMAL
- en: Say you added Google Guava as a dependency ([https://github.com/google/guava](https://github.com/google/guava))
    and you want to collect emissions into an `ImmutableList`. To create an `ImmutableList` ,
    you have to call its `builder()` factory to yield an `ImmutableList.Builder<T>`**.**
    You then call its `add()` method to put items in the builder, followed by a call
    to `build()`, which returns a sealed, final `ImmutableList<T>` that cannot be
    modified.
  prefs: []
  type: TYPE_NORMAL
- en: 'To collect emissions into `ImmutableList`, you can supply an `ImmutableList.Builder<T>`
    for your first lambda argument and then add each element through its `add()` method
    in the second argument. This will emit `ImmutableList.Builder<T>` once it is fully
    populated, and you can `map()` it to its `build()` call in order to emit an `ImmutableList<T>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code snippet is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: Again, the `collect()` operator is helpful to collect emissions into any arbitrary
    type that RxJava does not provide out of the box.
  prefs: []
  type: TYPE_NORMAL
- en: Error recovery operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Exceptions can occur in your `Observable` chain across many operators depending
    on what you are doing. We already know about the `onError()` event that is communicated
    down the `Observable` chain to the `Observer`. After that, the subscription terminates
    and no more emissions will occur. But sometimes, we want to intercept exceptions
    before they get to the `Observer` and attempt some form of recovery. We cannot
    necessarily pretend that the error never happened and expect emissions to resume,
    but we can attempt re-subscribing or switch to an alternate source `Observable`.
  prefs: []
  type: TYPE_NORMAL
- en: We can still do the former, just not with RxJava operators, which we will see
    shortly. If you find that the error recovery operators do not meet your needs,
    chances are you can compose them creatively.
  prefs: []
  type: TYPE_NORMAL
- en: 'For these examples, let''s divide each integer emission by 10, where one of
    the emissions is `0`. This will result in a "`/ by zero`" exception being emitted
    to the `Observer`, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code snippet is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: onErrorReturn() and onErrorReturnItem()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you want to resort to a default value when an exception occurs, you can
    use `onErrorReturnItem()`. If we want to emit `-1` when an exception occurs, we
    can do it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code snippet is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also supply `Function<Throwable,T>` to dynamically produce the value
    using a lambda. This gives you access to `Throwable` , which you can use to determine
    the returned value as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: The placement of `onErrorReturn()` matters. If we put it before the `map()`
    operator, the error would not be caught because it happened after `onErrorReturn()`.
    To intercept the emitted error, it must be downstream from where the error occurred.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that even though we emitted `-1` to handle the error, the sequence still
    terminated after that. We did not get the `3`, `2`, or `8` that was supposed to
    follow. If you want to resume emissions, you will just want to handle the error
    within the `map()` operator where the error can occur. You would do this in lieu
    of `onErrorReturn()` or `onErrorReturnItem()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code snippet is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: onErrorResumeNext()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Similar to `onErrorReturn()` and `onErrorReturnItem()`, `onErrorResumeNext()`
    is very similar. The only difference is that it accepts another `Observable` as
    a parameter to emit potentially multiple values, not a single value, in the event
    of an exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is somewhat contrived and likely has no business use case, but we can
    emit three `-1` emissions in the event of an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code snippet is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also pass it `Observable.empty()` to quietly stop emissions in the event
    that there is an error and gracefully call the `onComplete()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code snippet is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'Similar to `onErrorReturn()`, you can provide a `Function<Throwable,Observable<T>>`
    lambda to produce an `Observable` dynamically from the emitted `Throwable`, as
    shown in the code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: retry()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another way to attempt recovery is to use the `retry()` operator, which has
    several parameter overloads. It will re-subscribe to the preceding `Observable`
    and, hopefully, not have the error again.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you call `retry()` with no arguments, it will resubscribe an infinite number
    of times for each error. You need to be careful with `retry()` as it can have
    chaotic effects. Using it with our example will cause it to emit these integers
    infinitely and repeatedly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code snippet is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'It might be safer to specify a fixed number of times to `retry()` before it
    gives up and just emits the error to the `Observer`. In the following code snippet,
    we will only retry two times:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code snippet is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: You can also provide `Predicate<Throwable>` or `BiPredicate<Integer,Throwable>`
    to conditionally control when `retry()` is attempted. The `retryUntil()` operator
    will allow retries while a given `BooleanSupplier` lambda is false. There is also
    an advanced `retryWhen()` operator that supports advanced composition for tasks
    such as delaying retries.
  prefs: []
  type: TYPE_NORMAL
- en: Action operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To close this chapter, we will cover some helpful operators that can assist
    in debugging as well as getting visibility into an `Observable` chain. These are
    the action or `doOn` operators.
  prefs: []
  type: TYPE_NORMAL
- en: doOnNext(), doOnComplete(), and doOnError()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: These three operators: `doOnNext()`, `doOnComplete()`, and `doOnError()` are
    like putting a mini `Observer` right in the middle of the `Observable` chain.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `doOnNext()` operator allows you to peek at each emission coming out of
    an operator and going into the next. This operator does not affect the operation
    or transform the emissions in any way. We just create a side-effect for each event
    that occurs at that point in the chain. For instance, we can perform an action
    with each string before it is mapped to its length. In this case, we will just
    print them by providing a `Consumer<T>` lambda:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code snippet is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: You can also leverage `doAfterNext()`, which performs the action after the emission
    is passed downstream rather than before.
  prefs: []
  type: TYPE_NORMAL
- en: The `onComplete()` operator allows you to fire off an action when `onComplete()`
    is called at the point in the `Observable` chain. This can be helpful in seeing
    which points of the `Observable` chain have completed, as shown in the following
    code snippet**:**
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code snippet is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'And, of course, `onError()` will peek at the error being emitted up the chain,
    and you can perform an action with it. This can be helpful to put between operators
    to see which one is to blame for an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code snippet is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: We used `doOnError()` in two places to see where the error first appeared. Since
    we did not see `Source failed!` printed but we saw `Division failed!`, we can
    deduct that the error occurred in the `map()` operator.
  prefs: []
  type: TYPE_NORMAL
- en: Use these three operators together to get an insight into what your `Observable`
    operation is doing or to quickly create side-effects.
  prefs: []
  type: TYPE_NORMAL
- en: You can specify all three actions for `onNext()`, `onComplete()`, and `onError()`
    using `doOnEach()` as well. The `subscribe()` method accepts these three actions
    as lambda arguments or an entire `Observer<T>`. It is like putting `subscribe()`
    right in the middle of your Observable chain! There is also a `doOnTerminate()`
    operator, which fires for an `onComplete()` or `onError()` event.
  prefs: []
  type: TYPE_NORMAL
- en: doOnSubscribe() and doOnDispose()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Two other helpful action operators are `doOnSubscribe()` and `doOnDispose()`.
    The `doOnSubscribe()` fires a specific `Consumer<Disposable>` the moment subscription
    occurs at that point in the `Observable` chain. It provides access to the Disposable
    in case you want to call `dispose()` in that action. The `doOnDispose()` operator
    will perform a specific action when disposal is executed at that point in the
    `Observable` chain.
  prefs: []
  type: TYPE_NORMAL
- en: 'We use both operators to print when subscription and disposal occur, as shown
    in the following code snippet. As you can predict, we see the subscribe event
    fire off first. Then, the emissions go through, and then disposal is finally fired:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code snippet is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: Note that `doOnDispose()` can fire multiple times for redundant disposal requests
    or not at all if it is not disposed of in some form or another. Another option
    is to use the `doFinally()` operator, which will fire after either `onComplete()`
    or `onError()` is called or disposed of by the downstream.
  prefs: []
  type: TYPE_NORMAL
- en: doOnSuccess()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Remember that `Maybe` and `Single` types do not have an `onNext()` event but
    rather an `onSuccess()` operator to pass a single emission. Therefore, there is
    no `doOnNext()` operator on either of these types, as observed in the following
    code snippet, but rather a `doOnSuccess()` operator. Its usage should effectively
    feel like `doOnNext()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code snippet is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We covered a lot of ground in this chapter, and hopefully by now, you are starting
    to see that RxJava has a lot of practical use. We covered various operators that
    suppress and transform emissions as well as reduce them to a single emission in
    some form. You learned how RxJava provides robust ways to recover from errors
    as well as get visibility into what `Observable` chains are doing with action
    operators.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to learn more about RxJava operators, there are many resources online.
    Marble diagrams are a popular form of Rx documentation, visually showing how each
    operator works. The *rxmarbles.com* ([http://rxmarbles.com](http://rxmarbles.com))
    site is a popular, interactive web app that allows you to drag marble emissions
    and see the affected behavior with each operator. There is also an *RxMarbles*
    Android App ([https://play.google.com/store/apps/details?id=com.moonfleet.rxmarbles](https://play.google.com/store/apps/details?id=com.moonfleet.rxmarbles))
    that you can use on your Android device. Of course, you can also see a comprehensive
    list of operators on the ReactiveX website ([http://reactivex.io/documentation/operators.html](http://reactivex.io/documentation/operators.html)).
  prefs: []
  type: TYPE_NORMAL
- en: Believe it or not, we have barely gotten started. This chapter only covered
    the basic operators. In the coming chapters, we will cover operators that perform
    powerful behaviors, such as concurrency and multicasting. But before we do that,
    let's move on to operators that combine Observables.
  prefs: []
  type: TYPE_NORMAL
