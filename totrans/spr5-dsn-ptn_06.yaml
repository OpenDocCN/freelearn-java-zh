- en: Spring Aspect Oriented Programming with Proxy and Decorator pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before you start reading this chapter, I want to share something with you; as
    I was writing this chapter, my wife Anamika, was taking a selfie and uploading
    it to several social media sites such as Facebook and WhatsApp. She keeps a track
    of the *likes*, However, uploading more photos uses more mobile data, and mobile
    data costs money. I rarely use social media as I prefer to avoid paying more to
    the internet company. Every month, the internet company knows how much to bill
    us. Now consider what would happen if the internet usage, total call duration
    and bill calculation was meticulously planned and managed by us? It's possible
    that some obsessive internet users would manage it and I'm really clueless as
    to how.
  prefs: []
  type: TYPE_NORMAL
- en: Calculating billing for internet usage and calls is an important function, but
    it is still not predominant for most internet users. For those like my wife, taking
    selfies, uploading photos to social media, and watching videos on YouTube are
    the kinds of things that most internet users are actively involved in. Managing
    and calculating their internet bill is a passive action for internet users.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly some modules of the enterprise applications are like the internet
    billing calculator for our internet usage. There are some modules in the application
    that have important functionalities that need to be placed at multiple points
    in the application. But it is unexpected to explicitly call these functionalities
    at every points. Functionalities such as logging, security, and transaction management
    are important for your application but your business objects are not actively
    participating in it because your business objects need to focus on the business
    domain problems they're designed for, and leave certain aspects to be handled
    by someone else.
  prefs: []
  type: TYPE_NORMAL
- en: In software development, there are specific tasks to be performed at certain
    points in an application. These tasks or functions are known as **cross-cutting
    concerns**. In an application, all cross-cutting concerns are separate from the
    business logic of this application. Spring provides a module **Aspect-Oriented
    Programming** (**AOP**) to separate these cross-cutting concerns from the business
    logic.
  prefs: []
  type: TYPE_NORMAL
- en: As in [Chapter 4](fb30c4f8-9c4c-4705-b508-3782801e2a81.xhtml), *Wiring Beans
    using Dependency Injection Pattern*, you learned about the dependency injection
    to configure and resolve dependencies of collaborating objects in the application.
    Whereas DI promotes programming to interface and decoupling application objects
    from each other, Spring AOP promotes decoupling between the application's business
    logic and the cross-cutting concerns in the application.
  prefs: []
  type: TYPE_NORMAL
- en: In our bankapp example, transferring money from one account to another account
    is a business logic but logging this activity and securing the transaction are
    cross-cutting concerns in our bankapp application. That means logging, security,
    and transaction are common examples of the application of aspects.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will explore Spring''s support for aspects. It will cover
    the following points:'
  prefs: []
  type: TYPE_NORMAL
- en: Proxy pattern in Spring
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adapter design pattern to handle load time weaving
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decorator design pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Aspect-oriented programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Problems resolved by AOP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Core AOP concepts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining point cuts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing Advices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating aspects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding AOP proxies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before we go further into our Spring AOP discussion, let's first understand
    the implemented patterns under the Spring AOP Framework, and see how these patterns
    are applied.
  prefs: []
  type: TYPE_NORMAL
- en: Proxy pattern in Spring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Proxy design pattern provides an object of class that has the functionality
    of another class. This pattern comes under the structural design pattern of GOF
    design patterns. According to GOF pattern, *Provide a surrogate or placeholder
    for another object to control access to it*. The intent of this design pattern
    is to provide a different class for another class with its functionality to the
    outer world.
  prefs: []
  type: TYPE_NORMAL
- en: Proxying classes using Decorator pattern in Spring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you have seen in [Chapter 3](bd05acbb-a42a-4070-9e01-54a8ce049e41.xhtml),
    *Consideration of Structural and Behavioral Patterns*, according to GOF book,
    *Attach additional responsibilities to an object dynamically. Decorators provide
    a flexible alternative to subclassing for extending functionality.* This pattern
    allows you to add and remove behaviors to an individual object at the runtime
    dynamically or statically without changing the existing behavior of other associated
    objects from the same class.
  prefs: []
  type: TYPE_NORMAL
- en: In Spring AOP, CGLIB is used to create the proxy in the application. CGLIB proxying
    works by generating a subclass of the target class at runtime. Spring configures
    this generated subclass to delegate method calls to the original target--the subclass
    is used to implement the Decorator pattern, weaving in the advice.
  prefs: []
  type: TYPE_NORMAL
- en: Spring provides two ways to create the proxy in the application.
  prefs: []
  type: TYPE_NORMAL
- en: CGLIB proxy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JDK proxy or dynamic proxy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s see the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **JDK proxy** | **CGLIB proxy** |'
  prefs: []
  type: TYPE_TB
- en: '| Also called **dynamic proxies** | NOT built into JDK |'
  prefs: []
  type: TYPE_TB
- en: '| API is built into the JDK | Included in Spring JARs |'
  prefs: []
  type: TYPE_TB
- en: '| Requirements: Java interface(s) | Used when interface not available |'
  prefs: []
  type: TYPE_TB
- en: '| All interfaces proxied | Cannot be applied to final classes or methods |'
  prefs: []
  type: TYPE_TB
- en: 'Let''s see the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9b911954-7460-422b-be91-2ca3bb52de3e.png)'
  prefs: []
  type: TYPE_IMG
- en: Note--CGLIB proxying has one issue to be considered, that is, final methods
    can't be advised, as they can't be overridden.
  prefs: []
  type: TYPE_NORMAL
- en: In the following section let's learn more about the cross-cutting concerns.
  prefs: []
  type: TYPE_NORMAL
- en: What are cross-cutting concerns?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In any application, there is some generic functionality that is needed in many
    places. But this functionality is not related to the application's business logic.
    Suppose you perform a role-based security check before every business method in
    your application. Here security is a cross-cutting concern. It is required for
    any application but it is not necessary from the business point of view, it is
    a simple generic functionality we have to implement in many places in the application.
    The following are examples of the cross-cutting concerns for the enterprise application.
  prefs: []
  type: TYPE_NORMAL
- en: Logging and tracing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transaction management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Security
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Caching
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Error handling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performance monitoring
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom business rules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's see how we will implement these cross-cutting concerns in our application
    by using aspects of Spring AOP.
  prefs: []
  type: TYPE_NORMAL
- en: What is Aspect-Oriented Programming?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As mentioned earlier, **Aspect-Oriented Programming** (**AOP**) enables modularization
    of cross-cutting concerns. It complements **Object-oriented programming** (**OOP**)
    which is another programing paradigm. OOP has class and object as key elements
    but AOP has aspect as key element. Aspects allow you to modularize some functionality
    across the application at multiple points. This type of functionality is known
    as **cross-cutting concerns**. For example, security is one of the cross-cutting
    concerns in the application, because we have to apply it at multiple methods where
    we want security. Similarly, transaction and logging are also cross-cutting concerns
    for the application and many more. Let''s see in the following figure how these
    concerns are applied to the business modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/adfca5cd-3471-4fc6-9b82-e378370fb23a.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see in the preceding figure, there are three main business modules
    as **TransferService**, **AccountService**, and **BankService**. All business
    modules require some common functionality such as **Security**, **Transaction**
    management and **Logging**.
  prefs: []
  type: TYPE_NORMAL
- en: Let's check out what problems we have to face in the application if we do not
    use the Spring AOP.
  prefs: []
  type: TYPE_NORMAL
- en: Problems resolved by AOP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As stated earlier, aspects enable modularization of cross-cutting concerns.
    So if you are not using aspects, then modularization of some cross-cutting functionality
    is not possible. It tends to mix the cross-cutting functionality with the business
    modules. If you use a common object-oriented principle to reuse the common functionalities
    such as security, logging and transaction management, *you need to use* inheritance
    or composition. But here using inheritance can violate the single responsibility
    of SOLID principles and also increase object hierarchy. Also, the composition
    can be complicated to handle across the application. That means, failing to modularize
    cross-cutting concerns leads to two main problems as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Code tangling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code scattering
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code tangling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It is a coupling of concerns in the application. Code tangling occurs when
    there is a mixing of cross-cutting concerns with the application''s business logic.
    It promotes tight coupling between the cross-cutting and business modules. Let''s
    see the following code to understand more about code tangling:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see in the preceding code, security concern code (highlighted) is
    mixing with application''s business logic code. This situation is an example of
    code tangling. Here we have only included security concern, but in the enterprise
    application you have to implement multiple cross-cutting concerns such as logging,
    transaction management and so on. In such cases, it will be even more complicated
    to manage the code and make any change to the code, which may cause critical bugs
    in the code as follows in the figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5e372d1d-cc14-4430-94d1-8926573c605a.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding figure, you can see there are three cross-cutting concerns
    which are distributed across the `TransferService` business class and cross-cutting
    concerns logic mixing with `AccountService`'s business logic. This coupling between
    the concerns and application's logic is called **code tangling**. Let's see another
    main problem if we are using aspects for cross-cutting concern.
  prefs: []
  type: TYPE_NORMAL
- en: Code scattering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This means that the same concern is spread across modules in the application.
    Code scattering promotes the duplicity of the concern''s code across the application
    modules. Let''s see the following code to understand more about code scattering:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see in the preceding code, there are two modules for the application,
    `TransferService` and `AccountService`. Both modules have the same cross-cutting
    concern code for the security. The bold highlighted code in both business modules
    are the same, it means there is code duplication here. The following figure illustrates
    code scattering:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c8012756-1076-44af-b483-493e64d5e477.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding figure, there are three business modules **TransferService**,
    **AccountService**, and **BankService**. Each business module contains cross-cutting
    concerns such as **Security**, **Logging** and **Transaction** management. All
    modules have the same code of concerns in the application. It is actually duplication
    of concerns code across the application.
  prefs: []
  type: TYPE_NORMAL
- en: Spring AOP provides solution for these two problems that is, code tangling and
    code scattering in the Spring application. Aspects enable modularization of cross-cutting
    concerns to avoid tangling and to eliminate scattering. Let's see in further section
    how AOP solves these problems.
  prefs: []
  type: TYPE_NORMAL
- en: How AOP Works to solve problems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Spring AOP allows you to keep cross-cutting concern logic separate from the
    mainline application logic. That means, you can implement your mainline application
    logic and only focus on the core problem of the application. And you can write
    aspects to implement your cross-cutting concerns. Spring provides many aspects
    out-of-the-box. After creating the aspects, you can add these aspects that is,
    cross-cutting behaviors to the right places into your application. Let''s see
    the following figure that illustrates the functionality of AOP:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ef9a3a53-6425-4198-9c33-db865e4c4942.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see in the preceding figure, all aspects such as Security, Logging,
    and Transaction aspect are implemented separately in the application. We have
    added these aspects at the right places in the applications. Now our application
    logic is separate from the concerns. Let's see the following section defining
    the core AOP concepts and use AOP's terminology in your application.
  prefs: []
  type: TYPE_NORMAL
- en: Core AOP terminology and concepts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As with other technologies, AOP has its own vocabularies. Let''s start to learn
    some core AOP concepts and terminology. Spring used the AOP paradigm for the Spring
    AOP module. But unfortunately, terms used in the Spring AOP Framework are Spring-specific.
    These terms are used to describe AOP modules and features, but these aren''t intuitive.
    In spite of this, these terms are used in order to understand AOP. Without an
    understanding of the AOP idiom you will not be able to understand AOP functionality.
    Basically, AOP is defined in terms of advice, pointcuts, and join points. Let''s
    see the following figure that illustrates about the core AOP concepts and how
    they are tied together in the framework:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f45ada93-dcf9-4f09-86db-f36b666fc9e6.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding figure, you can see an AOP functionality, it is known as **Advices**
    and it is implemented into multiple points. These points are known as **Joint
    Points**, these are defined by using an expression. These expression are known
    as **pointcuts**. Let's understand these terms in detail using an example (remember
    my wife's internet bill story?).
  prefs: []
  type: TYPE_NORMAL
- en: Advice
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An internet plan is used for calculating the bill according to data usage in
    MB or GB by the internet company. The internet company has a list of customers,
    also and they also company calculates the internet bill for them. So calculating
    bills and sending it to the customers is a core job for the internet company but
    not for customers. Likewise, each aspect has its own main job and also has a purpose
    for doing this job. The job of an aspect is known as advice in the AOP.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you know now, advice is a job, aspect will perform this job, so there are
    some questions that come to in mind, when to perform this job and what will be
    in this job. Will this job be performed before a business method is invoked? Or
    will it be performed after the business method is invoked? Or will it be performed
    both before and after method invocation? Or it will be performed when business
    method throws an exception. Sometime this business method is also called the **advised
    method**. Let''s see the following five kinds of advises used by Spring aspects:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Before:** Advice''s job executes before the `advised` method is invoked.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the advice throws an exception, target will not be called - this is a valid
    use of a Before Advice.
  prefs: []
  type: TYPE_NORMAL
- en: '**After:** Advice''s job executes after the advised method completes regardless
    of whether an exception has been thrown by the target or not.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**After-returning:** Advice''s job executes after the advised method successfully
    completes. For example, if a business method returns without throwing an exception.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**After-throwing:** Advice''s job executes if the advised method exits by throwing
    an exception.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Around:** This is one of the most powerful advice of Spring AOP, this advice
    surrounds the advised method, providing some advice''s job before and after the
    advised method is invoked.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In short, advice's job code to be executed at each selected point that is, Join
    Point, let's look into another term of AOP.
  prefs: []
  type: TYPE_NORMAL
- en: Join Point
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The internet company provides internet to many customers. Each customer has
    an internet plan and that plan needs to be used for their bill calculation. With
    the help of each internet plan, the company could potentially calculates the internet
    bill for all customers. Similarly, your application may have multiple number of
    places to apply advice. These places in the application are called **join points**.
    A join point is a point in the execution of a program such as a method call or
    exception thrown. In these points, Spring aspect inserts concern functionality
    in your application. Let's see how AOP knows about the join points and discuss
    another term of AOP concepts.
  prefs: []
  type: TYPE_NORMAL
- en: Pointcut
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Internet company makes a number of internet plans according to usage of internet
    data (customers like my wife need more data) because it is not possible for any
    internet company to provide same plan for all customers or a unique plan for each
    customer. Instead, each plan is assigned to the subset of the customers. In the
    same way, an advice is not necessary to apply to all join points in an application.
    You can define an expression that selects one or more Join Points in the application.
    This expression is known as **pointcut**. It helps to narrow down the join points
    advised by an aspect. Let's see another term of AOP that is Aspect.
  prefs: []
  type: TYPE_NORMAL
- en: Aspect
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An internet company knows which customer has what internet plan. On the basis
    of this information the internet company calculates an internet bill and sends
    it to the customer. In this example internet company is an aspect, internet plans
    are pointcuts and customers are join points, and calculating internet bills by
    the company is an advice. Likewise, in your application, an aspect is a module
    that encapsulates pointcuts and advice. Aspects know what it does; where and when
    it does it in the application. Let's see how AOP applies the aspect to the business
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: Weaving
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Weaving** is a technique by which aspects are combined with the business
    code. This is a process of applying aspects to a target object by creating a new
    proxy object. Weaving can be done at the compile time or at class load time, or
    at runtime. Spring AOP uses the runtime weaving by using proxy pattern.'
  prefs: []
  type: TYPE_NORMAL
- en: You have seen lot of terms used in the AOP. You must know about this terminology
    whenever your learn about any AOP Framework either AspectJ or Spring AOP. Spring
    has used AspectJ Framework to implement Spring AOP Framework. Spring AOP supports
    limited features of AspectJ. Spring AOP provides proxy-based AOP solution. Spring
    only supports the method joint points. Now you have some basic idea about Spring
    AOP and how it works, let's move on the next topics how to define pointcuts in
    the Spring's declarative AOP model.
  prefs: []
  type: TYPE_NORMAL
- en: Defining pointcuts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned before, pointcuts are used to define a point where advice would
    be applied. So pointcut is one of the most important elements of an aspect in
    the application. Let's understand how to define pointcuts. In Spring AOP, we can
    use expression language to define the pointcuts. Spring AOP uses AspectJ's pointcut
    expression language for selecting where to apply advice. Spring AOP supports a
    subset of the pointcut designators available in AspectJ because as you know, Spring
    AOP is proxy-based and some designators do not support proxy-based AOP. Let's
    see following table has Spring AOP supported designators.
  prefs: []
  type: TYPE_NORMAL
- en: '| **Spring supported AspectJ designators** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| execution | It matches the join points by method executions, it is primary
    pointcut designator supported by Spring AOP. |'
  prefs: []
  type: TYPE_TB
- en: '| within | It matches the join points by limit within certain types. |'
  prefs: []
  type: TYPE_TB
- en: '| this | It limits matching to join points where the bean reference is an instance
    of the given type. |'
  prefs: []
  type: TYPE_TB
- en: '| target | It limits matching to join points where the target object is of
    a given type. |'
  prefs: []
  type: TYPE_TB
- en: '| args | It limits matching to join points where the arguments are instances
    of the given types. |'
  prefs: []
  type: TYPE_TB
- en: '| `@target` | It limits matching to join points where the target object has
    an annotation of the given type. |'
  prefs: []
  type: TYPE_TB
- en: '| `@args` | It limits matching to join points where the runtime, type of the
    actual arguments passed have annotations of the given type. |'
  prefs: []
  type: TYPE_TB
- en: '| `@within` | It limits matching to join points where the declared type of
    the target object has the given type annotation. |'
  prefs: []
  type: TYPE_TB
- en: '| `@annotation` | It limits matching to join points where the subject of the
    join point has the given annotation. |'
  prefs: []
  type: TYPE_TB
- en: As listed earlier, Spring supported pointcut designators, execution is primary
    pointcut designator. So here I will only show you how to define pointcuts using
    execution designators. Let's see how to write the pointcut expression in the application.
  prefs: []
  type: TYPE_NORMAL
- en: Writing pointcuts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can write pointcuts by using execution designator as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**execution(<method pattern>)**: The method must match the pattern as defined
    follows'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Can chain together to create composite pointcuts by using following operators**:
    `&& (and)`, `|| (or)`, `! (not)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Method pattern**: Following is method pattern:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[Modifiers] ReturnType [ClassType]`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MethodName ([Arguments]) [throws ExceptionType]`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In the preceding method pattern, values within bracket `[ ]` that is, modifiers,
    `ClassType`, arguments and exceptions are all optional values. There is no need
    to define it for every pointcut using execution designator. Value without brackets
    such as `ReturnType`, and `MethodName` are mandatory to define.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s define a `TransferService` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '`TransferService` is a service for transferring amounts from one to another
    account. Let''s say that you want to write a logging aspect that triggers off
    `TransferService`''s `transfer()` method. The following figure illustrates a pointcut
    expression that can be used to apply advice whenever the `transfer()` method is
    executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fd74bf26-fc3c-4b3a-a33e-28e15f5de131.png)'
  prefs: []
  type: TYPE_IMG
- en: As in the preceding figure, you can see, I used the `execution()` designator
    to select join point `TransferService`'s `transfer()` method. In preceding expression
    in figure, I have used an asterisk at the beginning of the expression. This means
    that method can return any type. And after asterisk, I have specified a fully
    qualified class name and name of method as `transfer()`. As method arguments,
    I have used double dot (..), it means that the pointcut can select a method whose
    name is `transfer()` with no parameter or any number of parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see following some more pointcut expressions to select join points:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Any class or package:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**execution(void transfer*(String))**: Any method starting with transfer that
    takes a single String parameter and has a void return type'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**execution(* transfer(*))**: Any method named `transfer()` that takes a single
    parameter'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**execution(* transfer(int, ..))**: Any method named transfer whose first parameter
    is an int (the `".."` signifies zero or more parameters may follow)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Restrict by class:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`execution(void com.packt.patterninspring.chapter6.bankapp.service.TransferServiceImpl.*(..))`:
    Any void method in the `TransferServiceImpl` class, it is including any sub-class,
    but will be ignored if a different implementation is used.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Restrict by interface:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`execution(void com.packt.patterninspring.chapter6.bankapp.service.TransferService.transfer(*))`:
    Any void `transfer()` method taking one argument, in any object implementing `TransferService`,
    it is more flexible choice--works if implementation changes.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Annotations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`execution(@javax.annotation.security.RolesAllowed void transfer*(..))`: Any
    void method whose name starts with `transfer` that is annotated with the `@RolesAllowed`
    annotation.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with packages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`execution(* com..bankapp.*.*(..))`: There is one directory between `com` and
    `bankapp`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`execution(* com.*.bankapp.*.*(..))`: There may be several directories between
    `bankapp` and `com`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`execution(* *..bankapp.*.*(..))`: Any sub-package called `bankapp`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that you have seen that the basics of writing pointcuts, let's see how to
    write the advice and declare the aspects that use those pointcuts
  prefs: []
  type: TYPE_NORMAL
- en: Creating aspects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As I said earlier, *aspects* is one of the most important terms in the AOP.
    Aspect merges the pointcuts and advices in the application. Let's see how to define
    aspect in the application.
  prefs: []
  type: TYPE_NORMAL
- en: You've already defined the `TransferService` interface as the subject of your
    aspect's pointcuts. Now let's use AspectJ annotations to create an aspect.
  prefs: []
  type: TYPE_NORMAL
- en: Define aspects using Annotation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Suppose in your bank application, you want to generate log for a money transfer
    service for auditing and tracking to understand customers'' behaviors. A business
    never succeeds without understanding its customers. Whenever you will think about
    it from the perspective of a business, an auditing is required but isn''t central
    to the function of the business itself; it''s a separate concern. Therefore, it
    makes sense to define the auditing as an aspect that''s applied to a transfer
    service. Let''s see the following code which shows the `Auditing` class that defines
    the aspects for this concern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As you can see how the `Auditing` class is annotated with `@Aspect` annotation.
    It means this class is not just Spring bean, it is an aspect of the application.
    And `Auditing` class has some methods, these are advices and define some logic
    within these methods. As we know that before beginning to transfer amount from
    an account to another, bank will validate (`validate ()`) the use credentials
    and after that instantiate (`transferInstantiate()`) this service. After successful
    validation (`success ()`) amount is transferred and the bank audits it. But if
    the amount transferring fails in any case, then the bank should roll back (`rollback
    ()`) that amount.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, all methods of `Auditing` aspects are annotated with advice
    annotations to indicate when those methods should be called. Spring AOP provides
    five type advice annotations for defining advice. Let''s see in the following
    table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Annotation** | **Advice** |'
  prefs: []
  type: TYPE_TB
- en: '| `@Before` | It is used for before advice, `advice`''s method executes before
    the advised method is invoked. |'
  prefs: []
  type: TYPE_TB
- en: '| `@After` | It is used for after advice, advice''s method execute after the
    advised method executes normally or abnormally doesn''t matter. |'
  prefs: []
  type: TYPE_TB
- en: '| `@AfterReturning` | It used for after returning advice, advice''s method
    execute after the advised method complete successfully. |'
  prefs: []
  type: TYPE_TB
- en: '| `@AfterThrowing` | It used for after throwing advice, advice''s method execute
    after the method terminate abnormally by throwing an exception. |'
  prefs: []
  type: TYPE_TB
- en: '| `@Around` | It is used for around advice, advice''s method executes before
    and after the advised method invoked. |'
  prefs: []
  type: TYPE_TB
- en: Let's see the implementation of advices and how these work in the application.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing Advice
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you know that, Spring provides five types of advices, let's see work flow
    of one by one.
  prefs: []
  type: TYPE_NORMAL
- en: Advice type - Before
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s see the following figure for before advice. This advice executes the
    before the target method:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2326ca56-3752-4323-8173-14d3d5077e09.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see in figure, before advice is executed first and then it calls
    the **Target** method. As we know that Spring AOP is proxy-based. So a **Proxy**
    object is created of target class. It is based on Proxy design pattern and Decorator
    Design Pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Before Advice example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s see the use of `@Before` annotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Note--if the advice throws an exception, target will not be called--this is
    a valid use of a Before Advice.
  prefs: []
  type: TYPE_NORMAL
- en: Now you have seen the before advice, let's have a look into another type advice.
  prefs: []
  type: TYPE_NORMAL
- en: 'Advice Types: After Returning'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s see the following figure for after returning advice. This advice executes
    the after the **Target** method executed successfully:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/83caf5aa-cf58-49e4-a856-16798371089a.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see in figure, the after returning advice is executed after the target
    returns successfully. This advice will never execute if target throws any exception
    in the application.
  prefs: []
  type: TYPE_NORMAL
- en: After Returning Advice example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s see the use of the `@AfterReturning` annotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Now you have seen the after returning advice, let's move to another type advice
    in the Spring AOP.
  prefs: []
  type: TYPE_NORMAL
- en: 'Advice Types: After Throwing'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s see the following figure for after throwing advice. This advice executes
    the after the target method terminated abnormally. It mean the `target` method
    throws any exception, then this advice will be executed. Please refer to the following
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/aa71dc23-ee24-4fe2-9ff6-46379859a877.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see in figure, the after throwing advice is executed after the target
    throws an exception. This advice will never execute if the target doesn't throw
    any exception in the application.
  prefs: []
  type: TYPE_NORMAL
- en: After Throwing Advice example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s see the use of the `@AfterThrowing` annotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use the `@AfterThrowing` annotation with the throwing attribute,
    it only invokes advice if the right exception type is thrown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Execute every time a `TransferService` class throws an exception of type `DataAccessException`.
  prefs: []
  type: TYPE_NORMAL
- en: The `@AfterThrowing` advice will not stop the exception from propagating. However,
    it can throw a different type of exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'Advice Types: After'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s see the following figure for **AfterAdvice**. This advice executes after
    the **Target** method is terminated normally or abnormally. It doesn''t matter
    that **Target** method throws any exception or executes without any exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1b0871fc-98a6-47c9-93c3-cc2f3b299093.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see in figure, the after advice is executed after the `target` method
    terminates by throwing any exception or normally.
  prefs: []
  type: TYPE_NORMAL
- en: After Advice example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s see the use of `@After` annotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Use `@After` annotation called regardless of whether an exception has been thrown
    by the target or not.
  prefs: []
  type: TYPE_NORMAL
- en: Advice Types - Around
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s see the following figure for **AroundAdvice**. This advice executes
    both times before and after the **Target** method is invoked. This advice is very
    powerful advice of Spring AOP. Many features of the Spring Framework are implemented
    by using this advice. This is the only advice in Spring which has capability to
    stop or proceed the target method execution. Please refer to the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f85e8209-cdcc-4a3f-8bfa-9b7d79f40e51.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see in the preceding figure, **AroundAdvice** executed two times,
    first time it is executed before the advised method and second time it is executed
    after advised method is invoked. And also this advice calls the `proceed()` method
    to execute the advised method in the application. Let''s see the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: Around Advice example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s see the use of the `@Around` annotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Here I used `@Around` annotation and a `ProceedingJoinPoint`, it inherits from
    Join Point and adds the `proceed()` method. As you can see in this example, this
    advice proceeds to target only if value is not already in the cache.
  prefs: []
  type: TYPE_NORMAL
- en: You have seen how to implement the advice in the application using annotations
    and how to create aspect and how to define pointcuts by annotations. In this example,
    we are using Auditing as an aspect class and it is annotated with `@Aspect` annotation,
    but this annotation will not work if you don't enable AOP proxy behavior of the
    Spring.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see the following Java configuration file, `AppConfig.java`, you can
    turn on auto-proxying by applying the `@EnableAspectJAutoProxy` annotation at
    the class level:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'If you''re using XML configuration, let''s see how to wire your beans in Spring
    and how to enable Spring AOP feature by using the `<aop:aspectj-autoproxy>` element
    from Spring''s AOP namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Let's see how you can declare aspects in a Spring XML configuration file.
  prefs: []
  type: TYPE_NORMAL
- en: Define aspects using XML configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we know that, we can configure beans in the XML based configuration, similarly
    you can declare aspects in the XML configuration. Spring provides another AOP
    namespace and it offers many elements that are used to declare aspects in XML,
    let''s see in the following tables:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Annotation** | **Parallel XML element** | **Purpose of XML element** |'
  prefs: []
  type: TYPE_TB
- en: '| `@Before` | `<aop:before>` | It defines before advice. |'
  prefs: []
  type: TYPE_TB
- en: '| `@After` | `<aop:after>` | It defines after advice. |'
  prefs: []
  type: TYPE_TB
- en: '| `@AfterReturning` | `<aop:after-returning>` | It defines after returning
    advice. |'
  prefs: []
  type: TYPE_TB
- en: '| `@AfterThrowing` | `<aop:after-throwing>` | It defines after throwing advice.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `@Around` | `<aop:around>` | It defines around advice. |'
  prefs: []
  type: TYPE_TB
- en: '| `@Aspect` | `<aop:aspect>` | It defines an aspect. |'
  prefs: []
  type: TYPE_TB
- en: '| `@EnableAspectJAutoProxy` | `<aop:aspectj-autoproxy>` | It enables annotation-driven
    aspects using `@AspectJ`. |'
  prefs: []
  type: TYPE_TB
- en: '| `@Pointcut` | `<aop:pointcut>` | It defines a pointcut. |'
  prefs: []
  type: TYPE_TB
- en: '| -- | `<aop:advisor>` | It define AOP adviser |'
  prefs: []
  type: TYPE_TB
- en: '| -- | `<aop:config>` | It is top level AOP element |'
  prefs: []
  type: TYPE_TB
- en: 'As you can see in the preceding table, a number of AOP namespace elements are
    parallel to the corresponding annotation available in the Java based configuration.
    Let''s see the following same example in the XML based configuration, first have
    a look into the aspect class `Auditing`. Let''s remove all of those AspectJ annotations
    as shown in following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see the preceding code, now our aspect class doesn''t indicate that
    it is an aspect class. It is a basic Java POJO class with some methods. Let''s
    see in next section how to declare advices in XML configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, `<aop-config>` is using a top level element. In `<aop:config>`,
    you declare other elements like `<aop:aspect>`, this element has `ref` attribute
    and it references to the POJO bean Auditing. It indicates that `Auditing` is an
    aspect class in the application. Now `<aop-aspect>` element has advices and pointcuts
    elements. All logics are same as we have defined in Java configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see in the next section how spring create AOP proxy.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding AOP proxies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As you know that, Spring AOP is proxy-based. It mean Spring creates the proxy
    to weave the aspect between the business logic that is, in `target` object. It
    is based on the Proxy and Decorator design pattern. Let''s see `TransferServiceImpl`
    class as an implementation of `TransferService` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Caller invokes this service (`transfer()` method) directly by the object reference,
    let''s see the following figure to illustrate more:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/32f326cc-3a54-42ad-8912-5e0b5346bb20.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see that caller could directly call the service and do the task assigned
    to it.
  prefs: []
  type: TYPE_NORMAL
- en: But you declare this `TransferService` as a target for the aspect. Since this
    is done, things change slightly. Now this class wrapped by proxy and client code
    actually doesn't call this service directly, it calls routed by this proxy. Let's
    see the following diagram.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0488bcb2-9014-4db0-b912-7f2e31556772.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see in the preceding diagram, Spring apply the AOP-proxy to the
    object in the following sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: Spring creates a proxy weaving aspect and target.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Proxy also implements target interface, that is, `TransferServive` interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: All calls for transfer service method `transfer()` routed through proxy interceptor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Matching advice is executed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then `target` method is executed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As preceding list, is the flow when you call the method that has the proxy created
    by Spring.
  prefs: []
  type: TYPE_NORMAL
- en: You have seen in this chapter the Spring AOP Framework, it has actually implemented
    some part of the AspectJ Framework using proxy-based aspect weaving. I think,
    this gave good knowledge about Spring AOP.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have seen the Spring AOP Framework and used design patterns
    behind this module. AOP is a very powerful paradigm and it complements the Object
    oriented programming. **Aspect-Oriented Programming** (**AOP**) modularizes cross-cutting
    concerns such as Logging, Security and Transaction. An aspect is a Java class
    annotated with `@Aspect` annotation. It defines a module containing the crosscutting
    behavior. This module separates from the application's business logic. We can
    reuse it in our application with other business modules without making any changes.
  prefs: []
  type: TYPE_NORMAL
- en: In Spring AOP, behavior is implemented as an advice method. You have learned
    in Spring, there are five types as Before, AfterThrowing, AfterReturning, After
    and Around. Around advice is a very powerful advice, there are interesting features
    implemented by using Around advice. You've learned how to weave these advices
    using load time weaving.
  prefs: []
  type: TYPE_NORMAL
- en: You have seen how to declare Pointcuts in the Spring application and pointcuts
    select joinpoints where advice applies.
  prefs: []
  type: TYPE_NORMAL
- en: Now we'll move to the essential part and look at how spring works in the backend
    to connect with database and read data for the application. Starting in the next
    chapter, you'll see how to build applications using JDBC template in Spring.
  prefs: []
  type: TYPE_NORMAL
