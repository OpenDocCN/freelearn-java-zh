["```java\n(and\n  (or (> x 23) (> y 55))\n  (or (= c d) (= e f))\n  (or (> a 55) (> b 55)))\n```", "```java\n(and-ors (> x 23) (> y 55) | (= c d) (= e f) | (> a 55) (> b 55))\n```", "```java\n(defmacro my-macro\n  \"Macro for showing how to write macros\"\n  [param]\n  ;;TODO: do something\n  )\n```", "```java\n(defmacro minimal-macro []\n  '(println \"I'm trapped inside a macro!\"))\n```", "```java\n(defn minimal-function []\n  (println \"I'm trapped inside a function!\"))\n```", "```java\nuser> (minimal-macro)\nI'm trapped inside a macro!\nnil\nuser> (minimal-function)\nI'm trapped inside a function!\nnil\n```", "```java\nuser> (macroexpand '(minimal-function))\n(minimal-function)\n```", "```java\nuser> (macroexpand '(minimal-macro))\n(println \"I'm trapped inside a macro!\")\n```", "```java\n(defmacro mistaken-macro []\n  (println \"I'm trapped... somewhere!\"))\n```", "```java\nuser> (mistaken-macro)\nI'm trapped... somewhere!\nnil\n```", "```java\nuser> (macroexpand '(mistaken-macro))\nI'm trapped... somewhere!\nnil\n```", "```java\n(do\n  (println \"Macro\")\n  (println \"Macro\")\n  (println \"Macro\"))\n```", "```java\nuser> (repeat 3 '(println \"Macro\"))\n((println \"Macro\")\n (println \"Macro\")\n (println \"Macro\"))\n```", "```java\nuser> (cons 'do (repeat 3 '(println \"Macro\")))\n(do\n (println \"Macro\")\n (println \"Macro\")\n (println \"Macro\"))\n```", "```java\nuser> (defmacro multi-minimal [n-times]\n        (cons 'do (repeat n-times '(println \"Macro\"))))\n```", "```java\nuser> (multi-minimal 3)\nMacro\nMacro\nMacro\nnil\n```", "```java\nuser> (macroexpand '(multi-minimal 3))\n(do\n (println \"Macro\")\n (println \"Macro\")\n (println \"Macro\"))\n```", "```java\nuser> (defn multi-min [n-times]\n        (cons 'do (repeat n-times '(println \"Macro\"))))\n#'user/multi-min\nuser> (defmacro multi-minimal-two [n-times]\n        (multi-min n-times))\n#'user/multi-minimal-two\nuser> (multi-minimal-two 3)\nMacro\nMacro\nMacro\nnil\n```", "```java\nuser> (defmacro parameterized-multi-minimal [n-times s]\n        (cons 'do (repeat n-times '(println s))))\n#'user/parameterized-multi-minimal\n```", "```java\nuser> (parameterized-multi-minimal 3 \"My own text.\")\nSyntax error compiling at (Chapter11:localhost:58838(clj)*:49:36).\nUnable to resolve symbol: s in this context\n```", "```java\nuser> (macroexpand '(parameterized-multi-minimal 3 \"My own text.\"))\n(do (println s) (println s) (println s))\n```", "```java\n(let [string-to-print \"My own text.\"]\n  (println string-to-print)\n  (println string-to-print)\n  (println string-to-print))\n```", "```java\n(defmacro parameterized-multi-minimal [n-times s]\n  (concat (list 'let ['string-to-print s])\n          (repeat n-times '(println string-to-print))))\n```", "```java\nuser> (parameterized-multi-minimal 3 \"My own text.\")\nMy own text.\nMy own text.\nMy own text.\nnil\n```", "```java\n(defmacro parameterized-with-syntax [n-times s]\n        '(do ~@(repeat n-times '(println ~s))))\n```", "```java\nuser> (macroexpand '(parameterized-with-syntax 3 \"Syntax quoting!\"))\n(do\n (clojure.core/println \"Syntax quoting!\")\n (clojure.core/println \"Syntax quoting!\")\n (clojure.core/println \"Syntax quoting!\"))\n```", "```java\n(defn validate-params\n  [a b c d]\n  (and\n    (or (> a 5) (> a b))\n    (or (= b a) (> b 5))\n    (or (> a c) (> c 5) (= c b))\n    (or (= a d) (> d 5))))\n```", "```java\n(defn validate-params\n  [a b c d]\n  (and-ors\n    (> a 5) (> a b) |\n    (= b a) (> b 5) |\n    (> a c) (> c 5) (= c b) |\n    (= a d) (> d 5)))\n```", "```java\n    (defmacro and-ors [& or-exps]\n      ;; TODO: write a macro\n      )\n    ```", "```java\n    (defmacro and-ors [& or-exps]\n      (let [groups (remove (partial = '(|)) (partition-by (partial = '|) or-exps))]\n        ;; TODO: do something finally\n        ))\n    ```", "```java\n    user> (partition-by (partial = '|) [1 2 '| 3 4])\n    ((1 2) (|) (3 4))\n\n    ```", "```java\n    (remove #(= '(|) %) (partition-by (partial = '|) or-exps))\n    ```", "```java\n    (defmacro and-ors [& or-exps]\n      (let [groups (remove (partial = '(|)) (partition-by (partial = '|) or-exps))]\n        '(and\n            ;; TODO: the ors\n            )))\n    ```", "```java\n    (defmacro and-ors [& or-exps]\n      (let [groups (remove (partial = '(|)) (partition-by (partial = '|) or-exps))]\n        '(and\n            ~@(map (fn [g] '(or ~@g)) groups))))\n    ```", "```java\n    user> (and-ors (> 5 3) (= 6 6) | (> 6 3) | (= 5 5 5))\n    true\n    ```", "```java\n    user> (and-ors \n            (and-ors (= 3 3) | (= 5 5) (= 6 8))\n              | \n              (> 5 3) (= 6 6) \n              | \n              (> 6 3) \n              | \n              (= 5 5 5))\n    true\n    ```", "```java\n    user> (macroexpand-1 '(and-ors (> 5 3) (= 6 6) | (> 6 3) | (= 5 5 5)))\n    (clojure.core/and\n      (clojure.core/or (> 5 3) (= 6 6))\n      (clojure.core/or (> 6 3))\n      (clojure.core/or (= 5 5 5)))\n    ```", "```java\n[:h1 \"First things first\"]\n```", "```java\n<h1>First things first</h1>\n```", "```java\n(h1 {:class \"intro\"} \"First things first\")\n```", "```java\n(def p (tag-fn \"p\"))\n(def ul (tag-fn \"ul\"))\n(def li (tag-fn \"li\"))\n(def h1 (tag-fn \"h1\"))\n(def h2 (tag-fn \"h2\"))\n(def h3 (tag-fn \"h3\"))\n(def h4 (tag-fn \"h4\"))\n;; etc. etc. etc.\n```", "```java\n(define-html-tags \"p\" \"ul\" \"li\" \"h1\" \"h2\" \"h3\" \"h4\")\n```", "```java\n    (do\n      (def h1 (tag-fn \"h1\"))\n      (def h2 (tag-fn \"h2\"))\n      (def h3 (tag-fn \"h3\"))\n      (def h4 (tag-fn \"h4\")))\n    ```", "```java\n    (defmacro define-html-tags [& tags]\n      '(do\n          ;; TODO: macro code\n          ))\n    ```", "```java\n    (defmacro define-html-tags [& tags]\n      '(do\n          ~@(map (fn [tagname]\n                  '(def ~(symbol tagname) (tag-fn ~tagname)))\n                tags)))\n    ```", "```java\n    (define-html-tags \"h1\" \"h2\" \"h3\" \"h4\" \"h5\" \"p\" \"div\" \"span\")\n    ```", "```java\n    packt-clj.htmlgen> (div\n                          (h1 \"First things first\")\n                          (p {:class \"intro\"} \"What's the best way to get started?\"))\n    \"<div><h1>First things first</h1><p class=\\\"intro\\\">What's the best way to get started?</p></div>\"\n    ```", "```java\n(defmacro define-html-tags-from-list [tags]\n  '(do\n     ~@(map (fn [tagname]\n              '(def ~(symbol tagname) (tag-fn ~tagname)))\n            tags)))\n```", "```java\npackt-clj.htmlgen> (apply define-html-tags [\"br\" \"p\" \"a\"])\nSyntax error compiling at (Exercise01:localhost:52997(clj)*:116:24).\nCan't take value of a macro: #'packt-clojure.htmlgen/define-html-tags\n```", "```java\n(ul (map li [\"item 1\" \"item2\"]))\n```", "```java\n(ul->li [\"item 1\" \"item 2\"])\n```", "```java\n    (defn subtag-fn [tagname subtag]\n      (fn [content]\n        (str\n          (->opening-tag tagname nil)\n          (apply str (map subtag content))\n          (->end-tag tagname))))\n    ```", "```java\n    packt-clj.htmlgen> ((subtag-fn \"ul\" li) [\"Item 1\" \"Item 2\"])\n    \"<ul><li>Item 1</li><li>Item 2</li></ul>\"\n    ```", "```java\n    (defn subtag-fn [tagname subtag]\n      (fn subtag-function-builder\n        ([content]\n         (subtag-function-builder nil content))\n        ([attrs content]\n           (str\n             (->opening-tag tagname attrs)\n             (apply str (map subtag content))\n             (->end-tag tagname)))))\n    ```", "```java\n    packt-clj.htmlgen> ((subtag-fn \"ul\" li) {:class \"my-class\"} [\"Item 1\" \"Item 2\"])\n    \"<ul class=\\\"my-class\\\"><li>Item 1</li><li>Item 2</li></ul>\"\n    ```", "```java\n    packt-clj.htmlgen> ((subtag-fn \"ul\" li) [\"Item 1\" \"Item 2\"])\n    \"<ul><li>Item 1</li><li>Item 2</li></ul>\"\n    ```", "```java\n    (define-html-list-tags [\"ul\" \"li\"] [\"ol\" \"li\"])\n    (defmacro define-html-list-tags [& tags-with-subtags]\n      '(do\n         ~@(map (fn [[tagname subtag]]\n                  '(do\n                     (def ~(symbol tagname) (tag-fn ~tagname))\n                     (def ~(symbol (str tagname \"->\" subtag)) (subtag-fn ~tagname ~(symbol subtag)))))\n                tags-with-subtags)))\n    ```", "```java\n    (def ~(symbol tagname) (tag-fn ~tagname))\n    ```", "```java\n    (def ~(symbol (str tagname \"->\" subtag)) (subtag-fn ~tagname ~(symbol subtag)))\n    ```", "```java\n    packt-clj.htmlgen> (macroexpand '(define-html-list-tags [\"ul\" \"li\"] [\"ol\" \"li\"]))\n    (do\n     (do\n      (def ul (packt-clj.htmlgen/tag-fn \"ul\"))\n      (def ul->li (packt-clj.htmlgen/subtag-fn \"ul\" li)))\n     (do\n      (def ol (packt-clj.htmlgen/tag-fn \"ol\"))\n      (def ol->li (packt-clj.htmlgen/subtag-fn \"ol\" li))))\n    ```", "```java\n    packt-clj.htmlgen> (define-html-list-tags [\"ul\" \"li\"] [\"ol\" \"li\"])\n    #'packt-clj.htmlgen/ol->li\n    packt-clj.htmlgen> (ol->li [\"Item 1\" \"Item 2\"])\n    \"<ol><li>Item 1</li><li>Item 2</li></ol>\"\n    packt-clj.htmlgen> (ol->li {:class \"my-class\"} [\"Item 1\" \"Item 2\"])\n    \"<ol class=\\\"my-class\\\"><li>Item 1</li><li>Item 2</li></ol>\"\n    ```", "```java\n(defmacro define-html-list-tags-with-mapcat [& tags-with-subtags]\n  '(do\n     ~@(mapcat (fn [[tagname subtag]]\n                 ['(def ~(symbol tagname) (tag-fn ~tagname))\n                  '(def ~(symbol (str tagname \"->\" subtag)) (subtag-fn ~tagname ~(symbol subtag)))])\n            tags-with-subtags)))\n```", "```java\npackt-clj.htmlgen> (macroexpand '(define-html-list-tags-with-mapcat [\"ul\" \"li\"] [\"ol\" \"li\"]))\n(do\n (def ul (packt-clj.htmlgen/tag-fn \"ul\"))\n (def ul->li (packt-clj.htmlgen/subtag-fn \"ul\" li))\n (def ol (packt-clj.htmlgen/tag-fn \"ol\"))\n (def ol->li (packt-clj.htmlgen/subtag-fn \"ol\" li)))\n```", "```java\n(ns minmacros.core\n  (:require-macros [minmacros.macros :as mm]))\n(println \"Hello from clojurescript\")\n(mm/minimal-macro)\n```", "```java\n(ns minmacros.core\n  (:require-macros [minmacros.macros :as mm])\n  (:require [minmacros.macros :as mm]))\n```", "```java\n$ clj --main cljs.main --compile minmacros.core --repl\n```", "```java\n$ java -cp \"cljs.jar;src\" cljs.main --compile minmacros.core --repl\n```", "```java\n(defmacro js-macro [symbol-name]\n  '(def ~(symbol symbol-name)\n     ~(if (.includes symbol-name \"b\")\n       \"Hello\"\n       \"Goodbye\")))\n```", "```java\ncljs.user=> (minmacros.macros/js-macro \"hello\")\nUnexpected error (IllegalArgumentException) macroexpanding minmacros.macros/js-macro at (<cljs repl>:1:1).\nNo matching method includes found taking 1 args for class java.lang.String\n```", "```java\n(defmacro runtime-includes [function-name character]\n  '(defn ~(symbol function-name) []\n     (if (.includes \"Clojurescript macros\" ~character)\n       \"Found it!\"\n       \"Not here...\")))\n```", "```java\ncljs.user=> (load-file \"minmacros/core.cljs\")\nnil\ncljs.user=> Hello from clojurescript\nI'm trapped inside a Clojurescript macro!\ncljs.user=> (minmacros.macros/runtime-includes \"hello\" \"m\")\n#'cljs.user/hello\ncljs.user=> (hello)\n\"Found it!\"\ncljs.user=> \n```", "```java\nuser> (defmacro parameterized-multi-minimal [n-times s]\n        (cons 'do (repeat n-times '(println s))))\n#'user/parameterized-multi-minimal\n```", "```java\nuser> (parameterized-multi-minimal 5 \"error?\")\nSyntax error compiling at (Exercise01:localhost:52997(clj)*:121:36).\nUnable to resolve symbol: s in this context\n```", "```java\nuser> (let [s \"Wrong\"]\n        (parameterized-multi-minimal 2 \"Right\"))\nWrong\nWrong\nnil\n```", "```java\nuser> '(my-symbol 5)\n(user/my-symbol 5)\n```", "```java\n(defmacro let-number [[binding n] body]\n  '(let [~(symbol (str binding \"-as-string\"))  (str ~n)\n         ~(symbol (str binding \"-as-int\")) (int ~n)\n         ~(symbol (str binding \"-as-double\")) (double ~n)]\n     ~body))\n```", "```java\nuser> (let-number [my-int 5]\n        (type my-int-as-string))\njava.lang.String\n```", "```java\nuser> (let [my-int-as-int 1000]\n        (let-number [my-int (/ my-int-as-int 2)]\n        (str \"The result is: \" my-int-as-double)))\n\"The result is: 250.0\"\n```", "```java\nuser> (macroexpand-1 '(let-number [my-int (/ my-int-as-int 2)]\n                      (str \"The result is: \" my-int-as-double)))\n(clojure.core/let\n [my-int-as-string\n  (clojure.core/str (/ my-int-as-int 2))\n  my-int-as-int\n  (clojure.core/int (/ my-int-as-int 2))\n  my-int-as-double\n  (clojure.core/double (/ my-int-as-int 2))]\n (str \"The result is: \" my-int-as-double))\n```", "```java\n(defmacro let-number [[binding n] body]\n  '(let [result# ~n\n         ~(symbol (str binding \"-as-string\"))  (str result#)\n         ~(symbol (str binding \"-as-int\")) (int result#)\n         ~(symbol (str binding \"-as-double\")) (double result#)]\n     ~body))\n```", "```java\nuser> (let [my-int-as-int 1000.0]\n        (let-number [my-int (/ my-int-as-int 2)]\n          (str \"The result is: \" my-int-as-double)))\n\"The result is: 500.0\"\n```", "```java\nuser> '(result#)\n(result__15099__auto__)\nuser> '(result#)\n(result__15103__auto__)\n```", "```java\nuser> '(= result# result#)\n(clojure.core/= result__15111__auto__ result__15111__auto__)\n```", "```java\nuser> (defmacro bad-let-number [[binding n] body]\n        '(let [~'result ~n\n               ~(symbol (str binding \"-as-string\"))  (str ~'result)\n               ~(symbol (str binding \"-as-int\")) (int ~'result)\n               ~(symbol (str binding \"-as-double\")) (double ~'result)]\n           ~body))\n```", "```java\n(let [result 42]\n  (bad-let-number [my-int 1000]\n    (= result 1000)))  ;; Would return \"true\"\n```", "```java\n    (defmacro defmonitored\n      [fn-name tx-fn args & body-elements]\n      ;; TODO: everything\n      )\n    ```", "```java\n    (defmonitored my-func send-to-framework\n                  [an-arg another-arg client-id]...)\n    ```", "```java\n    (my-func an-arg another-arg 42)\n    ```", "```java\n    (defmacro defmonitored\n      [fn-name tx-fn & args-and-body]\n      (let [\n            ;; TODO: compile time let bindings\n            ]\n        '(defn ~fn-name ~[]\n           ;; TODO: the defn template\n           )))\n    ```", "```java\n    user> (defmonitored my-func identity [])\n    #'user/my-func\n    user> (my-func)\n    nil\n    ```", "```java\n    (defn a-func [arg1 arg2]\n      (+ arg1 arg2))\n    ```", "```java\n    (defn b-func \n      ([arg1] arg1)\n      ([arg1 arg2]\n       (+ arg1 arg2))\n      ([arg1 arg2 arg3]\n        (* (+ arg1 arg2) arg3)))\n    ```", "```java\n    (defn a-func\n      ([arg] (println arg)))\n    ```", "```java\n    (defmacro defmonitored\n      [fn-name tx-fn & args-and-body]\n      (let [pre-arg-list (take-while (complement sequential?) args-and-body)\n            fn-content (drop-while (complement sequential?) args-and-body)\n            fn-bodies (if (vector? (first fn-content))\n                        '(~fn-content)\n                        fn-content)]\n        '(defn ~fn-name ~@pre-arg-list\n           ;; TODO: more magic\n           ~@fn-bodies)))\n    ```", "```java\n    (defn wrap-fn-body [fn-name tx-fn b]\n      (let [arg-list (first b)\n            client-id-arg (first (filter #(= 'client-id %) arg-list))\n            fn-body (rest b)]\n        ;; TODO: the body\n        ))\n    ```", "```java\n    (defn wrap-fn-body [fn-name tx-fn b]\n      (let [arg-list (first b)\n            client-id-arg (first (filter #(= 'client-id %) arg-list))\n            fn-body (rest b)]\n           (when-not (first (filter #(= % 'client-id) arg-list))\n          (throw (ex-info \"Missing client-id argument\" {})))\n        ;; TODO: the body\n        ))\n    ```", "```java\n    '(~arg-list\n      (let [start-time# (System/nanoTime)]\n        (try\n          (let [result# (do  ~@fn-body)]\n            (~tx-fn {:name ~(name fn-name)\n                     :client-id ~'client-id\n                     :status :complete\n                     :start-time start-time#\n                     :end-time (System/nanoTime)})\n            result#)\n          (catch Exception e#\n            (~tx-fn {:name ~(name fn-name)\n                     :client-id ~'client-id\n                     :status :error\n                     :start-time start-time#\n                     :end-time (System/nanoTime)})\n            (throw e#)))))\n    ```", "```java\n    (defn wrap-fn-body [fn-name tx-fn b]\n      (let [arg-list (first b)\n            fn-body (rest b)]\n        (when-not (first (filter #(= % 'client-id) arg-list))\n          (throw (ex-info \"Missing client-id argument\" {})))\n        '(~arg-list\n          (let [start-time# (System/nanoTime)]\n            (try\n              (let [result# (do  ~@fn-body)]\n                (~tx-fn {:name ~(name fn-name)\n                        :client-id ~'client-id\n                         :status :complete\n                         :start-time start-time#\n                        :end-time (System/nanoTime)})\n                result#)\n              (catch Exception e#\n                (~tx-fn {:name ~(name fn-name)\n                         :client-id ~'client-id\n                         :status :error\n                         :start-time start-time#\n                         :end-time (System/nanoTime)})\n                (throw e#)))))))\n    ```", "```java\n    (defmacro defmonitored\n      [fn-name tx-fn & args-and-body]\n      (let [pre-arg-list (take-while (complement sequential?) args-and-body)\n            fn-content (drop-while (complement sequential?) args-and-body)\n            fn-bodies (if (vector? (first fn-content))\n                        '(~fn-content)\n                        fn-content)]\n        '(defn ~fn-name ~@pre-arg-list\n           ~@(map (partial wrap-fn-body fn-name tx-fn) fn-bodies))))\n    ```", "```java\n    user> (defmonitored my-func println [client-id m]  (assoc m :client client-id))\n    #'user/my-func\n    ```", "```java\n    user> (my-func 32 {:data 123})\n    {:client-id 32, :name my-func, :start-time 770791427794572, :end-time 770791428448202, :status :complete}\n    {:data 123, :client 32}\n    ```", "```java\n    user> (defmonitored exception-func println [client-id] (throw (ex-info \"Boom!\" {})))\n    ```", "```java\nuser> (defmonitored no-client-func println [no-client-id] (+ 1 1))\n```", "```java\nuser> (macroexpand '(def my-number# 5))\n(def my-number# 5)\n```", "```java\nuser> (macroexpand '(def 'my-number# 5))\n(def 'my-number__14717__auto__ 5)\n```", "```java\n(defmacro fn-context [v & symbol-fn-pairs]\n  '(let [v# ~v]\n     ~@(map (fn [[sym f]]\n              '(defn ~sym [x#]\n                 (f v# x#))) (partition 2 symbol-fn-pairs))))\n```", "```java\n(let [common-value 5]\n  (defn adder [n] (+ common-value 5))\n  (defn subtractor [n] (- common-value 5))\n  (defn multiplier [n] (* common-value 5)))\n```", "```java\n(fn-context 5 adder + subtractor - multiplier *)\n```", "```java\nuser> (fn-context 5 adder + subtractor - multiplier *)\nSyntax error compiling at (Activity:localhost:52217(clj)*:246:15).\nUnable to resolve symbol: v__14896__auto__ in this context\n```", "```java\nuser> (macroexpand-1 '(fn-context 5 adder + subtractor - multiplier *))\n(clojure.core/let\n [v__14897__auto__ 5]\n (clojure.core/defn\n  adder\n  [x__14895__auto__]\n  (+ v__14896__auto__ x__14895__auto__))\n (clojure.core/defn\n  subtractor\n  [x__14895__auto__]\n  (- v__14896__auto__ x__14895__auto__))\n (clojure.core/defn\n  multiplier\n  [x__14895__auto__]\n  (* v__14896__auto__ x__14895__auto__)))\n```", "```java\n(defmacro fn-context [v & symbol-fn-pairs]\n  (let [common-val-gensym (gensym \"common-val-\")]\n    '(let [~common-val-gensym ~v]\n       ~@(map (fn [[sym f]]\n                '(defn ~sym [x#]\n                   (~f ~common-val-gensym x#))) (partition 2 symbol-fn-pairs)))))\n```", "```java\nuser> (fn-context 5 adder + subtractor - multiplier *)\n#'user/multiplier\nuser> (adder 5)\n10\nuser> (subtractor 12)\n-7\nuser> (multiplier 10)\n50\n```", "```java\nuser> (let [x 100]\n        (def adder (partial + x))\n        (def subtractor (partial - x))\n        (def multiplier (partial * x)))\n#'user/multiplier\nuser> (adder 5)\n105\n```", "```java\n(defn blowouts [csv threshold]\n  (with-tennis-csv csv\n    {:winner_games_won sc/->int :loser_games_won sc/->int}\n    [:winner_name :loser_name :games_diff]\n    (map #(assoc % :games_diff (- (:winner_games_won %) (:loser_games_won %))))\n    (filter #(> (:games_diff %) threshold))))\n```"]