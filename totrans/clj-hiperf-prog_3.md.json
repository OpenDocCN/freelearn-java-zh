["```java\n(ns foo.core)\n\n(defn mul [x y]\n  (* x y))\n```", "```java\ntarget/classes/\n`-- foo\n    |-- core$fn__18.class\n    |-- core__init.class\n    |-- core$loading__4910__auto__.class\n    `-- core$mul.class\n```", "```java\npackage foo;\n\nimport clojure.lang.AFunction;\nimport clojure.lang.Numbers;\nimport clojure.lang.RT;\nimport clojure.lang.Var;\n\npublic final class core$mul extends AFunction\n{\n  public static final Var const__0 = (Var)RT.var(\"clojure.core\", \"*\");\n\n  public Object invoke(Object x, Object y) { x = null; y = null; return Numbers.multiply(x, y);\n  }\n}\n```", "```java\nuser=> (binding [*compiler-options* {:disable-locals-clearing true}] (compile 'foo.core))\nfoo.core\n```", "```java\n(set! *unchecked-math* true)\n```", "```java\nuser=> (set! *warn-on-reflection* true)\ntrue\nuser=> (def s \"Hello, there\")\n#'user/s\nuser=> (.length s)\nReflection warning, NO_SOURCE_PATH:1 - reference to field length can't be resolved.\n12\nuser=> (defn str-len [^String s] (.length s))\n#'user/str-len\nuser=> (str-len s)\n12\nuser=> (.length ^String s)  ; type hint when passing argument\n12\nuser=> (def ^String t \"Hello, there\")  ; type hint at var level\n#'user/t\nuser=> (.length t)  ; no more reflection warning\n12\nuser=> (time (dotimes [_ 1000000] (.length s)))\nReflection warning, /private/var/folders/cv/myzdv_vd675g4l7y92jx9bm5lflvxq/T/form-init6904047906685577265.clj:1:28 - reference to field length can't be resolved.\n\"Elapsed time: 2409.155848 msecs\"\nnil\nuser=> (time (dotimes [_ 1000000] (.length t)))\n\"Elapsed time: 12.991328 msecs\"\nnil\n```", "```java\n:profiles {:dev {:global-vars {*warn-on-reflection* true}}}\n```", "```java\n(def a (int-array [10 20 30 40 50 60]))\n;; amap example\n(seq\n (amap ^ints a idx ret\n    (do (println idx (seq ret))\n      (inc (aget ^ints a idx)))))\n;; areduce example\n(areduce ^ints a idx ret 0\n  (do (println idx ret)\n    (+ ret idx)))\n```", "```java\n(def ^ints a (int-array [10 20 30 40 50 60]))  ; wrong, will complain later\n(def ^\"[I\" a (int-array [10 20 30 40 50 60]))  ; correct\n(def ^{:tag 'ints} a (int-array [10 20 30 40 50 60])) ; correct\n```", "```java\n(defn do-something\n  [^long a ^long b ^long c ^long d]\n  ..)\n```", "```java\n(defmacro str-len\n  [s]\n  `(.length ~(with-meta s {:tag String})))\n;; below is another way to write the same macro\n(defmacro str-len\n  [s]\n  `(.length ~(vary-meta s assoc :tag `String)))\n```", "```java\n(defmacro str-len\n  [s]\n  `(let [^String s# ~s] (.length s#)))\n```", "```java\n(defn foo [] \"Hello\")\n(defn foo ^String [] \"Hello\")\n(defn foo (^String [] \"Hello\") (^String [x] (str \"Hello, \" x)))\n```", "```java\n(require '[stringer.core :as s])\nuser=> (time (dotimes [_ 10000000] (str \"foo\" :bar 707 nil 'baz)))\n\"Elapsed time: 2044.284333 msecs\"\nnil\nuser=> (time (dotimes [_ 10000000] (s/strcat \"foo\" :bar 707 nil 'baz)))\n\"Elapsed time: 555.843271 msecs\"\nnil\n```", "```java\n(deftype Counter [^:volatile-mutable ^long now]\n  ..)\n```", "```java\n(definterface Foo\n  (^long doSomething [^long a ^double b]))\n```", "```java\n(proxy [Object][]\n  (equals [other]\n    (let [^Object this this]\n      (proxy-super equals other))))\n```", "```java\n:dependencies [;; other dependencies\n               [prismatic/hiphip \"0.2.0\"]]\n```", "```java\n(require '[hiphip.double :as hd])\n\n(def xs (double-array [12.3 23.4 34.5 45.6 56.7 67.8]))\n\n(let [s (hd/asum xs)] (hd/amap [x xs] (/ x s)))\n```", "```java\n:dependencies [;; other dependencies\n               [primitive-math \"0.1.4\"]]\n```", "```java\n;; must enable reflection warnings for extra warnings from primitive-math\n(set! *warn-on-reflection* true)\n(require '[primitive-math :as pm])\n(defn mul [x y] (pm/* x y))  ; primitive-math produces reflection warning\n(mul 10.3 2)                        ; throws exception\n(defn mul [^long x ^long y] (pm/* x y))  ; no warning after type hinting\n(mul 10.3 2)  ; returns 20\n```", "```java\n(set! *unchecked-math* :warn-on-boxed)\n\n(defn sum-till [n] (/ (* n (inc n)) 2))  ; causes warning\nBoxed math warning, /private/var/folders/cv/myzdv_vd675g4l7y92jx9bm5lflvxq/T/form-init3701519533014890866.clj:1:28 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_inc(java.lang.Object).\nBoxed math warning, /private/var/folders/cv/myzdv_vd675g4l7y92jx9bm5lflvxq/T/form-init3701519533014890866.clj:1:23 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_multiply(java.lang.Object,java.lang.Object).\nBoxed math warning, /private/var/folders/cv/myzdv_vd675g4l7y92jx9bm5lflvxq/T/form-init3701519533014890866.clj:1:20 - call: public static java.lang.Number clojure.lang.Numbers.divide(java.lang.Object,long).\n\n;; now we define again with type hint\n(defn sum-till [^long n] (/ (* n (inc n)) 2))\n```", "```java\n:global-vars {*unchecked-math* :warn-on-boxed}\n```", "```java\n:dependencies [;;other dependencies\n               [proteus \"0.1.4\"]]\n```", "```java\n(require '[proteus :as p])\n(p/let-mutable [a 10]\n  (println a)\n  (set! a 20)\n  (println a))\n;; Output below:\n;; 10\n;; 20\n```", "```java\n(p/let-mutable [a 10 add2! (fn [x] (set! x (+ 2 x)))]\n  (add2! a)\n  (println a))\n```"]