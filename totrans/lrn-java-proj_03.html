<html><head></head><body>
		<div id="_idContainer037">
			<h1 id="_idParaDest-67" class="chapter-number"><span class="superscript"><a id="_idTextAnchor067"/></span>3</h1>
			<h1 id="_idParaDest-68"><a id="_idTextAnchor068"/>Operators and Casting</h1>
			<p>In <a href="B19793_02.xhtml#_idTextAnchor051"><span class="No-Break"><em class="italic">Chapter 2</em></span></a>, we learned that variables are simply named pigeonholes and contain values. These values vary and Java provides eight primitive data types accordingly. These primitive types cater for whole numbers (<strong class="source-inline">byte</strong>, <strong class="source-inline">char</strong>, <strong class="source-inline">short</strong>, <strong class="source-inline">int</strong>, and <strong class="source-inline">long</strong>), decimal numbers (<strong class="source-inline">float</strong> and <strong class="source-inline">double</strong>), and the literals true and <span class="No-Break">false (</span><span class="No-Break"><strong class="source-inline">boolean</strong></span><span class="No-Break">).</span></p>
			<p>We also learned how to declare a variable. As Java is a strongly typed language, this means you must give every variable a data type immediately upon declaration. This is where primitive data types are <span class="No-Break">very useful.</span></p>
			<p>Now that we know how to declare variables, let’s do something interesting with them. By the end of this chapter, you will be able to combine variables using Java’s various operators. In addition, you will understand Java casting, including what it is, and when and why <span class="No-Break">it occurs.</span></p>
			<p>In this chapter, we are going to cover the following <span class="No-Break">main topics:</span></p>
			<ul>
				<li>Learning how Java’s <span class="No-Break">operators cooperate</span></li>
				<li>Understanding <span class="No-Break">Java’s operators</span></li>
				<li>Explaining <span class="No-Break">Java casting</span></li>
			</ul>
			<h1 id="_idParaDest-69"><a id="_idTextAnchor069"/>Technical requirements</h1>
			<p>The code for this chapter can be found on GitHub <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Learn-Java-with-Projects/tree/main/ch3"><span class="No-Break">https://github.com/PacktPublishing/Learn-Java-with-Projects/tree/main/ch3</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-70"><a id="_idTextAnchor070"/>Learning how Java’s operators cooperate</h1>
			<p>Java provides<a id="_idIndexMarker153"/> numerous operators for us to work with. By way of definition, if we have an expression <strong class="source-inline">3 + 4</strong>, the <strong class="source-inline">+</strong> is the <em class="italic">operator</em>, whereas <strong class="source-inline">3</strong> and <strong class="source-inline">4</strong> are <a id="_idIndexMarker154"/>the <em class="italic">operands</em>. Since <strong class="source-inline">+</strong> has <em class="italic">two</em> operands, it is known<a id="_idIndexMarker155"/> as a <span class="No-Break"><em class="italic">binary</em></span><span class="No-Break"> operator.</span></p>
			<p>Before we discuss the operators<a id="_idIndexMarker156"/> themselves, we must first discuss two important features <a id="_idIndexMarker157"/>relating to Java operators, namely <strong class="bold">order of precedence</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="bold">associativity</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-71"><a id="_idTextAnchor071"/>Order of precedence</h2>
			<p>Order of precedence specifies how operands are grouped with operators. This becomes<a id="_idIndexMarker158"/> important when you have shared operands in a complex expression. In the following code segment, we have an expression of <strong class="source-inline">2 + 3 * 4</strong>, where <strong class="source-inline">*</strong> represents multiplication and <strong class="source-inline">+</strong> <span class="No-Break">represents addition:</span></p>
			<pre class="source-code">
int a = 2 + 3 * 4;System.out.println(a);</pre>
			<p>In the preceding code, <strong class="source-inline">3</strong> is shared by both <strong class="source-inline">2</strong> and <strong class="source-inline">4</strong>. So, the question arises, do we group <strong class="source-inline">3</strong> with <strong class="source-inline">2</strong>, where the expression is <strong class="source-inline">(2 + 3) * 4</strong>, giving us <strong class="source-inline">20</strong>; or do we group <strong class="source-inline">3</strong> with <strong class="source-inline">4</strong>, where the expression is <strong class="source-inline">2 + (3 * 4)</strong>, giving us <strong class="source-inline">14</strong>? This is where the order of precedence applies. As <strong class="source-inline">*</strong> has higher precedence than <strong class="source-inline">+</strong>, <strong class="source-inline">3</strong> is grouped with <strong class="source-inline">4</strong> and therefore the expression evaluates to <strong class="source-inline">2 + (3 * 4)</strong>. Note that the evaluation order is still left to right; it is just that <strong class="source-inline">3</strong> is grouped with <strong class="source-inline">4</strong> rather than <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">2</strong></span><span class="No-Break">.</span></p>
			<p class="callout-heading">Parentheses in an expression</p>
			<p class="callout">Note that parentheses<a id="_idIndexMarker159"/> can change the default order of operator precedence. As we have seen, the default order of precedence, where <strong class="source-inline">*</strong> has higher precedence than <strong class="source-inline">+</strong>, means that <strong class="source-inline">2 + 3 * 4</strong> is <strong class="source-inline">14</strong>. This is the same as <strong class="source-inline">2 + (3 * </strong><span class="No-Break"><strong class="source-inline">4)</strong></span><span class="No-Break">.</span></p>
			<p class="callout">However, <strong class="source-inline">(2 + 3) * 4</strong> is <strong class="source-inline">20</strong>. In this case, the parentheses grouped <strong class="source-inline">3</strong> with <strong class="source-inline">2</strong>, so the expression evaluated to <strong class="source-inline">5 * 4 = </strong><span class="No-Break"><strong class="source-inline">20</strong></span><span class="No-Break">.</span></p>
			<p>This begs the question, what if you are evaluating an expression that contains operators at the same level of precedence? This is where <span class="No-Break">associativity</span><span class="No-Break"><a id="_idIndexMarker160"/></span><span class="No-Break"> applies.</span></p>
			<h2 id="_idParaDest-72"><a id="_idTextAnchor072"/>Associativity</h2>
			<p>When an expression has two operators with the same level of precedence, operator<a id="_idIndexMarker161"/> associativity determines the groupings of operators and operands. For example, in the following code segment, we are evaluating a simple expression involving two divisions (which have the same level <span class="No-Break">of precedence):</span></p>
			<pre class="source-code">
int x =  72 / 6 / 3;</pre>			<p>As division associates left to right, <strong class="source-inline">6</strong> will be grouped with <strong class="source-inline">72</strong> and not <strong class="source-inline">3</strong>. Thus, the expression is the same as <strong class="source-inline">(72 / 6) / 3</strong>, which evaluates to <strong class="source-inline">12 / 3 = 4</strong>. Parentheses can also be used to change the default associativity order. Take, for example, the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
int x =  72 / (6 / 3);</pre>			<p>In this case, <strong class="source-inline">6</strong> is now grouped with <strong class="source-inline">3</strong> and the expression evaluates to <strong class="source-inline">72 / 2 = </strong><span class="No-Break"><strong class="source-inline">36</strong></span><span class="No-Break">.</span></p>
			<p><em class="italic">Table 3.1</em> outlines the order of precedence and <span class="No-Break">associativity rules:</span></p>
			<div>
				<div id="_idContainer026" class="IMG---Figure">
					<img src="image/B19793_03_Table_01.jpg" alt="Table 3.1 – Order of precedence and associativity rules"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 3.1 – Order of precedence and associativity rules</p>
			<p>Note that <em class="italic">Table 3.1</em> is simplified in that it refers to the operators that are commonly used. For example, the unsigned right shift operator, <strong class="source-inline">&gt;&gt;&gt;</strong>, is omitted as it is rarely used. Also, note that the <strong class="source-inline">instanceof</strong> operator will be discussed in <a href="B19793_08.xhtml#_idTextAnchor168"><span class="No-Break"><em class="italic">Chapter 8</em></span></a><span class="No-Break">.</span></p>
			<p>It is interesting to note that the assignment operator, namely <strong class="source-inline">=</strong>, is at the bottom of the precedence table. This means that regardless of the expression on the right-hand side of the assignment, the assignment will always be done last. This makes sense. Also, while most of the operators associate left to right, the assignment associates right to left. This is demonstrated in the following <span class="No-Break">code segment:</span></p>
			<pre class="source-code">
boolean b1 = false;boolean b2;
boolean b3;
b3 = b2 = b1;
System.out.println(b1);
System.out.println(b2);
System.out.println(b3);</pre>
			<p>The preceding code segment outputs <strong class="source-inline">false</strong> three times. The crucial line is <strong class="source-inline">b3 = b2 = b1;</strong>. Since the assignment associates right to left, the value in <strong class="source-inline">b1</strong>, which is <strong class="source-inline">false</strong>, is assigned<a id="_idIndexMarker162"/> to <strong class="source-inline">b2</strong>; then, the value in <strong class="source-inline">b2</strong>, which is now <strong class="source-inline">false</strong>, is assigned <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">b3</strong></span><span class="No-Break">.</span></p>
			<p>Now that we understand these properties, let’s examine the <span class="No-Break">operators themselves.</span></p>
			<h1 id="_idParaDest-73"><a id="_idTextAnchor073"/>Understanding Java’s operators</h1>
			<p>Operators can be grouped into the <span class="No-Break">following categories:</span></p>
			<ul>
				<li><span class="No-Break">Unary operators</span></li>
				<li><span class="No-Break">Arithmetic operators</span></li>
				<li><span class="No-Break">Relational operators</span></li>
				<li><span class="No-Break">Logical operators</span></li>
				<li><span class="No-Break">Ternary operator</span></li>
				<li>Compound <span class="No-Break">assignment operators</span></li>
			</ul>
			<p>We will now discuss each category <span class="No-Break">in turn.</span></p>
			<h2 id="_idParaDest-74"><a id="_idTextAnchor074"/>Unary operators</h2>
			<p>Unary operators<a id="_idIndexMarker163"/> have only one<a id="_idIndexMarker164"/> operand, hence the term <em class="italic">unary</em>. Let’s <span class="No-Break">examine them.</span></p>
			<h3>Prefix and postfix unary operators</h3>
			<p><strong class="source-inline">++</strong> and <strong class="source-inline">--</strong> denote these operators<a id="_idIndexMarker165"/> and they<a id="_idIndexMarker166"/> increment and decrement by 1, respectively. If the operator<a id="_idIndexMarker167"/> appears before the variable, it is known as <em class="italic">prefix</em>, while if the operator <a id="_idIndexMarker168"/>appears after the variable, it is called <em class="italic">postfix</em>. For example, <em class="italic">++x</em> is prefix increment, whereas <em class="italic">y--</em> is <span class="No-Break">postfix decrement.</span></p>
			<p>Depending on whether <strong class="source-inline">++</strong> or <strong class="source-inline">--</strong> appears before or after the variable can, in some situations, affect the overall expression. This is best explained with a code sample, as shown in <span class="No-Break"><em class="italic">Figure 3</em></span><span class="No-Break"><em class="italic">.1</em></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer027" class="IMG---Figure">
					<img src="image/B19793_03_1.jpg" alt="Figure 3.1 – Prefix and postfix increment and decrement operators"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.1 – Prefix and postfix increment and decrement operators</p>
			<p>In <span class="No-Break"><em class="italic">Figure 3</em></span><em class="italic">.1</em>, on line 25, we can see that <strong class="source-inline">x</strong> is initialized to <strong class="source-inline">3</strong>. On line 26, <strong class="source-inline">x</strong> is incremented by 1 to <strong class="source-inline">4</strong>. Line 26 is a simple statement and because of that, whether it is prefix or postfix notation does not matter. Line 27 outputs the value of <strong class="source-inline">x</strong> to show that it is <strong class="source-inline">4</strong> at <span class="No-Break">this point.</span></p>
			<p>Line 28 is where things get interesting. The postfix notation on line 28 has a real effect on the screen output. As it is the postfix notation in the <strong class="source-inline">System.out.println</strong> command, the current value of <strong class="source-inline">x</strong> is output, and <em class="italic">afterwards</em>, <strong class="source-inline">x</strong> is incremented by 1. So, the output to the screen is <strong class="source-inline">4</strong>, and afterwards, <strong class="source-inline">x</strong> is incremented to <strong class="source-inline">5</strong>. Line 29 demonstrates that <strong class="source-inline">x</strong> <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">5</strong></span><span class="No-Break">.</span></p>
			<p>On line 31, <strong class="source-inline">y</strong> is<a id="_idIndexMarker169"/> initialized to <strong class="source-inline">4</strong>. On line 32, <strong class="source-inline">y</strong> is decremented by 1 to <strong class="source-inline">3</strong>. Again, as <a id="_idIndexMarker170"/>line 32 is a simple statement, prefix or postfix notation makes no difference. Line 33 outputs the value of <strong class="source-inline">y</strong> to show that it is <strong class="source-inline">3</strong> at <span class="No-Break">this point.</span></p>
			<p>The prefix notation on line 34<a id="_idIndexMarker171"/> has no real effect on the screen output. As it is the prefix notation in the <strong class="source-inline">System.out.println</strong> command, the current value of <strong class="source-inline">y</strong> is decremented <strong class="bold">before</strong> being output. Thus, the<a id="_idIndexMarker172"/> value of <strong class="source-inline">y</strong> and the output to the screen<a id="_idIndexMarker173"/> match (both are <strong class="source-inline">2</strong>). Lastly, line 35 demonstrates that the current value of <strong class="source-inline">y</strong> <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">2</strong></span><span class="No-Break">.</span></p>
			<h3>Unary plus/minus operators</h3>
			<p>Now that we have discussed<a id="_idIndexMarker174"/> the prefix and postfix operators, let’s discuss other unary operators. The code in <span class="No-Break"><em class="italic">Figure 3</em></span><em class="italic">.2</em> <span class="No-Break">will help:</span></p>
			<div>
				<div id="_idContainer028" class="IMG---Figure">
					<img src="image/B19793_03_2.jpg" alt="Figure 3.2 – Other unary operators"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.2 – Other unary operators</p>
			<p>In <span class="No-Break"><em class="italic">Figure 3</em></span><em class="italic">.2</em>, line 37 uses the unary plus sign, <strong class="source-inline">+</strong>, to initialize <strong class="source-inline">x</strong> to <strong class="source-inline">6</strong>. Here, <strong class="source-inline">+</strong> is the default as numbers without a sign are assumed to be positive numbers. Line 38 uses the unary minus sign, <strong class="source-inline">-</strong>, to initialize <strong class="source-inline">y</strong> to be the<a id="_idIndexMarker175"/> negative of <strong class="source-inline">x</strong>. Lines 39 and 40 demonstrate that <strong class="source-inline">x</strong> and <strong class="source-inline">y</strong> are <strong class="source-inline">6</strong> and <strong class="source-inline">-</strong><span class="No-Break"><strong class="source-inline">6</strong></span><span class="No-Break">, respectively.</span></p>
			<h3>Cast operator</h3>
			<p>In <span class="No-Break"><em class="italic">Figure 3</em></span><em class="italic">.2</em>, line 42 uses the<a id="_idIndexMarker176"/> cast operator. We will discuss<a id="_idIndexMarker177"/> casting in greater detail later in this chapter. For now, <strong class="source-inline">3.45</strong> is a <strong class="source-inline">double</strong> literal (8 bytes) and cannot be stored in an <strong class="source-inline">int</strong> variable, <strong class="source-inline">z</strong>, as <strong class="source-inline">int</strong> variables are 4 bytes in size. The compiler spots this and generates an error. To get around this error, we can use a cast, which takes the form of <em class="italic">(cast type)</em>. This cast enables us to override the compiler error. In this case, we are casting <strong class="source-inline">3.45</strong> to an <strong class="source-inline">int</strong> variable, which means we lose the decimal places. Thus, we store <strong class="source-inline">3</strong> in <strong class="source-inline">z</strong>, as shown by the output from <span class="No-Break">line 43.</span></p>
			<h3>Logical NOT operator</h3>
			<p>In <span class="No-Break"><em class="italic">Figure 3</em></span><em class="italic">.2</em>, on line 45, we<a id="_idIndexMarker178"/> declare<a id="_idIndexMarker179"/> a boolean, <strong class="source-inline">b</strong>, and initialize it to <strong class="source-inline">true</strong>. On line 46, we output the inverted value of <strong class="source-inline">b</strong> by using the logical NOT operator. Note that we are not changing the value of <strong class="source-inline">b</strong> meaning, the value of <strong class="source-inline">b</strong> is still <strong class="source-inline">true</strong>. This is shown by the output from<a id="_idIndexMarker180"/> <span class="No-Break">line 47.</span></p>
			<p>Now, let’s examine the <span class="No-Break">arithmetic operators.</span></p>
			<h2 id="_idParaDest-75"><a id="_idTextAnchor075"/>Arithmetic operators</h2>
			<p>There are five<a id="_idIndexMarker181"/> arithmetic operators, all<a id="_idIndexMarker182"/> of which we will <span class="No-Break">examine now.</span></p>
			<h3>Addition/subtraction operators</h3>
			<p>As in <a id="_idIndexMarker183"/>mathematics, the <strong class="source-inline">+</strong> operator represents<a id="_idIndexMarker184"/> addition and the <strong class="source-inline">-</strong> operator represents subtraction. Both are binary operators; in other words, there are two operands, one on either side of the operator. The following code example <span class="No-Break">demonstrates this:</span></p>
			<pre class="source-code">
int res = 6 + 4 - 2;System.out.println(res); // 8</pre>
			<p>In this code segment, <strong class="source-inline">res</strong> has been <a id="_idIndexMarker185"/>assigned a <a id="_idIndexMarker186"/>value of <strong class="source-inline">6 + 4 – 2</strong>, which <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">8</strong></span><span class="No-Break">.</span></p>
			<h3>Multiplication/division operators</h3>
			<p>The <strong class="source-inline">*</strong> operator represents<a id="_idIndexMarker187"/> multiplication and the <strong class="source-inline">/</strong> operator <a id="_idIndexMarker188"/>represents division. Both are binary operators. Note that <em class="italic">integer division truncates</em>. The following code segment <span class="No-Break">demonstrates this:</span></p>
			<pre class="source-code">
System.out.println(10/3); // 3</pre>			<p>This code segment outputs <strong class="source-inline">3</strong> because integer division truncates. We are dividing one integer, <strong class="source-inline">10</strong>, by another integer, <strong class="source-inline">3</strong>. The remainder is <span class="No-Break">simply discarded.</span></p>
			<h3>Modulus operator</h3>
			<p>The <strong class="source-inline">%</strong> operator<a id="_idIndexMarker189"/> is used for calculating the modulus (remainder). The <a id="_idIndexMarker190"/>following code example demonstrates the modulus <a id="_idIndexMarker191"/>operator <span class="No-Break">in action:</span></p>
			<pre class="source-code">
int mod1 = 10 % 3;System.out.println(mod1); // 1
int mod2 = 0 % 3;
System.out.println(mod2); // 0</pre>
			<p>The first line initializes <strong class="source-inline">mod1</strong> to be the remainder of <strong class="source-inline">10</strong> divided by <strong class="source-inline">3</strong>, which is <strong class="source-inline">1</strong>. In other words, <strong class="source-inline">3</strong> goes into <strong class="source-inline">10</strong> three times and <strong class="source-inline">1</strong> is left over. Therefore, <strong class="source-inline">1</strong> is assigned <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">mod1</strong></span><span class="No-Break">.</span></p>
			<p>The initialization of <strong class="source-inline">mod2</strong> is interesting: <strong class="source-inline">3</strong> goes into <strong class="source-inline">0</strong> zero times and there is <strong class="source-inline">0</strong> (or nothing) left over. Hence, <strong class="source-inline">0</strong> is assigned <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">mod2</strong></span><span class="No-Break">.</span></p>
			<h3>The precedence of arithmetic operators</h3>
			<p>As per <em class="italic">Table 3.1</em>, <strong class="source-inline">*</strong>, <strong class="source-inline">/</strong>, and <strong class="source-inline">%</strong> have higher<a id="_idIndexMarker192"/> precedence than the <strong class="source-inline">+</strong> and <strong class="source-inline">–</strong> operators, and assignment has the lowest precedence. <span class="No-Break"><em class="italic">Figure 3</em></span><em class="italic">.3</em> shows how this affects the evaluation of expressions <span class="No-Break">in code:</span></p>
			<div>
				<div id="_idContainer029" class="IMG---Figure">
					<img src="image/B19793_03_3.jpg" alt="Figure 3.3 – Arithmetic operators precedence"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.3 – Arithmetic operators precedence</p>
			<p>Lines 61 demonstrates that <strong class="source-inline">*</strong> has higher precedence than <strong class="source-inline">+</strong>, in that the expression evaluates to <strong class="source-inline">3 + (2 * 4) = 3 + 8 = </strong><span class="No-Break"><strong class="source-inline">11</strong></span><span class="No-Break">.</span></p>
			<p>Line 63 demonstrates that parentheses change the grouping. Now, the shared value, <strong class="source-inline">2</strong>, is grouped with <strong class="source-inline">3</strong> (as opposed to <strong class="source-inline">4</strong>, which was the case on line 61). The expression now evaluates to <strong class="source-inline">5 * 4 = </strong><span class="No-Break"><strong class="source-inline">20</strong></span><span class="No-Break">.</span></p>
			<p>Line 65 demonstrates that <strong class="source-inline">+</strong> and <strong class="source-inline">-</strong> associate left to right. The expression <span class="No-Break">evaluates to</span></p>
			<p><strong class="source-inline">10 - 2 = </strong><span class="No-Break"><strong class="source-inline">8</strong></span><span class="No-Break">.</span></p>
			<p>Lines 67 <a id="_idIndexMarker193"/>demonstrates that <strong class="source-inline">*</strong>, <strong class="source-inline">/</strong>, and <strong class="source-inline">%</strong> also associate<a id="_idIndexMarker194"/> left to right. The expression evaluates to <strong class="source-inline">2 * 6 % 10</strong>, which, in turn, evaluates to <strong class="source-inline">12 % 10</strong>, which <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">2</strong></span><span class="No-Break">.</span></p>
			<p class="callout-heading">Math operations involving <strong class="source-inline">int</strong> variables or smaller result in an <strong class="source-inline">int</strong></p>
			<p class="callout">It is interesting to note that any math<a id="_idIndexMarker195"/> operation involving an <strong class="source-inline">int</strong> type or smaller results in <strong class="source-inline">int</strong>. This is demonstrated in the following <span class="No-Break">code segment:</span></p>
			<p class="callout"><strong class="source-inline">byte </strong><span class="No-Break"><strong class="source-inline">b1=2, b2=3;</strong></span></p>
			<p class="callout"><strong class="source-inline">byte b3 = b1 + b2; // </strong><span class="No-Break"><strong class="source-inline">compiler error</strong></span></p>
			<p class="callout"><strong class="source-inline">byte b4 = (byte)(b1 + </strong><span class="No-Break"><strong class="source-inline">b2);// Ok</strong></span></p>
			<p class="callout">The first line declares 2 bytes, namely <strong class="source-inline">b1</strong> and <strong class="source-inline">b2</strong>. Notice that, even though <strong class="source-inline">2</strong> and <strong class="source-inline">3</strong> are integer literals, the compiler is aware that these values are within the range of <strong class="source-inline">byte</strong> (-128 to +127) and, consequently, allows <span class="No-Break">the declarations.</span></p>
			<p class="callout">However, the next line is a problem. The compiler has a rule that all math operations involving <strong class="source-inline">int</strong> types or smaller result in an <strong class="source-inline">int</strong>. Therefore, even though the sum of the two bytes, 5, is well within the <strong class="source-inline">byte</strong> range, the compiler complains saying “possible loss of data converting from <strong class="source-inline">int</strong> <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">byte</strong></span><span class="No-Break">”.</span></p>
			<p class="callout">The last line fixes this issue by casting<a id="_idIndexMarker196"/> the result of the addition (an <strong class="source-inline">int</strong> type) to a <strong class="source-inline">byte</strong> before the assignment. What this means is that the extra 3 bytes from the <strong class="source-inline">int</strong> (that do not fit into the <strong class="source-inline">byte</strong>) are simply discarded. Thus, the sum of <strong class="source-inline">b1 + b2</strong> is cast from <strong class="source-inline">int</strong> to <strong class="source-inline">byte</strong> and the resultant <strong class="source-inline">byte</strong> is assigned to <strong class="source-inline">b4</strong>. Casting is discussed in more detail later in <span class="No-Break">the chapter.</span></p>
			<p>We will finish our discussion on arithmetic operators by examining <strong class="source-inline">+</strong> in a <span class="No-Break">different context.</span></p>
			<h3>String append</h3>
			<p>As we have <a id="_idIndexMarker197"/>seen, Java uses <strong class="source-inline">+</strong> for mathematical <a id="_idIndexMarker198"/>addition. However, this occurs only if both operands are numbers. For<a id="_idIndexMarker199"/> example, 3 + 4 results in 7 because both operands, 3 and 4, <span class="No-Break">are numbers.</span></p>
			<p>However, if either operand (or both) are strings, Java performs a <strong class="source-inline">String</strong> append. A <strong class="source-inline">String</strong> literal is enclosed in double quotes – for example, <strong class="source-inline">"abc"</strong>, <strong class="source-inline">"123"</strong>, <strong class="source-inline">"Sean"</strong>, and <strong class="source-inline">"Maaike"</strong> are all <strong class="source-inline">String</strong> literals. So, just to be clear on what operation is performed and when, let’s take a look at <span class="No-Break">some examples:</span></p>
			<ul>
				<li>3 + 4 is mathematical addition. Thus, the result <span class="No-Break">is 7.</span></li>
				<li>“3” + 4 is a string append as there is a string on the left of <strong class="source-inline">+</strong>. The result is the <span class="No-Break">string “34.”</span></li>
				<li>3 + “4” is a string append as there is a string on the right of <strong class="source-inline">+</strong>. Again, the result is the <span class="No-Break">string “34.”</span></li>
				<li>“3” + “4” is a string append as there is a string on both sides of <strong class="source-inline">+</strong>. The result is also the <span class="No-Break">string “34.”</span></li>
			</ul>
			<p>So, what exactly happens during a string append? <em class="italic">Java cannot perform any mathematical operations when the operands are of different types</em>. Let’s examine this with an example piece <span class="No-Break">of code:</span></p>
			<pre class="source-code">
String s = "3" + 4;System.out.println(s); // "34"</pre>
			<p>The first thing to note is that the<a id="_idIndexMarker200"/> first line of code only compiles because <strong class="source-inline">"3" + 4</strong> results in a <strong class="source-inline">String</strong> literal. When Java encounters a string on the left/right/both sides of <strong class="source-inline">+</strong>, it performs string concatenation (append). Essentially, as <strong class="source-inline">+</strong> associates left to right, Java appends (adds) the string on the right of <strong class="source-inline">+</strong> to the end of the string on the left <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">+</strong></span><span class="No-Break">.</span></p>
			<p>In this example, Java sees the <strong class="source-inline">String</strong> literal <strong class="source-inline">"3"</strong> and the <strong class="source-inline">+</strong> operator and realizes it must perform a <strong class="source-inline">String</strong> append. To do this, in memory, it creates a string version of 4 – in other words, <strong class="source-inline">"4"</strong>. The integer <strong class="source-inline">4</strong> literal is not touched. Thus, a new variable is created under the hood – it is a <strong class="source-inline">String</strong> variable, and <strong class="source-inline">"4"</strong> is its value. The expression is now <strong class="source-inline">"3" + "4"</strong>. As both operands on either side of <strong class="source-inline">+</strong> are now of the same type (both are strings), Java can perform<a id="_idIndexMarker201"/> the append. The new string is the result of <strong class="source-inline">"3" + "4"</strong>, which is <strong class="source-inline">"34"</strong>. This is what is assigned to <strong class="source-inline">s</strong>. The second line <a id="_idIndexMarker202"/>demonstrates this by outputting <strong class="source-inline">"34"</strong> <span class="No-Break">for </span><span class="No-Break"><strong class="source-inline">s</strong></span><span class="No-Break">.</span></p>
			<p>In <span class="No-Break"><em class="italic">Figure 3</em></span><em class="italic">.4</em>, a more substantial example <span class="No-Break">is presented:</span></p>
			<div>
				<div id="_idContainer030" class="IMG---Figure">
					<img src="image/B19793_03_4.jpg" alt="Figure 3.4 – String append in action"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.4 – String append in action</p>
			<p>On line 79, as both operands, <strong class="source-inline">a</strong> and <strong class="source-inline">b</strong>, are integers, Java initializes <strong class="source-inline">res</strong> to <strong class="source-inline">5</strong> (the sum of <strong class="source-inline">3</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">2</strong></span><span class="No-Break">).</span></p>
			<p>Line 82 is evaluated as follows: <strong class="source-inline">3 + "abc" = "3" + "abc" = "3abc"</strong>. In other words, Java realizes that it must do a string append due to the presence of <strong class="source-inline">"abc"</strong> on the right-hand side of <strong class="source-inline">+</strong>. Thus, somewhere in memory, a string version of the value of <strong class="source-inline">a</strong> is created. In other words, a variable with <strong class="source-inline">"3"</strong> is created. Note that <strong class="source-inline">a</strong> <em class="italic">remains an int with 3 as its value</em>. Now, Java can proceed since both operands are the same type (strings): <strong class="source-inline">"3" + "abc"</strong> results <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">"3abc"</strong></span><span class="No-Break">.</span></p>
			<p>Line 83 <a id="_idIndexMarker203"/>demonstrates that it does not matter which side of <strong class="source-inline">+</strong> the string is on. Plus, it does not matter if the string is a string literal or a string variable. The expression on line 83 is evaluated as follows: <strong class="source-inline">"abc" + 3 = "abc" + "3" = "abc3"</strong>. This<a id="_idIndexMarker204"/> is what <strong class="source-inline">s2</strong> is initialized to. Line 84 outputs the values of both <strong class="source-inline">s1</strong> and <strong class="source-inline">s2</strong> with a space between them. Note that <strong class="source-inline">System.out.println</strong> expects a string. The string output on line 84 is constructed as follows: <strong class="source-inline">"3abc" + " " = "3abc " + "abc3" = "</strong><span class="No-Break"><strong class="source-inline">3abc abc3"</strong></span><span class="No-Break">.</span></p>
			<p>Lines 86 and 87 require special mention. The problem with line 86 is that the output string is constructed as follows: <strong class="source-inline">"Output is "+ 3 = "Output is " + "3" = "Output is 3" + 2 = "Output is 3" + "2" = "Output is 32"</strong>. This is not what <span class="No-Break">we wanted.</span></p>
			<p>Line 87 rectifies this by using parentheses to ensure that <strong class="source-inline">a + b</strong> is grouped. Thus, the string is constructed<a id="_idIndexMarker205"/> as follows: <strong class="source-inline">"Output is "+ 5 = "Output is "+ "5" = "Output </strong><span class="No-Break"><strong class="source-inline">is 5"</strong></span><span class="No-Break">.</span></p>
			<p>That finishes the arithmetic operators. We will now examine <span class="No-Break">relational operators.</span></p>
			<h2 id="_idParaDest-76"><a id="_idTextAnchor076"/>Relational operators</h2>
			<p>Java has six relational <a id="_idIndexMarker206"/>operators, all of which<a id="_idIndexMarker207"/> result in a <strong class="source-inline">boolean</strong> value of <strong class="source-inline">true</strong> or <strong class="source-inline">false</strong>. They are <span class="No-Break">as follows:</span></p>
			<ul>
				<li><strong class="source-inline">==</strong> is the <span class="No-Break">equivalence operator</span></li>
				<li><strong class="source-inline">!=</strong> is the not <span class="No-Break">equivalent operator</span></li>
				<li><strong class="source-inline">&gt;</strong> is the greater <span class="No-Break">than operator</span></li>
				<li><strong class="source-inline">&gt;=</strong> is the greater than or equal <span class="No-Break">to operator</span></li>
				<li><strong class="source-inline">&lt;</strong> is the less <span class="No-Break">than operator</span></li>
				<li><strong class="source-inline">&lt;=</strong> is the less than or equal <span class="No-Break">to operator</span></li>
			</ul>
			<p><span class="No-Break"><em class="italic">Figure 3</em></span><em class="italic">.5</em> shows the relational operators in action <span class="No-Break">in code:</span></p>
			<div>
				<div id="_idContainer031" class="IMG---Figure">
					<img src="image/B19793_03_5.jpg" alt="Figure 3.5 – Relational operators in code"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.5 – Relational operators in code</p>
			<p>Line 89 declares two <strong class="source-inline">int</strong> variables, namely <strong class="source-inline">x</strong> and <strong class="source-inline">y</strong>, and initializes them to <strong class="source-inline">3</strong> and <strong class="source-inline">4</strong>, respectively. Line 90 uses Java’s equivalence operator, <strong class="source-inline">==</strong>, to check if <strong class="source-inline">x</strong> and <strong class="source-inline">y</strong> are equivalent. As they are not, line 90 outputs <strong class="source-inline">false</strong>. Line 91 checks the exact opposite. As <strong class="source-inline">x</strong> is not equivalent to <strong class="source-inline">y</strong>, line 91 <span class="No-Break">outputs </span><span class="No-Break"><strong class="source-inline">true</strong></span><span class="No-Break">.</span></p>
			<p>Line 92 outputs whether <strong class="source-inline">x</strong> is greater than <strong class="source-inline">y</strong>. This is, of course, <strong class="source-inline">false</strong> as <strong class="source-inline">3</strong> is not greater than <strong class="source-inline">4</strong>. Similarly, line 93 outputs whether <strong class="source-inline">x</strong> is greater than or equal to <strong class="source-inline">y</strong>. Again, this <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">false</strong></span><span class="No-Break">.</span></p>
			<p>Line 94 outputs whether <strong class="source-inline">x</strong> is less than <strong class="source-inline">y</strong>. This is <strong class="source-inline">true</strong> as <strong class="source-inline">3</strong> is less than <strong class="source-inline">4</strong>. Line 95 outputs whether <strong class="source-inline">x</strong> is less than or equal to <strong class="source-inline">y</strong>. Again, this <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">true</strong></span><span class="No-Break">.</span></p>
			<p>The relational operators<a id="_idIndexMarker208"/> and their boolean<a id="_idIndexMarker209"/> return values are going to be extremely useful going forward, particularly when we look at conditional statements in <a href="B19793_04.xhtml#_idTextAnchor087"><span class="No-Break"><em class="italic">Chapter 4</em></span></a><span class="No-Break">.</span></p>
			<p class="callout-heading">Implicit promotion</p>
			<p class="callout">While Java’s operators do not require the operands to be exactly the same type, the operands must be compatible. Consider the following <span class="No-Break">code snippet:</span></p>
			<p class="callout"><strong class="source-inline">System.out.println(3 + 4.0);  // </strong><span class="No-Break"><strong class="source-inline">7.0</strong></span></p>
			<p class="callout"><strong class="source-inline">System.out.println(4 == 4.0); // </strong><span class="No-Break"><strong class="source-inline">true</strong></span></p>
			<p class="callout">The first line tries to add an <strong class="source-inline">int</strong> variable of <strong class="source-inline">3</strong> to a <strong class="source-inline">double</strong> variable. Java realizes that the types are not the same. However, Java can figure out a safe solution without bothering us. This is where <em class="italic">implicit promotion</em> comes in. <strong class="source-inline">int</strong> requires 4 bytes of storage whereas <strong class="source-inline">double</strong> requires 8 bytes. In the background, somewhere in memory, Java declares a temporary <strong class="source-inline">double</strong> variable and promotes <strong class="source-inline">int 3</strong> to <strong class="source-inline">double 3.0</strong>, and stores <strong class="source-inline">3.0</strong> in this temporary location. Now, Java can add <strong class="source-inline">3.0</strong> to <strong class="source-inline">4.0</strong> (as both are <strong class="source-inline">double</strong>s), resulting in the <span class="No-Break">answer </span><span class="No-Break"><strong class="source-inline">7.0</strong></span><span class="No-Break">.</span></p>
			<p class="callout">The second line compares <strong class="source-inline">int 4</strong> with <strong class="source-inline">double 4.0</strong>. The same process happens. Java implicitly promotes <strong class="source-inline">4</strong> to <strong class="source-inline">4.0</strong> (in a new temporary location) and then compares <strong class="source-inline">4.0</strong> with <strong class="source-inline">4.0</strong>. This results in <strong class="source-inline">true</strong> <span class="No-Break">being</span><span class="No-Break"><a id="_idIndexMarker210"/></span><span class="No-Break"> output.</span></p>
			<p>Now, we will turn our attention to <span class="No-Break">logical operators.</span></p>
			<h2 id="_idParaDest-77"><a id="_idTextAnchor077"/>Logical operators</h2>
			<p>Logical operators<a id="_idIndexMarker211"/> enable us to build<a id="_idIndexMarker212"/> complex <strong class="source-inline">boolean</strong> expressions by combining sub-expressions. These operators are <span class="No-Break">as follows:</span></p>
			<ul>
				<li><strong class="source-inline">&amp;&amp;</strong> is the <span class="No-Break">logical AND</span></li>
				<li><strong class="source-inline">||</strong> is the <span class="No-Break">logical OR</span></li>
				<li><strong class="source-inline">&amp;</strong> is the <span class="No-Break">bitwise AND</span></li>
				<li><strong class="source-inline">|</strong> is the <span class="No-Break">bitwise OR</span></li>
				<li><strong class="source-inline">^</strong> is the bitwise eXclusive <span class="No-Break">OR (XOR)</span></li>
			</ul>
			<p>We will examine these in turn with code examples to help explain how they operate. But before we do that, it is worthwhile refreshing our truth tables, as shown in <span class="No-Break"><em class="italic">Table 3.2</em></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer032" class="IMG---Figure">
					<img src="image/B19793_03_Table_02.jpg" alt="Table 3.2 – Boolean truth tables"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 3.2 – Boolean truth tables</p>
			<p>In <em class="italic">Table 3.2</em>, the first two columns, <strong class="bold">P</strong> and <strong class="bold">Q</strong>, represent two expressions, where <strong class="bold">T</strong> means true and <strong class="bold">F</strong> means false. For example, the logical AND column (the <strong class="bold">P &amp;&amp; Q</strong> column) represents the result of the overall expression, <strong class="bold">P &amp;&amp; Q</strong>, depending on the values of <strong class="bold">P</strong> and <strong class="bold">Q</strong>. So, if <strong class="bold">P</strong> is true<a id="_idIndexMarker213"/> and <strong class="bold">Q</strong> is <strong class="bold">T</strong>, then <strong class="bold">P &amp;&amp; Q</strong> is <span class="No-Break">also true.</span></p>
			<p>With this table in mind, let’s examine the operators <span class="No-Break">in turn.</span></p>
			<h3>Logical AND (&amp;&amp;)</h3>
			<p>The logical AND<a id="_idIndexMarker214"/> states that both boolean operands must be true for the overall expression to be true. This is represented by the <strong class="bold">P &amp;&amp; Q</strong> column in <span class="No-Break"><em class="italic">Table 3.2</em></span><span class="No-Break">.</span></p>
			<p>Note that this operator<a id="_idIndexMarker215"/> is known as a short-circuiting operator. For example, in an expression P &amp;&amp; Q, if P evaluates to false, then &amp;&amp; will <em class="italic">not</em> evaluate the expression Q because the overall expression will evaluate to false regardless. This is because F &amp;&amp; F is false and F &amp;&amp; T is also false. In effect, Java knows that once the expression P is false on the left-hand side of an &amp;&amp; expression, the overall expression must be false. So, there is no need to evaluate the Q expression on the right-hand side, so it <em class="italic">short-circuits</em>. This is better explained with a <span class="No-Break">code example:</span></p>
			<pre class="source-code">
boolean b1 = false, b2 = true;boolean res = b1 &amp;&amp; (b2=false); // F &amp;&amp;
System.out.println(b1 + " " + b2 + " " + res);// false true
  false</pre>
			<p>The first line initializes two boolean variables, <strong class="source-inline">b1</strong> and <strong class="source-inline">b2</strong>, to <strong class="source-inline">false</strong> and <strong class="source-inline">true</strong>, respectively. The second line is the important one. Note that the parentheses are required around the <strong class="source-inline">b2=false</strong> sub-expression to get the code to compile (otherwise, you will get a syntax error). So, when we plug in <strong class="source-inline">false</strong> for <strong class="source-inline">b1</strong>, the expression evaluates to <strong class="source-inline">F &amp;&amp; (b2=false)</strong>. As the evaluation order is left to right, this will lead <strong class="source-inline">&amp;&amp;</strong> to short-circuit, because, regardless of what remains in the expression, there is no way the overall expression can evaluate to true. This means that the <strong class="source-inline">(b2=false)</strong> sub-expression is <span class="No-Break"><strong class="bold">not</strong></span><span class="No-Break"> executed.</span></p>
			<p>The last line outputs the values of the variables. The output is <strong class="source-inline">false</strong>, <strong class="source-inline">true</strong>, and <strong class="source-inline">false</strong> for <strong class="source-inline">b1</strong>, <strong class="source-inline">b2</strong>, and <strong class="source-inline">res</strong>, respectively. Crucially, <strong class="source-inline">b2</strong> is <strong class="source-inline">true</strong>, demonstrating<a id="_idIndexMarker216"/> that <strong class="source-inline">&amp;&amp;</strong> <span class="No-Break">short-circuited.</span></p>
			<h3>Logical OR (||)</h3>
			<p>The logical<a id="_idIndexMarker217"/> OR<a id="_idIndexMarker218"/> states that either or both boolean operands can be true for the overall expression to be true. This is represented by the <strong class="bold">P || Q</strong> column in <span class="No-Break"><em class="italic">Table 3.2</em></span><span class="No-Break">.</span></p>
			<p>This operator is also a short-circuiting operator. For example, in an expression P || Q, if P evaluates to true, then || will <em class="italic">not</em> evaluate the expression Q because the overall expression will evaluate to true regardless. This is because T || F is true and T || T is also true. In effect, Java knows that once the expression P is true on the left-hand side of an || expression, the overall expression must be true. So, there is no need to evaluate the expression, Q, and hence it <em class="italic">short-circuits</em>. Again a code example <span class="No-Break">will help:</span></p>
			<pre class="source-code">
boolean b1=false, b2=true;boolean res = b2 || (b1=true);  // T ||
System.out.println(b1 + " "+ b2 + " "+res);// false true
  true</pre>
			<p>The first line initializes two boolean variables, <strong class="source-inline">b1</strong> and <strong class="source-inline">b2</strong>, to <strong class="source-inline">false</strong> and <strong class="source-inline">true</strong>, respectively. The second line is the important one. Note again that the parentheses are required around the <strong class="source-inline">b1=true</strong> sub-expression to get the code to compile. So, when we plug in <strong class="source-inline">true</strong> for <strong class="source-inline">b2</strong>, the expression evaluates to <strong class="source-inline">T || (b1=true)</strong>. As the evaluation order is left to right, this will lead <strong class="source-inline">||</strong> to short-circuit because, regardless of what remains in the expression, there is no way the overall expression can evaluate <span class="No-Break">to false.</span></p>
			<p>The last line<a id="_idIndexMarker219"/> outputs the values of the variables. The output is <strong class="source-inline">false</strong>, <strong class="source-inline">true</strong>, and <strong class="source-inline">true</strong> for <strong class="source-inline">b1</strong>, <strong class="source-inline">b2</strong>, and <strong class="source-inline">res</strong>, respectively. Crucially, <strong class="source-inline">b1</strong> is <strong class="source-inline">false</strong>, demonstrating that <strong class="source-inline">||</strong> <span class="No-Break">short-circuited.</span></p>
			<p class="callout-heading">Order of evaluation versus precedence</p>
			<p class="callout">This topic often causes<a id="_idIndexMarker220"/> confusion and is best explained with some sample<a id="_idIndexMarker221"/> pieces of code. Let’s start with an example that can be <span class="No-Break">deceptively simple:</span></p>
			<p class="callout"><strong class="source-inline">int x=2, </strong><span class="No-Break"><strong class="source-inline">y=3, z=4;</strong></span></p>
			<p class="callout"><strong class="source-inline">int res = x + y * z;    // x + (y * </strong><span class="No-Break"><strong class="source-inline">z)</strong></span></p>
			<p class="callout"><span class="No-Break"><strong class="source-inline">System.out.println(res);// 14</strong></span></p>
			<p class="callout">As <strong class="source-inline">*</strong> has higher precedence than <strong class="source-inline">+</strong>, the common element <strong class="source-inline">y</strong>, is grouped with <strong class="source-inline">z</strong> and not <strong class="source-inline">x</strong>. Thus, the overall expression is <strong class="source-inline">x + (y * z)</strong> = 2 + 12 = <span class="No-Break">14.</span></p>
			<p class="callout">What is important to<a id="_idIndexMarker222"/> note here is that the evaluation order is left to right and as evaluation<a id="_idIndexMarker223"/> order trumps precedence, <strong class="source-inline">x</strong> is evaluated first before the <strong class="source-inline">(y * z)</strong> sub-expression. While this makes no difference in this example, let’s look at an example where it does make <span class="No-Break">a difference:</span></p>
			<p class="callout"><strong class="source-inline">boolean a=false, </strong><span class="No-Break"><strong class="source-inline">b=false, c=false;</strong></span></p>
			<p class="callout"><strong class="source-inline">// a || (b &amp;&amp; </strong><span class="No-Break"><strong class="source-inline">c)</strong></span></p>
			<p class="callout"><strong class="source-inline">// The next line evaluates to </strong><span class="No-Break"><strong class="source-inline">T ||</strong></span></p>
			<p class="callout"><strong class="source-inline">boolean bool = (a = true) || (b = true) &amp;&amp; (c = </strong><span class="No-Break"><strong class="source-inline">true);</strong></span></p>
			<p class="callout"><strong class="source-inline">System.out.print(a + ", " + b + ", " + c); // true, </strong><span class="No-Break"><strong class="source-inline">false, false</strong></span></p>
			<p class="callout">As <strong class="source-inline">&amp;&amp;</strong> has higher precedence than <strong class="source-inline">||</strong>, the expression evaluates to <strong class="source-inline">(a = true) ||   ( (b = true) &amp;&amp; (c = </strong><span class="No-Break"><strong class="source-inline">true) )</strong></span><span class="No-Break">.</span></p>
			<p class="callout">In other words, the common sub-expression <strong class="source-inline">(b = true)</strong> is grouped with <strong class="source-inline">(c = true)</strong> rather than <strong class="source-inline">(a = true)</strong>. Now comes the crucial bit: <em class="italic">evaluation order trumps precedence</em>. Therefore, <strong class="source-inline">(a = true)</strong> is evaluated first, resulting in <strong class="source-inline">T || ((b = true) &amp;&amp; (c = </strong><span class="No-Break"><strong class="source-inline">true))</strong></span><span class="No-Break">.</span></p>
			<p class="callout">As <strong class="source-inline">||</strong> is a short-circuit operator, the rest of the expression (to the right of <strong class="source-inline">||</strong>) is <strong class="bold">not</strong> evaluated. This is demonstrated<a id="_idIndexMarker224"/> by the output on the last line, where <a id="_idIndexMarker225"/>it outputs <strong class="source-inline">true</strong>, <strong class="source-inline">false</strong>, <strong class="source-inline">false</strong>, for <strong class="source-inline">a</strong>, <strong class="source-inline">b</strong>, and <strong class="source-inline">c</strong>, respectively. The crucial thing to note here is that <strong class="source-inline">b</strong> and <strong class="source-inline">c</strong> are <span class="No-Break">still </span><span class="No-Break"><strong class="source-inline">false</strong></span><span class="No-Break">!</span></p>
			<p>Now that we have discussed the logical operators, we will move on to <span class="No-Break">bitwise operators.</span></p>
			<h2 id="_idParaDest-78"><a id="_idTextAnchor078"/>Bitwise operators</h2>
			<p>Although some of the bitwise operators<a id="_idIndexMarker226"/> look very similar to the logical<a id="_idIndexMarker227"/> operators, they operate quite differently. The principle differences are that the bitwise operators can work with both boolean and integral (<strong class="source-inline">byte</strong>, <strong class="source-inline">short</strong>, <strong class="source-inline">int</strong>, <strong class="source-inline">long</strong>, and <strong class="source-inline">char</strong>) operands. In addition, bitwise operators do <span class="No-Break"><em class="italic">not</em></span><span class="No-Break"> short-circuit.</span></p>
			<p>Let’s examine the boolean bitwise <span class="No-Break">operators first.</span></p>
			<h3>Bitwise AND (&amp;)</h3>
			<p>Comparing<a id="_idIndexMarker228"/> the bitwise AND (<strong class="source-inline">&amp;</strong>) with the<a id="_idIndexMarker229"/> logical AND (<strong class="source-inline">&amp;&amp;</strong>), the difference is that the bitwise AND will <em class="italic">not</em> short-circuit. This is represented by the <strong class="bold">P &amp; Q</strong> column in <em class="italic">Table 3.2</em>. If we take the sample code that we used for the logical AND but change it to use the bitwise AND operator, you will see the difference in <span class="No-Break">the output:</span></p>
			<pre class="source-code">
boolean b1 = false, b2 = true;boolean res = b1 &amp; (b2=false); // F &amp; F
System.out.println(b1 + " " + b2 + " " + res);// false
  false false</pre>
			<p>In this case, the <strong class="source-inline">(b2=false)</strong> sub-expression is executed because <strong class="source-inline">&amp;</strong> did not short-circuit. So we had <strong class="source-inline">false</strong> &amp; <strong class="source-inline">false</strong>, which is <strong class="source-inline">false</strong>. Thus, the output is <strong class="source-inline">false</strong> for all <span class="No-Break">the variables.</span></p>
			<h3>Bitwise OR (|)</h3>
			<p>Comparing the <a id="_idIndexMarker230"/>bitwise OR (<strong class="source-inline">|</strong>) with the logical OR (<strong class="source-inline">||</strong>), the difference is that the bitwise OR will <em class="italic">not</em> short-circuit. This is represented by the <strong class="bold">P | Q</strong> column in <em class="italic">Table 3.2</em>. If we take the sample code that we used for the logical OR but change it to use the bitwise OR operator, you will see the difference in <span class="No-Break">the output:</span></p>
			<pre class="source-code">
boolean b1=false, b2=true;boolean res = b2 | (b1=true);  // T | T
System.out.println(b1 + " "+ b2 + " "+res);// true true
  true</pre>
			<p>In this case, the <strong class="source-inline">(b1=true)</strong> sub-expression is executed because <strong class="source-inline">|</strong> did not short-circuit. So, we had: <strong class="source-inline">true</strong> | <strong class="source-inline">true</strong>, which is <strong class="source-inline">true</strong>. Thus, the output is <strong class="source-inline">true</strong> for all <span class="No-Break">the variables.</span></p>
			<h3>Bitwise XOR (^)</h3>
			<p>This is<a id="_idIndexMarker231"/> another<a id="_idIndexMarker232"/> non-short-circuiting operator. The bitwise XOR, represented by the <strong class="source-inline">^</strong> operator, evaluates to <strong class="source-inline">true</strong>, if and only if one of the operands is <strong class="source-inline">true</strong> but <em class="italic">not</em> both. This is represented by the <strong class="bold">P ^ Q</strong> column in <em class="italic">Table 3.2</em>. Let’s look at some examples in terms <span class="No-Break">of code:</span></p>
			<pre class="source-code">
boolean b1 = (5 &gt; 1)  ^ (10 &lt; 20);   // T ^ T == Fboolean b2 = (5 &gt; 10) ^ (10 &lt; 20);   // F ^ T == T
boolean b3 = (5 &gt; 1)  ^ (10 &lt; 2);    // T ^ F == T
boolean b4 = (5 &gt; 10) ^ (10 &lt; 2);    // F ^ F == F
// false true true false
System.out.println(b1 + " " + b2 + " " + b3 + " " + b4);</pre>
			<p>The <strong class="source-inline">boolean</strong> variable, <strong class="source-inline">b1</strong>, is initialized to <strong class="source-inline">false</strong> because both of the sub-expressions – <strong class="source-inline">(5 &gt; 1)</strong> and <strong class="source-inline">(10 &lt; 20)</strong> – are <strong class="source-inline">true</strong>. Similarly, <strong class="source-inline">b4</strong> is also initialized to <strong class="source-inline">false</strong> because both <strong class="source-inline">(5 &gt; 10)</strong> and <strong class="source-inline">(10 &lt; 2)</strong> <span class="No-Break">are </span><span class="No-Break"><strong class="source-inline">false</strong></span><span class="No-Break">.</span></p>
			<p>However, <strong class="source-inline">b2</strong> is <strong class="source-inline">true</strong> because even though <strong class="source-inline">(5 &gt; 10)</strong> is <strong class="source-inline">false</strong>, <strong class="source-inline">(10 &lt; 20)</strong> is <strong class="source-inline">true</strong>, and <strong class="source-inline">F ^ T</strong> is <strong class="source-inline">true</strong>. Likewise, <strong class="source-inline">b3</strong> is <strong class="source-inline">true</strong> because <strong class="source-inline">(5 &gt; 1)</strong> is <strong class="source-inline">true</strong>, <strong class="source-inline">(10 &lt; 2)</strong> is <strong class="source-inline">F</strong>, and <strong class="source-inline">T ^ F</strong> <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">true</strong></span><span class="No-Break">.</span></p>
			<p>Now that we have examined the bitwise operators when used with <strong class="source-inline">boolean</strong> operands, we will now briefly examine<a id="_idIndexMarker233"/> how the same operators work when the operands are <span class="No-Break">integral numbers.</span></p>
			<h3>Bitwise operators (integral operands)</h3>
			<p>Though not commonly<a id="_idIndexMarker234"/> used, we have included them for completeness. A code example is <span class="No-Break">useful here:</span></p>
			<pre class="source-code">
byte b1 = 6 &amp; 8;       // both bits must be 1byte b2 = 7 | 9;       // one or the other or both
byte b3 = 5 ^ 4;       // one or the other but not both
System.out.println(b1 + ", " + b2 + ", "+b3); // 0, 15, 1</pre>
			<p>When the operands are integrals (as opposed to booleans), the bit patterns become important in evaluating the result. For the <strong class="source-inline">&amp;</strong> operator, both bits must be 1 for that bit to be 1 in <span class="No-Break">the result:</span></p>
			<pre class="source-code">
6 &amp; 8 (in binary) = 0110 &amp; 1000 = 0000 = 0</pre>			<p>For the <strong class="source-inline">|</strong> operator, one of the bits, or both, must be 1 for that bit to be 1 in <span class="No-Break">the result:</span></p>
			<pre class="source-code">
7 | 9 (in binary) = 0111 | 1001 = 1111 = 15</pre>			<p>For the <strong class="source-inline">^</strong> operator, one <a id="_idIndexMarker235"/>of the bits, but not both, must be 1 for that bit<a id="_idIndexMarker236"/> to be 1 in <span class="No-Break">the result:</span></p>
			<pre class="source-code">
5 ^ 4 (in binary) = 0101 ^ 0100 = 0001 = 1</pre>			<p>That completes the bitwise operators. Now, let’s cover the <span class="No-Break">ternary operator.</span></p>
			<h2 id="_idParaDest-79"><a id="_idTextAnchor079"/>Ternary operator</h2>
			<p>The ternary operator, as its name<a id="_idIndexMarker237"/> suggests, is an operator that takes<a id="_idIndexMarker238"/> three operands. The ternary operator is used to evaluate boolean expressions and assign values accordingly to a variable. In other words, as boolean expressions evaluate to <strong class="source-inline">true</strong> or <strong class="source-inline">false</strong> only, the goal of the ternary operator is to decide which of the two values to assign to <span class="No-Break">the variable.</span></p>
			<p>The syntax is of the <span class="No-Break">following form:</span></p>
			<pre class="source-code">
variable = boolean expression ? value to assign if true :value to assign if false</pre>
			<p>Let’s look at <span class="No-Break">an example:</span></p>
			<pre class="source-code">
int x = 4;String s = x % 2 == 0 ? " is an even number" : " is an odd
  number";
System.out.println(x + s); // 4 is an even number</pre>
			<p>In this example, the boolean expression to be evaluated is <strong class="source-inline">x % 2==0</strong>, which, because <strong class="source-inline">x = 4</strong>, evaluates to <strong class="source-inline">true</strong>. Thus, <strong class="source-inline">is an even number</strong> is assigned to the string, <strong class="source-inline">s</strong>, and is output. Had <strong class="source-inline">x</strong> been 5, then the boolean<a id="_idIndexMarker239"/> expression would have been <strong class="source-inline">false</strong>, and therefore, <strong class="source-inline">is an odd number</strong> would <a id="_idIndexMarker240"/>have been assigned to <strong class="source-inline">s</strong> <span class="No-Break">and output.</span></p>
			<p>The last group of operators we will examine are compound <span class="No-Break">assignment operators.</span></p>
			<h2 id="_idParaDest-80"><a id="_idTextAnchor080"/>Compound assignment operators</h2>
			<p>These operators exist <a id="_idIndexMarker241"/>as a shorthand for more verbose<a id="_idIndexMarker242"/> expressions. For example, assuming <strong class="source-inline">x</strong> and <strong class="source-inline">y</strong> are both integers, <strong class="source-inline">x = x + y</strong> can be written as <strong class="source-inline">x += y</strong>. There are compound assignment operators for all of the <span class="No-Break">mathematical operators:</span></p>
			<ul>
				<li><strong class="source-inline">+=</strong> Example: <strong class="source-inline">x += y</strong> is the same as <strong class="source-inline">x = x + y</strong></li>
				<li><strong class="source-inline">-=</strong> Example: <strong class="source-inline">x -= y</strong> is the same as <strong class="source-inline">x = x - y</strong></li>
				<li><strong class="source-inline">*=</strong> Example: <strong class="source-inline">x *= y</strong> is the same as <strong class="source-inline">x = x * y</strong></li>
				<li><strong class="source-inline">/=</strong> Example: <strong class="source-inline">x /= y</strong> is the same as <strong class="source-inline">x = x / y</strong></li>
				<li><strong class="source-inline">%=</strong> Example: <strong class="source-inline">x %= y</strong> is the same as <strong class="source-inline">x = x % y</strong></li>
			</ul>
			<p>Indeed, there are compound assignment operators for the bitwise operators – for example, x &amp;= 3 is the same as x = x &amp; 3 but they are so rarely used that we will just mention that <span class="No-Break">they exist.</span></p>
			<p>There are one or two subtleties to be aware of. As mentioned earlier, any mathematical operation involving an <strong class="source-inline">int</strong> type or smaller results in <strong class="source-inline">int</strong>. This can result in a cast being required to get the code to compile. With the compound assignment operators, the cast is in-built, so the explicit cast is not required. Take the following code <span class="No-Break">for example:</span></p>
			<pre class="source-code">
byte b1 = 3, b2 = 4;//  b1 = b1 + b2;         // compiler error
b1 = (byte)(b1 + b2);     // ok
b1 += b2;         // ok, no cast required</pre>
			<p>The first line initializes 2 bytes, <strong class="source-inline">b1</strong> and <strong class="source-inline">b2</strong>, to <strong class="source-inline">3</strong> and <strong class="source-inline">4</strong>, respectively. The second line is commented out as it generates a compiler error. The addition of <strong class="source-inline">b1</strong> and <strong class="source-inline">b2</strong> results in an <strong class="source-inline">int</strong> type that cannot be directly assigned to a <strong class="source-inline">byte</strong> variable, unless you cast it down from <strong class="source-inline">int</strong> to <strong class="source-inline">byte</strong>. This is what the third line is doing – using the cast (<strong class="source-inline">byte</strong>) to override the compiler error. We’ll cover casting very soon but for now, just realize that with the cast, you are overriding the compiler error, effectively saying “I know what I am <span class="No-Break">doing, proceed.”</span></p>
			<p>The last line is interesting in that, in the background, it is the same as the third line. In other words, the compiler translates <strong class="source-inline">b1 += b2</strong> into <strong class="source-inline">b1 = (byte) (b1 + </strong><span class="No-Break"><strong class="source-inline">b2)</strong></span><span class="No-Break">.</span></p>
			<p>Another subtlety to be aware of is that whatever is on the right-hand side of the compound assignment operator is going to be grouped, regardless of precedence. An example will help here. Consider <span class="No-Break">the following:</span></p>
			<pre class="source-code">
int x = 2;x *= 2 + 5;                   // x = x * (2 + 5) = 2 * 7 = 14
System.out.println(x); // 14</pre>
			<p>We know that <strong class="source-inline">*</strong> has higher<a id="_idIndexMarker243"/> precedence than <strong class="source-inline">+</strong> and that the order<a id="_idIndexMarker244"/> of evaluation is left to right. That said, what is on the right-hand side of <strong class="source-inline">*=</strong> is grouped by the compiler by surrounding <strong class="source-inline">2 + 5</strong> with parentheses (in the background). Thus, the expression becomes <strong class="source-inline">2 * (2 + 5)  = 2 * 7 = 14</strong>. To further this point, had the compiler <em class="italic">not</em> inserted parentheses, the expression would have been evaluated to 9. In other words, due to operator precedence, the expression would have been (2 * 2) + 5 = 4 + 5 = 9. However, as we have seen, this is <strong class="bold">not</strong> <span class="No-Break">the case.</span></p>
			<p>Let’s look at another more <span class="No-Break">complicated example:</span></p>
			<pre class="source-code">
int k=1;k += (k=4) * (k+2);
System.out.println(k); // 25</pre>
			<p>In this example, the right-hand side is, once again, enclosed <span class="No-Break">in parentheses:</span></p>
			<pre class="source-code">
k += (right hand side) where the right hand side is (k=4) *  (k+2)</pre>
			<p>Translating <strong class="source-inline">+=</strong> into its longer form gives us the <span class="No-Break">following output:</span></p>
			<pre class="source-code">
k = k + (right hand side)</pre>			<p>The order of evaluation is left to right, so plugging in the current value of <strong class="source-inline">k</strong>, which is <strong class="source-inline">1</strong>, <span class="No-Break">results in:</span></p>
			<pre class="source-code">
k = 1 + (right hand side)</pre>			<p>Now, by plugging in the right-hand side expression, we get <span class="No-Break">the following:</span></p>
			<pre class="source-code">
k = 1 + ( (k=4) * (k+2) )</pre>			<p>As the order of evaluation is left to right, <strong class="source-inline">k</strong> is changed to <strong class="source-inline">4</strong> before we <span class="No-Break">add </span><span class="No-Break"><strong class="source-inline">2</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
k = 1 + ( 4 * 6 )k = 1 + 24
k = 25</pre>
			<p>That concludes our treatment of Java<a id="_idIndexMarker245"/> operators. Now, let’s examine Java casting, a topic we have touched on already<a id="_idIndexMarker246"/> in <span class="No-Break">this chapter.</span></p>
			<h1 id="_idParaDest-81"><a id="_idTextAnchor081"/>Explaining Java casting</h1>
			<p>To discuss casting<a id="_idIndexMarker247"/> properly, we need to explain both the widening and narrowing of Java’s primitive data types. With this in mind, it is helpful to remember the sizes of the primitive data types in bytes. <em class="italic">Table 3.3</em> represents <span class="No-Break">this information:</span></p>
			<div>
				<div id="_idContainer033" class="IMG---Figure">
					<img src="image/B19793_03_Table_03.jpg" alt="Table 3.3 – The sizes of Java’s primitive types"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 3.3 – The sizes of Java’s primitive types</p>
			<p>The preceding table presents the sizes in bytes of Java’s various primitive data types. This will help us as we discuss both widening <span class="No-Break">and narrowing.</span></p>
			<h2 id="_idParaDest-82"><a id="_idTextAnchor082"/>Widening</h2>
			<p>Widening <a id="_idIndexMarker248"/>is done automatically; in other <a id="_idIndexMarker249"/>words, a cast is not needed. As the promotion<a id="_idIndexMarker250"/> is done in the background, widening is also known as <em class="italic">implicit promotion</em>. With <em class="italic">Table 3.3</em> in mind, the widening rules are <span class="No-Break">as follows:</span></p>
			<p>byte → short/char → int → long → float → <span class="No-Break">double</span></p>
			<p>Given the sizes from <em class="italic">Table 3.3</em>, most of these rules should make sense. For example, a <strong class="source-inline">byte</strong> can automatically fit into a <strong class="source-inline">short</strong> because 1 byte fits into 2 bytes automatically. The only interesting one is <strong class="source-inline">long</strong> → <strong class="source-inline">float</strong>, which is <em class="italic">widening</em> from 8 bytes to 4 bytes. This is possible because even though a <strong class="source-inline">long</strong> requires 8 bytes and a <strong class="source-inline">float</strong> requires only 4 bytes, their ranges differ – that is, a <strong class="source-inline">float</strong> type can accommodate any <strong class="source-inline">long</strong> value but not vice versa. This is shown in the following <span class="No-Break">code snippet:</span></p>
			<pre class="source-code">
System.out.println("Float: " + Float.MAX_VALUE);// Float:  3.4028235E38
System.out.println("Float: " + Float.MIN_VALUE);// Float:
  1.4E-45
System.out.println(Long.MAX_VALUE);  //   9223372036854775807
System.out.println(Long.MIN_VALUE);   //  -9223372036854775808</pre>
			<p>Note the scientific notation <strong class="source-inline">E</strong> used for floating point. <strong class="source-inline">float</strong> takes up less space, but due to its representation, it can hold larger and smaller numbers <span class="No-Break">than </span><span class="No-Break"><strong class="source-inline">long</strong></span><span class="No-Break">.</span></p>
			<p class="callout-heading">Scientific notation</p>
			<p class="callout">Scientific notation<a id="_idIndexMarker251"/> is a shorthand way to represent decimal numbers and can be useful for representing very large and/or very small numbers. Here are <span class="No-Break">some examples:</span></p>
			<p class="callout"><strong class="source-inline">double d1 = .</strong><span class="No-Break"><strong class="source-inline">00000000123;</strong></span></p>
			<p class="callout"><strong class="source-inline">double d2 = </strong><span class="No-Break"><strong class="source-inline">1.23e-9;</strong></span></p>
			<p class="callout"><strong class="source-inline">System.out.println(d1==d2); // </strong><span class="No-Break"><strong class="source-inline">true</strong></span></p>
			<p class="callout"><strong class="source-inline">double d3 = </strong><span class="No-Break"><strong class="source-inline">120_000_000;</strong></span></p>
			<p class="callout"><strong class="source-inline">double d4 = </strong><span class="No-Break"><strong class="source-inline">1.2e+8;</strong></span></p>
			<p class="callout"><strong class="source-inline">System.out.println(d3==d4); // </strong><span class="No-Break"><strong class="source-inline">true</strong></span></p>
			<p class="callout">As the comparisons both return <strong class="source-inline">true</strong>, this means that <strong class="source-inline">d1</strong> is the internal representation of <strong class="source-inline">d2</strong>. Similarly, both <strong class="source-inline">d3</strong> and <strong class="source-inline">d4</strong> <span class="No-Break">are equivalent.</span></p>
			<p>Let’s examine widening in code. <span class="No-Break"><em class="italic">Figure 3</em></span><em class="italic">.6</em> <span class="No-Break">demonstrates this:</span></p>
			<p class="IMG---Figure"> </p>
			<div>
				<div id="_idContainer034" class="IMG---Figure">
					<img src="image/B19793_03_6.jpg" alt="Figure 3.6 – Implicit widening examples"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.6 – Implicit widening examples</p>
			<p>Line 14 is a regular <strong class="source-inline">char</strong> assignment – in other words, no widening is involved. Note that characters (represented by <strong class="source-inline">char</strong>) are simply small numbers (0..65,535). To represent a character, we enclose the character in single quotes. In contrast, a <strong class="source-inline">String</strong>, which is a sequence of characters, is represented in double quotes. Therefore, <strong class="source-inline">"a"</strong> is a <strong class="source-inline">String</strong>, whereas <strong class="source-inline">'a'</strong> is <span class="No-Break">a character.</span></p>
			<p>Line 15 is a widening from <strong class="source-inline">char</strong> (2 bytes) to <strong class="source-inline">int</strong> (4 bytes). Line 16 is a widening from <strong class="source-inline">int</strong> to <strong class="source-inline">float</strong>. Although both <strong class="source-inline">int</strong> and <strong class="source-inline">float</strong> require 4 bytes, as discussed earlier with <strong class="source-inline">long</strong>, <strong class="source-inline">float</strong> has a greater range, so there is no issue here. Line 17 is a widening from <strong class="source-inline">float</strong> to <strong class="source-inline">double</strong>. Lastly, line 18 is a widening from <strong class="source-inline">long</strong> to <strong class="source-inline">float</strong>. Note that there are no compiler errors anywhere<a id="_idIndexMarker252"/> and that the cast <a id="_idIndexMarker253"/>operator is not needed in any of <span class="No-Break">the assignments.</span></p>
			<p>Now, let’s discuss narrowing, where the cast operator <span class="No-Break"><em class="italic">is</em></span><span class="No-Break"> required.</span></p>
			<h2 id="_idParaDest-83"><a id="_idTextAnchor083"/>Narrowing</h2>
			<p>The cast operator<a id="_idIndexMarker254"/> is a type enclosed<a id="_idIndexMarker255"/> in parentheses – for example, <strong class="source-inline">(int)</strong> and <strong class="source-inline">(byte)</strong> are both cast operators that cast to <strong class="source-inline">int</strong> and <strong class="source-inline">byte</strong>, respectively. With <em class="italic">Table 3.3</em> in mind, the following figure, <span class="No-Break"><em class="italic">Figure 3</em></span><em class="italic">.7</em>, presents assignments that <span class="No-Break">require casting:</span></p>
			<div>
				<div id="_idContainer035" class="IMG---Figure">
					<img src="image/B19793_03_7.jpg" alt="Figure 3.7 – Casting examples"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.7 – Casting examples</p>
			<p>In the preceding figure, line 23 is attempting to assign <strong class="source-inline">3.3</strong>, a <strong class="source-inline">double</strong> type (8 bytes), to an <strong class="source-inline">int</strong> type (4 bytes). Without the cast, this would be a compiler error. With the cast, you are overriding the compiler error. So, on line 23, we are casting <strong class="source-inline">3.3</strong> to <strong class="source-inline">int</strong> and assigning this <strong class="source-inline">int</strong> to the <strong class="source-inline">i</strong> variable. Therefore, after the assignment completes, <strong class="source-inline">i</strong> has a value <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">3</strong></span><span class="No-Break">.</span></p>
			<p>Line 24 is casting the <strong class="source-inline">int</strong> type, <strong class="source-inline">233</strong>, into the <strong class="source-inline">byte</strong> variable, <strong class="source-inline">b</strong>. This literal value is outside the range of <strong class="source-inline">byte</strong> (-128 to +127), so a cast is required. Line 25 is casting the <strong class="source-inline">double</strong> type, <strong class="source-inline">3.5</strong>, to <strong class="source-inline">float</strong>. Remember that, by default, a decimal number is <strong class="source-inline">double</strong>; to have it considered as a <strong class="source-inline">float</strong> as opposed to a <strong class="source-inline">double</strong>, you must suffix <strong class="source-inline">f</strong> or <strong class="source-inline">F</strong>. For example, <strong class="source-inline">3.3f</strong> <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">float</strong></span><span class="No-Break">.</span></p>
			<p>The output on line 26 is 3, -23, and 3.5 for <strong class="source-inline">i</strong>, <strong class="source-inline">b</strong>, and <strong class="source-inline">f</strong>, respectively. Note that in the output, the <strong class="source-inline">float</strong> variable appears <span class="No-Break">without </span><span class="No-Break"><strong class="source-inline">f</strong></span><span class="No-Break">.</span></p>
			<p>How we arrived at <strong class="source-inline">-23</strong> is explained in the <span class="No-Break">following callout.</span></p>
			<p class="callout-heading">Overflowing the byte</p>
			<p class="callout">Remember<a id="_idIndexMarker256"/> that the range of <strong class="source-inline">byte</strong> is -128 (10000000) to +127 (01111111). The leftmost bit is the sign bit, with 1 representing negative and 0 <span class="No-Break">representing positive.</span></p>
			<p class="callout">In the preceding example, we did <span class="No-Break">the following:</span></p>
			<p class="callout"><strong class="source-inline">byte b</strong><strong class="source-inline">  = (</strong><span class="No-Break"><strong class="source-inline">byte) 233;</strong></span></p>
			<p class="callout">The literal value of <strong class="source-inline">233</strong> (an integer) is too big for <strong class="source-inline">byte</strong> but how was <strong class="source-inline">b</strong> assigned the value of -23? Mapping <strong class="source-inline">233</strong> as an <strong class="source-inline">int</strong> type gives us the following <span class="No-Break">bit pattern:</span></p>
			<p class="callout"><strong class="source-inline">11101001 = 1 + 8 + 32 + 64 + 128 = </strong><span class="No-Break"><strong class="source-inline">233 (int)</strong></span></p>
			<p class="callout">Note that as an <strong class="source-inline">int</strong> is 4 bytes, <strong class="source-inline">233</strong> is 00000000000000000000000011101001. Mapping that bit pattern as a <strong class="bold">byte</strong> (the high order 3 bytes are truncated) gives us the <span class="No-Break">following output:</span></p>
			<p class="callout"><strong class="source-inline">11101001 = 1 + 8 + 32 + 64 + (-128) = -</strong><span class="No-Break"><strong class="source-inline">23 (byte)</strong></span></p>
			<p class="callout">Remember that the leftmost bit is the sign bit. That is why <strong class="source-inline">–128</strong> is in the calculation. It is <strong class="source-inline">-(2</strong><span class="superscript">7</span><strong class="source-inline">) = -</strong><span class="No-Break"><strong class="source-inline">128</strong></span><span class="No-Break">.</span></p>
			<p>We will conclude<a id="_idIndexMarker257"/> this section by looking<a id="_idIndexMarker258"/> at some unusual examples where casting is/is <span class="No-Break">not required.</span></p>
			<h3>To cast or not to cast, that is the question</h3>
			<p>There are certain situations where, because<a id="_idIndexMarker259"/> the compiler applies rules in the background, a cast is <em class="italic">not</em> required. Let’s examine some of these situations with code examples. <span class="No-Break"><em class="italic">Figure 3</em></span><em class="italic">.8</em> presents <span class="No-Break">the code:</span></p>
			<div>
				<div id="_idContainer036" class="IMG---Figure">
					<img src="image/B19793_03_8.jpg" alt="Figure 3.8 – Situations where casting is not always necessary"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.8 – Situations where casting is not always necessary</p>
			<p>Line 32 declares and initializes a <strong class="source-inline">char</strong> variable <strong class="source-inline">c</strong>, to an <strong class="source-inline">int</strong> value of <strong class="source-inline">12</strong>. Remember that <strong class="source-inline">char</strong> variables are essentially small positive numbers. Although we are assigning an <strong class="source-inline">int</strong> value (4 bytes) to a <strong class="source-inline">char</strong> variable (2 bytes), because the literal value is within the range of <strong class="source-inline">char</strong> (0 to 65,535), the compiler allows it. Had the literal value been out of the range of <strong class="source-inline">char</strong>, the compiler would have generated an error – this is what is happening on <span class="No-Break">line 33.</span></p>
			<p>Line 34 declares and initializes a <strong class="source-inline">short</strong> variable, <strong class="source-inline">s</strong>, to an <strong class="source-inline">int</strong> value of <strong class="source-inline">12</strong>. Again, although <strong class="source-inline">short</strong> can hold only 2 bytes, the compiler realizes it can store the literal value, <strong class="source-inline">12</strong>, and <span class="No-Break">allows it.</span></p>
			<p>Note that, from the compiler’s perspective, assigning literal values into variables is different to assigning <em class="italic">variables</em> to variables. For example, lines 32 and 37 are quite different. This will become apparent as we discuss the next few lines in <span class="No-Break">the figure.</span></p>
			<p>Lines 35 to 38 demonstrate that while both <strong class="source-inline">char</strong> and <strong class="source-inline">short</strong> require 2 bytes, they have different ranges: <strong class="source-inline">char</strong> (0 to 65,535) and <strong class="source-inline">short</strong> (-32,768 to +32,767). This means that a <strong class="source-inline">short</strong> variable can hold a negative value such as -15, whereas a <strong class="source-inline">char</strong> variable cannot. Conversely, a <strong class="source-inline">char</strong> variable can hold a value such as 65,000 but a <strong class="source-inline">short</strong> variable cannot. Therefore, as lines 35 and 37 demonstrate, you cannot directly assign a <strong class="source-inline">char</strong> variable to a <strong class="source-inline">short</strong> variable and vice versa. You need<a id="_idIndexMarker260"/> a cast in both scenarios. Lines 36 and 38 <span class="No-Break">demonstrate this.</span></p>
			<h4>Compile-time constants</h4>
			<p>However, lines 40 to 42 show a way around<a id="_idIndexMarker261"/> the requirement for the cast we just outlined. If you declare your variable as a <em class="italic">compile-time constant</em> (and assuming the value is in range), the compiler will allow the variable-to-variable assignment. Line 40 uses the <strong class="source-inline">final</strong> keyword to declare a compile-time constant. We will discuss <strong class="source-inline">final</strong> in detail in <a href="B19793_09.xhtml#_idTextAnchor205"><span class="No-Break"><em class="italic">Chapter 9</em></span></a>, but in this context, it means that <strong class="source-inline">c1</strong> will always have a value of <strong class="source-inline">12</strong>. The value is fixed (or <em class="italic">constant</em>) for <strong class="source-inline">c1</strong> and this is done at <em class="italic">compile time</em>. If you try to change the value of <strong class="source-inline">c1</strong>, you will get a compiler error. Now that the compiler knows that <strong class="source-inline">c1</strong> will always have <strong class="source-inline">12</strong> as its value, the compiler can apply the same rules that it applies to literal values; in other words, is the value in range? This is why line 42 does <em class="italic">not</em> generate a <span class="No-Break">compiler error.</span></p>
			<p>This concludes our discussion on operators. Now, let’s <span class="No-Break">apply them!</span></p>
			<h1 id="_idParaDest-84"><a id="_idTextAnchor084"/>Exercises</h1>
			<p>Mesozoic Eden is doing great. The dinosaurs are healthy and the guests are happy. Now that you have some new skills, let’s go ahead and perform slightly more <span class="No-Break">complicated tasks!</span></p>
			<ol>
				<li>The caretakers want to be able to keep track of dinosaur weights. It’s your task to write a program that calculates the average weight of two dinosaurs. This will help our team of nutritionists in planning the correct <span class="No-Break">food portions.</span></li>
				<li>Proper nutrition is essential for the health of our dinosaurs. The caretakers want to have a rough guideline of how much to feed a dinosaur. Write a program that determines the amount of food required for a dinosaur based on its weight. You can come up with the amount of food needed per weight unit of <span class="No-Break">the dinosaurs.</span></li>
				<li>For our park, we need to have a leap year checker. In our commitment to scientific accuracy, use the modulus operator to determine if the current year is a leap year. We want to make sure our calendar-themed exhibits are always up <span class="No-Break">to date.</span></li>
				<li>Create a program that checks whether the park’s maximum capacity has been reached. The program only needs to print true or false after the words “Max capacity reached:”. This is crucial in maintaining safety standards and ensuring a positive <span class="No-Break">visitor experience.</span></li>
				<li>Sometimes visitors want to compare dinosaurs’ ages. And we get it – this could be interesting for educational purposes. Write a program that calculates the age difference between <span class="No-Break">two dinosaurs.</span></li>
				<li>In Mesozoic Eden, we have a very strong safety-first policy. Write a program that checks whether the park’s safety rating is above a certain threshold. Maintaining a good safety rating is our <span class="No-Break">utmost priority.</span></li>
			</ol>
			<h1 id="_idParaDest-85"><a id="_idTextAnchor085"/>Project – Dino meal planner</h1>
			<p>As a zookeeper in Mesozoic Eden, the crucial tasks include planning the meals for our beloved dinosaurs. While we’re not using conditionals and loops yet, we can still calculate some <span class="No-Break">basic requirements!</span></p>
			<p>Develop a simple program to help the zookeepers plan the meal portions for different dinosaurs. The program should use the dinosaur’s weight to calculate how much food it needs to eat <span class="No-Break">per meal.</span></p>
			<p>If you need a bit more guidance, here’s how you can <span class="No-Break">do it:</span></p>
			<ul>
				<li>Declare variables for the dinosaur’s weight and the proportion of its weight it needs to eat per day. For instance, if a dinosaur needs to eat 5% of its body weight daily, and it weighs 2,000 kg, it would need to eat 100 kg <span class="No-Break">of food.</span></li>
				<li>Now, let’s say you feed the dinosaur twice a day. Declare a variable for the number of feedings and calculate how much food you need to serve per feeding. In this example, it would be 50 kg <span class="No-Break">per feeding.</span></li>
				<li>Print out the result in a meaningful way – for example, “Our 2,000 kg dinosaur needs to eat 100 kg daily, which means we need to serve 50 kg <span class="No-Break">per feeding.”</span></li>
			</ul>
			<h1 id="_idParaDest-86"><a id="_idTextAnchor086"/>Summary</h1>
			<p>In this chapter, we learned about how Java’s operators work and how they cooperate. In addition, we learned how to cast <span class="No-Break">in Java.</span></p>
			<p>Initially, we discussed two important properties relating to operators: precedence and associativity. We saw that precedence dictates how common terms are grouped. Associativity comes into play when the operators have the same order <span class="No-Break">of precedence.</span></p>
			<p>We then examined the operators themselves. We started by looking at unary operators, which have one operand such as the prefix/postfix increment/decrement operators, <strong class="source-inline">++</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">--</strong></span><span class="No-Break">.</span></p>
			<p>We then moved on to the arithmetic operators: <strong class="source-inline">+</strong>, <strong class="source-inline">-</strong>, <strong class="source-inline">*</strong>, <strong class="source-inline">/</strong>, and <strong class="source-inline">%</strong>. We noted that integer division truncates. In addition, we discussed that any math operations involving <strong class="source-inline">int</strong> types or smaller results in <strong class="source-inline">int</strong>. Lastly, we discussed in detail how the <strong class="source-inline">+</strong> operator works when one or both operands are strings. In these cases, a string append <span class="No-Break">is performed.</span></p>
			<p>Next, we discussed relational operators. The results of these operators are always boolean values and will be used when we construct conditional statements in <a href="B19793_04.xhtml#_idTextAnchor087"><span class="No-Break"><em class="italic">Chapter 4</em></span></a><span class="No-Break">.</span></p>
			<p>As Java cannot perform operations where the types are different, where possible, Java performs implicit promotion. This is where Java promotes the smaller type to the larger type somewhere in memory. This is Java’s way of invisibly continuing with <span class="No-Break">the operation.</span></p>
			<p>We then discussed the logical operators: <strong class="source-inline">&amp;&amp;</strong>, <strong class="source-inline">||</strong>, <strong class="source-inline">&amp;</strong>, <strong class="source-inline">|</strong>, and <strong class="source-inline">^</strong>. Truth tables were presented to aid in understanding. Both the logical <strong class="source-inline">&amp;&amp;</strong> and logical <strong class="source-inline">||</strong> operators are short-circuiting operators. Understanding this is important because the order of evaluation <span class="No-Break">trumps precedence.</span></p>
			<p>The bitwise operators, bitwise AND (<strong class="source-inline">&amp;</strong>) and bitwise OR (<strong class="source-inline">|</strong>), are similar except that in contrast to <strong class="source-inline">&amp;&amp;</strong> and <strong class="source-inline">||</strong>, both <strong class="source-inline">&amp;</strong> and <strong class="source-inline">|</strong> never short-circuit and can also work with <span class="No-Break">integral operands.</span></p>
			<p>The ternary operator takes three operands. It evaluates a boolean expression and assigns one of two values to a variable, depending on whether the boolean expression was <strong class="source-inline">true</strong> <span class="No-Break">or </span><span class="No-Break"><strong class="source-inline">false</strong></span><span class="No-Break">.</span></p>
			<p>Regarding operators, the last group we covered were the compound assignment operators, of which there is one for each <span class="No-Break">mathematical operator.</span></p>
			<p>In our discussion on casting, we covered both widening<a id="_idIndexMarker262"/> and narrowing. Widening is done in the background and is often called <em class="italic">implicit promotion</em>. There is no risk here as the type being promoted fits easily into the <span class="No-Break">target type.</span></p>
			<p>Narrowing is where the cast is required. This is because, given that you are going from a type that requires more storage space to a type that requires less, there is a potential loss <span class="No-Break">of data.</span></p>
			<p>Now that we know how to use operators, in the next chapter, we will move on to conditional statements, where operators are <span class="No-Break">commonly used.</span></p>
		</div>
	</body></html>