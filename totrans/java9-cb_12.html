<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Memory Management and Debugging</h1>
                </header>
            
            <article>
                
<p>This chapter deals with managing the memory of your Java application. Understanding the garbage collection process is crucial to developing memory-efficient applications. We will introduce you to the garbage collection algorithm being used in Java 9. Then, we will introduce you to some new features of Java 9, which help in advanced application diagnostics. We'll also show you how to manage the resources by using the new <em>try with resources</em> construct. Later, we'll show you the new stack walking API introduced in Java 9. Тhe following recipes will be covered:</p>
<ul>
<li>Understanding the G1 garbage collector</li>
<li>Unified logging for JVM</li>
<li>Using the new diagnostic commands for the JVM</li>
<li>Try with resources for better resource handling</li>
<li>Stack walking for improved debugging</li>
<li>Some best practices for better memory usage</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introduction</h1>
                </header>
            
            <article>
                
<p>Memory management is the process of memory allocation (for program execution) and memory reuse (after some of the allocated memory is not used anymore). In Java, this process happens automatically and is called <strong>Garbage Collection</strong> (<strong>GC</strong>). The effectiveness of GC affects two major application characteristics--responsiveness and throughput.</p>
<p><span>Responsiveness is measured by </span>how quickly an application responds (brings necessary data) to the request. For example, how quickly a website returns a page or how quickly a desktop application responds to an event. Naturally, the lower the response time, the better the user experience, which is the goal of design and implementation for many applications.</p>
<p>Throughput indicates the amount of work an application can do in a unit of time. For example, how many requests a web application can serve or how many transactions a database can support. The bigger the number, the more value the application can potentially generate and the greater number of users it can accommodate.</p>
<p>Not every application needs to have the minimal possible responsiveness and the maximum achievable throughput. An application may be an asynchronous submit-and-go-do-something-else, which does not require much user interaction. There may be a few potential application users too, so a lower than average throughput could be more than enough. Yet, there are applications that have high requirements to one or both of these characteristics and cannot tolerate long pauses imposed by the GC process.</p>
<p>GC, on the other hand, needs to stop any application execution to reassess the memory usage and to release it from data not used anymore. Such periods of GC activity are called stop-the-world. The longer they are, the quicker the GC does its job and the longer an application freeze lasts, which can eventually grow big enough to affect both the application responsiveness and throughput. If that is the case, the GC tuning and JVM optimization become important and require an understanding of the GC principles and its modern implementations.</p>
<p>Unfortunately, this step is often missed. Trying to improve <span>responsiveness and/or throughput, companies and individuals just add memory and other computing capacities, thus providing the originally small existing problem with the space to grow. The enlarged infrastructure, in addition to hardware and software costs, requires more people to maintain it and eventually justifies the building of a whole new organization dedicated to keeping up the system. By then, the problem reaches the scale of becoming virtually unsolvable and feeds on those who have created it by forcing them to do the routine--almost menial--work for the rest of their professional lives.</span></p>
<p>In this chapter, we will focus on <strong>Garbage-First</strong> (<strong>G1</strong>) garbage collector that is going to be the default one in Java 9. However, we'll also refer to a few other available GC implementations to contrast and explain some design decisions that have brought G1 to life. Besides, they might be more appropriate than G1 for some of the systems.</p>
<p>Memory organization and management are very specialized and complex areas of expertise in JVM development. This book is not intended to address the implementation details on such a level. Our focus is on those aspects of GC that can help an application developer to tune it for the application needs by setting the corresponding parameters of the JVM runtime.</p>
<p>There are two memory areas that are used by GC, heap and stack, which illustrate the main principle of any GC implementation. The first one is used by the JVM to allocate memory and store objects created by the program. When an object is created with the <kbd>new</kbd> keyword, it is allocated on the heap, and the reference to it is stored on the stack. The stack also stores primitive variables and references to heap objects that are used by the current method or thread. The stack operates in <strong>Last-In-First-Out</strong> (<strong>LIFO</strong>). The stack is much smaller than the heap, and only the GC reads it. </p>
<p>Here is a slightly simplistic, but good enough for our purpose, high-level view of the main activity of any GC: walking through objects in the heap and removing those that don’t have any references in the stack.  </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Understanding the G1 garbage collector</h1>
                </header>
            
            <article>
                
<p>The previous GC implementations include <strong>Serial GC</strong>, <strong>Parallel GC</strong>, and <strong>Concurrent Mark-Sweep</strong> (<strong>CMS</strong>) collector. They divide the heap into three sections: young generation, old or tenured generation, and humongous regions for holding the objects that are 50% the size of a standard region or larger. The young generation contains most of the newly created objects; this is the most dynamic area because a majority of the objects are short-lived and soon (as they age) become eligible for collection. The term age refers to the number of collection cycles the object has survived. The young generation has three collection cycles: an <em>Eden space</em> and two survivor spaces, such as survivor 0 (<em>S0</em>) and survivor 1 (<em>S1</em>). The objects are moved through them (according to their age and some other characteristics) until they are eventually discarded or placed in the old generation.</p>
<p>The old generation contains objects that are older than a certain age. This area is bigger than the young generation, and because of this, the garbage collection here is more expensive and happens not as often as in the young generation.</p>
<p>The permanent generation contains metadata that describes the classes and methods used in applications. It also stores strings, library classes, and methods. </p>
<p>When the JVM starts, the heap is empty and then the objects are pushed into Eden. When it is filling up, a minor GC process starts. It removes the unreferenced and circular referred objects and moves the others to the <em>S0</em> area.</p>
<p>First, any new object is allocated to the Eden space. Both the survivor spaces start out empty. When the Eden space fills up, a minor garbage collection is triggered. Referenced objects are moved to the S0 space. Unreferenced objects are deleted.</p>
<p>The next minor GC process migrates the referenced objects to <em>S1</em> and increments the age of those that survived the previous minor collection. After all the surviving objects (of different ages) are moved to <em>S1</em>, both <em>S0</em> and Eden become empty. </p>
<p>In the next minor collection, <em>S0</em> and <em>S1</em> switch their roles. The referenced objects are moved from Eden to <em>S1</em> and <em>S1</em> to <em>S0</em>. </p>
<p>In each of the minor collections, the objects that have reached a certain age are moved to the old generation. As we mentioned earlier, the old generation is checked eventually (after several minor collections), the unreferenced objects are removed from there, and the memory is defragmented. This cleaning of the old generation is considered a major collection.</p>
<p>The <span>permanent generation</span> is cleaned at different times by different GC algorithms.</p>
<p>The G1 GC does it somewhat differently. It divides the heap into equal-sized regions and assigns each of them one of the same roles--Eden, survivor, or old--but changes the number of regions with the same role dynamically, depending on the need. It makes the memory cleaning process and the memory defragmentation more predictable. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>The serial GC cleans the young and the old generations in the same cycle (serially, thus the name). During the task, it stops the world. That is why it is used for non-server applications with one CPU and a heap size of a few hundred MB. </p>
<p>The parallel GC works in parallel on all available cores, although the number of threads can be configured. It also stops the world and is appropriate only for applications that can tolerate long freezing times.</p>
<p>The CMS collector was designed to address this very issue of long pauses. It does it at the expense of not defragmenting the old generation and doing some analysis in parallel to the application execution (typically using 25% of CPU). The collection of old generation starts when it is 68% full (by default, but this value can be configured). </p>
<p>The G1 GC algorithm is similar to the CMS collector. First, it concurrently identifies all the referenced objects in the heap and marks them correspondingly. Then it collects the emptiest regions first, thus releasing a lot of free space. That's why it is called <em>Garbage-First</em>. Because it uses many small dedicated regions, it has a better chance in predicting the amount of time it needs to clean one of them and in fitting a user-defined pause time (G1 may exceed it occasionally, but it is pretty close most of the times).  </p>
<p>The main beneficiaries of G1 are applications that require large heaps (6 GB or more) and that do not tolerate long pauses (0.5 sec or less). If an application encounters an issue of too many and/or too long pauses, it can benefit from switching from the CMS or parallel GC (especially the parallel GC of the old generation) to the G1 GC. If that is not the case, switching to the G1 collector is not a requirement for using JDK 9.</p>
<p>The G1 GC starts with the young generation collection using stop-the-world pauses for evacuation (moving objects inside the young generation and out to the old generation). After the occupancy of the old generation reaches a certain threshold, it is collected too. The collection of some of the objects in the old generation is done concurrently and some objects are collected using stop-the-world pauses. The steps include the following:</p>
<ul>
<li>The initial marking of the survivor regions (root regions), which may have references to objects in the old generation, done using <span>stop-the-world pauses</span></li>
<li><span>The scanning</span> of survivor regions for references to the old generation, done concurrently while the application continues to run</li>
<li>The concurrent marking of live objects over the entire heap<span>, done concurrently while the application continues to run</span></li>
<li>The remark step completes the <span>marking of live objects, done using stop-the-world pauses</span></li>
<li>The cleanup process calculates the age of live objects, frees the regions (using stop-the-world pauses), and returns them to the free list (concurrently)</li>
</ul>
<p><span>The preceding sequence might be interspersed with young generation evacuations because most of the objects are short-lived and it is easier to free a lot of memory by scanning the young generation more often.</span></p>
<p><span>There is also a mixed phase, when G1 collects the regions already marked as mostly garbage in both the young and old generations, and h</span>umongous allocation, when large objects are moved to or evacuated from humongous regions.</p>
<p>There are a few occasions when full GC is performed, using stop-the-world pauses:</p>
<ul>
<li><strong>Concurrent failure</strong>: This happens if the old generation gets full during the marking phase</li>
<li><strong>Promotion failure</strong>: This happens if the old generation runs out of space during the mixed phase</li>
<li><strong>Evacuation failure</strong>: This happens when the collector cannot promote objects to the survivor space and the old generation</li>
<li><strong>Humongous allocation</strong>: This happens when an application tries to allocate a very big object</li>
</ul>
<p>If tuned properly, your applications should avoid full GC.</p>
<p>To help with GC tuning, the JVM documentation describes <em>ergonomics</em>--the process by which "<em>the JVM and garbage collection tuning, such as behavior-based tuning, improve application performance. The JVM provides platform-dependent default selections for the garbage collector, heap size, and runtime compiler. These selections match the needs of different types of applications while requiring less command-line tuning. In addition, behavior-based tuning dynamically tunes the sizes of the heap to meet a specified behavior of the application</em>" <span>(from the JVM documentation).</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>To see how GC works, write the following program:</li>
</ol>
<pre><span>        package com.packt.cookbook.ch12_memory;<br/>        import java.util.ArrayList;<br/>        import java.util.List;<br/>        import java.util.stream.IntStream;<br/>        public class </span>Chapter12Memory {<br/>          <span>public static void </span><span>main</span>(String... args) {<br/><span>            int </span>max = <span>99888999</span><span>;<br/></span><span>            </span>System.<span>out</span>.println(<span>"Chapter12Memory.main() for " <br/></span>                                + max + <span>" is running..."</span>)<span>;<br/></span><span>            </span>List&lt;AnObject&gt; list = <span>new </span>ArrayList&lt;&gt;()<span>;<br/></span><span>            </span>IntStream.<span>range</span>(<span>0</span><span>, </span>max)<br/>                     .forEach(i -&gt; <span>list</span>.add(<span>new </span>AnObject(i)))<span>;</span><span><br/></span><span>          </span>}<br/>          <span>private static class </span>AnObject {<br/>            <span>private int </span><span>prop</span><span>;<br/></span><span>            </span><span>AnObject</span>(<span>int </span>i){ <span>this</span>.<span>prop </span>= i<span>; </span>}<br/>          }<br/>        }</pre>
<p style="padding-left: 60px">As you can see, it creates 99,888,999 objects and adds them to the <kbd>List&lt;AnObject&gt; list</kbd> collection. You might tune it by decreasing the maximum number of objects (<kbd>max</kbd>) to match the configuration of your computer.</p>
<ol start="2">
<li>The G1 GC is the default collector in Java 9, so you don't have to set anything if it is good enough for your application. <span>Nevertheless, you can explicitly enable G1 by providing</span> <kbd>-XX:+UseG1GC</kbd> <span>on the command line </span>(run in the same folder, where the executable <kbd>.jar</kbd> file is located, which contains the <kbd>com.packt.cookbook.ch12_memory.Chapter12Memory</kbd> class with the <kbd>main()</kbd> method): </li>
</ol>
<pre><strong>      java -XX:+UseG1GC -cp ./cookbook-1.0.jar<br/>      com.packt.cookbook.ch12_memory.Chapter12Memory</strong></pre>
<div class="packt_infobox">Note that we assume you can build an executable <kbd>.jar</kbd> file and understand the basic Java execution command. If not, please refer to the JVM documentation. </div>
<p style="padding-left: 60px">Other available GCs can be used by setting one of the following options:</p>
<ul>
<li style="list-style-type: none">
<ul>
<li><kbd>-XX:+UseSerialGC</kbd> for using a Serial collector.</li>
<li><kbd>-XX:+UseParallelGC</kbd> for using parallel collector with parallel compaction (which enables the parallel collector to perform major collections in parallel). Without parallel compaction, major collections are performed using a single thread, which can significantly limit the scalability. Parallel compaction is disabled by the <kbd>-XX:+UseParallelOldGC</kbd> option.</li>
<li><kbd>-XX:+UseConcMarkSweepGC</kbd> for using the CMS collector.</li>
</ul>
</li>
</ul>
<ol start="3">
<li>To see the log messages of GC, set <kbd><span>-Xlog:gc</span></kbd>. You can also use the Unix utility, <kbd>time</kbd>, to measure the time it took to do the job (the utility publishes the last three lines of the output, so you do not need to use it if you cannot or do not want to do it): </li>
</ol>
<pre><strong>      time java -Xlog:gc -cp ./cookbook-1.0.jar<br/>      com.packt.cookbook.ch12_memory.Chapter12Memory</strong></pre>
<ol start="4">
<li>Run the preceding command, the result may look as follows (the actual values may be different on your computer):</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img height="150" width="555" class="image-border" src="assets/cfe1bbe4-a376-451b-8a77-0f84e2042647.png"/></div>
<p style="padding-left: 60px">You can see that the GC went through most of the steps we have described. It has started with collecting the young generation. Then, when the <kbd>List&lt;AnObject&gt; list</kbd> object (see the preceding code) becomes too big (more than 50% of a young generation region), the memory for it is allocated in the <em>humongous</em> region. You can also see the initial mark step and the following remark and other steps described earlier.</p>
<p style="padding-left: 60px">Each line starts with an accumulative time amount (in seconds) the JVM was running for and ends with the time (in milliseconds) that every step took. At the bottom of the screenshot we see three lines printed by the <kbd>time</kbd> utility:</p>
<ul>
<li style="list-style-type: none">
<ul>
<li><kbd>real</kbd> is the amount of wall clock time spent--all the time elapsed (should align with the first column of the JVM uptime value) since the command was run</li>
<li><kbd>user</kbd><span> </span>is the amount of time all the CPUs spent in the user-mode code (outside the kernel) within the process; it is bigger because GC worked concurrently with the application</li>
<li><kbd>sys</kbd> is the amount of time the CPU spent in the kernel within the process</li>
<li><kbd>user</kbd>+<kbd>sys</kbd> is the amount of CPU time the process used</li>
</ul>
</li>
</ul>
<ol start="5">
<li>Set the <kbd>-XX:+PrintGCDetails</kbd> option (or just add a <kbd>*</kbd> to the log option<span> </span><kbd><span>-Xlog:gc*</span></kbd><span><span>) to see more details about GC activity (in the following screenshot, we provide only the beginning of the log related to GC step 0):</span></span></li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img height="229" width="521" class="image-border" src="assets/4548fcf5-7594-422b-98d0-4d6f6570523b.png"/></div>
<p style="padding-left: 60px">Now the log has more than a dozen entries for each of the GC steps and ends up with logging the <kbd>User</kbd>, <kbd>Sys</kbd>, and <kbd>Real</kbd> amount of time (the amounts accumulated by the <kbd>time</kbd> utility) each step took. You can modify the program (by adding more short-lived objects, for example) and see how the GC activity changes.</p>
<ol start="6">
<li>Get even more information with the<span> </span><kbd><span>-Xlog:gc*=debug</span></kbd><span> option (the following is a fragment only):</span></li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img height="186" width="609" src="assets/7e2430e5-bac7-4cdc-9758-b1f48116cd4c.png"/></div>
<p>So, it is up to you to choose how much info you need for the analysis.</p>
<p>We will discuss more details of the logging format and other log options in the following recipe, <em>Unified logging for JVM</em>, of this chapter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>As we had mentioned earlier, the G1 GC uses default ergonomic values that probably would be good enough for most applications. Here is the list of the most important ones (<kbd>&lt;ergo&gt;</kbd> means that the actual value is determined ergonomically depending on the environment):</p>
<ul>
<li><kbd>-XX:MaxGCPauseMillis=200</kbd> holds the value for the maximum pause time</li>
<li><kbd>-XX:GCPauseTimeInterval=<span>&lt;ergo&gt;</span></kbd> holds the maximum pause time between GC steps (not set by default, allowing G1 to perform garbage collections back to back if need be)</li>
<li><kbd>-XX:ParallelGCThreads=<span>&lt;ergo&gt;</span></kbd> holds the maximum number of threads used for parallel work during garbage collection pauses (by default, derived from the number of available threads; if the number of CPU threads available to the process is less than or equal to 8, it uses this number; otherwise, it adds five-eighths of the threads greater than 8 to the final number of threads)</li>
<li><kbd>-XX:ConcGCThreads=<span>&lt;ergo&gt;</span></kbd> holds the maximum number of threads used for concurrent work (set by default as <kbd>-XX:ParallelGCThreads</kbd> divided by 4).</li>
<li><kbd>-XX:+G1UseAdaptiveIHOP</kbd> indicates that the initiating heap occupancy should be adaptive</li>
<li><kbd>-XX:InitiatingHeapOccupancyPercent=45</kbd> sets the first few collection cycles; G1 will use an occupancy of 45% of the old generation as the mark start threshold</li>
<li><kbd>-XX:G1HeapRegionSize=<span>&lt;ergo&gt;</span></kbd> holds the heap region size based on the initial and maximum heap sizes (by default, because heap contains roughly 2048 heap regions, the size of a heap region can vary from 1 to 32 MB and must be a power of 2)</li>
<li><kbd>-XX:G1NewSizePercent=5</kbd> and<kbd>-XX:XX:G1MaxNewSizePercent=60</kbd> define the size of the young generation in total, which varies between these two values as percentages of the current JVM heap in use</li>
<li><kbd>-XX:G1HeapWastePercent=5</kbd> holds the allowed unreclaimed space in the collection set candidates as a percentage (G1 stops the space reclamation if the free space in the collection set candidates is lower than that)</li>
<li><kbd>-XX:G1MixedGCCountTarget=8</kbd> holds the expected length of the space-reclamation phase in a number of collections)</li>
<li><kbd>-XX:G1MixedGCLiveThresholdPercent=85</kbd> holds the percentage of the live object occupancy of the old generation regions, after which a region won't to be collected in this space-reclamation phase</li>
</ul>
<p>In general, the G1 goals in the default configuration are <em>to provide relatively small, uniform pauses at high throughput </em><span>(from the G1 documentation).</span> If these default settings do not fit your application, you can change the <span>pause time</span> (using <kbd>-XX:MaxGCPauseMillis</kbd>) and the maximum Java heap size (using the <kbd>-Xmx</kbd> option). Note, though, that the actual pause time will not be an exact match at runtime, but G1 will try its best to meet the goal. </p>
<p>If you would like to increase the throughput, decrease the pause time goal or request a larger heap. To increase responsiveness, change the pause time value. Note, though, that the limiting of the young generation size (using the <kbd>-Xmn</kbd>, <kbd>-XX:NewRatio</kbd><span>, or</span> other options) can impede the pause time control because <em>the young generation size is the main means for G1 to allow it to meet the pause time </em>(from the G1 documentation).</p>
<p>One of the first possible causes of poor performance can be full GC in the presence of pause full (allocation failure) in the log. It usually happens when too many objects are created in a quick succession (and cannot be collected quickly enough) or many large (humongous) objects cannot be allocated in a timely manner. There are several recommended ways to handle this condition: </p>
<ul>
<li>In the case of an excessive number of humongous objects, try to reduce their count by increasing the region size, using the <kbd>-XX:G1HeapRegionSize</kbd> option (the currently selected heap region size is printed at the beginning of the log).</li>
<li>Increase the size of the heap.</li>
<li>Increase the number of concurrent marking threads by setting<span> </span><kbd>-XX:ConcGCThreads</kbd>.</li>
<li>Facilitate the beginning of marking earlier (using the fact that G1 makes the decisions based on earlier application behavior). Increase the buffer used in an adaptive IHOP calculation by modifying <kbd>-XX:G1ReservePercent</kbd>, or disable the adaptive calculation of the IHOP by setting it manually using <kbd>-XX:-G1UseAdaptiveIHOP</kbd> and <kbd>-XX:InitiatingHeapOccupancyPercent</kbd>.</li>
</ul>
<p>Only after addressing full GC can one start tuning the JVM for better responsiveness and/or throughput. The JVM documentation identifies the following cases for responsiveness tuning:</p>
<ul>
<li>Unusual system or real-time usage </li>
<li>Reference processing takes too long</li>
<li>Young-only collections take too long</li>
<li>Mixed collections take too long</li>
<li>High update RS and scan RS times</li>
</ul>
<p>Better throughput can be achieved by decreasing the overall pause times and the frequency of the pauses. Refer to the JVM documentation for the identification and recommendations of mitigating the issues.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<p>Do refer to the following recipes in this chapter:</p>
<ul>
<li>Unified logging for JVM</li>
<li>Using the new diagnostic commands for the JVM</li>
<li>Some best practices for better memory usage</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Unified logging for JVM</h1>
                </header>
            
            <article>
                
<p>Java 9 implemented <em>JEP 158: Unified JVM Logging</em>, which requested to <em>introduce a common logging system for all the components of the JVM.</em> The main components of JVM include the following:</p>
<ul>
<li>Class loader</li>
<li>Runtime data area
<ul>
<li>Stack area</li>
<li>Method area</li>
<li>Heap area</li>
<li>PC registers</li>
<li>Native method stack</li>
</ul>
</li>
<li>Execution engine
<ul>
<li>Interpreter</li>
<li>The JIT compiler</li>
<li>Garbage collection</li>
<li>Native method interface JNI</li>
<li>Native method library</li>
</ul>
</li>
</ul>
<p>The log message of all these components can now be captured and analyzed using unified logging, turned on by the <kbd>-Xlog</kbd> option.</p>
<p>The main features of the new logging system are as follows:</p>
<ul>
<li>Usage of the log levels: <kbd>trace</kbd>, <kbd>debug</kbd>, <kbd>info</kbd>, <kbd>warning</kbd>, <kbd>error</kbd></li>
<li>Message tags that identify the JVM component, action, or message of a specific interest</li>
<li>Three output types: <kbd>stdout</kbd>, <kbd>stderr</kbd>, and <kbd>file</kbd></li>
<li>The enforcement of the one-message-per-line limit</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>To see all the logging possibilities at a glance, you can run the following command:</p>
<pre><strong>java -Xlog:help</strong></pre>
<p>Here is the output:</p>
<div class="CDPAlignCenter CDPAlign"><img height="413" width="684" class="image-border" src="assets/258604c0-9b0a-475b-9910-ef90d7eb1de8.png"/></div>
<p>As you can see, the format of the <kbd>-Xlog</kbd> option is defined as follows:</p>
<pre><strong>-Xlog[:[what][:[output][:[decorators][:output-options]]]]</strong></pre>
<p>Let's explain the option in detail:</p>
<ul>
<li>The <kbd>what</kbd> is a combination of tags and levels of the form, <kbd>tag1[+tag2...][*][=level][,...]</kbd>. We have already demonstrated how this construct works when we used the <kbd>gc</kbd> tag in the <kbd><span>-Xlog:gc*=debug</span></kbd><span> option. The </span>wildcard (<kbd>*</kbd>) indicates that you'd like to see all the messages that have the <kbd>gc</kbd> tag (maybe among other tags). An absence of the<span> </span><kbd><span>-Xlog:gc=debug</span></kbd><span> wildcard indicates that you would like to see messages marked by one tag (<kbd>gc</kbd>, in this case) only. If only <kbd>-Xlog</kbd> is used, the log will show all the messages at the <kbd>info</kbd> level.</span></li>
<li>The <kbd>output</kbd> sets the type of output (the default is <kbd>stdout</kbd>).</li>
<li>The <kbd>decorators</kbd> indicate what will be placed at the beginning of each line of the log (before the actual log message comes from a component). Default decorators are <kbd>uptime</kbd>, <kbd>level</kbd>, and <kbd>tags</kbd>, each included in square brackets.</li>
<li>The <kbd>output_options</kbd> may include <kbd>filecount=file count</kbd> and/or <kbd>filesize=file size with optional K, M or G suffix</kbd>.</li>
</ul>
<p>To summarize, the default log configuration is as follows:</p>
<pre><strong>-Xlog:all=info:stdout:uptime,level,tags</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Let's run some of the log settings, which are as follows:</p>
<ol>
<li>Run the following command:</li>
</ol>
<pre><strong>      java -Xlog:cpu -cp ./cookbook-1.0.jar<br/>      com.packt.cookbook.ch12_memory.Chapter12Memory</strong></pre>
<p style="padding-left: 60px">There are no messages because the JVM does not log messages with the <kbd>cpu</kbd> tag only. The tag is used in combination with other tags.</p>
<ol start="2">
<li>Add a <kbd>*</kbd> sign and run the command again:</li>
</ol>
<pre><strong>      java -Xlog:cpu* -cp ./cookbook-1.0.jar<br/>      com.packt.cookbook.ch12_memory.Chapter12Memory</strong></pre>
<p style="padding-left: 60px">The result will look as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img height="139" width="352" class="image-border" src="assets/16f1ff6c-ca64-4b7f-82ac-69c0d9b95fda.png"/></div>
<p style="padding-left: 60px">As you can see, the tag <kbd>cpu</kbd> brings only messages that log time it took a garbage collection task to execute. Even if we set the log level to <kbd>trace</kbd> or <kbd>debug</kbd> (<kbd><span>-Xlog:cpu*=debug</span></kbd><span>, for example), no other messages will be shown.</span></p>
<ol start="3">
<li class="mce-root">Now run the command with the <kbd>heap</kbd> tag:</li>
</ol>
<pre><strong>      java -Xlog:heap* -cp ./cookbook-1.0.jar<br/>      com.packt.cookbook.ch12_memory.Chapter12Memory</strong></pre>
<p style="padding-left: 60px">You will only get heap-related messages:</p>
<div class="CDPAlignCenter CDPAlign"><img height="117" width="349" class="image-border" src="assets/4d03c1fc-819c-4465-9633-831172e782c5.png"/></div>
<p style="padding-left: 60px">But let's look closer at the first line. It starts with three decorators--<kbd>uptime</kbd>, <kbd>log</kbd> level, and <kbd>tags</kbd>--and then with the message itself, which starts with the collection cycle number (0 in this case) and the information that the number of Eden regions dropped from 24 to 0 (and their count now is 9). It happened because (as we see in the next line) the count of survivor regions grew from 0 to 3 and the count of the old generation (the third line) grew to 18, while the count of humongous regions (23) did not change. These are all the heap-related messages in the first collection cycle. Then, the second collection cycle starts. </p>
<ol start="4">
<li>Add the <kbd>cpu</kbd> tag again and run:</li>
</ol>
<pre><strong>      java -Xlog:heap*,cpu* -cp ./cookbook-1.0.jar<br/>      com.packt.cookbook.ch12_memory.Chapter12Memory</strong></pre>
<p style="padding-left: 60px"> As you can see, the <kbd>cpu</kbd> message shows how long each cycle took:</p>
<div class="CDPAlignCenter CDPAlign"><img height="110" width="458" class="image-border" src="assets/5fd27d43-9a39-4bcb-bcb3-c63004018638.png"/></div>
<ol start="5">
<li>Try and use two tags combined via sign <kbd>+</kbd> <span>(</span><kbd><span>-Xlog:gc+heap</span></kbd><span>, for example). It brings up only the messages that have both tags (similar to the binary <kbd>AND</kbd> operation). Notice that a wildcard will not work together with the <kbd>+</kbd> sign (<kbd>-Xlog:gc*+heap</kbd> , for example, does not work). </span></li>
<li>You can also select the output type and decorators. In practice, the decorator level does not seem very informative and can be easily omitted by explicitly listing only the decorators that are needed. Consider the following example:</li>
</ol>
<pre><strong>      java -Xlog:heap*,cpu*::uptime,tags -cp ./cookbook-1.0.jar<br/>      com.packt.cookbook.ch12_memory.Chapter12Memory</strong></pre>
<p style="padding-left: 60px">Note how the two colons (<kbd>:</kbd>) were inserted to preserve the default setting of the output type. We could also show it explicitly:</p>
<pre><strong>      java -Xlog:heap*,cpu*:stdout:uptime,tags -cp ./cookbook-1.0.jar<br/>      com.packt.cookbook.ch12_memory.Chapter12Memory</strong></pre>
<p style="padding-left: 60px">To remove any decoration, one can set them to <kbd>none</kbd>:</p>
<pre><strong>      java -Xlog:heap*,cpu*::none -cp ./cookbook-1.0.jar<br/>      com.packt.cookbook.ch12_memory.Chapter12Memory</strong></pre>
<p>The most useful aspect of a new logging system is tag selection. It allows a better analysis of the memory evolution of each JVM component and its subsystems or to find the performance bottleneck, analyzing the time spent in each collection phase--both are critical for the JVM and application tuning.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<p>Do refer to the other recipes of this chapter:</p>
<ul>
<li>Using the new diagnostic commands for the JVM</li>
<li>Stack walking for improved debugging</li>
<li>Some best practices for better memory usage</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using the new diagnostic commands for the JVM</h1>
                </header>
            
            <article>
                
<p>If you open the <kbd>bin</kbd> folder of the Java installation, you can find there quite a few command-line utilities that can <span>be used to diagnose issues and monitor an application deployed with the <strong>Java Runtime Environment</strong> (<strong>JRE</strong>). They </span>use different mechanisms to get the data they report. The mechanisms are specific to the <strong>Virtual Machine</strong> (<strong>VM</strong>) implementation, operating systems, and release. Typically, only a subset of the tools is applicable to a given issue at a particular time.</p>
<p>In this recipe, we will focus on the new diagnostic commands introduced in Java 9, some of them listed in <em>JEP 228: Add More Diagnostic Commands</em> (the actual command names are slightly different than in JEP). The new diagnostic commands were implemented as commands of the command-line utility, <kbd>jcmd</kbd>. You can find this utility in the same <kbd>bin</kbd> folder of the Java installation and can invoke it (if this folder is on the path) just by typing<span> </span><kbd>jcmd</kbd><span> on the command prompt.</span></p>
<p>If you do type it and there is no Java process currently running on the machine, you will get back only one line, which looks as follows:</p>
<pre><strong>87863 jdk.jcmd/sun.tools.jcmd.JCmd</strong> </pre>
<p>It shows that only one Java process is currently running (the <kbd>jcmd</kbd> utility itself) and it has the <strong>process identifier</strong> (<strong>PID</strong>) 87863 (which will be different with each run).</p>
<p>Let's run another Java program, for example:</p>
<pre><strong>java -cp ./cookbook-1.0.jar com.packt.cookbook.ch12_memory.Chapter12Memory</strong></pre>
<p>The output of <kbd>jcmd</kbd><span> </span>will show (with different PIDs) the following:</p>
<pre><strong>87864 jdk.jcmd/sun.tools.jcmd.JCmd </strong><br/><strong>87785 com.packt.cookbook.ch12_memory.Chapter12Memory</strong></pre>
<p>As you can see, if entered without any options, the <kbd>jcmd</kbd><span> </span>utility reports the PIDs of all the currently running Java processes. After getting the PID, you can then use <kbd>jcmd</kbd><span> to </span>request data from the JVM that runs the process:</p>
<pre><strong>jcmd 88749 VM.version</strong> </pre>
<p>Alternatively, you can avoid using PID (and calling <kbd>jcmd</kbd><span> </span>without parameters) by referring to the process by the main class of the application:</p>
<pre><strong>jcmd Chapter12Memory VM.version</strong></pre>
<p>You can read the JVM documentation for more details about the <kbd>jcmd</kbd><span> </span>utility and how to use it. In this recipe, we will focus only on the new diagnostic commands that came with Java 9. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Get the full list of the available <kbd>jcmd</kbd><span> </span>commands by running the following line:</li>
</ol>
<pre><strong>      jcmd PID/main-class-name help</strong></pre>
<p style="padding-left: 60px">Instead of <kbd>PID/main-class</kbd>, put the process identifier or the main class name. The list is specific to the JVM, so the command requests the data from the specific process.</p>
<ol start="2">
<li>If you can, compile the same class with JDK 8 and with JDK 9 and run the preceding command for each of the JSK versions. This way, you can compare the lists and see that JDK 9 introduced the following new <kbd>jcmd</kbd><span> </span>commands:</li>
</ol>
<ul>
<li style="list-style-type: none">
<ul>
<li><kbd>Compiler.queue</kbd>: This prints the methods queued for compilation with either C1 or C2 (separate queues)</li>
<li><kbd>Compiler.codelist</kbd>: This prints n-methods (compiled) with full signature, address range, and state (alive, non-entrant, and zombie) and allows the selection of printing to <kbd>stdout</kbd> , a file, XML, or text printout</li>
<li><kbd>Compiler.codecache</kbd>: This prints the content of the code cache, where the JIT compiler stores the generated native code to improve performance</li>
<li><kbd>Compiler.directives_add file</kbd>: This adds compiler directives from a file to the top of the directives stack</li>
<li><kbd>Compiler.directives_clear</kbd>: This clears the compiler directives stack (leaves the default directives only)</li>
<li><kbd>Compiler.directives_print</kbd>: This prints all the directives on the compiler directives stack from top to bottom</li>
<li><kbd>Compiler.directives_remove</kbd>: This removes the top directive from the compiler directives stack</li>
<li><kbd>GC.heap_info</kbd>: This prints the current heap parameters and status</li>
<li><kbd>GC.finalizer_info</kbd>: This shows the status of the finalizer thread, which collects objects with a finalizer (that is, a <kbd>finalize()</kbd> method)</li>
<li><kbd>JFR.configure</kbd>: This allows configuring the Java Flight Recorder</li>
<li><kbd>JVMTI.data_dump</kbd>: This prints the Java Virtual Machine Tool Interface<span> data dump</span></li>
<li><kbd>JVMTI.agent_load</kbd>: This loads (attaches) the Java Virtual Machine Tool Interface<span> agent</span></li>
<li><kbd>ManagementAgent.status</kbd>: This prints the status of the <span>remote JMX agent</span></li>
<li><kbd>Thread.print</kbd>: This prints all the threads with stack traces</li>
<li><kbd>VM.log [option]</kbd>: This allows setting the JVM log configuration (which we described in the previous recipe) at runtime, after the JVM has started (the availability can be seen by using <kbd>VM.log list</kbd>)</li>
<li><kbd>VM.info</kbd>: This prints the unified JVM info (version and configuration), a list of all threads and their state (without thread dump and heap dump), heap summary, JVM internal events (GC, JIT, safepoint, and so on), memory map with loaded native libraries, VM arguments and environment variables, and details of the operation system and hardware</li>
<li><kbd>VM.dynlibs</kbd>: This prints information about dynamic libraries</li>
<li><kbd>VM.set_flag</kbd>: This allows setting the JVM <em>writable</em> (also called <em>manageable</em>) flags (see the JVM documentation for a list of the flags)</li>
<li><kbd>VM.stringtable</kbd> and <span><kbd>VM.symboltable</kbd></span>: These p<span><span>rint all UTF-8 string constants</span></span></li>
<li><kbd>VM.class_hierarchy [full-class-name]</kbd>: This prints all the loaded classes or just a specified class hierarchy</li>
<li><kbd>VM.classloader_stats</kbd>: This prints information about the classloader</li>
<li><kbd>VM.print_touched_methods</kbd>: This prints all the methods that have been touched at runtime</li>
</ul>
</li>
</ul>
<p>As you can see, these new commands belong to several groups, denoted by the prefix compiler, <strong>garbage collector</strong> (<strong>GC</strong>), <strong>Java Flight Recorder</strong> (<strong>JFR</strong>), <strong>Java Virtual Machine Tool Interface</strong> (<strong>JVMTI</strong>),  <strong>Management Agent</strong> (related to remote JMX agent), thread, and VM. In this book, we do not have enough space to go through each command in detail. We will only demonstrate the usage of a few most practical ones.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>To get help for the <kbd>jcmd</kbd> utility, run the following command:</p>
<pre><strong>jcmd -h</strong> </pre>
<p>Here is the result of the command:</p>
<div class="CDPAlignCenter CDPAlign"><img height="178" width="364" class="image-border" src="assets/e7685cf9-19f1-4481-89a9-bc91acfa45bb.png"/></div>
<p>It tells us that the commands can also be read from the file specified after <kbd>-f</kbd> and that there is a <kbd>PerfCounter.print</kbd> command, which prints all the performance counters (statistics) of the process.</p>
<p> Let's run the following command:</p>
<pre><strong>jcmd Chapter12Memory GC.heap_info</strong></pre>
<p>The output may look as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img height="59" width="498" class="image-border" src="assets/771a97b3-6d9b-47bd-abc0-f7646c33df72.png"/></div>
<p>It shows the total heap size and how much of it was used, the size of a region in the young generation and how many regions are allocated, and the parameters of <kbd>Metaspace</kbd> and <kbd>class space</kbd>.</p>
<p>The following command is very helpful in case you are looking for runaway threads or would like to know what else is going on behind the scenes:</p>
<pre><strong>jcmd Chapter12Memory Thread.print</strong></pre>
<p>Here is a fragment of the possible output:</p>
<div class="CDPAlignCenter CDPAlign"><img height="132" width="571" class="image-border" src="assets/12ccab5c-ce62-486b-836a-46a9e2d45970.png"/></div>
<p>The following command is probably used most often, as it produces a wealth of information about the hardware, the JVM process as a whole, and the current state of its components:</p>
<pre><strong>jcmd Chapter12Memory VM.info</strong></pre>
<p>It starts with a summary, as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img height="147" width="526" class="image-border" src="assets/07ee898d-cf7c-497d-a978-d155e6463417.png"/></div>
<p>Then the general process description follows:</p>
<div class="CDPAlignCenter CDPAlign"><img height="98" width="519" class="image-border" src="assets/b42a94c1-15af-4c1c-bdc0-8a8d9d6bca9d.png"/></div>
<p>Then come the details of the heap (this is only a tiny fragment of it):</p>
<div class="CDPAlignCenter CDPAlign"><img height="144" width="544" src="assets/37456028-8bd0-4b9b-bdb4-21b7724e6d9a.png"/></div>
<p>It then prints the compilation events, GC heap history, deoptimization events, internal exceptions, events, dynamic libraries, logging options, environment variables, VM arguments, and many parameters of the system running the process. </p>
<p>The <kbd>jcmd</kbd> commands give a deep insight into the JVM process, which helps us debug and tune the process for best performance and optimal resource usage.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<p>Do refer to the other recipes of this chapter:</p>
<ul>
<li>Stack walking for improved debugging</li>
<li>Some best practices for better memory usage</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Try with resources for better resource handling</h1>
                </header>
            
            <article>
                
<p>Managing resources is important. Here is an excerpt from the JDK 7 documentation:</p>
<div class="packt_quote">"The typical Java application manipulates several types of resources such as files, streams, sockets, and database connections. Such resources must be handled with great care, because they acquire system resources for their operations. Thus, you need to ensure that they get freed even in case of errors. Indeed, incorrect resource management is a common source of failures in production applications, with the usual pitfalls being database connections and file descriptors remaining opened after an exception has occurred somewhere else in the code. This leads to application servers being frequently restarted when resource exhaustion occurs, because operating systems and server applications generally have an upper-bound limit for resources."</div>
<p>The phrase <em>because they acquire system resources for their operations</em> is the key. It means that mishandling (not releasing) the resources can exhaust the system's capability to operate. That's why, in JDK 7  the <em>try-with-resources</em> statement was introduced and we used it in the examples of <a href="41632f15-3abe-4f59-8ce9-009aacfbe1cf.xhtml">Chapter 6</a>, <em>Database Programming</em>:</p>
<pre><span>try </span>(Connection conn = <span>getDbConnection</span>()){<br/>  <span>try </span>(Statement st = <span>createStatement</span>(conn)) {<br/>    st.execute(sql)<span>;<br/></span><span>  </span>}<br/>} <span>catch </span>(Exception ex) {<br/>  ex.printStackTrace()<span>;<br/></span>}</pre>
<p>Another variation of the same statement is to include the acquisition of both the resources into the same <kbd>try</kbd> block:</p>
<pre><span>try </span>(Connection conn = <span>getDbConnection</span>()<span>;<br/></span>Statement st = <span>createStatement</span>(conn)) {<br/>  st.execute(sql)<span>;<br/></span>} <span>catch </span>(Exception ex) {<br/>  ex.printStackTrace()<span>;<br/></span>}</pre>
<p>As a reminder, we used the <kbd>getDbConnection()</kbd> and <kbd>createStatement()</kbd> methods. Here is the <kbd>getDbConnection()</kbd> method:</p>
<pre>Connection <span>getDbConnection</span>() {<br/>  PGPoolingDataSource source = <span>new </span>PGPoolingDataSource()<span>;<br/></span><span>  </span>source.setServerName(<span>"localhost"</span>)<span>;<br/></span><span>  </span>source.setDatabaseName(<span>"cookbook"</span>)<span>;<br/></span><span>  try </span>{<br/>    <span>return </span>source.getConnection()<span>; <br/></span>  } <span>catch</span>(Exception ex) {<br/>    ex.printStackTrace()<span>;<br/></span><span>    return null;<br/></span><span>  </span>}<br/>}</pre>
<p>Here is the <kbd>createStatement()</kbd> method:</p>
<pre>Statement <span>createStatement</span>(Connection conn) {<br/>  <span>try </span>{<br/>    <span>return </span>conn.createStatement()<span>;<br/></span><span>  </span>} <span>catch</span>(Exception ex) {<br/>    ex.printStackTrace()<span>;<br/></span><span>    return null;<br/></span><span>  </span>}<br/>}</pre>
<p>This was very helpful, but in some cases, we were still required to write extra code in old style. For example, if there is an  <kbd>execute()</kbd> method that accepts a <kbd>Statement</kbd> object as a parameter, and we would like to release (close) it as soon as it was used. In such a case, the code will look as follows:</p>
<pre><span>void </span><span>execute</span>(Statement st<span>, </span>String sql){<br/>  <span>try </span>{<br/>    st.execute(sql)<span>;<br/></span><span>  </span>} <span>catch </span>(Exception ex) {<br/>    ex.printStackTrace()<span>;<br/></span><span>  </span>} <span>finally </span>{<br/>    <span>if</span>(st != <span>null</span>) {<br/>      <span>try</span>{<br/>        st.close()<span>;<br/></span><span>      </span>} <span>catch </span>(Exception ex) {<br/>        ex.printStackTrace()<span>;<br/></span><span>      </span>}<br/>    }<br/>  }<br/>}</pre>
<p>As you can see, most of it is just boilerplate copy-and-paste code.</p>
<p>The new <em>try-with-resources</em> <span>statement (coming with Java 9) addresses this case by a</span>llowing effectively-final variables to be used as resources in the <em>try-with-resources</em> statement.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Rewrite the previous example using the new <em>try-with-resources</em> statement:</li>
</ol>
<pre><span>        void </span><span>execute</span>(Statement st<span>, </span>String sql){<br/>          <span>try </span>(st) {<br/>            st.execute(sql)<span>;<br/></span><span>          </span>} <span>catch </span>(Exception ex) {<br/>            ex.printStackTrace()<span>;<br/></span><span>          </span>}<br/>        }</pre>
<p style="padding-left: 60px">As you can see, it is much more concise and focused, without the need of repeatedly writing trivial code that closes the resource. No more <kbd>finally</kbd> and extra <kbd>try...catch</kbd> in it.</p>
<ol start="2">
<li>Try and write it so that it closes the connection as soon as it was used<span>:</span></li>
</ol>
<pre><span>        void </span><span>execute</span>(Connection conn<span>, </span>Statement st<span>, </span>String sql) {<br/>          <span>try </span>(conn<span>; </span>st) {<br/>            st.execute(sql)<span>;<br/></span><span>          </span>} <span>catch </span>(Exception ex) {<br/>            ex.printStackTrace()<span>;<br/></span><span>          </span>}<br/>        }</pre>
<p style="padding-left: 60px">It may or may not fit your application connection handling, but often, this capability is handy.</p>
<ol start="3">
<li>Try a different combination, such as the following:</li>
</ol>
<pre><span>        Connection conn = getDbConnection();<br/>        Statement st = conn.createStatement();<br/>        try </span>(conn<span>; </span>st) {<br/>          st.execute(sql)<span>;<br/></span>        } <span>catch </span>(Exception ex) {<br/>          ex.printStackTrace()<span>;<br/></span>        }</pre>
<p style="padding-left: 30px">You can also try this combination:</p>
<pre><span>        Connection conn = getDbConnection();<br/>        try </span>(conn<span>; Statement st = conn.createStatement()</span>) {<br/>          st.execute(sql)<span>;<br/></span>        } <span>catch </span>(Exception ex) {<br/>          ex.printStackTrace()<span>;<br/></span>        }</pre>
<p style="padding-left: 60px"><span>The new statement provides more flexibility to write code that fits the needs without writing lines to close the resource. </span></p>
<p style="padding-left: 60px">The only requirements are as follows:</p>
<ul>
<li style="list-style-type: none">
<ul>
<li>The variable included in the <kbd>try</kbd> statement has to be final or effectively final</li>
<li>The resource has to implement the <kbd>AutoCloseable</kbd><span> interface , which includes only one method:</span></li>
</ul>
</li>
</ul>
<pre style="padding-left: 90px">        void close() throws Exception;</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>To demonstrate how the new statement works, let's create our own resources that implement <kbd>AutoCloseable</kbd> and use them in a fashion similar to the resources of the previous examples.</p>
<p>Here is one resource:</p>
<pre><span>class </span>MyResource1 <span>implements </span>AutoCloseable {<br/>  <span>public </span><span>MyResource1</span>(){<br/>    System.<span>out</span>.println(<span>"MyResource1 is acquired"</span>)<span>;<br/></span><span>  </span>}<br/>  <span>public void </span><span>close</span>() <span>throws </span>Exception {<br/>    <span>//Do what has to be done to release this resource<br/></span><span>    </span>System.<span>out</span>.println(<span>"MyResource1 is closed"</span>)<span>;<br/></span><span>  </span>}<br/>}</pre>
<p>Here is the second resource:</p>
<pre><span>class </span>MyResource2 <span>implements </span>AutoCloseable {<br/>  <span>public </span><span>MyResource2</span>(){<br/>    System.<span>out</span>.println(<span>"MyResource2 is acquired"</span>)<span>;<br/></span><span>  </span>}<br/>  <span>public void </span><span>close</span>() <span>throws </span>Exception {<br/>    <span>//Do what has to be done to release this resource<br/></span><span>    </span>System.<span>out</span>.println(<span>"MyResource2 is closed"</span>)<span>;<br/></span><span>  </span>}<br/>}</pre>
<p>Let's use them in the code example:</p>
<pre>MyResource1 res1 = <span>new </span>MyResource1()<span>;<br/></span>MyResource2 res2 = <span>new </span>MyResource2()<span>;<br/></span><span>try </span>(res1<span>; </span>res2) {<br/>  System.<span>out</span>.println(<span>"res1 and res2 are used"</span>)<span>;<br/></span>} <span>catch </span>(Exception ex) {<br/>  ex.printStackTrace()<span>;<br/></span>}</pre>
<p>If we run it, the result will be as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img height="81" width="415" class="image-border" src="assets/1b617582-087d-4a90-996f-04c642c55a41.png"/></div>
<p>Note that the resource listed first in the <kbd>try</kbd> statement is closed last. If we make only one change and switch the order in the <kbd>try</kbd> statement:</p>
<pre>MyResource1 res1 = <span>new </span>MyResource1()<span>;<br/></span>MyResource2 res2 = <span>new </span>MyResource2()<span>;<br/></span><span>try </span>(res2<span>; </span>res1) {<br/>  System.<span>out</span>.println(<span>"res1 and res2 are used"</span>)<span>;<br/></span>} <span>catch </span>(Exception ex) {<br/>  ex.printStackTrace()<span>;<br/></span>}</pre>
<p>The output confirms it:</p>
<div class="CDPAlignCenter CDPAlign"><img height="79" width="393" class="image-border" src="assets/aeb523cc-3d63-4076-843a-a827cbb6c280.png"/></div>
<p>This rule of closing the resources in the reverse order addresses the most important possible issue of dependency between resources, but it is up to the programmer to define the sequence of closing the resources (by listing them in the <kbd>try</kbd> statement in the correct order). Fortunately, the closing of most standard resources is handled by the JVM gracefully, and the code does not break if the resources are listed in incorrect order. Still, it is a good idea to list them in the same sequence as they were created.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<p>Do refer to the other recipes of this chapter:</p>
<ul>
<li>Some best practices for better memory usage</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Stack walking for improved debugging</h1>
                </header>
            
            <article>
                
<p>Stack trace can be very helpful in figuring out the source of the problem, although the need to read it is usually caused by some unpleasant surprise. Once in a while, especially in a big and complex system, the need arises to read it programmatically when an automatic correction is possible.</p>
<p>Since Java 1.4, the current stack trace can be accessed via the <span><kbd>java.lang.Thread</kbd> and <kbd>java.lang.Throwable</kbd> classes. To any method of your code, you can add the following line:</span></p>
<pre>Thread.currentThread().dumpStack();</pre>
<p>You can also add the following line:</p>
<pre>new Throwable().printStackTrace();</pre>
<p>It will print the stack trace to the standard output. Alternatively, since Java 8, you can use any of the following lines for the same effect:</p>
<pre>Arrays.<span>stream</span>(Thread.<span>currentThread</span>().getStackTrace())<br/>      .forEach(System.<span>out</span>::println)<span>;<br/><br/></span>Arrays.<span>stream</span>(<span>new </span>Throwable().getStackTrace())<br/>      .forEach(System.<span>out</span>::println)<span>;<br/></span></pre>
<p>You can use the stack trace to find the fully qualified name of the caller class, using one of these lines:</p>
<pre>System.out.println("This method is called by "+Thread.currentThread()<br/>                        .getStackTrace()[1].getClassName());<br/><br/>System.out.println("This method is called by " + new Throwable()<br/>                        .getStackTrace()[0].getClassName());</pre>
<p>All the aforementioned lines are possible because of the <kbd>java.lang.StackTraceElement</kbd> class, which represents a stack frame in a stack trace. This class provides other methods that describe the execution point represented by this stack trace element, which allows programmatic access to the stack trace information. For example, you can run this code snippet from anywhere in your program:</p>
<pre><span>Arrays.stream(Thread.currentThread().getStackTrace())<br/>  .forEach(e -&gt; {<br/></span><span>    System.out.println();<br/></span><span>    System.out.println("e="+e);<br/></span><span>    System.out.println("e.getFileName()="+ e.getFileName());<br/></span><span>    System.out.println("e.getMethodName()="+ e.getMethodName());<br/></span><span>    System.out.println("e.getLineNumber()="+ e.getLineNumber());<br/></span><span>});<br/></span></pre>
<p>You can also run this one from anywhere in the program:</p>
<pre><span>Arrays.stream(new Throwable().getStackTrace())<br/>  .forEach(x -&gt; {<br/></span><span>    System.out.println();<br/></span><span>    System.out.println("x="+x);<br/></span><span>    System.out.println("x.getFileName()="+ x.getFileName());</span><span><br/></span><span>    System.out.println("x.getMethodName()="+ x.getMethodName());<br/></span><span>    System.out.println("x.getLineNumber()="+ x.getLineNumber());<br/></span><span>});<br/></span></pre>
<p>In either case, you can see how much information you get. Unfortunately, this wealth of data comes with a price. The JVM captures the entire stack (except for hidden stack frames), and it may affect the performance, while the chances are that you only need a fraction of this data (like in the preceding example where we use only one element of the stack trace array).</p>
<p>This is where the new Java 9 class, <kbd>java.lang.StackWalker</kbd>, with its nested <kbd>Option</kbd> class and <kbd>StackFrame</kbd> interface, comes in handy.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>The <kbd>StackWalker</kbd> class has four variants of the static factory method, <kbd>getInstance()</kbd>, which are different only in their ability to take one of the following several options or no options at all:</p>
<ul>
<li><kbd>StackWalker getInstance()</kbd>: This is configured to skip all the hidden frames and no caller class reference.</li>
<li><kbd>StackWalker getInstance(StackWalker.Option option)</kbd>: This creates an instance with the given option, specifying the stack frame information it can access.</li>
<li><kbd>StackWalker getInstance(Set&lt;StackWalker.Option&gt; options)</kbd>: This creates an instance with the given set of options, specifying the stack frame information it can access. If the given set is empty, the instance is configured exactly like an instance of <kbd>StackWalker getInstance()</kbd>.</li>
<li><kbd>StackWalker getInstance(Set&lt;StackWalker.Option&gt; options, int estimatedDepth)</kbd>: This creates a similar instance as the preceding one and accepts the <kbd>estimatedDepth</kbd> parameter, which specifies the estimated number of stack frames this instance will traverse so that it can estimate the buffer size it might need.</li>
</ul>
<p>One of the following values is passed as an option:</p>
<ul>
<li><kbd>StackWalker.Option.RETAIN_CLASS_REFERENCE</kbd></li>
<li><kbd>StackWalker.Option.SHOW_HIDDEN_FRAMES</kbd></li>
<li><kbd>StackWalker.Option.SHOW_REFLECT_FRAMES</kbd></li>
</ul>
<p>The <kbd>StackWalker</kbd> class also has three methods:</p>
<ul>
<li><kbd>T walk(Function&lt;Stream&lt;StackWalker.StackFrame&gt;, T&gt; function)</kbd>: This applies the given function to the stream of <kbd>StackFrames</kbd> for the current thread, traversing from the top frame of the stack, which is the method calling this walk method.</li>
<li><kbd>void forEach(Consumer&lt;StackWalker.StackFrame&gt; action)</kbd>: This performs the given action on each element of the <kbd>StackFrame</kbd> stream of the current thread, traversing from the top frame of the stack, which is the method calling the <kbd>forEach</kbd> method. This method is equivalent to calling <kbd>walk(s -&gt; { s.forEach(action); return null; })</kbd>.</li>
<li><kbd>Class&lt;?&gt; getCallerClass()</kbd>: This gets the <kbd>Class</kbd> object of the caller that invoked the method that invoked <kbd>getCallerClass()</kbd>. This method throws <kbd>UnsupportedOperationException</kbd> if this <kbd>StackWalker</kbd> instance is not configured with the <kbd>RETAIN_CLASS_REFERENCE</kbd> option.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Create several classes and methods that will call each other, so you can perform stack trace processing.</p>
<ol>
<li>Create a <kbd>Clazz01</kbd> class:</li>
</ol>
<pre><span>        public class </span>Clazz01 {<br/>          <span>public void </span><span>method</span>(){<br/><span>            new </span>Clazz03().method(<span>"Do something"</span>)<span>;<br/></span><span>            new </span>Clazz02().method()<span>;<br/></span><span>          </span>}<br/>        }</pre>
<ol start="2">
<li>Create a <kbd>Clazz02</kbd> class:</li>
</ol>
<pre><span>        public class </span>Clazz02 {<br/>          <span>public void </span><span>method</span>(){<br/><span>            new </span>Clazz03().method(<span>null</span>)<span>;<br/></span><span>          </span>}<br/>        }</pre>
<ol start="3">
<li>Create a <kbd>Clazz03</kbd> class:</li>
</ol>
<pre><span>        public class </span>Clazz03 {<br/>          <span>public void </span><span>method</span>(String action){<br/><span>            </span><span>if</span>(action != <span>null</span>){<br/>              System.<span>out</span>.println(action)<span>;<br/></span><span>              return;<br/></span><span>            </span>}<br/>            <span>System.out.println("Throw the exception:");<br/></span><span>            action.toString();<br/>          }<br/>        }</span></pre>
<ol start="4">
<li>Write a <kbd><span>demo4_StackWalk</span>()</kbd> method:</li>
</ol>
<pre><span>        private static void </span><span>demo4_StackWalk</span>(){<br/><span>          new </span>Clazz01().method()<span>;<br/></span>        }</pre>
<p style="padding-left: 90px">Call this method from the main method of the <kbd>Chapter12Memory</kbd> class:</p>
<pre><span>        public class </span>Chapter12Memory {<br/>          <span>public static void </span><span>main</span>(String... args) {<br/><span>            </span><span>demo4_StackWalk</span>()<span>;<br/></span><span>          </span>}<br/>        }</pre>
<p>If we run now the <kbd>Chapter12Memory</kbd> class, the result will be as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img height="124" width="557" class="image-border" src="assets/e3941b47-746b-4bdc-8b6f-6685b1ec985a.png"/></div>
<p><span>The message, <kbd>Do something</kbd>, is passed from <kbd>Clazz01</kbd> and printed out in <kbd>Clazz03</kbd>. Then <kbd>Clazz02</kbd> passes null to <kbd>Clazz03</kbd>, and the message, <kbd>Throw the exception:</kbd>, is printed out before the stack trace caused by the <kbd>NullPointerException</kbd> from the <kbd>action.toString();</kbd> line.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p><span>For a deeper understanding of the concepts here, let's modify <kbd>Clazz03</kbd>:</span></p>
<pre><span>public class </span>Clazz03 {<br/>  <span>public void </span><span>method</span>(String action){<br/><span>    </span><span>if</span>(action != <span>null</span>){<br/>      System.<span>out</span>.println(action)<span>;<br/></span><span>      return;<br/></span><span>    </span>}<br/>    System.out.println("Print the stack trace:");<br/><span>    Thread.currentThread().dumpStack();<br/>  }<br/>}</span></pre>
<p><span>The result will be the following:</span></p>
<div class="CDPAlignCenter CDPAlign"><img height="129" width="526" class="image-border" src="assets/c0289bc5-b946-4518-b1c2-b60fe74ac929.png"/></div>
<p><span>Alternatively, we can get a similar output by using <kbd>Throwable</kbd> instead of <kbd>Thread</kbd>:</span></p>
<pre><span>new </span>Throwable().printStackTrace()<span>;</span></pre>
<p>It does look very familiar:</p>
<div class="CDPAlignCenter CDPAlign"><img height="115" width="500" class="image-border" src="assets/ec4edfae-5d60-48ce-9241-401f08f00299.png"/></div>
<p>A similar result will produce each of the following two lines:</p>
<pre>Arrays.<span>stream</span>(Thread.<span>currentThread</span>().getStackTrace())<br/>                             .forEach(System.<span>out</span>::println)<span>;<br/></span>Arrays.<span>stream</span>(<span>new </span>Throwable().getStackTrace())<br/>                             .forEach(System.<span>out</span>::println)<span>;<br/></span></pre>
<p><span>Now with Java 9, the same output is achieved by using the <kbd>StackWalker</kbd> class. Let's look at what happens if we modify <kbd>Clazz03</kbd> as follows:</span></p>
<pre><span>public class </span>Clazz03 {<br/>  <span>public void </span><span>method</span>(String action){<br/><span>    </span><span>if</span>(action != <span>null</span>){<br/>      System.<span>out</span>.println(action)<span>;<br/></span><span>      return;<br/></span><span>    </span>}<br/><span>    StackWalker stackWalker = StackWalker.getInstance();<br/>    stackWalker.forEach(System.out::println);<br/>  }<br/>}</span></pre>
<p><span>The result will be the same:</span></p>
<div class="CDPAlignCenter CDPAlign"><img height="120" width="538" class="image-border" src="assets/80e70b00-e7ae-4f08-ab66-e8c67621b1ad.png"/></div>
<p>However, contrary to the full stack trace generated and stored in an array in the memory, the <kbd>StackWalker</kbd> class only brings the requested elements. This is already a big plus. However, <kbd>StackWalker</kbd> shows the biggest advantage when we need the caller class name only. Instead of getting all the arrays and using only one element, we can now get the info we need by using the following two lines: </p>
<pre>System.<span>out</span>.println(<span>"Print the caller class name:"</span>)<span>;<br/></span>System.<span>out</span>.println(StackWalker.<span>getInstance</span>(StackWalker<br/>                        .Option.<span>RETAIN_CLASS_REFERENCE</span>)<br/>                        .getCallerClass().getSimpleName())<span>;<br/></span></pre>
<p><span>We will get the result:</span></p>
<div class="CDPAlignCenter CDPAlign"><span><img height="42" width="422" class="image-border" src="assets/0109fd66-5daa-48ef-9bdb-95645c0b7d8a.png"/></span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<p>Do refer to the other recipes of this chapter:</p>
<ul>
<li>Some best practices for better memory usage</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Some best practices for better memory usage</h1>
                </header>
            
            <article>
                
<p>Memory management may never become an issue for you, or it can be a haunting never-ending story of your life, and anything in between. It is probably going to be a non-issue for a majority of programmers, especially with the constantly improving garbage collection algorithms. The G1 garbage collector (default in JVM 9) is definitely a step in the right direction. But there is also a chance you will be called (or will notice yourself) about the degrading application performance, and that is when you'll learn how well you are equipped to meet the challenge.</p>
<p>This recipe is an attempt to help you avoid such a situation or to get out of it successfully.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it  works...</h1>
                </header>
            
            <article>
                
<p>The first line of defense is the code itself. In the previous recipes, we have already discussed the need to release resources as soon as they are not needed anymore and the usage of <kbd>StackWalker</kbd> to consume less memory. There are plenty of recommendations on the internet, but they might not apply to your application. You'll have to monitor the memory consumption and test your design decisions, especially if your code handles a lot of data before deciding where to concentrate your attention. </p>
<p>For example, the choice of the collection (different collections use more or less memory) may be irrelevant if your collection is going to be small. However, programmers usually use the same coding pattern, and one can identify the code's author by their style. That's why it pays back in a long run to figure the most efficient constructs and use them routinely. However, try to avoid making your code difficult to understand; readability is an important aspect of the code quality.</p>
<p>Here are a few most popular pieces of advice on memory-aware coding style:</p>
<ul>
<li>Use lazy initialization and create an object just before the usage, especially if there is a good chance, this need may never materialize at all</li>
<li>Use <kbd>StringBuilder</kbd> instead of the <kbd>+</kbd> operator</li>
<li>Use <kbd>ArrayList</kbd> if it fits your needs, before using <kbd>HashSet</kbd> (the memory usage increases from <kbd>ArrayList</kbd> to <kbd>LinkedList</kbd>, <kbd>HashTable</kbd>, <kbd>HashMap</kbd>, and <kbd>HashSet</kbd>, in this sequence)</li>
<li>Avoid regular expressions and cache <kbd>Pattern</kbd> references if you cannot avoid them</li>
<li>Prefer primitives over the class wrappers (use autoboxing)</li>
<li>Don't forget to clean the cache and remove unnecessary entries</li>
<li>Pay attention to the object created inside the loop</li>
</ul>
<p>Test and profile your code as soon as it starts doing what it was supposed to do. You might need to change your design or some details of implementation. It will also inform your future decisions. There are many profilers and diagnostic tools available for any environment. We described one of them (<kbd>jcmd</kbd>) in the <em>Using the new diagnostic commands for the JVM </em>recipe of this chapter.</p>
<p>Learn how your garbage collector works (see the recipe, <em>Understanding the G1 garbage collector</em>) and do not forget to use JVM logging (described in the recipe, <em>Unified logging for JVM</em>).</p>
<p>After that, you might need to tune the JVM and garbage collector. Here are a few most often used JVM parameters (the size is specified in bytes by default, but you can a<span>ppend the letter k or K to indicate kilobytes, m or M to indicate megabytes, g or G to indicate gigabytes)</span>:</p>
<ul>
<li><kbd>-Xms size</kbd>: This sets the initial size of the heap, which must be a multiple of 1024 and greater than 1 MB.</li>
<li><kbd>-Xmx size</kbd>: This sets the maximum size of the heap, which must be a multiple of 1024 and greater than 2 MB. The default value is chosen at runtime based on the system configuration. For server deployments, <kbd>-Xms size</kbd> and <kbd>-Xmx size</kbd> are often set to the same value. The actual memory usage may exceed the amount you have set by <kbd>-Xmx size</kbd>, because it limits the Java heap size only, while the JVM allocates memory for other purposes too, including a stack for each thread.</li>
<li>
<p><kbd>-Xmn size</kbd>: This sets the initial and maximum size of the heap for the young generation (nursery). If the size for the young generation is too small, then a lot of minor garbage collections will be performed. If the size is too large, then only full garbage collections will be performed, which can take a long time to complete. Oracle recommends that you keep the size for the young generation greater than 25% and less than 50% of the overall heap size. This parameter is equivalent to <kbd>-XX:NewSize=size</kbd>. For efficient garbage collection, <kbd>-Xmn size</kbd> should be lower than <kbd>-Xmx size</kbd>.</p>
</li>
<li><kbd>-XX:MaxNewSize=size</kbd>: This s<span>ets the maximum size of the heap for the young generation (nursery). The default value is set ergonomically.</span> Oracle advises that after the total available memory, the second most influential factor is the proportion of the heap reserved for the young generation. By default, the minimum size of the young generation is 1310 MB, and the maximum size is unlimited.</li>
</ul>
<ul>
<li><kbd>-XX:NewRatio=ratio</kbd>: This sets the ratio between the young and old generation sizes; the default is set to 2.</li>
</ul>
<ul>
<li><kbd>-Xss size</kbd>: This sets the thread stack size, the default value depends on the platform:
<ul>
<li>Linux/ARM (32-bit): 320 KB</li>
<li>Linux/ARM (64-bit): 1024 KB</li>
<li>Linux/x64 (64-bit): 1024 KB</li>
<li>OS X (64-bit): 1024 KB</li>
<li>Oracle Solaris/i386 (32-bit): 320 KB</li>
<li>Oracle Solaris/x64 (64-bit): 1024 KB</li>
<li>Windows: The default value depends on virtual memory</li>
</ul>
</li>
</ul>
<p style="padding-left: 90px">Each thread has a stack, so the stack size will limit the number of threads the JVM can have. If the stack size is too small, you can get the <kbd>java.lang.StackOverflowError</kbd> exception. However, making the stack size too big can exhaust the memory too, as each thread will allocate more memory than it needs.</p>
<ul>
<li><kbd>-XX:MaxMetaspaceSize=size</kbd>: This sets the upper limit of the memory allocated for class metadata, not limited by default.</li>
</ul>
<p>The tell-tell sign of a memory leak is the growing of the old generation causing the full GC to run more often. To investigate, you can use the JVM parameters that dump heap memory into a file:</p>
<ul>
<li><kbd>-XX:+HeapDumpOnOutOfMemoryError</kbd>: This saves the Java heap into a file in the current directory when a <kbd>java.lang.OutOfMemoryError</kbd> exception is thrown. You can explicitly set the heap dump file path and name using the <kbd>-XX:HeapDumpPath=path</kbd> option. By default, this option is disabled and the heap is not dumped when an <kbd>OutOfMemoryError</kbd> exception is thrown.</li>
<li><kbd>-XX:HeapDumpPath=path</kbd><span>: This </span>sets the path and filename for writing the heap dump provided by the heap profiler (<kbd>hprof</kbd>) when the <kbd>-XX:+HeapDumpOnOutOfMemoryError</kbd> parameter is set. By default, the file is created in the current working directory, and it is named <kbd>java_pidpid.hprof</kbd> where <kbd>pid</kbd> is the identifier of the process that caused the error.</li>
<li><kbd>-XX:OnOutOfMemoryError="&lt; cmd args &gt;;&lt; cmd args &gt;"</kbd>: This sets a custom command or a series of semicolon-separated commands to run when an <kbd>OutOfMemoryError</kbd> exception is first thrown. If the string contains spaces, then it must be enclosed in quotation marks. For an example of a command string, see the description of the <kbd>-XX:OnError</kbd> parameter.</li>
<li><kbd>-XX:+UseGCOverheadLimit</kbd>: This enables the use of a policy that limits the proportion of time spent by the JVM on GC before an <kbd>OutOfMemoryError</kbd> exception is thrown. This option is enabled by default, and the parallel GC will throw an <kbd>OutOfMemoryError</kbd> exception if more than 98% of the total time is spent on garbage collection and less than 2% of the heap is recovered. When the heap is small, this feature can be used to prevent applications from running for long periods of time with little or no progress. To disable this option, specify <kbd>-XX:-UseGCOverheadLimit</kbd>.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<p>Do refer to the other recipes of this chapter:</p>
<ul>
<li>Understanding the G1 garbage collector</li>
<li>Unified logging for JVM</li>
<li>Using the new diagnostic commands for the JVM</li>
<li>Try with resources for better resource handling</li>
<li>Stack walking for improved debugging</li>
</ul>


            </article>

            
        </section>
    </body></html>