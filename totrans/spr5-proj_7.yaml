- en: Task Management System Using Spring and Kotlin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the chapters so far, we have explored various topics and concepts in depth.
    Starting with the pure Spring Framework and moving onto Spring Boot, we learned
    how quickly and easily we can create an enterprise-grade application with Spring
    Boot.
  prefs: []
  type: TYPE_NORMAL
- en: We also learned about the integration of the Spring Framework with other tools
    and technologies, such as Elasticsearch, LDAP, and OAuth, within the purview of
    the Spring Boot context. We then learned a new way of creating an application
    with Spring as a backend and Angular as a frontend with a tool called **JHipster**.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we discovered how to create an application with modern architecture in
    the dimension of the distributed environment called **microservice**. In this
    chapter, we go further and explore a completely different dimension of the Spring
    Framework, looking at how it is supported by a new programming language called
    **Kotlin**.
  prefs: []
  type: TYPE_NORMAL
- en: As a programming language, Kotlin has quickly become popular among developers
    and companies. The first stable version of Kotlin was released officially in 2016\.
    The very next year Google officially declared Kotlin as a supported language for
    mobile development on an Android platform. This greatly increased the popularity
    and adoption rate of Kotlin.
  prefs: []
  type: TYPE_NORMAL
- en: 'Starting with version 5, Spring announced support for Kotlin to develop enterprise
    applications on a Spring Framework. In this chapter, we will explore how to develop
    a Spring-based application with Kotlin. We will build an application called Task
    Management with Spring Boot and Kotlin, and will cover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Kotlin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basic features of Kotlin as a programming language
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kotlin versus Java
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring support for Kotlin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing a Task Management application in Spring with Kotlin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All the code used in this chapter can be downloaded from the following GitHub
    link: [https://github.com/PacktPublishing/Spring-5.0-Projects/tree/master/chapter07](https://github.com/PacktPublishing/Spring-5.0-Projects/tree/master/chapter07).
    The code can be executed on any operating system, although it has only been tested
    on Windows.'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Kotlin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kotlin is a language for **Java Virtual Machine** (**JVM**) and hence can be
    used in place of Java. Be it server side, mobile, or web, you can use Kotlin everywhere
    Java is used at present. It is sponsored by a company called **JetBrains**; it
    is open source, and you can download the source code from GitHub ([https://github.com/jetbrains/kotlin](https://github.com/jetbrains/kotlin)).
    They plan to roll out Kotlin for embedded and iOS platforms in the near future.
  prefs: []
  type: TYPE_NORMAL
- en: Kotlin provides good support as a functional programming language. The term
    functional programming is used to describe a declarative paradigm where the program
    is created by an expression or declaration rather than by the execution of commands.
    The functional programming model inherently brings certain qualities to the application,
    such as more compressed and predicted code, easy testing ability, reusability,
    and so on. Kotlin brings a functional paradigm in the form of inbuilt features.
  prefs: []
  type: TYPE_NORMAL
- en: There are many similarities between Java and Kotlin, and so the question arises,
    why do we need another programming language when Java has been widely used and
    very popular for more than two decades. The answer lies in some of the cool features
    Kotlin has, which make it the better choice for developing JVM-based applications.
  prefs: []
  type: TYPE_NORMAL
- en: Interoperability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most promising features of Kotlin is its interoperable capabilities.
    Kotlin is 100% interoperable with Java. The application can combine both the languages.
    The call to Java libraries can be made from Kotlin without any conversion or fuss.
    Similarly, code written in Kotlin can also be called from Java with ease. This
    greatly helps Java developers to migrate from Java to Kotlin without any difficulty.
  prefs: []
  type: TYPE_NORMAL
- en: 'Migrating a code from one programming language to another is a quite tedious
    and time-consuming task, especially when those programming languages are incompatible,
    in terms of rules, syntax, features, and so on. Although there are a bunch of
    features available in Kotlin that are not present directly or indirectly in Java,
    it is the interoperability of Kotlin that allows running the code with both programming
    languages simultaneously. You do not have to migrate all Java code to Kotlin.
    Kotlin''s **Interoperability** is shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e3cc5dc9-95a7-4c99-a716-6a793669cb62.png)'
  prefs: []
  type: TYPE_IMG
- en: 'On top of this, the Kotlin standard library is dependent on the Java Class
    Library, which enables reusing the dependencies, and no code refactoring is required
    in any of the places. For example: Kotlin''s collection framework is built on
    top of Java''s collection API.'
  prefs: []
  type: TYPE_NORMAL
- en: Concise yet powerful
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While working with Kotlin, you will find another good quality is how concise
    it is. The Kotlin syntax is easy to read and interpret even without prior knowledge
    of any programming language. Kotlin has certain features that make it a truly
    concise language, such as type interface, data classes, properties, smart casts,
    and a lot more. We will see more detail about each of them later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: With these features, the code written with Kotlin is compact without losing
    its capabilities. Kotlin is more concise than Java in many aspects, and because
    of this we can implement the same functionality with fewer lines of code. This
    greatly improves legibility and ease of use. Developers can easily read, code,
    and update the program, even when it has been written by others.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, Kotlin enables the speeding up of day-to-day development tasks
    with various features such as default parameters, extension functions, and object
    declarations. Your code is more compact and yet robust, without raising any maintainability
    concerns. This will reduce the possibility of bugs in the system.
  prefs: []
  type: TYPE_NORMAL
- en: Kotlin evolved as an enhancement to Java rather than as a completely new language.
    So the skills and knowledge you have with Java can be applied to Kotlin, making
    it an easy language to learn.
  prefs: []
  type: TYPE_NORMAL
- en: Safety feature
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another reason you will love Kotlin is its safety feature. The code written
    in Kotlin is far safer than that written in Java. Kotlin is designed in a way
    to shield it from the common programming flaws, which results in a more stable
    system with fewer crashes and failures.
  prefs: []
  type: TYPE_NORMAL
- en: For any programming language that allows the null reference will create a runtime
    exception, such as `NullPointerException` , during the execution of the application.
    Improper handling of such a scenario may result in an abrupt system collision.
    If you have prior experience of Java, you might have experienced such scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: 'Kotlin was designed with this in mind and defines the reference types in two
    categories: those that are nullable and those that are not. By default, Kotlin
    does not allow the reference with the null value and forces the developer to handle
    them in a specific manner. This greatly reduces the possibility of problems caused
    by `NullPointerException`.'
  prefs: []
  type: TYPE_NORMAL
- en: IDE Support
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**JetBrains**, the company behind Kotlin, is well known for its **i****ntegrated
    development environment (IDE)** called **IntelliJ IDEA**, andobviously has first-class
    support for Kotlin. As far as the IDE is concerned, Eclipse is also one of the
    most favored among Java developers, and so JetBrains also offers a Kotlin plugin
    for Eclipse.'
  prefs: []
  type: TYPE_NORMAL
- en: In the very early days when Java had just evolved, there was no IDE in the initial
    stage and developers had to use text editors to do coding. It was difficult working
    without the safety and convenience of an IDE. When Eclipse came onto the market,
    developers quickly adopted it and since then it has become popular and widely
    accepted among Java developers.
  prefs: []
  type: TYPE_NORMAL
- en: Kotlin, on the other hand, was lucky enough to get IDE support from day one.
    This quickly boosted the popularity of Kotlin. It was really convenient and easy
    to learn. Developers were able to produce good quality code quickly, improving
    the software development life cycle.
  prefs: []
  type: TYPE_NORMAL
- en: Needless to say, Kotlin allows coding with text editors. Also, you can use Command
    Prompt to build Kotlin applications. Additionally, if you are an Android developer,
    it has its own IDE called **Android Studio** developed on top of IntelliJ IDEA
    IDE.
  prefs: []
  type: TYPE_NORMAL
- en: Kotlin features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kotlin was designed not to compete with Java, but rather to be a good JVM language
    with added features not present in Java. Kotlin, as a language, has lots of new
    and exciting features, compared to Java, that increase code readability and maintainability.
  prefs: []
  type: TYPE_NORMAL
- en: It is vital to understand the basic features of Kotlin. In this section, we
    will explore a few of them that are essential for building an application in Kotlin.
  prefs: []
  type: TYPE_NORMAL
- en: The concept of a function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By definition, a function is a set or group of related statements that perform
    a specific task. It is a basic building block of any program. You can equate the
    function in Kotlin with the method in Java; however, there are certain differences.
    The function in Kotlin can be defined at the top level, meaning it is not required
    to be enclosed in a class. The function can be part of a class as well as defined
    within another function.
  prefs: []
  type: TYPE_NORMAL
- en: In Kotlin, the functions get first-class support, meaning it supports all the
    operations and can be stored into a variable and data structure, passed as an
    argument to other function as well as being returned from other (top-level) functions,
    it can be defined as an expression, and lots more. All these features bring a
    great amount of flexibility and make Kotlin really concise. We will see the following
    uses of functions in Kotlin.
  prefs: []
  type: TYPE_NORMAL
- en: Function as an expression
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While writing the function, you need to put the code in a function body. However,
    in Kotlin, you can define a function as an expression. For example: you want to
    find the minimum between two numbers and you wrote a function called `min()` as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This will return the minimum number out of two given numbers. This function
    can be written as an expression style as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This is how the code looks expressive and compact. Also, notice that we have
    removed the `return` keyword, as Kotlin is smart enough to return the last value
    without explicitly specifying the `return` keyword. This is what is called a **single
    line** or **one line** function. However, for a complex function, you can write
    it in multiple lines as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This looks more compact and expressive.
  prefs: []
  type: TYPE_NORMAL
- en: Default function arguments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Often, the amount of data that we supply to functions or constructors varies
    in different use cases. The system should be flexible enough to produce the desired
    result even if we don't provide the values of all the parameters.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to achieve this in Java, you need to write a couple of overloaded
    functions or constructors as per your need. You will end up writing the same method
    multiple times with a different set of input parameters and calling other constructors
    or methods with default values. This quickly results in verbose code—writing code
    again and again for the same thing.
  prefs: []
  type: TYPE_NORMAL
- en: Kotlin provides an intuitive solution to this scenario with the feature called
    the default function argument. This is as simple as it sounds. You need to define
    a default value to those function arguments that you feel may not be provided
    with the value at the time of executing the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example: let''s say we wrote the function to find the volume of the cube
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'While calling this function, you need to pass all three parameters or else
    the compiler will signal the error. Now, assume that we want the system to take
    the default height as `10` if it is not provided explicitly. It can be written
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This function can be called as `getVolume(2,4)` and `10` will be substituted
    as a default value to `height`.
  prefs: []
  type: TYPE_NORMAL
- en: Extension functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you need to extend a class with a set of new functionalities, you need to
    update the Java source code. However, if you are using third-party libraries,
    you may not have the source. A class needs to be extended to accommodate other
    functions. You also can use various design patterns such as decorator and strategy
    for this purpose.
  prefs: []
  type: TYPE_NORMAL
- en: However, Kotlin allows the straightforward adding of extra functions to an existing
    class with the feature called an **e****xtension function**. As its name implies,
    an extension function extends the functionality of the class without touching
    its source code. In other words, you are no longer required to inherit the class
    to be extended. This sounds really interesting. It behaves just like other member
    functions but is declared outside of the class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assume that you need to convert the given string into camel case. The Kotlin `String` class
    does not provide the functionality to convert a given string into camel case out
    of the box. We will the use extension function to define a separate function that,
    will actually do this job as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The `camelCase()` function is the extension function on the `String` class,
    which returns the string. The custom logic resides in the body of this function.
    You can call the `camelCase()` function on any string literal as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The `camelCase()` function is our custom function so you can use any other
    name you feel appropriate. Let''s see one more example of an extension function.
    Suppose you want to find the square of a given integer. Again, Kotlin does not
    provide a direct function for that but we can write the extension function as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The `square()` extension function can be called in an integer literal as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This is an extraordinary feature that we can use to extend functionalities without
    updating the code or inheriting the base class.
  prefs: []
  type: TYPE_NORMAL
- en: Lambda expression or function literal
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Every programming language has a provision for defining the literals, such
    as string, integer, double, and so on. They can be defined in a specific manner
    such as string literal as `Hello`, double literal as `34.23`, and so on. Kotlin
    allows us to define a function as a literal by enclosing the code in braces as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This function can be declared in a normal way as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'It is essentially the same thing as a function literal. But the functional
    literal looks pretty compact yet expressive. A function literal can be assigned
    to a variable and called at a later point of the code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The function literal can be assigned to a variable as in the first line. Just
    like other functions, the function literal can be invoked with a variable (with
    parenthesis) as shown in the second line. There are certain characteristics of
    the function literal as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: It represents the block or body of the function that does not have any name.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is not associated with or bound to any entity such as class, interface, or
    object, and hence an access modifier is not allowed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since it does not have a name, it is called **anonymous.**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can be passed to other functions (mainly high-order functions) as an argument.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is generally surrounded by curly braces and without the `fun` keyword.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is also known as a lambda expression.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Kotlin also allows passing parameters to a function literal or lambda expression
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The lambda expression is divided into two parts by an arrow (`->`). The left
    part is the parameter section, while the right part is the lambda or function
    body. Multiple parameters are allowed with comma-separated lists and without enclosing
    them in parentheses as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We can write this code in a slightly different way as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In this code, the declaration of a parameter is moved out from the lambda expression.
    The `Unit` function in Kotlin is equivalent to `void` in Java. This feature makes
    Kotlin a truly functional language. The function literal can also be the parameter
    of another function.
  prefs: []
  type: TYPE_NORMAL
- en: Passing lambda to another function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kotlin allows us to pass a function to other (higher-order) functions as a parameter,
    using the lambda expression. Such a function can accept as a parameter a lambda
    expression or an anonymous function. Before discussing this topic further, let
    us first understand what a function type is.
  prefs: []
  type: TYPE_NORMAL
- en: 'Kotlin is a statically typed language and the functions also need to have a
    type. It is called a **function type**. We will see a few examples of how to define
    them as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`()->Int`: The function type that returns an integer type and takes no argument.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`(Int)->Unit`: The function type that takes an integer parameter and returns
    nothing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`()->(Int)->String`: The function type that returns another function, which
    eventually returns a string. The latter function takes an integer as a parameter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, let''s see how we can define a function type as an input parameter to
    the outer function. Consider a scenario where you are designing an application
    for a bank loan. You need to check the eligibility criteria and decide whether
    a loan is applicable. The function that does this job should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The `isEligibleForLoan()` function is a higher-order function that takes two
    parameters. The first parameter is the applicant''s mobile number from which it
    will fetch the applicant''s details. The second parameter is a function type,
    which we can consider as a sort of interface type. It simply calculates the eligibility
    score based on a given applicant ID. The actual implementation of the function
    type will be provided when the `isEligibleForLoan()` function is called as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We need to pass a lambda expression in the second parameter. It is nothing but
    an anonymous function that takes the application ID as an input parameter and
    calculates an eligibility score. The score will be returned back to the `isEligibleForLoan()`
    function from where, based on the score, we return whether a loan is applicable
    or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the function type is the last parameter, then Kotlin allows to call it in
    a slightly different way. The preceding function can be called alternatively as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In this way, the lambda expression is placed outside of the parenthesis, which
    is more expressive. But this is only possible when a function type is declared
    at the last parameter. Passing a lambda expression as a function type is useful,
    especially for an Ajax call where we want to update the page element once we get
    the data from the response without freezing the UI. The function that is injected
    through the lambda expression will work as a callback function.
  prefs: []
  type: TYPE_NORMAL
- en: Returning a function from another function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have seen how function type can be defined as a parameter while calling another
    function. With the help of a lambda expression, it becomes even more straightforward.
    One step further, Kotlin allows the returning of a function from another function.
    Let's understand how that works.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose we have one interface called `WildAnimal` that is implemented by three
    classes as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Each class implements two methods—`setName()` and `bark()` that will set the
    animal and show a barking voice respectively. We will create an instance of each
    of the class, set its name, and call the `bark()` function to print the barking
    voice and also print the name of the animal. To achieve this, we will write a
    function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The `getAnimalVoiceFun` function takes the implementation of `WildAnimal` as
    a parameter and returns the function that takes `String` as a parameter and returns
    `String` as an output. The code written inside the `{ }` braces in the body of
    the `getAnimalVoiceFun` function denotes the function that is returning from it.
    The `it` parameter points to the `String` parameter of the enclosing function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `animal.bark()` function, which actually returns the string, will be ultimately
    returned from an enclosed function. This function can be written in a slightly
    different way as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The difference is we are declaring the name of the parameter—`name` of the
    type string and using it as a `name=it` expression in the enclosing function.
    In both of the previous ways, the parenthesis represents the function, so the `fun`
    keyword is silent. However, you can declare it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'In this way, we are explicitly using the `fun` keyword for enclosing function.
    Also, you have to explicitly mention the `return` keyword in the enclosing function.
    You can use either of these ways to declare the `getAnimalVoiceFun` function.
    You can call this function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We are calling the `getAnimalVoiceFun` function with an instance of the respective
    class. You can see how the second string parameter included in separate parenthesis
    will be provided to a function defined within the function—`getAnimalVoiceFun`.
    You will get an output as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e42631de-5550-4cfc-9cc8-32fdebc12724.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In Kotlin, the function can be defined as a type. We can use the function type
    to declare the preceding function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The `getAnimalVoice` variable is defined as a function type, which takes the `WildAnimal`
    object and returns another function, which takes `String` as an input parameter
    (with the `it` keyword) and returns a `String` output (by calling `animal.bark()`).
    The lambda expression is used to define this function. This can be called as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'And the output would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cca14107-1d57-453e-af30-9f17e0808088.png)'
  prefs: []
  type: TYPE_IMG
- en: There may be other straightforward ways to set the animal name and print the
    barking voice. However, we have just seen how it can be possible by returning
    the function from another function. You can write some common logic that is applicable
    to multiple functions, and returning common code as a separate function would
    be an ideal scenario to use the function as a return type of another function.
    This is how flexible and concise Kotlin is.
  prefs: []
  type: TYPE_NORMAL
- en: Null safety
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While working with Java, when the program executes and tries to access the variables
    set to null and then not initialized with a proper value, it will crash the system
    and produce the classic exception called `NullPointerException`.
  prefs: []
  type: TYPE_NORMAL
- en: As we know, Kotlin is a statically typed language so everything is defined as
    a type, including null values. The nullability is a type in Kotlin. By default,
    a Kotlin compiler does not allow a null value to any type. Generally, when we
    define variables, we set their values at the time of declaration.
  prefs: []
  type: TYPE_NORMAL
- en: 'But, in some exceptional cases, you don''t want to initialize the variable
    at the time of declaration. In this case, while using those variables, the Kotlin
    compiler will raise the concern. For example: the following code will give an
    error signal in Kotlin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The variable initialized with some value is not allowed to be reassigned with
    the null value. Also, any variable defined with type (`String` , in our case)
    is not allowed to initialize with null. The Kotlin compiler has this restriction
    to avoid `NullPointerException`, so it will catch this at compile time rather
    than causing a runtime error which results in an abrupt system collision.
  prefs: []
  type: TYPE_NORMAL
- en: 'Kotlin wants us to initialize the typed variable at the time of declaration. As
    we said, there are situations where we have to initialize variables with null
    and Kotlin allows it in a different way, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The nullable variable can be defined with a question mark with a type of variable
    called a **safe call operator**. You can now assign null value. However, when
    we define a nullable variable and try to call its method, the compiler will show
    an error as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The reason for this is Kotlin will not allow calling methods on a nullable
    type without either explicitly checking for null or calling the method in a safe
    way. The previous code can be rewritten to avoid a compilation error in the following
    ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The `nullableMsg2?` method is the safe way to call a nullable variable. If
    the variable is null, Kotlin will silently bypass that call and return a null
    value. This is a more concise way for a safe null check in Kotlin. But if you
    want to make sure the value is returned, even if it is null, then you can use
    another approach as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The additional question mark and colon (`?:` ) is called the **Elvis operator**.
    It is basically similar to the if-else block and returns the length if not null.
    If it is null, then it will return `-1`. This is basically the short form of a
    ternary operator, such as `if(a) ? b : c` , but cleaner and more compact. This will
    prevent any accidental `NullPointerException` at runtime.'
  prefs: []
  type: TYPE_NORMAL
- en: Data classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You might have created a class that is a simple data container without specific
    business logic or functionality. Such a scenario happens while following the value
    object or the data transfer object pattern. Typically, such classes look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: There is nothing special in this class, just a few properties, getters, setters,
    constructor, and the implementation of `hashCode()`, `equals()`, and `toString()`.
    Lots of boilerplate code would really distract any business functionality. Due
    to this, the code becomes less readable, searchable, and verbose.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the help of modern IDEs, it is just a matter of a few clicks to generate
    this code, but still it has a readability issue. The same code written in Kotlin
    is not only much cleaner on the first view but also helps with focusing on the
    important part out of the boring boilerplate stuff, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Everything is covered in just a single line of code, and it is also more readable.
    A declaration such as this will create setters, getters, constructor, and the
    implementation of the `toString()`, `hashCode()`, and `equals()` methods along
    with other useful functionalities behind the curtain by Kotlin. If you want to
    make your class immutable, just declare the properties with `val` instead of `var`
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Immutable variables can be defined with `val` in Kotlin. You can now call only
    getters on the object of the `StudentVOKotlin` class. We can use this class as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This really makes the code compact and readable.
  prefs: []
  type: TYPE_NORMAL
- en: Interoperability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have seen, Kotlin is fully interoperable with Java so that you can write
    Java and Kotlin functions altogether in the same project and call them from each
    other. Let's understand how that magic happens. Before that, let's look at how
    things happen behind the scenes.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, you wrote a Kotlin function in the `CheckOperability.kt` file
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'This code will be compiled by the Kotlin compiler and converted into byte code.
    The generated Java class file will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, Kotlin converts the `.kt` file (`CheckInterOperabilityKt.class`)
    into a corresponding Java class. The `greeting()` function defined in Kotlin is
    also converted to a Java function. By default, all functions in Kotlin are static.
    Also, Kotlin is not forcing you to define a `void` in case there is no-return
    value. (Kotlin has `Unit` in place of `void` actually.) While converting, it will
    add `void` along with a `static` keyword to the function.
  prefs: []
  type: TYPE_NORMAL
- en: We will now see how we can call the Java code from Kotlin, and vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: Calling the Kotlin code from Java
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s create a Kotlin function that simply does multiplication of two given
    numbers in the `KotlinFile.kt` file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: We want to call a Kotlin `multiply()` function into a Java class. As we know,
    the Kotlin compiler processes this file into a Java class, where it defines the
    `multiply()` method as a static method of the `KotlinFileKt.class` generated class file, so
    that it can be accessible with the `KotlinFileKt.multiply()` expression.
  prefs: []
  type: TYPE_NORMAL
- en: In case you wish to change the Java class file name from the Kotlin source,
    you need to define it as `@file:JvmName("CustomKotlinFile")` in the Kotlin file.
    In this case, the Kotlin compiler will generate the `CustomKotlinFile.class` file
    and the function can be accessed with the `CustomKotlinFile.multiply()` call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s first add the Java class and call the Kotlin function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: This is how the Kotlin function can be called from the Java class. Now let's
    see how to call a Java function from Kotlin.
  prefs: []
  type: TYPE_NORMAL
- en: Calling Java code from Kotlin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s define a function that simply does the addition of two numbers in a
    Java file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'This can be called in the Kotlin file in a similar way to how we called the
    Kotlin code into Java. Since this is a static function, we can call it with the
    Java class in Kotlin as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The `main` function in Kotlin represents the execution point similar to `public
    static void main()` in Java.
  prefs: []
  type: TYPE_NORMAL
- en: Smart casts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While working with Java, you may face the scenario where you need to cast the
    object before further processing. However, even if there is certainty about the
    type of object that you are passing, you still need to cast the object explicitly
    in Java as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: If we try to call `greetingMsg()` without an explicit cast, the Java compiler
    will show an error because the `name` variable is of the `Object` type. In this
    case, although the compiler knows that `name` can be only of the `String` type
    (through the condition `if(name instanceOf String)`), the Java compiler needs
    explicit casting. In other words, we need to perform casting, even though it is
    actually redundant.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, in the case of Kotlin, you are not required to cast explicitly if
    a parameter is proven to be of a required type. This code can be written in Kotlin
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The `Any` type in Kotlin is equivalent to `Object` in Java. In this code, the
    compiler knows that the input given to the `greetingMsg` function can only be
    of the `String` type (with the `if` condition) so an explicit cast is not required.
    This is called **smart** **cast** in Kotlin.
  prefs: []
  type: TYPE_NORMAL
- en: Operator overloading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Operator overloading is another convenient feature of Kotlin, which makes it
    more expressive and readable. It allows you to use standard symbols such as `+`,
    `-`, `*`, `/`, `%`, `<`, `>`, and so on, to perform various operations on any
    object. Under the hood, operator overloading initiates a function call to perform
    various mathematical operations, comparisons, indexing operations with arrays,
    and lots more.
  prefs: []
  type: TYPE_NORMAL
- en: 'The classes such as int, byte, short, long, double, float, and so on, have
    defined corresponding functions for each of these operators. For example: if we
    do `a+b` on an integer, Kotlin will call `a.plus(b)` internally as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Both print statements show the same result. We can define how operators work
    for custom classes by overloading corresponding functions. For example, we have
    a class called `CoordinatePoint`, which represents the x and y coordinates for
    a given point in the graph. If we want to override the operators on this class,
    then it should be coded as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The `CoordinatePoint` class is our custom class, and the `plus()` and `minus()` functions
    are actually called when the objects of this class are used along with the corresponding
    operators. The `operator` keyword is used to associate the corresponding function
    with the operators.
  prefs: []
  type: TYPE_NORMAL
- en: Apart from arithmetic, Kotlin supports other operators, such as **index access**
    operators, **in** operators, **invoke** operators, **argument** **assignment**
    operators, **equal** operators, **function** operators, and so on. With operator
    overloading, this code is more compact and concise and of course is clearer as
    well.
  prefs: []
  type: TYPE_NORMAL
- en: Kotlin versus Java
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After going through the feature richness of Kotlin, it would be really helpful
    to compare it to Java. This is not to prove a particular language is more appropriate
    than the other, but rather to just list the differences to make the choice easier
    for different scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Null safety**: Kotlin provides a nice way to define and handle nullable types,
    whereas Java does not have a similar feature out of the box.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Extension function**: Java needs an inheritance to extend the class, whereas
    Kotlin allows you to define the extension function without inheriting any class.
    You can define an extension function for custom classes as well.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Type reference**: In Java, we need to specify the type of variable explicitly,
    but Kotlin will handle it based on the assignment so you do not have to define
    the type in all the scenarios.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Functional programming**: Kotlin is a functional language and provides many
    useful features for functions. Java, on the other hand, has started supporting
    lambda expressions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Coroutine support**: Coroutines are lightweight threads used to handle asynchronous,
    non-blocking code. Kotlin support coroutines out of the box. The Co-routines are
    managed by users. Java, on other hand, supports similar functionality with multithreads
    managed by the underlying OS.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data class**: In Java, we need to declare constructors, getters, setters,
    `toString()`, `hashCode()`, and `equals()` manually, while Kotlin does all that
    behind the scene.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Smart cast**: Java needs to check for cast explicitly, while Kotlin does
    this job smartly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Checked exception**: Java does support checked exceptions, whereas Kotlin
    does not support them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring supports for Kotlin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Due to its stunning features, Kotlin has rapidly grown in popularity, and many
    frameworks have started supporting it. The Spring Framework has allowed the development
    of Spring applications with Kotlin since version 5\. Though Kotlin is fully interoperable
    with Java, you can write an application with pure and fully idiomatic Kotlin code.
    The diverse range of Kotlin features enhances productivity and combines well with
    Spring for application development.
  prefs: []
  type: TYPE_NORMAL
- en: As we have seen, the extension function in Kotlin is a non-intrusive way of
    providing a better alternative to the utility class or creating a class hierarchy
    for adding new features. Spring has used this feature to apply new Kotlin specific
    capabilities to existing Spring APIs. It is mainly used for dependency management. In
    the same way, Spring has also made framework APIs null safe to take full advantage
    of Kotlin.
  prefs: []
  type: TYPE_NORMAL
- en: Even Spring Boot has first-class Kotlin support, starting from version 2.x.
    This means you can write Spring-based applications in Kotlin as if Spring was
    a native framework of Kotlin. The current version of Kotlin released in October
    2018 is 1.3, and Spring supports Kotlin 1.1 and higher.
  prefs: []
  type: TYPE_NORMAL
- en: Developing an application – Task Management System
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter aims to create an application called **Task Management System**
    (**TMS**) with Spring Boot and Kotlin. In previous chapters, we created various
    applications in Java. In this section, we will learn how to develop Spring-based
    applications in Kotlin with Spring Boot.
  prefs: []
  type: TYPE_NORMAL
- en: 'With TMS, we will implement the following functionalities; instead of making
    full-fledged and feature-rich applications, our focus will be on how to leverage
    Kotlin capability while developing Spring-based applications:'
  prefs: []
  type: TYPE_NORMAL
- en: Task creation and assigning to the user.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: View, update, and delete the task by an admin user.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add comments to a given task by the admin and normal user to whom the task is
    assigned.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement authentication and authorization with Spring Security.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For simplicity, we will expose the REST service to add users. There will be
    one admin user and one or more normal users.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a Spring Boot project with Kotlin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first thing is to create a project structure through the Spring Boot initializer.
    In all previous chapters, we created a project structure in **Spring Tool Suit** (**STS**—an
    Eclipse-based IDE). There is another way to create it from the web. Go to the  [https://start.spring.io/](https://start.spring.io/) URL,
    and fill in the data as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b2d965e3-a06a-4333-b41c-5bbe1b59bdce.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Make sure you select Kotlin as a programming language option along with latest
    stable Spring Boot version (2.1.2 as of now). Also select the dependencies as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'JPA: Used to interact with the database through **Java Persistence API** (**JPA**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Web: Add Spring **Model-View-Controller** (**MVC**) specific features'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Security: Required to add Spring Security capabilities'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'DevTools: To make live reload on code changes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Thymeleaf: Designing the views with Thymeleaf templates'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'MySQL: Java connector to interact with the MySQL database'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Click on the Generate Project button, and you will see an application structure
    is downloaded as a ZIP bundle. Just unzip it in your local machine. So far, we
    have used STS—an Eclipse IDE—as an IDE to develop various applications in previous
    chapters. However, for a more comprehensive experience, we will use IntelliJ IDEA
    (a well-known IDE  native with support for Kotlin) in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'IntelliJ IDEA ships in two versions: Community and Ultimate. The former is
    available free of cost for JVM and Android-based development, while the later
    is for web and enterprise development, with more feature support. It is available
    for popular operating systems—Windows, macOS, and Linux. We will use the Community
    version. Download it from the [https://www.jetbrains.com/idea/download](https://www.jetbrains.com/idea/download) URL,
    and install it on your local machine.'
  prefs: []
  type: TYPE_NORMAL
- en: To import the project, open the IntelliJ IDEA IDE, select the File | Open menu,
    and select the extracted project structure folder that we have downloaded from
    the Spring initializer. The very first difference you will see in the Kotlin-based
    Spring application is the folder structure. The Kotlin source code will reside
    in `src/main/kotlin` compared to `src/main/java`for standard Java-based applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'To support Kotlin, Spring requires certain dependencies, which are added automatically
    to `pom.xml` while generating it from the Spring initializer. You will see the
    Kotlin specific dependencies as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The `kotlin-stdlib-jdk8` dependency is required for Kotlin 1.2 and higher versions.
    For Kotlin 1.1, you need to use `kotlin-stdlib-jre8`. The Kotlin-reflect is a
    reflection feature used in Kotlin.
  prefs: []
  type: TYPE_NORMAL
- en: DB design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To store task-related data, we will use the MySQL database. We will also store
    user and role information in database tables. The tables and their relationship
    details look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7735aa6d-919b-4860-9a9d-53929f0626f6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The table details are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**task:** This table stores the details about tasks added into the system.
    It has a one-to-many relationship with the **comments** table.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**comments:** When a user enters a **task** comment, it will be added to this
    table.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**users:** This is a master table to store user details. It has a many-to-many
    relationship with the table **role**. It also has a one-to-many relationship with
    the **task** and **comments** tables.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**role:** This is a master table for roles. Mainly, there are two roles—`ROLE_USER`
    and `ROLE_ADMIN`. It has a many-to-many relationship with the table **users**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**user_role:** This is a link table and will store the associated data of **role** and
    **users**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Entity classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will use Spring Data JPA to interact with the database, so first we need
    to write entity classes. An entity class will be mapped to a database table, and
    its attributes are mapped to the table columns. The JPA entity class is a user-defined
    POJO class, which is nothing but an ordinary Java class with certain JPA specific
    annotation and is capable of presenting the objects in the database.
  prefs: []
  type: TYPE_NORMAL
- en: We will create a separate entity class for each of the tables except the link
    table **user_role**, which is handled with the `@ManyToMany` annotation. The details
    are as follows.
  prefs: []
  type: TYPE_NORMAL
- en: Users
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Entity class for the `users` table should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The `@Entity` annotation is used to declare that the class is a JPA entity.
    The `@Table` annotation is used to map the class with a specific database table.
    The attributes of this class are mapped to the respective columns with the `@Column`
    annotation. The attributes are defined as nullable, as they will be populated
    at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `@JoinTable` annotation is used to declare the link table, and `JoinColumn`
    is used to define the column reference between tables associated with a many-to-many
    relationship along with the link table. The many-to-many relationship declaration
    in Kotlin is a little bit different than in Java. The same configuration is declared
    in Java as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The visible difference here is the declaration of the `joinColumns` attribute
    of the `@JoinTable` annotation. In Java, it is declared with an annotation, while
    in Kotlin it is defined as an array. Another difference is defining the `cascade`
    attribute in the `@ManyToMany` annotation.
  prefs: []
  type: TYPE_NORMAL
- en: Role
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The entity class corresponding to the `role` table looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: In the many-to-many relationship between `User` and `Role` entities, the ownership
    is with the`User` entity so the `@ManyToMany` annotation in the `Role` entity
    is defined with the `mappedBy` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: Task
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The entity class associated to `task` table should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The `@OneToMany` annotation is used to declare a one-to-many relationship with
    the `comments` table. The `@JoinColumn` annotation is used to declare the column
    reference in the `comments` table.
  prefs: []
  type: TYPE_NORMAL
- en: Comments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The entity class for `comments` table should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: The `@ManyToOne` annotation is used to declare a many-to-one relationship with
    a **task** table. The `@JoinColumn` annotation is used to define the reference
    column (primary key).
  prefs: []
  type: TYPE_NORMAL
- en: Spring Security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring Security is the de facto standard for implementing security constraints
    in Spring-based applications. In previous chapters, we used Spring Security with
    an in-memory model while implementing user authentication and authorization. The
    in-memory model should only be used for testing purposes only. In a real scenario,
    authentication and authorization details are fetched from other systems to make
    it loosely coupled with the application code, such as LDAP, OAuth, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 3](e32452e8-07bb-4815-96d6-b0db0a6009ba.xhtml), *Blogpress – A
    Simple Blog Management System*, we learned how to configure Spring Security with
    LDAP and OAuth in detail. In this chapter, we will use database tables to store
    authentication and authorization details. First, let''s create a class and define
    the security configuration as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a typical security configuration. The way we declared annotation for
    Kotlin is similar to what we have done with Java. However, there are differences
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: In Kotlin, we can use a colon (`:`) to declare inheritance. The `WebSecurityConfigurerAdapter` class
    is a parent class, but with the surprise that it is a Java class. You can extend
    your Kotlin class from another Java class, and it is absolutely fine. This is
    how Kotlin is deeply interoperable with Java. Another difference is the parent
    class is used with the constructor notation (with brackets).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To override a method from the parent class, Kotlin uses the `override` keyword.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since Kotlin does not support checked exceptions directly, the `@Throws` annotation
    is used to define the exception details.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next, the access mechanism needs to be configured to various pages in the system.
    This can be done by overriding the configure method, which basically provides
    an HTTP specific security configuration. It looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: The noticeable things here are we have configured various URLs accessible for
    all users, even without login, and only the admin needs to log in. We also have
    configured the login, success, and failure URLs along with the logout URL. We
    will talk more about them in the *Defining the Spring MVC controller* section.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will configure an authentication mechanism. Spring supports various
    options such as in-memory, LDAP, OAuth, and so on. For this application, we will
    fetch user details from the database. To implement Spring Security with the database,
    there are two approaches.
  prefs: []
  type: TYPE_NORMAL
- en: Query approach
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Spring Security needs users and their role details to perform the security
    check. In this approach, we will fetch the user and role details with a SQL query.
    We will define a query in the `application.properties` file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The first query fetches user details while second queries retrieve the list
    of roles for a given username. These properties can be read in the `WebSecurityConfig`
    class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: In Kotlin, the symbol `$` is used to print the variable within `String` without
    explicitly using the `+` operator. Since we want to read the property from the `application.properties`
    file, we have to use the escape character (`\`) along with the `$` operator. Apart
    from this, the variables are declared as nullable (with `String?`) as they will
    be populated by Spring at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will override the `configure()` method to define the authentication
    configuration as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The nice thing about IntelliJ IDEA is, whenever you pass any Java code, it
    will prompt to convert to Java. On choosing yes, it will automatically convert
    Java code into Kotlin code. The `!!` symbol is a not-null assertion operator,
    which basically converts any value to a non-null type and throws a `NullPointerException`
    if the variable is null. It is part of the null safety feature of Kotlin. The
    `dataSource` and `passwordEncoder` methods can be defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The `dataSource` will be injected by Spring at runtime, so it must be declared
    as nullable (with `?`). We will use `BCryptPasswordEncoder` to encode the password
    with the `bcrpt` algorithm, which is considered to be a very strong encoding algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: The `userQuery` and `roleQuery` objects are not necessarily required.  If you
    do not provide them, you need to design the tables with predefined names and columns.
    The user table must be created with a name—`users` with columns `username`, `password`,
    and `enabled` , while the **role** table must be created with a name—`authorities`.
  prefs: []
  type: TYPE_NORMAL
- en: This approach has certain restrictions. For example: `userQuery` must return
    the `username`, `password`, and `enabled` column value in the same sequence and  `roleQuery`
    must return  `username` and `role name` in the same sequence. If any change happens
    in this sequence, it may not work properly.
  prefs: []
  type: TYPE_NORMAL
- en: UserDetailsService approach
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another approach to fetch use and role information is using the `UserDetailsService`
    interface. It is an abstract way to fetch authentication and authorization details.
    It has one method—`loadUserByUsername()` that will return user details based on
    `username`. You can override it and write your own logic to retrieve the user
    details.
  prefs: []
  type: TYPE_NORMAL
- en: 'Spring provides a class called `DaoAuthenticationProvider` that basically uses
    the `UserDetailsService` implementation to fetch user details during the authentication
    process. The flexibility in this approach means we can define a custom method
    to fetch user details. We will define a method in the JPA repository for the `User`
    entity. The JPA is a standard way of interacting with a relational database with
    Java objects. The repository looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '`UserRepository` is a Kotlin interface that extends the Java `JpaRepository` interface.
    The `@Repository` annotation is used to declare this interface as a JPA repository.
    The `findByUsername` method is a query method, which will fetch the user. Spring
    Data JPA has an inbuilt query building mechanism, based on the repository method
    name.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For the `findByUsername` method, it will first remove the `findBy` prefix and
    compose the query from the rest of the method name. In this case, it will internally
    create a query, such as `select * from users where username=?`. This method returns
    an object of the `User` entity class. Next, we need to provide a custom user service,
    and for that we will implement `UserDetailsService` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: The `CustomUserDetailsService` class is declared with a `@Service` annotation
    to declare it as a service component. It overrides a `loadUserByUsername()` method,
    where we can write custom logic to fetch user details. A repository `findByUsername()` method
    that we have created is used here to fetch user details.
  prefs: []
  type: TYPE_NORMAL
- en: 'The return type is `UserDetails` that is an interface that actually stores
    user information, which is then encapsulated to authenticate objects later. We
    have created a `CustomUserPrinciple` class to provide an implementation of `UserDetails`
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'The `UserDetails` interface requires the implementation of certain methods
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`isEnable()`: This method basically returns if the user is activated or not.
    In a practical scenario, there must be a separate database column to check if
    the user is enabled or not. For simplicity, we simply return `true`  assuming
    that all users are enabled. If the user returns `false`, Spring Security will
    not allow login.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getUsername()`: This simply returns the username.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`isCredentialsNonExpired()`: This is a very useful method when you want to
    impose a constraint on the user to update the password after a certain time limit.
    In this method, you need to check whether the password has expired, based on your
    requirement, and return the value accordingly. For simplicity, if we return `true` ,
    it means password has not expired.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getPassword()`: It should return the password.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`isAccountNonExpired()`: This indicates whether a user account has expired
    or not. To make it simple, we just return `true`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`isAccountNonLocked()`: This is used to check whether a user account is locked.
    Again, for simplicity, we a just return `true`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getAuthorities()`: This method returns authorities granted to the user. We
    retrieve roles from a user object and wrap them in a `GrantedAuthority` type.
    The `GrantedAuthority` is an interface. We have provided an implementation through the `CustomGrantedAuthority`
    class as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: We are injecting a user object through the constructor, which can be used to
    retrieve further details in each of these methods.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The last part is to define the Spring Security configuration. Add methods to
    the `WebSecurityConfig` class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'The `authenticationProvider()` method simply creates an object of the `DaoAuthenticationProvider` type,
    configure it with user detail service object and password encoder and return.
    It is then used in the `configure()` method to set as the authentication provider.
    The object of `UserDetailService` can be injected in the same class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: This approach is more flexible in terms of allowing a customized way to fetch
    user details, which are then used by Spring to perform various security constraints.
    It simply decouples the logic of authentication and authorization from the mechanism
    to fetch user details. This makes the system more flexible.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the Spring MVC controller
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our backend layer is ready, and now we will design the controller and view
    layer. We have decided to user Spring MVC for the frontend, which is the best
    fit for web-based Spring applications. The declaration of Spring MVC controller
    in Kotlin is similar to what we have done in Java, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'The Kotlin `TaskMgmtSystemController` class is declared with the `@Controller`
    annotation, which is used to define the class as a Spring MVC controller. The
    way of defining controller methods in Kotlin is also similar to Java. For example:
    a home page can be shown by the following controller method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: This method is mapped with the `/` URL (accessible at [http://localhost:8080](http://localhost:8080))
    and returns a home page. As mentioned, we are going to use Thymeleaf templates
    to construct a view layer.
  prefs: []
  type: TYPE_NORMAL
- en: If you are not very familiar with Thymeleaf, it is a natural template engine
    used to produce views, which are processed at the server side. A detail explanation
    was given in [Chapter 3](e32452e8-07bb-4815-96d6-b0db0a6009ba.xhtml)*, Blogpress
    – A Simple Blog Management System,* of this book. You can refer to it to get more
    idea about how Thymeleaf works with Spring.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also have defined constants to access predefined values. Unlike Java, we
    can not define constants in the Kotlin interface. To define constants, we will
    use a singleton class. In Kotlin, we can create a singleton class by an object
    declaration feature. This can be achieved with the `object` keyword. The `TaskMgmntConstant` singleton
    class looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Though there is no `class` keyword used here, this code combines both `class`
    and the singleton declaration altogether. Internally, Kotlin will create a single
    static instance of the `TaskMgmntConstant` class. The `object` declaration can
    contain functions as well, which can be accessed with the `object` declaration
    name directly. It is similar to accessing the static variables and methods of
    the class type in Java.
  prefs: []
  type: TYPE_NORMAL
- en: The `const` keyword is used to define constants. The variables declared with
    the `const` keyword are compile-time constants, meaning they must be populated
    at the time of compilation. Because of this reason, they can not be assigned to
    function or class constructors but only to a string or primitives.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will see how to define controller methods for other operations as follows.
  prefs: []
  type: TYPE_NORMAL
- en: Showing the control page
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When a user does log in, the system will land on a page called the control
    page. From this page, users can view the task and perform various operations based
    on the role they have. For example: a normal user can see the task list assigned
    to it and also able to add a comment for a specific task. The admin user can add
    a new task, edit, and delete an existing one. This controller method simply redirects
    the user to the landing (or control) page. The code looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: In the *Spring Security* section, we configured `/controlPage` accessible to
    normal and admin users. It cannot be accessed without login.
  prefs: []
  type: TYPE_NORMAL
- en: Showing the login page
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This controller method will redirect the user to the login page. It looks as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: It is accessible from the navigation menu. This method also handles an error
    in the case of invalid credentials and shows an appropriate message to the user.
  prefs: []
  type: TYPE_NORMAL
- en: Showing the add new task page
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The add new task feature is configured to allow only admin users. It will redirect
    the user to the add new task page. The code looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: The  `/showAddTask` URL is configured as a navigation menu in the control page.
  prefs: []
  type: TYPE_NORMAL
- en: Showing the edit task page
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Only admin users can edit existing tasks. Admin users can see an Edit button
    for each task record on task—list screen. Upon clicking it, this method will be
    triggered. It looks as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'The `taskId` parameter will be sent as a request parameter from the task list
    screen. First, we fetch the task object from a given `taskId` with `taskRepository`
    and then copy it to the `TaskDTO` object. You can see we have declared variables
    with the `val` keyword, which is used to declare constants. Kotlin recommends
    using `val` in case the variable is not changed after assigning the value. The
    `TaskDTO` class is a data class defined in Kotlin as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'The Edit Task screen looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/95e80311-3475-48d1-93f3-96d63fb1f4bd.png)'
  prefs: []
  type: TYPE_IMG
- en: Adding a new task
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Only admin users can add a new task. This controller method will insert the
    task record in the database. It looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: The `title`, `detail`, and `userId` parameters (to whom the task is assigned)
    are provided from the add task screen. This method simply creates an instance
    of the `Task` class, populates its value, and saves it in `taskRepsitory`. Unlike
    Java, the instance can be created without the `new` keyword in Kotlin. Also, Kotlin
    defers the type of variable wherever it is possible. For example, we have not
    defined the type of the `task` variable because it is assigned the object of the `Task` type
    class so Kotlin understands that it is the `Task` type only.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of redirecting to a specific page, we are redirecting to another controller
    method with the `/allTaskList` URL pattern, which basically shows a task list.
  prefs: []
  type: TYPE_NORMAL
- en: Updating a task
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Updating a task is similar to adding a new task method. Only admin users can
    update the existing task. This method looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: The code looks similar to the `addTask()` method. The only difference is we
    get the `taskId` of the existing task as an additional parameter. First, we retrieve
    it, update its value, and finally save it with `taskRepository`. This method also
    redirects to another controller method to show a task list with an `/allTaskList` URL
    pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a task comment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Normal and admin users can add comments to an existing task. On opening the
    task in view mode, the screen provides a facility to add a comment. The code of
    the controller method for adding task comments looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: In this method, the `taskId` and `taskComment` parameters are supplied by the view
    task screen from where the user can add the comment. We fetch the `Task` object
    from `taskId` and fetch its comments as a mutable set.
  prefs: []
  type: TYPE_NORMAL
- en: Kotlin provides an API collection (list, set, map, and so on) with a clear distinction
    between mutable and immutable types. This is very handy to ensure you avoid bugs
    and design clear APIs. When you declare any collection, say, `List<out T>`, it
    is immutable by default and Kotlin allows read-only operations, such as `size()`,
    `get()`, and so on. You cannot add any element to it.
  prefs: []
  type: TYPE_NORMAL
- en: If you wish to modify the collection, you need to use mutable types explicitly,
    such as `MutableList<String>`, `MutableMap<String, String>`, and so on. In our
    case, we need to add a comment in the existing set so we used the `MutableSet`
    type. The comment set is empty while adding the first comment so we create an
    empty set with the `mutableSetOf()` method. This method is used to create a collection
    of the `Set` type on the fly.
  prefs: []
  type: TYPE_NORMAL
- en: We also need to add `userId` of the currently logged-in user to a comment. To
    do so, we make a call to `SecurityContextHolder.getContext().authentication.principal`.
    The `SecurityContextHolder` class is provided by Spring Security, and it is used
    to get various security-related information.
  prefs: []
  type: TYPE_NORMAL
- en: Getting all users
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This method will return all users available in the system. It is used to create
    a task screen to fetch a user list to choose for a task assignment. The method
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: We call it from the model popup in the add task screen. The UI will be rendered
    by the Thymeleaf template—`users.html`*.*
  prefs: []
  type: TYPE_NORMAL
- en: Showing a task list
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This method shows the list of tasks to both normal and admin users. The difference
    is a normal user can only view and add comments, while the admin user can view,
    edit, and delete operations on a task record. Another difference is a normal user
    can see a list of tasks assigned to it, while an admin user can see all tasks
    available in the system. The method should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'This method serves two operations, based on the `myTask` request parameter.
    If it is available then pull the tasks assigned to current users only or else
    fetch all tasks. Fetching all tasks is available to the user with the admin role. After
    fetching the tasks from the database, we map them on to an object of the `TaskDTO`
    class. The **data transfer object** (**DTO**) is the Kotlin data class and looks
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: In the task list, we show the name of the user to whom the task is assigned.
    In the `task` table, we store `userId` , so we need to fetch the username by combining
    the task and user tables. Spring Data JAP provides a convenient way of fetching
    results of complex queries with the `@Query` annotation.
  prefs: []
  type: TYPE_NORMAL
- en: 'This annotation is used to define a query using JAP query language (and even
    native SQL query) and bind it to the method of the JPA repository. When we call
    that repository method, JPA will execute the query attached to that method with
    the `@Query` annotation. Let''s define two methods with join query on a repository
    interface as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: The first method will fetch all tasks available in the system, while the second
    method will fetch tasks that are assigned to a specific user only. The `nativeQery` attribute
    indicates that it is a SQL query. Since this query returns columns from multiple
    tables (**task** and **users** in our case), it returns a list of an array of
    the `Any` type, instead of a specific entity class object. The `List` object represents
    the records row, the elements of `Array` are columns, and `Any` means any available
    type in Kotlin. `Any` is equivalent to `Object` in Java.
  prefs: []
  type: TYPE_NORMAL
- en: 'It can be then used to populate the `TaskDTO` object in the controller method—`showAllTaskList`.
    The keyword `as` is used to do casting from `Any` to a respective type. Kotlin
    compiler uses smart cast so you don''t need to explicitly check if the `Any` type
    given is compatible. For admin users, the task list screen looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/03c35fa4-fe75-44f5-8a64-7994e74c3498.png)'
  prefs: []
  type: TYPE_IMG
- en: 'For the normal user, it looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7dae280f-8eba-41cd-9ecc-6d9e87392924.png)'
  prefs: []
  type: TYPE_IMG
- en: Viewing a task
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The view task screen will open the task in view mode, meaning it will show
    the details of the task. It also allows you to add a comment and shows the list
    of comments added to the selected task. The controller method for viewing the
    task will populate the task and comment data, and redirects the user to view the
    task screen. The method looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'The `taskId` parameter will be sent from a task list screen. First, we fetch
    the task detail from a given `taskId`. We also fetch the user data from the user
    ID associated with the `Task` object. For comments, we do the same thing: fetch
    comments with a given `taskId` from `commentRepository`.'
  prefs: []
  type: TYPE_NORMAL
- en: We fetch comments from `commentRepository` , but we could have fetched it from
    the `Task` object, since they have one-to-many relationships. The reason we do
    not fetch them that way is, we want to show the username to whom the task is assigned.
    If we fetch comments from `Task`, it will return the collection of the object
    of the `Comments` type, which has a user ID but not first and last name. So we
    might have to make an additional round of database calls to fetch the user first
    and last name for each comments record. This may result in a poor performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an alternative, we use a JPA query language mechanism, by associating the `join`
    SQL query with the repository method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'It is returned as a `List<Array<Any>>` type because the data is fetched from
    multiple tables (**task** and **comments**). We are iterating it and populating
    the list of `CommentDTO` , which is defined as a data class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: The  `TaskDTO` object is used to show task details while the list of `CommentDTO`
    is used to show comments in tabular format in the view task screen.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting a task
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Only admin users can delete an existing task. The delete option is visible
    in the task list screen. The controller method of deleting a task looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: The `taskId` parameter is provided in the task list screen. First, we fetch
    the object of `Task` with `taskId` from `taskRepository` and delete if it is not
    null. Finally, we redirect to another controller method with the `/allTaskList` URL
    to show the task list screen.
  prefs: []
  type: TYPE_NORMAL
- en: REST call in Kotlin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s understand how to make a REST call with Kotlin. We expose the REST API
    to add users to the system. Basic user details along with role information need
    to be given. Defining REST controller in Kotlin is similar to Java as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'The `TaskMgmntRESTController` Kotlin class is defined as a REST controller
    with `@RestController` and configures the `/api` URL pattern with the `@RequestMapping`
    annotation. We will write a function that handles the registration of users as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'This function is defined with the `@PostMapping` annotation so data must be
    sent with the HTTP POST method. Also, the URL mapping is `/register` so the effective
    path would be `/api/register` to access this function (method). It consumes the
    data in JSON format. Spring will populate an object of `UserRegistrationDTO` from
    the JSON input. The Kotlin data class is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'The `username`, `password`, `firstname`, and `lastname` attributes are used
    to insert a record in the user table, while the `roleList` attribute is used to
    associate the roles this user has. The input data must be given in JSON format
    with the HTTP POST method from the REST client as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: The code written in the `registerNewUser` method will be divided into the following
    two parts.
  prefs: []
  type: TYPE_NORMAL
- en: Validation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A user sends the data in JSON format and it must be validated before entering
    into the system to avoid any backend errors. Instead of imposing a full list of
    validations, we will implement a few basic validations. For example, validating
    an existing username,the role list has invalid values other than `ROLR_USER` and
    `ROLE_ADMIN`. The code looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we check whether the username sent in JSON data already exists in the
    system. If it does, then return an appropriate message. The second check is about
    the role list. We have created a predefined role list in the `TaskMgmntConstant`
    class with the function declaration as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: Let's recall that `TaskMgmntConstant` is singleton class and we can define functions
    apart from constants. If the `roleList` data sent as a JSON string is different
    than these two roles, then we show an appropriate message. You can see how a for-loop
    is used by the `forEach` method with a lambda expression. If any error occurs,
    we send a validation message with HTTP status 401 (`HttpStatus.BAD_REQUEST`).
  prefs: []
  type: TYPE_NORMAL
- en: User registration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If all validations are satisfied, then we will do user registration along with
    role mapping with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: In this code, we create the `User` object and populate its value from the `UserRegistrationDTO`
    object. We also create the mutable role list and populate it by fetching roles
    with `roleRepository` , based on the role name populated in `UserRegistrationDTO`
    from the JSON data. Finally, we associate the mutable set with the `User` object
    and save it in `userRepository`.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned the basics of Kotlin and its various features, and
    then created an application with Spring Boot and Kotlin. Within a short time span,
    Kotlin has gained huge momentum and popularity due to its capabilities, such as
    its interoperability, conciseness, safety features, and support for well-known
    IDEs.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Framework has lots of features and is widely used in developing modern
    enterprise applications. With its first class support of various programming languages
    such as Java, Scala, Groovy, and Kotlin, Spring Framework has become a dominant
    player among enterprise-application development frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Framework has a modular design and provides seamless integration in all
    aspects of the system, such as the frontend, controller layer, security, persistence,
    cloud support, messaging support, web flow, and lots more. With the invention
    of Spring Boot, developing Spring-based applications has become easier than ever
    before.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout this book, we have explored the Spring Framework, showcasing its
    capabilities by developing a sample application in each chapter. This should definitely
    build your confidence and encourage you to explore the framework further. However, we
    recommend you create more sample apps so that you gain more hands-on experience
    and you really get the most out of the framework.
  prefs: []
  type: TYPE_NORMAL
- en: Here is a perfect way to finish our journey. For further reading, you can refer
    to the official Spring documentation and forums. Spring has a huge active community,
    and you can find many personal blogs that will help you to learn and explore the
    concepts.
  prefs: []
  type: TYPE_NORMAL
