- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Additional Jakarta Faces Features
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 额外的Jakarta Faces功能
- en: In this chapter, we will cover the additional features of Jakarta Faces, the
    standard component framework for Jakarta EE. These additional features allow us
    to make our web application user-friendly, while providing features that are convenient
    for application developers.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍Jakarta EE的标准组件框架Jakarta Faces的附加功能。这些附加功能使我们能够使我们的Web应用程序用户友好，同时为应用程序开发者提供方便的功能。
- en: 'In this chapter, we’ll cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Ajax-enabled Faces applications
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ajax启用的前端应用
- en: Jakarta Faces HTML5 support
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jakarta Faces对HTML5的支持
- en: Faces Flows
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Faces Flows
- en: Faces WebSocket support
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Faces WebSocket支持
- en: Additional Faces component libraries
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 额外的Faces组件库
- en: Note
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The source code for this chapter can be found on GitHub at: [https://github.com/PacktPublishing/Jakarta-EE-Application-Development/tree/main/ch07_src](https://github.com/PacktPublishing/Jakarta-EE-Application-Development/tree/main/ch07_src)'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的源代码可以在GitHub上找到：[https://github.com/PacktPublishing/Jakarta-EE-Application-Development/tree/main/ch07_src](https://github.com/PacktPublishing/Jakarta-EE-Application-Development/tree/main/ch07_src)
- en: Ajax-enabled Faces applications
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ajax启用的前端应用
- en: Jakarta Faces allows us to easily implement`<f:ajax>` tag and CDI named beans,
    without needing to implement any JavaScript code or having to parse JSON strings.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Jakarta Faces允许我们轻松实现`<f:ajax>`标签和CDI命名豆，而无需实现任何JavaScript代码或解析JSON字符串。
- en: The following markup illustrates the typical usage of the `<``f:ajax>` tag.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 以下标记展示了`<f:ajax>`标签的典型用法。
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: After deploying our application, the preceding markup renders as illustrated
    in *Figure 7**.1*.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在部署我们的应用程序后，前面的标记渲染如图*图7.1*所示。
- en: '![Figure 7.1: Faces Ajax functionality in action](img/B21231_7_01.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![图7.1：Faces Ajax功能演示](img/B21231_7_01.jpg)'
- en: Figure 7.1 – Faces Ajax functionality in action
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1 – Faces Ajax功能演示
- en: Our example illustrates two uses of the `<f:ajax>` tag. At the top of the page,
    we are using this tag by implementing a typical Ajax Echo example, in which we
    have an `<h:outputText>` component updating itself with the value of an input
    text component. Any time any character is entered into the input field, the value
    of the `<h:outputText>` component is automatically updated.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的示例说明了`<f:ajax>`标签的两个用途。在页面顶部，我们通过实现一个典型的Ajax Echo示例来使用这个标签，其中有一个`<h:outputText>`组件通过输入文本组件的值来更新自己。每当输入字段中输入任何字符时，`<h:outputText>`组件的值会自动更新。
- en: To implement the functionality described in the previous paragraph, we put an
    `<f:ajax>` tag inside an `<h:inputText>` tag. The value of the `render` attribute
    of the `<f:ajax>` tag must correspond to the ID of the component we wish to update
    after the Ajax request finishes. In our particular example, we wish to update
    the `<h:outputText>` component with an ID of `textVal`, therefore this is the
    value we use for the `render` attribute of our `<``f:ajax>` tag.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现上一段描述的功能，我们在一个`<h:inputText>`标签内放置了一个`<f:ajax>`标签。`<f:ajax>`标签的`render`属性值必须与Ajax请求完成后要更新的组件的ID相对应。在我们的特定示例中，我们希望更新ID为`textVal`的`<h:outputText>`组件，因此这就是我们为`<f:ajax>`标签的`render`属性使用的值。
- en: Note
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In some cases, we may need to render more than one Faces component after an
    Ajax event finishes. In order to accommodate for this, we can add several IDs
    as the value of the `render` attribute. We simply need to separate them with spaces.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们可能需要在Ajax事件完成后渲染多个Faces组件。为了适应这种情况，我们可以将多个ID作为`render`属性的值。我们只需用空格将它们分开即可。
- en: The other `<f:ajax>` attribute we used in this instance is the `event` attribute.
    This attribute indicates the JavaScript event that triggers the Ajax event. In
    this particular case, we need to trigger the event any time a key is released
    while a user is typing into the input field. Therefore the appropriate event to
    use is `keyup`.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个实例中，我们使用的另一个`<f:ajax>`属性是`event`属性。此属性指示触发Ajax事件的JavaScript事件。在这种情况下，我们需要在用户在输入字段中键入时释放任何键时触发事件。因此，适当的事件是`keyup`。
- en: 'The following table lists all supported JavaScript events:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格列出了所有支持的JavaScript事件：
- en: '| **Event** | **Description** |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| **事件** | **描述** |'
- en: '| --- | --- |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `blur` | The component loses focus |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| `blur` | 组件失去焦点 |'
- en: '| `change` | The component loses focus and its value has been modified |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| `change` | 组件失去焦点且其值已更改 |'
- en: '| `click` | The component is clicked on |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| `click` | 组件被点击 |'
- en: '| `dblclick` | The component is double-clicked on |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| `dblclick` | 组件被双击 |'
- en: '| `focus` | The component gains focus |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| `focus` | 组件获得焦点 |'
- en: '| `keydown` | A key is pressed down while the component has focus |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| `keydown` | 当组件获得焦点时按下键 |'
- en: '| `keypress` | A key is pressed or held down while the component has focus
    |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| `keypress` | 当组件获得焦点时按下或保持按键 |'
- en: '| `keyup` | A key is released while the component has focus |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| `keyup` | 当组件获得焦点时释放键 |'
- en: '| `mousedown` | The mouse button is depressed while the component has focus
    |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| `mousedown` | 当组件获得焦点时鼠标按钮被按下 |'
- en: '| `mousemove` | The mouse pointer is moved over the component |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| `mousemove` | 鼠标指针在组件上移动 |'
- en: '| `mouseout` | The mouse pointer leaves the component |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| `mouseout` | 鼠标指针离开组件 |'
- en: '| `mouseover` | The mouse pointer is placed over the component |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| `mouseover` | 鼠标指针放置在组件上 |'
- en: '| `mouseup` | The mouse button is released while the component has focus |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| `mouseup` | 当组件获得焦点时释放鼠标按钮 |'
- en: '| `select` | The component’s text is selected |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| `select` | 选择组件的文本 |'
- en: '| `valueChange` | Equivalent to change, the component loses focus and its value
    has been modified |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| `valueChange` | 等同于更改，组件失去焦点且其值已被修改 |'
- en: Table 7.1 – <f:ajax> tag JavaScript event attributes
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 表7.1 – `<f:ajax>`标签JavaScript事件属性
- en: We use the `<f:ajax>` once again farther down the page to Ajax-enable a command
    button component. In this instance, we want to recalculate a value based on the
    values of two input components. In order to have the values on the server updated
    with the latest user input, we used the `execute` attribute of `<f:ajax>`. This
    attribute takes a space-separated list of component IDs to use as input. We then
    use the `render` attribute just like before to specify which components need to
    be re-rendered after the Ajax request finishes.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次在页面下方使用`<f:ajax>`来启用一个命令按钮组件的Ajax功能。在这种情况下，我们想要根据两个输入组件的值重新计算一个值。为了将服务器上的值更新为最新的用户输入，我们使用了`<f:ajax>`的`execute`属性。此属性接受一个用空格分隔的组件ID列表，用作输入。然后，我们像之前一样使用`render`属性来指定在Ajax请求完成后需要重新渲染哪些组件。
- en: Notice we are using the `actionListener` attribute of `<h:commandButton>`. This
    attribute is typically used whenever we don’t need to navigate to another page
    after clicking the button. The value for this attribute is an action listener
    method we wrote in one of our named beans. Action listener methods must return
    void, and take an instance of `jakarta.faces.event.ActionEvent` as their sole
    parameter.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们正在使用`<h:commandButton>`的`actionListener`属性。此属性通常在我们点击按钮后不需要导航到另一个页面时使用。此属性的值是我们在一个名为bean中编写的动作监听器方法。动作监听器方法必须返回void，并接受一个`jakarta.faces.event.ActionEvent`实例作为其唯一参数。
- en: 'The named bean for our application looks like this:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序中名为bean看起来像这样：
- en: '[PRE1]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The value of the `actionListener` attribute on our `commandButton` is a Jakarta
    Expression Language method expression resolving to the `calculateTotal()` method
    on our CDI named bean. As such, this method is automatically invoked when the
    user clicks on the button labeled `firstOperand` and `secondOperand` variables
    are bound to the `value` attributes of those fields. As such, these variables
    are populated with the user-entered values on the page; our method simply adds
    those values and assigns them to the `total` variable. Then, the `outputText`
    component on the page bound to this variable is automatically updated.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们`commandButton`上的`actionListener`属性的值是一个Jakarta表达式语言方法表达式，解析到我们的CDI名为bean的`calculateTotal()`方法。因此，当用户点击标有`firstOperand`和`secondOperand`变量的按钮时，此方法会自动调用；这些变量绑定到这些字段的`value`属性。因此，这些变量被页面上的用户输入值填充；我们的方法只是将这些值相加并将它们分配给`total`变量。然后，页面上的`outputText`组件自动更新，该组件绑定到这个变量。
- en: Notice that we didn’t have to do anything special in our named bean to enable
    Ajax in our application. It is all controlled by the `<f:ajax>` tag on the page.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们不需要在我们的名为bean中做任何特殊操作来在我们的应用程序中启用Ajax。所有这些都由页面上的`<f:ajax>`标签控制。
- en: As we can see from this example, Ajax-enabled Faces applications are very simple.
    We simply need to use a single tag to enable Ajax on our page, without having
    to write a single line of JavaScript, JSON, or XML.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如此例所示，启用了Ajax的Faces应用程序非常简单。我们只需使用一个标签就能在我们的页面上启用Ajax，无需编写任何JavaScript、JSON或XML代码。
- en: Jakarta Faces HTML5 support
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Jakarta Faces HTML5支持
- en: '**HTML5** is the latest version of the HTML specification. It includes several
    improvements over previous versions of HTML. Jakarta Faces includes several features
    to make Faces pages work nicely with HTML5\. Jakarta Faces support for HTML5 includes
    the ability to develop our Jakarta Faces pages in HTML5 without using Faces-specific
    tags, along with the ability to add arbitrary HTML5 attributes to our Jakarta
    Faces pages.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '**HTML5** 是 HTML 规范的最新版本。它包括对之前 HTML 版本的多项改进。Jakarta Faces 包含了几个特性，使得 Faces
    页面能够很好地与 HTML5 一起工作。Jakarta Faces 对 HTML5 的支持包括在 HTML5 中开发我们的 Jakarta Faces 页面而不使用特定于
    Faces 的标签，以及将任意 HTML5 属性添加到我们的 Jakarta Faces 页面中。'
- en: HTML5-friendly markup
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HTML5 兼容的标记
- en: Through the use of pass-through elements, we can develop our Faces pages using
    HTML5, as opposed to using Faces-specific tags. Using HTML5 to develop our pages
    has the advantage that we can preview how our page renders in the browser without
    having to deploy our application to a Jakarta EE runtime. We can simply open the
    page in a web browser.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用透传元素，我们可以使用 HTML5 而不是使用特定于 Faces 的标签来开发我们的 Faces 页面。使用 HTML5 开发页面有一个优点，那就是我们可以在不将应用程序部署到
    Jakarta EE 运行时的情况下预览页面在浏览器中的渲染效果。我们只需在网页浏览器中打开页面即可。
- en: 'To do this, we need to specify at least one of the element attributes using
    the `jakarta.faces` XML namespace. The following example demonstrates this approach
    in action:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现这一点，我们需要使用`jakarta.faces` XML命名空间指定至少一个元素属性。以下示例展示了这一方法在实际中的应用：
- en: '[PRE2]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The first thing we should notice about the preceding example is the XML namespace
    prefixed by `faces` near the top of the page. This namespace allows us to add
    Jakarta Faces-specific attributes to HTML5 pages. When the Faces runtime encounters
    attributes prefixed by `faces` in any of the tags on the page, it automatically
    converts the HTML5 tag to the equivalent Faces component. Faces-specific attributes
    are the same as in regular Faces pages, except they are prefixed with `faces`.
    Therefore, at this point, they should be self-explanatory and will not be discussed
    in detail.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先应该注意到的关于前面示例的是页面顶部附近的带有`faces`前缀的 XML 命名空间。这个命名空间允许我们向 HTML5 页面添加 Jakarta
    Faces 特定的属性。当 Faces 运行时遇到页面上的任何标签中带有`faces`前缀的属性时，它会自动将 HTML5 标签转换为等效的 Faces 组件。特定于
    Faces 的属性与常规 Faces 页面中的属性相同，只是它们以`faces`为前缀。因此，在这个阶段，它们应该是自解释的，不会进行详细讨论。
- en: The preceding example will render and behave just like the first example in
    this chapter.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例将渲染和表现与本章的第一个示例完全相同。
- en: The technique described in this section is useful if we have experienced HTML
    web designers in our team that prefer to have full control over the look of the
    page. The pages are developed using standard HTML5 with Faces-specific attributes
    so that the Faces runtime can manage user input.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中描述的技术如果我们的团队中有经验丰富的 HTML 网页设计师，他们更喜欢对页面外观有完全控制权时非常有用。页面使用标准的 HTML5 和特定于 Faces
    的属性开发，以便 Faces 运行时可以管理用户输入。
- en: If our team consists primarily of Java developers with limited CSS/HTML knowledge,
    then it is preferable to develop the web pages for our web application using Faces
    components.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的团队主要由对 CSS/HTML 知识有限的 Java 开发者组成，那么使用 Faces 组件开发我们的 Web 应用程序的网页是更可取的。
- en: HTML is an evolving standard; occasionally, attributes are added to HTML tags.
    To future-proof Faces components, Jakarta Faces supports pass-through attributes,
    which can be used to add arbitrary attributes to Jakarta Faces components. This
    technique is discussed in the next section.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: HTML 是一个不断发展的标准；偶尔，属性会被添加到 HTML 标签中。为了确保 Faces 组件的未来兼容性，Jakarta Faces 支持透传属性，可以使用它向
    Jakarta Faces 组件添加任意属性。这项技术将在下一节中讨论。
- en: Pass-through attributes
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 透传属性
- en: 'Jakarta Faces allows the definition of any arbitrary attributes (not processed
    by the Faces engine). These attributes are simply rendered as-is on the generated
    HTML displayed on the browser. The following example is a new version of an earlier
    example in this chapter, modified to take advantage of HTML5 pass-through attributes:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Jakarta Faces 允许定义任何任意属性（不被 Faces 引擎处理）。这些属性在浏览器上显示的生成的 HTML 中简单地按原样渲染。以下示例是本章早期示例的新版本，经过修改以利用
    HTML5 透传属性：
- en: '[PRE3]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The first thing we should notice about this example is the addition of the namespace.
    This namespace allows us to add any arbitrary attributes to our Faces components.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先应该注意到的这个示例是命名空间的增加。这个命名空间允许我们向我们的 Faces 组件添加任何任意属性。
- en: In our example, we added the HTML5 `placeholder` attribute to all input text
    fields on our page. As we can see, passthrough attributes need to be prefixed
    by the defined prefix for the namespace at the top of the application (`pt`, in
    our case). The `placeholder` HTML attribute simply adds some placeholder text
    to the input fields that are automatically deleted once the user starts typing
    on the input field (this technique was commonly implemented using JavaScript before
    the `placeholder` attribute was added to HTML5).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们在页面上所有输入文本字段上添加了HTML5的`placeholder`属性。正如我们所看到的，透传属性需要以应用程序顶部定义的命名空间的前缀（在我们的情况下是`pt`）为前缀。`placeholder`
    HTML属性简单地向输入字段添加一些占位文本，一旦用户开始在输入字段中键入，这些文本就会自动删除（在`placeholder`属性添加到HTML5之前，这种技术通常使用JavaScript实现）。
- en: 'The following screenshot shows our updated page in action:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了我们的更新页面在实际操作中的效果：
- en: '![Figure 7.2: Faces pass-through attributes](img/B21231_7_02.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![图7.2：面部透传属性](img/B21231_7_02.jpg)'
- en: Figure 7.2 – Faces pass-through attributes
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2 – 面部透传属性
- en: 'If we examine the generated HTML (by right-clicking on the web browser and
    selecting **View Source** or similar), we can see that the HTML placeholder attribute
    was added to it. For example, the generated markup for the **First Name** input
    field looks like this:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们检查生成的HTML（通过在网页浏览器上右键单击并选择**查看源代码**或类似操作），我们可以看到HTML占位符属性被添加到了其中。例如，**姓氏**输入字段的生成标记如下：
- en: '[PRE4]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The placeholder attribute was placed there as a result of our pass-through attribute.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 占位符属性是由于我们的透传属性而放置在那里的。
- en: The next topic we’ll discuss is Faces Flows, which provide a custom Jakarta
    Faces scope that is longer than the request scope, but shorter than the session
    scope.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来要讨论的主题是面部流程，它提供了一个比请求作用域长但比会话作用域短的定制Jakarta Faces作用域。
- en: Faces Flows
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 面部流程
- en: Faces Flows defines a scope that can span several pages. Flow-scoped beans are
    created when the user enters a flow (a set of web pages), and are destroyed when
    the user leaves the flow.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 面部流程定义了一个可以跨越多个页面的作用域。当用户进入流程（一组网页）时创建流程作用域的bean，当用户离开流程时销毁。
- en: 'Faces Flows adopts the *convention-over-configuration* principle of Jakarta
    Faces. The following conventions are typically used when developing applications
    employing Faces Flows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 面部流程采用了Jakarta Faces的*约定优于配置*原则。在开发使用面部流程的应用程序时，通常使用以下约定：
- en: All pages in the flow must be placed in a directory whose name defines the name
    of the flow.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流程中的所有页面都必须放置在一个以定义流程名称的目录中。
- en: An XML configuration file named after the directory name and suffixed with `-flow`
    must exist inside the directory that contains the pages in the flow (the file
    may be empty, but it must exist)
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必须在包含流程页面的目录内存在一个以目录名称命名并附加`-flow`后缀的XML配置文件（该文件可能为空，但必须存在）
- en: The first page in the flow must be named after the directory name that contains
    the flow
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流程中的第一个页面必须以包含流程的目录名称命名
- en: The last page in the flow must not be located inside the directory containing
    the flow, and must be named after the directory name and suffixed with `-return`
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流程中的最后一页不得位于包含流程的目录内，并且必须以目录名称命名并附加`-return`后缀
- en: '*Figure 7**.3* illustrates these conventions:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7*.3说明了这些约定：'
- en: '![Figure 7.3: Faces Flows conventions](img/B21231_7_03.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![图7.3：面部流程约定](img/B21231_7_03.jpg)'
- en: Figure 7.3 – Faces Flows conventions
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.3 – 面部流程约定
- en: In our example, we define a flow named `"customerinfo"`. By convention, these
    files are inside a directory named `"customerinfo"`, and the first page on the
    flow is named `customerinfo.xhtml` (there are no restrictions on the names of
    other pages in the flow). When we exit the flow, we navigate to a page named `"flowname-return.xml"`
    – in our case, since our flow is named `"customerinfo"`, the name of the page
    in question is `customerinfo-return.xhtml`, which follows the naming convention
    and takes us out of the flow.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们定义了一个名为`"customerinfo"`的流程。按照惯例，这些文件位于名为`"customerinfo"`的目录中，流程的第一个页面命名为`customerinfo.xhtml`（流程中其他页面的名称没有限制）。当我们退出流程时，我们将导航到一个名为`"flowname-return.xml"`的页面
    – 在我们的情况下，由于我们的流程名为`"customerinfo"`，相关页面的名称是`customerinfo-return.xhtml`，它遵循命名约定并使我们退出流程。
- en: The markup for the pages doesn’t illustrate anything we haven’t seen before,
    so we will not examine it here – all example code is available as part of this
    book’s code download bundle if you wish to review it yourself.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 页面的标记没有展示我们之前没有见过的内容，因此我们在这里不会对其进行检查 – 如果您想自己查看，所有示例代码都作为本书代码下载包的一部分提供。
- en: 'All of the preceding pages store data in a named bean named `Customer`, which
    has a flow scoped bean:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的前几页都将数据存储在名为`Customer`的命名bean中，该bean具有流程作用域：
- en: '[PRE5]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `@FlowScoped` annotation has a value attribute that must match the name
    of the flow that the bean is meant to work with (`"customerinfo"`, in this example).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`@FlowScoped`注解有一个值属性，它必须与bean打算与之一起工作的流程的名称匹配（在这个例子中是`"customerinfo"`）。'
- en: This example creates a wizard-style set of pages in which data for a user is
    entered across several pages in the flow.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例创建了一个向导风格的页面集，其中用户数据在流程中的多个页面上输入。
- en: 'On the first page, we enter the customer’s name information:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一页，我们输入客户的姓名信息：
- en: '![Figure 7.4: First page of our Faces Flow example](img/B21231_7_04.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![图7.4：我们Faces Flow示例的第一页](img/B21231_7_04.jpg)'
- en: Figure 7.4 – First page of our Faces Flow example
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.4 – 我们Faces Flow示例的第一页
- en: 'On the second page, we enter the customer’s address information:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二页，我们输入客户的地址信息：
- en: '![Figure 7.5: Second page of our Faces Flow example](img/B21231_7_05.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图7.5：我们Faces Flow示例的第二页](img/B21231_7_05.jpg)'
- en: Figure 7.5 – Second page of our Faces Flow example
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.5 – 我们Faces Flow示例的第二页
- en: 'On the next page, we enter the customer’s telephone contact details:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一页，我们输入客户的电话联系信息：
- en: '![Figure 7.6: Third page of our Faces Flow example](img/B21231_7_06.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![图7.6：我们Faces Flow示例的第三页](img/B21231_7_06.jpg)'
- en: Figure 7.6 – Third page of our Faces Flow example
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.6 – 我们Faces Flow示例的第三页
- en: 'Finally, we display a confirmation page:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们显示一个确认页面：
- en: '![Figure 7.7: Last page of our Faces Flow example](img/B21231_7_07.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图7.7：我们Faces Flow示例的最后一页](img/B21231_7_07.jpg)'
- en: Figure 7.7 – Last page of our Faces Flow example
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.7 – 我们Faces Flow示例的最后一页
- en: If the user verifies that the information is correct, we navigate outside the
    flow to `customerinfo-return.xhtml`; otherwise, we go back to the first page in
    the flow to allow the user to make any necessary corrections.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户验证信息正确，我们将导航到`customerinfo-return.xhtml`以跳出流程；否则，我们将返回流程中的第一页，以便用户进行任何必要的更正。
- en: Faces WebSocket support
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Faces WebSocket支持
- en: In typical web applications, servers always respond to requests from a browser.
    There is no way for a server to send data to the client browser without responding
    to a request. The **WebSocket** technology provides full duplex communication
    between a browser and a server, allowing servers to independently send data to
    a client without having to respond to a request. WebSocket allows myriad new applications
    to be developed for the web, including updating stock tickers, multiplayer online
    games, and chat applications.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在典型的Web应用程序中，服务器总是响应来自浏览器的请求。服务器没有在不响应请求的情况下向客户端浏览器发送数据的方法。**WebSocket**技术提供了浏览器和服务器之间的全双工通信，允许服务器在不响应请求的情况下独立地向客户端发送数据。WebSocket允许为Web开发出无数新的应用程序，包括更新股票行情、多人在线游戏和聊天应用程序。
- en: Note
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Although some of these types of web applications were developed before the advent
    of WebSockets, they relied on hacks to work around the limitations of HTTP. With
    WebSockets, these hacks are no longer necessary.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然一些这类Web应用程序是在WebSocket出现之前开发的，但它们依赖于黑客手段来绕过HTTP的限制。有了WebSocket，这些黑客手段就不再必要了。
- en: Traditionally, taking advantage of the WebSocket protocol when writing applications
    required a lot of JavaScript code. Faces’ WebSocket supports abstracts out most
    of the JavaScript plumbing, allowing us to focus on developing the business logic
    of our applications.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，在编写应用程序时利用WebSocket协议需要大量的JavaScript代码。Faces的WebSocket支持抽象出了大部分JavaScript基础设施，使我们能够专注于开发我们应用程序的业务逻辑。
- en: The following example illustrates a simple chat application developed using
    Faces WebSocket support.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了使用Faces WebSocket支持开发的一个简单的聊天应用程序。
- en: 'Note that Faces WebSocket support needs to be explicitly enabled. This can
    be done by adding a context parameter to our `web.xml` configuration file:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，Faces WebSocket支持需要显式启用。这可以通过向我们的`web.xml`配置文件添加一个上下文参数来完成：
- en: '[PRE6]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As illustrated in our example `web.xml` configuration file, to enable WebSocket
    support in our Faces applications, we need to set a context parameter named `jakarta.faces.ENABLE_WEBSOCKET_ENDPOINT`
    and set its value to `true`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们的示例`web.xml`配置文件所示，为了在我们的Faces应用中启用WebSocket支持，我们需要设置一个名为`jakarta.faces.ENABLE_WEBSOCKET_ENDPOINT`的上下文参数，并将其值设置为`true`。
- en: 'Let’s now take a look at how we can develop an application-scoped CDI named
    bean that is responsible for sending messages to all browser clients:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在看看我们如何开发一个负责向所有浏览器客户端发送消息的应用作用域CDI名为bean：
- en: '[PRE7]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As shown in the preceding example, in order to send data via WebSockets to the
    clients, we need to inject an instance of an implementation of the `jakarta.faces.push.PushContext`
    interface and annotate it with the `@Push` annotation. We can optionally specify
    a channel via the annotation’s `channel` attribute. If we don’t specify a channel
    name, then the name of the variable annotated with `@Push` will be used as the
    channel name by default.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如前例所示，为了通过WebSockets向客户端发送数据，我们需要注入一个实现`jakarta.faces.push.PushContext`接口的实例，并用`@Push`注解标注它。我们可以通过注解的`channel`属性指定一个通道。如果我们没有指定通道名称，则默认使用标注了`@Push`的变量的名称作为通道名称。
- en: To send the message to the WebSocket client, we need to invoke the `send()`
    method of the injected `PushContext` implementation. In our example, this is done
    in the `send()` method of our CDI named bean.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将消息发送到WebSocket客户端，我们需要调用注入的`PushContext`实现中的`send()`方法。在我们的例子中，这是在CDI名为bean的`send()`方法中完成的。
- en: 'Further, in our example, there is a session-scoped CDI named bean that takes
    input from the user and passes it to the `send()` method of the preceding application-scoped
    CDI named bean. Our session-scoped CDI bean looks as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在我们的例子中，有一个会话作用域的CDI名为bean，它从用户那里获取输入并将其传递给前面应用作用域的CDI名为bean的`send()`方法。我们的会话作用域CDI
    bean看起来如下所示：
- en: '[PRE8]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `sendMessage()` method of the preceding class calls the `send()` method
    of the application-scoped CDI bean we discussed earlier, passing the name of the
    user and the message to be broadcasted to all browsers. The aforementioned `sendMessage()`
    method is invoked via Ajax when a user clicks a button on the corresponding page,
    as shown in the following markup:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的类中的`sendMessage()`方法调用我们之前讨论的应用作用域CDI bean的`send()`方法，传递用户的名称和要广播给所有浏览器的消息。上述`sendMessage()`方法通过Ajax在用户点击相应页面上的按钮时被调用，如下所示：
- en: '[PRE9]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `<f:websocket>` tag in the preceding markup is needed to enable WebSocket
    support for our page. The value of its `channel` attribute links the page to the
    corresponding `PushContext` instance on the server (in our example, it is defined
    in the application-scoped `FacesWebSocketMessageSender` CDI named bean). The value
    of this attribute must match the value of the corresponding attribute in the `@Push`
    annotation on the CDI bean (`"websocketdemo"` in our example).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 前述标记中的`<f:websocket>`标签是启用我们页面WebSocket支持所必需的。其`channel`属性的值将页面链接到服务器上相应的`PushContext`实例（在我们的例子中，它定义在应用作用域的`FacesWebSocketMessageSender`
    CDI名为bean中）。此属性的值必须与CDI bean上`@Push`注解中相应的属性值匹配（在我们的例子中是`"websocketdemo"`）。
- en: After building and deploying our application, we can see it in action.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建和部署我们的应用程序后，我们可以看到它的实际运行情况。
- en: '![Figure 7.8: Jakarta Faces WebSocket support](img/B21231_7_08.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![图7.8: Jakarta Faces WebSocket支持](img/B21231_7_08.jpg)'
- en: Figure 7.8 – Jakarta Faces WebSocket support
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.8 – Jakarta Faces WebSocket支持
- en: WebSocket technology allows us to develop two-way communication between web
    clients and servers. Jakarta Faces support for WebSocket makes it easy to implement
    WebSocket technologies in our Jakarta EE applications.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: WebSocket技术使我们能够在Web客户端和服务器之间开发双向通信。Jakarta Faces对WebSocket的支持使得在我们的Jakarta
    EE应用中实现WebSocket技术变得容易。
- en: Additional Faces component libraries
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他Faces组件库
- en: In addition to the standard Jakarta Faces component libraries, there are a number
    of third-party libraries available. The following table lists two of the most
    popular.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 除了标准的Jakarta Faces组件库之外，还有许多第三方库可供选择。以下表格列出了其中两个最受欢迎的。
- en: '| **Tag Library** | **Distributor** | **License** | **URL** |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| **标签库** | **分发商** | **许可** | **URL** |'
- en: '| --- | --- | --- | --- |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| ICEfaces | ICEsoft | MPL 1.1 | [http://www.icefaces.org](http://www.icefaces.org)
    |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| ICEfaces | ICEsoft | MPL 1.1 | [http://www.icefaces.org](http://www.icefaces.org)
    |'
- en: '| Primefaces | Prime Technology | Apache 2.0 | [http://www.primefaces.org](http://www.primefaces.org)
    |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| Primefaces | Prime Technology | Apache 2.0 | [http://www.primefaces.org](http://www.primefaces.org)
    |'
- en: Table 7.2 – Jakarta Faces Component libraries
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 表7.2 – Jakarta Faces组件库
- en: Using a third-party Jakarta Faces library allows us to develop elegant-looking
    applications without having to use much (if any) CSS. Most third-party Jakarta
    Faces contain drop-in replacements for standard Jakarta Faces components, such
    as `<h:inputText>` and `<h:commandButton>`, and also provide additional components
    that allow us to implement elaborate functionality with little effort. For example,
    most third-party libraries contain a table component with built-in pagination
    and sorting, freeing us from having to develop that functionality ourselves. Most
    real-life Jakarta Faces projects take advantage of a third-party component library,
    with PrimeFaces being the most popular one.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 使用第三方Jakarta Faces库，我们可以开发出外观优雅的应用程序，而无需使用很多（如果有的话）CSS。大多数第三方Jakarta Faces库都包含标准Jakarta
    Faces组件的即插即用替代品，例如`<h:inputText>`和`<h:commandButton>`，并且还提供了额外的组件，使我们能够以最小的努力实现复杂的功能。例如，大多数第三方库都包含一个具有内置分页和排序功能的表格组件，从而让我们免于自己开发该功能。大多数现实生活中的Jakarta
    Faces项目都利用了第三方组件库，其中PrimeFaces是最受欢迎的一个。
- en: Summary
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we covered how to develop web-based applications using Jakarta
    Faces, the standard component framework for the Jakarta EE:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了如何使用Jakarta Faces开发基于Web的应用程序，Jakarta EE的标准组件框架：
- en: We covered how to develop Ajax-enabled Faces pages
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们介绍了如何开发启用Ajax的Faces页面
- en: We explained how to integrate Faces and HTML5
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们解释了如何集成Faces和HTML5
- en: We covered how to develop wizard-like interfaces with Faces Flows
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们介绍了如何使用Faces Flows开发类似向导的界面
- en: We saw how to integrate WebSockets technology into our Jakarta Faces application
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们展示了如何将WebSocket技术集成到我们的Jakarta Faces应用程序中
- en: We talked about third-party Jakarta Faces component libraries, which we can
    leverage to make our lives easier
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们讨论了第三方Jakarta Faces组件库，我们可以利用这些库使我们的工作更轻松
- en: In this chapter, we went beyond basic Jakarta Faces functionality, covering
    advanced Jakarta Faces features such as Ajax and WebSocket support.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们超越了基本的Jakarta Faces功能，涵盖了高级Jakarta Faces特性，如Ajax和WebSocket支持。
