- en: '7'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Additional Jakarta Faces Features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will cover the additional features of Jakarta Faces, the
    standard component framework for Jakarta EE. These additional features allow us
    to make our web application user-friendly, while providing features that are convenient
    for application developers.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Ajax-enabled Faces applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Jakarta Faces HTML5 support
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Faces Flows
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Faces WebSocket support
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additional Faces component libraries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'The source code for this chapter can be found on GitHub at: [https://github.com/PacktPublishing/Jakarta-EE-Application-Development/tree/main/ch07_src](https://github.com/PacktPublishing/Jakarta-EE-Application-Development/tree/main/ch07_src)'
  prefs: []
  type: TYPE_NORMAL
- en: Ajax-enabled Faces applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Jakarta Faces allows us to easily implement`<f:ajax>` tag and CDI named beans,
    without needing to implement any JavaScript code or having to parse JSON strings.
  prefs: []
  type: TYPE_NORMAL
- en: The following markup illustrates the typical usage of the `<``f:ajax>` tag.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: After deploying our application, the preceding markup renders as illustrated
    in *Figure 7**.1*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.1: Faces Ajax functionality in action](img/B21231_7_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.1 – Faces Ajax functionality in action
  prefs: []
  type: TYPE_NORMAL
- en: Our example illustrates two uses of the `<f:ajax>` tag. At the top of the page,
    we are using this tag by implementing a typical Ajax Echo example, in which we
    have an `<h:outputText>` component updating itself with the value of an input
    text component. Any time any character is entered into the input field, the value
    of the `<h:outputText>` component is automatically updated.
  prefs: []
  type: TYPE_NORMAL
- en: To implement the functionality described in the previous paragraph, we put an
    `<f:ajax>` tag inside an `<h:inputText>` tag. The value of the `render` attribute
    of the `<f:ajax>` tag must correspond to the ID of the component we wish to update
    after the Ajax request finishes. In our particular example, we wish to update
    the `<h:outputText>` component with an ID of `textVal`, therefore this is the
    value we use for the `render` attribute of our `<``f:ajax>` tag.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: In some cases, we may need to render more than one Faces component after an
    Ajax event finishes. In order to accommodate for this, we can add several IDs
    as the value of the `render` attribute. We simply need to separate them with spaces.
  prefs: []
  type: TYPE_NORMAL
- en: The other `<f:ajax>` attribute we used in this instance is the `event` attribute.
    This attribute indicates the JavaScript event that triggers the Ajax event. In
    this particular case, we need to trigger the event any time a key is released
    while a user is typing into the input field. Therefore the appropriate event to
    use is `keyup`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table lists all supported JavaScript events:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Event** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `blur` | The component loses focus |'
  prefs: []
  type: TYPE_TB
- en: '| `change` | The component loses focus and its value has been modified |'
  prefs: []
  type: TYPE_TB
- en: '| `click` | The component is clicked on |'
  prefs: []
  type: TYPE_TB
- en: '| `dblclick` | The component is double-clicked on |'
  prefs: []
  type: TYPE_TB
- en: '| `focus` | The component gains focus |'
  prefs: []
  type: TYPE_TB
- en: '| `keydown` | A key is pressed down while the component has focus |'
  prefs: []
  type: TYPE_TB
- en: '| `keypress` | A key is pressed or held down while the component has focus
    |'
  prefs: []
  type: TYPE_TB
- en: '| `keyup` | A key is released while the component has focus |'
  prefs: []
  type: TYPE_TB
- en: '| `mousedown` | The mouse button is depressed while the component has focus
    |'
  prefs: []
  type: TYPE_TB
- en: '| `mousemove` | The mouse pointer is moved over the component |'
  prefs: []
  type: TYPE_TB
- en: '| `mouseout` | The mouse pointer leaves the component |'
  prefs: []
  type: TYPE_TB
- en: '| `mouseover` | The mouse pointer is placed over the component |'
  prefs: []
  type: TYPE_TB
- en: '| `mouseup` | The mouse button is released while the component has focus |'
  prefs: []
  type: TYPE_TB
- en: '| `select` | The component’s text is selected |'
  prefs: []
  type: TYPE_TB
- en: '| `valueChange` | Equivalent to change, the component loses focus and its value
    has been modified |'
  prefs: []
  type: TYPE_TB
- en: Table 7.1 – <f:ajax> tag JavaScript event attributes
  prefs: []
  type: TYPE_NORMAL
- en: We use the `<f:ajax>` once again farther down the page to Ajax-enable a command
    button component. In this instance, we want to recalculate a value based on the
    values of two input components. In order to have the values on the server updated
    with the latest user input, we used the `execute` attribute of `<f:ajax>`. This
    attribute takes a space-separated list of component IDs to use as input. We then
    use the `render` attribute just like before to specify which components need to
    be re-rendered after the Ajax request finishes.
  prefs: []
  type: TYPE_NORMAL
- en: Notice we are using the `actionListener` attribute of `<h:commandButton>`. This
    attribute is typically used whenever we don’t need to navigate to another page
    after clicking the button. The value for this attribute is an action listener
    method we wrote in one of our named beans. Action listener methods must return
    void, and take an instance of `jakarta.faces.event.ActionEvent` as their sole
    parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The named bean for our application looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The value of the `actionListener` attribute on our `commandButton` is a Jakarta
    Expression Language method expression resolving to the `calculateTotal()` method
    on our CDI named bean. As such, this method is automatically invoked when the
    user clicks on the button labeled `firstOperand` and `secondOperand` variables
    are bound to the `value` attributes of those fields. As such, these variables
    are populated with the user-entered values on the page; our method simply adds
    those values and assigns them to the `total` variable. Then, the `outputText`
    component on the page bound to this variable is automatically updated.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we didn’t have to do anything special in our named bean to enable
    Ajax in our application. It is all controlled by the `<f:ajax>` tag on the page.
  prefs: []
  type: TYPE_NORMAL
- en: As we can see from this example, Ajax-enabled Faces applications are very simple.
    We simply need to use a single tag to enable Ajax on our page, without having
    to write a single line of JavaScript, JSON, or XML.
  prefs: []
  type: TYPE_NORMAL
- en: Jakarta Faces HTML5 support
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**HTML5** is the latest version of the HTML specification. It includes several
    improvements over previous versions of HTML. Jakarta Faces includes several features
    to make Faces pages work nicely with HTML5\. Jakarta Faces support for HTML5 includes
    the ability to develop our Jakarta Faces pages in HTML5 without using Faces-specific
    tags, along with the ability to add arbitrary HTML5 attributes to our Jakarta
    Faces pages.'
  prefs: []
  type: TYPE_NORMAL
- en: HTML5-friendly markup
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Through the use of pass-through elements, we can develop our Faces pages using
    HTML5, as opposed to using Faces-specific tags. Using HTML5 to develop our pages
    has the advantage that we can preview how our page renders in the browser without
    having to deploy our application to a Jakarta EE runtime. We can simply open the
    page in a web browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, we need to specify at least one of the element attributes using
    the `jakarta.faces` XML namespace. The following example demonstrates this approach
    in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The first thing we should notice about the preceding example is the XML namespace
    prefixed by `faces` near the top of the page. This namespace allows us to add
    Jakarta Faces-specific attributes to HTML5 pages. When the Faces runtime encounters
    attributes prefixed by `faces` in any of the tags on the page, it automatically
    converts the HTML5 tag to the equivalent Faces component. Faces-specific attributes
    are the same as in regular Faces pages, except they are prefixed with `faces`.
    Therefore, at this point, they should be self-explanatory and will not be discussed
    in detail.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding example will render and behave just like the first example in
    this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The technique described in this section is useful if we have experienced HTML
    web designers in our team that prefer to have full control over the look of the
    page. The pages are developed using standard HTML5 with Faces-specific attributes
    so that the Faces runtime can manage user input.
  prefs: []
  type: TYPE_NORMAL
- en: If our team consists primarily of Java developers with limited CSS/HTML knowledge,
    then it is preferable to develop the web pages for our web application using Faces
    components.
  prefs: []
  type: TYPE_NORMAL
- en: HTML is an evolving standard; occasionally, attributes are added to HTML tags.
    To future-proof Faces components, Jakarta Faces supports pass-through attributes,
    which can be used to add arbitrary attributes to Jakarta Faces components. This
    technique is discussed in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Pass-through attributes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Jakarta Faces allows the definition of any arbitrary attributes (not processed
    by the Faces engine). These attributes are simply rendered as-is on the generated
    HTML displayed on the browser. The following example is a new version of an earlier
    example in this chapter, modified to take advantage of HTML5 pass-through attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The first thing we should notice about this example is the addition of the namespace.
    This namespace allows us to add any arbitrary attributes to our Faces components.
  prefs: []
  type: TYPE_NORMAL
- en: In our example, we added the HTML5 `placeholder` attribute to all input text
    fields on our page. As we can see, passthrough attributes need to be prefixed
    by the defined prefix for the namespace at the top of the application (`pt`, in
    our case). The `placeholder` HTML attribute simply adds some placeholder text
    to the input fields that are automatically deleted once the user starts typing
    on the input field (this technique was commonly implemented using JavaScript before
    the `placeholder` attribute was added to HTML5).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows our updated page in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.2: Faces pass-through attributes](img/B21231_7_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.2 – Faces pass-through attributes
  prefs: []
  type: TYPE_NORMAL
- en: 'If we examine the generated HTML (by right-clicking on the web browser and
    selecting **View Source** or similar), we can see that the HTML placeholder attribute
    was added to it. For example, the generated markup for the **First Name** input
    field looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The placeholder attribute was placed there as a result of our pass-through attribute.
  prefs: []
  type: TYPE_NORMAL
- en: The next topic we’ll discuss is Faces Flows, which provide a custom Jakarta
    Faces scope that is longer than the request scope, but shorter than the session
    scope.
  prefs: []
  type: TYPE_NORMAL
- en: Faces Flows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Faces Flows defines a scope that can span several pages. Flow-scoped beans are
    created when the user enters a flow (a set of web pages), and are destroyed when
    the user leaves the flow.
  prefs: []
  type: TYPE_NORMAL
- en: 'Faces Flows adopts the *convention-over-configuration* principle of Jakarta
    Faces. The following conventions are typically used when developing applications
    employing Faces Flows:'
  prefs: []
  type: TYPE_NORMAL
- en: All pages in the flow must be placed in a directory whose name defines the name
    of the flow.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An XML configuration file named after the directory name and suffixed with `-flow`
    must exist inside the directory that contains the pages in the flow (the file
    may be empty, but it must exist)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first page in the flow must be named after the directory name that contains
    the flow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The last page in the flow must not be located inside the directory containing
    the flow, and must be named after the directory name and suffixed with `-return`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Figure 7**.3* illustrates these conventions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.3: Faces Flows conventions](img/B21231_7_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.3 – Faces Flows conventions
  prefs: []
  type: TYPE_NORMAL
- en: In our example, we define a flow named `"customerinfo"`. By convention, these
    files are inside a directory named `"customerinfo"`, and the first page on the
    flow is named `customerinfo.xhtml` (there are no restrictions on the names of
    other pages in the flow). When we exit the flow, we navigate to a page named `"flowname-return.xml"`
    – in our case, since our flow is named `"customerinfo"`, the name of the page
    in question is `customerinfo-return.xhtml`, which follows the naming convention
    and takes us out of the flow.
  prefs: []
  type: TYPE_NORMAL
- en: The markup for the pages doesn’t illustrate anything we haven’t seen before,
    so we will not examine it here – all example code is available as part of this
    book’s code download bundle if you wish to review it yourself.
  prefs: []
  type: TYPE_NORMAL
- en: 'All of the preceding pages store data in a named bean named `Customer`, which
    has a flow scoped bean:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `@FlowScoped` annotation has a value attribute that must match the name
    of the flow that the bean is meant to work with (`"customerinfo"`, in this example).
  prefs: []
  type: TYPE_NORMAL
- en: This example creates a wizard-style set of pages in which data for a user is
    entered across several pages in the flow.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the first page, we enter the customer’s name information:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.4: First page of our Faces Flow example](img/B21231_7_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.4 – First page of our Faces Flow example
  prefs: []
  type: TYPE_NORMAL
- en: 'On the second page, we enter the customer’s address information:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.5: Second page of our Faces Flow example](img/B21231_7_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.5 – Second page of our Faces Flow example
  prefs: []
  type: TYPE_NORMAL
- en: 'On the next page, we enter the customer’s telephone contact details:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.6: Third page of our Faces Flow example](img/B21231_7_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.6 – Third page of our Faces Flow example
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we display a confirmation page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.7: Last page of our Faces Flow example](img/B21231_7_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.7 – Last page of our Faces Flow example
  prefs: []
  type: TYPE_NORMAL
- en: If the user verifies that the information is correct, we navigate outside the
    flow to `customerinfo-return.xhtml`; otherwise, we go back to the first page in
    the flow to allow the user to make any necessary corrections.
  prefs: []
  type: TYPE_NORMAL
- en: Faces WebSocket support
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In typical web applications, servers always respond to requests from a browser.
    There is no way for a server to send data to the client browser without responding
    to a request. The **WebSocket** technology provides full duplex communication
    between a browser and a server, allowing servers to independently send data to
    a client without having to respond to a request. WebSocket allows myriad new applications
    to be developed for the web, including updating stock tickers, multiplayer online
    games, and chat applications.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Although some of these types of web applications were developed before the advent
    of WebSockets, they relied on hacks to work around the limitations of HTTP. With
    WebSockets, these hacks are no longer necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Traditionally, taking advantage of the WebSocket protocol when writing applications
    required a lot of JavaScript code. Faces’ WebSocket supports abstracts out most
    of the JavaScript plumbing, allowing us to focus on developing the business logic
    of our applications.
  prefs: []
  type: TYPE_NORMAL
- en: The following example illustrates a simple chat application developed using
    Faces WebSocket support.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that Faces WebSocket support needs to be explicitly enabled. This can
    be done by adding a context parameter to our `web.xml` configuration file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As illustrated in our example `web.xml` configuration file, to enable WebSocket
    support in our Faces applications, we need to set a context parameter named `jakarta.faces.ENABLE_WEBSOCKET_ENDPOINT`
    and set its value to `true`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s now take a look at how we can develop an application-scoped CDI named
    bean that is responsible for sending messages to all browser clients:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As shown in the preceding example, in order to send data via WebSockets to the
    clients, we need to inject an instance of an implementation of the `jakarta.faces.push.PushContext`
    interface and annotate it with the `@Push` annotation. We can optionally specify
    a channel via the annotation’s `channel` attribute. If we don’t specify a channel
    name, then the name of the variable annotated with `@Push` will be used as the
    channel name by default.
  prefs: []
  type: TYPE_NORMAL
- en: To send the message to the WebSocket client, we need to invoke the `send()`
    method of the injected `PushContext` implementation. In our example, this is done
    in the `send()` method of our CDI named bean.
  prefs: []
  type: TYPE_NORMAL
- en: 'Further, in our example, there is a session-scoped CDI named bean that takes
    input from the user and passes it to the `send()` method of the preceding application-scoped
    CDI named bean. Our session-scoped CDI bean looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The `sendMessage()` method of the preceding class calls the `send()` method
    of the application-scoped CDI bean we discussed earlier, passing the name of the
    user and the message to be broadcasted to all browsers. The aforementioned `sendMessage()`
    method is invoked via Ajax when a user clicks a button on the corresponding page,
    as shown in the following markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `<f:websocket>` tag in the preceding markup is needed to enable WebSocket
    support for our page. The value of its `channel` attribute links the page to the
    corresponding `PushContext` instance on the server (in our example, it is defined
    in the application-scoped `FacesWebSocketMessageSender` CDI named bean). The value
    of this attribute must match the value of the corresponding attribute in the `@Push`
    annotation on the CDI bean (`"websocketdemo"` in our example).
  prefs: []
  type: TYPE_NORMAL
- en: After building and deploying our application, we can see it in action.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.8: Jakarta Faces WebSocket support](img/B21231_7_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.8 – Jakarta Faces WebSocket support
  prefs: []
  type: TYPE_NORMAL
- en: WebSocket technology allows us to develop two-way communication between web
    clients and servers. Jakarta Faces support for WebSocket makes it easy to implement
    WebSocket technologies in our Jakarta EE applications.
  prefs: []
  type: TYPE_NORMAL
- en: Additional Faces component libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In addition to the standard Jakarta Faces component libraries, there are a number
    of third-party libraries available. The following table lists two of the most
    popular.
  prefs: []
  type: TYPE_NORMAL
- en: '| **Tag Library** | **Distributor** | **License** | **URL** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| ICEfaces | ICEsoft | MPL 1.1 | [http://www.icefaces.org](http://www.icefaces.org)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Primefaces | Prime Technology | Apache 2.0 | [http://www.primefaces.org](http://www.primefaces.org)
    |'
  prefs: []
  type: TYPE_TB
- en: Table 7.2 – Jakarta Faces Component libraries
  prefs: []
  type: TYPE_NORMAL
- en: Using a third-party Jakarta Faces library allows us to develop elegant-looking
    applications without having to use much (if any) CSS. Most third-party Jakarta
    Faces contain drop-in replacements for standard Jakarta Faces components, such
    as `<h:inputText>` and `<h:commandButton>`, and also provide additional components
    that allow us to implement elaborate functionality with little effort. For example,
    most third-party libraries contain a table component with built-in pagination
    and sorting, freeing us from having to develop that functionality ourselves. Most
    real-life Jakarta Faces projects take advantage of a third-party component library,
    with PrimeFaces being the most popular one.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we covered how to develop web-based applications using Jakarta
    Faces, the standard component framework for the Jakarta EE:'
  prefs: []
  type: TYPE_NORMAL
- en: We covered how to develop Ajax-enabled Faces pages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We explained how to integrate Faces and HTML5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We covered how to develop wizard-like interfaces with Faces Flows
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We saw how to integrate WebSockets technology into our Jakarta Faces application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We talked about third-party Jakarta Faces component libraries, which we can
    leverage to make our lives easier
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, we went beyond basic Jakarta Faces functionality, covering
    advanced Jakarta Faces features such as Ajax and WebSocket support.
  prefs: []
  type: TYPE_NORMAL
