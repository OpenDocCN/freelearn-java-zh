<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Building a Central Authentication Server</h1>
                </header>
            
            <article>
                
<p>Implementing security constraints is a core requirement of any application. Spring provides support to various aspects of applications, including security. One of the modules of the Spring framework, called Spring Security, was specially designed to meet security needs. It is a robust and highly adaptive framework, providing authentication and authorization out of the box.</p>
<p>Spring Security is the standard for securing any Spring-based application. We can see the real strength of Spring Security when integrating it with other systems. Its capabilities can be extended with ease, in order to meet custom requirements. This chapter will be devoted purely to Spring Security.</p>
<p>In the last chapter, we looked at the power of the Spring framework, with various modules and third-party libraries binding together in Spring Boot: a module built on top of the Spring framework, mainly designed for bootstrapping and developing a Spring-based application with auto configuration. We will continue to use it in this chapter, in order to build central authentication and authorization system.</p>
<p>Spring Security is a highly customizable framework, and we can integrate it with other systems that provide the data for access control. In this chapter, we will look closely at <strong><span>Lightweight Directory Access Protocol</span></strong> (<strong>LDAP</strong>) and <strong>OAuth</strong> integration with Spring Security.</p>
<p>We will cover the following interesting topics in this chapter:</p>
<ul>
<li>A basic understanding of LDAP and data structures</li>
<li>Configuration of the LDAP server (Apache DS)</li>
<li>Authentication in Spring Security with LDAP</li>
<li>LDAP authorization with Spring Security</li>
<li>OAuth fundamentals and various grant types</li>
<li>Spring Security integration with OAuth</li>
<li>Dual authentication with LDAP and OAuth in Spring Security</li>
<li>OAuth implementation with a custom authorization server in Spring Security</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p>All the code used in this chapter can be downloaded from the following GitHub link: <a href="https://github.com/PacktPublishing/Spring-5.0-Projects/tree/master/chapter04">https://github.com/PacktPublishing/Spring-5.0-Projects/tree/master/chapter04</a>. The code can be executed on any operating system, although it has only been tested on Windows.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">LDAP</h1>
                </header>
            
            <article>
                
<p>When email was introduced and started to be used in corporations, one challenge was to look up the email address of someone that had never communicated with you. It required some sort of central repository for searching the email addresses of other people within the organization.</p>
<p>Necessity is the mother of invention. The need for a central data depot brought companies like Microsoft, Lotus, Netscape, and IBM together, and they defined a standard called <strong>LDAP</strong>. It is a protocol for accessing data stored in a directory structure over the network.</p>
<p>The LDAP server, which holds and indexes the data in a hierarchical manner, can be accessed by LDAP-aware clients. The data can be filtered to select a particular person or group stored in a different entity. For example, imagine searching for all employees located in Chicago that are from the admin department and have been working for more than three years, and receiving their full name, designation, and email address. This is quite possible with LDAP. </p>
<p>Apart from contact information, LDAP can also be used to store access control data, which can then be used to perform authentication and authorization. We will start by covering the basics of LDAP and how to construct a data structure with it.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">What is LDAP?</h1>
                </header>
            
            <article>
                
<p><span>LDAP</span> is an industry standard for accessing and managing hierarchical information stored in a directory structure over the network. LDAP has been in use for quite a long time. Nowadays, it is mainly used to build an authentication system; however, that is by no means its only purpose. LDAP can also be used to store any kind of information that needs to be accessed centrally (for example, emails or contact information in an organization). </p>
<p>The main motive for storing user (or any other) information, like usernames, emails, passwords, and so on, in one place, is to provide administration and maintenance support with ease. For example, rather than handling the user list for each subgroup separately in an organization, LDAP can be used to manage them as a central repository, accessible from anywhere in the network. There are certain use cases where LDAP is the perfect fit, as follows:</p>
<ul>
<li style="font-weight: 400">Allowing a user to log in with the same credentials in multiple applications, like logging in on an intranet and on your local machine.</li>
<li style="font-weight: 400">Providing role-based access to a group of users; for example, accessing a specific page on the intranet site, or accessing a document in a document management system.</li>
<li style="font-weight: 400">Collecting user contact details and making them available globally, so that any user in the organization can access them.</li>
</ul>
<p>LDAP is a way to access the structured information stored in directories. For this, it follows the client-server model, where data is stored on the LDAP server and the client can raise a request to access required information (through the LDAP API).</p>
<p>The information stored in an LDAP service is not intended to be altered upon each access, which makes that LDAP is a write once and read many times form of service. For example, LDAP would not be appropriate for maintaining the transaction records of an online shopping application, considering the fact that those records change with every operation. However, LDAP can be used to maintain data that changes less frequently, like user accounts, user addresses, and so on.</p>
<div class="packt_infobox">The data stored on the LDAP server is not in a relational form; rather, it is hierarchical. However, LDAP uses the database to store the information internally, but presents it in a hierarchical manner.</div>
<p>Along with defining how to access the data in the directory service, LDAP also defines how the data is presented. To understand this data information model, it is essential to understand certain terms used in LDAP. This will not only help you to get a better idea of how it works, but will also illustrate how to create and search for the data in LDAP:</p>
<ul>
<li><strong>Directory information tree </strong>(<strong>DIT</strong>): As we discussed, the LDAP server stores the information in a hierarchical (or a tree) form. This tree is called a directory information tree.</li>
<li><strong>Entry</strong>: As trees have nodes, the nodes in the DIT are called entries. The information that is stored within the entry is in the form of a key-value pair. Each entry has one parent entry (except for the root entry) and zero or more child entries. A child entry is a sibling of its parent’s other child entry.</li>
<li><strong>Root/base/suffix</strong>: The top entry in DIT is called the root, base, or suffix.</li>
<li><strong>Distinguished name </strong>(<strong>DN</strong>): Each entry in DIT should be recognized by a unique identifier. This unique identifier is called a distinguished name. Generally, it is a string consisting of one or more comma-separated key-value pairs, which together uniquely distinguish the node (entry) in the tree. For example, the string <kbd>dc=nilangpatel</kbd><em>,</em> <kbd>cd=com</kbd> could be the DN for the root entity.</li>
<li><strong>Relative distinguished name</strong> (<strong>RDN</strong>): A string that uniquely distinguishes the entity relative to its parent is called a relative distinguished name. The DN uniquely identifies the entity globally, while the RDN uniquely identifies the entity among its siblings.</li>
<li><strong>Object class</strong>: Each entity is comprised of one or more <kbd>objectClasses</kbd>. Each object class has a name and zero or more attributes. The <kbd>objectclass</kbd> is considered a container for attributes, and it will control what types of attributes can be added to the entity.</li>
<li><strong>Attribute</strong>: The attribute is part of the <kbd>objectclass</kbd>. It has a name and a value. It also has an abbreviation or alias.</li>
</ul>
<p style="padding-left: 60px">The following is a list of a few attributes (along with their object classes) that we are going to use in this chapter:</p>
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td>Attribute name</td>
<td>Alias name</td>
<td><span>Description</span></td>
<td><span>Object class</span></td>
</tr>
<tr>
<td class="CDPAlignLeft CDPAlign"><kbd>dc</kbd></td>
<td><kbd>domainComponent</kbd></td>
<td>
<p>Any part of a domain name; for example, <kbd>domain.com</kbd>, domain, or com</p>
</td>
<td><kbd>dcObject</kbd></td>
</tr>
<tr>
<td><kbd>o</kbd></td>
<td><kbd>organizationName</kbd></td>
<td>Organization name</td>
<td><kbd>organization</kbd></td>
</tr>
<tr>
<td><kbd>ou</kbd></td>
<td><kbd>organisationalUnitName</kbd> </td>
<td>Department or any subgroup</td>
<td><kbd>organizationUnit</kbd></td>
</tr>
<tr>
<td><kbd>cn</kbd></td>
<td><kbd>common name</kbd></td>
<td>Name of the entity</td>
<td>
<p class="mce-root"><kbd>person</kbd>, <kbd>organizationalPerson</kbd>, <kbd>organizationalRole</kbd>, <kbd>groupOfNames</kbd>, <kbd>applicationProcess</kbd>, <kbd>applicationEntity</kbd>, <kbd>posixAccount</kbd>, <kbd>device</kbd></p>
</td>
</tr>
<tr>
<td><kbd>sn</kbd></td>
<td><kbd>surname</kbd></td>
<td>Surname or family name</td>
<td><kbd>person</kbd></td>
</tr>
<tr>
<td><kbd>uid</kbd></td>
<td><kbd>userid</kbd></td>
<td>Username or other unique value</td>
<td><kbd>account</kbd>, <kbd>inetOrgPerson</kbd>, <kbd>posixAccount</kbd></td>
</tr>
<tr>
<td><kbd>userPassword</kbd> </td>
<td> <kbd>-</kbd></td>
<td>User password for some form of access control</td>
<td>
<p class="mce-root"><kbd>organization</kbd>, <kbd>organizationalUnit</kbd>, <kbd>person</kbd>, <kbd>dmd</kbd>, <kbd>simpleSecurityObject</kbd>, <kbd>domain</kbd>, <kbd>posixAccount</kbd></p>
</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>LDAP Data Interchange Format </strong>(<strong>LDIF</strong>): This is an ASCII file format to describe the hierarchical tree structure of LDAP data in the form of a text file. LDAP data can be imported or exported in an LDIF file format.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Configuring Apache DS as an LDAP server</h1>
                </header>
            
            <article>
                
<p>We will use <span><strong>Apache Directory Server</strong> </span>(<strong>Apache DS</strong>), an extendable, modern, and embeddable LDAP server, to showcase LDAP authentication. It is written purely in Java. Apache DS comes as a standalone LDAP server. While working with it, you will need some sort of <span class="packt_screen">LDAP Browser</span> to visualize and manipulate the data.</p>
<p>However, Apache provides another tool, called <strong>Apache Directory Studio,</strong> which is an Eclipse-based application. It ships with Apache DS and <span class="packt_screen">LDAP Browser</span>, in a single bundle. It was designed particularly for Apache DS; however, you can use it with any LDAP server (like <strong>OpenLDAP</strong>).</p>
<div class="packt_infobox">When you use Apache Directory Studio, you are no longer required to get another LDAP server, because it comes with Apache DS (an LDAP server).</div>
<p>Download Apache Directory Studio (<a href="https://directory.apache.org/studio/">https://directory.apache.org/studio/</a>), extract it on your local machine, and double-click on the <kbd>ApacheDirectoryStudio</kbd> executable file to open it.</p>
<p>First, we need to add the Apache DS server. For that, go to the <span class="packt_screen">LDAP Server</span> tab (generally placed at the bottom of the window), right-click there, select <span class="packt_screen">New | </span><span class="packt_screen">New Server</span>, and choose the latest version of Apache DS server. Once the server has been added, right-click on it and select <em><span class="packt_screen">Run</span></em> to start the server.</p>
<p>After the server is up and running, we need to create a connection. Right-click on the <em><span class="packt_screen">Connections</span></em> tab and select <span class="packt_screen">New Connection</span>, with the following information:</p>
<ul>
<li><span class="packt_screen">Connection name</span><strong>:</strong> Any appropriate name.</li>
<li><span class="packt_screen">Hostname</span>: The <span class="packt_screen">localhost.</span></li>
<li><span class="packt_screen">Port</span><strong>:</strong> The default port for any LDAP server is <kbd>389</kbd>. However, the default port for Apache DS is <kbd>10389</kbd>. Needless to say, that port can be changed.</li>
</ul>
<p>Keep the rest of the options as is, and click on the <span class="packt_screen">Next</span> button to fill in the following details:</p>
<ul>
<li><strong>Authentication Method:</strong> <span class="packt_screen">Simple authentication</span></li>
<li><strong>Bind DN or user: </strong><kbd>uid=admin</kbd>, <kbd>ou=system</kbd></li>
<li><strong>Bind password:</strong> <kbd>Secret</kbd></li>
</ul>
<p>This is the default admin credential, and can be verified by clicking on the <span class="packt_screen">Check Authentication</span> button. Click on <span class="packt_screen">Finish</span>, and you will see the details in the <span class="packt_screen">LDAP Browser</span> windows, as shown in the following screenshot:</p>
<p class="mce-root CDPAlignCenter CDPAlign"><img src="assets/e77d5953-205b-452f-8cb8-30cadfe77ffd.png" style="width:29.08em;height:20.17em;"/></p>
<p>Next, we will start to create a data structure to store user details. As you have seen, LDAP can be used to store any kind of information, but we will use LDAP for authentication. LDAP stores the data in the form of a tree (DIT), so we will create a DIT structure.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Example DIT structures</h1>
                </header>
            
            <article>
                
<p>Moving on, let's first look at a few data structures that are commonly used in LDAP, and then select one of them:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/82f72d0f-e7ab-4c5f-a48a-2240ca32af5a.png" style="width:37.00em;height:39.08em;"/></p>
<p>This structure starts with an organization with a name, packt (<strong>o=packt</strong>), followed by an organizational unit (subgroup) for each of the departments, and finally, the users. At some places, the sub-organization has a user group, followed by users.</p>
<p>The tree can also be arranged based on internet domain names, as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/54101e71-9a26-4e90-8bc2-8cdf364380b0.png" style="width:38.33em;height:28.25em;"/></p>
<p>This structure has <kbd>example.com</kbd> as a domain. You can give the same attribute multiple times with different name, as previously shown. The <strong>dc</strong> stands for <span><strong>domain component</strong>. It is followed by subgroups for <strong>users</strong> and <strong>printers</strong> (devices), and at the end, the <strong>users</strong> and devices (<strong>printers</strong>) are listed.</span></p>
<p>Another option could be as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/fa6a4809-43f0-4b9d-ab26-5f8619a589f7.png" style="width:36.75em;height:27.92em;"/></p>
<p>This option has an organization (<strong>o=packtPublisher</strong>) as the root, and two child <strong>users</strong> and <strong>roles</strong> as the <strong>ou</strong> (organizational unit, or subgroup). The <strong>users</strong> entry will have user entries, and the<span class="packt_screen"> </span><strong>roles</strong> entry will have role entries. We will choose this option to construct a DIT in LDAP in this chapter. LDAP allows for associating the users to roles with attribute members. You will see more details about this in the <em>Creating roles in an LDAP server</em> section, later in this book. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Apache DS partitions</h1>
                </header>
            
            <article>
                
<p>Apache DS has a concept called <strong>partitions</strong>. Every partition contains an entity tree (DIT) that is totally disconnected from the entity trees in other partitions. This means that changes that happen with entry trees in one partition will never affect entry trees in other partition. Each partition is identified by a unique ID. It also has a naming context referred to as the <strong>partition suffix</strong>, which can be thought of as the root (or base) for the DIT in that partition; all entries are stored beneath that.</p>
<p>To create a partition in Apache DS, double-click on the server instance in the <span class="packt_screen">LDAP server</span> tab, and it will open the server configuration. Open the <span class="packt_screen">Partitions</span> tab of the server configuration, click on the <span class="packt_screen">Add</span> button, and give the values for the <span class="packt_screen">Partition General Details</span> section, as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/93d2ee51-0e6a-44fd-8634-33e8bb916c39.png" style="width:50.50em;height:43.42em;"/></p>
<ul>
<li><span class="packt_screen">ID</span>: <kbd>packtPublisher</kbd></li>
<li><span class="packt_screen">Suffix</span>: <kbd>o=packtPublisher</kbd></li>
</ul>
<p>Keep all of the other values as the defaults, and save the configuration. Restart the server to take the partition into effect. The new partition will be available in the <span class="packt_screen">LDAP Browser,</span> as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/c05bf0b7-40a1-4e18-ba9c-2e40d5706561.png" style="width:28.08em;height:21.67em;"/></p>
<p>We will create an entity tree (DIT) under this partition. The partition suffix (<kbd>o=packtPublisher</kbd>) will be considered the base (or root) of the DIT. Next, we will create entries underneath it.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The LDAP structure</h1>
                </header>
            
            <article>
                
<p>Proceeding further, we will look at the DN and RDN concept in DIT. We are targeting our DIT as per the third option that you saw in the <em>Example DIT structures</em> section. Let's recall that the RDN uniquely distinguishes the entry among its siblings. That means it is a key that makes the entry unique underneath the parent entry. We can use any attribute to declare the RDN. Additionally, at each level, the attribute used as an RDN can differ.</p>
<p>In our case, the RDN of the base is <kbd>o=packtPublisher</kbd> <span>(which is the partition suffix)</span>. We have used the attribute <kbd>o</kbd>, which is the organization name. Just beneath it, there are two children, for which the <kbd>ou</kbd> attribute has been used as the RDN. The attribute <kbd>ou</kbd> stands for an organizational unit. These two children represent users and roles, respectively.</p>
<p>We are going to store the user information (the username and password, along with other information) under the <kbd>users</kbd> entity. So, the children of the <kbd>users</kbd> entity are the actual user entity for which the attribute <kbd>uid</kbd> is used as the RDN. The attribute <kbd>uid</kbd> stands for the <strong>user ID</strong>. Generally, in any organization, either the username or email ID is used for logging in; so, we can take either of them as the value of the <kbd>uid</kbd> attribute. In this case, we will give the username as <kbd>uid</kbd>.</p>
<p>We've gone over how the RDN works. Now, let's look at how the DN works. As we described, the DN uniquely identifies any entry in a given DIT. In other words, the DN makes the entry unique across the whole tree (DIT). The DN is a comma-separated string of the RDNs of the given entity, along with all of its parents, up till the root entity. So, the DN is automatically calculated, based on a given RDN at each level.</p>
<p>In the previous case, the DN of each entity (with <kbd>uid=npatel</kbd>) would be <kbd>uid=npatel</kbd><em>,</em> <kbd>ou=users</kbd><em>,</em> and <kbd>o=packtPublisher</kbd>. Similarly, the DN of the <kbd>users</kbd> entity is <kbd>ou=users</kbd> and <kbd>o=packtPublisher</kbd>. This is how the DN is calculated by appending the RDN at each level.</p>
<p>Let's create this structure in Apace DS now. Execute the following steps to expand the DIT structure in Apache Directory Studio:</p>
<ol>
<li style="font-weight: 400">Right-click on the partition <kbd>o=packtPublisher</kbd>, and select <span class="packt_screen">New | </span><span class="packt_screen">New Entry</span>.</li>
<li style="font-weight: 400">Choose an option, <em><span class="packt_screen">Create entry from scratch</span></em>, and click on <span class="packt_screen">Next</span>.</li>
<li style="font-weight: 400">We are going to add an entity type organization unit, so choose the <kbd>organizationalUnit</kbd> object class and click on <span class="packt_screen">Next</span>.</li>
<li style="font-weight: 400">We will use <kbd>ou</kbd> (organizational unit) as an RDN and <kbd>users</kbd> as its value. The DN is automatically calculated when you give the value of the RDN. You can use more than one attribute (or the same attribute multiple times, with a different value) for the RDN. The DN will then be calculated by appending each name with a comma.</li>
<li style="font-weight: 400">Click on <span class="packt_screen">Next</span>, followed by the <span class="packt_screen">Finish</span> button, and the entry <kbd>ou=users</kbd> will be added under <kbd>o=packtPublisher</kbd>. The updated structure will be visible in the <span class="packt_screen">LDAP Browser</span> window.</li>
</ol>
<p>Once the <kbd>users</kbd> entry is added, we can insert the individual user entries underneath it. The steps are as follows:</p>
<ol>
<li style="font-weight: 400">Right-click on the <kbd>users</kbd> entity (<kbd>ou=users</kbd>), and select <span class="packt_screen">New | </span><span class="packt_screen">New Entry</span>.</li>
<li style="font-weight: 400">Choose the option <span class="packt_screen">Create entry from scratch</span> and click on <span class="packt_screen">Next</span>.</li>
<li style="font-weight: 400">We are going to add a user, so choose the <kbd>inetOrgPerson</kbd> object class, which represents a person within an organization. Click on the <span class="packt_screen">Next</span> button.</li>
</ol>
<ol start="4">
<li style="font-weight: 400">We are going to add a user, so we will use the attribute <kbd>uid</kbd> (user ID) as the RDN. Just give the value as <kbd>npatel</kbd>. You can give any value that uniquely identifies the user. At this moment, the DN is calculated as <kbd>uid=npatel</kbd>,<em> </em><kbd>ou=users</kbd>, <kbd>o=packtPublisher</kbd>.</li>
<li style="font-weight: 400">Click on <span class="packt_screen">Next</span>, and you will see <span>a few </span>required attributes, like <kbd>cn</kbd> and <kbd>sn</kbd>. The <kbd>cn</kbd> stands for <strong>common name</strong>, and <kbd>sn</kbd> means <strong>surname</strong>. The first name and last name can be given for <kbd>cn</kbd> and <kbd>sn</kbd>, respectively.</li>
<li style="font-weight: 400">We want to authenticate a user, so there must be a password field (attribute) for a user entity. Just right-click on this screen and select <span class="packt_screen">New Attribute</span>.</li>
<li style="font-weight: 400">Give the attribute type as <kbd>userPassword</kbd>, and click on <span class="packt_screen">Next |</span> <span class="packt_screen">Finish</span>; a new window will pop up, in which you can give the password.</li>
<li style="font-weight: 400">Give the appropriate value for the password, confirm the password, and set the <span class="packt_screen">Hash</span> method as <span class="packt_screen">SHA</span>; click on the <span class="packt_screen">OK</span> button. Click on the <span class="packt_screen">Finish</span> button from the parent window.</li>
</ol>
<p>Add two to three such users, using the previous steps. We will look at how to add roles and create actual roles in the <em>LDAP authorization with Spring Security</em> section.</p>
<div class="packt_infobox">The default configuration of Apache DS contains a data partition with the suffix <kbd>dc=example</kbd>, <kbd>dc=com</kbd>. This partition can also be used, but to understand the concept in detail, we have created a separate partition.</div>
<p>Congratulations! The basic step of configuring the LDAP is done. The LDAP server is ready for use. Next, we will look at how to authenticate the user against the LDAP server with Spring Security.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Spring Security integration with LDAP</h1>
                </header>
            
            <article>
                
<p>In <a href="e32452e8-07bb-4815-96d6-b0db0a6009ba.xhtml">Chapter 3</a>, <em>Blogpress - A Simple Blog Management System</em>, we provided information about Spring Boot and looked at how to create an application with it. In this chapter, we will use Spring Boot to build an app to showcase authentication and authorization in Spring Security. In the <em>LDAP</em> section, we covered the installation and setup of the LDAP server, along with its data structure. <span>In this section, you will see how Spring Security works with LDAP.</span></p>
<p>Spring Security is a highly comprehensive and extensible framework; it provides authentication and authorization support for a J2EE-based web and REST application. We will look at how to integrate Spring Security with LDAP to perform authentication. By definition, <strong>authentication</strong> is a mechanism of validating or deciding whether an individual or entity is what it claims to be. </p>
<p>To demonstrate authentication, we will first build a web application with Spring Boot, and then we'll integrate it with LDAP.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a web application with Spring Boot</h1>
                </header>
            
            <article>
                
<p>We have created the data structure and have added the users, along with their credentials, in the LDAP server. Next, we will build a web application and integrate Spring Security, which will talk to the LDAP server for authentication. In the previous chapter, we built an application with Spring MVC and Thymeleaf. We will reuse the same architecture and create a web application with the following artifacts:</p>
<ul>
<li>Spring Boot, for creating a web application and auto configuration for other modules</li>
<li>Thymeleaf, for the presentation layer</li>
<li>Spring Security, to perform authentication with LDAP.</li>
</ul>
<p>Like in the previous chapter, we will use an Eclipse-based IDE called <strong>Spring Tool Suite (STS)</strong> in this chapter. Create a Spring Boot application with the name <kbd>SpringAuth</kbd>, and other suitable parameters, like the group, artifact, version, description, and Java package. Make sure that the following starters are added to <kbd>pom.xml</kbd>:</p>
<pre>&lt;depedency&gt;<br/>  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br/>  &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;<br/>&lt;/dependency&gt;<br/>&lt;dependency&gt;<br/>  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br/>  &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;<br/>&lt;/dependency&gt;<br/>&lt;dependency&gt;<br/>  &lt;groupId&gt;org.springframework.security&lt;/groupId&gt;<br/>  &lt;artifactId&gt;spring-security-ldap&lt;/artifactId&gt;<br/>&lt;/dependency&gt;</pre>
<div class="packt_infobox">Among the preceding entries, the <kbd>spring-security-ldap</kbd> is not a starter, but rather, a plain dependency. It provides the relevant dependencies required in the integration of Spring Security with LDAP.</div>
<p class="mce-root">We will configure the LDAP server as a data source to fetch user details and perform authentication in Spring Security. At this moment, Spring Security should know the details of how to connect with the LDAP server. These details are comprised of the URL, the base RDN, and the admin credentials. We will define these details in the <kbd>application.properties</kbd> file, as follows.</p>
<pre>spring.ldap.urls=ldap://localhost:10389<br/>spring.ldap.base=o=packtPublisher<br/>spring.ldap.password=secret<br/>spring.ldap.username=uid=admin,ou=system</pre>
<p class="mce-root">The details are straightforward. The username and password represent the LDAP admin credentials. Since we are dealing with LDAP, the admin username is in the form of a DN (<kbd>uid=admin</kbd><em>,</em> <kbd>ou=system</kbd>) instead of a direct value (like admin). We can relate these details with the information that we use to interact with a database (like the URL, port, username, and password). We will read these details and supply them to Spring Security to make a connection with LDAP. To achieve this, we will write a configuration class, as follows:</p>
<pre>@Configuration<br/>@ComponentScan(basePackages = { "com.nilangpatel.springldap.config" })<br/>public class LdapDataConfig {<br/>  <br/>  @Value("${spring.ldap.urls}")<br/>  private String ldapUrls;<br/><br/>  @Value("${spring.ldap.base}")<br/>  private String ldapBase;<br/><br/>  @Value("${spring.ldap.password}")<br/>  private String ldapManagerPwd;<br/>    <br/>  @Value("${spring.ldap.username}")<br/>  private String ldapManagerUserName;<br/>  <br/>  @Bean("ldapAuthStructure")<br/>  public LdapAuthStructure getLDAPAuthStructure() {<br/>    LdapAuthStructure authStructure = new LdapAuthStructure();<br/>    <br/>    authStructure.setLdapUrl(ldapUrls);<br/>    authStructure.setLdapBase(ldapBase);<br/>    authStructure.setLdapManagerDn(ldapManagerUserName);<br/>    authStructure.setLdapManagerPwd(ldapManagerPwd);<br/>    authStructure.setUserDnPattern("uid={0},ou=users");<br/>    authStructure.setUserSearchBase("ou=roles");<br/><br/>    return authStructure;<br/>  }<br/>}</pre>
<p>This class simply reads the LDAP connection properties with the <kbd>@Value</kbd> annotation, stored in the instance of the <kbd>LdapAuthStructure</kbd> class, and defines it as Spring Bean, so that it is available to other classes. The <kbd>LdapAuthStructure</kbd> is a custom class that holds LDAP configuration properties. We will use the following two additional properties for LDAP integration with Spring:</p>
<ul>
<li><kbd>userDnPattern</kbd>: The value is <kbd>uid={0},ou=users</kbd>. This is nothing but a DN pattern (relative to the entity <kbd>ou=users</kbd>). The <kbd>{0}</kbd> will be substituted with the actual value (<kbd>uid</kbd>, user ID) by Spring at runtime.</li>
<li><kbd>userSearchBase</kbd>:<strong> </strong>It represents the user base (<kbd>ou=users</kbd>). Basically, it represents an entity under which the users can be searched.</li>
<li><kbd>groupSearchBase</kbd>: It represents the group base (<kbd>ou=roles</kbd>). We will use this property to perform authorization in upcoming sections.</li>
</ul>
<p>Next, we will use these properties and initialize Spring Security with the security configuration class, as follows:</p>
<pre>@Configuration<br/>@EnableWebSecurity<br/>@ComponentScan("com.nilangpatel.springldap.security")<br/>public class WebSecurityConfig extends WebSecurityConfigurerAdapter {<br/>  <br/>  @Autowired<br/>  private LdapAuthStructure ldapAuthStructure;<br/> <br/>  private Logger logger = LoggerFactory.getLogger(WebSecurityConfig.class);<br/><br/>  @Override<br/>  public void configure(WebSecurity web) throws Exception {<br/>    web.ignoring().antMatchers("/js/**");<br/>    web.ignoring().antMatchers("/css/**");<br/>  }<br/><br/>  @Override<br/>  protected void configure(HttpSecurity http) throws Exception {<br/>     http.authorizeRequests()<br/>      .antMatchers("/").permitAll()<br/>      .anyRequest().fullyAuthenticated().and()<br/>    .formLogin().loginPage("/login").permitAll()<br/>      .defaultSuccessUrl("/privatePage",true)<br/>      .failureUrl("/login?error=true")<br/>      .and()<br/>    .logout()<br/>      .permitAll().logoutSuccessUrl("/login?logout=true");<br/>    logger.info("configure method is called to make the resources secure ...");<br/>  }<br/><br/>  @Override<br/>  protected void configure(AuthenticationManagerBuilder authManagerBuilder) throws Exception {<br/>    authManagerBuilder.ldapAuthentication()<br/>    .userDnPatterns(ldapAuthStructure.getUserDnPattern())<br/>    .userSearchBase(ldapAuthStructure.getUserSearchBase())<br/>    .contextSource()<br/>      .url(ldapAuthStructure.getLdapUrl()+"/"+ldapAuthStructure.getLdapBase())<br/>      .managerDn(ldapAuthStructure.getLdapManagerDn())<br/>      .managerPassword(ldapAuthStructure.getLdapManagerPwd())<br/>      .and()<br/>    .passwordCompare()<br/>      .passwordEncoder(new LdapShaPasswordEncoder())<br/>      .passwordAttribute("userPassword");<br/>    <br/>    logger.info("configure method is called to build Authentication manager ...");<br/>  }  <br/>  <br/>}</pre>
<p>The <kbd><span>WebSecurityConfig</span></kbd><span class="packt_screen"> </span>is a custom class that extends the <kbd>WebSecurityConfigurerAdapter</kbd> class. This class is a single point of configuration to declare security-related details. The <kbd>configure(WebSecurity web)</kbd> method is used for ignoring the requests for static resources (JS and CSS) from the security context. Without this, not a single static resource will be loaded in the browser, because they will be filtered by Spring Security.</p>
<div class="packt_infobox">For our application, we did not use any images; if we did, the image path (generally <kbd>/img/**</kbd>) would also need to be ignored.</div>
<p>The next method, <kbd>configure(HttpSecurity http)</kbd>, is used to set rules on various pages (URLs). Our motive is to showcase authentication with LDAP; hence, to make things simple, there are three pages with corresponding URLs, as follows:</p>
<ul>
<li>The home page (with the URL <span class="packt_screen"><kbd>/</kbd></span>). It is a landing page, meaning that this page will be opened when a user types <kbd>http://localhost:8080/springauth</kbd> (considering <kbd>8080</kbd> as the server port and <kbd>springauth</kbd> as the context).</li>
</ul>
<ul>
<li>The login page (with the URL <kbd>/login</kbd>). It will show a login form, with which the user can be authenticated.</li>
<li>A private page (with the URL <kbd>/privatePage</kbd>). This is a protected page and is only available to the logged in user. A user will be redirected to this page upon successful login. </li>
</ul>
<p>The home page and login page are set to view for all, while the private page is set as a successful URL after logging in. This is a simple form login. The next method, <kbd>configure(AuthenticationManagerBuilder authManagerBuilder)</kbd>, actually does the magic. This is the place where the LDAP is being configured as an authentication mechanism. </p>
<p>In this class, the object of <kbd>LdapAuthStructure</kbd> is being auto-wired, which is supplied from the <kbd>LdapDataConfig</kbd> class, where we declared it with the <kbd>@Bean</kbd> annotation. Let's recall that the <span><kbd>LdapAuthStructure</kbd> class holds the LDAP connection data, which we are using in the <kbd>configure(AuthenticationManagerBuilder authManagerBuilder)</kbd> method. The call <kbd>ldapAuthentication()</kbd> on the <kbd>AuthenticationManagerBuilder</kbd> class will set the type of authentication as LDAP. </span></p>
<p><span>Further, it will set other connection data, like <kbd>userDnPattern</kbd> and <kbd>userSearchBase</kbd>. The value of <kbd>url</kbd> is supplied as a combination of the LDAP URL and the LDAP base (for example, <kbd>localhost:10389/o=packtPublisher</kbd>). In the end, the admin credential is supplied with the <kbd>managerDn()</kbd> and <kbd>managerPassword()</kbd> call. </span>We also need to supply a password encoder. It must be the same password encoder that we used in the LDAP server, so we have used <kbd>LdapShaPasswordEncoder</kbd>. Finally, we are just mentioning the password field that we set in the LDAP server.</p>
<p>The LDAP authentication configuration is done. When we log in with the (same) credentials that we created in the Apache DS server, it will be successful. We have set the <kbd>uid</kbd><em> </em>as <kbd>userDnPatterns</kbd>, so give <kbd>uid</kbd> as the username when logging in.</p>
<p>Congratulations! The LDAP integration with Spring Security has been successfully executed. The user will be authenticated against LDAP through Spring Security. If you only need to perform authentication with LDAP, the configuration that we have done so far will suffice. Next, we will look at how to interact with the LDAP server through the Spring Data repository, which we will use while working with both LDAP and OAuth later in this chapter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Managing LDAP users with Spring Data</h1>
                </header>
            
            <article>
                
<p>One part of our integration is over. The LDAP admin can configure users from the LDAP server; then, they can be authenticated from web applications created with Spring Security. However, we still have to deal with separate systems (Apache DS) to maintain the user information.</p>
<p>How cool would it be if an admin could directly maintain the users from a Spring web application? This is a great idea, because it will not only make the admin job easy, but a user will be able to update their profile information (like the password, first name, last name, and so on) directly in the Spring-based web application. This is quite possible with Spring Boot. We are talking about performing CRUD operations on the LDAP server from a web application. </p>
<p>In our application, the LDAP is used as a data store, where we are maintaining user data. Whenever we need to deal with any kind of data provider in a Spring-based application, we need to use <strong>Spring Data</strong>, a module of the Spring family that was specially designed to interact with the data store. Spring Data facilitates an abstract layer to interact with the underlying data provider, while providing an implementation for each of the data providers, like JPA, REST, Elasticsearch (which we used in the previous chapter), Mongo DB, and so on. S<span>pring Data LDAP interacts with the LDAP server, and we will use it in our application.</span></p>
<p>Spring supplies a set of libraries for each of these data providers, which can be availed of by specifying the corresponding starter in the Spring Boot application. The Spring Data LDAP module can be integrated with the following starter entry in <kbd>pom.xml</kbd>:</p>
<pre>&lt;dependency&gt;<br/>  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br/>  &lt;artifactId&gt;spring-boot-starter-data-ldap&lt;/artifactId&gt;<br/>&lt;/dependency&gt;</pre>
<p>Soon after we have defined this starter, all of the required JARs will be available in the classpath. Next, we will create the model (entity) class.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Spring Data models</h1>
                </header>
            
            <article>
                
<p>The Spring Data module provides an implementation of DAO, with the aim of making data access consistent for various data providers. This brings the great flexibility of switching the underlying persistence technologies without much effort. Eventually, this will make the system loosely coupled.</p>
<p>Spring Data allows for exchanging the data with the persistence layer in an object-oriented manner, meaning that we can perform CRUD operations with entity class objects. Needless to say, the Spring Data LDAP module also facilitates the feature of dealing with the LDAP server in the form of the model class object. So, the first thing is to define the model (entity) class that represents the user data that we defined in the LDAP server, as follows:</p>
<pre>@Entry(<br/>  base = "ou=users", <br/>  objectClasses = {"top", "person", "organizationalPerson","inetOrgPerson"})<br/>public final class LdapAuthUser implements Persistable&lt;Name&gt; {<br/><br/>  @Id<br/>  private Name id;<br/>    <br/>  @Attribute(name = "uid")<br/>  @DnAttribute(value="uid")<br/>  private String userName;<br/>  <br/>  @Attribute(name = "sn")<br/>  private String surName;<br/>  <br/>  @Attribute(name = "cn") <br/>  private String firstName;<br/>  <br/>  @Attribute(name = "userPassword") <br/>  private String password;<br/>  <br/>  @Transient<br/>  private boolean isNew;<br/><br/>  //.. setter and getter methods<br/>}</pre>
<p>The <kbd>LdapAuthUser</kbd> class represents the LDAP user that we created in Apache DS. The <kbd>@Entity</kbd> annotation is used to map the Java class with an entity in the LDAP server. The <kbd>base</kbd> represents the base of the <kbd>users</kbd> entity (<kbd>ou=users</kbd>), while <kbd>objectClasses</kbd> is used to define the object class hierarchy used for creating the user entity. </p>
<p>The <kbd>@Attribute</kbd> annotation is used to map the instance variable with the attribute of the LDAP entity. The annotation <kbd>@DnAttribute</kbd> is used to populate the values automatically, from the distinguished names of the entries found. Special attention for <kbd>id</kbd> instance variable. <span>It will be of the type </span><kbd>javax<span>.naming.Name</span></kbd><span>. </span></p>
<p>There is no direct attribute, like <kbd>id</kbd>, in the LDAP entity, but Spring Data needs some sort of unique identifier (like <kbd>PK</kbd>, in a relational database) for each instance of the model class. So, internally, it assigns a DN relative to a <kbd>base</kbd> (in the <kbd>@Entity</kbd> annotation) defined for the model class. For example, if the <kbd>uid</kbd> of a user is <kbd>npatel</kbd>, then the <kbd>id</kbd> would be <kbd>uid=npatel</kbd>, <kbd>ou=users</kbd>.</p>
<p>Another unique point is that this model class implements the <kbd>Persistable&lt;Name&gt;</kbd> interface. Especially for the LDAP, at the time of adding a new entity, Spring Data does not have any way of knowing whether the entity is new or existing. So, every time <span>Spring Data </span>tries to search for an existing entity, it will throw an error if the entity does not exist. To avoid this, while adding a new record, we will explicitly set the <kbd>isNew</kbd> attribute to <kbd>true</kbd>, so that Spring Data will get its value with the overridden method <kbd>isNew()</kbd><span>.</span></p>
<p>The model class is now ready to use. Next, we will perform CRUD operations for LDAP users with Spring Data.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Spring Data repository for LDAP</h1>
                </header>
            
            <article>
                
<p>As you have seen, Spring Data provides an abstract (interface) layer while working with the persistence layer, in order to support various data stores, including relational databases, non-relational databases, map-reduce frameworks, cloud services, and so on. The abstraction starts with the <kbd>CrudRepository</kbd> interface, which provides basic CRUD operations, irrespective of the underlying data stores. This interface covers all basic CRUD operations. </p>
<p>Spring Data defines various interfaces, which are specific to each data provider on top of the <kbd>CrudRepository</kbd>. For LDAP support, Spring Data supplies the <kbd>LdapRepository</kbd> interface, which basically extends the <kbd>CrudRepository</kbd> interface, the one that we will extend for our custom repository. This interface has all of the required methods to perform CRUD operations. This way, by extending the specific repository interface, all basic CRUD operations for standard data access will be readily available. </p>
<p>Let's add Spring Data capability to LDAP in our application. The custom repository interface will be as follows:</p>
<pre>@Repository<br/>public interface LdapAuthRepository extends LdapRepository&lt;LdapAuthUser&gt;{<br/><br/>}</pre>
<p>The <kbd>@Repository</kbd> annotation is used to describe that this is the repository interface. The custom interface <kbd>LdapAuthRepository</kbd> extends the <kbd>LdapRepository</kbd> with the model entity <kbd>LdapAuthUser</kbd>, which we created in the previous section. Upon declaring this interface, Spring Data provides the CRUD implementation that we can use in the service class, as follows:</p>
<pre>@Component<br/>public class LdapAuthService {<br/><br/>  private Logger logger = LoggerFactory.getLogger(LdapAuthService.class);<br/>  <br/>  @Autowired<br/>  private LdapAuthRepository ldapAuthRepository;<br/><br/>//Create<br/>  public void addUser(LdapAuthUser ldapAuthUser) {<br/>    Name dn = LdapNameBuilder<br/>            .newInstance()<br/>            .add("uid", ldapAuthUser.getUserName())<br/>            .add("ou", "users")<br/>            .build();<br/><br/>    boolean isExist = ldapAuthRepository.existsById(dn);<br/>    if(isExist ==false) {<br/>      ldapAuthRepository.save(ldapAuthUser);<br/>    }else {<br/>      logger.info("User with username "+ldapAuthUser.getUserName()+" is already exist ");<br/>    }<br/>  }<br/>  //Read  <br/>  public LdapAuthUser getUser(String userName) {<br/>    Optional&lt;LdapAuthUser&gt; ldapAuthUserOptional = ldapAuthRepository.<br/>            findOne(LdapQueryBuilder.query().where("uid").is(userName));<br/>    if(ldapAuthUserOptional.isPresent()) {<br/>      return ldapAuthUserOptional.get();<br/>    }else {<br/>      return null;<br/>    }<br/>  }<br/>  //Update<br/>  public void updateLdapUser(LdapAuthUser ldapUser) {<br/>    ldapAuthRepository.save(ldapUser);<br/>    <br/>  }<br/>//Delete<br/>public void deleteUser(String userName) {<br/>    Optional&lt;LdapAuthUser&gt; ldapAuthUserOptional = ldapAuthRepository.<br/>            findOne(LdapQueryBuilder.query().where("uid").is(userName));<br/>    if(ldapAuthUserOptional.isPresent()) {<br/>      ldapAuthRepository.delete(ldapAuthUserOptional.get());<br/>    }else {<br/>      logger.info("User with username "+userName+" does not exist ");<br/>    }<br/>  }<br/>}</pre>
<p>In this service class, the object of the <kbd>LdapAuthRepository</kbd> class is injected with the <kbd>@Autowired</kbd> annotation. It is used to call the CRUD methods, as follows:</p>
<ul>
<li><strong>CREATE</strong>: The <kbd>existsById()</kbd> command is used to check whether a user with the same ID already exists. The ID is of the type <kbd>javax.naming.Name</kbd>. The <kbd>LdapNameBuilder</kbd> class is used to build the ID. If a user does not exist, the <kbd>save</kbd> method is called on the <kbd>ldapAuthRepository</kbd> object, in order to create a fresh object. We can call this service method to add the record from the Spring MVC controller. We need to create the object of <kbd>LdapAuthUser</kbd>, set the data, and call the service method from the controller method, as follows:</li>
</ul>
<pre>        LdapAuthUser ldapUser = new LdapAuthUser();<br/>        ldapUser.setUserName("kpatel");<br/>        ldapUser.setPassword("test1234");<br/>        ldapUser.setFirstName("Komal");<br/>        ldapUser.setSurName("Patel");<br/>        ldapUser.setIsNew(true);<br/>        <br/>        Name dn = LdapNameBuilder.newInstance()<br/>              .add("ou=users")<br/>              .add("uid=kpatel")<br/>              .build();<br/>        ldapUser.setId(dn);<br/>        <br/>        ldapAuthService.addUser(ldapUser);</pre>
<ul>
<li style="list-style-type: none">
<ul>
<li>To create a new user, the object of the model class (<kbd>LdapAuthUser</kbd>) needs to be created first, along with its attribute.</li>
<li>Since we are creating a new user, it is required to set <kbd>isNew</kbd> to <kbd>true</kbd>, to make sure that the Spring Data module considers it a new record. Without doing this, the system will throw an error.</li>
<li>We also need to set the value of <kbd>id</kbd>. The <kbd>LdapNameBuilder</kbd> is used to create the object of the type <kbd>javax.naming.Name</kbd> (<kbd>id</kbd>). It is also required to add values like <kbd>uid=kpatel</kbd> (<kbd>username</kbd>) and <kbd>ou=users</kbd> in <kbd>id</kbd>. </li>
</ul>
</li>
<li><strong>READ</strong>:<strong> </strong>To read the LDAP user with <kbd>username</kbd>, the <kbd>findOne()</kbd> method is used. We need to pass the LDAP query inside of this method. The <kbd>LdapQueryBuilder</kbd> class is used to create the LDAP query, which matches the <kbd>username</kbd> against the <kbd>uid</kbd>.</li>
<li><strong>UPDATE</strong>: The update operation is straightforward. The <kbd>save</kbd> method of <kbd>ldapAuthRepository</kbd><span> will actually update the LDAP user. </span></li>
</ul>
<ul>
<li><strong>DELETE</strong>: When deleting a user, first, it is required to check whether the user exists. Again, <kbd>fineOne</kbd> can be used to retrieve the existing user. The <kbd>delete</kbd> operation can only be executed if a user exists.</li>
</ul>
<p>Additionally, we can use the following methods to perform authentication programmatically, in the service class, as follows:</p>
<pre> public boolean authenticateLdapUserWithContext(String userName, String password) {<br/>    return ldapAuthRepository.authenticateLdapUserWithContext(userName, password);<br/>  }<br/>  <br/>  public boolean authenticateLdapUserWithLdapQuery(String userName, String password) {<br/>    return ldapAuthRepository.authenticateLdapUserWithLdapQuery(userName, password);<br/>  }</pre>
<p>The <kbd>authenticateLdapUserWithLdapQuery</kbd> and <kbd>authenticateLdapUserWithContext</kbd> are the custom methods defined in the <kbd>LdapAuthRepositoryCustomImpl</kbd> class, where we can define the custom method to interact with LDAP. We will discuss this topic further in the next section.</p>
<p>Upon successful authentication, these methods will return <kbd>true</kbd>; otherwise, they will be <kbd>false</kbd>. We need to pass the password in a plain text format for both of these methods. This is how the Spring Data repository is used to perform CRUD operations on LDAP users. Alternatively, we can use <kbd>LdapTemplate</kbd> to perform CRUD operations, as well as other complex business functions.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Performing CRUD operations with LdapTemplate</h1>
                </header>
            
            <article>
                
<p>The Spring Data repository is a convenient way to interact with the underlying data provider, as it is easy to use and requires less code, because the implementation is provided by the Spring Data module out of the box. However, this simplicity comes with certain limitations. For example, with the repository programming model, we only have basic CRUD operations available to use. For more complex business needs, we need to extend this and provide our own repository implementation. This is where the Template model comes into the picture.</p>
<p>The template model in the Spring Data module is less handy than repository abstraction, but it is more powerful in terms of furnishing more fine-grained control for complex operations that we execute on the data store. We will look at the same CRUD operations with the Spring Data template model. Of course, the motive is to learn how to prepare the Spring Data template so that it can be used for complex business functions.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Initializing LdapTemplate</h1>
                </header>
            
            <article>
                
<p>Spring Data provides templates for each of the underlying data providers, like <kbd>JdbcTemplate</kbd>, <kbd>JpaTemplate</kbd>, <kbd>MongoTemplate</kbd>, <kbd>ElasticSearchTemplate</kbd>, <kbd>CassandraTemplate</kbd>, and so on. The <kbd>LdapTemplate</kbd> is the one that is used to communicate with the LDAP server. We will first initialize <kbd>LdapTemplate</kbd>. Add the following methods to the <kbd>LdapDataConfig</kbd> class:</p>
<pre>@Bean("ldapTemplate")<br/>  public LdapTemplate getLdapTemplate() {<br/>    return new LdapTemplate(getLdapContextSrc());<br/>  }<br/><br/>  @Bean<br/>  public ContextSource getLdapContextSrc() {<br/>    LdapContextSource ldapContextSrc = new LdapContextSource();<br/>    ldapContextSrc.setUrl(ldapUrls);<br/>    ldapContextSrc.setUserDn(ldapManagerUserName);<br/>    ldapContextSrc.setPassword(ldapManagerPwd);<br/>    ldapContextSrc.setBase(ldapBase);<br/>    ldapContextSrc.afterPropertiesSet();<br/>    return ldapContextSrc;<br/>  }</pre>
<p>The <kbd>getLdapContextSrc()</kbd> method first creates an object of <kbd>LdapContextSource</kbd> and initializes it with the LDAP connection parameters that were read from <kbd>application.properties</kbd>. The <kbd>@Bean</kbd> annotation will export this object as a Spring bean. The second method, <kbd>getLdapTemplate()</kbd>, uses the object of <kbd>LdapContextSoruce</kbd> and initializes the object of the <kbd>LdapTemplate</kbd> class; then, it is exposed as a Spring bean with <kbd>id=ldapTemplate</kbd>, with the <kbd>@Bean</kbd> annotation. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using LdapTemplate to perform CRUD operations</h1>
                </header>
            
            <article>
                
<p>Now, we have initialized the <kbd>LdapTemplate</kbd> object. Next, we will use it to perform various CRUD operations. We will use <kbd>LdapTemplate</kbd> in the Spring Data repository structure. For this, we need to extend the Spring Data repository model and provide a custom implementation. </p>
<p>Create an interface: <kbd>LdapAuthRepositoryCustom</kbd>. This is a place where we can define customized methods that are not directly available with the repository abstraction. Update the definition of the <kbd>LdapAuthRepository</kbd> interface, as follows:</p>
<pre>@Repository<br/>public interface LdapAuthRepository extends LdapRepository&lt;LdapAuthUser&gt;,LdapAuthRepositoryCustom<br/>{<br/><br/>}</pre>
<p>This is a glue point of the custom implementation with the Spring Data repository framework. Finally, define the <kbd>LdapAuthRepositoryCustomImpl</kbd><span> </span>class that implements the <span><kbd>LdapAuthRepositoryCustom</kbd><span> </span>interface. This is the class where the implementation of custom methods are defined, as follows:</span></p>
<pre>@Repository<br/>public class LdapAuthRepositoryCustomImpl implements LdapAuthRepositoryCustom {<br/><br/>  private Logger logger = LoggerFactory.getLogger(LdapAuthRepositoryCustomImpl.class);<br/>  <br/>  @Autowired<br/>  private LdapTemplate ldapTemplate;<br/><br/>  ...// Custom implementation method.</pre>
<p>The <kbd>LdapAuthRepositoryCustomImpl</kbd> implements the <kbd>LdapAuthRepositoryCustom</kbd> interface, which is used to declare custom repository methods. This class has an instance variable of the type <kbd>LdapTemplate</kbd>, which is injected with the <kbd>@Autowired</kbd> annotation (created in the <kbd>LdapDataConfig</kbd> class). Next, we will look at some of the methods defined in this class, as follows.</p>
<ul>
<li><strong>CREATE operation:</strong> <span>The following code block describes how the CREATE operation is used to add a new LDAP user, with <kbd>ldapTemplate</kbd>: </span></li>
</ul>
<pre>@Override<br/>  public void create(LdapAuthUser ldapAuthUser) {<br/>    ldapAuthUser.setIsNew(true);<br/>    ldapTemplate.create(ldapAuthUser);<br/>  }<br/>  @Override<br/>  public void createByBindOperation(LdapAuthUser ldapAuthUser) {<br/>    <br/>    DirContextOperations ctx = new DirContextAdapter();<br/>    ctx.setAttributeValues("objectclass", new String[] {"top", "person",     "organizationalPerson","inetOrgPerson"});<br/>    ctx.setAttributeValue("cn", ldapAuthUser.getFirstName());<br/>    ctx.setAttributeValue("sn", ldapAuthUser.getSurName());<br/>    ctx.setAttributeValue("uid", ldapAuthUser.getUserName());<br/>    ctx.setAttributeValue("password", ldapAuthUser.getPassword());<br/>    <br/>    Name dn = LdapNameBuilder.newInstance()<br/>            .add("ou=users")<br/>            .add("uid=bpatel")<br/>            .build();<br/>    <br/>    ctx.setDn(dn);<br/>    ldapTemplate.bind(ctx);<br/>    <br/>  }</pre>
<p style="padding-left: 60px">The first method is straightforward. It uses <kbd>ldapTemplate</kbd> to create an LDAP user with the model object. We have set <kbd>isNew</kbd> to <kbd>true</kbd>, to make sure that there will not be any issues while creating the LDAP user. The second method, <kbd>createByBindOperation</kbd>, uses a low-level API to create the LDAP user. The object of <kbd>DirContextAdapter</kbd> is first initialized with various model attributes, like <kbd>objectClass</kbd>, <kbd>cn</kbd>, <kbd>sn</kbd>, <kbd>uid</kbd>, <kbd>userPassword</kbd>, and <kbd>dn</kbd>. The <kbd>LdapNameBuilder</kbd> class is used to create the DN of the LDAP user. Finally, the <kbd>bind</kbd> method of <kbd>ldapTemplate</kbd> is used to create the user. We can use either of these methods to create a user. </p>
<ul>
<li><strong>READ operation: </strong><span>The following code block depicts how the READ operation is used to fetch the LDAP user, with </span><kbd>ldapTemplate</kbd><span>:</span></li>
</ul>
<pre>@Override<br/>public LdapAuthUser findByUserName(String userName) {<br/>    return ldapTemplate.findOne(<br/>        LdapQueryBuilder.query().where("uid").is(userName), LdapAuthUser.class);<br/>}<br/><br/>@Override<br/>public List&lt;LdapAuthUser&gt; findByMatchingUserName(String userName) {<br/>   return ldapTemplate.find(<br/>       LdapQueryBuilder.query().where("uid").like(userName), LdapAuthUser.class);<br/>}<br/><br/>@Override<br/>public LdapAuthUser findByUid(String uid) {<br/>    return ldapTemplate.findOne(LdapQueryBuilder.query().where("uid").is(uid), LdapAuthUser.class);<br/>}<br/><br/>@Override<br/>public List&lt;LdapAuthUser&gt; findAllWithTemplate() {<br/>   return ldapTemplate.findAll(LdapAuthUser.class);<br/>}<br/><br/>@Override<br/>public List&lt;LdapAuthUser&gt; findBySurname(String surName) {<br/>    return ldapTemplate.find(LdapQueryBuilder.query().where("sn").is(surName), LdapAuthUser.class);<br/>}</pre>
<p style="padding-left: 60px">These are a few methods that read the user from the LDAP server. The <kbd>LdapQueryBuilder</kbd> is used to construct a query that can be used to perform a search of various attributes, such as <kbd>uid</kbd>, and <kbd>surname</kbd>. It can also be used to find users with matching attributes, with the <kbd>like</kbd> query. </p>
<ul>
<li><strong>UPDATE operation:</strong><strong> </strong>T<span>he</span> <span>following code block shows how the UPDATE operation updates the LDAP user, with</span> <kbd>ldapTemplate</kbd>:</li>
</ul>
<pre>@Override<br/>  public void updateWithTemplate(LdapAuthUser ldapAuthUser) {<br/>    ldapTemplate.update(ldapAuthUser);<br/>  }</pre>
<p style="padding-left: 60px">The <kbd>update</kbd> method is straightforward. The <kbd>update()</kbd> method is used to update the LDAP user with the model object.</p>
<ul>
<li><strong>DELETE operation:</strong> <span>The following code block describes how the DELETE operation is used to delete the LDAP user, with</span><span> </span><kbd>ldapTemplate</kbd><span>:</span></li>
</ul>
<pre>  @Override<br/>  public void deleteFromTemplate(LdapAuthUser ldapAuthUser) {<br/>    ldapTemplate.delete(ldapAuthUser);<br/>  }<br/>  <br/>  @Override<br/>  public void deleteFromTemplateWithUnbind(String userName) {<br/>    Name dn = LdapNameBuilder.newInstance()<br/>            .add("ou=users")<br/>            .add("uid="+userName)<br/>            .build();<br/>    ldapTemplate.unbind(dn);<br/>  }</pre>
<p style="padding-left: 60px">The first method is straightforward. It simply calls the <kbd>delete</kbd> method on the <kbd>ldapTemplate</kbd> object to delete the LDAP user. The second method first creates the user DN, and then calls the <kbd>unbind</kbd> method on <kbd>ldapTemplate</kbd>, to delete the user.</p>
<div class="packt_infobox">The <kbd>delete</kbd> method on <kbd>ldapTemplate</kbd> simply calls the <kbd>unbind</kbd> method with a null check on the given entity. So, both of the methods, <kbd>delete()</kbd> and <kbd>unbind()</kbd>, are ultimately doing the same thing. </div>
<p>In addition to the basic CRUD operations, we can perform some other operations with <kbd>ldapTemplate</kbd>, as follows:</p>
<pre>@Override<br/>public boolean authenticateLdapUserWithLdapQuery(String userName, String password) {<br/>    try {<br/>     ldapTemplate.authenticate(LdapQueryBuilder.query().where("uid").is(userName), password);<br/>     return true;<br/>    }catch(Exception e) {<br/>      logger.error("Exception occuired while authenticating user with user name "+userName,e.getMessage(),e);<br/>    }<br/>    return false;<br/>  }<br/>  <br/>@Override<br/>public boolean authenticateLdapUserWithContext(String userName, String password) {<br/>    DirContext ctx = null;<br/>    try {<br/>      String userDn = getDnForUser(userName);<br/>      ctx = ldapTemplate.getContextSource().getContext(userDn, password);<br/>      return true;<br/>    } catch (Exception e) {<br/>      // If exception occurred while creating Context, means - authentication did not succeed<br/>      logger.error("Authentication failed ", e.getMessage(),e);<br/>      return false;<br/>    } finally {<br/>      // DirContext must be closed here.<br/>      LdapUtils.closeContext(ctx);<br/>    }<br/>}</pre>
<p>The first method calls the <kbd>authenticate</kbd> method on the <kbd>ldapTemplate</kbd> by passing the <kbd>LdapQuery</kbd> and <kbd>password</kbd>. The <kbd>LdapQueryBuilder</kbd> is used to create the LDAP query for the given username. The second method calls <kbd>getContextSource().getContet()</kbd> on the <kbd>ldapTemplate</kbd> object by passing the user DN and password. The context is required to be closed at the end. The user DN is obtained for a given <kbd>userName</kbd> with the <kbd>getDnForUser()</kbd> method, as follows:</p>
<pre>  private String getDnForUser(String uid) {<br/>      List&lt;String&gt; result = ldapTemplate.search(<br/>          LdapQueryBuilder.query().where("uid").is(uid),<br/>          new AbstractContextMapper&lt;String&gt;() {<br/>             protected String doMapFromContext(DirContextOperations ctx) {<br/>                return ctx.getNameInNamespace();<br/>             }<br/>          });<br/>      if(result.size() != 1) {<br/>        throw new RuntimeException("User not found or not unique");<br/>      }<br/>      return result.get(0);<br/>   }</pre>
<p>The <kbd>search</kbd> method of <kbd>ldapTemplate</kbd> is called by passing <kbd>LdapQuery</kbd> and an implementation of <kbd>ContextMapper</kbd>, and finally, it returns a user DN (for example, <kbd>uid=npatel</kbd>, <kbd>ou=users</kbd>, <kbd>o=packtPublisher</kbd>) for the given username.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">LDAP authorization with Spring Security</h1>
                </header>
            
            <article>
                
<p> </p>
<p>You saw LDAP authentication with Spring Security in the previous section. Next, we will look at how to perform authorization. Let's recall that <strong>authorization</strong> is a verification process of whether an entity should have access to something. In short, authorization concerns the rules that will identify who is allowed to do what. After successful authentication, a user can perform various actions, based on the authority they have.</p>
<p>Let's recall that authentication deals with login credentials to verify valid users. Authorization is more of a check of whether a user has the authority to perform various actions, like adding, updating, viewing, or deleting a resource.<span> An authorization happens after the user has been successfully authenticated. In this section, we will look at how to authorize an LDAP user.</span></p>
<p>So far, you have seen that the user's details are maintained at the LDAP server, which is used by Spring Security to perform authentication. Similarly, we will set up authorization details in the LDAP server and fetch them in Spring Security to achieve authorization.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating roles in the LDAP server</h1>
                </header>
            
            <article>
                
<p>As you saw in the previous section, we have created the <kbd>users</kbd> entity (<kbd>ou=users</kbd>) under the root entity (<kbd>o=packtPublisher</kbd>), and have kept all users under that entity in the LDAP server. Similarly, to store authorization information, we will create a new entity directly under the root entity in Apache DS, with the following steps:</p>
<ol>
<li>Right-click on the partition <kbd>o=packtPublisher</kbd> and select <span class="packt_screen">New | New Entry</span><em> </em>from the <span class="packt_screen">LDAP Browser</span> window.</li>
<li>Choose the option <span class="packt_screen">Create entry from scratch</span> and click on the <span class="packt_screen">Next</span> button.</li>
<li>We are going to add an entity type organization unit, so choose the <span class="packt_screen">organizationalUnit</span> object class and click on the <span class="packt_screen">Next</span><em> </em>button.</li>
<li>We will use <kbd>ou</kbd> (organizational unit) as the RDN and roles as its value. The DN is automatically calculated when we give the value of the RDN. You can use more than one attribute (or the same attribute multiple times, with different values) for the RDN. The DN will then be calculated by appending each of them with a comma.</li>
<li>Click on the <span class="packt_screen">Next</span> button, followed by the <span class="packt_screen">Finish</span> button, and the entry <span class="packt_screen"><kbd>ou=roles</kbd></span> will be added under <kbd>o=packtPublisher</kbd>. The updated structure will be visible in the <span class="packt_screen">LDAP Browser</span> window.</li>
</ol>
<p>Next, we will add the actual role entries under the <kbd>ou=roles</kbd> entry. The steps are as follows:</p>
<ol>
<li style="font-weight: 400">Right-click on the roles entity (<kbd>ou=roles</kbd>) and select<em><span class="packt_screen"><span> </span>New | New Entry</span></em>.</li>
<li style="font-weight: 400">Choose the option<span> </span><span class="packt_screen">Create entry from scratch<span> </span></span>and click on<span> </span><span class="packt_screen">Next</span><em>.</em></li>
<li style="font-weight: 400">To add a role, choose<span> </span><kbd>groupOfNames</kbd><span> as the </span>object class that represents a role. Click on the<span> </span><span class="packt_screen">Next</span><span> </span>button.</li>
<li style="font-weight: 400">We are going to add a role, so we will use the attribute<span> </span><kbd>cn</kbd><span> </span>(common name) as the RDN. Just give the value as<span> </span><kbd>ADMIN</kbd>. At this moment, the DN is calculated as<span> </span><kbd>cn=ADMIN</kbd>, <kbd>ou=roles</kbd>, <kbd>o=packtPublisher</kbd>. Click on the <span class="packt_screen">Next</span> button.</li>
<li>Since this entity has <kbd>groupOfNames</kbd> as the object class, the system will ask for the member assignment in the next window. </li>
<li>Click on the <span class="packt_screen">Browse</span> button and choose the user that you want to assign this role, under the <kbd>o=packtPublisher</kbd> entry. Click on the <span class="packt_screen">OK</span> button.</li>
<li>The following are the steps for assigning multiple members in the given role:
<ol>
<li>Select any of the role entries from the <span class="packt_screen">LDAP Browser</span> window. Right-click in the middle section (where the details of the selected role are visible a tabular format) and choose <span class="packt_screen">New Attribute</span>.</li>
<li>Give the value of <span class="packt_screen">Attribute type</span> as <kbd>member</kbd>, click on <span class="packt_screen">Next</span><em>,</em> and click on the <span class="packt_screen">Finish</span> button; you will see the same window for selecting the user to assign to this role.</li>
</ol>
</li>
</ol>
<p>Execute these steps and create the following two roles under the roles entry:</p>
<ul>
<li><kbd>ADMIN</kbd></li>
<li><kbd>USER</kbd></li>
</ul>
<p>The role structure has been created in Apache DS. We will now import these details to perform authorization.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Importing role information to perform authorization</h1>
                </header>
            
            <article>
                
<p>In the <em>Example DIT structures</em> section of this chapter, we created a role entity (<kbd>ou=roles</kbd>) under the root entity (<kbd>o=packtPublisher</kbd>). The role entity contains various roles as its child entities. We will look at how to use these roles to perform authorization with Spring Security. We have already configured Spring Security to perform authentication with LDAP. We will now add two sample pages, and configure it so that one page is only accessible by a user with the <kbd>ADMIN</kbd> role, and the other is accessible by a user with either the <kbd>USER</kbd> or <kbd>ADMIN</kbd> role.</p>
<p>To achieve this, the changes need to be done in the <kbd>configure</kbd> method of the <kbd>WebSecurityConfig</kbd> class that we created for Spring Security configuration. The updated method should look as follows:</p>
<pre>  @Override<br/>  protected void configure(HttpSecurity http) throws Exception {<br/>    http.authorizeRequests()<br/>      .antMatchers("/").permitAll()<br/>      .antMatchers("/adminPage/").hasAnyAuthority("ADMIN")<br/>      .antMatchers("/userPage/").hasAnyAuthority("USER")<br/>      .anyRequest().fullyAuthenticated()<br/>      .and()<br/>   .formLogin().loginPage("/login").permitAll()<br/>      .defaultSuccessUrl("/privatePage",true)<br/>      .failureUrl("/login?error=true")<br/>      .and()<br/>      .logout()<br/>      .permitAll().logoutSuccessUrl("/login?logout=true");<br/>    logger.info("configure method is called to make the resources secure ...");<br/>  }</pre>
<p>We have added an admin page (with the URL <kbd>/adminPage/</kbd>) and a user page <span>(with the URL </span><kbd>/usePage/</kbd><span>),</span> and have configured them so that they can be accessed by a user with the <kbd>ADMIN</kbd> and <kbd>USER</kbd> role, respectively.</p>
<p>Additionally, we need to create respective Thymeleaf templates under the <kbd>src/main/resources/templates</kbd> folder and entries for both of these pages in the Spring MVC controller class, and update the menu structure (defined in the header template) to accommodate these pages. The full details are mentioned in the source code, which is available in GitHub (<a href="https://github.com/PacktPublishing/Spring-5.0-Projects">https://github.com/PacktPublishing/Spring-5.0-Projects</a>).</p>
<p>Next, we will update the <kbd>configure</kbd> method that represents the LDAP configuration with Spring Security. This method takes an object of the type <kbd>AuthenticationManagerBuilder</kbd>. After making the required changes, this method will look as follows:</p>
<pre>  @Override<br/>  protected void configure(AuthenticationManagerBuilder authManagerBuilder) throws Exception {<br/>    authManagerBuilder.ldapAuthentication()<br/>      .userDnPatterns(ldapAuthStructure.getUserDnPattern())<br/>      .userSearchBase(ldapAuthStructure.getUserSearchBase())<br/>      .groupSearchBase(ldapAuthStructure.getGroupSearchBase())<br/>      .groupSearchFilter("member={0}").rolePrefix("")<br/>    .contextSource()<br/>      .url(ldapAuthStructure.getLdapUrl()+"/"+ldapAuthStructure.getLdapBase())<br/>      .managerDn(ldapAuthStructure.getLdapManagerDn())<br/>      .managerPassword(ldapAuthStructure.getLdapManagerPwd())<br/>      .and()<br/>    .passwordCompare()<br/>      .passwordEncoder(new LdapShaPasswordEncoder())<br/>      .passwordAttribute("userPassword");<br/>    <br/>    logger.info("configure method is called to build Authentication manager ...");<br/>  }</pre>
<p>The following are the changes that we made for authorization:</p>
<ul>
<li>Added the <kbd>groupSearchBase</kbd> method call and passed the value as <kbd>ou=roles</kbd>, which represents the base for group search. The group search base value (<kbd>ou=roles</kbd>) is stored in an <kbd>ldapAuthStructure</kbd> object that we created to hold LDAP connection properties. </li>
<li>Added a <kbd>groupSearchFilter</kbd> method call and passed the value as <kbd>member={0}</kbd>. It is used to define the pattern to search the members. The <kbd>{0}</kbd> will be substituted by the actual user DN at runtime. </li>
<li>The additional method <kbd>rolePrefix("")</kbd> is placed to set the role prefix. In absence of this method call, the role name will be prepended with <kbd>ROLE_</kbd> by Spring Security. As an example, for the role <kbd>ADMIN</kbd> defined in the LDAP server, the actual role return by Spring Security would be <kbd>ROLE_ADMIN</kbd>. To avoid this, we call this method and simply pass an empty string, so that we get the exact role name that we defined in the LDAP server. </li>
</ul>
<p>The configuration part of the authorization is over. You can create some sample users in Apache DS, assign them roles, and check whether they are able to access the pages that we have created. A user that does not have any role cannot access any of the pages (admin or user).</p>
<p>This was all about the integration of LDAP using Spring Security. In the next section, we will look at OAuth integration.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">OAuth</h1>
                </header>
            
            <article>
                
<p>A typical web application requires credentials, in the form of a username/password, to perform authentication. The HTML form is used to ask for credentials in the browser, and then send them to the server. The server then authenticates the information, creates and maintains a session at the server side, and sends the session ID back to the browser.</p>
<p>The session ID will be sent in each request, and the server will map the session with the session ID and pull certain information from the database to perform authorization. The browser generally stores the session ID in cookies. As long as the session is active, a user can access the restricted resources, based on the authorities assigned.</p>
<p>This is a quite simple and easy mechanism for client-server interaction, and hence, it is still used by many web applications and services today. However, there are certain limitations to this model, as follows:</p>
<ul>
<li>Generally, the cookies are stateful, so the server needs to keep track of the session and check with the database (or in the memory) for every request. This may lead to overhead on the server. Additionally, the authorization process is closely associated with the application server, which results in a tightly coupled system.</li>
<li>For REST clients, like a native mobile app, cookies may not work properly.</li>
</ul>
<ul>
<li>If the application functionality is spread across multiple domains, additional configuration may be required to maintain the cookie value.</li>
<li>The cookie-based model has the limitation of granting third-party client access.</li>
</ul>
<p><strong>OAuth</strong> overcomes these restrictions. By definition, it is an authorization framework (or protocol, more precisely), allowing for the application to access resources within the same or different applications. In other words, <span>OAuth 2.0 allows limited access to protected resources to a third-party application, on behalf of a resource owner. It supports authorization flows for mobile, web, and desktop applications. </span>The current version of this protocol is OAuth 2.0. We will integrate OAuth 2.0 with Spring Security. </p>
<div class="packt_infobox">Even though OAuth has certain characteristics that are not available with a normal client-server mechanism with the session, the former cannot replace the latter. For example, a banking application must be implemented with a client-server mechanism. The comparison given here is to showcase how OAuth can be used to provide access to third-party applications.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">OAuth roles</h1>
                </header>
            
            <article>
                
<p>Before moving further, it is important that you understand certain terminologies used in OAuth. This will provide a profound understanding of its underlying concepts. They are referred to as OAuth roles, as follows:</p>
<ul>
<li><strong>Resource owner:</strong> A person or entity that can grant access to protected resources. The OAuth protocol is not limited to a person. An application to application interaction can happen with OAuth. If the resource owner is a person (or user), it is called an end user. </li>
<li><strong>Authorization server: </strong>As its name suggests, it is an entity that provides authorization, in the form of a token. After the resource owner is authenticated successfully, the authorization server will issue an access token to a client.</li>
<li><strong>Resource server: </strong>This is the server that holds the protected resources. When a request for a protected resource comes to the resource server, it will verify the access token with the authorization server and respond accordingly.</li>
<li><strong>Client: </strong>An entity that initiates the request to access the protected resource in support of a resource owner is called a <strong>client</strong>. It can be in any form, like a mobile application asking for credentials or a web-based application that provides an alternate login functionality with social media (like Facebook or Google).</li>
</ul>
<p>The relationships between these roles is illustrated in the following diagram:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/4449129b-3238-4c98-a1ce-eea5fec9ee78.png" style="width:28.42em;height:24.75em;"/></p>
<p>The end user, who is the <span class="packt_screen">Resource owner,</span> interacts with an application, which acts as a <span class="packt_screen">Client</span> here. The <span class="packt_screen">Client</span> will talk to the <span class="packt_screen">Authorization server</span>. The <span class="packt_screen">Resource owner</span> provides credentials, and it will be authenticated at the <span class="packt_screen">Authorization server</span> first. Upon successful identification, the <span class="packt_screen">Authorization server</span> issues an access token, which is used by the <span class="packt_screen">Client</span> to access the secure resources on the <span class="packt_screen">Resource server</span>, in support of the <span class="packt_screen">Resource owner</span>. <span>The </span><span class="packt_screen">Authorization server</span><span> is also known as an <strong>identity provider</strong>.</span></p>
<p>Let's look at the process of authorization in OAuth with a real-life scenario. Suppose that John has a car with <span>a smart </span>key. Nowadays, a vehicle with a smart key is common, wherein the vehicle cannot be operated (not even unlocked or started) without a smart key in your pocket. John has asked his friend Charles to pick him up from the airport. He already has already given him a smart key. Charles uses the smart key and starts the car.</p>
<p>In this analogy, the smart key gives Charles the authorization to operate John's car, as authorization involves the resources a user has access to, and what it can do with those resources. John, in this case, is the end user (<span class="packt_screen">Resource owner</span>), whereas Charles is a <span class="packt_screen">Client</span>. The smart key is an access token, whereas the car's security system can be considered an <span class="packt_screen">Authorization server</span> (or identity provider) who authorizes Charles (<span class="packt_screen">Client</span>) with a smart key (access token). The whole car is the <span class="packt_screen">Resource server</span> (Charles can use other features of the car, like the AC, music system, and so on, as he is authorized to use the car with the access token (smart key)).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Grant types</h1>
                </header>
            
            <article>
                
<p>The crux of the OAuth protocol is to provide access tokens for authorization. The way of retrieving the access token is called a <strong>grant</strong>. There are various ways (grants) to access and use the access token. OAuth 2.0 provides different grants for different scenarios, like the level of trust for the application, the type of the application, and so on.</p>
<p>OAuth 2.0 supports the following types of grants. <span>Selecting the one that best fits an application depends on the type of that application:</span></p>
<ul>
<li>Authorization code</li>
<li>Implicit</li>
<li>Resource Owner Password Credentials</li>
<li>Client Credentials</li>
</ul>
<p>Let's look at each of these grant types in detail: how they work, and into which situations they fit best.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Authorization code</h1>
                </header>
            
            <article>
                
<p>Being the most commonly and widely used, the authorization code grant is the best fit for server-side applications. The <strong>Client</strong> would be a web application. To make sure that the <strong>Client</strong> interacts with the <strong>Authorization Server</strong> properly, it is required to configure certain connection parameters, like the <em>Client ID</em> and <em>Client Secret, </em>with the <strong>Client</strong>. Since the <strong>Client</strong> is a web application, these parameters can be maintained secretly. </p>
<p>In this grant type, a <strong>Client</strong> must be able to collaborate with a <strong>User Agent (Browser)</strong>, because the authorization code is routed through the browser. The process of obtaining an access token for an authorization code grant can be described with the following diagram. Since the <strong>Resource Owner</strong> is authenticated at the <strong>Authorization Server</strong>, its credentials will not be shared with the <strong>Client</strong>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/ee105b78-23eb-48c0-a39d-4b34868c9461.png" style="width:37.67em;height:20.25em;"/></p>
<p>In this grant type, the access token is obtained through the following steps:</p>
<ol>
<li style="font-weight: 400">The <strong>Client</strong> is configured to establish a connection to the authorization server. It will open the link in the <strong>User Agent (Browser)</strong>. This link contains other information, which will be used by the authorization server to identify and respond back to the <strong>Client</strong>. Generally, the link opens in a separate window, and it contains a login form to authenticate a user as the first step towards authorization.</li>
<li style="font-weight: 400">A user (<strong>Resource Owner</strong>) then enters the credentials, in the form of a username and password.</li>
<li style="font-weight: 400">The browser (<strong>User Agent</strong>) then sends these credentials to the <strong>Authorization Server</strong>.</li>
<li>The <strong>Authorization Server</strong> verifies the credentials and sends the response back to the <strong>Client</strong> with the authorization code.</li>
<li>Upon receiving the authorization code, the <strong>Client</strong> will exchange it with the <strong>Authorization Server</strong> to get an access token, and optionally, a refresh token.</li>
<li>After getting an access token, the <strong>Client</strong> can talk to the <strong>Resource Server</strong> to get protected resources.</li>
</ol>
<div class="packt_infobox">The authorization code flow can be used with web and mobile app clients. Generally, web app clients use <em>Client ID</em> and <em>Client Secret,</em> while mobile app clients use the <strong>Proof Key for Code Exchange (PKCE)</strong> mechanism and utilize code challenges and code verifiers. </div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implicit</h1>
                </header>
            
            <article>
                
<p>The implicit grant type was designed specifically for single-page JavaScript applications running in the browser. It is most similar to the authorization code flow. The only difference is in the process of exchanging the authorization code. In the implicit grant type, a client will not receive an authorization code from the <strong>Authorization Server</strong>, in contrast with the authorization code grant type, due to security reasons.</p>
<p>Alternatively, once a <strong>User Agent</strong> successfully sends the credentials, the <strong>Authorization Server</strong> issues an access token directly to the <strong>Client</strong>. Since the implicit flow is targeted at single-page JavaScript applications, the refresh token is also not allowed. The whole process is described in the following diagram.</p>
<p>Since the <strong>Authorization Server</strong> directly issues an access token, the round-trip of the request-response between the <strong>Client</strong> and <strong>Authorization Server</strong> is reduced, as compare to the authorization code flow:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/9910f850-7806-4a80-9137-05a4462f6891.png" style="width:44.17em;height:22.00em;"/></p>
<p>This process happens in the following sequence:</p>
<ol>
<li style="font-weight: 400">The<span> </span><span class="packt_screen">Client</span> will open the link in a separate window in the <span class="packt_screen">User Agent</span> (browser), which contains a login form to authenticate a user as a first step towards authorization.</li>
<li style="font-weight: 400">A user (<span class="packt_screen">Resource Owner</span>) then enters the credentials, in the form of a username and password.</li>
<li style="font-weight: 400">The browser (<span class="packt_screen">User Agent</span>) then sends these credentials to the<span> </span><span class="packt_screen">Authorization Server</span>.</li>
<li>The<span> </span><span class="packt_screen">Authorization Server</span><span> </span>verifies the credentials and sends the access token directly to the <span class="packt_screen">Client</span>.</li>
<li>After getting the access token,<span> the </span><span class="packt_screen">Client</span><span> </span>can talk to the <span class="packt_screen">Resource Server</span> to get protected resources.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Resource Owner Password Credentials</h1>
                </header>
            
            <article>
                
<p>The Resource Owner Password Credentials grant type should be used for a highly trusted client, because it handles the user credentials directly. In other words, this grant type should only be used when there is plenty of certainty and faith between the <strong>Resource owner</strong> and the <strong>Client</strong>. Mostly, the client will be a first-party application. The credentials will be used by the <strong>Client</strong> directly, to interact with the <strong>Authorization Server</strong> and get an access token. The flow can be described with the following diagram:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/54da154e-3463-4a25-94b1-ca3c42307b4c.png" style="width:49.67em;height:22.33em;"/></p>
<p>This flow can be described as follows:</p>
<ol>
<li style="font-weight: 400">The<span> </span><strong>Client</strong> is highly trusted, so it will directly ask the <strong>Resource Owner</strong> to provide credentials. The <strong>Client</strong> could be a highly indulged application.</li>
<li style="font-weight: 400">The credentials will be sent by the <strong>Client</strong> to the <strong>Authorization Server</strong>. The <strong>Client</strong> will also send its own identity to the <strong>Authorization Server</strong>. In response, the <strong>Authorization Server</strong> will send back the access token, and optionally, a refresh token.</li>
<li style="font-weight: 400">The access token is used by the client to access the protected resources of the <strong>Resource Server</strong>.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Client Credentials</h1>
                </header>
            
            <article>
                
<p class="mce-root">The Client Credentials grant type is similar to the Resource Owner Password Credentials flow. In the Client Credentials grant, the <strong>Client</strong> interacts with the <strong>Authorization Server</strong>, provides the identification by sending the Client ID and Client Secrets, and gets the access token. Once the access token is received, the <strong>Client</strong> will interact with the <strong>Resource Server</strong>. In this case, a refresh token should not be used. The process flow is illustrated by the following diagram:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/c04d5470-6da0-402c-b287-ad9c20a87106.png" style="width:41.75em;height:14.92em;"/></p>
<ol>
<li style="font-weight: 400">The<span> Client ID and Client Secrets are configured with the </span><strong>Client</strong>. The <strong>Client</strong> will interact with the <strong>Authorization Server</strong> to get an access token. </li>
<li style="font-weight: 400">After getting the access token, the <strong>Client</strong> can interact with the <strong>Resource Server</strong> to access protected resources.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Which grant type should be used?</h1>
                </header>
            
            <article>
                
<p><span>Having seen the details about each grant type, it is important to understand the right grant type for a given application. There are various factors that play a vital role in grant type selection, like end user identification, the type of client (server-side, web-based, native, client-side), and the level of assurance between the client and resource owner.</span></p>
<p style="font-size: 16px">If we are planning to build an app and allow for the access of resources to other third-party apps, then the authorization code flow is the right choice. It is a highly recommended grant type for a publicly hosted application. On the other hand, if a client is JavaScript-based and runs in a browser, we should go with the implicit grant type for a third-party client, and the resource owner password credentials grant for a first-party client.</p>
<p>If a client is a native (mobile) application, we can select the resource owner password credentials grant type. If the resource owner does not need the identity of the end user and the client itself behaves like a resource owner, we should use the client credentials grant type. Typically, a client credentials<em> </em>grant is used where the machine (and not a user) needs the authorization to access protected resources, and user permission is not required.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Spring Security integration with OAuth</h1>
                </header>
            
            <article>
                
<p>Having seen the basic fundamentals of what OAuth 2.0 is and how it works, we will now look at the integration of OAuth in Spring Security. We will continue to work with the same application that we created for LDAP, and will make the necessary changes for OAuth integration.</p>
<p>For the OAuth demonstration, we will use<span> readily available </span>authorization providers. Spring Security supports <span>Google, Facebook, Okta, and GitHub providers o</span>ut of the box. Choosing one of them would only require certain configurations, and things would start to work. We will select Google as an authorization server (provider) to build OAuth for our application. The grant type that we will use in this integration is a<span>uthorization code.</span></p>
<p><span>Every authorization provider supports some sort of mechanism that enables the clients to establish a connection with the service. This process is known as <strong>application registration</strong>. </span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Application registration</h1>
                </header>
            
            <article>
                
<p><span>Let's register (or create) an application at Google, which provides connection access to use the authorization service. This is an essential step before start to implement OAuth. Google provides an <strong>API console</strong> to register an application. A valid Google account is required to access the API console. Go to <a href="https://console.developers.google.com/apis/credentials">https://console.developers.google.com/apis/credentials </a>and follow these steps:</span></p>
<ol>
<li>Click on the <span class="packt_screen">Create credentials</span> button in the <span class="packt_screen">Credentials</span> tab, and click on the <span class="packt_screen">OAuth client ID</span> option. Select the application type as <span class="packt_screen">Web Application</span>.</li>
<li>Give an appropriate name (like <kbd>SpringOAuthDemo</kbd>).</li>
<li>We need to set the authorized redirect URI in the Google console, which represents a path upon which users are redirected after they are successfully authorized by Google. The default implementation, provided by Spring Security for Google, has configured the redirect URI as <kbd>/login/oauth2/code/google</kbd>. Apparently, the valid redirect URI, in our case, would be <a href="http://localhost:8080/springuath/login/oauth2/code/google">http://localhost:8080/springuath/login/oauth2/code/google</a><span> (considering <kbd>8080</kbd> as the port and <kbd>springauth</kbd><em> </em>as the context name). Give this URI in <span class="packt_screen">Authorized redirectURIs</span> in the Google console, and click on the <span class="packt_screen">Create</span> button.</span></li>
</ol>
<p>Upon successful registration of the application, Google will create client credentials in the form of the <span class="packt_screen">client ID</span> and <span class="packt_screen">client secret</span>, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/6f5dc88c-7ffc-433d-b918-008d54e3e628.png" style="width:36.08em;height:25.58em;"/></p>
<p>The <span class="packt_screen">client ID</span> is a kind of public key used by the Google service API to identify the application that we have registered. It is also used to construct authorization URLs of the Google login form. The <span class="packt_screen">client secret</span>, as its name suggests, is a kind of private key. When the application (that we registered) requests the details of a user account, at the moment the user credentials are sent, the <span class="packt_screen">client secret</span> will be used to validate the identity of the application. Because of this, the <span class="packt_screen">client secret</span> must be kept private between the application and the client. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Changes in the Spring Boot application</h1>
                </header>
            
            <article>
                
<p>After completing the preceding requirements, we will start to make the necessary changes in the Spring Boot application that we created for LDAP authentication. The aim is to build a central authentication and authorization server that will work with both technologies (LDAP and OAuth). </p>
<p>When the user enters a plain username and password, the authentication and authorization will be done with LDAP. We will configure our application with Google, for OAuth. The very first step for OAuth integration is to declare the relevant starters. Spring Boot provides support for OAuth in the form of starters. Add the following starter entries in a <kbd>pom.xml</kbd> file:</p>
<pre>&lt;dependency&gt;<br/>  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br/>  &lt;artifactId&gt;spring-boot-starter-oauth2-client&lt;/artifactId&gt;<br/>&lt;/dependency&gt;</pre>
<p>Upon defining this starter, Spring Boot will add the following dependencies, which are essentials for OAuth integration, automatically:</p>
<pre>&lt;dependency&gt;<br/>  &lt;groupId&gt;org.springframework.security&lt;/groupId&gt;<br/>  &lt;artifactId&gt;spring-security-oauth2-client&lt;/artifactId&gt;<br/>&lt;/dependency&gt;<br/>&lt;dependency&gt;<br/>   &lt;groupId&gt;org.springframework.security&lt;/groupId&gt;<br/>   &lt;artifactId&gt;spring-security-oauth2-jose&lt;/artifactId&gt;<br/>&lt;/dependency&gt;<br/>&lt;dependency&gt;<br/>   &lt;groupId&gt;org.springframework.security&lt;/groupId&gt;<br/>   &lt;artifactId&gt;spring-security-oauth2-core&lt;/artifactId&gt;<br/>&lt;/dependency&gt;</pre>
<p>Next, we will add properties for the client ID and client secret, along with the provider and client name, in the <kbd>application.propeties</kbd> file. These properties are prefixed with <kbd>spring.security.oauth.client.registration</kbd>, along with the provider name and property name. Set these properties with the <kbd>Client ID</kbd> and <kbd>Client Secret</kbd> that we created in the Google developer console in the previous section, <span>as follows:</span></p>
<pre>spring.security.oauth2.client.registration.google.provider=google<br/>spring.security.oauth2.client.registration.google.client-name=Google<br/>spring.security.oauth2.client.registration.google.client-id=&lt;GOOGLE_CLIENT_ID&gt;<br/>spring.security.oauth2.client.registration.google.client-secret=&lt;GOOGLE_SECRET&gt;</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The default OAuth configuration</h1>
                </header>
            
            <article>
                
<p>Spring Security allows for configuring multiple OAuth clients. In addition to Google, Spring Security also supports default configurations for Facebook, GitHub, and Okta, out of the box. That means that all required classes and configurations are readily available, and we just need to define the client credentials (<kbd>Client ID</kbd> and <kbd>Client Secret</kbd>). Next, we will update the <kbd>configure(HttpSecurity http)</kbd> method of the <kbd>WebSecurityConfig</kbd> class, as follows:</p>
<pre>@Override<br/>  protected void configure(HttpSecurity http) throws Exception {<br/>     http.authorizeRequests()<br/>      .anyRequest().authenticated()<br/>      .and()<br/>        .oauth2Login();<br/>     super.configure(http);<br/>  }</pre>
<p>The <span class="packt_screen">oauth2Login()</span> method will initiate an OAuth call. At this moment, while executing the application, the preceding method will make an OAuth call to Google. A user will be asked for a valid Google login credential. Upon successful authentication, it will show the home page.</p>
<div class="packt_infobox"><span>If we set the properties for at least one client, Spring Security will automatically enable the </span><span><kbd>Oauth2ClientAutoConfiguration</kbd> class, which will make all of the necessary arrangements to enable OAuth login, without even defining the preceding <kbd>WebSecurityConfig</kbd> class.</span></div>
<p>If more than one client is configured in the <kbd>application.properties</kbd> file, the system will show a list of those clients, with a default login (username and password) form. It will be the autogenerated login page. We can perform a login with any of those configured clients.</p>
<p>It is quite obvious to show the name of the user at the top, to indicate which user is currently logged in. We can get the name of the user that has been authenticated at Google with the following code snippet:</p>
<pre>@ModelAttribute("currentUserName")<br/>public String getCurrentUserName() {<br/>  String name = "";<br/>  if(SecurityContextHolder.getContext().getAuthentication() !=null) {<br/>    if(SecurityContextHolder.getContext().getAuthentication() <br/>        instanceof OAuth2AuthenticationToken) {<br/>      OAuth2AuthenticationToken oauth2Authentication = <br/>          (OAuth2AuthenticationToken)SecurityContextHolder.getContext().getAuthentication();<br/>      name = (String)oauth2Authentication.getPrincipal().getAttributes().get("name");<br/>    }else {<br/>      String userName = SecurityContextHolder.getContext().getAuthentication().getName();<br/>      LdapAuthUser ldapUser = ldapAuthService.getUser(userName);<br/>      if(ldapUser !=null) {<br/>        name = ldapUser.getFirstName()+" "+ldapUser.getSurName();<br/>      }<br/>    }<br/>  }<br/>  return name;<br/>}</pre>
<p>This method is defined with <kbd>ModelAttribute</kbd>, meaning it can be directly used in the presentation layer with the <kbd>${currentUserName}</kbd> expression. We are getting an instance of <kbd>Authentication</kbd>, and checking if it is of the type <kbd>OAuth2AuthenticationToken</kbd>. The <kbd>getPrincipal()</kbd> method will return the user details, along with the attributes. The <kbd>name</kbd> attribute returns the name of the user that logged in with Google. </p>
<p>The other part will be executed when we perform authentication with LDAP, which gets the <kbd>userName</kbd> from the <kbd>Authentication</kbd> object, and then calls the custom service method (<kbd>ldapAuthService.getUser()</kbd>) to fetch the LDAP user object. It is then used to get the name of the user (the first name and surname).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">OAuth with a custom login page</h1>
                </header>
            
            <article>
                
<p>This is how OAuth can be integrated with Spring Security. In the preceding configuration, Spring Boot provides an autogenerated login page, which may suffice for testing purposes. In real scenarios, we may need a customized login page. To build a custom login page, we need to make certain configuration changes in the <kbd>configure(HttpSecurity http)</kbd><span> method, as follows:<br/></span></p>
<pre> http.authorizeRequests()<br/>  .antMatchers("/","/login").permitAll()<br/>  .antMatchers("/adminPage/").hasAnyAuthority("ADMIN")<br/>  .antMatchers("/userPage/").hasAnyAuthority("USER")<br/>  .anyRequest().fullyAuthenticated()<br/>    .and()<br/>  .oauth2Login().loginPage("/login")<br/>    .defaultSuccessUrl("/privatePage",true)<br/>    .failureUrl("/login?error=true")<br/>    .and()<br/>  .logout()<br/>    .permitAll().logoutSuccessUrl("/login?logout=true");</pre>
<p>This looks similar to what we configured for LDAP. The only change is that we are using <kbd>oauth2Login()</kbd> instead of <kbd>formLogin()</kbd>. The call for <kbd>super.configure(http)</kbd><em> </em>has been removed at the end, as it is no longer required. If we place it there, Spring Boot will show an autogenerated login page, so make sure to remove it at the end. </p>
<p>This change will show the custom login page, but the list of OAuth providers will not be visible automatically. We need to prepare the list manually, and show them in the login page. To achieve this, we will need to update the controller method, <kbd>showLoginPage()</kbd>, <span>as follows. This method basically shows the login page:</span></p>
<pre>@Autowired<br/>private ClientRegistrationRepository clientRegistrationRepository;<br/><br/>@GetMapping("/login")<br/>public String showLoginPage(@RequestParam(value = "error",required = false) String error,<br/>    @RequestParam(value = "logout", required = false) String logout,Model model) {<br/>  logger.info("This is login page URL ");<br/>  <br/>  if (error != null) {<br/>    model.addAttribute("error", "Invalid Credentials provided.");<br/>  }<br/><br/>  if (logout != null) {<br/>    model.addAttribute("message", "Logged out");<br/>  }<br/>  <br/>  String authorizationRequestBaseUri = "oauth2/authorization";<br/>  Map&lt;String, String&gt; oauth2AuthenticationUrls = new HashMap&lt;String, String&gt;();<br/>  <br/>  Iterable&lt;ClientRegistration&gt; clientRegistrations = (Iterable&lt;ClientRegistration&gt;)  clientRegistrationRepository;<br/>  <br/>  clientRegistrations.forEach(registration -&gt; <br/>  oauth2AuthenticationUrls.put(registration.getClientName(), <br/>      authorizationRequestBaseUri + "/" + registration.getRegistrationId()));<br/>  model.addAttribute("urls", oauth2AuthenticationUrls);<br/><br/>  setProcessingData(model, LdapAuthConstant.TITLE_LOGIN_PAGE);<br/>  <br/>  return "login";<br/>}</pre>
<p>This is the login method that we already created at the beginning of the chapter, in order to show the login form. The changes are made specifically for OAuth. First, the instance of <kbd>ClientRegistrationRepository</kbd> is injected, which represents the repository and stores the OAuth client's primary details. It is an interface type, and Spring Boot provides the instance of the <kbd>InMemoryClientRegistrationRepository</kbd> class as a default implementation. The <kbd>InMemoryClientRegistrationRepository</kbd> maintains a map for <kbd>ClientRegistration</kbd>, a class that represents the OAuth providers. </p>
<p>In the preceding code, we are getting the map of <kbd>ClientRegistration</kbd> from <kbd>clientRegistrationRepository</kbd>, iterating it, and preparing the list of OAuth providers with a name and authorization URL that is prefixed with <kbd>oauth2/authorization</kbd>. We set it as a model attribute, so that it will be available to the presentation layer. After applying these changes, the login page will look as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/8b464a88-ab49-4f0f-9a25-08e2fa631a07.png" style="width:17.50em;height:18.92em;"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Dual authentication with OAuth and LDAP</h1>
                </header>
            
            <article>
                
<p>The application will now show a custom login page, along with the list of OAuth clients that we configured. Still, when we enter the credentials manually in the login form, nothing will happen, because the Spring Security is configured for OAuth. The user, when entering credentials in a login form, should be authenticated with LDAP. <span>To achieve this, we need to perform certain configurations specifically within LDAP. </span></p>
<p><span>Here, the goal is to perform manual authentication with LDAP. Spring Security provides a way to define a custom authentication provider, by implementing the <kbd>AuthenticationProvider</kbd> interface. First, we will write a class that implements this interface and performs LDAP authentication, as follows:</span></p>
<pre>@Component<br/>public class CustomLdapAuthProvider implements AuthenticationProvider{<br/><br/>  @Autowired<br/>  LdapAuthService ldapAuthService;<br/><br/>  @Override<br/>  public Authentication authenticate(Authentication authentication) throws AuthenticationException {<br/>    String userName = authentication.getPrincipal().toString();<br/>    String password = authentication.getCredentials().toString();<br/><br/>    boolean isAuthenticate = ldapAuthService.authenticateLdapUserWithContext(userName, password);<br/><br/>    if(isAuthenticate == true) {<br/>      List&lt;LdapGranntedAuthority&gt; userRoles = ldapAuthService.getUserAuthorities(userName);<br/>      return new UsernamePasswordAuthenticationToken(<br/>          userName, password, userRoles);<br/>    }else {<br/>      return null;<br/>    }<br/>  }<br/><br/>  @Override<br/>  public boolean supports(Class&lt;?&gt; authentication) {<br/>    return authentication.equals(<br/>        UsernamePasswordAuthenticationToken.class);<br/>  }<br/>}</pre>
<p>The class <kbd>CustomLdapAuthProvider</kbd> is defined with the <kbd>@Component</kbd> annotation, meaning that Spring will configure it as a bean, so that it can be available to other components with the <kbd>@Autowired</kbd> annotation. The <kbd>AuthenticationProvider</kbd> interface declares the following two methods:</p>
<ul>
<li><kbd>Authentication authenticate(Authentication authentication)</kbd>: This is the place where we can provide custom authentication.</li>
<li><kbd>boolean supports(Class&lt;?&gt; authentication)</kbd>: This method indicates whether this custom authentication provider supports the indicated authenticated object.</li>
</ul>
<p>In the <kbd>authenticate</kbd> method, we are first getting the <kbd>username</kbd> and <kbd>password</kbd> from an instance of <kbd>Authentication</kbd>. Then, we are doing manual authentication by calling the custom service method <kbd>authenticateLdapUserWithContext</kbd>, which we already created for LDAP authentication. If this method returns <kbd>true</kbd>, it means that the credentials are valid.</p>
<p>Along with verifying the credentials, we also need to fetch the authorities (roles) that a user has. To get them, we have defined a method in the custom repository <kbd>impl</kbd> class (<kbd>LdapAuthRepositoryCustomImpl</kbd>), as follows:</p>
<pre>@Override<br/>public List&lt;LdapGranntedAuthority&gt; getUserAuthorities(String userName) {<br/>  AndFilter groupFilter = new AndFilter();<br/>  groupFilter.and(new EqualsFilter("objectclass","groupOfNames"));<br/>  groupFilter.and(new EqualsFilter("member","uid="+userName+",ou=users,o=packtPublisher"));<br/>  List&lt;LdapGranntedAuthority&gt; userRoleLst =  ldapTemplate.search(LdapQueryBuilder.query().<br/>                      filter(groupFilter),new LdapRoleMapper());<br/>  return userRoleLst;<br/>}</pre>
<p>The <kbd>getUserAuthorities</kbd> method takes the <kbd>userName</kbd> and returns the list of authorities. Let's recall that for roles, we have created a separate entity (<kbd>ou=roles</kbd>) in Apache DS. All of its children represent actual roles (with the attribute <kbd>cn</kbd> as the role name). Any LDAP user that is a member of a particular authority (role) is added with the <kbd>member</kbd> attribute. The aim is to fetch all the authorities of which the current user is a member. </p>
<p>The search method on <kbd>ldapTemplate</kbd> takes <kbd>LdapQuery</kbd> and the <kbd>ContextMapper</kbd> object and returns the list of authorities. The <kbd>LdapQuery</kbd> is built with a group filter of <kbd>objectclass</kbd> and value of member attribute. The value of <kbd>objectclass</kbd> is the same as the name of the <kbd>objectclass</kbd> that we gave to the entity (<kbd>ou=roles</kbd>) in LDAP. The value of the member attribute will be a valid user DN; for example, <kbd>uid=npatel</kbd>, <kbd>ou=users</kbd>, <kbd>o=packtPublisher</kbd>. The <kbd>ContextMapper</kbd> is a mechanism to retrieve only the required values from the <kbd>search</kbd> method. More specifically, <kbd>ContextMapper</kbd> can be used to retrieve custom results (wrap the selected value in custom POJO).</p>
<p>This can be done by providing the implementation for a <kbd>ContextMapper</kbd> interface. We have created a class for this implementation, as follows:</p>
<pre>public class LdapRoleMapper implements ContextMapper&lt;LdapGranntedAuthority&gt;{<br/><br/>  @Override<br/>  public LdapGranntedAuthority mapFromContext(Object ctx) throws NamingException {<br/>    DirContextAdapter adapter = (DirContextAdapter) ctx;<br/>    String role = adapter.getStringAttribute("cn");<br/>    LdapGranntedAuthority ldapGranntedAuthority = new LdapGranntedAuthority();<br/>    ldapGranntedAuthority.setAuthority(role);<br/>    return ldapGranntedAuthority;<br/>  }<br/>}</pre>
<p>The <kbd>ContextMapper</kbd> interface is a raw type, so we have defined the type as <kbd>LdapGranntedAuthority</kbd>, which is nothing but a custom POJO. In the <kbd>mapFromContext</kbd> method, the object of <kbd>DirContextAdapter</kbd> is used to fetch the name of the role with the attribute <kbd>cn</kbd>. This role name is then set in the instance of <kbd>LdapGranntedAuthority</kbd>, and finally, returns it. The <kbd>LdapGranntedAuthority</kbd> class looks as follows:</p>
<pre>public class LdapGranntedAuthority implements GrantedAuthority {<br/>  <br/>  String authority;<br/>  public void setAuthority(String authority) {<br/>    this.authority = authority;<br/>  }<br/>  @Override<br/>  public String getAuthority() {<br/>    return authority;<br/>  }<br/>}</pre>
<p>This POJO implements the <kbd>GrantedAuthority</kbd> interface to set the name of the authority (role). Now, let's go back to the authenticate method of the <kbd>CustomLdapAuthProvider</kbd> class. After getting the authorities, we are creating the object of the <kbd>UsernamePasswordAuthenticationToken</kbd> class with the username, password, and list of authorities. The <kbd>UsernamePasswordAuthenticationToken</kbd> class basically provides an implementation of the <kbd>Authentication</kbd> interface. </p>
<p>Next, with the help of this custom authentication provider, we will do manual authentication. Before that, we have to change the action of the login form, since the default (<kbd>/login</kbd>) will no longer work automatically. Change the path from <kbd>/login</kbd> to <kbd>/ldapLogin</kbd> in the login form. We also need to create a corresponding controller method to handle the login flow manually, as follows:</p>
<pre>@Autowired<br/>CustomLdapAuthProvider customLdapAuthProvider;<br/><br/>@PostMapping("/ldapLogin")<br/>public String ldapAuthenticate(HttpServletRequest req,@RequestParam(value = "username",required = true) String username,<br/>    @RequestParam(value = "password", required = true) String password,RedirectAttributes redirectAttributes) {<br/>  <br/>  UsernamePasswordAuthenticationToken authReq<br/>  = new UsernamePasswordAuthenticationToken(username, password);<br/>  Authentication auth = customLdapAuthProvider.authenticate(authReq);<br/>  if(auth !=null) {<br/>    logger.info(" If user is authenticated .... "+auth.isAuthenticated());<br/>    SecurityContext sc = SecurityContextHolder.getContext();<br/>    sc.setAuthentication(auth);<br/>    HttpSession session = req.getSession(true);<br/>    session.setAttribute(HttpSessionSecurityContextRepository.SPRING_SECURITY_CONTEXT_KEY, sc);<br/><br/>    if(auth.isAuthenticated() == true) {<br/>      return "redirect:/privatePage"; <br/>    }else {<br/>      redirectAttributes.addAttribute("error", "true");<br/>      return "redirect:/login";<br/>    }<br/>  }else { // failed authentication - either username or password fails.<br/>    redirectAttributes.addAttribute("error", "true");<br/>    return "redirect:/login";<br/>  }<br/>}</pre>
<p>The instance of <kbd>CustomLdapAuthProvider</kbd> is injected with the <kbd>@Autowired</kbd> annotation. This method is defined with the <kbd>@PostMapping</kbd> annotation, to handle the login form with the POST method. We are creating the instance of <kbd>UsernamePasswordAuthenticationToken</kbd> with the username and password that were submitted with the login form, and we pass it to the <kbd>authenticate</kbd> method of <kbd>CustomLdapAuthProvider</kbd>, which basically does authentication with LDAP and fetches the user authorities. Once the authentication is done, we will store the authentication object in the Spring Security context.</p>
<p>Finally, we have saved the security context in an HTTP session, so that Spring Security will create and maintain the user authentication information in the session. After performing all of these processes, we are checking whether the authentication is successful by calling the <kbd>isAuthenticated</kbd> method on the authentication object. Based on the authentication status (success or failure), we are redirecting the flow to either a private page (upon successful authentication) or a login page (upon failed authentication). This was all about using dual authentication with LDAP and OAuth. Next, we will illustrate OAuth implementation on a custom authorization server. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">OAuth authorization with a custom authorization server</h1>
                </header>
            
            <article>
                
<p>Now, you have seen OAuth integration with Spring using third-party providers (Google). In this section, we will build a custom authorization server (provider) and do OAuth authorization. We will also build our own resource server, and we'll access the resources once the authorization is done.</p>
<p>In the previous section, the authorization code grant type was used with Google. We will implement an implicit grant type in this section. Let's recall that the implicit grant type was specially designed for JavaScript applications. Since it runs in a browser, the authorization server directly sends the access token. There is no support for refresh tokens, for security purposes.</p>
<p>We will first develop a custom authorization server (provider) that will provide the access token. We can consider it in place of Google in the previous section, where we developed a client for authorization. For our custom authorization, we will set up a client with credentials (an ID and secret), which will be used to provide authorization (in the form of providing an access token).</p>
<div class="packt_infobox">We will create separate Spring Boot applications for the authorization and resource server, and we will need to run them simultaneously, in order to test the functionality. To avoid the port clashing (the default is 8080 for both applications), we need to explicitly set the port while running them. To do so, you need to give a different port with the property <kbd>server.port</kbd> in the <kbd>application.properties</kbd> file. </div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Authorization server configuration</h1>
                </header>
            
            <article>
                
<p>We will develop a separate Spring Boot application and apply the necessary configurations to use it as an authorization server. This is our custom authorization server. Create a Spring Boot application with the name <kbd>SpringCustomAuthorization</kbd><em> </em>and add the following component, which is basically an essential entry point to building a custom authorization server:</p>
<pre>@Configuration<br/>@EnableAuthorizationServer<br/>public class CustomAuthorizationConfig extends AuthorizationServerConfigurerAdapter{<br/>  <br/>  @Autowired<br/>    @Qualifier("authenticationManager")<br/>    private AuthenticationManager authenticationManager;<br/>  <br/>  @Autowired<br/>  PasswordEncoder encoder;<br/> <br/>    @Override<br/>    public void configure(ClientDetailsServiceConfigurer clients) <br/>      throws Exception {<br/>        clients.inMemory()<br/>          .withClient("c1")<br/>          .authorizedGrantTypes("implicit")<br/>          .scopes("read", "write", "trust")<br/>          .secret(encoder.encode("123"))<br/>          .redirectUris("http://localhost:8082/privatePage")<br/>          .resourceIds("oauth2-server");<br/>    }<br/>    <br/>    @Bean<br/>    public JwtAccessTokenConverter accessTokenConverter() {<br/>        JwtAccessTokenConverter converter = new JwtAccessTokenConverter();<br/>        converter.setSigningKey("123");<br/>        return converter;<br/>    }<br/>    <br/>    @Bean<br/>    public TokenStore tokenStore() {<br/>        return new JwtTokenStore(accessTokenConverter());<br/>    }<br/> <br/>    @Override<br/>    public void configure(<br/>      AuthorizationServerEndpointsConfigurer endpoints) <br/>      throws Exception {<br/>        endpoints<br/>          .authenticationManager(authenticationManager)<br/>          .tokenServices(tokenServices())<br/>          .tokenStore(tokenStore())<br/>          .accessTokenConverter(accessTokenConverter());<br/>    }<br/>    <br/>    @Bean("resourceServerTokenServices")<br/>    @Primary<br/>    public DefaultTokenServices tokenServices() {<br/>        DefaultTokenServices defaultTokenServices = new DefaultTokenServices();<br/>        defaultTokenServices.setTokenStore(tokenStore());<br/>        defaultTokenServices.setSupportRefreshToken(false);<br/>        defaultTokenServices.setAccessTokenValiditySeconds(120);<br/>        defaultTokenServices.setTokenEnhancer(accessTokenConverter());<br/>        return defaultTokenServices;<br/>    }<br/>}</pre>
<p>With the <kbd>@EnableAuthorizationServer</kbd> annotation, this class claims to present a configuration for the authorization server. In order to understand the concept in more detail, we will associate each step for configuring the custom authorization server with what we already did in the Google OAuth integration. The very first step in this configuration is to define a client, which basically talks to an authorization server to get an access token. </p>
<p>The <kbd>configure(ClientDetailsServiceConfigurer clients)</kbd> method is used to define a client with various metadata, like the client ID, grant type, scopes, secret, and redirection URI. The <kbd>resourceId</kbd> is used to make the pair with the resource server. We will configure the same <kbd>resourceId</kbd> while creating a resource server later in this chapter. The type of client that we have used here is in-memory, which is appropriate for developmental purposes.</p>
<p>Another type is JDBC, wherein the client details can be stored in the database. We can configure multiple clients in this method, and each can be separated with the <kbd>.and()</kbd> method call. The client is created within an authorization server. We can relate this to the client that we created in the Google developer console.</p>
<p>The <kbd>tokenStore()</kbd> method is used to construct an access token. Spring provides various mechanisms, like <kbd>InMemoryTokenStore</kbd>, <kbd>JdbcTokenStore</kbd>, <kbd>JwkTokenStore</kbd>, and <kbd>JwtTokenStore</kbd>, to create a token. Out of these, we have used <kbd>JwtTokenStore</kbd>. The <kbd>accessTokenConverter()</kbd> method is used to encode/decode the token with a signing key.</p>
<p>We need to use the same signing key while configuring the token store at the resource server. The <kbd>tokenServices()</kbd> method is used to configure the token service with the token store, along with a few settings. Since the grant type is implicit, the refresh token is not allowed, so we are setting <kbd>setSupportRefreshToken()</kbd> to <kbd>false</kbd>. We can also set how long the token is valid, through the <kbd>setAccessTokenValiditySeconds()</kbd> method. Since this is an implicit flow and will be used by a JavaScript application, the token should be short-lived, for security reasons.</p>
<p>Finally, the <kbd>configure(AuthorizationServerEndpointsConfigurer endpoints)</kbd> method is a glue point to group the things that we have configured so far together. Generally, user authentication is performed prior to authorization, and the object of <kbd>AuthenticationManager</kbd> is used to perform the authentication. After defining the authorization configuration, let's make it secure by applying security configurations, as follows:</p>
<pre>@Configuration<br/>@EnableWebSecurity<br/>public class WebSecurityConfig extends WebSecurityConfigurerAdapter {<br/><br/>    @Override<br/>    @Bean("authenticationManager")<br/>    public AuthenticationManager authenticationManagerBean() throws Exception {<br/>      AuthenticationManager authenticationManager = super.authenticationManagerBean(); <br/>      return authenticationManager;<br/>    }<br/>    <br/>    @Override<br/>  public void configure(WebSecurity web) throws Exception {<br/>    web.ignoring().antMatchers("/js/**");<br/>    web.ignoring().antMatchers("/css/**");<br/>  }<br/><br/>    @Override<br/>    protected void configure(AuthenticationManagerBuilder auth) <br/>      throws Exception {<br/>        auth.inMemoryAuthentication()<br/>          .withUser("john").password(new BCryptPasswordEncoder().encode("123")).authorities("USER");<br/>    }<br/><br/>    @Override<br/>    protected void configure(HttpSecurity http) throws Exception {<br/>       http<br/>         .authorizeRequests()<br/>         .antMatchers("/oauth/authorize","/").permitAll()<br/>         .and()<br/>         .formLogin().loginPage("/login").permitAll();<br/>    }<br/><br/>    @Bean("encoder")<br/>    public BCryptPasswordEncoder encoder(){<br/>        return new BCryptPasswordEncoder();<br/>    }<br/>   <br/>}</pre>
<p>With the <kbd>@EnableWebSecurity</kbd> annotation, Spring Security will be applied to the authorization server. It is a normal Spring Security configuration that you have already seen in previous sections. The <kbd>/oauth/authorize</kbd> is a default authorization endpoint. The resource server will initiate an authorization call on this path, so we have configured it in the <kbd>configure</kbd> method.</p>
<p>We have created an in-memory user with credentials and authority. We can associate it with the user account hold in Google, which is being asked when we initiate authorization with Google. In our case, we will provide this credential when the authorization process is initiated at the custom authorization server. </p>
<p>Our authorization server is now ready. It cannot be accessed directly; instead, the resource server initiates the request with certain parameters. Next, we will build the resource server.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Resource server configuration</h1>
                </header>
            
            <article>
                
<p>As its name suggests, a <strong>resource server</strong> holds resources (in the form of data, services, files, and so on), which can be accessed by the resource owner by providing valid authorization. The process of providing authorization happens in the form of a <strong>token sharing mechanism</strong>.</p>
<p>The authorization server creates a token after authentication, which is used by a resource server to serve the restricted resources. For all incoming requests for protected resources, the resource server will check the validity of the access token with the authorization server. This is the flow of the system, in brief. Now, we will create a resource server with a separate Spring Boot application.</p>
<p>Spring allows for creating a resource server by declaring certain essential configurations, as follows:</p>
<pre>@Configuration<br/>@EnableResourceServer<br/>public class ResourceServerConfig extends ResourceServerConfigurerAdapter {<br/><br/>private static final String RESOURCE_ID = "oauth2-server";<br/><br/>  @Override<br/>  public void configure(ResourceServerSecurityConfigurer resources) {<br/>    resources<br/>      .tokenStore(tokenStore())<br/>      .resourceId(RESOURCE_ID);<br/>  }<br/><br/>  @Override<br/>  public void configure(HttpSecurity http) throws Exception {<br/>        http<br/>            .authorizeRequests()<br/>            .antMatchers("/api/**").authenticated()<br/>            .and().exceptionHandling().accessDeniedHandler(new OAuth2AccessDeniedHandler());<br/>  }<br/><br/>  @Bean<br/>    public TokenStore tokenStore() {<br/>        return new JwtTokenStore(accessTokenConverter());<br/>    }<br/>  <br/>  @Bean<br/>    public JwtAccessTokenConverter accessTokenConverter() {<br/>        JwtAccessTokenConverter converter = new JwtAccessTokenConverter();<br/>        converter.setSigningKey("123");<br/>        return converter;<br/>    }<br/> <br/>}</pre>
<p>The <kbd>@EnableResourceServer</kbd> annotation will instruct Spring Security to treat the component as the resource server and to authenticate incoming requests with an access token. In this configuration, we are using the same <kbd>resourceId</kbd> that we used in the authorization server. Also, the process of creating and converting the token, along with the signing key, is the same as what we implemented in the authorization server.</p>
<div class="packt_infobox">For a token of the type <kbd>Jwt</kbd>, we can also use the public-private key as a signing key for generating an access token. In a normal case, the signing key declared <span>at the authorization and resource server</span> must be the same.</div>
<p>The <kbd>configure(HttpSecurity http)</kbd> method of this class is a place where we can configure the path of protected resources. In our case, we are configuring <kbd>/api/**</kbd>, meaning that any path that starts with <kbd>/api/</kbd> is considered secure. Without a valid token, the user cannot access that path. We also defined the appropriate denied handler to show an appropriate message, in the case of invalid tokens or insufficient privileges. Next, we will configure Spring Security for the resource server, as follows:</p>
<pre>@Configuration<br/>@EnableWebSecurity<br/>public class WebSecurityConfig extends WebSecurityConfigurerAdapter{<br/>      @Override<br/>      protected void configure(HttpSecurity http) throws Exception {<br/>         http<br/>           .authorizeRequests()<br/>           .antMatchers("/","/customAuth").permitAll()<br/>        .anyRequest().authenticated();<br/>      }<br/>  }</pre>
<p>This is a straightforward security configuration, where we have declared certain paths to be accessible by all. Next, we will create a Spring MVC controller, which will show the page from which we can initiate authorization, as follows:</p>
<pre>@Controller<br/>public class WebController {<br/><br/>  private Logger logger = LoggerFactory.getLogger(WebController.class);<br/>  <br/>  @GetMapping("/")<br/>  public String showHomePage(Model model) {<br/>    logger.info("This is show home page method ");<br/>    setProcessingData(model, "Home Page");<br/>    return "home";<br/>  }<br/>  <br/>  @GetMapping("/privatePage")<br/>  public String showControlPage(Model model) {<br/>    logger.info("This is privaet page ");<br/>      setProcessingData(model, "Private Page");<br/>      return "private-page";<br/>  }<br/>  <br/>  @GetMapping("/customAuth")<br/>  public String authorizeUser(Model model,@Value("${custom.auth.authorization-uri}") String authorizationUri,<br/>      @Value("${custom.auth.client-id}") String clientId,<br/>      @Value("${custom.auth.client-secret}") String clientSecret,<br/>      @Value("${custom.auth.grant-type}") String grantType,<br/>      @Value("${custom.auth.response-type}") String responseType) {<br/>      <br/>      UriComponentsBuilder uriBuilder = UriComponentsBuilder.fromHttpUrl(authorizationUri)<br/>                .queryParam("username", clientId)<br/>                .queryParam("password", clientSecret)<br/>                .queryParam("grant_type", grantType)<br/>                .queryParam("response_type", responseType)<br/>                .queryParam("client_id", clientId);<br/>      <br/>      return "redirect:"+uriBuilder.toUriString();<br/>  }<br/>}</pre>
<p>The first two methods show the home page and private page, respectively. We will show a link on the home page that will initiate the authorization process. This link will call the <kbd>authorizeUser()</kbd> method (with the link <kbd>/customAuth</kbd>). This method fetches the client metadata that is defined in the <kbd>application.properties</kbd> file, as follows:</p>
<pre>custom.auth.authorization-uri=http://localhost:8081/oauth/authorizee<br/>custom.auth.client-id=c1<br/>custom.auth.client-secret=123<br/>custom.auth.grant-type=implicit<br/>custom.auth.response-type=token</pre>
<p>In the <kbd>authorizeUser()</kbd> method, we are redirecting the flow to the authorization URI, along with the <kbd>client-id</kbd>, <kbd>client-secret</kbd>, <kbd>grant-type</kbd>, and <kbd>response-type</kbd> parameters. The <kbd>oauth/authorize</kbd> is a default authorization endpoint.</p>
<p>Let's recall that, while doing a client setup in the authorization server, we configured the <kbd>redirectUri</kbd> as <a href="http://localhost:8082/privatePage">http://localhost:8082/privatePage</a>, meaning that after authorization, the flow will go back to this URL, which ultimately shows a private page, along with the access token.</p>
<p>Once we get the token, we can start to consume the protected resources. We have defined the path <kbd>/api/**</kbd> as protected resources in the resource server configuration. So, let's create a REST controller, as follows, which will provide the resources. For demo purpose, we will return some sample data:</p>
<pre>@RestController<br/>@RequestMapping("/api")<br/>public class ServiceAPIController {<br/>  <br/>  private Logger logger = LoggerFactory.getLogger(ServiceAPIController.class);<br/><br/>  @RequestMapping("/currentUser")<br/>  public Principal getUser(Principal user) {<br/>    return user;<br/>  }<br/>  <br/>  @RequestMapping("/adminresource")<br/>  public String adminResource(Principal user) {<br/>    return "{\"id\":\"" + user.getName() + "\",\"content\":\"Hello World\"}";<br/>  }<br/>  <br/>  @RequestMapping(value="/usergreeting", method = RequestMethod.GET, produces = {MediaType.APPLICATION_JSON_VALUE})<br/>  public String userResource(Principal user) {<br/>    return "{\"id\":\"" + user.getName() + "\",\"content\":\"Hello World\"}";<br/>  }<br/>  <br/>  @RequestMapping(value = "/userlist", method = RequestMethod.GET)<br/>  public ResponseEntity&lt;List&lt;SampleUser&gt;&gt; listAllSampleUsers() {<br/>      logger.info("Listing all users...");<br/>      SampleUser s1 = new SampleUser();<br/>      SampleUser s2 = new SampleUser();<br/>      <br/>      s1.setFirstName("Nilang");<br/>      s1.setLastName("Patel");<br/>      <br/>      s2.setFirstName("Komal");<br/>      s2.setLastName("Patel");<br/>      <br/>      List&lt;SampleUser&gt; users = new ArrayList&lt;SampleUser&gt;();<br/>        <br/>      users.add(s1);<br/>      users.add(s2);<br/>      return new ResponseEntity&lt;List&lt;SampleUser&gt;&gt;(users, HttpStatus.OK);<br/>    }<br/>  <br/>}</pre>
<p>The REST controller is configured with path <kbd>/api</kbd>, meaning that all of its methods can be accessible with the valid authorization token. Now, it is time to run the application and test the flow. We will first run the resource server application (<a href="http://localhost:8082">http://localhost:8082</a>, assuming it is running on port <kbd>8082</kbd>). It will show a link, which will redirect the flow to the authorization server.</p>
<p>Soon after the flow reaches the authorization server, it prompts a login page. This is because an authorization server required a valid authentication before even starting authorization. This makes sense, because the authorization server will authorize the given user account, and for this, a user must be logged in. We will use the in-memory credentials that we created for the authorization server. </p>
<p>Soon after logging in, the authorization server shows an intermediate page and asks a user to either allows or denies. Based on that, a user can access the restricted resource on the resource server, as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/56135b7d-db6e-4b8f-a40d-26515f933566.png" style="width:26.67em;height:11.25em;"/></p>
<p>This is similar to when we created a client in the Google developer console and did authorization with it. At that time, first, we gave Google the credentials, and after authentication, it asked for the approval of access for the client. When we authorize the client, it will redirect to the private page of the resource server with an access token.</p>
<div class="packt_infobox">At this moment, the access token is returned with <kbd>#</kbd> character in the response. To access any protected resources, we need to append the access token with <kbd>?</kbd>, so that it will be supplied as a request parameter. Without this, the resource server will not allow for accessing any protected resources.</div>
<p>Now, we can access protected resources with the access token. The rest controller (with the path <kbd>/api</kbd>) will serve the resources. For example, the URL <a href="http://localhost:8082/api/usergreeting?access_token=%3Ctoken_string%3E">http://localhost:8082/api/usergreeting?access_token=&lt;token_string&gt;</a> will give the following output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/39988647-0eeb-4943-8c43-532f04a1dbaa.png" style="width:23.92em;height:3.92em;"/></p>
<p>It will show a <kbd>token expired</kbd> error if the request is made after the token validity is over. It will also throw an <kbd>invalid token</kbd> error if the original token is altered. Without supplying the token, it will show an error like, <kbd><span>Full authentication is required to access this resource</span></kbd><span>.</span><em><span> </span></em></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Method-level resource permissions</h1>
                </header>
            
            <article>
                
<p>Now, an authorized user can access all of the resources that we have configured. How good would it be if the resources could be accessed based on user roles? It would provide for more fine-grained control over the resources. This is possible by applying method-level configurations in Spring Security. For this, first, we need to define a class that represents method-level Spring Security configurations, as follows:</p>
<pre>@Configuration<br/>@EnableGlobalMethodSecurity(prePostEnabled = true,securedEnabled = true)<br/>public class MethodSecurityConfig extends GlobalMethodSecurityConfiguration {<br/><br/>  @Override<br/>  protected MethodSecurityExpressionHandler createExpressionHandler() {<br/>    return new OAuth2MethodSecurityExpressionHandler();<br/>  }<br/>}</pre>
<p>The <kbd>@EnableGlobalMethodSecurity</kbd> annotation is required to define authorization constraints at the method level. The base class, <kbd>GlobalMethodSecurityConfiguration</kbd>, provides a default implementation of method-level security configuration.</p>
<p>We have overridden the <kbd>createExpressionHandle</kbd> method to supply <kbd>OAuth2MethodSecurityExpressionHandler</kbd> instead of <kbd>DefaultMethodSecurityExpressionHandler</kbd>, which is provided out of the box. Spring Security uses an AOP proxy mechanism to apply method-level security configurations.</p>
<p>The <kbd>prePostEnabled</kbd> and <kbd>securedEnabled</kbd> options enable respective annotations at the method level, to define authorization rules. For example, <kbd>prePostEnabled</kbd> will allow for defining the Spring Security pre/post annotations <kbd>@PreAuthorize</kbd> and <kbd>@PostAuthorize</kbd>. These annotations allow for expression-based access control, meaning that we can use Spring <strong>EL (Expression Language)</strong> to describe the rule.</p>
<p>The <kbd>@PreAuthorize</kbd> will evaluate the expression before entering the method, while the <kbd>@PostAuthorize</kbd> will verify the expression after method execution has completed, and could alter the result. The <span><kbd>securedEnabled</kbd> option of <kbd>@EnableGlobalMethodSecurity</kbd> is used to define the <kbd>@Secured</kbd> annotation. With the <kbd>@Secuired</kbd> annotation, we can specify a list of roles on a method. Let's look at a few examples of this annotation, as follows:</span></p>
<pre>@Secured("ROLE_USER")<br/>public String getUserAccnt() {<br/>....<br/>}<br/>@Secured({ "ROLE_USER", "ROLE_ADMIN" })<br/>public String getCompanyPolicy() {<br/>....<br/>}</pre>
<p>The <kbd>getUserAccnt</kbd> method will be accessible by the user that has a role as <kbd>ROLE_USER</kbd>. The <kbd>getCompanyPolicy</kbd> method will be invoked by a user who has at least one role among <kbd>ROLE_USER</kbd> and <kbd>ROLE_ADMIN</kbd>. The <kbd>@Secuired</kbd> annotation does not allow for defining an expression with Spring EL. On the other hand, the <span><kbd>@PreAuthorize</kbd> and <kbd>@PostAuthorize</kbd> annotations allow for Spring EL to define the expression, meaning that we can define the more complex condition. Let's look at some examples of <kbd>@PreAuthorize</kbd>, as follows:</span></p>
<pre>@PreAuthorize("hasAuthority('ADMIN') and #oauth2.hasScope('read')")<br/>public String adminResource(Principal user) {<br/>  ...<br/>}<br/>@PreAuthorize("hasAuthority('USER') and #oauth2.hasScope('read') or (!#oauth2.isOAuth() and hasAuthority('USER'))")<br/>public String userResource(Principal user) {<br/>  ...<br/>}<br/>@PreAuthorize("hasAuthority('ADMIN') or #oauth2.hasScope('trust') or (!#oauth2.isOAuth() and hasAuthority('ADMIN'))")<br/>public ResponseEntity&lt;List&lt;SampleUser&gt;&gt; listAllSampleUsers() {<br/>  ...<br/>}</pre>
<p>The first method (<kbd>adminResource</kbd>) is accessible for the user with a <kbd>USER</kbd> role, and the client should have a <kbd>read</kbd> scope. Let's recall that for the client that we configured in the authorization server, we set three scopes: read, write, and trust. The <kbd>#oauth2</kbd> variable is provided out of the box, and is used to check the various scopes that a client has. We can utilize other methods on the <kbd>#oauth2</kbd> variable, like <kbd>clientHasRole()</kbd>, <kbd>clientHasAnyRole()</kbd>, <kbd>hasAnyScope()</kbd>, <kbd>isOAuth()</kbd>, <kbd>isUser()</kbd>, <kbd>isClient()</kbd>, and so on. They are defined in the class <kbd>OAuth2SecurityExpressionMethods</kbd>. In short, the variable <kbd>#oauth2</kbd> represents the object of this class.</p>
<p>The second method (<kbd>userResource</kbd>) is a bit more complex, and can be accessed under the following conditions:</p>
<ul>
<li>A user has a <kbd>USER</kbd> role and a client has a <kbd>read</kbd> scope</li>
<li>A request is not of the OAuth type (it may be raised by a machine client) and a user has a <kbd>USER</kbd> role</li>
</ul>
<p>The third method (<kbd>listAllSampleUsers</kbd>) is similar to the second method, and can be accessed in the following situations:</p>
<ul>
<li>A user has an <kbd>ADMIN</kbd> role</li>
<li>A client has a <kbd>trust</kbd> scope</li>
<li>A request is not of the OAuth type (it may be raised by a machine client) and a user has an <kbd>ADMIN</kbd> role</li>
</ul>
<p>This is how the implicit grant type can be implemented with the custom authorization server. There are certain things that require attention while using the implicit grant type. Since it was designed for JavaScript applications, both the authorization and resource server should be securely accessible (with HTTPS). The second thing is, in an implicit grant type, the access token is directly returned by the authorization server to the browser, instead of at a trusted backend; it is highly recommended to configure short-lived access tokens, to mitigate the risk of the access token being leaked. </p>
<p>Another challenge in the implicit flow is that it does not allow refresh tokens. That means that after the short-lived token has expired, a user should be prompt to initiate the flow again; or, a better method might be to set a mechanism, like <kbd>iframe</kbd>, to get the new token without interruption. </p>
<p>As an exercise, you could create a few more users with different roles in the authorization server, and configure the resource methods with those roles, checking how they are accessible.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>Security is an essential part of any system. How effective it is depends on various aspects, like simplicity, feature richness, ease of integration with other systems, flexibility, robustness, and so on. This whole chapter was based on Spring Security. It is a fully-fledged framework that's used to secure J2EE-based applications. </p>
<p>In this chapter, we explored Spring Security more closely, especially how it can be integrated with LDAP and OAuth. We started with the basics of LDAP, including its data structure and setup; we created the structure in Apache DS, which is an LDAP server. Then, we explored the required configurations with Spring Security, to integrate it with LDAP. </p>
<p>Along with authentication with LDAP, we explored how to manage users in LDAP from a Spring application. We used the Spring Data framework to achieve this. Next, we created a structure for the role (authority) in LDAP. In the same sequence, we fetched the role details and implemented authorization in Spring Security with LDAP.</p>
<p>Later in the chapter, we started to cover another mechanism, called OAuth. It is an open standard for token-based authorization. We began with the basics of OAuth roles, then explored details about various grant types; you also learned which grant should be used when. Going further, we started on Spring Security integration with OAuth. We used Google to implement the authorization code flow with Spring Security.</p>
<p>With the default OAuth implementation, Spring Security shows the autogenerated login page. We showed how to implement a custom login page in OAuth. Up to that point, you had only seen the two different mechanisms, LDAP and OAuth, independently. We integrated both of them together, creating dual authentication. </p>
<p>We then implemented OAuth with the authorization code flow. Next, we showed how to implement the implicit flow with custom authorization and the resource server. We performed a set of configurations for both the authorization and resource server, and we successfully implemented an implicit flow. Towards the end, we applied method-level authorization in Spring Security.</p>
<p>In next chapter, we will explore another tool, called JHipster. It is an open source application generator framework that's mainly used to develop web applications and microservices with responsive web fronts (Angular or React) and the Spring framework as a backend.</p>


            </article>

            
        </section>
    </body></html>