- en: Chapter 9. Java EE MVC Framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '|   | *"Compared even to the development of the phone or TV, the Web developed
    very quickly."* |   |'
  prefs: []
  type: TYPE_TB
- en: '|   | --*Sir Tim Berners-Lee, inventor of the World Wide Web* |'
  prefs: []
  type: TYPE_TB
- en: In the past couple of chapters, we reviewed the web application service from
    the perspective of the client side. For this last chapter, we will return to the
    digital application written mainly on the server-side. We will examine a brand
    new specification under the Java EE umbrella. It is called **Model-View-Controller**
    (**MVC**) and falls under the Java EE 8 release (March 2017) with JSR 371 ([https://jcp.org/en/jsr/detail?id=371](https://jcp.org/en/jsr/detail?id=371)).
    At the time of writing this book, there was already an Early Draft Release of
    Java EE MVC that demonstrates the working of the reference implementation called
    Ozark ([https://ozark.java.net/index.html](https://ozark.java.net/index.html)).
  prefs: []
  type: TYPE_NORMAL
- en: 'The MVC framework is based on a design pattern that was invented in the Smalltalk
    programming language and environment, which was particularly common in the early
    user interface applications. The idea is that the Model refers to the component
    that stores the application data such as a value object or data transfer objects.
    The View is the component that renders or is responsible for the delivery of a
    representation of the application''s data to the user and the Controller is the
    component that contains the logic to process the input and output between the
    two former components: the View and Model. The design pattern is extremely popular
    because it embraces the separation of concerns, which is a key concept in a good
    pragmatic object-oriented design.'
  prefs: []
  type: TYPE_NORMAL
- en: In 2014, Oracle issued a public open survey to the wider Java EE community and
    collected the results ([https://java.net/downloads/javaee-spec/JavaEE8_Community_Survey_Results.pdf](https://java.net/downloads/javaee-spec/JavaEE8_Community_Survey_Results.pdf)).
    Thousands of technologists responded to this survey. One key question in the survey
    was, *Should Java EE provide support for MVC, along with JSF?* The correspondence
    was 60.8 percent in favor with a yes vote, 20 percent with a no vote, and 19.2
    percent were unsure. This was enough to sanction the MVC 1.0 specification to
    be a part of Java EE 8.
  prefs: []
  type: TYPE_NORMAL
- en: Java EE 8 MVC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we continue on to the programming, I should warn you that the information
    here is subject to change, because MVC is evolving right in front of our eyes.
    As an avid reader, you should certainly verify, at least, that the API is with
    the current or final specification.
  prefs: []
  type: TYPE_NORMAL
- en: With all this said, the MVC framework certainly—even at this early stage—will
    be a leading specification for the future digital web development framework for
    many years to come, and not just because it is now officially part of the Java
    EE umbrella drivetrain. MVC leverages the JAX-RS (Java for RESTful Services) API
    and currently integrates with the other Java EE technologies including CDI and
    Bean Validation.
  prefs: []
  type: TYPE_NORMAL
- en: The expert group made the decision to layer on top of JAX-RS rather than the
    older Java servlet API, because JAX-RS fits the modern programming practice to
    use full semantics of the HTTP mapping capabilities. They also felt that adopting
    servlet would expose the developer to the lower-level programming interfaces that
    are already duplicated in the JAX-RS specification.
  prefs: []
  type: TYPE_NORMAL
- en: From a digital developer's and modern web practices' points of view, the layering
    of MVC on top of JAX-RS is really a good adoption. The servlet specification has
    been criticized severely by the likes of the Play framework and others as being
    a wide and thick Context Map abstraction (Eric Evans' Domain-Driven Design) and
    a blocker to the natural design of the web and HTTP utilization.
  prefs: []
  type: TYPE_NORMAL
- en: We will be working with the Java EE 8 MVC reference implementation called Ozark.
    At the time of writing, Ozark is still a work in progress. However, the milestone
    release contains the essential components and interfaces of the MVC applications.
  prefs: []
  type: TYPE_NORMAL
- en: MVC controllers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There is a new package structure reserved for MVC under `javax.mvc`. The `@javac.mvc.Controller`
    annotation declares a class type or method as a controller component. Here is
    an example of its use in a method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This controller method is missing the HTTP semantics and this is where the JAX-RS
    annotations help. It is also useless from an MVC perspective because there are
    associations with either a Model or View component.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, first let''s turn the method into a proper RESTful resource, starting with
    the model object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The User component serves as our Model component. It has one property: the
    name of the person whom we are greeting politely. We can, therefore, write an
    MVC resource endpoint and inject this model instance into it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the initial version of our controller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We will annotate a JAX RS `@Path` element to our `AlienGreetings` class in order
    to declare that it is a resource endpoint. Although our type is defined as an
    EJB stateless session bean, MVC is expected to work with the CDI scopes such as
    `@ApplicationScoped` and `@SessionScoped`. The reference implementation is changing
    as I write this.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will annotate the `simple1()` method as an MVC `@Controller` annotation.
    This method accepts one argument name as `@QueryParam`. We will add the other
    JAX-RS annotations in order to define the HTTP method protocol `@GET`, relative
    URI `@Path`, and MIME content type `@Produces`. The method sets the name property
    in the `User` instance and returns a reference string, which is the name of the
    view: `/hello.jsp`.'
  prefs: []
  type: TYPE_NORMAL
- en: An MVC controller method can return a string, which means that the servlet container
    takes over the rendering of the final view. However, MVC can also render different
    views due to an extendible implementation. We will see more on this later. Behind
    the scenes, MVC converts the string to a view type. The Java interface `javax.mvc.Viewable`
    represents the abstraction of a view technology. The Viewable is an association
    between `javax.mvc.ViewEngine` and `javax.mvc.Models`.
  prefs: []
  type: TYPE_NORMAL
- en: The abstract class type `javax.mvc.Engine` has the responsibility to render
    a model to a technology choice. Engineers can develop or add this engine to render
    the views. At the moment, Ozark supports many rendering styles, from Apache Velocity
    to AsciiDoc.
  prefs: []
  type: TYPE_NORMAL
- en: The Java interface `javax.mvc.Models` represents a key value store that is passed
    from the view to the rendering engine. The model's type is a request-scoped map
    collection.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s extend the `AlienGreeting` controller with a few more methods. The
    following `simple2()` method returns a `Viewable` instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the `simple2()` method is a variation on `simple1()`, and MVC
    is rather flexible. It even supports the void methods that do not return types.
    We will annotate the subsequent `simple3()` method with `@javax.mvc.View` in order
    to declare the next view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: All of the three methods are HTTP GET requests so far. As MVC is layered on
    top of JAX-RS, we can utilize other protocol methods too. It is straightforward
    to write an HTML form handler that handles an HTTP POST request.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the code extract for the `helloWebForm()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The preceding controller method, `helloWebForm()`, accepts an HTML form named
    parameter. It sets the model object and returns a view instance. In the HTML5
    standard, the form element officially supports the HTTP GET and POST requests.
    The popular web browsers tend to have access only to the HTTP PUT and DELETE protocol
    requests through JavaScript. This limitation does not, however, prevent the MVC
    controllers being annotated with `@PUT` or `@DELETE`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The MVC controllers have access to a full gamut of the URI space that is available
    to the JAX-RS endpoints. The following example illustrates the path parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The preceding controller method, `helloWebPath()`, accepts a path parameter
    as the user's name. The `@PathParam` annotation establishes the parameter token
    used in the relative URI. The URI is defined by the `@Path` annotation. The full
    URL will be `http://localhost:8080/javaee-basic-mvc/rest/hello/view/Curtis`.
  prefs: []
  type: TYPE_NORMAL
- en: MVC page views and templates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Under the MVC specification, a `view` instance can be treated as a templating
    technology reference. We have seen only JavaServer Page views up until now. A
    view can be anything that a developer can imagine, as long as there is a corresponding
    `ViewEngine` instance that knows exactly how to process (render) a view from the
    associated model and the other results from a controller.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the first basic JSP view, `index.jsp`, in the sample source
    code project from this book (`ch09/basic-javaee-mvc`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In this JSP view, we will take advantage of an EL to generate a URL with the
    context path for the web application, namely `pageContext.request.contextPath`.
    There are three HTML anchor elements that invoke the `AlienGreeting` controller
    methods: `simple1()`, `simple2()`, and `simple3()`. The HTML form invokes the
    `helloWebForm()` method.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The page extract JSP view called `hello.jsp` looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The view template is very straightforward; we will use the request-scoped user
    instance to supply the name.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the time of writing this, Ozark supported the following view rendition technologies
    in the beta reference implementation, as shown in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Template name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| AsciiDoc | This a text document format to write notes, documents, articles,
    books, e-books, slideshows, man pages, and blogs.[https://github.com/asciidoctor/asciidoctorj](https://github.com/asciidoctor/asciidoctorj)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Freemarker | This is a Java template engine that generates HTML, RTF, and
    source code.[http://freemarker.org/](http://freemarker.org/) |'
  prefs: []
  type: TYPE_TB
- en: '| Handlebars | This is a multiple language and platform extension to the original
    Mustache templating specification with helpful utilities tokens.JavaScript version:
    [http://handlebarsjs.com/](http://handlebarsjs.com/) and Java port: [https://github.com/jknack/handlebars.java/](https://github.com/jknack/handlebars.java/)
    |'
  prefs: []
  type: TYPE_TB
- en: '| JSR 223 | This is an extension of the MVC framework that supports JSR 223
    for a dynamic scripting language such as Groovy and Jython.[https://www.jcp.org/en/jsr/detail?id=223](https://www.jcp.org/en/jsr/detail?id=223)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Mustache | This is a simple web template language that separates the presentation
    from the business view logic. It is available on multiple platforms and languages.[https://github.com/spullara/mustache.java](https://github.com/spullara/mustache.java)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Thymeleaf | This is a Java-based HTML5 template library that works in the
    web and non-web environments. It is associated strongly with the string framework.[http://www.thymeleaf.org/](http://www.thymeleaf.org/)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Velocity | Apache Velocity is a suite of the templating tools. The Velocity
    engine is the component library that provides templating. It was one of the first
    web template frameworks that was written for server-side Java.[http://velocity.apache.org/](http://velocity.apache.org/)
    |'
  prefs: []
  type: TYPE_TB
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: MVC is a server-side template solution. Don't confuse the world of client-side
    templating with the backend variety.
  prefs: []
  type: TYPE_NORMAL
- en: MVC models
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The MVC specification supports two forms of models. The first is based on the
    `javax.mvc.Models` instance and the second form leverages the CDI `@Named` beans.
    The `Models` interface types map the key names to the values in a map collection.
    All the view engines must mandatorily support `Models`. A view engine may optionally
    support CDI. The specification recommends that the view engine implementers provide
    the CDI beans support.
  prefs: []
  type: TYPE_NORMAL
- en: 'The default implementation of the `Models` interface is a request-scoped bean:
    `com.oracle.ozark.core.ModelsImpl`. This class delegates to a `java.util.Map`
    collection. Developers normally never instantiate this type but prefer to inject
    the `Models` type. As you will see later, it is sometimes necessary to create
    an instance for a particular view engine.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s demonstrate the practical use of the `Models` interface in a second
    version of our controller class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In `PhobosGreetings`, we will replace the CDI injection of the `User` type with
    a `Models` instance. We will create a `User` instance and store this under the
    property key, `user`. After the method returns, the framework will retrieve all
    of the properties in the `Models` instance and place them in the attributes collection
    of `HttpServlerResponse`. Therefore, a JSP template view has access to the data
    through an EL or inline scripting.
  prefs: []
  type: TYPE_NORMAL
- en: Response and redirects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: MVC also supports the controller that returns an instance of the JAX RS Response
    type. This is especially useful to the sites that shove the Grunt work of rendering
    to the client side. A highly scalable web application may choose to send the megabytes
    of a JSON response rather than render on the server through a template.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will now inspect another MVC controller called `RedirectController`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We will annotate `RedirectController` with JAX-RS `@Path` and we must pay particular
    attention to the base value, `redirect`.
  prefs: []
  type: TYPE_NORMAL
- en: The `getString()` method performs a URI redirection using the special prefix
    operator, redirect. This method has a unique relative URI of `redirect/string`.
    MVC detects the prefix internally and builds a JAX-RS Response as a redirect request.
    The URI that is returned is a reference to the `getRedirectedView()` controller,
    which has a relative path URI of `redirect/here`.
  prefs: []
  type: TYPE_NORMAL
- en: We can directly build the response ourselves as seen in the `getResponse()`
    method. Invoking the static `Response.seeOther()` method with a URI is the equivalent
    of achieving an HTTP redirect response. This method has its own unique relative
    URI of `redirect/response1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `getRedirectedView()` method simply navigates to the view template, `redirected.jsp`.
    This controller method is the eventual target of the other controller methods:
    `getString()` and `getResponse()`.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At the time of writing this, the MVC specification was designing the HTTP redirect
    approach. There was a question about providing a Flash scope or an equivalent
    of a JSF View scope bean for the MVC applications in order to save the data among
    the multiple request scopes. I strongly recommend you to check for updates on
    the specification.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, an MVC controller can also return HTTP error responses. The `getErrorResponse()`
    method has a relative URI of `redirect/deliberateError1` and returns a Response
    instance with an HTTP Bad Request error code (401). The controller also informs
    the MVC framework to serve the view template under the view ID `error.jsp`. `RedirectController`
    represents the simplest form of an MVC controller. We can enrich it with the injection
    of `Models` or other CDI beans. We can also use the Viewable instances instead
    of the dumb strings as entities in a Response builder.
  prefs: []
  type: TYPE_NORMAL
- en: Let's move on to the different templating technologies, and this is the unique
    selling point of MVC so far.
  prefs: []
  type: TYPE_NORMAL
- en: Reconfiguring the view root
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the working MVC early draft release, the view root is set by default to `WEB-INF/views`.
    Programmatically, this is found in the static property of `ViewEngine.DEFAULT_VIEW_ENGINE`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This may be inconvenient for the digital engineers with relative URI, especially
    in the redirection of the page views. Luckily, the Ozark implementation can be
    reconfigured from the web XML descriptor (`web.xml`), as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We will override the `javax.mvc.engine.ViewEngine.viewFolder` property in the
    web page root in order to achieve the behavior that we want.
  prefs: []
  type: TYPE_NORMAL
- en: Handlebars Java
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Handlebars framework is a templating library for a developing web application.
    In its JavaScript incantation ([http://handlebarsjs.com/](http://handlebarsjs.com/)),
    you might already have heard the digital interface developers raving about it.
    We will use the Handlebars Java port for the rest of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The Handlebars framework permits the developers along with designers to write
    semantic templates. It is based on a slightly older templating framework called
    Mustache ([https://mustache.github.io/](https://mustache.github.io/)). Both of
    these refer to the masculine facial hair that can be seen if you squint your eyes
    and look at a curly bracket rotated by 90 degrees.
  prefs: []
  type: TYPE_NORMAL
- en: Templating frameworks drive home the separation of concerns and reduction of
    mixing the business logic in the rendered page view as much as possible. The Handlebars
    framework borrows the double curly bracket notation from Mustache. For our masculine
    readers, this is a deliberate play on words and an idiosyncrasy of computer programming.
    The Handlebars framework has a clear advantage of leveraging the same template
    engine on the server side that also works on the client side.
  prefs: []
  type: TYPE_NORMAL
- en: A compiled-inline template servlet
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will start with a servlet example as an introduction. We will create a Java
    servlet with just one dependency, which is the Handlebars Java implementation.
    We are not considering the MVC framework just yet. Our servlet will instantiate
    the templating framework, invoke an inline template script, and then return the
    output as a straightforward direct response.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is our servlet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The `CompileInlineServlet` class illustrates how to compile a basic Handlers
    template example in the Java code. We will instantiate a Handlebars engine template
    and then compile the template inline, as shown in the following text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'After compilation, we will obtain a `Template` instance that contains the content.
    We will then call the `apply()` method with a simple string and this will serve
    as the context for the template. The `{{this}}` placeholder refers to the context
    object. We will then retrieve the text representation and send the response back
    to the web browser. We will see the following plain text output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: There are no dependencies in Handlebars Java that tie the framework to Java
    EE. Therefore, it can also be used in Java SE as a standalone Java executable.
  prefs: []
  type: TYPE_NORMAL
- en: Template expressions in Handlebars
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here is another example of a Handlebars template with a different context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The template renders in a DIV layer with a token name substitution with an embedded
    expression. An expression is reserved and activated between the double curly brackets.
    It renders an output for the domain of the trading system. In both Handlebars
    and Mustache notation, the double curly bracket surrounding a variable name denotes
    a placeholder entry. A placeholder entry in a template means that it can be replaced
    with a dynamic content. Therefore, during the template rendering process, the
    `{{title}}` placeholder is replaced with the trade entry headline and the `{{detail}}`
    is replaced with the trade detail. The expression value may be literal strings
    or they could be an embedded HTML5 markup.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s write another Java servlet that renders this view using the Handlebars
    framework:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This `TradeInfoServlet` servlet is almost the same as the previous one, `CompileInlineServlet`;
    but this time, we will utilize the `ServletContextTemplateLoader` class. This
    is a loader class that retrieves the view templates from the Java EE web context
    via the servlet engine. We will create the loader and pass this as an argument
    during the construction of a Handlebar instance. We will then compile a template
    using a reference name, trade. The framework invokes the loader to retrieve the
    view template, which by default is suffixed as `trade.hbs`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We built a literal map collection of the keys and values. They will serve as
    our collection of placeholders in the view, and we will apply them to the template.
    Navigating to the web browser with `http://localhost:8080/handlebars-javaee-mvc-1.0-SNAPSHOT/tradeinfo`
    should display the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Template expressions in Handlebars](img/image00425.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Screenshot of the TradeInfoServlet
  prefs: []
  type: TYPE_NORMAL
- en: In addition to straightforward replacements, Handlebars supports the `Block`,
    `Partials`, and `Helper` expressions. The Handlebars framework provides the standard
    building blocks; however, engineers can register custom helpers. In the JavaScript
    implementation, developers usually define the compiled script templates in the
    page in order to reuse the content. `Handlebars.js` tends to be used with one
    or the other JavaScript framework such as RequireJS or EmberJS in order to deliver
    reusable content.
  prefs: []
  type: TYPE_NORMAL
- en: We will proceed to write a CRUD example with Handlebars Java. Our application
    will allow the user to manipulate a basic product catalog. We will need a welcome
    page, so let's create it with the template framework.
  prefs: []
  type: TYPE_NORMAL
- en: The welcome controller
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the Java port, we do not have to register or compile the templates because
    the page content is delivered from the server side. The project for this is called
    `handlebars-javaee-mvc`. The first thing to do is cause an HTTP redirect in an
    initial JSP, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code will immediately redirect the web browser to send an HTTP
    GET request to the URI, `handler-javeee-mvc-1.0/rest/welcome`. In this URI path,
    we already have an MVC controller waiting for this invocation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: After populating a couple properties in the model instance, the `WelcomeController`
    progresses the response to the Handlebars Java template `/welcomee.hbs`. The absolute
    URI with the forward slash character ensures that the MVC framework searches for
    the page template from the web context root. The suffix extension `*.hbs` is generally
    reserved for the Handlebars view templates in both the client and server editions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the following Handlebars template (`welcome.hbs`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Handlebars support the concept of Partials. A partial is a template that is
    used in another template. They are extremely useful for page composition. The
    syntax begins with `{{> NAME }}`, where `NAME` refers to another template. In
    a JavaScript stack, the partials must be registered beforehand; however, the Java
    port knows how to find the partial template by loading them from the servlet container.
    Therefore, the partial template reference, `{{> header }}`, instructs Handlebars
    to load the `header.hbs` view.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are four partial templates in the `welcome.hbs` view: `header.hbs`, `navbar.hbs`,
    `footer.hbs`, and `bottom.hbs`. You can examine the source code for these templates
    in this book''s code distribution.'
  prefs: []
  type: TYPE_NORMAL
- en: The custom view engine
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Handlebars Java ships with several template view engines. The default extension
    view engine, unfortunately, does not provide all of the features that we would
    like to use. For one, Handlebars does not render the decimal numbers readily,
    and so, we must register our own function. Luckily, it is reasonable to write
    a view engine extension with CDI, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We will annotate our `MyHandlebarsViewEngine` class as an application-scoped
    bean and also ensure that it subclasses `ViewEngineBase` from Ozark. We will inject
    `ServletContext` into this class because we need to retrieve certain properties
    from it such as the web context path.
  prefs: []
  type: TYPE_NORMAL
- en: We will override the `supports()` method so as to establish the support for
    the Handlebars files. The MVC View type is passed as a single argument.
  prefs: []
  type: TYPE_NORMAL
- en: The real work happens in the `processView()` method, and we are totally responsible
    for rendering the Handlebars View template. The MVC framework supplies `javax.mvc.engine.ViewEngineContext`,
    which provides access to the current `View` and `Models` instances. We can establish
    the name of the View template that we need to retrieve. From here on, we can create
    the `ServletContextTemplateLoader` and `Handlebars` instances to load a view as
    we saw in the earlier `TradeInfoServlet` class. Then we have to navigate some
    tricky waters a little bit by reading the contents of the current view in a buffer.
    `ViewEngineBase` provides a `resolve()` method that helps us immensely and returns
    `InputStream`. By the way, the Java 7 acquire/resource syntax for the try-catch
    statements reduces the boilerplate code. At the end of the method, we can compile
    the view inline because we have the content in a buffer.
  prefs: []
  type: TYPE_NORMAL
- en: We will add a couple of useful features in `MyHandlebarsViewEngine`. First,
    we will add extra properties to the `Models` instance. We will add the web context
    path and request and response objects to the `Models` instance. Second, we will
    register a Handlebars helper in order to better render the BigDecimal types.
  prefs: []
  type: TYPE_NORMAL
- en: When our application is deployed, Ozark relies on CDI to find the `ViewEngineBase`
    types. Ozark scans the classpath of JAR files and classes to find types of `ViewEengineBase`
    objects. It builds an internal list of available renders. `MyHandlebarsViewEngine`
    is the place presently where you can add additional helpers and utilities in the
    rendering phase. Keep a watch on the MVC specification to see if any of these
    interfaces are exposed in a meaningful public accessible API.
  prefs: []
  type: TYPE_NORMAL
- en: We will move on to our controller and the product list view.
  prefs: []
  type: TYPE_NORMAL
- en: The product controller
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our domain object is the humble `Product` entity, which has an outline that
    resembles the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Note that `Product` takes full advantage of the Bean Validation annotations.
    In particular, it uses a BigDecimal type for the accurate prices and the `@DecimalMin`
    annotation prevents storage negative and zero prices at the bounded context.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given our entity object, we will need `ProductController` to interface the
    domain to the presentation view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: As usual, we will annotate `ProductController` with the JAX-RS annotations in
    order to bring in the RESTful service space. We will be using Bean Validation
    to verify the state of our input objects, and therefore, we will inject `ValidatorFactory`
    from the Java EE container. We will inject the `Models` instance for the MVC operations.
    We also have a custom `FormErrorBean` POJO to capture the error messages, and
    finally, there is an EJB, `ProductService`, to persist the records to a database.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `listProducts()` controller method delegates to the shared methods: `retrieveAll()`
    and `defineCommonModelProperties()`. The `retreieveAll()` method pulls all the
    products from the database using the EJB. It saves the list collection in `Models`
    under a known property key. The `defineCommonModelProperties()` method saves a
    title as a key in the same `Models` instance. It turns out that many controller
    methods need the same functionality and so we refactored it. We will place the
    retrieved product collection in a `Models` key property called products. Finally,
    `listProducts()` forwards it to the Handlebars Java view template, `product.hbs`.
    After our controller method is returned, Ozark will eventually delegate to our
    custom view engine: `MyHandlebarsViewEngine`.'
  prefs: []
  type: TYPE_NORMAL
- en: Block expressions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can take a look at the view and learn about the useful block expressions.
    The following is the extract of the view template, `/products.hbs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we actually used the `{{title}}` expression in this view template,
    which was set in the `defineCommonModelProperties()` method. The value for the
    `{{webContextPath}}` placeholder is set in our extension class, `MyHandlebarsViewEngine`.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two new expressions: `{{#each}}` and `{{/each}}`. These are the built-in
    block expressions that allow us to loop over a context element. In this case,
    we will iterate over the products. The product element at the heart of the loop
    becomes accessible under the `{{this}}` placeholder.'
  prefs: []
  type: TYPE_NORMAL
- en: In order to print the BigDecimal price correctly, we will invoke the `{{formatDecimal}}`
    helper function that was defined in our custom view engine. A helper function
    can accept more than one parameter. The result is a rendered table of the products
    with their names, descriptions, and prices with the anchor links to edit or delete
    an item.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the screenshot for the view template, `products.jsp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Block expressions](img/image00426.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: A product listing view template rendered by Handlebars
  prefs: []
  type: TYPE_NORMAL
- en: The retrieve and edit operations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Once a customer selects a product to edit, then we will need to retrieve the
    data from the database and push them to a different view template. This is the
    purpose of the preview edit method in the controller, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We will annotate this controller method, `retrieveProduct()`, with `@PathParam`
    in order to retrieve the product ID. With the identifier, we will simply look
    up the `Product` entity and put the result in the request-scoped `Models` property.
    Obviously, for a production application, we would probably be really defensive-minded
    in checking whether the identifier is valid or not. The method progresses the
    final delivery of the response to the view template, `/edit-products.hbs`. The
    source code for the view template is available with this book's source distribution.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will move on to the next part when the user has submitted the HTML form
    on this page view template. If the customer submits the form, then their journey
    will invoke the next controller method in `ProductController`, which is called
    `editProduct()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Our controller method is invoked on the submission of the HTML form and so we
    will annotate it with the necessary `@PathParam` and `@FormParam` declarations
    in order to receive the product ID and properties. Our controller expects a form
    parameter with the `name`, action. The customer may cancel the operation and if
    so the action does not match the `Save` operation. Therefore nothing occurs and
    the method progress the response to the product list view.
  prefs: []
  type: TYPE_NORMAL
- en: With the `Save` action, our method will utilize the injected `ValidatorFactory`
    instance so as to manually validate the form parameters. As the entity product
    has the validation annotations, we will construct a temporary instance with the
    form parameter and then create a validator to check it. We do not directly change
    a persisted entity at this juncture because the data may be invalid. If this is
    the case, then the Java EE container will raise `javax.persistence.RollbackException`
    after the controller method exits because the thread of control passes through
    a transaction barrier. After validating the temporary instance, a collection of
    the `ConstraintViolation` elements is returned.
  prefs: []
  type: TYPE_NORMAL
- en: Let's assume that the form data is invalid. We will retrieve the information
    from the first violation and populate the details in a request scope `FormErrorMessage`
    bean. The form errors are accessible in the view template from the property key,
    `formError`. The controller method then builds a response with the HTTP Bad Request
    error code and then forwards to a view template, `/error.hbs`.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, if the form is valid according to the Bean Validation check,
    then we will proceed to retrieve the `Product` entity from the database by the
    product ID. We will update the `Product` entity from the form properties and then
    save it in the database. As we have already checked the data manually, there should
    not be an error in saving the data. We will build an HTTP OK response and forward
    to the view template, `/products.hbs`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At the time of writing this, the MVC specification leads were still developing
    the validation and binding of the parameters post the Early Draft Release of MVC.
    Notably, if a controller injected the `javax.mvc.BindingResult` instance, then
    it would be possible to handle the form validation in a precise and narrow user
    story instead of globally, as in the case of a straight JAX-RS API.
  prefs: []
  type: TYPE_NORMAL
- en: 'To complete the picture, here is the compact version of the `FormErrorMessage`
    bean:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a request-scoped bean and we will render the information in a Handlebars
    view template, `error.hbs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'This view renders the error message in the `FormErrorMessage` bean. You might
    be wondering why we are sending the form validation errors to a separate view.
    The answer is simple: baby steps. In a professional digital application, we would
    take advantage of an AJAX validation and a JavaScript framework such as jQuery
    on the client side. Our client-side JavaScript module would invoke an HTTP POST
    request to an MVC controller method in order to validate the property information.
    This method called, say `validateCheck()`, would check on a temporary instance
    and report with a JSON response containing the constraint violations, if any.
    Perhaps the members of the JSR-371 expert group will ease this part of the development
    for Digital.'
  prefs: []
  type: TYPE_NORMAL
- en: The JAX-RS global validation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The problem with the `editProduct()` method is that we are forced to use manual
    validation steps. The only alternative at the moment is to fall back on the JAX-RS
    validation.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s inspect a new version of the controller method called `altEditProduct()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This time, we will inscribe the Bean Validation annotations directly on the
    controller method, `altEditProduct()`. You might be concerned that this is duplication,
    with the annotation already on the Entity bean. You would be correct, but let's
    continue. The `altEditMethod()` method is shorter, which is great. There is a
    problem now with this approach in that the validation is delegated globally to
    JAX-RS. If the customer submits an HTML form to `altEditMethod()`, then they will
    send an HTTP Bad Request error response and a user-unfriendly error message direct
    from the application server. Obviously, the UX team would be throwing a fit! What
    can we do?
  prefs: []
  type: TYPE_NORMAL
- en: 'The JAX-RS specification permits an application to provide a handler for an
    error response. The way to achieve this goal is to configure a provider through
    CDI, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This `ConstraintViolationExceptionMapper` class is a JAX-RS provider because
    we annotated it with `@javax.ws.rs.ext.Provider`. The class is generically typed
    to `ConstraintViolationException` and therefore, it handles all the failures in
    the web application! There is no leeway here. We will inject into the `HttpServletRequest`
    POJO in order to get access to the web context. The `toResponse()` method transforms
    the constraint violation into a new response. We will need an implementation of
    the `Models` instance, so we will instantiate the class in the Ozark framework.
    We will build a `FormErrorMessage` POJO directly and populate it from the first
    instance of a `javax.validation.ConstraintViolation` type. We will set a key property
    in the `Models` instance and servlet request scope. From here, we will create
    a `Viewable` instance with the view template reference, `error.hbs`, and the `Models`
    instance and then build and return a response.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is worth looking at some of the internals of the reference implementation,
    Ozark. We have always seen `ViewEngineBase` and `ViewEngineContext`. Here is a
    diagram of some of the important internal classes and their packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The JAX-RS global validation](img/image00427.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: An MVC binding result validation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The MVC specification has an API for fine grain validation, which is still being
    decided on. There are two interface types—`BindingResult` and `BindingError`—in
    the `javax.mvc.binding` package.
  prefs: []
  type: TYPE_NORMAL
- en: '`BindingResult` captures the constraint violations during an attempt to validate
    the input arguments of an MVC controller method, which is annotated with `@FormParam`.
    The specification describes the term binding to reflect the association between
    the form parameter and actual type of the property that is being validated and
    the possible constraint violations that could occur. Therefore, an integer property
    cannot be bound if the HTML form parameter, which is a string, cannot be converted
    to a number in a meaningful manner. The interface for `BindingResult` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The interesting members of `BindingResult` are `isFailed()`, `getAllViolations()`,
    and `getAllBindingErrors()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `BindingError` type is designed to represent a single error that occurs
    while binding a parameter to a controller method. Here is the condensed interface
    API for this type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The `BindingError` type works similarly to the Bean Validation specification
    for an interpolated message. Therefore, it is helpful for internationalization
    because the messages may be retrieved from `java.util.ResourceBundle`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For our final example, we will use `BindingResult` to validate our new `editMethod()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: In order to get the benefit of fine grain validation, we will inject `@BindingResult`
    as a property into `ProductController`. We will change the annotations around
    the `editProduct()` method. In order to ensure that JAX-RS performs the validation
    and the CDI and Bean Validation do not abort the process, we will annotate `@ValidateOnExecution`
    and set the type parameter to `ExecutableType.NONE`. According to the Bean Validation
    specification, the `@ValidateOnExecution` annotation is used to selectively enable
    and disable the violation. Switching off the validation allows JAX RS to take
    over our controller method, `editProduct()`. We will also use `@Valid` and `@BeanParam`
    to direct the MVC provider to validate the `Product` entity bean.
  prefs: []
  type: TYPE_NORMAL
- en: MVC takes over the validation when it notices that the controller class has
    injected the `BindingResult` instance or has a JavaBean setter method that accepts
    `BindingResult`. In the `editProduct()` method, we will check the Boolean status
    of the validation by calling the `isFailed()` method. If the input failed to get
    validated, we will grab the first constraint violation from the `BindResult` result
    and then populate the `FormErrorMessage` bean as before. We will then send an
    HTTP response with a Bad Request error code that forwards to the `error.hbs` view
    template.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we will write the `editProduct()` method with a separate named variable
    argument, `incomingProduct`, in order to keep a temporary holder of the HTML form
    data. We will copy the properties of this variable over the product entity that
    is retrieved from the database and save it. By the time we reach the end of the
    controller method, the entity bean must be valid. We will retrieve a list of the
    products and return an OK response. With `BindingResult`, it is clear to the developers
    that this validation is easier to program with. There is less code to deliberate
    over.
  prefs: []
  type: TYPE_NORMAL
- en: Design considerations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MVC is a very promising specification, and at the moment, the view technology
    solution is usual for digital developers. There is still a story to be developed
    regarding the handling of an HTTP redirects response and especially a way to hold
    over a form state. Many digital web developers are already familiar with the design
    pattern, HTTP POST– REDIRECT–GET ([https://en.wikipedia.org/wiki/Post/Redirect/Get](https://en.wikipedia.org/wiki/Post/Redirect/Get)),
    and therefore, they would be looking for an equivalent and safe option in the
    MVC specification.
  prefs: []
  type: TYPE_NORMAL
- en: On the other side of the equation lies the question about an HTML form validation;
    however, there may be breaking news on this front. The story on form validation
    shares much of the ground as HTTP redirect requests. Developers want to take advantage
    of the Bean Validation on an entity but they also want to seamlessly invoke the
    validation in a controller and introspect the validation result. The fact is that
    JAX-RS allows the validation through a global provider. However, this approach
    does not provide fine-grain validation handling and it cannot map constraint violation
    instances to individual HTML form input elements. Nevertheless, the post Early
    Draft Release snapshots have shown early promise in this regard.
  prefs: []
  type: TYPE_NORMAL
- en: As we have seen in the Handlebars Java code examples, there is a design consideration
    and trade-off for many digital architects. How much of the presentation logic
    resides in the client against the server side?
  prefs: []
  type: TYPE_NORMAL
- en: Majority server-side templating
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Considering the option of mostly server-side templating, why would a technical
    architect choose this mode? There are a lot of reasons for this approach. One
    reason may be that the team is slightly intimidated by JavaScript programming
    and wants minimum dependencies and time-to-market. This is a skill, training,
    and maintenance trade-off. Another reason might be that the final end client devices
    are sufficiently underpowered, such as an Internet of Things device. It is unlikely
    that a digital thermostat would have to render retina edition images. Yet another
    reason could be an easier migration for a very old legacy application in order
    to bring it up to date: this is digital transformation. MVC can help here with
    the extensive view templates support.'
  prefs: []
  type: TYPE_NORMAL
- en: Majority client-side templating
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This design choice implies that the client side renders much of the content
    on a device. It has been said that smartphones with JavaScript and HTML5 have
    orders of magnitude of computing power over the rocket ship computers that took
    humankind to the moon. One reason that a technical architect might want to delegate
    the load to a client is to reduce the load on a server application. This is a
    trade-off in scalability on the server. Handlebars.js is a JavaScript view templating
    implementation that is perfectly adequate for this requirement among the other
    competing JavaScript frameworks out there on the Internet. The MVC controllers
    in this mode become thin layers of architecture that truly bind the view to the
    model. This mode may also be appropriate if your team features very strong interface
    designers and developers or if they have a lack of experience with the modern
    Java EE development. On the UI front, there may be a valid reason to have customer
    journeys that map to a page-by-page navigation. Therefore, the architecture avoids
    single page applications and this might rule out frameworks such as AngularJS.
  prefs: []
  type: TYPE_NORMAL
- en: Shared templating
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The final design choice is to combine both the client-side and server-side templating
    and share the responsibility of the presentation view. This may be a favored strategy
    for the digital technical architects working across cross-functional teams. If
    there is a strong interface development team and server-side Java EE team and
    they communicate well, then this is a reasonable approach. Apart from human resource
    considerations in an agile team, this approach technically favors an architecture
    where there is a shared template and vision to organize the digital assets. Let's
    say the architecture is decided on Handlebars Java on the server and Handlebars.js
    on the client-side; the team is immediately faced with the organization of the
    view templates. Which templates are compiled on the JavaScript frontend and which
    templates matter on the server side? The resolution to this design choice will
    result in the construction of the MVC controllers on the server side.
  prefs: []
  type: TYPE_NORMAL
- en: Let me leave you with one note of warning about these three design considerations.
    If you are worth your salt, you will consider the effect of the UX changes and
    sudden surprises. Therefore, a digital technical architect must factor the effect
    of design changes into his or her calculations.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this final chapter of the book, we covered the burgeoning MVC specification
    from the ground up. We covered the essential elements of the models, views, and
    controllers. We saw that MVC is a layering on top of JAX-RS and it reuses the
    same annotations, including `@GET`, `@FormParam`, `@Path`, `@FormParam`, and `@POST`.
  prefs: []
  type: TYPE_NORMAL
- en: In order to establish a method as an MVC controller, we annotated them with
    `@Controller`. We wrote controllers that generate either the response instance
    or, if they returned a void type, we would annotate the method with `@View`.
  prefs: []
  type: TYPE_NORMAL
- en: You learned about the various view technologies that are supported by the MVC
    reference specification, Ozark. We used the Handlebars Java view template to build
    the elements of a CRUD example. We also understood that the MVC specification
    might change in respect to the redirection and validation APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are the questions and exercises for this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: What are the constituent components of the Java EE MVC framework? What does
    MVC attempt to solve?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between `@Controller`, `@Model`, and `@View`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between the Response and Viewable types?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Given that the standard HTML form element does not send an HTTP PUT or DELETE
    request, just how would you handle the removing of a record from the database
    using MVC? What does this mean for the businesses that already have full RESTful
    interfaces?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By the time this book is published, the MVC framework will be further along
    and there is likely to be many milestone releases. Update your knowledge. What
    has changed? Look especially at the redirection and validation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Download the `handlebars-javaee-mvc-validation` project from the book's source
    code repository and adapt the product instance in order to include the `description`
    (`string`), `manufacturer` (`string`), and `manufacturedDate` (`java.util.Date`)
    properties. What needs to happen in order to display a formatted date correctly
    (say, MMM-dd-yyyy or dd-MMM-yyyy)?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Working from the previous exercise, ensure that the proper validation techniques
    are in place using MVC. How would you validate the user input?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you are reasonably comfortable with the JavaScript programming, write a
    module to invoke validation over AJAX. (Hint: you will probably need to understand
    the JQuery REST requests and responses.)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this exercise, take the `Product` entity and `ProductController` controller
    classes and use them as a basis to experiment with another view template technology
    with the Ozark reference implementation. There are plenty of choices. Adapt a
    new templating framework to the product CRUD application—try Thymeleaf or even
    AsciiDoc. What is the difference between the templating choices? What are the
    benefits? What are the disadvantages?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Write a short essay that proposes the MVC framework to your current team for
    a particular project. What are the design considerations of the MVC approach?
    Does your target audience suit a single page navigation or page-by-page navigation
    or a mixture of both the ideas? (Hint: personas might be useful; you can write
    a proposal aimed to convince the technical leader in your team or you might be
    a technical leader aiming to convince the members in your team.)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
