- en: Chapter 9. Java EE MVC Framework
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第九章. Java EE MVC框架
- en: '|   | *"Compared even to the development of the phone or TV, the Web developed
    very quickly."* |   |'
  id: totrans-1
  prefs: []
  type: TYPE_TB
  zh: '|    | *"与电话或电视的开发相比，Web发展得非常快。"|'
- en: '|   | --*Sir Tim Berners-Lee, inventor of the World Wide Web* |'
  id: totrans-2
  prefs: []
  type: TYPE_TB
  zh: '|    | --*蒂姆·伯纳斯-李爵士，万维网的发明者*|'
- en: In the past couple of chapters, we reviewed the web application service from
    the perspective of the client side. For this last chapter, we will return to the
    digital application written mainly on the server-side. We will examine a brand
    new specification under the Java EE umbrella. It is called **Model-View-Controller**
    (**MVC**) and falls under the Java EE 8 release (March 2017) with JSR 371 ([https://jcp.org/en/jsr/detail?id=371](https://jcp.org/en/jsr/detail?id=371)).
    At the time of writing this book, there was already an Early Draft Release of
    Java EE MVC that demonstrates the working of the reference implementation called
    Ozark ([https://ozark.java.net/index.html](https://ozark.java.net/index.html)).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去几章中，我们从客户端的角度回顾了Web应用程序服务。在本章的最后，我们将回到主要在服务器端编写的数字应用程序。我们将检查Java EE下的一个全新的规范。它被称为**模型-视图-控制器**（**MVC**），属于Java
    EE 8版本（2017年3月）下的JSR 371（[https://jcp.org/en/jsr/detail?id=371](https://jcp.org/en/jsr/detail?id=371)）。在撰写本书时，Java
    EE MVC的早期草案版本已经发布，展示了参考实现Ozark（[https://ozark.java.net/index.html](https://ozark.java.net/index.html)）的工作原理。
- en: 'The MVC framework is based on a design pattern that was invented in the Smalltalk
    programming language and environment, which was particularly common in the early
    user interface applications. The idea is that the Model refers to the component
    that stores the application data such as a value object or data transfer objects.
    The View is the component that renders or is responsible for the delivery of a
    representation of the application''s data to the user and the Controller is the
    component that contains the logic to process the input and output between the
    two former components: the View and Model. The design pattern is extremely popular
    because it embraces the separation of concerns, which is a key concept in a good
    pragmatic object-oriented design.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: MVC框架基于在Smalltalk编程语言和环境中所发明的设计模式，这在早期的用户界面应用程序中尤为常见。其理念是，模型指的是存储应用程序数据（如值对象或数据传输对象）的组件。视图是负责将应用程序数据的表示渲染或交付给用户的组件，控制器是包含处理前两个组件（视图和模型）之间输入和输出逻辑的组件。这种设计模式之所以非常流行，是因为它拥抱了关注点的分离，这是良好实用主义面向对象设计中的一个关键概念。
- en: In 2014, Oracle issued a public open survey to the wider Java EE community and
    collected the results ([https://java.net/downloads/javaee-spec/JavaEE8_Community_Survey_Results.pdf](https://java.net/downloads/javaee-spec/JavaEE8_Community_Survey_Results.pdf)).
    Thousands of technologists responded to this survey. One key question in the survey
    was, *Should Java EE provide support for MVC, along with JSF?* The correspondence
    was 60.8 percent in favor with a yes vote, 20 percent with a no vote, and 19.2
    percent were unsure. This was enough to sanction the MVC 1.0 specification to
    be a part of Java EE 8.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在2014年，甲骨文公司对更广泛的Java EE社区发布了一项公开的问卷调查，并收集了结果（[https://java.net/downloads/javaee-spec/JavaEE8_Community_Survey_Results.pdf](https://java.net/downloads/javaee-spec/JavaEE8_Community_Survey_Results.pdf)）。数千名技术人员对此调查做出了回应。调查中的一个关键问题是，“Java
    EE是否应该提供对MVC和JSF的支持？”投票结果显示，60.8%的人支持，20%的人反对，19.2%的人不确定。这足以批准MVC 1.0规范成为Java
    EE 8的一部分。
- en: Java EE 8 MVC
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java EE 8 MVC
- en: Before we continue on to the programming, I should warn you that the information
    here is subject to change, because MVC is evolving right in front of our eyes.
    As an avid reader, you should certainly verify, at least, that the API is with
    the current or final specification.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续编程之前，我应该提醒您，这里的信息可能会发生变化，因为MVC正在我们眼前不断发展。作为一名热心的读者，您应该至少验证API是否与当前或最终规范一致。
- en: With all this said, the MVC framework certainly—even at this early stage—will
    be a leading specification for the future digital web development framework for
    many years to come, and not just because it is now officially part of the Java
    EE umbrella drivetrain. MVC leverages the JAX-RS (Java for RESTful Services) API
    and currently integrates with the other Java EE technologies including CDI and
    Bean Validation.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 如此一来，MVC框架无疑——即使在这个早期阶段——将成为未来许多年数字Web开发框架的领先规范，而不仅仅是因为它现在是Java EE伞下驱动系统的一部分。MVC利用了JAX-RS（Java
    for RESTful Services）API，并目前与其他Java EE技术集成，包括CDI和Bean Validation。
- en: The expert group made the decision to layer on top of JAX-RS rather than the
    older Java servlet API, because JAX-RS fits the modern programming practice to
    use full semantics of the HTTP mapping capabilities. They also felt that adopting
    servlet would expose the developer to the lower-level programming interfaces that
    are already duplicated in the JAX-RS specification.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 专家小组决定在JAX-RS而不是较旧的Java servlet API之上分层，因为JAX-RS适合现代编程实践，以使用HTTP映射能力的完整语义。他们还认为采用servlet会将开发者暴露于JAX-RS规范中已经重复的低级编程接口。
- en: From a digital developer's and modern web practices' points of view, the layering
    of MVC on top of JAX-RS is really a good adoption. The servlet specification has
    been criticized severely by the likes of the Play framework and others as being
    a wide and thick Context Map abstraction (Eric Evans' Domain-Driven Design) and
    a blocker to the natural design of the web and HTTP utilization.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 从数字开发者和现代网络实践的角度来看，在JAX-RS之上分层MVC确实是一个很好的采用。Servlet规范受到了像Play框架和其他人的严厉批评，因为它是一个宽而厚的上下文映射抽象（埃里克·埃文斯的领域驱动设计）并且是阻止网络和HTTP自然设计的障碍。
- en: We will be working with the Java EE 8 MVC reference implementation called Ozark.
    At the time of writing, Ozark is still a work in progress. However, the milestone
    release contains the essential components and interfaces of the MVC applications.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Java EE 8 MVC参考实现Ozark。在撰写本文时，Ozark仍在开发中。然而，里程碑版本包含MVC应用程序的必要组件和接口。
- en: MVC controllers
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MVC控制器
- en: 'There is a new package structure reserved for MVC under `javax.mvc`. The `@javac.mvc.Controller`
    annotation declares a class type or method as a controller component. Here is
    an example of its use in a method:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在`javax.mvc`下为MVC保留了一个新的包结构。`@javac.mvc.Controller`注解声明一个类类型或方法作为控制器组件。以下是在方法中使用它的一个示例：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This controller method is missing the HTTP semantics and this is where the JAX-RS
    annotations help. It is also useless from an MVC perspective because there are
    associations with either a Model or View component.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 此控制器方法缺少HTTP语义，这正是JAX-RS注解帮助的地方。从MVC的角度来看，它也是无用的，因为与模型或视图组件有关联。
- en: 'So, first let''s turn the method into a proper RESTful resource, starting with
    the model object:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，首先让我们将方法转换为合适的RESTful资源，从模型对象开始：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The User component serves as our Model component. It has one property: the
    name of the person whom we are greeting politely. We can, therefore, write an
    MVC resource endpoint and inject this model instance into it.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 用户组件充当我们的模型组件。它有一个属性：我们礼貌问候的人的名字。因此，我们可以编写一个MVC资源端点，并将此模型实例注入其中。
- en: 'Here is the initial version of our controller:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们控制器的初始版本：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We will annotate a JAX RS `@Path` element to our `AlienGreetings` class in order
    to declare that it is a resource endpoint. Although our type is defined as an
    EJB stateless session bean, MVC is expected to work with the CDI scopes such as
    `@ApplicationScoped` and `@SessionScoped`. The reference implementation is changing
    as I write this.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用JAX RS的`@Path`注解注解我们的`AlienGreetings`类，以声明它是一个资源端点。尽管我们的类型定义为EJB无状态会话豆，但MVC预计将与CDI作用域一起工作，如`@ApplicationScoped`和`@SessionScoped`。参考实现正在我编写时发生变化。
- en: 'We will annotate the `simple1()` method as an MVC `@Controller` annotation.
    This method accepts one argument name as `@QueryParam`. We will add the other
    JAX-RS annotations in order to define the HTTP method protocol `@GET`, relative
    URI `@Path`, and MIME content type `@Produces`. The method sets the name property
    in the `User` instance and returns a reference string, which is the name of the
    view: `/hello.jsp`.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用MVC的`@Controller`注解来注解`simple1()`方法。此方法接受一个名为`@QueryParam`的参数。我们将添加其他JAX-RS注解，以定义HTTP方法协议`@GET`、相对URI`@Path`和MIME内容类型`@Produces`。该方法在`User`实例中设置名称属性，并返回一个引用字符串，即视图的名称：`/hello.jsp`。
- en: An MVC controller method can return a string, which means that the servlet container
    takes over the rendering of the final view. However, MVC can also render different
    views due to an extendible implementation. We will see more on this later. Behind
    the scenes, MVC converts the string to a view type. The Java interface `javax.mvc.Viewable`
    represents the abstraction of a view technology. The Viewable is an association
    between `javax.mvc.ViewEngine` and `javax.mvc.Models`.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: MVC控制器方法可以返回一个字符串，这意味着Servlet容器接管了最终视图的渲染。然而，由于可扩展的实现，MVC也可以渲染不同的视图。我们将在稍后看到更多关于这一点的内容。在幕后，MVC将字符串转换为视图类型。Java接口`javax.mvc.Viewable`代表视图技术的抽象。Viewable是`javax.mvc.ViewEngine`和`javax.mvc.Models`之间的关联。
- en: The abstract class type `javax.mvc.Engine` has the responsibility to render
    a model to a technology choice. Engineers can develop or add this engine to render
    the views. At the moment, Ozark supports many rendering styles, from Apache Velocity
    to AsciiDoc.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象类类型`javax.mvc.Engine`负责将模型渲染到技术选择。工程师可以开发或添加此引擎以渲染视图。目前，Ozark支持从Apache Velocity到AsciiDoc的许多渲染样式。
- en: The Java interface `javax.mvc.Models` represents a key value store that is passed
    from the view to the rendering engine. The model's type is a request-scoped map
    collection.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Java接口`javax.mvc.Models`代表一个从视图传递到渲染引擎的关键值存储。模型类型是请求作用域的映射集合。
- en: 'So, let''s extend the `AlienGreeting` controller with a few more methods. The
    following `simple2()` method returns a `Viewable` instance:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们扩展`AlienGreeting`控制器并添加一些更多的方法。下面的`simple2()`方法返回一个`Viewable`实例：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'As you can see, the `simple2()` method is a variation on `simple1()`, and MVC
    is rather flexible. It even supports the void methods that do not return types.
    We will annotate the subsequent `simple3()` method with `@javax.mvc.View` in order
    to declare the next view:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`simple2()`方法是对`simple1()`的变体，MVC相当灵活。它甚至支持不返回类型的void方法。我们将使用`@javax.mvc.View`注解后续的`simple3()`方法，以声明下一个视图：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: All of the three methods are HTTP GET requests so far. As MVC is layered on
    top of JAX-RS, we can utilize other protocol methods too. It is straightforward
    to write an HTML form handler that handles an HTTP POST request.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，所有三个方法都是HTTP GET请求。由于MVC建立在JAX-RS之上，我们还可以利用其他协议方法。编写处理HTTP POST请求的HTML表单处理程序很简单。
- en: 'Here is the code extract for the `helloWebForm()` method:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`helloWebForm()`方法的代码片段：
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The preceding controller method, `helloWebForm()`, accepts an HTML form named
    parameter. It sets the model object and returns a view instance. In the HTML5
    standard, the form element officially supports the HTTP GET and POST requests.
    The popular web browsers tend to have access only to the HTTP PUT and DELETE protocol
    requests through JavaScript. This limitation does not, however, prevent the MVC
    controllers being annotated with `@PUT` or `@DELETE`.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的控制器方法`helloWebForm()`接受一个名为参数的HTML表单。它设置模型对象并返回一个视图实例。在HTML5标准中，表单元素正式支持HTTP
    GET和POST请求。流行的网络浏览器通常只能通过JavaScript访问HTTP PUT和DELETE协议请求。然而，这种限制并不会阻止MVC控制器被注解为`@PUT`或`@DELETE`。
- en: 'The MVC controllers have access to a full gamut of the URI space that is available
    to the JAX-RS endpoints. The following example illustrates the path parameter:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: MVC控制器可以访问JAX-RS端点可用的完整URI空间。以下示例说明了路径参数：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The preceding controller method, `helloWebPath()`, accepts a path parameter
    as the user's name. The `@PathParam` annotation establishes the parameter token
    used in the relative URI. The URI is defined by the `@Path` annotation. The full
    URL will be `http://localhost:8080/javaee-basic-mvc/rest/hello/view/Curtis`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的控制器方法`helloWebPath()`接受一个路径参数作为用户的名称。`@PathParam`注解建立了在相对URI中使用的参数标记。URI由`@Path`注解定义。完整的URL将是`http://localhost:8080/javaee-basic-mvc/rest/hello/view/Curtis`。
- en: MVC page views and templates
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MVC页面视图和模板
- en: Under the MVC specification, a `view` instance can be treated as a templating
    technology reference. We have seen only JavaServer Page views up until now. A
    view can be anything that a developer can imagine, as long as there is a corresponding
    `ViewEngine` instance that knows exactly how to process (render) a view from the
    associated model and the other results from a controller.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 MVC 规范，一个`view`实例可以被视为模板技术参考。到目前为止，我们只看到了JavaServer Page视图。只要有一个相应的`ViewEngine`实例知道如何从关联的模型和其他控制器结果中处理（渲染）视图，视图可以是开发者能想到的任何东西。
- en: 'Let''s look at the first basic JSP view, `index.jsp`, in the sample source
    code project from this book (`ch09/basic-javaee-mvc`):'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这本书（`ch09/basic-javaee-mvc`）示例源代码项目中的第一个基本 JSP 视图，`index.jsp`：
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In this JSP view, we will take advantage of an EL to generate a URL with the
    context path for the web application, namely `pageContext.request.contextPath`.
    There are three HTML anchor elements that invoke the `AlienGreeting` controller
    methods: `simple1()`, `simple2()`, and `simple3()`. The HTML form invokes the
    `helloWebForm()` method.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个 JSP 视图中，我们将利用表达式语言（EL）生成带有 Web 应用程序上下文路径的 URL，即 `pageContext.request.contextPath`。有三个
    HTML 锚元素调用 `AlienGreeting` 控制器方法：`simple1()`、`simple2()` 和 `simple3()`。HTML 表单调用
    `helloWebForm()` 方法。
- en: 'The page extract JSP view called `hello.jsp` looks as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 被称为 `hello.jsp` 的页面提取 JSP 视图如下所示：
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The view template is very straightforward; we will use the request-scoped user
    instance to supply the name.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 视图模板非常简单；我们将使用请求作用域的用户实例来提供名称。
- en: 'At the time of writing this, Ozark supported the following view rendition technologies
    in the beta reference implementation, as shown in the following table:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，Ozark 支持以下视图呈现技术，如以下表格所示：
- en: '| Template name | Description |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| 模板名称 | 描述 |'
- en: '| --- | --- |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| AsciiDoc | This a text document format to write notes, documents, articles,
    books, e-books, slideshows, man pages, and blogs.[https://github.com/asciidoctor/asciidoctorj](https://github.com/asciidoctor/asciidoctorj)
    |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| AsciiDoc | 这是一个用于编写笔记、文档、文章、书籍、电子书、幻灯片、手册页和博客的文本文档格式。[https://github.com/asciidoctor/asciidoctorj](https://github.com/asciidoctor/asciidoctorj)
    |'
- en: '| Freemarker | This is a Java template engine that generates HTML, RTF, and
    source code.[http://freemarker.org/](http://freemarker.org/) |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| Freemarker | 这是一个 Java 模板引擎，可以生成 HTML、RTF 和源代码。[http://freemarker.org/](http://freemarker.org/)
    |'
- en: '| Handlebars | This is a multiple language and platform extension to the original
    Mustache templating specification with helpful utilities tokens.JavaScript version:
    [http://handlebarsjs.com/](http://handlebarsjs.com/) and Java port: [https://github.com/jknack/handlebars.java/](https://github.com/jknack/handlebars.java/)
    |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| Handlebars | 这是一个针对原始 Mustache 模板规范的多种语言和平台扩展，包含有用的实用工具标记。JavaScript 版本：[http://handlebarsjs.com/](http://handlebarsjs.com/)
    和 Java 版本：[https://github.com/jknack/handlebars.java/](https://github.com/jknack/handlebars.java/)
    |'
- en: '| JSR 223 | This is an extension of the MVC framework that supports JSR 223
    for a dynamic scripting language such as Groovy and Jython.[https://www.jcp.org/en/jsr/detail?id=223](https://www.jcp.org/en/jsr/detail?id=223)
    |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| JSR 223 | 这是 MVC 框架的一个扩展，支持 JSR 223 动态脚本语言，如 Groovy 和 Jython。[https://www.jcp.org/en/jsr/detail?id=223](https://www.jcp.org/en/jsr/detail?id=223)
    |'
- en: '| Mustache | This is a simple web template language that separates the presentation
    from the business view logic. It is available on multiple platforms and languages.[https://github.com/spullara/mustache.java](https://github.com/spullara/mustache.java)
    |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| Mustache | 这是一个简单的网络模板语言，将表示与业务视图逻辑分离。它在多个平台和语言上可用。[https://github.com/spullara/mustache.java](https://github.com/spullara/mustache.java)
    |'
- en: '| Thymeleaf | This is a Java-based HTML5 template library that works in the
    web and non-web environments. It is associated strongly with the string framework.[http://www.thymeleaf.org/](http://www.thymeleaf.org/)
    |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| Thymeleaf | 这是一个基于 Java 的 HTML5 模板库，适用于 Web 和非 Web 环境。它与字符串框架紧密相关。[http://www.thymeleaf.org/](http://www.thymeleaf.org/)
    |'
- en: '| Velocity | Apache Velocity is a suite of the templating tools. The Velocity
    engine is the component library that provides templating. It was one of the first
    web template frameworks that was written for server-side Java.[http://velocity.apache.org/](http://velocity.apache.org/)
    |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| Velocity | Apache Velocity 是一套模板工具集。Velocity 引擎是提供模板功能的组件库。它是为服务器端 Java 编写的第一个网络模板框架之一。[http://velocity.apache.org/](http://velocity.apache.org/)
    |'
- en: Tip
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: MVC is a server-side template solution. Don't confuse the world of client-side
    templating with the backend variety.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: MVC 是一个服务器端模板解决方案。不要将客户端模板的世界与后端版本混淆。
- en: MVC models
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MVC 模型
- en: The MVC specification supports two forms of models. The first is based on the
    `javax.mvc.Models` instance and the second form leverages the CDI `@Named` beans.
    The `Models` interface types map the key names to the values in a map collection.
    All the view engines must mandatorily support `Models`. A view engine may optionally
    support CDI. The specification recommends that the view engine implementers provide
    the CDI beans support.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: MVC规范支持两种模型形式。第一种是基于`javax.mvc.Models`实例，第二种形式利用CDI的`@Named` beans。`Models`接口类型将键名映射到映射集合中的值。所有视图引擎都必须强制支持`Models`。视图引擎可以可选地支持CDI。规范建议视图引擎实现者提供CDI
    beans支持。
- en: 'The default implementation of the `Models` interface is a request-scoped bean:
    `com.oracle.ozark.core.ModelsImpl`. This class delegates to a `java.util.Map`
    collection. Developers normally never instantiate this type but prefer to inject
    the `Models` type. As you will see later, it is sometimes necessary to create
    an instance for a particular view engine.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`Models`接口的默认实现是一个请求作用域的bean：`com.oracle.ozark.core.ModelsImpl`。此类委托给`java.util.Map`集合。开发者通常永远不会实例化此类，而是更喜欢注入`Models`类型。正如你稍后将会看到的，有时需要为特定的视图引擎创建一个实例。'
- en: 'Let''s demonstrate the practical use of the `Models` interface in a second
    version of our controller class:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在控制器类的第二个版本中演示`Models`接口的实际应用：
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In `PhobosGreetings`, we will replace the CDI injection of the `User` type with
    a `Models` instance. We will create a `User` instance and store this under the
    property key, `user`. After the method returns, the framework will retrieve all
    of the properties in the `Models` instance and place them in the attributes collection
    of `HttpServlerResponse`. Therefore, a JSP template view has access to the data
    through an EL or inline scripting.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在`PhobosGreetings`中，我们将用`Models`实例替换`User`类型的CDI注入。我们将创建一个`User`实例，并将其存储在属性键`user`下。方法返回后，框架将检索`Models`实例中的所有属性并将它们放置在`HttpServletResponse`的属性集合中。因此，JSP模板视图可以通过EL或内联脚本访问数据。
- en: Response and redirects
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 响应和重定向
- en: MVC also supports the controller that returns an instance of the JAX RS Response
    type. This is especially useful to the sites that shove the Grunt work of rendering
    to the client side. A highly scalable web application may choose to send the megabytes
    of a JSON response rather than render on the server through a template.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: MVC还支持返回JAX RS响应类型实例的控制器。这对于将渲染工作推到客户端的网站特别有用。一个高度可扩展的Web应用程序可能会选择发送兆字节的JSON响应，而不是通过模板在服务器上渲染。
- en: 'We will now inspect another MVC controller called `RedirectController`:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将检查另一个名为`RedirectController`的MVC控制器：
- en: '[PRE10]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We will annotate `RedirectController` with JAX-RS `@Path` and we must pay particular
    attention to the base value, `redirect`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用JAX-RS的`@Path`注解`RedirectController`，我们必须特别注意基本值`redirect`。
- en: The `getString()` method performs a URI redirection using the special prefix
    operator, redirect. This method has a unique relative URI of `redirect/string`.
    MVC detects the prefix internally and builds a JAX-RS Response as a redirect request.
    The URI that is returned is a reference to the `getRedirectedView()` controller,
    which has a relative path URI of `redirect/here`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`getString()`方法使用特殊的重定向操作符`redirect`执行URI重定向。此方法具有唯一的相对URI `redirect/string`。MVC内部检测到前缀并构建一个JAX-RS响应作为重定向请求。返回的URI是`getRedirectedView()`控制器的引用，其相对路径URI为`redirect/here`。'
- en: We can directly build the response ourselves as seen in the `getResponse()`
    method. Invoking the static `Response.seeOther()` method with a URI is the equivalent
    of achieving an HTTP redirect response. This method has its own unique relative
    URI of `redirect/response1`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以直接构建响应，就像在`getResponse()`方法中看到的那样。使用URI调用静态`Response.seeOther()`方法等同于实现HTTP重定向响应。此方法有其独特的相对URI
    `redirect/response1`。
- en: 'The `getRedirectedView()` method simply navigates to the view template, `redirected.jsp`.
    This controller method is the eventual target of the other controller methods:
    `getString()` and `getResponse()`.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`getRedirectedView()`方法简单地导航到视图模板`redirected.jsp`。此控制器方法是其他控制器方法（`getString()`和`getResponse()`）的最终目标。'
- en: Tip
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: At the time of writing this, the MVC specification was designing the HTTP redirect
    approach. There was a question about providing a Flash scope or an equivalent
    of a JSF View scope bean for the MVC applications in order to save the data among
    the multiple request scopes. I strongly recommend you to check for updates on
    the specification.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，MVC规范正在设计HTTP重定向方法。有一个问题关于为MVC应用提供Flash作用域或JSF视图作用域豆的等效物，以便在多个请求作用域之间保存数据。我强烈建议你检查规范更新。
- en: Finally, an MVC controller can also return HTTP error responses. The `getErrorResponse()`
    method has a relative URI of `redirect/deliberateError1` and returns a Response
    instance with an HTTP Bad Request error code (401). The controller also informs
    the MVC framework to serve the view template under the view ID `error.jsp`. `RedirectController`
    represents the simplest form of an MVC controller. We can enrich it with the injection
    of `Models` or other CDI beans. We can also use the Viewable instances instead
    of the dumb strings as entities in a Response builder.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，MVC控制器还可以返回HTTP错误响应。`getErrorResponse()`方法有一个相对URI `redirect/deliberateError1`，并返回一个带有HTTP错误请求错误代码（401）的Response实例。控制器还通知MVC框架在视图ID
    `error.jsp`下提供视图模板。`RedirectController`代表了MVC控制器最简单的形式。我们可以通过注入`Models`或其他CDI豆来丰富它。我们还可以在响应构建器中将可视化实例用作实体，而不是使用愚蠢的字符串。
- en: Let's move on to the different templating technologies, and this is the unique
    selling point of MVC so far.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续介绍不同的模板技术，这也是MVC到目前为止的独特卖点。
- en: Reconfiguring the view root
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重新配置视图根
- en: In the working MVC early draft release, the view root is set by default to `WEB-INF/views`.
    Programmatically, this is found in the static property of `ViewEngine.DEFAULT_VIEW_ENGINE`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在工作的MVC早期草案版本中，视图根默认设置为`WEB-INF/views`。在程序上，这可以在`ViewEngine.DEFAULT_VIEW_ENGINE`的静态属性中找到。
- en: 'This may be inconvenient for the digital engineers with relative URI, especially
    in the redirection of the page views. Luckily, the Ozark implementation can be
    reconfigured from the web XML descriptor (`web.xml`), as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能对具有相对URI的数字工程师来说不方便，尤其是在页面视图的重定向中。幸运的是，Ozark实现可以从web XML描述符（`web.xml`）中进行重新配置，如下所示：
- en: '[PRE11]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We will override the `javax.mvc.engine.ViewEngine.viewFolder` property in the
    web page root in order to achieve the behavior that we want.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将覆盖`javax.mvc.engine.ViewEngine.viewFolder`属性，在网页根目录中实现我们想要的行为。
- en: Handlebars Java
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Handlebars Java
- en: The Handlebars framework is a templating library for a developing web application.
    In its JavaScript incantation ([http://handlebarsjs.com/](http://handlebarsjs.com/)),
    you might already have heard the digital interface developers raving about it.
    We will use the Handlebars Java port for the rest of this chapter.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Handlebars框架是一个用于开发Web应用的模板库。在其JavaScript版本([http://handlebarsjs.com/](http://handlebarsjs.com/))中，你可能已经听到了数字界面开发者对其赞不绝口。在本章的其余部分，我们将使用Handlebars
    Java版本。
- en: The Handlebars framework permits the developers along with designers to write
    semantic templates. It is based on a slightly older templating framework called
    Mustache ([https://mustache.github.io/](https://mustache.github.io/)). Both of
    these refer to the masculine facial hair that can be seen if you squint your eyes
    and look at a curly bracket rotated by 90 degrees.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: Handlebars框架允许开发者和设计师编写语义模板。它基于一个稍微老旧一些的模板框架，称为Mustache([https://mustache.github.io/](https://mustache.github.io/))。这两个都指的是如果你眯起眼睛看一个旋转90度的花括号，可以看到的男性面部毛发。
- en: Templating frameworks drive home the separation of concerns and reduction of
    mixing the business logic in the rendered page view as much as possible. The Handlebars
    framework borrows the double curly bracket notation from Mustache. For our masculine
    readers, this is a deliberate play on words and an idiosyncrasy of computer programming.
    The Handlebars framework has a clear advantage of leveraging the same template
    engine on the server side that also works on the client side.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 模板框架强调关注点的分离，尽可能减少在渲染的页面视图中混合业务逻辑。Handlebars框架从Mustache借用了双大括号符号。对于我们的男性读者来说，这是一种故意的文字游戏和计算机编程的怪癖。Handlebars框架在利用服务器端和客户端相同的模板引擎方面具有明显优势。
- en: A compiled-inline template servlet
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个编译内联模板servlet
- en: We will start with a servlet example as an introduction. We will create a Java
    servlet with just one dependency, which is the Handlebars Java implementation.
    We are not considering the MVC framework just yet. Our servlet will instantiate
    the templating framework, invoke an inline template script, and then return the
    output as a straightforward direct response.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从 Servlet 示例开始介绍。我们将创建一个只有一个依赖项的 Java Servlet，这个依赖项是 Handlebars Java 实现。我们目前不考虑
    MVC 框架。我们的 Servlet 将实例化模板框架，调用内联模板脚本，然后直接返回输出。
- en: 'Here is our servlet:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们的 Servlet：
- en: '[PRE12]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `CompileInlineServlet` class illustrates how to compile a basic Handlers
    template example in the Java code. We will instantiate a Handlebars engine template
    and then compile the template inline, as shown in the following text:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`CompileInlineServlet` 类展示了如何在 Java 代码中编译一个基本的 Handlers 模板示例。我们将实例化一个 Handlebars
    引擎模板，然后按以下文本所示内联编译模板：'
- en: '[PRE13]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'After compilation, we will obtain a `Template` instance that contains the content.
    We will then call the `apply()` method with a simple string and this will serve
    as the context for the template. The `{{this}}` placeholder refers to the context
    object. We will then retrieve the text representation and send the response back
    to the web browser. We will see the following plain text output:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 编译后，我们将获得一个包含内容的 `Template` 实例。然后我们将调用 `apply()` 方法，并使用一个简单的字符串作为模板的上下文。`{{this}}`
    占位符指的是上下文对象。然后我们将检索文本表示并回送给网络浏览器。我们将看到以下纯文本输出：
- en: '[PRE14]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: There are no dependencies in Handlebars Java that tie the framework to Java
    EE. Therefore, it can also be used in Java SE as a standalone Java executable.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Handlebars Java 中没有依赖项将框架绑定到 Java EE。因此，它也可以在 Java SE 中作为一个独立的 Java 可执行文件使用。
- en: Template expressions in Handlebars
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Handlebars 中的模板表达式
- en: 'Here is another example of a Handlebars template with a different context:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是另一个具有不同上下文的 Handlebars 模板示例：
- en: '[PRE15]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The template renders in a DIV layer with a token name substitution with an embedded
    expression. An expression is reserved and activated between the double curly brackets.
    It renders an output for the domain of the trading system. In both Handlebars
    and Mustache notation, the double curly bracket surrounding a variable name denotes
    a placeholder entry. A placeholder entry in a template means that it can be replaced
    with a dynamic content. Therefore, during the template rendering process, the
    `{{title}}` placeholder is replaced with the trade entry headline and the `{{detail}}`
    is replaced with the trade detail. The expression value may be literal strings
    or they could be an embedded HTML5 markup.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 模板在 DIV 层中渲染，带有嵌入表达式的占位符名称替换。一个表达式在双大括号之间保留和激活。它为交易系统的域渲染输出。在 Handlebars 和 Mustache
    语法中，围绕变量名的双大括号表示一个占位符条目。模板中的占位符条目意味着它可以被动态内容替换。因此，在模板渲染过程中，`{{title}}` 占位符被替换为交易条目的标题，而
    `{{detail}}` 被替换为交易详情。表达式值可以是字面量字符串，也可以是嵌入的 HTML5 标记。
- en: 'Let''s write another Java servlet that renders this view using the Handlebars
    framework:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再写一个 Java Servlet，使用 Handlebars 框架渲染这个视图：
- en: '[PRE16]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This `TradeInfoServlet` servlet is almost the same as the previous one, `CompileInlineServlet`;
    but this time, we will utilize the `ServletContextTemplateLoader` class. This
    is a loader class that retrieves the view templates from the Java EE web context
    via the servlet engine. We will create the loader and pass this as an argument
    during the construction of a Handlebar instance. We will then compile a template
    using a reference name, trade. The framework invokes the loader to retrieve the
    view template, which by default is suffixed as `trade.hbs`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `TradeInfoServlet` Servlet 几乎与之前的 `CompileInlineServlet` 相同；但这次，我们将利用 `ServletContextTemplateLoader`
    类。这是一个从 Java EE 网络上下文中通过 Servlet 引擎检索视图模板的加载器类。我们将创建加载器，并在构建 Handlebar 实例时将其作为参数传递。然后，我们将使用参考名称
    trade 编译一个模板。框架调用加载器检索视图模板，默认情况下模板后缀为 `trade.hbs`。
- en: 'We built a literal map collection of the keys and values. They will serve as
    our collection of placeholders in the view, and we will apply them to the template.
    Navigating to the web browser with `http://localhost:8080/handlebars-javaee-mvc-1.0-SNAPSHOT/tradeinfo`
    should display the following screenshot:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们构建了一个键和值的字面量映射集合。它们将作为我们的视图中的占位符集合，并将它们应用到模板中。通过 `http://localhost:8080/handlebars-javaee-mvc-1.0-SNAPSHOT/tradeinfo`
    访问网络浏览器应该显示以下截图：
- en: '![Template expressions in Handlebars](img/image00425.jpeg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![Handlebars 中的模板表达式](img/image00425.jpeg)'
- en: Screenshot of the TradeInfoServlet
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: TradeInfoServlet 的截图
- en: In addition to straightforward replacements, Handlebars supports the `Block`,
    `Partials`, and `Helper` expressions. The Handlebars framework provides the standard
    building blocks; however, engineers can register custom helpers. In the JavaScript
    implementation, developers usually define the compiled script templates in the
    page in order to reuse the content. `Handlebars.js` tends to be used with one
    or the other JavaScript framework such as RequireJS or EmberJS in order to deliver
    reusable content.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 除了直接的替换之外，Handlebars 支持使用 `Block`、`Partials` 和 `Helper` 表达式。Handlebars 框架提供了标准的构建块；然而，工程师可以注册自定义助手。在
    JavaScript 实现中，开发者通常会在页面中定义编译后的脚本模板以便重用内容。`Handlebars.js` 通常与 RequireJS 或 EmberJS
    等一个或多个 JavaScript 框架一起使用，以便提供可重用的内容。
- en: We will proceed to write a CRUD example with Handlebars Java. Our application
    will allow the user to manipulate a basic product catalog. We will need a welcome
    page, so let's create it with the template framework.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续使用 Handlebars Java 编写一个 CRUD 示例。我们的应用程序将允许用户操作一个基本的产品目录。我们需要一个欢迎页面，所以让我们使用模板框架来创建它。
- en: The welcome controller
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 欢迎控制器
- en: 'In the Java port, we do not have to register or compile the templates because
    the page content is delivered from the server side. The project for this is called
    `handlebars-javaee-mvc`. The first thing to do is cause an HTTP redirect in an
    initial JSP, as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 版本中，我们不需要注册或编译模板，因为页面内容是从服务器端提供的。这个项目被称为 `handlebars-javaee-mvc`。首先要做的是在一个初始的
    JSP 中引发一个 HTTP 重定向，如下所示：
- en: '[PRE17]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The preceding code will immediately redirect the web browser to send an HTTP
    GET request to the URI, `handler-javeee-mvc-1.0/rest/welcome`. In this URI path,
    we already have an MVC controller waiting for this invocation:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将立即将网络浏览器重定向到发送一个 HTTP GET 请求到 URI，`handler-javeee-mvc-1.0/rest/welcome`。在这个
    URI 路径中，我们已经有一个 MVC 控制器等待这个调用：
- en: '[PRE18]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: After populating a couple properties in the model instance, the `WelcomeController`
    progresses the response to the Handlebars Java template `/welcomee.hbs`. The absolute
    URI with the forward slash character ensures that the MVC framework searches for
    the page template from the web context root. The suffix extension `*.hbs` is generally
    reserved for the Handlebars view templates in both the client and server editions.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在模型实例中填充了几个属性之后，`WelcomeController` 将响应推进到 Handlebars Java 模板 `/welcomee.hbs`。带有正斜杠字符的绝对
    URI 确保 MVC 框架从 Web 上下文根目录中搜索页面模板。后缀扩展 `*.hbs` 通常在客户端和服务器版本中都保留用于 Handlebars 视图模板。
- en: 'Let''s look at the following Handlebars template (`welcome.hbs`):'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下 Handlebars 模板 (`welcome.hbs`)：
- en: '[PRE19]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Handlebars support the concept of Partials. A partial is a template that is
    used in another template. They are extremely useful for page composition. The
    syntax begins with `{{> NAME }}`, where `NAME` refers to another template. In
    a JavaScript stack, the partials must be registered beforehand; however, the Java
    port knows how to find the partial template by loading them from the servlet container.
    Therefore, the partial template reference, `{{> header }}`, instructs Handlebars
    to load the `header.hbs` view.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: Handlebars 支持部分的概念。部分是用于另一个模板的模板。它们对于页面组成非常有用。语法以 `{{> NAME }}` 开始，其中 `NAME`
    指的是另一个模板。在 JavaScript 堆栈中，部分必须在之前注册；然而，Java 版本知道如何通过从 servlet 容器中加载它们来找到部分模板。因此，部分模板引用
    `{{> header }}` 指示 Handlebars 加载 `header.hbs` 视图。
- en: 'There are four partial templates in the `welcome.hbs` view: `header.hbs`, `navbar.hbs`,
    `footer.hbs`, and `bottom.hbs`. You can examine the source code for these templates
    in this book''s code distribution.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `welcome.hbs` 视图中，有四个部分模板：`header.hbs`、`navbar.hbs`、`footer.hbs` 和 `bottom.hbs`。您可以在本书的代码分发中查看这些模板的源代码。
- en: The custom view engine
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义视图引擎
- en: 'Handlebars Java ships with several template view engines. The default extension
    view engine, unfortunately, does not provide all of the features that we would
    like to use. For one, Handlebars does not render the decimal numbers readily,
    and so, we must register our own function. Luckily, it is reasonable to write
    a view engine extension with CDI, as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: Handlebars Java 随带几个模板视图引擎。不幸的是，默认扩展视图引擎并没有提供我们希望使用的所有功能。例如，Handlebars 并不直接渲染十进制数字，因此我们必须注册自己的函数。幸运的是，使用
    CDI 编写视图引擎扩展是合理的，如下所示：
- en: '[PRE20]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We will annotate our `MyHandlebarsViewEngine` class as an application-scoped
    bean and also ensure that it subclasses `ViewEngineBase` from Ozark. We will inject
    `ServletContext` into this class because we need to retrieve certain properties
    from it such as the web context path.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 `MyHandlebarsViewEngine` 类注释为应用程序范围的 bean，并确保它从 Ozark 继承 `ViewEngineBase`。我们将向这个类注入
    `ServletContext`，因为我们需要从中检索某些属性，例如网络上下文路径。
- en: We will override the `supports()` method so as to establish the support for
    the Handlebars files. The MVC View type is passed as a single argument.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将重写 `supports()` 方法以建立对 Handlebars 文件的支持。MVC 视图类型作为单个参数传递。
- en: The real work happens in the `processView()` method, and we are totally responsible
    for rendering the Handlebars View template. The MVC framework supplies `javax.mvc.engine.ViewEngineContext`,
    which provides access to the current `View` and `Models` instances. We can establish
    the name of the View template that we need to retrieve. From here on, we can create
    the `ServletContextTemplateLoader` and `Handlebars` instances to load a view as
    we saw in the earlier `TradeInfoServlet` class. Then we have to navigate some
    tricky waters a little bit by reading the contents of the current view in a buffer.
    `ViewEngineBase` provides a `resolve()` method that helps us immensely and returns
    `InputStream`. By the way, the Java 7 acquire/resource syntax for the try-catch
    statements reduces the boilerplate code. At the end of the method, we can compile
    the view inline because we have the content in a buffer.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 真正的工作发生在 `processView()` 方法中，我们完全负责渲染 Handlebars 视图模板。MVC 框架提供了 `javax.mvc.engine.ViewEngineContext`，它提供了对当前
    `View` 和 `Models` 实例的访问。我们可以确定需要检索的视图模板的名称。从现在开始，我们可以创建 `ServletContextTemplateLoader`
    和 `Handlebars` 实例来加载视图，就像我们在早期的 `TradeInfoServlet` 类中看到的那样。然后，我们需要通过在缓冲区中读取当前视图的内容来稍微处理一些棘手的问题。`ViewEngineBase`
    提供了一个 `resolve()` 方法，它极大地帮助我们并返回 `InputStream`。顺便说一句，Java 7 的 acquire/resource
    语法简化了 try-catch 语句的样板代码。在方法结束时，由于我们在缓冲区中有内容，我们可以直接编译视图。
- en: We will add a couple of useful features in `MyHandlebarsViewEngine`. First,
    we will add extra properties to the `Models` instance. We will add the web context
    path and request and response objects to the `Models` instance. Second, we will
    register a Handlebars helper in order to better render the BigDecimal types.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 `MyHandlebarsViewEngine` 中添加一些有用的功能。首先，我们将向 `Models` 实例添加额外的属性。我们将添加网络上下文路径以及请求和响应对象到
    `Models` 实例中。其次，我们将注册一个 Handlebars 辅助函数，以便更好地渲染 BigDecimal 类型。
- en: When our application is deployed, Ozark relies on CDI to find the `ViewEngineBase`
    types. Ozark scans the classpath of JAR files and classes to find types of `ViewEengineBase`
    objects. It builds an internal list of available renders. `MyHandlebarsViewEngine`
    is the place presently where you can add additional helpers and utilities in the
    rendering phase. Keep a watch on the MVC specification to see if any of these
    interfaces are exposed in a meaningful public accessible API.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的应用程序部署时，Ozark 依赖于 CDI 来查找 `ViewEngineBase` 类型。Ozark 扫描 JAR 文件和类的类路径以查找 `ViewEengineBase`
    对象的类型。它构建一个可用的渲染内部列表。`MyHandlebarsViewEngine` 是目前可以在渲染阶段添加额外辅助函数和实用工具的地方。请关注 MVC
    规范，看看是否有这些接口以有意义的公共可访问 API 的形式暴露出来。
- en: We will move on to our controller and the product list view.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将转到我们的控制器和产品列表视图。
- en: The product controller
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 产品控制器
- en: 'Our domain object is the humble `Product` entity, which has an outline that
    resembles the following form:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的领域对象是谦逊的 `Product` 实体，其结构类似于以下形式：
- en: '[PRE21]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Note that `Product` takes full advantage of the Bean Validation annotations.
    In particular, it uses a BigDecimal type for the accurate prices and the `@DecimalMin`
    annotation prevents storage negative and zero prices at the bounded context.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`Product` 充分利用了 Bean Validation 注解。特别是，它使用 BigDecimal 类型来精确价格，而 `@DecimalMin`
    注解防止在边界上下文中存储负数和零价格。
- en: 'Given our entity object, we will need `ProductController` to interface the
    domain to the presentation view:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 给定我们的实体对象，我们需要 `ProductController` 来将领域与表示视图接口：
- en: '[PRE22]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: As usual, we will annotate `ProductController` with the JAX-RS annotations in
    order to bring in the RESTful service space. We will be using Bean Validation
    to verify the state of our input objects, and therefore, we will inject `ValidatorFactory`
    from the Java EE container. We will inject the `Models` instance for the MVC operations.
    We also have a custom `FormErrorBean` POJO to capture the error messages, and
    finally, there is an EJB, `ProductService`, to persist the records to a database.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如同往常，我们将使用 JAX-RS 注解注释 `ProductController` 以引入 RESTful 服务空间。我们将使用 Bean Validation
    验证输入对象的状态，因此我们将从 Java EE 容器注入 `ValidatorFactory`。我们将注入 `Models` 实例以进行 MVC 操作。我们还有一个自定义的
    `FormErrorBean` POJO 用于捕获错误消息，最后还有一个 EJB，`ProductService`，用于将记录持久化到数据库中。
- en: 'The `listProducts()` controller method delegates to the shared methods: `retrieveAll()`
    and `defineCommonModelProperties()`. The `retreieveAll()` method pulls all the
    products from the database using the EJB. It saves the list collection in `Models`
    under a known property key. The `defineCommonModelProperties()` method saves a
    title as a key in the same `Models` instance. It turns out that many controller
    methods need the same functionality and so we refactored it. We will place the
    retrieved product collection in a `Models` key property called products. Finally,
    `listProducts()` forwards it to the Handlebars Java view template, `product.hbs`.
    After our controller method is returned, Ozark will eventually delegate to our
    custom view engine: `MyHandlebarsViewEngine`.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`listProducts()` 控制器方法委托给共享方法：`retrieveAll()` 和 `defineCommonModelProperties()`。`retrieveAll()`
    方法使用 EJB 从数据库中检索所有产品。它将列表集合保存在 `Models` 下的一个已知属性键中。`defineCommonModelProperties()`
    方法将标题作为一个键保存在同一个 `Models` 实例中。结果证明，许多控制器方法需要相同的功能，因此我们进行了重构。我们将检索到的产品集合放置在名为 `products`
    的 `Models` 键属性中。最后，`listProducts()` 将其转发到 Handlebars Java 视图模板 `product.hbs`。在我们的控制器方法返回后，Ozark
    最终将委托给我们的自定义视图引擎：`MyHandlebarsViewEngine`。'
- en: Block expressions
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 块表达式
- en: 'We can take a look at the view and learn about the useful block expressions.
    The following is the extract of the view template, `/products.hbs`:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以查看视图并了解有用的块表达式。以下是从视图模板 `/products.hbs` 的摘录：
- en: '[PRE23]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As you can see, we actually used the `{{title}}` expression in this view template,
    which was set in the `defineCommonModelProperties()` method. The value for the
    `{{webContextPath}}` placeholder is set in our extension class, `MyHandlebarsViewEngine`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们实际上在这个视图模板中使用了 `{{title}}` 表达式，该表达式是在 `defineCommonModelProperties()`
    方法中设置的。`{{webContextPath}}` 占位符的值是在我们的扩展类 `MyHandlebarsViewEngine` 中设置的。
- en: 'There are two new expressions: `{{#each}}` and `{{/each}}`. These are the built-in
    block expressions that allow us to loop over a context element. In this case,
    we will iterate over the products. The product element at the heart of the loop
    becomes accessible under the `{{this}}` placeholder.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个新的表达式：`{{#each}}` 和 `{{/each}}`。这些是内置的块表达式，允许我们遍历上下文元素。在这种情况下，我们将遍历产品。循环核心的产品元素可以在
    `{{this}}` 占位符下访问。
- en: In order to print the BigDecimal price correctly, we will invoke the `{{formatDecimal}}`
    helper function that was defined in our custom view engine. A helper function
    can accept more than one parameter. The result is a rendered table of the products
    with their names, descriptions, and prices with the anchor links to edit or delete
    an item.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 为了正确打印 BigDecimal 价格，我们将调用在自定义视图引擎中定义的 `{{formatDecimal}}` 辅助函数。辅助函数可以接受多个参数。结果是渲染的产品表，包括它们的名称、描述和价格，以及编辑或删除项目的锚点链接。
- en: 'Here is the screenshot for the view template, `products.jsp`:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是视图模板 `products.jsp` 的截图：
- en: '![Block expressions](img/image00426.jpeg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![块表达式](img/image00426.jpeg)'
- en: A product listing view template rendered by Handlebars
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 由 Handlebars 渲染的产品列表视图模板
- en: The retrieve and edit operations
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检索和编辑操作
- en: 'Once a customer selects a product to edit, then we will need to retrieve the
    data from the database and push them to a different view template. This is the
    purpose of the preview edit method in the controller, as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦客户选择了一个产品进行编辑，我们就需要从数据库中检索数据并将它们推送到不同的视图模板。这就是控制器中预览编辑方法的目的，如下所示：
- en: '[PRE24]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We will annotate this controller method, `retrieveProduct()`, with `@PathParam`
    in order to retrieve the product ID. With the identifier, we will simply look
    up the `Product` entity and put the result in the request-scoped `Models` property.
    Obviously, for a production application, we would probably be really defensive-minded
    in checking whether the identifier is valid or not. The method progresses the
    final delivery of the response to the view template, `/edit-products.hbs`. The
    source code for the view template is available with this book's source distribution.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`@PathParam`注释这个控制器方法`retrieveProduct()`，以便检索产品ID。有了标识符，我们只需查找`Product`实体并将结果放入请求作用域的`Models`属性中。显然，对于生产应用程序，我们可能会非常谨慎地检查标识符是否有效。方法将响应的最终交付推进到视图模板`/edit-products.hbs`。视图模板的源代码包含在这本书的源代码分发中。
- en: 'We will move on to the next part when the user has submitted the HTML form
    on this page view template. If the customer submits the form, then their journey
    will invoke the next controller method in `ProductController`, which is called
    `editProduct()`:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户在这个页面视图模板上提交HTML表单时，我们将继续到下一部分。如果客户提交表单，那么他们的旅程将调用`ProductController`中的下一个控制器方法，该方法称为`editProduct()`：
- en: '[PRE25]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Our controller method is invoked on the submission of the HTML form and so we
    will annotate it with the necessary `@PathParam` and `@FormParam` declarations
    in order to receive the product ID and properties. Our controller expects a form
    parameter with the `name`, action. The customer may cancel the operation and if
    so the action does not match the `Save` operation. Therefore nothing occurs and
    the method progress the response to the product list view.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的控制方法在HTML表单提交时被调用，因此我们将使用必要的`@PathParam`和`@FormParam`声明来注释它，以便接收产品ID和属性。我们的控制器期望一个带有`name`和`action`的表单参数。客户可以取消操作，如果这样做，则操作不匹配`Save`操作。因此，不会发生任何事情，方法将响应推进到产品列表视图。
- en: With the `Save` action, our method will utilize the injected `ValidatorFactory`
    instance so as to manually validate the form parameters. As the entity product
    has the validation annotations, we will construct a temporary instance with the
    form parameter and then create a validator to check it. We do not directly change
    a persisted entity at this juncture because the data may be invalid. If this is
    the case, then the Java EE container will raise `javax.persistence.RollbackException`
    after the controller method exits because the thread of control passes through
    a transaction barrier. After validating the temporary instance, a collection of
    the `ConstraintViolation` elements is returned.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Save`操作中，我们的方法将利用注入的`ValidatorFactory`实例来手动验证表单参数。因为实体产品有验证注解，所以我们将使用表单参数构建一个临时实例，然后创建一个验证器来检查它。在这个阶段，我们不会直接更改持久化实体，因为数据可能无效。如果是这种情况，那么Java
    EE容器将在控制器方法退出后引发`javax.persistence.RollbackException`，因为控制线程通过了事务屏障。在验证临时实例后，将返回一个`ConstraintViolation`元素的集合。
- en: Let's assume that the form data is invalid. We will retrieve the information
    from the first violation and populate the details in a request scope `FormErrorMessage`
    bean. The form errors are accessible in the view template from the property key,
    `formError`. The controller method then builds a response with the HTTP Bad Request
    error code and then forwards to a view template, `/error.hbs`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 假设表单数据无效。我们将从第一条违规信息中检索信息，并在请求作用域的`FormErrorMessage` bean中填充详细信息。表单错误可以通过视图模板中的属性键`formError`访问。然后，控制器方法构建一个带有HTTP
    Bad Request错误代码的响应，并将其转发到一个视图模板`/error.hbs`。
- en: On the other hand, if the form is valid according to the Bean Validation check,
    then we will proceed to retrieve the `Product` entity from the database by the
    product ID. We will update the `Product` entity from the form properties and then
    save it in the database. As we have already checked the data manually, there should
    not be an error in saving the data. We will build an HTTP OK response and forward
    to the view template, `/products.hbs`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果表单根据Bean Validation检查有效，那么我们将通过产品ID从数据库中检索`Product`实体。我们将从表单属性更新`Product`实体，然后将其保存到数据库中。因为我们已经手动检查了数据，所以在保存数据时不应该出现错误。我们将构建一个HTTP
    OK响应并将其转发到视图模板`/products.hbs`。
- en: Tip
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: At the time of writing this, the MVC specification leads were still developing
    the validation and binding of the parameters post the Early Draft Release of MVC.
    Notably, if a controller injected the `javax.mvc.BindingResult` instance, then
    it would be possible to handle the form validation in a precise and narrow user
    story instead of globally, as in the case of a straight JAX-RS API.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，MVC规范领导仍在开发MVC早期草案发布后的验证和参数绑定。值得注意的是，如果控制器注入了`javax.mvc.BindingResult`实例，那么就可以在精确和狭窄的用户故事中处理表单验证，而不是像直接JAX-RS
    API那样全局处理。
- en: 'To complete the picture, here is the compact version of the `FormErrorMessage`
    bean:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完整地展示，以下是`FormErrorMessage`bean的紧凑版本：
- en: '[PRE26]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This is a request-scoped bean and we will render the information in a Handlebars
    view template, `error.hbs`:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个请求作用域的bean，我们将使用Handlebars视图模板`error.hbs`来显示信息：
- en: '[PRE27]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This view renders the error message in the `FormErrorMessage` bean. You might
    be wondering why we are sending the form validation errors to a separate view.
    The answer is simple: baby steps. In a professional digital application, we would
    take advantage of an AJAX validation and a JavaScript framework such as jQuery
    on the client side. Our client-side JavaScript module would invoke an HTTP POST
    request to an MVC controller method in order to validate the property information.
    This method called, say `validateCheck()`, would check on a temporary instance
    and report with a JSON response containing the constraint violations, if any.
    Perhaps the members of the JSR-371 expert group will ease this part of the development
    for Digital.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这个视图在`FormErrorMessage`bean中显示错误消息。你可能想知道为什么我们将表单验证错误发送到单独的视图。答案很简单：逐步进行。在一个专业的数字应用中，我们会在客户端利用AJAX验证和JavaScript框架，如jQuery。我们的客户端JavaScript模块将调用一个HTTP
    POST请求到MVC控制器方法以验证属性信息。这个方法，比如说`validateCheck()`，会在一个临时实例上检查，并通过包含约束违规的JSON响应报告。也许JSR-371专家组的成员会简化Digital的开发部分。
- en: The JAX-RS global validation
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: JAX-RS全局验证
- en: The problem with the `editProduct()` method is that we are forced to use manual
    validation steps. The only alternative at the moment is to fall back on the JAX-RS
    validation.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`editProduct()`方法的问题在于我们被迫使用手动验证步骤。目前唯一的替代方案是回退到JAX-RS验证。'
- en: 'So, let''s inspect a new version of the controller method called `altEditProduct()`:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们检查一下控制器方法的新版本，称为`altEditProduct()`：
- en: '[PRE28]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This time, we will inscribe the Bean Validation annotations directly on the
    controller method, `altEditProduct()`. You might be concerned that this is duplication,
    with the annotation already on the Entity bean. You would be correct, but let's
    continue. The `altEditMethod()` method is shorter, which is great. There is a
    problem now with this approach in that the validation is delegated globally to
    JAX-RS. If the customer submits an HTML form to `altEditMethod()`, then they will
    send an HTTP Bad Request error response and a user-unfriendly error message direct
    from the application server. Obviously, the UX team would be throwing a fit! What
    can we do?
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们将直接在控制器方法`altEditProduct()`上编写Bean Validation注解。你可能担心这会造成重复，因为注解已经在实体bean上存在。你的担忧是正确的，但让我们继续。`altEditMethod()`方法更短，这很好。现在，这种方法的缺点在于验证被全局委托给了JAX-RS。如果客户向`altEditMethod()`提交HTML表单，那么他们将会收到一个HTTP
    Bad Request错误响应和一个直接从应用服务器发出的用户不友好的错误消息。显然，用户体验团队会非常不满！我们该怎么办？
- en: 'The JAX-RS specification permits an application to provide a handler for an
    error response. The way to achieve this goal is to configure a provider through
    CDI, as follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: JAX-RS规范允许应用程序提供一个错误响应的处理程序。实现这一目标的方法是通过CDI配置一个提供者，如下所示：
- en: '[PRE29]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This `ConstraintViolationExceptionMapper` class is a JAX-RS provider because
    we annotated it with `@javax.ws.rs.ext.Provider`. The class is generically typed
    to `ConstraintViolationException` and therefore, it handles all the failures in
    the web application! There is no leeway here. We will inject into the `HttpServletRequest`
    POJO in order to get access to the web context. The `toResponse()` method transforms
    the constraint violation into a new response. We will need an implementation of
    the `Models` instance, so we will instantiate the class in the Ozark framework.
    We will build a `FormErrorMessage` POJO directly and populate it from the first
    instance of a `javax.validation.ConstraintViolation` type. We will set a key property
    in the `Models` instance and servlet request scope. From here, we will create
    a `Viewable` instance with the view template reference, `error.hbs`, and the `Models`
    instance and then build and return a response.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`ConstraintViolationExceptionMapper`类是一个JAX-RS提供者，因为我们用`@javax.ws.rs.ext.Provider`注解了它。这个类泛型类型化为`ConstraintViolationException`，因此它处理了Web应用程序中的所有失败！这里没有余地。我们将注入到`HttpServletRequest`
    POJO中，以便访问Web上下文。`toResponse()`方法将约束违规转换为新的响应。我们需要`Models`实例的实现，所以我们将在这个Ozark框架中实例化这个类。我们将直接构建一个`FormErrorMessage`
    POJO，并从`javax.validation.ConstraintViolation`类型的第一个实例中填充它。我们将在`Models`实例和servlet请求范围内设置一个键属性。从这里，我们将创建一个带有视图模板引用`error.hbs`和`Models`实例的`Viewable`实例，然后构建并返回一个响应。
- en: 'It is worth looking at some of the internals of the reference implementation,
    Ozark. We have always seen `ViewEngineBase` and `ViewEngineContext`. Here is a
    diagram of some of the important internal classes and their packages:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 值得一看的是参考实现Ozark的一些内部细节。我们一直看到`ViewEngineBase`和`ViewEngineContext`。以下是某些重要内部类及其包的图示：
- en: '![The JAX-RS global validation](img/image00427.jpeg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![JAX-RS全局验证](img/image00427.jpeg)'
- en: An MVC binding result validation
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MVC绑定结果验证
- en: The MVC specification has an API for fine grain validation, which is still being
    decided on. There are two interface types—`BindingResult` and `BindingError`—in
    the `javax.mvc.binding` package.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: MVC规范有一个用于细粒度验证的API，这个API仍在决定中。在`javax.mvc.binding`包中有两种接口类型——`BindingResult`和`BindingError`。
- en: '`BindingResult` captures the constraint violations during an attempt to validate
    the input arguments of an MVC controller method, which is annotated with `@FormParam`.
    The specification describes the term binding to reflect the association between
    the form parameter and actual type of the property that is being validated and
    the possible constraint violations that could occur. Therefore, an integer property
    cannot be bound if the HTML form parameter, which is a string, cannot be converted
    to a number in a meaningful manner. The interface for `BindingResult` is as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`BindingResult`在尝试验证带有`@FormParam`注解的MVC控制器方法的输入参数时捕获约束违规。规范描述了绑定这个术语，以反映表单参数与正在验证的属性的实际情况之间的关联以及可能发生的约束违规。因此，如果HTML表单参数（它是一个字符串）不能以有意义的方式转换为数字，则整数属性不能被绑定。`BindingResult`的接口如下：'
- en: '[PRE30]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The interesting members of `BindingResult` are `isFailed()`, `getAllViolations()`,
    and `getAllBindingErrors()`.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`BindingResult`的有趣成员有`isFailed()`、`getAllViolations()`和`getAllBindingErrors()`。'
- en: 'The `BindingError` type is designed to represent a single error that occurs
    while binding a parameter to a controller method. Here is the condensed interface
    API for this type:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`BindingError`类型是为了表示在将参数绑定到控制器方法时发生的单个错误而设计的。以下是该类型的简化接口API：'
- en: '[PRE31]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The `BindingError` type works similarly to the Bean Validation specification
    for an interpolated message. Therefore, it is helpful for internationalization
    because the messages may be retrieved from `java.util.ResourceBundle`.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`BindingError`类型与Bean Validation规范中的插值消息类似。因此，它对国际化很有帮助，因为消息可以从`java.util.ResourceBundle`检索。'
- en: 'For our final example, we will use `BindingResult` to validate our new `editMethod()`
    method:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的最终示例，我们将使用`BindingResult`来验证我们的新`editMethod()`方法：
- en: '[PRE32]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In order to get the benefit of fine grain validation, we will inject `@BindingResult`
    as a property into `ProductController`. We will change the annotations around
    the `editProduct()` method. In order to ensure that JAX-RS performs the validation
    and the CDI and Bean Validation do not abort the process, we will annotate `@ValidateOnExecution`
    and set the type parameter to `ExecutableType.NONE`. According to the Bean Validation
    specification, the `@ValidateOnExecution` annotation is used to selectively enable
    and disable the violation. Switching off the validation allows JAX RS to take
    over our controller method, `editProduct()`. We will also use `@Valid` and `@BeanParam`
    to direct the MVC provider to validate the `Product` entity bean.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得细粒度验证的好处，我们将`@BindingResult`注入作为属性到`ProductController`中。我们将更改`editProduct()`方法周围的注解。为了确保JAX-RS执行验证而CDI和Bean
    Validation不会终止进程，我们将注解`@ValidateOnExecution`并将类型参数设置为`ExecutableType.NONE`。根据Bean
    Validation规范，`@ValidateOnExecution`注解用于选择性地启用和禁用违规。关闭验证允许JAX RS接管我们的控制器方法，`editProduct()`。我们还将使用`@Valid`和`@BeanParam`来指示MVC提供者验证`Product`实体bean。
- en: MVC takes over the validation when it notices that the controller class has
    injected the `BindingResult` instance or has a JavaBean setter method that accepts
    `BindingResult`. In the `editProduct()` method, we will check the Boolean status
    of the validation by calling the `isFailed()` method. If the input failed to get
    validated, we will grab the first constraint violation from the `BindResult` result
    and then populate the `FormErrorMessage` bean as before. We will then send an
    HTTP response with a Bad Request error code that forwards to the `error.hbs` view
    template.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 当MVC注意到控制器类已注入`BindingResult`实例或有一个接受`BindingResult`的JavaBean设置方法时，它将接管验证。在`editProduct()`方法中，我们将通过调用`isFailed()`方法检查验证的布尔状态。如果输入验证失败，我们将从`BindResult`结果中获取第一个约束违规，然后像以前一样填充`FormErrorMessage`bean。然后我们将发送一个带有Bad
    Request错误代码的HTTP响应，该响应转发到`error.hbs`视图模板。
- en: Note that we will write the `editProduct()` method with a separate named variable
    argument, `incomingProduct`, in order to keep a temporary holder of the HTML form
    data. We will copy the properties of this variable over the product entity that
    is retrieved from the database and save it. By the time we reach the end of the
    controller method, the entity bean must be valid. We will retrieve a list of the
    products and return an OK response. With `BindingResult`, it is clear to the developers
    that this validation is easier to program with. There is less code to deliberate
    over.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们将使用一个单独的命名变量参数`incomingProduct`来编写`editProduct()`方法，以便保持HTML表单数据的临时持有者。我们将复制此变量的属性到从数据库检索的产品实体，并保存它。当我们到达控制器方法末尾时，实体bean必须有效。我们将检索产品列表并返回一个OK响应。使用`BindingResult`，开发人员可以清楚地看到这种验证更容易编程。需要深思熟虑的代码更少。
- en: Design considerations
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计考虑
- en: MVC is a very promising specification, and at the moment, the view technology
    solution is usual for digital developers. There is still a story to be developed
    regarding the handling of an HTTP redirects response and especially a way to hold
    over a form state. Many digital web developers are already familiar with the design
    pattern, HTTP POST– REDIRECT–GET ([https://en.wikipedia.org/wiki/Post/Redirect/Get](https://en.wikipedia.org/wiki/Post/Redirect/Get)),
    and therefore, they would be looking for an equivalent and safe option in the
    MVC specification.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: MVC是一个非常有前途的规范，目前，视图技术解决方案对于数字开发者来说是常见的。关于处理HTTP重定向响应的故事仍然有待开发，特别是关于保持表单状态的方法。许多数字Web开发者已经熟悉设计模式HTTP
    POST– REDIRECT–GET ([https://en.wikipedia.org/wiki/Post/Redirect/Get](https://en.wikipedia.org/wiki/Post/Redirect/Get))，因此，他们会在MVC规范中寻找一个等效且安全的选项。
- en: On the other side of the equation lies the question about an HTML form validation;
    however, there may be breaking news on this front. The story on form validation
    shares much of the ground as HTTP redirect requests. Developers want to take advantage
    of the Bean Validation on an entity but they also want to seamlessly invoke the
    validation in a controller and introspect the validation result. The fact is that
    JAX-RS allows the validation through a global provider. However, this approach
    does not provide fine-grain validation handling and it cannot map constraint violation
    instances to individual HTML form input elements. Nevertheless, the post Early
    Draft Release snapshots have shown early promise in this regard.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在等式的另一边，是关于HTML表单验证的问题；然而，在这个方面可能会有突破性的新闻。关于表单验证的故事与HTTP重定向请求有很多共同点。开发者想要利用实体上的Bean
    Validation，但他们也希望在控制器中无缝调用验证并检查验证结果。事实上，JAX-RS允许通过全局提供者进行验证。然而，这种方法不提供细粒度的验证处理，并且无法将约束违规实例映射到单个HTML表单输入元素。尽管如此，Early
    Draft Release快照在这一点上已经显示出早期的希望。
- en: As we have seen in the Handlebars Java code examples, there is a design consideration
    and trade-off for many digital architects. How much of the presentation logic
    resides in the client against the server side?
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在Handlebars Java代码示例中所看到的，许多数字架构师在设计上有一个考虑和权衡：多少展示逻辑位于客户端与服务器端之间？
- en: Majority server-side templating
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 大多数服务器端模板
- en: 'Considering the option of mostly server-side templating, why would a technical
    architect choose this mode? There are a lot of reasons for this approach. One
    reason may be that the team is slightly intimidated by JavaScript programming
    and wants minimum dependencies and time-to-market. This is a skill, training,
    and maintenance trade-off. Another reason might be that the final end client devices
    are sufficiently underpowered, such as an Internet of Things device. It is unlikely
    that a digital thermostat would have to render retina edition images. Yet another
    reason could be an easier migration for a very old legacy application in order
    to bring it up to date: this is digital transformation. MVC can help here with
    the extensive view templates support.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到主要在服务器端模板化的选项，为什么技术架构师会选择这种模式？这种方法的理由有很多。其中一个原因可能是团队对JavaScript编程有些畏惧，希望最小化依赖和上市时间。这是一个技能、培训和维护的权衡。另一个原因可能是最终端客户设备性能不足，例如物联网设备。一个数字恒温器不太可能需要渲染视网膜版图像。另一个原因可能是为了使非常旧的遗留应用程序更容易迁移以使其更新：这是数字化转型。MVC可以通过广泛的支持视图模板来帮助这里。
- en: Majority client-side templating
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 大多数客户端模板
- en: This design choice implies that the client side renders much of the content
    on a device. It has been said that smartphones with JavaScript and HTML5 have
    orders of magnitude of computing power over the rocket ship computers that took
    humankind to the moon. One reason that a technical architect might want to delegate
    the load to a client is to reduce the load on a server application. This is a
    trade-off in scalability on the server. Handlebars.js is a JavaScript view templating
    implementation that is perfectly adequate for this requirement among the other
    competing JavaScript frameworks out there on the Internet. The MVC controllers
    in this mode become thin layers of architecture that truly bind the view to the
    model. This mode may also be appropriate if your team features very strong interface
    designers and developers or if they have a lack of experience with the modern
    Java EE development. On the UI front, there may be a valid reason to have customer
    journeys that map to a page-by-page navigation. Therefore, the architecture avoids
    single page applications and this might rule out frameworks such as AngularJS.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这个设计选择意味着客户端在设备上渲染了大部分内容。据说，具有JavaScript和HTML5的智能手机在计算能力上比将人类送上月球的那艘火箭船计算机要强大许多个数量级。一个技术架构师可能想要将负载委托给客户端的原因之一是减少服务器应用程序的负载。这是服务器可扩展性上的一个权衡。Handlebars.js是一个JavaScript视图模板实现，在众多互联网上的竞争JavaScript框架中，它完全满足这一需求。在这种模式下，MVC控制器变成了真正将视图绑定到模型上的薄层架构。如果您的团队拥有非常强大的界面设计师和开发者，或者他们缺乏现代Java
    EE开发经验，这种模式可能也是合适的。在UI方面，可能存在一个合理的理由，让客户旅程映射到逐页导航。因此，该架构避免了单页应用程序，这可能会排除AngularJS等框架。
- en: Shared templating
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 共享模板
- en: The final design choice is to combine both the client-side and server-side templating
    and share the responsibility of the presentation view. This may be a favored strategy
    for the digital technical architects working across cross-functional teams. If
    there is a strong interface development team and server-side Java EE team and
    they communicate well, then this is a reasonable approach. Apart from human resource
    considerations in an agile team, this approach technically favors an architecture
    where there is a shared template and vision to organize the digital assets. Let's
    say the architecture is decided on Handlebars Java on the server and Handlebars.js
    on the client-side; the team is immediately faced with the organization of the
    view templates. Which templates are compiled on the JavaScript frontend and which
    templates matter on the server side? The resolution to this design choice will
    result in the construction of the MVC controllers on the server side.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的设计选择是将客户端和服务器端模板相结合，并共享展示视图的责任。这可能是在跨职能团队工作的数字技术架构师所青睐的策略。如果有一个强大的接口开发团队和服务器端Java
    EE团队，并且他们沟通良好，那么这是一个合理的方案。除了敏捷团队中的人力资源考虑之外，这种方案在技术上倾向于一个共享模板和愿景来组织数字资产。假设架构是在服务器端使用Handlebars
    Java，在客户端使用Handlebars.js；团队立即面临的是视图模板的组织。哪些模板在JavaScript前端编译，哪些模板在服务器端重要？对这个设计选择的解决将导致在服务器端构建MVC控制器。
- en: Let me leave you with one note of warning about these three design considerations.
    If you are worth your salt, you will consider the effect of the UX changes and
    sudden surprises. Therefore, a digital technical architect must factor the effect
    of design changes into his or her calculations.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 让我给你们留下关于这三个设计考虑的一个警告。如果你真的称得上是行家里手，你会考虑UX变化和突如其来的惊喜的影响。因此，数字技术架构师必须将设计变化的影响纳入其计算之中。
- en: Summary
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this final chapter of the book, we covered the burgeoning MVC specification
    from the ground up. We covered the essential elements of the models, views, and
    controllers. We saw that MVC is a layering on top of JAX-RS and it reuses the
    same annotations, including `@GET`, `@FormParam`, `@Path`, `@FormParam`, and `@POST`.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书的最后一章中，我们从底层开始介绍了新兴的MVC规范。我们涵盖了模型、视图和控制器的基本元素。我们看到MVC是在JAX-RS之上构建的，并且重用了相同的注解，包括`@GET`、`@FormParam`、`@Path`、`@FormParam`和`@POST`。
- en: In order to establish a method as an MVC controller, we annotated them with
    `@Controller`. We wrote controllers that generate either the response instance
    or, if they returned a void type, we would annotate the method with `@View`.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将一个方法作为MVC控制器，我们用`@Controller`注解了它们。我们编写了生成响应实例的控制器，或者如果它们返回了void类型，我们会用`@View`注解该方法。
- en: You learned about the various view technologies that are supported by the MVC
    reference specification, Ozark. We used the Handlebars Java view template to build
    the elements of a CRUD example. We also understood that the MVC specification
    might change in respect to the redirection and validation APIs.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 你了解了MVC参考规范Ozark支持的多种视图技术。我们使用了Handlebars Java视图模板来构建CRUD示例的元素。我们也了解到MVC规范可能会在重定向和验证API方面发生变化。
- en: Exercises
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: 'Here are the questions and exercises for this chapter:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是本章的问题和练习：
- en: What are the constituent components of the Java EE MVC framework? What does
    MVC attempt to solve?
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Java EE MVC框架的组成部分是什么？MVC试图解决什么问题？
- en: What is the difference between `@Controller`, `@Model`, and `@View`?
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`@Controller`、`@Model`和`@View`之间的区别是什么？'
- en: What is the difference between the Response and Viewable types?
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 响应类型和可视化类型之间有什么区别？
- en: Given that the standard HTML form element does not send an HTTP PUT or DELETE
    request, just how would you handle the removing of a record from the database
    using MVC? What does this mean for the businesses that already have full RESTful
    interfaces?
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于标准的HTML表单元素不支持发送HTTP PUT或DELETE请求，那么在MVC架构中，我们该如何处理从数据库中删除记录的操作呢？这对已经拥有完整RESTful接口的企业意味着什么呢？
- en: By the time this book is published, the MVC framework will be further along
    and there is likely to be many milestone releases. Update your knowledge. What
    has changed? Look especially at the redirection and validation.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 到这本书出版的时候，MVC框架将会有进一步的发展，很可能会出现许多里程碑式的版本。更新你的知识。有什么变化？特别是关注重定向和验证。
- en: Download the `handlebars-javaee-mvc-validation` project from the book's source
    code repository and adapt the product instance in order to include the `description`
    (`string`), `manufacturer` (`string`), and `manufacturedDate` (`java.util.Date`)
    properties. What needs to happen in order to display a formatted date correctly
    (say, MMM-dd-yyyy or dd-MMM-yyyy)?
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从书籍的源代码仓库下载 `handlebars-javaee-mvc-validation` 项目，并调整产品实例以包括 `description`（字符串）、`manufacturer`（字符串）和
    `manufacturedDate`（java.util.Date）属性。为了正确显示格式化的日期（例如，MMM-dd-yyyy 或 dd-MMM-yyyy），需要发生什么？
- en: Working from the previous exercise, ensure that the proper validation techniques
    are in place using MVC. How would you validate the user input?
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从上一个练习开始，确保使用 MVC 模式正确地实施验证技术。你将如何验证用户输入？
- en: 'If you are reasonably comfortable with the JavaScript programming, write a
    module to invoke validation over AJAX. (Hint: you will probably need to understand
    the JQuery REST requests and responses.)'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你合理地熟悉 JavaScript 编程，编写一个模块来通过 AJAX 调用验证。（提示：你可能需要理解 JQuery REST 请求和响应。）
- en: In this exercise, take the `Product` entity and `ProductController` controller
    classes and use them as a basis to experiment with another view template technology
    with the Ozark reference implementation. There are plenty of choices. Adapt a
    new templating framework to the product CRUD application—try Thymeleaf or even
    AsciiDoc. What is the difference between the templating choices? What are the
    benefits? What are the disadvantages?
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个练习中，以 `Product` 实体和 `ProductController` 控制器类为基础，使用它们来实验另一个视图模板技术，例如 Ozark
    的参考实现。有很多选择。将新的模板框架适应到产品 CRUD 应用程序中——尝试 Thymeleaf 或甚至 AsciiDoc。模板选择之间的区别是什么？有什么好处？有什么缺点？
- en: 'Write a short essay that proposes the MVC framework to your current team for
    a particular project. What are the design considerations of the MVC approach?
    Does your target audience suit a single page navigation or page-by-page navigation
    or a mixture of both the ideas? (Hint: personas might be useful; you can write
    a proposal aimed to convince the technical leader in your team or you might be
    a technical leader aiming to convince the members in your team.)'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 写一篇简短的论文，向你的当前团队提出使用 MVC 框架进行特定项目的建议。MVC 方法的设计考虑因素是什么？你的目标受众适合单页导航、逐页导航还是两者的混合？（提示：角色可能很有用；你可以写一个旨在说服你团队中的技术领导或你可能是技术领导，旨在说服团队成员的提案。）
