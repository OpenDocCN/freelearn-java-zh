- en: Chapter 8. JSF 2.2 – HTML5 and Upload
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter can be read in two parts. The first part will present the JSF 2.2
    support for HTML5, while the second part discusses the new **upload** component
    of JSF 2.2\. Apparently, these two parts are not related, but as you will see,
    the upload component of JSF 2.2 can be spiced up with HTML5 features and the new
    pass-through attributes can be very helpful to extend the upload component of
    JSF 2.2 with HTML5 upload component facilities.
  prefs: []
  type: TYPE_NORMAL
- en: Working with HTML5 and JSF 2.2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Everybody involved in web application development is enthusiastic to explore
    and use HTML5, which comes with a suite of new components and features, such as
    `<audio>`, `<video>`, `<keygen>`, and so on. Starting with version 2.2, JSF developers
    can interact with HTML5 using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Pass-through attributes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pass-through elements (HTML-friendly markup)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although pass-through elements and pass-through attributes are inspired by HTML5,
    they are JSF elements that might be used with other HTML versions as well.
  prefs: []
  type: TYPE_NORMAL
- en: These mechanisms are the alternative to writing custom render kits. This is
    a great solution, because HTML5 is in the developing stage, which means that writing
    and adapting render kits to constant HTML5 changes can be a real challenge.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to use HTML5 with JSF 2.0, then you need to write custom render
    kits for supporting the new components and attributes.
  prefs: []
  type: TYPE_NORMAL
- en: Pass-through attributes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Starting with JSF 2.2, we have attributes that are processed by JSF components
    on the server side and **pass-through attributes** that are processed at runtime
    on the client side.
  prefs: []
  type: TYPE_NORMAL
- en: A handy HTML5 element that can be used for exemplifying pass-through attributes
    is the `<input>` element. Among the new supported features, we have new values
    for `type` attribute (such as, `email`, `tel`, `color`, and `reset`) and the new
    attribute, `placeholder` (a text used as a hint in empty fields).
  prefs: []
  type: TYPE_NORMAL
- en: 'In pure HTML5, such an element can be as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The same thing can be obtained with pass-through attributes in five different
    ways:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Place the pass-through attributes in the new namespace `http://xmlns.jcp.org/jsf/passthrough`
    (any JSF developer is familiar with namespaces and prefixed elements. There is
    no trick to use this namespace or prefixed attributes). Let''s see how to obtain
    the preceding HTML5 element using JSF pass-through attributes, as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: When this book was written, there was still a debate about which is the proper
    prefix for this namespace. Initially, `p` was chosen, but this is recognized as
    the prefix of PrimeFaces; therefore, another prefix had to be used. So, when you
    read this book, feel free to replace `f5` (used here) with the one that wins this
    debate and becomes more popular.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Use `<f:passThroughAttribute>` nested in `<h:inputText>`, as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Pass-through attributes might come from a managed bean also. Place them in
    a `Map<String, String>`, where the map key is the attribute name and the map value
    is the attribute value, as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Further, use `<f:passThroughAttributes>` tag, as shown in the following code:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Using Expression Language 3 (part of Java EE 7), multiple attributes can also
    be directly defined, as follows (practically, you define a `Map<String, String>`
    via EL 3):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The complete example is available in the code bundle of this chapter and is
    named `ch8_1`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Pass-through attributes can be added programmatically. For example, you can
    generate an HTML5 input element and add it into a form, as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The complete example is available on the code bundle of this chapter and is
    named `ch8_1_2`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Pass-through elements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'JSF developers hide HTML code behind JSF components. For web designers, the
    JSF code may look pretty strange, but the generated HTML is more familiar. In
    order to alter the generated HTML, web designers have to modify the JSF code,
    which can be difficult for them. But JSF 2.2 comes with friendly markup for HTML5,
    known as **pass-through elements**. Using this feature, web designers can write
    pure HTML code and JSF developers can come over and link the HTML elements to
    the server side by adding/replacing the necessary attributes. JSF recognizes such
    attributes if they are in the [http://xmlns.jcp.org/jsf](http://xmlns.jcp.org/jsf)
    namespace. For example, we can write a JSF page without any JSF tag, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: JSF scans the HTML elements for attributes in the namespace [http://xmlns.jcp.org/jsf](http://xmlns.jcp.org/jsf).
    For such elements, JSF will determine the element type and will add the corresponding
    JSF component instead (`<h:head>` for `<head>` and `<h:inputText>` for `<input>`).
    JSF will add the components in the component tree, which will be rendered as HTML
    code to the client. This JSF component will be linked to the particular element
    and will receive the attributes as "normal" attributes or as pass-through attributes,
    depending on their origins. The correspondence between JSF components and HTML
    elements is available at [http://docs.oracle.com/javaee/7/api/javax/faces/view/facelets/TagDecorator.html](http://docs.oracle.com/javaee/7/api/javax/faces/view/facelets/TagDecorator.html).
    For HTML elements that don't have a direct correspondent (for example `<div>`
    and `<span>`), JSF will create a special component, component-family, such as
    `javax.faces.Panel`, and render-type `javax.faces.passthrough.Element` as detailed
    at [http://docs.oracle.com/javaee/7/javaserverfaces/2.2/vdldocs/facelets/jsf/element.html](http://docs.oracle.com/javaee/7/javaserverfaces/2.2/vdldocs/facelets/jsf/element.html).
  prefs: []
  type: TYPE_NORMAL
- en: The complete example is available in the code bundle of this chapter and is
    named `ch8_1_3`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since JSF replaces the HTML elements with JSF components, we can use these
    components at full capacity, meaning that we can use them as in JSF. For example,
    we can use validators, converters, and `<f:param>`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The complete example is available in the code bundle of this chapter and is
    named `ch8_1_4`.
  prefs: []
  type: TYPE_NORMAL
- en: JSF 2.2 – HTML5 and Bean Validation 1.1 (Java EE 7)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Bean Validation 1.1 (see [http://docs.oracle.com/javaee/7/tutorial/doc/partbeanvalidation.htm](http://docs.oracle.com/javaee/7/tutorial/doc/partbeanvalidation.htm))
    can be the perfect choice for validating user inputs in a JSF 2.2/HTML5 application.
    For example, we can validate the submitted name and surname in `PlayersBean`,
    as follows—we don''t accept null values, empty values, or values shorter than
    three characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'JSF can interpret empty string submitted values as `null` if you set the following
    context parameter in `web.xml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: So in this case, there is no need to use the `<f:validator>` or `validator`
    attribute. Check out the complete application named `ch8_2`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: OmniFaces provides an HTML5 render kit that extends support for HTML5 specific
    attributes. You may want to check it out at [http://showcase.omnifaces.org/](http://showcase.omnifaces.org/).
  prefs: []
  type: TYPE_NORMAL
- en: JSF 2.2 upload feature
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JSF developers have waited a long time for a built-in upload component. Until
    JSF 2.2, the workarounds consisted of using JSF extensions, such as PrimeFaces,
    RichFaces, and third-party libraries such as Apache Commons FileUpload.
  prefs: []
  type: TYPE_NORMAL
- en: 'JSF 2.2 comes with an input component dedicated for upload tasks (that renders
    an HTML `input` element of type `file`). This component is represented by the
    `<h:inputFile>` tag and it can be used as any other JSF component. The entire
    list of supported attributes is available at [http://docs.oracle.com/javaee/7/javaserverfaces/2.2/vdldocs/facelets/h/inputFile.html](http://docs.oracle.com/javaee/7/javaserverfaces/2.2/vdldocs/facelets/h/inputFile.html),
    but the most important ones are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`value`: This represents the file to be uploaded as a `javax.servlet.http.Part`
    object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`required`: This is a Boolean value. If it is `true`, the user must provide
    a value to submit.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`validator`: This indicates a validator for this component.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`converter`: This indicates a converter for this component.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`valueChangeListener`: This indicates a method that will be called when the
    component''s value is changed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `<h:inputFile>` component is based on Servlet 3.0, which is part of Java
    EE since version 6\. Servlet 3.0 provides an upload mechanism based on the `javax.servlet.http.Part`
    interface and the `@MultipartConfig` annotation. A simple Servlet 3.0 for upload
    files looks like the following code—keep in mind this servlet because we will
    use it in the last section of this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you take a quick look over the JSF 2.2 `FacesServlet` source code, you will
    notice that it was annotated with `@MultipartConfig` especially for handling multipart
    data.
  prefs: []
  type: TYPE_NORMAL
- en: If you are not familiar with uploading files using Servlet 3.0, then you can
    try the tutorial at [http://docs.oracle.com/javaee/6/tutorial/doc/glrbb.html](http://docs.oracle.com/javaee/6/tutorial/doc/glrbb.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'On the client side, you can use a `<form>` tag and an HTML5 input of type `file`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Basically, JSF 2.2 upload component is just a wrapper of this example.
  prefs: []
  type: TYPE_NORMAL
- en: A simple JSF 2.2 upload example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we will cover the fundamental steps of a JSF 2.2 upload application.
    Even if this is a simple example, you will see that further examples are based
    on this one. So in order to use the `<h:inputFile>` component, you need to focus
    on the client side and on the server side:'
  prefs: []
  type: TYPE_NORMAL
- en: 'On the client side, we need to perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, the `<h:form>` encoding must be set to multipart/form-data, which will
    help the browser to build the `POST` request accordingly, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Second, the `<h:inputFile>` must be configured to respect your needs, Here,
    we provide a simple case, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Further, you need a button (or a link) to start the upload process, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Optionally, you can add some tags for handling upload messages, as shown in
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'On the server side, we need to perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Usually, the `value` attribute of `<h:inputFile>` contains an EL expression
    of type `#{`*upload_bean.part_object*`}`. If you replace *upload_bean* with `uploadBean`
    and *part_object* with `file`, you will obtain `#{uploadBean.file}`. The `file`
    object is used to store the uploaded data as an instance of `javax.servlet.http.Part`
    in the `UploadBean` bean. All you have to do is to define the `file` property
    in the same manner as any other property, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: The uploaded data can be read through the `getInputStream` method of `Part`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'When the button labeled **Upload** is clicked, the `upload` method is called.
    When this method is called, the `file` object is already populated with the uploaded
    bytes; therefore, you can obtain the data as a stream (use the `getInputStream`
    method) and process it accordingly. For example, you can use the `Scanner` API
    to extract the data into a `String`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The complete application is available in the code bundle of this chapter and
    is named `ch8_3`. In this case, the uploaded data is converted into string and
    displayed in a log; therefore, try to upload readable information, such as plain
    text files.
  prefs: []
  type: TYPE_NORMAL
- en: Using multiple <h:inputFile> elements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you ask yourself whether you can use more than one `<h:inputFile>` element
    in a `<h:form>` form, the answer is yes. Specify an ID for each `<h:inputFile>`
    element and associate it with a unique `Part` instance. In order to use two `<h:inputFile>`
    elements, the `<h:form>` form will change to the following code—you can easily
    extrapolate this example for three, four, or more `<h:inputFile>` elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, on the server side, you need two `Part` instances, defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `upload` method, you need to process both `Part` instances:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Done! The complete application is available in the code bundle of this chapter
    and is named `ch8_4`.
  prefs: []
  type: TYPE_NORMAL
- en: Extracting info about a file to be uploaded
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Filename, size, and content type are the most common types of information needed
    when uploading a file. In JSF, this information is available on both the client
    side and the server side. Let''s consider the following `<h:inputFile>` element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Now you will see how to extract the information about the file selected for
    upload.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the client side, we need to perform either of the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Extracting the filename, size (in bytes), and the content type on the client
    side can be accomplished in a JavaScript function, as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Another approach is to use EL in a JSF page, as follows (of course, this works
    after the file is uploaded):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'On the server side, we need to perform either of the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Extracting the filename, size (in bytes), and the content type on server side
    can be accomplished through several methods of the `Part` interface, as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: If the string returned by this method represents the entire path instead of
    the filename, then you have to isolate the filename as a substring of this string.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The filename can be obtained from the `content-disposition` header as well
    using the following code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'An example of the `content-disposition` header can be seen in the following
    screenshot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Extracting info about a file to be uploaded](img/6466EN_08_01.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: This is very easy to understand if you inspect the `POST` request (you can do
    this with Firebug or any other specialized tool). In the preceding screenshot,
    you can see the relevant chunk of request that is depicted in the `getFileNameFromContentDisposition`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: The complete application is available in the code bundle of this chapter and
    is named `ch8_5`.
  prefs: []
  type: TYPE_NORMAL
- en: Writing uploaded data to a disk
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the previous examples, the uploaded data was converted to `String` and displayed
    on a console. Normally, when you upload a file, you want to save its content on
    a disk in a specific location (let''s say, the `D:\files` folder). For this, you
    can use `FileOutputStream`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you want buffered I/O, then add `BufferedInputStream` and `BufferedOutputStream`
    into your code.
  prefs: []
  type: TYPE_NORMAL
- en: The complete application is available in the code bundle of this chapter and
    is named `ch8_6`. If you prefer to obtain the filename from the `content-disposition`
    header, you better check the application `ch8_7`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another approach consists of using the `Part.write` method. In this case, you
    have to indicate the location where the file should be saved through the `<multipart-config>`
    tag ([http://docs.oracle.com/javaee/7/tutorial/doc/servlets011.htm](http://docs.oracle.com/javaee/7/tutorial/doc/servlets011.htm)).
    Moreover, you can set the maximum file size, request size, and the file size threshold;
    these configurations should be added in `web.xml`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you don't specify a location, the default one will be used. The default location
    is "".
  prefs: []
  type: TYPE_NORMAL
- en: 'The uploaded file will be saved in the indicated location under the name passed
    to the `Part.write` method, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The complete application is available in the code bundle of this chapter and
    is named `ch8_8`.
  prefs: []
  type: TYPE_NORMAL
- en: Upload validator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In most cases, you need to restrict the user upload based on certain constraints.
    Commonly, you will limit the filename length, file size, and file content type.
    For example, you may want to reject the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Files that have names bigger than 25 characters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Files that are not PNG or JPG images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Files that are bigger than 1 MB in size
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For this, you can write a JSF validator, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, add the validator to the `<h:inputFile>` element, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Now, only the files that meet our constraints will be uploaded. For each rejected
    file, you will see an info message that will signal if the filename or its size
    is too big, or whether the file is a PNG or JPG image.
  prefs: []
  type: TYPE_NORMAL
- en: The complete application is available in the code bundle of this chapter and
    is named `ch8_9`.
  prefs: []
  type: TYPE_NORMAL
- en: Ajaxify the upload
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A JSF upload can take advantages of the AJAX mechanism by combining the `<h:inputFile>`
    tag with `<f:ajax>` or the `<h:commandButton>` tag (upload initialization) with
    `<f:ajax>`. In the first case, a common ajaxified upload will look like the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The render attribute should contain the IDs of components to re-render after
    upload. In JSF 2.2.0, you need to use `@all` instead of IDs because there is a
    bug associated that was fixed in the later versions. For example, in JSF 2.2.5
    everything works as expected.
  prefs: []
  type: TYPE_NORMAL
- en: The complete application is available in the code bundle of this chapter and
    is named `ch8_10`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the second case, place `<f:ajax>` in `<h:commandButton>`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The complete application is available in the code bundle of this chapter and
    is named `ch8_11`.
  prefs: []
  type: TYPE_NORMAL
- en: Uploading images with preview
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A nice feature of the upload components is that they allow us to preview images
    before they are uploaded. In the following screenshot, you can see what we will
    develop next:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Uploading images with preview](img/6466EN_08_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: So when the user browses an image, you need to proceed with a behind the scene
    auto AJAX upload, which should cause the user to see the image preview immediately
    after he/she chooses the image from the local machine. The `POST` request generated
    by AJAX will populate the server-side `Part` object (let's call it `file`). When
    AJAX completes, you need to re-render a component capable of displaying an image,
    such as `<h:graphicImage>`. This component will call a servlet using a `GET` request.
    The managed bean responsible with upload should be session scoped; therefore,
    the servlet will be able to extract the bean instance from the session and use
    the `file` object representing the image. Now, the servlet can pass the image
    bytes directly to the response output stream, or create a thumbnail of the image
    and send a small number of bytes. Further, when the user clicks the button that
    initializes the upload, you need to write the file object on the disk.
  prefs: []
  type: TYPE_NORMAL
- en: This is the main idea. Next, you will implement it and spice it up with some
    validation capabilities, a cancel button, and some image information displayed
    next to the preview.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to achieve this, you need to perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Write an auto upload based on AJAX, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'AJAX will call the `validateFile` method. This server-side method is capable
    of validating the filename, length, size, and the content type. The `validateFile`
    method is defined as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If the constraints are violated, then the `resetFile` method is called. This
    is a simple method that resets the file object to its initial state. Moreover,
    it calls the `delete` method, which deletes the underlying storage for the file
    item (including temporary files on the disk).The `resetFile` method is defined
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When the AJAX request is complete, it will re-render the components with IDs:
    `previewImgId`, `imgNameId`, and `uploadMessagesId`. The following code reveals
    the components having the `previewImgId` and `imgNameId` IDs—here the `uploadMessagesId`
    ID corresponds to a `<h:messages>` component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The value of `<h:graphicImage>` accesses `PreviewServlet`. This servlet can
    serve the image for preview through the response output stream. In order to avoid
    the caching mechanism, you need to provide a URL with a random part (the request
    content length can be a convenient choice). This technique will load the correct
    image every time, instead of loading the same image for all requests. The relevant
    part of the servlet is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The preceding code will send all bytes of the uploaded image to the response
    output stream. A common technique consists of scaling down the image to obtain
    a thumbnail that contains a smaller number of bytes. In Java, scaling an image
    can be accomplished in many ways, but a quick approach can be seen in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Further, you add two buttons: one button labeled **Upload** and another one
    labeled **Cancel**. The first one will initialize the upload, and the second one
    will cancel the upload, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When the button labeled **Upload** is clicked, the `saveFileToDisk` method
    will save the uploaded data to the disk, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Done! The complete application, without thumbnail, is available in the code
    bundle of this chapter and is named `ch8_13`. The complete application, with thumbnail,
    is named `ch8_12`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The validation process can be eliminated from the server side and can be accomplished
    on the client side also. Such an example can be found in the code bundle of this
    chapter and is named `ch8_14`. The JavaScript code is pretty straightforward,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Uploading multiple files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By default, JSF 2.2 does not provide support for uploading multiple files,
    but with some adjustments, we can easily achieve this goal. In order to have multiple
    file uploads, you need to focus on two aspects, which are listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Making multiple file selections possible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Uploading all the selected files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Regarding the first task, the multiple selection can be activated using an
    HTML5 input file attribute (`multiple`) and the JSF 2.2 pass-through attribute
    feature. When this attribute is present and its value is set to `multiple`, the
    file chooser can select multiple files. So, this task requires some minimal adjustments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The second task is a little bit tricky, because when multiple files are selected,
    JSF will overwrite the previous `Part` instance with each file in the uploaded
    set. This is normal, since you use an object of type `Part`, but you need a collection
    of `Part` instances. Fixing this issue requires us to focus on the renderer of
    the file component. This renderer is named `FileRenderer` (an extension of `TextRenderer`),
    and the `decode` method implementation is the key for our issue (the bold code
    is very important for us), as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The highlighted code causes the override `Part` issue, but you can easily modify
    it to submit a list of `Part` instances instead of one `Part`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Of course, in order to modify this code, you need to create a custom file renderer
    and configure it properly in `faces-config.xml`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Afterwards, you can define a list of `Part` instances in your bean using the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Each entry in the list is a file; therefore, you can write them on the disk
    by iterating the list using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The complete application is available in the code bundle of this chapter and
    is named `ch8_15`.
  prefs: []
  type: TYPE_NORMAL
- en: Upload and the indeterminate progress bar
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When users upload small files, the process happens pretty fast; however, when
    large files are involved, it may take several seconds, or even minutes, to end.
    In this case, it is a good practice to implement a progress bar that indicates
    the upload status. The simplest progress bar is known as an indeterminate progress
    bar, because it shows that the process is running, but it doesn't provide information
    for estimating the time left or the amount of processed bytes.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to implement a progress bar, you need to develop an AJAX-based upload.
    The JSF AJAX mechanism allows us to determine when the AJAX request begins and
    when it completes. This can be achieved on the client side; therefore, an indeterminate
    progress bar can be easily implemented using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'A possible output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Upload and the indeterminate progress bar](img/6466EN_08_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The complete application is available in the code bundle of this chapter and
    is named `ch8_16`.
  prefs: []
  type: TYPE_NORMAL
- en: Upload and the determinate progress bar
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A determinate progress bar is much more complicated. Usually, such a progress
    bar is based on a listener capable to monitor the transferred bytes (if you have
    worked with Apache Commons' `FileUpload`, you must have had the chance to implement
    such a listener). In JSF 2.2, `FacesServlet` was annotated with `@MultipartConfig`
    for dealing multipart data (upload files), but there is no progress listener interface
    for it. Moreover, `FacesServlet` is declared `final`; therefore, we cannot extend
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Well, the possible approaches are pretty limited by these aspects. In order
    to implement a server-side progress bar, we need to implement the upload component
    in a separate class (servlet) and provide a listener. Alternatively, on the client
    side, we need a custom `POST` request that tricks `FacesServlet` that the request
    is formatted by `jsf.js`.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you will see a workaround based on HTML5 XMLHttpRequest Level
    2 (can upload/download streams as `Blob`, `File`, and `FormData`), HTML5 progress
    events (for upload it returns total transferred bytes and uploaded bytes), HTML5
    progress bar, and a custom Servlet 3.0\. If you are not familiar with these HTML5
    features, then you have to check out some dedicated documentation.
  prefs: []
  type: TYPE_NORMAL
- en: 'After you get familiar with these HTML5 features, it will be very easy to understand
    the following client-side code. First we have the following JavaScript code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Further, we have the upload component that uses the preceding JavaScript code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'A possible output can be seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Upload and the determinate progress bar](img/6466EN_08_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The servlet behind this solution is `UploadServlet` that was presented earlier.
    The complete application is available in the code bundle of this chapter and is
    named `ch8_17`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For multiple file uploads and progress bars, you can extend this example, or
    choose a built-in solution, such as PrimeFaces Upload, RichFaces Upload, or jQuery
    Upload Plugin.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you saw how to exploit HTML5 through JSF 2.2 using the pass-through
    attribute and the pass-through elements techniques. Moreover, in the second part
    of this chapter, you saw how to work with the new JSF 2.2 upload component (simple
    upload, multiple file uploads, upload images with preview, and indeterminate/determinate
    progress bars for upload).
  prefs: []
  type: TYPE_NORMAL
- en: See you in the next chapter, where we will go further with a great feature of
    JSF 2.2, that is, stateless views.
  prefs: []
  type: TYPE_NORMAL
