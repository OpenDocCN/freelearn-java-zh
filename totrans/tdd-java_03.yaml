- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Dispelling Common Myths about TDD
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 消除关于 TDD 的常见神话
- en: '**Test-driven development** (**TDD**) brings many benefits to developers and
    the business. However, it is not always used in real projects. This is something
    I find surprising. TDD has been demonstrated to improve internal and external
    code quality in different industrial settings. It works for frontend and backend
    code. It works across verticals. I have experienced it working in embedded systems,
    web conferencing products, desktop applications, and microservice fleets.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**测试驱动开发**（**TDD**）为开发人员和业务带来了许多好处。然而，它并不总是在实际项目中使用。这让我感到惊讶。TDD 已被证明在不同工业环境中改善了内部和外部代码质量。它适用于前端和后端代码。它适用于各个行业。我亲身体验过它在嵌入式系统、网络会议产品、桌面应用程序和微服务舰队中的工作。'
- en: To better understand how perceptions have gone wrong, let’s review the common
    objections to TDD, then explore how we can overcome them. By understanding the
    perceived difficulties, we can equip ourselves to be TDD advocates and help our
    colleagues reframe their thinking. We will examine six popular myths that surround
    TDD and form constructive responses to them.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解为什么人们的看法出了问题，让我们回顾一下对 TDD 的常见反对意见，然后探讨我们如何克服它们。通过理解感知到的困难，我们可以装备自己成为
    TDD 的倡导者，并帮助我们的同事重新思考。我们将检查围绕 TDD 的六个流行神话，并形成对这些神话的建设性回应。
- en: 'In this chapter, we’re going to cover the following myths:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下神话：
- en: “Writing tests slows me down”
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “编写测试让我慢下来”
- en: “Tests cannot prevent every bug”
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “测试不能防止每一个错误”
- en: “How do you know the tests are right”
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “你怎么知道测试是正确的”
- en: “TDD guarantees good code”
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “TDD 保证编写出好代码”
- en: “Our code is too complex to test”
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “我们的代码太复杂了，无法测试”
- en: “I don’t know what to test until I write the code”
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “我不知道要测试什么，直到我写代码”
- en: Writing tests slows me down
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写测试让我慢下来
- en: Writing tests slowing development down is a popular complaint about TDD. This
    criticism has some merit. Personally, I have only ever felt that TDD has made
    me faster, but academic research disagrees. A meta-analysis of 18 primary studies
    by the *Association for Computing Machinery* showed that TDD did improve productivity
    in academic settings but added extra time in industrial contexts. However, that’s
    not the full story.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 编写测试会减慢开发速度是关于 TDD 的一个常见抱怨。这种批评有一定的道理。就我个人而言，我始终认为 TDD 让我更快，但学术研究并不认同。美国计算机协会（*Association
    for Computing Machinery*）对 18 项主要研究进行的元分析表明，TDD 在学术环境中提高了生产力，但在工业环境中增加了额外的时间。然而，这并不是全部的故事。
- en: Understanding the benefits of slowing down
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解放慢速度的好处
- en: The aforementioned research indicates that the payback for taking extra time
    with TDD is a reduction in the number of defects that go live in the software.
    With TDD, these defects are identified and eliminated far sooner than with other
    approaches. By resolving issues before manual **quality assurance** (**QA**),
    deployment, and release, and before potentially facing a bug report from an end
    user, TDD allows us to cut out a large chunk of that wasted effort.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 上述研究指出，使用 TDD 多花的时间的回报是减少进入软件的缺陷数量。使用 TDD，这些缺陷比其他方法更早地被识别和消除。通过在手动 **质量保证**（**QA**）、部署和发布之前，以及在可能面对最终用户提出的错误报告之前解决这些问题，TDD
    让我们能够削减大量浪费的努力。
- en: 'We can see the difference in the amount of work to be done in this figure:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从这张图中看到要完成的工作量的差异：
- en: '![Figure 3.1 – Not using TDD slows us down due to rework](img/Figure_3.1_B18384.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.1 – 不使用 TDD 会因为返工而减慢我们](img/Figure_3.1_B18384.jpg)'
- en: Figure 3.1 – Not using TDD slows us down due to rework
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.1 – 不使用 TDD 会因为返工而减慢我们
- en: The top row represents developing a feature using TDD, where we have sufficient
    tests to prevent any defects from going into production. The bottom row represents
    developing the same feature in a **code-and-fix** style, without TDD, and finding
    that a defect has gone live in production. Without TDD, we discover faults very
    late, annoy the user, and pay a heavy time penalty in rework. Note that the code-and-fix
    solution *looks* like it gets us into the QA stage faster, until we consider all
    the rework caused by undiscovered defects. The rework is what isn’t taken into
    account in this myth.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 最上面一行表示使用 TDD 开发一个功能，我们有足够的测试来防止任何缺陷进入生产环境。最下面一行表示在没有 TDD 的情况下以 **代码和修复** 的风格开发相同的功能，并发现一个缺陷已经进入生产环境。没有
    TDD，我们很晚才发现错误，让用户感到烦恼，并在返工上付出沉重的时间代价。请注意，代码和修复方案 *看起来* 让我们更快地进入 QA 阶段，直到我们考虑到所有由未发现的缺陷引起的返工。返工正是这个神话中没有考虑到的。
- en: Using TDD, we simply make all our design and testing thinking explicit and upfront.
    We capture and document it using executable tests. Whether we write tests or not,
    we still spend that same thinking time considering what the specifics that our
    code needs to cover are. It turns out that the mechanical writing of the test
    code takes very little time. You can measure that yourself when we write our first
    test in [*Chapter 5*](B18384_05.xhtml#_idTextAnchor092)*, Writing Our First Test*.
    The total time spent writing a piece of code is the time to design it, plus the
    time to write the code, plus the time to test it. Even without writing automated
    tests, the design and coding time remain constant and dominant factors.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 使用TDD，我们只是将我们的设计和测试思考明确化并提前进行。我们通过可执行的测试来捕获和记录它。无论我们是否编写测试，我们仍然会花费相同的时间思考我们的代码需要覆盖的具体细节。结果证明，编写测试代码的机械性写作花费的时间非常少。当我们在[*第五章*](B18384_05.xhtml#_idTextAnchor092)*，编写我们的第一个测试*中编写第一个测试时，你可以亲自测量这一点。编写一段代码所花费的总时间是设计它的时间，加上编写代码的时间，再加上测试它的时间。即使没有编写自动化测试，设计和编码时间仍然是恒定和主导因素。
- en: The other area conveniently ignored through all this is the time taken to manually
    test. Without a doubt, our code will be tested. The only question is when and
    by who. If we write a test first, it is by us, the developers. It happens before
    any faulty code gets checked into our system. If we leave testing to a manual
    testing colleague, then we slow down the whole development process. We need to
    spend time helping our colleague understand what the success criteria are for
    our code. They must then devise a manual test plan, which often must be written
    up, reviewed, and accepted into documentation.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些中，方便地被忽视的一个领域是手动测试所需的时间。毫无疑问，我们的代码将被测试。唯一的问题是何时以及由谁进行测试。如果我们首先编写测试，那么就是由我们，即开发者进行。这发生在任何错误代码被检查到我们的系统之前。如果我们将测试留给手动测试同事，那么就会减慢整个开发过程。我们需要花时间帮助我们的同事理解我们代码的成功标准是什么。然后他们必须制定一个手动测试计划，这通常需要编写、审查和接受到文档中。
- en: Executing manual tests is very time-consuming. Generally, the whole system must
    be built and deployed to a test environment. Databases must be manually set up
    to contain known data. The **user interface** (**UI**) must be clicked through
    to get to a suitable screen where our new code might be exercised. The output
    must be manually inspected and a decision made on its correctness. These steps
    must be manually performed every time we make a change.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 执行手动测试非常耗时。通常，整个系统必须构建并部署到测试环境中。数据库必须手动设置以包含已知数据。**用户界面**（**UI**）必须点击以到达一个合适的屏幕，我们的新代码可能在那里被测试。输出必须手动检查，并对其正确性做出决定。每次我们做出更改时，都必须手动执行这些步骤。
- en: Worse still, the later we leave it to test, the greater the chance is that we
    will have built on top of any faulty code that exists. We cannot know we are doing
    that, as we haven’t tested our code yet. This often becomes difficult to unpick.
    In some projects, we get so far out of step with the main code branch that developers
    start emailing patch files to each other. This means we start building on top
    of this faulty code, making it even harder to remove. These are bad practices
    but they do occur in real projects.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 更糟糕的是，我们越晚进行测试，就越有可能在存在任何错误代码的基础上构建。因为我们还没有测试我们的代码，所以我们无法知道我们在做这件事。这通常很难解开。在一些项目中，我们与主代码分支的差距如此之大，以至于开发者开始互相发送补丁文件。这意味着我们开始在这个错误代码的基础上构建，使其更难移除。这些是不良做法，但它们确实在真实项目中发生。
- en: The contrast to writing a TDD test first could not be greater. With TDD, the
    setup is automated, the steps are captured and automated, and the result checking
    is automated. We are talking timescale reductions of minutes for a manual test
    down to milliseconds using a TDD unit test. This time saving is made every single
    time we need to run that test.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 与先编写TDD测试相比，差异可谓天差地别。在TDD中，设置是自动化的，步骤被捕获并自动化，结果检查也是自动化的。我们谈论的是将手动测试的时间从分钟级减少到毫秒级，使用TDD单元测试。这种时间节省在每次我们需要运行那个测试时都会发生。
- en: 'While manual testing is not as efficient as TDD, there is still one far worse
    option: no testing at all. Having a defect released to production means that we
    leave it to our users to test the code. Here, there may be financial considerations
    and the risk of reputation damage. At the very least, this is a very slow way
    to discover a fault. Isolating the defective lines of code from production logs
    and databases is extraordinarily time-consuming. It is also usually frustrating,
    in my experience.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然手动测试不如TDD高效，但仍然有一个更糟糕的选择：完全没有测试。将缺陷发布到生产意味着我们将代码的测试留给用户。在这里，可能会有财务考虑和声誉损害的风险。至少，这是一个非常缓慢地发现错误的方式。从生产日志和数据库中隔离有缺陷的代码行是非常耗时的。根据我的经验，这通常也是令人沮丧的。
- en: It’s funny how a project that can never find time to write unit tests can *always*
    find time to trawl production logs, roll back released code, issue marketing communications,
    and stop all other work to do a **Priority 1 (P1)** fix. Sometimes, it feels like
    days are easier to find than minutes for some management approaches.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 很有趣，一个永远找不到时间编写单元测试的项目总是能找到时间翻查生产日志、回滚发布代码、发布营销通讯，以及停止所有其他工作来进行**优先级1（P1）**的修复。有时，感觉对于某些管理方法来说，找到一天的时间比找到一分钟的时间还容易。
- en: TDD certainly places a time cost up front in writing a test, but in return,
    we gain fewer faults to rectify in production – with a huge saving in overall
    cost, time, and reputation compared to multiple rework cycles with defects occurring
    in live code.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: TDD确实在编写测试时 upfront 放置了时间成本，但作为回报，我们在生产中需要修正的错误更少——与多次返工周期中在实时代码中出现的缺陷相比，这大大节省了整体成本、时间和声誉。
- en: Overcoming objections to tests slowing us down
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 克服测试让我们减速的反对意见
- en: Build a case that tracks the time spent on undiscovered defects in manual QA
    and failed deployments. Find some rough figures for the time taken for the most
    recent live issue to be fixed. Work out which missing unit test could have prevented
    it. Now work out how long that would have taken to write. Present these figures
    to stakeholders. It can be even more effective to work out the cost of all that
    engineering time and any lost revenue.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 建立一个案例，追踪手动质量保证和失败部署中未发现的缺陷所花费的时间。找出最近一次现场问题修复所需的大致时间。找出哪些缺失的单元测试本可以预防它。现在计算一下编写这些测试需要多长时间。将这些数字呈现给利益相关者。计算出所有这些工程时间以及任何损失的收入可能更加有效。
- en: Knowing that tests do have an overall benefit in terms of fewer defects, let’s
    examine another common objection that tests are of no value, as they cannot prevent
    every bug.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 知道测试在减少缺陷方面确实有整体益处，让我们来审视另一个常见的反对意见，即测试没有价值，因为它们不能预防每一个错误。
- en: Tests cannot prevent every bug
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试无法预防每一个错误
- en: 'A very old objection to testing of any kind is this one: you cannot catch every
    bug. While this is certainly true, if anything, it means that we need more and
    better testing, not less. Let’s understand the motivations behind this one to
    prepare an appropriate response.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 对任何类型的测试的一个非常古老的反对意见是：你不能捕捉到每一个错误。虽然这确实是真的，但如果我们从任何方面来看，这意味着我们需要更多和更好的测试，而不是更少。让我们了解这一点的动机，以便准备一个适当的回应。
- en: Understanding why people say tests cannot catch every bug
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解为什么人们会说测试不能捕捉到每一个错误
- en: Straight away, we can agree with this statement. Tests cannot catch every bug.
    More precisely, it has been proven that testing in software systems can only reveal
    the presence of defects. It can never prove that no defects exist. We can have
    many passing tests, and defects can still hide in the places we haven’t tested.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 立刻，我们可以同意这个说法。测试不能捕捉到每一个错误。更确切地说，已经证明软件系统中的测试只能揭示缺陷的存在。它永远不能证明不存在缺陷。我们可以有很多通过测试，但缺陷仍然可能隐藏在我们没有测试的地方。
- en: This seems to apply in other fields as well. Medical scans will not always reveal
    problems that are too faint to notice. Wind tunnel tests for aircraft will not
    always reveal problems under specific flight conditions. Batch sampling in a chocolate
    factory will not catch every substandard sweet.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这似乎也适用于其他领域。医学扫描并不总是能揭示那些难以察觉的问题。飞机的风洞测试并不总是能在特定的飞行条件下揭示问题。巧克力工厂的批量抽样不会捕捉到每一个不合格的甜食。
- en: 'Just because we cannot catch every bug, does not mean this invalidates our
    testing. Every test we write that catches one defect results in one less defect
    running through our workflow. TDD gives us a process to help us think in terms
    of testing as we develop, but there are still areas where our tests will not be
    effective:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 就因为我们无法捕捉到每个错误，并不意味着这使我们的测试无效。我们编写的每一个测试捕捉到一个缺陷，就会减少一个缺陷在我们的工作流程中运行。TDD给我们提供了一个过程，帮助我们开发时考虑测试，但仍然有一些领域，我们的测试将不会有效：
- en: Tests you have not thought to write
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你没有想到要编写的测试
- en: Defects that arise due to system-level interactions
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于系统级交互而产生的缺陷
- en: Tests that we have not written are a real problem. Even when writing tests first
    in TDD, we must be disciplined enough to write a test for every scenario that
    we want to function. It is easy to write a test and then write the code to make
    it pass. The temptation is to then just keep adding code because we are on a roll.
    It is easy to miss an edge case and so not write a test for it. If we have a missing
    test, we open up the possibility of a defect existing and being found later.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有编写的测试是一个真正的问题。即使在TDD中首先编写测试，我们也必须足够自律，为每个我们希望功能化的场景编写一个测试。编写测试然后编写代码使其通过很容易。诱惑是继续添加代码，因为我们正在顺利地进行。很容易忽略一个边缘情况，因此不为其编写测试。如果我们有一个缺失的测试，我们就会打开一个缺陷存在并被后来发现的可能。
- en: The problem with system-level interactions here refers to the behavior that
    emerges when you take tested units of software and join them. The interactions
    between units can sometimes be more complex than anticipated. Basically, if we
    join up two well-tested things, the new combination itself is still not yet tested.
    Some interactions have faults that only show up in these interactions, even though
    the units that they are made up of passed all tests.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这里系统级交互的问题指的是当你将经过测试的软件单元组合在一起时出现的行为。单元之间的交互有时可能比预期的更复杂。基本上，如果我们把两个经过良好测试的东西组合在一起，新的组合本身还没有经过测试。一些交互有错误，只有在这些交互中才会出现，尽管构成它们的单元已经通过了所有测试。
- en: These two problems are real and valid. Testing will never cover every possible
    fault, but this misses the main value of testing. Every test we *do* write will
    reduce one defect.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个问题是真实且有效的。测试永远无法覆盖所有可能的错误，但这却错过了测试的主要价值。我们编写的每一个测试都会减少一个缺陷。
- en: 'By not testing anything, we will never spot anything wrong. We will not prevent
    any defects. If we test, no matter how little, then we will improve the quality
    of our code. Every defect that these tests can detect will be prevented. We can
    see the straw-man nature of this argument: just because we cannot cover every
    eventuality, it does not mean we should not do what we can.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 通过不进行任何测试，我们永远不会发现任何错误。我们不会防止任何缺陷。如果我们测试，无论测试多少，我们都会提高代码的质量。这些测试可以检测到的每一个缺陷都将被防止。我们可以看到这个论点的稻草人性质：仅仅因为我们不能覆盖所有可能性，并不意味着我们不应该做我们能做的事情。
- en: Overcoming objections to not catching every bug
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 克服无法捕捉到每个错误的反对意见
- en: The way to reframe this is for us to have confidence that TDD prevents many
    classes of errors from happening. Not all kinds of errors, certainly, but a bank
    of thousands of tests is going to make a noticeable improvement to the quality
    of our applications.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 重新审视这个问题的方式是我们对自己有信心，认为TDD可以防止许多类别的错误发生。当然，并不是所有类型的错误，但成千上万的测试库将显著提高我们应用程序的质量。
- en: 'To explain this to our colleagues, we can draw on familiar analogies: just
    because a strong password cannot prevent every hacker, this does not mean we should
    not use passwords and leave ourselves vulnerable to any and *every* hacker. Staying
    healthy will not prevent every kind of medical problem but it will prevent many
    kinds of serious problems.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 为了向我们的同事解释这一点，我们可以借鉴熟悉的类比：仅仅因为一个强大的密码不能阻止每个黑客，这并不意味着我们不应该使用密码，让自己容易受到任何和每个黑客的攻击。保持健康不能防止所有类型的医疗问题，但它可以防止许多严重的医疗问题。
- en: 'Ultimately, this is a question of balance. Zero testing is clearly not enough
    – every single defect will end up going live in this case. We know that testing
    can never eliminate defects. So, where should we stop? What constitutes *enough*?
    We can argue that TDD helps us decide on this balance at the best possible time:
    while we are thinking about writing code. The automated TDD tests we create will
    save us manual QA time. It’s manual work that no longer needs to be done. These
    time and cost savings compound, repaying us in every single iteration of code.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，这是一个平衡的问题。零测试显然是不够的——在这种情况下，每一个缺陷最终都会上线。我们知道测试永远不能消除缺陷。那么，我们应该在哪里停止？什么构成了*足够*？我们可以争论说TDD帮助我们在这个最佳时机决定这个平衡：当我们思考编写代码的时候。我们创建的自动化TDD测试将为我们节省手动QA时间。这是不再需要做的手动工作。这些时间和成本节约在代码的每一次迭代中都会累积，并回报我们。
- en: 'Now that we understand why testing as much as possible always beats not testing
    at all, we can look into the next common objection: how do we know the tests themselves
    were written correctly?'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经理解了为什么尽可能多的测试总是胜过完全不测试，我们可以看看下一个常见的反对意见：我们怎么知道测试本身是正确编写的？
- en: How do you know the tests are right?
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你怎么知道测试是正确的？
- en: This is an objection that has merit, so we need to deeply understand the logic
    behind it. This is a common objection from people unfamiliar with writing automated
    tests, as they misunderstand how we avoid incorrect tests. By helping them see
    the safeguards we put in place, we can help them reframe their thinking.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个有价值的反对意见，因此我们需要深入理解其背后的逻辑。这是来自不熟悉编写自动化测试的人的常见反对意见，因为他们误解了我们如何避免错误的测试。通过帮助他们看到我们实施的保障措施，我们可以帮助他们重新思考。
- en: Understanding the concerns behind writing broken tests
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解编写有缺陷的测试背后的担忧
- en: One objection you will hear is, “*How do we know the tests are right if the
    tests themselves don’t have tests?*” This objection was raised the first time
    I introduced unit tests to a team. It was polarizing. Some of the team understood
    the value right away. Others were indifferent, but some were actively hostile.
    They saw this new practice as suggesting they were somehow deficient. It was perceived
    as a threat. Against that background, one developer pointed out a flaw in the
    logic I had explained.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 你会听到的一个反对意见是，“*如果测试本身没有测试，我们怎么知道测试是正确的呢？*”这个反对意见是在我第一次向团队介绍单元测试时提出的。它是两极分化的。一些团队成员立刻理解了其价值。其他人无动于衷，但有些人则是积极敌对的。他们认为这种新的做法暗示他们有某种缺陷。这被视为一种威胁。在这种背景下，一位开发者指出了我解释的逻辑中的一个缺陷。
- en: 'I told the team that we could not trust our visual reading of production code.
    Yes, we are all skilled at reading code, but we are humans, so we miss things.
    Unit tests would help us avoid missing things. One bright developer asked a great
    question: if visual inspection does not work for production code, why are we saying
    that it *does* work for test code? What’s the difference between the two?'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我告诉团队我们不能相信我们对生产代码的视觉阅读。是的，我们所有人都擅长阅读代码，但我们都是人类，所以我们会错过一些东西。单元测试可以帮助我们避免错过。一位聪明的开发者提出了一个很好的问题：如果视觉检查对生产代码不起作用，为什么我们说它对测试代码*确实*起作用？两者之间有什么区别？
- en: The right illustration for this came after I needed to test some XML output
    (which was in 2005, I remember). The code I had written for checking the XML output
    was truly complex. The criticism was correct. There was no way I could visually
    inspect that test code and honestly say it was without defects.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个问题的正确说明是在我需要测试一些XML输出之后（我记得那是2005年）。我编写的用于检查XML输出的代码确实很复杂。批评是正确的。我无法直观地检查那段测试代码，并诚实地说我没有发现任何缺陷。
- en: So, I applied TDD to the problem. I used TDD to write a utility class that could
    compare two XML strings and report either that they were the same or what the
    first difference was. It could be configured to ignore the order of XML elements.
    I extracted this complex code out of my original test and replaced it with a call
    to this new utility class. I knew the utility class did not have any defects,
    as it passed every TDD test that I had written for it. There were many tests,
    covering every happy path and every edge case I cared about. The original test
    that had been criticized now became very short and direct.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我将TDD应用于这个问题。我使用TDD编写了一个实用类，可以比较两个XML字符串并报告它们是否相同或第一个差异是什么。它可以配置为忽略XML元素的顺序。我将这段复杂的代码从原始测试中提取出来，并用对这个新实用类的调用替换了它。我知道这个实用类没有缺陷，因为它通过了我为它编写的每一个TDD测试。有很多测试，覆盖了我关心的每一个快乐路径和边缘情况。之前受到批评的原始测试现在变得非常简短和直接。
- en: I asked my colleague who had raised the point to review the code. They agreed
    that in this new, simpler form, they were happy to agree that the test was correct,
    visually. They added the caveat “*if the utility class works right*.” Of course,
    we had the confidence that it passed every TDD test we had written it against.
    We were certain that it did all the things we specifically wanted it to do, as
    proven by tests for these things.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我让提出这个观点的同事审查了代码。他们同意，在这个新的、更简单的形式下，他们很高兴同意测试是正确的，从视觉上看。他们补充说，“*如果工具类工作正常的话*。”当然，我们有信心它通过了我们针对它编写的每一个TDD测试。我们确信它做了我们特别想要它做的事情，正如这些事情的测试所证明的那样。
- en: Providing reassurance that we test our tests
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提供我们测试测试的保证
- en: The essence of this argument is that short, simple code can be visually inspected.
    To ensure this, we keep most of our unit tests simple and short enough to reason
    about. Where tests get too complex, we extract that complexity into its own code
    unit. We develop that using TDD and end up making both the original test code
    simple enough to inspect and the test utility simple enough for its tests to inspect,
    a classic example of divide and conquer.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这个论点的本质是，简短、简单的代码可以直观检查。为了确保这一点，我们保持大多数单元测试简单且足够简短，以便进行推理。当测试变得过于复杂时，我们将这种复杂性提取到自己的代码单元中。我们使用TDD来开发它，最终使得原始测试代码足够简单以便检查，测试工具足够简单以便其测试可以检查，这是一个经典的分而治之的例子。
- en: Practically, we invite our colleagues to point out where they feel our test
    code is too complex to trust. We refactor it to use simple utility classes, these
    themselves written using simple TDD. This approach helps us build trust, respects
    the valid concerns of our colleagues, and shows how we can find ways to reduce
    all TDD tests to simple, reviewable code blocks.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们邀请我们的同事指出他们认为我们的测试代码过于复杂而无法信任的地方。我们重构它，使用简单的工具类，这些工具类本身也是使用简单的TDD编写的。这种方法帮助我们建立信任，尊重同事的合理担忧，并展示了我们如何找到方法将所有TDD测试简化为简单、可审查的代码块。
- en: 'Now that we have addressed knowing our tests are right, another common objection
    involves having overconfidence in TDD: that simply following the TDD process will
    therefore guarantee good code. Can that be true? Let’s examine the arguments.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经解决了知道我们的测试是正确的问题，另一个常见的反对意见涉及对TDD过度自信：简单地遵循TDD过程就可以保证优秀的代码。这可能吗？让我们来分析一下这些论点。
- en: TDD guarantees good code
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TDD保证优秀的代码
- en: 'Just as there are often overly pessimistic objections to TDD, here is an opposite
    view: TDD *guarantees* good code. As TDD is a process, and it claims to improve
    code, it is quite reasonable to assume that using TDD is all you need to guarantee
    good code. Unfortunately, that is not at all correct. TDD helps developers write
    good code and it helps as feedback to show us where we have made mistakes in design
    and logic. It cannot guarantee good code, however.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 正如常常有对TDD过度悲观的反对意见一样，这里有一个相反的观点：TDD *保证* 优秀的代码。因为TDD是一个过程，它声称可以改进代码，所以合理地假设使用TDD就是保证优秀代码的全部，这是完全正确的。不幸的是，这并不完全正确。TDD帮助开发者编写优秀的代码，并且作为反馈，它可以帮助我们发现自己的设计和逻辑错误。然而，它并不能保证代码的优秀。
- en: Understanding problem-inflated expectations
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解问题膨胀的期望
- en: The issue here is a misunderstanding. TDD is not a set of techniques that directly
    affect your design decisions. It is a set of techniques that help you specify
    what you expect a piece of code to do, when, under what conditions, and given
    a particular design. It leaves you free to choose that design, what you expect
    it to do, and how you are going to implement that code.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的问题是一个误解。TDD不是一套直接影响你的设计决策的技术。它是一套帮助你指定你期望代码在何时、在什么条件下执行什么操作，以及给定特定设计的技术。它让你自由地选择设计，期望它做什么，以及如何实现这段代码。
- en: TDD has no suggestions regarding choosing a long variable name over a short
    one. It does not tell you whether you should choose an interface or an abstract
    class. Should you choose to split a feature over two classes or five? TDD has
    no advice there. Should you eliminate duplicated code? Invert a dependency? Connect
    to a database? Only you can decide. TDD offers no advice. It is not intelligent.
    *It cannot replace you and your expertise.* It is a simple process, enabling you
    to validate your assumptions and ideas.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: TDD没有关于选择长变量名还是短变量名的建议。它不会告诉你是否应该选择接口或抽象类。你应该将功能拆分到两个类还是五个类中？TDD在这方面没有建议。你应该消除重复代码吗？反转依赖关系？连接到数据库？只有你可以决定。TDD不提供建议。它不是智能的。*它不能取代你和你的专业知识.*
    它是一个简单的流程，使你能够验证你的假设和想法。
- en: Managing your expectations of TDD
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管理你对TDD的期望
- en: TDD is hugely beneficial in my view but we must regard it in context. It provides
    instant feedback on our decisions but leaves every important software design decision
    to us.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: Using TDD, we are free to write code using the **SOLID** principles (which will
    be covered in [*Chapter 7*](B18384_07.xhtml#_idTextAnchor128), *Driving Design
    — TDD and SOLID*, of this book) or we can use a procedural approach, an object-oriented
    approach, or a functional approach. TDD allows us to choose our algorithm as we
    see fit. It enables us to change our minds about how something should be implemented.
    TDD works across every programming language. It works across every vertical.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: Helping our colleagues see past this objection helps them realize that TDD is
    not some magic system that replaces the intelligence and skill of the programmer.
    It harnesses this skill by providing instant feedback on our decisions. While
    this may disappoint colleagues who hoped it would allow perfect code to come from
    imperfect thinking, we can point out that TDD gives us time to think. The advantage
    is that it puts thinking and design up front and central. By writing a failing
    test before writing the production code that makes the test pass, we have ensured
    that we have thought about what that code should do and how it should be used.
    That’s a great advantage.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: Given that we understand that TDD does not design our code for us, yet is still
    a developer’s friend, how can we approach testing complex code?
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: Our code is too complex to test
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Professional developers routinely deal with highly complex code. That’s just
    a fact of life. It leads to one valid objection: our code is too difficult to
    write unit tests for. The code we work on might be highly valuable, trusted legacy
    code that brings in significant top-line revenue. This code may be complex. But
    is it *too* complex to test? Is it true to say that every piece of complex code
    simply cannot be tested?'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the causes of untestable code
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The answer lies in the three ways that code becomes complex and hard to test:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: 'Accidental complexity: We chose a hard way over a simpler way by accident'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: External systems cannot be controlled to set up for our tests
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code is so entangled that we no longer understand it
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accidental complexity makes code hard to read and hard to test. The best way
    to think about this is to know that any given problem has many valid solutions.
    Say we want to add a total of five numbers. We could write a loop. We could create
    five concurrent tasks that take each number, then report that number to another
    concurrent task that computes the total (bear with me, please… I’ve seen this
    happen). We could have a complex design pattern-based system that has each number
    trigger an observer, which places each one in a collection, which triggers an
    observer to add to the total, which triggers an observer every 10 seconds after
    the last input.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: Yes, I know some of those are silly. I just made them up. But let’s be honest
    – what kinds of silly designs have you worked on before? I know I have written
    code that was more complex than it needed to be.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，我知道其中一些很愚蠢。我只是编造了它们。但让我们说实话——你之前工作过哪些愚蠢的设计？我知道我写过比需要的更复杂的代码。
- en: The key point of the addition of five numbers example is that it really should
    use a simple loop. Anything else is accidental complexity, neither necessary nor
    intentional. Why would we do that? There are many reasons. There may be some project
    constraints, a management directive, or simply a personal preference that steers
    our decision. However it happened, a simpler solution was possible, yet we did
    not take it.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 五个数加法示例的关键点是它实际上应该使用一个简单的循环。其他任何东西都是偶然的复杂性，既不必要也不故意。我们为什么会这样做？有许多原因。可能有项目约束、管理指令，或者仅仅是个人偏好影响了我们的决策。无论如何，一个更简单的解决方案是可能的，但我们没有采取。
- en: Testing more complex solutions generally requires more complex tests. Sometimes,
    our team thinks it is not worth spending time on that. The code is complex, it
    will be hard to write tests for, and we think it works already. We think it is
    best not to touch it.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 测试更复杂的解决方案通常需要更复杂的测试。有时，我们团队认为不值得花时间在这上面。代码本身很复杂，编写测试会很困难，而且我们认为它已经可以工作了。我们认为最好不要去动它。
- en: External systems cause problems in testing. Suppose our code talks to a third-party
    web service. It is hard to write a repeatable test for that. Our code consumes
    the external service and the data it sends to us is different each time. We cannot
    write a test and verify what the service sent us, as we do not know what the service
    should be sending to us. If we could replace that external service with some dummy
    service that we could control, then we could fix this problem easily. But if our
    code does not permit that, then we are stuck.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 外部系统在测试中会引起问题。假设我们的代码与第三方网络服务进行交互。为这种情况编写可重复的测试是困难的。我们的代码消耗外部服务，并且它发送给我们的数据每次都不同。我们无法编写测试并验证服务发送给我们的内容，因为我们不知道服务应该发送什么。如果我们能用一个我们可以控制的虚拟服务替换那个外部服务，那么我们可以轻松解决这个问题。但如果我们的代码不允许这样做，那么我们就陷入了困境。
- en: 'Entangled code is a further development of this. To write a test, we need to
    understand what that code does to an input condition: what do we expect the outputs
    to be? If we have a body of code that we simply do not understand, then we cannot
    write a test for it.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 混乱的代码是这一点的进一步发展。为了编写测试，我们需要了解该代码对输入条件做了什么：我们期望输出是什么？如果我们有一段我们根本不理解代码，那么我们就无法为它编写测试。
- en: 'While these three problems are real, there is one underlying cause to them
    all: we allowed our software to get into this state. We could have arranged it
    to only use simple algorithms and data structures. We could have isolated external
    systems so that we could test the rest of the code without them. We could have
    modularized our code so that it was not overly entangled.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这三个问题都是真实的，但它们都有一个根本原因：我们让我们的软件陷入了这种状态。我们可以安排它只使用简单的算法和数据结构。我们可以隔离外部系统，这样我们就可以在没有它们的情况下测试其余的代码。我们可以模块化我们的代码，使其不会过于混乱。
- en: However, how can we persuade our teams with these ideas?
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们如何说服我们的团队接受这些想法呢？
- en: Reframing the relationship between good design and simple tests
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重新审视良好设计和简单测试之间的关系
- en: All the preceding problems relate to making software that works yet does not
    follow good design practices. The most effective way to change this, in my experience,
    is **pair programming** – working together on the same piece of code and helping
    each other find these better design ideas. If pair programming is not an option,
    then code reviews also provide a checkpoint to introduce better designs. Pairing
    is better as by the time you get to code review, it can be too late to make major
    changes. It’s cheaper, better, and faster to prevent poor design than it is to
    correct it.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的前述问题都与制作工作软件但又不遵循良好设计实践有关。根据我的经验，改变这种情况最有效的方法是**结对编程**——在相同的代码上一起工作，并互相帮助找到更好的设计理念。如果结对编程不是一个选择，那么代码审查也可以提供一个检查点来引入更好的设计。结对编程更好，因为当你到达代码审查时，可能已经太晚做重大更改了。预防不良设计比纠正它更便宜、更好、更快。
- en: Managing legacy code without tests
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 没有测试管理遗留代码
- en: We will encounter legacy code without tests that we need to maintain. Often,
    this code has grown to be quite unmanageable and ideally needs replacing, except
    that nobody knows what it does anymore. There may be no written documentation
    or specification to help us understand it. Whatever written material there is
    may be completely outdated and unhelpful. The original authors of the code may
    have moved on to a different team or different company.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: The best advice here is to simply leave this code alone if possible. Sometimes
    though, we need to add features that require that code to be changed. Given that
    we have no existing tests, it is quite likely we will find that adding a new test
    is all but impossible. The code simply is not split up in a way that gives us
    access points to hang a test off.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, we can use the **Characterization Test** technique. We can describe
    this in three steps:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: Run the legacy code, supplying it with every possible combination of inputs.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Record all the outputs that result from each one of these input runs. This output
    is traditionally called the Golden Master.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a Characterization Test that runs the code with all inputs again. Compare
    every output against the captured Golden Master. The test fails if any are different.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This automated test compares any changes that we have made to the code against
    what the original code did. This will guide us as we refactor the legacy code.
    We can use standard refactoring techniques combined with TDD. By preserving the
    defective outputs in the Golden Master, we ensure that we are purely refactoring
    in this step. We avoid the trap of restructuring the code at the same time as
    fixing the bugs. When bugs are present in the original code, we work in two distinct
    phases: first, refactor the code without changing observable behavior. Afterwards,
    fix the defects as a separate task. We never fix bugs and refactor together. The
    Characterization Test ensures we do not accidentally conflate the two tasks.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: We’ve seen how TDD helps tackle accidental complexity and the difficulty of
    changing legacy code. Surely writing a test before production code means we need
    to know what the code looks like before we test it though? Let’s review this common
    objection next.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: I don’t know what to test until I write the code
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A great frustration for TDD learners is knowing what to test without having
    written the production code beforehand. This is another criticism that has merit.
    In this case, once we understand the issue that developers face, we can see that
    the solution is a technique we can apply to our workflow, not a reframing of thinking.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the difficulty of starting with testing
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To an extent, it’s natural to think about how we implement code. It’s how we
    learn, after all. We write `System.out.println("Hello, World!");` instead of thinking
    up some structure to place around the famous line. Small programs and utilities
    work just fine when we write them as linear code, similar to a shopping list of
    instructions.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: We begin to face difficulties as programs get larger. We need help organizing
    the code into understandable chunks. These chunks need to be easy to understand.
    We want them to be self-documenting and it to be easy for us to know how to call
    them. The larger the code gets, the less interesting the insides of these chunks
    are, and the more important the external structure of these chunks – the *outsides*
    – becomes.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: As an example, let’s say we are writing a `TextEditorWidget` class, and we want
    to check the spelling on the fly. We find a library with a `SpellCheck` class
    in it. We don’t care that much about how the `SpellCheck` class works. We only
    care about how we can *use* this class to check the spelling. We want to know
    how to create an object of that class, what methods we need to call to get it
    to do its spellchecking job, and how we can access the output.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: This kind of thinking is the definition of software design – how components
    fit together. It is critical that we emphasize design as code bases grow if we
    want to maintain them. We use encapsulation to hide the details of data structures
    and algorithms inside our functions and classes. We provide a simple-to-use programming
    interface.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: Overcoming the need to write production code first
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: TDD scaffolds design decisions. By writing the test before the production code,
    we are defining how we want the code under test to be created, called, and used.
    This helps us see very quickly how well our decisions are working out. If the
    test shows that creating our object is hard, that shows us that our design should
    simplify the creation step. The same applies if the object is difficult to use;
    we should simplify our programming interface as a result.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: However, how do we cope with the times when we simply do not yet know what a
    reasonable design should be? This situation is common when we either use a new
    library, integrate with some new code from the rest of our team, or tackle a large
    user story.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: To solve this, we use a **spike**, a short section of code that is sufficient
    to prove the shape of a design. We don’t aim for the cleanest code at this stage.
    We do not cover many edge cases or error conditions. We have the specific and
    limited goal of exploring a possible arrangement of objects and functions to make
    a credible design. As soon as we have that, we sketch out some notes on the design
    and then delete it. Now that we know what a reasonable design looks like, we are
    better placed to know what tests to write. We can now use normal TDD to drive
    our design.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: Interestingly, when we start over in this way, we often end up driving out a
    better design than our spike. The feedback loop of TDD helps us spot new approaches
    and improvements.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: We’ve seen how natural it is to want to start implementing code before tests,
    and how we can use TDD and spikes to create a better process. We make decisions
    at the **last responsible moment** – the latest possible time to decide before
    we are knowingly making an irreversible, inferior decision. When in doubt, we
    can learn more about the solution space by using a **spike** – a short piece of
    experimental code designed to learn from and then throw away.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we’ve learned six common myths that prevent teams from using
    TDD and discussed the right approach to reframing those conversations. TDD really
    deserves a much wider application in modern software development than it has now.
    It’s not that the techniques don’t work. TDD simply has an image problem, often
    among people who haven’t experienced its true power.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: In the second part of this book, we will start to put the various rhythms and
    techniques of TDD into practice and build out a small web application. In the
    next chapter, we will start our TDD journey with the basics of writing a unit
    test with the **Arrange-Act-Assert** (**AAA**) **pattern**.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: Questions and answers
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Why is it believed that TDD slows developers down?
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When we don’t write a test, we save the time spent writing the test. What this
    fails to consider is the extra time costs of finding, reproducing, and fixing
    a defect in production.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: Does TDD eliminate human design contributions?
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: No. Quite the opposite. We still design our code using every design technique
    at our disposal. What TDD gives us is a fast feedback loop on whether our design
    choices have resulted in easy-to-use, correct code.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: Why doesn’t my project team use TDD?
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What a fantastic question to ask them! Seriously. See whether any of their objections
    have been covered by this chapter. If so, you can gently lead the conversation
    using the ideas presented.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Characterization_test](https://en.wikipedia.org/wiki/Characterization_test)'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More detail on the Characterization Test technique, where we capture the output
    of an existing software module exactly as-is, with a view to restructuring the
    code without changing any of its behavior. This is especially valuable in older
    code where the original requirements have become unclear, or that has evolved
    over the years to contain defects that other systems now rely on.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '[https://effectivesoftwaredesign.com/2014/03/27/lean-software-development-before-and-after-the-last-responsible-moment/](https://effectivesoftwaredesign.com/2014/03/27/lean-software-development-before-and-after-the-last-responsible-moment/)'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An in-depth look at what deciding at the last responsible moment means for software
    design.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: 'Part 2: TDD Techniques'
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Part 2* introduces the techniques necessary for effective TDD. Along the way,
    we will incrementally build the core logic of a word guessing game, Wordz – writing
    all our tests first.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this part, we will have produced high-quality code by writing
    tests first. The SOLID principles and hexagonal architecture will help us organize
    code into well-engineered building blocks that are easy to test. Test doubles
    will bring external dependencies under our control. We will look at the bigger
    picture of test automation and how the test pyramid, QA engineers, and workflow
    improve our work.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: 'This part has the following chapters:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 4*](B18384_04.xhtml#_idTextAnchor078), *Building an Application Using
    TDD*'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 5*](B18384_05.xhtml#_idTextAnchor092), *Writing Our First Test*'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 6*](B18384_06.xhtml#_idTextAnchor117), *Following the Rhythms of
    TDD*'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 7*](B18384_07.xhtml#_idTextAnchor128), *Driving Design – TDD and
    SOLID*'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 8*](B18384_08.xhtml#_idTextAnchor149), *Test Doubles – Stubs and
    Mocks*'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 9*](B18384_09.xhtml#_idTextAnchor179), *Hexagonal Architecture –
    Decoupling External Systems*'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 10*](B18384_10.xhtml#_idTextAnchor209), *FIRST Tests and the Test
    Pyramid*'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 11*](B18384_11.xhtml#_idTextAnchor234), *How TDD Fits into Quality
    Assurance*'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 12*](B18384_12.xhtml#_idTextAnchor249), *Test First, Test Later,
    Test Never*'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
