<html><head></head><body><div class="chapter" title="Chapter&#xA0;7.&#xA0;Configuring mod_cluster with SSL"><div class="titlepage"><div><div><h1 class="title"><a id="ch07"/>Chapter 7. Configuring mod_cluster with SSL</h1></div></div></div><p>In the previous chapter, we learned how to use SSL with JK (mod_jk). In this chapter, we will check the design of mod_cluster first, and discuss how it can be used with SSL. Then we will learn how to configure the httpd and EAP6 servers so that they can use SSL.</p><p>First, let's check the design of mod_cluster.</p><div class="section" title="The design of mod_cluster"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec41"/>The design of mod_cluster</h1></div></div></div><p>As we have <a id="id289" class="indexterm"/>seen in the last chapter, JK uses the AJP13 protocol between the load balancer and worker nodes. In comparison to JK, mod_cluster allows us to secure its communication channels.</p><p>In design, mod_cluster uses three channels for communication: the advertising channel, the management channel, and the proxy channel. mod_cluster allows us to secure the communication in the management and proxy channels. </p><p>The following is the deployment diagram:</p><div class="mediaobject"><img src="graphics/2432OS_07_01.jpg" alt="The design of mod_cluster"/></div><p>As we can see <a id="id290" class="indexterm"/>from the preceding diagram, SSL communications can be enabled in the following three places:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Communication between users and httpd</li><li class="listitem" style="list-style-type: disc">The mod_cluster management channel communication between httpd and EAP6</li><li class="listitem" style="list-style-type: disc">The mod_cluster proxy channel communication between httpd and EAP6</li></ul></div><p>We learned how to enable SSL communication between users and httpd in the previous chapter. We need to generate a self-signed certificate and configure mod_ssl in httpd to use the certificate. The following is the configuration that we used in the previous chapter:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>SSLEngine on</strong></span>
<span class="strong"><strong>SSLCertificateFile /packt/httpd/certs/lb.crt</strong></span>
<span class="strong"><strong>SSLCertificateKeyFile /packt/httpd/certs/lb.key</strong></span>
</pre></div><p>The preceding configuration is actually for mod_ssl; so, it remains unchanged when we switch our load balancer component from JK to mod_cluster.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note07"/>Note</h3><p>Please check the <code class="literal">mod-cluster-ssl.conf</code> file in this chapter's code.</p></div></div><p>In addition to the pure mod_ssl support of httpd to enable SSL communication between users and httpd, mod_cluster provides additional functions to secure data transmission between the httpd and EAP6 servers. In the following sections, we will have a look at how to enable secure communication for the other two places that are mentioned. First, we'll learn how to enable SSL in the mod_cluster management channel.</p></div></div>
<div class="section" title="Enabling SSL for the mod_cluster management channel"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec42"/>Enabling SSL for the mod_cluster management channel</h1></div></div></div><p>In this<a id="id291" class="indexterm"/> section, <a id="id292" class="indexterm"/>we will learn how to secure the MCMP channel. This means that the MCMP messages will be transferred over SSL.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip17"/>Tip</h3><p>In the mod_cluster documentation, we named the protocol MCMP, which stands for <span class="strong"><strong>Mod-Cluster Management Protocol</strong></span>.</p></div></div><p>In design, mod_cluster uses SSL mutual authentication to secure the MCMP channel<a id="id293" class="indexterm"/>. This means that we must create certificates for both the servers. EAP6 needs to trust the certificate provided by httpd; meanwhile, httpd must trust the certificate from the EAP6 server. So, we need two certificates instead of just one.</p><div class="section" title="An introduction to SSL mutual authentication"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec56"/>An introduction to SSL mutual authentication</h2></div></div></div><p>In the<a id="id294" class="indexterm"/> previous chapter, we created a self-signed certificate for httpd to enable HTTPS communication with users. When users use the web browser to access our website, httpd will provide its certificate <a id="id295" class="indexterm"/>to the web browser. If a user chooses to trust the certificate, the web browser will establish a secure connection with our server. This is called one-way authentication. It means that the user will verify the identity of the website, but the website won't verify the identity of the user.</p><p>Since our certificate is self-signed, the web browser will pop up a warning to tell the user that it cannot verify the identity of this certificate, and the user will need to decide whether to trust it or not. But if our certificate is signed by an authority, the web browser will trust our certificate without any pop-up warning messages. This is because every web browser contains a default list of authorities. The certificates signed by these authorities will be trusted by default.</p><p>For example, I can see the following list of default CAs in my Firefox browser:</p><div class="mediaobject"><img src="graphics/2432OS_07_29.jpg" alt="An introduction to SSL mutual authentication"/></div><p>Firefox will <a id="id296" class="indexterm"/>trust the certificates signed by these authorities only. JDK also contains one such list that<a id="id297" class="indexterm"/> is usually the <code class="literal">$JAVA_HOME/jre/lib/security/cacerts</code> file.</p><p>Now, let's talk about encrypting the communication between httpd and EAP6. First, we will learn about one-way authentication. This scenario is shown in the following diagram:</p><div class="mediaobject"><img src="graphics/2432OS_07_06.jpg" alt="An introduction to SSL mutual authentication"/></div><p>Since EAP6 is running in JVM, it trusts a default list of CAs. Our self-signed certificate is obviously not signed by these authorities; so, by default, EAP6 won't trust it.</p><p>To solve this <a id="id298" class="indexterm"/>problem, we can create an authority ourselves, and sign the certificate using this authority. Then we can place the authority in EAP6 to override the default trust list so that EAP6 trusts the certificate signed by it. This scenario is shown in the following diagram:</p><div class="mediaobject"><img src="graphics/2432OS_07_07.jpg" alt="An introduction to SSL mutual authentication"/></div><p>With the previous method, we can establish a one-way authentication from httpd to EAP6. If we want<a id="id299" class="indexterm"/> to establish a mutual SSL authentication, we need to additionally create a certificate for EAP6, and sign it with myca. Then, we need to configure httpd to put myca in its trust list so that it trusts the EAP6 certificate. The following diagram shows this scenario:</p><div class="mediaobject"><img src="graphics/2432OS_07_09.jpg" alt="An introduction to SSL mutual authentication"/></div><p>As we can see from this diagram, <span class="strong"><strong>httpd</strong></span> will show its certificate to <span class="strong"><strong>EAP6</strong></span>, and <span class="strong"><strong>EAP6</strong></span> will show its certificate to <span class="strong"><strong>httpd.</strong></span> Only then will they trust each other because their certificates are signed by<a id="id300" class="indexterm"/> myca as myca is in their trust list. mod_cluster enforces this mutual SSL authentication. In the following sections, we will learn how to configure httpd and EAP6 properly.</p></div><div class="section" title="Configuring SSL mutual authentication"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec57"/>Configuring SSL mutual authentication</h2></div></div></div><p>As we have <a id="id301" class="indexterm"/>learned <a id="id302" class="indexterm"/>the concepts of SSL mutual authentication, let's now configure our environment to enable it. We need to create the following three certificates:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">One self-signed certificate as the authority. Let's name it <code class="literal">myca.crt</code>.</li><li class="listitem" style="list-style-type: disc">One certificate for httpd, signed by myca. Let's name it <code class="literal">httpd.crt</code>.</li><li class="listitem" style="list-style-type: disc">One certificate for EAP6, signed by myca. Let's name it <code class="literal">eap6.crt</code>.</li></ul></div><p>Let's create them one by one.</p><div class="section" title="Creating a CA certificate"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec22"/>Creating a CA certificate</h3></div></div></div><p>First, we<a id="id303" class="indexterm"/> will create a CA certificate. The term<a id="id304" class="indexterm"/> <span class="strong"><strong>CA</strong></span> stands for <span class="strong"><strong>Certificate Authority</strong></span>; it's actually a self-signed certificate that will be used to sign the other certificates. If one application puts this CA into its trust list, the certificates that are signed by it will be trusted.</p><p>We'll create a self-signed certificate named <code class="literal">myca</code> and use it as our CA. Before we create it, please prepare a directory called <code class="literal">certs</code> and place it appropriately. Since we'll create three certificates along with their key files, it's better to put them together. For me, I'll put it in <code class="literal">/packt/certs</code>.</p><p>Please use the following command to create a self-signed certificate together with its key file:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ opensslreq -new -newkeyrsa -days 365 -x509 -subj "/C=CN/ST=Beijing/L=Beijing/O=Personal/CN=myca" -keyoutmyca.key -out myca.crt</strong></span>
<span class="strong"><strong>Generating a 2048 bit RSA private key</strong></span>
<span class="strong"><strong>..++++++</strong></span>
<span class="strong"><strong>........................++++++</strong></span>
<span class="strong"><strong>writing new private key to 'myca.key'</strong></span>
<span class="strong"><strong>Enter PEM pass phrase: packt000</strong></span>
<span class="strong"><strong>Verifying - Enter PEM pass phrase: packt000</strong></span>
<span class="strong"><strong>-----</strong></span>
</pre></div><p>With the preceding command, I have generated a key pair with its self-signed certificate, and the <code class="literal">CN</code> of this certificate is <code class="literal">myca</code>. We can see this by checking the content of the certificate as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ keytool -printcert -file myca.crt | head -n 2</strong></span>
<span class="strong"><strong>Owner: CN=myca, O=Personal, L=Beijing, ST=Beijing, C=CN</strong></span>
<span class="strong"><strong>Issuer: CN=myca, O=Personal, L=Beijing, ST=Beijing, C=CN</strong></span>
</pre></div><p>As we can see, the <code class="literal">Owner</code> and <code class="literal">Issuer</code> are the same. Now, let's create a certificate for httpd, and sign it with myca.</p></div><div class="section" title="Creating a certificate for httpd"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec23"/>Creating a certificate for httpd</h3></div></div></div><p>As we have the authority<a id="id305" class="indexterm"/> myca now, let's create a certificate for httpd and then sign it with myca. We first need to create a key pair for httpd with the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ openssl genrsa -des3 -out httpd.key 1024</strong></span>
<span class="strong"><strong>Generating RSA private key, 1024 bit long modulus</strong></span>
<span class="strong"><strong>.........++++++</strong></span>
<span class="strong"><strong>..........................................................++++++</strong></span>
<span class="strong"><strong>e is 65537 (0x10001)</strong></span>
<span class="strong"><strong>Enter pass phrase for httpd.key: packt000</strong></span>
<span class="strong"><strong>Verifying - Enter pass phrase for httpd.key: packt000</strong></span>
</pre></div><p>As we can see<a id="id306" class="indexterm"/> from the preceding command, the key file is named <code class="literal">httpd.key</code>. Next, we'll create a certificate related to the key pair; the following command does this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ openssl req -new -key httpd.key -out httpd.csr -subj "/C=CN/ST=Beijing/L=Beijing/O=Personal/CN=httpd"</strong></span>
<span class="strong"><strong>Enter pass phrase for httpd.key: packt000</strong></span>
</pre></div><p>Please note that the <code class="literal">CN</code> value of our certificate is <code class="literal">httpd</code>. As a result of running the previous command, we get the <code class="literal">http.csr</code> file that waits to be signed. Now, we need to use the tools provided by OpenSSL to sign this certificate with myca, but before that we need to set up OpenSSL properly.</p></div><div class="section" title="Setting up OpenSSL"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec24"/>Setting up OpenSSL</h3></div></div></div><p>OpenSSL<a id="id307" class="indexterm"/> has its own workflow for signing the certificate. Please run the following command to set up the working environment for OpenSSL:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ mkdir -p demoCA/newcerts</strong></span>
<span class="strong"><strong>$ touch ./demoCA/index.txt</strong></span>
<span class="strong"><strong>$ touch ./demoCA/serial</strong></span>
<span class="strong"><strong>$ echo "01" &gt; ./demoCA/serial</strong></span>
</pre></div><p>Our signed certificate will be placed in the <code class="literal">newcerts</code> directory and named <code class="literal">01.pem</code>. Please make sure that you have run the previous command from the <code class="literal">certs</code> directory that contains the myca and httpd certificates.</p><p>The next step is to loosen the signing policy in OpenSSL. First, we need to locate the configuration file that OpenSSL is using. Please run the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ openssl ca</strong></span>
<span class="strong"><strong>Using configuration from /etc/pki/tls/openssl.cnf</strong></span>
<span class="strong"><strong>…</strong></span>
</pre></div><p>We can see the location of the configuration file used by OpenSSL from the previous command. Let's open <code class="literal">openssl.cnf</code> and find the <code class="literal">policy_match</code> section. Other than <code class="literal">commonName</code>, we need to change all the items in this section to <code class="literal">optional</code>. The following screenshot lists the details:</p><div class="mediaobject"><img src="graphics/2432OS_07_16.jpg" alt="Setting up OpenSSL"/></div><p>In addition, we <a id="id308" class="indexterm"/>need to change the default directory that OpenSSL will use to sign the certificates; this is done as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>#dir = /etc/pki/CA</strong></span>
<span class="strong"><strong>dir = demoCA</strong></span>
</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note08"/>Note</h3><p>We are changing the OpenSSL defaults merely for testing purposes. In practice, this will loosen the security of the certificates.</p><p>We should always use the default positions for signing certificates and carefully manage their permissions in production environment.</p><p>In addition, a real CA faculty will usually require you to provide a certificate with the valid information that it requires. For example, a requirement could be that your certificate's CN must match your DNS hostname, and your country's name must match your host location.</p></div></div></div><div class="section" title="Signing the httpd.csr file"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec25"/>Signing the httpd.csr file</h3></div></div></div><p>Since we <a id="id309" class="indexterm"/>have set OpenSSL properly, we can now start signing our httpd certificate. Please make sure that you are in the <code class="literal">certs</code> directory, and that it includes a <code class="literal">demoCA</code> directory with the necessary file contents. Please run the following command to sign the httpd certificate:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ openssl ca -in httpd.csr -keyfile myca.key -cert myca.crt</strong></span>
<span class="strong"><strong>Using configuration from /etc/pki/tls/openssl.cnf</strong></span>
<span class="strong"><strong>Enter pass phrase for myca.key: packt000</strong></span>
<span class="strong"><strong>Check that the request matches the signature</strong></span>
<span class="strong"><strong>Signature ok</strong></span>
<span class="strong"><strong>Certificate Details:</strong></span>
<span class="strong"><strong>...</strong></span>
<span class="strong"><strong>Sign the certificate? [y/n]:y</strong></span>
<span class="strong"><strong>1 out of 1 certificate requests certified, commit? [y/n] y</strong></span>
<span class="strong"><strong>Write out database with 1 new entries</strong></span>
<span class="strong"><strong>...</strong></span>
<span class="strong"><strong>Data Base Updated</strong></span>
</pre></div><p>Now, we have signed <code class="literal">httpd.csr</code>; this signed certificate is located in <code class="literal">demoCA/newcerts</code>, and is named <code class="literal">01.pem</code>. Let's check the content of this certificate:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ cat demoCA/newcerts/01.pem</strong></span>
<span class="strong"><strong>Certificate:</strong></span>
<span class="strong"><strong>Issuer: C=CN, ST=Beijing, L=Beijing, O=Personal, CN=myca</strong></span>
<span class="strong"><strong>Subject: CN=httpd, C=CN, ST=Beijing, O=Personal</strong></span>
</pre></div><p>We can see <a id="id310" class="indexterm"/>that the <code class="literal">Subject</code> value is <code class="literal">httpd</code> and the <code class="literal">Issuer</code> value is <code class="literal">myca</code>. So we've used our own CA to sign our certificate. Let's copy this certificate into the <code class="literal">certs</code> directory and rename it to <code class="literal">httpd.crt</code>:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ cpdemoCA/newcerts/01.pem httpd.crt</strong></span>
</pre></div><p>That's all for the httpd certificate. Now, let's work on the EAP6 server, create a certificate for it, and also sign this with myca.</p></div><div class="section" title="Creating a certificate for EAP6"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec26"/>Creating a certificate for EAP6</h3></div></div></div><p>The <a id="id311" class="indexterm"/>processes in the EAP6 server are different; first, we need to use the <code class="literal">keytool</code> command<a id="id312" class="indexterm"/> to create a keystore with a self-signed certificate. Then, we will export the certificate from the keystore, and sign it with myca. Later, we'll import <code class="literal">myca.crt</code> into the keystore to act as a trust authority. So, all the certificates signed by myca will be trusted and accepted by JVM. After that, we'll import the signed EAP6 certificate back to the keystore.</p><p>First, let's create a keystore. The keystore file <code class="literal">eap6.ks</code> will have the default key pair and a self-signed certificate that is related to the key pair. The following is the command for creating the keystore:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ keytool -genkey -keystoreeap6.ks -storepass packt000 -keypass packt000 -keyalg RSA -validity 365 -alias eap6cert -dname "cn=eap6,o=Personal,c=CN,ST=Beijing,L=Beijing"</strong></span>
</pre></div><p>From the preceding command, we can see that the keystore is named <code class="literal">eap6.ks</code>, and the alias of the <a id="id313" class="indexterm"/>certificate is <code class="literal">eap6cert</code>. The <code class="literal">cn</code> field of the certificate has a value of <code class="literal">eap6</code>, and this certificate is self-signed by default. We can check this with the <code class="literal">keytool</code> command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ keytool -list -v -keystore eap6.ks -storepass packt000 -alias eap6cert</strong></span>
<span class="strong"><strong>Alias name: eap6cert</strong></span>
<span class="strong"><strong>...</strong></span>
<span class="strong"><strong>Owner: CN=eap6, O=Personal, C=CN, ST=Beijing, L=Beijing</strong></span>
<span class="strong"><strong>Issuer: CN=eap6, O=Personal, C=CN, ST=Beijing, L=Beijing</strong></span>
<span class="strong"><strong>...</strong></span>
</pre></div><p>Now, let's export <code class="literal">eap6cert</code> for the signing request using the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ keytool -certreq -keyalg RSA -alias eap6cert -file eap6cert.csr -keystoreeap6.ks -storepass packt000</strong></span>
</pre></div><p>With the preceding command, we get the <span class="strong"><strong>Certificate Signing Request</strong></span> (<span class="strong"><strong>CSR</strong></span>) file<a id="id314" class="indexterm"/>, <code class="literal">eap6cert.csr</code>. We need to sign this certificate with myca. The process is exactly the same as it was for the signing of the <code class="literal">httpd.csr</code> file. We need to place <code class="literal">eap6cert.csr</code> in the <code class="literal">certs</code> directory, and we need to reuse the <code class="literal">demoCA</code> directory that is created for signing the httpd certificate. Please note that we don't need to reset the serial number in <code class="literal">./demoCA/serial</code>, and don't delete the httpd certificate <code class="literal">01.pem</code> from the <code class="literal">newcerts</code> directory. OpenSSL will automatically increase the serial number, and the signed EAP6 certificate will be named <code class="literal">02.pem</code>. The following code snippet denotes the signing process:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ opensslca -in eap6cert.csr -keyfilemyca.key -cert myca.crt</strong></span>
<span class="strong"><strong>Using configuration from /etc/pki/tls/openssl.cnf</strong></span>
<span class="strong"><strong>Enter pass phrase for myca.key: packt000</strong></span>
<span class="strong"><strong>Check that the request matches the signature</strong></span>
<span class="strong"><strong>Signature ok</strong></span>
<span class="strong"><strong>Certificate Details:</strong></span>
<span class="strong"><strong>...</strong></span>
<span class="strong"><strong>Sign the certificate? [y/n]:y</strong></span>
<span class="strong"><strong>1 out of 1 certificate requests certified, commit? [y/n]y</strong></span>
<span class="strong"><strong>Write out database with 1 new entries</strong></span>
<span class="strong"><strong>Certificate:</strong></span>
<span class="strong"><strong>...</strong></span>
<span class="strong"><strong>Data Base Updated</strong></span>
</pre></div><p>With this process, the EAP6 certificate is signed and stored in <code class="literal">demoCA/serial/02.pem</code>. Now, let's copy <code class="literal">02.pem</code> to <code class="literal">eap6raw.crt</code>:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ cp demoCA/newcerts/02.pem eap6raw.crt</strong></span>
</pre></div><p>We can check the contents of this certificate as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Issuer: C=CN, ST=Beijing, L=Beijing, O=Personal, CN=myca</strong></span>
<span class="strong"><strong>Subject: CN=eap6, C=CN, ST=Beijing, O=Personal</strong></span>
</pre></div><p>From the <code class="literal">Issuer</code> and <code class="literal">Subject</code> fields, we can see that the certificate is signed. In addition, <a id="id315" class="indexterm"/>we can see the encoded certificate data at the bottom of this file. Let's use the following command to extract the encoded certificate text from <code class="literal">eap6raw.crt</code>:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ grep -A 50 "BEGIN CERTIFICATE" eap6raw.crt</strong></span>
<span class="strong"><strong>-----BEGIN CERTIFICATE-----</strong></span>
<span class="strong"><strong>MIIChTCCAe6gAwIBAgIBAjANBgkqhk...</strong></span>
<span class="strong"><strong>...</strong></span>
<span class="strong"><strong>bzCk0wKoQRWOZ5lCXUfN9OEOnVbYcBXTAQ==</strong></span>
<span class="strong"><strong>-----END CERTIFICATE-----:</strong></span>
</pre></div><p>The Java security library can only read the certificate in the previously encoded format, and doesn't allow any extra text in the certificate file. So, we need to extract the encoded certificate data to another file using the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ grep -A 50 "BEGIN CERTIFICATE" eap6raw.crt &gt;eap6cert.crt</strong></span>
</pre></div><p>With the preceding command, we have extracted the encoded certificate data to <code class="literal">eap6cert.crt</code>; only then can the <code class="literal">keytool</code> command read it correctly. The following is the command to be used:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ keytool -printcert -file eap6cert.crt  | head -n 2</strong></span>
<span class="strong"><strong>Owner: O=Personal, ST=Beijing, C=CN, CN=eap6</strong></span>
<span class="strong"><strong>Issuer: CN=myca, O=Personal, L=Beijing, ST=Beijing, C=CN</strong></span>
</pre></div><p>Now we need to import this signed certificate back to our keystore; the <code class="literal">keytool</code> command will help us to update the self-signed certificate in the keystore with this signed one. Before doing this, we need to import myca into the keystore. Since our EAP6 certificate is signed by myca and our keystore currently doesn't contain myca, it will reject any certificate that is signed by it. The following command imports myca into the keystore:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ keytool -import -v -trustcacerts -alias myca -file myca.crt -keystoreeap6.ks -storepass packt000</strong></span>
<span class="strong"><strong>...</strong></span>
<span class="strong"><strong>Trust this certificate? [no]:  yes</strong></span>
<span class="strong"><strong>Certificate was added to keystore</strong></span>
<span class="strong"><strong>[Storing eap6.ks]</strong></span>
</pre></div><p>Please note the <code class="literal">-trustcacerts</code> option in the preceding command. We use this option to mark <code class="literal">myca</code> as a trusted signing authority. Now we can import the <code class="literal">eap6cert.crt</code> file so that it is accepted by the keystore; we use the following command to do so:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ keytool -import -v -alias eap6cert -file eap6cert.crt -keystoreeap6.ks -storepass packt000</strong></span>
<span class="strong"><strong>Certificate reply was installed in keystore</strong></span>
<span class="strong"><strong>[Storing EAP6.ks]</strong></span>
</pre></div><p>Let's have a look at the certificates in the keystore:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ keytool -list -keystore eap6.ks -storepass packt000</strong></span>
<span class="strong"><strong>Keystore type: JKS</strong></span>
<span class="strong"><strong>Keystore provider: SUN</strong></span>

<span class="strong"><strong>Your keystore contains 2 entries</strong></span>

<span class="strong"><strong>eap6cert, Dec 2, 2013, PrivateKeyEntry,</strong></span>
<span class="strong"><strong>Certificate fingerprint (MD5): …</strong></span>
<span class="strong"><strong>myca, Dec 2, 2013, trustedCertEntry,</strong></span>
<span class="strong"><strong>Certificate fingerprint (MD5): …</strong></span>
</pre></div><p>From the <a id="id316" class="indexterm"/>preceding command output, we can see that there are two entries in the keystore. These two entries have different types: <code class="literal">eap6cert</code> is a <code class="literal">PrivateKeyEntry</code>, which means it is a certificate that can be used for identification, and <code class="literal">myca</code> is a <code class="literal">trustedCertEntry</code>, which means that it is an authority, and all the other certificates signed by it will be trusted.</p><p>We have prepared all the certificates properly. Next, we'll configure httpd and EAP6 so that we can use these certificates properly.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note09"/>Note</h3><p>Please check the code provided with this chapter. In the <code class="literal">certs</code> directory, you can see all of the sample certificates that we've generated in this section.</p></div></div></div></div><div class="section" title="Configuring httpd"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec58"/>Configuring httpd</h2></div></div></div><p>To enable <a id="id317" class="indexterm"/>secure communication in the management channel, we'll need to add several SSL directives to the virtual host that is relative to the surrounding <code class="literal">&lt;VirtualHost&gt;</code>, as shown in the following configuration:</p><div class="informalexample"><pre class="programlisting">&lt;VirtualHost 10.0.1.32:6666&gt;
SSLEngine on
SSLCertificateFile /packt/httpd/certs/httpd.crt
SSLCertificateKeyFile /packt/httpd/certs/httpd.key
SSLCertificateChainFile /packt/httpd/certs/myca.crt
&lt;Directory /&gt;
    Order deny,allow
      Deny from all
      Allow from 10.0.1
&lt;/Directory&gt;
ServerAdvertise on https://10.0.1.32:6666
EnableMCPMReceive
ManagerBalancerNamepacktlb
&lt;/VirtualHost&gt;</pre></div><p>The <code class="literal">httpd.crt</code> file is used by httpd to identify itself, and will be sent to EAP6 for authentication. The <code class="literal">myca.crt</code> file will be used to authenticate the certificate that EAP6 sends to httpd. As we know, the certificate of EAP6 is signed by <code class="literal">myca</code>; so, httpd will trust it.</p><p>That's all that we need to do for the httpd configuration.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note10"/>Note</h3><p>Please check the <code class="literal">mod-cluster-ssl-mcmp.conf</code> configuration in this chapter's code.</p></div></div><p>Now let's configure the EAP6 part.</p></div><div class="section" title="Configuring EAP6"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec59"/>Configuring EAP6</h2></div></div></div><p>In EAP6, <a id="id318" class="indexterm"/>we need to place our certificate and truststore in the configuration file of the <code class="literal">mod_cluster</code> subsystem of <code class="literal">domain.xml</code>. The following are its contents:</p><div class="informalexample"><pre class="programlisting">&lt;subsystem &gt;
  &lt;mod-cluster-config ...&gt;
        ...
&lt;ssl key-alias="eap6cert" password="packt000" certificate-key-file="/packt/certs/eap6.ks" ca-certificate-file="/packt/certs/eap6.ks"/&gt;
  &lt;/mod-cluster-config&gt;
&lt;/subsystem&gt;</pre></div><p>Since both the server certificate <code class="literal">eap6cert</code> and the CA certificate <code class="literal">myca</code> are in the keystore <code class="literal">eap6.ks</code>, we will use them as <code class="literal">certificate-key-file</code> and <code class="literal">ca-certificate-file</code> respectively. EAP6 will show the <code class="literal">eap6cert</code> certificate to httpd, and it will be trusted by httpd because it's signed by myca.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note11"/>Note</h3><p>Please check the <code class="literal">domain-ssl-mcmp.xml</code> file in this chapter's code.</p></div></div><p>At last, we have a very important step left: we need to copy the <code class="literal">eap6.ks</code> keystore on both the master and slave servers, and place it in the position <code class="literal">/packt/certs/eap6.ks</code>, just as we've done in the previous code snippet. Since all the worker nodes are using the configuration from <code class="literal">domain.xml</code>, all the EAP6 servers need this keystore file.</p><p>Finally, all the configurations are done. Now let's test the cluster.</p></div><div class="section" title="Testing the configuration"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec60"/>Testing the configuration</h2></div></div></div><p>To test our configuration,<a id="id319" class="indexterm"/> let's start httpd and two EAP6 servers. Then we can use <code class="literal">cURL</code> to access our cluster:</p><div class="informalexample"><pre class="programlisting">$ curl–k https://172.16.123.1/cluster-demo1/index.jsp
&lt;html&gt;
  &lt;body&gt;
    &lt;h2&gt;Hello World!&lt;/h2&gt;
    
    Hello! The time is now Mon Oct 14 01:52:56 CST 2013
  &lt;/body&gt;
&lt;/html&gt;</pre></div><p>The preceding <a id="id320" class="indexterm"/>code snippet shows that the load balancer is working. If we use Wireshark to monitor the management channel, we can see the SSL protocol in action:</p><div class="mediaobject"><img src="graphics/2432OS_07_25.jpg" alt="Testing the configuration"/></div><p>This verifies that the management channel is secured. If we check the data transmission in the proxy channel, we can see that it is still using the plaintext AJP13 protocol:</p><div class="mediaobject"><img src="graphics/2432OS_07_26.jpg" alt="Testing the configuration"/></div><p>In the following <a id="id321" class="indexterm"/>section, we'll see how to enable SSL in the proxy channel.</p></div></div>
<div class="section" title="Enabling SSL in the proxy channel"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec43"/>Enabling SSL in the proxy channel</h1></div></div></div><p>In this<a id="id322" class="indexterm"/> section, <a id="id323" class="indexterm"/>we'll configure mod_cluster to use HTTPS instead of AJP13 for the proxy channel.</p><p>Since we have prepared the necessary certificates in the previous sections, enabling HTTPS for the proxy channel won't be a difficult task. First, let's check the configuration in the httpd server. We need to add an <code class="literal">SSLProxyEngine On</code> configuration to the virtual host to enable public access:</p><div class="informalexample"><pre class="programlisting">&lt;VirtualHost 172.16.123.1:443&gt;
  ...
SSLProxyEngine On
  ...
&lt;/VirtualHost&gt;</pre></div><p>As we <a id="id324" class="indexterm"/>can see<a id="id325" class="indexterm"/> from the preceding configuration, it tells httpd that we need to use an SSL connection for the proxy channel, and that's all that we need to configure httpd.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note12"/>Note</h3><p>The sample configuration file is <code class="literal">mod-cluster-ssl-full.conf</code>.</p></div></div><p>Now we need to configure the EAP6 server. In <code class="literal">domain.xml</code>, we need to change the mod_cluster connector from <code class="literal">ajp</code> to <code class="literal">https</code>, as shown in the following code snippet:</p><div class="informalexample"><pre class="programlisting">&lt;subsystem &gt;
&lt;!--&lt;mod-cluster-config advertise-socket="mod_cluster" connector="ajp"&gt;--&gt;
&lt;mod-cluster-config advertise-socket="mod_cluster" advertise="true" sticky-session="true" sticky-session-remove="false" sticky-session-force="false" connector="https"&gt;
...
&lt;/mod-cluster-config&gt;
&lt;/subsystem&gt;</pre></div><p>Then, we need to turn off the <code class="literal">ajp</code> connector, and add the <code class="literal">https</code> connector, as follows:</p><div class="informalexample"><pre class="programlisting">&lt;!--&lt;connector name="ajp" protocol="AJP/1.3" scheme="http" socket-binding="ajp" enabled="true"/&gt;--&gt;
&lt;connector name="https" protocol="HTTP/1.1" scheme="https" socket-binding="https" secure="true"&gt;
&lt;ssl name="https" key-alias="eap6cert" 
    password="packt000" 
    certificate-key-file="/packt/certs/eap6.ks" 
    protocol="TLS"
verify-client="false" 
    certificate-file="/packt/certs/eap6.ks" 
ca-certificate-file="/packt/certs/eap6.ks"/&gt;
&lt;/connector&gt;</pre></div><p>Since we are enforcing the SSL connection, we need to turn off the <code class="literal">ajp</code> connector to prevent the others from using this plaintext communication port.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note13"/>Note</h3><p>The sample configuration file is <code class="literal">domain-ssl-full.xml</code>.</p></div></div><p>After restarting the EAP6 server, we can see that the proxy channel starts using HTTPS for communication. <a id="id326" class="indexterm"/>The Wireshark analysis is shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/2432OS_07_28.jpg" alt="Enabling SSL in the proxy channel"/></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec44"/>Summary</h1></div></div></div><p>In this chapter, we learned the different ways to use SSL with mod_cluster. We usually just need to secure the transportation layer for public access, and use plaintext communication between httpd and EAP6 because we protect the worker nodes by placing them in a local network. Please choose a proper solution to meet your requirements. In the next chapter, we will learn how to develop and deploy a distributed project to a cluster.</p></div></body></html>