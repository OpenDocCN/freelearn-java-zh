- en: '1'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Understanding RESTful Core Concepts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The history of web services is a fascinating journey through the evolution of
    the way that systems are built, distributed, and scaled.
  prefs: []
  type: TYPE_NORMAL
- en: Initially, the monolithic approach, which involved developing everything within
    a single application and machine, was the standard architectural method for many
    years. However, the need to divide software into distinct components with separate
    responsibilities has transformed how we design and implement systems.
  prefs: []
  type: TYPE_NORMAL
- en: The need to integrate distributed systems composed of software running on separate
    machines has existed since the early days of computing, and its importance is
    increasing, as the way we develop software is moving from monoliths toward more
    distributed architectures.
  prefs: []
  type: TYPE_NORMAL
- en: The global spread of the Internet, especially the World Wide Web, brought about
    the standardization of communication protocols, such as **Internet Protocol (IP)**
    , **Transmission Control Protocol (TCP)** , and **Hypertext Transfer Protocol
    (HTTP)** . The success of the World Wide Web and its support by different devices,
    operating systems, and applications brought the idea that the infrastructure of
    the web could be used for connecting applications in general. This is when the
    term **web services** was adopted for using web technologies to create APIs.
  prefs: []
  type: TYPE_NORMAL
- en: In this book, you will acquire the knowledge needed to be ready to develop and
    master the creation of RESTful web services, starting from the concepts to full
    implementation, following the best practices in the market.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will prepare you for the rest of your journey in this book, understanding
    what the **Representational State Transfer** ( **REST** ) architecture and RESTful
    API services are, how these terms differ from each other, principles, maturity
    levels, and guidelines, as well as the project you will be creating throughout
    this chapters to implement this knowledge.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Why REST?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Principles of REST architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Levels of a RESTful API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Representing data with **JavaScript Object Notation** ( **JSON** )
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The importance of guidelines for developing REST APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Common REST API use cases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Architecture impact on REST API design
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Alternatives to REST
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why REST?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To understand why REST is the dominating architectural style for most web services,
    we will need to understand what was available before the rise of REST and the
    challenges that made this change so important in the way that distributed services
    are built.
  prefs: []
  type: TYPE_NORMAL
- en: The pre-REST era
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before REST, the web services landscape was dominated by protocols such as **Simple
    Object Access Protocol** ( **SOAP** ) and **Extensible Markup Language–Remote
    Procedure Call** ( **XML-RPC** ). These were powerful but complex standards that
    allowed for detailed communication between clients and servers. However, they
    were often seen as cumbersome due to their verbose nature and the strict requirements
    they imposed on developers.
  prefs: []
  type: TYPE_NORMAL
- en: SOAP, for instance, required developers to write extensive XML documents with
    specific calls and responses. It was notorious for its complexity and difficulty
    in debugging. Similarly, XML-RPC, while simpler than SOAP, still involved significant
    overhead for simple requests and responses (e.g., verbose and complex XML formatting,
    serialization and deserialization, a text-based protocol, and parsing complexity).
    Both SOAP and XML-RPC only used the HTTP protocol as a *transport* and duplicated,
    in their own ways, several features that the protocol offered and that were also
    supported by the existing web infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: To overcome these challenges and improve the way the systems communicated with
    each other, REST was created and has been widely implemented since its inception.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding REST
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**REST** was introduced in 2000 by Dr. Roy Fielding in his doctoral dissertation
    titled *Architectural Styles and the Design of Network-based Software Architectures*
    .'
  prefs: []
  type: TYPE_NORMAL
- en: This architectural style was proposed as a more efficient, flexible, and scalable
    alternative to the existing standards of the time, such as SOAP and XML-RPC.
  prefs: []
  type: TYPE_NORMAL
- en: Dr. Fielding’s dissertation aimed to simplify the way web services were created
    and consumed, leveraging the existing capabilities of the HTTP protocol.
  prefs: []
  type: TYPE_NORMAL
- en: The key principles of REST – **statelessness** , **cacheability** , **uniform
    interface** , and a **client-server architecture** – were designed to make web
    services more intuitive and aligned with the design of the web itself.
  prefs: []
  type: TYPE_NORMAL
- en: We will be covering each one of these principles in detail in the *Principles
    of REST architecture* section.
  prefs: []
  type: TYPE_NORMAL
- en: When we implement the REST architecture into web services, applying all these
    key principles, then we can say that we have a RESTful API. Let us understand
    this difference better in the next session.
  prefs: []
  type: TYPE_NORMAL
- en: Unpacking RESTful
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: RESTful APIs represent an approach to designing web services that adhere to
    the principles of REST, so they are not the same.
  prefs: []
  type: TYPE_NORMAL
- en: While REST provides the theoretical framework for building scalable and interoperable
    systems, RESTful APIs put these principles into practice, enabling developers
    to create robust and flexible APIs that are easy to understand, maintain, and
    extend.
  prefs: []
  type: TYPE_NORMAL
- en: The introduction of RESTful APIs marked a significant shift in web services
    since developers quickly adopted REST due to its simplicity and the way it facilitated
    the development of scalable and performant web applications. RESTful APIs became
    the backbone of web communication, powering everything from social media platforms
    to e-commerce sites.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a clear understanding of REST and RESTful, let’s dive deep
    into the principles of REST architecture. This will give us a clearer understanding
    of its key principles and how to achieve them.
  prefs: []
  type: TYPE_NORMAL
- en: Principles of REST architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up to this point, we have only mentioned the key principles of REST. Let us
    dive deeper to understand these principles in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Uniform interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The **uniform interface** is the cornerstone of any REST design, promoting
    a standardized way of interacting with a given set of resources. This principle
    encompasses four key constraints:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Identification of resources** : Each resource, whether it is a document,
    image, or service, is identified using a unique **uniform resource identifier**
    ( **URI** )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Manipulation of resources via representations** : When a client possesses
    a representation of a resource, along with any attached metadata, it can modify
    or delete the resource on the server if it has the necessary permissions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Self-descriptive messages** : Each message contains enough information to
    describe how to process it, which may include the representation format and the
    desired state transitions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Hypermedia as the engine of application state (HATEOAS)** : Clients interact
    with a RESTful service entirely through hypermedia provided dynamically by application
    servers – a concept known as HATEOAS'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Example** : Imagine a library system where each book is a *resource* identified
    by an ISBN number (URI). When you want to borrow a book, you get a *representation*
    (a card with book details), which you use to check out the book. The library’s
    checkout system tells you how to proceed (using *self-descriptive* messages),
    and the catalog guides you to related resources ( *HATEOAS* ), such as the author’s
    other books.'
  prefs: []
  type: TYPE_NORMAL
- en: Client-server separation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This principle enforces the separation of concerns by dividing the user interface
    concerns from the data storage concerns. This separation allows the client and
    server components to evolve independently, leading to a more flexible and scalable
    application architecture.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.1 – Client-server diagram](img/B21843_01_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.1 – Client-server diagram
  prefs: []
  type: TYPE_NORMAL
- en: '**Example** : A user submits a form on a website with their data to finalize
    a checkout (client sending the request); this will be JSON using the `POST` HTTP
    verb and will be received by the server. The server will receive the data, create
    this new resource with the customer data, store the customer data, place a new
    order, and return the appropriate response to the user.'
  prefs: []
  type: TYPE_NORMAL
- en: Statelessness
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In a RESTful service, each request from a client to a server must contain all
    the information the server needs to fulfill the request. The server does not store
    any session state about the client, which means that each request is independent
    and isolated.
  prefs: []
  type: TYPE_NORMAL
- en: '**Example** : Each time you order a coffee at a café, you provide your full
    order details. The barista does not need to remember your previous orders; they
    just make the coffee based on the current order alone.'
  prefs: []
  type: TYPE_NORMAL
- en: Cacheability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Responses must, implicitly or explicitly, define themselves as cacheable or
    not. This helps improve the network’s efficiency by reducing client-server interactions
    for frequently requested resources.
  prefs: []
  type: TYPE_NORMAL
- en: Note that caching brings the risk that the client may see an outdated version
    of the resource, especially if the resource changes frequently. However, we often
    accept the risk in exchange for better performance.
  prefs: []
  type: TYPE_NORMAL
- en: '**Example** : A resource requested thousands of times per day is eligible for
    caching since this will drastically reduce the usage of **database** ( **DB**
    ) resources and improve the response time.'
  prefs: []
  type: TYPE_NORMAL
- en: Layered system
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A RESTful architecture may consist of layered hierarchies, which can include
    load balancers, caches, or authentication gateways. This layered system ensures
    that a client cannot ordinarily tell whether it is connected directly to the end
    server or to an intermediary along the way. The layered system is one of the key
    constraints of the RESTful architecture and it offers several benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Modularity** : The layered system allows you to organize your application
    into logical layers, each with a specific role and responsibility. This makes
    the system easier to understand, develop, and maintain.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Separation of concerns** : Each layer can focus on its own tasks. For example,
    an authentication layer can handle all aspects of authentication and nothing else.
    This separation of concerns leads to cleaner, more maintainable code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Interchangeability** : If a layer is designed and implemented in a modular
    way, it can be replaced or upgraded without affecting other layers. This is particularly
    useful when you want to update or improve a specific part of the system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scalability** : You can scale different layers independently based on their
    individual load and performance requirements. For example, if your application
    layer is experiencing heavy load, you can add more servers to that layer without
    having to scale your database layer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Security** : By segregating the system into layers, you can apply appropriate
    security controls to each layer. For example, you can put a firewall between layers
    to control traffic and protect sensitive layers from potential attacks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Example** : When you send a letter, it goes through various postal offices
    (layers) before reaching the destination. Similarly, a RESTful request might pass
    through security checks and load balancers without the client’s knowledge.'
  prefs: []
  type: TYPE_NORMAL
- en: Code on demand
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Servers can extend client functionality by transferring executable code. This
    is an optional feature that is used sparingly in the context of APIs because it
    is difficult to implement reliably and securely.
  prefs: []
  type: TYPE_NORMAL
- en: '**Example** : A web application could ask the browser to download and execute
    a calendar widget. The widget is a piece of executable code that extends the functionality
    of the browser.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that you understand the principles of REST architecture, let’s learn how
    to achieve glory in a RESTful API through the levels explained by the Richardson
    Maturity Model.
  prefs: []
  type: TYPE_NORMAL
- en: Levels of a RESTful API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One way to understand the concept of RESTfulness is through the **Richardson
    Maturity Model** , which outlines various levels of adherence to REST principles
    in API design.
  prefs: []
  type: TYPE_NORMAL
- en: 'Named after Leonard Richardson, who introduced it in 2008, the model consists
    of four levels, each representing progression toward more RESTful design:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.2 – Richardson Maturity Model diagram](img/B21843_01_2.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.2 – Richardson Maturity Model diagram
  prefs: []
  type: TYPE_NORMAL
- en: Level 0 – the swamp of Plain Old XML (POX)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At this level, APIs are characterized by a single URI for all operations, typically
    using HTTP `POST` requests. The payloads are often XML-based, and there is no
    distinction between different resource types or HTTP methods. This level lacks
    the fundamental principles of REST, such as resource identification and separation
    of concerns.
  prefs: []
  type: TYPE_NORMAL
- en: Level 1 – resources
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This level introduces the concept of resources, where each entity in the system
    is represented as a unique URI. However, HTTP methods are not fully utilized,
    and operations are typically performed using a combination of HTTP `POST` and
    `GET` requests.
  prefs: []
  type: TYPE_NORMAL
- en: While resources are identified, the API lacks the uniform interface and predictability
    associated with RESTful design.
  prefs: []
  type: TYPE_NORMAL
- en: Level 2 – HTTP verbs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At this level, APIs start leveraging HTTP methods – `GET` , `POST` , `PUT` ,
    `DELETE` – to perform **CRUD** ( **Create, Read, Update, Delete** ) operations
    on resources.
  prefs: []
  type: TYPE_NORMAL
- en: Each HTTP method corresponds to a specific action, providing a more intuitive
    and standardized interface for interacting with the API. However, hypermedia links
    are still missing, limiting the discoverability and flexibility of the API.
  prefs: []
  type: TYPE_NORMAL
- en: Level 3 – hypermedia controls (HATEOAS)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The highest level of RESTfulness, *Level 3* , introduces HATEOAS. In addition
    to leveraging HTTP methods, RESTful APIs at this level include hypermedia links
    in responses, allowing clients to navigate the API dynamically. By providing links
    to related resources and actions, HATEOAS reduces coupling between client and
    server, enhancing flexibility and scalability.
  prefs: []
  type: TYPE_NORMAL
- en: Each level of the Richardson Maturity Model represents progression toward more
    RESTful design, with *Level 3* being the ideal endpoint where APIs fully embrace
    the principles of REST, including resource identification, uniform interface,
    and hypermedia-driven navigation.
  prefs: []
  type: TYPE_NORMAL
- en: Most real-life APIs do not reach *Level 3* , but when they follow as many REST
    principles from the lower levels as possible, they benefit significantly from
    standardization and leverage the capabilities of the HTTP protocol.
  prefs: []
  type: TYPE_NORMAL
- en: Many APIs, instead of implementing hypermedia controls, publish machine-readable
    (but static) specifications of their supported operations using the OpenAPI standard.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s examine one of the most notable characteristics of REST services:
    how requests and responses are represented (typically in JSON), and why JSON is
    preferred over XML.'
  prefs: []
  type: TYPE_NORMAL
- en: Representing data with JSON
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**JSON** is a simple data format which is designed for easy reading and writing
    for humans, while also being straightforward for machines to process and create.
    One small feature that a human user may miss is that JSON does not support comments.'
  prefs: []
  type: TYPE_NORMAL
- en: It is based on a subset of the JavaScript programming language and is completely
    language-independent, with parsers available for every programming language.
  prefs: []
  type: TYPE_NORMAL
- en: 'A JSON document is built from two structures:'
  prefs: []
  type: TYPE_NORMAL
- en: '**A collection of name/value pairs** : In various languages, this is implemented
    as an object, record, struct, dictionary, hash table, keyed list, or associative
    array'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**An ordered list of values** : In most languages, this is implemented as an
    array, vector, list, or sequence'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is a simple example of a JSON document for a `book` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The value of the `"book"` field is the object structure containing name/value
    pairs. The value of the `"tags"` field is a list of ordered unnamed values.
  prefs: []
  type: TYPE_NORMAL
- en: So, why is JSON preferred for RESTful APIs?
  prefs: []
  type: TYPE_NORMAL
- en: 'JSON and XML are both formats used for data interchange, but they have distinct
    characteristics that can make one more suitable than the other for certain applications,
    particularly RESTful APIs. Here is a brief overview of why JSON is often preferred
    over XML for RESTful services:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Performance** : JSON’s lightweight nature means it can be parsed more quickly
    than XML, which is crucial for the performance of RESTful APIs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Simplicity** : JSON’s simpler syntax makes it easier to read and write and
    to parse and generate programmatically'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Web-friendly** : Given its compatibility with JavaScript and the fact that
    modern web development heavily relies on JavaScript, JSON aligns well with web
    technologies'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While both JSON and XML have their places, JSON’s efficiency, simplicity, and
    web-friendliness make it the preferred choice for many developers when it comes
    to RESTful API development. There are also binary structured data interchange
    formats, such as ProtoBuf, that provide better performance than JSON as they remove
    the need for text parsing, but the binary formats are not as widespread and ubiquitously
    supported.
  prefs: []
  type: TYPE_NORMAL
- en: As shown earlier, in RESTful services, JSON plays a crucial role as the medium
    of data exch ange. REST does not prescribe any particular language to be used
    to represent the data of the resources. However, thanks to its ease of use and
    ubiquitous support, JSON is a natural choice for most RESTful APIs. When clients
    make requests to servers, they can send JSON in the body of the request. The server
    then processes this JSON, performs the required operations, and can also send
    back JSON in the response body. This consistent format allows for clear and structured
    data interchange.
  prefs: []
  type: TYPE_NORMAL
- en: 'JSON’s functionality in REST services includes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Serialization** : Converting an object into a JSON string to send it over
    a network. For example, see the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Deserialization** : Converting a JSON string received over a network into
    an object. For example, see the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Data interchange** : Acting as the medium for exchanging data between client
    and server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These examples show the usage of `ObjectMapper` from the Jackson library to
    serialize and deserialize JSON, with the JSON book example earlier in this section.
    This library is already included in the Spring web framework but can also be imported
    separately if needed.
  prefs: []
  type: TYPE_NORMAL
- en: We have seen the importance of JSON and the change this has introduced in comparison
    to the previously used XML. Now, you will learn one of the crucial steps to master
    the development of great REST APIs, and that is to adhere to well-proven guidelines,
    as explained in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: The importance of guidelines in REST APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Guidelines** serve as a roadmap for developers, outlining best practices
    and standards that should be followed during the API development process. They
    are a set of rules that aim to prevent common pitfalls and promote excellence
    in API design. Here are some of the most important aspects of following well-established
    guidelines:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Consistency and predictability** : Developers ensure a level of consistency
    that makes APIs predictable and easier to understand. This uniformity is essential
    for both the developers who create APIs and the users who consume them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Interoperability** : Guidelines often emphasize the use of standard protocols
    and data formats, which fosters interoperability across different platforms and
    technologies. This is particularly important in a diverse ecosystem where APIs
    serve as the bridge between various software components.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scalability** : Well-designed APIs that adhere to guidelines are more likely
    to be scalable, handling increased loads and accommodating growth without requiring
    significant redesign or refactoring.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Security** : This is fundamental in API development, and guidelines provide
    strategies to secure APIs against common threats, ensuring the protection of sensitive
    data and services.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Market relevance of following guidelines
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Adherence to guidelines has a direct impact on the market. Well-designed APIs
    that follow guidelines can lead to the following outcomes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Increased adoption** : APIs that are easy to understand and integrate can
    quickly gain popularity among developers, leading to widespread adoption and a
    larger user base'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Enhanced interoperability** : In markets such as healthcare, where data sharing
    is vital, guidelines ensure that different systems can communicate effectively,
    thereby improving patient care and operational efficiency'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Regulatory compliance** : Especially in regulated industries, following guidelines
    helps organizations comply with legal standards, avoiding penalties and fostering
    trust among stakeholders'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Examples of guideline-driven success
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are some of the most successful guidelines that you can use as a reference:'
  prefs: []
  type: TYPE_NORMAL
- en: The Microsoft Azure REST API Guidelines at [https://github.com/microsoft/api-guidelines/blob/vNext/azure/Guidelines.md](https://github.com/microsoft/api-guidelines/blob/vNext/azure/Guidelines.md
    )
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The HL7 FHIR guidelines for healthcare systems at [https://fhir.org/](https://fhir.org/
    )
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Community-driven API enhancement proposals at [https://aep.dev/](https://aep.dev/
    )
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Many more design guidelines are available on the API Stylebook Design Guidelines
    page from companies such as PayPal, Adidas, Heroku, and others at [https://apistylebook.com/design/guidelines/](https://apistylebook.com/design/guidelines/)
    .
  prefs: []
  type: TYPE_NORMAL
- en: In this book, we will follow the Microsoft Azure REST API Guidelines.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will look at some of the most common use cases where REST APIs are
    used and implemented.
  prefs: []
  type: TYPE_NORMAL
- en: Common REST API use cases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here, we will explore some common use cases for REST APIs with examples that
    illustrate their practical applications:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Integration with third-party services** : Syncing data between different
    platforms, such as **Customer Relationship Management** ( **CRM** ) and **Enterprise
    Resource Planning** ( **ERP** ) systems'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Social media services** : Enabling social interactions and content sharing
    on various platforms'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**E-commerce transactions** : Managing product listings, orders, and payments'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Internet of Things (IoT)** : Connecting and controlling smart devices remotely'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Health and fitness tracking** : Aggregating data from various health and
    fitness devices'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next section, we will discuss the impact of the architectural design
    of REST APIs in a complete system and its clients.
  prefs: []
  type: TYPE_NORMAL
- en: Architecture impact on REST API design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The need to design and implement APIs can occur in many different contexts.
    The goal we want to achieve with an API and the role it plays within the architecture
    of the application or system being developed influences the relative importance
    of the various API aspects described in the respective chapters of this book.
    The unique mix of architectural aspects also impacts the choice of approaches
    and techniques to implement APIs.
  prefs: []
  type: TYPE_NORMAL
- en: The following sections present the most common patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Cross-organizational public APIs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: APIs consumed beyond organizational boundaries are the closest to the original
    application of web technologies.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling all API clients is unfeasible. Public APIs with numerous independent
    consumers frequently prioritize backward compatibility over other design goals.
    The introduction of incompatible changes incurs a substantial cost associated
    with supporting multiple API versions at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, public APIs require higher security standards compared to internal APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Frontend-to-backend APIs developed by a single team
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most contemporary applications comprise a frontend component operating on an
    end-user device (web browser or mobile application) and a backend component, typically
    deployed on a cloud or other server infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: In numerous instances, both the backend and its corresponding frontend are developed
    within a single agile development team. In this scenario, API changes can be mirrored
    on both ends swiftly, and the importance of backward compatibility may be lower.
  prefs: []
  type: TYPE_NORMAL
- en: Nonetheless, even in this situation, there may be clients beyond the team’s
    control utilizing an older API version, for example, mobile applications lacking
    recent updates.
  prefs: []
  type: TYPE_NORMAL
- en: Frontend-to-backend APIs are public APIs as well because the clients are beyond
    our control, necessitating their treatment as such from a security standpoint.
  prefs: []
  type: TYPE_NORMAL
- en: APIs interconnecting microservices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Microservice development teams should maintain autonomy to progress rapidly.
    They need to pay attention to the documentation and backward compatibility of
    their APIs to avoid disrupting other services connected to them. Unlike public
    APIs, within an organization, it is feasible to track the usage of internal microservice
    APIs and their versions.
  prefs: []
  type: TYPE_NORMAL
- en: Solutions managing the formal specifications of various APIs utilized within
    an organization, known as **schema registries** , can assist in balancing the
    pace of development and the stability of the overall business solution.
  prefs: []
  type: TYPE_NORMAL
- en: With multiple services implementing multiple APIs within a single organization,
    it often proves beneficial to delegate some of the API responsibilities to infrastructure
    components, such as a service mesh.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, you will learn about API styles that may be preferable
    to REST in some scenarios. Remember that it does not matter how well you implement
    a RESTful API if you use it in the wrong place.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatives to REST
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This section presents some of the existing alternatives in the market to REST
    APIs and their comparison. It is good to know that REST is not always the best
    option for every case, and it is wise to be able to differentiate between the
    existing options available. Let us mention some examples here:'
  prefs: []
  type: TYPE_NORMAL
- en: Remote Procedure Call (RPC)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: RPC is an API style that obfuscates the existence of an API, rendering it akin
    to a standard procedure invocation (or a method in object-oriented languages)
    in a specific programming language. This style encompasses SOAP web services and
    XML-RPC.
  prefs: []
  type: TYPE_NORMAL
- en: Other notable representatives include CORBA (utilized by Enterprise Java Beans)
    and gRPC (a new one with support for numerous programming languages). gRPC delivers
    performance benefits due to its use of efficient binary message encoding.
  prefs: []
  type: TYPE_NORMAL
- en: RPC APIs are optimally suited for integrations where the number of clients is
    limited, and the API provider can exert control over them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Their disadvantages are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: High coupling between the client and the server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Limited or no compatibility between different API versions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clients are forced to use a less common and more complex technology
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Familiarity with the well-known HTTP protocol cannot be leveraged to understand
    the semantics of the operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GraphQL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Analogous to SQL, **GraphQL** defines a data query and mutational language,
    enabling the client to specify which properties and nodes of a graph-structured
    data source should be returned by the server.
  prefs: []
  type: TYPE_NORMAL
- en: Like SOAP, GraphQL exclusively employs the HTTP `POST` method to tunnel all
    requests. GraphQL affords the client the liberty to execute operations using unexpected
    combinations of data elements. This can result in an excessive amount of logic
    on the client side, leading to duplication as there are typically multiple clients
    for a single server.
  prefs: []
  type: TYPE_NORMAL
- en: 'If there is a requirement to provide data in a different structure and detail
    level for different clients, with REST APIs, the problem can be addressed by doing
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Incorporating parameters in the request (for instance, query parameters)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating multiple APIs on the server side, specialized for the client type,
    by using an architecture known as **Backends for Frontends** ( **BFF** )
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Messaging (event) APIs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Asynchronous communication via messaging platforms, such as Kafka or **Java
    Message System** ( **JMS** ), as opposed to the synchronous request-response style
    of web APIs, is commonly employed for connecting applications and services within
    an organization and used in conjunction with REST APIs.
  prefs: []
  type: TYPE_NORMAL
- en: While providing benefits such as loose coupling, low latency, and more, asynchronous
    communication is also more complex and indirect.
  prefs: []
  type: TYPE_NORMAL
- en: Event interfaces, such as the web APIs, need to be well documented and they
    face challenges of API evolution and compatibility. AsyncAPI, the specification
    standard utilized for asynchronous APIs, is inspired by, and shares considerable
    overlap with, the more mature OpenAPI, which will be discussed later in this book.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we introduce the project we will be creating during this
    book to apply these REST concepts in depth.
  prefs: []
  type: TYPE_NORMAL
- en: About the project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this book, we will develop a project to apply the concepts mentioned in this
    chapter, having hands-on practice and experience. We will build two APIs that
    will communicate with each other.
  prefs: []
  type: TYPE_NORMAL
- en: The first API will be a Product API, which will be introduced in [*Chapter 2*](B21843_02.xhtml#_idTextAnchor050)
    . This API, as its name suggests, is focused on product operations, such as reading
    product data and adding new products.
  prefs: []
  type: TYPE_NORMAL
- en: The second API will be the Order Management API. It will be introduced in [*Chapter
    4*](B21843_04.xhtml#_idTextAnchor096) and will hold the orders containing the
    products stored in the first API, so they will communicate with each other.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout the chapters, you will be able to implement these APIs, apply most
    of the best practices mentioned in this chapter, evolve these, document, test,
    and version to guarantee backward compatibility, implement tracing tools, and
    deploy to the cloud.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned the difference between REST and RESTful, and why
    the REST approach is the preferred method for building API web services compared
    to previous methods used before.
  prefs: []
  type: TYPE_NORMAL
- en: We have investigated the principles of REST architecture, the levels of using
    the Richardson Maturity Model, and the existing alternatives to REST.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we looked at the role of JSON in REST services and the importance of following
    well-defined guidelines proven by numerous projects while developing REST web
    services.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we investigated the architectural impact of REST API design and the
    project that will be built throughout this book in the following chapters.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter presents the basics for you to get started with the upcoming content
    that will be presented and built throughout this book.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will explore the design and practical implementation
    of RESTful APIs using Spring Boot.
  prefs: []
  type: TYPE_NORMAL
