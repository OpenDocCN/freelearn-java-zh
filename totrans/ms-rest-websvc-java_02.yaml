- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: Understanding RESTful Core Concepts
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解RESTful核心概念
- en: The history of web services is a fascinating journey through the evolution of
    the way that systems are built, distributed, and scaled.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Web服务的历史是一段迷人的旅程，它记录了系统构建、分发和扩展方式的演变。
- en: Initially, the monolithic approach, which involved developing everything within
    a single application and machine, was the standard architectural method for many
    years. However, the need to divide software into distinct components with separate
    responsibilities has transformed how we design and implement systems.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，将所有内容开发在单个应用程序和机器中的单体方法，多年来一直是许多人的标准架构方法。然而，将软件划分为具有单独责任的不同组件的需求，已经改变了我们设计和实现系统的方式。
- en: The need to integrate distributed systems composed of software running on separate
    machines has existed since the early days of computing, and its importance is
    increasing, as the way we develop software is moving from monoliths toward more
    distributed architectures.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 自从计算机的早期阶段以来，就需要将运行在不同机器上的软件组成的分布式系统进行集成，其重要性正在增加，因为我们开发软件的方式正从单体架构转向更分布式的架构。
- en: The global spread of the Internet, especially the World Wide Web, brought about
    the standardization of communication protocols, such as **Internet Protocol (IP)**
    , **Transmission Control Protocol (TCP)** , and **Hypertext Transfer Protocol
    (HTTP)** . The success of the World Wide Web and its support by different devices,
    operating systems, and applications brought the idea that the infrastructure of
    the web could be used for connecting applications in general. This is when the
    term **web services** was adopted for using web technologies to create APIs.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网的全球普及，尤其是万维网的兴起，推动了通信协议的标准化，例如**互联网协议（IP**），**传输控制协议（TCP**）和**超文本传输协议（HTTP**）。万维网的成功及其在不同设备、操作系统和应用程序上的支持，使得人们开始认为网络基础设施可以被用于连接各种应用程序。这就是采用**Web服务**这一术语来使用Web技术创建API的时候。
- en: In this book, you will acquire the knowledge needed to be ready to develop and
    master the creation of RESTful web services, starting from the concepts to full
    implementation, following the best practices in the market.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，您将获得开发并精通创建RESTful Web服务所需的知识，从概念到完整实现，遵循市场上的最佳实践。
- en: This chapter will prepare you for the rest of your journey in this book, understanding
    what the **Representational State Transfer** ( **REST** ) architecture and RESTful
    API services are, how these terms differ from each other, principles, maturity
    levels, and guidelines, as well as the project you will be creating throughout
    this chapters to implement this knowledge.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将为您在本书的剩余旅程中做好准备，帮助您理解**表征状态转移（REST**）架构和RESTful API服务是什么，这些术语之间的区别，原则、成熟度水平和指南，以及您将在本章中创建的项目，以实现这些知识。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Why REST?
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么选择REST？
- en: Principles of REST architecture
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: REST架构原则
- en: Levels of a RESTful API
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RESTful API的层级
- en: Representing data with **JavaScript Object Notation** ( **JSON** )
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用**JavaScript对象表示法（JSON**）表示数据
- en: The importance of guidelines for developing REST APIs
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发REST API的指南的重要性
- en: Common REST API use cases
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常见的REST API用例
- en: Architecture impact on REST API design
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 架构对REST API设计的影响
- en: Alternatives to REST
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: REST的替代方案
- en: Why REST?
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么选择REST？
- en: To understand why REST is the dominating architectural style for most web services,
    we will need to understand what was available before the rise of REST and the
    challenges that made this change so important in the way that distributed services
    are built.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解为什么REST是大多数Web服务的占主导地位的架构风格，我们需要了解REST兴起之前可用的技术，以及使这种变化在分布式服务构建方式上变得如此重要的挑战。
- en: The pre-REST era
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: REST之前的时代
- en: Before REST, the web services landscape was dominated by protocols such as **Simple
    Object Access Protocol** ( **SOAP** ) and **Extensible Markup Language–Remote
    Procedure Call** ( **XML-RPC** ). These were powerful but complex standards that
    allowed for detailed communication between clients and servers. However, they
    were often seen as cumbersome due to their verbose nature and the strict requirements
    they imposed on developers.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在REST之前，Web服务领域主要由**简单对象访问协议（SOAP**）和**可扩展标记语言-远程过程调用（XML-RPC**）等协议主导。这些协议功能强大但复杂，允许客户端和服务器之间进行详细的通信。然而，由于它们的冗长性质和对开发者严格的约束，它们通常被认为很繁琐。
- en: SOAP, for instance, required developers to write extensive XML documents with
    specific calls and responses. It was notorious for its complexity and difficulty
    in debugging. Similarly, XML-RPC, while simpler than SOAP, still involved significant
    overhead for simple requests and responses (e.g., verbose and complex XML formatting,
    serialization and deserialization, a text-based protocol, and parsing complexity).
    Both SOAP and XML-RPC only used the HTTP protocol as a *transport* and duplicated,
    in their own ways, several features that the protocol offered and that were also
    supported by the existing web infrastructure.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，SOAP 需要开发者编写大量的 XML 文档，包含特定的调用和响应。它因其复杂性以及调试困难而臭名昭著。同样，XML-RPC 虽然比 SOAP 简单，但对于简单的请求和响应仍然涉及显著的开销（例如，冗长和复杂的
    XML 格式化、序列化和反序列化、基于文本的协议以及解析复杂性）。SOAP 和 XML-RPC 只使用 HTTP 协议作为 *传输*，并以各自的方式重复了协议提供的某些功能和现有网络基础设施所支持的功能。
- en: To overcome these challenges and improve the way the systems communicated with
    each other, REST was created and has been widely implemented since its inception.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 为了克服这些挑战并改善系统之间通信的方式，REST 被创造出来，并且自其诞生以来已被广泛实施。
- en: Understanding REST
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解 REST
- en: '**REST** was introduced in 2000 by Dr. Roy Fielding in his doctoral dissertation
    titled *Architectural Styles and the Design of Network-based Software Architectures*
    .'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '**REST** 在 2000 年由 Roy Fielding 博士在其博士论文《*架构风格和网络软件架构设计*》中提出。'
- en: This architectural style was proposed as a more efficient, flexible, and scalable
    alternative to the existing standards of the time, such as SOAP and XML-RPC.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这种架构风格被提出作为一种更高效、更灵活、更可扩展的替代方案，以替代当时现有的标准，如 SOAP 和 XML-RPC。
- en: Dr. Fielding’s dissertation aimed to simplify the way web services were created
    and consumed, leveraging the existing capabilities of the HTTP protocol.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Fielding 博士的论文旨在简化创建和消费网络服务的方式，利用 HTTP 协议的现有功能。
- en: The key principles of REST – **statelessness** , **cacheability** , **uniform
    interface** , and a **client-server architecture** – were designed to make web
    services more intuitive and aligned with the design of the web itself.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: REST 的关键原则 – **无状态**、**可缓存性**、**统一接口**和**客户端-服务器架构** – 被设计成使网络服务更直观，并与网络本身的设计保持一致。
- en: We will be covering each one of these principles in detail in the *Principles
    of REST architecture* section.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 *REST 架构原则* 部分详细讨论这些原则中的每一个。
- en: When we implement the REST architecture into web services, applying all these
    key principles, then we can say that we have a RESTful API. Let us understand
    this difference better in the next session.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将 REST 架构应用于网络服务，并应用所有这些关键原则时，我们可以说我们有一个 RESTful API。让我们在下一节中更好地理解这种差异。
- en: Unpacking RESTful
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解构 RESTful
- en: RESTful APIs represent an approach to designing web services that adhere to
    the principles of REST, so they are not the same.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: RESTful API 代表了一种设计网络服务的方法，它遵循 REST 原则，因此它们并不相同。
- en: While REST provides the theoretical framework for building scalable and interoperable
    systems, RESTful APIs put these principles into practice, enabling developers
    to create robust and flexible APIs that are easy to understand, maintain, and
    extend.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 REST 为构建可扩展和互操作的系统提供了理论框架，但 RESTful API 将这些原则付诸实践，使开发者能够创建易于理解、维护和扩展的强大且灵活的
    API。
- en: The introduction of RESTful APIs marked a significant shift in web services
    since developers quickly adopted REST due to its simplicity and the way it facilitated
    the development of scalable and performant web applications. RESTful APIs became
    the backbone of web communication, powering everything from social media platforms
    to e-commerce sites.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: RESTful API 的引入标志着网络服务的一个重大转变，因为开发者由于 REST 的简单性和它促进可扩展和性能良好的网络应用开发的方式而迅速采用 REST。RESTful
    API 成为网络通信的骨干，为从社交媒体平台到电子商务网站的一切提供动力。
- en: Now that we have a clear understanding of REST and RESTful, let’s dive deep
    into the principles of REST architecture. This will give us a clearer understanding
    of its key principles and how to achieve them.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经清楚地理解了 REST 和 RESTful，让我们深入探讨 REST 架构的原则。这将使我们对其关键原则和如何实现它们有更清晰的理解。
- en: Principles of REST architecture
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: REST 架构原则
- en: Up to this point, we have only mentioned the key principles of REST. Let us
    dive deeper to understand these principles in more detail.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只提到了 REST 的关键原则。让我们进一步深入，更详细地了解这些原则。
- en: Uniform interface
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 统一接口
- en: 'The **uniform interface** is the cornerstone of any REST design, promoting
    a standardized way of interacting with a given set of resources. This principle
    encompasses four key constraints:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '**统一接口**是任何REST设计的基石，它促进了与一组给定资源交互的标准化方式。这一原则包括四个关键约束：'
- en: '**Identification of resources** : Each resource, whether it is a document,
    image, or service, is identified using a unique **uniform resource identifier**
    ( **URI** )'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源识别**：每个资源，无论是文档、图像还是服务，都使用唯一的**统一资源标识符**（**URI**）进行识别。'
- en: '**Manipulation of resources via representations** : When a client possesses
    a representation of a resource, along with any attached metadata, it can modify
    or delete the resource on the server if it has the necessary permissions'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通过表示形式操作资源**：当客户端拥有资源的表示形式以及任何附加的元数据时，如果它拥有必要的权限，它可以修改或删除服务器上的资源。'
- en: '**Self-descriptive messages** : Each message contains enough information to
    describe how to process it, which may include the representation format and the
    desired state transitions'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自描述性消息**：每条消息都包含足够的信息来描述如何处理它，这可能包括表示格式和期望的状态转换。'
- en: '**Hypermedia as the engine of application state (HATEOAS)** : Clients interact
    with a RESTful service entirely through hypermedia provided dynamically by application
    servers – a concept known as HATEOAS'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**超媒体作为应用程序状态引擎（HATEOAS）**：客户端完全通过由应用程序服务器动态提供的超媒体与RESTful服务交互，这一概念被称为HATEOAS。'
- en: '**Example** : Imagine a library system where each book is a *resource* identified
    by an ISBN number (URI). When you want to borrow a book, you get a *representation*
    (a card with book details), which you use to check out the book. The library’s
    checkout system tells you how to proceed (using *self-descriptive* messages),
    and the catalog guides you to related resources ( *HATEOAS* ), such as the author’s
    other books.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '**示例**：想象一个图书馆系统，其中每本书都是一个*资源*，通过ISBN号码（URI）进行标识。当你想借一本书时，你会得到一个*表示形式*（一张包含书籍详细信息的卡片），你用它来借阅书籍。图书馆的借阅系统会告诉你如何进行（使用*自描述性*消息），目录会引导你找到相关的资源（*HATEOAS*），例如作者的其它书籍。'
- en: Client-server separation
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 客户端-服务器分离
- en: This principle enforces the separation of concerns by dividing the user interface
    concerns from the data storage concerns. This separation allows the client and
    server components to evolve independently, leading to a more flexible and scalable
    application architecture.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这一原则通过将用户界面关注点与数据存储关注点分离，强制执行关注点分离。这种分离允许客户端和服务器组件独立发展，从而实现更灵活和可扩展的应用程序架构。
- en: '![Figure 1.1 – Client-server diagram](img/B21843_01_1.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![图1.1 – 客户端-服务器图](img/B21843_01_1.jpg)'
- en: Figure 1.1 – Client-server diagram
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.1 – 客户端-服务器图
- en: '**Example** : A user submits a form on a website with their data to finalize
    a checkout (client sending the request); this will be JSON using the `POST` HTTP
    verb and will be received by the server. The server will receive the data, create
    this new resource with the customer data, store the customer data, place a new
    order, and return the appropriate response to the user.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '**示例**：用户在网站上提交一个包含其数据的表单以完成借阅（客户端发送请求）；这将使用`POST` HTTP动词发送JSON格式，并由服务器接收。服务器将接收数据，创建包含客户数据的这个新资源，存储客户数据，放置新的订单，并向用户返回适当的响应。'
- en: Statelessness
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 无状态
- en: In a RESTful service, each request from a client to a server must contain all
    the information the server needs to fulfill the request. The server does not store
    any session state about the client, which means that each request is independent
    and isolated.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在RESTful服务中，客户端向服务器发出的每个请求都必须包含服务器完成请求所需的所有信息。服务器不存储任何关于客户端的会话状态，这意味着每个请求都是独立和隔离的。
- en: '**Example** : Each time you order a coffee at a café, you provide your full
    order details. The barista does not need to remember your previous orders; they
    just make the coffee based on the current order alone.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '**示例**：每次你在咖啡馆点咖啡时，你都会提供你完整的订单详情。咖啡师不需要记住你之前的订单；他们只需根据当前的订单制作咖啡。'
- en: Cacheability
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缓存性
- en: Responses must, implicitly or explicitly, define themselves as cacheable or
    not. This helps improve the network’s efficiency by reducing client-server interactions
    for frequently requested resources.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 响应必须隐式或显式地定义自己为可缓存的或不可缓存的。这有助于通过减少频繁请求的资源与客户端-服务器交互来提高网络的效率。
- en: Note that caching brings the risk that the client may see an outdated version
    of the resource, especially if the resource changes frequently. However, we often
    accept the risk in exchange for better performance.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，缓存可能会带来风险，即客户端可能看到资源的过时版本，尤其是如果资源频繁更改。然而，我们通常为了更好的性能而接受这种风险。
- en: '**Example** : A resource requested thousands of times per day is eligible for
    caching since this will drastically reduce the usage of **database** ( **DB**
    ) resources and improve the response time.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '**示例**：每天请求数千次资源有资格进行缓存，因为这将大大减少**数据库**（**DB**）资源的使用并提高响应时间。'
- en: Layered system
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分层系统
- en: 'A RESTful architecture may consist of layered hierarchies, which can include
    load balancers, caches, or authentication gateways. This layered system ensures
    that a client cannot ordinarily tell whether it is connected directly to the end
    server or to an intermediary along the way. The layered system is one of the key
    constraints of the RESTful architecture and it offers several benefits:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: RESTful架构可能由分层层次结构组成，这可能包括负载均衡器、缓存或身份验证网关。这种分层系统确保客户端通常无法判断它是直接连接到端服务器还是连接到途中的中介。分层系统是RESTful架构的关键约束之一，并提供了几个好处：
- en: '**Modularity** : The layered system allows you to organize your application
    into logical layers, each with a specific role and responsibility. This makes
    the system easier to understand, develop, and maintain.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模块化**：分层系统允许你将应用程序组织成逻辑层，每个层都有特定的角色和责任。这使得系统更容易理解、开发和维护。'
- en: '**Separation of concerns** : Each layer can focus on its own tasks. For example,
    an authentication layer can handle all aspects of authentication and nothing else.
    This separation of concerns leads to cleaner, more maintainable code.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**关注点分离**：每一层可以专注于自己的任务。例如，一个身份验证层可以处理所有身份验证方面，而无需处理其他任何事情。这种关注点分离导致代码更清晰、更易于维护。'
- en: '**Interchangeability** : If a layer is designed and implemented in a modular
    way, it can be replaced or upgraded without affecting other layers. This is particularly
    useful when you want to update or improve a specific part of the system.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可互换性**：如果一个层以模块化的方式设计和实现，它可以被替换或升级而不会影响其他层。这在你想更新或改进系统的特定部分时特别有用。'
- en: '**Scalability** : You can scale different layers independently based on their
    individual load and performance requirements. For example, if your application
    layer is experiencing heavy load, you can add more servers to that layer without
    having to scale your database layer.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可伸缩性**：你可以根据各自的负载和性能要求独立地扩展不同的层。例如，如果你的应用层正在经历高负载，你可以向该层添加更多服务器，而无需扩展你的数据库层。'
- en: '**Security** : By segregating the system into layers, you can apply appropriate
    security controls to each layer. For example, you can put a firewall between layers
    to control traffic and protect sensitive layers from potential attacks.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全性**：通过将系统分层，你可以对每一层应用适当的控制措施。例如，你可以在层之间放置防火墙来控制流量并保护敏感层免受潜在攻击。'
- en: '**Example** : When you send a letter, it goes through various postal offices
    (layers) before reaching the destination. Similarly, a RESTful request might pass
    through security checks and load balancers without the client’s knowledge.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '**示例**：当你发送一封信时，它会在到达目的地之前通过各个邮政局（层）。同样，一个RESTful请求可能会在客户端不知情的情况下通过安全检查和负载均衡器。'
- en: Code on demand
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 需求代码
- en: Servers can extend client functionality by transferring executable code. This
    is an optional feature that is used sparingly in the context of APIs because it
    is difficult to implement reliably and securely.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器可以通过传输可执行代码来扩展客户端功能。这是一个可选功能，在API的上下文中很少使用，因为它难以可靠和安全地实现。
- en: '**Example** : A web application could ask the browser to download and execute
    a calendar widget. The widget is a piece of executable code that extends the functionality
    of the browser.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '**示例**：一个Web应用程序可以要求浏览器下载并执行日历小部件。这个小部件是一段可执行代码，它扩展了浏览器的功能。'
- en: Now that you understand the principles of REST architecture, let’s learn how
    to achieve glory in a RESTful API through the levels explained by the Richardson
    Maturity Model.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 既然你已经了解了REST架构的原则，让我们学习如何通过Richardson成熟度模型解释的级别来实现RESTful API的辉煌。
- en: Levels of a RESTful API
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RESTful API的级别
- en: One way to understand the concept of RESTfulness is through the **Richardson
    Maturity Model** , which outlines various levels of adherence to REST principles
    in API design.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 理解RESTful概念的一种方式是通过**Richardson 成熟度模型**，它概述了API设计中遵循REST原则的各个级别。
- en: 'Named after Leonard Richardson, who introduced it in 2008, the model consists
    of four levels, each representing progression toward more RESTful design:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 该模型以Leonard Richardson的名字命名，他在2008年引入了它，该模型由四个级别组成，每个级别代表着向更RESTful设计的进步：
- en: '![Figure 1.2 – Richardson Maturity Model diagram](img/B21843_01_2.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![图1.2 – Richardson 成熟度模型图](img/B21843_01_2.png)'
- en: Figure 1.2 – Richardson Maturity Model diagram
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.2 – Richardson 成熟度模型图
- en: Level 0 – the swamp of Plain Old XML (POX)
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第0级 – 纯旧XML (POX) 的泥潭
- en: At this level, APIs are characterized by a single URI for all operations, typically
    using HTTP `POST` requests. The payloads are often XML-based, and there is no
    distinction between different resource types or HTTP methods. This level lacks
    the fundamental principles of REST, such as resource identification and separation
    of concerns.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一级别，API的特点是所有操作使用单个URI，通常使用HTTP `POST`请求。有效载荷通常是基于XML的，并且没有区分不同的资源类型或HTTP方法。这一级别缺乏REST的基本原则，如资源标识和关注点分离。
- en: Level 1 – resources
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第1级 – 资源
- en: This level introduces the concept of resources, where each entity in the system
    is represented as a unique URI. However, HTTP methods are not fully utilized,
    and operations are typically performed using a combination of HTTP `POST` and
    `GET` requests.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一级别，引入了资源的概念，其中系统中的每个实体都表示为一个唯一的URI。然而，HTTP方法并没有得到充分利用，操作通常是通过HTTP `POST`和`GET`请求的组合来执行的。
- en: While resources are identified, the API lacks the uniform interface and predictability
    associated with RESTful design.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然资源得到了标识，但API缺乏与RESTful设计相关的统一接口和可预测性。
- en: Level 2 – HTTP verbs
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第2级 – HTTP 动词
- en: At this level, APIs start leveraging HTTP methods – `GET` , `POST` , `PUT` ,
    `DELETE` – to perform **CRUD** ( **Create, Read, Update, Delete** ) operations
    on resources.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一级别，API开始利用HTTP方法 – `GET`、`POST`、`PUT`、`DELETE` – 来对资源执行**CRUD**（**创建、读取、更新、删除**）操作。
- en: Each HTTP method corresponds to a specific action, providing a more intuitive
    and standardized interface for interacting with the API. However, hypermedia links
    are still missing, limiting the discoverability and flexibility of the API.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 每个HTTP方法对应一个特定的动作，为与API交互提供了一个更直观和标准化的接口。然而，超媒体链接仍然缺失，限制了API的可发现性和灵活性。
- en: Level 3 – hypermedia controls (HATEOAS)
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第3级 – 超媒体控件（HATEOAS）
- en: The highest level of RESTfulness, *Level 3* , introduces HATEOAS. In addition
    to leveraging HTTP methods, RESTful APIs at this level include hypermedia links
    in responses, allowing clients to navigate the API dynamically. By providing links
    to related resources and actions, HATEOAS reduces coupling between client and
    server, enhancing flexibility and scalability.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 最高级别的RESTful，**第3级**引入了HATEOAS。除了利用HTTP方法外，这一级别的RESTful API在响应中包括超媒体链接，允许客户端动态地导航API。通过提供相关资源及其操作的链接，HATEOAS减少了客户端和服务器之间的耦合，增强了灵活性和可扩展性。
- en: Each level of the Richardson Maturity Model represents progression toward more
    RESTful design, with *Level 3* being the ideal endpoint where APIs fully embrace
    the principles of REST, including resource identification, uniform interface,
    and hypermedia-driven navigation.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: Richardson 成熟度模型的每一级都代表着向更RESTful设计的进步，其中**第3级**是理想的终点，在这一级API完全拥抱REST原则，包括资源标识、统一接口和超媒体驱动的导航。
- en: Most real-life APIs do not reach *Level 3* , but when they follow as many REST
    principles from the lower levels as possible, they benefit significantly from
    standardization and leverage the capabilities of the HTTP protocol.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数现实生活中的API没有达到**第3级**，但当他们尽可能遵循较低级别的REST原则时，他们从标准化中受益匪浅，并利用了HTTP协议的功能。
- en: Many APIs, instead of implementing hypermedia controls, publish machine-readable
    (but static) specifications of their supported operations using the OpenAPI standard.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 许多API，而不是实现超媒体控件，使用OpenAPI标准发布其支持的操作的机器可读（但静态）规范。
- en: 'Now, let’s examine one of the most notable characteristics of REST services:
    how requests and responses are represented (typically in JSON), and why JSON is
    preferred over XML.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来考察REST服务最显著的特征之一：请求和响应是如何表示的（通常在JSON中），以及为什么JSON比XML更受欢迎。
- en: Representing data with JSON
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用JSON表示数据
- en: '**JSON** is a simple data format which is designed for easy reading and writing
    for humans, while also being straightforward for machines to process and create.
    One small feature that a human user may miss is that JSON does not support comments.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '**JSON**是一种简单的数据格式，它旨在使人类易于阅读和编写，同时也便于机器处理和创建。一个人类用户可能不会注意到的一个小特点是，JSON不支持注释。'
- en: It is based on a subset of the JavaScript programming language and is completely
    language-independent, with parsers available for every programming language.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 它基于JavaScript编程语言的一个子集，并且完全与语言无关，每种编程语言都有可用的解析器。
- en: 'A JSON document is built from two structures:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 一个JSON文档由两种结构组成：
- en: '**A collection of name/value pairs** : In various languages, this is implemented
    as an object, record, struct, dictionary, hash table, keyed list, or associative
    array'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一组键值对**：在不同的语言中，这通常实现为一个对象、记录、结构、字典、哈希表、键列表或关联数组'
- en: '**An ordered list of values** : In most languages, this is implemented as an
    array, vector, list, or sequence'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**值的有序列表**：在大多数语言中，这通常实现为一个数组、向量、列表或序列'
- en: 'Here is a simple example of a JSON document for a `book` object:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个简单的JSON文档示例，用于`book`对象：
- en: '[PRE0]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The value of the `"book"` field is the object structure containing name/value
    pairs. The value of the `"tags"` field is a list of ordered unnamed values.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`"book"`字段的值是一个包含键值对的对象结构。`"tags"`字段的值是一个有序的无名值列表。'
- en: So, why is JSON preferred for RESTful APIs?
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，为什么JSON被首选用于RESTful API？
- en: 'JSON and XML are both formats used for data interchange, but they have distinct
    characteristics that can make one more suitable than the other for certain applications,
    particularly RESTful APIs. Here is a brief overview of why JSON is often preferred
    over XML for RESTful services:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: JSON和XML都是用于数据交换的格式，但它们具有不同的特性，这可以使一个格式比另一个更适合某些应用，尤其是RESTful API。以下是为什么JSON通常比XML更适合RESTful服务的一个简要概述：
- en: '**Performance** : JSON’s lightweight nature means it can be parsed more quickly
    than XML, which is crucial for the performance of RESTful APIs'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能**：JSON轻量级的特性意味着它比XML解析得更快，这对于RESTful API的性能至关重要'
- en: '**Simplicity** : JSON’s simpler syntax makes it easier to read and write and
    to parse and generate programmatically'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简洁性**：JSON的简单语法使其更容易阅读和编写，也更容易程序化解析和生成'
- en: '**Web-friendly** : Given its compatibility with JavaScript and the fact that
    modern web development heavily relies on JavaScript, JSON aligns well with web
    technologies'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网络友好**：鉴于其与JavaScript的兼容性以及现代Web开发对JavaScript的依赖性，JSON与Web技术非常契合'
- en: While both JSON and XML have their places, JSON’s efficiency, simplicity, and
    web-friendliness make it the preferred choice for many developers when it comes
    to RESTful API development. There are also binary structured data interchange
    formats, such as ProtoBuf, that provide better performance than JSON as they remove
    the need for text parsing, but the binary formats are not as widespread and ubiquitously
    supported.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然JSON和XML都有自己的应用场景，但JSON的效率、简洁性和网络友好性使其成为许多开发者在开发RESTful API时的首选选择。此外，还有一些二进制结构化数据交换格式，如ProtoBuf，它们比JSON提供了更好的性能，因为它们消除了文本解析的需要，但这些二进制格式并不像JSON那样广泛和普遍地得到支持。
- en: As shown earlier, in RESTful services, JSON plays a crucial role as the medium
    of data exch ange. REST does not prescribe any particular language to be used
    to represent the data of the resources. However, thanks to its ease of use and
    ubiquitous support, JSON is a natural choice for most RESTful APIs. When clients
    make requests to servers, they can send JSON in the body of the request. The server
    then processes this JSON, performs the required operations, and can also send
    back JSON in the response body. This consistent format allows for clear and structured
    data interchange.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，在RESTful服务中，JSON作为数据交换的媒介发挥着至关重要的作用。REST没有规定用于表示资源数据的特定语言。然而，得益于其易用性和普遍支持，JSON成为大多数RESTful
    API的自然选择。当客户端向服务器发送请求时，它们可以在请求体中发送JSON。然后服务器处理这个JSON，执行所需的操作，也可以在响应体中发送JSON。这种一致的格式允许进行清晰和结构化的数据交换。
- en: 'JSON’s functionality in REST services includes the following:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: JSON在REST服务中的功能包括以下内容：
- en: '**Serialization** : Converting an object into a JSON string to send it over
    a network. For example, see the following:'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**序列化**：将对象转换为JSON字符串以便通过网络发送。例如，请参见以下内容：'
- en: '[PRE1]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '**Deserialization** : Converting a JSON string received over a network into
    an object. For example, see the following:'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**反序列化**：将通过网络接收到的JSON字符串转换为对象。例如，请参阅以下内容：'
- en: '[PRE2]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '**Data interchange** : Acting as the medium for exchanging data between client
    and server.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据交换**：作为客户端和服务器之间交换数据的媒介。'
- en: These examples show the usage of `ObjectMapper` from the Jackson library to
    serialize and deserialize JSON, with the JSON book example earlier in this section.
    This library is already included in the Spring web framework but can also be imported
    separately if needed.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这些示例展示了Jackson库中`ObjectMapper`的使用，用于在前面本节中提到的JSON书籍示例中序列化和反序列化JSON。这个库已经包含在Spring
    Web框架中，但在需要的情况下也可以单独导入。
- en: We have seen the importance of JSON and the change this has introduced in comparison
    to the previously used XML. Now, you will learn one of the crucial steps to master
    the development of great REST APIs, and that is to adhere to well-proven guidelines,
    as explained in the next section.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了JSON的重要性以及与之前使用的XML相比带来的变化。现在，你将学习掌握开发优秀REST API的关键步骤之一，那就是遵循经过验证的指南，如下一节所述。
- en: The importance of guidelines in REST APIs
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指南在REST API中的重要性
- en: '**Guidelines** serve as a roadmap for developers, outlining best practices
    and standards that should be followed during the API development process. They
    are a set of rules that aim to prevent common pitfalls and promote excellence
    in API design. Here are some of the most important aspects of following well-established
    guidelines:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '**指南**为开发者提供路线图，概述了在API开发过程中应遵循的最佳实践和标准。它们是一套旨在防止常见陷阱并促进API设计卓越的规则。以下是遵循既定指南的一些最重要的方面：'
- en: '**Consistency and predictability** : Developers ensure a level of consistency
    that makes APIs predictable and easier to understand. This uniformity is essential
    for both the developers who create APIs and the users who consume them.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一致性和可预测性**：开发者确保了一致性水平，使API可预测且易于理解。这种统一性对于创建API的开发者和使用API的用户都是必不可少的。'
- en: '**Interoperability** : Guidelines often emphasize the use of standard protocols
    and data formats, which fosters interoperability across different platforms and
    technologies. This is particularly important in a diverse ecosystem where APIs
    serve as the bridge between various software components.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**互操作性**：指南通常强调使用标准协议和数据格式，这促进了不同平台和技术之间的互操作性。在API作为连接各种软件组件的桥梁的多样化生态系统中，这一点尤为重要。'
- en: '**Scalability** : Well-designed APIs that adhere to guidelines are more likely
    to be scalable, handling increased loads and accommodating growth without requiring
    significant redesign or refactoring.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可扩展性**：遵循指南精心设计的API更有可能具有可扩展性，能够处理增加的负载并适应增长，而无需进行重大重新设计或重构。'
- en: '**Security** : This is fundamental in API development, and guidelines provide
    strategies to secure APIs against common threats, ensuring the protection of sensitive
    data and services.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全性**：这是API开发的基本要求，指南提供了策略来保护API免受常见威胁，确保敏感数据和服务的保护。'
- en: Market relevance of following guidelines
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 遵循指南的市场相关性
- en: 'Adherence to guidelines has a direct impact on the market. Well-designed APIs
    that follow guidelines can lead to the following outcomes:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循指南对市场有直接影响。遵循指南精心设计的API可能导致以下结果：
- en: '**Increased adoption** : APIs that are easy to understand and integrate can
    quickly gain popularity among developers, leading to widespread adoption and a
    larger user base'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**增加采用率**：易于理解和集成的API可以迅速在开发者中受到欢迎，导致广泛采用和更大的用户基础。'
- en: '**Enhanced interoperability** : In markets such as healthcare, where data sharing
    is vital, guidelines ensure that different systems can communicate effectively,
    thereby improving patient care and operational efficiency'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**增强互操作性**：在医疗保健等数据共享至关重要的市场中，指南确保不同的系统可以有效地进行通信，从而提高患者护理和运营效率。'
- en: '**Regulatory compliance** : Especially in regulated industries, following guidelines
    helps organizations comply with legal standards, avoiding penalties and fostering
    trust among stakeholders'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**合规性**：特别是在受监管的行业中，遵循指南有助于组织遵守法律标准，避免处罚并增强利益相关者之间的信任。'
- en: Examples of guideline-driven success
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 指南驱动的成功案例
- en: 'Here are some of the most successful guidelines that you can use as a reference:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些你可以作为参考的最成功的指南：
- en: The Microsoft Azure REST API Guidelines at [https://github.com/microsoft/api-guidelines/blob/vNext/azure/Guidelines.md](https://github.com/microsoft/api-guidelines/blob/vNext/azure/Guidelines.md
    )
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微软Azure REST API指南，请访问[https://github.com/microsoft/api-guidelines/blob/vNext/azure/Guidelines.md](https://github.com/microsoft/api-guidelines/blob/vNext/azure/Guidelines.md)。
- en: The HL7 FHIR guidelines for healthcare systems at [https://fhir.org/](https://fhir.org/
    )
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://fhir.org/](https://fhir.org/)上的HL7 FHIR医疗保健系统指南'
- en: Community-driven API enhancement proposals at [https://aep.dev/](https://aep.dev/
    )
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://aep.dev/](https://aep.dev/)上的社区驱动的API增强提案'
- en: Many more design guidelines are available on the API Stylebook Design Guidelines
    page from companies such as PayPal, Adidas, Heroku, and others at [https://apistylebook.com/design/guidelines/](https://apistylebook.com/design/guidelines/)
    .
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 更多设计指南可在API风格手册设计指南页面找到，例如PayPal、Adidas、Heroku等公司，请访问[https://apistylebook.com/design/guidelines/](https://apistylebook.com/design/guidelines/)。
- en: In this book, we will follow the Microsoft Azure REST API Guidelines.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将遵循微软Azure REST API指南。
- en: Next, we will look at some of the most common use cases where REST APIs are
    used and implemented.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨一些最常见的使用REST API的用例和实现，以示例说明其实际应用。
- en: Common REST API use cases
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常见的REST API用例
- en: 'Here, we will explore some common use cases for REST APIs with examples that
    illustrate their practical applications:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将探讨一些常见的REST API用例，并通过示例说明其实际应用。
- en: '**Integration with third-party services** : Syncing data between different
    platforms, such as **Customer Relationship Management** ( **CRM** ) and **Enterprise
    Resource Planning** ( **ERP** ) systems'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**与第三方服务的集成**：在不同平台之间同步数据，例如**客户关系管理**（**CRM**）和**企业资源计划**（**ERP**）系统'
- en: '**Social media services** : Enabling social interactions and content sharing
    on various platforms'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**社交媒体服务**：在各个平台上启用社交互动和内容共享'
- en: '**E-commerce transactions** : Managing product listings, orders, and payments'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**电子商务交易**：管理产品列表、订单和支付'
- en: '**Internet of Things (IoT)** : Connecting and controlling smart devices remotely'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**物联网（IoT）**：远程连接和控制智能设备'
- en: '**Health and fitness tracking** : Aggregating data from various health and
    fitness devices'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**健康和健身跟踪**：从各种健康和健身设备汇总数据'
- en: In the next section, we will discuss the impact of the architectural design
    of REST APIs in a complete system and its clients.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论REST API的架构设计对完整系统和其客户端的影响。
- en: Architecture impact on REST API design
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 架构对REST API设计的影响
- en: The need to design and implement APIs can occur in many different contexts.
    The goal we want to achieve with an API and the role it plays within the architecture
    of the application or system being developed influences the relative importance
    of the various API aspects described in the respective chapters of this book.
    The unique mix of architectural aspects also impacts the choice of approaches
    and techniques to implement APIs.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 需要设计和实现API的情况可能出现在许多不同的环境中。我们希望通过API实现的目标以及它在开发的应用程序或系统架构中的作用会影响本书各章节中描述的各种API方面的相对重要性。独特的架构方面组合也会影响选择实现API的方法和技术。
- en: The following sections present the most common patterns.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 以下部分将介绍最常见的模式。
- en: Cross-organizational public APIs
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 跨组织公共API
- en: APIs consumed beyond organizational boundaries are the closest to the original
    application of web technologies.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 跨组织边界使用的API最接近原始的Web技术应用。
- en: Controlling all API clients is unfeasible. Public APIs with numerous independent
    consumers frequently prioritize backward compatibility over other design goals.
    The introduction of incompatible changes incurs a substantial cost associated
    with supporting multiple API versions at the same time.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 控制所有API客户端是不切实际的。具有众多独立消费者的公共API通常优先考虑向后兼容性，而不是其他设计目标。引入不兼容的变更会带来支持多个API版本的同时产生的重大成本。
- en: Lastly, public APIs require higher security standards compared to internal APIs.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，公共API相比内部API需要更高的安全标准。
- en: Frontend-to-backend APIs developed by a single team
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 由单一团队开发的客户端到服务端API
- en: Most contemporary applications comprise a frontend component operating on an
    end-user device (web browser or mobile application) and a backend component, typically
    deployed on a cloud or other server infrastructure.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数当代应用程序由一个在终端用户设备（网页浏览器或移动应用程序）上运行的前端组件和一个通常部署在云或其他服务器基础设施上的后端组件组成。
- en: In numerous instances, both the backend and its corresponding frontend are developed
    within a single agile development team. In this scenario, API changes can be mirrored
    on both ends swiftly, and the importance of backward compatibility may be lower.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，后端及其相应的客户端都是在同一个敏捷开发团队内开发的。在这种情况下，API 变更可以迅速地在两端进行镜像，向后兼容性的重要性可能较低。
- en: Nonetheless, even in this situation, there may be clients beyond the team’s
    control utilizing an older API version, for example, mobile applications lacking
    recent updates.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，即使在这种情况之下，也可能存在团队无法控制的客户端使用较旧的 API 版本，例如，缺乏最近更新的移动应用程序。
- en: Frontend-to-backend APIs are public APIs as well because the clients are beyond
    our control, necessitating their treatment as such from a security standpoint.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 前端到后端的 API 也是公共 API，因为客户端超出了我们的控制，从安全角度出发，需要将其视为此类处理。
- en: APIs interconnecting microservices
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接微服务的 API
- en: Microservice development teams should maintain autonomy to progress rapidly.
    They need to pay attention to the documentation and backward compatibility of
    their APIs to avoid disrupting other services connected to them. Unlike public
    APIs, within an organization, it is feasible to track the usage of internal microservice
    APIs and their versions.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务开发团队应保持自主权以快速进步。他们需要关注其 API 的文档和向后兼容性，以避免干扰与之连接的其他服务。与公共 API 不同，在组织内部，可以跟踪内部微服务
    API 及其版本的使用情况。
- en: Solutions managing the formal specifications of various APIs utilized within
    an organization, known as **schema registries** , can assist in balancing the
    pace of development and the stability of the overall business solution.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 管理组织内部使用的各种 API 的正式规范，称为 **模式注册表**，可以帮助平衡开发速度和整体业务解决方案的稳定性。
- en: With multiple services implementing multiple APIs within a single organization,
    it often proves beneficial to delegate some of the API responsibilities to infrastructure
    components, such as a service mesh.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个组织内，多个服务实现多个 API 的情况下，将一些 API 责任委托给基础设施组件，如服务网格，通常是有益的。
- en: In the next section, you will learn about API styles that may be preferable
    to REST in some scenarios. Remember that it does not matter how well you implement
    a RESTful API if you use it in the wrong place.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，你将了解在某些情况下可能比 REST 更可取的 API 风格。记住，如果你在不适当的地方使用 RESTful API，即使你实现了很好的 RESTful
    API，也没有意义。
- en: Alternatives to REST
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: REST 的替代方案
- en: 'This section presents some of the existing alternatives in the market to REST
    APIs and their comparison. It is good to know that REST is not always the best
    option for every case, and it is wise to be able to differentiate between the
    existing options available. Let us mention some examples here:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 本节介绍了市场上现有的替代 REST API 的解决方案及其比较。了解 REST 并非在所有情况下都是最佳选择，能够区分现有选项是明智的。以下是一些例子：
- en: Remote Procedure Call (RPC)
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 远程过程调用 (RPC)
- en: RPC is an API style that obfuscates the existence of an API, rendering it akin
    to a standard procedure invocation (or a method in object-oriented languages)
    in a specific programming language. This style encompasses SOAP web services and
    XML-RPC.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: RPC 是一种隐藏 API 存在的 API 风格，使其在特定编程语言中类似于标准过程调用（或面向对象语言中的方法）。这种风格包括 SOAP 网络服务和
    XML-RPC。
- en: Other notable representatives include CORBA (utilized by Enterprise Java Beans)
    and gRPC (a new one with support for numerous programming languages). gRPC delivers
    performance benefits due to its use of efficient binary message encoding.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 其他值得注意的代表包括 CORBA（由企业 JavaBeans 使用）和 gRPC（一个支持多种编程语言的新协议）。gRPC 通过使用高效的二进制消息编码提供了性能优势。
- en: RPC APIs are optimally suited for integrations where the number of clients is
    limited, and the API provider can exert control over them.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: RPC API 适用于客户端数量有限且 API 提供商可以控制它们的集成。
- en: 'Their disadvantages are as follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 它们的缺点如下：
- en: High coupling between the client and the server
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端与服务器之间的高耦合
- en: Limited or no compatibility between different API versions
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同 API 版本之间有限或没有兼容性
- en: Clients are forced to use a less common and more complex technology
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端被迫使用较少见且更复杂的技术
- en: Familiarity with the well-known HTTP protocol cannot be leveraged to understand
    the semantics of the operations
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无法利用对知名 HTTP 协议的熟悉来理解操作的语义
- en: GraphQL
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GraphQL
- en: Analogous to SQL, **GraphQL** defines a data query and mutational language,
    enabling the client to specify which properties and nodes of a graph-structured
    data source should be returned by the server.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 与 SQL 类似，**GraphQL** 定义了一种数据查询和突变语言，使客户端能够指定服务器应返回哪些图结构数据源的性质和节点。
- en: Like SOAP, GraphQL exclusively employs the HTTP `POST` method to tunnel all
    requests. GraphQL affords the client the liberty to execute operations using unexpected
    combinations of data elements. This can result in an excessive amount of logic
    on the client side, leading to duplication as there are typically multiple clients
    for a single server.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 与 SOAP 类似，GraphQL 专门使用 HTTP `POST` 方法来隧道所有请求。GraphQL 允许客户端使用数据元素的不同组合来执行操作，这可能导致客户端逻辑过多，因为通常一个服务器会有多个客户端。
- en: 'If there is a requirement to provide data in a different structure and detail
    level for different clients, with REST APIs, the problem can be addressed by doing
    the following:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要为不同的客户端提供不同结构和详细程度的数据，使用 REST API，可以通过以下方式解决这个问题：
- en: Incorporating parameters in the request (for instance, query parameters)
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在请求中包含参数（例如，查询参数）
- en: Creating multiple APIs on the server side, specialized for the client type,
    by using an architecture known as **Backends for Frontends** ( **BFF** )
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用称为 **前后端分离**（**BFF**）的架构，在服务器端创建多个针对客户端类型的 API
- en: Messaging (event) APIs
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 消息（事件）API
- en: Asynchronous communication via messaging platforms, such as Kafka or **Java
    Message System** ( **JMS** ), as opposed to the synchronous request-response style
    of web APIs, is commonly employed for connecting applications and services within
    an organization and used in conjunction with REST APIs.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Web API 的同步请求-响应风格相比，通过消息平台（如 Kafka 或 **Java 消息系统**（**JMS**））进行异步通信，通常用于连接组织内的应用程序和服务，并与
    REST API 一起使用。
- en: While providing benefits such as loose coupling, low latency, and more, asynchronous
    communication is also more complex and indirect.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然异步通信提供了诸如松散耦合、低延迟等好处，但它也更复杂和间接。
- en: Event interfaces, such as the web APIs, need to be well documented and they
    face challenges of API evolution and compatibility. AsyncAPI, the specification
    standard utilized for asynchronous APIs, is inspired by, and shares considerable
    overlap with, the more mature OpenAPI, which will be discussed later in this book.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 事件接口，如 Web API，需要良好的文档，并且面临 API 进化和兼容性的挑战。AsyncAPI，用于异步 API 的规范标准，受到了更成熟的 OpenAPI
    的启发，并在本书的后续部分进行讨论。
- en: In the next section, we introduce the project we will be creating during this
    book to apply these REST concepts in depth.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将介绍我们将在这本书中创建的项目，以深入应用这些 REST 概念。
- en: About the project
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于项目
- en: In this book, we will develop a project to apply the concepts mentioned in this
    chapter, having hands-on practice and experience. We will build two APIs that
    will communicate with each other.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们将开发一个项目，以应用本章中提到的概念，进行实践和经验积累。我们将构建两个将相互通信的 API。
- en: The first API will be a Product API, which will be introduced in [*Chapter 2*](B21843_02.xhtml#_idTextAnchor050)
    . This API, as its name suggests, is focused on product operations, such as reading
    product data and adding new products.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个 API 将是产品 API，它将在 [*第 2 章*](B21843_02.xhtml#_idTextAnchor050) 中介绍。这个 API，正如其名称所暗示的，专注于产品操作，例如读取产品数据和添加新产品。
- en: The second API will be the Order Management API. It will be introduced in [*Chapter
    4*](B21843_04.xhtml#_idTextAnchor096) and will hold the orders containing the
    products stored in the first API, so they will communicate with each other.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个 API 将是订单管理 API。它将在 [*第 4 章*](B21843_04.xhtml#_idTextAnchor096) 中介绍，并将包含存储在第一个
    API 中的产品订单，因此它们将相互通信。
- en: Throughout the chapters, you will be able to implement these APIs, apply most
    of the best practices mentioned in this chapter, evolve these, document, test,
    and version to guarantee backward compatibility, implement tracing tools, and
    deploy to the cloud.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在整个章节中，您将能够实现这些 API，应用本章中提到的大多数最佳实践，进化这些实践，进行文档编制、测试和版本控制，以确保向后兼容性，实现跟踪工具，并将它们部署到云端。
- en: Summary
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned the difference between REST and RESTful, and why
    the REST approach is the preferred method for building API web services compared
    to previous methods used before.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学习了 REST 和 RESTful 之间的区别，以及为什么与之前使用的方法相比，REST 方法是构建 API Web 服务的首选方法。
- en: We have investigated the principles of REST architecture, the levels of using
    the Richardson Maturity Model, and the existing alternatives to REST.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经研究了REST架构的原则、使用Richardson成熟度模型的级别以及现有的REST替代方案。
- en: Then, we looked at the role of JSON in REST services and the importance of following
    well-defined guidelines proven by numerous projects while developing REST web
    services.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们探讨了JSON在REST服务中的作用以及遵循经过众多项目验证的良好定义指南在开发REST网络服务中的重要性。
- en: Lastly, we investigated the architectural impact of REST API design and the
    project that will be built throughout this book in the following chapters.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在以下章节中调查了REST API设计对架构的影响以及本书中将要构建的项目。
- en: This chapter presents the basics for you to get started with the upcoming content
    that will be presented and built throughout this book.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 本章为您提供了基础知识，以便您开始学习本书将要呈现和构建的内容。
- en: In the next chapter, we will explore the design and practical implementation
    of RESTful APIs using Spring Boot.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨使用Spring Boot设计和实现RESTful API的实践。
