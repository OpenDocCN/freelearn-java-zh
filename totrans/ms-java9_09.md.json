["```java\n    import java.io.IOException;\n    import java.time.Duration;\n    import java.time.Instant;\n    public class ProcessHandleDemonstration\n    {\n      public static void main(String[] args) throws \n       InterruptedException, IOException\n      {\n        provideProcessInformation(ProcessHandle.current());\n        Process theProcess = new\n         ProcessBuilder(\"SnippingTool.exe\").start();\n        provideProcessInformation(theProcess.toHandle());\n        theProcess.waitFor();\n        provideProcessInformation(theProcess.toHandle());\n      }\n      static void provideProcessInformation(ProcessHandle theHandle)\n      {\n        // get id\n        long pid = ProcessHandle.current().pid();\n        // Get handle information (if available)\n        ProcessHandle.Info handleInformation = theHandle.info();\n        // Print header\n        System.out.println(\"|=============================|\");\n        System.out.println(\"| INFORMATION ON YOUR PROCESS |\");\n        System.out.println(\"|=============================|\\n\");\n        // Print the PID\n        System.out.println(\"Process id (PID): \" + pid);\n        System.out.println(\"Process Owner: \" + \n          handleInformation.user().orElse(\"\"));\n        // Print additional information if available\n        System.out.println(\"Command:\" + \n         handleInformation.command().orElse(\"\"));\n        String[] args = handleInformation.arguments().orElse\n         (new String[]{});\n        System.out.println(\"Argument(s): \");\n        for (String arg: args) System.out.printf(\"\\t\" + arg);\n        System.out.println(\"Command line: \" + handleInformation.\n         commandLine().orElse(\"\"));\n        System.out.println(\"Start time: \" + \n         handleInformation.startInstant().\n         orElse(Instant.now()).toString());\n        System.out.printf(\"Run time duration: %sms%n\",\n         handleInformation.totalCpuDuration()\n         .orElse(Duration.ofMillis(0)).toMillis());\n      }\n    }\n```", "```java\n    package packt.mastering.java9.process;\n\n    import java.io.IOException;\n\n    public class ChildLister {\n      public static void main(String[] args) throws IOException {\n        for (int i = 0; i < 10; i++) {\n          new ProcessBuilder().command(\"cmd.exe\").start();\n        }\n        System.out.println(\"Number of children :\" +\n         ProcessHandle.current().children().count());\n      }\n    }\n```", "```java\n    package packt.mastering.java9.process;\n\n    import java.io.IOException;\n    import java.util.stream.Collectors;\n\n    public class DescendantLister {\n      public static void main(String[] args) throws IOException {\n        for (int i = 0; i < 10; i++) {\n          new ProcessBuilder().command(\"cmd.exe\",\"/K\",\"cmd\").                \n           start();\n        }\n        System.out.println(\"Number of descendants: \" +\n         ProcessHandle.current().descendants().count();\n      }\n    }\n```", "```java\n    package packt.mastering.java9.process;\n    import java.lang.ProcessHandle.Info;\n    public class ProcessLister {\n      private static void out(String format, Object... params) {\n        System.out.println(String.format(format, params));\n      }\n      private static boolean looksLikeJavaProcess(Info info) {\n        return info.command().isPresent() &&\n         info.command().get().\n         toLowerCase().indexOf(\"java\") != -1;\n      }\n\n      public static void main(String[] args) {\n        ProcessHandle.allProcesses().\n         map(ProcessHandle::info).\n         filter(info -> looksLikeJavaProcess(info)).\n         forEach(\n           (info) -> System.out.println(\n             info.command().orElse(\"---\"))\n         );\n      }\n\n    }\n```", "```java\n    package packt.mastering.java9.process; \n\n    public class WaitForChildToBeTerminated  \n    { \n      public static void main(String[] args) \n       throws InterruptedException  \n      { \n        Thread.sleep(10_000); \n      } \n    } \n```", "```java\n    package packt.mastering.java9.process;\n\n    import java.io.IOException;\n    import java.util.Arrays;\n    import java.util.concurrent.CompletableFuture;\n    import java.util.stream.Collectors;\n\n    public class TerminateAProcessAfterWaiting {\n      private static final int N = 10;\n\n      public static void main(String[] args)\n       throws IOException, InterruptedException {  \n         ProcessHandle ph[] = new ProcessHandle[N];\n\n         for (int i = 0; i < N; i++)  \n         {\n           final ProcessBuilder pb = ew ProcessBuilder(). \n            command(\"java\", \"-cp\", \"build/classes/main\",\n            \"packt.mastering.java9.process.\n            WaitForChildToBeTerminated\");\n           Process p = pb.start();\n           ph[i] = p.toHandle();\n         }\n         long start = System.currentTimeMillis();\n         Arrays.stream(ph).forEach(ProcessHandle::destroyForcibly);\n\n         CompletableFuture.allOf(Arrays.stream(ph).\n          map(ProcessHandle::onExit).\n          collect(Collectors.toList()).\n          toArray(new CompletableFuture[ph.length])).\n          join();\n         long duration = System.currentTimeMillis() - start;\n         System.out.println(\"Duration \" + duration + \"ms\");\n      }\n    }\n```", "```java\n    public static void main(String[] args) throws IOException, \n     InterruptedException  \n    {\n      // DemoOutput.out() simulated - implementation no shown\n      DemoOutput.out(new File(\".\").getAbsolutePath().toString());\n      if (args.length == 0)    {\n        System.err.println(\"Usage: daemon directory\");\n        System.exit(-1);\n      }\n      Set<Parameters> params = parametersSetFrom(args[0]);\n      Thread t = new Thread(new ControlDaemon(params));\n      t.start();\n    }\n```", "```java\n    private static Set<Parameters>  \n     GetListOfFilesInDirectory(String directory) throws IOException  \n    {\n      return Files.walk(Paths.get(directory))\n       .map(Path::toFile)\n       .filter(File::isFile)\n       .map(file -> Parameters.fromFile(file))\n       .collect(Collectors.toSet());\n    }\n```", "```java\n    final String[] commandLine;\n\n    public Parameters(String[] commandLine) {\n      this.commandLine = commandLine;\n    }\n```", "```java\n    private static String[] getCommandLineStrings(Properties props)  \n    {\n      return Optional\n       .ofNullable(props.getProperty(\"commandLine\"))\n       .orElse(\"\")\n       .split(\"\\\\s+\");\n    }\n```", "```java\n    public static Parameters fromFile(final File file)  \n    {\n      final Properties props = new Properties();\n      try (final InputStream is = new FileInputStream(file)) {\n        props.load(is);\n      }  catch (IOException e) {\n           throw new RuntimeException(e);\n      }\n      return new Parameters(getCommandLineStrings(props));\n    }\n```", "```java\n    public class ParamsAndHandle  \n    {\n      final Parameters params;\n      ProcessHandle handle;\n\n      public ParamsAndHandle(Parameters params,\n        ProcessHandle handle) {\n          this.params = params;\n          this.handle = handle;\n      }\n\n      public ProcessHandle toHandle() {\n        return handle;\n      }\n    }\n```", "```java\n    private final Set<ParamsAndHandle> handlers;\n\n    public ControlDaemon(Set<Parameters> params) {\n      handlers = params\n      .stream()\n      .map( s -> new ParamsAndHandle(s,null))\n      .collect(Collectors.toSet());\n    }\n```", "```java\n    @Override\n    public void run() {\n      try {\n        for (ParamsAndHandle pah : handlers) {\n          log.log(DEBUG, \"Starting {0}\", pah.params);\n          ProcessHandle handle = start(pah.params);\n          pah.handle = handle;\n        }\n        keepProcessesAlive();\n        while (handlers.size() > 0) {\n          allMyProcesses().join();\n        } \n      } catch (IOException e)  \n        {\n          log.log(ERROR, e);\n        }\n    }\n```", "```java\n    private void keepProcessesAlive()  \n    {\n      anyOfMyProcesses()\n       .thenAccept(ignore -> {\n         restartProcesses();\n         keepProcessesAlive();\n       });\n    }\n```", "```java\n    private void restartProcesses()  \n    {\n      Set<ParamsAndHandle> failing = new HashSet<>();\n      handlers.stream()\n       .filter(pah -> !pah.toHandle().isAlive())\n       .forEach(pah -> {\n         try {\n           pah.handle = start(pah.params);\n         } catch (IOException e) {\n             failing.add(pah);\n         }\n       });\n       handlers.removeAll(failing);\n    }\n```", "```java\n    private CompletableFuture anyOfMyProcesses()  \n    {\n      return CompletableFuture.anyOf(\n        completableFuturesOfTheProcesses());\n    }\n\n    private CompletableFuture allMyProcesses() {\n      return CompletableFuture.allOf(\n        completableFuturesOfTheProcesses());\n    }\n```", "```java\n    private CompletableFuture[] completableFuturesOfTheProcesses()  \n    {\n      return handlers.stream()\n       .map(ParamsAndHandle::toHandle)\n       .map(ProcessHandle::onExit)\n       .collect(Collectors.toList())\n       .toArray(new CompletableFuture[handlers.size()]);\n    }\n```", "```java\n    private ProcessHandle start(Parameters params)\n     throws IOException {\n       return new ProcessBuilder(params.commandLine)\n        .start()\n        .toHandle();\n    }\n```"]