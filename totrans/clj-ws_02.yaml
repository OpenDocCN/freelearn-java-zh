- en: 2\. Data Types and Immutability
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2. 数据类型和不可变性
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: 'In this chapter, we start by discovering the concept of immutability and its
    relevance in modern programs. We then examine simple data types such as strings,
    numbers and booleans, highlighting subtle differences in different environments
    like Clojure and ClojureScript. After a first exercise, we move on to more elaborated
    data types with collections such as lists, vectors, maps and sets, learning along
    the way which to use in different situations. After touching on the collection
    and sequence abstractions, we learn new techniques for working with nested data
    structures, before finally moving on to the final activity: implementing our very
    own in-memory database.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们首先探讨不可变性的概念及其在现代程序中的相关性。然后我们检查简单的数据类型，如字符串、数字和布尔值，强调在不同环境（如Clojure和ClojureScript）中的细微差异。在完成第一个练习后，我们继续探讨更复杂的数据类型，如列表、向量、映射和集合，并在不同情况下学习如何使用它们。在触及集合和序列抽象之后，我们学习处理嵌套数据结构的新技术，最后转向最终活动：实现我们自己的内存数据库。
- en: By the end of this chapter, you will be able to work with the commonly used
    data types in Clojure.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够使用Clojure中常用的数据类型。
- en: Introduction
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Computer hardware has evolved dramatically in the last few decades. On a typical
    computer, storage and memory capacity have both increased a millionfold compared
    to the early 1980s. Nonetheless, standard industry practices in software development
    and mainstream ways of programming are not that different. Programming languages
    such as C++, Java, Python, and Ruby still typically encourage you to change things
    in place, and to use variables and mutate the state of a program, that is, to
    do things as if we were programming on a computer with a minimal amount of memory.
    However, in our quest for efficiency, better languages, and better tools, we reach
    for higher-level languages. We want to get further away from machine code. We
    want to write less code and let the computers do the tedious work.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的几十年里，计算机硬件发生了巨大的变化。在典型的计算机上，存储和内存容量与20世纪80年代初相比都增加了百万倍。然而，软件开发中的标准行业实践和主流编程方式并没有太大的不同。像C++、Java、Python和Ruby这样的编程语言仍然通常鼓励你就地更改事物，并使用变量来修改程序的状态，也就是说，就像我们在内存最少的计算机上编程一样。然而，在我们追求效率、更好的语言和更好的工具的过程中，我们转向了高级语言。我们希望离机器代码更远。我们希望编写更少的代码，让计算机做繁琐的工作。
- en: We don't want to think about the computer's memory anymore, such as where a piece of
    information is stored and whether it's safe and shareable, as much as we don't
    want to know about the order of the instructions in the CPU. It is a distraction
    to the problems we are trying to solve, which are already complicated enough.
    If you have ever tried to do some multithreading in the languages cited previously,
    you will know the pain of sharing data between threads. Although, leveraging multicore
    CPUs with multithreaded applications is an essential part of optimizing a modern
    program's performance.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不再需要考虑计算机的内存，比如信息存储在哪里，它是否安全且可共享，就像我们不想知道CPU中指令的顺序一样。这会分散我们试图解决的问题的注意力，这些问题已经足够复杂。如果你曾经尝试在之前提到的语言中做一些多线程操作，你就会知道线程间共享数据的痛苦。尽管如此，利用多核CPU和多线程应用程序是优化现代程序性能的一个关键部分。
- en: 'In Clojure, we work almost exclusively with immutable data types. They are
    safe to share, easy to fabricate, and improve the readability of our source code.
    Clojure provides the necessary tools to write programs with the functional programming
    paradigm: first-class citizen functions, which we will discover in the next chapter,
    and avoiding mutating and sharing the state of an application with immutable data
    types.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在Clojure中，我们几乎完全使用不可变数据类型。它们可以安全地共享，易于制造，并提高我们源代码的可读性。Clojure提供了编写函数式编程范式程序的必要工具：一等公民函数，我们将在下一章中了解到，以及避免使用不可变数据类型来修改和共享应用程序的状态。
- en: 'Let''s dust off the dictionary and look up the definition of immutable, "*Immutable:
    that cannot be changed; that will never change.*" It doesn''t mean that a piece
    of information cannot change over time, but we record those modifications as a
    series of new values. "Updating" an immutable data structure provides a new value
    derived from the original value. However, the original value remains unchanged
    – those data structures that preserve previous versions of themselves are called
    persistent data structures.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们翻阅一下词典，查找“不可变”的定义，“*不可变：不能改变；永远不会改变*”。这并不意味着信息不能随时间改变，但我们把这些修改记录为一系列新的值。“更新”不可变数据结构提供了一个从原始值派生的新值。然而，原始值保持不变——那些保留自身先前版本的数据结构被称为持久数据结构。
- en: Intuitively, we may think that such a persistent data structure would negatively
    impact performance, but it's not as bad as it seems. They are optimized for performance,
    and techniques such as structural sharing bring the time complexity of all operations
    close to classic, mutable implementations.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 直觉上，我们可能会认为这样的持久数据结构会对性能产生负面影响，但事实并非如此。它们针对性能进行了优化，并且像结构共享这样的技术将所有操作的时间复杂度接近于经典的、可变的实现。
- en: In other terms, unless you are programming an application that requires extraordinarily
    high performance, such as a video game, the benefits of using immutable data structures
    far outweigh the small loss in performance.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 从另一个角度来看，除非你正在编写一个需要非凡高性能的应用程序，例如视频游戏，否则使用不可变数据结构的优势远远超过性能上的小损失。
- en: Simple Data Types
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简单数据类型
- en: 'A data type designates what kind of value a piece of data holds; it is a fundamental
    way of classifying data. Different types allow different kinds of operations:
    we can concatenate strings, multiply numbers, and perform logic algebra operations
    with Booleans. Because Clojure has a strong emphasis on practicality, we don''t
    explicitly assign types to values in Clojure, but those values still have a type.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 数据类型指定了数据块所持有的值的类型；它是分类数据的基本方式。不同的类型允许不同的操作：我们可以连接字符串，乘以数字，以及使用布尔值进行逻辑代数运算。由于Clojure非常注重实用性，我们在Clojure中并不显式地为值分配类型，但这些值仍然有类型。
- en: Clojure is a hosted language and has three notable, major implementations in
    Java, JavaScript, and .NET. Being a hosted language is a useful trait that allows
    Clojure programs to run in different environments and take advantage of the ecosystem
    of its host. Regarding data types, it means that each implementation has different
    underlying data types, but don't worry as those are just implementation details.
    As a Clojure programmer, it does not make much difference, and if you know how
    to do something in Clojure, you likely know how to do it in, say, ClojureScript.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Clojure是一种托管语言，在Java、JavaScript和.NET中有三个显著的、主要的实现。作为一个托管语言，这是一个有用的特性，它允许Clojure程序在不同的环境中运行并利用其宿主环境的生态系统。关于数据类型，这意味着每个实现都有不同的底层数据类型，但不用担心，这些只是实现细节。作为一个Clojure程序员，这并没有太大的区别，如果你知道如何在Clojure中做某事，你很可能也知道如何在，比如说，ClojureScript中做同样的事情。
- en: 'In this topic, we will go through Clojure''s simple data types. Here is the
    list of the data types looked at in this section. Please note that the following
    types are all immutable:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个主题中，我们将介绍Clojure的简单数据类型。以下是本节中查看的数据类型列表。请注意，以下类型都是不可变的：
- en: Strings
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串
- en: Numbers
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数字
- en: Booleans
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 布尔值
- en: Keywords
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关键字
- en: Nil
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空值（nil）
- en: Strings
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串
- en: Strings are sequences of characters representing text. We have been using and
    manipulating strings since the first exercise of *Chapter 1*, *Hello REPL.*
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串是表示文本的字符序列。我们从*第一章*，*Hello REPL*的第一个练习开始就一直在使用和处理字符串。
- en: 'You can create a string by simply wrapping characters with double quotes (`"`):'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过简单地用双引号（`"`）包裹字符来创建字符串：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'String literals are only created with double quotes, and if you need to use
    double quotes in a string, you can escape them with the backslash character (`\`):'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串字面量只能用双引号创建，如果你需要在字符串中使用双引号，你可以用反斜杠字符（`\`）来转义它们：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Strings are not able to be changed; they are immutable. Any function that claims
    to transform a string yields a new value:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串不能被改变；它们是不可变的。任何声称可以转换字符串的函数都会产生一个新的值：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the preceding example, calling `clojure.string/replace` on `silly-string`
    returned a new string with the word "silly" replaced with "clever." However, when
    evaluating `silly-string` again, we can see that the value has not changed. The
    function returned a different value and did not change the original string.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，对 `silly-string` 调用 `clojure.string/replace` 返回了一个新的字符串，其中 "silly" 被替换为
    "clever"。然而，当再次评估 `silly-string` 时，我们可以看到值没有改变。函数返回了一个不同的值，并且没有改变原始字符串。
- en: 'Although a string is usually a single unit of data representing text, Strings
    are also collections of characters. In the JVM implementation of Clojure, strings
    are of the `java.lang.String` Java type and they are implemented as collections
    of the `java.lang.Character` Java type, such as the following command, which returns
    a character:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然字符串通常是一个表示文本的单个数据单元，但字符串也是字符的集合。在 Clojure 的 JVM 实现中，字符串是 `java.lang.String`
    Java 类型，它们被实现为 `java.lang.Character` Java 类型的集合，如下面的命令所示，它返回一个字符：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`first` returns the first element of a collection. Here, the literal notation
    of a character is `\a`. The `type` function returns a string representation of
    the data type for a given value. Remember that we can use `*1` to retrieve the
    last returned value in the REPL, so `*1` evaluates to `\a`.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`first` 返回集合的第一个元素。在这里，字符的文表示法是`\a`。`type` 函数返回给定值的类型字符串表示。记住，我们可以使用 `*1` 来检索
    REPL 中最后返回的值，所以 `*1` 的结果是 `\a`。'
- en: 'It is interesting to note that, in ClojureScript, strings are collections of
    one-character strings, because there is no character type in JavaScript. Here
    is a similar example in a ClojureScript REPL:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，在 ClojureScript 中，字符串是一组单字符字符串的集合，因为 JavaScript 中没有字符类型。以下是一个类似的 ClojureScript
    REPL 中的例子：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As with the Clojure REPL, `type` returns a string representation of the data
    type. This time, in ClojureScript, the value returned by the `last` function (which
    returns the last character of a string) is of the `#object[String]` type, which
    means a JavaScript string.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Clojure REPL 一样，`type` 返回数据类型的字符串表示。这次，在 ClojureScript 中，`last` 函数（返回字符串的最后一个字符）返回的是
    `#object[String]` 类型，这意味着一个 JavaScript 字符串。
- en: 'You can find a few common functions for manipulating strings in the core namespace,
    such as `str`, which we used in *Chapter 1*, *Hello REPL!*, to concatenate (combine
    multiple strings together into one string):'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在核心命名空间中找到一些用于操作字符串的常见函数，例如 `str`，我们在 *第一章*，*Hello REPL!* 中使用它来连接（将多个字符串组合成一个字符串）：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Most functions for manipulating strings can be found in the `clojure.string`
    namespace. Here is a list of them using the REPL `dir` function:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数字符串操作函数都可以在 `clojure.string` 命名空间中找到。以下是使用 REPL `dir` 函数列出的一些函数：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'As a reminder, this is how you can use a function from a specific namespace:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 作为提醒，这是您如何使用特定命名空间中的函数：
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We will not cover all the string functions, but feel free to try them out now.
    You can always look up the documentation of a string function from the preceding
    list with the `doc` function.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会涵盖所有的字符串函数，但现在您可以随意尝试它们。您始终可以使用 `doc` 函数查找前面列表中字符串函数的文档。
- en: Numbers
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数字
- en: Clojure has good support for numbers and you will most likely not have to worry
    about the underlying types, as Clojure will handle pretty much anything. However,
    it is important to note that there are a few differences between Clojure and ClojureScript
    in that regard.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Clojure 对数字有很好的支持，您很可能不需要担心底层类型，因为 Clojure 将处理几乎所有事情。然而，重要的是要注意，在 Clojure 和
    ClojureScript 之间，在这方面有一些差异。
- en: 'In Clojure, by default, natural numbers are implemented as the `java.lang.Long`
    Java type unless the number is too big for `Long`. In that case, it is typed `clojure.lang.BigInt`:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Clojure 中，默认情况下，自然数以 `java.lang.Long` Java 类型实现，除非数字太大而无法适合 `Long`。在这种情况下，它被类型化为
    `clojure.lang.BigInt`：
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Notice, in the preceding example, that the number was too big to fit in the
    `java.lang.Long` Java type and, therefore, was implicitly typed `clojure.lang.BigInt`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在前面的例子中，数字太大，无法适合 `java.lang.Long` Java 类型，因此被隐式地类型化为 `clojure.lang.BigInt`。
- en: 'Exact ratios are represented by Clojure as "Ratio" types, which have a literal
    representation. 5/4 is not an exact ratio, so the output is the ratio itself:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 精确比例在 Clojure 中表示为 "Ratio" 类型，它有文表示法。5/4 不是一个精确比例，所以输出是比例本身：
- en: '[PRE9]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The result of dividing `3` by `4` can be represented by the ratio 3/4:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `3` 除以 `4` 的结果可以用比例 3/4 来表示：
- en: '[PRE10]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '`4/4` is equivalent to `1` and is evaluated as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`4/4` 等于 `1`，其计算如下：'
- en: '[PRE11]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Decimal numbers are "double" precision floating-point numbers:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 小数是“双精度”浮点数：
- en: '[PRE12]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If we take our division of 3 by 4 again, but this time mix in a "Double" type,
    we will not get a ratio as a result:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们再次进行3除以4的除法，但这次混合使用“Double”类型，我们将不会得到一个比率作为结果：
- en: '[PRE13]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This is because floating-point numbers are "contagious" in Clojure. Any operation
    involving floating-point numbers will result in a float or a double:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为在Clojure中，浮点数是“传染性”的。任何涉及浮点数的操作都会导致得到一个浮点数或双精度浮点数：
- en: '[PRE14]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In ClojureScript, however, numbers are just "JavaScript numbers," which are
    all double-precision floating-point numbers. JavaScript does not define different
    types of numbers like Java and some other programming languages do (for example,
    `long`, `integer`, and `short`):'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在ClojureScript中，数字只是“JavaScript数字”，它们都是双精度浮点数。JavaScript没有定义像Java和一些其他编程语言那样的不同数字类型（例如，`long`、`integer`和`short`）：
- en: '[PRE15]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Notice that, this time, any operation returns a floating-point number. The fact
    that there is no decimal separation for `1` or `2` is just a formatting convenience.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这次，任何操作都会返回一个浮点数。`1`或`2`没有小数分隔只是格式上的便利。
- en: 'We can make sure that all those numbers are JavaScript numbers (double-precision,
    floating-point) by using the `type` function:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用`type`函数来确保所有这些数字都是JavaScript数字（双精度，浮点数）：
- en: '[PRE16]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: If you need to do more than simple arithmetic, you can use the Java or JavaScript
    `math` libraries, which are similar except for a few minor exceptions.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要做比简单算术更复杂的事情，你可以使用Java或JavaScript的`math`库，它们非常相似，除了少数例外。
- en: 'You will learn more about host platform interoperability in *Chapter 9*, *Host
    Platform Interoperability with Java and JavaScript* (how to interact with the
    host platform and its ecosystem), but the examples in the chapter will get you
    started with doing some more complicated math and with using the `math` library:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在第9章*主机平台互操作性*（如何与主机平台及其生态系统交互）中了解更多关于主机平台互操作性的内容，但该章节中的示例将帮助你开始做一些更复杂的数学运算，以及使用`math`库：
- en: 'Reading a value from a constant can be done like this:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 从一个常量中读取值可以这样操作：
- en: '[PRE17]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'And calling a function, like the usual Clojure functions, can be done like
    this:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 调用一个函数，就像通常的Clojure函数一样，可以这样操作：
- en: '[PRE18]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Exercise 2.01: The Obfuscation Machine'
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习2.01：混淆机
- en: You have been contacted by a secret government agency to develop an algorithm
    that encodes text into a secret string that only the owner of the algorithm can
    decode. Apparently, they don't trust other security mechanisms such as SSL and
    will only communicate sensitive information with their own proprietary technology.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 你被一个秘密政府机构联系，要求开发一个算法，将文本编码成一个只有算法所有者才能解码的秘密字符串。显然，他们不相信其他安全机制，如SSL，而只愿意用他们自己的专有技术来传输敏感信息。
- en: You need to develop an `encode` function and a `decode` function. The `encode`
    function should replace letters with numbers that are not easily guessable. For
    that purpose, each letter will take the character's number value in the ASCII
    table, add another number to it (the number of words in the sentence to encode),
    and finally, compute the square value of that number. The `decode` function should
    allow the user to revert to the original string. Someone highly ranked in the
    agency came up with that algorithm so they trust it to be very secure.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要开发一个`encode`函数和一个`decode`函数。`encode`函数应该用不易猜测的数字替换字母。为此，每个字母将取其在ASCII表中的字符数值，然后加上另一个数字（要编码的句子中的单词数），最后计算该数字的平方值。`decode`函数应该允许用户恢复到原始字符串。一个高级别的机构成员提出了这个算法，所以他们相信它非常安全。
- en: 'In this exercise, we will put into practice some of the things we''ve learned
    about strings and numbers by building an obfuscation machine:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将通过构建一个混淆机来实践我们关于字符串和数字学到的一些知识：
- en: 'Start your REPL and look up the documentation of the `clojure.string/replace`
    function:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动你的REPL并查找`clojure.string/replace`函数的文档：
- en: '[PRE19]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Notice that the `replace` function can take a pattern and a function of the
    matching result as parameters. We don't know how to iterate over collections yet,
    but using the `replace` function with a pattern and a "replacement function" should
    do the job.
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，`replace`函数可以接受一个模式和匹配结果的函数作为参数。我们目前还不知道如何遍历集合，但使用带有模式和“替换函数”的`replace`函数应该可以完成任务。
- en: 'Try and use the `replace` function with the `#"\w"` pattern (which means word
    character), replace it with the `!` character, and observe the result:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试使用`#"\w"`模式（表示单词字符）的`replace`函数，将其替换为`!`字符，并观察结果：
- en: '[PRE20]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The output is as follows:'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE21]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Try and use the `replace` function with the same pattern, but this time passing
    an anonymous function that takes the matching letter as a parameter:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试使用相同的模式使用`replace`函数，但这次传递一个匿名函数，该函数接受匹配的字母作为参数：
- en: '[PRE22]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The output is as follows:'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE23]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Observe that the function was called for each letter, printing the match out
    to the console and finally returning the string with the matches replaced by the
    `!` character. It looks like we should be able to write our encoding logic in
    that replacement function.
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 观察到函数为每个字母调用了，将匹配打印到控制台，并最终返回用`!`字符替换的字符串。看起来我们应该能够在那个替换函数中编写我们的编码逻辑。
- en: 'Let''s now see how we can convert a character to a number. We can use the `int`
    function, which coerces its parameter to an integer. It can be used like this:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们来看看如何将一个字符转换为数字。我们可以使用`int`函数，它将它的参数强制转换为整数。它可以这样使用：
- en: '[PRE24]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'It seems that the "replacement function" will take a string as a parameter,
    so let''s convert our string to a character. Use the `char-array` function combined
    with `first` to convert our string to a character as follows:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: “替换函数”似乎将接受一个字符串作为参数，所以让我们将我们的字符串转换为字符。使用`char-array`函数结合`first`将我们的字符串转换为字符，如下所示：
- en: '[PRE25]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now, if we combine previous steps together and also compute the square value
    of the character''s number, we should be approaching our obfuscation goal. Combine
    the code written previously to obtain a character code from a string and get its
    square value using the `Math/pow` function as follows:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，如果我们结合之前的步骤，并计算字符的数字的平方值，我们应该接近我们的混淆目标。将之前编写的代码组合起来，从字符串中获取字符代码并使用`Math/pow`函数计算其平方值，如下所示：
- en: '[PRE26]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Let''s now convert this result to the string that will be returned from our
    `replace` function. First, let''s remove the decimal part by coercing the result
    to an `int`, and put things together in an `encode-letter` function, as follows:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将这个结果转换成`replace`函数将返回的字符串。首先，通过将结果强制转换为`int`来删除小数部分，并在`encode-letter`函数中将这些内容组合起来，如下所示：
- en: '[PRE27]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Great! It seems to work. Let's now test our function as part of the `replace`
    function.
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 太好了！它似乎可以工作。现在让我们测试我们的函数作为`replace`函数的一部分。
- en: 'Create the `encode` function, which uses `clojure.string/replace` as well as
    our `encode-letter` function:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`encode`函数，它使用`clojure.string/replace`以及我们的`encode-letter`函数：
- en: '[PRE28]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: It seems to work but the resulting string will be hard to decode without being
    able to identify each letter individually.
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 它似乎可以工作，但如果没有能够单独识别每个字母，生成的字符串将很难解码。
- en: 'There is another thing that we did not take into account: the `encode` function
    should take an arbitrary number to add to the code before calculating the square
    value.'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们还有另一件事没有考虑到：`encode`函数应该在计算平方值之前添加一个任意数到代码中。
- en: 'First, add a separator as part of our `encode-letter` function, for example,
    the `#` character, so that we can identify each letter individually. Second, add
    an extra parameter to `encode-letter`, which needs to be added before calculating
    the square value:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在`encode-letter`函数中添加一个分隔符作为部分，例如`#`字符，这样我们就可以单独识别每个字母。其次，给`encode-letter`函数添加一个额外的参数，这个参数需要在计算平方值之前添加：
- en: '[PRE29]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now, test the `encode` function another time:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，再次测试`encode`函数：
- en: '[PRE30]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Our `encode` function is now failing because it is expecting an extra argument.
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们的`encode`函数现在失败了，因为它期望一个额外的参数。
- en: 'Modify the `encode` function to calculate the number of words in the text to
    obfuscate, and pass it to the `encode-letter` function. You can use the `clojure.string/split`
    function with a whitespace, as follows, to count the number of words:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`encode`函数以计算要混淆的文本中的单词数量，并将其传递给`encode-letter`函数。你可以使用`clojure.string/split`函数和空格，如下所示，来计算单词数量：
- en: '[PRE31]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Try your newly created function with a few examples and make sure it obfuscates
    strings properly:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用几个例子尝试你新创建的函数，并确保它正确地混淆字符串：
- en: '[PRE32]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: What a beautiful, unintelligible, obfuscated string – well done! Notice how
    the numbers for the same letters are different depending on the number of words
    in the phrase to encode. It seems to work according to the specification!
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是一个多么美丽、难以理解、混淆的字符串——做得好！注意，对于相同的字母，根据要编码的短语中的单词数量，数字是不同的。它似乎按照规范工作！
- en: 'We can now start working on the `decode` function, for which we will need to
    use the following functions:'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们现在可以开始编写 `decode` 函数，我们将需要使用以下函数：
- en: '`Math/sqrt` to obtain the square root value of a number.'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Math/sqrt` 用于获取一个数字的平方根值。'
- en: '`char` to retrieve a letter from a character code (a number).'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`char` 用于从字符代码（一个数字）中检索一个字母。'
- en: '`subs` as in substring, to get a sub-portion of a string (and get rid of our
    `#` separator).'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`subs` 作为子字符串，用于获取字符串的一部分（并去除我们的 `#` 分隔符）。'
- en: '`Integer/parseInt` to convert a string to an integer.'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Integer/parseInt` 用于将字符串转换为整数。'
- en: 'Write the `decode` function using a combination of the preceding functions,
    to decode an obfuscated character:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用前面提到的函数的组合编写 `decode` 函数，以解码一个加密字符：
- en: '[PRE33]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Finally, write the `decode` function, which is similar to the `encode` function
    except that it should use `decode-letter` instead of `encode-letter`:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，编写 `decode` 函数，它与 `encode` 函数类似，但应该使用 `decode-letter` 而不是 `encode-letter`：
- en: '[PRE34]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Test your functions and make sure that they both work:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试你的函数，确保它们都能正常工作：
- en: '[PRE35]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The output is as follows:'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE36]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In this exercise, we've put into practice working with numbers and strings by
    creating an encoding system. We can now move on to learning other data types,
    starting with Booleans.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们通过创建一个编码系统来实践了处理数字和字符串。现在我们可以继续学习其他数据类型，从布尔值开始。
- en: Booleans
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 布尔值
- en: Booleans are implemented as Java's `java.lang.Boolean` in Clojure or JavaScript's
    "Boolean" in ClojureScript. Their value can either be `true` or `false`, and their
    literal notations are simply the lowercase `true` and `false`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Clojure 中，布尔值以 Java 的 `java.lang.Boolean` 实现，在 ClojureScript 中以 JavaScript
    的 "Boolean" 实现。它们的值可以是 `true` 或 `false`，它们的字面表示法仅仅是小写的 `true` 和 `false`。
- en: Symbols
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 符号
- en: 'Symbols are identifiers referring to something else. We have already been using
    symbols when creating bindings or calling functions. For example, when using `def`,
    the first argument is a symbol that will refer to a value, and when calling a
    function such as `+`, `+` is a symbol referring to the function implementing the
    addition. Consider the following examples:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 符号是标识符，它们指向其他东西。我们已经在使用符号创建绑定或调用函数时使用过符号。例如，当使用 `def` 时，第一个参数是一个将指向一个值的符号，当调用像
    `+` 这样的函数时，`+` 是一个指向实现加法的函数的符号。考虑以下示例：
- en: '[PRE37]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Here, we have created the `user/foo` symbol, which refers to the `"bar"` string,
    and the `add-2` symbol, which refers to the function that adds 2 to its parameter.
    We have created those symbols in the user namespace, hence the notation with `/`:
    `user/foo`.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了 `user/foo` 符号，它指向 `"bar"` 字符串，以及 `add-2` 符号，它指向将 2 加到其参数上的函数。我们是在用户命名空间中创建这些符号的，因此有
    `/` 的表示法：`user/foo`。
- en: 'If we try to evaluate a symbol that has not been defined, we''ll get an error:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试评估一个未定义的符号，我们会得到一个错误：
- en: '[PRE38]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'In the *REPL Basics* topic of *Chapter 1*, *Hello REPL!*, we were able to use
    the following functions because they are bound to a specific symbol:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *第一章* 的 *REPL 基础* 主题 *Hello REPL!* 中，我们能够使用以下函数，因为它们绑定到特定的符号：
- en: '[PRE39]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Those gibberish-like values are string representations of the functions, because
    we are asking for the values bound to the symbols rather than invoking the functions
    (wrapping them with parentheses).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类似乱码的值是函数的字符串表示，因为我们要求的是符号绑定的值，而不是调用函数（用括号包裹它们）。
- en: Keywords
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关键字
- en: 'You can think of a keyword as some kind of a special constant string. Keywords
    are a nice addition to Clojure because they are lightweight and convenient to
    use and create. You just need to use the colon character, `:`, at the beginning
    of a word to create a keyword:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将关键字视为某种特殊的常量字符串。关键字是 Clojure 的一个很好的补充，因为它们轻量级且易于使用和创建。你只需要在单词的开头使用冒号字符 `:`
    来创建一个关键字：
- en: '[PRE40]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: They don't refer to anything else like symbols do; as you can see in the preceding
    example, when evaluated, they just return themselves. Keywords are typically used
    as keys in a key-value associative map, as we will see in the next topic about
    collections.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 它们不像符号那样指向其他东西；正如前一个示例所示，当被评估时，它们只是返回自身。关键字通常用作键值关联映射中的键，正如我们将在关于集合的下一个主题中看到的那样。
- en: In this section, we went through simple data types such as string, numbers,
    Boolean, symbols, and keywords. We highlighted how their underlying implementation
    depends on the host platform because Clojure is a hosted language. In the next
    section, we will see how those values can aggregate to collections.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们介绍了简单的数据类型，如字符串、数字、布尔值、符号和关键字。我们强调了它们的底层实现依赖于宿主平台，因为Clojure是一种托管语言。在下一节中，我们将看到这些值如何聚合成为集合。
- en: Collections
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集合
- en: Clojure is a functional programming language in which we focus on building the
    computations of our programs in terms of the evaluation of functions, rather than
    building custom data types and their associated behaviors. In the other dominant
    programming paradigm, object-oriented programming, programmers define the data
    types and the operations available on them. Objects are supposed to encapsulate
    data and communicate with each other by passing messages around. But there is
    an unfortunate tendency to create classes and new types of objects to customize
    the shape of the data, instead of using more generic data structures, which cascades
    into creating specific methods to access and modify the data. We have to come
    up with decent names, which is difficult, and then we pass instances of objects
    around in our programs. We create new classes all the time, but more code means
    more bugs. It is a recipe for disaster; it is an explosion of code, with code
    that is very specific and benefits from little reuse.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: Clojure是一种函数式编程语言，我们专注于以函数评估的方式来构建程序的计算，而不是构建自定义数据类型及其相关行为。在另一种主导的编程范式，面向对象编程中，程序员定义数据类型及其上的操作。对象应该封装数据并通过传递消息进行交互。但不幸的是，有一种趋势是创建类和新类型的对象来定制数据形状，而不是使用更通用的数据结构，这导致需要创建特定的方法来访问和修改数据。我们必须想出合适的名字，这很困难，然后我们在程序中传递对象的实例。我们不断创建新的类，但更多的代码意味着更多的错误。这是一场灾难；它是一场代码爆炸，代码非常具体且很少重用。
- en: Of course, it is not like that everywhere, and you can write clean object-oriented
    code, with objects being the little black boxes of functionality they were designed
    for. However, as programmers, whether it's through using other libraries or maintaining
    a legacy code base, we spend most of our time working with other people's code.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，并非所有地方都是这样，你也可以编写干净的面向对象代码，其中对象是它们设计用于的功能的小黑盒。然而，作为程序员，无论是通过使用其他库还是维护遗留代码库，我们大部分时间都在处理他人的代码。
- en: In functional programming, and more specifically, in Clojure, we tend to work
    with just a few data types. Types that are generic and powerful, types that every
    other "Clojurian" already knows and has mastered.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数式编程中，特别是在Clojure中，我们倾向于只使用少数几种数据类型。这些类型是通用的且功能强大，是每个其他“Clojurian”（Clojure程序员）都已经了解并掌握的类型。
- en: Collections are data types that can contain more than one thing and describe
    how those items relate to each other. The four main data structures for collections
    that you should know about are **Maps**, **Sets**, **Vectors**, and **Lists**.
    There are more available, including the data structure offered by your host platform
    (for example, Java or JavaScript) or other libraries, but those four are your
    bread and butter for doing things in Clojure.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 集合是能够包含多个元素并描述这些元素之间相互关系的数据类型。你应该了解的四个主要集合数据结构是**映射（Maps**）、**集合（Sets**）、**向量（Vectors**）和**列表（Lists**）。还有更多可供选择的数据结构，包括由你的宿主平台（例如Java或JavaScript）或其他库提供的数据结构，但那四个是你在Clojure中做事的基础。
- en: '*"Data dominates. If you''ve chosen the right data structures and organized
    things well, the algorithms will almost always be self-evident. Data structures,
    not algorithms, are central to programming." - Rob Pike''s Rule #5 of programming.*'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '*"数据为王。如果你选择了正确的数据结构并且组织得当，算法几乎总是显而易见的。数据结构，而非算法，是编程的核心。" - Rob Pike的编程规则第5条。*'
- en: Maps
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 映射（Maps）
- en: A Map is a collection of key-value pairs. Clojure provides – in a persistent
    and immutable fashion – the usual HashMap but also a SortedMap.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 映射（Map）是一组键值对。Clojure以持久和不可变的方式提供了常规的HashMap，同时也提供了SortedMap。
- en: HashMaps are called "Hash" because they create a hash of the key and map it
    to a given value. Lookups, as well as other common operations (`insert` and `delete`),
    are fast.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: HashMap被称为“Hash”，因为它们会对键创建哈希并映射到给定的值。查找以及其他常见操作（如`insert`和`delete`）都很快。
- en: HashMaps are used a lot in Clojure, notably, for representing entities where
    we need to associate some attributes to some values. SortedMaps are different
    because they preserve the order of the keys; otherwise, they have the same interface
    and are used in the same way as HashMaps. SortedMaps are not very common, so let's
    focus on HashMaps.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: HashMap在Clojure中用得很多，特别是在需要将一些属性关联到一些值来表示实体时。SortedMap与HashMap不同，因为它们保留了键的顺序；否则，它们具有相同的接口，并且以相同的方式使用。SortedMap并不常见，所以让我们专注于HashMap。
- en: 'You can create a HashMap with the literal notation using curly braces. Here
    is a Map with three key-value pairs, with the keys being the `:artist`, `:song`,
    and `:year` keywords:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用花括号字面量语法来创建HashMap。以下是一个包含三个键值对的映射，键是`:artist`、`:song`和`:year`关键字：
- en: '[PRE41]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: You might have noticed in the preceding example that key-value pairs in the
    map are separated by a space, but Clojure evaluates it and returns a Map with
    key-value pairs separated by a comma. As with other collections, you can choose
    to use a space or a comma to separate each entry. For maps, there's no best practice
    and if you think it improves a map's readability, use commas; otherwise, simply
    omit them. You can also separate entries with new lines.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到在前面的例子中，映射中的键值对是通过空格分隔的，但Clojure会对其进行评估，并返回一个用逗号分隔键值对的映射。与其他集合一样，你可以选择使用空格或逗号来分隔每个条目。对于映射，没有最佳实践，如果你认为使用逗号可以提高映射的可读性，那么就使用逗号；否则，简单地省略它们。你也可以使用换行符来分隔条目。
- en: 'Here''s another map written with comma-separated entries:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还有一个用逗号分隔的条目编写的映射：
- en: '[PRE42]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Notice that the values can be of any type, and not only simple values such
    as strings and numbers, but also vectors and even other maps, allowing you to
    create nested data structures and structure information as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，值可以是任何类型，而不仅仅是简单的字符串和数字，还可以是向量甚至是其他映射，允许你创建嵌套数据结构并按如下方式组织信息：
- en: '[PRE43]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Keys can be of different types too, so you could have strings, numbers, or even
    other types as a key; however, we generally use keywords.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 键也可以是不同类型，所以你可以有字符串、数字，甚至是其他类型的键；然而，我们通常使用关键字。
- en: 'Another way of creating a map is by using the `hash-map` function, passing
    in pairs of arguments as follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 创建映射的另一种方式是使用`hash-map`函数，如下传递参数对：
- en: '[PRE44]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Choose to use literal notation with curly braces when possible, but when HashMaps
    are programmatically generated, the `hash-map` function can come in handy.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 当可能时，选择使用花括号字面量语法，但当HashMap是程序生成时，`hash-map`函数会很有用。
- en: 'Map keys are unique:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 映射键是唯一的：
- en: '[PRE45]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: An exception was thrown because the `:name` key was present twice in the preceding
    literal map.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 由于前一个字面量映射中`:name`键出现了两次，因此抛出了一个异常。
- en: 'However, different keys can have the same value:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，不同的键可以有相同的值：
- en: '[PRE46]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Notice that both `age` and `number-of-teeth` have the same value, and that is
    both valid and convenient, to say the least.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到`age`和`number-of-teeth`的值相同，这至少是有效且方便的。
- en: Now that you know how to create maps, it is time for a bit of practice.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 既然你已经知道了如何创建映射，那么是时候进行一些实践了。
- en: 'Exercise 2.02: Using Maps'
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习2.02：使用映射
- en: 'In this exercise, we will learn how to access and modify simple maps:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将学习如何访问和修改简单的映射：
- en: 'Start your REPL and create a map:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动你的REPL并创建一个映射：
- en: '[PRE47]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'You can read an entry from the map with the `get` function. Try to look up
    a key or two, as follows:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以使用`get`函数从映射中读取条目。尝试查找一个或两个键，如下所示：
- en: '[PRE48]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'If the value for a given key cannot be found, `get` returns `nil`, but you
    can specify a fallback value with a third argument to `get`:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果找不到给定键的值，`get`会返回`nil`，但你可以在`get`的第三个参数中指定一个回退值：
- en: '[PRE49]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Maps and keywords have the special ability to be used as functions. When positioned
    in the "operator position" (as the first item of the list), they are invoked as
    a function that can be used to look up a value in a map. Try it now by using the
    `favorite-fruit` map as a function:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 映射和关键字有特殊的能力可以作为函数使用。当它们位于“操作位置”（列表的第一个项目）时，它们会被调用为一个函数，可以用来在映射中查找值。现在尝试使用`favorite-fruit`映射作为函数来试试看：
- en: '[PRE50]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Try to use a keyword as a function to look up a value in a Map:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试使用关键字作为函数在映射中查找值：
- en: '[PRE51]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: As with the `get` function, those ways of retrieving a value return `nil` when
    the key cannot be found, and you can pass an extra argument to provide a fallback
    value.
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 与`get`函数一样，当找不到键时，这些获取值的方式会返回`nil`，并且你可以传递一个额外的参数来提供一个回退值。
- en: 'Provide a fallback value for a key that doesn''t exist in the `favorite-fruit`
    map:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`favorite-fruit`映射中不存在的键提供一个回退值：
- en: '[PRE52]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'We would like to store this value in the map. Use `assoc` to associate a new
    key, `:shape`, with a new value, `"egg-like"`, in our map:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The `assoc` operation returns a new map containing our previous key-value pairs
    as well as the new association we've just added.
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Evaluate `favorite-fruit` and notice that it remains unchanged:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Because a map is immutable, the value bound to the `favorite-fruit` symbol has
    not changed. By using `assoc`, we have created a new version of the map.
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now, the F3C ("Funny Fruity Fruits Consortium") have reverted their previous
    ruling and determined during their quarterly review of fruit specifications that
    the color of the kiwi fruit should be brown and not green. To make sure that your
    application is F3C compliant, you decide to update your system with the new value.
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Change the color of `favorite-fruit` by associating a new value to the `:color`
    key:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '`assoc` replaces the existing value when a key already exists, because HashMaps
    cannot have duplicate keys.'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If we wanted to add more structured information, we could add a map as a value.
    Add production information as a nested map in our `Kiwi` map:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Having nested maps or other data types is commonly used to represent structured
    information.
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*New research has found out that the Kiwi contains fewer calories than previously
    thought, and to stay compliant, the F3C requires organizations to reduce the current
    value of kcal per 100 g by 1.*'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Decrement `kcal_per_100g` with the `assoc` function, as follows:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Great! It works, but there is a more elegant way to deal with this type of operation.
    When you need to change a value in a map based on a previous value, you can use
    the `update` function. While the `assoc` function lets you associate a completely
    new value to a key, `update` allows you to compute a new value based on the previous
    value of a key. The `update` function takes a function as its third parameter.
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Decrement `kcal_per_100g` with the `update` function and `dec`, as follows:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Notice how the value of `:kcal_per_100g` changed from `61` to `60`.
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You can also pass arguments to the function provided to update; for example,
    if we wanted to lower `:kcal_per_100g` by 10 instead of 1, we could use the subtract
    function, `-`, and write the following:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Like `assoc`, `update` does not change the immutable map; it returns a new map.
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'This example illustrates the power of functions being "first-class citizens":
    we treat them like typical values; in this case, a function was passed as an argument
    to another function. We will elaborate on this concept in the next chapter while
    diving into functions in more depth.'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Finally, use `dissoc` (as in "dissociate") to remove one or multiple elements
    from a map:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Well done! Now that we know how to use maps, it is time to move on to the next
    data structure: sets.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: Sets
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A set is a collection of unique values. Clojure provides HashSet and SortedSet.
    Hash Sets are implemented as Hash Maps, with the key and the value of each entry
    being identical.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: 'Hash Sets are fairly common in Clojure and have a literal notation of a hash
    with curly braces, `#{}`, for example:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Notice in the preceding expression that when the set is evaluated, it does not
    return the elements of the sets in the order that they were defined in the literal
    expression. This is because of the internal structure of the HashSet. The value
    is transformed in a unique hash, which allows fast access but does not keep the
    insertion order. If you care about the order in which the elements are added,
    you need to use a different data structure, for example, a sequence such as a
    vector (which we will soon discover). Use a HashSet to represent elements that
    logically belong together, for example, an enumeration of unique values.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: 'As with maps, sets cannot have duplicate entries:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Hash Sets can be created from a list of values by passing those values to the
    `hash-set` function:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Hash Sets can also be created from another collection with the `set` function.
    Let''s create a HashSet from a vector:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Notice that the order defined in the vector was lost.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: 'The `set` function will not throw an error when converting a collection of
    non-unique values to a set with the `set` function, which can be useful for deduplicating
    values:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Notice how one of the duplicate strings, `"Cats"`, was silently removed to create
    a set.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: 'A Sorted Set can be created with the `sorted-set` function and have no literal
    syntax as Hash Sets do:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Notice that they are printed in the same way as Hash Sets, only the order looks
    different. Sorted Sets are sorted based on the natural order of elements they
    contain rather than the order of the arguments provided upon creation. You could
    instead provide your own sorting function, but we will focus on Hash Sets as they
    are far more common and useful.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 2.03: Using Sets'
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we will use a Hash Set to represent a collection of supported
    currencies:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: A Hash Set is a good choice of data structure for a list of currencies because
    we typically want to store a collection of unique values and efficiently check
    for containment. Also, the order of the currencies probably doesn't matter. If
    you wanted to associate more data to a currency (such as ISO codes and countries),
    then you would more likely use nested Maps to represent each currency as an entity,
    keyed by a unique ISO code. Ultimately, the choice of the data structure depends
    on how you plan to use the data. In this exercise, we simply want to read it,
    check for containment, and add items to our set.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: 'Start a REPL. Create a set and bind it to the `supported-currencies` symbol:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'As with maps, you can use `get` to retrieve an entry from a set, which returns
    the entry passed as a parameter when present in the set. Use `get` to retrieve
    an existing entry as well as a missing entry:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'It is likely that you just want to check for containment, and `contains?` is,
    therefore, semantically better. Use `contains?` instead of `get` to check for
    containment:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Notice that `contains?` returns a Boolean and that `get` returns the lookup
    value or `nil` when not found. There is the edge case of looking up `nil` in a
    set that will return `nil` both when found and not found. In that case, `contains?`
    is naturally more suitable.
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'As with maps, sets and keywords can be used as functions to check for containment.
    Use the `supported-currencies` set as a function to look up a value in the set:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '`"Swiss franc"` isn''t in the `supported-currencies` set; therefore, the preceding
    return value is `nil`.'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If you tried to use the `"Dollar"` string as a function to look itself up in
    the set, you would get the following error:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: We cannot use strings as a function to look up a value in a set or a Map. That's
    one of the reasons why keywords are a better choice in both sets and maps when possible.
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To add an entry to a set, use the `conj` function, as in "conjoin":'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'You can pass more than one item to the `conj` function. Try to add multiple
    currencies to our Hash Set:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Finally, you can remove one or more items with the `disj` function, as in "disjoin":'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'That''s it for sets! If you ever need to, you can find more functions for working
    with sets in the `clojure.set` namespace (such as union and intersection), but
    this is more advanced usage, so let''s move on to the next collection: vectors.'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: Vectors
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A vector is another type of collection that is widely used in Clojure. You can
    think of vectors as powerful immutable arrays. They are collections of values
    efficiently accessible by their integer index (starting from 0), and they maintain
    the order of item insertion as well as duplicates.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: Use a vector when you need to store and read elements in order, and when you
    don't mind duplicate elements. For example, a web browser history could be a good
    candidate, as you might want to easily go back to the recent pages but also remove
    older elements using a vector's index, and there would likely be duplicate elements
    in it. A map or a set wouldn't be of much help in that situation, as you don't
    have a specific key to look up a value with.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: 'Vectors have a literal notation with square brackets (`[]`):'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Vectors can also be created with the `vector` function followed by a list of
    items as arguments:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'You can create a vector from another collection using the `vec` function; for
    example, the following expression converts a Hash Set to a vector:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'As with other collections, vectors also can contain different types of values:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: We can now start practicing.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 2.04: Using Vectors'
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we will discover different ways of accessing and interacting
    with vectors:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: 'Start a REPL. You can look up values in a vector using their index (that is,
    their position in the collection) with the `get` function. Try to use the `get`
    function with a literal vector:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Because vectors start at 0-index, `:a` is at index 0 and `:c` is at index 2\.
    When the lookup fails, `get` returns `nil`.
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let''s bind a vector to a symbol to make the practice more convenient:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'As with maps and sets, you can use the vector as a function to look up items,
    but for vectors, the parameter is the index of the value in the vector:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Add the next two values of the Fibonacci sequence to your vector with the `conj` function:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Notice that the items are added to the end of the vector, and the order of the
    sequence is kept the same.
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Each item in the Fibonacci sequence corresponds to the sum of the previous
    two items. Let''s dynamically compute the next item of the sequence:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: In the preceding example, we used `let` to create three local bindings and improve
    the readability. We used `count` to calculate the size of a vector, `last` to
    retrieve its last element, `8`, and finally, we used the `fibonacci` vector as
    a function to retrieve the element at index "size - 2" (which is the value `5`
    at index `5`).
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In the body of the `let` block, we used the local binding to add the two last
    items to the end of the Fibonacci sequence with `conj`, which returns `13` (which
    is, indeed, 5 + 8).
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: Lists
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Lists are sequential collections, similar to vectors, but items are added to
    the front (at the beginning). Also, they don't have the same performance properties,
    and random access by index is slower than with vectors. We mostly use lists to
    write code and macros, or in cases when we need a **last-in, first-out** (**LIFO**)
    type of data structure (for example, a stack), which can arguably also be implemented
    with a vector.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: 'We create lists with the literal syntax, `()`, but to differentiate lists that
    represent code and lists that represent data, we need to use the single quote,
    `''`:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: In the preceding examples, we can see that a list that is not quoted with `'`
    throws an error unless the first item of the list can be invoked as a function.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: 'Lists can also be created with the `list` function:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'To read the first element of a list, use `first`:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'The `rest` function returns the list without its first item:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'We will not talk about iterations and recursion yet, but you could imagine
    that the combination of `first` and `rest` is all you need to "walk" or go through
    an entire list: simply by calling `first` on the rest of the list over and over
    again until there''s no rest.'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: 'You cannot use the `get` function with a list to retrieve by index. You could
    use `nth`, but it is not efficient as the list is iterated or "walked" until it
    reaches the desired position:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Exercise 2.05: Using Lists'
  id: totrans-293
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, we will practice using lists by reading and adding elements
    to a to-do list.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: 'Start a REPL and create a to-do list with a list of actions that you need to
    do, using the `list` function as follows:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'You can add items to your list by using the `cons` function, which operates
    on sequences:'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Similarly, you can use the `conj` function, which is used because a list is
    a collection:'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: Notice how the order of the parameters is different. `cons` is available on
    lists because a list is a sequence, and `conj` is available to use on lists because
    a list is a collection. `conj` is, therefore, slightly more "generic" and also
    has the advantage of accepting multiple elements as arguments.
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add multiple elements at once to your list by using the `conj` function:'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Now it''s time to catch up with your task. Retrieve the first element in your
    to-do list with the `first` function:'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE93]'
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Once done, you can retrieve the rest of your tasks with the `rest` function:'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: You could imagine then having to call `first` on the rest of the list (if you
    had to develop a fully blown to-do list application). Because the list is immutable,
    if you keep calling `first` on the same `my-todo` list, you will end up with the
    same element, `"Feed the cat"`, over and over again, and also with a happy but
    very fat cat.
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Finally, you can also retrieve a specific element from the list using the `nth`
    function:'
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE95]'
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: However, remember that retrieving an element at a specific position in a list
    is slower than with vectors because the list has to be "walked" until the `nth`
    element. In that case, you might be better off using a vector. One final note
    about `nth` is that it throws an exception when the element at position n is not
    found.
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: That is all you need to know about lists for now and we can move on to the next
    section about collection and sequence abstractions.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: Collection and Sequence Abstractions
  id: totrans-313
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Clojure's data structures are implemented in terms of powerful abstractions.
    You might have noticed that the operations we used on collections are often similar,
    but behave differently based on the type of the collection. For instance, `get`
    retrieves items from a map with a key, but from a vector with an index; `conj`
    adds elements to a vector at the back, but to a list at the front.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: A sequence is a collection of elements in a particular order, where each item
    follows another. Maps, sets, vectors, and lists are all collections, but only
    vectors and lists are sequences, although we can easily obtain a sequence from
    a map or a set.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go through a few examples of useful functions to use with collections.
    Consider the following map:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Use `count` to get the number of elements in a collection. Each element of
    this map is a key-value pair; therefore, it contains three elements:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Slightly more apparent, the following set contains no elements:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'We can test whether a collection is empty with the `empty?` function:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'A map is not sequential because there is no logical order between its elements.
    However, we can convert a map to a sequence using the `seq` function:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'It yielded a list of vectors or *tuples*, which means that there is now a logical
    order and we can use sequence functions on this data structure:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'A lot of functions just work on collections directly because they can be turned
    into a sequence, so you could omit the `seq` step and, for example, call `first`,
    `rest`, or `last` directly on a map or a set:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: The value of using sequence functions such as `first` or `rest` on maps and
    sets seems questionable but treating those collections as sequences means that
    they can then be iterated. Many more functions are available for processing each
    item of a sequence, such as `map`, `reduce`, `filter`, and so on. We have dedicated
    entire chapters to learning about those in the second part of the book so that
    we can stay focused on the other core functions for now.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: '`into` is another useful operator that puts elements of one collection into
    another collection. The first argument for `into` is the target collection:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'In the preceding example, each element of the `#{5 6 7 8}` set was added into
    the `[1 2 3 4]` vector. The resulting vector is not in ascending order because
    Hash Sets are not sorted:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: In the preceding example, the `[5 6 7 8]` vector was added to the `#{1 2 3 4}`
    set. Once again, Hash Sets do not keep insertion order and the resulting set is
    simply a logical collection of unique values.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: 'A usage example would be, for example, to deduplicate a vector, just put it
    into a set:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'To put items into a map, you would need to pass a collection of tuples representing
    key-value pairs:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'Each item is "conjoined" in the collection, and so it follows the semantic
    of the target collection for inserting items with `conj`. Elements are added to
    a list at the front:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'To help you understand `(into ''() [1 2 3 4])`, here is a step-by-step representation
    of what happened:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'If you want to concatenate collections, `concat` might be more appropriate
    than `into`. See how they behave differently here:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'A lot of Clojure functions that operate on sequences will return sequences
    no matter what the input type was. `concat` is one example:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '`sort` is another example. `sort` can rearrange a collection to order its elements.
    It has the benefit of being slightly more obvious in terms of why you would want
    a sequence as a result:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'But what if you wanted a vector as a result? Well, now you know that you could
    use the `into` function:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'It is interesting to note that `conj` can also be used on maps. For its arguments
    to be consistent with other types of collections, the new entry is represented
    by a tuple:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'Similarly, a vector is an associative collection of key-value pairs where the
    key is the index of the value:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'Exercise 2.06: Working with Nested Data Structures'
  id: totrans-356
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For the purpose of this exercise, imagine that you are working with a little
    shop called "Sparkling," whose business is to trade gemstones. It turns out that
    the owner of the shop knows a bit of Clojure, and has been using a Clojure REPL
    to manage the inventory with some kind of homemade database. However, the owner
    has been struggling to work with nested data structures, and they require help
    from a professional: you. The shop won''t share their database because it contains
    sensitive data – they have just given you a sample dataset so that you know about
    the shape of the data.'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: The shop owner read a blog post on the internet saying that pure functions are
    amazing and make for good quality code. So, they asked you to develop some pure
    functions that take their gemstone database as the first parameter of each function.
    The owner said you would only get paid if you provide pure functions. In this
    exercise, we will develop a few functions that will help us understand and operate
    on nested data structures.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: A pure function is a function where the return value is only determined by its
    input values. A pure function does not have any side effects, which means that
    it does not mutate a program's state nor generate any kind of I/O.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: 'Open up a REPL and create the following Hash Map representing the sample gemstone
    database:'
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE115]'
  id: totrans-362
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE115]'
- en: One of the most popular questions the shop gets from its customers is about
    the durability of a gem. This can be found in the properties of a gem, at the
    `:hardness` key. The first function that we need to develop is `durability`, which
    retrieves the hardness of a given gem.
  id: totrans-363
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let''s start by using a function we already know, `get`, with the `:ruby` gem
    as an example:'
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE116]'
  id: totrans-365
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE116]'
- en: It works, but nesting `get` is not very elegant. We could use the map or keywords
    as functions and see how it improves the readability.
  id: totrans-366
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Use the keywords as a function to see how it improves the readability of our
    code:'
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE117]'
  id: totrans-368
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE117]'
- en: This is slightly better. But it's still a lot of nested calls and parentheses.
    Surely, there must be a better way!
  id: totrans-369
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: When you need to fetch data in a deeply nested map such as this one, use the
    `get-in` function. It takes a vector of keys as parameters and digs in the map
    with just one function call.
  id: totrans-370
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Use the `get-in` function with the `[:ruby :properties :hardness]` vector of
    parameters to retrieve the deeply nested `:hardness` key:'
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE118]'
  id: totrans-372
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE118]'
- en: Great! The vector of keys reads left to right and there is no nested expression.
    It will make our function a lot more readable.
  id: totrans-373
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create the durability function that takes the database and the `gem` keyword
    as a parameter and returns the value of the `hardness` property:'
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE119]'
  id: totrans-375
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'Test your newly created function to make sure that it works as expected:'
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE120]'
  id: totrans-377
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE120]'
- en: Great! Let's move on to the next function.
  id: totrans-378
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Apparently, a ruby is not simply "red" but "Near colorless through pink through
    all shades of red to a deep crimson." Who would have thought? The owner is now
    asking you to create a function to update the color of a gem, because they might
    want to change some other colors too, for marketing purposes. The function needs
    to return the updated database.
  id: totrans-379
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let''s try to write the code to change the color property of a gem. We can
    try to use `assoc`:'
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE121]'
  id: totrans-381
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'It seems to work but, all the other properties are gone! We replaced the existing
    Hash Map at the key property with a new Hash Map that contains only one entry:
    the color.'
  id: totrans-382
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We could use a trick. Do you remember the `into` function? It takes a collection
    and put its values in another collection, like this:'
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE122]'
  id: totrans-384
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE122]'
- en: If we use the `update` function combined with `into`, we could obtain the desired result.
  id: totrans-385
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Try to use `update` combined with `into` to change the `:color` property of
    the ruby gem:'
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE123]'
  id: totrans-387
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE123]'
- en: That's great, but there are two problems with this approach. First, the combination
    of `update` and `into` is not very readable or easy to understand. Second, we
    wanted to return the entire database, but we just returned the `"Ruby"` entry.
    We would have to add another operation to update this entry in the main database,
    perhaps by nesting another `into`, reducing readability even further.
  id: totrans-388
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'As with `get-in`, Clojure offers a simpler way of dealing with nested maps:
    `assoc-in` and `update-in`. They work like `assoc` and `update`, but take a vector
    of keys (such as `get-in`) as a parameter, instead of a single key.'
  id: totrans-389
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You would use `update-in` when you want to update a deeply nested value with
    a function (for example, to compute the new value with the previous value). Here,
    we simply want to replace the color with an entirely new value, so we should use
    `assoc-in`.
  id: totrans-390
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Use `assoc-in` to change the `color` property of the ruby gem:'
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE124]'
  id: totrans-392
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE124]'
- en: Notice how `gemstone-db` was returned entirely. Can you notice the value that
    has changed? There is a lot of data, so it is not very obvious. You can use the
    `pprint` function to "pretty print" the value.
  id: totrans-393
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Use `pprint` on the last returned value to improve the readability and make
    sure that our `assoc-in` expression behaved as expected. In a REPL, the last returned
    value can be obtained with `*1`:'
  id: totrans-394
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 2.1: Printing the output to REPL'
  id: totrans-395
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14502_02_01.jpg)'
  id: totrans-396
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 2.1: Printing the output to REPL'
  id: totrans-397
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: That is much more readable. We will not use `pprint` everywhere as it takes
    a lot of extra space, but you should use it.
  id: totrans-398
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create the `change-color` pure function, which takes three parameters: a database,
    a gemstone keyword, and a new color. This function updates the color in the given
    database and returns the new value of the database:'
  id: totrans-399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE125]'
  id: totrans-400
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'Test that your newly created function behaves as expected:'
  id: totrans-401
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE126]'
  id: totrans-402
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE126]'
- en: The owner would like to add one last function to record the sale of a gem and
    update the inventory accordingly.
  id: totrans-403
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'When a sale occurs, the shop owner would like to call the `sell` function with
    the following arguments: a database, a gemstone keyword, and a client ID. `client-id`
    will be inserted in the `sales` vector and the `stock` value for that gem will
    be decreased by one. As with the other functions, the new value of the database
    will be returned so that the client can handle the update themselves.'
  id: totrans-404
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We can use the `update-in` function in combination with `dec` to decrement
    (decrease by one) the stock. Let''s try it with the diamond gem:'
  id: totrans-405
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE127]'
  id: totrans-406
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE127]'
- en: The output is not very readable, and it is hard to verify that the value was
    correctly updated. Another useful command to improve readability in the REPL is
    the `*print-level*` option, which can limit the depth of the data structure printed
    to the terminal.
  id: totrans-407
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Use the `*print-level*` option to set the depth level to `2`, and observe how
    the result is printed:'
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE128]'
  id: totrans-409
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE128]'
- en: The diamond stock has indeed decreased by 1, from 10 to 9.
  id: totrans-410
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We can use the `update-in` function again, this time in combination with `conj`
    and a `client-id` to add in the `sales` vector. Let''s try an example with the
    diamond gem and `client-id 999`:'
  id: totrans-411
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE129]'
  id: totrans-412
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE129]'
- en: It might have worked, but we cannot see the `sales` vector as the data has been
    truncated by the `*print-level*` option.
  id: totrans-413
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Set `*print-level*` to `nil` to reset the option, and reevaluate the previous expression:'
  id: totrans-414
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE130]'
  id: totrans-415
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE130]'
- en: Notice that our diamond `sales` vector now contains the value `999`.
  id: totrans-416
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now let''s write our pure function, which combines the two operations (updating
    the stock and the clients):'
  id: totrans-417
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE131]'
  id: totrans-418
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'Test your newly created function by selling a `:moissanite` to `client-id`
    `123`:'
  id: totrans-419
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE132]'
  id: totrans-420
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE132]'
- en: Notice that the `sales` vector of the moissanite entity now contains the value
    `123`.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, we did not really "update" data but merely derived new data
    structures from others because of their immutability. Even if we work mostly with
    immutable data types, Clojure offers simple mechanisms that allow you to persist
    information. In the following activity, you will create a database that can be
    read and updated with the techniques acquired in this chapter, and we will even
    provide a helper function to make the database persistent.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 2.01: Creating a Simple In-Memory Database'
  id: totrans-423
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this activity, we are going to create our own implementation of an in-memory
    database. After all, if the "Sparkling" shop owner was able to do it, then it
    shouldn't be a problem for us!
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: Our database interface will live in the Clojure REPL. We will implement functions
    to create and drop tables, as well as to insert and read records.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: 'For the purposes of this activity, we will provide a couple of helper functions
    to help you maintain the state of the database in memory:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: We use an `atom` but you don't need to understand how atoms work for now, as
    they are explained in great detail later in the book. You just need to know that
    it will keep a reference to our database in memory, and use two helper functions,
    `read-db` and `write-db`, to read and persist a Hash Map in memory.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: 'As guidance, we would like the data structure to have this shape:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'For example, if we used our database in a grocery store to save clients, fruits,
    and purchases, we can imagine that it would contain the data in this manner:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: Storing data and indexes separately allows multiple indexes to be created without
    having to duplicate the actual data.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: The `indexes` map stores an association between the index key and its position
    in the `data` vector for each index key. In the fruits table, "Lemon" is the first
    record of the `data` vector, so the value in the `:name` index is 0.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: 'These steps will help you perform the activity:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: Create the helper functions. You can get the Hash Map by executing the `read-db`
    function with no arguments, and write to the database by executing the `write-db`
    function with a Hash Map as an argument.
  id: totrans-436
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Start by creating the `create-table` function. This function should take one
    parameter: the table name. It should add a new key (the table name) at the root
    of our Hash Map database, and the value should be another Hash Map containing
    two entries: an empty vector at the `data` key and an empty Hash Map at the `indexes`
    key.'
  id: totrans-437
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Test that your `create-table` function works.
  id: totrans-438
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `drop-table` function such that it takes one parameter as well - the
    table name. It should remove a table, including all its data and indexes from
    our database.
  id: totrans-439
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Test that your `drop-table` function works.
  id: totrans-440
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create an `insert` function. This function should take three parameters: `table`,
    `record`, and `id-key`. The `record` parameter is a Hash Map, and `id-key` corresponds
    to a key in the record map that will be used as a unique index. For now, we will
    not handle cases when a table does not exist or when an index key already exists
    in a given table.'
  id: totrans-441
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Try to use a `let` block to divide the work of the `insert` function in multiple
    steps:'
  id: totrans-442
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In a `let` statement, create a binding for the value of the database, retrieved
    with `read-db`.
  id: totrans-443
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In the same `let` statement, create a second binding for the new value of the
    database (after adding the record in the `data` vector).
  id: totrans-444
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In the same `let` statement, retrieve the index at which the record was inserted
    by counting the number of elements in the `data` vector.
  id: totrans-445
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In the body of the `let` statement, update the index at `id-key` and write the
    resulting map to the database with `write-db`.
  id: totrans-446
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: To verify that your `insert` function works, try to use it multiple times to
    insert new records.
  id: totrans-447
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `select-*` function that will return all the records of a table passed
    as a parameter.
  id: totrans-448
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a `select-*-where` function that takes three arguments: `table-name`,
    `field`, and `field-value`. The function should use the index map to retrieve
    the index of the record in the data vector and return the element.'
  id: totrans-449
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Modify the `insert` function to reject any index duplicate. When a record with
    `id-key` already exists in the `indexes` map, we should not modify the database
    and print an error message to the user.
  id: totrans-450
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'On completing the activity, the output should be similar to this:'
  id: totrans-451
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE136]'
  id: totrans-452
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE136]'
- en: In this activity, we have used our new knowledge about reading and updating
    both simple and deeply nested data structures to implement a simple in-memory
    database. This was not an easy feat – well done!
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
- en: The solution for this activity can be found on page 682.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-456
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we discovered the concept of immutability. We learned about
    Clojure''s simple data types, as well as their implementation on different host
    platforms. We discovered the most common types of collections and sequences: maps,
    sets, vectors, and lists. We saw how to use them with generic collections and
    sequence operations. We learned how to read and update complex structures of nested
    collections. We also learned about the standard functions for using collection
    data structures, as well as more advanced usage with deeply nested data structures.
    In the next chapter, we will learn advanced techniques for working with functions.'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
