- en: 2\. Data Types and Immutability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overview
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we start by discovering the concept of immutability and its
    relevance in modern programs. We then examine simple data types such as strings,
    numbers and booleans, highlighting subtle differences in different environments
    like Clojure and ClojureScript. After a first exercise, we move on to more elaborated
    data types with collections such as lists, vectors, maps and sets, learning along
    the way which to use in different situations. After touching on the collection
    and sequence abstractions, we learn new techniques for working with nested data
    structures, before finally moving on to the final activity: implementing our very
    own in-memory database.'
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be able to work with the commonly used
    data types in Clojure.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Computer hardware has evolved dramatically in the last few decades. On a typical
    computer, storage and memory capacity have both increased a millionfold compared
    to the early 1980s. Nonetheless, standard industry practices in software development
    and mainstream ways of programming are not that different. Programming languages
    such as C++, Java, Python, and Ruby still typically encourage you to change things
    in place, and to use variables and mutate the state of a program, that is, to
    do things as if we were programming on a computer with a minimal amount of memory.
    However, in our quest for efficiency, better languages, and better tools, we reach
    for higher-level languages. We want to get further away from machine code. We
    want to write less code and let the computers do the tedious work.
  prefs: []
  type: TYPE_NORMAL
- en: We don't want to think about the computer's memory anymore, such as where a piece of
    information is stored and whether it's safe and shareable, as much as we don't
    want to know about the order of the instructions in the CPU. It is a distraction
    to the problems we are trying to solve, which are already complicated enough.
    If you have ever tried to do some multithreading in the languages cited previously,
    you will know the pain of sharing data between threads. Although, leveraging multicore
    CPUs with multithreaded applications is an essential part of optimizing a modern
    program's performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Clojure, we work almost exclusively with immutable data types. They are
    safe to share, easy to fabricate, and improve the readability of our source code.
    Clojure provides the necessary tools to write programs with the functional programming
    paradigm: first-class citizen functions, which we will discover in the next chapter,
    and avoiding mutating and sharing the state of an application with immutable data
    types.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s dust off the dictionary and look up the definition of immutable, "*Immutable:
    that cannot be changed; that will never change.*" It doesn''t mean that a piece
    of information cannot change over time, but we record those modifications as a
    series of new values. "Updating" an immutable data structure provides a new value
    derived from the original value. However, the original value remains unchanged
    – those data structures that preserve previous versions of themselves are called
    persistent data structures.'
  prefs: []
  type: TYPE_NORMAL
- en: Intuitively, we may think that such a persistent data structure would negatively
    impact performance, but it's not as bad as it seems. They are optimized for performance,
    and techniques such as structural sharing bring the time complexity of all operations
    close to classic, mutable implementations.
  prefs: []
  type: TYPE_NORMAL
- en: In other terms, unless you are programming an application that requires extraordinarily
    high performance, such as a video game, the benefits of using immutable data structures
    far outweigh the small loss in performance.
  prefs: []
  type: TYPE_NORMAL
- en: Simple Data Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A data type designates what kind of value a piece of data holds; it is a fundamental
    way of classifying data. Different types allow different kinds of operations:
    we can concatenate strings, multiply numbers, and perform logic algebra operations
    with Booleans. Because Clojure has a strong emphasis on practicality, we don''t
    explicitly assign types to values in Clojure, but those values still have a type.'
  prefs: []
  type: TYPE_NORMAL
- en: Clojure is a hosted language and has three notable, major implementations in
    Java, JavaScript, and .NET. Being a hosted language is a useful trait that allows
    Clojure programs to run in different environments and take advantage of the ecosystem
    of its host. Regarding data types, it means that each implementation has different
    underlying data types, but don't worry as those are just implementation details.
    As a Clojure programmer, it does not make much difference, and if you know how
    to do something in Clojure, you likely know how to do it in, say, ClojureScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this topic, we will go through Clojure''s simple data types. Here is the
    list of the data types looked at in this section. Please note that the following
    types are all immutable:'
  prefs: []
  type: TYPE_NORMAL
- en: Strings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Numbers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Booleans
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keywords
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nil
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Strings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Strings are sequences of characters representing text. We have been using and
    manipulating strings since the first exercise of *Chapter 1*, *Hello REPL.*
  prefs: []
  type: TYPE_NORMAL
- en: 'You can create a string by simply wrapping characters with double quotes (`"`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'String literals are only created with double quotes, and if you need to use
    double quotes in a string, you can escape them with the backslash character (`\`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Strings are not able to be changed; they are immutable. Any function that claims
    to transform a string yields a new value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, calling `clojure.string/replace` on `silly-string`
    returned a new string with the word "silly" replaced with "clever." However, when
    evaluating `silly-string` again, we can see that the value has not changed. The
    function returned a different value and did not change the original string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although a string is usually a single unit of data representing text, Strings
    are also collections of characters. In the JVM implementation of Clojure, strings
    are of the `java.lang.String` Java type and they are implemented as collections
    of the `java.lang.Character` Java type, such as the following command, which returns
    a character:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '`first` returns the first element of a collection. Here, the literal notation
    of a character is `\a`. The `type` function returns a string representation of
    the data type for a given value. Remember that we can use `*1` to retrieve the
    last returned value in the REPL, so `*1` evaluates to `\a`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'It is interesting to note that, in ClojureScript, strings are collections of
    one-character strings, because there is no character type in JavaScript. Here
    is a similar example in a ClojureScript REPL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As with the Clojure REPL, `type` returns a string representation of the data
    type. This time, in ClojureScript, the value returned by the `last` function (which
    returns the last character of a string) is of the `#object[String]` type, which
    means a JavaScript string.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find a few common functions for manipulating strings in the core namespace,
    such as `str`, which we used in *Chapter 1*, *Hello REPL!*, to concatenate (combine
    multiple strings together into one string):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Most functions for manipulating strings can be found in the `clojure.string`
    namespace. Here is a list of them using the REPL `dir` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'As a reminder, this is how you can use a function from a specific namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We will not cover all the string functions, but feel free to try them out now.
    You can always look up the documentation of a string function from the preceding
    list with the `doc` function.
  prefs: []
  type: TYPE_NORMAL
- en: Numbers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Clojure has good support for numbers and you will most likely not have to worry
    about the underlying types, as Clojure will handle pretty much anything. However,
    it is important to note that there are a few differences between Clojure and ClojureScript
    in that regard.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Clojure, by default, natural numbers are implemented as the `java.lang.Long`
    Java type unless the number is too big for `Long`. In that case, it is typed `clojure.lang.BigInt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Notice, in the preceding example, that the number was too big to fit in the
    `java.lang.Long` Java type and, therefore, was implicitly typed `clojure.lang.BigInt`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exact ratios are represented by Clojure as "Ratio" types, which have a literal
    representation. 5/4 is not an exact ratio, so the output is the ratio itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of dividing `3` by `4` can be represented by the ratio 3/4:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '`4/4` is equivalent to `1` and is evaluated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Decimal numbers are "double" precision floating-point numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'If we take our division of 3 by 4 again, but this time mix in a "Double" type,
    we will not get a ratio as a result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This is because floating-point numbers are "contagious" in Clojure. Any operation
    involving floating-point numbers will result in a float or a double:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'In ClojureScript, however, numbers are just "JavaScript numbers," which are
    all double-precision floating-point numbers. JavaScript does not define different
    types of numbers like Java and some other programming languages do (for example,
    `long`, `integer`, and `short`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Notice that, this time, any operation returns a floating-point number. The fact
    that there is no decimal separation for `1` or `2` is just a formatting convenience.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can make sure that all those numbers are JavaScript numbers (double-precision,
    floating-point) by using the `type` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: If you need to do more than simple arithmetic, you can use the Java or JavaScript
    `math` libraries, which are similar except for a few minor exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will learn more about host platform interoperability in *Chapter 9*, *Host
    Platform Interoperability with Java and JavaScript* (how to interact with the
    host platform and its ecosystem), but the examples in the chapter will get you
    started with doing some more complicated math and with using the `math` library:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Reading a value from a constant can be done like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'And calling a function, like the usual Clojure functions, can be done like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Exercise 2.01: The Obfuscation Machine'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You have been contacted by a secret government agency to develop an algorithm
    that encodes text into a secret string that only the owner of the algorithm can
    decode. Apparently, they don't trust other security mechanisms such as SSL and
    will only communicate sensitive information with their own proprietary technology.
  prefs: []
  type: TYPE_NORMAL
- en: You need to develop an `encode` function and a `decode` function. The `encode`
    function should replace letters with numbers that are not easily guessable. For
    that purpose, each letter will take the character's number value in the ASCII
    table, add another number to it (the number of words in the sentence to encode),
    and finally, compute the square value of that number. The `decode` function should
    allow the user to revert to the original string. Someone highly ranked in the
    agency came up with that algorithm so they trust it to be very secure.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this exercise, we will put into practice some of the things we''ve learned
    about strings and numbers by building an obfuscation machine:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start your REPL and look up the documentation of the `clojure.string/replace`
    function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that the `replace` function can take a pattern and a function of the
    matching result as parameters. We don't know how to iterate over collections yet,
    but using the `replace` function with a pattern and a "replacement function" should
    do the job.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Try and use the `replace` function with the `#"\w"` pattern (which means word
    character), replace it with the `!` character, and observe the result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Try and use the `replace` function with the same pattern, but this time passing
    an anonymous function that takes the matching letter as a parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Observe that the function was called for each letter, printing the match out
    to the console and finally returning the string with the matches replaced by the
    `!` character. It looks like we should be able to write our encoding logic in
    that replacement function.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let''s now see how we can convert a character to a number. We can use the `int`
    function, which coerces its parameter to an integer. It can be used like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'It seems that the "replacement function" will take a string as a parameter,
    so let''s convert our string to a character. Use the `char-array` function combined
    with `first` to convert our string to a character as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, if we combine previous steps together and also compute the square value
    of the character''s number, we should be approaching our obfuscation goal. Combine
    the code written previously to obtain a character code from a string and get its
    square value using the `Math/pow` function as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s now convert this result to the string that will be returned from our
    `replace` function. First, let''s remove the decimal part by coercing the result
    to an `int`, and put things together in an `encode-letter` function, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Great! It seems to work. Let's now test our function as part of the `replace`
    function.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create the `encode` function, which uses `clojure.string/replace` as well as
    our `encode-letter` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: It seems to work but the resulting string will be hard to decode without being
    able to identify each letter individually.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'There is another thing that we did not take into account: the `encode` function
    should take an arbitrary number to add to the code before calculating the square
    value.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'First, add a separator as part of our `encode-letter` function, for example,
    the `#` character, so that we can identify each letter individually. Second, add
    an extra parameter to `encode-letter`, which needs to be added before calculating
    the square value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, test the `encode` function another time:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Our `encode` function is now failing because it is expecting an extra argument.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Modify the `encode` function to calculate the number of words in the text to
    obfuscate, and pass it to the `encode-letter` function. You can use the `clojure.string/split`
    function with a whitespace, as follows, to count the number of words:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Try your newly created function with a few examples and make sure it obfuscates
    strings properly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: What a beautiful, unintelligible, obfuscated string – well done! Notice how
    the numbers for the same letters are different depending on the number of words
    in the phrase to encode. It seems to work according to the specification!
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We can now start working on the `decode` function, for which we will need to
    use the following functions:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`Math/sqrt` to obtain the square root value of a number.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`char` to retrieve a letter from a character code (a number).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`subs` as in substring, to get a sub-portion of a string (and get rid of our
    `#` separator).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`Integer/parseInt` to convert a string to an integer.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Write the `decode` function using a combination of the preceding functions,
    to decode an obfuscated character:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, write the `decode` function, which is similar to the `encode` function
    except that it should use `decode-letter` instead of `encode-letter`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Test your functions and make sure that they both work:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this exercise, we've put into practice working with numbers and strings by
    creating an encoding system. We can now move on to learning other data types,
    starting with Booleans.
  prefs: []
  type: TYPE_NORMAL
- en: Booleans
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Booleans are implemented as Java's `java.lang.Boolean` in Clojure or JavaScript's
    "Boolean" in ClojureScript. Their value can either be `true` or `false`, and their
    literal notations are simply the lowercase `true` and `false`.
  prefs: []
  type: TYPE_NORMAL
- en: Symbols
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Symbols are identifiers referring to something else. We have already been using
    symbols when creating bindings or calling functions. For example, when using `def`,
    the first argument is a symbol that will refer to a value, and when calling a
    function such as `+`, `+` is a symbol referring to the function implementing the
    addition. Consider the following examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have created the `user/foo` symbol, which refers to the `"bar"` string,
    and the `add-2` symbol, which refers to the function that adds 2 to its parameter.
    We have created those symbols in the user namespace, hence the notation with `/`:
    `user/foo`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we try to evaluate a symbol that has not been defined, we''ll get an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'In the *REPL Basics* topic of *Chapter 1*, *Hello REPL!*, we were able to use
    the following functions because they are bound to a specific symbol:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Those gibberish-like values are string representations of the functions, because
    we are asking for the values bound to the symbols rather than invoking the functions
    (wrapping them with parentheses).
  prefs: []
  type: TYPE_NORMAL
- en: Keywords
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can think of a keyword as some kind of a special constant string. Keywords
    are a nice addition to Clojure because they are lightweight and convenient to
    use and create. You just need to use the colon character, `:`, at the beginning
    of a word to create a keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: They don't refer to anything else like symbols do; as you can see in the preceding
    example, when evaluated, they just return themselves. Keywords are typically used
    as keys in a key-value associative map, as we will see in the next topic about
    collections.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we went through simple data types such as string, numbers,
    Boolean, symbols, and keywords. We highlighted how their underlying implementation
    depends on the host platform because Clojure is a hosted language. In the next
    section, we will see how those values can aggregate to collections.
  prefs: []
  type: TYPE_NORMAL
- en: Collections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Clojure is a functional programming language in which we focus on building the
    computations of our programs in terms of the evaluation of functions, rather than
    building custom data types and their associated behaviors. In the other dominant
    programming paradigm, object-oriented programming, programmers define the data
    types and the operations available on them. Objects are supposed to encapsulate
    data and communicate with each other by passing messages around. But there is
    an unfortunate tendency to create classes and new types of objects to customize
    the shape of the data, instead of using more generic data structures, which cascades
    into creating specific methods to access and modify the data. We have to come
    up with decent names, which is difficult, and then we pass instances of objects
    around in our programs. We create new classes all the time, but more code means
    more bugs. It is a recipe for disaster; it is an explosion of code, with code
    that is very specific and benefits from little reuse.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, it is not like that everywhere, and you can write clean object-oriented
    code, with objects being the little black boxes of functionality they were designed
    for. However, as programmers, whether it's through using other libraries or maintaining
    a legacy code base, we spend most of our time working with other people's code.
  prefs: []
  type: TYPE_NORMAL
- en: In functional programming, and more specifically, in Clojure, we tend to work
    with just a few data types. Types that are generic and powerful, types that every
    other "Clojurian" already knows and has mastered.
  prefs: []
  type: TYPE_NORMAL
- en: Collections are data types that can contain more than one thing and describe
    how those items relate to each other. The four main data structures for collections
    that you should know about are **Maps**, **Sets**, **Vectors**, and **Lists**.
    There are more available, including the data structure offered by your host platform
    (for example, Java or JavaScript) or other libraries, but those four are your
    bread and butter for doing things in Clojure.
  prefs: []
  type: TYPE_NORMAL
- en: '*"Data dominates. If you''ve chosen the right data structures and organized
    things well, the algorithms will almost always be self-evident. Data structures,
    not algorithms, are central to programming." - Rob Pike''s Rule #5 of programming.*'
  prefs: []
  type: TYPE_NORMAL
- en: Maps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A Map is a collection of key-value pairs. Clojure provides – in a persistent
    and immutable fashion – the usual HashMap but also a SortedMap.
  prefs: []
  type: TYPE_NORMAL
- en: HashMaps are called "Hash" because they create a hash of the key and map it
    to a given value. Lookups, as well as other common operations (`insert` and `delete`),
    are fast.
  prefs: []
  type: TYPE_NORMAL
- en: HashMaps are used a lot in Clojure, notably, for representing entities where
    we need to associate some attributes to some values. SortedMaps are different
    because they preserve the order of the keys; otherwise, they have the same interface
    and are used in the same way as HashMaps. SortedMaps are not very common, so let's
    focus on HashMaps.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can create a HashMap with the literal notation using curly braces. Here
    is a Map with three key-value pairs, with the keys being the `:artist`, `:song`,
    and `:year` keywords:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: You might have noticed in the preceding example that key-value pairs in the
    map are separated by a space, but Clojure evaluates it and returns a Map with
    key-value pairs separated by a comma. As with other collections, you can choose
    to use a space or a comma to separate each entry. For maps, there's no best practice
    and if you think it improves a map's readability, use commas; otherwise, simply
    omit them. You can also separate entries with new lines.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s another map written with comma-separated entries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that the values can be of any type, and not only simple values such
    as strings and numbers, but also vectors and even other maps, allowing you to
    create nested data structures and structure information as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Keys can be of different types too, so you could have strings, numbers, or even
    other types as a key; however, we generally use keywords.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way of creating a map is by using the `hash-map` function, passing
    in pairs of arguments as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Choose to use literal notation with curly braces when possible, but when HashMaps
    are programmatically generated, the `hash-map` function can come in handy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Map keys are unique:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: An exception was thrown because the `:name` key was present twice in the preceding
    literal map.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, different keys can have the same value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Notice that both `age` and `number-of-teeth` have the same value, and that is
    both valid and convenient, to say the least.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know how to create maps, it is time for a bit of practice.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 2.02: Using Maps'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we will learn how to access and modify simple maps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start your REPL and create a map:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can read an entry from the map with the `get` function. Try to look up
    a key or two, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If the value for a given key cannot be found, `get` returns `nil`, but you
    can specify a fallback value with a third argument to `get`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Maps and keywords have the special ability to be used as functions. When positioned
    in the "operator position" (as the first item of the list), they are invoked as
    a function that can be used to look up a value in a map. Try it now by using the
    `favorite-fruit` map as a function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Try to use a keyword as a function to look up a value in a Map:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As with the `get` function, those ways of retrieving a value return `nil` when
    the key cannot be found, and you can pass an extra argument to provide a fallback
    value.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Provide a fallback value for a key that doesn''t exist in the `favorite-fruit`
    map:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We would like to store this value in the map. Use `assoc` to associate a new
    key, `:shape`, with a new value, `"egg-like"`, in our map:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `assoc` operation returns a new map containing our previous key-value pairs
    as well as the new association we've just added.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Evaluate `favorite-fruit` and notice that it remains unchanged:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Because a map is immutable, the value bound to the `favorite-fruit` symbol has
    not changed. By using `assoc`, we have created a new version of the map.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now, the F3C ("Funny Fruity Fruits Consortium") have reverted their previous
    ruling and determined during their quarterly review of fruit specifications that
    the color of the kiwi fruit should be brown and not green. To make sure that your
    application is F3C compliant, you decide to update your system with the new value.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Change the color of `favorite-fruit` by associating a new value to the `:color`
    key:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`assoc` replaces the existing value when a key already exists, because HashMaps
    cannot have duplicate keys.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If we wanted to add more structured information, we could add a map as a value.
    Add production information as a nested map in our `Kiwi` map:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Having nested maps or other data types is commonly used to represent structured
    information.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*New research has found out that the Kiwi contains fewer calories than previously
    thought, and to stay compliant, the F3C requires organizations to reduce the current
    value of kcal per 100 g by 1.*'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Decrement `kcal_per_100g` with the `assoc` function, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Great! It works, but there is a more elegant way to deal with this type of operation.
    When you need to change a value in a map based on a previous value, you can use
    the `update` function. While the `assoc` function lets you associate a completely
    new value to a key, `update` allows you to compute a new value based on the previous
    value of a key. The `update` function takes a function as its third parameter.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Decrement `kcal_per_100g` with the `update` function and `dec`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice how the value of `:kcal_per_100g` changed from `61` to `60`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You can also pass arguments to the function provided to update; for example,
    if we wanted to lower `:kcal_per_100g` by 10 instead of 1, we could use the subtract
    function, `-`, and write the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Like `assoc`, `update` does not change the immutable map; it returns a new map.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'This example illustrates the power of functions being "first-class citizens":
    we treat them like typical values; in this case, a function was passed as an argument
    to another function. We will elaborate on this concept in the next chapter while
    diving into functions in more depth.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Finally, use `dissoc` (as in "dissociate") to remove one or multiple elements
    from a map:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Well done! Now that we know how to use maps, it is time to move on to the next
    data structure: sets.'
  prefs: []
  type: TYPE_NORMAL
- en: Sets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A set is a collection of unique values. Clojure provides HashSet and SortedSet.
    Hash Sets are implemented as Hash Maps, with the key and the value of each entry
    being identical.
  prefs: []
  type: TYPE_NORMAL
- en: 'Hash Sets are fairly common in Clojure and have a literal notation of a hash
    with curly braces, `#{}`, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Notice in the preceding expression that when the set is evaluated, it does not
    return the elements of the sets in the order that they were defined in the literal
    expression. This is because of the internal structure of the HashSet. The value
    is transformed in a unique hash, which allows fast access but does not keep the
    insertion order. If you care about the order in which the elements are added,
    you need to use a different data structure, for example, a sequence such as a
    vector (which we will soon discover). Use a HashSet to represent elements that
    logically belong together, for example, an enumeration of unique values.
  prefs: []
  type: TYPE_NORMAL
- en: 'As with maps, sets cannot have duplicate entries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Hash Sets can be created from a list of values by passing those values to the
    `hash-set` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Hash Sets can also be created from another collection with the `set` function.
    Let''s create a HashSet from a vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the order defined in the vector was lost.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `set` function will not throw an error when converting a collection of
    non-unique values to a set with the `set` function, which can be useful for deduplicating
    values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Notice how one of the duplicate strings, `"Cats"`, was silently removed to create
    a set.
  prefs: []
  type: TYPE_NORMAL
- en: 'A Sorted Set can be created with the `sorted-set` function and have no literal
    syntax as Hash Sets do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Notice that they are printed in the same way as Hash Sets, only the order looks
    different. Sorted Sets are sorted based on the natural order of elements they
    contain rather than the order of the arguments provided upon creation. You could
    instead provide your own sorting function, but we will focus on Hash Sets as they
    are far more common and useful.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 2.03: Using Sets'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we will use a Hash Set to represent a collection of supported
    currencies:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: A Hash Set is a good choice of data structure for a list of currencies because
    we typically want to store a collection of unique values and efficiently check
    for containment. Also, the order of the currencies probably doesn't matter. If
    you wanted to associate more data to a currency (such as ISO codes and countries),
    then you would more likely use nested Maps to represent each currency as an entity,
    keyed by a unique ISO code. Ultimately, the choice of the data structure depends
    on how you plan to use the data. In this exercise, we simply want to read it,
    check for containment, and add items to our set.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start a REPL. Create a set and bind it to the `supported-currencies` symbol:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As with maps, you can use `get` to retrieve an entry from a set, which returns
    the entry passed as a parameter when present in the set. Use `get` to retrieve
    an existing entry as well as a missing entry:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'It is likely that you just want to check for containment, and `contains?` is,
    therefore, semantically better. Use `contains?` instead of `get` to check for
    containment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that `contains?` returns a Boolean and that `get` returns the lookup
    value or `nil` when not found. There is the edge case of looking up `nil` in a
    set that will return `nil` both when found and not found. In that case, `contains?`
    is naturally more suitable.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'As with maps, sets and keywords can be used as functions to check for containment.
    Use the `supported-currencies` set as a function to look up a value in the set:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`"Swiss franc"` isn''t in the `supported-currencies` set; therefore, the preceding
    return value is `nil`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If you tried to use the `"Dollar"` string as a function to look itself up in
    the set, you would get the following error:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We cannot use strings as a function to look up a value in a set or a Map. That's
    one of the reasons why keywords are a better choice in both sets and maps when possible.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To add an entry to a set, use the `conj` function, as in "conjoin":'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can pass more than one item to the `conj` function. Try to add multiple
    currencies to our Hash Set:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, you can remove one or more items with the `disj` function, as in "disjoin":'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'That''s it for sets! If you ever need to, you can find more functions for working
    with sets in the `clojure.set` namespace (such as union and intersection), but
    this is more advanced usage, so let''s move on to the next collection: vectors.'
  prefs: []
  type: TYPE_NORMAL
- en: Vectors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A vector is another type of collection that is widely used in Clojure. You can
    think of vectors as powerful immutable arrays. They are collections of values
    efficiently accessible by their integer index (starting from 0), and they maintain
    the order of item insertion as well as duplicates.
  prefs: []
  type: TYPE_NORMAL
- en: Use a vector when you need to store and read elements in order, and when you
    don't mind duplicate elements. For example, a web browser history could be a good
    candidate, as you might want to easily go back to the recent pages but also remove
    older elements using a vector's index, and there would likely be duplicate elements
    in it. A map or a set wouldn't be of much help in that situation, as you don't
    have a specific key to look up a value with.
  prefs: []
  type: TYPE_NORMAL
- en: 'Vectors have a literal notation with square brackets (`[]`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Vectors can also be created with the `vector` function followed by a list of
    items as arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'You can create a vector from another collection using the `vec` function; for
    example, the following expression converts a Hash Set to a vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'As with other collections, vectors also can contain different types of values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: We can now start practicing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 2.04: Using Vectors'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we will discover different ways of accessing and interacting
    with vectors:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start a REPL. You can look up values in a vector using their index (that is,
    their position in the collection) with the `get` function. Try to use the `get`
    function with a literal vector:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Because vectors start at 0-index, `:a` is at index 0 and `:c` is at index 2\.
    When the lookup fails, `get` returns `nil`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let''s bind a vector to a symbol to make the practice more convenient:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As with maps and sets, you can use the vector as a function to look up items,
    but for vectors, the parameter is the index of the value in the vector:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the next two values of the Fibonacci sequence to your vector with the `conj` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that the items are added to the end of the vector, and the order of the
    sequence is kept the same.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Each item in the Fibonacci sequence corresponds to the sum of the previous
    two items. Let''s dynamically compute the next item of the sequence:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding example, we used `let` to create three local bindings and improve
    the readability. We used `count` to calculate the size of a vector, `last` to
    retrieve its last element, `8`, and finally, we used the `fibonacci` vector as
    a function to retrieve the element at index "size - 2" (which is the value `5`
    at index `5`).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In the body of the `let` block, we used the local binding to add the two last
    items to the end of the Fibonacci sequence with `conj`, which returns `13` (which
    is, indeed, 5 + 8).
  prefs: []
  type: TYPE_NORMAL
- en: Lists
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Lists are sequential collections, similar to vectors, but items are added to
    the front (at the beginning). Also, they don't have the same performance properties,
    and random access by index is slower than with vectors. We mostly use lists to
    write code and macros, or in cases when we need a **last-in, first-out** (**LIFO**)
    type of data structure (for example, a stack), which can arguably also be implemented
    with a vector.
  prefs: []
  type: TYPE_NORMAL
- en: 'We create lists with the literal syntax, `()`, but to differentiate lists that
    represent code and lists that represent data, we need to use the single quote,
    `''`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding examples, we can see that a list that is not quoted with `'`
    throws an error unless the first item of the list can be invoked as a function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lists can also be created with the `list` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'To read the first element of a list, use `first`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'The `rest` function returns the list without its first item:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'We will not talk about iterations and recursion yet, but you could imagine
    that the combination of `first` and `rest` is all you need to "walk" or go through
    an entire list: simply by calling `first` on the rest of the list over and over
    again until there''s no rest.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You cannot use the `get` function with a list to retrieve by index. You could
    use `nth`, but it is not efficient as the list is iterated or "walked" until it
    reaches the desired position:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'Exercise 2.05: Using Lists'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, we will practice using lists by reading and adding elements
    to a to-do list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start a REPL and create a to-do list with a list of actions that you need to
    do, using the `list` function as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can add items to your list by using the `cons` function, which operates
    on sequences:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Similarly, you can use the `conj` function, which is used because a list is
    a collection:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice how the order of the parameters is different. `cons` is available on
    lists because a list is a sequence, and `conj` is available to use on lists because
    a list is a collection. `conj` is, therefore, slightly more "generic" and also
    has the advantage of accepting multiple elements as arguments.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add multiple elements at once to your list by using the `conj` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now it''s time to catch up with your task. Retrieve the first element in your
    to-do list with the `first` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once done, you can retrieve the rest of your tasks with the `rest` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You could imagine then having to call `first` on the rest of the list (if you
    had to develop a fully blown to-do list application). Because the list is immutable,
    if you keep calling `first` on the same `my-todo` list, you will end up with the
    same element, `"Feed the cat"`, over and over again, and also with a happy but
    very fat cat.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Finally, you can also retrieve a specific element from the list using the `nth`
    function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: However, remember that retrieving an element at a specific position in a list
    is slower than with vectors because the list has to be "walked" until the `nth`
    element. In that case, you might be better off using a vector. One final note
    about `nth` is that it throws an exception when the element at position n is not
    found.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: That is all you need to know about lists for now and we can move on to the next
    section about collection and sequence abstractions.
  prefs: []
  type: TYPE_NORMAL
- en: Collection and Sequence Abstractions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Clojure's data structures are implemented in terms of powerful abstractions.
    You might have noticed that the operations we used on collections are often similar,
    but behave differently based on the type of the collection. For instance, `get`
    retrieves items from a map with a key, but from a vector with an index; `conj`
    adds elements to a vector at the back, but to a list at the front.
  prefs: []
  type: TYPE_NORMAL
- en: A sequence is a collection of elements in a particular order, where each item
    follows another. Maps, sets, vectors, and lists are all collections, but only
    vectors and lists are sequences, although we can easily obtain a sequence from
    a map or a set.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go through a few examples of useful functions to use with collections.
    Consider the following map:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'Use `count` to get the number of elements in a collection. Each element of
    this map is a key-value pair; therefore, it contains three elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'Slightly more apparent, the following set contains no elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'We can test whether a collection is empty with the `empty?` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'A map is not sequential because there is no logical order between its elements.
    However, we can convert a map to a sequence using the `seq` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'It yielded a list of vectors or *tuples*, which means that there is now a logical
    order and we can use sequence functions on this data structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'A lot of functions just work on collections directly because they can be turned
    into a sequence, so you could omit the `seq` step and, for example, call `first`,
    `rest`, or `last` directly on a map or a set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: The value of using sequence functions such as `first` or `rest` on maps and
    sets seems questionable but treating those collections as sequences means that
    they can then be iterated. Many more functions are available for processing each
    item of a sequence, such as `map`, `reduce`, `filter`, and so on. We have dedicated
    entire chapters to learning about those in the second part of the book so that
    we can stay focused on the other core functions for now.
  prefs: []
  type: TYPE_NORMAL
- en: '`into` is another useful operator that puts elements of one collection into
    another collection. The first argument for `into` is the target collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, each element of the `#{5 6 7 8}` set was added into
    the `[1 2 3 4]` vector. The resulting vector is not in ascending order because
    Hash Sets are not sorted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, the `[5 6 7 8]` vector was added to the `#{1 2 3 4}`
    set. Once again, Hash Sets do not keep insertion order and the resulting set is
    simply a logical collection of unique values.
  prefs: []
  type: TYPE_NORMAL
- en: 'A usage example would be, for example, to deduplicate a vector, just put it
    into a set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'To put items into a map, you would need to pass a collection of tuples representing
    key-value pairs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'Each item is "conjoined" in the collection, and so it follows the semantic
    of the target collection for inserting items with `conj`. Elements are added to
    a list at the front:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'To help you understand `(into ''() [1 2 3 4])`, here is a step-by-step representation
    of what happened:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to concatenate collections, `concat` might be more appropriate
    than `into`. See how they behave differently here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'A lot of Clojure functions that operate on sequences will return sequences
    no matter what the input type was. `concat` is one example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: '`sort` is another example. `sort` can rearrange a collection to order its elements.
    It has the benefit of being slightly more obvious in terms of why you would want
    a sequence as a result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'But what if you wanted a vector as a result? Well, now you know that you could
    use the `into` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'It is interesting to note that `conj` can also be used on maps. For its arguments
    to be consistent with other types of collections, the new entry is represented
    by a tuple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, a vector is an associative collection of key-value pairs where the
    key is the index of the value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: 'Exercise 2.06: Working with Nested Data Structures'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For the purpose of this exercise, imagine that you are working with a little
    shop called "Sparkling," whose business is to trade gemstones. It turns out that
    the owner of the shop knows a bit of Clojure, and has been using a Clojure REPL
    to manage the inventory with some kind of homemade database. However, the owner
    has been struggling to work with nested data structures, and they require help
    from a professional: you. The shop won''t share their database because it contains
    sensitive data – they have just given you a sample dataset so that you know about
    the shape of the data.'
  prefs: []
  type: TYPE_NORMAL
- en: The shop owner read a blog post on the internet saying that pure functions are
    amazing and make for good quality code. So, they asked you to develop some pure
    functions that take their gemstone database as the first parameter of each function.
    The owner said you would only get paid if you provide pure functions. In this
    exercise, we will develop a few functions that will help us understand and operate
    on nested data structures.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: A pure function is a function where the return value is only determined by its
    input values. A pure function does not have any side effects, which means that
    it does not mutate a program's state nor generate any kind of I/O.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open up a REPL and create the following Hash Map representing the sample gemstone
    database:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: One of the most popular questions the shop gets from its customers is about
    the durability of a gem. This can be found in the properties of a gem, at the
    `:hardness` key. The first function that we need to develop is `durability`, which
    retrieves the hardness of a given gem.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let''s start by using a function we already know, `get`, with the `:ruby` gem
    as an example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: It works, but nesting `get` is not very elegant. We could use the map or keywords
    as functions and see how it improves the readability.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Use the keywords as a function to see how it improves the readability of our
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is slightly better. But it's still a lot of nested calls and parentheses.
    Surely, there must be a better way!
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: When you need to fetch data in a deeply nested map such as this one, use the
    `get-in` function. It takes a vector of keys as parameters and digs in the map
    with just one function call.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Use the `get-in` function with the `[:ruby :properties :hardness]` vector of
    parameters to retrieve the deeply nested `:hardness` key:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Great! The vector of keys reads left to right and there is no nested expression.
    It will make our function a lot more readable.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create the durability function that takes the database and the `gem` keyword
    as a parameter and returns the value of the `hardness` property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Test your newly created function to make sure that it works as expected:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Great! Let's move on to the next function.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Apparently, a ruby is not simply "red" but "Near colorless through pink through
    all shades of red to a deep crimson." Who would have thought? The owner is now
    asking you to create a function to update the color of a gem, because they might
    want to change some other colors too, for marketing purposes. The function needs
    to return the updated database.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let''s try to write the code to change the color property of a gem. We can
    try to use `assoc`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'It seems to work but, all the other properties are gone! We replaced the existing
    Hash Map at the key property with a new Hash Map that contains only one entry:
    the color.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We could use a trick. Do you remember the `into` function? It takes a collection
    and put its values in another collection, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If we use the `update` function combined with `into`, we could obtain the desired result.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Try to use `update` combined with `into` to change the `:color` property of
    the ruby gem:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: That's great, but there are two problems with this approach. First, the combination
    of `update` and `into` is not very readable or easy to understand. Second, we
    wanted to return the entire database, but we just returned the `"Ruby"` entry.
    We would have to add another operation to update this entry in the main database,
    perhaps by nesting another `into`, reducing readability even further.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'As with `get-in`, Clojure offers a simpler way of dealing with nested maps:
    `assoc-in` and `update-in`. They work like `assoc` and `update`, but take a vector
    of keys (such as `get-in`) as a parameter, instead of a single key.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You would use `update-in` when you want to update a deeply nested value with
    a function (for example, to compute the new value with the previous value). Here,
    we simply want to replace the color with an entirely new value, so we should use
    `assoc-in`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Use `assoc-in` to change the `color` property of the ruby gem:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice how `gemstone-db` was returned entirely. Can you notice the value that
    has changed? There is a lot of data, so it is not very obvious. You can use the
    `pprint` function to "pretty print" the value.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Use `pprint` on the last returned value to improve the readability and make
    sure that our `assoc-in` expression behaved as expected. In a REPL, the last returned
    value can be obtained with `*1`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 2.1: Printing the output to REPL'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14502_02_01.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 2.1: Printing the output to REPL'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: That is much more readable. We will not use `pprint` everywhere as it takes
    a lot of extra space, but you should use it.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create the `change-color` pure function, which takes three parameters: a database,
    a gemstone keyword, and a new color. This function updates the color in the given
    database and returns the new value of the database:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Test that your newly created function behaves as expected:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The owner would like to add one last function to record the sale of a gem and
    update the inventory accordingly.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'When a sale occurs, the shop owner would like to call the `sell` function with
    the following arguments: a database, a gemstone keyword, and a client ID. `client-id`
    will be inserted in the `sales` vector and the `stock` value for that gem will
    be decreased by one. As with the other functions, the new value of the database
    will be returned so that the client can handle the update themselves.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We can use the `update-in` function in combination with `dec` to decrement
    (decrease by one) the stock. Let''s try it with the diamond gem:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The output is not very readable, and it is hard to verify that the value was
    correctly updated. Another useful command to improve readability in the REPL is
    the `*print-level*` option, which can limit the depth of the data structure printed
    to the terminal.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Use the `*print-level*` option to set the depth level to `2`, and observe how
    the result is printed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The diamond stock has indeed decreased by 1, from 10 to 9.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We can use the `update-in` function again, this time in combination with `conj`
    and a `client-id` to add in the `sales` vector. Let''s try an example with the
    diamond gem and `client-id 999`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: It might have worked, but we cannot see the `sales` vector as the data has been
    truncated by the `*print-level*` option.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Set `*print-level*` to `nil` to reset the option, and reevaluate the previous expression:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that our diamond `sales` vector now contains the value `999`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now let''s write our pure function, which combines the two operations (updating
    the stock and the clients):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Test your newly created function by selling a `:moissanite` to `client-id`
    `123`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that the `sales` vector of the moissanite entity now contains the value
    `123`.
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, we did not really "update" data but merely derived new data
    structures from others because of their immutability. Even if we work mostly with
    immutable data types, Clojure offers simple mechanisms that allow you to persist
    information. In the following activity, you will create a database that can be
    read and updated with the techniques acquired in this chapter, and we will even
    provide a helper function to make the database persistent.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 2.01: Creating a Simple In-Memory Database'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this activity, we are going to create our own implementation of an in-memory
    database. After all, if the "Sparkling" shop owner was able to do it, then it
    shouldn't be a problem for us!
  prefs: []
  type: TYPE_NORMAL
- en: Our database interface will live in the Clojure REPL. We will implement functions
    to create and drop tables, as well as to insert and read records.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the purposes of this activity, we will provide a couple of helper functions
    to help you maintain the state of the database in memory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: We use an `atom` but you don't need to understand how atoms work for now, as
    they are explained in great detail later in the book. You just need to know that
    it will keep a reference to our database in memory, and use two helper functions,
    `read-db` and `write-db`, to read and persist a Hash Map in memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'As guidance, we would like the data structure to have this shape:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, if we used our database in a grocery store to save clients, fruits,
    and purchases, we can imagine that it would contain the data in this manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: Storing data and indexes separately allows multiple indexes to be created without
    having to duplicate the actual data.
  prefs: []
  type: TYPE_NORMAL
- en: The `indexes` map stores an association between the index key and its position
    in the `data` vector for each index key. In the fruits table, "Lemon" is the first
    record of the `data` vector, so the value in the `:name` index is 0.
  prefs: []
  type: TYPE_NORMAL
- en: 'These steps will help you perform the activity:'
  prefs: []
  type: TYPE_NORMAL
- en: Create the helper functions. You can get the Hash Map by executing the `read-db`
    function with no arguments, and write to the database by executing the `write-db`
    function with a Hash Map as an argument.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Start by creating the `create-table` function. This function should take one
    parameter: the table name. It should add a new key (the table name) at the root
    of our Hash Map database, and the value should be another Hash Map containing
    two entries: an empty vector at the `data` key and an empty Hash Map at the `indexes`
    key.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Test that your `create-table` function works.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `drop-table` function such that it takes one parameter as well - the
    table name. It should remove a table, including all its data and indexes from
    our database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Test that your `drop-table` function works.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create an `insert` function. This function should take three parameters: `table`,
    `record`, and `id-key`. The `record` parameter is a Hash Map, and `id-key` corresponds
    to a key in the record map that will be used as a unique index. For now, we will
    not handle cases when a table does not exist or when an index key already exists
    in a given table.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Try to use a `let` block to divide the work of the `insert` function in multiple
    steps:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In a `let` statement, create a binding for the value of the database, retrieved
    with `read-db`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In the same `let` statement, create a second binding for the new value of the
    database (after adding the record in the `data` vector).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In the same `let` statement, retrieve the index at which the record was inserted
    by counting the number of elements in the `data` vector.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In the body of the `let` statement, update the index at `id-key` and write the
    resulting map to the database with `write-db`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: To verify that your `insert` function works, try to use it multiple times to
    insert new records.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `select-*` function that will return all the records of a table passed
    as a parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a `select-*-where` function that takes three arguments: `table-name`,
    `field`, and `field-value`. The function should use the index map to retrieve
    the index of the record in the data vector and return the element.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Modify the `insert` function to reject any index duplicate. When a record with
    `id-key` already exists in the `indexes` map, we should not modify the database
    and print an error message to the user.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'On completing the activity, the output should be similar to this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this activity, we have used our new knowledge about reading and updating
    both simple and deeply nested data structures to implement a simple in-memory
    database. This was not an easy feat – well done!
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The solution for this activity can be found on page 682.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we discovered the concept of immutability. We learned about
    Clojure''s simple data types, as well as their implementation on different host
    platforms. We discovered the most common types of collections and sequences: maps,
    sets, vectors, and lists. We saw how to use them with generic collections and
    sequence operations. We learned how to read and update complex structures of nested
    collections. We also learned about the standard functions for using collection
    data structures, as well as more advanced usage with deeply nested data structures.
    In the next chapter, we will learn advanced techniques for working with functions.'
  prefs: []
  type: TYPE_NORMAL
