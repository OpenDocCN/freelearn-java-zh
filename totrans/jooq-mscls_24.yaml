- en: '*Chapter 19*: Logging and Testing'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover logging and testing from the jOOQ perspective.
    Relying on the fact that these are common-sense notions, I won''t explain what
    logging and testing are, nor will I highlight their obvious importance. That being
    said, let''s jump directly into the agenda of this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: jOOQ logging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: jOOQ testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code for this chapter can be found on GitHub at [https://github.com/PacktPublishing/jOOQ-Masterclass/tree/master/Chapter19](https://github.com/PacktPublishing/jOOQ-Masterclass/tree/master/Chapter19).
  prefs: []
  type: TYPE_NORMAL
- en: jOOQ logging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'By default, you''ll see the jOOQ logs at the `DEBUG` level during code generation
    and during queries/routine execution. For instance, during a regular `SELECT`
    execution, jOOQ logs the query SQL string (with and without the bind values),
    the first 5 records from the fetched result set as a nice formatted table, and
    the size of the result is set as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Figure_19.1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 19.1 – A default jOOQ log for a SELECT execution
  prefs: []
  type: TYPE_NORMAL
- en: This figure reveals a few important aspects of jOOQ logging. First of all, the
    jOOQ logger is named `org.jooq.tools.LoggerListener` and represents an implementation
    of the `ExecuteListener` SPI presented in [*Chapter 18*](B16833_18.xhtml#_idTextAnchor338),
    *jOOQ SPI (Providers and Listeners)*. Under the hood, `LoggerListener` uses an
    internal abstraction (`org.jooq.tools.JooqLogger`) that attempts to interact with
    any of the famous loggers, sl4j, log4j, or the Java Logging API (`java.util.logging`).
    So, if your application uses any of these loggers, jOOQ hooks into it and uses
    it.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in this figure, jOOQ logs the query SQL string when the `renderEnd()`
    callback is invoked, and the fetched result set when the `resultEnd()` callback
    is invoked. Nevertheless, the jOOQ methods that rely on lazy (sequential) access
    to the underlying JDBC `ResultSet` (so, methods that uses `Iterator` of the `Cursor`–
    for instance, `ResultQuery.fetchStream()` and `ResultQuery.collect()`) don't pass
    through `resultStart()` and `resultEnd()`. In such cases, only the first five
    records from `ResultSet` are buffered by jOOQ and are available for logging in
    `fetchEnd()` via `ExecuteContext.data("org.jooq.tools.LoggerListener.BUFFER")`.
    The rest of the records are either lost or skipped.
  prefs: []
  type: TYPE_NORMAL
- en: If we execute a routine or the query is a DML, then other callbacks are involved
    as well. Are you curious to find out more?! Then you'll enjoy studying the `LoggerListener`
    source code by yourself.
  prefs: []
  type: TYPE_NORMAL
- en: jOOQ logging in Spring Boot – default zero-configuration logging
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Spring Boot 2.x, without providing any explicit logging configurations, we
    see logs printed in the console at the `INFO` level. This is happening because
    the Spring Boot default logging functionality uses the popular Logback logging
    framework.
  prefs: []
  type: TYPE_NORMAL
- en: Mainly, the Spring Boot logger is determined by the `spring-boot-starter-logging`
    artifact that (based on the provided configuration or auto-configuration) activates
    any of the supported logging providers (`java.util.logging`, log4j2, and Logback).
    This artifact can be imported explicitly or transitively (for instance, as a dependency
    of `spring-boot-starter-web`).
  prefs: []
  type: TYPE_NORMAL
- en: 'In this context, having a Spring Boot application with no explicit logging
    configurations will not log jOOQ messages. However, we can take advantage of jOOQ
    logging if we simply enable the `DEBUG` level (or `TRACE` for more verbose logging).
    For instance, we can do it in the `application.properties` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: You can practice this example in *SimpleLogging* for MySQL.
  prefs: []
  type: TYPE_NORMAL
- en: jOOQ logging with Logback/log4j2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you already have Logback configured (for instance, via `logback-spring.xml`),
    then you''ll need to add the jOOQ logger, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: You can practice this example in *Logback* for MySQL. If you prefer log4j2,
    then consider the *Log4j2* application for MySQL. The jOOQ logger is configured
    in `log4j2.xml`.
  prefs: []
  type: TYPE_NORMAL
- en: Turn off jOOQ logging
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Turning on/off jOOQ logging can be done via the `set`/`withExecuteLogging()`
    setting. For instance, the following query will not be logged:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'You can practice this example in *TurnOffLogging* for MySQL. Note that this
    setting doesn''t affect the jOOQ Code Generator logging. That logging is configured
    with `<logging>LEVEL</logging>` (Maven), `logging = ''LEVEL''` (Gradle), or `.withLogging(Logging.LEVEL)`
    (programmatically). `LEVEL` can be any of `TRACE`, `DEBUG`, `INFO`, `WARN`, `ERROR`,
    and `FATAL`. Here is the Maven approach for setting the `WARN` level – log everything
    that is bigger or equal to the `WARN` level:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: You can practice this example in *GenCodeLogging* for MySQL.
  prefs: []
  type: TYPE_NORMAL
- en: In the second part of this section, let's tackle a suite of examples that should
    help you to get familiar with different techniques of customizing jOOQ logging.
    Based on these examples, you should be capable of solving your scenarios. Since
    these are just examples, they won't cover all possible cases, which is worth remembering
    in your real scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing result set logging
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By default, jOOQ truncates the logged result set to five records. However,
    we can easily log the entire result set via `format(int size)`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'How about logging the whole result set for every query (excluding queries that
    rely on lazy, sequential access to an underlying JDBC `ResultSet`)? Moreover,
    let''s assume that we plan to log the row number, as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 19.2 – Customizing result set logging'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_19.2.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 19.2 – Customizing result set logging
  prefs: []
  type: TYPE_NORMAL
- en: 'One approach for accomplishing this consists of writing a custom logger as
    `ExecuteListener` and overriding the `resultEnd()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: You can practice this example in *LogAllRS* for MySQL.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing binding parameters logging
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If we switch the logging level to `TRACE` (`logging.level.root=TRACE`), then
    we get more verbose jOOQ logging. For instance, the bind parameters are logged
    as a separate list, as shown in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Challenge yourself to customize this list to look different and to be logged
    at `DEBUG` level. You can find some inspiration in *LogBind* for MySQL, which
    logs bindings like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: How about log bindings as a nice formatted table? I'm looking forward to seeing
    your code.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing logging invocation order
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s assume that we plan to enrich jOOQ logging to log a chart, as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 19.3 – Logging a chart'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_19.3.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 19.3 – Logging a chart
  prefs: []
  type: TYPE_NORMAL
- en: This chart is logged only for `SELECT` statements that contain `PRODUCT.PRODUCT_ID`
    (represented on the X axis of the chart – category) and `PRODUCT.BUY_PRICE` (represented
    on the Y axis of the chart – value). Moreover, we don't take into account the
    queries that rely on lazy sequential access to the underlying JDBC `ResultSet`,
    such as `ctx.selectFrom(PRODUCT).collect(Collectors.toList());`. In such cases,
    jOOQ buffers for logging only the first five records, so, in most of the cases,
    the chart will be irrelevant.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step consists of writing a custom `ExecuteListener` (our own logger)
    and overriding the `resultEnd()` method – called after fetching a set of records
    from `ResultSet`. In this method, we search for `PRODUCT.PRODUCT_ID` and `PRODUCT.BUY_PRICE`,
    and if we find them, then we use the jOOQ `ChartFormat` API, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'There is one more thing that we need. At this moment, our `resultEnd()` is
    invoked after the jOOQ''s `LoggerListener.resultEnd()` is invoked, which means
    that our chart is logged after the result set. However, if you look at the previous
    figure, you can see that our chart is logged before the result set. This can be
    accomplished by reversing the order of invocation for the `fooEnd()` methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'So, by default, as long as the jOOQ logger is enabled, our loggers (the overridden
    `fooStart()` and `fooEnd()` methods) are invoked after their counterparts from
    the default logger (`LoggingLogger`). But, we can reverse the default order via
    two settings: `withExecuteListenerStartInvocationOrder()` for `fooStart()` methods
    and `withExecuteListenerEndInvocationOrder()` for `fooEnd()` methods. In our case,
    after reversion, our `resultEnd()` is called before `LoggingLogger.resultEnd()`,
    and this is how we slipped our chart in the proper place. You can practice this
    example in *ReverseLog* for MySQL.'
  prefs: []
  type: TYPE_NORMAL
- en: Wrapping jOOQ logging into custom text
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s assume that we plan to wrap each query/routine default logging into
    some custom text, as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 19.4 – Wrapping jOOQ logging into custom text'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_19.4.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 19.4 – Wrapping jOOQ logging into custom text
  prefs: []
  type: TYPE_NORMAL
- en: Before checking a potential solution in *WrapLog* for MySQL, consider challenging
    yourself to solve it.
  prefs: []
  type: TYPE_NORMAL
- en: Filtering jOOQ logging
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes, we want to be very selective with what's being logged. For instance,
    let's assume that only the SQL strings for the `INSERT` and `DELETE` statements
    should be logged. So, after we turn off the jOOQ default logger, we set up our
    logger, which should be capable of isolating the `INSERT` and `DELETE` statements
    from the rest of the queries. A simple approach consists of applying a simple
    check, such as (`query instanceof Insert || query instanceof Delete`), where `query`
    is given by `ExecuteContext.query()`. However, this will not work in the case
    of plain SQL or batches containing the `INSERT` and `DELETE` statements. Specifically
    for such cases, we can apply a regular expression, such as "`^(?i:(INSERT|DELETE).*)$`",
    to the SQL string(s) returned via `ExecuteContext` passed in `renderEnd()`. While
    you can find these words materialized in code lines in *FilterLog* for MySQL,
    let's focus on another scenario.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s assume that we plan to log only regular `SELECT`, `INSERT`, `UPDATE`,
    and `DELETE` statements that contain a suite of given tables (plain SQL, batches,
    and routines are not logged at all). For instance, we can conveniently pass the
    desired tables via `data()` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'So, if a query refers to the `EMPLOYEE` and `SALE` tables, then, and only then,
    should it be logged. This time, relying on regular expressions can be a little
    bit sophisticated and risky. It would be more proper to rely on a `VisitListener`
    that allows us to inspect the AST and extract the referred tables of the current
    query with a robust approach. Every `QueryPart` passes through `VisitListener`,
    so we can inspect its type and collect it accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: When `VisitListener` finishes its execution, we have already traversed all `QueryPart`,
    and we've collected all the tables involved in the current query, so we can compare
    these tables with the given tables and decide whether or not to log the current
    query. Note that our `VisitListener` has been declared as `private static class`
    because we use it internally in our `ExecuteListener` (our logger), which orchestrates
    the logging process. More precisely, at the proper moment, we append this `VisitListener`
    to a configuration derived from the configuration of `ExecuteContext`, passed
    to our `ExecuteListener`. So, this `VisitListener` is not appended to the configuration
    of `DSLContext` that is used to execute the query.
  prefs: []
  type: TYPE_NORMAL
- en: 'The relevant part of our logger (`ExecuteListener`) is listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: Check out the highlighted code. The `deriveAppending()` method creates a derived
    `Configuration` from this one (by "this one", we understand `Configuration` of
    the current `ExecuteContext`, which was automatically derived from the `Configuration`
    of `DSLContext`), with appended visit listeners. Practically, this `VisitListener`
    is inserted into `Configuration` through `VisitListenerProvider`, which is responsible
    for creating a new listener instance for every rendering life cycle.
  prefs: []
  type: TYPE_NORMAL
- en: However, what's the point of this? In short, it is all about performance and
    scopes (`org.jooq.Scope`). `VisitListener` is intensively called; therefore, it
    can have some impact on rendering performance. So, in order to minimize its usage,
    we ensure that it is used only in the proper conditions from our logger. In addition,
    `VisitListener` should store the list of tables that are being rendered in some
    place accessible to our logger. Since we choose to rely on the `data()` map, we
    have to ensure that the logger and `VisitListener` have access to it. By appending
    `VisitListener` to the logger via `deriveAppending()`, we append its `Scope` as
    well, so the `data()` map is accessible from both. This way, we can share custom
    data between the logger and `VisitContext` for the entire lifetime of the scope.
  prefs: []
  type: TYPE_NORMAL
- en: You can practice this example in *FilterVisitLog* for MySQL. Well, that's all
    about logging. Next, let's talk about testing.
  prefs: []
  type: TYPE_NORMAL
- en: jOOQ testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Accomplishing jOOQ testing can be done in several ways, but we can immediately
    highlight that the less appealing option relies on mocking the jOOQ API, while
    the best option relies on writing integration tests against the production database
    (or at least against an in-memory database). Let's start with the option that
    fits well only in simple cases, mocking the jOOQ API.
  prefs: []
  type: TYPE_NORMAL
- en: Mocking the jOOQ API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'While mocking the JDBC API can be really difficult, jOOQ solves this chore
    and exposes a simple mock API via `org.jooq.tools.jdbc`. The climax of this API
    is represented by the `MockConnection` (for mocking a database connection) and
    `MockDataProvider` (for mocking query executions). Assuming that jUnit 5 is used,
    we can mock a connection like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: 'Before writing tests, we have to prepare `ClassicmodelsMockProvider` as an
    implementation of `MockDataProvider` that overrides the `execute()` method. This
    method returns an array of `MockResult` (each `MockResult` represents a mock result).
    A possible implementation may look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we are ready to go! First, we can write a test. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: 'The code that mocks this behavior is added in `ClassicmodelsMockProvider`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: The first argument of the `MockResult` constructor represents the number of
    affected rows, and -`1` represents that the row count not being applicable. In
    the bundled code (*Mock* for MySQL), you can see more examples, including testing
    batching, fetching many results, and deciding the result based on the bindings.
    However, do not forget that jOOQ testing is equivalent to testing the database
    interaction, so mocking is proper only for simple cases. Do not use it for transactions,
    locking, or testing your entire database!
  prefs: []
  type: TYPE_NORMAL
- en: 'If you don''t believe me, then follow Lukas Eder''s statement: *"The fact that
    mocking only fits well in a few cases can''t be stressed enough. People will still
    attempt to use this SPI, because it looks so easy to do, not thinking about the
    fact that they''re about to implement a full-fledged DBMS in the poorest of ways.
    I''ve had numerous users to whom I''ve explained this 3-4x: ''You''re about to
    implement a full-fledged DBMS" and they keep asking me: "Why doesn''t jOOQ ''just''
    execute this query when I mock it?" – "Well jOOQ *isn''t* a DBMS, but it allows
    you to pretend you can write one, using the mocking SPI."* *And they keep asking
    again and again. Hard to imagine what''s tricky about this, but as much as it
    helps with SEO (people want to solve this problem, then discover jOOQ), I regret
    leading some developers down this path... It''s excellent though to test some
    converter and mapping integrations within jOOQ."*'
  prefs: []
  type: TYPE_NORMAL
- en: Writing integration tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A quick approach for writing integration tests for jOOQ relies on simply creating
    `DSLContext` for the production database. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: However, this approach (exemplified in *SimpleTest* for MySQL) fits well for
    simple scenarios that don't require dealing with transaction management (begin,
    commit, and rollback). For instance, if you just need to test your `SELECT` statements,
    then most probably this approach is all you need.
  prefs: []
  type: TYPE_NORMAL
- en: Using SpringBoot @JooqTest
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'On the other hand, it''s a common scenario to run each integration test in
    a separate transaction that rolls back in the end, and to achieve this while testing
    jOOQ in Spring Boot, you can use the `@JooqTest` annotation, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE189]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE193]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE194]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE195]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE196]'
  prefs: []
  type: TYPE_PRE
- en: This time, Spring Boot automatically creates `DSLContext` for the current profile
    (of course, using explicit profiles is optional, but I added it here, since it
    is a common practice in Spring Boot applications) and automatically wraps each
    test in a separate Spring transaction that is rolled back at the end. In this
    context, if you prefer to use jOOQ transactions for certain tests, then don't
    forget to disable Spring transaction by annotating those test methods with `@Transactional(propagation=Propagation.NEVER)`.
    The same is true for the usage of `TransactionTemplate`. You can practice this
    example in *JooqTest* for MySQL, which contains several tests, including jOOQ
    optimistic locking via `TransactionTemplate` and via jOOQ transactions.
  prefs: []
  type: TYPE_NORMAL
- en: By using Spring Boot profiles, you can easily configure a separate database
    for tests that is (or not) identical to the production database. In *JooqTestDb*,
    you have the MySQL `classicmodels` database for production and the MySQL `classicmodels_test`
    database for testing (both of them have the same schema and data and are managed
    by Flyway).
  prefs: []
  type: TYPE_NORMAL
- en: 'Moreover, if you prefer an in-memory database that is destroyed at the end
    of testing, then in *JooqTestInMem* for MySQL, you have the on-disk MySQL `classicmodels`
    database for production and the in-memory H2 `classicmodels_mem_test` database
    for testing (both of them have the same schema and data and are managed by Flyway).
    In these two applications, after you inject the `DSLContext` prepared by Spring
    Boot, you have to point jOOQ to the test schema – for instance, for the in-memory
    database, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE197]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE198]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE199]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE200]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE201]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE202]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE203]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE204]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE205]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE206]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE207]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE208]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE209]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE210]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE211]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE212]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE213]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE214]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE215]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE216]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE217]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE218]'
  prefs: []
  type: TYPE_PRE
- en: You should be familiar with this technique from [*Chapter 17*](B16833_17.xhtml#_idTextAnchor330),
    *Multitenancy in jOOQ*.
  prefs: []
  type: TYPE_NORMAL
- en: Using Testcontainers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Testcontainers ([https://www.testcontainers.org/](https://www.testcontainers.org/))
    is a Java library that allows us to perform JUnit tests in lightweight Docker
    containers, created and destroyed automatically for the most common databases.
    So, in order to use Testcontainers, you have to install Docker.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you''ve installed Docker and provided the expected dependencies in your
    Spring Boot application, you can start a container and run some tests. Here, I''ve
    done it for MySQL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE219]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE220]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE221]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE222]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE223]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE224]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE225]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE226]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE227]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE228]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE229]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE230]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE231]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE232]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE233]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE234]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE235]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE236]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE237]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE238]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE239]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE240]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE241]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE242]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE243]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE244]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE245]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE246]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE247]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE248]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE249]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE250]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE251]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE252]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE253]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE254]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE255]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE256]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE257]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE258]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE259]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we''ve populated the test database via Flyway, but this is not mandatory.
    You can use any other dedicated utility, such as Commons DbUtils. For instance,
    you can do it via `org.testcontainers.ext.ScriptUtils`, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE260]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE261]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE262]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE263]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE264]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE265]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE266]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE267]'
  prefs: []
  type: TYPE_PRE
- en: That's it! Now, you can spin out a throwaway container for testing database
    interaction. Most probably, this is the most preferable approach for testing jOOQ
    applications in production. You can practice this example in *Testcontainers*
    for MySQL.
  prefs: []
  type: TYPE_NORMAL
- en: Testing R2DBC
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Finally, if you are using jOOQ R2DBC, then writing tests is quite straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the bundled code, you can find three examples for MySQL, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The *TestR2DBC* example: `ConnectionFactory` is created via `ConnectionFactories.get()`
    and `DSLContext` via `ctx = DSL.using(connectionFactory)`. The tests are executed
    against a production database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The *TestR2DBCDb* example: `ConnectionFactory` is automatically created by
    Spring Boot and `DSLContext` is created as `@Bean`. The tests are executed against
    a MySQL test database (`classicmodels_test`), similar to the production one (`classicmodels`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The *TestR2DBCInMem* example: `ConnectionFactory` is automatically created
    by Spring Boot and `DSLContext` is created as `@Bean`. The tests are executed
    against an H2 in-memory test database (`classicmodels_mem_test`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you just saw, jOOQ has solid support for logging and testing, proving yet
    again that it is a mature technology ready to meet the most demanding expectations
    of a production environment. With a high rate of productivity and a small learning
    curve, jOOQ is the first choice that I use and recommend for projects. I strongly
    encourage you to do the same!
  prefs: []
  type: TYPE_NORMAL
