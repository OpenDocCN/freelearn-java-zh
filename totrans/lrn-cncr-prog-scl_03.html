<html><head></head><body><div id="book-columns"><div id="book-inner"><div class="chapter" title="Chapter 3. Traditional Building Blocks of Concurrency"><div class="titlepage"><div><div><h1 class="title"><a id="ch03"/><span class="koboSpan" id="kobo.1.1">Chapter 3. Traditional Building Blocks of Concurrency</span></h1></div></div></div><div class="blockquote"><table border="0" width="100%" cellspacing="0" cellpadding="0" class="blockquote" summary="Block quote"><tr><td valign="top"><span class="koboSpan" id="kobo.2.1"> </span></td><td valign="top"><p><span class="emphasis"><em><span class="koboSpan" id="kobo.3.1">"There's an old story about the person who wished his computer were as easy to use as his telephone. </span><span class="koboSpan" id="kobo.3.2">That wish has come true, since I no longer know how to use my telephone."</span></em></span></p></td><td valign="top"><span class="koboSpan" id="kobo.4.1"> </span></td></tr><tr><td valign="top"><span class="koboSpan" id="kobo.5.1"> </span></td><td colspan="2" align="right" valign="top" style="text-align: center"><span class="koboSpan" id="kobo.6.1">--</span><span class="attribution"><span class="emphasis"><em><span class="koboSpan" id="kobo.7.1">Bjarne Stroustrup</span></em></span></span></td></tr></table></div><p><span class="koboSpan" id="kobo.8.1">The concurrency primitives shown in </span><a class="link" href="ch02.html" title="Chapter 2. Concurrency on the JVM and the Java Memory Model"><span class="koboSpan" id="kobo.9.1">Chapter 2</span></a><span class="koboSpan" id="kobo.10.1">, </span><span class="emphasis"><em><span class="koboSpan" id="kobo.11.1">Concurrency on the JVM and the Java Memory Model</span></em></span><span class="koboSpan" id="kobo.12.1">, are the basics of concurrent programming on JVM. </span><span class="koboSpan" id="kobo.12.2">Nevertheless, we usually avoid using them directly, as their low-level nature makes them delicate and prone to errors. </span><span class="koboSpan" id="kobo.12.3">As we saw, low-level concurrency is susceptible to effects such as data races, reordering, visibility, deadlocks, and non-determinism. </span><span class="koboSpan" id="kobo.12.4">Fortunately, people have come up with more advanced building blocks of concurrency, that capture common patterns in concurrent programs and are a lot safer to use. </span><span class="koboSpan" id="kobo.12.5">Although these building blocks do not solve all the issues of concurrent programming, they simplify the reasoning about concurrent programs and can be found across concurrency frameworks and libraries in many languages, including Scala. </span><span class="koboSpan" id="kobo.12.6">This chapter extends the fundamental concurrent programming model from </span><a class="link" href="ch02.html" title="Chapter 2. Concurrency on the JVM and the Java Memory Model"><span class="koboSpan" id="kobo.13.1">Chapter 2</span></a><span class="koboSpan" id="kobo.14.1">, </span><span class="emphasis"><em><span class="koboSpan" id="kobo.15.1">Concurrency on the JVM and the Java Memory Model</span></em></span><span class="koboSpan" id="kobo.16.1">, with traditional building blocks of concurrency and shows how to use them in practice.</span></p><p><span class="koboSpan" id="kobo.17.1">In general, there are two aspects of a concurrent programming model. </span><span class="koboSpan" id="kobo.17.2">The first deals with expressing concurrency in a program. </span><span class="koboSpan" id="kobo.17.3">Given a program, which of its parts can execute concurrently and under which conditions? </span><span class="koboSpan" id="kobo.17.4">In the previous chapter, we saw that JVM allows declaring and starting separate threads of control. </span><span class="koboSpan" id="kobo.17.5">In this chapter, we will visit a more lightweight mechanism for starting concurrent executions. </span><span class="koboSpan" id="kobo.17.6">The second important aspect of concurrency is data access. </span><span class="koboSpan" id="kobo.17.7">Given a set of concurrent executions, how can these executions correctly access and modify the program data? </span><span class="koboSpan" id="kobo.17.8">Having seen a low-level answer to these questions in the previous chapter, such as the </span><code class="literal"><span class="koboSpan" id="kobo.18.1">synchronized</span></code><span class="koboSpan" id="kobo.19.1"> statement and volatile variables, we will now dive into more complex abstractions. </span><span class="koboSpan" id="kobo.19.2">We will study the following topics:</span></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.20.1">Using the </span><code class="literal"><span class="koboSpan" id="kobo.21.1">Executor</span></code><span class="koboSpan" id="kobo.22.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.23.1">ExecutionContext</span></code><span class="koboSpan" id="kobo.24.1"> objects</span></li><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.25.1">Atomic primitives for non-blocking synchronization</span></li><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.26.1">The interaction of lazy values and concurrency</span></li><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.27.1">Using concurrent queues, sets, and maps</span></li><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.28.1">How to create processes and communicate with them</span></li></ul></div><p><span class="koboSpan" id="kobo.29.1">The ultimate goal of this chapter will be to implement a safe API for concurrent file handling. </span><span class="koboSpan" id="kobo.29.2">We will use the abstractions in this chapter to implement a simple, reusable file-handling API for applications such as filesystem managers or FTP servers. </span><span class="koboSpan" id="kobo.29.3">We will thus see how the traditional building blocks of concurrency work separately and how they all fit together in a larger use case.</span></p><div class="section" title="The Executor and ExecutionContext objects"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec19"/><span class="koboSpan" id="kobo.30.1">The Executor and ExecutionContext objects</span></h1></div></div></div><p><span class="koboSpan" id="kobo.31.1">As discussed in </span><a class="link" href="ch02.html" title="Chapter 2. Concurrency on the JVM and the Java Memory Model"><span class="koboSpan" id="kobo.32.1">Chapter 2</span></a><span class="koboSpan" id="kobo.33.1">, </span><span class="emphasis"><em><span class="koboSpan" id="kobo.34.1">Concurrency on the JVM and the Java Memory Model</span></em></span><span class="koboSpan" id="kobo.35.1">, although creating a new thread in a Scala program takes orders of magnitude less computational time compared to creating a new JVM process, thread creation is still much more expensive than allocating a single object, acquiring a monitor lock, or updating an entry in a collection. </span><span class="koboSpan" id="kobo.35.2">If an application performs a large number of small concurrent tasks and requires high throughput, we cannot afford to create a fresh thread for each of these tasks. </span><span class="koboSpan" id="kobo.35.3">Starting a thread requires us to allocate a memory region for its call stack and a context switch from one thread to another, which can be much more time-consuming than the amount of work in the concurrent task. </span><span class="koboSpan" id="kobo.35.4">For this reason, most concurrency frameworks have facilities that maintain a set of threads in a waiting state and start running when concurrently executable work tasks become available. </span><span class="koboSpan" id="kobo.35.5">Generally, we call such facilities </span><span class="strong"><strong><span class="koboSpan" id="kobo.36.1">thread pools</span></strong></span><span class="koboSpan" id="kobo.37.1">.</span></p><p><span class="koboSpan" id="kobo.38.1">To allow programmers to encapsulate the decision of how to run concurrently executable work tasks, JDK comes with an abstraction called </span><code class="literal"><span class="koboSpan" id="kobo.39.1">Executor</span></code><span class="koboSpan" id="kobo.40.1">. </span><span class="koboSpan" id="kobo.40.2">The </span><code class="literal"><span class="koboSpan" id="kobo.41.1">Executor</span></code><span class="koboSpan" id="kobo.42.1"> interface is a simple interface that defines a single </span><code class="literal"><span class="koboSpan" id="kobo.43.1">execute</span></code><span class="koboSpan" id="kobo.44.1"> method. </span><span class="koboSpan" id="kobo.44.2">This method takes a </span><code class="literal"><span class="koboSpan" id="kobo.45.1">Runnable</span></code><span class="koboSpan" id="kobo.46.1"> object and eventually calls the </span><code class="literal"><span class="koboSpan" id="kobo.47.1">Runnable</span></code><span class="koboSpan" id="kobo.48.1"> object's </span><code class="literal"><span class="koboSpan" id="kobo.49.1">run</span></code><span class="koboSpan" id="kobo.50.1"> method. </span><span class="koboSpan" id="kobo.50.2">The </span><code class="literal"><span class="koboSpan" id="kobo.51.1">Executor</span></code><span class="koboSpan" id="kobo.52.1"> object decides on which thread and when to call the </span><code class="literal"><span class="koboSpan" id="kobo.53.1">run</span></code><span class="koboSpan" id="kobo.54.1"> method. </span><span class="koboSpan" id="kobo.54.2">An </span><code class="literal"><span class="koboSpan" id="kobo.55.1">Executor</span></code><span class="koboSpan" id="kobo.56.1"> object can start a new thread specifically for this invocation of </span><code class="literal"><span class="koboSpan" id="kobo.57.1">execute</span></code><span class="koboSpan" id="kobo.58.1"> or even execute the </span><code class="literal"><span class="koboSpan" id="kobo.59.1">Runnable</span></code><span class="koboSpan" id="kobo.60.1"> object directly on the caller thread. </span><span class="koboSpan" id="kobo.60.2">Usually, the </span><code class="literal"><span class="koboSpan" id="kobo.61.1">Executor</span></code><span class="koboSpan" id="kobo.62.1"> executes the </span><code class="literal"><span class="koboSpan" id="kobo.63.1">Runnable</span></code><span class="koboSpan" id="kobo.64.1"> object concurrently to the execution of the thread that called the </span><code class="literal"><span class="koboSpan" id="kobo.65.1">execute</span></code><span class="koboSpan" id="kobo.66.1"> method, and it is implemented as a thread pool.</span></p><p><span class="koboSpan" id="kobo.67.1">One </span><code class="literal"><span class="koboSpan" id="kobo.68.1">Executor</span></code><span class="koboSpan" id="kobo.69.1"> implementation, introduced in JDK 7, is </span><code class="literal"><span class="koboSpan" id="kobo.70.1">ForkJoinPool</span></code><span class="koboSpan" id="kobo.71.1"> and it is available in the </span><code class="literal"><span class="koboSpan" id="kobo.72.1">java.util.concurrent</span></code><span class="koboSpan" id="kobo.73.1"> package. </span><span class="koboSpan" id="kobo.73.2">Scala programs can use it in JDK 6 as well by importing the contents of the </span><code class="literal"><span class="koboSpan" id="kobo.74.1">scala.concurrent.forkjoin</span></code><span class="koboSpan" id="kobo.75.1"> package. </span><span class="koboSpan" id="kobo.75.2">In the following code snippet, we show you how to instantiate a </span><code class="literal"><span class="koboSpan" id="kobo.76.1">ForkJoinPool</span></code><span class="koboSpan" id="kobo.77.1"> class implementation and submit a task that can be asynchronously executed:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.78.1">import scala.concurrent._
import java.util.concurrent.ForkJoinPool
object ExecutorsCreate extends App {
  val executor = new ForkJoinPool
  executor.execute(new Runnable {
    def run() = log("This task is run asynchronously.")
  })
  Thread.sleep(500)
}</span></pre><p><span class="koboSpan" id="kobo.79.1">We start by importing the </span><code class="literal"><span class="koboSpan" id="kobo.80.1">scala.concurrent</span></code><span class="koboSpan" id="kobo.81.1"> package. </span><span class="koboSpan" id="kobo.81.2">In later examples, we implicitly assume that this package is imported. </span><span class="koboSpan" id="kobo.81.3">We then call the </span><code class="literal"><span class="koboSpan" id="kobo.82.1">ForkJoinPool</span></code><span class="koboSpan" id="kobo.83.1"> class and assign it to a value called the </span><code class="literal"><span class="koboSpan" id="kobo.84.1">executor</span></code><span class="koboSpan" id="kobo.85.1"> method. </span><span class="koboSpan" id="kobo.85.2">Once instantiated, the </span><code class="literal"><span class="koboSpan" id="kobo.86.1">executor</span></code><span class="koboSpan" id="kobo.87.1"> value is sent a task in the form of a </span><code class="literal"><span class="koboSpan" id="kobo.88.1">Runnable</span></code><span class="koboSpan" id="kobo.89.1"> object that prints to the standard output. </span><span class="koboSpan" id="kobo.89.2">Finally, we invoke the </span><code class="literal"><span class="koboSpan" id="kobo.90.1">sleep</span></code><span class="koboSpan" id="kobo.91.1"> statement in order to prevent the daemon threads in the </span><code class="literal"><span class="koboSpan" id="kobo.92.1">ForkJoinPool</span></code><span class="koboSpan" id="kobo.93.1"> instance from being terminated before they call the </span><code class="literal"><span class="koboSpan" id="kobo.94.1">run</span></code><span class="koboSpan" id="kobo.95.1"> method on the </span><code class="literal"><span class="koboSpan" id="kobo.96.1">Runnable</span></code><span class="koboSpan" id="kobo.97.1"> object. </span><span class="koboSpan" id="kobo.97.2">Note that the </span><code class="literal"><span class="koboSpan" id="kobo.98.1">sleep</span></code><span class="koboSpan" id="kobo.99.1"> statement is not required if you are running the example from SBT with the </span><code class="literal"><span class="koboSpan" id="kobo.100.1">fork</span></code><span class="koboSpan" id="kobo.101.1"> setting set to </span><code class="literal"><span class="koboSpan" id="kobo.102.1">false</span></code><span class="koboSpan" id="kobo.103.1">.</span></p><p><span class="koboSpan" id="kobo.104.1">Why do we need </span><code class="literal"><span class="koboSpan" id="kobo.105.1">Executor</span></code><span class="koboSpan" id="kobo.106.1"> objects in the first place? </span><span class="koboSpan" id="kobo.106.2">In the previous example, we can easily change the </span><code class="literal"><span class="koboSpan" id="kobo.107.1">Executor</span></code><span class="koboSpan" id="kobo.108.1"> implementation without affecting the code in the </span><code class="literal"><span class="koboSpan" id="kobo.109.1">Runnable</span></code><span class="koboSpan" id="kobo.110.1"> object. </span><span class="koboSpan" id="kobo.110.2">The </span><code class="literal"><span class="koboSpan" id="kobo.111.1">Executor</span></code><span class="koboSpan" id="kobo.112.1"> objects serve to decouple the logic in the concurrent computations from how these computations are executed. </span><span class="koboSpan" id="kobo.112.2">The programmer can focus on specifying parts of the code that potentially execute concurrently, separately from where and when to execute those parts of the code.</span></p><p><span class="koboSpan" id="kobo.113.1">The more elaborate subtype of the </span><code class="literal"><span class="koboSpan" id="kobo.114.1">Executor</span></code><span class="koboSpan" id="kobo.115.1"> interface, also implemented by the </span><code class="literal"><span class="koboSpan" id="kobo.116.1">ForkJoinPool</span></code><span class="koboSpan" id="kobo.117.1"> class, is called </span><code class="literal"><span class="koboSpan" id="kobo.118.1">ExecutorService</span></code><span class="koboSpan" id="kobo.119.1">. </span><span class="koboSpan" id="kobo.119.2">This extended </span><code class="literal"><span class="koboSpan" id="kobo.120.1">Executor</span></code><span class="koboSpan" id="kobo.121.1"> interface defines several convenience methods, the most prominent being the </span><code class="literal"><span class="koboSpan" id="kobo.122.1">shutdown</span></code><span class="koboSpan" id="kobo.123.1"> method. </span><span class="koboSpan" id="kobo.123.2">The </span><code class="literal"><span class="koboSpan" id="kobo.124.1">shutdown</span></code><span class="koboSpan" id="kobo.125.1"> method makes sure that the </span><code class="literal"><span class="koboSpan" id="kobo.126.1">Executor</span></code><span class="koboSpan" id="kobo.127.1"> object gracefully terminates by executing all the submitted tasks and then stopping all the worker threads. </span><span class="koboSpan" id="kobo.127.2">Fortunately, our </span><code class="literal"><span class="koboSpan" id="kobo.128.1">ForkJoinPool</span></code><span class="koboSpan" id="kobo.129.1"> implementation is benign with respect to termination. </span><span class="koboSpan" id="kobo.129.2">Its threads are daemons by default, so there is no need to shut it down explicitly at the end of the program. </span><span class="koboSpan" id="kobo.129.3">In general, however, programmers should call the </span><code class="literal"><span class="koboSpan" id="kobo.130.1">shutdown</span></code><span class="koboSpan" id="kobo.131.1"> method on the </span><code class="literal"><span class="koboSpan" id="kobo.132.1">ExecutorService</span></code><span class="koboSpan" id="kobo.133.1"> objects they created, typically before the program terminates.</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip18"/><span class="koboSpan" id="kobo.134.1">Tip</span></h3><p><span class="koboSpan" id="kobo.135.1">When your program no longer needs the </span><code class="literal"><span class="koboSpan" id="kobo.136.1">ExecutorService</span></code><span class="koboSpan" id="kobo.137.1"> object you created, you should ensure that the </span><code class="literal"><span class="koboSpan" id="kobo.138.1">shutdown</span></code><span class="koboSpan" id="kobo.139.1"> method is called.</span></p></div></div><p><span class="koboSpan" id="kobo.140.1">To ensure that all the tasks submitted to the </span><code class="literal"><span class="koboSpan" id="kobo.141.1">ForkJoinPool</span></code><span class="koboSpan" id="kobo.142.1"> object are complete, we need to additionally call the </span><code class="literal"><span class="koboSpan" id="kobo.143.1">awaitTermination</span></code><span class="koboSpan" id="kobo.144.1"> method, specifying the maximum amount of time to wait for their completion. </span><span class="koboSpan" id="kobo.144.2">Instead of calling the </span><code class="literal"><span class="koboSpan" id="kobo.145.1">sleep</span></code><span class="koboSpan" id="kobo.146.1"> statement, we can do the following:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.147.1">import java.util.concurrent.TimeUnit 
executor.shutdown() 
executor.awaitTermination(60, TimeUnit.SECONDS) 
</span></pre><p><span class="koboSpan" id="kobo.148.1">The </span><code class="literal"><span class="koboSpan" id="kobo.149.1">scala.concurrent</span></code><span class="koboSpan" id="kobo.150.1"> package defines the </span><code class="literal"><span class="koboSpan" id="kobo.151.1">ExecutionContext</span></code><span class="koboSpan" id="kobo.152.1"> trait that offers a similar functionality to that of </span><code class="literal"><span class="koboSpan" id="kobo.153.1">Executor</span></code><span class="koboSpan" id="kobo.154.1"> objects but is more specific to Scala. </span><span class="koboSpan" id="kobo.154.2">We will later learn that many Scala methods take </span><code class="literal"><span class="koboSpan" id="kobo.155.1">ExecutionContext</span></code><span class="koboSpan" id="kobo.156.1"> objects as implicit parameters. </span><span class="koboSpan" id="kobo.156.2">Execution contexts implement the abstract </span><code class="literal"><span class="koboSpan" id="kobo.157.1">execute</span></code><span class="koboSpan" id="kobo.158.1"> method, which exactly corresponds to the </span><code class="literal"><span class="koboSpan" id="kobo.159.1">execute</span></code><span class="koboSpan" id="kobo.160.1"> method on the </span><code class="literal"><span class="koboSpan" id="kobo.161.1">Executor</span></code><span class="koboSpan" id="kobo.162.1"> interface, and the </span><code class="literal"><span class="koboSpan" id="kobo.163.1">reportFailure</span></code><span class="koboSpan" id="kobo.164.1"> method, which takes a </span><code class="literal"><span class="koboSpan" id="kobo.165.1">Throwable</span></code><span class="koboSpan" id="kobo.166.1"> object and is called whenever some task throws an exception. </span><span class="koboSpan" id="kobo.166.2">The </span><code class="literal"><span class="koboSpan" id="kobo.167.1">ExecutionContext</span></code><span class="koboSpan" id="kobo.168.1"> companion object contains the default execution context called </span><code class="literal"><span class="koboSpan" id="kobo.169.1">global</span></code><span class="koboSpan" id="kobo.170.1">, which internally uses a </span><code class="literal"><span class="koboSpan" id="kobo.171.1">ForkJoinPool</span></code><span class="koboSpan" id="kobo.172.1"> instance:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.173.1">object ExecutionContextGlobal extends App { 
  val ectx = ExecutionContext.global 
  ectx.execute(new Runnable { 
    def run() = log("Running on the execution context.") 
  }) 
  Thread.sleep(500) 
} 
</span></pre><p><span class="koboSpan" id="kobo.174.1">The </span><code class="literal"><span class="koboSpan" id="kobo.175.1">ExecutionContext</span></code><span class="koboSpan" id="kobo.176.1"> companion object defines a pair of methods, </span><code class="literal"><span class="koboSpan" id="kobo.177.1">fromExecutor</span></code><span class="koboSpan" id="kobo.178.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.179.1">fromExecutorService</span></code><span class="koboSpan" id="kobo.180.1">, which create an </span><code class="literal"><span class="koboSpan" id="kobo.181.1">ExecutionContext</span></code><span class="koboSpan" id="kobo.182.1"> object from an </span><code class="literal"><span class="koboSpan" id="kobo.183.1">Executor</span></code><span class="koboSpan" id="kobo.184.1"> or </span><code class="literal"><span class="koboSpan" id="kobo.185.1">ExecutorService</span></code><span class="koboSpan" id="kobo.186.1"> interface, respectively:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.187.1">object ExecutionContextCreate extends App { 
  val pool = new forkjoin.ForkJoinPool(2) 
  val ectx = ExecutionContext.fromExecutorService(pool) 
  ectx.execute(new Runnable { 
    def run() = log("Running on the execution context again.") 
  }) 
  Thread.sleep(500) 
} 
</span></pre><p><span class="koboSpan" id="kobo.188.1">In the preceding example, we will create an </span><code class="literal"><span class="koboSpan" id="kobo.189.1">ExecutionContext</span></code><span class="koboSpan" id="kobo.190.1"> object from a </span><code class="literal"><span class="koboSpan" id="kobo.191.1">ForkJoinPool</span></code><span class="koboSpan" id="kobo.192.1"> instance with a parallelism level of </span><code class="literal"><span class="koboSpan" id="kobo.193.1">2</span></code><span class="koboSpan" id="kobo.194.1">. </span><span class="koboSpan" id="kobo.194.2">This means that the </span><code class="literal"><span class="koboSpan" id="kobo.195.1">ForkJoinPool</span></code><span class="koboSpan" id="kobo.196.1"> instance will usually keep two worker threads in its pool.</span></p><p><span class="koboSpan" id="kobo.197.1">In the examples that follow, we will rely on the global </span><code class="literal"><span class="koboSpan" id="kobo.198.1">ExecutionContext</span></code><span class="koboSpan" id="kobo.199.1"> object. </span><span class="koboSpan" id="kobo.199.2">To make the code more concise, we will introduce the </span><code class="literal"><span class="koboSpan" id="kobo.200.1">execute</span></code><span class="koboSpan" id="kobo.201.1"> convenience method in the package object of this chapter, which executes a block of code on the global </span><code class="literal"><span class="koboSpan" id="kobo.202.1">ExecutionContext</span></code><span class="koboSpan" id="kobo.203.1"> object:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.204.1">def execute(body: =&gt;Unit) = ExecutionContext.global.execute( 
  new Runnable { def run() = body } 
) 
</span></pre><p><span class="koboSpan" id="kobo.205.1">The </span><code class="literal"><span class="koboSpan" id="kobo.206.1">Executor</span></code><span class="koboSpan" id="kobo.207.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.208.1">ExecutionContext</span></code><span class="koboSpan" id="kobo.209.1"> objects are a nifty concurrent programming abstraction, but they are not a silver bullets. </span><span class="koboSpan" id="kobo.209.2">They can improve throughput by reusing the same set of threads for different tasks, but they are unable to execute tasks if those threads become unavailable, because all the threads are busy with running other tasks. </span><span class="koboSpan" id="kobo.209.3">In the following example, we declare </span><code class="literal"><span class="koboSpan" id="kobo.210.1">32</span></code><span class="koboSpan" id="kobo.211.1"> independent executions, each of which lasts two seconds, and wait </span><code class="literal"><span class="koboSpan" id="kobo.212.1">10</span></code><span class="koboSpan" id="kobo.213.1"> seconds for their completion:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.214.1">object ExecutionContextSleep extends App { 
  for (i&lt;- 0 until 32) execute { 
    Thread.sleep(2000) 
    log(s"Task $i completed.") 
  } 
  Thread.sleep(10000) 
} 
</span></pre><p><span class="koboSpan" id="kobo.215.1">You would expect that all the executions terminate after two seconds, but this is not the case. </span><span class="koboSpan" id="kobo.215.2">Instead, on our quad-core CPU with hyper threading, the global </span><code class="literal"><span class="koboSpan" id="kobo.216.1">ExecutionContext</span></code><span class="koboSpan" id="kobo.217.1"> object has eight threads in the thread pool, so it executes work tasks in batches of eight. </span><span class="koboSpan" id="kobo.217.2">After two seconds, a batch of eight tasks print that they are completed, after two more seconds another batch prints, and so on. </span><span class="koboSpan" id="kobo.217.3">This is because the global </span><code class="literal"><span class="koboSpan" id="kobo.218.1">ExecutionContext</span></code><span class="koboSpan" id="kobo.219.1"> object internally maintains a pool of eight worker threads, and calling </span><code class="literal"><span class="koboSpan" id="kobo.220.1">sleep</span></code><span class="koboSpan" id="kobo.221.1"> puts all of them into a timed waiting state. </span><span class="koboSpan" id="kobo.221.2">Only once the </span><code class="literal"><span class="koboSpan" id="kobo.222.1">sleep</span></code><span class="koboSpan" id="kobo.223.1"> method call in these worker threads is completed can another batch of eight tasks be executed. </span><span class="koboSpan" id="kobo.223.2">Things can be much worse. </span><span class="koboSpan" id="kobo.223.3">We could start eight tasks that execute the guarded block idiom seen in </span><a class="link" href="ch02.html" title="Chapter 2. Concurrency on the JVM and the Java Memory Model"><span class="koboSpan" id="kobo.224.1">Chapter 2</span></a><span class="koboSpan" id="kobo.225.1">, </span><span class="emphasis"><em><span class="koboSpan" id="kobo.226.1">Concurrency on the JVM and the Java Memory Model</span></em></span><span class="koboSpan" id="kobo.227.1">, and another task that calls the </span><code class="literal"><span class="koboSpan" id="kobo.228.1">notify</span></code><span class="koboSpan" id="kobo.229.1"> method to wake them up. </span><span class="koboSpan" id="kobo.229.2">As the </span><code class="literal"><span class="koboSpan" id="kobo.230.1">ExecutionContext</span></code><span class="koboSpan" id="kobo.231.1"> object can execute only eight tasks concurrently, the worker threads would, in this case, be blocked forever. </span><span class="koboSpan" id="kobo.231.2">We say that executing blocking operations on </span><code class="literal"><span class="koboSpan" id="kobo.232.1">ExecutionContext</span></code><span class="koboSpan" id="kobo.233.1"> objects can cause starvation.</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip19"/><span class="koboSpan" id="kobo.234.1">Tip</span></h3><p><span class="koboSpan" id="kobo.235.1">Avoid executing operations that might block indefinitely on </span><code class="literal"><span class="koboSpan" id="kobo.236.1">ExecutionContext</span></code><span class="koboSpan" id="kobo.237.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.238.1">Executor</span></code><span class="koboSpan" id="kobo.239.1"> objects.</span></p></div></div><p><span class="koboSpan" id="kobo.240.1">Having seen how to declare concurrent executions, we turn our attention to how these concurrent executions interact by manipulating program data.</span></p></div></div></div></div>
<div id="book-columns"><div id="book-inner"><div class="section" title="Atomic primitives"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec20"/><span class="koboSpan" id="kobo.1.1">Atomic primitives</span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">In </span><a class="link" href="ch02.html" title="Chapter 2. Concurrency on the JVM and the Java Memory Model"><span class="koboSpan" id="kobo.3.1">Chapter 2</span></a><span class="koboSpan" id="kobo.4.1">, </span><span class="emphasis"><em><span class="koboSpan" id="kobo.5.1">Concurrency on the JVM and the Java Memory Model</span></em></span><span class="koboSpan" id="kobo.6.1">, we learned that memory writes do not happen immediately unless proper synchronization is applied. </span><span class="koboSpan" id="kobo.6.2">A set of memory writes is not executed at once, that is, atomically. </span><span class="koboSpan" id="kobo.6.3">We saw that visibility is ensured by the happens-before relationship, and we relied on the </span><code class="literal"><span class="koboSpan" id="kobo.7.1">synchronized</span></code><span class="koboSpan" id="kobo.8.1"> statement to achieve it. </span><span class="koboSpan" id="kobo.8.2">Volatile fields were a more lightweight way of ensuring happens-before relationships, but a less powerful synchronization construct. </span><span class="koboSpan" id="kobo.8.3">Recall how volatile fields alone could not implement the </span><code class="literal"><span class="koboSpan" id="kobo.9.1">getUniqueId</span></code><span class="koboSpan" id="kobo.10.1"> method correctly.</span></p><p><span class="koboSpan" id="kobo.11.1">In this section, we study atomic variables that provide basic support for executing multiple memory reads and writes at once. </span><span class="koboSpan" id="kobo.11.2">Atomic variables are close cousins of volatile variables, but are more expressive than them; they are used to build complex concurrent operations without relying on the </span><code class="literal"><span class="koboSpan" id="kobo.12.1">synchronized</span></code><span class="koboSpan" id="kobo.13.1"> statement.</span></p><div class="section" title="Atomic variables"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec22"/><span class="koboSpan" id="kobo.14.1">Atomic variables</span></h2></div></div></div><p><span class="koboSpan" id="kobo.15.1">An atomic variable is a memory location that supports complex </span><span class="emphasis"><em><span class="koboSpan" id="kobo.16.1">linearizable</span></em></span><span class="koboSpan" id="kobo.17.1"> operations. </span><span class="koboSpan" id="kobo.17.2">A linearizable operation is any operation that appears to occur instantaneously to the rest of the system. </span><span class="koboSpan" id="kobo.17.3">For example, a volatile write is a linearizable operation. </span><span class="koboSpan" id="kobo.17.4">A complex linearizable operation is a linearizable operation equivalent to at least two reads and/or writes. </span><span class="koboSpan" id="kobo.17.5">We will use the term </span><span class="emphasis"><em><span class="koboSpan" id="kobo.18.1">atomically</span></em></span><span class="koboSpan" id="kobo.19.1"> to refer to complex linearizable operations.</span></p><p><span class="koboSpan" id="kobo.20.1">Various atomic variables defined in the </span><code class="literal"><span class="koboSpan" id="kobo.21.1">java.util.concurrent.atomic</span></code><span class="koboSpan" id="kobo.22.1"> package support some complex linearizable operations on the Boolean, integer, long, and reference types with the </span><code class="literal"><span class="koboSpan" id="kobo.23.1">AtomicBoolean</span></code><span class="koboSpan" id="kobo.24.1">, </span><code class="literal"><span class="koboSpan" id="kobo.25.1">AtomicInteger</span></code><span class="koboSpan" id="kobo.26.1">, </span><code class="literal"><span class="koboSpan" id="kobo.27.1">AtomicLong</span></code><span class="koboSpan" id="kobo.28.1">, and </span><code class="literal"><span class="koboSpan" id="kobo.29.1">AtomicReference</span></code><span class="koboSpan" id="kobo.30.1"> classes, respectively. </span><span class="koboSpan" id="kobo.30.2">Recall that the </span><code class="literal"><span class="koboSpan" id="kobo.31.1">getUniqueId</span></code><span class="koboSpan" id="kobo.32.1"> method from </span><a class="link" href="ch02.html" title="Chapter 2. Concurrency on the JVM and the Java Memory Model"><span class="koboSpan" id="kobo.33.1">Chapter 2</span></a><span class="koboSpan" id="kobo.34.1">, </span><span class="emphasis"><em><span class="koboSpan" id="kobo.35.1">Concurrency on the JVM and the Java Memory Model</span></em></span><span class="koboSpan" id="kobo.36.1">, needs to return a unique numeric identifier each time a thread invokes it. </span><span class="koboSpan" id="kobo.36.2">We previously implemented this method using the </span><code class="literal"><span class="koboSpan" id="kobo.37.1">synchronized</span></code><span class="koboSpan" id="kobo.38.1"> statement, and we now reimplement it using atomic long variables:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.39.1">import java.util.concurrent.atomic._ 
object AtomicUid extends App { 
  private val uid = new AtomicLong(0L) 
  def getUniqueId(): Long = uid.incrementAndGet() 
  execute { log(s"Uid asynchronously: ${getUniqueId()}") } 
  log(s"Got a unique id: ${getUniqueId()}") 
} 
</span></pre><p><span class="koboSpan" id="kobo.40.1">Here, we declare an atomic long variable, which is </span><code class="literal"><span class="koboSpan" id="kobo.41.1">uid</span></code><span class="koboSpan" id="kobo.42.1">, with an initial value </span><code class="literal"><span class="koboSpan" id="kobo.43.1">0</span></code><span class="koboSpan" id="kobo.44.1"> and call its </span><code class="literal"><span class="koboSpan" id="kobo.45.1">incrementAndGet</span></code><span class="koboSpan" id="kobo.46.1"> method from </span><code class="literal"><span class="koboSpan" id="kobo.47.1">getUniqueId</span></code><span class="koboSpan" id="kobo.48.1">. </span><span class="koboSpan" id="kobo.48.2">The </span><code class="literal"><span class="koboSpan" id="kobo.49.1">incrementAndGet</span></code><span class="koboSpan" id="kobo.50.1"> method is a complex linearizable operation. </span><span class="koboSpan" id="kobo.50.2">It simultaneously reads the current value </span><code class="literal"><span class="koboSpan" id="kobo.51.1">x</span></code><span class="koboSpan" id="kobo.52.1"> of </span><code class="literal"><span class="koboSpan" id="kobo.53.1">uid</span></code><span class="koboSpan" id="kobo.54.1">, computes </span><code class="literal"><span class="koboSpan" id="kobo.55.1">x + 1</span></code><span class="koboSpan" id="kobo.56.1">, writes </span><code class="literal"><span class="koboSpan" id="kobo.57.1">x + 1</span></code><span class="koboSpan" id="kobo.58.1"> back to </span><code class="literal"><span class="koboSpan" id="kobo.59.1">uid</span></code><span class="koboSpan" id="kobo.60.1">, and returns </span><code class="literal"><span class="koboSpan" id="kobo.61.1">x + 1</span></code><span class="koboSpan" id="kobo.62.1">. </span><span class="koboSpan" id="kobo.62.2">These steps cannot be interleaved with steps in other invocations of the </span><code class="literal"><span class="koboSpan" id="kobo.63.1">incrementAndGet</span></code><span class="koboSpan" id="kobo.64.1"> method, so each invocation of the </span><code class="literal"><span class="koboSpan" id="kobo.65.1">getUniqueId</span></code><span class="koboSpan" id="kobo.66.1"> method returns a unique number.</span></p><p><span class="koboSpan" id="kobo.67.1">Atomic variables define other methods such as the </span><code class="literal"><span class="koboSpan" id="kobo.68.1">getAndSet</span></code><span class="koboSpan" id="kobo.69.1"> method, which atomically reads the value of the variable, sets the new value, and returns its previous value. </span><span class="koboSpan" id="kobo.69.2">Numeric atomic variables additionally have methods such as </span><code class="literal"><span class="koboSpan" id="kobo.70.1">decrementAndGet</span></code><span class="koboSpan" id="kobo.71.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.72.1">addAndGet</span></code><span class="koboSpan" id="kobo.73.1">. </span><span class="koboSpan" id="kobo.73.2">It turns out that all these atomic operations are implemented in terms of a fundamental atomic operation, which is </span><code class="literal"><span class="koboSpan" id="kobo.74.1">compareAndSet</span></code><span class="koboSpan" id="kobo.75.1">. </span><span class="koboSpan" id="kobo.75.2">The compare-and-set operation, sometimes called </span><span class="strong"><strong><span class="koboSpan" id="kobo.76.1">compare-and-swap</span></strong></span><span class="koboSpan" id="kobo.77.1"> (</span><span class="strong"><strong><span class="koboSpan" id="kobo.78.1">CAS</span></strong></span><span class="koboSpan" id="kobo.79.1">), takes the expected previous value and the new value for the atomic variable and atomically replaces the current value with the new value only if the current value is equal to the expected value.</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note20"/><span class="koboSpan" id="kobo.80.1">Note</span></h3><p><span class="koboSpan" id="kobo.81.1">The CAS operation is a fundamental building block for lock-free programming.</span></p></div></div><p><span class="koboSpan" id="kobo.82.1">The CAS operation is conceptually equivalent to the following </span><code class="literal"><span class="koboSpan" id="kobo.83.1">synchronized</span></code><span class="koboSpan" id="kobo.84.1"> block, but is more efficient and does not get blocked on most JVMs, as it is implemented in terms of a processor instruction:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.85.1">def compareAndSet(ov: Long, nv: Long): Boolean = 
  this.synchronized { 
    if (this.get == ov) false else { 
      this.set(nv) 
      true 
    } 
  } 
</span></pre><p><span class="koboSpan" id="kobo.86.1">The CAS operation is available on all types of atomic variables; </span><code class="literal"><span class="koboSpan" id="kobo.87.1">compareAndSet</span></code><span class="koboSpan" id="kobo.88.1"> also exists in the generic </span><code class="literal"><span class="koboSpan" id="kobo.89.1">AtomicReference[T]</span></code><span class="koboSpan" id="kobo.90.1"> class used to store object references of an arbitrary object of type </span><code class="literal"><span class="koboSpan" id="kobo.91.1">T</span></code><span class="koboSpan" id="kobo.92.1">, and is equivalent to the following:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.93.1">def compareAndSet(ov: T, nv: T): Boolean = this.synchronized { 
  if (this.get eq ov) false else { 
    this.set(nv) 
    true 
  } 
} 
</span></pre><p><span class="koboSpan" id="kobo.94.1">If CAS does replace the old value with the new value, it returns the value </span><code class="literal"><span class="koboSpan" id="kobo.95.1">true</span></code><span class="koboSpan" id="kobo.96.1">. </span><span class="koboSpan" id="kobo.96.2">Otherwise, CAS returns </span><code class="literal"><span class="koboSpan" id="kobo.97.1">false</span></code><span class="koboSpan" id="kobo.98.1">. </span><span class="koboSpan" id="kobo.98.2">When using CAS, we usually start by calling the </span><code class="literal"><span class="koboSpan" id="kobo.99.1">get</span></code><span class="koboSpan" id="kobo.100.1"> method on the atomic variable to read its value. </span><span class="koboSpan" id="kobo.100.2">We then compute a new value based on the value we read. </span><span class="koboSpan" id="kobo.100.3">Finally, we invoke the CAS operation to change the value we previously read with the new value. </span><span class="koboSpan" id="kobo.100.4">If the CAS operation returns </span><code class="literal"><span class="koboSpan" id="kobo.101.1">true</span></code><span class="koboSpan" id="kobo.102.1">, we are done. </span><span class="koboSpan" id="kobo.102.2">If the CAS operation returns </span><code class="literal"><span class="koboSpan" id="kobo.103.1">false</span></code><span class="koboSpan" id="kobo.104.1">, then some other thread must have changed the atomic variable since we last read it using the </span><code class="literal"><span class="koboSpan" id="kobo.105.1">get</span></code><span class="koboSpan" id="kobo.106.1"> variable.</span></p><p><span class="koboSpan" id="kobo.107.1">Let's see how CAS works in a concrete example. </span><span class="koboSpan" id="kobo.107.2">We will re-implement the </span><code class="literal"><span class="koboSpan" id="kobo.108.1">getUniqueId</span></code><span class="koboSpan" id="kobo.109.1"> method using the </span><code class="literal"><span class="koboSpan" id="kobo.110.1">get</span></code><span class="koboSpan" id="kobo.111.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.112.1">compareAndSet</span></code><span class="koboSpan" id="kobo.113.1"> methods:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.114.1">@tailrec def getUniqueId(): Long = { 
  val oldUid = uid.get 
  val newUid = oldUid + 1 
  if (uid.compareAndSet(oldUid, newUid)) newUid 
  else getUniqueId() 
} 
</span></pre><p><span class="koboSpan" id="kobo.115.1">This time, the thread</span><code class="literal"><span class="koboSpan" id="kobo.116.1">T</span></code><span class="koboSpan" id="kobo.117.1"> calls the </span><code class="literal"><span class="koboSpan" id="kobo.118.1">get</span></code><span class="koboSpan" id="kobo.119.1"> method to read the value of </span><code class="literal"><span class="koboSpan" id="kobo.120.1">uid</span></code><span class="koboSpan" id="kobo.121.1"> into a local variable </span><code class="literal"><span class="koboSpan" id="kobo.122.1">oldUid</span></code><span class="koboSpan" id="kobo.123.1">. </span><span class="koboSpan" id="kobo.123.2">Note that local variables such as </span><code class="literal"><span class="koboSpan" id="kobo.124.1">oldUid</span></code><span class="koboSpan" id="kobo.125.1"> are only used by a single thread that initialized them, so no other thread can see the version of the </span><code class="literal"><span class="koboSpan" id="kobo.126.1">oldUid</span></code><span class="koboSpan" id="kobo.127.1"> variable in thread T. </span><span class="koboSpan" id="kobo.127.2">The thread </span><code class="literal"><span class="koboSpan" id="kobo.128.1">T</span></code><span class="koboSpan" id="kobo.129.1"> then computes the new value </span><code class="literal"><span class="koboSpan" id="kobo.130.1">newUid</span></code><span class="koboSpan" id="kobo.131.1">. </span><span class="koboSpan" id="kobo.131.2">This does not happen atomically, and at this point, another thread S might concurrently change the value of the </span><code class="literal"><span class="koboSpan" id="kobo.132.1">uid</span></code><span class="koboSpan" id="kobo.133.1"> variable. </span><span class="koboSpan" id="kobo.133.2">The </span><code class="literal"><span class="koboSpan" id="kobo.134.1">compareAndSet</span></code><span class="koboSpan" id="kobo.135.1"> call by T changes </span><code class="literal"><span class="koboSpan" id="kobo.136.1">uid</span></code><span class="koboSpan" id="kobo.137.1"> successfully only if no other thread S modified the value of the </span><code class="literal"><span class="koboSpan" id="kobo.138.1">uid</span></code><span class="koboSpan" id="kobo.139.1"> variable since thread </span><code class="literal"><span class="koboSpan" id="kobo.140.1">T</span></code><span class="koboSpan" id="kobo.141.1"> called the </span><code class="literal"><span class="koboSpan" id="kobo.142.1">get</span></code><span class="koboSpan" id="kobo.143.1"> method in the first line. </span><span class="koboSpan" id="kobo.143.2">If the </span><code class="literal"><span class="koboSpan" id="kobo.144.1">compareAndSet</span></code><span class="koboSpan" id="kobo.145.1"> method is not successful, the method is called again tail-recursively. </span><span class="koboSpan" id="kobo.145.2">Hence, we use the </span><code class="literal"><span class="koboSpan" id="kobo.146.1">@tailrec</span></code><span class="koboSpan" id="kobo.147.1"> annotation to force the compiler to generate a tail-recursive call. </span><span class="koboSpan" id="kobo.147.2">We say that thread </span><code class="literal"><span class="koboSpan" id="kobo.148.1">T</span></code><span class="koboSpan" id="kobo.149.1"> needs to retry the operation. </span><span class="koboSpan" id="kobo.149.2">This is illustrated in the following figure:</span></p><div class="mediaobject"><span class="koboSpan" id="kobo.150.1"><img src="graphics/image_03_001.jpg" alt="Atomic variables"/></span></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip21"/><span class="koboSpan" id="kobo.151.1">Tip</span></h3><p><span class="koboSpan" id="kobo.152.1">Always use the </span><code class="literal"><span class="koboSpan" id="kobo.153.1">@tailrec</span></code><span class="koboSpan" id="kobo.154.1"> annotation for these functions, which are intended to be tail-recursive. </span><span class="koboSpan" id="kobo.154.2">The compiler will check all the annotated functions to see whether or not they are tail-recursive.</span></p></div></div><p><span class="koboSpan" id="kobo.155.1">Retrying is a common pattern when programming with CAS operations. </span><span class="koboSpan" id="kobo.155.2">This retry can happen infinitely many times. </span><span class="koboSpan" id="kobo.155.3">The good news is that a CAS in thread </span><span class="strong"><strong><span class="koboSpan" id="kobo.156.1">T</span></strong></span><span class="koboSpan" id="kobo.157.1"> can fail only when another thread </span><span class="strong"><strong><span class="koboSpan" id="kobo.158.1">S</span></strong></span><span class="koboSpan" id="kobo.159.1"> completes the operation successfully; if our part of the system does not progress, at least some other part of the system does. </span><span class="koboSpan" id="kobo.159.2">In fact, the </span><code class="literal"><span class="koboSpan" id="kobo.160.1">getUniqueId</span></code><span class="koboSpan" id="kobo.161.1"> method is fair to all the threads in practice, and most JDKs implement the </span><code class="literal"><span class="koboSpan" id="kobo.162.1">incrementAndGet</span></code><span class="koboSpan" id="kobo.163.1"> method in a very similar manner to our CAS-based implementation of the </span><code class="literal"><span class="koboSpan" id="kobo.164.1">getUniqueId</span></code><span class="koboSpan" id="kobo.165.1"> method.</span></p></div><div class="section" title="Lock-free programming"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec23"/><span class="koboSpan" id="kobo.166.1">Lock-free programming</span></h2></div></div></div><p><span class="koboSpan" id="kobo.167.1">A </span><span class="strong"><strong><span class="koboSpan" id="kobo.168.1">lock</span></strong></span><span class="koboSpan" id="kobo.169.1"> is a synchronization mechanism used to limit access to a resource that can be used by multiple threads. </span><span class="koboSpan" id="kobo.169.2">In </span><a class="link" href="ch02.html" title="Chapter 2. Concurrency on the JVM and the Java Memory Model"><span class="koboSpan" id="kobo.170.1">Chapter 2</span></a><span class="koboSpan" id="kobo.171.1">, </span><span class="emphasis"><em><span class="koboSpan" id="kobo.172.1">Concurrency on the JVM and the Java Memory Model</span></em></span><span class="koboSpan" id="kobo.173.1">, we learned that every JVM object has an intrinsic lock that is used when invoking the </span><code class="literal"><span class="koboSpan" id="kobo.174.1">synchronized</span></code><span class="koboSpan" id="kobo.175.1"> statement on the object. </span><span class="koboSpan" id="kobo.175.2">Recall that an intrinsic lock makes sure that at most one thread executes the </span><code class="literal"><span class="koboSpan" id="kobo.176.1">synchronized</span></code><span class="koboSpan" id="kobo.177.1"> statement on the object. </span><span class="koboSpan" id="kobo.177.2">The intrinsic lock accomplishes this by blocking all the threads that try to acquire it when it is unavailable. </span><span class="koboSpan" id="kobo.177.3">We will study other examples of locks in this section.</span></p><p><span class="koboSpan" id="kobo.178.1">As we already learned, programming using locks is susceptible to deadlocks. </span><span class="koboSpan" id="kobo.178.2">Also, if the OS pre-empts a thread that is holding a lock, it might arbitrarily delay the execution of other threads. </span><span class="koboSpan" id="kobo.178.3">In lock-free programs, these effects are less likely to compromise the program's performance.</span></p><p><span class="koboSpan" id="kobo.179.1">Why do we need atomic variables? </span><span class="koboSpan" id="kobo.179.2">Atomic variables allow us to implement </span><span class="emphasis"><em><span class="koboSpan" id="kobo.180.1">lock-free operations</span></em></span><span class="koboSpan" id="kobo.181.1">. </span><span class="koboSpan" id="kobo.181.2">As the name implies, a thread that executes a lock-free operation does not acquire any locks. </span><span class="koboSpan" id="kobo.181.3">Consequently, many lock-free algorithms have an improved throughput. </span><span class="koboSpan" id="kobo.181.4">A thread executing a lock-free algorithm does not hold any locks when it gets pre-empted by the OS, so it cannot temporarily block other threads. </span><span class="koboSpan" id="kobo.181.5">Furthermore, lock-free operations are impervious to deadlocks, because threads cannot get blocked indefinitely without locks.</span></p><p><span class="koboSpan" id="kobo.182.1">Our CAS-based implementation of the </span><code class="literal"><span class="koboSpan" id="kobo.183.1">getUniqueId</span></code><span class="koboSpan" id="kobo.184.1"> method is an example of a lock-free operation. </span><span class="koboSpan" id="kobo.184.2">It acquires no locks that can permanently suspend other threads. </span><span class="koboSpan" id="kobo.184.3">If one thread fails due to concurrent CAS operations, it immediately restarts and tries to execute the </span><code class="literal"><span class="koboSpan" id="kobo.185.1">getUniqueId</span></code><span class="koboSpan" id="kobo.186.1"> method again.</span></p><p><span class="koboSpan" id="kobo.187.1">However, not all operations composed from atomic primitives are lock-free. </span><span class="koboSpan" id="kobo.187.2">Using atomic variables is a necessary precondition for lock-freedom, but it is not sufficient. </span><span class="koboSpan" id="kobo.187.3">To show this, we will implement our own simple </span><code class="literal"><span class="koboSpan" id="kobo.188.1">synchronized</span></code><span class="koboSpan" id="kobo.189.1"> statement, which will use atomic variables:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.190.1">object AtomicLock extends App { 
  private val lock = new AtomicBoolean(false) 
  def mySynchronized(body: =&gt;Unit): Unit = { 
    while (!lock.compareAndSet(false, true)) {} 
    try body finally lock.set(false) 
  } 
  var count = 0 
  for (i&lt;- 0 until 10) execute { mySynchronized { count += 1 } } 
  Thread.sleep(1000) 
  log(s"Count is: $count") 
} 
</span></pre><p><span class="koboSpan" id="kobo.191.1">The </span><code class="literal"><span class="koboSpan" id="kobo.192.1">mySynchronized</span></code><span class="koboSpan" id="kobo.193.1"> statement executes a block of code </span><code class="literal"><span class="koboSpan" id="kobo.194.1">body</span></code><span class="koboSpan" id="kobo.195.1"> in isolation. </span><span class="koboSpan" id="kobo.195.2">It uses the atomic </span><code class="literal"><span class="koboSpan" id="kobo.196.1">lock</span></code><span class="koboSpan" id="kobo.197.1"> Boolean variable to decide whether some thread is currently calling the </span><code class="literal"><span class="koboSpan" id="kobo.198.1">mySynchronized</span></code><span class="koboSpan" id="kobo.199.1"> method or not. </span><span class="koboSpan" id="kobo.199.2">The first thread that changes the </span><code class="literal"><span class="koboSpan" id="kobo.200.1">lock</span></code><span class="koboSpan" id="kobo.201.1"> variable from </span><code class="literal"><span class="koboSpan" id="kobo.202.1">false</span></code><span class="koboSpan" id="kobo.203.1"> to </span><code class="literal"><span class="koboSpan" id="kobo.204.1">true</span></code><span class="koboSpan" id="kobo.205.1"> using the </span><code class="literal"><span class="koboSpan" id="kobo.206.1">compareAndSet</span></code><span class="koboSpan" id="kobo.207.1"> method can proceed with executing the body. </span><span class="koboSpan" id="kobo.207.2">While the thread is executing the body, other threads calling the </span><code class="literal"><span class="koboSpan" id="kobo.208.1">mySynchronized</span></code><span class="koboSpan" id="kobo.209.1"> method repetitively invoke the </span><code class="literal"><span class="koboSpan" id="kobo.210.1">compareAndSet</span></code><span class="koboSpan" id="kobo.211.1"> method on the </span><code class="literal"><span class="koboSpan" id="kobo.212.1">lock</span></code><span class="koboSpan" id="kobo.213.1"> variable but fail. </span><span class="koboSpan" id="kobo.213.2">Once </span><code class="literal"><span class="koboSpan" id="kobo.214.1">body</span></code><span class="koboSpan" id="kobo.215.1"> completes executing, the thread unconditionally sets the </span><code class="literal"><span class="koboSpan" id="kobo.216.1">lock</span></code><span class="koboSpan" id="kobo.217.1"> variable back to </span><code class="literal"><span class="koboSpan" id="kobo.218.1">false</span></code><span class="koboSpan" id="kobo.219.1"> in the </span><code class="literal"><span class="koboSpan" id="kobo.220.1">finally</span></code><span class="koboSpan" id="kobo.221.1"> block. </span><span class="koboSpan" id="kobo.221.2">A </span><code class="literal"><span class="koboSpan" id="kobo.222.1">compareAndSet</span></code><span class="koboSpan" id="kobo.223.1"> method in some other thread can then succeed, and the process is repeated again. </span><span class="koboSpan" id="kobo.223.2">After all the tasks are completed, the value of the </span><code class="literal"><span class="koboSpan" id="kobo.224.1">count</span></code><span class="koboSpan" id="kobo.225.1"> variable is always </span><code class="literal"><span class="koboSpan" id="kobo.226.1">10</span></code><span class="koboSpan" id="kobo.227.1">. </span><span class="koboSpan" id="kobo.227.2">The main difference with respect to the </span><code class="literal"><span class="koboSpan" id="kobo.228.1">synchronized</span></code><span class="koboSpan" id="kobo.229.1"> statement is that threads calling </span><code class="literal"><span class="koboSpan" id="kobo.230.1">mySynchronized</span></code><span class="koboSpan" id="kobo.231.1"> busy-wait in the </span><code class="literal"><span class="koboSpan" id="kobo.232.1">while</span></code><span class="koboSpan" id="kobo.233.1"> loop until the lock becomes available. </span><span class="koboSpan" id="kobo.233.2">Such locks are dangerous and much worse than the </span><code class="literal"><span class="koboSpan" id="kobo.234.1">synchronized</span></code><span class="koboSpan" id="kobo.235.1"> statement. </span><span class="koboSpan" id="kobo.235.2">This example shows you that we need to define lock-freedom more carefully, because a lock can implicitly exist in the program without the programmer being aware of it.</span></p><p><span class="koboSpan" id="kobo.236.1">In </span><a class="link" href="ch02.html" title="Chapter 2. Concurrency on the JVM and the Java Memory Model"><span class="koboSpan" id="kobo.237.1">Chapter 2</span></a><span class="koboSpan" id="kobo.238.1">, </span><span class="emphasis"><em><span class="koboSpan" id="kobo.239.1">Concurrency on the JVM and the Java Memory Model</span></em></span><span class="koboSpan" id="kobo.240.1">, we learned that most modern operating systems use pre-emptive multitasking, where a thread </span><code class="literal"><span class="koboSpan" id="kobo.241.1">T</span></code><span class="koboSpan" id="kobo.242.1"> can be temporarily suspended by the operating system at any point in time. </span><span class="koboSpan" id="kobo.242.2">If this happens while thread </span><code class="literal"><span class="koboSpan" id="kobo.243.1">T</span></code><span class="koboSpan" id="kobo.244.1"> is holding a lock, other threads waiting for the same lock cannot proceed until the lock is released. </span><span class="koboSpan" id="kobo.244.2">These other threads have to wait until the operating system continues executing the thread </span><code class="literal"><span class="koboSpan" id="kobo.245.1">T</span></code><span class="koboSpan" id="kobo.246.1"> and the thread </span><code class="literal"><span class="koboSpan" id="kobo.247.1">T</span></code><span class="koboSpan" id="kobo.248.1"> releases the lock. </span><span class="koboSpan" id="kobo.248.2">This is unfortunate, as these threads could be doing useful work while the thread </span><code class="literal"><span class="koboSpan" id="kobo.249.1">T</span></code><span class="koboSpan" id="kobo.250.1"> is suspended. </span><span class="koboSpan" id="kobo.250.2">We say that a slow thread </span><code class="literal"><span class="koboSpan" id="kobo.251.1">T</span></code><span class="koboSpan" id="kobo.252.1"> blocked the execution of other threads. </span><span class="koboSpan" id="kobo.252.2">In a lock-free operation, a slow thread cannot block the execution of other threads. </span><span class="koboSpan" id="kobo.252.3">If multiple threads execute an operation concurrently, then at least one of these threads must complete in a finite amount of time.</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note22"/><span class="koboSpan" id="kobo.253.1">Note</span></h3><p><span class="koboSpan" id="kobo.254.1">Given a set of threads executing an operation, an operation is lock-free if at least one thread always completes the operation after a finite number of steps, regardless of the speed at which different threads progress.</span></p></div></div><p><span class="koboSpan" id="kobo.255.1">With this more formal definition of lock-freedom, you can get a feel for why lock-free programming is hard. </span><span class="koboSpan" id="kobo.255.2">It is not easy to prove that an operation is lock-free, and implementing more complex lock-free operations is notoriously difficult. </span><span class="koboSpan" id="kobo.255.3">The CAS-based </span><code class="literal"><span class="koboSpan" id="kobo.256.1">getUniqueId</span></code><span class="koboSpan" id="kobo.257.1"> implementation is indeed lock-free. </span><span class="koboSpan" id="kobo.257.2">Threads only loop if the CAS fails, and the CAS can only fail if some thread successfully computed the unique identifier: this means that some other thread executed </span><code class="literal"><span class="koboSpan" id="kobo.258.1">getUniqueId</span></code><span class="koboSpan" id="kobo.259.1"> method successfully in a finite number of steps between the </span><code class="literal"><span class="koboSpan" id="kobo.260.1">get</span></code><span class="koboSpan" id="kobo.261.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.262.1">compareAndSet</span></code><span class="koboSpan" id="kobo.263.1"> method calls. </span><span class="koboSpan" id="kobo.263.2">This fact proves lock-freedom.</span></p></div><div class="section" title="Implementing locks explicitly"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec24"/><span class="koboSpan" id="kobo.264.1">Implementing locks explicitly</span></h2></div></div></div><p><span class="koboSpan" id="kobo.265.1">In some cases, we really do want locks, and atomic variables allow us to implement locks that do not have to block the caller. </span><span class="koboSpan" id="kobo.265.2">The trouble with intrinsic object locks from </span><a class="link" href="ch02.html" title="Chapter 2. Concurrency on the JVM and the Java Memory Model"><span class="koboSpan" id="kobo.266.1">Chapter 2</span></a><span class="koboSpan" id="kobo.267.1">, </span><span class="emphasis"><em><span class="koboSpan" id="kobo.268.1">Concurrency on the JVM and the Java Memory Model</span></em></span><span class="koboSpan" id="kobo.269.1">, is that a thread cannot inspect whether the object's intrinsic lock is currently acquired. </span><span class="koboSpan" id="kobo.269.2">Instead, a thread that calls </span><code class="literal"><span class="koboSpan" id="kobo.270.1">synchronized</span></code><span class="koboSpan" id="kobo.271.1"> is immediately blocked until the monitor becomes available. </span><span class="koboSpan" id="kobo.271.2">Sometimes, we would like our threads to execute a different action when a lock is unavailable.</span></p><p><span class="koboSpan" id="kobo.272.1">We now turn to the concurrent filesystem API mentioned at the beginning of this chapter. </span><span class="koboSpan" id="kobo.272.2">Inspecting the state of a lock is something we need to do in an application such as a file manager. </span><span class="koboSpan" id="kobo.272.3">In the good old days of DOS and Norton Commander, starting a file copy blocked the entire user interface, so you could sit back, relax, and grab your Game Boy until the file transfer completes. </span><span class="koboSpan" id="kobo.272.4">Times change; modern file managers need to start multiple file transfers simultaneously, cancel existing transfers, or delete different files simultaneously. </span><span class="koboSpan" id="kobo.272.5">Our filesystem API must ensure that:</span></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.273.1">If a thread is creating a new file, then that file cannot be copied or deleted</span></li><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.274.1">If one or more threads are copying a file, then the file cannot be deleted</span></li><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.275.1">If a thread is deleting a file, then the file cannot be copied</span></li><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.276.1">Only a single thread in the file manager is deleting a file at a time</span></li></ul></div><p><span class="koboSpan" id="kobo.277.1">The filesystem API will allow the concurrent copying and deleting of files. </span><span class="koboSpan" id="kobo.277.2">In this section, we will start by ensuring that only a single thread gets to delete a file. </span><span class="koboSpan" id="kobo.277.3">We model a single file or directory with the </span><code class="literal"><span class="koboSpan" id="kobo.278.1">Entry</span></code><span class="koboSpan" id="kobo.279.1"> class:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.280.1">class Entry(val isDir: Boolean) { 
  val state = new AtomicReference[State](new Idle) 
} 
</span></pre><p><span class="koboSpan" id="kobo.281.1">The </span><code class="literal"><span class="koboSpan" id="kobo.282.1">isDir</span></code><span class="koboSpan" id="kobo.283.1"> field of the </span><code class="literal"><span class="koboSpan" id="kobo.284.1">Entry</span></code><span class="koboSpan" id="kobo.285.1"> class denotes whether the respective path is a file or a directory. </span><span class="koboSpan" id="kobo.285.2">The </span><code class="literal"><span class="koboSpan" id="kobo.286.1">state</span></code><span class="koboSpan" id="kobo.287.1"> field describes the file state: whether the file is idle, currently being created, copied, or is scheduled for deletion. </span><span class="koboSpan" id="kobo.287.2">We model these states with a sealed trait called </span><code class="literal"><span class="koboSpan" id="kobo.288.1">State</span></code><span class="koboSpan" id="kobo.289.1">:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.290.1">sealed trait State 
class Idle extends State 
class Creating extends State 
class Copying(val n: Int) extends State 
class Deleting extends State 
</span></pre><p><span class="koboSpan" id="kobo.291.1">Note that, in the case of the </span><code class="literal"><span class="koboSpan" id="kobo.292.1">Copying</span></code><span class="koboSpan" id="kobo.293.1"> state, the </span><code class="literal"><span class="koboSpan" id="kobo.294.1">n</span></code><span class="koboSpan" id="kobo.295.1"> field also tracks how many concurrent copies are in progress. </span><span class="koboSpan" id="kobo.295.2">When using atomic variables, it is often useful to draw a diagram of the different states that an atomic variable can be in. </span><span class="koboSpan" id="kobo.295.3">As illustrated in the following figure, </span><code class="literal"><span class="koboSpan" id="kobo.296.1">state</span></code><span class="koboSpan" id="kobo.297.1"> is set to </span><code class="literal"><span class="koboSpan" id="kobo.298.1">Creating</span></code><span class="koboSpan" id="kobo.299.1"> immediately after an </span><code class="literal"><span class="koboSpan" id="kobo.300.1">Entry</span></code><span class="koboSpan" id="kobo.301.1"> class is created and then becomes the </span><code class="literal"><span class="koboSpan" id="kobo.302.1">Idle</span></code><span class="koboSpan" id="kobo.303.1"> state. </span><span class="koboSpan" id="kobo.303.2">After that, an </span><code class="literal"><span class="koboSpan" id="kobo.304.1">Entry</span></code><span class="koboSpan" id="kobo.305.1"> object can jump between the </span><code class="literal"><span class="koboSpan" id="kobo.306.1">Copying</span></code><span class="koboSpan" id="kobo.307.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.308.1">Idle</span></code><span class="koboSpan" id="kobo.309.1"> states indefinitely and, eventually, get from </span><code class="literal"><span class="koboSpan" id="kobo.310.1">Idle</span></code><span class="koboSpan" id="kobo.311.1"> to </span><code class="literal"><span class="koboSpan" id="kobo.312.1">Deleting</span></code><span class="koboSpan" id="kobo.313.1">. </span><span class="koboSpan" id="kobo.313.2">After getting into the </span><code class="literal"><span class="koboSpan" id="kobo.314.1">Deleting</span></code><span class="koboSpan" id="kobo.315.1"> state, the </span><code class="literal"><span class="koboSpan" id="kobo.316.1">Entry</span></code><span class="koboSpan" id="kobo.317.1"> class can no longer be modified; this indicates that we are about to delete the file.</span></p><div class="mediaobject"><span class="koboSpan" id="kobo.318.1"><img src="graphics/image_03_002.jpg" alt="Implementing locks explicitly"/></span></div><p><span class="koboSpan" id="kobo.319.1">Let's assume that we want to delete a file. </span><span class="koboSpan" id="kobo.319.2">There might be many threads running inside our file manager, and we want to avoid having two threads delete the same file. </span><span class="koboSpan" id="kobo.319.3">We will require the file being deleted to be in the </span><code class="literal"><span class="koboSpan" id="kobo.320.1">Idle</span></code><span class="koboSpan" id="kobo.321.1"> state and atomically change it to the </span><code class="literal"><span class="koboSpan" id="kobo.322.1">Deleting</span></code><span class="koboSpan" id="kobo.323.1"> state. </span><span class="koboSpan" id="kobo.323.2">If the file is not in the </span><code class="literal"><span class="koboSpan" id="kobo.324.1">Idle</span></code><span class="koboSpan" id="kobo.325.1"> state, we report an error. </span><span class="koboSpan" id="kobo.325.2">We will use the </span><code class="literal"><span class="koboSpan" id="kobo.326.1">logMessage</span></code><span class="koboSpan" id="kobo.327.1"> method, which is defined later; for now, we can assume that this method just calls our </span><code class="literal"><span class="koboSpan" id="kobo.328.1">log</span></code><span class="koboSpan" id="kobo.329.1"> statement:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.330.1">@tailrec private def prepareForDelete(entry: Entry): Boolean = { 
  val  s0 = entry.state.get 
  s0 match { 
    case i: Idle =&gt; 
      if (entry.state.compareAndSet(s0, new Deleting)) true 
      else prepareForDelete(entry) 
    case c: Creating =&gt; 
      logMessage("File currently created, cannot delete."); false 
    case c: Copying =&gt; 
      logMessage("File currently copied, cannot delete."); false 
    case d: Deleting =&gt; 
      false 
  } 
} 
</span></pre><p><span class="koboSpan" id="kobo.331.1">The </span><code class="literal"><span class="koboSpan" id="kobo.332.1">prepareForDelete</span></code><span class="koboSpan" id="kobo.333.1"> method starts by reading the </span><code class="literal"><span class="koboSpan" id="kobo.334.1">state</span></code><span class="koboSpan" id="kobo.335.1"> atomic reference variable and stores its value into a local variable, </span><code class="literal"><span class="koboSpan" id="kobo.336.1">s0</span></code><span class="koboSpan" id="kobo.337.1">. </span><span class="koboSpan" id="kobo.337.2">It then checks whether the </span><code class="literal"><span class="koboSpan" id="kobo.338.1">s0</span></code><span class="koboSpan" id="kobo.339.1"> variable is the </span><code class="literal"><span class="koboSpan" id="kobo.340.1">Idle</span></code><span class="koboSpan" id="kobo.341.1"> state and attempts to atomically change the state to the </span><code class="literal"><span class="koboSpan" id="kobo.342.1">Deleting</span></code><span class="koboSpan" id="kobo.343.1"> state. </span><span class="koboSpan" id="kobo.343.2">Just like in the </span><code class="literal"><span class="koboSpan" id="kobo.344.1">getUniqueId</span></code><span class="koboSpan" id="kobo.345.1"> method example, a failed CAS indicates that another thread changed the </span><code class="literal"><span class="koboSpan" id="kobo.346.1">state</span></code><span class="koboSpan" id="kobo.347.1"> variable and the operation needs to be repeated. </span><span class="koboSpan" id="kobo.347.2">The file cannot be deleted if another thread is creating or copying it, so we report an error and return </span><code class="literal"><span class="koboSpan" id="kobo.348.1">false</span></code><span class="koboSpan" id="kobo.349.1">. </span><span class="koboSpan" id="kobo.349.2">If another thread is already deleting the file, we only return </span><code class="literal"><span class="koboSpan" id="kobo.350.1">false</span></code><span class="koboSpan" id="kobo.351.1">.</span></p><p><span class="koboSpan" id="kobo.352.1">The </span><code class="literal"><span class="koboSpan" id="kobo.353.1">state</span></code><span class="koboSpan" id="kobo.354.1"> atomic variable implicitly acts like a lock in this example, although it neither blocks the other threads nor busy-waits. </span><span class="koboSpan" id="kobo.354.2">If the </span><code class="literal"><span class="koboSpan" id="kobo.355.1">prepareForDelete</span></code><span class="koboSpan" id="kobo.356.1"> method returns </span><code class="literal"><span class="koboSpan" id="kobo.357.1">true</span></code><span class="koboSpan" id="kobo.358.1">, we know that our thread can safely delete the file, as it is the only thread that changed the </span><code class="literal"><span class="koboSpan" id="kobo.359.1">state</span></code><span class="koboSpan" id="kobo.360.1"> variable value to </span><code class="literal"><span class="koboSpan" id="kobo.361.1">Deleting</span></code><span class="koboSpan" id="kobo.362.1">. </span><span class="koboSpan" id="kobo.362.2">However, if the method returns </span><code class="literal"><span class="koboSpan" id="kobo.363.1">false</span></code><span class="koboSpan" id="kobo.364.1">, we report an error in the file manager UI instead of blocking it.</span></p><p><span class="koboSpan" id="kobo.365.1">An important thing to note about the </span><code class="literal"><span class="koboSpan" id="kobo.366.1">AtomicReference</span></code><span class="koboSpan" id="kobo.367.1"> class is that it always uses reference equality when comparing the old object and the new object assigned to </span><code class="literal"><span class="koboSpan" id="kobo.368.1">state</span></code><span class="koboSpan" id="kobo.369.1">.</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note23"/><span class="koboSpan" id="kobo.370.1">Note</span></h3><p><span class="koboSpan" id="kobo.371.1">The CAS instructions on atomic reference variables always use reference equality and never call the </span><code class="literal"><span class="koboSpan" id="kobo.372.1">equals</span></code><span class="koboSpan" id="kobo.373.1"> method, even when the </span><code class="literal"><span class="koboSpan" id="kobo.374.1">equals</span></code><span class="koboSpan" id="kobo.375.1"> method is overridden.</span></p></div></div><p><span class="koboSpan" id="kobo.376.1">As an expert in sequential Scala programming, you might be tempted to implement </span><code class="literal"><span class="koboSpan" id="kobo.377.1">State</span></code><span class="koboSpan" id="kobo.378.1"> subtypes as case classes in order to get the </span><code class="literal"><span class="koboSpan" id="kobo.379.1">equals</span></code><span class="koboSpan" id="kobo.380.1"> method for free, but this does not affect the </span><code class="literal"><span class="koboSpan" id="kobo.381.1">compareAndSet</span></code><span class="koboSpan" id="kobo.382.1"> method operation.</span></p></div><div class="section" title="The ABA problem"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec25"/><span class="koboSpan" id="kobo.383.1">The ABA problem</span></h2></div></div></div><p><span class="koboSpan" id="kobo.384.1">The </span><span class="strong"><strong><span class="koboSpan" id="kobo.385.1">ABA problem</span></strong></span><span class="koboSpan" id="kobo.386.1"> is a situation in concurrent programming where two reads of the same memory location yield the same value A, which is used to indicate that the value of the memory location did not change between the two reads. </span><span class="koboSpan" id="kobo.386.2">This conclusion can be violated if other threads concurrently write some value B to the memory location, followed by the write of value A again. </span><span class="koboSpan" id="kobo.386.3">The ABA problem is usually a type of a race condition. </span><span class="koboSpan" id="kobo.386.4">In some cases, it leads to program errors.</span></p><p><span class="koboSpan" id="kobo.387.1">Suppose that we implemented </span><code class="literal"><span class="koboSpan" id="kobo.388.1">Copying</span></code><span class="koboSpan" id="kobo.389.1"> as a class with a mutable field </span><code class="literal"><span class="koboSpan" id="kobo.390.1">n</span></code><span class="koboSpan" id="kobo.391.1">. </span><span class="koboSpan" id="kobo.391.2">We might then be tempted to reuse the same </span><code class="literal"><span class="koboSpan" id="kobo.392.1">Copying</span></code><span class="koboSpan" id="kobo.393.1"> object for subsequent calls to </span><code class="literal"><span class="koboSpan" id="kobo.394.1">release</span></code><span class="koboSpan" id="kobo.395.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.396.1">acquire</span></code><span class="koboSpan" id="kobo.397.1">. </span><span class="koboSpan" id="kobo.397.2">This is almost certainly not a good idea!</span></p><p><span class="koboSpan" id="kobo.398.1">Let's assume that we have a hypothetical pair of methods called </span><code class="literal"><span class="koboSpan" id="kobo.399.1">releaseCopy</span></code><span class="koboSpan" id="kobo.400.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.401.1">acquireCopy</span></code><span class="koboSpan" id="kobo.402.1">. </span><span class="koboSpan" id="kobo.402.2">The </span><code class="literal"><span class="koboSpan" id="kobo.403.1">releaseCopy</span></code><span class="koboSpan" id="kobo.404.1"> method assumes that the </span><code class="literal"><span class="koboSpan" id="kobo.405.1">Entry</span></code><span class="koboSpan" id="kobo.406.1"> class is in the </span><code class="literal"><span class="koboSpan" id="kobo.407.1">Copying</span></code><span class="koboSpan" id="kobo.408.1"> state and changes the state from </span><code class="literal"><span class="koboSpan" id="kobo.409.1">Copying</span></code><span class="koboSpan" id="kobo.410.1"> to another </span><code class="literal"><span class="koboSpan" id="kobo.411.1">Copying</span></code><span class="koboSpan" id="kobo.412.1"> or </span><code class="literal"><span class="koboSpan" id="kobo.413.1">Idle</span></code><span class="koboSpan" id="kobo.414.1"> state. </span><span class="koboSpan" id="kobo.414.2">It then returns the old </span><code class="literal"><span class="koboSpan" id="kobo.415.1">Copying</span></code><span class="koboSpan" id="kobo.416.1"> object associated with the previous state:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.417.1">def releaseCopy(e: Entry): Copying = e.state.get match { 
  case c: Copying =&gt; 
    val nstate = if (c.n == 1) new Idle else new Copying(c.n - 1) 
    if (e.state.compareAndSet(c, nstate)) c 
    else releaseCopy(e) 
} 
</span></pre><p><span class="koboSpan" id="kobo.418.1">The </span><code class="literal"><span class="koboSpan" id="kobo.419.1">acquireCopy</span></code><span class="koboSpan" id="kobo.420.1"> method takes a currently unused </span><code class="literal"><span class="koboSpan" id="kobo.421.1">Copying</span></code><span class="koboSpan" id="kobo.422.1"> object and attempts to replace the old state with the previously used </span><code class="literal"><span class="koboSpan" id="kobo.423.1">Copying</span></code><span class="koboSpan" id="kobo.424.1"> object:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.425.1">def acquireCopy(e: Entry, c: Copying) = e.state.get match { 
  case i: Idle =&gt; 
    c.n = 1 
    if (!e.state.compareAndSet(i, c)) acquire(e, c) 
  case oc: Copying =&gt; 
    c.n = oc.n + 1 
    if (!e.state.compareAndSet(oc, c)) acquire(e, c) 
} 
</span></pre><p><span class="koboSpan" id="kobo.426.1">Upon calling the </span><code class="literal"><span class="koboSpan" id="kobo.427.1">releaseCopy</span></code><span class="koboSpan" id="kobo.428.1"> method, a thread might store the old </span><code class="literal"><span class="koboSpan" id="kobo.429.1">Copying</span></code><span class="koboSpan" id="kobo.430.1"> object. </span><span class="koboSpan" id="kobo.430.2">Later, the same thread can reuse the old </span><code class="literal"><span class="koboSpan" id="kobo.431.1">Copying</span></code><span class="koboSpan" id="kobo.432.1"> object in the call to the </span><code class="literal"><span class="koboSpan" id="kobo.433.1">acquireCopy</span></code><span class="koboSpan" id="kobo.434.1"> method. </span><span class="koboSpan" id="kobo.434.2">Here, the programmer's intent could be to reduce the pressure on the garbage collector by allocating fewer </span><code class="literal"><span class="koboSpan" id="kobo.435.1">Copying</span></code><span class="koboSpan" id="kobo.436.1"> objects. </span><span class="koboSpan" id="kobo.436.2">However, this leads to the ABA problem, as we will describe further.</span></p><p><span class="koboSpan" id="kobo.437.1">We consider two threads </span><span class="strong"><strong><span class="koboSpan" id="kobo.438.1">T1</span></strong></span><span class="koboSpan" id="kobo.439.1"> and </span><span class="strong"><strong><span class="koboSpan" id="kobo.440.1">T2</span></strong></span><span class="koboSpan" id="kobo.441.1">, which call the </span><code class="literal"><span class="koboSpan" id="kobo.442.1">releaseCopy</span></code><span class="koboSpan" id="kobo.443.1"> method. </span><span class="koboSpan" id="kobo.443.2">They both read the state of the </span><code class="literal"><span class="koboSpan" id="kobo.444.1">Entry</span></code><span class="koboSpan" id="kobo.445.1"> object and create a new state object </span><code class="literal"><span class="koboSpan" id="kobo.446.1">nstate</span></code><span class="koboSpan" id="kobo.447.1">, which is </span><code class="literal"><span class="koboSpan" id="kobo.448.1">Idle</span></code><span class="koboSpan" id="kobo.449.1">. </span><span class="koboSpan" id="kobo.449.2">Let's assume that the thread </span><span class="strong"><strong><span class="koboSpan" id="kobo.450.1">T1</span></strong></span><span class="koboSpan" id="kobo.451.1"> executes the </span><code class="literal"><span class="koboSpan" id="kobo.452.1">compareAndSet</span></code><span class="koboSpan" id="kobo.453.1"> operation first and returns the old </span><code class="literal"><span class="koboSpan" id="kobo.454.1">Copying</span></code><span class="koboSpan" id="kobo.455.1"> object </span><code class="literal"><span class="koboSpan" id="kobo.456.1">c</span></code><span class="koboSpan" id="kobo.457.1"> from the </span><code class="literal"><span class="koboSpan" id="kobo.458.1">releaseCopy</span></code><span class="koboSpan" id="kobo.459.1"> method. </span><span class="koboSpan" id="kobo.459.2">Next, let's assume that a third thread </span><span class="strong"><strong><span class="koboSpan" id="kobo.460.1">T3</span></strong></span><span class="koboSpan" id="kobo.461.1"> calls the </span><code class="literal"><span class="koboSpan" id="kobo.462.1">acquireCopy</span></code><span class="koboSpan" id="kobo.463.1"> method and changes the state of the </span><code class="literal"><span class="koboSpan" id="kobo.464.1">Entry</span></code><span class="koboSpan" id="kobo.465.1"> object to </span><code class="literal"><span class="koboSpan" id="kobo.466.1">Copying(1)</span></code><span class="koboSpan" id="kobo.467.1">. </span><span class="koboSpan" id="kobo.467.2">If the thread </span><span class="strong"><strong><span class="koboSpan" id="kobo.468.1">T1</span></strong></span><span class="koboSpan" id="kobo.469.1"> now calls the </span><code class="literal"><span class="koboSpan" id="kobo.470.1">acquireCopy</span></code><span class="koboSpan" id="kobo.471.1"> method with the old </span><code class="literal"><span class="koboSpan" id="kobo.472.1">Copying</span></code><span class="koboSpan" id="kobo.473.1"> object </span><code class="literal"><span class="koboSpan" id="kobo.474.1">c</span></code><span class="koboSpan" id="kobo.475.1">, the state of the </span><code class="literal"><span class="koboSpan" id="kobo.476.1">Entry</span></code><span class="koboSpan" id="kobo.477.1"> object becomes </span><code class="literal"><span class="koboSpan" id="kobo.478.1">Copying(2)</span></code><span class="koboSpan" id="kobo.479.1">. </span><span class="koboSpan" id="kobo.479.2">Note that, at this point, the old </span><code class="literal"><span class="koboSpan" id="kobo.480.1">Copying</span></code><span class="koboSpan" id="kobo.481.1"> object </span><code class="literal"><span class="koboSpan" id="kobo.482.1">c</span></code><span class="koboSpan" id="kobo.483.1"> is once again stored inside the atomic variable </span><code class="literal"><span class="koboSpan" id="kobo.484.1">state</span></code><span class="koboSpan" id="kobo.485.1">. </span><span class="koboSpan" id="kobo.485.2">If the thread </span><span class="strong"><strong><span class="koboSpan" id="kobo.486.1">T1</span></strong></span><span class="koboSpan" id="kobo.487.1"> now attempts to call </span><code class="literal"><span class="koboSpan" id="kobo.488.1">compareAndSet</span></code><span class="koboSpan" id="kobo.489.1">, it will succeed and set the state of the </span><code class="literal"><span class="koboSpan" id="kobo.490.1">Entry</span></code><span class="koboSpan" id="kobo.491.1"> object to </span><code class="literal"><span class="koboSpan" id="kobo.492.1">Idle</span></code><span class="koboSpan" id="kobo.493.1">. </span><span class="koboSpan" id="kobo.493.2">Effectively, the last </span><code class="literal"><span class="koboSpan" id="kobo.494.1">compareAndSet</span></code><span class="koboSpan" id="kobo.495.1"> operation changes the state from </span><code class="literal"><span class="koboSpan" id="kobo.496.1">Copying(2)</span></code><span class="koboSpan" id="kobo.497.1"> to </span><code class="literal"><span class="koboSpan" id="kobo.498.1">Idle</span></code><span class="koboSpan" id="kobo.499.1">, so one acquire is lost.</span></p><p><span class="koboSpan" id="kobo.500.1">This scenario is shown in the following figure:</span></p><div class="mediaobject"><span class="koboSpan" id="kobo.501.1"><img src="graphics/image_03_003.jpg" alt="The ABA problem"/></span></div><p><span class="koboSpan" id="kobo.502.1">In the preceding example, the ABA problem manifests itself in the execution of thread </span><span class="strong"><strong><span class="koboSpan" id="kobo.503.1">T2</span></strong></span><span class="koboSpan" id="kobo.504.1">. </span><span class="koboSpan" id="kobo.504.2">Having first read the value of the </span><code class="literal"><span class="koboSpan" id="kobo.505.1">state</span></code><span class="koboSpan" id="kobo.506.1"> field in the </span><code class="literal"><span class="koboSpan" id="kobo.507.1">Entry</span></code><span class="koboSpan" id="kobo.508.1"> object with the </span><code class="literal"><span class="koboSpan" id="kobo.509.1">get</span></code><span class="koboSpan" id="kobo.510.1"> method and with the </span><code class="literal"><span class="koboSpan" id="kobo.511.1">compareAndSet</span></code><span class="koboSpan" id="kobo.512.1"> method later, thread </span><span class="strong"><strong><span class="koboSpan" id="kobo.513.1">T2</span></strong></span><span class="koboSpan" id="kobo.514.1"> assumes that the value of the </span><code class="literal"><span class="koboSpan" id="kobo.515.1">state</span></code><span class="koboSpan" id="kobo.516.1"> field has not changed between these two writes. </span><span class="koboSpan" id="kobo.516.2">In this case, this leads to a program error.</span></p><p><span class="koboSpan" id="kobo.517.1">There is no general technique to avoid the ABA problem, so we need to guard the program against it on a per-problem basis. </span><span class="koboSpan" id="kobo.517.2">Still, the following guidelines are useful when avoiding the ABA problem in a managed runtime, such as JVM:</span></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.518.1">Create new objects before assigning them to the </span><code class="literal"><span class="koboSpan" id="kobo.519.1">AtomicReference</span></code><span class="koboSpan" id="kobo.520.1"> objects</span></li><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.521.1">Store immutable objects inside the </span><code class="literal"><span class="koboSpan" id="kobo.522.1">AtomicReference</span></code><span class="koboSpan" id="kobo.523.1"> objects</span></li><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.524.1">Avoid assigning a value that was previously already assigned to an atomic variable</span></li><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.525.1">If possible, make updates to numeric atomic variables monotonic, that is, either strictly decreasing or strictly increasing with respect to the previous value</span></li></ul></div><p><span class="koboSpan" id="kobo.526.1">There are other techniques in order to avoid the ABA problem, such as pointer masking and hazard pointers, but these are not applicable to JVM.</span></p><p><span class="koboSpan" id="kobo.527.1">In some cases, the ABA problem does not affect the correctness of the algorithm; for example, if we change the </span><code class="literal"><span class="koboSpan" id="kobo.528.1">Idle</span></code><span class="koboSpan" id="kobo.529.1"> class to a singleton object, the </span><code class="literal"><span class="koboSpan" id="kobo.530.1">prepareForDelete</span></code><span class="koboSpan" id="kobo.531.1"> method will continue to work correctly. </span><span class="koboSpan" id="kobo.531.2">Still, it is a good practice to follow the preceding guidelines, because they simplify the reasoning about lock-free algorithms.</span></p></div></div></div></div>
<div id="book-columns"><div id="book-inner"><div class="section" title="Lazy values"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec21"/><span class="koboSpan" id="kobo.1.1">Lazy values</span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">You should be familiar with lazy values from sequential programming in Scala. </span><span class="koboSpan" id="kobo.2.2">Lazy values are the value declarations that are initialized with their right-hand side expression when the lazy value is read for the first time. </span><span class="koboSpan" id="kobo.2.3">This is unlike regular values, which are initialized the moment they are created. </span><span class="koboSpan" id="kobo.2.4">If a lazy value is never read inside the program, it is never initialized and it is not necessary to pay the cost of its initialization. </span><span class="koboSpan" id="kobo.2.5">Lazy values allow you to implement data structures such as lazy streams; they improve complexities of persistent data structures, can boost the program's performance, and help avoid initialization order problems in Scala's mix-in composition.</span></p><p><span class="koboSpan" id="kobo.3.1">Lazy values are extremely useful in practice, and you will often deal with them in Scala. </span><span class="koboSpan" id="kobo.3.2">However, using them in concurrent programs can have some unexpected interactions, and this is the topic of this section. </span><span class="koboSpan" id="kobo.3.3">Note that lazy values must retain the same semantics in a multithreaded program; a lazy value is initialized only when a thread accesses it, and it is initialized at most once. </span><span class="koboSpan" id="kobo.3.4">Consider the following motivating example in which two threads access two lazy values, which are </span><code class="literal"><span class="koboSpan" id="kobo.4.1">obj</span></code><span class="koboSpan" id="kobo.5.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.6.1">non</span></code><span class="koboSpan" id="kobo.7.1">:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.8.1">object LazyValsCreate extends App { 
  lazy val obj = new AnyRef 
  lazy val non = s"made by ${Thread.currentThread.getName}" 
  execute { 
    log(s"EC sees obj = $obj") 
    log(s"EC sees non = $non") 
  } 
  log(s"Main sees obj = $obj") 
  log(s"Main sees non = $non") 
  Thread.sleep(500) 
} 
</span></pre><p><span class="koboSpan" id="kobo.9.1">You know from sequential Scala programming that it is a good practice to initialize the lazy value with an expression that does not depend on the current state of the program. </span><span class="koboSpan" id="kobo.9.2">The lazy value </span><code class="literal"><span class="koboSpan" id="kobo.10.1">obj</span></code><span class="koboSpan" id="kobo.11.1"> follows this practice, but the lazy value </span><code class="literal"><span class="koboSpan" id="kobo.12.1">non</span></code><span class="koboSpan" id="kobo.13.1"> does not. </span><span class="koboSpan" id="kobo.13.2">If you run this program once, you might notice that </span><code class="literal"><span class="koboSpan" id="kobo.14.1">non</span></code><span class="koboSpan" id="kobo.15.1"> lazy value is initialized with the name of the main thread:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.16.1">[info] main: Main sees non = made by main 
[info] FJPool-1-worker-13: EC sees non = made by main 
</span></pre><p><span class="koboSpan" id="kobo.17.1">Running the program again shows you that </span><code class="literal"><span class="koboSpan" id="kobo.18.1">non</span></code><span class="koboSpan" id="kobo.19.1"> is initialized by the worker thread:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.20.1">[info] main: Main sees non = made by FJPool-1-worker-13 
[info] FJPool-1-worker-13: EC sees non = made by FJPool-1-worker-13 
</span></pre><p><span class="koboSpan" id="kobo.21.1">As the previous example shows you, lazy values are affected by non-determinism. </span><span class="koboSpan" id="kobo.21.2">Non-deterministic lazy values are a recipe for trouble, but we cannot always avoid them. </span><span class="koboSpan" id="kobo.21.3">Lazy values are deeply tied into Scala, because singleton objects are implemented as lazy values under the hood:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.22.1">object LazyValsObject extends App { 
  object Lazy { log("Running Lazy constructor.") } 
  log("Main thread is about to reference Lazy.") 
  Lazy 
  log("Main thread completed.") 
} 
</span></pre><p><span class="koboSpan" id="kobo.23.1">Running this program reveals that the </span><code class="literal"><span class="koboSpan" id="kobo.24.1">Lazy</span></code><span class="koboSpan" id="kobo.25.1"> initializer runs when the object is first referenced in the third line and not when it is declared. </span><span class="koboSpan" id="kobo.25.2">Getting rid of singleton objects in your Scala code would be too restrictive, and singleton objects are often large; they can contain all kinds of potentially non-deterministic code.</span></p><p><span class="koboSpan" id="kobo.26.1">You might think that a little bit of non-determinism is something we can live with. </span><span class="koboSpan" id="kobo.26.2">However, this non-determinism can be dangerous. </span><span class="koboSpan" id="kobo.26.3">In the existing Scala versions, lazy values and singleton objects are implemented with the so-called </span><span class="emphasis"><em><span class="koboSpan" id="kobo.27.1">double-checked locking idiom</span></em></span><span class="koboSpan" id="kobo.28.1"> under the hood. </span><span class="koboSpan" id="kobo.28.2">This concurrent programming pattern ensures that a lazy value is initialized by at most one thread when it is first accessed. </span><span class="koboSpan" id="kobo.28.3">Thanks to this pattern, upon initializing the lazy value, its subsequent reads are cheap and do not need to acquire any locks. </span><span class="koboSpan" id="kobo.28.4">Using this idiom, a single lazy value declaration, which is </span><code class="literal"><span class="koboSpan" id="kobo.29.1">obj</span></code><span class="koboSpan" id="kobo.30.1"> from the previous example, is translated by the Scala compiler as follows:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.31.1">object LazyValsUnderTheHood extends App { 
  @volatile private var _bitmap = false 
  private var _obj: AnyRef = _ 
  def obj = if (_bitmap) _obj else this.synchronized { 
    if (!_bitmap) { 
      _obj = new AnyRef 
      _bitmap = true 
    } 
    _obj 
  } 
  log(s"$obj") 
  log(s"$obj") 
} 
</span></pre><p><span class="koboSpan" id="kobo.32.1">The Scala compiler introduces an additional volatile field, </span><code class="literal"><span class="koboSpan" id="kobo.33.1">_bitmap</span></code><span class="koboSpan" id="kobo.34.1">, when a class contains lazy fields. </span><span class="koboSpan" id="kobo.34.2">The private </span><code class="literal"><span class="koboSpan" id="kobo.35.1">_obj</span></code><span class="koboSpan" id="kobo.36.1"> field that holds the value is uninitialized at first. </span><span class="koboSpan" id="kobo.36.2">After the </span><code class="literal"><span class="koboSpan" id="kobo.37.1">obj</span></code><span class="koboSpan" id="kobo.38.1"> getter assigns a value to the </span><code class="literal"><span class="koboSpan" id="kobo.39.1">_obj</span></code><span class="koboSpan" id="kobo.40.1"> field, it sets the </span><code class="literal"><span class="koboSpan" id="kobo.41.1">_bitmap</span></code><span class="koboSpan" id="kobo.42.1"> field to </span><code class="literal"><span class="koboSpan" id="kobo.43.1">true</span></code><span class="koboSpan" id="kobo.44.1"> to indicate that the lazy value was initialized. </span><span class="koboSpan" id="kobo.44.2">Other subsequent invocations of the getter know whether they can read the lazy value from the </span><code class="literal"><span class="koboSpan" id="kobo.45.1">_obj</span></code><span class="koboSpan" id="kobo.46.1"> field by checking the </span><code class="literal"><span class="koboSpan" id="kobo.47.1">_bitmap</span></code><span class="koboSpan" id="kobo.48.1"> field.</span></p><p><span class="koboSpan" id="kobo.49.1">The getter </span><code class="literal"><span class="koboSpan" id="kobo.50.1">obj</span></code><span class="koboSpan" id="kobo.51.1"> starts by checking whether the </span><code class="literal"><span class="koboSpan" id="kobo.52.1">_bitmap</span></code><span class="koboSpan" id="kobo.53.1"> field is </span><code class="literal"><span class="koboSpan" id="kobo.54.1">true</span></code><span class="koboSpan" id="kobo.55.1">. </span><span class="koboSpan" id="kobo.55.2">If </span><code class="literal"><span class="koboSpan" id="kobo.56.1">_bitmap</span></code><span class="koboSpan" id="kobo.57.1"> field is </span><code class="literal"><span class="koboSpan" id="kobo.58.1">true</span></code><span class="koboSpan" id="kobo.59.1">, then the lazy value was already initialized and the getter returns </span><code class="literal"><span class="koboSpan" id="kobo.60.1">_obj</span></code><span class="koboSpan" id="kobo.61.1">. </span><span class="koboSpan" id="kobo.61.2">Otherwise, the getter </span><code class="literal"><span class="koboSpan" id="kobo.62.1">obj</span></code><span class="koboSpan" id="kobo.63.1"> attempts to obtain the intrinsic lock of the enclosing object, in this case, </span><code class="literal"><span class="koboSpan" id="kobo.64.1">LazyValsUnderTheHood</span></code><span class="koboSpan" id="kobo.65.1">. </span><span class="koboSpan" id="kobo.65.2">If the </span><code class="literal"><span class="koboSpan" id="kobo.66.1">_bitmap</span></code><span class="koboSpan" id="kobo.67.1"> field is still not set from within the </span><code class="literal"><span class="koboSpan" id="kobo.68.1">synchronized</span></code><span class="koboSpan" id="kobo.69.1"> block, the getter evaluates the </span><code class="literal"><span class="koboSpan" id="kobo.70.1">new AnyRef</span></code><span class="koboSpan" id="kobo.71.1"> expression, assigns it to </span><code class="literal"><span class="koboSpan" id="kobo.72.1">_obj</span></code><span class="koboSpan" id="kobo.73.1">, and sets </span><code class="literal"><span class="koboSpan" id="kobo.74.1">_bitmap</span></code><span class="koboSpan" id="kobo.75.1"> to </span><code class="literal"><span class="koboSpan" id="kobo.76.1">true</span></code><span class="koboSpan" id="kobo.77.1">. </span><span class="koboSpan" id="kobo.77.2">After this point, the lazy value is considered initialized. </span><span class="koboSpan" id="kobo.77.3">Note that the </span><code class="literal"><span class="koboSpan" id="kobo.78.1">synchronized</span></code><span class="koboSpan" id="kobo.79.1"> statement, together with the check that the </span><code class="literal"><span class="koboSpan" id="kobo.80.1">_bitmap</span></code><span class="koboSpan" id="kobo.81.1"> field is </span><code class="literal"><span class="koboSpan" id="kobo.82.1">false</span></code><span class="koboSpan" id="kobo.83.1">, ensure that a single thread at most initializes the lazy value.</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note24"/><span class="koboSpan" id="kobo.84.1">Note</span></h3><p><span class="koboSpan" id="kobo.85.1">The double-checked locking idiom ensures that every lazy value is initialized by at most a single thread.</span></p></div></div><p><span class="koboSpan" id="kobo.86.1">This mechanism is robust and ensures that lazy values are both thread-safe and efficient. </span><span class="koboSpan" id="kobo.86.2">However, synchronization on the enclosing object can cause problems. </span><span class="koboSpan" id="kobo.86.3">Consider the following example in which two threads attempt to initialize lazy values </span><code class="literal"><span class="koboSpan" id="kobo.87.1">A.x</span></code><span class="koboSpan" id="kobo.88.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.89.1">B.y</span></code><span class="koboSpan" id="kobo.90.1"> at the same time:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.91.1">object LazyValsDeadlock extends App { 
  object A { lazy val x: Int = B.y } 
  object B { lazy val y: Int = A.x } 
  execute { B.y } 
  A.x 
} 
</span></pre><p><span class="koboSpan" id="kobo.92.1">In a sequential setting, accessing either </span><code class="literal"><span class="koboSpan" id="kobo.93.1">A.x</span></code><span class="koboSpan" id="kobo.94.1"> or </span><code class="literal"><span class="koboSpan" id="kobo.95.1">B.y</span></code><span class="koboSpan" id="kobo.96.1"> results in a stack overflow. </span><span class="koboSpan" id="kobo.96.2">Initializing </span><code class="literal"><span class="koboSpan" id="kobo.97.1">A.x</span></code><span class="koboSpan" id="kobo.98.1"> requires calling the getter for </span><code class="literal"><span class="koboSpan" id="kobo.99.1">B.y</span></code><span class="koboSpan" id="kobo.100.1">, which is not initialized. </span><span class="koboSpan" id="kobo.100.2">Initialization of </span><code class="literal"><span class="koboSpan" id="kobo.101.1">B.y</span></code><span class="koboSpan" id="kobo.102.1"> calls the getter for </span><code class="literal"><span class="koboSpan" id="kobo.103.1">A.x</span></code><span class="koboSpan" id="kobo.104.1"> and continues in infinite recursion. </span><span class="koboSpan" id="kobo.104.2">However, this example was carefully tuned to access both </span><code class="literal"><span class="koboSpan" id="kobo.105.1">A.x</span></code><span class="koboSpan" id="kobo.106.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.107.1">B.y</span></code><span class="koboSpan" id="kobo.108.1"> at the same time by both the main thread and the worker thread. </span><span class="koboSpan" id="kobo.108.2">Prepare to restart SBT. </span><span class="koboSpan" id="kobo.108.3">After both </span><code class="literal"><span class="koboSpan" id="kobo.109.1">A</span></code><span class="koboSpan" id="kobo.110.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.111.1">B</span></code><span class="koboSpan" id="kobo.112.1"> are initialized, their monitors are acquired simultaneously by two different threads. </span><span class="koboSpan" id="kobo.112.2">Each of these threads needs to acquire a monitor owned by the other thread. </span><span class="koboSpan" id="kobo.112.3">Neither thread lets go of its own monitor, and this results in a deadlock.</span></p><p><span class="koboSpan" id="kobo.113.1">Cyclic dependencies between lazy values are unsupported in both sequential and concurrent Scala programs. </span><span class="koboSpan" id="kobo.113.2">The difference is that they potentially manifest themselves as deadlocks instead of stack overflows in concurrent programming.</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip25"/><span class="koboSpan" id="kobo.114.1">Tip</span></h3><p><span class="koboSpan" id="kobo.115.1">Avoid cyclic dependencies between lazy values, as they can cause deadlocks.</span></p></div></div><p><span class="koboSpan" id="kobo.116.1">The previous example is not something you are likely to do in your code, but cyclic dependencies between lazy values and singleton objects can be much more devious and harder to spot. </span><span class="koboSpan" id="kobo.116.2">In fact, there are other ways to create dependencies between lazy values besides directly accessing them. </span><span class="koboSpan" id="kobo.116.3">A lazy value initialization expression can block a thread until some other value becomes available. </span><span class="koboSpan" id="kobo.116.4">In the following example, the initialization expression uses the </span><code class="literal"><span class="koboSpan" id="kobo.117.1">thread</span></code><span class="koboSpan" id="kobo.118.1"> statement from </span><a class="link" href="ch02.html" title="Chapter 2. Concurrency on the JVM and the Java Memory Model"><span class="koboSpan" id="kobo.119.1">Chapter 2</span></a><span class="koboSpan" id="kobo.120.1">, </span><span class="emphasis"><em><span class="koboSpan" id="kobo.121.1">Concurrency on the JVM and the Java Memory Model</span></em></span><span class="koboSpan" id="kobo.122.1">, to start a new thread and join it:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.123.1">object LazyValsAndBlocking extends App { 
  lazy val x: Int = { 
    val t = ch2.thread { println(s"Initializing $x.") } 
    t.join() 
    1 
  } 
  x 
} 
</span></pre><p><span class="koboSpan" id="kobo.124.1">Although there is only a single lazy value in this example, running it inevitably results in a deadlock. </span><span class="koboSpan" id="kobo.124.2">The new thread attempts to access </span><code class="literal"><span class="koboSpan" id="kobo.125.1">x</span></code><span class="koboSpan" id="kobo.126.1">, which is not initialized, so it attempts to call the </span><code class="literal"><span class="koboSpan" id="kobo.127.1">synchronized</span></code><span class="koboSpan" id="kobo.128.1"> statement on the </span><code class="literal"><span class="koboSpan" id="kobo.129.1">LazyValsAndBlocking</span></code><span class="koboSpan" id="kobo.130.1"> object and blocks, because the main thread already holds this lock. </span><span class="koboSpan" id="kobo.130.2">On the other hand, the main thread waits for the other thread to terminate, so neither thread can progress.</span></p><p><span class="koboSpan" id="kobo.131.1">While the deadlock is relatively obvious in this example, in a larger code base, circular dependencies can easily sneak past your guard. </span><span class="koboSpan" id="kobo.131.2">In some cases, they might even be non-deterministic and occur only in particular system states. </span><span class="koboSpan" id="kobo.131.3">To guard against them, avoid blocking in the lazy value expression altogether.</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip26"/><span class="koboSpan" id="kobo.132.1">Tip</span></h3><p><span class="koboSpan" id="kobo.133.1">Never invoke blocking operations inside lazy value initialization expressions or singleton object constructors.</span></p></div></div><p><span class="koboSpan" id="kobo.134.1">Lazy values cause deadlocks even when they do not block themselves. </span><span class="koboSpan" id="kobo.134.2">In the following example, the main thread calls the </span><code class="literal"><span class="koboSpan" id="kobo.135.1">synchronized</span></code><span class="koboSpan" id="kobo.136.1"> statement on the enclosing object, starts a new thread, and waits for its termination. </span><span class="koboSpan" id="kobo.136.2">The new thread attempts to initialize the lazy value </span><code class="literal"><span class="koboSpan" id="kobo.137.1">x</span></code><span class="koboSpan" id="kobo.138.1">, but it cannot acquire the monitor until the main thread releases it:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.139.1">object LazyValsAndMonitors extends App { 
  lazy val x = 1 
  this.synchronized { 
    val t = ch2.thread { x } 
    t.join() 
  } 
} 
</span></pre><p><span class="koboSpan" id="kobo.140.1">This kind of deadlock is not inherent to lazy values and can happen with arbitrary code that uses </span><code class="literal"><span class="koboSpan" id="kobo.141.1">synchronized</span></code><span class="koboSpan" id="kobo.142.1"> statements. </span><span class="koboSpan" id="kobo.142.2">The problem is that the </span><code class="literal"><span class="koboSpan" id="kobo.143.1">LazyValsAndMonitors</span></code><span class="koboSpan" id="kobo.144.1"> lock is used in two different contexts: as a lazy value initialization lock and as the lock for some custom logic in the main thread. </span><span class="koboSpan" id="kobo.144.2">To prevent two unrelated software components from using the same lock, always call </span><code class="literal"><span class="koboSpan" id="kobo.145.1">synchronized</span></code><span class="koboSpan" id="kobo.146.1"> on separate private objects that exist solely for this purpose.</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip27"/><span class="koboSpan" id="kobo.147.1">Tip</span></h3><p><span class="koboSpan" id="kobo.148.1">Never call </span><code class="literal"><span class="koboSpan" id="kobo.149.1">synchronized</span></code><span class="koboSpan" id="kobo.150.1"> on publicly available objects; always use a dedicated, private dummy object for synchronization.</span></p></div></div><p><span class="koboSpan" id="kobo.151.1">Although we rarely use separate objects for synchronization in this book, to keep the examples concise, you should strongly consider doing this in your programs. </span><span class="koboSpan" id="kobo.151.2">This tip is useful outside the context of lazy values; keeping your locks private reduces the possibility of deadlocks.</span></p></div></div></div>
<div id="book-columns"><div id="book-inner"><div class="section" title="Concurrent collections"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec22"/><span class="koboSpan" id="kobo.1.1">Concurrent collections</span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">As you can conclude from the discussion on the Java Memory Model in </span><a class="link" href="ch02.html" title="Chapter 2. Concurrency on the JVM and the Java Memory Model"><span class="koboSpan" id="kobo.3.1">Chapter 2</span></a><span class="koboSpan" id="kobo.4.1">, </span><span class="emphasis"><em><span class="koboSpan" id="kobo.5.1">Concurrency on the JVM and the Java Memory Model</span></em></span><span class="koboSpan" id="kobo.6.1">, modifying the Scala standard library collections from different threads can result in arbitrary data corruption. </span><span class="koboSpan" id="kobo.6.2">Standard collection implementations do not use any synchronization. </span><span class="koboSpan" id="kobo.6.3">Data structures underlying mutable collections can be quite complex; predicting how multiple threads affect the collection state in the absence of synchronization is neither recommended nor possible. </span><span class="koboSpan" id="kobo.6.4">We will demonstrate this by letting two threads add numbers to the </span><code class="literal"><span class="koboSpan" id="kobo.7.1">mutable.ArrayBuffer</span></code><span class="koboSpan" id="kobo.8.1"> collection:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.9.1">import scala.collection._ 
object CollectionsBad extends App { 
  val buffer = mutable.ArrayBuffer[Int]() 
  def asyncAdd(numbers: Seq[Int]) = execute { 
    buffer ++= numbers 
    log(s"buffer = $buffer") 
  } 
  asyncAdd(0 until 10) 
  asyncAdd(10 until 20) 
  Thread.sleep(500) 
} 
</span></pre><p><span class="koboSpan" id="kobo.10.1">Instead of printing an array buffer with 20 different elements, this example arbitrarily prints different results or throws exceptions each time it runs. </span><span class="koboSpan" id="kobo.10.2">The two threads modify the internal array buffer state simultaneously and cause data corruption.</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip28"/><span class="koboSpan" id="kobo.11.1">Tip</span></h3><p><span class="koboSpan" id="kobo.12.1">Never use mutable collections from several different threads without applying proper synchronization.</span></p></div></div><p><span class="koboSpan" id="kobo.13.1">We can restore synchronization in several ways. </span><span class="koboSpan" id="kobo.13.2">First, we can use </span><span class="strong"><strong><span class="koboSpan" id="kobo.14.1">immutable collections</span></strong></span><span class="koboSpan" id="kobo.15.1"> along with synchronization to share them between threads. </span><span class="koboSpan" id="kobo.15.2">For example, we can store immutable data structures inside atomic reference variables. </span><span class="koboSpan" id="kobo.15.3">In the following code snippet, we introduce an </span><code class="literal"><span class="koboSpan" id="kobo.16.1">AtomicBuffer</span></code><span class="koboSpan" id="kobo.17.1"> class that allows concurrent </span><code class="literal"><span class="koboSpan" id="kobo.18.1">+=</span></code><span class="koboSpan" id="kobo.19.1"> operations. </span><span class="koboSpan" id="kobo.19.2">Appending reads the current immutable </span><code class="literal"><span class="koboSpan" id="kobo.20.1">List</span></code><span class="koboSpan" id="kobo.21.1"> value from the atomic reference buffer and creates a new </span><code class="literal"><span class="koboSpan" id="kobo.22.1">List</span></code><span class="koboSpan" id="kobo.23.1"> object containing </span><code class="literal"><span class="koboSpan" id="kobo.24.1">x</span></code><span class="koboSpan" id="kobo.25.1">. </span><span class="koboSpan" id="kobo.25.2">It then invokes a CAS operation to atomically update the buffer, retrying the operation if the CAS operation is not successful:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.26.1">class AtomicBuffer[T] { 
  private val buffer = new AtomicReference[List[T]](Nil) 
  @tailrec def +=(x: T): Unit = { 
    val xs = buffer.get 
    val nxs = x :: xs 
    if (!buffer.compareAndSet(xs, nxs)) this += x 
  } 
} 
</span></pre><p><span class="koboSpan" id="kobo.27.1">While using atomic variables or the </span><code class="literal"><span class="koboSpan" id="kobo.28.1">synchronized</span></code><span class="koboSpan" id="kobo.29.1"> statements with immutable collections is simple, it can lead to scalability problems when many threads access an atomic variable at once.</span></p><p><span class="koboSpan" id="kobo.30.1">If we intend to continue using mutable collections, we need to add </span><code class="literal"><span class="koboSpan" id="kobo.31.1">synchronized</span></code><span class="koboSpan" id="kobo.32.1"> statements around calls to collection operations:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.33.1">def asyncAdd(numbers: Seq[Int]) = execute { 
  buffer.synchronized { 
    buffer ++= numbers 
    log(s"buffer = $buffer") 
  } 
} 
</span></pre><p><span class="koboSpan" id="kobo.34.1">This approach can be satisfactory, provided that collection operations do not block inside </span><code class="literal"><span class="koboSpan" id="kobo.35.1">synchronized</span></code><span class="koboSpan" id="kobo.36.1">. </span><span class="koboSpan" id="kobo.36.2">In fact, this approach allows you to implement guarded blocks around collection operations, as we saw in the </span><code class="literal"><span class="koboSpan" id="kobo.37.1">SynchronizedPool</span></code><span class="koboSpan" id="kobo.38.1"> example in </span><a class="link" href="ch02.html" title="Chapter 2. Concurrency on the JVM and the Java Memory Model"><span class="koboSpan" id="kobo.39.1">Chapter 2</span></a><span class="koboSpan" id="kobo.40.1">, </span><span class="emphasis"><em><span class="koboSpan" id="kobo.41.1">Concurrency on the JVM and the Java Memory Model</span></em></span><span class="koboSpan" id="kobo.42.1">. </span><span class="koboSpan" id="kobo.42.2">However, using the </span><code class="literal"><span class="koboSpan" id="kobo.43.1">synchronized</span></code><span class="koboSpan" id="kobo.44.1"> statement can also lead to scalability problems when many threads attempt to acquire the lock at once.</span></p><p><span class="koboSpan" id="kobo.45.1">Finally, concurrent collections are collection implementations with operations that can be safely invoked from different threads without synchronization. </span><span class="koboSpan" id="kobo.45.2">In addition to the thread-safe versions of basic collection operations, some concurrent collections provide more expressive operations. </span><span class="koboSpan" id="kobo.45.3">Conceptually, the same operations can be achieved using atomic primitives, </span><code class="literal"><span class="koboSpan" id="kobo.46.1">synchronized</span></code><span class="koboSpan" id="kobo.47.1"> statements, and guarded blocks, but concurrent collections ensure far better performance and scalability.</span></p><div class="section" title="Concurrent queues"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec26"/><span class="koboSpan" id="kobo.48.1">Concurrent queues</span></h2></div></div></div><p><span class="koboSpan" id="kobo.49.1">A common pattern used in concurrent programming is the </span><span class="strong"><strong><span class="koboSpan" id="kobo.50.1">producer-consumer pattern</span></strong></span><span class="koboSpan" id="kobo.51.1">. </span><span class="koboSpan" id="kobo.51.2">In this pattern, the responsibility for different parts of the computational workload is divided across several threads. </span><span class="koboSpan" id="kobo.51.3">In an FTP server, one or more threads can be responsible for reading chunks of a large file from the disk. </span><span class="koboSpan" id="kobo.51.4">Such threads are called producers. </span><span class="koboSpan" id="kobo.51.5">Another dedicated set of threads can bear the responsibility of sending file chunks through the network. </span><span class="koboSpan" id="kobo.51.6">We call these threads consumers. </span><span class="koboSpan" id="kobo.51.7">In their relationship, consumers must react to work elements created by the producers. </span><span class="koboSpan" id="kobo.51.8">Often, the two are not perfectly synchronized, so work elements need to be buffered somewhere.</span></p><p><span class="koboSpan" id="kobo.52.1">The concurrent collection that supports this kind of buffering is called a </span><span class="strong"><strong><span class="koboSpan" id="kobo.53.1">concurrent queue</span></strong></span><span class="koboSpan" id="kobo.54.1">. </span><span class="koboSpan" id="kobo.54.2">There are three main operations we expect from a concurrent queue. </span><span class="koboSpan" id="kobo.54.3">The enqueue operation allows producers to add work elements to the queue, and the dequeue operation allows consumers to remove them. </span><span class="koboSpan" id="kobo.54.4">Finally, sometimes we want to check whether the queue is empty or inspect the value of the next item without changing the queue's contents. </span><span class="koboSpan" id="kobo.54.5">Concurrent queues can be </span><span class="strong"><strong><span class="koboSpan" id="kobo.55.1">bounded</span></strong></span><span class="koboSpan" id="kobo.56.1">, which means that they can only contain a maximum number of elements, or they can be </span><span class="strong"><strong><span class="koboSpan" id="kobo.57.1">unbounded</span></strong></span><span class="koboSpan" id="kobo.58.1">, which means that they can grow indefinitely. </span><span class="koboSpan" id="kobo.58.2">When a bounded queue contains the maximum number of elements, we say it is full. </span><span class="koboSpan" id="kobo.58.3">The semantics of the various versions of enqueue and dequeue operations differ with respect to what happens when we try to enqueue to a full queue or dequeue from an empty queue. </span><span class="koboSpan" id="kobo.58.4">This special case needs to be handled differently by the concurrent queue. </span><span class="koboSpan" id="kobo.58.5">In single-threaded programming, sequential queues usually return a special value such as </span><code class="literal"><span class="koboSpan" id="kobo.59.1">null</span></code><span class="koboSpan" id="kobo.60.1"> or </span><code class="literal"><span class="koboSpan" id="kobo.61.1">false</span></code><span class="koboSpan" id="kobo.62.1"> when they are full or empty, or simply throw an exception. </span><span class="koboSpan" id="kobo.62.2">In concurrent programming, the absence of elements in the queue can indicate that the producer has not yet enqueued an element, although it might enqueue it in the future. </span><span class="koboSpan" id="kobo.62.3">Similarly, a full queue means that the consumer did not yet remove elements but will do so later. </span><span class="koboSpan" id="kobo.62.4">For this reason, some concurrent queues have </span><span class="emphasis"><em><span class="koboSpan" id="kobo.63.1">blocking</span></em></span><span class="koboSpan" id="kobo.64.1"> enqueue and dequeue implementations, which block the caller until the queue is non-full or non-empty, respectively.</span></p><p><span class="koboSpan" id="kobo.65.1">JDK represents multiple efficient concurrent queue implementations in the </span><code class="literal"><span class="koboSpan" id="kobo.66.1">java.util.concurrent</span></code><span class="koboSpan" id="kobo.67.1"> package with the </span><code class="literal"><span class="koboSpan" id="kobo.68.1">BlockingQueue</span></code><span class="koboSpan" id="kobo.69.1"> interface. </span><span class="koboSpan" id="kobo.69.2">Rather than reinventing the wheel with its own concurrent queue implementations, Scala adopts these concurrent queues as part of its concurrency utilities and it does not currently have a dedicated trait for blocking queues.</span></p><p><span class="koboSpan" id="kobo.70.1">The </span><code class="literal"><span class="koboSpan" id="kobo.71.1">BlockingQueue</span></code><span class="koboSpan" id="kobo.72.1"> interface contains several versions of the basic concurrent queue operations, each with slightly different semantics. </span><span class="koboSpan" id="kobo.72.2">Different variants of their enqueue, dequeue, and inspect-next methods are summarized in the following table. </span><span class="koboSpan" id="kobo.72.3">The inspect, dequeue, and enqueue versions are called </span><code class="literal"><span class="koboSpan" id="kobo.73.1">element</span></code><span class="koboSpan" id="kobo.74.1">, </span><code class="literal"><span class="koboSpan" id="kobo.75.1">remove</span></code><span class="koboSpan" id="kobo.76.1">, and </span><code class="literal"><span class="koboSpan" id="kobo.77.1">add</span></code><span class="koboSpan" id="kobo.78.1"> in the first column; they throw an exception when the queue is empty or full. </span><span class="koboSpan" id="kobo.78.2">Methods such as </span><code class="literal"><span class="koboSpan" id="kobo.79.1">poll</span></code><span class="koboSpan" id="kobo.80.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.81.1">offer</span></code><span class="koboSpan" id="kobo.82.1"> return special values such as </span><code class="literal"><span class="koboSpan" id="kobo.83.1">null</span></code><span class="koboSpan" id="kobo.84.1"> or </span><code class="literal"><span class="koboSpan" id="kobo.85.1">false</span></code><span class="koboSpan" id="kobo.86.1">. </span><span class="koboSpan" id="kobo.86.2">Timed versions of these methods block the caller for a specified duration before returning an element or a special value, and blocking methods block the calling thread until the queue becomes non-empty or non-full.</span></p><div class="informaltable"><table border="1"><colgroup><col/><col/><col/><col/><col/></colgroup><tbody><tr><td>
<p><span class="strong"><strong><span class="koboSpan" id="kobo.87.1">Operation</span></strong></span></p>
</td><td>
<p><span class="strong"><strong><span class="koboSpan" id="kobo.88.1">Exception</span></strong></span></p>
</td><td>
<p><span class="strong"><strong><span class="koboSpan" id="kobo.89.1">Special value</span></strong></span></p>
</td><td>
<p><span class="strong"><strong><span class="koboSpan" id="kobo.90.1">Timed</span></strong></span></p>
</td><td>
<p><span class="strong"><strong><span class="koboSpan" id="kobo.91.1">Blocking</span></strong></span></p>
</td></tr><tr><td>
<p><span class="koboSpan" id="kobo.92.1">Dequeue</span></p>
</td><td>
<p><span class="koboSpan" id="kobo.93.1">remove(): T</span></p>
</td><td>
<p><span class="koboSpan" id="kobo.94.1">poll(): T</span></p>
</td><td>
<p><span class="koboSpan" id="kobo.95.1">poll(t: Long, u:</span></p><p>
</p><p><span class="koboSpan" id="kobo.96.1">  TimeUnit): T</span></p>
</td><td>
<p><span class="koboSpan" id="kobo.97.1">take(): T</span></p>
</td></tr><tr><td>
<p><span class="koboSpan" id="kobo.98.1">Enqueue</span></p>
</td><td>
<p><span class="koboSpan" id="kobo.99.1">add(x: T)</span></p>
</td><td>
<p><span class="koboSpan" id="kobo.100.1">offer(x: T):</span></p><p>
</p><p><span class="koboSpan" id="kobo.101.1">  Boolean</span></p>
</td><td>
<p><span class="koboSpan" id="kobo.102.1">offer(x: T, t: Long,</span></p><p>
</p><p><span class="koboSpan" id="kobo.103.1">  u: TimeUnit)</span></p>
</td><td>
<p><span class="koboSpan" id="kobo.104.1">put(x: T)</span></p>
</td></tr><tr><td>
<p><span class="koboSpan" id="kobo.105.1">Inspect</span></p>
</td><td>
<p><span class="koboSpan" id="kobo.106.1">element: T</span></p>
</td><td>
<p><span class="koboSpan" id="kobo.107.1">peek: T</span></p>
</td><td>
<p><span class="koboSpan" id="kobo.108.1">N/A</span></p>
</td><td>
<p><span class="koboSpan" id="kobo.109.1">N/A</span></p>
</td></tr></tbody></table></div><p><span class="koboSpan" id="kobo.110.1">The </span><code class="literal"><span class="koboSpan" id="kobo.111.1">ArrayBlockingQueue</span></code><span class="koboSpan" id="kobo.112.1"> class is a concrete implementation of a bounded blocking queue. </span><span class="koboSpan" id="kobo.112.2">When creating the </span><code class="literal"><span class="koboSpan" id="kobo.113.1">ArrayBlockingQueue</span></code><span class="koboSpan" id="kobo.114.1"> class, we need to specify its capacity, which is the number of elements in the queue when it is full. </span><span class="koboSpan" id="kobo.114.2">If producers can potentially create elements faster than the consumers can process them, we need to use bounded queues. </span><span class="koboSpan" id="kobo.114.3">Otherwise, the queue size can potentially grow to the point where it consumes all the available memory in the program.</span></p><p><span class="koboSpan" id="kobo.115.1">Another concurrent queue implementation is called </span><code class="literal"><span class="koboSpan" id="kobo.116.1">LinkedBlockingQueue</span></code><span class="koboSpan" id="kobo.117.1">. </span><span class="koboSpan" id="kobo.117.2">This queue is unbounded, and we can use it when we are sure that the consumers work much faster than the producers. </span><span class="koboSpan" id="kobo.117.3">This queue is an ideal candidate for the logging component of our filesystem's API. </span><span class="koboSpan" id="kobo.117.4">Logging must return feedback about the execution to the user. </span><span class="koboSpan" id="kobo.117.5">In a file manager, logging produces messages to the user inside the UI, while in an FTP server it sends feedback over the network. </span><span class="koboSpan" id="kobo.117.6">To keep the example simple, we just print the messages to the standard output.</span></p><p><span class="koboSpan" id="kobo.118.1">We use the </span><code class="literal"><span class="koboSpan" id="kobo.119.1">LinkedBlockingQueue</span></code><span class="koboSpan" id="kobo.120.1"> collection to buffer various messages from different components of the filesystem API. </span><span class="koboSpan" id="kobo.120.2">We declare the queue to a private variable called </span><code class="literal"><span class="koboSpan" id="kobo.121.1">messages</span></code><span class="koboSpan" id="kobo.122.1">. </span><span class="koboSpan" id="kobo.122.2">A separate daemon thread, called </span><code class="literal"><span class="koboSpan" id="kobo.123.1">logger</span></code><span class="koboSpan" id="kobo.124.1">, repetitively calls the </span><code class="literal"><span class="koboSpan" id="kobo.125.1">take</span></code><span class="koboSpan" id="kobo.126.1"> method on messages. </span><span class="koboSpan" id="kobo.126.2">Recall from the previous table that the </span><code class="literal"><span class="koboSpan" id="kobo.127.1">take</span></code><span class="koboSpan" id="kobo.128.1"> method is blocking; it blocks the </span><code class="literal"><span class="koboSpan" id="kobo.129.1">logger</span></code><span class="koboSpan" id="kobo.130.1"> thread until there is a message in the queue. </span><span class="koboSpan" id="kobo.130.2">The </span><code class="literal"><span class="koboSpan" id="kobo.131.1">logger</span></code><span class="koboSpan" id="kobo.132.1"> thread then calls </span><code class="literal"><span class="koboSpan" id="kobo.133.1">log</span></code><span class="koboSpan" id="kobo.134.1"> to print the message. </span><span class="koboSpan" id="kobo.134.2">The </span><code class="literal"><span class="koboSpan" id="kobo.135.1">logMessage</span></code><span class="koboSpan" id="kobo.136.1"> method, which we used in the </span><code class="literal"><span class="koboSpan" id="kobo.137.1">prepareForDelete</span></code><span class="koboSpan" id="kobo.138.1"> method earlier, simply calls the </span><code class="literal"><span class="koboSpan" id="kobo.139.1">offer</span></code><span class="koboSpan" id="kobo.140.1"> method on the </span><code class="literal"><span class="koboSpan" id="kobo.141.1">messages</span></code><span class="koboSpan" id="kobo.142.1"> queue. </span><span class="koboSpan" id="kobo.142.2">We could have alternatively called </span><code class="literal"><span class="koboSpan" id="kobo.143.1">add</span></code><span class="koboSpan" id="kobo.144.1"> or </span><code class="literal"><span class="koboSpan" id="kobo.145.1">put</span></code><span class="koboSpan" id="kobo.146.1">. </span><span class="koboSpan" id="kobo.146.2">We know that the queue is unbounded, so these methods never throw or block:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.147.1">private val messages = new LinkedBlockingQueue[String] 
val logger = new Thread { 
  setDaemon(true) 
  override def run() = while (true) log(messages.take()) 
} 
logger.start() 
def logMessage(msg: String): Unit = messages.offer(msg) 
</span></pre><p><span class="koboSpan" id="kobo.148.1">We place these methods and the previously defined </span><code class="literal"><span class="koboSpan" id="kobo.149.1">prepareForDelete</span></code><span class="koboSpan" id="kobo.150.1"> method into the </span><code class="literal"><span class="koboSpan" id="kobo.151.1">FileSystem</span></code><span class="koboSpan" id="kobo.152.1"> class. </span><span class="koboSpan" id="kobo.152.2">To test this, we can simply instantiate our </span><code class="literal"><span class="koboSpan" id="kobo.153.1">FileSystem</span></code><span class="koboSpan" id="kobo.154.1"> class and call the </span><code class="literal"><span class="koboSpan" id="kobo.155.1">logMessage</span></code><span class="koboSpan" id="kobo.156.1"> method. </span><span class="koboSpan" id="kobo.156.2">Once the main thread terminates, the </span><code class="literal"><span class="koboSpan" id="kobo.157.1">logger</span></code><span class="koboSpan" id="kobo.158.1"> thread automatically stops:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.159.1">val fileSystem = new FileSystem(".") 
fileSystem.logMessage("Testing log!") 
</span></pre><p><span class="koboSpan" id="kobo.160.1">An important difference between sequential queues and concurrent queues is that concurrent queues have </span><span class="strong"><strong><span class="koboSpan" id="kobo.161.1">weakly consistent iterators</span></strong></span><span class="koboSpan" id="kobo.162.1">. </span><span class="koboSpan" id="kobo.162.2">An iterator created with the </span><code class="literal"><span class="koboSpan" id="kobo.163.1">iterator</span></code><span class="koboSpan" id="kobo.164.1"> method traverses the elements that were in the queue at the moment the </span><code class="literal"><span class="koboSpan" id="kobo.165.1">iterator</span></code><span class="koboSpan" id="kobo.166.1"> method was created. </span><span class="koboSpan" id="kobo.166.2">However, if there is an enqueue or dequeue operation before the traversal is over, all bets are off, and the iterator might or might not reflect any modifications. </span><span class="koboSpan" id="kobo.166.3">Consider the following example, in which one thread traverses the concurrent queue while another thread dequeues its elements:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.167.1">object CollectionsIterators extends App { 
  val queue = new LinkedBlockingQueue[String] 
  for (i &lt;- 1 to 5500) queue.offer(i.toString) 
  execute { 
    val it = queue.iterator 
    while (it.hasNext) log(it.next()) 
  } 
  for (i &lt;- 1 to 5500) queue.poll() 
  Thread.sleep(1000) 
} 
</span></pre><p><span class="koboSpan" id="kobo.168.1">The main thread creates a queue with 5,500 elements. </span><span class="koboSpan" id="kobo.168.2">It then starts a concurrent task that creates an iterator and prints the elements one by one. </span><span class="koboSpan" id="kobo.168.3">At the same time, the main thread starts removing all the elements from the queue in the same order. </span><span class="koboSpan" id="kobo.168.4">In one of our thread runs, the iterator returns </span><code class="literal"><span class="koboSpan" id="kobo.169.1">1</span></code><span class="koboSpan" id="kobo.170.1">, </span><code class="literal"><span class="koboSpan" id="kobo.171.1">4,779</span></code><span class="koboSpan" id="kobo.172.1">, and </span><code class="literal"><span class="koboSpan" id="kobo.173.1">5,442</span></code><span class="koboSpan" id="kobo.174.1">. </span><span class="koboSpan" id="kobo.174.2">This does not make sense, because the queue never contained these three elements alone; we would expect to see a suffix that has the range of </span><code class="literal"><span class="koboSpan" id="kobo.175.1">1</span></code><span class="koboSpan" id="kobo.176.1"> to </span><code class="literal"><span class="koboSpan" id="kobo.177.1">5,500</span></code><span class="koboSpan" id="kobo.178.1">. </span><span class="koboSpan" id="kobo.178.2">We say that the iterator is not consistent. </span><span class="koboSpan" id="kobo.178.3">It is never corrupt and does not throw exceptions, but it fails to return a consistent set of elements that were in the queue at some point. </span><span class="koboSpan" id="kobo.178.4">With a few notable exceptions, this effect can happen when using any concurrent data structure.</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip29"/><span class="koboSpan" id="kobo.179.1">Tip</span></h3><p><span class="koboSpan" id="kobo.180.1">Use iterators on concurrent data structures only when you can ensure that no other thread will modify the data structure from the point where the iterator was created until the point where the iterator's </span><code class="literal"><span class="koboSpan" id="kobo.181.1">hasNext</span></code><span class="koboSpan" id="kobo.182.1"> method returns </span><code class="literal"><span class="koboSpan" id="kobo.183.1">false</span></code><span class="koboSpan" id="kobo.184.1">.</span></p></div></div><p><span class="koboSpan" id="kobo.185.1">The </span><code class="literal"><span class="koboSpan" id="kobo.186.1">CopyOnWriteArrayList</span></code><span class="koboSpan" id="kobo.187.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.188.1">CopyOnWriteArraySet</span></code><span class="koboSpan" id="kobo.189.1"> collections in JDK are exceptions to this rule, but they copy the underlying data whenever the collection is mutated and can be slow. </span><span class="koboSpan" id="kobo.189.2">Later in this section, we will see a concurrent collection from the </span><code class="literal"><span class="koboSpan" id="kobo.190.1">scala.collection.concurrent</span></code><span class="koboSpan" id="kobo.191.1"> package called </span><code class="literal"><span class="koboSpan" id="kobo.192.1">TrieMap</span></code><span class="koboSpan" id="kobo.193.1">, which creates consistent iterators without copying the underlying dataset and allows arbitrary modifications during the traversal.</span></p></div><div class="section" title="Concurrent sets and maps"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec27"/><span class="koboSpan" id="kobo.194.1">Concurrent sets and maps</span></h2></div></div></div><p><span class="koboSpan" id="kobo.195.1">Concurrent API designers strive to provide programmers with interfaces that resemble those from sequential programming. </span><span class="koboSpan" id="kobo.195.2">We have seen that this is the case with concurrent queues. </span><span class="koboSpan" id="kobo.195.3">As the main use case for concurrent queues is the producer-consumer pattern, the </span><code class="literal"><span class="koboSpan" id="kobo.196.1">BlockingQueue</span></code><span class="koboSpan" id="kobo.197.1"> interface additionally provides blocking versions of methods that are already known from sequential queues. </span><span class="koboSpan" id="kobo.197.2">Concurrent maps and concurrent sets are map and set collections, respectively, that can be safely accessed and modified by multiple threads. </span><span class="koboSpan" id="kobo.197.3">Like concurrent queues, they retain the API from the corresponding sequential collections. </span><span class="koboSpan" id="kobo.197.4">Unlike concurrent queues, they do not have blocking operations. </span><span class="koboSpan" id="kobo.197.5">The reason is that their principal use case is not the producer-consumer pattern, but encoding the program state.</span></p><p><span class="koboSpan" id="kobo.198.1">The </span><code class="literal"><span class="koboSpan" id="kobo.199.1">concurrent.Map</span></code><span class="koboSpan" id="kobo.200.1"> trait in the </span><code class="literal"><span class="koboSpan" id="kobo.201.1">scala.collection</span></code><span class="koboSpan" id="kobo.202.1"> package represents different concurrent map implementations. </span><span class="koboSpan" id="kobo.202.2">In our filesystem API, we use it to track the files that exist in the filesystem as follows:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.203.1">val files: concurrent.Map[String, Entry] 
</span></pre><p><span class="koboSpan" id="kobo.204.1">This concurrent map contains paths and their corresponding </span><code class="literal"><span class="koboSpan" id="kobo.205.1">Entry</span></code><span class="koboSpan" id="kobo.206.1"> objects. </span><span class="koboSpan" id="kobo.206.2">These are the same </span><code class="literal"><span class="koboSpan" id="kobo.207.1">Entry</span></code><span class="koboSpan" id="kobo.208.1"> objects that </span><code class="literal"><span class="koboSpan" id="kobo.209.1">prepareForDelete</span></code><span class="koboSpan" id="kobo.210.1"> used earlier. </span><span class="koboSpan" id="kobo.210.2">The concurrent </span><code class="literal"><span class="koboSpan" id="kobo.211.1">files</span></code><span class="koboSpan" id="kobo.212.1"> map is populated when the </span><code class="literal"><span class="koboSpan" id="kobo.213.1">FileSystem</span></code><span class="koboSpan" id="kobo.214.1"> object is created.</span></p><p><span class="koboSpan" id="kobo.215.1">For the examples in this section, we add the following dependency to our </span><code class="literal"><span class="koboSpan" id="kobo.216.1">build.sbt</span></code><span class="koboSpan" id="kobo.217.1"> file. </span><span class="koboSpan" id="kobo.217.2">This will allow us to use the Apache </span><code class="literal"><span class="koboSpan" id="kobo.218.1">Commons IO</span></code><span class="koboSpan" id="kobo.219.1"> library in order to handle files:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.220.1">libraryDependencies += "commons-io" % "commons-io" % "2.4" 
</span></pre><p><span class="koboSpan" id="kobo.221.1">We will allow </span><code class="literal"><span class="koboSpan" id="kobo.222.1">FileSystem</span></code><span class="koboSpan" id="kobo.223.1"> objects to only track files in a certain directory called </span><code class="literal"><span class="koboSpan" id="kobo.224.1">root</span></code><span class="koboSpan" id="kobo.225.1">. </span><span class="koboSpan" id="kobo.225.2">By instantiating the </span><code class="literal"><span class="koboSpan" id="kobo.226.1">FileSystem</span></code><span class="koboSpan" id="kobo.227.1"> object with the </span><code class="literal"><span class="koboSpan" id="kobo.228.1">"."</span></code><span class="koboSpan" id="kobo.229.1"> string, we set the </span><code class="literal"><span class="koboSpan" id="kobo.230.1">root</span></code><span class="koboSpan" id="kobo.231.1"> directory to the root of our project with the example code. </span><span class="koboSpan" id="kobo.231.2">This way, the worst thing that can happen is that you delete all your examples by accident and have to rewrite them once more. </span><span class="koboSpan" id="kobo.231.3">However, that's okay, as practice makes perfect! </span><span class="koboSpan" id="kobo.231.4">The </span><code class="literal"><span class="koboSpan" id="kobo.232.1">FileSystem</span></code><span class="koboSpan" id="kobo.233.1"> class is shown in the following snippet:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.234.1">import scala.collection.convert.decorateAsScala._ 
import java.io.File 
import org.apache.commons.io.FileUtils 
class FileSystem(val root: String) { 
  val rootDir = new File(root) 
  val files: concurrent.Map[String, Entry] = 
    new ConcurrentHashMap().asScala 
  for (f &lt;- FileUtils.iterateFiles(rootDir, null, false).asScala) 
  files.put(f.getName, new Entry(false)) 
} 
</span></pre><p><span class="koboSpan" id="kobo.235.1">We first create a new </span><code class="literal"><span class="koboSpan" id="kobo.236.1">ConcurrentHashMap</span></code><span class="koboSpan" id="kobo.237.1"> method from the </span><code class="literal"><span class="koboSpan" id="kobo.238.1">java.util.concurrent</span></code><span class="koboSpan" id="kobo.239.1"> package and wrap it to a Scala </span><code class="literal"><span class="koboSpan" id="kobo.240.1">concurrent.Map</span></code><span class="koboSpan" id="kobo.241.1"> trait by calling </span><code class="literal"><span class="koboSpan" id="kobo.242.1">asScala</span></code><span class="koboSpan" id="kobo.243.1">. </span><span class="koboSpan" id="kobo.243.2">This method can be called to wrap most Java collections, provided the contents of the </span><code class="literal"><span class="koboSpan" id="kobo.244.1">decorateAsScala</span></code><span class="koboSpan" id="kobo.245.1"> object are imported like they are in our example. </span><span class="koboSpan" id="kobo.245.2">The </span><code class="literal"><span class="koboSpan" id="kobo.246.1">asScala</span></code><span class="koboSpan" id="kobo.247.1"> method ensures that Java collections obtain the Scala collection API. </span><span class="koboSpan" id="kobo.247.2">The </span><code class="literal"><span class="koboSpan" id="kobo.248.1">iterateFiles</span></code><span class="koboSpan" id="kobo.249.1"> method in the </span><code class="literal"><span class="koboSpan" id="kobo.250.1">FileUtils</span></code><span class="koboSpan" id="kobo.251.1"> class returns a Java iterator that traverses the files in a specific folder; we can only use Scala iterators in </span><code class="literal"><span class="koboSpan" id="kobo.252.1">for</span></code><span class="koboSpan" id="kobo.253.1"> comprehensions, so we call </span><code class="literal"><span class="koboSpan" id="kobo.254.1">asScala</span></code><span class="koboSpan" id="kobo.255.1"> again. </span><span class="koboSpan" id="kobo.255.2">The first argument for the </span><code class="literal"><span class="koboSpan" id="kobo.256.1">iterateFiles</span></code><span class="koboSpan" id="kobo.257.1"> method specifies the </span><code class="literal"><span class="koboSpan" id="kobo.258.1">root</span></code><span class="koboSpan" id="kobo.259.1"> folder, and the second method specifies an optional filter for the files. </span><span class="koboSpan" id="kobo.259.2">The final </span><code class="literal"><span class="koboSpan" id="kobo.260.1">false</span></code><span class="koboSpan" id="kobo.261.1"> argument for the </span><code class="literal"><span class="koboSpan" id="kobo.262.1">iterateFiles</span></code><span class="koboSpan" id="kobo.263.1"> method denotes that we do not scan files recursively in the subdirectories of </span><code class="literal"><span class="koboSpan" id="kobo.264.1">root</span></code><span class="koboSpan" id="kobo.265.1">. </span><span class="koboSpan" id="kobo.265.2">We play it safe and expose only files in our </span><code class="literal"><span class="koboSpan" id="kobo.266.1">root</span></code><span class="koboSpan" id="kobo.267.1"> project directory to the </span><code class="literal"><span class="koboSpan" id="kobo.268.1">FileSystem</span></code><span class="koboSpan" id="kobo.269.1"> class. </span><span class="koboSpan" id="kobo.269.2">We place each </span><code class="literal"><span class="koboSpan" id="kobo.270.1">f</span></code><span class="koboSpan" id="kobo.271.1"> file along with a fresh </span><code class="literal"><span class="koboSpan" id="kobo.272.1">Entry</span></code><span class="koboSpan" id="kobo.273.1"> object into </span><code class="literal"><span class="koboSpan" id="kobo.274.1">files</span></code><span class="koboSpan" id="kobo.275.1"> by calling </span><code class="literal"><span class="koboSpan" id="kobo.276.1">put</span></code><span class="koboSpan" id="kobo.277.1"> on the concurrent map. </span><span class="koboSpan" id="kobo.277.2">There is no need to use a </span><code class="literal"><span class="koboSpan" id="kobo.278.1">synchronized</span></code><span class="koboSpan" id="kobo.279.1"> statement around </span><code class="literal"><span class="koboSpan" id="kobo.280.1">put</span></code><span class="koboSpan" id="kobo.281.1">, as the concurrent map takes care of synchronization and thread-safety. </span><span class="koboSpan" id="kobo.281.2">The </span><code class="literal"><span class="koboSpan" id="kobo.282.1">put</span></code><span class="koboSpan" id="kobo.283.1"> operation is atomic, and it establishes a happens-before relationship with subsequent </span><code class="literal"><span class="koboSpan" id="kobo.284.1">get</span></code><span class="koboSpan" id="kobo.285.1"> operations.</span></p><p><span class="koboSpan" id="kobo.286.1">The same is true for the other methods such as </span><code class="literal"><span class="koboSpan" id="kobo.287.1">remove</span></code><span class="koboSpan" id="kobo.288.1">, which removes key-value pairs from a concurrent map. </span><span class="koboSpan" id="kobo.288.2">We can now use the </span><code class="literal"><span class="koboSpan" id="kobo.289.1">prepareForDelete</span></code><span class="koboSpan" id="kobo.290.1"> method implemented earlier to atomically lock a file for deletion and then remove it from the </span><code class="literal"><span class="koboSpan" id="kobo.291.1">files</span></code><span class="koboSpan" id="kobo.292.1"> map. </span><span class="koboSpan" id="kobo.292.2">We implement the </span><code class="literal"><span class="koboSpan" id="kobo.293.1">deleteFile</span></code><span class="koboSpan" id="kobo.294.1"> method for this purpose:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.295.1">def deleteFile(filename: String): Unit = { 
  files.get(filename) match { 
    case None =&gt; 
      logMessage(s"Path '$filename' does not exist!") 
    case Some(entry) if entry.isDir =&gt; 
      logMessage(s"Path '$filename' is a directory!") 
    case Some(entry) =&gt; execute { 
      if (prepareForDelete(entry)) 
        if (FileUtils.deleteQuietly(new File(filename))) 
          files.remove(filename) 
    } 
  } 
} 
</span></pre><p><span class="koboSpan" id="kobo.296.1">If the </span><code class="literal"><span class="koboSpan" id="kobo.297.1">deleteFile</span></code><span class="koboSpan" id="kobo.298.1"> method finds that the concurrent map contains the file with the given name, it calls the </span><code class="literal"><span class="koboSpan" id="kobo.299.1">execute</span></code><span class="koboSpan" id="kobo.300.1"> method to asynchronously delete it, as we prefer not to block the caller thread. </span><span class="koboSpan" id="kobo.300.2">The concurrent task, started by the </span><code class="literal"><span class="koboSpan" id="kobo.301.1">execute</span></code><span class="koboSpan" id="kobo.302.1"> invocation, calls the </span><code class="literal"><span class="koboSpan" id="kobo.303.1">prepareForDelete</span></code><span class="koboSpan" id="kobo.304.1"> method. </span><span class="koboSpan" id="kobo.304.2">If the </span><code class="literal"><span class="koboSpan" id="kobo.305.1">prepareForDelete</span></code><span class="koboSpan" id="kobo.306.1"> method returns </span><code class="literal"><span class="koboSpan" id="kobo.307.1">true</span></code><span class="koboSpan" id="kobo.308.1">, then it is safe to call the </span><code class="literal"><span class="koboSpan" id="kobo.309.1">deleteQuietly</span></code><span class="koboSpan" id="kobo.310.1"> method from the </span><code class="literal"><span class="koboSpan" id="kobo.311.1">Commons IO</span></code><span class="koboSpan" id="kobo.312.1"> library. </span><span class="koboSpan" id="kobo.312.2">This method physically removes the file from the disk. </span><span class="koboSpan" id="kobo.312.3">If the deletion is successful, the file entry is removed from the </span><code class="literal"><span class="koboSpan" id="kobo.313.1">files</span></code><span class="koboSpan" id="kobo.314.1"> map. </span><span class="koboSpan" id="kobo.314.2">We create a new file called </span><code class="literal"><span class="koboSpan" id="kobo.315.1">test.txt</span></code><span class="koboSpan" id="kobo.316.1"> and use it to test the </span><code class="literal"><span class="koboSpan" id="kobo.317.1">deleteFile</span></code><span class="koboSpan" id="kobo.318.1"> method. </span><span class="koboSpan" id="kobo.318.2">We prefer not to experiment with the build definition file. </span><span class="koboSpan" id="kobo.318.3">The following code shows the deletion of the file:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.319.1">fileSystem.deleteFile("test.txt") 
</span></pre><p><span class="koboSpan" id="kobo.320.1">The second time we run this line, our logger thread from before complains that the file does not exist. </span><span class="koboSpan" id="kobo.320.2">A quick check in our file manager reveals that the </span><code class="literal"><span class="koboSpan" id="kobo.321.1">test.txt</span></code><span class="koboSpan" id="kobo.322.1"> file is no longer there.</span></p><p><span class="koboSpan" id="kobo.323.1">The </span><code class="literal"><span class="koboSpan" id="kobo.324.1">concurrent.Map</span></code><span class="koboSpan" id="kobo.325.1"> trait also defines several complex linearizable methods. </span><span class="koboSpan" id="kobo.325.2">Recall that complex linearizable operations involve multiple reads and writes. </span><span class="koboSpan" id="kobo.325.3">In the context of concurrent maps, methods are complex linearizable operations if they involve multiple instances of the </span><code class="literal"><span class="koboSpan" id="kobo.326.1">get</span></code><span class="koboSpan" id="kobo.327.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.328.1">put</span></code><span class="koboSpan" id="kobo.329.1"> methods, but appear to get executed at a single point in time. </span><span class="koboSpan" id="kobo.329.2">Such methods are a powerful tool in our concurrency arsenal. </span><span class="koboSpan" id="kobo.329.3">We have already seen that volatile reads and writes do not allow us to implement the </span><code class="literal"><span class="koboSpan" id="kobo.330.1">getUniqueId</span></code><span class="koboSpan" id="kobo.331.1"> method; we need the </span><code class="literal"><span class="koboSpan" id="kobo.332.1">compareAndSet</span></code><span class="koboSpan" id="kobo.333.1"> method for that. </span><span class="koboSpan" id="kobo.333.2">Similar methods on concurrent maps have comparable advantages. </span><span class="koboSpan" id="kobo.333.3">Different atomic methods on atomic maps are summarized in the following table. </span><span class="koboSpan" id="kobo.333.4">Note that, unlike the CAS instruction, these methods use structural equality to compare keys and values, and they call the </span><code class="literal"><span class="koboSpan" id="kobo.334.1">equals</span></code><span class="koboSpan" id="kobo.335.1"> method.</span></p><div class="informaltable"><table border="1"><colgroup><col/><col/></colgroup><thead><tr><th>
<p><span class="koboSpan" id="kobo.336.1">Signature</span></p>
</th><th>
<p><span class="koboSpan" id="kobo.337.1">Description</span></p>
</th></tr></thead><tbody><tr><td>
<p><span class="koboSpan" id="kobo.338.1">putIfAbsent (k: K,  v: V):        Option[V]</span></p>
</td><td>
<p><span class="koboSpan" id="kobo.339.1">This atomically assigns the value </span><code class="literal"><span class="koboSpan" id="kobo.340.1">v</span></code><span class="koboSpan" id="kobo.341.1"> to the key </span><code class="literal"><span class="koboSpan" id="kobo.342.1">k</span></code><span class="koboSpan" id="kobo.343.1"> if </span><code class="literal"><span class="koboSpan" id="kobo.344.1">k</span></code><span class="koboSpan" id="kobo.345.1"> is not in the map. </span><span class="koboSpan" id="kobo.345.2">Otherwise, it returns the value associated with </span><code class="literal"><span class="koboSpan" id="kobo.346.1">k</span></code><span class="koboSpan" id="kobo.347.1">.</span></p>
</td></tr><tr><td>
<p><span class="koboSpan" id="kobo.348.1">remove (k: K, v: V):</span></p><p>
</p><p><span class="koboSpan" id="kobo.349.1">  Boolean</span></p>
</td><td>
<p><span class="koboSpan" id="kobo.350.1">This atomically removes the key </span><code class="literal"><span class="koboSpan" id="kobo.351.1">k</span></code><span class="koboSpan" id="kobo.352.1"> if it is associated to the value equal to </span><code class="literal"><span class="koboSpan" id="kobo.353.1">v</span></code><span class="koboSpan" id="kobo.354.1"> and returns </span><code class="literal"><span class="koboSpan" id="kobo.355.1">true</span></code><span class="koboSpan" id="kobo.356.1"> if successful.</span></p>
</td></tr><tr><td>
<p><span class="koboSpan" id="kobo.357.1">replace (k: K, v: V):</span></p><p>
</p><p><span class="koboSpan" id="kobo.358.1">  Option[V]</span></p>
</td><td>
<p><span class="koboSpan" id="kobo.359.1">This atomically assigns the value </span><code class="literal"><span class="koboSpan" id="kobo.360.1">v</span></code><span class="koboSpan" id="kobo.361.1"> to the key </span><code class="literal"><span class="koboSpan" id="kobo.362.1">k</span></code><span class="koboSpan" id="kobo.363.1"> and returns the value previously associated with </span><code class="literal"><span class="koboSpan" id="kobo.364.1">k</span></code><span class="koboSpan" id="kobo.365.1">.</span></p>
</td></tr><tr><td>
<p><span class="koboSpan" id="kobo.366.1">replace (k: K, ov: V, nv: V):</span></p><p>
</p><p><span class="koboSpan" id="kobo.367.1">  Boolean</span></p>
</td><td>
<p><span class="koboSpan" id="kobo.368.1">This atomically assigns the key </span><code class="literal"><span class="koboSpan" id="kobo.369.1">k</span></code><span class="koboSpan" id="kobo.370.1"> to the value </span><code class="literal"><span class="koboSpan" id="kobo.371.1">nv</span></code><span class="koboSpan" id="kobo.372.1"> if </span><code class="literal"><span class="koboSpan" id="kobo.373.1">k</span></code><span class="koboSpan" id="kobo.374.1"> was previously associated with </span><code class="literal"><span class="koboSpan" id="kobo.375.1">ov</span></code><span class="koboSpan" id="kobo.376.1"> and returns </span><code class="literal"><span class="koboSpan" id="kobo.377.1">true</span></code><span class="koboSpan" id="kobo.378.1"> if successful.</span></p>
</td></tr></tbody></table></div><p><span class="koboSpan" id="kobo.379.1">Coming back to our filesystem API, let's see how these methods work to our advantage. </span><span class="koboSpan" id="kobo.379.2">We will now implement the </span><code class="literal"><span class="koboSpan" id="kobo.380.1">copyFile</span></code><span class="koboSpan" id="kobo.381.1"> method in the </span><code class="literal"><span class="koboSpan" id="kobo.382.1">FileSystem</span></code><span class="koboSpan" id="kobo.383.1"> class. </span><span class="koboSpan" id="kobo.383.2">Recall the diagram from the section on atomic variables. </span><span class="koboSpan" id="kobo.383.3">A copy operation can start only if the file is either in the </span><code class="literal"><span class="koboSpan" id="kobo.384.1">Idle</span></code><span class="koboSpan" id="kobo.385.1"> state or already in the </span><code class="literal"><span class="koboSpan" id="kobo.386.1">Copying</span></code><span class="koboSpan" id="kobo.387.1"> state, so we need to atomically switch the file state from </span><code class="literal"><span class="koboSpan" id="kobo.388.1">Idle</span></code><span class="koboSpan" id="kobo.389.1"> to </span><code class="literal"><span class="koboSpan" id="kobo.390.1">Copying</span></code><span class="koboSpan" id="kobo.391.1"> or from the </span><code class="literal"><span class="koboSpan" id="kobo.392.1">Copying</span></code><span class="koboSpan" id="kobo.393.1"> state to another </span><code class="literal"><span class="koboSpan" id="kobo.394.1">Copying</span></code><span class="koboSpan" id="kobo.395.1"> state with the value </span><code class="literal"><span class="koboSpan" id="kobo.396.1">n</span></code><span class="koboSpan" id="kobo.397.1"> incremented. </span><span class="koboSpan" id="kobo.397.2">We do this with the </span><code class="literal"><span class="koboSpan" id="kobo.398.1">acquire</span></code><span class="koboSpan" id="kobo.399.1"> method:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.400.1">@tailrec private def acquire(entry: Entry): Boolean = { 
  val s0 = entry.state.get 
  s0 match { 
    case _: Creating | _: Deleting =&gt; 
      logMessage("File inaccessible, cannot copy."); false 
    case i: Idle =&gt; 
      if (entry.state.compareAndSet(s0, new Copying(1))) true 
      else acquire(entry) 
    case c: Copying =&gt; 
      if (entry.state.compareAndSet(s0, new Copying(c.n+1))) true 
      else acquire(entry) 
  } 
} 
</span></pre><p><span class="koboSpan" id="kobo.401.1">After a thread completes copying a file, it needs to release the </span><code class="literal"><span class="koboSpan" id="kobo.402.1">Copying</span></code><span class="koboSpan" id="kobo.403.1"> lock. </span><span class="koboSpan" id="kobo.403.2">This is done by a similar </span><code class="literal"><span class="koboSpan" id="kobo.404.1">release</span></code><span class="koboSpan" id="kobo.405.1"> method, which decreases the </span><code class="literal"><span class="koboSpan" id="kobo.406.1">Copying</span></code><span class="koboSpan" id="kobo.407.1"> count or changes the state to </span><code class="literal"><span class="koboSpan" id="kobo.408.1">Idle</span></code><span class="koboSpan" id="kobo.409.1">. </span><span class="koboSpan" id="kobo.409.2">Importantly, this method must be called after files are newly created in order to switch from the </span><code class="literal"><span class="koboSpan" id="kobo.410.1">Creating</span></code><span class="koboSpan" id="kobo.411.1"> state to the </span><code class="literal"><span class="koboSpan" id="kobo.412.1">Idle</span></code><span class="koboSpan" id="kobo.413.1"> state. </span><span class="koboSpan" id="kobo.413.2">By now, the retry pattern following unsuccessful CAS operations should be child's play for you. </span><span class="koboSpan" id="kobo.413.3">The following code shows this:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.414.1">@tailrec private def release(entry: Entry): Unit = { 
  Val s0 = entry.state.get 
  s0 match { 
    case c: Creating =&gt; 
      if (!entry.state.compareAndSet(s0, new Idle)) release(entry) 
    case c: Copying =&gt; 
      val nstate = if (c.n == 1) new Idle else new Copying(c.n-1) 
      if (!entry.state.compareAndSet(s0, nstate)) release(entry) 
  } 
} 
</span></pre><p><span class="koboSpan" id="kobo.415.1">We now have all the machinery required to implement the </span><code class="literal"><span class="koboSpan" id="kobo.416.1">copyFile</span></code><span class="koboSpan" id="kobo.417.1"> method. </span><span class="koboSpan" id="kobo.417.2">This method checks whether an </span><code class="literal"><span class="koboSpan" id="kobo.418.1">src</span></code><span class="koboSpan" id="kobo.419.1"> entry exists in the </span><code class="literal"><span class="koboSpan" id="kobo.420.1">files</span></code><span class="koboSpan" id="kobo.421.1"> map. </span><span class="koboSpan" id="kobo.421.2">If the entry exists, the </span><code class="literal"><span class="koboSpan" id="kobo.422.1">copyFile</span></code><span class="koboSpan" id="kobo.423.1"> method starts a concurrent task to copy the file. </span><span class="koboSpan" id="kobo.423.2">The concurrent task attempts to acquire the file for copying and creates a new </span><code class="literal"><span class="koboSpan" id="kobo.424.1">destEntry</span></code><span class="koboSpan" id="kobo.425.1"> file entry in the </span><code class="literal"><span class="koboSpan" id="kobo.426.1">Creating</span></code><span class="koboSpan" id="kobo.427.1"> state. </span><span class="koboSpan" id="kobo.427.2">It then calls the </span><code class="literal"><span class="koboSpan" id="kobo.428.1">putIfAbsent</span></code><span class="koboSpan" id="kobo.429.1"> method, which atomically checks whether the file path </span><code class="literal"><span class="koboSpan" id="kobo.430.1">dest</span></code><span class="koboSpan" id="kobo.431.1"> is a key in the map and adds the </span><code class="literal"><span class="koboSpan" id="kobo.432.1">dest</span></code><span class="koboSpan" id="kobo.433.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.434.1">destEntry</span></code><span class="koboSpan" id="kobo.435.1"> pair if it is not. </span><span class="koboSpan" id="kobo.435.2">Both the </span><code class="literal"><span class="koboSpan" id="kobo.436.1">srcEntry</span></code><span class="koboSpan" id="kobo.437.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.438.1">destEntry</span></code><span class="koboSpan" id="kobo.439.1"> value pair are locked at this point, so the </span><code class="literal"><span class="koboSpan" id="kobo.440.1">FileUtils.copyFile</span></code><span class="koboSpan" id="kobo.441.1"> method from the </span><code class="literal"><span class="koboSpan" id="kobo.442.1">Commons IO</span></code><span class="koboSpan" id="kobo.443.1"> library is called to copy the file on the disk. </span><span class="koboSpan" id="kobo.443.2">Once the copying is complete, both the </span><code class="literal"><span class="koboSpan" id="kobo.444.1">srcEntry</span></code><span class="koboSpan" id="kobo.445.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.446.1">destEntry</span></code><span class="koboSpan" id="kobo.447.1"> value pair are released:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.448.1">def copyFile(src: String, dest: String): Unit = { 
  files.get(src) match { 
    case Some(srcEntry) if !srcEntry.isDir =&gt; execute { 
      if (acquire(srcEntry)) try { 
        val destEntry = new Entry(isDir = false) 
        destEntry.state.set(new Creating) 
        if (files.putIfAbsent(dest, destEntry) == None) try { 
          FileUtils.copyFile(new File(src), new File(dest)) 
        } finally release(destEntry) 
      } finally release(srcEntry) 
    } 
  } 
} 
</span></pre><p><span class="koboSpan" id="kobo.449.1">You should convince yourself that the </span><code class="literal"><span class="koboSpan" id="kobo.450.1">copyFile</span></code><span class="koboSpan" id="kobo.451.1"> method would be incorrect if it first called </span><code class="literal"><span class="koboSpan" id="kobo.452.1">get</span></code><span class="koboSpan" id="kobo.453.1"> to check whether </span><code class="literal"><span class="koboSpan" id="kobo.454.1">dest</span></code><span class="koboSpan" id="kobo.455.1"> is in the map and then called </span><code class="literal"><span class="koboSpan" id="kobo.456.1">put</span></code><span class="koboSpan" id="kobo.457.1"> to place </span><code class="literal"><span class="koboSpan" id="kobo.458.1">dest</span></code><span class="koboSpan" id="kobo.459.1"> in the map. </span><span class="koboSpan" id="kobo.459.2">This would allow another thread's </span><code class="literal"><span class="koboSpan" id="kobo.460.1">get</span></code><span class="koboSpan" id="kobo.461.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.462.1">put</span></code><span class="koboSpan" id="kobo.463.1"> steps to interleave and potentially overwrite an entry in the </span><code class="literal"><span class="koboSpan" id="kobo.464.1">files</span></code><span class="koboSpan" id="kobo.465.1"> map. </span><span class="koboSpan" id="kobo.465.2">This demonstrates the importance of the </span><code class="literal"><span class="koboSpan" id="kobo.466.1">putIfAbsent</span></code><span class="koboSpan" id="kobo.467.1"> method.</span></p><p><span class="koboSpan" id="kobo.468.1">There are some methods that the </span><code class="literal"><span class="koboSpan" id="kobo.469.1">concurrent.Map</span></code><span class="koboSpan" id="kobo.470.1"> trait inherits from the </span><code class="literal"><span class="koboSpan" id="kobo.471.1">mutable.Map</span></code><span class="koboSpan" id="kobo.472.1"> trait and that are not atomic. </span><span class="koboSpan" id="kobo.472.2">An example is the </span><code class="literal"><span class="koboSpan" id="kobo.473.1">getOrElseUpdate</span></code><span class="koboSpan" id="kobo.474.1"> method, which retrieves an element if it is present in the map and updates it with a different element otherwise. </span><span class="koboSpan" id="kobo.474.2">This method is not atomic, while its individual steps are atomic; they can be interleaved arbitrarily with concurrent calls to the </span><code class="literal"><span class="koboSpan" id="kobo.475.1">getOrElseUpdate</span></code><span class="koboSpan" id="kobo.476.1"> method. </span><span class="koboSpan" id="kobo.476.2">Another example is </span><code class="literal"><span class="koboSpan" id="kobo.477.1">clear</span></code><span class="koboSpan" id="kobo.478.1">, which does not have to be atomic on concurrent collections in general and can behave like the concurrent data structure iterators we studied before.</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note30"/><span class="koboSpan" id="kobo.479.1">Note</span></h3><p><span class="koboSpan" id="kobo.480.1">The</span><code class="literal"><span class="koboSpan" id="kobo.481.1">+=</span></code><span class="koboSpan" id="kobo.482.1">, </span><code class="literal"><span class="koboSpan" id="kobo.483.1">-=</span></code><span class="koboSpan" id="kobo.484.1">, </span><code class="literal"><span class="koboSpan" id="kobo.485.1">put</span></code><span class="koboSpan" id="kobo.486.1">, </span><code class="literal"><span class="koboSpan" id="kobo.487.1">update</span></code><span class="koboSpan" id="kobo.488.1">, </span><code class="literal"><span class="koboSpan" id="kobo.489.1">get</span></code><span class="koboSpan" id="kobo.490.1">, </span><code class="literal"><span class="koboSpan" id="kobo.491.1">apply</span></code><span class="koboSpan" id="kobo.492.1">, and </span><code class="literal"><span class="koboSpan" id="kobo.493.1">remove</span></code><span class="koboSpan" id="kobo.494.1"> methods in the </span><code class="literal"><span class="koboSpan" id="kobo.495.1">concurrent.Map</span></code><span class="koboSpan" id="kobo.496.1"> trait are linearizable methods. </span><span class="koboSpan" id="kobo.496.2">The </span><code class="literal"><span class="koboSpan" id="kobo.497.1">putIfAbsent</span></code><span class="koboSpan" id="kobo.498.1">, conditional </span><code class="literal"><span class="koboSpan" id="kobo.499.1">remove</span></code><span class="koboSpan" id="kobo.500.1">, and </span><code class="literal"><span class="koboSpan" id="kobo.501.1">replace</span></code><span class="koboSpan" id="kobo.502.1"> methods in the </span><code class="literal"><span class="koboSpan" id="kobo.503.1">concurrent.Map</span></code><span class="koboSpan" id="kobo.504.1"> trait are the only complex methods guaranteed to be linearizable.</span></p></div></div><p><span class="koboSpan" id="kobo.505.1">Just like the Java concurrency library, Scala currently does not have a dedicated trait for concurrent sets. </span><span class="koboSpan" id="kobo.505.2">A concurrent set of the </span><code class="literal"><span class="koboSpan" id="kobo.506.1">Set[T]</span></code><span class="koboSpan" id="kobo.507.1"> type can be emulated with a concurrent map with the </span><code class="literal"><span class="koboSpan" id="kobo.508.1">ConcurrentMap[T, Unit]</span></code><span class="koboSpan" id="kobo.509.1"> type, which ignores the values assigned to keys. </span><span class="koboSpan" id="kobo.509.2">This is the reason why concrete concurrent set implementations appear less often in concurrency frameworks. </span><span class="koboSpan" id="kobo.509.3">In rare situations, where a Java concurrent set, such as the </span><code class="literal"><span class="koboSpan" id="kobo.510.1">ConcurrentSkipListSet[T]</span></code><span class="koboSpan" id="kobo.511.1"> class, needs to be converted to a Scala concurrent set, we can use the </span><code class="literal"><span class="koboSpan" id="kobo.512.1">asScala</span></code><span class="koboSpan" id="kobo.513.1"> method, which converts it to a </span><code class="literal"><span class="koboSpan" id="kobo.514.1">mutable.Set[T]</span></code><span class="koboSpan" id="kobo.515.1"> class.</span></p><p><span class="koboSpan" id="kobo.516.1">As a final note, you should never use </span><code class="literal"><span class="koboSpan" id="kobo.517.1">null</span></code><span class="koboSpan" id="kobo.518.1"> as a key or value in a concurrent map or a concurrent set. </span><span class="koboSpan" id="kobo.518.2">Many concurrent data structure implementations on JVM rely on using </span><code class="literal"><span class="koboSpan" id="kobo.519.1">null</span></code><span class="koboSpan" id="kobo.520.1"> as a special indicator of the absence of an element.</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip31"/><span class="koboSpan" id="kobo.521.1">Tip</span></h3><p><span class="koboSpan" id="kobo.522.1">Avoid using the </span><code class="literal"><span class="koboSpan" id="kobo.523.1">null</span></code><span class="koboSpan" id="kobo.524.1"> value as a key or a value in a concurrent data structure.</span></p></div></div><p><span class="koboSpan" id="kobo.525.1">Some implementations are defensive and will throw an exception; for others, the results might be undefined. </span><span class="koboSpan" id="kobo.525.2">Even when a concurrent collection specifies that </span><code class="literal"><span class="koboSpan" id="kobo.526.1">null</span></code><span class="koboSpan" id="kobo.527.1"> is allowed, you should avoid coupling </span><code class="literal"><span class="koboSpan" id="kobo.528.1">null</span></code><span class="koboSpan" id="kobo.529.1"> with your program logic in order to make potential refactoring easier.</span></p></div><div class="section" title="Concurrent traversals"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec28"/><span class="koboSpan" id="kobo.530.1">Concurrent traversals</span></h2></div></div></div><p><span class="koboSpan" id="kobo.531.1">As you had a chance to witness, Scala directly inherits many of its basic concurrency utilities from the Java concurrency packages. </span><span class="koboSpan" id="kobo.531.2">After all, these facilities were implemented by JVM's concurrency experts. </span><span class="koboSpan" id="kobo.531.3">Apart from providing conversions that make Java's traditional concurrency utilities feel Scala-idiomatic, there is no need to reinvent what's already there. </span><span class="koboSpan" id="kobo.531.4">When it comes to concurrent collections, a particularly bothersome limitation is that you cannot safely traverse most concurrent collections and modify them in the same time. </span><span class="koboSpan" id="kobo.531.5">This is not so problematic for sequential collections where we control the thread that calls the </span><code class="literal"><span class="koboSpan" id="kobo.532.1">foreach</span></code><span class="koboSpan" id="kobo.533.1"> loop or uses iterators. </span><span class="koboSpan" id="kobo.533.2">In a concurrent system where threads are not perfectly synchronized with each other, it is much harder to guarantee that there will be no modifications during the traversal.</span></p><p><span class="koboSpan" id="kobo.534.1">Fortunately, Scala has an answer for concurrent collection traversals. </span><span class="koboSpan" id="kobo.534.2">The </span><code class="literal"><span class="koboSpan" id="kobo.535.1">TrieMap</span></code><span class="koboSpan" id="kobo.536.1"> collection from the </span><code class="literal"><span class="koboSpan" id="kobo.537.1">scala.collection.concurrent</span></code><span class="koboSpan" id="kobo.538.1"> package, which is based on the concurrent </span><span class="strong"><strong><span class="koboSpan" id="kobo.539.1">Ctrie</span></strong></span><span class="koboSpan" id="kobo.540.1"> data structure, is a concurrent map implementation that produces consistent iterators. </span><span class="koboSpan" id="kobo.540.2">When its </span><code class="literal"><span class="koboSpan" id="kobo.541.1">iterator</span></code><span class="koboSpan" id="kobo.542.1"> method is called, the </span><code class="literal"><span class="koboSpan" id="kobo.543.1">TrieMap</span></code><span class="koboSpan" id="kobo.544.1"> collection atomically takes a snapshot of all the elements. </span><span class="koboSpan" id="kobo.544.2">A </span><span class="strong"><strong><span class="koboSpan" id="kobo.545.1">snapshot</span></strong></span><span class="koboSpan" id="kobo.546.1"> is complete information about the state of a data structure. </span><span class="koboSpan" id="kobo.546.2">The iterator then uses this snapshot to traverse the elements. </span><span class="koboSpan" id="kobo.546.3">If the </span><code class="literal"><span class="koboSpan" id="kobo.547.1">TrieMap</span></code><span class="koboSpan" id="kobo.548.1"> collection is later modified during the traversal, the modifications are not visible in the snapshot and the iterator does not reflect them. </span><span class="koboSpan" id="kobo.548.2">You might conclude that taking a snapshot is expensive and requires copying all the elements, but this is not the case. </span><span class="koboSpan" id="kobo.548.3">The </span><code class="literal"><span class="koboSpan" id="kobo.549.1">snapshot</span></code><span class="koboSpan" id="kobo.550.1"> method of the </span><code class="literal"><span class="koboSpan" id="kobo.551.1">TrieMap</span></code><span class="koboSpan" id="kobo.552.1"> class incrementally rebuilds parts of the </span><code class="literal"><span class="koboSpan" id="kobo.553.1">TrieMap</span></code><span class="koboSpan" id="kobo.554.1"> collection when they are first accessed by some thread. </span><span class="koboSpan" id="kobo.554.2">The </span><code class="literal"><span class="koboSpan" id="kobo.555.1">readOnlySnapshot</span></code><span class="koboSpan" id="kobo.556.1"> method, internally used by the </span><code class="literal"><span class="koboSpan" id="kobo.557.1">iterator</span></code><span class="koboSpan" id="kobo.558.1"> method, is even more efficient. </span><span class="koboSpan" id="kobo.558.2">It ensures that only the modified parts of the </span><code class="literal"><span class="koboSpan" id="kobo.559.1">TrieMap</span></code><span class="koboSpan" id="kobo.560.1"> collection are lazily copied. </span><span class="koboSpan" id="kobo.560.2">If there are no subsequent concurrent modifications, then no part of the </span><code class="literal"><span class="koboSpan" id="kobo.561.1">TrieMap</span></code><span class="koboSpan" id="kobo.562.1"> collection is ever copied.</span></p><p><span class="koboSpan" id="kobo.563.1">Let's study the difference between the Java </span><code class="literal"><span class="koboSpan" id="kobo.564.1">ConcurrentHashMap</span></code><span class="koboSpan" id="kobo.565.1"> and the Scala </span><code class="literal"><span class="koboSpan" id="kobo.566.1">concurrent.TrieMap</span></code><span class="koboSpan" id="kobo.567.1"> collections in an example. </span><span class="koboSpan" id="kobo.567.2">Assume that we have a concurrent map that maps names to numerals in these names. </span><span class="koboSpan" id="kobo.567.3">For example, </span><code class="literal"><span class="koboSpan" id="kobo.568.1">"Jane"</span></code><span class="koboSpan" id="kobo.569.1"> will be mapped to </span><code class="literal"><span class="koboSpan" id="kobo.570.1">0</span></code><span class="koboSpan" id="kobo.571.1">, but </span><code class="literal"><span class="koboSpan" id="kobo.572.1">"John"</span></code><span class="koboSpan" id="kobo.573.1"> will be mapped to </span><code class="literal"><span class="koboSpan" id="kobo.574.1">4</span></code><span class="koboSpan" id="kobo.575.1">, and so on. </span><span class="koboSpan" id="kobo.575.2">In one concurrent task, we add different names for John in the order of </span><code class="literal"><span class="koboSpan" id="kobo.576.1">0</span></code><span class="koboSpan" id="kobo.577.1"> to </span><code class="literal"><span class="koboSpan" id="kobo.578.1">10</span></code><span class="koboSpan" id="kobo.579.1"> to the </span><code class="literal"><span class="koboSpan" id="kobo.580.1">ConcurrentHashMap</span></code><span class="koboSpan" id="kobo.581.1"> collection. </span><span class="koboSpan" id="kobo.581.2">We concurrently traverse the map and output these names:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.582.1">object CollectionsConcurrentMapBulk extends App { 
  val names = new ConcurrentHashMap[String, Int]().asScala 
  names("Johnny") = 0; names("Jane") = 0; names("Jack") = 0 
  execute { 
    for (n &lt;- 0 until 10) names(s"John $n") = n } 
  execute { 
    for (n &lt;- names) log(s"name: $n") } 
  Thread.sleep(1000) 
} 
</span></pre><p><span class="koboSpan" id="kobo.583.1">If the iterator was consistent, we would expect to see the three names </span><code class="literal"><span class="koboSpan" id="kobo.584.1">Johnny</span></code><span class="koboSpan" id="kobo.585.1">, </span><code class="literal"><span class="koboSpan" id="kobo.586.1">Jane</span></code><span class="koboSpan" id="kobo.587.1">, and </span><code class="literal"><span class="koboSpan" id="kobo.588.1">Jack</span></code><span class="koboSpan" id="kobo.589.1"> that were initially in the map and the name </span><code class="literal"><span class="koboSpan" id="kobo.590.1">John</span></code><span class="koboSpan" id="kobo.591.1"> in the interval from </span><code class="literal"><span class="koboSpan" id="kobo.592.1">0</span></code><span class="koboSpan" id="kobo.593.1"> to an </span><code class="literal"><span class="koboSpan" id="kobo.594.1">n</span></code><span class="koboSpan" id="kobo.595.1"> value, depending on how many names the first task added; this could be </span><code class="literal"><span class="koboSpan" id="kobo.596.1">John 1</span></code><span class="koboSpan" id="kobo.597.1">, </span><code class="literal"><span class="koboSpan" id="kobo.598.1">John 2</span></code><span class="koboSpan" id="kobo.599.1">, or </span><code class="literal"><span class="koboSpan" id="kobo.600.1">John 3</span></code><span class="koboSpan" id="kobo.601.1">. </span><span class="koboSpan" id="kobo.601.2">Instead, the output shows you random nonconsecutive names such as </span><code class="literal"><span class="koboSpan" id="kobo.602.1">John 8</span></code><span class="koboSpan" id="kobo.603.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.604.1">John 5</span></code><span class="koboSpan" id="kobo.605.1">, which does not make sense. </span><code class="literal"><span class="koboSpan" id="kobo.606.1">John 8</span></code><span class="koboSpan" id="kobo.607.1"> should never appear in the map without </span><code class="literal"><span class="koboSpan" id="kobo.608.1">John 7</span></code><span class="koboSpan" id="kobo.609.1">, and other entries inserted earlier by the other task. </span><span class="koboSpan" id="kobo.609.2">This never happens in a concurrent </span><code class="literal"><span class="koboSpan" id="kobo.610.1">TrieMap</span></code><span class="koboSpan" id="kobo.611.1"> collection. </span><span class="koboSpan" id="kobo.611.2">We can run the same experiment with the </span><code class="literal"><span class="koboSpan" id="kobo.612.1">TrieMap</span></code><span class="koboSpan" id="kobo.613.1"> collection and sort the names lexicographically before outputting them. </span><span class="koboSpan" id="kobo.613.2">Running the following program always prints all the </span><code class="literal"><span class="koboSpan" id="kobo.614.1">John</span></code><span class="koboSpan" id="kobo.615.1"> names in the interval of </span><code class="literal"><span class="koboSpan" id="kobo.616.1">0</span></code><span class="koboSpan" id="kobo.617.1"> and some value </span><code class="literal"><span class="koboSpan" id="kobo.618.1">n</span></code><span class="koboSpan" id="kobo.619.1">:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.620.1">object CollectionsTrieMapBulk extends App { 
  val names = new concurrent.TrieMap[String, Int] 
  names("Janice") = 0; names("Jackie") = 0; names("Jill") = 0 
  execute {for (n &lt;- 10 until 100) names(s"John $n") = n} 
  execute { 
    log("snapshot time!") 
    for (n &lt;- names.map(_._1).toSeq.sorted) log(s"name: $n") 
  } 
} 
</span></pre><p><span class="koboSpan" id="kobo.621.1">How is this useful in practice? </span><span class="koboSpan" id="kobo.621.2">Imagine that we need to return a consistent snapshot of the filesystem; all the files are as seen by the file manager or an FTP server at a point in time. </span><span class="koboSpan" id="kobo.621.3">A </span><code class="literal"><span class="koboSpan" id="kobo.622.1">TrieMap</span></code><span class="koboSpan" id="kobo.623.1"> collection ensures that other threads that delete or copy files cannot interfere with the thread that is extracting the files. </span><span class="koboSpan" id="kobo.623.2">We thus use the </span><code class="literal"><span class="koboSpan" id="kobo.624.1">TrieMap</span></code><span class="koboSpan" id="kobo.625.1"> collection to store files in our filesystem API and define a simple </span><code class="literal"><span class="koboSpan" id="kobo.626.1">allFiles</span></code><span class="koboSpan" id="kobo.627.1"> method that returns all the files. </span><span class="koboSpan" id="kobo.627.2">At the point where we start using the </span><code class="literal"><span class="koboSpan" id="kobo.628.1">files</span></code><span class="koboSpan" id="kobo.629.1"> map in a </span><code class="literal"><span class="koboSpan" id="kobo.630.1">for</span></code><span class="koboSpan" id="kobo.631.1"> comprehension, a snapshot with the filesystem contents is created:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.632.1">val files: concurrent.Map[String, Entry] = new concurrent.TrieMap() 
def allFiles(): Iterable[String] = for ((name, state) &lt;- files) yield name 
</span></pre><p><span class="koboSpan" id="kobo.633.1">We use the </span><code class="literal"><span class="koboSpan" id="kobo.634.1">allFiles</span></code><span class="koboSpan" id="kobo.635.1"> method to display all the files in the </span><code class="literal"><span class="koboSpan" id="kobo.636.1">root</span></code><span class="koboSpan" id="kobo.637.1"> directory:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.638.1">val rootFiles = fileSystem.allFiles() 
log("All files in the root dir: " + rootFiles.mkString(", ")) 
</span></pre><p><span class="koboSpan" id="kobo.639.1">After having seen both these concurrent maps, you might be wondering about which one to use. </span><span class="koboSpan" id="kobo.639.2">This mainly depends on the use case. </span><span class="koboSpan" id="kobo.639.3">If the application requires consistent iterators, then you should definitely use the </span><code class="literal"><span class="koboSpan" id="kobo.640.1">TrieMap</span></code><span class="koboSpan" id="kobo.641.1"> collections. </span><span class="koboSpan" id="kobo.641.2">On the other hand, if the application does not require consistent iterators and rarely modifies the concurrent map, you can consider using </span><code class="literal"><span class="koboSpan" id="kobo.642.1">ConcurrentHashMap</span></code><span class="koboSpan" id="kobo.643.1"> collections, as their lookup operations are slightly faster.</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip32"/><span class="koboSpan" id="kobo.644.1">Tip</span></h3><p><span class="koboSpan" id="kobo.645.1">Use </span><code class="literal"><span class="koboSpan" id="kobo.646.1">TrieMap</span></code><span class="koboSpan" id="kobo.647.1"> collections if you require consistent iterators and </span><code class="literal"><span class="koboSpan" id="kobo.648.1">ConcurrentHashMap</span></code><span class="koboSpan" id="kobo.649.1"> collections when the </span><code class="literal"><span class="koboSpan" id="kobo.650.1">get</span></code><span class="koboSpan" id="kobo.651.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.652.1">apply</span></code><span class="koboSpan" id="kobo.653.1"> operations are the bottlenecks in your program.</span></p></div></div><p><span class="koboSpan" id="kobo.654.1">From a performance point of view, this tip is only applicable if your application is exclusively accessing a concurrent map all the time and doing nothing else. </span><span class="koboSpan" id="kobo.654.2">In practice, this is rarely the case, and in most situations, you can use either of these collections.</span></p></div></div></div></div>
<div id="book-columns"><div id="book-inner"><div class="section" title="Custom concurrent data structures"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec23"/><span class="koboSpan" id="kobo.1.1">Custom concurrent data structures</span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">In this section, we will show how to design a concurrent data structure. </span><span class="koboSpan" id="kobo.2.2">The data structure we will use as a running example will be simple, but sufficient to demonstrate the general approach. </span><span class="koboSpan" id="kobo.2.3">You will be able to apply the same principles to more complex data structures.</span></p><p><span class="koboSpan" id="kobo.3.1">Before we start, there is a disclaimer. </span><span class="koboSpan" id="kobo.3.2">Designing a concurrent data structure is hard, and, as a rule of the thumb, you should almost never do it. </span><span class="koboSpan" id="kobo.3.3">Even if you manage to implement a correct and efficient concurrent data structure, the cost of doing so is usually high.</span></p><p><span class="koboSpan" id="kobo.4.1">There are several reasons why designing a concurrent data structure is hard. </span><span class="koboSpan" id="kobo.4.2">The first is achieving correctness: errors are much harder to notice, reproduce, or analyze due to inherent non-determinism. </span><span class="koboSpan" id="kobo.4.3">Then, operations must not slow down when more processors use the data structure. </span><span class="koboSpan" id="kobo.4.4">In other words, the data structure must be scalable. </span><span class="koboSpan" id="kobo.4.5">Finally, a concurrent data structure must be efficient in absolute terms, and it must not be much slower than its sequential counterpart when used with a single processor.</span></p><p><span class="koboSpan" id="kobo.5.1">That said, we proceed to designing a concrete data structure: a concurrent pool.</span></p><div class="section" title="Implementing a lock-free concurrent pool"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec29"/><span class="koboSpan" id="kobo.6.1">Implementing a lock-free concurrent pool</span></h2></div></div></div><p><span class="koboSpan" id="kobo.7.1">In this section, we will implement a concurrent lock-free pool as an example of how to design a concurrent data structure. </span><span class="koboSpan" id="kobo.7.2">A </span><span class="strong"><strong><span class="koboSpan" id="kobo.8.1">pool</span></strong></span><span class="koboSpan" id="kobo.9.1"> is one of the simplest data structure abstractions, and only has two methods--the </span><code class="literal"><span class="koboSpan" id="kobo.10.1">add</span></code><span class="koboSpan" id="kobo.11.1"> and the </span><code class="literal"><span class="koboSpan" id="kobo.12.1">remove</span></code><span class="koboSpan" id="kobo.13.1"> operations. </span><span class="koboSpan" id="kobo.13.2">The </span><code class="literal"><span class="koboSpan" id="kobo.14.1">add</span></code><span class="koboSpan" id="kobo.15.1"> operation simply adds an element into the pool, but the </span><code class="literal"><span class="koboSpan" id="kobo.16.1">remove</span></code><span class="koboSpan" id="kobo.17.1"> operation is more limited than in a set or a map of elements. </span><span class="koboSpan" id="kobo.17.2">Instead of removing a specific element from the pool, the </span><code class="literal"><span class="koboSpan" id="kobo.18.1">remove</span></code><span class="koboSpan" id="kobo.19.1"> operation removes any element, as long as the pool is non-empty. </span><span class="koboSpan" id="kobo.19.2">A lock-free pool is a pool whose operations are lock-free.</span></p><p><span class="koboSpan" id="kobo.20.1">Although simple, the pool abstraction is very useful, as it allows temporarily storing expensive objects (for example, worker threads or database connectors). </span><span class="koboSpan" id="kobo.20.2">For this use-case, we do not care about which exact element the </span><code class="literal"><span class="koboSpan" id="kobo.21.1">remove</span></code><span class="koboSpan" id="kobo.22.1"> operation returns, as long as it returns some element.</span></p><p><span class="koboSpan" id="kobo.23.1">Determining its operations is the first step in designing a concurrent data structure. </span><span class="koboSpan" id="kobo.23.2">Knowing the operations and their exact semantics drives the rest of the design, and adding supplementary operations later is likely to break the invariants of the data structure. </span><span class="koboSpan" id="kobo.23.3">It is usually hard to correctly extend a concurrent data structure once it has already been implemented.</span></p><p><span class="koboSpan" id="kobo.24.1">Having determined the operations that a concurrent data structure must support, the next step is to think about data representation. </span><span class="koboSpan" id="kobo.24.2">Since we decided that the operations must be lock-free, one seemingly reasonable choice is to encode the state as an </span><code class="literal"><span class="koboSpan" id="kobo.25.1">AtomicReference</span></code><span class="koboSpan" id="kobo.26.1"> object holding a pointer to an immutable list:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.27.1">val pool = new AtomicReference[List[T]] 
</span></pre><p><span class="koboSpan" id="kobo.28.1">Both, the </span><code class="literal"><span class="koboSpan" id="kobo.29.1">add</span></code><span class="koboSpan" id="kobo.30.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.31.1">remove</span></code><span class="koboSpan" id="kobo.32.1"> operations follow naturally from this choice. </span><span class="koboSpan" id="kobo.32.2">To add an element, we read the old list, use it to append the element at the head of the list, and then invoke a </span><code class="literal"><span class="koboSpan" id="kobo.33.1">compareAndSet</span></code><span class="koboSpan" id="kobo.34.1"> operation to replace the old list, retrying if necessary. </span><span class="koboSpan" id="kobo.34.2">Elements would be removed in a similar fashion.</span></p><p><span class="koboSpan" id="kobo.35.1">However, such an implementation would not be very scalable. </span><span class="koboSpan" id="kobo.35.2">Multiple processors would need to access the same memory location, and retrying would occur frequently. </span><span class="koboSpan" id="kobo.35.3">The expected time to complete the operation would then be </span><span class="emphasis"><em><span class="koboSpan" id="kobo.36.1">O(P)</span></em></span><span class="koboSpan" id="kobo.37.1">, where </span><span class="emphasis"><em><span class="koboSpan" id="kobo.38.1">P</span></em></span><span class="koboSpan" id="kobo.39.1"> is the number of processors that are concurrently executing </span><code class="literal"><span class="koboSpan" id="kobo.40.1">add</span></code><span class="koboSpan" id="kobo.41.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.42.1">remove</span></code><span class="koboSpan" id="kobo.43.1"> operations.</span></p><p><span class="koboSpan" id="kobo.44.1">To improve this, we will need to allow different processors to pick different memory locations in the data structure when updating it. </span><span class="koboSpan" id="kobo.44.2">The fact that we are implementing a pool mitigates this decision, since the </span><code class="literal"><span class="koboSpan" id="kobo.45.1">remove</span></code><span class="koboSpan" id="kobo.46.1"> operation will not have to search for specific elements, and just needs to return any element. </span><span class="koboSpan" id="kobo.46.2">Therefore, the </span><code class="literal"><span class="koboSpan" id="kobo.47.1">add</span></code><span class="koboSpan" id="kobo.48.1"> operation can append the element to any location in the data structure.</span></p><p><span class="koboSpan" id="kobo.49.1">With this in mind, we choose an array of atomic references, each holding an immutable list, as our internal representation. </span><span class="koboSpan" id="kobo.49.2">Having many atomic references allows each processor to pick an arbitrary slot to perform the update. </span><span class="koboSpan" id="kobo.49.3">This is shown in the following snippet:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.50.1">class Pool[T] { 
  val parallelism = Runtime.getRuntime.availableProcessors * 32 
  val buckets = 
    new Array[AtomicReference[(List[T], Long)]](parallelism) 
  for (i &lt;- 0 until buckets.length) 
    buckets(i) = new AtomicReference((Nil, 0L)) 
</span></pre><p><span class="koboSpan" id="kobo.51.1">Note that each atomic reference holds not only a list of values in the respective bucket, but also a </span><code class="literal"><span class="koboSpan" id="kobo.52.1">Long</span></code><span class="koboSpan" id="kobo.53.1"> value. </span><span class="koboSpan" id="kobo.53.2">This unique numeric value will serve as a timestamp that must be incremented each time the bucket is modified. </span><span class="koboSpan" id="kobo.53.3">Before we see why having the timestamp is important, we will implement the </span><code class="literal"><span class="koboSpan" id="kobo.54.1">add</span></code><span class="koboSpan" id="kobo.55.1"> operation.</span></p><p><span class="koboSpan" id="kobo.56.1">The </span><code class="literal"><span class="koboSpan" id="kobo.57.1">add</span></code><span class="koboSpan" id="kobo.58.1"> operation must pick one of the atomic references in the </span><code class="literal"><span class="koboSpan" id="kobo.59.1">buckets</span></code><span class="koboSpan" id="kobo.60.1"> array, create a new version of the list that contains the new element, and then invoke the CAS instruction until the respective atomic reference is updated. </span><span class="koboSpan" id="kobo.60.2">When picking a bucket, the processor must aim for a bucket that no other processor is currently using, to prevent contention and retries. </span><span class="koboSpan" id="kobo.60.3">There are many ways to achieve this, but we will settle for a relatively simple strategy--we compute the bucket from the thread ID, and the hash code of the element. </span><span class="koboSpan" id="kobo.60.4">Once the bucket is picked, the </span><code class="literal"><span class="koboSpan" id="kobo.61.1">add</span></code><span class="koboSpan" id="kobo.62.1"> operation follows the standard retry pattern that we saw earlier. </span><span class="koboSpan" id="kobo.62.2">This is shown in the following snippet:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.63.1">  def add(x: T): Unit = { 
    val i = 
      (Thread.currentThread.getId ^ x.## % buckets.length).toInt 
    @tailrec def retry() { 
      val bucket = buckets(i) 
      val v = bucket.get 
      val (lst, stamp) = v 
      val nlst = x :: lst 
      val nstamp = stamp + 1 
      val nv = (nlst, nstamp) 
      if (!bucket.compareAndSet(v, nv)) retry() 
    } 
    retry() 
  } 
</span></pre><p><span class="koboSpan" id="kobo.64.1">The </span><code class="literal"><span class="koboSpan" id="kobo.65.1">remove</span></code><span class="koboSpan" id="kobo.66.1"> operation is more complex. </span><span class="koboSpan" id="kobo.66.2">Unlike the </span><code class="literal"><span class="koboSpan" id="kobo.67.1">add</span></code><span class="koboSpan" id="kobo.68.1"> operation, which can pick any bucket when inserting an element, the </span><code class="literal"><span class="koboSpan" id="kobo.69.1">remove</span></code><span class="koboSpan" id="kobo.70.1"> operation must pick a non-empty bucket. </span><span class="koboSpan" id="kobo.70.2">The current design of the data structure offers no apriori way of knowing which bucket is non-empty, so the best we can do is pick some bucket, and scan the other buckets linearly until finding a non-empty bucket. </span><span class="koboSpan" id="kobo.70.3">This has two consequences. </span><span class="koboSpan" id="kobo.70.4">First, if our concurrent pool is nearly empty, we will need to scan all the buckets in the worst case scenario. </span><span class="koboSpan" id="kobo.70.5">The </span><code class="literal"><span class="koboSpan" id="kobo.71.1">remove</span></code><span class="koboSpan" id="kobo.72.1"> operation is only scalable if the pool is relatively full. </span><span class="koboSpan" id="kobo.72.2">Second, when the pool is almost empty, it is impossible to atomically scan all the entries. </span><span class="koboSpan" id="kobo.72.3">It can happen that, during the scan, one thread inserts an element to a bucket we already traversed, and another thread removes an element from a non-traversed bucket. </span><span class="koboSpan" id="kobo.72.4">In this case, the </span><code class="literal"><span class="koboSpan" id="kobo.73.1">remove</span></code><span class="koboSpan" id="kobo.74.1"> operation could falsely conclude that the pool is empty, which was never the case.</span></p><p><span class="koboSpan" id="kobo.75.1">To address the second issue, we use the timestamps associated with each bucket. </span><span class="koboSpan" id="kobo.75.2">Recall that each timestamp is incremented when the respective bucket is modified. </span><span class="koboSpan" id="kobo.75.3">Therefore, if the sum of the timestamps remains constant, then no operation was executed on the pool. </span><span class="koboSpan" id="kobo.75.4">We can use this fact as follows. </span><span class="koboSpan" id="kobo.75.5">If we scan the bucket array twice, and see that the timestamp sum did not change, we can conclude that there have been no updates to the pool. </span><span class="koboSpan" id="kobo.75.6">This is crucial for the </span><code class="literal"><span class="koboSpan" id="kobo.76.1">remove</span></code><span class="koboSpan" id="kobo.77.1"> operation, which will use this information to know when to terminate.</span></p><p><span class="koboSpan" id="kobo.78.1">The </span><code class="literal"><span class="koboSpan" id="kobo.79.1">remove</span></code><span class="koboSpan" id="kobo.80.1"> operation starts by picking a bucket based on the current thread ID, and then starting a tail-recursive </span><code class="literal"><span class="koboSpan" id="kobo.81.1">scan</span></code><span class="koboSpan" id="kobo.82.1"> method. </span><span class="koboSpan" id="kobo.82.2">The </span><code class="literal"><span class="koboSpan" id="kobo.83.1">scan</span></code><span class="koboSpan" id="kobo.84.1"> method traverses the array, searching for non-empty buckets. </span><span class="koboSpan" id="kobo.84.2">When an empty bucket is observed, its timestamp is added to the </span><code class="literal"><span class="koboSpan" id="kobo.85.1">sum</span></code><span class="koboSpan" id="kobo.86.1"> local variable. </span><span class="koboSpan" id="kobo.86.2">When a non-empty bucket is found, the standard CAS pattern attempts to remove an element from the bucket in the </span><code class="literal"><span class="koboSpan" id="kobo.87.1">retry</span></code><span class="koboSpan" id="kobo.88.1"> method. </span><span class="koboSpan" id="kobo.88.2">If successful, the element is immediately removed from the </span><code class="literal"><span class="koboSpan" id="kobo.89.1">remove</span></code><span class="koboSpan" id="kobo.90.1"> operation. </span><span class="koboSpan" id="kobo.90.2">Otherwise, if upon traversing the array the previous timestamp sum is equal to the current sum, the </span><code class="literal"><span class="koboSpan" id="kobo.91.1">scan</span></code><span class="koboSpan" id="kobo.92.1"> method terminates. </span><span class="koboSpan" id="kobo.92.2">This is shown in the following snippet:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.93.1">  def remove(): Option[T] = { 
    val start = 
      (Thread.currentThread.getId % buckets.length).toInt 
    @tailrec def scan(witness: Long): Option[T] = { 
      var i = (start + 1) % buckets.length 
      var sum = 0L 
      while (i != start) { 
        val bucket = buckets(i) 
 
        @tailrec def retry(): Option[T] = { 
          bucket.get match { 
            case (Nil, stamp) =&gt; 
              sum += stamp 
              None 
            case v @ (lst, stamp) =&gt; 
              val nv = (lst.tail, stamp + 1) 
              if (bucket.compareAndSet(v, nv)) Some(lst.head) 
              else retry() 
          } 
        } 
        retry() match { 
          case Some(v) =&gt; return Some(v) 
          case None =&gt; 
        } 
 
        i = (i + 1) % buckets.length 
      } 
      if (sum == witness) None 
      else scan(sum) 
    } 
    scan(-1L) 
  } 
} 
</span></pre><p><span class="koboSpan" id="kobo.94.1">We test the concurrent pool as follows. </span><span class="koboSpan" id="kobo.94.2">First, we instantiate a concurrent hash map that will track the elements we removed. </span><span class="koboSpan" id="kobo.94.3">Then, we create a concurrent pool, and set the number of threads </span><code class="literal"><span class="koboSpan" id="kobo.95.1">p</span></code><span class="koboSpan" id="kobo.96.1"> and the number of elements </span><code class="literal"><span class="koboSpan" id="kobo.97.1">num</span></code><span class="koboSpan" id="kobo.98.1">:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.99.1">val check = new ConcurrentHashMap[Int, Unit]() 
val pool = new Pool[Int] 
val p = 8 
val num = 1000000 
</span></pre><p><span class="koboSpan" id="kobo.100.1">We first start </span><code class="literal"><span class="koboSpan" id="kobo.101.1">p</span></code><span class="koboSpan" id="kobo.102.1"> inserter threads, which insert non-overlapping ranges of integers into the pool. </span><span class="koboSpan" id="kobo.102.2">We then wait for the threads to complete:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.103.1">val inserters = for (i &lt;- 0 until p) yield ch2.thread { 
  for (j &lt;- 0 until num) pool.add(i * num + j) 
} 
inserters.foreach(_.join()) 
</span></pre><p><span class="koboSpan" id="kobo.104.1">We similarly start </span><code class="literal"><span class="koboSpan" id="kobo.105.1">p</span></code><span class="koboSpan" id="kobo.106.1"> remover threads, which remove the elements from the pool, and store the removed elements to the </span><code class="literal"><span class="koboSpan" id="kobo.107.1">check</span></code><span class="koboSpan" id="kobo.108.1"> hash map we created earlier. </span><span class="koboSpan" id="kobo.108.2">Each thread removes </span><code class="literal"><span class="koboSpan" id="kobo.109.1">num</span></code><span class="koboSpan" id="kobo.110.1"> elements, so the pool should never be empty until all the threads complete:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.111.1">val removers = for (i &lt;- 0 until p) yield ch2.thread { 
  for (j &lt;- 0 until num) { 
    pool.remove() match { 
      case Some(v) =&gt; check.put(v, ()) 
      case None =&gt; sys.error("Should be non-empty.") 
    } 
  } 
} 
removers.foreach(_.join()) 
</span></pre><p><span class="koboSpan" id="kobo.112.1">At the end, we sequentially traverse the elements we expect to see in the </span><code class="literal"><span class="koboSpan" id="kobo.113.1">check</span></code><span class="koboSpan" id="kobo.114.1"> hash map, and assert that they are contained, as shown in the following snippet:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.115.1">for (i &lt;- 0 until (num * p)) assert(check.containsKey(i)) 
</span></pre><p><span class="koboSpan" id="kobo.116.1">And this is it! </span><span class="koboSpan" id="kobo.116.2">We have verified that our concurrent pool implementation works correctly. </span><span class="koboSpan" id="kobo.116.3">Although we will not prove this, we loosely claim that the </span><code class="literal"><span class="koboSpan" id="kobo.117.1">add</span></code><span class="koboSpan" id="kobo.118.1"> operation runs in the expected </span><span class="emphasis"><em><span class="koboSpan" id="kobo.119.1">O(1)</span></em></span><span class="koboSpan" id="kobo.120.1"> time, the </span><code class="literal"><span class="koboSpan" id="kobo.121.1">remove</span></code><span class="koboSpan" id="kobo.122.1"> operation runs in the expected </span><span class="emphasis"><em><span class="koboSpan" id="kobo.123.1">O(1)</span></em></span><span class="koboSpan" id="kobo.124.1"> time when the pool has enough elements, and in the expected </span><span class="emphasis"><em><span class="koboSpan" id="kobo.125.1">O(P)</span></em></span><span class="koboSpan" id="kobo.126.1"> time when the queue is nearly empty. </span><span class="koboSpan" id="kobo.126.2">As an exercise, you can try to improve the </span><code class="literal"><span class="koboSpan" id="kobo.127.1">remove</span></code><span class="koboSpan" id="kobo.128.1"> operation, so that it always runs in the expected </span><span class="emphasis"><em><span class="koboSpan" id="kobo.129.1">O(1)</span></em></span><span class="koboSpan" id="kobo.130.1"> time.</span></p></div><div class="section" title="Creating and handling processes"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec30"/><span class="koboSpan" id="kobo.131.1">Creating and handling processes</span></h2></div></div></div><p><span class="koboSpan" id="kobo.132.1">So far, we focused on concurrency within a Scala program running in a single JVM process. </span><span class="koboSpan" id="kobo.132.2">Whenever we wanted to allow multiple computations to proceed concurrently, we created new threads or sent </span><code class="literal"><span class="koboSpan" id="kobo.133.1">Runnable</span></code><span class="koboSpan" id="kobo.134.1"> objects to </span><code class="literal"><span class="koboSpan" id="kobo.135.1">Executor</span></code><span class="koboSpan" id="kobo.136.1"> threads. </span><span class="koboSpan" id="kobo.136.2">Another route to concurrency is to create separate processes. </span><span class="koboSpan" id="kobo.136.3">As explained in </span><a class="link" href="ch02.html" title="Chapter 2. Concurrency on the JVM and the Java Memory Model"><span class="koboSpan" id="kobo.137.1">Chapter 2</span></a><span class="koboSpan" id="kobo.138.1">, </span><span class="emphasis"><em><span class="koboSpan" id="kobo.139.1">Concurrency on the JVM and the Java Memory Model</span></em></span><span class="koboSpan" id="kobo.140.1">, separate processes have separate memory spaces and cannot share the memory directly.</span></p><p><span class="koboSpan" id="kobo.141.1">There are several reasons why we occasionally want to do this. </span><span class="koboSpan" id="kobo.141.2">First, while JVM has a very rich ecosystem with thousands of software libraries for all kinds of tasks, sometimes the only available implementation of a certain software component is a command-line utility or prepackaged program. </span><span class="koboSpan" id="kobo.141.3">Running it in a new process could be the only way to harvest its functionality. </span><span class="koboSpan" id="kobo.141.4">Second, sometimes we want to put Scala or Java code that we do not trust in a sandbox. </span><span class="koboSpan" id="kobo.141.5">A third-party plugin might have to run with a reduced set of permissions. </span><span class="koboSpan" id="kobo.141.6">Third, sometimes we just don't want to run in the same JVM process for performance reasons. </span><span class="koboSpan" id="kobo.141.7">Garbage collection or JIT compilation in a separate process should not affect the execution of our process, given that the machine has sufficient CPUs.</span></p><p><span class="koboSpan" id="kobo.142.1">The </span><code class="literal"><span class="koboSpan" id="kobo.143.1">scala.sys.process</span></code><span class="koboSpan" id="kobo.144.1"> package contains a concise API for dealing with other processes. </span><span class="koboSpan" id="kobo.144.2">We can run the child process synchronously, in which case the thread from the parent process that runs it waits until the child process terminates, or asynchronously, in which case, the child process runs concurrently with the calling thread from the parent process. </span><span class="koboSpan" id="kobo.144.3">We will first show you how to run a new process synchronously:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.145.1">import scala.sys.process._ 
object ProcessRun extends App { 
  val command = "ls" 
  val exitcode = command.! 
  </span><span class="koboSpan" id="kobo.145.2">log(s"command exited with status $exitcode") 
} 
</span></pre><p><span class="koboSpan" id="kobo.146.1">Importing the contents of the </span><code class="literal"><span class="koboSpan" id="kobo.147.1">scala.sys.process</span></code><span class="koboSpan" id="kobo.148.1"> package allows us to call the </span><code class="literal"><span class="koboSpan" id="kobo.149.1">!</span></code><span class="koboSpan" id="kobo.150.1"> method on any string. </span><span class="koboSpan" id="kobo.150.2">The shell command represented by the string is then run from the working directory of the current process. </span><span class="koboSpan" id="kobo.150.3">The return value is the exit code of the new process--zero when the process exits successfully and a nonzero error code otherwise.</span></p><p><span class="koboSpan" id="kobo.151.1">Sometimes, we are interested in the standard output of a process rather than its exit code. </span><span class="koboSpan" id="kobo.151.2">In this case, we start the process with the</span><code class="literal"><span class="koboSpan" id="kobo.152.1">!!</span></code><span class="koboSpan" id="kobo.153.1"> method. </span><span class="koboSpan" id="kobo.153.2">Let's assume that we want a </span><code class="literal"><span class="koboSpan" id="kobo.154.1">lineCount</span></code><span class="koboSpan" id="kobo.155.1"> method for text files in </span><code class="literal"><span class="koboSpan" id="kobo.156.1">FileSystem</span></code><span class="koboSpan" id="kobo.157.1">, but are too lazy to implement it from scratch:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.158.1">def lineCount(filename: String): Int = { 
  val output = s"wc $filename".!! 
  </span><span class="koboSpan" id="kobo.158.2">output.trim.split(" ").head.toInt 
} 
</span></pre><p><span class="koboSpan" id="kobo.159.1">After removing the white space from the output with the </span><code class="literal"><span class="koboSpan" id="kobo.160.1">trim</span></code><span class="koboSpan" id="kobo.161.1"> method on </span><code class="literal"><span class="koboSpan" id="kobo.162.1">String</span></code><span class="koboSpan" id="kobo.163.1"> type and converting the first part of the output to an integer, we obtain the word count of a file.</span></p><p><span class="koboSpan" id="kobo.164.1">To start the process asynchronously, we call the </span><code class="literal"><span class="koboSpan" id="kobo.165.1">run</span></code><span class="koboSpan" id="kobo.166.1"> method on a string that represents the command. </span><span class="koboSpan" id="kobo.166.2">This method returns a </span><code class="literal"><span class="koboSpan" id="kobo.167.1">Process</span></code><span class="koboSpan" id="kobo.168.1"> object with the </span><code class="literal"><span class="koboSpan" id="kobo.169.1">exitValue</span></code><span class="koboSpan" id="kobo.170.1"> method, which is blocked until the process terminates, and the </span><code class="literal"><span class="koboSpan" id="kobo.171.1">destroy</span></code><span class="koboSpan" id="kobo.172.1"> method, which stops the process immediately. </span><span class="koboSpan" id="kobo.172.2">Assume that we have a potentially long-running process that lists all the files in our filesystem. </span><span class="koboSpan" id="kobo.172.3">After one second, we might wish to stop it by calling the </span><code class="literal"><span class="koboSpan" id="kobo.173.1">destroy</span></code><span class="koboSpan" id="kobo.174.1"> method on the </span><code class="literal"><span class="koboSpan" id="kobo.175.1">Process</span></code><span class="koboSpan" id="kobo.176.1"> object:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.177.1">object ProcessAsync extends App { 
  val lsProcess = "ls -R /".run() 
  Thread.sleep(1000) 
  log("Timeout - killing ls!") 
  lsProcess.destroy() 
} 
</span></pre><p><span class="koboSpan" id="kobo.178.1">Overloads of the </span><code class="literal"><span class="koboSpan" id="kobo.179.1">run</span></code><span class="koboSpan" id="kobo.180.1"> method allow you to communicate with the process by hooking the custom input and output streams or providing a custom </span><code class="literal"><span class="koboSpan" id="kobo.181.1">logger</span></code><span class="koboSpan" id="kobo.182.1"> object that is called each time the new process outputs a line.</span></p><p><span class="koboSpan" id="kobo.183.1">The </span><code class="literal"><span class="koboSpan" id="kobo.184.1">scala.sys.process</span></code><span class="koboSpan" id="kobo.185.1"> API has additional features such as starting multiple processes and piping their outputs together, running a different process if the current process fails, or redirecting the output to a file. </span><span class="koboSpan" id="kobo.185.2">It strives to mimic much of the functionality provided by the Unix shells. </span><span class="koboSpan" id="kobo.185.3">For complete information, we refer the reader to the Scala standard library's documentation of the </span><code class="literal"><span class="koboSpan" id="kobo.186.1">scala.sys.process</span></code><span class="koboSpan" id="kobo.187.1"> package.</span></p></div></div></div></div>
<div id="book-columns"><div id="book-inner"><div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec24"/><span class="koboSpan" id="kobo.1.1">Summary</span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">This chapter presented the traditional building blocks of concurrent programs in Scala. </span><span class="koboSpan" id="kobo.2.2">We saw how to use </span><code class="literal"><span class="koboSpan" id="kobo.3.1">Executor</span></code><span class="koboSpan" id="kobo.4.1"> objects to run concurrent computations. </span><span class="koboSpan" id="kobo.4.2">We learned how to use atomic primitives to atomically switch between different states in the program and implement locks and lock-free algorithms. </span><span class="koboSpan" id="kobo.4.3">We studied the implementation of lazy values and their impact on concurrent programs. </span><span class="koboSpan" id="kobo.4.4">We then showed you important classes of concurrent collections and learned how to apply them in practice, and we concluded by visiting the </span><code class="literal"><span class="koboSpan" id="kobo.5.1">scala.sys.process</span></code><span class="koboSpan" id="kobo.6.1"> package. </span><span class="koboSpan" id="kobo.6.2">These insights are not only specific to Scala; but most languages and platforms also have concurrency utilities that are similar to the ones presented in this chapter.</span></p><p><span class="koboSpan" id="kobo.7.1">Many other Java concurrency APIs are thoroughly explained in the book </span><span class="emphasis"><em><span class="koboSpan" id="kobo.8.1">Java Concurrency in Practice</span></em></span><span class="koboSpan" id="kobo.9.1">, by Brian Goetz, Tim Peierls, Joshua Bloch, Joseph Bowbeer, David Holmes, and Doug Lea. </span><span class="koboSpan" id="kobo.9.2">To learn more about concepts such as lock-freedom, atomic variables, various types of locks, or concurrent data structures, we recommend the book </span><span class="emphasis"><em><span class="koboSpan" id="kobo.10.1">The Art of Multiprocessor Programming</span></em></span><span class="koboSpan" id="kobo.11.1"> by Maurice Herlihy and Nir Shavit, Morgan Kaufmann.</span></p><p><span class="koboSpan" id="kobo.12.1">Although the concurrency building blocks in this chapter are more high level than the basic concurrency primitives of </span><a class="link" href="ch02.html" title="Chapter 2. Concurrency on the JVM and the Java Memory Model"><span class="koboSpan" id="kobo.13.1">Chapter 2</span></a><span class="koboSpan" id="kobo.14.1">, </span><span class="emphasis"><em><span class="koboSpan" id="kobo.15.1">Concurrency on the JVM and the Java Memory Model</span></em></span><span class="koboSpan" id="kobo.16.1">, there are still culprits lurking at every corner. </span><span class="koboSpan" id="kobo.16.2">We had to be careful not to block when running on the execution context, to steer clear from the ABA problem, avoid synchronizing on objects that use lazy values, and ensure that concurrent collections are not modified while using their iterators. </span><span class="koboSpan" id="kobo.16.3">All this imposes quite a burden on the programmer. </span><span class="koboSpan" id="kobo.16.4">Couldn't concurrent programming be simpler? </span><span class="koboSpan" id="kobo.16.5">Fortunately, the answer is yes, as Scala supports styles of expressing concurrency that are more high level and declarative; less prone to effects such as deadlocks, starvation, or non-determinism; and generally easier to reason about. </span><span class="koboSpan" id="kobo.16.6">In the following chapters, we will dive into Scala-specific concurrency APIs that are safer and more intuitive to use. </span><span class="koboSpan" id="kobo.16.7">We will start by studying futures and promises in the next chapter, which allow you to compose asynchronous computations in a thread-safe and intuitive way.</span></p></div></div></div>
<div id="book-columns"><div id="book-inner"><div class="section" title="Exercises"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec25"/><span class="koboSpan" id="kobo.1.1">Exercises</span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">The following exercises cover the various topics from this chapter. </span><span class="koboSpan" id="kobo.2.2">Most of the exercises require implementing new concurrent data structures using atomic variables and the CAS instruction. </span><span class="koboSpan" id="kobo.2.3">These data structures can also be solved using the </span><code class="literal"><span class="koboSpan" id="kobo.3.1">synchronized</span></code><span class="koboSpan" id="kobo.4.1"> statement, so it is helpful to contrast the advantages of the two approaches:</span></p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem"><span class="koboSpan" id="kobo.5.1">Implement a custom </span><code class="literal"><span class="koboSpan" id="kobo.6.1">ExecutionContext</span></code><span class="koboSpan" id="kobo.7.1"> class called </span><code class="literal"><span class="koboSpan" id="kobo.8.1">PiggybackContext</span></code><span class="koboSpan" id="kobo.9.1">, which executes </span><code class="literal"><span class="koboSpan" id="kobo.10.1">Runnable</span></code><span class="koboSpan" id="kobo.11.1"> objects on the same thread that calls the </span><code class="literal"><span class="koboSpan" id="kobo.12.1">execute</span></code><span class="koboSpan" id="kobo.13.1"> method. </span><span class="koboSpan" id="kobo.13.2">Ensure that a </span><code class="literal"><span class="koboSpan" id="kobo.14.1">Runnable</span></code><span class="koboSpan" id="kobo.15.1"> object executing on the </span><code class="literal"><span class="koboSpan" id="kobo.16.1">PiggybackContext</span></code><span class="koboSpan" id="kobo.17.1"> can also call the </span><code class="literal"><span class="koboSpan" id="kobo.18.1">execute</span></code><span class="koboSpan" id="kobo.19.1"> method and that exceptions are properly reported.</span></li><li class="listitem"><span class="koboSpan" id="kobo.20.1">Implement a </span><code class="literal"><span class="koboSpan" id="kobo.21.1">TreiberStack</span></code><span class="koboSpan" id="kobo.22.1"> class, which implements a concurrent stack abstraction:</span><pre class="programlisting"><span class="koboSpan" id="kobo.23.1">            class TreiberStack[T] { 
              def push(x: T): Unit = ??? 
              </span><span class="koboSpan" id="kobo.23.2">def pop(): T = ??? 
            </span><span class="koboSpan" id="kobo.23.3">} 
</span></pre><p><span class="koboSpan" id="kobo.24.1">Use an atomic reference variable that points to a linked list of nodes that were previously pushed to the stack. </span><span class="koboSpan" id="kobo.24.2">Make sure that your implementation is lock-free and not susceptible to the ABA problem.</span></p></li><li class="listitem"><span class="koboSpan" id="kobo.25.1">Implement a </span><code class="literal"><span class="koboSpan" id="kobo.26.1">ConcurrentSortedList</span></code><span class="koboSpan" id="kobo.27.1"> class, which implements a concurrent sorted list abstraction:</span><pre class="programlisting"><span class="koboSpan" id="kobo.28.1">            class ConcurrentSortedList[T](implicit val ord: Ordering[T]) { 
               def add(x: T): Unit = ??? 
               </span><span class="koboSpan" id="kobo.28.2">def iterator: Iterator[T] = ???  
            </span><span class="koboSpan" id="kobo.28.3">} 
</span></pre><p><span class="koboSpan" id="kobo.29.1">Under the hood, the </span><code class="literal"><span class="koboSpan" id="kobo.30.1">ConcurrentSortedList</span></code><span class="koboSpan" id="kobo.31.1"> class should use a linked list of atomic references. </span><span class="koboSpan" id="kobo.31.2">Ensure that your implementation is lock-free and avoids ABA problems.</span></p><p><span class="koboSpan" id="kobo.32.1">The </span><code class="literal"><span class="koboSpan" id="kobo.33.1">Iterator</span></code><span class="koboSpan" id="kobo.34.1"> object returned by the </span><code class="literal"><span class="koboSpan" id="kobo.35.1">iterator</span></code><span class="koboSpan" id="kobo.36.1"> method must correctly traverse the elements of the list in ascending order under the assumption that there are no concurrent invocations of the </span><code class="literal"><span class="koboSpan" id="kobo.37.1">add</span></code><span class="koboSpan" id="kobo.38.1"> method.</span></p></li><li class="listitem"><span class="koboSpan" id="kobo.39.1">If required, modify the </span><code class="literal"><span class="koboSpan" id="kobo.40.1">ConcurrentSortedList</span></code><span class="koboSpan" id="kobo.41.1"> class from the previous example so that calling the </span><code class="literal"><span class="koboSpan" id="kobo.42.1">add</span></code><span class="koboSpan" id="kobo.43.1"> method has the running time linear to the length of the list and creates a constant number of new objects when there are no retries due to concurrent </span><code class="literal"><span class="koboSpan" id="kobo.44.1">add</span></code><span class="koboSpan" id="kobo.45.1"> invocations.</span></li><li class="listitem"><span class="koboSpan" id="kobo.46.1">Implement a </span><code class="literal"><span class="koboSpan" id="kobo.47.1">LazyCell</span></code><span class="koboSpan" id="kobo.48.1"> class with the following interface:</span><pre class="programlisting"><span class="koboSpan" id="kobo.49.1">            class LazyCell[T](initialization: =&gt;T) { 
              def apply(): T = ??? 
            </span><span class="koboSpan" id="kobo.49.2">} 
</span></pre><p><span class="koboSpan" id="kobo.50.1">Creating a </span><code class="literal"><span class="koboSpan" id="kobo.51.1">LazyCell</span></code><span class="koboSpan" id="kobo.52.1"> object and calling the </span><code class="literal"><span class="koboSpan" id="kobo.53.1">apply</span></code><span class="koboSpan" id="kobo.54.1"> method must have the same semantics as declaring a lazy value and reading it, respectively.</span></p><p><span class="koboSpan" id="kobo.55.1">You are not allowed to use lazy values in your implementation.</span></p></li><li class="listitem"><span class="koboSpan" id="kobo.56.1">Implement a </span><code class="literal"><span class="koboSpan" id="kobo.57.1">PureLazyCell</span></code><span class="koboSpan" id="kobo.58.1"> class with the same interface and semantics as the </span><code class="literal"><span class="koboSpan" id="kobo.59.1">LazyCell</span></code><span class="koboSpan" id="kobo.60.1"> class from the previous exercise. </span><span class="koboSpan" id="kobo.60.2">The </span><code class="literal"><span class="koboSpan" id="kobo.61.1">PureLazyCell</span></code><span class="koboSpan" id="kobo.62.1"> class assumes that the initialization parameter does not cause side effects, so it can be evaluated more than once.</span><p><span class="koboSpan" id="kobo.63.1">The </span><code class="literal"><span class="koboSpan" id="kobo.64.1">apply</span></code><span class="koboSpan" id="kobo.65.1"> method must be lock-free and should call the initialization as little as possible.</span></p></li><li class="listitem"><span class="koboSpan" id="kobo.66.1">Implement a </span><code class="literal"><span class="koboSpan" id="kobo.67.1">SyncConcurrentMap</span></code><span class="koboSpan" id="kobo.68.1"> class that extends the </span><code class="literal"><span class="koboSpan" id="kobo.69.1">Map</span></code><span class="koboSpan" id="kobo.70.1"> interface from the </span><code class="literal"><span class="koboSpan" id="kobo.71.1">scala.collection.concurrent</span></code><span class="koboSpan" id="kobo.72.1"> package. </span><span class="koboSpan" id="kobo.72.2">Use the </span><code class="literal"><span class="koboSpan" id="kobo.73.1">synchronized</span></code><span class="koboSpan" id="kobo.74.1"> statement to protect the state of the concurrent map.</span></li><li class="listitem"><span class="koboSpan" id="kobo.75.1">Implement a method </span><code class="literal"><span class="koboSpan" id="kobo.76.1">spawn</span></code><span class="koboSpan" id="kobo.77.1"> that, given a block of Scala code, starts a new JVM process and runs the specified block in the new process:</span><pre class="programlisting"><span class="koboSpan" id="kobo.78.1">            def spawn[T](block: =&gt;T): T = ??? 
</span></pre><p><span class="koboSpan" id="kobo.79.1">Once the block returns a value, the </span><code class="literal"><span class="koboSpan" id="kobo.80.1">spawn</span></code><span class="koboSpan" id="kobo.81.1"> method should return the value from the child process. </span><span class="koboSpan" id="kobo.81.2">If the block throws an exception, the </span><code class="literal"><span class="koboSpan" id="kobo.82.1">spawn</span></code><span class="koboSpan" id="kobo.83.1"> method should throw the same exception.</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip33"/><span class="koboSpan" id="kobo.84.1">Tip</span></h3><p><span class="koboSpan" id="kobo.85.1">Use Java serialization to transfer the block of code, its return value, and the potential exceptions between the parent and the child JVM processes.</span></p></div></div></li><li class="listitem"><span class="koboSpan" id="kobo.86.1">Augment the lock-free pool implementation from this chapter with a </span><code class="literal"><span class="koboSpan" id="kobo.87.1">foreach</span></code><span class="koboSpan" id="kobo.88.1"> operation, used to traverse all the elements in the pool. </span><span class="koboSpan" id="kobo.88.2">Then make another version of </span><code class="literal"><span class="koboSpan" id="kobo.89.1">foreach</span></code><span class="koboSpan" id="kobo.90.1"> that is both lock-free and linearizable.</span></li><li class="listitem"><span class="koboSpan" id="kobo.91.1">Prove that the lock-free pool implementation from this chapter is correct.</span></li><li class="listitem"><span class="koboSpan" id="kobo.92.1">Currently, the </span><code class="literal"><span class="koboSpan" id="kobo.93.1">remove</span></code><span class="koboSpan" id="kobo.94.1"> operation of the lock-free pool implementation from this chapter runs in </span><span class="emphasis"><em><span class="koboSpan" id="kobo.95.1">O(P)</span></em></span><span class="koboSpan" id="kobo.96.1"> worst-case time, where </span><span class="emphasis"><em><span class="koboSpan" id="kobo.97.1">P</span></em></span><span class="koboSpan" id="kobo.98.1"> is the number of processors on the machine. </span><span class="koboSpan" id="kobo.98.2">Improve the lock-free pool implementation so that the operations run in </span><span class="emphasis"><em><span class="koboSpan" id="kobo.99.1">O(1)</span></em></span><span class="koboSpan" id="kobo.100.1"> expected time, both in terms of the number of stored elements and the number of processors.</span></li></ol></div></div></div></div></body></html>