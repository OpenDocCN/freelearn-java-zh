- en: '*Chapter 17*: Best Practices for Writing High-Quality Code'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When programmers talk to each other, they often use jargon that cannot be understood
    by non-programmers, or is vaguely understood by the programmers of different programming
    languages. But those who use the same programming language understand each other
    just fine. Sometimes, it may also depend on how knowledgeable a programmer is.
    A novice may not understand what an experienced programmer is talking about, while
    a seasoned colleague nods and responds in kind. This chapter is designed to fill
    this gap and improve the understanding between programmers of different levels.
    In this chapter, we will discuss some Java programming jargon – the Java idioms
    that describe certain features, functionality, design solutions, and so on. You
    will also learn about the most popular and useful practices for designing and
    writing application code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Java idioms, their implementation, and their usage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `equals()`, `hashCode()`, `compareTo()`, and `clone()` methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `StringBuffer` and `StringBuilder` classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `try`, `catch`, and `finally` clauses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Best design practices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code is written for people
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use well-established frameworks and libraries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing is the shortest path to quality code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have a solid understanding of what other
    Java programmers are talking about while discussing their design decisions and
    the functionality they use.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To execute the code examples provided in this chapter, you will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A computer with either Microsoft Windows, Apple macOS, or Linux
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Java SE version 17 or later
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An IDE or code editor of your choice
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The instructions for how to set up a Java SE and IntelliJ IDEA editor were provided
    in [*Chapter 1*](B18388_01_ePub.xhtml#_idTextAnchor015)*,* *Getting Started with
    Java 17*. The files containing the code examples for this chapter are available
    on GitHub at [https://github.com/PacktPublishing/Learn-Java-17-Programming.git](https://github.com/PacktPublishing/Learn-Java-17-Programming.git)
    in the examples/src/main/java/com/packt/learnjava/ch17_bestpractices folder and
    in the `spring` and `reactive` folders.
  prefs: []
  type: TYPE_NORMAL
- en: Java idioms, their implementation, and their usage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In addition to serving as a means of communication among professionals, programming
    idioms are also proven programming solutions and common practices not directly
    derived from the language specification but born out of the programming experience.
    In this section, we are going to discuss the ones that are used most often. You
    can find and study the full list of idioms in the official Java documentation
    ([https://docs.oracle.com/javase/tutorial](https://docs.oracle.com/javase/tutorial)).
  prefs: []
  type: TYPE_NORMAL
- en: The equals() and hashCode() methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The default implementation of the `equals()` and `hashCode()` methods in the
    `java.lang.Object` class looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the default implementation of the `equals()` method only compares
    memory references that point to the addresses where the objects are stored. Similarly,
    as you can see from the comments (quoted from the source code), the `hashCode()`
    method returns the same integer for the same object and a different integer for
    different objects. Let’s demonstrate this using the `Person` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is an example of how the default `equals()` and `hashCode()` methods behave:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The output in your system might be slightly different.
  prefs: []
  type: TYPE_NORMAL
- en: The `person1` and `person2` references and their hash codes are equal because
    they point to the same object (the same area of memory and the same address),
    while the `person3` reference points to another object.
  prefs: []
  type: TYPE_NORMAL
- en: 'In practice, though, as we described in [*Chapter 6*](B18388_06_ePub.xhtml#_idTextAnchor141),
    *Data Structures, Generics, and Popular Utilities*, we would like the equality
    of the object to be based on the value of all or some of the object properties.
    So, here is a typical implementation of the `equals()` and `hashCode()` methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: It used to be more involved, but using `java.util.Objects` utilities makes it
    much easier, especially if you notice that the `Objects.equals()` method handles
    `null` too.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we have added the described implementation of the `equals()` and `hashCode()`
    methods to the `Person1` class and executed the same comparisons:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the change we have made not only makes the same objects equal
    but makes two different objects with the same values of the properties equal too.
    Furthermore, the hash code value is now based on the values of the same properties
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 6*](B18388_06_ePub.xhtml#_idTextAnchor141), *Data Structures, Generics,
    and Popular Utilities*, we explained why it is important to implement the `hasCode()`
    method while implementing the `equals()` method.
  prefs: []
  type: TYPE_NORMAL
- en: The same set of properties must be used for establishing equality in the `equals()`
    method and for the hash calculation in the `hashCode()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Having the `@Override` annotation in front of these methods assures that they
    override the default implementation in the `Object` class. Otherwise, a typo in
    the method’s name may create the illusion that the new implementation is being
    used when it isn’t. Debugging such cases has proved much more difficult and costly
    than just adding the `@Override` annotation, which generates an error if the method
    does not override anything.
  prefs: []
  type: TYPE_NORMAL
- en: The compareTo() method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In [*Chapter 6*](B18388_06_ePub.xhtml#_idTextAnchor141), *Data Structures, Generics,
    and Popular Utilities*, we used the `compareTo()` method (the only method of the
    `Comparable` interface) extensively and pointed out that the order that is established
    based on this method (its implementation by the elements of a collection) is called
    a **natural order**.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate this, we created the `Person2` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we composed a list of `Person2` objects and sorted it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'The result looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18388_Figure_17.1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'There are three things worth noting:'
  prefs: []
  type: TYPE_NORMAL
- en: According to the `Comparable` interface, the `compareTo()` method must return
    a negative integer, zero, or a positive integer if the object is less than, equal
    to, or greater than another object. In our implementation, we returned the result
    immediately if the values of the same property of two objects were different.
    We already know that this object is *bigger* or *smaller*, regardless of what
    the other properties are. But the sequence in which you compare the properties
    of two objects, affects the final result. It defines the precedence in which the
    property value affects the order.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have put the result of `List.of()` into a `new ArrayList()` object. We did
    so because, as we mentioned in [*Chapter 6*](B18388_06_ePub.xhtml#_idTextAnchor141),
    *Data Structures, Generics, and Popular Utilities*, the collection that’s created
    by the `of()` factory method is unmodifiable. No elements can be added or removed
    from it and the order of the elements cannot be changed either, while we need
    to sort the created collection. We only used the `of()` method because it is more
    convenient and provides a shorter notation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, using `java.util.Objects` for comparing properties makes the implementation
    much easier and more reliable than custom coding.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'While implementing the `compareTo()` method, it is important to make sure that
    the following rules are not violated:'
  prefs: []
  type: TYPE_NORMAL
- en: '`obj1.compareTo(obj2)` returns the same value as `obj2.compareTo(obj1)`, but
    only when the returned value is `0`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the returned value is not `0`, `obj1.compareTo(obj2)` has the opposite sign
    of `obj2.compareTo(obj1)`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If `obj1.compareTo(obj2) > 0` and `obj2.compareTo(obj3) > 0`, then `obj1.compareTo(obj3)
    > 0`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If `obj1.compareTo(obj2) < 0` and `obj2.compareTo(obj3) < 0`, then `obj1.compareTo(obj3)
    < 0`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If `obj1.compareTo(obj2) == 0`, then `obj2.compareTo(obj3)` and `obj1.compareTo(obj3)
    > 0` have the same sign.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both `obj1.compareTo(obj2)` and `obj2.compareTo(obj1)` throw the same exceptions,
    if any.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is also recommended, but not always required, that if `obj1.equals(obj2)`,
    then `obj1.compareTo(obj2) == 0` and, at the same time, if `obj1.compareTo(obj2)
    == 0`, then `obj1.equals(obj2)`.
  prefs: []
  type: TYPE_NORMAL
- en: The clone() method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `clone()` method’s implementation in the `java.lang.Object` class looks
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'The comment shown in the preceding code states the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: The default result of this method returns a copy of the object fields as-is,
    which is fine if the values are of primitive types. However, if an object property
    holds a reference to another object, only the reference itself will be copied,
    not the referred object. That is why such a copy is called a `clone()` method
    and clone each of the object properties that refers to an object.
  prefs: []
  type: TYPE_NORMAL
- en: In any case, to be able to clone an object, it must implement the `Cloneable`
    interface and make sure that all the objects along the inheritance tree (and the
    properties that are objects) implement the `Cloneable` interface too (except the
    `java.lang.Object` class). The `Cloneable` interface is just a marker interface
    that tells the compiler that the programmer made a conscious decision to allow
    this object to be cloned (whether it’s because the shallow copy was good enough
    or because the `clone()` method was overridden). An attempt to call `clone()`
    on an object that does not implement the `Cloneable` interface will result in
    a `CloneNotSupportedException`.
  prefs: []
  type: TYPE_NORMAL
- en: 'It looks complex already, but in practice, there are even more pitfalls. For
    example, let’s say that the `Person` class has an `address` property of the `Address`
    type. The shallow copy, `p2`, of the `Person` object, `p1`, will refer to the
    same object of `Address` so that `p1.address == p2.address`. Here is an example.
    The `Address` class looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Person3` class uses it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that the `clone()` method does a shallow copy because it does not clone
    the `address` property. Here is the result of using such a `clone()` method implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, after the cloning is complete, the change that was made to the
    `address` property of the source object is reflected in the same property of the
    clone. That isn’t very intuitive, is it? While cloning, we expected an independent
    copy, didn’t we?
  prefs: []
  type: TYPE_NORMAL
- en: 'To avoid sharing the `Address` object, you must clone it explicitly too. To
    do so, you must make the `Address` object cloneable, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: 'With that implementation in place, we can now add the `address` property for
    cloning:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE189]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if we run the same test, the results are going to be as we expected them
    originally:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE193]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE194]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE195]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE196]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE197]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE198]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE199]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE200]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE201]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE202]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE203]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE204]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE205]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE206]'
  prefs: []
  type: TYPE_PRE
- en: So, if the application expects all the properties to be deeply copied, all the
    objects involved must be cloneable. That is fine so long as none of the related
    objects, whether it’s a property in the current object or the parent class (and
    their properties and parents), do not acquire a new object property without making
    them cloneable and are cloned explicitly in the `clone()` method of the container
    object. This last statement is complex. The reason for its complexity is due to
    the underlying complexity of the cloning process. That is why programmers often
    stay away from making objects cloneable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead, they prefer to clone the object manually, if need be, as shown in
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE207]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE208]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE209]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE210]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE211]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE212]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE213]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE214]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE215]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE216]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE217]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE218]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE219]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE220]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE221]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE222]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE223]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE224]'
  prefs: []
  type: TYPE_PRE
- en: This approach still requires code changes if another property is added to any
    related object. However, it provides more control over the result and has less
    chance of unexpected consequences.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, the `clone()` method is not used very often. You may never encounter
    a need to use it.
  prefs: []
  type: TYPE_NORMAL
- en: The StringBuffer and StringBuilder classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We talked about the difference between the `StringBuffer` and `StringBuilder`
    classes in [*Chapter 6*](B18388_06_ePub.xhtml#_idTextAnchor141), *Data Structures,
    Generics, and Popular Utilities*. We are not going to repeat this here. Instead,
    we will just mention that, in a single-threaded process (which is the vast majority
    of cases), the `StringBuilder` class is the preferred choice because it is faster.
  prefs: []
  type: TYPE_NORMAL
- en: The try, catch, and finally clauses
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[*Chapter 4*](B18388_04_ePub.xhtml#_idTextAnchor110), *Exception Handling*,
    is dedicated to using the `try`, `catch`, and `finally` clauses, so we are not
    going to repeat this here. We would like to repeat that using a `try-with-resources`
    statement is the preferred way to release resources (traditionally done in a `finally`
    block). Deferring the library makes the code simpler and more reliable.'
  prefs: []
  type: TYPE_NORMAL
- en: Best design practices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The term *best* is often subjective and context-dependent. That is why we would
    like to disclose that the following recommendations are based on the vast majority
    of cases in mainstream programming. However, they should not be followed blindly
    and unconditionally because there are cases when some of these practices, in some
    contexts, are useless or even wrong. Before following them, try to understand
    the motivation behind them and use it as a guide for your decisions. For example,
    size matters. If the application is not going to grow beyond a few thousand lines
    of code, a simple monolith with laundry-list-style code is good enough. But if
    there are complicated pockets of code and several people working on it, breaking
    the code into specialized pieces would be beneficial for code understanding, maintenance,
    and even scaling, if one particular code area requires more resources than others.
  prefs: []
  type: TYPE_NORMAL
- en: We will start with higher-level design decisions in no particular order.
  prefs: []
  type: TYPE_NORMAL
- en: Identifying loosely coupled functional areas
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'These design decisions can be made very early on, based just on the general
    understanding of the main parts of the future system, their functionality, and
    the data they produce and exchange. There are several benefits of doing this:'
  prefs: []
  type: TYPE_NORMAL
- en: You can identify the structure of the future system, which has bearings on the
    further design steps and implementation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can specialize in and analyze parts deeply
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can develop parts in parallel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can have a better understanding of the data flow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Breaking the functional area into traditional tiers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With each functional area in place, specializations based on the technical
    aspects and technologies can be used. The traditional separation of technical
    specialization is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The frontend (user graphic or web interface)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The middle tier with extensive business logic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The backend (data storage or data source)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The benefits of doing this include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: You can deploy and scale by tiers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can gain programmer specialization based on your expertise
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can develop parts in parallel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Coding to an interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The specialized parts, based on the decisions described in the previous two
    subsections, must be described in an interface that hides the implementation details.
    The benefits of such a design lie in the foundations of **object-oriented programming**
    (**OOP**) and were described in detail in [*Chapter 2*](B18388_02_ePub.xhtml#_idTextAnchor045),
    *Java Object-Oriented Programming (OOP)*, so we are not going to repeat this here.
  prefs: []
  type: TYPE_NORMAL
- en: Using factories
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We talked about this in [*Chapter 2*](B18388_02_ePub.xhtml#_idTextAnchor045),
    *Java Object-Oriented Programming (OOP)*, too. An interface, by definition, does
    not and cannot describe the constructor of a class that implements the interface.
    Using factories allows you to close this gap and expose just an interface to a
    client.
  prefs: []
  type: TYPE_NORMAL
- en: Preferring composition over inheritance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Originally, OOP focused on inheritance as a way to share the common functionality
    between objects. Inheritance is even one of the four OOP principles, as we have
    described in [*Chapter 2*](B18388_02_ePub.xhtml#_idTextAnchor045), *Java Object-Oriented
    Programming (OOP)*. In practice, however, this method of functionality sharing
    creates too much dependency between classes included in the same inheritance line.
    The evolution of application functionality is often unpredictable, and some of
    the classes in the inheritance chain start to acquire functionality that’s unrelated
    to the original purpose of the class chain. We can argue that there are design
    solutions that allow us not to do this and keep the original classes intact. But,
    in practice, such things happen all the time, and the subclasses may suddenly
    change behavior just because they acquired new functionality through inheritance.
    We cannot choose our parents, can we? Besides, it breaks encapsulation this way,
    which is another foundational principle of OOP.
  prefs: []
  type: TYPE_NORMAL
- en: Composition, on the other hand, allows us to choose and control which functionality
    of the class to use and which to ignore. It also allows the object to stay light
    and not be burdened by the inheritance. Such a design is more flexible, extensible,
    and predictable.
  prefs: []
  type: TYPE_NORMAL
- en: Using libraries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Throughout this book, we have mentioned that using the **Java Class Library**
    (**JCL**) and external (to the **Java Development Kit** (**JDK**)) Java libraries
    makes programming much easier and produces code of higher quality. [*Chapter 7*](B18388_07_ePub.xhtml#_idTextAnchor169),
    *Java Standard and External Libraries*, contains an overview of the most popular
    Java libraries. People who create libraries invest a lot of time and effort, so
    you should take advantage of them any time you can.
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 13*](B18388_13_ePub.xhtml#_idTextAnchor281), *Functional Programming*,
    we described standard functional interfaces that reside in the `java.util.function`
    package of JCL. That is another way to take advantage of a library – by using
    its set of well-known and shared interfaces, instead of defining your own.
  prefs: []
  type: TYPE_NORMAL
- en: This last statement is a good segue to the next topic about writing code that
    can easily be understood by other people.
  prefs: []
  type: TYPE_NORMAL
- en: Code is written for people
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first decades of programming required writing machine commands so that electronic
    devices could execute them. Not only was it a tedious and error-prone endeavor,
    but it also required you to write the instructions in a manner that yielded the
    best performance possible. This is because the computers were slow and did not
    do much code optimization, if at all.
  prefs: []
  type: TYPE_NORMAL
- en: Since then, we have made a lot of progress in terms of both hardware and programming.
    The modern compiler went a long way toward making the submitted code work as fast
    as possible, even when a programmer did not think about it. We talked about this
    with specific examples in the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: It allowed programmers to write more lines of code without thinking much about
    optimization. But tradition and many books about programming continued to call
    for it, and some programmers still worry about their code performance – more so
    than the results it produces. It is easier to follow tradition than to break away
    from it. That is why programmers tend to pay more attention to the way they write
    code than to the business they automate, although good code that implements incorrect
    business logic is useless.
  prefs: []
  type: TYPE_NORMAL
- en: However, back to the topic. With modern JVM, the need for code optimization
    by a programmer is not as pressing as it used to be. Nowadays, a programmer must
    pay attention mostly to the big picture, to avoid structural mistakes that lead
    to poor code performance and to code that is used multiple times. The latter becomes
    less pressing as the JVM becomes more sophisticated, observing the code in real
    time, and just returning the results (without execution) when the same code block
    is called several times with the same input.
  prefs: []
  type: TYPE_NORMAL
- en: That leaves us with the only conclusion possible – while writing code, you must
    make sure it is easy to read and understand for a human, not for a computer. Those
    who have worked in the industry for some time have been puzzled over code they
    wrote a few years prior. You can improve your code-writing style via clarity and
    the transparency of its intent.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s discuss the need for comments. We do not need comments that echo
    what the code does, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE225]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE226]'
  prefs: []
  type: TYPE_PRE
- en: 'The comments that explain the intent are much more valuable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE227]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE228]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE229]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE230]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE231]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE232]'
  prefs: []
  type: TYPE_PRE
- en: 'The commented code can be very complex. Good comments explain the intent and
    provide guidance that helps us understand the code. Yet, programmers often do
    not bother to write comments. The argument against writing comments typically
    includes two statements:'
  prefs: []
  type: TYPE_NORMAL
- en: Comments must be maintained and evolve along with the code; otherwise, they
    may become misleading. However, no tool can prompt the programmer to adjust the
    comments along with changing the code. Thus, comments are dangerous.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code itself must be written (including name selection for variables and
    methods) so that no extra explanation is needed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both statements are true, but it is also true that comments can be very helpful,
    especially those that capture the intent. Besides, such comments tend to require
    fewer adjustments because the code intent doesn’t change often, if ever.
  prefs: []
  type: TYPE_NORMAL
- en: Use well-established frameworks and libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Programmers are not always given a chance to select the framework and libraries
    to develop the software. Often, the company prefers to stay with the set of software
    and development tools they have already used for other projects. But when you
    get such a possibility of choosing, the variety of available products may be overwhelming.
    It may also be tempting to select the latest new offer that is trending in the
    programming community. Nevertheless, experience proves time and again that the
    best course of action would be to select something well–established and proven
    to be production-strong. Besides, using solid software with a long history requires
    typically writing less boilerplate code.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate this point, we created two projects:'
  prefs: []
  type: TYPE_NORMAL
- en: Using the Spring Boot framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the **Vert.x** toolkit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We start with Spring Boot. It is an open source Java-based framework, developed
    by the Pivotal Team for building standalone production-strong applications. By
    default, it does not need an external web server, because it embeds a web server
    (Tomcat or Netty). As a result, the Spring Boot user does not need to write any
    non-business code. You don’t need even to create configuration, as in Spring.
    You just define which non-business features you need (such as health check, metrics,
    or swagger doc, for example) using the properties file and tune them using annotation.
  prefs: []
  type: TYPE_NORMAL
- en: Naturally, because there is so much implemented behind the scenes, Spring Boot
    is very opinionated. But you would be hard-pressed to find a case when it cannot
    be used to produce a solid efficient application. Most probably, limitations of
    Spring Boot will manifest themselves in large-scale projects. The best approach
    for using Spring Boot is to embrace its way to do things, because by doing this
    you will save a lot of time and will get a robust and well-optimized solution.
  prefs: []
  type: TYPE_NORMAL
- en: To simplify dependency management, Spring Boot provides the required third-party
    dependencies for each type of application in the so-called `starter` JAR file.
    For example, spring-boot-starter-web brings into the project all the libraries
    necessary for Spring MVC (Model-View-Controller) and the Tomcat web server. Based
    on the selected starter package, Spring Boot automatically configures the application.
  prefs: []
  type: TYPE_NORMAL
- en: You can find comprehensive and well-written information for programmers of all
    levels – from beginners to experienced professionals – at [https://spring.io/projects/spring-boot](https://spring.io/projects/spring-boot).
    If you plan to use Spring Boot in your line of work, we encourage you to read
    it.
  prefs: []
  type: TYPE_NORMAL
- en: To demonstrate Spring Boot capabilities and advantages, we created a project
    in the `spring` folder. To run this sample application, you need the database,
    created in [*Chapter 10*](B18388_10_ePub.xhtml#_idTextAnchor230), *Managing Data
    in a Database,* of this book, up and running. The sample application manages (creates,
    reads, updates, deletes) records of persons in the database. This functionality
    is accessible via the UI (HTML pages), which is human-oriented. In addition, we
    implemented access to the same functionality via RESTful services, which can be
    used by other applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can run the application from an IDE by executing the `Application` class.
    Alternatively, you can start the application from the command line. There are
    two command files in the `spring` folder: `mvnw` (for Unix/Linux/Mac systems)
    and `mvnw.cmd` (for Windows). They can be used to launch the application as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For Unix/Linux/Mac systems:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE233]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For Windows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE234]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When you do it the first time, you may get an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE235]'
  prefs: []
  type: TYPE_PRE
- en: 'If that happens, install the Maven wrapper by executing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE236]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can build the executable `.jar` file:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For Unix/Linux/Mac systems:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE237]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For Windows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE238]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then you can put the created `.jar` file on any computer that has Java 17 installed
    and run it, using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE239]'
  prefs: []
  type: TYPE_PRE
- en: 'After the application is running, execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE240]'
  prefs: []
  type: TYPE_PRE
- en: 'The `curl` command requires the application to create a new person record.
    The expected response looks as follows (the `id` value will be different every
    time you run this command):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE241]'
  prefs: []
  type: TYPE_PRE
- en: To see the HTTP code in the response, add the option `-v` to the command. The
    HTTP code 200 indicates successful processing of the request.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s execute the `update` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE242]'
  prefs: []
  type: TYPE_PRE
- en: 'The application responds to this command as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE243]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE244]'
  prefs: []
  type: TYPE_PRE
- en: Notice that not all fields in the payload have to be populated. Only the `id`
    value is required and has to match with one of the existing records. The application
    retrieves the current `Person` record by the provided `id` value and updates only
    those properties that are provided.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `delete` endpoint is similarly constructed. The difference is that the
    data (the `Person` record identity number `id`) is passed as part of the URL.
    Now let’s execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE245]'
  prefs: []
  type: TYPE_PRE
- en: 'The application responds to this command with the following message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE246]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE247]'
  prefs: []
  type: TYPE_PRE
- en: 'The list of all the existing records can be retrieved with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE248]'
  prefs: []
  type: TYPE_PRE
- en: All the preceding functionalities can be accessed via the UI. Type in the browser
    the URL `http://localhost:8083/ui/list` and click the corresponding links.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also type `http://localhost:8083` in the browser URL and access the
    following page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18388_Figure_17.2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Then again, click any of the available links. The `Home` page presents information
    about the current application version and its heath. The `http://localhost:8083/swagger-ui.html`
    URL brings up the list of all the application endoints.
  prefs: []
  type: TYPE_NORMAL
- en: We highly encourage you to study the application code and read the Spring Boot
    documentation on the [https://spring.io/projects/spring-boot](https://spring.io/projects/spring-boot)
    website.
  prefs: []
  type: TYPE_NORMAL
- en: Now let us look in the project in the `reactive` folder. It demonstrates the
    reactive methods of communication, using Vert.x, which is an event-driven non-blocking
    lightweight polyglot toolkit. It allows you to write components in Java, JavaScript,
    Groovy, Ruby, Scala, Kotlin, and Ceylon. It supports an asynchronous programming
    model and a distributed event bus that reaches into the JavaScript browser, thus
    allowing the creation of real-time web applications. However, because of the focus
    of this book, we are going to use Java only.
  prefs: []
  type: TYPE_NORMAL
- en: To demonstrate how a reactive system of microservices may look if implemented
    using the **Vert**.x toolkit, we have created an HTTP server that can accept a
    REST-based request to the system, send an EventBus-based message to another *verticle*
    (the fundamental processing unit in the **Vert**.x toolkit that can be deployed),
    receive a reply, and send the response back to the original request.
  prefs: []
  type: TYPE_NORMAL
- en: 'We created two verticles:'
  prefs: []
  type: TYPE_NORMAL
- en: '`HttpServerVert`, which acts as a server and receives HTTP messages, which
    then sends them to a particular address via the EventBus(a lightweight distributed
    messaging system)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MessageRcvVert`, which listens messages on a particular event-bus address'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now we can deploy them as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE249]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE250]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE251]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE252]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE253]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE254]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE255]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE256]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE257]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE258]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE259]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE260]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE261]'
  prefs: []
  type: TYPE_PRE
- en: 'To execute this code, run the `ReactiveSystemDemo` class. The result is expected
    to be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18388_Figure_17.3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s now start sending HTTP requests to our system. First, let’s send the
    same HTTP `GET` request three times:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18388_Figure_17.4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If there are several verticles registered with the same address (as it is in
    our case: we have registered two verticles with the same `One` address), the system
    uses a round-robin algorithm to select the verticle that should receive the next
    message.'
  prefs: []
  type: TYPE_NORMAL
- en: The first request went to the receiver with `ID="1"`, the second request went
    to the receiver with `ID="2"`, and the third request went to the receiver with
    `ID="1"` again.
  prefs: []
  type: TYPE_NORMAL
- en: 'We get the same results using the HTTP `POST` request for the `/some/path/send`
    path:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18388_Figure_17.5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Again, the receiver of the message is rotated using the round-robin algorithm.
    Now, let’s publish a message to our system twice.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the receiver’s reply cannot propagate back to the system user, we need
    to take a look at the messages that are logged on the backend:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18388_Figure_17.6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the `publish()` method sends the message to all verticles that
    are registered to the specified address. And note that the verticle with `ID="3"`
    (registered with the `Two` address) never received a message.
  prefs: []
  type: TYPE_NORMAL
- en: Before we wrap up this reactive system demonstration, it is worth mentioning
    that the **Vert.x** toolkit allows you to easily cluster verticles. You can read
    about this feature in the **Vert.x** documentation at [https://vertx.io/docs/vertx-core/java](https://vertx.io/docs/vertx-core/java).
  prefs: []
  type: TYPE_NORMAL
- en: These two examples demonstrated how little code you have to write in order to
    create a complete web application if you use a well-established framework. It
    does not mean that you cannot explore the latest and greatest of frameworks. By
    any means, you can and should do it to stay abreast with progress in your industry.
    Just keep in mind that it takes some time for a new product to mature and become
    reliable and helpful enough for creating a production-strong software solution.
  prefs: []
  type: TYPE_NORMAL
- en: Testing is the shortest path to quality code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The last best practice we will discuss is this statement: *testing is not an
    overhead or a burden; it is the programmer’s guide to success*. The only question
    is when to write the test.'
  prefs: []
  type: TYPE_NORMAL
- en: There is a compelling argument that requires writing a test before any line
    of code is written. If you can do it, that is great. We are not going to try and
    talk you out of it. But if you do not do it, try to start writing a test after
    you have written one, or all, the lines of code you have been tasked to write.
  prefs: []
  type: TYPE_NORMAL
- en: In practice, many experienced programmers find it helpful to start writing testing
    code after some of the new functionality is implemented. This is because that
    is when the programmer understands better how the new code fits into the existing
    context. They may even try and hardcode some values to see how well the new code
    is integrated with the code that calls the new method. After making sure the new
    code is well integrated, the programmer can continue implementing and tuning it,
    all while testing the new implementation against the requirements in the context
    of the calling code.
  prefs: []
  type: TYPE_NORMAL
- en: One important qualification must be added – while writing the test, it is better
    if the input data and the test criteria are set not by you, but by the person
    who assigned you the task or the tester. Setting the test according to the results
    the code produces is a well-known programmer’s trap. Objective self-assessment
    is not easy, if at all possible.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed the Java idioms that a mainstream programmer encounters
    daily. We also discussed the best design practices and related recommendations,
    including code-writing styles and testing.
  prefs: []
  type: TYPE_NORMAL
- en: You also learned about the most popular Java idioms related to certain features,
    functionalities, and design solutions. These idioms were demonstrated with practical
    examples, where you learned how to incorporate them into your code and the professional
    language that’s used to communicate with other programmers.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter concludes this book about Java 17 and its usage for writing effective
    application code. If you have read all of it, then you should have a very good
    overview of this topic and acquired valuable programming knowledge and skills
    you can immediately apply professionally. If you found this material valuable,
    then it makes us happy to know that we have achieved our goal. Thank you for reading.
  prefs: []
  type: TYPE_NORMAL
- en: Quiz
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Answer the following questions to test your knowledge of this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Select all the correct statements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Idioms can be used to communicate the code’s intent.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Idioms can be used to explain what the code does.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Idioms can be misused and obscure the topic of conversation.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Idioms should be avoided to express the idea clearly.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Is it necessary to implement `hasCode()` every time `equals()` is implemented?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If `obj1.compareTo(obj2)` returns a negative value, what does this mean?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Does the deep copy notion apply to a primitive value during cloning?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which is faster, `StringBuffer` or `StringBuilder`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the benefits of coding to an interface?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the benefits of using composition versus inheritance?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the advantage of using libraries versus writing your own code?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Who is the target audience of your code?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Is testing required?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
