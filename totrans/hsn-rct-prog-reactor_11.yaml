- en: Assessments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Chapter 1: Getting Started with Reactive Streams'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What are the principles of the Reactive Manifesto?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The Reactive Manifesto defines the following principles:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Message-Driven**: All application components should be loosely coupled and
    communicate using messages'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Responsive**: An application must respond to user input in a timely manner'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Resilient**: An application must isolate failures to individual components'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scalable**: An application must react to changes in workload'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are Reactive Extensions?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Reactive Extensions are libraries in imperative languages that enables us to
    write asynchronous, event-driven reactive applications. The libraries enable us
    to express asynchronous events as a set of observables. This enables us to build
    application components that can receive and process these async events. On the
    other hand, there are also event producers, which push these events.
  prefs: []
  type: TYPE_NORMAL
- en: What does the Reactive Streams specification cater to?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Reactive Streams is a specification that determines the minimum set of interfaces
    required to build the asynchronous processing of a large volume of unbounded data.
    It is a specification aimed at JVM and JavaScript runtime. The main goal of the
    Reactive Streams specification is to standardize the exchange of stream data across
    an asynchronous boundary of applications.
  prefs: []
  type: TYPE_NORMAL
- en: What are the principles upon which Reactive Streams are based?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Reactive Streams are based on the following two principles:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Asynchronous execution**: This is the ability to execute tasks without having
    to wait for previously executed tasks to finish first. The execution model decouples
    tasks so that each of them can be performed simultaneously, utilizing the available
    hardware.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Backpressure**: A subscriber can control events in its queue to avoid any
    overruns. It can also request more events if there is additional capacity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are the salient features of the Reactor Framework?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Infinite data streams**: This refers to Reactor''s capability of generating
    infinite sequences of data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Push-pull model**: In Reactor, a producer can push events. On the other hand,
    if the consumer is slow in processing, it can pull events at its own rate.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Concurrency agnostic**: Reactor does not enforce any concurrency model. It
    allows a developer to select what fits best.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Operator vocabulary**: Reactor provides a wide range of operators. These
    operators allow us to select, filter, transform, and combine streams.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Chapter 2: The Publisher and Subscriber APIs in a Reactor'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How can we validate Reactive Streams publisher and subscriber implementations?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In order to validate a publisher, the Reactive Streams API has published a test
    compatibility kit called `reactive-streams-tck`. Reactive publisher can be verified
    using the `PublisherVerifier` interface. Similarly, a subscriber can be verified
    by using the `SubscriberBlackboxVerification<T>` abstract class.
  prefs: []
  type: TYPE_NORMAL
- en: How is the Reactive Streams publisher-subscriber model different from the JMS
    API?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In JMS, the producer is responsible for generating unbounded events on the queue
    or topics, while the consumer actively consumes the events. The producer and consumer
    are working in isolation, at their own rates. The task of managing the subscription
    is taken care of by the JMS broker. There is no concept of backpressure in JMS.
    Also, it lacks event modeling, such as subscription, error, or completion.
  prefs: []
  type: TYPE_NORMAL
- en: How is the Reactive Streams publisher-subscriber model different from the Observer
    API?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Observable API has the responsibility of determining a change and publishing
    it to all interested parties. The API is about entity state changes. This is not
    what we are modeling with the `Publisher` and `Subscriber` interface. The `Publisher`
    interface is responsible for generating unbounded events. The `Subscriber`, on
    the other hand, lists all kinds of events, such as data, error, and completion.
  prefs: []
  type: TYPE_NORMAL
- en: What is the difference between Flux and Mono?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Flux` is a general-purpose reactive publisher. It represents a stream of asynchronous
    events with zero or more values. On the other hand, Mono can only generate a maximum
    of one event.'
  prefs: []
  type: TYPE_NORMAL
- en: What is the difference between `SynchronousSink` and `FluxSink`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`SynchronousSink` can generate only one event at a time. It is synchronous
    in nature. A subscriber must consume the event before generating the next event.
    On the other hand, `FluxSink` can generate many events asynchronously. Moreover,
    it does not take subscription cancelation or backpressure into account. This means
    that even if the subscriber has canceled its subscription, the `create` API will
    continue to generate events.'
  prefs: []
  type: TYPE_NORMAL
- en: What are the different lifecycle hooks available in Reactor?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`doOnSubscribe`: For the subscribe event'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`doOnRequest`: For the request event'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`doOnNext`: For the next event'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`doOnCancel`: For the subscription cancel event'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`doOnError`: For an error event'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`doOnCompletion`: For completion event'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`doOnTerminate`: For termination due to error, completion, or cancelation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`doFinally`: For clean-up post termination of a stream'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`doOnEach`: For all events'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Chapter 3: Data and Stream Processing'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Which operator is used to select data elements from a stream?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`filter`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`filterWhen`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`take`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`takeLast`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`last`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`distinct`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`single`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`elementAT`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Which operator is used to reject data elements from a stream?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`filter`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`filterWhen`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`skip`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`skipLast`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SkipUntil`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ignoreElements`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Which operators does Reactor offer for data conversion? How are these operators
    different from each other?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`map`: This is used for one-to-one transformation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`flatMap`: This is used for one-to-n transformation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How can we perform data aggregation by using Reactor operators?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`collectList`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`collectMap`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`` `collectMultiMap` ``'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Which conditional operators are offered by Reactor?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`all`: Represents the `AND` operator'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`any`: Represents the `OR` operator'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Chapter 4: Processors'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What are the limitations of `DirectProcessor`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`DirectProcessor` does not offer any backpressure handling.'
  prefs: []
  type: TYPE_NORMAL
- en: What are the limitations of `UnicastProcessor`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`UnicastProcessor` can work with only a single subscriber.'
  prefs: []
  type: TYPE_NORMAL
- en: What are the capabilities of `EmitterProcessor`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`EmitterProcessor` is a processor that can be used with several subscribers.
    Multiple subscribers can ask the processor for the next value event, based on
    their individual rates of consumption'
  prefs: []
  type: TYPE_NORMAL
- en: What are the capabilities of `ReplayProcessor`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`ReplayProcessor` is a special-purpose processor, capable of caching and replaying
    events to its subscribers.'
  prefs: []
  type: TYPE_NORMAL
- en: What are the capabilities of `TopicProcessor`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`TopicProcessor` is a processor capable of working with multiple subscribers,
    using an event-loop architecture. The processor delivers events from a publisher
    to the attached subscribers in an asynchronous manner and honors backpressure
    for each subscriber by using the RingBuffer data structure.'
  prefs: []
  type: TYPE_NORMAL
- en: What are the capabilities of `WorkQueueProcessor`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`WorkQueueProcessor` can connect to multiple subscribers. It does not deliver
    all events to each subscriber. The demand from every subscriber is added to a
    queue and events from a publisher are sent to any of the subscribers.'
  prefs: []
  type: TYPE_NORMAL
- en: What is the difference between a hot publisher and a cold publisher?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Cold publishers have an individual subscription state for each subscriber. They
    publish all data to each of the subscribers irrespective of the subscription time.
    On the other hand, a hot publisher publishes common data to all its subscribers.
    Thus, new subscribers get only the current events and no older events are delivered
    to them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Chapter 5: SpringWebFlux for Microservices'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How can we configure the `SpringWebFlux` project?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`SpringWebFlux` can be configured in two ways :'
  prefs: []
  type: TYPE_NORMAL
- en: '**Using annotations**: `SpringWebFlux` supports `SpringWebMVC` annotations.
    This is the easiest way of configuring `SpringWebFlux`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Using functional endpoints**: This model allows us to build Java 8 functions
    as web endpoints. The application can be configured as a set of routes, handlers,
    and filters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Which `MethodParameter` annotations are supported by `SpringWebFlux`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`@PathVariable`: This annotation is used to access values for URI template
    variables'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@RequestParam`: This annotation is used to determine values passed as query
    parameters'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@RequestHeader`: This annotation is used to determine values passed in request
    headers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@RequestBody`: This annotation is used to determine values passed in the request
    body'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@CookieValue`: This annotation is used to determine HTTP cookie values as
    part of request'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@ModelAttribute`: This annotation is used to determine an attribute from the
    request model or instantiate one if not present'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@SessionAttribute`: This annotation is used to determine preexisting session
    attributes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@RequestAttribute`: This annotation is used to determine preexisting request
    attributes created by a previous filter execution'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is the use of `ExceptionHandler`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`SpringWebFlux` supports exception handling by creating methods that are annotated
    with `@ExceptionHandler`.'
  prefs: []
  type: TYPE_NORMAL
- en: What is the use of `HandlerFunction` ?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`SpringWebFlux` handler function is responsible for serving a given request.
    It takes the request in the form of a `ServerRequest` class and generates the
    response as `ServerResponse`.'
  prefs: []
  type: TYPE_NORMAL
- en: What is the use of `RouterFunction` ?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`SpringWebFlux` router function is responsible for routing incoming requests
    to the correct handler function.'
  prefs: []
  type: TYPE_NORMAL
- en: What is the use of `HandlerFilter` ?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`HandlerFilter` is analogous to the Servlet filter. This executes before the
    request gets processed by `HandlerFunction`. There could be chain filters, which
    get executed before the request gets served.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Chapter 6: Dynamic Rendering'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How does the `SpringWebFlux` framework resolve a View?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The framework invokes `ViewResolutionResultHandler` using the `HandlerResult`
    returned for the endpoint invocation. `ViewResolutionResultHandler` then determines
    the correct view by validating the returned value for the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**String**: If the returned value is a string, then the framework builds a
    view using the configured `ViewResolvers`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Void**: If nothing is returned, it then tries to build the default view'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Map**: The framework looks for the default view but it also adds the key
    values returned into the request model'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ViewResolutionResultHandler` looks up the content type passed in the request.
    In order to determine which view should be used, it compares the content type
    passed to the content type supported by `ViewResolver`. It then selects the first
    `ViewResolver`, which supports the request content type.'
  prefs: []
  type: TYPE_NORMAL
- en: Which components need to be configured so you can use the Thymeleaf template
    engine?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add `spring-boot-starter-thymeleaf` to the project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create an instance of `ThymeleafReactiveViewResolver`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add the resolver to `ViewResolverRegistry`, available in the `configureViewResolvers`
    method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Which API is used to configure static resources in SpringWebFlux?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `addResourceHandler` method takes a URL pattern and configures it to be
    a static location
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `addResourceLocations` method configures a location from where the static
    content needs to be served
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are the benefits of `WebClient`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`WebClient` is a non-blocking, asynchronous HTTP client for making requests.
    It can be configured with Java 8 lambdas for processing data.'
  prefs: []
  type: TYPE_NORMAL
- en: What is the difference between the retrieve and exchange APIs of WebClient?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Retrieve`: This can decode a request body into a Flux or Mono'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Exchange`: The `Exchange` method provides the complete message, which can
    be converted back into a target type'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Chapter 7: Flow Control and Backpressure'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Why do we need the `groupBy` operator?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `groupBy()` operator converts `Flux<T>` into batches. The operator associates
    a key with each element of `Flux<T>`. It then groups elements that have the same
    key. These groups are then emitted by the operator.
  prefs: []
  type: TYPE_NORMAL
- en: What is the difference between the `groupBy` and `buffer` operators?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `groupBy` operator groups the stream of events based on a configured key,
    but the `buffer` operator splits the stream into chunks of a specified size. Thus,
    the `buffer` operator maintains the original ordering of events.
  prefs: []
  type: TYPE_NORMAL
- en: How can we throttle an event in Reactor?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `sample()` operator allows us to accomplish throttling.
  prefs: []
  type: TYPE_NORMAL
- en: What is the difference between the `Overflow.Ignore` and the `OverFlow.Latest`
    strategies?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Overflow.Ignore` ignores the limits of the subscriber backpressure and keeps
    delivering the next event to the subscriber. `OverFlow.Latest` keeps the latest
    event raised in the buffer. The subscriber will only get the latest produced event
    when the next request is raised.'
  prefs: []
  type: TYPE_NORMAL
- en: Which operators are available for changing the backpressure strategy of a producer?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`onBackpressureDrop()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onBackpressureLatest()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onBackpressureError()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onBackpressureBuffer()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Chapter 8: Handling Errors'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How is an error handled in Reactor?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Errors arise when either the publisher or the subscriber throws back an exception.
    Reactor intercepts the exception, builds an `Error` event, and then sends it to
    the subscriber. The subscriber must implement `ErrorCallbackHandler` to handle
    the error.
  prefs: []
  type: TYPE_NORMAL
- en: Which operators allow us to configure error handling?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`onErrorReturn`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onErrorResume`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onErrorMap`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is the difference between `onErrorResume` and `onErrorReturn`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `OnErrorReturn` operator provides a fall-back value in the event of an error.
    On the other hand, the `OnErrorResume` operator provides a fall-back value stream
    instead of a single fall-back value.
  prefs: []
  type: TYPE_NORMAL
- en: How can we generate a timely response for a Reactive Streams?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `timeout()` operator can be configured for a time interval. The operator
    will raise an error when it first discovers a delay of more than the configured
    time. The operator also has a fallback Flux. The fallback value is returned once
    the timeout expires.
  prefs: []
  type: TYPE_NORMAL
- en: How does the `retry` operator behave?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `retry` operator allows us to resubscribe to a published stream when an
    error is discovered. The `retry` operation can only be performed a fixed number
    of times. The resubscribed events are handled as next events by the subscriber.
    If the stream completes normally, no next retry takes place.
  prefs: []
  type: TYPE_NORMAL
- en: 'Chapter 9: Execution Control'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What are the different types of schedulers available in Reactor?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Schedulers.immediate`: This schedules on the current thread'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Schedulers.single`: This schedules on a single thread'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Schedulers.parallel`: This schedules on the thread pool'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Schedulers.elastic`: This schedules on a thread pool'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Schedulers.fromExecutor`: This schedules the configured executor service'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Which scheduler should be used for blocking operations?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Schedulers.elastic` schedules on a thread pool.'
  prefs: []
  type: TYPE_NORMAL
- en: Which scheduler should be used for computation intensive operations?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Schedulers.single`: This schedules on a single thread.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Schedulers.parallel`: This schedules on the thread pool'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How are `PublishOn` and `SubscriberOn` different from each other?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `subscribeOn` operator intercepts events from a publisher in the execution
    chain and sends them to a different scheduler for the complete chain. It is important
    to note that the operator changes the execution context for the complete chain,
    unlike the `publishOn` operator, which only alters the execution of a downstream
    chain.
  prefs: []
  type: TYPE_NORMAL
- en: What is the limitation of `ParallelFlux`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`ParallelFlux` does not offer the `doFinally` lifecycle hook. It can be converted
    back to a `Flux` using the `sequential` operator, which can then be configured
    using the `doFinally` hook.'
  prefs: []
  type: TYPE_NORMAL
- en: Which operators are available for generating a `ConnectedFlux`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`replay`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`publish`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Chapter 10: Testing and Debugging'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Which test utility class is available in Reactor to validate the invoked operations
    on a stream?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Reactor provides the `StepVerifier` component to validate the required operations
    in isolation.
  prefs: []
  type: TYPE_NORMAL
- en: What is the difference between `PublisherProbe` and `TestPublisher`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `PublisherProbe` utility can instrument an existing publisher. The probe
    keeps track of signals published by the publisher, which can be validated at the
    end of the test. On the other hand, `TestPublisher` is capable of generating the
    `Publisher` stub, which can be used to unit test Reactor operators.
  prefs: []
  type: TYPE_NORMAL
- en: How should the virtual clock be configured to validate time-bound operations
    ?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The virtual clock must be injected before performing any time-based operations.
  prefs: []
  type: TYPE_NORMAL
- en: What is the difference between the `onOperatorDebug` hook and the `checkpoint`
    operator?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `onOperatorDebug` hook makes a global change for all reactive pipelines.
    On the other hand, the `checkpoint` operator makes the change specific to the
    stream it is applied to.
  prefs: []
  type: TYPE_NORMAL
- en: How can we turn on the logging of stream processing?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `log` operator can be used to turn on logging.
  prefs: []
  type: TYPE_NORMAL
