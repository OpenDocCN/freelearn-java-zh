- en: Assessments
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 评估
- en: 'Chapter 1: Getting Started with Reactive Streams'
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一章：开始使用反应式流
- en: What are the principles of the Reactive Manifesto?
  id: totrans-2
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 反应式宣言的原则是什么？
- en: 'The Reactive Manifesto defines the following principles:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 反应式宣言定义了以下原则：
- en: '**Message-Driven**: All application components should be loosely coupled and
    communicate using messages'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**消息驱动**：所有应用程序组件都应该是松散耦合的，并使用消息进行通信'
- en: '**Responsive**: An application must respond to user input in a timely manner'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**响应性**：应用程序必须及时响应用户输入'
- en: '**Resilient**: An application must isolate failures to individual components'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**弹性**：应用程序必须将故障隔离到单个组件'
- en: '**Scalable**: An application must react to changes in workload'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可伸缩性**：应用程序必须对工作负载的变化做出反应'
- en: What are Reactive Extensions?
  id: totrans-8
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 反应式扩展是什么？
- en: Reactive Extensions are libraries in imperative languages that enables us to
    write asynchronous, event-driven reactive applications. The libraries enable us
    to express asynchronous events as a set of observables. This enables us to build
    application components that can receive and process these async events. On the
    other hand, there are also event producers, which push these events.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 反应式扩展是命令式语言中的库，使我们能够编写异步、事件驱动的反应式应用程序。这些库使我们能够将异步事件表达为一系列可观察对象。这使得我们能够构建可以接收和处理这些异步事件的组件。另一方面，也存在事件生产者，它们推送这些事件。
- en: What does the Reactive Streams specification cater to?
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 反应式流规范旨在满足什么需求？
- en: Reactive Streams is a specification that determines the minimum set of interfaces
    required to build the asynchronous processing of a large volume of unbounded data.
    It is a specification aimed at JVM and JavaScript runtime. The main goal of the
    Reactive Streams specification is to standardize the exchange of stream data across
    an asynchronous boundary of applications.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 反应式流是一个规范，它确定了构建大量无界数据异步处理所需的最小接口集。它是一个针对JVM和JavaScript运行时的规范。反应式流规范的主要目标是标准化应用程序异步边界之间的流数据交换。
- en: What are the principles upon which Reactive Streams are based?
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 反应式流基于哪些原则？
- en: 'Reactive Streams are based on the following two principles:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 反应式流基于以下两个原则：
- en: '**Asynchronous execution**: This is the ability to execute tasks without having
    to wait for previously executed tasks to finish first. The execution model decouples
    tasks so that each of them can be performed simultaneously, utilizing the available
    hardware.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**异步执行**：这是在不等待先前执行的任务完成的情况下执行任务的能力。执行模型解耦任务，以便每个任务都可以同时执行，利用可用的硬件。'
- en: '**Backpressure**: A subscriber can control events in its queue to avoid any
    overruns. It can also request more events if there is additional capacity.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**背压**：订阅者可以控制其队列中的事件以避免任何溢出。如果还有额外容量，它还可以请求更多事件。'
- en: What are the salient features of the Reactor Framework?
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Reactor框架的主要特点是什么？
- en: '**Infinite data streams**: This refers to Reactor''s capability of generating
    infinite sequences of data.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无限数据流**：这指的是Reactor生成无限数据序列的能力。'
- en: '**Push-pull model**: In Reactor, a producer can push events. On the other hand,
    if the consumer is slow in processing, it can pull events at its own rate.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**推拉模型**：在Reactor中，生产者可以推送事件。另一方面，如果消费者在处理方面较慢，它可以在自己的速率下拉取事件。'
- en: '**Concurrency agnostic**: Reactor does not enforce any concurrency model. It
    allows a developer to select what fits best.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无并发性**：Reactor不强制执行任何并发模型。它允许开发者选择最适合的。'
- en: '**Operator vocabulary**: Reactor provides a wide range of operators. These
    operators allow us to select, filter, transform, and combine streams.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**操作词汇**：Reactor提供了一系列操作符。这些操作符允许我们选择、过滤、转换和组合流。'
- en: 'Chapter 2: The Publisher and Subscriber APIs in a Reactor'
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章：Reactor中的发布者和订阅者API
- en: How can we validate Reactive Streams publisher and subscriber implementations?
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何验证反应式流的发布者和订阅者实现？
- en: In order to validate a publisher, the Reactive Streams API has published a test
    compatibility kit called `reactive-streams-tck`. Reactive publisher can be verified
    using the `PublisherVerifier` interface. Similarly, a subscriber can be verified
    by using the `SubscriberBlackboxVerification<T>` abstract class.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证发布者，反应式流API发布了一个名为`reactive-streams-tck`的测试兼容性套件。可以使用`PublisherVerifier`接口验证反应式发布者。同样，可以使用`SubscriberBlackboxVerification<T>`抽象类验证订阅者。
- en: How is the Reactive Streams publisher-subscriber model different from the JMS
    API?
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 反应式流发布者-订阅者模型与JMS API有何不同？
- en: In JMS, the producer is responsible for generating unbounded events on the queue
    or topics, while the consumer actively consumes the events. The producer and consumer
    are working in isolation, at their own rates. The task of managing the subscription
    is taken care of by the JMS broker. There is no concept of backpressure in JMS.
    Also, it lacks event modeling, such as subscription, error, or completion.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在JMS中，生产者负责在队列或主题上生成无界事件，而消费者积极消费事件。生产者和消费者独立工作，以自己的速率。订阅管理的任务由JMS代理负责。JMS中没有背压的概念。此外，它缺乏事件建模，如订阅、错误或完成。
- en: How is the Reactive Streams publisher-subscriber model different from the Observer
    API?
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 反应式流发布者-订阅者模型与Observer API有何不同？
- en: The Observable API has the responsibility of determining a change and publishing
    it to all interested parties. The API is about entity state changes. This is not
    what we are modeling with the `Publisher` and `Subscriber` interface. The `Publisher`
    interface is responsible for generating unbounded events. The `Subscriber`, on
    the other hand, lists all kinds of events, such as data, error, and completion.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Observable API负责确定变化并将其发布给所有感兴趣方。API是关于实体状态变化的。这不是我们使用`Publisher`和`Subscriber`接口所建模的内容。`Publisher`接口负责生成无界事件。另一方面，`Subscriber`列出了所有类型的事件，如数据、错误和完成。
- en: What is the difference between Flux and Mono?
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Flux和Mono之间有什么区别？
- en: '`Flux` is a general-purpose reactive publisher. It represents a stream of asynchronous
    events with zero or more values. On the other hand, Mono can only generate a maximum
    of one event.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`Flux`是一个通用反应式发布者。它表示一个异步事件流，其中包含零个或多个值。另一方面，Mono只能生成最多一个事件。'
- en: What is the difference between `SynchronousSink` and `FluxSink`?
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`SynchronousSink`和`FluxSink`之间有什么区别？'
- en: '`SynchronousSink` can generate only one event at a time. It is synchronous
    in nature. A subscriber must consume the event before generating the next event.
    On the other hand, `FluxSink` can generate many events asynchronously. Moreover,
    it does not take subscription cancelation or backpressure into account. This means
    that even if the subscriber has canceled its subscription, the `create` API will
    continue to generate events.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`SynchronousSink`一次只能生成一个事件。它是同步的。订阅者必须在生成下一个事件之前消费事件。另一方面，`FluxSink`可以异步生成多个事件。此外，它不考虑订阅取消或背压。这意味着即使订阅者取消了其订阅，`create`
    API也会继续生成事件。'
- en: What are the different lifecycle hooks available in Reactor?
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Reactor提供了哪些不同的生命周期钩子？
- en: '`doOnSubscribe`: For the subscribe event'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`doOnSubscribe`: 用于订阅事件'
- en: '`doOnRequest`: For the request event'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`doOnRequest`: 用于请求事件'
- en: '`doOnNext`: For the next event'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`doOnNext`: 用于下一个事件'
- en: '`doOnCancel`: For the subscription cancel event'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`doOnCancel`: 用于订阅取消事件'
- en: '`doOnError`: For an error event'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`doOnError`: 用于错误事件'
- en: '`doOnCompletion`: For completion event'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`doOnCompletion`: 用于完成事件'
- en: '`doOnTerminate`: For termination due to error, completion, or cancelation'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`doOnTerminate`: 用于由于错误、完成或取消而终止'
- en: '`doFinally`: For clean-up post termination of a stream'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`doFinally`: 用于流终止后的清理'
- en: '`doOnEach`: For all events'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`doOnEach`: 用于所有事件'
- en: 'Chapter 3: Data and Stream Processing'
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三章：数据和流处理
- en: Which operator is used to select data elements from a stream?
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个算子用于从流中选择数据元素？
- en: '`filter`'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`filter`'
- en: '`filterWhen`'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`filterWhen`'
- en: '`take`'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`take`'
- en: '`takeLast`'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`takeLast`'
- en: '`last`'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`last`'
- en: '`distinct`'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`distinct`'
- en: '`single`'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`single`'
- en: '`elementAT`'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`elementAT`'
- en: Which operator is used to reject data elements from a stream?
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个算子用于从流中拒绝数据元素？
- en: '`filter`'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`filter`'
- en: '`filterWhen`'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`filterWhen`'
- en: '`skip`'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`skip`'
- en: '`skipLast`'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`skipLast`'
- en: '`SkipUntil`'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SkipUntil`'
- en: '`ignoreElements`'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ignoreElements`'
- en: Which operators does Reactor offer for data conversion? How are these operators
    different from each other?
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Reactor提供了哪些算子用于数据转换？这些算子之间有何不同？
- en: '`map`: This is used for one-to-one transformation'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`map`: 这用于一对一转换'
- en: '`flatMap`: This is used for one-to-n transformation'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`flatMap`: 这用于一对一转换'
- en: How can we perform data aggregation by using Reactor operators?
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何使用Reactor算子进行数据聚合？
- en: '`collectList`'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`collectList`'
- en: '`collectMap`'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`collectMap`'
- en: '`` `collectMultiMap` ``'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`` `collectMultiMap` ``'
- en: Which conditional operators are offered by Reactor?
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Reactor提供了哪些条件算子？
- en: '`all`: Represents the `AND` operator'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`all`: 表示`AND`运算符'
- en: '`any`: Represents the `OR` operator'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`any`: 表示`OR`运算符'
- en: 'Chapter 4: Processors'
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章：处理器
- en: What are the limitations of `DirectProcessor`?
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`DirectProcessor`有哪些局限性？'
- en: '`DirectProcessor` does not offer any backpressure handling.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`DirectProcessor`不提供任何背压处理。'
- en: What are the limitations of `UnicastProcessor`?
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`UnicastProcessor` 的局限性是什么？'
- en: '`UnicastProcessor` can work with only a single subscriber.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`UnicastProcessor` 只能与单个订阅者一起工作。'
- en: What are the capabilities of `EmitterProcessor`?
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`EmitterProcessor` 的功能有哪些？'
- en: '`EmitterProcessor` is a processor that can be used with several subscribers.
    Multiple subscribers can ask the processor for the next value event, based on
    their individual rates of consumption'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`EmitterProcessor` 是一个可以与多个订阅者一起使用的处理器。多个订阅者可以根据它们各自的消费速率请求处理器获取下一个值事件'
- en: What are the capabilities of `ReplayProcessor`?
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ReplayProcessor` 的功能有哪些？'
- en: '`ReplayProcessor` is a special-purpose processor, capable of caching and replaying
    events to its subscribers.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`ReplayProcessor` 是一个特殊用途的处理器，能够缓存并回放事件给其订阅者。'
- en: What are the capabilities of `TopicProcessor`?
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`TopicProcessor` 的功能有哪些？'
- en: '`TopicProcessor` is a processor capable of working with multiple subscribers,
    using an event-loop architecture. The processor delivers events from a publisher
    to the attached subscribers in an asynchronous manner and honors backpressure
    for each subscriber by using the RingBuffer data structure.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`TopicProcessor` 是一个能够使用事件循环架构与多个订阅者一起工作的处理器。处理器以异步方式从发布者向附加的订阅者传递事件，并通过使用
    RingBuffer 数据结构为每个订阅者尊重背压。'
- en: What are the capabilities of `WorkQueueProcessor`?
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`WorkQueueProcessor` 的功能有哪些？'
- en: '`WorkQueueProcessor` can connect to multiple subscribers. It does not deliver
    all events to each subscriber. The demand from every subscriber is added to a
    queue and events from a publisher are sent to any of the subscribers.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`WorkQueueProcessor` 可以连接到多个订阅者。它不会将所有事件发送给每个订阅者。每个订阅者的需求被添加到队列中，发布者的事件被发送给任何订阅者。'
- en: What is the difference between a hot publisher and a cold publisher?
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 热发布者和冷发布者之间有什么区别？
- en: Cold publishers have an individual subscription state for each subscriber. They
    publish all data to each of the subscribers irrespective of the subscription time.
    On the other hand, a hot publisher publishes common data to all its subscribers.
    Thus, new subscribers get only the current events and no older events are delivered
    to them.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 冷发布者为每个订阅者有一个单独的订阅状态。它们将所有数据发布给每个订阅者，而不考虑订阅时间。另一方面，热发布者将公共数据发布给所有订阅者。因此，新订阅者只能获得当前事件，不会向他们传递旧事件。
- en: 'Chapter 5: SpringWebFlux for Microservices'
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第五章：SpringWebFlux 用于微服务
- en: How can we configure the `SpringWebFlux` project?
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何配置 `SpringWebFlux` 项目？
- en: '`SpringWebFlux` can be configured in two ways :'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`SpringWebFlux` 可以以两种方式配置：'
- en: '**Using annotations**: `SpringWebFlux` supports `SpringWebMVC` annotations.
    This is the easiest way of configuring `SpringWebFlux`.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用注解**：`SpringWebFlux` 支持 `SpringWebMVC` 注解。这是配置 `SpringWebFlux` 的最简单方法。'
- en: '**Using functional endpoints**: This model allows us to build Java 8 functions
    as web endpoints. The application can be configured as a set of routes, handlers,
    and filters.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用功能端点**：此模型允许我们构建 Java 8 函数作为网络端点。应用程序可以配置为一系列路由、处理程序和过滤器。'
- en: Which `MethodParameter` annotations are supported by `SpringWebFlux`?
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`SpringWebFlux` 支持哪些 `MethodParameter` 注解？'
- en: '`@PathVariable`: This annotation is used to access values for URI template
    variables'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@PathVariable`：此注解用于访问 URI 模板变量的值'
- en: '`@RequestParam`: This annotation is used to determine values passed as query
    parameters'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@RequestParam`：此注解用于确定作为查询参数传递的值'
- en: '`@RequestHeader`: This annotation is used to determine values passed in request
    headers'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@RequestHeader`：此注解用于确定请求头中传递的值'
- en: '`@RequestBody`: This annotation is used to determine values passed in the request
    body'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@RequestBody`：此注解用于确定请求体中传递的值'
- en: '`@CookieValue`: This annotation is used to determine HTTP cookie values as
    part of request'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@CookieValue`：此注解用于确定作为请求一部分的 HTTP cookie 值'
- en: '`@ModelAttribute`: This annotation is used to determine an attribute from the
    request model or instantiate one if not present'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@ModelAttribute`：此注解用于确定请求模型中的属性或在没有时实例化一个'
- en: '`@SessionAttribute`: This annotation is used to determine preexisting session
    attributes'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@SessionAttribute`：此注解用于确定现有的会话属性'
- en: '`@RequestAttribute`: This annotation is used to determine preexisting request
    attributes created by a previous filter execution'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@RequestAttribute`：此注解用于确定由先前过滤器执行创建的现有请求属性'
- en: What is the use of `ExceptionHandler`?
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ExceptionHandler` 的用途是什么？'
- en: '`SpringWebFlux` supports exception handling by creating methods that are annotated
    with `@ExceptionHandler`.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`SpringWebFlux` 通过创建带有 `@ExceptionHandler` 注解的方法来支持异常处理。'
- en: What is the use of `HandlerFunction` ?
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`SpringWebFlux` handler function is responsible for serving a given request.
    It takes the request in the form of a `ServerRequest` class and generates the
    response as `ServerResponse`.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: What is the use of `RouterFunction` ?
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`SpringWebFlux` router function is responsible for routing incoming requests
    to the correct handler function.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: What is the use of `HandlerFilter` ?
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`HandlerFilter` is analogous to the Servlet filter. This executes before the
    request gets processed by `HandlerFunction`. There could be chain filters, which
    get executed before the request gets served.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: 'Chapter 6: Dynamic Rendering'
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How does the `SpringWebFlux` framework resolve a View?
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The framework invokes `ViewResolutionResultHandler` using the `HandlerResult`
    returned for the endpoint invocation. `ViewResolutionResultHandler` then determines
    the correct view by validating the returned value for the following:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '**String**: If the returned value is a string, then the framework builds a
    view using the configured `ViewResolvers`'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Void**: If nothing is returned, it then tries to build the default view'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Map**: The framework looks for the default view but it also adds the key
    values returned into the request model'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ViewResolutionResultHandler` looks up the content type passed in the request.
    In order to determine which view should be used, it compares the content type
    passed to the content type supported by `ViewResolver`. It then selects the first
    `ViewResolver`, which supports the request content type.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: Which components need to be configured so you can use the Thymeleaf template
    engine?
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add `spring-boot-starter-thymeleaf` to the project
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create an instance of `ThymeleafReactiveViewResolver`
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add the resolver to `ViewResolverRegistry`, available in the `configureViewResolvers`
    method
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Which API is used to configure static resources in SpringWebFlux?
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `addResourceHandler` method takes a URL pattern and configures it to be
    a static location
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `addResourceLocations` method configures a location from where the static
    content needs to be served
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are the benefits of `WebClient`?
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`WebClient` is a non-blocking, asynchronous HTTP client for making requests.
    It can be configured with Java 8 lambdas for processing data.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: What is the difference between the retrieve and exchange APIs of WebClient?
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Retrieve`: This can decode a request body into a Flux or Mono'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Exchange`: The `Exchange` method provides the complete message, which can
    be converted back into a target type'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Chapter 7: Flow Control and Backpressure'
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Why do we need the `groupBy` operator?
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `groupBy()` operator converts `Flux<T>` into batches. The operator associates
    a key with each element of `Flux<T>`. It then groups elements that have the same
    key. These groups are then emitted by the operator.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: What is the difference between the `groupBy` and `buffer` operators?
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `groupBy` operator groups the stream of events based on a configured key,
    but the `buffer` operator splits the stream into chunks of a specified size. Thus,
    the `buffer` operator maintains the original ordering of events.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`groupBy` 操作符根据配置的键对事件流进行分组，但 `buffer` 操作符将流分割成指定大小的块。因此，`buffer` 操作符保持事件的原始顺序。'
- en: How can we throttle an event in Reactor?
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何在 Reactor 中节流事件？
- en: The `sample()` operator allows us to accomplish throttling.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`sample()` 操作符允许我们实现节流。'
- en: What is the difference between the `Overflow.Ignore` and the `OverFlow.Latest`
    strategies?
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Overflow.Ignore` 和 `Overflow.Latest` 策略之间的区别是什么？'
- en: '`Overflow.Ignore` ignores the limits of the subscriber backpressure and keeps
    delivering the next event to the subscriber. `OverFlow.Latest` keeps the latest
    event raised in the buffer. The subscriber will only get the latest produced event
    when the next request is raised.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`Overflow.Ignore` 忽略订阅者背压的限制，并继续向订阅者发送下一个事件。`Overflow.Latest` 保持缓冲区中提出的最新事件。当下一次请求提出时，订阅者将只获得最新产生的事件。'
- en: Which operators are available for changing the backpressure strategy of a producer?
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪些操作符可用于更改生产者的背压策略？
- en: '`onBackpressureDrop()`'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onBackpressureDrop()`'
- en: '`onBackpressureLatest()`'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onBackpressureLatest()`'
- en: '`onBackpressureError()`'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onBackpressureError()`'
- en: '`onBackpressureBuffer()`'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onBackpressureBuffer()`'
- en: 'Chapter 8: Handling Errors'
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章：处理错误
- en: How is an error handled in Reactor?
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Reactor 中是如何处理错误的？
- en: Errors arise when either the publisher or the subscriber throws back an exception.
    Reactor intercepts the exception, builds an `Error` event, and then sends it to
    the subscriber. The subscriber must implement `ErrorCallbackHandler` to handle
    the error.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 当发布者或订阅者抛出异常时，会出现错误。Reactor 会在拦截异常后构建一个 `Error` 事件，并将其发送给订阅者。订阅者必须实现 `ErrorCallbackHandler`
    来处理错误。
- en: Which operators allow us to configure error handling?
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪些操作符允许我们配置错误处理？
- en: '`onErrorReturn`'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onErrorReturn`'
- en: '`onErrorResume`'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onErrorResume`'
- en: '`onErrorMap`'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onErrorMap`'
- en: What is the difference between `onErrorResume` and `onErrorReturn`?
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`onErrorResume` 和 `onErrorReturn` 之间的区别是什么？'
- en: The `OnErrorReturn` operator provides a fall-back value in the event of an error.
    On the other hand, the `OnErrorResume` operator provides a fall-back value stream
    instead of a single fall-back value.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`OnErrorReturn` 操作符在发生错误时提供后备值。另一方面，`OnErrorResume` 操作符提供后备值流而不是单个后备值。'
- en: How can we generate a timely response for a Reactive Streams?
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何为反应式流生成及时响应？
- en: The `timeout()` operator can be configured for a time interval. The operator
    will raise an error when it first discovers a delay of more than the configured
    time. The operator also has a fallback Flux. The fallback value is returned once
    the timeout expires.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`timeout()` 操作符可以配置时间间隔。当操作符首次发现延迟超过配置时间时，将引发错误。操作符还有一个后备 Flux。当超时到期时，将返回后备值。'
- en: How does the `retry` operator behave?
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`retry` 操作符是如何表现的？'
- en: The `retry` operator allows us to resubscribe to a published stream when an
    error is discovered. The `retry` operation can only be performed a fixed number
    of times. The resubscribed events are handled as next events by the subscriber.
    If the stream completes normally, no next retry takes place.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`retry` 操作符允许我们在发现错误时重新订阅已发布的流。`retry` 操作只能执行固定次数。重新订阅的事件由订阅者作为后续事件处理。如果流正常完成，则不会进行后续重试。'
- en: 'Chapter 9: Execution Control'
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章：执行控制
- en: What are the different types of schedulers available in Reactor?
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Reactor 中可用的不同类型的调度器有哪些？
- en: '`Schedulers.immediate`: This schedules on the current thread'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Schedulers.immediate`: 这将在当前线程上调度'
- en: '`Schedulers.single`: This schedules on a single thread'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Schedulers.single`: 这将在单个线程上调度'
- en: '`Schedulers.parallel`: This schedules on the thread pool'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Schedulers.parallel`: 这将在线程池上调度'
- en: '`Schedulers.elastic`: This schedules on a thread pool'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Schedulers.elastic`: 这将在线程池上调度'
- en: '`Schedulers.fromExecutor`: This schedules the configured executor service'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Schedulers.fromExecutor`: 这将在配置的执行器服务上调度'
- en: Which scheduler should be used for blocking operations?
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应该使用哪个调度器来处理阻塞操作？
- en: '`Schedulers.elastic` schedules on a thread pool.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`Schedulers.elastic` 在线程池上调度。'
- en: Which scheduler should be used for computation intensive operations?
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应该使用哪个调度器来处理计算密集型操作？
- en: '`Schedulers.single`: This schedules on a single thread.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Schedulers.single`: 这将在单个线程上调度'
- en: '`Schedulers.parallel`: This schedules on the thread pool'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Schedulers.parallel`: 这将在线程池上调度'
- en: How are `PublishOn` and `SubscriberOn` different from each other?
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`PublishOn` 和 `SubscriberOn` 与彼此有何不同？'
- en: The `subscribeOn` operator intercepts events from a publisher in the execution
    chain and sends them to a different scheduler for the complete chain. It is important
    to note that the operator changes the execution context for the complete chain,
    unlike the `publishOn` operator, which only alters the execution of a downstream
    chain.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`subscribeOn` 操作符会拦截执行链中的发布者事件并将它们发送到不同的调度器以完成整个链。需要注意的是，该操作符会改变整个链的执行上下文，与仅改变下游链执行的
    `publishOn` 操作符不同。'
- en: What is the limitation of `ParallelFlux`?
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ParallelFlux` 的局限性是什么？'
- en: '`ParallelFlux` does not offer the `doFinally` lifecycle hook. It can be converted
    back to a `Flux` using the `sequential` operator, which can then be configured
    using the `doFinally` hook.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`ParallelFlux` 不提供 `doFinally` 生命周期钩子。它可以使用 `sequential` 操作符转换回 `Flux`，然后可以使用
    `doFinally` 钩子进行配置。'
- en: Which operators are available for generating a `ConnectedFlux`?
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪些操作符可用于生成 `ConnectedFlux`？
- en: '`replay`'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`replay`'
- en: '`publish`'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`publish`'
- en: 'Chapter 10: Testing and Debugging'
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 10 章：测试和调试
- en: Which test utility class is available in Reactor to validate the invoked operations
    on a stream?
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Reactor 中，哪个测试实用类可用于验证流上调用的操作？
- en: Reactor provides the `StepVerifier` component to validate the required operations
    in isolation.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: Reactor 提供了 `StepVerifier` 组件来独立验证所需的操作。
- en: What is the difference between `PublisherProbe` and `TestPublisher`?
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`PublisherProbe` 和 `TestPublisher` 之间的区别是什么？'
- en: The `PublisherProbe` utility can instrument an existing publisher. The probe
    keeps track of signals published by the publisher, which can be validated at the
    end of the test. On the other hand, `TestPublisher` is capable of generating the
    `Publisher` stub, which can be used to unit test Reactor operators.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`PublisherProbe` 实用类可以用于对现有的发布者进行监控。该监控器会跟踪发布者发布的信号，这些信号可以在测试结束时进行验证。另一方面，`TestPublisher`
    能够生成 `Publisher` 模拟器，这可以用于对 Reactor 操作符进行单元测试。'
- en: How should the virtual clock be configured to validate time-bound operations
    ?
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应如何配置虚拟时钟以验证时间限制操作？
- en: The virtual clock must be injected before performing any time-based operations.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行任何基于时间的操作之前，必须注入虚拟时钟。
- en: What is the difference between the `onOperatorDebug` hook and the `checkpoint`
    operator?
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`onOperatorDebug` 钩子和 `checkpoint` 操作符之间的区别是什么？'
- en: The `onOperatorDebug` hook makes a global change for all reactive pipelines.
    On the other hand, the `checkpoint` operator makes the change specific to the
    stream it is applied to.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`onOperatorDebug` 钩子会对所有反应式管道进行全局更改。另一方面，`checkpoint` 操作符会对应用到的流进行特定更改。'
- en: How can we turn on the logging of stream processing?
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何开启流处理日志记录？
- en: The `log` operator can be used to turn on logging.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `log` 操作符来开启日志记录。
