<html><head></head><body>
        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Creating Web Applications with Spring MVC</h1>
                
            
            <article>
                
<p class="calibre3">In the last chapter, we learned how to create JEE applications using EJBs. In this chapter, we are going to divert a bit from the core JEE specifications and learn Spring MVC. </p>
<p class="calibre3">Although this book is about JEE and Eclipse, and Spring MVC is not a part of JEE, it would be worthwhile to understand the Spring MVC framework. Spring MVC is a very popular framework for creating web applications and can be used with other JEE technologies, such as servlet, JSP, JPA, and EJBs.</p>
<p class="calibre3">JEE does support MVC out of the box, if you use JSF. Refer to <em class="calibre21">Java Server Faces</em> in <a href="part0037.html#1394Q0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55" class="calibre9"><span>Chapter 2</span></a>, <em class="calibre21">Creating a Simple JEE Web Application</em>, for details. However, there is a difference in the design of JSF and Spring MVC. JSF is a component-based MVC framework. It is designed so that the user interface designer can create pages by assembling reusable components that are either provided by JSF or custom-developed. Spring MVC is a request-response-based MVC framework. If you are familiar with writing JSP or servlets, then Spring MVC would be an easier framework to use than JSF. You can find a good description of component-based MVC (as implemented by JSF) and request-response-based MVC (as implemented by Spring MVC) by Ed Burns at <a href="http://www.oracle.com/technetwork/articles/java/mvc-2280472.html" class="calibre9"><span>http://www.oracle.com/technetwork/articles/java/mvc-2280472.html</span></a>. JSR 371 for MVC was supposed to be part of JEE 8, but this JSR was later withdrawn from JEE 8 specifications. You can find more information about JSR 371 (also called MVC 1.0) at <a href="https://www.mvc-spec.org/" class="calibre9">https://www.mvc-spec.org/</a>.</p>
<p class="calibre3">Before we see how Spring MVC works, we need to understand what the MVC framework is. <strong class="calibre5">MVC</strong> stands for <strong class="calibre5">Model-View-Controller</strong>. We are going to refer to the MVC framework in the context of Java web applications only, although it should be mentioned here that the MVC pattern is often used in desktop applications too:</p>
<ul class="calibre10">
<li class="calibre11"><strong class="calibre1">Model</strong>: The Model contains data that is used by the View to create the output. In the example that we have been following in this book, the <em class="calibre2">Course Management</em> application, if you have a <kbd class="calibre13">Course</kbd> class that contains information about the course to be displayed on a page, then the <kbd class="calibre13">Course</kbd> object can be called the Model.<br class="title-page-name"/>
Some definitions of MVC also include classes that implement business logic in the Model layer. For example, a <kbd class="calibre13">CourseService</kbd> class that takes a <kbd class="calibre13">Course</kbd> object and calls <kbd class="calibre13">CourseDAO</kbd> to save the <kbd class="calibre13">Course</kbd> in the database could also be considered a part of the Model layer.</li>
</ul>
<ul class="calibre10">
<li class="calibre11"><strong class="calibre1">View</strong>: The View is a page that is displayed to the user. A JSP that displays a list of courses could be considered a part of the View layer. The View holds a reference to the Model object and uses the data it contains to create the page that the user sees in the browser.</li>
</ul>
<ul class="calibre10">
<li class="calibre11"><strong class="calibre1">Controller:</strong> The Controller is the glue between Model and View. It handles requests/actions from the web client (for example, the browser), calls the Model to handle business logic, and makes Model objects available to the View to create the page (user interface) to be returned to the client. The Controller could be a servlet, as in the case of JSF, or could be POJOs (as in the case of Spring MVC). When Controllers are POJOs, <span>typically </span>they get called by <kbd class="calibre13">DispatcherServlet</kbd>. <kbd class="calibre13">DispatherServlet</kbd> is a servlet that receives the request and dispatches it to one of the Controllers, based on the configuration. We will see example of this later in the chapter.</li>
</ul>
<p class="calibre3">MVC provides separation of concerns; that is, the code for the user interface and the business logic are separate. Because of this, the UI and the business layer can be modified independently to a great extent. Of course, since the UI usually displays the data generated by the business layer, it may not always be possible to make changes to each of the layers independent of the others. Developers of appropriate skills can work on each layer independently. A UI expert need not be too worried about how the business layer is implemented and vice versa.</p>
<p class="calibre3">In this chapter, we will cover the following topics:</p>
<ul class="calibre10">
<li class="calibre11">Introduction to Spring dependency injection</li>
<li class="calibre11">Configuring Spring beans and injecting them into the application</li>
<li class="calibre11">Creating Spring MVC applications using the Eclipse plugin and JEE specifications such as JDBC, JPA, and JSP</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Dependency injection</h1>
                
            
            <article>
                
<p class="calibre3">Spring MVC is a part of the overall Spring Framework. The core feature of the Spring Framework is <strong class="calibre5">dependency injection</strong> (<strong class="calibre5">DI</strong>). Almost all other features of the Spring Framework use DI. Objects managed by the dependency injection framework are not directly instantiated in the code (using, for example, the <kbd class="calibre13">new</kbd> operator). Let's call them <em class="calibre21">managed objects</em>. These objects are created by a DI framework, such as Spring. Because these objects are created by a framework, the framework has a lot more flexibility in deciding how to set values in the object and from where to get them. For example, your <strong class="calibre5">Data Access Object</strong> (<strong class="calibre5">DAO</strong>) class might need an instance of a database connection factory object. However, instead of instantiating it in the DAO class, you just tell the DI framework that when it instantiates the DAO, it has to set the value of a member variable for the connection pool factory. Of course, the parameters for the connection pool factory will have to be configured somewhere and be known to the DI framework.</p>
<p class="calibre3">When a class instantiates another class, there is tight dependency between them. Such design could be a problem if you want to test classes independently of others. For example, you may want to test a class that has business logic, but one that also refers to a DAO, which in turn depends on a JDBC connection object. When testing the first class, you will have to instantiate the DAO and configure the connection pool. As we saw in <a href="part0108.html#36VSO0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55" class="calibre9"><span>Chapter 5</span></a>, <em class="calibre21">Unit Testing</em>, unit tests should be able to run without any external dependencies. One way to achieve this is by using DI. Instead of instantiating the DAO class, our class could refer to an interface that is implemented by the DAO and have the DI framework inject the implementation of this interface at runtime. When you are unit testing this class, the DI framework can be configured to inject a mock object that implements the required interface. Thus, DI enables loose coupling between objects.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Dependency injection in Spring</h1>
                
            
            <article>
                
<p class="calibre3">Because DI is at the core of the Spring Framework, let's spend some time understanding how it works in Spring. We will create a standalone application for this purpose. Create a simple Maven project. Add the following dependency for the Spring Framework:</p>
<pre class="calibre25">    &lt;dependency&gt; 
      &lt;groupId&gt;org.springframework&lt;/groupId&gt; 
      &lt;artifactId&gt;spring-context&lt;/artifactId&gt; 
      &lt;version&gt;5.0.5.RELEASE&lt;/version&gt; 
    &lt;/dependency&gt; </pre>
<p class="calibre3">Replace the preceding version number with the latest version of Spring. Classes managed by the DI container of Spring are called beans or components. You can either declare beans in an XML file or you can annotate the class. We will use annotations in this chapter. However, even though we use annotations, we need to specify the minimum configuration in an XML file. So, create an XML file in the <kbd class="calibre13">src/main/resource</kbd> folder of your project and name it <kbd class="calibre13">context.xml</kbd>. The reason that we are creating this file in the <kbd class="calibre13">src/main.resource</kbd> folder is that the files in this folder are made available in the classpath. Next, add the following content to <kbd class="calibre13">context.xml</kbd>:</p>
<pre class="calibre25"><span>&lt;?</span><span>xml</span><span> </span>version<span>=</span><span>"1.0"</span><span> </span>encoding<span>=</span><span>"UTF-8"</span><span>?&gt;</span><span> <br class="title-page-name"/></span>&lt;<span>beans</span><span> </span><span>xmlns</span><span>=</span><span>"http://www.springframework.org/schema/beans"</span><span> <br class="title-page-name"/></span><span><span>    </span></span><span>xmlns:xsi</span><span>=</span>"http://www.w3.org/2001/XMLSchema-instance"<span> <br class="title-page-name"/></span><span><span>    </span></span><span>xmlns:context</span><span>=</span>"http://www.springframework.org/schema/context"<span> <br class="title-page-name"/></span><span><span>   </span></span><span>xsi:schemaLocation</span><span>=</span>"http://www.springframework.org/schema/beans<br class="title-page-name"/><span>        </span>http://www.springframework.org/schema/beans/spring-beans.xsd<br class="title-page-name"/><span>        </span>http://www.springframework.org/schema/context<br class="title-page-name"/><span>        </span>http://www.springframework.org/schema/context/spring-context.xsd"<span>&gt;</span><span> <br class="title-page-name"/></span><span><span>        </span></span><span>&lt;</span><span>context:component-scan</span><span> </span><span>base-package</span><span>=</span>"packt.jee.eclipse.spring"<span>/&gt;</span><span> <br class="title-page-name"/></span><span>&lt;/</span>beans<span>&gt;</span> </pre>
<p class="calibre3">By using the <kbd class="calibre13">&lt;context:component-scan&gt;</kbd> tag, we are telling the Spring Framework to scan the <kbd class="calibre13">base-package</kbd> folder and then look for the classes annotated with <kbd class="calibre13">@Component</kbd> and recognize them as managed classes so that they can be made available when injecting dependencies. In the preceding example, all classes in the <kbd class="calibre13">packt.jee.eclipse.spring</kbd> package (and its sub-packages) would be scanned to identify components.</p>
<p class="calibre3">Information read from the configuration file must be saved in an object. In Spring, it is saved in an instance of the <kbd class="calibre13">ApplicationContext</kbd> interface. There are different implementations of <kbd class="calibre13">ApplicationContext</kbd>. We will be using the <kbd class="calibre13">ClassPathXmlApplicationContext</kbd> class, which looks for the configuration XML file in the classpath.</p>
<p class="calibre3">We will now create two Spring components. The first one is <kbd class="calibre13">CourseDAO</kbd>, and the second is <kbd class="calibre13">CourseService</kbd>. Although we won't write any business logic in these classes (the purpose of this example is to understand how DI works in Spring), assume that <kbd class="calibre13">CourseDAO</kbd> could have the code to access the database and <kbd class="calibre13">CourseService</kbd> calls <kbd class="calibre13">CourseDAO</kbd> to perform the database operations. So, <kbd class="calibre13">CourseService</kbd> is dependent on <kbd class="calibre13">CourseDAO</kbd>. To keep the code simple, we will not create any interface for <kbd class="calibre13">CourseDAO</kbd> but will have the direct dependency. Create the <kbd class="calibre13">CourseDAO</kbd> class as follows:</p>
<pre class="calibre25">package packt.jee.eclipse.spring; 
 
import org.springframework.stereotype.Component; 
 
@Component 
public class CourseDAO { 
 
} </pre>
<p class="calibre3">We will have no methods in <kbd class="calibre13">CourseDAO</kbd>, but as mentioned before, it could have methods to access the database. <kbd class="calibre13">@Component</kbd> marks this class as managed by Spring. Now, create the <kbd class="calibre13">CourseService</kbd> class. This class needs an instance of <kbd class="calibre13">CourseDAO</kbd>:</p>
<pre class="calibre25">package packt.jee.eclipse.spring; 
 
import org.springframework.beans.factory.annotation.Autowired; 
import org.springframework.stereotype.Component; 
 
@Component 
public class CourseService { 
 
  @Autowired 
  private CourseDAO courseDAO; 
 
  public CourseDAO getCourseDAO() { 
    return courseDAO; 
  } 
} </pre>
<p class="calibre3">We have declared a member variable called <kbd class="calibre13">courseDAO</kbd> and annotated it with <kbd class="calibre13">@Autowired</kbd>. This tells Spring to look for a component in its context (of <kbd class="calibre13">CourseDAO</kbd> type) and assign that to the <kbd class="calibre13">courseDAO</kbd> member.</p>
<p class="calibre3">We will now create the main class. It creates <kbd class="calibre13">ApplicationContext</kbd>, gets the <kbd class="calibre13">CourseService</kbd> bean, calls the <kbd class="calibre13">getCourseDAO</kbd> method, and then checks whether it was injected properly. Create the <kbd class="calibre13">SpringMain</kbd> class:</p>
<pre class="calibre25">package packt.jee.eclipse.spring; 
 
import org.springframework.context.ApplicationContext; 
import org.springframework.context.support.ClassPathXmlApplicationContext; 
 
public class SpringMain { 
 
  public static void main (String[] args) { 
    //create ApplicationContext 
    ApplicationContext ctx = new <br class="title-page-name"/>     ClassPathXmlApplicationContext("context.xml"); 
    //Get bean 
    CourseService courseService = (CourseService) <br class="title-page-name"/>     ctx.getBean("courseService"); 
    //Get and print CourseDAO. It should not be null 
    System.out.println("CourseDAO = " + <br class="title-page-name"/>     courseService.getCourseDAO()); 
  } 
} </pre>
<p class="calibre3">We first create an instance of <kbd class="calibre13">ClassPathXmlApplicationContext</kbd>. The configuration XML file is passed as an argument to the constructor. We then get the <kbd class="calibre13">courseService</kbd> bean/component. Note the naming convention when specifying the bean name; it is the class name with the first letter in lowercase. We then get and print the value of <kbd class="calibre13">CourseDAO</kbd>. The value won't show any meaningful information, but if the value is not null, then it would mean that the Spring DI container has injected it properly. Note that we have not instantiated <kbd class="calibre13">CourseDAO</kbd>; it is the Spring DI container that instantiates and injects this object.</p>
<p class="calibre3">In the preceding code, we saw an example of injecting objects at the member declaration (this is also called property injection). We can have this object injected in the constructors too:</p>
<pre class="calibre25">@Component 
public class CourseService { 
 
  private CourseDAO courseDAO; 
 
  @Autowired 
  public CourseService (CourseDAO courseDAO) { 
    this.courseDAO = coueseDAO; 
  } 
 
  public CourseDAO getCourseDAO() { 
    return courseDAO; 
  } 
} </pre>
<p class="calibre3">Note that the <kbd class="calibre13">@Autowired</kbd> annotation is moved to the constructor, and the single constructor argument is auto-injected. You can also have the object injected in a setter:</p>
<pre class="calibre25">@Component 
public class CourseService { 
 
  private CourseDAO courseDAO; 
 
  @Autowired 
  public void setCourseDAO (CourseDAO courseDAO) { 
    this.courseDAO = courseDAO; 
  } 
 
  public CourseDAO getCourseDAO() { 
    return courseDAO; 
  } 
} </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Component scopes</h1>
                
            
            <article>
                
<p class="calibre3">You can specify the scope for your components in Spring MVC. The default scope is singleton, which means that there will be only one instance of the component in the context. Every request for this component will be served with the same instance. The other scopes are as follows:</p>
<ul class="calibre10">
<li class="calibre11"><strong class="calibre1">Prototype</strong>: Each request for the component is served with a new instance of that class.</li>
<li class="calibre11"><strong class="calibre1">Request</strong>: Valid for web applications. Single instance of a component class created for each HTTP request.</li>
<li class="calibre11"><strong class="calibre1">Session</strong>: Single instance of a component class created for each HTTP session. Used in web applications.</li>
<li class="calibre11"><strong class="calibre1">Global session</strong>: Single instance of a component class created for the global HTTP session. Used in portlet applications.</li>
<li class="calibre11"><strong class="calibre1">Application</strong>: Single instance of a component class in the web application. The instance is shared by all sessions in that application.</li>
</ul>
<div class="packt_infobox">
<p class="calibre187">See  <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-factory-scopes" class="calibre17">https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-factory-scopes</a> for more information on component scopes in Spring.</p>
</div>
<p class="calibre3">If the component to be injected was not instantiated at the time it was requested, then Spring creates an instance of the component. In the previous example, we have not specified the scope of the <kbd class="calibre13">CourseDAO</kbd> component, so the same instance would be injected if there is another request for injecting <kbd class="calibre13">CourseDAO</kbd>. You can specify the scope in the <kbd class="calibre13">@Component</kbd> annotation. You can also specify the component name if you want to override the default name that Spring gives to the component.</p>
<p class="calibre3">To see if a single instance of a component is injected when no scope is specified, let's change the <kbd class="calibre13">main</kbd> method in the <kbd class="calibre13">SpringMain</kbd> class and make two calls to the <kbd class="calibre13">getBean</kbd> method:</p>
<pre class="calibre25">  public static void main (String[] args) { 
    //create ApplicationContext 
    ApplicationContext ctx = new <br class="title-page-name"/>     ClassPathXmlApplicationContext("context.xml"); 
    //call and print ctx.getBean first time 
    System.out.println("Course Service 1 - " + <br class="title-page-name"/>     ctx.getBean("courseService"));    System.out.println("Course Service 2 - " + <br class="title-page-name"/>     ctx.getBean("courseService")); 
  } </pre>
<p class="calibre3">Run the application and you should see the same instance of the <kbd class="calibre13">courseService</kbd> bean printed. Let's change the scope of the <kbd class="calibre13">CourseService</kbd> component:</p>
<pre class="calibre25">@Component 
@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE) 
public class CourseService { 
  //content remains the same 
} </pre>
<p class="calibre3">Run the application again; this time, you should see different instances of the <kbd class="calibre13">CourseService</kbd> component.</p>
<p class="calibre3">When Spring comes across the <kbd class="calibre13">@Autowire</kbd> annotation, it tries to find the component by type. In the preceding example, <kbd class="calibre13">courseDAO</kbd> is annotated with <kbd class="calibre13">@Autowire</kbd>. Spring tries to find a component of <kbd class="calibre13">CourseDAO</kbd> type; it finds an instance of <kbd class="calibre13">CourseDAO</kbd> and injects it. But what if there are multiple instances of the class in the context? In such a case, we can use the <kbd class="calibre13">@Qualifier</kbd> annotation to uniquely identify components. Let's now create the <kbd class="calibre13">ICourseDAO</kbd> interface, which will be implemented by two components, namely <kbd class="calibre13">CourseDAO</kbd> and <kbd class="calibre13">CourseDAO1</kbd>:</p>
<pre class="calibre25">public interface ICourseDAO { 
} </pre>
<p class="calibre3"><kbd class="calibre13">CourseDAO</kbd> implements <kbd class="calibre13">ICourseDAO</kbd> and is uniquely qualified as <kbd class="calibre13">"courseDAO"</kbd>:</p>
<pre class="calibre25">@Component 
@Qualifier("courseDAO") 
public class CourseDAO implements ICourseDAO { 
} </pre>
<p class="calibre3"><kbd class="calibre13">CourseDAO1</kbd> implements <kbd class="calibre13">ICourseDAO</kbd> and is uniquely qualified as <kbd class="calibre13">"courseDAO1"</kbd>:</p>
<pre class="calibre25">@Component 
@Qualifier("courseDAO1") 
public class CourseDAO1 implements ICourseDAO { 
} </pre>
<p class="calibre3">In the <kbd class="calibre13">CourseService</kbd> class, we will use a qualifier to uniquely identify whether we want <kbd class="calibre13">CourseDAO</kbd> or <kbd class="calibre13">CourseDAO1</kbd> to be injected:</p>
<pre class="calibre25">@Component 
public class CourseService { 
 
  @Autowired 
  private @Qualifier("courseDAO1") ICourseDAO courseDAO; 
 
  public ICourseDAO getCourseDAO() { 
    return courseDAO; 
  } 
} </pre>
<p class="calibre3">The qualifier can also be specified at method arguments, for example:</p>
<pre class="calibre25">@Autowired 
public void setCourseDAO (@Qualifier("courseDAO1") ICourseDAO <br class="title-page-name"/> courseDAO) { 
  this.courseDAO = courseDAO; 
} </pre>
<p class="calibre3">Run the application now. You should see that an instance of <kbd class="calibre13">CourseDAO1</kbd> is printed in the console.</p>
<p class="calibre3">We have covered the basics of dependency injection in Spring. However, Spring offers a lot more options and features for dependency injection than we have covered here. We will see more DI features as and when required in this chapter.</p>
<div class="packt_infobox">Visit <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-dependencies" class="calibre17">https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-dependencies</a> for more information about dependency injection in Spring.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Installing Spring Tool Suite</h1>
                
            
            <article>
                
<p class="calibre3"><strong class="calibre5">Spring Tool Suite</strong> (<strong class="calibre5">STS</strong>) is a set of tools in Eclipse for creating Spring applications. It can be either installed as a plugin to an existing installation of Eclipse JEE or can be installed standalone. The standalone version of STS is also packaged with Eclipse EE, so all Eclipse features for Java EE development are available in STS too. You can download STS from <a href="https://spring.io/tools" class="calibre9"><span>https://spring.io/tools</span></a>. Since we have already installed Eclipse EE, we will install STS as a plugin. The easiest way to install the STS plugin is from <span class="calibre12">Eclipse Marketplace</span>. Select the <span class="calibre12">Help</span> | <span class="calibre12">Eclipse Marketplace...</span> menu.</p>
<p class="calibre3">Type <kbd class="calibre13">Spring Tool Suite</kbd> in the <span class="calibre12">Find</span> box, and click the <span class="calibre12">Go</span> button:</p>
<div class="mce-root1"><br class="title-page-name"/>
<img src="../images/00178.jpeg" class="calibre188"/></div>
<div class="packt_figure1">Figure 8.1: Search fir STS in Eclipse Marketplace</div>
<div class="title-page-name">
<ol start="2" class="calibre14"/>
</div>
<p class="calibre3">Click <span class="calibre12">Install</span>. The next page shows the features of STS that will be installed. Click <span class="calibre12">Confirm</span> to install the selected features.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Creating a Spring MVC application</h1>
                
            
            <article>
                
<p class="calibre3">Spring MVC can be used for creating web applications. It provides an easy framework to map incoming web requests to a handler class (Controller) and create dynamic HTML output. It is an implementation of the MVC pattern. The Controller and Models are created as POJOs, and Views can be created using JSP, JSTL, XSLT, and even JSF. However, in this chapter, we will focus on creating Views using JSP and JSTL.</p>
<div class="packt_infobox">You can find the Spring web documentation at <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html" class="calibre17">https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html</a>.</div>
<p class="calibre3">A web request is handled by four layers in Spring MVC:</p>
<ul class="calibre10">
<li class="calibre11"><strong class="calibre1">Front controller</strong>: This is a Spring servlet configured in <kbd class="calibre13">web.xml</kbd>. Based on the request URL pattern, it passes requests to the Controller.</li>
<li class="calibre11"><strong class="calibre1">Controller</strong>: These are POJOs annotated with <kbd class="calibre13">@Controller</kbd>. For each Controller that you write, you need to specify a URL pattern that the Controller is expected to handle. Sub-URL patterns can be specified at the method level too. We will see examples of this later. Controller has access to Model and to HTTP request and response objects. Controller can delegate processing of a request to other business handler objects, get results, and populate the Model object, which is made available to View by Spring MVC.</li>
<li class="calibre11"><strong class="calibre1">Model</strong>: These are data objects. The Controller and View layers can set and get data from Model objects.</li>
<li class="calibre11"><strong class="calibre1">View</strong>: These are typically JSPs, but Spring MVC supports other types of Views too. See <span>View technologies</span> in the Spring documentation at <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-view" class="calibre9">https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-view</a>.</li>
</ul>
<p class="calibre3">We will learn Spring MVC in this chapter through examples, as we have been learning in some other chapters in this book. We will create a part of the same <em class="calibre21">Course Management</em> application using Spring MVC. The application will display a list of courses with options to add, remove, and modify them.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Creating a Spring project</h1>
                
            
            <article>
                
<p class="calibre3">First, make sure that you have installed STS in Eclipse EE. From the Eclipse menu, select <span class="calibre12">File</span> | <span class="calibre12">New</span> | <span class="calibre12">Other</span> and then select the <span class="calibre12">Spring</span> | <span class="calibre12">Spring Legacy Project</span> option. Enter the project name and select the <span class="calibre12">Spring MVC Project</span> template:</p>
<div class="mce-root1"><img src="../images/00179.jpeg" class="calibre189"/></div>
<div class="packt_figure1">Figure 8.2: Select the Spring MVC Project template</div>
<p class="calibre3">Click on <span class="calibre12">Next</span>. The page will ask you to enter the top-level package name:</p>
<div class="mce-root1"><img src="../images/00180.jpeg" class="calibre190"/></div>
<div class="packt_figure1">Figure 8.3: Enter top-level package name</div>
<p class="calibre3">Whatever you enter as a top-level package, the wizard takes the third sub-package as the application name. When the application is deployed in a server, the application name becomes the context name. For example, if you enter the package name as <kbd class="calibre13">packt.jee.course_management</kbd>, then <kbd class="calibre13">course_management</kbd> becomes the application name, and the base URL of the application on the local machine would be <kbd class="calibre13">http://localhost:8080/course_management/</kbd>.</p>
<p class="calibre3">Click <span class="calibre12">Finish</span>. This creates a Maven project with the required libraries for Spring MVC.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Understanding files created by the Spring MVC project template</h1>
                
            
            <article>
                
<p class="calibre3">Let's examine some of the files created by the template:</p>
<ul class="calibre10">
<li class="calibre11"><kbd class="calibre13">src/main/webapp/WEB-INF/web.xml</kbd>: A front Controller servlet is declared here, along with other configurations:</li>
</ul>
<pre class="calibre35">&lt;!-- Processes application requests --&gt; 
&lt;servlet&gt; 
  &lt;servlet-name&gt;appServlet&lt;/servlet-name&gt; 
  &lt;servlet- <br class="title-page-name"/> class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; 
  &lt;init-param&gt; 
    &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; 
    &lt;param-value&gt;/WEB-INF/spring/appServlet/servlet- <br class="title-page-name"/>     context.xml&lt;/param-value&gt; 
  &lt;/init-param&gt; 
  &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; 
&lt;/servlet&gt; </pre>
<p class="mce-root2"><kbd class="calibre13">DispatcherServlet</kbd> is the front Controller servlet. It is passed the path of the context (XML) file for configuring Spring DI. Recall that in the standalone Spring application, we created <kbd class="calibre13">context.xml</kbd> to configure dependency injection. The <kbd class="calibre13">DispatcherServlet</kbd> servlet is mapped to handle requests to this web application.</p>
<ul class="calibre10">
<li class="calibre11"><kbd class="calibre13">src/main/webapp/WEB-INF/spring/appServlet/servlet-context.xml</kbd>: Context configuration for Spring DI. Some of the notable configuration parameters in this file are as follows:</li>
</ul>
<pre class="calibre35">&lt;annotation-driven /&gt; </pre>
<p class="calibre3">This enables annotations for configuring dependency injection at the class level:</p>
<pre class="calibre25">&lt;resources mapping="/resources/**" location="/resources/" /&gt; </pre>
<p class="calibre3">Static files, such as CSS, JavaScript, and images, can be placed in the <kbd class="calibre13">resources</kbd> folder (<kbd class="calibre13">src/main/webapp/resources</kbd>):</p>
<pre class="calibre25">&lt;beans:bean <br class="title-page-name"/> class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; 
  &lt;beans:property name="prefix" value="/WEB-INF/views/" /&gt; 
  &lt;beans:property name="suffix" value=".jsp" /&gt; 
&lt;/beans:bean&gt; </pre>
<p class="calibre3">This tells Spring to use the <kbd class="calibre13">InternalResourceViewResolver</kbd> class to resolve Views. Properties of this bean tell the <kbd class="calibre13">InternalResourceViewResolver</kbd> class to look for the View files in the <kbd class="calibre13">/WEB-INF/views</kbd> folder. Furthermore, Views will be JSP files, as indicated by the suffix property. Our Views will be the JSP files in the <kbd class="calibre13">src/main/webapp/WEB-INF/views</kbd> folder:</p>
<pre class="calibre25">&lt;context:component-scan base-package="packt.jee.course_management" /&gt; </pre>
<p class="calibre3">This tells Spring to scan the <kbd class="calibre13">packt.jee.course_management</kbd> package and its sub-packages to search for components (annotated by <kbd class="calibre13">@Component</kbd>).</p>
<p class="calibre3">The default template also creates one Controller and one View. The controller class is <kbd class="calibre13">HomeController</kbd> in the package that you specified in the Spring project wizard (in our example, it is <kbd class="calibre13">packt.jee.course_management</kbd>). Controller in Spring MVC is called by the dispatcher servlet. Controllers are annotated by <kbd class="calibre13">@Controller</kbd>. To map the request path to a Controller, you use the <kbd class="calibre13">@RequestMapping</kbd> annotation. Let's see the code generated by the template in the <kbd class="calibre13">HomeController</kbd> class:</p>
<pre class="calibre25">@Controller 
public class HomeController { 
 
  private static final Logger logger = <br class="title-page-name"/>   LoggerFactory.getLogger(HomeController.class); 
 
  /** 
   * Simply selects the home view to render by returning its name. 
   */ 
  @RequestMapping(value = "/", method = RequestMethod.GET) 
  public String home(Locale locale, Model model) { 
    logger.info("Welcome home! The client locale is {}.", locale); 
 
    Date date = new Date(); 
    DateFormat dateFormat = <br class="title-page-name"/> DateFormat.getDateTimeInstance(DateFormat.LONG, DateFormat.LONG, locale); 
 
    String formattedDate = dateFormat.format(date); 
 
    model.addAttribute("serverTime", formattedDate ); 
 
    return "home"; 
  } 
} </pre>
<p class="calibre3">The <kbd class="calibre13">home</kbd> method is annotated with <kbd class="calibre13">@RequestMapping</kbd>. The value of mapping is <kbd class="calibre13">/</kbd>, which tells the dispatcher servlet to send all requests coming its way to this method. The <kbd class="calibre13">method</kbd> attribute tells the dispatcher to call the <kbd class="calibre13">home</kbd> method only for HTTP requests of <span class="calibre12">the</span><span class="calibre12"> </span><kbd class="calibre13">GET</kbd> <span class="calibre12">type. The</span> <kbd class="calibre13">home</kbd> <span class="calibre12">method takes two arguments, namely</span> <kbd class="calibre13">Locale</kbd> <span class="calibre12">and</span> <kbd class="calibre13">Model</kbd><span class="calibre12">; both are injected at runtime by Spring. The</span> <kbd class="calibre13">@RequestMapping</kbd> <span class="calibre12">annotation also tells Spring to insert any dependencies when calling the </span><kbd class="calibre13">home</kbd> <span class="calibre12">method, and so </span><kbd class="calibre13">locale</kbd> <span class="calibre12">and</span> <kbd class="calibre13">model</kbd> <span class="calibre12">are auto-injected.</span></p>
<p class="calibre3">The method itself does not do much; it gets the current date-time and sets it as an attribute in the Model. Any attributes set in the Model are available to the View (JSP). The method returns a string, <kbd class="calibre13">"home"</kbd>. This value is used by Spring MVC to resolve the View to be displayed. The <kbd class="calibre13">InternalResourceViewResolver</kbd> that we saw in <kbd class="calibre13">servlet-context.xml</kbd> previously resolves this as <kbd class="calibre13">home.jsp</kbd> in the <kbd class="calibre13">/WEB-INF/views</kbd> folder. <kbd class="calibre13">home.jsp</kbd> has the following code in the <kbd class="calibre13">&lt;body&gt;</kbd> tag:</p>
<pre class="calibre25">&lt;P&gt;  The time on the server is ${serverTime}. &lt;/P&gt; </pre>
<p class="calibre3">The <kbd class="calibre13">serverTime</kbd> variable comes<span class="calibre12"> from the Model object set in the </span><kbd class="calibre13">home</kbd> <span class="calibre12">method of</span> <kbd class="calibre13">HomeController</kbd><span class="calibre12">.</span></p>
<p class="calibre3">To run this project, we need to configure a server in Eclipse and add this project to the server. Refer to the <em class="calibre21">Configuring Tomcat in Eclipse</em> and <em class="calibre21">Running JSP in Tomcat</em> sections in <a href="part0037.html#1394Q0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55" class="calibre9"><span>Chapter 2</span></a>, <em class="calibre21">Creating a Simple JEE Web Application</em>.</p>
<p class="calibre3">Once you configure Tomcat and add the project to it, start the server. Then, right-click on the project and select <span class="calibre12">Run As</span> | <span class="calibre12">Run on Server</span>. You should see a <span class="calibre12">hello</span> message with the timestamp displayed in the internal Eclipse browser. The URL in the browser's address bar should be <kbd class="calibre13">http://localhost:8080/course_management/</kbd>, assuming that Tomcat is deployed on port <kbd class="calibre13">8080</kbd> and the context name (derived from the top-level package name) is <kbd class="calibre13">course_management</kbd>. If you want to change the default context name or remove the context, that is, deploy the application in the root context, then open the project properties (right-click on the project and select <span class="calibre12">Properties</span>) and go to <span class="calibre12">Web Project Settings</span>. You can change the context root name or remove it from this page:</p>
<div class="mce-root1"><img src="../images/00181.jpeg" class="calibre191"/></div>
<div class="packt_figure1">Figure 8.4: Context root setting</div>
<p class="calibre3">For our <em class="calibre21">Course Management</em> application, we are not going to need the <kbd class="calibre13">HomeController</kbd> class or <kbd class="calibre13">home.jsp</kbd>, so you can go ahead and delete these files.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Building the Spring MVC application using JDBC</h1>
                
            
            <article>
                
<p class="calibre3">In this section, we will build a part of the course management application using Spring MVC and JDBC. The application will display a list of courses and options for adding, deleting, and modifying courses. We will continue using the project that we created in the previous section. We will learn many of the features of Spring for data access using JDBC as we go along.</p>
<p class="calibre3">First, we will configure our datasource. We will use the same MySQL database that we created in the <em class="calibre21">Creating database schema</em> section of <a href="part0073.html#25JP20-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55" class="calibre9"><span>Chapter 4</span></a>, <em class="calibre21">Creating JEE Database Applications</em>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Configuring a datasource</h1>
                
            
            <article>
                
<p class="calibre3">In Spring, you can configure a JDBC datasource either in Java code or in the XML configuration (context) file. Before we see how to configure a datasource, we need to add some dependencies in Maven. In this chapter, we will use Apache's Commons DBCP component for connection pooling (recall that in <a target="_blank" href="part0073.html#25JP20-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55" class="calibre9">Chapter 4</a>, <em class="calibre21">Creating JEE Database Applications</em>, we selected the Hikari connection pool). Visit <a href="https://commons.apache.org/proper/commons-dbcp/" class="calibre9"><span>https://commons.apache.org/proper/commons-dbcp/</span></a> for details on Apache DBCP. In addition to adding a dependency for Apache DBCP, we need to add dependencies for Spring JDBC and the MySQL JDBC driver. Add the following dependencies to the <kbd class="calibre13">pom.xml</kbd> of the project:</p>
<pre class="calibre25">&lt;!-- Spring JDBC --&gt; 
&lt;dependency&gt; 
  &lt;groupId&gt;org.springframework&lt;/groupId&gt; 
  &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; 
  &lt;version&gt;${org.springframework-version}&lt;/version&gt; 
&lt;/dependency&gt; 
 
&lt;!-- Apache DBCP --&gt; 
&lt;dependency&gt; 
  &lt;groupId&gt;commons-dbcp&lt;/groupId&gt; 
  &lt;artifactId&gt;commons-dbcp&lt;/artifactId&gt; 
  &lt;version&gt;1.4&lt;/version&gt; 
&lt;/dependency&gt; 
 
&lt;!-- MySQL --&gt; 
&lt;dependency&gt; 
  &lt;groupId&gt;mysql&lt;/groupId&gt; 
  &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; 
  &lt;version&gt;8.0.9-rc&lt;/version&gt; 
&lt;/dependency&gt; </pre>
<p class="calibre3">If you want to create a datasource in Java code, you can do so as follows:</p>
<pre class="calibre25">DriverManagerDataSource dataSource = new <br class="title-page-name"/> DriverManagerDataSource(); 
dataSource.setDriverClassName("com.mysql.jdbc.Driver"); 
dataSource.setUrl("jdbc:mysql://localhost:3306/course_management"); 
dataSource.setUsername("your_user_name"); 
dataSource.setPassword("your_password"); </pre>
<p class="calibre3">However, we will configure a datasource in an XML configuration file. Open <kbd class="calibre13">servlet-context.xml</kbd> (you will find it in the <kbd class="calibre13">src/main/webapp/WEB-INF/spring/appServlet</kbd> folder) and add the following bean:</p>
<pre class="calibre25">&lt;beans:bean id="dataSource" 
  class="org.apache.commons.dbcp.BasicDataSource" destroy- method="close"&gt; 
    &lt;beans:property name="driverClassName" <br class="title-page-name"/> value="com.mysql.jdbc.Driver"/&gt;  &lt;beans:property name="url" <br class="title-page-name"/> value="jdbc:mysql://localhost:3306/course_management" /&gt; 
  &lt;beans:property name="username" value="your_user_name"/&gt; 
  &lt;beans:property name="password" value="your_password"/&gt; 
&lt;/beans:bean&gt; </pre>
<p class="calibre3">If you are wondering what <em class="calibre21">bean</em> means, it is the same as the component that we created in the examples earlier in the chapter. We have so far created a component using annotations, but the component and the bean can be declared in an XML file too. In fact, this is how it used to be in earlier versions, till support for annotations was added in Spring. In a real-world application, you may want to encrypt database passwords before specifying them in a configuration file. One way to decrypt a password before sending it to the database is to create a wrapper class for the datasource (in the previous example, create a wrapper for <kbd class="calibre13">org.apache.commons.dbcp.BasicDataSource</kbd>) and override the <kbd class="calibre13">setPassword</kbd> method, where you can decrypt the password.</p>
<p class="calibre3">If you want to keep the database connection parameters separate from the Spring configuration, then you can use a <kbd class="calibre13">properties</kbd> file. Spring provides a consistent way to access resources such as a <kbd class="calibre13">properties</kbd> file. Just as you can access web URLs using the <kbd class="calibre13">http</kbd> protocol prefix or the file URL using the <kbd class="calibre13">file</kbd> protocol prefix, Spring allows you to access resources in the classpath using the <kbd class="calibre13">classpath</kbd> prefix. For example, if we create a <kbd class="calibre13">jdbc.properties</kbd> file and save it in one of the folders in the classpath, then we could access it as <kbd class="calibre13">classpath:jdbc.properties</kbd>.</p>
<div class="packt_tip">Visit <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#resources" class="calibre17">https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#resources</a> for detailed information on accessing resources using Spring. The Spring resource URL formats can be used in configuration files or Spring APIs where the resource location is expected.</div>
<p class="calibre3">Spring also provides a convenient tag to load property files in context config XML. You can access the values of properties in a <kbd class="calibre13">property</kbd> file in the config XML using the <kbd class="calibre13">${property_name}</kbd> syntax.</p>
<p class="calibre3">We will move the database connection properties to a file in this example. Create <kbd class="calibre13">jdbc.properties</kbd> in the <kbd class="calibre13">src/main/resources</kbd> folder. Maven makes this folder available in the classpath, so we can access it using the Spring resource format in the XML configuration file:</p>
<pre class="calibre25">jdbc.driverClassName=com.mysql.jdbc.Driver 
jdbc.url=jdbc:mysql://localhost:3306/course_management 
jdbc.username=your_user_name 
jdbc.password=your_password </pre>
<p class="calibre3">We will load this <kbd class="calibre13">properties</kbd> file from <kbd class="calibre13">servlet-context.xml</kbd> using the <kbd class="calibre13">property-placeholder</kbd> tag:</p>
<pre class="calibre25">&lt;context:property-placeholder location="classpath:jdbc.properties"/&gt; </pre>
<p class="calibre3">Notice that the location of the <kbd class="calibre13">property</kbd> file is specified using the Spring resource format. In this case, we ask Spring to look for the <kbd class="calibre13">jdbc.properties</kbd> file in the classpath. Further, because the <kbd class="calibre13">src/main/resources</kbd> folder is in the classpath (where we saved <kbd class="calibre13">jdbc.properties</kbd>), it should be loaded by Spring.</p>
<p class="calibre3">Let's now modify the <kbd class="calibre13">datasource</kbd> bean declaration in <kbd class="calibre13">servlet-context.xml</kbd> to use the property values:</p>
<pre class="calibre25">&lt;beans:bean id="dataSource" 
  class="org.apache.commons.dbcp.BasicDataSource" destroy- method="close"&gt; 
    &lt;beans:property name="driverClassName" <br class="title-page-name"/> value="${jdbc.driverClassName}"/&gt; 
  &lt;beans:property name="url" value="${jdbc.url}" /&gt; 
  &lt;beans:property name="username" value="${jdbc.username}"/&gt; 
  &lt;beans:property name="password" value="${jdbc.password}"/&gt; 
&lt;/beans:bean&gt; </pre>
<p class="calibre3">Note that the order of<span class="calibre12"> the</span> <kbd class="calibre13">property-placeholder</kbd> tag and where the properties are used does not matter. Spring loads the entire XML configuration file before replacing <kbd class="calibre13">property</kbd> references with their values.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Using the Spring JDBCTemplate class</h1>
                
            
            <article>
                
<p class="calibre3">Spring provides a utility class called <kbd class="calibre13">JDBCTemplate</kbd> that makes it easy to perform many operations using JDBC. It provides convenient methods to execute SQL statements, map results of a query to an object (using<span class="calibre12"> the</span> <kbd class="calibre13">RowMapper</kbd> class), close a database connection at the end of database operations, and many others.</p>
<div class="packt_tip">Visit <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/data-access.html#jdbc" class="calibre17">https://docs.spring.io/spring/docs/current/spring-framework-reference/data-access.html#jdbc</a> for more information on <kbd class="calibre48">JDBCTemplate</kbd>.</div>
<p class="calibre3">Before we write any data access code, we will create a <strong class="calibre5">Data Transfer Object</strong> (<strong class="calibre5">DTO</strong>), <kbd class="calibre13">CourseDTO</kbd>, which will just contain members that describe one <kbd class="calibre13">Course</kbd> and setters and getters for them. Create <kbd class="calibre13">CourseDTO</kbd> in<span class="calibre12"> the</span> <kbd class="calibre13">packt.jee.course_management.dto</kbd> package. Instances of this class will be used to transfer data between different tiers of our application:</p>
<pre class="calibre25">public class CourseDTO { 
  private int id; 
  private int credits; 
  private String name; 
 
  //skipped setters and getters to save space 
} </pre>
<p class="calibre3">We will now create a simple DAO that will use<span class="calibre12"> the</span> <kbd class="calibre13">JdbcTemplate</kbd> class to execute a query to get all courses. Create<span class="calibre12"> the</span> <kbd class="calibre13">CourseDAO</kbd> class in<span class="calibre12"> the</span> <kbd class="calibre13">packt.jee.course_management.dao</kbd> package. Annotate<span class="calibre12"> the</span> <kbd class="calibre13">CourseDAO</kbd> class with <kbd class="calibre13">@Repository</kbd>. Similar to <kbd class="calibre13">@Component</kbd>,<span class="calibre12"> the</span> <kbd class="calibre13">@Repository</kbd> annotation marks the class as a Spring DI container-managed class.</p>
<p class="calibre3">As per the Spring documentation (<a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-stereotype-annotations" class="calibre9">https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-stereotype-annotations</a>), <kbd class="calibre13">@Component</kbd> is a generic annotation to mark a class as Spring container-managed, and <kbd class="calibre13">@Repository</kbd> and <kbd class="calibre13">@Controller</kbd> are more specific ones. More specific annotations help to identify classes for specific treatments. It is recommended to use <kbd class="calibre13">@Repository</kbd> annotations for DAOs.</p>
<p class="calibre3"><kbd class="calibre13">CourseDAO</kbd> needs to have an instance of<span class="calibre12"> the</span> <kbd class="calibre13">JdbcTemplate</kbd> class to execute queries and other SQL statements. <kbd class="calibre13">JdbcTemplate</kbd> needs a <kbd class="calibre13">DataSource</kbd> object before it can be used. We will have <kbd class="calibre13">DataSource</kbd> injected in a method in <kbd class="calibre13">CourseDAO</kbd>:</p>
<pre class="calibre25">@Repository 
public class CourseDAO { 
 
  private JdbcTemplate jdbcTemplate; 
 
  @Autowired 
  public void setDatasource (DataSource dataSource) { 
    jdbcTemplate = new JdbcTemplate(dataSource); 
  } 
} </pre>
<p class="calibre3">The <kbd class="calibre13">datasource</kbd> that we have configured in <kbd class="calibre13">servlet-context.xml</kbd> will be injected by Spring when the <kbd class="calibre13">CourseDAO</kbd> object is created.</p>
<p class="calibre3">We will now write the method to get all courses.<span class="calibre12"> The</span> <kbd class="calibre13">JdbcTemplate</kbd> class has a <kbd class="calibre13">query</kbd> method that allows you to specify <kbd class="calibre13">RowMapper</kbd>, where you can map each row in the query to a Java object:</p>
<pre class="calibre25">public List&lt;CourseDTO&gt; getCourses() { 
  List&lt;CourseDTO&gt; courses = jdbcTemplate.query("select * from 
  course", 
    new CourseRowMapper()); 
 
  return courses; 
} 
 
public static final class CourseRowMapper implements <br class="title-page-name"/> RowMapper&lt;CourseDTO&gt; { 
  @Override 
  public CourseDTO mapRow(ResultSet rs, int rowNum) throws <br class="title-page-name"/>   SQLException { 
    CourseDTO course = new CourseDTO(); 
    course.setId(rs.getInt("id")); 
    course.setName(rs.getString("name")); 
    course.setCredits(rs.getInt("credits")); 
    return course; 
  } 
} </pre>
<p class="calibre3">In<span class="calibre12"> the</span> <kbd class="calibre13">getCourses</kbd> method, we will execute a static query. Later, we will see how to execute parameterized queries too. The second argument to<span class="calibre12"> the</span> <kbd class="calibre13">query</kbd> method of <kbd class="calibre13">JDBCTemplate</kbd> is an instance of<span class="calibre12"> the</span> <kbd class="calibre13">RowMapper</kbd> interface. We have created the static inner class <kbd class="calibre13">CourseRowMapper</kbd> that implements<span class="calibre12"> the</span> <kbd class="calibre13">RowMapper</kbd> interface. We override<span class="calibre12"> the</span> <kbd class="calibre13">mapRow</kbd> method, which is called for each row in <kbd class="calibre13">ResultSet</kbd>, and then we create/map<span class="calibre12"> the</span> <kbd class="calibre13">CourseDTO</kbd> object from<span class="calibre12"> the</span> <kbd class="calibre13">ResultSet</kbd> passed in the arguments. The method returns<span class="calibre12"> a </span><kbd class="calibre13">CourseDTO</kbd> object. The result of <kbd class="calibre13">JdbcTemplate.query</kbd> is a list of <kbd class="calibre13">CourseDTO</kbd> objects. Note that the <kbd class="calibre13">query</kbd> method can also return other Java collection objects, such as <kbd class="calibre13">Map</kbd>.</p>
<p class="calibre3">Now, let's write a method to add a course to the table:</p>
<pre class="calibre25">public void addCourse (final CourseDTO course) { 
  KeyHolder keyHolder = new GeneratedKeyHolder(); 
  jdbcTemplate.update(new PreparedStatementCreator() { 
 
    @Override 
    public PreparedStatement createPreparedStatement(Connection <br class="title-page-name"/>     con) 
        throws SQLException { 
      String sql = "insert into Course (name, credits) values <br class="title-page-name"/>       (?,?)";      PreparedStatement stmt = con.prepareStatement(sql, new <br class="title-page-name"/>       String[] {"id"}); 
      stmt.setString(1, course.getName()); 
      stmt.setInt(2, course.getCredits()); 
      return stmt; 
    } 
  }, keyHolder); 
 
  course.setId(keyHolder.getKey().intValue()); 
} </pre>
<p class="calibre3">When we add or insert a new course, we want to get the ID of the new record, which is autogenerated. Furthermore, we would like to use the prepared statement to execute SQL. Therefore, first we create <kbd class="calibre13">KeyHolder</kbd> for the auto-generated field. The <kbd class="calibre13">update</kbd> method of <kbd class="calibre13">JdbcTemplate</kbd> has many overloaded versions. We use the one that takes <kbd class="calibre13">PreparedStatementCreator</kbd> and <kbd class="calibre13">KeyHolder</kbd>. We create an instance of <kbd class="calibre13">PreparedStatementCreator</kbd> and override<span class="calibre12"> the</span> <kbd class="calibre13">createPreparedStatement</kbd> method. In this method, we create a JDBC <kbd class="calibre13">PreparedStatement</kbd> and return it. Once the update method is successfully executed, we retrieve the auto-generated value by calling<span class="calibre12"> the</span> <kbd class="calibre13">getKey</kbd> method of <kbd class="calibre13">KeyHolder</kbd>.</p>
<p class="calibre3">The methods to update or delete a course are similar:</p>
<pre class="calibre25">public void updateCourse (final CourseDTO course) { 
  jdbcTemplate.update(new PreparedStatementCreator() { 
    @Override 
    public PreparedStatement createPreparedStatement(Connection <br class="title-page-name"/>     con) 
        throws SQLException { 
      String sql = "update Course set name = ?, credits = ? where <br class="title-page-name"/>       id = ?"; 
      PreparedStatement stmt = con.prepareStatement(sql); 
      stmt.setString(1, course.getName()); 
      stmt.setInt(2, course.getCredits()); 
      stmt.setInt(3, course.getId()); 
      return stmt; 
    } 
  }); 
} 
 
public void deleteCourse(final int id) { 
  jdbcTemplate.update(new PreparedStatementCreator() { 
    @Override 
    public PreparedStatement createPreparedStatement(Connection <br class="title-page-name"/>     con) 
        throws SQLException { 
      String sql = "delete from Course where id = ?"; 
      PreparedStatement stmt = con.prepareStatement(sql); 
      stmt.setInt(1, id); 
      return stmt; 
    } 
  }); 
} </pre>
<p class="calibre3">We need to add one more method to <kbd class="calibre13">CourseDAO</kbd>, to get the details of a course, given the ID:</p>
<pre class="calibre25">public CourseDTO getCourse (int id) { 
  String sql = "select * from course where id = ?"; 
  CourseDTO course = jdbcTemplate.queryForObject(sql, new <br class="title-page-name"/>   CourseRowMapper(), id); 
  return course; 
}</pre>
<p class="calibre3"><kbd class="calibre13">queryForObject</kbd> returns a single object for a given query. We use a parameterized query here, and the parameter is passed as the last argument to<span class="calibre12"> the</span> <kbd class="calibre13">queryForObject</kbd> method. Further, we use <kbd class="calibre13">CourseRowMapper</kbd> to map the single row returned by this query to <kbd class="calibre13">CourseDTO</kbd>. Note that you can pass a variable number of parameters to<span class="calibre12"> the</span> <kbd class="calibre13">queryForObject</kbd> method, although in this case, we pass a single value, that is, the ID.</p>
<p class="calibre3">We now have all the methods in<span class="calibre12"> the</span> <kbd class="calibre13">CourseDAO</kbd> class to access data for <kbd class="calibre13">Course</kbd>.</p>
<div class="packt_tip">For a detailed discussion on data access using JDBC in Spring, refer to <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/data-access.html#jdbc" class="calibre17">https://docs.spring.io/spring/docs/current/spring-framework-reference/data-access.html#jdbc</a>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Creating the Spring MVC Controller</h1>
                
            
            <article>
                
<p class="calibre3">We will now create the <kbd class="calibre13">Controller</kbd> class. In Spring MVC, the Controller is mapped to the request URL and handles requests matching the URL pattern. The request URL for matching an incoming request is specified at the method level in the controller. However, more generic request mapping can be specified at<span class="calibre12"> the</span> <kbd class="calibre13">Controller</kbd> class level, and a specific URL, with respect to the URL at the class level, can be specified at the method level.</p>
<p class="calibre3">Create a class named <kbd class="calibre13">CourseController</kbd> in<span class="calibre12"> the</span> <kbd class="calibre13">packt.jee.course_management.controller</kbd> package. Annotate it with <kbd class="calibre13">@Controller</kbd>.<span class="calibre12"> The</span> <kbd class="calibre13">@Controller</kbd> annotation is of type <kbd class="calibre13">@Component</kbd>, and allows the Spring Framework to identify that class specifically as a controller. Add the method to get courses in <kbd class="calibre13">CourseController</kbd>:</p>
<pre class="calibre25">@Controller 
public class CourseController { 
  @Autowired 
  CourseDAO courseDAO; 
 
  @RequestMapping("/courses") 
  public String getCourses (Model model) { 
    model.addAttribute("courses", courseDAO.getCourses()); 
    return "courses"; 
  } 
} </pre>
<p class="calibre3">The <kbd class="calibre13">CourseDAO</kbd> instance is autowired; that is, it will be injected by Spring. We have added<span class="calibre12"> the</span>  <kbd class="calibre13">getCourses</kbd> method, which takes a Spring Model object. Data can be shared between View and Controller using this Model object. Therefore, we add an attribute to Model, named <kbd class="calibre13">courses</kbd>, and assign the list of courses that we get by calling <kbd class="calibre13">courseDAO.getCourses</kbd>. This list could be used in the View JSP as<span class="calibre12"> the</span> <kbd class="calibre13">courses</kbd> variable. We have annotated this method with <kbd class="calibre13">@RequestMapping</kbd>. This annotation maps the incoming request URL to a controller method. In this case, we are saying that any request (relative to the root) that starts with <kbd class="calibre13">/courses</kbd> should be handled by<span class="calibre12"> the</span> <kbd class="calibre13">getCourses</kbd> method in this controller. We will add more methods to <kbd class="calibre13">CourseController</kbd> later and discuss some of the parameters that we can pass to<span class="calibre12"> the</span> <kbd class="calibre13">@RequestMapping</kbd> annotation, but first let's create a View to display the list of courses.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Creating View</h1>
                
            
            <article>
                
<p class="calibre3">We have created data access objects for <kbd class="calibre13">Course</kbd> and a Controller. Let's see how we can call them from a View. Views in Spring are typically JSPs. Create a JSP (name it <kbd class="calibre13">courses.jsp</kbd>) in<span class="calibre12"> the</span> <kbd class="calibre13">src/main/webapp/WEB-INF/views</kbd> folder. This is the folder that we configured in <kbd class="calibre13">servlet-context.xml</kbd> to hold the Spring View files.</p>
<p class="calibre3">Add the JSTL tag library in <kbd class="calibre13">courses.jsp</kbd>:</p>
<pre class="calibre25">&lt;%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %&gt; </pre>
<p class="calibre3">The markup code to display courses is very simple; we make use of<span class="calibre12"> the</span> <kbd class="calibre13">courses</kbd> variable, which is made available in the Model from<span class="calibre12"> the</span> <kbd class="calibre13">CourseController.getCourses</kbd> method and displays values using JSTL expressions:</p>
<pre class="calibre25">&lt;table&gt; 
  &lt;tr&gt; 
    &lt;th&gt;Id&lt;/th&gt; 
    &lt;th&gt;Name&lt;/th&gt; 
    &lt;th&gt;Credits&lt;/th&gt; 
    &lt;th&gt;&lt;/th&gt; 
  &lt;/tr&gt; 
  &lt;c:forEach items="${courses}" var="course"&gt; 
    &lt;tr&gt; 
      &lt;td&gt;${course.id}&lt;/td&gt; 
      &lt;td&gt;${course.name}&lt;/td&gt; 
      &lt;td&gt;${course.credits}&lt;/td&gt; 
    &lt;/tr&gt; 
  &lt;/c:forEach&gt; 
&lt;/table&gt; </pre>
<p class="calibre3">Recall that <kbd class="calibre13">courses</kbd> is a list of objects of <kbd class="calibre13">CourseDTO</kbd> type. Members of <kbd class="calibre13">CourseDTO</kbd> are accessed in<span class="calibre12"> the</span> <kbd class="calibre13">forEach</kbd> tag to display the actual values.</p>
<p class="calibre3">Unfortunately, we can't run this page from Eclipse the way we have so far in this book, that is, by right-clicking on the project or page and selecting <span class="calibre12">Run As</span> | <span class="calibre12">Run on Server</span>. If you try to run the project (right-click on the project and select the <span class="calibre12">Run</span> menu), then Eclipse will try to open the <kbd class="calibre13">http://localhost:8080/course_management/</kbd> URL, and because we do not have any start page (<kbd class="calibre13">index.html</kbd> or <kbd class="calibre13">index.jsp</kbd>), we will get an <span class="calibre12">HTTP 404 error</span>. The reason that we can't run the page by right-clicking and selecting the run option is that Eclipse tries to open <kbd class="calibre13">http://localhost:8080/course_management/WEB-INF/views/courses.jsp</kbd>, and this fails because files in <kbd class="calibre13">WEB-INF</kbd> are not accessible from outside the server. Another reason, or rather the primary reason, that this URL will not work is that in <kbd class="calibre13">web.xml</kbd>, we have mapped all requests to be handled by <kbd class="calibre13">DispatcherServlet</kbd> of the Spring Framework and it does not find a suitable mapping for the request URL. To run the application, open the URL <kbd class="calibre13">http://localhost:8080/course_management/courses</kbd> in the browser.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Mapping data using @ModelAttribute</h1>
                
            
            <article>
                
<p class="calibre3">In this section, we will implement the feature to insert a new course. In the process, we will learn more about mapping requests to methods and mapping request parameters to method arguments.</p>
<p class="calibre3">In the previous section, we implemented <kbd class="calibre13">CourseController</kbd> with one method, <kbd class="calibre13">getCourses</kbd>. We will now add methods to insert new courses. To add a course, we first need to display a View with a form that accepts the user input. When the user actually submits the form, the form data should be posted to a URL that handles insertion of the data to the database. Therefore, there are two requests involved here: the first is to display the <em class="calibre21">add course</em> form, and the second is to handle the data posted from the form. We will call the first request <kbd class="calibre13">addCourse</kbd> and the second request <kbd class="calibre13">doAddCourse</kbd>. Let's first create the user interface. Create a new JSP and name it <kbd class="calibre13">addCourse.jsp</kbd>. Add<span class="calibre12"> the</span> following markup to the <kbd class="calibre13">body</kbd> of the page (JSTL and other header declarations are skipped to save space):</p>
<pre class="calibre25">  &lt;h2&gt;Add Course&lt;/h2&gt; 
  &lt;c:if test="${not empty error}"&gt; 
    &lt;span style="color:red;"&gt; 
      ${error}&lt;br&gt; 
    &lt;/span&gt; 
  &lt;/c:if&gt; 
 
  &lt;c:set var="actionPath" <br class="title-page-name"/>   value="${pageContext.request.contextPath}/doAddCourse"/&gt; 
  &lt;form method="post" action="${actionPath}"&gt; 
    &lt;table&gt; 
      &lt;tr&gt; 
        &lt;td&gt;Course Name:&lt;/td&gt; 
        &lt;td&gt;&lt;input type="text" name="name" value="${course.name}"&gt; <br class="title-page-name"/>         &lt;/td&gt; 
      &lt;/tr&gt; 
      &lt;tr&gt; 
        &lt;td&gt;Credits:&lt;/td&gt; 
        &lt;td&gt;&lt;input type="text" name="credits" <br class="title-page-name"/>         value="${course.credits}"&gt; &lt;/td&gt; 
      &lt;/tr&gt; 
      &lt;tr&gt; 
        &lt;td colspan="2"&gt; 
        &lt;button type="submit"&gt;Submit&lt;/button&gt; 
        &lt;/td&gt; 
      &lt;/tr&gt; 
    &lt;/table&gt; 
    &lt;input type="hidden" name="id" value="${course.id}"&gt; 
  &lt;/form&gt; </pre>
<p class="calibre3">The page expects<span class="calibre12"> a </span>course variable to be made available by the controller. In the form body, it assigns<span class="calibre12"> the</span> values of the course to appropriate input fields; for example,<span class="calibre12"> the</span> <kbd class="calibre13">${course.name}</kbd> value is assigned to the text input for <kbd class="calibre13">Course Name</kbd>. The form posts the data to<span class="calibre12"> the</span> <kbd class="calibre13">"${pageContext.request.contextPath}/doAddCourse"</kbd> URL. Note that since our application is not deployed in the root context, we need to include the context name in the URL.</p>
<p class="calibre3">Let's now add Controller methods to handle two requests for add: <kbd class="calibre13">addCourse</kbd> and <kbd class="calibre13">doAddCourse</kbd>. When<span class="calibre12"> the</span> <kbd class="calibre13">addCourse</kbd> request is made, we want to serve the page that displays the input form. When the user clicks<span class="calibre12"> the</span> <span class="calibre12">Submit</span> button, we want form data to be sent using<span class="calibre12"> the</span> <kbd class="calibre13">doAddCourse</kbd> request. Open<span class="calibre12"> the</span> <kbd class="calibre13">CourseController</kbd> class and add the following method:</p>
<pre class="calibre25">  @RequestMapping("/addCourse") 
  public String addCourse (@ModelAttribute("course") CourseDTO <br class="title-page-name"/>   course, Model model) { 
    if (course == null) 
      course = new CourseDTO(); 
    model.addAttribute("course", course); 
    return "addCourse"; 
} </pre>
<p class="calibre3">The <kbd class="calibre13">addCourse</kbd> method is configured, using<span class="calibre12"> the</span> <kbd class="calibre13">@RequestMapping</kbd> annotation, to handle  request URLs starting (relative to context root) with <kbd class="calibre13">"/addCourse"</kbd>. If previously<span class="calibre12"> the</span>  <kbd class="calibre13">course</kbd> attribute was added to Model, then we want this object to be passed as an argument to this function. Using <kbd class="calibre13">@ModelAttribute</kbd>, we tell the Spring Framework to inject the Model attribute called <kbd class="calibre13">course</kbd> if it is present and assign it to the argument named <kbd class="calibre13">course</kbd>; else, <kbd class="calibre13">null</kbd> is passed. In<span class="calibre12"> the</span> case of the first request, Model would not have a <kbd class="calibre13">course</kbd> attribute, so it would be <kbd class="calibre13">null</kbd>. In the subsequent requests, for example, when the user-entered data in the form (to add a course) is not valid and we want to redisplay the page, Model will have<span class="calibre12"> the</span> <kbd class="calibre13">course</kbd> attribute.</p>
<p class="calibre3">We will now create a handler method for<span class="calibre12"> the</span> <kbd class="calibre13">'/doAddCourse'</kbd> request. This is a <kbd class="calibre13">POST</kbd> request sent when the user submits the form in <kbd class="calibre13">addCourse.jsp</kbd> (refer to the form and its <kbd class="calibre13">POST</kbd> attribute discussed earlier):</p>
<pre class="calibre25">  @RequestMapping("/doAddCourse")  
  public String doAddCourse (@ModelAttribute("course") CourseDTO <br class="title-page-name"/>   course,  Model model) { 
    try { 
      coursesDAO.addCourse(course); 
    } catch (Throwable th) { 
      model.addAttribute("error", th.getLocalizedMessage()); 
      return "addCourse"; 
    } 
    return "redirect:courses"; 
  } </pre>
<p class="calibre3">The <kbd class="calibre13">doAddCourse</kbd> method also asks Spring to inject the Model attribute called <kbd class="calibre13">course</kbd> as the first argument. It then adds the course to the database using <kbd class="calibre13">CourseDAO</kbd>. In<span class="calibre12"> the</span> case of an error, it returns<span class="calibre12"> the</span> <kbd class="calibre13">addCourse</kbd> string, and Spring MVC displays <kbd class="calibre13">addCourse.jsp</kbd> again. If the course is successfully added, then the request is redirected to <kbd class="calibre13">courses</kbd>, which tells Spring to process and display <kbd class="calibre13">courses.jsp</kbd>. Recall that in <kbd class="calibre13">servlet-context.xml</kbd> (the Spring context configuration file in<span class="calibre12"> the</span> <kbd class="calibre13">src/main/webapp/WEB-INF/spring/appServlet</kbd> folder), we configured a bean with<span class="calibre12"> the</span> <kbd class="calibre13">org.springframework.web.servlet.view.InternalResourceViewResolver</kbd> class. This class is extended from <kbd class="calibre13">UrlBasedViewResolver</kbd>, which understands how to handle URLs with <kbd class="calibre13">redirect</kbd> and <kbd class="calibre13">forward</kbd> prefixes. So, in <kbd class="calibre13">doAddCourse</kbd> we save the data in the database, and if successful, we redirect the request to <kbd class="calibre13">courses</kbd>, which displays (after processing <kbd class="calibre13">courses.jsp</kbd>) the list of courses.</p>
<p class="calibre3">At this point, if you want to test the application, browse to <kbd class="calibre13">http://localhost:8080/course_management/addCourse</kbd>. Enter the course name and credits and click <span class="calibre12">Submit</span>. This should take you to the courses page and display the list of courses.</p>
<p class="calibre3">Note that Spring MVC looks at the form field names and properties of the object in Model (in this case, <kbd class="calibre13">CourseDTO</kbd>) when mapping form values to the object. For example, the form field <kbd class="calibre13">name</kbd> is mapped to<span class="calibre12"> the</span> <kbd class="calibre13">CourseDTO.name</kbd> property. So, make sure that the names of the form fields and the property names in the class (objects of which are added to the Model) are the same.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Using parameters in @RequestMapping</h1>
                
            
            <article>
                
<p class="calibre3">We have seen how to use<span class="calibre12"> the</span> <kbd class="calibre13">@RequestMapping</kbd> annotation to map the incoming request to a Controller method. So far, we have mapped static URL patterns in <kbd class="calibre13">@RequestMapping</kbd>. However, it is possible to map parameterized URLs (like those used in REST; see <a href="https://spring.io/understanding/REST" class="calibre9"><span>https://spring.io/understanding/REST</span></a>) using <kbd class="calibre13">@RequestMapping</kbd>. The parameters are specified inside <kbd class="calibre13">{}</kbd>.</p>
<p class="calibre3">Let's add the feature to update an existing course. Here, we will only discuss how to code the Controller method for this feature. The complete code is available when you download the samples for this chapter.</p>
<p class="calibre3">Let's add the following method in <kbd class="calibre13">CourseController</kbd>:</p>
<pre class="calibre25">  @RequestMapping("/course/update/{id}") 
  public String updateCourse (@PathVariable int id, Model model) { 
    //TODO: Error handling 
    CourseDTO course = coursesDAO.getCourse(id); 
    model.addAttribute("course", course); 
    model.addAttribute("title", "Update Course"); 
    return "updateCourse"; 
  } </pre>
<p class="calibre3">Here, we map<span class="calibre12"> the</span> <kbd class="calibre13">updateCourse</kbd> method to handle requests with the following URL pattern: <kbd class="calibre13">/course/update/{id}</kbd>, where <kbd class="calibre13">{id}</kbd> could be replaced with the ID (number) of any existing course, or for that matter, any integer. To access the value of this parameter, we used<span class="calibre12"> the</span> <kbd class="calibre13">@PathVariable</kbd> annotation in the arguments.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Using Spring interceptors</h1>
                
            
            <article>
                
<p class="calibre3">Spring interceptors can be used to process any request before it reaches the controller. These could be used, for example, to implement security features (authentication and authorization). Like request mappers, interceptors can also be declared for specific URL patterns. Let's add the login page to our application, which should be displayed before any other page in the application if the user has not already logged in.</p>
<p class="calibre3">We will first create <kbd class="calibre13">UserDTO</kbd> in<span class="calibre12"> the</span> <kbd class="calibre13">packt.jee.course_management.dto</kbd> package. This class contains<span class="calibre12"> the</span> username, password, and any message to be displayed on the login page, for example, authentication errors:</p>
<pre class="calibre25">public class UserDTO { 
  private String userName; 
  private String password; 
  private String message; 
 
  public boolean messageExists() { 
    return message != null &amp;&amp; message.trim().length() &gt; 0; 
  } 
 
  //skipped setters and getters follow 
} </pre>
<p class="calibre3">Now, let's create<span class="calibre12"> the</span> <kbd class="calibre13">UserController</kbd> that will process the login request. Once the user is logged in successfully, we would like to keep this information in the session. <span class="calibre12"> The p</span>resence of this object in the session can be used to check whether the user is already logged in. Create<span class="calibre12"> the</span> <kbd class="calibre13">UserController</kbd> class in<span class="calibre12"> the</span> <kbd class="calibre13">packt.jee.course_management.controller</kbd> package:</p>
<pre class="calibre25">@Controller 
public class UserController { 
} </pre>
<p class="calibre3">Add a handler method for the <kbd class="calibre13">GET</kbd> request for the login page:</p>
<pre class="calibre25">  @RequestMapping (value="/login", method=RequestMethod.GET) 
  public String login (Model model) {
    UserDTO  user = new UserDTO(); 
    model.addAttribute("user", user); 
    return "login"; 
  } </pre>
<p class="calibre3">Note that we have specified the method attribute in<span class="calibre12"> the</span> <kbd class="calibre13">@RequestMapping</kbd> annotation. When the request URL is <kbd class="calibre13">/login</kbd> and the HTTP request type is <kbd class="calibre13">GET</kbd>, only then will<span class="calibre12"> the</span> <kbd class="calibre13">login</kbd> method be called. This method would not be called if a <kbd class="calibre13">POST</kbd> request is sent from the client. In<span class="calibre12"> the</span> <kbd class="calibre13">login</kbd> method, we create an instance of <kbd class="calibre13">UserDTO</kbd> and add it to the Model so that it is accessible to the View.</p>
<p class="calibre3">We will add a method to handle <kbd class="calibre13">POST</kbd> requests from the login page. We will keep the same URL, that is, <kbd class="calibre13">/login</kbd>:</p>
<pre class="calibre25">  @RequestMapping (value="/login", method=RequestMethod.POST) 
  public String doLogin (@ModelAttribute ("user") UserDTO user, 
  Model model) { 
 
    //Hard-coded validation of user name and 
//password to keep this example simple 
    //But validation could be done against database or 
//any other means here. 
    if (user.getUserName().equals("admin") &amp;&amp; 
         user.getPassword().equals("admin")) 
      return "redirect:courses"; 
 
    user.setMessage("Invalid user name or password. Please try <br class="title-page-name"/>     again"); 
    return "login"; 
  } </pre>
<p class="calibre3">We now have two methods in <kbd class="calibre13">UserController</kbd> handling the request URL <kbd class="calibre13">/login</kbd>. However, the login method handles <kbd class="calibre13">GET</kbd> requests and <kbd class="calibre13">doLogin</kbd> handles <kbd class="calibre13">POST</kbd> requests. If authentication is successful in<span class="calibre12"> the</span> <kbd class="calibre13">doLogin</kbd> method, then we redirect to the courses (list) page. Else, we set the error message and return to the login page.</p>
<p class="calibre3">Let's save the user object created in the login method in the HTTP session. This can be done with the simple <kbd class="calibre13">@SessionAttributes</kbd> annotation. You can specify the list of attributes in Model that need to be saved in the session too. Furthermore, we want to save<span class="calibre12"> the</span> <kbd class="calibre13">user</kbd> attribute of Model in the session. Therefore, we will add the following annotation to<span class="calibre12"> the</span> <kbd class="calibre13">UserController</kbd> class:</p>
<pre class="calibre25">@Controller 
@SessionAttributes("user") 
 
public class UserController { 
} </pre>
<p class="calibre3">Now, let's create the login page. Create <kbd class="calibre13">login.jsp</kbd> in<span class="calibre12"> the</span> <kbd class="calibre13">views</kbd> folder and add the following code in the HTML <kbd class="calibre13">&lt;body&gt;</kbd>:</p>
<pre class="calibre25">&lt;c:if test="${user.messageExists()}"&gt; 
  &lt;span style="color:red;"&gt; 
    ${user.message}&lt;br&gt; 
  &lt;/span&gt; 
&lt;/c:if&gt; 
 
&lt;form id="loginForm" method="POST"&gt; 
  User Id : &lt;input type="text" name="userName" required="required" <br class="title-page-name"/>   value="${user.userName}"&gt;&lt;br&gt; 
  Password : &lt;input type="password" name="password"&gt;&lt;br&gt; 
  &lt;button type="submit"&gt;Submit&lt;/button&gt; 
&lt;/form&gt; </pre>
<p class="calibre3">The page expects <kbd class="calibre13">user</kbd> (instance of <kbd class="calibre13">UserDTO</kbd>) to be available. It is made available by <kbd class="calibre13">UserController</kbd> through Model.</p>
<p class="calibre3">We now have the login page and <kbd class="calibre13">UserController</kbd> to handle the authentication, but how do we make sure this page is displayed for every request when the user is not logged in? This is where we can use Spring interceptors. We will configure an interceptor in the Spring context configuration file: <kbd class="calibre13">servlet-context.xml</kbd>. Add the following code to <kbd class="calibre13">servlet-context.xml</kbd>:</p>
<pre class="calibre25">&lt;interceptors&gt; 
  &lt;interceptor&gt; 
    &lt;mapping path="/**"/&gt; 
      &lt;beans:bean <br class="title-page-name"/> class="packt.jee.course_management.interceptor.LoginInterceptor"/&gt; 
  &lt;/interceptor&gt; 
&lt;/interceptors&gt; </pre>
<p class="calibre3">In this configuration, we are telling Spring to call <kbd class="calibre13">LoginInterceptor</kbd> before executing any request (indicated by <kbd class="calibre13">mapping path = "/**"</kbd>).</p>
<p class="calibre3">Let's now implement <kbd class="calibre13">LoginInterceptor</kbd>. Interceptors must implement <kbd class="calibre13">HandlerInterceptor</kbd>. We will make <kbd class="calibre13">LoginInterceptor</kbd> extend <kbd class="calibre13">HandlerInterceptorAdapter</kbd>, which implements <kbd class="calibre13">HandlerInterceptor</kbd>.</p>
<p class="calibre3">Create <kbd class="calibre13">LoginInterceptor</kbd> in<span class="calibre12"> the</span> <kbd class="calibre13">packt.jee.course_management.interceptor</kbd> package:</p>
<pre class="calibre25">@Component 
public class LoginInterceptor extends HandlerInterceptorAdapter { 
 
  public boolean preHandle(HttpServletRequest request, <br class="title-page-name"/>   HttpServletResponse response, Object handler) 
        throws Exception { 
 
    //get session from request 
    HttpSession session = request.getSession(); 
    UserDTO user = (UserDTO) session.getAttribute("user"); 
 
    //Check if the current request is for /login. In that case 
    //do nothing, else we will execute the request in loop 
    //Intercept only if request is not /login 
    String context = request.getContextPath(); 
    if (!request.getRequestURI().equals(context + "/login") &amp;&amp; 
      (user == null || user.getUserName() == null)) { 
      //User is not logged in. Redirect to /login 
      response.sendRedirect(request.getContextPath() + "/login"); 
      //do not process this request further 
      return false; 
    } 
 
    return true; 
  } 
 
} </pre>
<p class="calibre3">The <kbd class="calibre13">preHandle</kbd> method of the interceptor is called before Spring executes any request. If we return <kbd class="calibre13">true</kbd> from the method, then the request is handled further; else, it is aborted. In <kbd class="calibre13">preHandle</kbd>, we first check whether<span class="calibre12"> the</span> <kbd class="calibre13">user</kbd> object is present in the session. The presence of<span class="calibre12"> the</span> <kbd class="calibre13">user</kbd> object means that the user is already logged in. In such a case, we don't do anything more in this interceptor and return <kbd class="calibre13">true</kbd>. If the user is not logged in, then we redirect to the login page and return <kbd class="calibre13">false</kbd> so that Spring does not process this request further. </p>
<p class="calibre3">Browse to <kbd class="calibre13">http://localhost:8080/course_management/courses</kbd> to test the login page. If you are not already logged in, the login page should be displayed.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Spring MVC application using JPA</h1>
                
            
            <article>
                
<p class="calibre3">In the previous section, we learned how to create a web application using Spring and JDBC. In this section, we will take a quick look at how to use Spring with <strong class="calibre5">JPA</strong> (<strong class="calibre5">Java Persistence API</strong>). We have already learned how to use JPA in <a target="_blank" href="part0073.html#25JP20-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55" class="calibre9"><span>Chapter 4</span></a>, <em class="calibre21">Creating JEE Database Applications</em>, and in <a target="_blank" href="part0129.html#3R0OI0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55" class="calibre9"><span>Chapter 7</span></a>, <em class="calibre21">Creating JEE Applications with EJB</em>, so we won't go into detail of how to set up the Eclipse project for JPA. However, we will discuss how to use JPA along with Spring in detail in this section.</p>
<p class="calibre3">We will create a separate project for this example. Create a Spring MVC project as described in<span class="calibre12"> the</span> <em class="calibre21">Creating Spring project</em> section of this chapter. On the second page of the project wizard, where you are asked to enter a top-level package name, enter <kbd class="calibre13">packt.jee.course_management_jpa</kbd>. Recall that the last part of this package name is also used as the web application context.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Configuring JPA</h1>
                
            
            <article>
                
<p class="calibre3">We are going to use the EclipseLink JPA provider and the MySQL database driver in this project. So, add the Maven dependencies for them in<span class="calibre12"> the</span> <kbd class="calibre13">pom.xml</kbd> file of the project:</p>
<pre class="calibre25">  &lt;!-- JPA --&gt; 
  &lt;dependency&gt; 
        &lt;groupId&gt;org.eclipse.persistence&lt;/groupId&gt; 
        &lt;artifactId&gt;eclipselink&lt;/artifactId&gt; 
        &lt;version&gt;2.7.1&lt;/version&gt; 
      &lt;/dependency&gt; 
      &lt;dependency&gt; 
        &lt;groupId&gt;mysql&lt;/groupId&gt; 
        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; 
        &lt;version&gt;8.0.9-rc&lt;/version&gt; 
  &lt;/dependency&gt; </pre>
<p class="calibre3">We will now configure the project for JPA. Right-click on the project and select <span class="calibre12">Configure</span> | <span class="calibre12">Convert to JPA Project</span>. This opens the <span class="calibre12">Project Facets</span> page, with JPA selected as one of the facets:</p>
<div class="mce-root1"><br class="title-page-name"/>
<img src="../images/00182.jpeg" class="calibre192"/></div>
<div class="packt_figure1">Figure 8.5: Project facets</div>
<p class="calibre3">Click the <span class="calibre12">Next</span> button to configure the JPA facet:</p>
<div class="mce-root1"><img src="../images/00183.jpeg" class="calibre193"/></div>
<div class="packt_figure1">Figure 8.6: JPA facet</div>
<p class="calibre3">Select<span class="calibre12"> the</span> <span class="calibre12">EclipseLink</span> platform in the preceding page. We will also disable the library configuration (select from the dropdown for the <span class="calibre12">Type</span> field). Configure the MySQL <span class="calibre12">Connection</span> (named <span class="calibre12">CourseMgmtDBConnection</span>), as described in the <em class="calibre21">Configuring JPA</em> section of <a target="_blank" href="part0129.html#3R0OI0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55" class="calibre9"><span>Chapter 7</span></a>, <em class="calibre21">Creating JEE Applications with EJB</em>.</p>
<p class="calibre3">Click <span class="calibre12">Finish</span>. <kbd class="calibre13">Persistence.xml</kbd> is created under<span class="calibre12"> the</span> <span class="calibre12">JPA Content</span> group in <span class="calibre12">Project Explorer</span> (the actual location of this file is <kbd class="calibre13">src/main/resources/META-INF/persistence.xml</kbd>). We will configure properties for the MySQL JDBC connection in this. Open the file and click<span class="calibre12"> the</span> <span class="calibre12">Connection</span> tab:</p>
<div class="mce-root1"><img src="../images/00184.jpeg" class="calibre194"/></div>
<div class="packt_figure1">Figure 8.7: Configure connection in persistence.xml</div>
<p class="calibre3">Select <span class="calibre12">Transaction type</span> as <kbd class="calibre13">Resource Local</kbd>. Then, enter the JDBC driver details. Save the file.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Creating the Course entity</h1>
                
            
            <article>
                
<p class="calibre3">Let's now create the <kbd class="calibre13">Course</kbd> entity. Right-click on the project and select the <span class="calibre12">JPA Tools</span> | <span class="calibre12">Generate Tables from Entities</span> menu:</p>
<div class="mce-root1"><img src="../images/00185.jpeg" class="calibre195"/></div>
<div class="packt_figure1">Figure 8.8: Generate course entity</div>
<p class="calibre3">Make sure that <kbd class="calibre13">CourseMgmtDBConnection</kbd> is selected (refer to the <em class="calibre21">Configuring JPA</em> section of <a target="_blank" href="part0129.html#3R0OI0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55" class="calibre9"><span>Chapter 7</span></a>, <em class="calibre21">Creating JEE Applications with EJB</em>, for configuring a MySQL database connection in Eclipse) and that <span class="calibre12">List generated classes in persistence.xml</span> is selected. Click <span class="calibre12">Next</span> on this and the next page. On<span class="calibre12"> the</span> <span class="calibre12">Customize Defaults</span> page, select <span class="calibre12">identity </span>as the <span class="calibre12">Key generator</span> and set the package name as <kbd class="calibre13">packt.jee.course_management_jpa.entity</kbd>:</p>
<div class="mce-root1"><img src="../images/00186.jpeg" class="calibre196"/></div>
<div class="packt_figure1">Figure 8.9: Customize JPA entity defaults</div>
<p class="calibre3">Click <span class="calibre12">Next</span>. Verify the entity class name and the other details:</p>
<div class="mce-root1"><img src="../images/00187.jpeg" class="calibre197"/></div>
<div class="packt_figure1">Figure 8.10: Customize JPA entity details</div>
<p class="calibre3">Click <span class="calibre12">Finish</span>. The <kbd class="calibre13">Course</kbd> entity class will be created in the package selected:</p>
<pre class="calibre25">//skipped imports 
@Entity 
@Table(name="COURSE") 
@NamedQuery(name="Course.findAll", query="SELECT c FROM Course c") 
public class Course implements Serializable { 
  private static final long serialVersionUID = 1L; 
 
  @Id 
  @GeneratedValue(strategy=GenerationType.IDENTITY) 
  private int id; 
 
  private int credits; 
 
  private String name; 
 
  @Column(name="teacher_id") 
  private int teacherId; 
 
  //skipped setter and getters 
} </pre>
<p class="calibre3">Note that the wizard has also created the named query to get all the courses from the table.</p>
<p class="calibre3">We now need to create <kbd class="calibre13">EntityManagerFactory</kbd> so that <kbd class="calibre13">EntityManager</kbd> can be created from it (refer to the <em class="calibre21">JPA concepts</em> section in <a target="_blank" href="part0073.html#25JP20-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55" class="calibre9"><span>Chapter 4</span></a>, <em class="calibre21">Creating JEE Database Applications</em>). We will create a Spring bean/component to create and store <kbd class="calibre13">EntityManagerFactory</kbd>. Furthermore, we will inject (autowire) this component into the DAO class.</p>
<p class="calibre3">Create<span class="calibre12"> the</span> <kbd class="calibre13">JPAEntityFactoryBean</kbd> class in<span class="calibre12"> the</span> <kbd class="calibre13">packt.jee.course_management_jpa.entity</kbd> package:</p>
<pre class="calibre25">//skipped imports 
 
@Component 
public class JPAEntityFactoryBean { 
 
  EntityManagerFactory entityManagerFactory; 
 
  @PostConstruct 
  public void init() { 
    entityManagerFactory = 
Persistence.createEntityManagerFactory("CourseManagementSpringMVCJPA"); 
  } 
 
  public EntityManagerFactory getEntityManagerFactory() { 
    return entityManagerFactory; 
  } 
} </pre>
<p class="calibre3">In the constructor of the class, we create <kbd class="calibre13">EntityManagerFactory</kbd>. The argument to <kbd class="calibre13">createEntityManagerFactory</kbd> is<span class="calibre12"> the</span> name of the persistence unit, as specified in <kbd class="calibre13">persistence.xml</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Creating CourseDAO and Controller</h1>
                
            
            <article>
                
<p class="calibre3">Let's now create<span class="calibre12"> the</span> <kbd class="calibre13">CourseDAO</kbd> class. We will have an instance of <kbd class="calibre13">JPAEntityFactoryBean</kbd> injected (auto-wired) into this class. Create<span class="calibre12"> the</span> <kbd class="calibre13">packt.jee.course_management_jpa.dao</kbd> package and<span class="calibre12"> the</span> <kbd class="calibre13">CourseDAO</kbd> class in it:</p>
<pre class="calibre25">@Component 
public class CourseDAO { 
 
  @Autowired 
  JPAEntityFactoryBean entityFactoryBean; 
 
  public List&lt;Course&gt; getCourses() { 
    //Get entity manager 
    EntityManagerFactory emf = <br class="title-page-name"/>     entityFactoryBean.getEntityManagerFactory(); 
    EntityManager em = emf.createEntityManager(); 
 
    //Execute Query 
    TypedQuery&lt;Course&gt; courseQuery = <br class="title-page-name"/>     em.createNamedQuery("Course.findAll", Course.class); 
      List&lt;Course&gt; courses = courseQuery.getResultList(); 
      em.close(); 
     
      return courses; 
  } 
} </pre>
<p class="calibre3">In<span class="calibre12"> the</span> <kbd class="calibre13">getCourses</kbd> method, we first create <kbd class="calibre13">EntityManager</kbd> (from <kbd class="calibre13">JPAEntityFactoryBean</kbd>) and execute the named query. Once we get the results, we close <kbd class="calibre13">EntityManager</kbd>.</p>
<p class="calibre3">The <kbd class="calibre13">Controller</kbd> class for <kbd class="calibre13">Course</kbd> will have <kbd class="calibre13">CourseDAO</kbd> auto-injected (auto-wired). Create <kbd class="calibre13">CourseController</kbd> in<span class="calibre12"> the</span> <kbd class="calibre13">packt.jee.course_management_jpa.controller</kbd> package:</p>
<pre class="calibre25">//skipped imports 
@Controller 
public class CourseController { 
  @Autowired 
  CourseDAO courseDAO; 
 
  @RequestMapping("/courses") 
  public String getCourses(Model model) { 
    model.addAttribute("courses", courseDAO.getCourses()); 
    return "courses"; 
  } 
} </pre>
<p class="calibre3">As we saw in<span class="calibre12"> the</span> <kbd class="calibre13">CourseController</kbd> created for the JDBC application earlier, we get courses from the database and add the list of courses to the Model under the key name <kbd class="calibre13">courses</kbd>. This variable will be available to the View page that displays the list of courses.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Creating the course list view</h1>
                
            
            <article>
                
<p class="calibre3">We now have all the classes to get courses. Let's now create a JSP to display the list of courses. Create <kbd class="calibre13">courses.jsp</kbd> in<span class="calibre12"> the</span> <kbd class="calibre13">src/main/webapp/WEB-INF/views</kbd> folder. Add the following content in the HTML <kbd class="calibre13">body</kbd> tag of the page:</p>
<pre class="calibre25">&lt;h2&gt;Courses:&lt;/h2&gt; 
 
&lt;table&gt; 
  &lt;tr&gt; 
    &lt;th&gt;Id&lt;/th&gt; 
    &lt;th&gt;Name&lt;/th&gt; 
    &lt;th&gt;Credits&lt;/th&gt; 
    &lt;th&gt;&lt;/th&gt; 
  &lt;/tr&gt; 
  &lt;c:forEach items="${courses}" var="course"&gt; 
    &lt;tr&gt; 
      &lt;td&gt;${course.id}&lt;/td&gt; 
      &lt;td&gt;${course.name}&lt;/td&gt; 
      &lt;td&gt;${course.credits}&lt;/td&gt; 
    &lt;/tr&gt; 
  &lt;/c:forEach&gt; 
&lt;/table&gt; </pre>
<p class="calibre3">The View page makes use of JSTL tags to iterate over courses (using the variable that was made available in the Model by the Controller) and displays them.</p>
<p class="calibre3">We are not going to build the entire application here. The idea was to understand how to use JPA with Spring MVC, which we have learned in this section. Browse to <kbd class="calibre13">http://localhost:8080/course_management_jpa/courses</kbd> to run the application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            <article>
                
<p class="calibre3">In this chapter, we learned how to use Spring MVC to create web applications. As the name indicates, Spring MVC implements the MVC design pattern, which enables clear separation of the user interface code and the business logic code.</p>
<p class="calibre3">Using the dependency injection feature of the Spring Framework, we can easily manage the dependencies of different objects in the application. We also learned how to use JDBC and JPA along with Spring MVC to create data-driven web applications.</p>
<p class="calibre3">In the next chapter, we will see how to create and consume web services in JEE applications. We will look at both SOAP-based and RESTful web services.</p>


            </article>

            
        </section>
    </body></html>