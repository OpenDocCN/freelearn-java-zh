- en: Chapter 4. JSON and Asynchronous Processing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter covers a brand new JSR, The JSR 353: Java API for JSON Processing
    [http://jcp.org/en/jsr/detail?id=353](http://jcp.org/en/jsr/detail?id=353), and
    related APIs along with some updates in different services and components in Java
    EE that provide better support for asynchronous interaction between different
    components of a system. The following list shows an itemized list of topics that
    are covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Producing, parsing and manipulating JSON data using Java
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing NIO API in Servlet 3.1
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: New features in JAX-RS 2.0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Producing and parsing JSON documents
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JSON format was introduced as a replacement for the XML format when the extensibility
    and verbosity of XML were not required and thus to lift the resource consumption
    of complex XML processing to let smaller devices consume streams of data or data
    packets produced by different services they needed to interact with.
  prefs: []
  type: TYPE_NORMAL
- en: Before the Java EE 7 specification there was no standard API to process JSON
    documents in Java but rather there were some open source projects such as **google-gson**,
    [https://code.google.com/p/google-gson](https://code.google.com/p/google-gson
    ) and **Jackson**, [http://jackson.codehaus.org](http://jackson.codehaus.org)
    to manipulate JSON documents. With Java EE 7 and the addition of JSON-P to the
    arsenal, a standard API is added to Java EE to let the developers manipulate JSON
    documents in a standard fashion similar to XML processing of APIs.
  prefs: []
  type: TYPE_NORMAL
- en: The JSON-P API provides two parsing methods to parse JSON documents, the same
    two models that are available for parsing XML documents. The streaming event-based
    parsing and the object model tree parsing which are explained in the next two
    sections.
  prefs: []
  type: TYPE_NORMAL
- en: An overview of JSON API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The following table shows the important API segments of JSON-P along with a
    brief description of each class. The JSON API-related classes are placed under
    the `javax.json` package. The follow-up sections cover how each one of these can
    be used.
  prefs: []
  type: TYPE_NORMAL
- en: '| Class | Description and use |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `JsonParser` | A Pull parser to parse JSON objects using event model. |'
  prefs: []
  type: TYPE_TB
- en: '| `JsonGenerator` | A JSON stream writer to write JSON objects to an output
    source such as `OutputStream` and `Writ` `er` in a streaming manner. |'
  prefs: []
  type: TYPE_TB
- en: '| `JsonBuilder` | Builds `JsonObject` and `JsonArray` Programmatically |'
  prefs: []
  type: TYPE_TB
- en: '| `JsonReader` | Reads `JsonObject` and `JsonArray` from input source |'
  prefs: []
  type: TYPE_TB
- en: '| `JsonWriter` | Writes `JsonObject` and `JsonArray` to output source |'
  prefs: []
  type: TYPE_TB
- en: '| `JsonObject and JsonArray` | To store `JSONObject` and array structure |'
  prefs: []
  type: TYPE_TB
- en: '| `JsonString and JsonNumber` | To store string and numerical values |'
  prefs: []
  type: TYPE_TB
- en: The `JSONObject` is the entry point to the entire JSON API arsenal. For each
    one of the following objects JSON API provides a factory method as well as a creator
    to create them. For example, `Json.createParser` and `Json.createParserFactory`
    can be used to create a JSON parser. The factory can be configured to produce
    customized parsers or, when more than one parser is required, to reduce the performance
    overhead of creating the parsers while the `createParser` overloads can be used
    to create a JSON parser with a default configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Manipulating JSON documents using the event-based API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The event-based API is best used when a one way, going forward, parsing or producing
    of JSON documents is required. The event-based API works similar to **StAX** parsing
    of XML documents but in a much simpler (due to the JSON format being much simpler)
    fashion.
  prefs: []
  type: TYPE_NORMAL
- en: Producing JSON documents
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Producing JSON documents using the event-based API is most suitable when a stream
    of events is arriving and they require transforming to JSON format for another
    processor that consumes JSON format.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following sample code shows how to generate JSON output using `JsonGenerator`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Executing the preceding code produces the following content in the standard
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In the beginning of the code, the properties object that is created can be used
    to add directives on what behaviors are expected from the `JsonGenerator` object.
    The directives that can be specified differ from implementation to implementation
    but here the `JsonGenerator.PRETTY_PRINTING` is used to ensure that the resulting
    JSON document is formatted and human-readable.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `JsonParser`, `JsonGenerator`, `JsonReader`, `JsonWriter` can be used in
    Automatic Resource Management blocks, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Parsing JSON documents
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Assuming that the result of the previous sample is saved to a file named `output.json`,
    the following snippet can be used to parse the `output.json` using stream parser.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The event types that should be processed when parsing a JSON document are listed
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`START_ARRAY`: Indicating start of an array in the JSON document'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`START_OBJECT`: Indicating start of an object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`KEY_NAME`: Name of the key'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VALUE_STRING`: When the key''s value is string'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VALUE_NUMBER`: When the value is number'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VALUE_NULL`: If the value is null'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VALUE_FALSE`: If value is Boolean false'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VALUE_TRUE`: If value is Boolean true'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`END_OBJECT`: End of an object is reached'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`END_ARRAY`: End of an array is reached'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manipulating JSON documents using the JSON object model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The document object model for parsing JSON provides the same flexibilities and
    limitation that XML DOM parsing provides. The list of flexibilities includes but
    not limited to, forward and backward traversing and manipulating the DOM tree;
    the disadvantages or the tradeoff are on the parser speed and memory requirement.
  prefs: []
  type: TYPE_NORMAL
- en: Generating JSON documents
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following sample code shows how to generate JSON documents using the builder
    API and later on writing the produced object to standard output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Note the use of configuration properties passed when the `JsonBuilderFactory`
    is created. Depending on the JSON API implementation, different configuration
    parameters can be passed to the factory to produce customized `JsonBuilder` objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'The resulting JSON output looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Parsing JSON documents
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Parsing a `JSONObject` using the object model is straightforward and starts
    with creating a reader object and reading the input file/document into a `JSONObject`.
    After having access to the `JSONObject`, it is possible to traverse over the primitive
    and array attributes of the `JSONObject`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As the sample code shows, reading each attribute of the `JSONObject`is performed
    through typed getters; for example `getString`, `getInt`, `getNull`, `getBoolean`,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: When to use the streaming versus the object API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The streaming event based API is useful when you are manipulating large JSON
    documents, which you do not want to store in memory. The object model API is useful
    in the case when you have navigated between different nodes of the JSON document.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Servlet 3.1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Java EE 7 specification brings along an updated specification for Servlet
    API, which addresses some of the community-requested and industry-required changes
    including but not limited to the following list of changes:'
  prefs: []
  type: TYPE_NORMAL
- en: Addition of the NIO API to servlet specification
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding new protocol upgrading support for WebSockets, and so on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next two sections cover the details of these changes and how they can be
    used.
  prefs: []
  type: TYPE_NORMAL
- en: NIO API and Servlet 3.1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Servlet 3 introduced async processing of incoming requests in which a request
    could be placed in a processing queue without a thread being bound to the request
    until the request processing is finished. In Servlet 3.1, another forward step
    made forward in which receiving the request data writing back the response can
    be done in a non-blocking, callback-oriented manner.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing ReadListener and WriteListener
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The two listeners are introduced to allow developers to basically receive notification
    when there is incoming data available to read rather than blocking until the data
    arrives and to be receiving notification when it is possible to write output without
    being blocked.
  prefs: []
  type: TYPE_NORMAL
- en: The `ReadListener` interface, which provides callback notification on availability
    of data in request's `InputStream` code, is shown in the following listing, a
    simple interface with three methods, which are described after the code snippet.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '`onDataAvailable`: Invoked when all data for the current request has been read.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onAllDataRead`: Invoked by the container the first time it is possible to
    read data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `onError`: Invoked when an error occurs processing the request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `WriteListener`, which provides callback notification when it is possible
    to write data in the Servlet's `OutputStream`, is a simple two methods interface
    that is shown in the following snippet and described afterward.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The container invokes the `onWritePossible` method when it is possible to write
    in the Servlet's `OutputStream`.
  prefs: []
  type: TYPE_NORMAL
- en: The `onError` is invoked when writing in the Servlet's `OutputStream` encounters
    an exception`.`
  prefs: []
  type: TYPE_NORMAL
- en: The sample code on how these two listeners can be used is included at the end
    of Servlet 3.1 introduction section.
  prefs: []
  type: TYPE_NORMAL
- en: Changes in the Servlet API interfaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are some changes in the Servlet API to make it possible to use the newly
    introduced interfaces. These changes are as follow:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `ServletOutputStream` interface:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`isReady`: This method can be used to determine if data can be written without
    blocking'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setWriteListener`: Instructs the `ServletOutputStream` to invoke the provided
    `WriteListener` when it is possible to write'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In the `ServletInputStream` interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`isFinished`: Returns true when all the data from the stream has been read
    else it returns false'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`isReady`: Returns true if data can be read without blocking else returns false'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setReadListener`: Instructs the `ServletInputStream` to invoke the provided
    `ReadListener` when it is possible to read'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now it is time to see how the non-blocking Servlet 3.1 API works. The following
    snippet shows an Async Servlet, which uses the non-blocking APIs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The code starts with declaring the Servlet and enabling asynchronous support
    by specifying the `asyncSupported=true`in the `@WebServlet` annotation.
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to set the `AsyncListener` to handle the `AsyncEvent`s. Invoking
    one of the `AsyncContext` sets the `AsyncListener` for `AsyncContext#addListner`
    overloads. The listener will receive the `AsyncEvents` when an asynchronous invocation
    of the Servlet is completed successfully or ended with timeout or error. Multiple
    listeners can be registered and listeners receive the events in the same order
    they are registered.
  prefs: []
  type: TYPE_NORMAL
- en: The last part of the code sets the `readListener` for the servlet to a `ReadListener`
    implementation included below. When the `ReadListener`is set, reading the incoming
    requests is delegated to the `ReservationRequestReadListener`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ReservationRequestReadListener.onDataAvailable` is invoked by the container
    when there is data to read and when reading the data is finished the `onAllDataRead`
    is invoked. The `onAllDataRead` performs the business operation on the available
    data and the set the `ResponseWriteListener`, which writes the data, is stored
    in the queue back to the client. The `ResponseWriteListener` is shown in the following
    listing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: When the writing operation is finished either normally or fatally, the context
    needs to be closed for this operation using the `context.complete()` method.
  prefs: []
  type: TYPE_NORMAL
- en: More changes in Servlet 3.1
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In addition to non-blocking IO inclusion, Servlet 3.1 brings in support for
    protocol upgrade in order to support the new WebSockets API. The addition of the
    `upgrade` method to `HttpServletRequest` allows developers to upgrade the communication
    protocol to other protocols, if supported by the container.
  prefs: []
  type: TYPE_NORMAL
- en: When an upgrade request is sent, the application decides to perform the upgrader,
    the `HttpServletRequest#upgrade(ProtocolHandler)` is invoked, and application
    prepares and sends an appropriate response to the client as usual. At this point
    the web container unwinds all the servlet filters and marks the connection to
    be handled by the protocol handler.
  prefs: []
  type: TYPE_NORMAL
- en: New features in JAX-RS 2.0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'JAX-RS 2.0 brings in several new features aligned with other lightweight and
    async processing features provided in other components. The new features include
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Client API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Common configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Asynchronous processing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filters/interceptors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hypermedia support
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Server-side content negotiation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: From this list of features, this section covers asynchronous processing and
    also the relevance of asynchronous processing to filters/interceptors.
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous request and response processing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Asynchronous processing is included in both client and server side APIs of
    JAX-RS 2.0 to facilitate asynchronous interaction between client and server components.
    The following list shows the new interfaces and classes added to support this
    feature:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Server side:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AsyncResponse`:An injectable JAX-RS asynchronous response that provides the
    means for asynchronous server side response processing.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@Suspended`: `@Suspended` instructs the container that the HTTP request processing
    should happen in a secondary thread.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CompletionCallback`: A request processing callback that receives request processing
    completion events.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ConnectionCallback`: Asynchronous request processing lifecycle callback that
    receives connection-related asynchronous response lifecycle events.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Client side:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`InvocationCallback`: Callback that can be implemented to receive the asynchronous
    processing events from the invocation processing'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Future`: Allows the client to poll for completion of the asynchronous operation
    or to block and wait for it'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `Future` interface introduced in Java SE 5 provides two different mechanism
    to get the result of an asynchronous operation: first by invoking the `Future.get(…)`
    variants, which block until the result is available or a timeout occurs; the second
    way is to check for the completion by invoking the `isDone()` and `isCancelled()`,
    which are Boolean methods returning the current status of the Future.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following sample code shows how an asynchronous resource can be developed
    using JAX-RS 2 API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '`BookResource` is a stateless session bean which has a method `borrow()`. This
    method is annotated with `@Asynchronous` annotation, which will work in the fire-and-forget
    manner. When the resource is requested through the `borrow()` method''s resource
    path, a new thread is spawned to work on preparing the request''s response. The
    thread is submitted to the executor for execution and the thread processing the
    client request is released (via `ctx.suspend`) to process other incoming requests.
    When the worker thread, created to prepare the response, is done with preparing
    the response, it invokes the`ctx.resume`, which lets the container know the response
    is ready to be sent back to the client. If the`ctx.resume` is invoked before the
    `ctx.suspend` (the worker thread has prepared the result before the execution
    reaching the `ctx.suspend`) the suspension is ignored and the result will be sent
    to the client.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Same functionality can be achieved using the `@Suspended` annotation that is
    shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Using `@Suspended` is cleaner as it does not involve use of `ExecutionContext`
    method to instruct container to suspend and then resume the communication thread
    when the worker thread, aka the `prepareResponse()` method in this case, is finished.
    The client code to consume the asynchronous resource can use the callback mechanism
    or polling at the code level. The following code shows how to use polling via
    `Future` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The code begins with forming the request to the book resource and then the `Future.get(…)`
    blocks until the response is back from the server or the 30 seconds timeout reaches.
  prefs: []
  type: TYPE_NORMAL
- en: Another API for the asynchronous client is to use the `InvocationCallback`.
  prefs: []
  type: TYPE_NORMAL
- en: Filters and interceptors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The filters and interceptors are two new concepts added to JAX-RS 2.0 that allow
    developers to intercept incoming and outgoing requests and responses as well as
    operating at stream level on the incoming and outgoing payloads.
  prefs: []
  type: TYPE_NORMAL
- en: The filters work the same way as Servlet filters work and provide access to
    inbound and outbound messages for tasks such as authentication/logging, auditing,
    etc. while interceptors can be used to perform dumb operations on payload such
    as compressing/decompressing the outgoing responses and incoming requests.
  prefs: []
  type: TYPE_NORMAL
- en: Filters and interceptors are asynchronous-aware, meaning that they can handle
    both synchronous and asynchronous communications.
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous processing in EJB 3.1 and 3.2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before Java EE 6 the only asynchronous processing facility in Java EE was **JMS**
    (**Java Message Service**) and **MDBs** (**Message Driven Beans**) in which a
    session bean method could send a JMS message to describe a request and then let
    an MDB process the request in an asynchronous manner. Using the JMS and MDBs the
    session bean method could return immediately and the client could check for the
    request completion using the reference returned by the method for the long running
    operation being handled by some MDBs.
  prefs: []
  type: TYPE_NORMAL
- en: The above solution works well, as it has worked for a decade now, but it is
    not easy to use and that was the reason for Java EE 6 to introduce the `@Asynchronous`
    annotation to annotate a method in a session bean or the whole session bean class
    as asynchronous. The `@Asynchronous` can be placed on a class to mark all the
    methods in that class as asynchronous or on a method to mark that particular method
    as asynchronous.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two types of asynchronous EJB invocation which are explained as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: In the first model the method returns `void` and there is no container-provided
    standard mechanism to check the result of the method invocation. This is referred
    to as a **fire-and-forget** mechanism.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the second model, the container provides a mechanism to check back the result
    of the invocation using a `Future<?>` object returned from the method invocation.
    This mechanism is referred to as **invoke-and-check-later**. Note that `Future`
    is part of the Java SE concurrency package. Having the Future object returned
    from the method, the client can check the result of invocation by using different
    Future methods such as `isDone()` and `get(…)`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before we dive down into sample codes or use the `@Asynchronous` it is worth
    mentioning that, in Java EE 6, the `@Asynchronous` was only available in full
    profile while in Java EE 7 the annotation is added to the web profile as well.
  prefs: []
  type: TYPE_NORMAL
- en: Developing an asynchronous session bean
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following listing shows how to use the invoke-and-check-later asynchronous
    EJB methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '`@Stateless` and `@LocalBean` are self-explanatory; they mark this class as
    a stateless session bean with a local interface.'
  prefs: []
  type: TYPE_NORMAL
- en: The `search` method is annotated with `@Asynchronous` and this tells the container
    that the method invocation should happen in a separate detached thread; when the
    result is available the returned Future object's `isDone()` returns true.
  prefs: []
  type: TYPE_NORMAL
- en: The `search` itself invokes a presumably long running method, `performSearch`,
    to get the result of the long running search operation the client has requested.
  prefs: []
  type: TYPE_NORMAL
- en: Developing a client servlet for the async session bean
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that the stateless session bean is developed it is time to develop a client
    that accesses the session bean''s business method. In this case the client is
    a Servlet, which is included in the following code without some of the boilerplate
    codes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Starting from the top, we have the servlet declaration annotations, injection
    of the stateless EJB, and the `get` method's implementation.
  prefs: []
  type: TYPE_NORMAL
- en: The get in the `get` method's implementation invokes the EJB's `search` method
    while passing two different `dummyTime` to simulate the wait. Between invocations
    of the `search` method till the Future object's `isDone` returns true, the client
    code can perform other required operations.
  prefs: []
  type: TYPE_NORMAL
- en: Now that the invoke-and-check-later model is described we can discuss the other
    Asynchronous EJB invocation model in which the EJB business methods return `void`
    and there is no container-provided way to check the result. We usually use these
    methods to trigger a long-running task that the current thread does not need to
    wait for it to be finished.
  prefs: []
  type: TYPE_NORMAL
- en: An example of this case is when a new e-book is added to the library and the
    full text search index needs to be updated to include the new book. In such a
    case the procedure that adds the book can invoke a `@Asynchronous` EJB method
    to index the book during the book's registration and after it is uploaded to the
    server's repository. In this way the registration process does not need to wait
    for the FTS indexing to complete while the FTS indexing starts right after the
    book is added to the library.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter, the final chapter before showing you some real-world examples,
    discusses JSON processing, Asynchronous JAX-RS resources, which can produce or
    consume JSON data along with discussing the new NIO support in the Servlet 3.1\.
    As `@Asynchronous` EJB is now included in Java EE 7's Web profile we discussed
    that feature along with other new features that are introduced in Java EE7\. The
    next chapter shows real-world examples on how these technologies and APIs can
    be used together to form a solution.
  prefs: []
  type: TYPE_NORMAL
