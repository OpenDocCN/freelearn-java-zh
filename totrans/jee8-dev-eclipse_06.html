<html><head></head><body>
        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Creating JEE Applications with EJB</h1>
                
            
            <article>
                
<p class="calibre3">In the last chapter, we learned some techniques to debug JEE applications from Eclipse. In this chapter, we will shift our focus back to JEE application development and learn how to create and use <strong class="calibre5">Enterprise JavaBeans</strong> (<strong class="calibre5"><span class="calibre12">EJB</span></strong>). If you recall the architecture of database applications in <a target="_blank" href="part0073.html#25JP20-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55" class="calibre9"><span>Chapter 4</span></a>, <em class="calibre21">Creating JEE Database Applications,</em> we had JSP or a JSF page calling a JSP bean or a managed bean. The beans then called DAOs to execute the data access code. This separated code for the user interface, the business logic, and the database nicely. This would work for small or medium applications, but may prove to be a bottleneck in large enterprise applications; the application may not scale very well. If processing of the business logic is time consuming then it would make more sense to distribute it on different servers for better scalability and resilience. If code for the user interface, the business logic, and the data access is all on the same machine, then it may affect scalability of the application; that is, it may not perform well under the load.</p>
<p class="calibre3">Using EJB for implementing the business logic is ideal in scenarios where you want components processing the business logic to be distributed across different servers. However, this is just one of the advantages of EJB. Even if you use EJBs on the same server as the web application, you may gain from a number of services that the EJB container provides; you can specify the security constraints for calling EJB methods declaratively (using annotations) and can easily specify transaction boundaries (specify a set of method calls from a part of one transaction) using annotations. Furthermore, the container handles the life cycle of EJBs, including pooling of certain types of EJB objects so that more objects can be created when load on the application increases.</p>
<p class="calibre3">In <a target="_blank" href="part0073.html#25JP20-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55" class="calibre9"><span>Chapter 4</span></a>, <em class="calibre21">Creating JEE Database Applications</em>, we created a <em class="calibre21">Course Management</em> web application using simple JavaBeans. In this chapter, we will create the same application using EJBs and deploy it on the GlassFish Server. However, before that we need to understand some basic concepts of EJBs.</p>
<p class="calibre3"><span class="calibre12"> </span>We will cover the following broad topics:</p>
<ul class="calibre10">
<li class="calibre11">Understanding different types of EJBs and how they can be accessed from different client deployment scenarios</li>
<li class="calibre11">Configuring GlassFish Server for testing EJB applications in Eclipse</li>
<li class="calibre11">Creating and testing EJB projects from Eclipse with and without Maven</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Types of EJB</h1>
                
            
            <article>
                
<p class="calibre3">EJB can be of the following types according to the EJB3 specification:</p>
<ul class="calibre10">
<li class="calibre11">Session bean:</li>
</ul>
<ul class="calibre10">
<li class="front-matter">
<ul class="calibre119">
<li class="calibre11">Stateful session bean</li>
<li class="calibre11">Stateless session bean</li>
<li class="calibre11">Singleton session bean</li>
</ul>
</li>
</ul>
<ul class="calibre10">
<li class="calibre11">Message-driven bean</li>
</ul>
<p class="calibre3">We will discuss <strong class="calibre5">message-driven bean</strong> (<strong class="calibre5">MDB</strong>) in detail in a <a target="_blank" href="part0208.html#66BL00-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55" class="calibre9">Chapter 10</a>, <em class="calibre21">Asynchronous Programming with JMS</em>, when we learn about asynchronous processing of requests in the JEE application. In this chapter, we will focus on session beans.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Session beans</h1>
                
            
            <article>
                
<p class="calibre3">In general, session beans are meant to contain methods to execute the main business logic of the enterprise application. Any <strong class="calibre5">Plain Old Java Object</strong> (<strong class="calibre5">POJO</strong>) can be annotated with the appropriate EJB3-specific annotations to make it a session bean. Session beans come in three types.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Stateful session beans</h1>
                
            
            <article>
                
<p class="calibre3">One stateful session bean serves requests for one client only. There is one-to-one mapping between the stateful session bean and the client. Therefore, stateful beans can hold the state data for the client between multiple method calls. In our <em class="calibre21">Course Management</em> application, we could use a stateful bean for holding student data (student profile and courses taken by her/him) after a student logs in. The state maintained by the stateful bean is lost when the server restarts or when the session times out. Since there is one stateful bean per client, using a stateful bean might impact scalability of the application.</p>
<p class="calibre3">We use the <kbd class="calibre13">@Stateful</kbd> annotation on the class to mark it as a stateful session bean.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Stateless session beans</h1>
                
            
            <article>
                
<p class="calibre3">A stateless session bean does not hold any state information for the client. Therefore, one session bean can be shared across multiple clients. The EJB container maintains pools of stateless beans, and when a client request comes, it takes a bean out of the pool, executes methods, and returns the bean to the pool again. Stateless session beans provide excellent scalability because they can be shared and they need not be created for each client.</p>
<p class="calibre3">We use the <kbd class="calibre13">@Stateless</kbd> annotation on the class to mark it as a stateless session bean.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Singleton session beans</h1>
                
            
            <article>
                
<p class="calibre3">As the name suggests, there is only one instance of a singleton bean class in the EJB container (this is true in the clustered environment too; each EJB container will have one instance of a singleton bean). This means that they are shared by multiple clients, and they are not pooled by EJB containers (because there can be only one instance). Since a singleton session bean is a shared resource, we need to manage concurrency in it. Java EE provides two concurrency management options for singleton session beans, namely container-managed concurrency and bean-managed concurrency. Container-managed concurrency can be easily specified by annotations.</p>
<div class="packt_tip"><br class="calibre26"/>
See <a href="https://javaee.github.io/tutorial/ejb-basicexamples003.html#GIPSZ" class="calibre17">https://javaee.github.io/tutorial/ejb-basicexamples003.html#GIPSZ</a> for more information on managing concurrency in singleton session beans.</div>
<p class="calibre3">The use of a singleton bean could have an impact on the scalability of the application if there are resource contentions.</p>
<p class="calibre3">We use the <kbd class="calibre13">@Singleton</kbd> annotation on the class to mark it as a singleton session bean.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Accessing session beans from a client</h1>
                
            
            <article>
                
<p class="calibre3">Session beans can be designed to be accessed locally (client and bean in the same application), remotely (from a client running in a different application or JVM), or both. In the case of remote access, session beans are required to implement a remote interface. For local access, session beans can implement a local interface or implement no interface (no-interface view of a session bean). The remote and local interfaces that the session bean implements are sometimes also called <strong class="calibre5">business interfaces</strong> because they typically expose the primary business functionality.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Creating a no-interface session bean</h1>
                
            
            <article>
                
<p class="calibre3">To create a session bean with the no-interface view, create a POJO and annotate it with the appropriate EJB annotation type and <kbd class="calibre13">@LocalBean</kbd>. For example, we can create a local stateful <kbd class="calibre13">Student</kbd> bean as follows:</p>
<pre class="calibre25">import javax.ejb.LocalBean; 
import javax.ejb.Singleton; 
 
@Singleton 
@LocalBean 
public class Student { 
... 
} </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Accessing session beans using dependency injection</h1>
                
            
            <article>
                
<p class="calibre3">You can access session beans either using the <kbd class="calibre13">@EJB</kbd> annotation (which injects the bean in the client class) or by performing the <strong class="calibre5">Java Naming and Directory Interface</strong> (<strong class="calibre5">JNDI</strong>) lookup. EJB containers are required to make JNDI URLs of the EJBs available to clients.</p>
<p class="calibre3">Injecting session beans using <kbd class="calibre13">@EJB</kbd> works only for managed components, that is, components of the application whose life cycle is managed by the EJB container. When a component is managed by the container, it is created (instantiated) and destroyed by the container. You do not create managed components using the <kbd class="calibre13">new</kbd> operator. JEE-managed components that support direct injection of EJBs are servlets, managed beans of JSF pages, and EJBs themselves (one EJB can have another EJB injected into it). Unfortunately, you cannot have a web container inject EJBs in JSPs or JSP beans. Furthermore, you cannot have EJBs injected into any custom classes that you create and that are instantiated using the <kbd class="calibre13">new</kbd> operator. Later in the chapter, we will see how to use JNDI to access EJBs from objects that are not managed by the container.</p>
<p class="calibre3">We could use a student bean (created previously) from a managed bean of a JSF as follows:</p>
<pre class="calibre25">import javax.ejb.EJB; 
import javax.faces.bean.ManagedBean; 
 
@ManagedBean 
public class StudentJSFBean { 
  @EJB 
  private Student studentEJB; 
} </pre>
<p class="calibre3">Note that if you create an EJB with no-interface view, then all <kbd class="calibre13">public</kbd> methods in that EJB will be exposed to the client. If you want to control the methods that could be called by the client, then you should implement a business interface.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Creating session beans using local business interface</h1>
                
            
            <article>
                
<p class="calibre3">Business interface for the EJB is a simple Java interface annotated either with <kbd class="calibre13">@Remote</kbd> or <kbd class="calibre13">@Local</kbd>. Therefore, we can create a local interface for a student bean as follows:</p>
<pre class="calibre25">import java.util.List; 
import javax.ejb.Local; 
 
@Local 
public interface StudentLocal { 
  public List&lt;Course&gt; getCourses(); 
} </pre>
<p class="calibre3">Furthermore, we can implement a session bean as follows:</p>
<pre class="calibre25">import java.util.List; 
import javax.ejb.Local; 
import javax.ejb.Stateful; 
 
@Stateful 
@Local 
public class Student implements StudentLocal { 
  @Override 
  public List&lt;CourseDTO&gt; getCourses() { 
    //get courses are return 
... 
  } 
} </pre>
<p class="calibre3">The client can access the <kbd class="calibre13">Student</kbd> EJB only through the local interface:</p>
<pre class="calibre25">import javax.ejb.EJB; 
import javax.faces.bean.ManagedBean; 
 
@ManagedBean 
public class StudentJSFBean { 
  @EJB 
  private StudentLocal student; 
} </pre>
<p class="calibre3">A session bean can implement multiple business interfaces.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Accessing session beans using JNDI lookup</h1>
                
            
            <article>
                
<p class="calibre3">Although accessing EJB using dependency injection is the easiest way, it works only if the container manages the class that accesses the EJB. If you want to access EJB from a POJO that is not a managed bean, then dependency injection will not work. Another scenario where dependency injection does not work is when EJB is deployed in a separate JVM (could be on a remote server). In such cases, you will have to access the EJB using JNDI lookup (visit <a href="https://docs.oracle.com/javase/tutorial/jndi/" class="calibre9"><span>https://docs.oracle.com/javase/tutorial/jndi/</span></a> for more information on JNDI).</p>
<p class="calibre3">JEE applications could be packaged in <strong class="calibre5">Enterprise Application aRchive</strong> (<strong class="calibre5">EAR</strong>), which contains a <kbd class="calibre13">.jar</kbd> file for EJBs and a <kbd class="calibre13">.war</kbd> file for web applications (and a <kbd class="calibre13">lib</kbd> folder containing libraries required for both). If, for example, the name of the EAR file is <kbd class="calibre13">CourseManagement.ear</kbd> and the name of the EJB JAR in it is <kbd class="calibre13">CourseManagementEJBs.jar</kbd>, then the name of the application is <kbd class="calibre13">CourseManagement</kbd> (name of the EAR file) and the module name is <kbd class="calibre13">CourseManagementEJBs</kbd>. The EJB container uses these names to create JNDI URL for looking up EJBs. A global JNDI URL for EJB is created as follows:</p>
<pre class="calibre25">"java:global/&lt;application_name&gt;/&lt;module_name&gt;/&lt;bean_name&gt;![&lt;bean_interface&gt;]" </pre>
<p class="calibre3">Let's have a look at the different parameters used in the preceding code snippets:</p>
<ul class="calibre10">
<li class="calibre11"><kbd class="calibre13">java:global</kbd>: This indicates that it is a global JNDI URL.</li>
<li class="calibre11"><kbd class="calibre13">&lt;application_name&gt;</kbd>: This is typically the name of the EAR file.</li>
<li class="calibre11"><kbd class="calibre13">&lt;module_name&gt;</kbd>: This is the name of the EJB JAR.</li>
<li class="calibre11"><kbd class="calibre13">&lt;bean_name&gt;</kbd>: This is the name of the EJB bean class.</li>
<li class="calibre11"><kbd class="calibre13">&lt;bean_interface&gt;</kbd>: This is optional if EJB has a no-interface view, or if EJB implements only one business interface. Otherwise it is a fully qualified name of the business interface.</li>
</ul>
<p class="calibre3">EJB containers are required to publish two more variations of JNDI URLs for each EJB. These are not global URLs, which means that they can't be used to access EJBs from clients that are not in the same JEE application (in the same EAR):</p>
<ul class="calibre10">
<li class="calibre11"><kbd class="calibre13">java:app/[&lt;module_name&gt;]/&lt;bean_name&gt;![&lt;bean_interface&gt;]</kbd></li>
<li class="calibre11"><kbd class="calibre13">java:module/&lt;bean_name&gt;![&lt;bean_interface&gt;]</kbd></li>
</ul>
<p class="calibre3">The first URL can be used if the EJB client is in the same application, and the second URL can be used if the client is in the same module (the same <kbd class="calibre13">.jar</kbd> file as the EJB).</p>
<p class="calibre3">Before you look up any URL in a JNDI server, you need to create <kbd class="calibre13">InitialContext</kbd>, which includes, among other things, <span class="calibre12">information </span>such as the hostname of the JNDI server and the port on which it is running. If you create <kbd class="calibre13">InitialContext</kbd> in the same server, then there is no need to specify these attributes:</p>
<pre class="calibre25">InitialContext initCtx  = new InitialContext(); 
Object obj = initCtx.lookup("jndi_url"); </pre>
<p class="calibre3">We can use the following JNDI URLs to access a no-interface (<kbd class="calibre13">LocalBean</kbd>) <kbd class="calibre13">Student</kbd> EJB (assuming that the name of the EAR file is <kbd class="calibre13">CourseManagement</kbd> and the name of the <kbd class="calibre13">.jar</kbd> file for EJBs is <kbd class="calibre13">CourseManagementEJBs</kbd>):</p>
<table border="1" class="calibre49">
<tbody class="calibre50">
<tr class="calibre51">
<td class="calibre52">
<p class="calibre3"><strong class="calibre5">URL</strong></p>
</td>
<td class="calibre52">
<p class="calibre3"><strong class="calibre5">When to use</strong></p>
</td>
</tr>
<tr class="calibre51">
<td class="calibre52">
<p class="calibre3"><kbd class="calibre13">java:global/CourseManagement/ CourseManagementEJBs/Student</kbd></p>
</td>
<td class="calibre52">
<p class="calibre3"><span class="calibre12">The client can be anywhere in the EAR file</span>, because we use the global URL. Note that we haven't specified the interface name because we are assuming that the student bean provides a no-interface view in this example.</p>
</td>
</tr>
<tr class="calibre51">
<td class="calibre52">
<p class="calibre3"><kbd class="calibre13">java:app/CourseManagementEJBs/Student</kbd></p>
</td>
<td class="calibre52">
<p class="calibre3">The client can be anywhere in the EAR. We skipped application name because the client is expected to be in the same application, because the namespace of the URL is <kbd class="calibre13">java:app</kbd>.</p>
</td>
</tr>
<tr class="calibre51">
<td class="calibre52">
<p class="calibre3"><kbd class="calibre13">java:module/Student</kbd></p>
</td>
<td class="calibre52">
<p class="calibre3">The client must be in the same <kbd class="calibre13">.jar</kbd> file as EJB.</p>
</td>
</tr>
</tbody>
</table>
<p class="calibre3"> </p>
<p class="calibre3">We can use the following JNDI URLs for accessing <kbd class="calibre13">Student</kbd> EJB that implemented a local interface called <kbd class="calibre13">StudentLocal</kbd>:</p>
<table border="1" class="calibre49">
<thead class="calibre160">
<tr class="calibre51">
<td class="calibre52">
<p class="calibre3"><strong class="calibre5">URL</strong></p>
</td>
<td class="calibre52">
<p class="calibre3"><strong class="calibre5">When to use</strong></p>
</td>
</tr>
</thead>
<tbody class="calibre50">
<tr class="calibre51">
<td class="calibre52">
<p class="calibre3"><kbd class="calibre13">java:global/CourseManagement/ CourseManagementEJBs/Student!packt.jee.book.ch6.StudentLocal</kbd></p>
</td>
<td class="calibre52">
<p class="calibre3">The client can be anywhere in the EAR file, because we use a global URL.</p>
</td>
</tr>
<tr class="calibre51">
<td class="calibre52">
<p class="calibre3"><kbd class="calibre13">java:global/CourseManagement/ CourseManagementEJBs/Student</kbd></p>
</td>
<td class="calibre52">
<p class="calibre3">The client can be anywhere in the EAR. We skipped the interface name because the bean implements only one business interface. Note that the object returned from this call will be of <kbd class="calibre13">StudentLocal</kbd> type, and not <kbd class="calibre13">Student</kbd> type.</p>
</td>
</tr>
<tr class="calibre51">
<td class="calibre52">
<p class="calibre3"><kbd class="calibre13">java:app/CourseManagementEJBs/Student</kbd></p>
<p class="calibre3">Or</p>
<p class="calibre3"><kbd class="calibre13">java:app/CourseManagementEJBs/Student!packt.jee.book.ch6.StudentLocal</kbd></p>
</td>
<td class="calibre52">
<p class="calibre3">The client can be anywhere in the EAR. We skipped the application name because the JNDI namespace is <kbd class="calibre13">java:app</kbd>.</p>
</td>
</tr>
<tr class="calibre51">
<td class="calibre52">
<p class="calibre3"><kbd class="calibre13">java:module/Student</kbd></p>
<p class="calibre3">Or</p>
<p class="calibre3"><kbd class="calibre13">java:module/Student!packt.jee.book.ch6.StudentLocal</kbd></p>
</td>
<td class="calibre52">
<p class="calibre3">The client must be in the same EAR as the EJB.</p>
</td>
</tr>
</tbody>
</table>
<div class="title-page-name"/>
<p class="calibre3">Here is an example of how we can call the student bean with a local business interface from one of the objects (that is not managed by the web container) in our web application:</p>
<pre class="calibre25">InitialContext ctx = new InitialContext(); 
StudentLocal student = (StudentLocal) ctx.loopup <br class="title-page-name"/> ("java:app/CourseManagementEJBs/Student"); 
return student.getCourses(id) ; //get courses from Student EJB </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Creating session beans using remote business interface</h1>
                
            
            <article>
                
<p class="calibre3">If the session bean that you create is going to be accessed by a client object that is not in the same JVM as the bean, then the bean needs to implement a remote business interface. You create a remote business interface by annotating the class with <kbd class="calibre13">@Remote</kbd>:</p>
<pre class="calibre25">import java.util.List; 
import javax.ejb.Remote; 
 
@Remote 
public interface StudentRemote { 
  public List&lt;CourseDTO&gt; getCourses(); 
} </pre>
<p class="calibre3">The EJB implementing the remote interface is also annotated with <kbd class="calibre13">@Remote</kbd>:</p>
<pre class="calibre25">@Stateful 
@Remote 
public class Student implements StudentRemote { 
  @Override 
  public List&lt;CourseDTO&gt; getCourses() { 
    //get courses are return 
... 
  } 
} </pre>
<p class="calibre3">Remote EJBs can be injected into managed objects in the same application using the <kbd class="calibre13">@EJB</kbd> annotation. For example, a JSF bean can access the previously mentioned student bean (in the same application) as follows:</p>
<pre class="calibre25">import javax.ejb.EJB; 
import javax.faces.bean.ManagedBean; 
 
@ManagedBean 
public class StudentJSFBean { 
  @EJB 
  private StudentRemote student; 
} </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Accessing remote session beans</h1>
                
            
            <article>
                
<p class="calibre3">For accessing a remote <kbd class="calibre13">Student</kbd> EJB, we can use the following JNDI URLs:</p>
<table border="1" class="calibre49">
<thead class="calibre160">
<tr class="calibre51">
<td class="calibre52">
<p class="calibre3"><strong class="calibre5">URL</strong></p>
</td>
<td class="calibre52">
<p class="calibre3"><strong class="calibre5">When to use</strong></p>
</td>
</tr>
</thead>
<tbody class="calibre50">
<tr class="calibre51">
<td class="calibre52">
<p class="calibre3"><kbd class="calibre13">java:global/CourseManagement/ CourseManagementEJBs/Student!packt.jee.book.ch6.StudentRemote</kbd></p>
</td>
<td class="calibre52">
<p class="calibre3">The client can be in the same application or remote. In the case of a remote client, we need to set up proper <kbd class="calibre13">InitialContext</kbd> parameters.</p>
</td>
</tr>
<tr class="calibre51">
<td class="calibre52">
<p class="calibre3"><kbd class="calibre13">java:global/CourseManagement/CourseManagementEJBs/Student</kbd></p>
</td>
<td class="calibre52">
<p class="calibre3">The client can be in the same application or remote. We skipped the interface name because the bean implements only one business interface.</p>
</td>
</tr>
<tr class="calibre51">
<td class="calibre52">
<p class="calibre3"><kbd class="calibre13">java:app/CourseManagementEJBs/Student</kbd></p>
<p class="calibre3">Or</p>
<p class="calibre3"><kbd class="calibre13">java:app/CourseManagementEJBs/Student!packt.jee.book.ch6.StudentRemote</kbd></p>
</td>
<td class="calibre52">
<p class="calibre3">The client can be anywhere in the EAR. We skipped the application name because the JNDI namespace is <kbd class="calibre13">java:app</kbd>.</p>
</td>
</tr>
<tr class="calibre51">
<td class="calibre52">
<p class="calibre3"><kbd class="calibre13">java:module/Student</kbd></p>
<p class="calibre3">Or</p>
<p class="calibre3"><kbd class="calibre13">java:module/Student!packt.jee.book.ch6.StudentRemote</kbd></p>
</td>
<td class="calibre52">
<p class="calibre3">The client must be in the same EAR as the EJB.</p>
</td>
</tr>
</tbody>
</table>
<p class="calibre3"> </p>
<p class="calibre3">To access EJBs from a remote client, you need to use the JNDI lookup method. Furthermore, you need to set up <kbd class="calibre13">InitialContext</kbd> with certain properties; some of them are JEE application server specific. If the remote EJB and the client are both deployed in GlassFish (different instances of GlassFish), then you can look up the remote EJB as follows:</p>
<pre class="calibre25">Properties jndiProperties = new Properties(); 
jndiProperties.setProperty("org.omg.CORBA.ORBInitialHost", <br class="title-page-name"/> "&lt;remote_host&gt;"); 
//target ORB port. default is 3700 in GlassFish 
jndiProperties.setProperty("org.omg.CORBA.ORBInitialPort", <br class="title-page-name"/> "3700"); 
 
InitialContext ctx = new InitialContext(jndiProperties); 
StudentRemote student = <br class="title-page-name"/> (StudentRemote)ctx.lookup("java:app/CourseManagementEJBs/Student"); 
return student.getCourses(); </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Configuring the GlassFish Server in Eclipse</h1>
                
            
            <article>
                
<p class="calibre3">We are going to use the GlassFish application server in this chapter. We have already seen how to install GlassFish in the <em class="calibre21">Installing GlassFish Server</em> section of <a target="_blank" href="part0008.html#7K4G0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55" class="calibre9"><span>Chapter 1</span></a>, <em class="calibre21">Introducing JEE and Eclipse</em>.</p>
<p class="calibre3">We will first configure the GlassFish Server in Eclipse JEE:</p>
<ol class="calibre14">
<li value="1" class="calibre11">To configure the GlassFish Server in Eclipse EE, make sure that you are in the <span>Java EE</span> perspective in Eclipse. Right-click on the <span>Servers</span> view and select <span>New</span> | <span>Server</span>. It you do not see the GlassFish Server group in the list of server types, then expand Oracle node and select and install <span>GlassFish Tools</span>:</li>
</ol>
<div class="mce-root1"><img src="../images/00153.jpeg" class="calibre161"/></div>
<div class="packt_figure1">Figure 7.1: Installing GlassFish Tools</div>
<ol start="2" class="calibre14">
<li value="2" class="calibre11"><span>If you have already installed <span>GlassFish Tools</span>, or if GlassFish Server type is available in the list, then expand that and select the <span>GlassFish</span> option:</span></li>
</ol>
<div class="packt_figure2"><img src="../images/00154.jpeg" class="calibre162"/></div>
<div class="packt_figure1">Figure 7.2: Creating GlassFish Server instance in Eclipse</div>
<ol start="3" class="calibre14">
<li class="calibre11" value="3"><span>Click</span> <span>Next</span><span>. </span><span>Enter the path of the GlassFish Server on your local machine in the </span><span>Domain path</span><span> field. Enter admin name and password, if applicable, and click </span><span>Next</span><span>:</span></li>
</ol>
<div class="packt_figure2"><img src="../images/00155.jpeg" class="calibre163"/></div>
<div class="packt_figure1">Figure 7.3: Defining GlassFish Server properties</div>
<ol start="4" class="calibre14">
<li value="4" class="calibre11">The next page allows you to deploy the existing Java EE projects in GlassFish. We don't have any projects to add at this point, so just click <span>Finish</span>.</li>
<li value="5" class="calibre11">The server is added to the <span>Servers</span> view. Right-click on the server and select <span>Start</span>. If the server is installed and configured properly, then the server status should change to <span>Started</span>.</li>
<li value="6" class="calibre11">To open the admin page of the server, right-click on the server and select <span>GlassFish</span> | <span>View Admin Console</span>. The admin page is opened in the built-in Eclipse browser. You can browse to the server home page by opening the <kbd class="calibre13">http://localhost:8080 URL</kbd>. <kbd class="calibre13">8080</kbd> is the default GlassFish port.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Creating a Course Management application using EJB</h1>
                
            
            <article>
                
<p class="calibre3">Let's now create the <em class="calibre21">Course Management</em> application that we created in <a target="_blank" href="part0073.html#25JP20-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55" class="calibre9"><span>Chapter 4</span></a>, <em class="calibre21">Creating JEE Database Applications,</em> this time using EJBs. In <a target="_blank" href="part0073.html#25JP20-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55" class="calibre9"><span>Chapter 4</span></a>, <em class="calibre21">Creating JEE Database Applications</em>, we created service classes (which were POJOs) for writing the business logic. We will replace them with EJBs. We will start by creating Eclipse projects for EJBs.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Creating EJB projects in Eclipse</h1>
                
            
            <article>
                
<p class="calibre3">EJBs are packaged in a JAR file. Web applications are packaged in a <strong class="calibre5">Web Application aRchive</strong> (<strong class="calibre5">WAR</strong>). If EJBs are to be accessed remotely, then the client needs to have access to business interfaces. Therefore, EJB business interfaces and shared objects are packaged in a separate JAR, called EJB client JAR. Furthermore, if EJBs and web applications are to be deployed as one single application, then they need to be packaged in an EAR.</p>
<p class="calibre3">So, in most cases the application with EJBs is not a single project, but four different projects:</p>
<ul class="calibre10">
<li class="calibre11">EJB project that creates EJB JAR</li>
<li class="calibre11">EJB client project that contains business classes and shared (between EJB and client) classes</li>
<li class="calibre11">Web project that generates WAR</li>
<li class="calibre11">EAR project that generates EAR containing EBJ JAR, EJB client JAR, and WAR</li>
</ul>
<p class="calibre3">You can create each of these projects independently and integrate them. However, Eclipse gives you the option to create EJB projects, EJB client projects, and EAR projects with one wizard:</p>
<ol class="calibre14">
<li class="calibre11" value="1"><span>Select</span> <span>File</span> <span>|</span> <span>New</span> <span>|</span> <span>EJB </span><span>Project</span><span>. Type</span> <kbd class="calibre13">CourseManagementEJBs</kbd> <span>in the </span><span>Project name</span> <span>textbox:</span></li>
</ol>
<div class="packt_figure2"><img src="../images/00156.jpeg" class="calibre164"/></div>
<div class="packt_figure1">Figure 7.4: New EJB Project wizard<strong class="calibre1"> </strong></div>
<p class="mce-root2"><span class="calibre12">Make sure </span><span class="calibre12">Target runtime</span> <span class="calibre12">is</span> <span class="calibre12">GlassFish 5</span><span class="calibre12"> and</span> <span class="calibre12">EJB </span><span class="calibre12">module </span><span class="calibre12">version</span> <span class="calibre12">is</span> <span class="calibre12">3.2</span> <span class="calibre12">or later. From the</span> <span class="calibre12">Configuration</span> <span class="calibre12">drop-down list, select</span> <span class="calibre12">Default Configuration for GlassFish 5</span><span class="calibre12">. In the </span><span class="calibre12">EAR membership</span> <span class="calibre12">group, check the</span> <span class="calibre12">Add project to an EAR</span> <span class="calibre12">box.</span></p>
<ol start="2" class="calibre14">
<li class="calibre11" value="2"><span>Select</span> <span>Next</span><span>. On the next page, specify source and output folders for the classes. Leave the defaults unchanged on this page:</span></li>
</ol>
<div class="packt_figure1"><img src="../images/00157.jpeg" class="calibre165"/></div>
<div class="packt_figure1"><span>Figure 7.5: Select source and output folders</span></div>
<ol start="3" class="calibre14">
<li class="calibre11" value="3"><span>The source Java files in this project would be created in the </span><kbd class="calibre13">ejbModule</kbd> <span>folder. Click</span> <span>Next</span><span>:</span></li>
</ol>
<div class="mce-root1"><img src="../images/00158.jpeg" class="calibre166"/></div>
<div class="packt_figure1">Figure 7.6: Creating an EJB client project</div>
<ol start="4" class="calibre14">
<li value="4" class="calibre11">Eclipse gives you the option to create an EJB client project. Select the option and click <span>Finish</span>.</li>
<li value="5" class="calibre11">Since we are building a web application, we will create a web project. Select <span>File</span> <span>|</span> <span>Dynamic Web Project</span><span>. Set the project name as</span> <kbd class="calibre13">CourseManagementWeb</kbd><span>:</span></li>
</ol>
<div class="packt_figure2"><img src="../images/00159.jpeg" class="calibre167"/></div>
<div class="packt_figure1">Figure 7.7: New Dynamic Web Project</div>
<ol start="6" class="calibre14">
<li value="6" class="calibre11">Select the <span>Add Project to an EAR</span> <span>checkbox. Since we have only one EAR project in the workspace, Eclipse selects this project from the drop-down list. Click</span> <span>Finish</span><span>.</span></li>
</ol>
<p class="calibre3">We now have the following four projects in the workspace:</p>
<div class="mce-root1"><img src="../images/00160.jpeg" class="calibre168"/></div>
<div class="packt_figure1">Figure 7.8: Course Management projects</div>
<p class="calibre3">In the course management application, we will create a stateless EJB called <kbd class="calibre13">CourseBean</kbd>. We will use <strong class="calibre5">Java Persistence API</strong>s (<span class="calibre12">JPA</span>) for data access and create a <kbd class="calibre13">Course</kbd> entity. See <a target="_blank" href="part0073.html#25JP20-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55" class="calibre9"><span>Chapter 4</span></a>, <em class="calibre21">Creating JEE Database Applications</em>, for details on using JPAs. The <kbd class="calibre13">CourseManagementEJBClient</kbd> project will contain the EJB business interface and shared classes. In <kbd class="calibre13">CourseManagementWeb</kbd>, we will create a JSF page and a managed bean that will access the <kbd class="calibre13">Course</kbd> EJB in the <kbd class="calibre13">CourseManagementEJBs</kbd> project to get a list of courses.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Configuring datasources in GlassFish</h1>
                
            
            <article>
                
<p class="calibre3">In <a target="_blank" href="part0073.html#25JP20-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55" class="calibre9"><span>Chapter 4</span></a>, <em class="calibre21">Creating JEE Database Applications,</em> we created the JDBC datasource locally in the application. In this chapter, we will create a JDBC datasource in GlassFish. GlassFish Server is not packaged with the JDBC driver for MySQL. So, we need to place the <kbd class="calibre13">.jar</kbd> file for <kbd class="calibre13">MySQLDriver</kbd> in the path where GlassFish can find it. You can place such external libraries in the <kbd class="calibre13">lib</kbd>/<kbd class="calibre13">ext</kbd> folder of the GlassFish domain in which you want to deploy your application. For this example, we will copy the JAR in <kbd class="calibre13">&lt;glassfish_home&gt;/glassfish/domains/domain1/lib/ext</kbd>.</p>
<p class="calibre3">If you do not have the MySQL JDBC driver, you can download it from <kbd class="calibre13"><span>http://dev.mysql.com/downloads/connector/j/</span></kbd>:</p>
<ol class="calibre14">
<li class="calibre11" value="1">O<span>pen the GlassFish admin console, either by right-clicking on the server in the</span> <span>Servers</span> <span>view and selecting</span> <span>GlassFish</span> <span>|</span> <span>View Admin Console</span> <span>(this opens the admin console inside Eclipse) or browsing to</span> <kbd class="calibre13">http://localhost:4848</kbd> <span>(</span><kbd class="calibre13">4848</kbd> <span>is the default port to which the GlassFish admin console application listens). In the admin console, select</span> <span>Resources</span> <span>|</span> <span>JDBC</span> <span>|</span> <span>JDBC </span><span>Connection </span><span>Pools</span><span>. Click the </span><span>New</span> <span>button on the </span><span>JDBC Connection Pool</span> <span>page:</span></li>
</ol>
<div class="packt_figure1"><img src="../images/00161.jpeg" class="calibre169"/></div>
<div class="packt_figure1"><span>Figure 7.9: Create JDBC Connection Pool in GlassFish</span></div>
<ol start="2" class="calibre14">
<li class="calibre11" value="2"><span>Set</span> <span>Pool Name</span> <span>as</span> <kbd class="calibre13">MySQLconnectionPool</kbd> <span>and select</span> <span>javax.sql.DataSource</span> <span>as</span> <span>Resource Type</span><span>. Select</span> <span>MySql</span> <span>from the</span> <span>Database Driver Vendor</span> <span>list and click</span> <span>Next</span><span>. In the next page, select the correct</span> <span>Datasource Classname</span> <span>(</span><span>com.mysql.jdbc.jdbc2.optional.MysqlDatasource</span><span>):</span></li>
</ol>
<div class="packt_figure1"><img src="../images/00162.jpeg" class="calibre170"/></div>
<div class="packt_figure1"><span>Figure 7.10: JDBC Connection Pool settings in GlassFish</span></div>
<ol start="3" class="calibre14">
<li value="3" class="calibre11">We need to set the hostname, port, username, and password of MySQL. In the admin page, scroll down to the <span>Additional Properties</span> section and set the following properties:</li>
</ol>
<table border="1" class="calibre49">
<tbody class="calibre50">
<tr class="calibre51">
<td class="calibre52">
<p class="calibre3"><strong class="calibre5">Properties</strong></p>
</td>
<td class="calibre52">
<p class="calibre3"><strong class="calibre5">Values</strong></p>
</td>
</tr>
<tr class="calibre51">
<td class="calibre52">
<p class="calibre3"><span class="calibre12">Port/PortNumber</span></p>
</td>
<td class="calibre52">
<p class="calibre3"><kbd class="calibre13">3306</kbd></p>
</td>
</tr>
<tr class="calibre51">
<td class="calibre52">
<p class="calibre3"><span class="calibre12">DatabaseName</span></p>
</td>
<td class="calibre52">
<p class="calibre3"><kbd class="calibre13">&lt;schemaname_of_coursemanagement&gt;</kbd>, for example,</p>
<p class="calibre3"><kbd class="calibre13">course_management</kbd>. See <a target="_blank" href="part0073.html#25JP20-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55" class="calibre9"><span>Chapter 4</span></a>, <em class="calibre21">Creating JEE Database Applications</em>, for details on creating the MySQL schema for the <em class="calibre21">Course Management</em> database.</p>
</td>
</tr>
<tr class="calibre51">
<td class="calibre52">
<p class="calibre3"><span class="calibre12">Password</span></p>
</td>
<td class="calibre52">
<p class="calibre3">MySQL database password.</p>
</td>
</tr>
<tr class="calibre51">
<td class="calibre52">
<p class="calibre3"><span class="calibre12">URL/Url</span></p>
</td>
<td class="calibre52">
<p class="calibre3"><kbd class="calibre13">jdbc:mysql://:3306/&lt;database_name&gt;</kbd> , for example,</p>
<p class="calibre3"><kbd class="calibre13">jdbc:mysql://:3306/course_management</kbd></p>
</td>
</tr>
<tr class="calibre51">
<td class="calibre52">
<p class="calibre3"><span class="calibre12">ServerName</span></p>
</td>
<td class="calibre52">
<p class="calibre3"><kbd class="calibre13">localhost</kbd></p>
</td>
</tr>
<tr class="calibre51">
<td class="calibre52">
<p class="calibre3"><span class="calibre12">User</span></p>
</td>
<td class="calibre52">
<p class="calibre3">MySQL username</p>
</td>
</tr>
</tbody>
</table>
<ol start="4" class="calibre14">
<li class="calibre11" value="4"><span>Click</span> <span>Finish</span><span>. The new connection pool is added to the list in the left pane. Click on the newly added connection pool. In the </span><span>General</span> <span>tab, click on the </span><span>Ping</span> <span>button and make sure that the ping is successful</span>:</li>
</ol>
<div class="packt_figure2"><img src="../images/00163.jpeg" class="calibre171"/></div>
<div class="packt_figure1">Figure 7.11: Test JDBC Connection Pool in GlassFish</div>
<ol start="5" class="calibre14">
<li class="calibre11" value="5"><span>Next, we need to create a JNDI resource for this connection pool so that it can be accessed from the client application. Select the </span><span>Resources</span> <span>|</span> <span>JDBC</span> <span>|</span> <span>JDBC </span><span>Resources</span> <span>node in the left pane. Click the </span><span>New</span> <span>button to create a new JDBC resource:</span></li>
</ol>
<div class="packt_figure1"><img src="../images/00164.jpeg" class="calibre172"/></div>
<div class="packt_figure1"><span>Figure 7.12: Test JDBC Connection Pool in GlassFish</span></div>
<ol start="6" class="calibre14">
<li value="6" class="calibre11">Set <span>JNDI Name</span> as <kbd class="calibre13">jdbc/CourseManagement</kbd>. From the <span>Pool Name</span> drop-down list, select the connection pool that we created for MySQL, <kbd class="calibre13">MySQLconnectionPool</kbd>. Click <span>Save</span>.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Configuring JPA in an Eclipse project</h1>
                
            
            <article>
                
<p class="calibre3">We will now configure our EJB project to use JPA to access the MySQL database. We have already learned how to enable JPA for an Eclipse project in <a target="_blank" href="part0073.html#25JP20-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55" class="calibre9"><span>Chapter 4</span></a>, <em class="calibre21">Creating JEE Database Applications</em>. However, we will briefly cover the steps again here:</p>
<ol class="calibre14">
<li class="calibre11" value="1"><span>Right-click on the </span><kbd class="calibre13">CourseManagementEJBs</kbd> <span>project in</span> <span>Project Explorer </span><span>and select</span> <span>Configure</span> <span>|</span> <span>Convert to JPA Project</span><span>. Eclipse opens the </span><span>Project Facets</span> <span>window:</span></li>
</ol>
<div class="packt_figure1"><img src="../images/00165.jpeg" class="calibre173"/></div>
<div class="packt_figure1">Figure 7.13: Eclipse Project Facets</div>
<ol start="2" class="calibre14">
<li class="calibre11" value="2"><span>Click</span> <span>Next</span> <span>to go to the </span><span>JPA Facet</span> <span>page:</span></li>
</ol>
<div class="packt_figure1"><img src="../images/00166.jpeg" class="calibre174"/></div>
<div class="packt_figure1">Figure 7.14: JPA Facet</div>
<p class="calibre3">Keep the default values unchanged, and click <span class="calibre12">Finish</span>. Eclipse adds <kbd class="calibre13">persistence.xml</kbd>, required by JPA, to the project under the <span class="calibre12">JPA Content</span> group in <span class="calibre12">Project Explorer</span>. We need to configure the JPA datasource in <kbd class="calibre13">persistence.xml</kbd>. Open <kbd class="calibre13">persistence.xml</kbd> and click on the <span class="calibre12">Connection</span> tab. Set <span class="calibre12">Transaction Type</span> to <kbd class="calibre13">JTA</kbd>. In the <span class="calibre12">JTA datasource</span> textbox, type the JNDI name that we set up for our MySQL database in the previous section, which was <kbd class="calibre13">jdbc/CourseManagement</kbd>. Save the file. Note that the actual location of <kbd class="calibre13">persistence.xml</kbd> is <kbd class="calibre13">ejbModule</kbd>/<kbd class="calibre13">META-INF</kbd>.</p>
<p class="calibre3">Let's now create a database connection in Eclipse and link it with JPA properties of the project so that we can create JPA entities from the database tables. Right-click on the <kbd class="calibre13">CourseManagementEJBs</kbd> project and select <span class="calibre12">Properties</span>. This opens the <span class="calibre12">Project Properties</span> window. Click on the <span class="calibre12">JPA</span> node to see the details page. Click on the <span class="calibre12">Add connection</span> link just below the <span class="calibre12">Connection</span> drop-down box. We have already seen how to set up a database connection in the <em class="calibre21">Using Eclipse Data Source Explorer</em> section of <a target="_blank" href="part0073.html#25JP20-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55" class="calibre9"><span>Chapter 4</span></a>, <em class="calibre21">Creating JEE Database Applications</em>. However, we will quickly recap the steps:</p>
<ol class="calibre14">
<li class="calibre11" value="1"><span>In the </span><span>Connection Profile</span> <span>window, select MySQL:</span></li>
</ol>
<div class="packt_figure1"><img src="../images/00167.jpeg" class="calibre175"/></div>
<div class="packt_figure1">Figure 7.15: New DB Connection Profile</div>
<ol start="2" class="calibre14">
<li class="calibre11" value="2"><span>Type</span> <kbd class="calibre13">CourseManagementDBConnection</kbd> <span>in the name textbox and click</span> <span>Next</span><span>. In the </span><span>New Connection Profile</span> <span>window, click on the</span> <span>new connection profile</span> <span>button (the circle next to the </span><span>Drivers</span> <span>drop-down box) to open the </span><span>New Driver Definition</span> <span>window. Select the appropriate</span> <span>MySQL JDBC Driver</span> <span>version and click on the </span><span>JAR List</span> <span>tab. In the case of any error, remove any existing</span> <kbd class="calibre13">.jar</kbd><span> and click on the</span> <span>Add </span><span>JAR/Zip</span> <span>button. Browse to the MySQL JDBC driver JAR that we saved in the</span> <kbd class="calibre13">&lt;glassfish_home&gt;/glassfish/domains/domain1/lib/ext</kbd> <span>folder. Click</span> <span>OK</span><span>. Back in the </span><span>New Connection Profile</span> <span>window, enter the database name, modify the connection URL, and enter</span> <span>User name</span> <span>and</span> <span>Password</span><span>:</span></li>
</ol>
<div class="packt_figure1"><img src="../images/00168.jpeg" class="calibre176"/></div>
<div class="packt_figure1">Figure 7.16: Configuring MySQL database connection</div>
<ol start="3" class="calibre14">
<li class="calibre11" value="3"><span>Select the </span><span>Save password</span> <span>checkbox. Click the </span><span>Test Connection</span> <span>button and make sure that the test is successful. Click the</span> <span>Finish</span> <span>button. Back in the JPA properties page, the new connection is added and appropriate schema is selected:</span></li>
</ol>
<div class="packt_figure1"><img src="../images/00169.jpeg" class="calibre177"/></div>
<div class="packt_figure1">Figure 7.17: Connection added to JPA project properties</div>
<ol start="4" class="calibre14">
<li value="4" class="calibre11">Click <span>OK</span> to save the changes.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Creating a JPA entity</h1>
                
            
            <article>
                
<p class="calibre3">We will now create the entity class for <kbd class="calibre13">Course</kbd>, using Eclipse JPA tools:</p>
<ol class="calibre14">
<li class="calibre11" value="1"><span>Right-click on the</span> <kbd class="calibre13">CourseManagementEJBs</kbd> <span>project and select</span> <span>JPA Tool</span> <span>|</span> <span>Generate Entities from Tables</span><span>:</span></li>
</ol>
<div class="packt_figure1"><img src="../images/00170.jpeg" class="calibre178"/></div>
<div class="packt_figure1">Figure 7.18: Creating entity from tables</div>
<ol start="2" class="calibre14">
<li class="calibre11" value="2"><span>Select the</span> <span>Course</span> <span>table and click</span> <span>Next</span><span>. Click</span> <span>Next</span> <span>in the </span><span>Table Associations</span> <span>window. On the next page, select</span> <kbd class="calibre13">identity</kbd> <span>as</span> <span>Key generator</span><span>:</span></li>
</ol>
<div class="packt_figure1"><img src="../images/00171.jpeg" class="calibre179"/></div>
<div class="packt_figure1">Figure 7.19: Customizing JPA entity details</div>
<ol start="3" class="calibre14">
<li value="3" class="calibre11">Enter the package name. We do not want to change anything on the next page, so click <span>Finish</span>. Notice that the wizard creates a <kbd class="calibre13">findAll</kbd> query for the class that we can use to get all courses:</li>
</ol>
<pre class="calibre35">@Entity 
@NamedQuery(name="Course.findAll", query="SELECT c FROM <br class="title-page-name"/> Course c") 
public class Course implements Serializable { ...} </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Creating stateless EJB</h1>
                
            
            <article>
                
<p class="calibre3">We will now create the stateless EJB for our application:</p>
<ol class="calibre14">
<li class="calibre11" value="1"><span>Right-click on the </span><kbd class="calibre13">ejbModule</kbd> <span>folder in the </span><kbd class="calibre13">CourseManagementEJBs</kbd> <span>project in</span> <span>Project Explorer</span> <span>and select</span> <span>New</span> <span>|</span> <span>Session Bean (3.x)</span><span>. Type</span> <kbd class="calibre13">packt.book.jee.eclipse.ch7.ejb</kbd> <span>in the </span><span>Java package</span> <span>textbox and</span> <kbd class="calibre13">CourseBean</kbd> <span>in</span> <span>Class </span><span>name</span><span>. Select the </span><span>Remote</span> <span>checkbox:</span></li>
</ol>
<div class="packt_figure1"><img src="../images/00172.jpeg" class="calibre180"/></div>
<div class="packt_figure1">Figure 7.20: Creating a stateless session bean</div>
<ol start="2" class="calibre14">
<li value="2" class="calibre11">Click <span>Next</span>. No change is required on the next page:</li>
</ol>
<div class="packt_figure1"><img src="../images/00173.jpeg" class="calibre181"/></div>
<div class="packt_figure1"><span>Figure 7.21: Stateless session bean information<br class="title-page-name"/></span></div>
<ol start="3" class="calibre14">
<li value="3" class="calibre11">Click <span>Finish</span>. A <kbd class="calibre13">CourseBean</kbd> class is created with <kbd class="calibre13">@Stateless</kbd> and <kbd class="calibre13">@Localbean</kbd> annotations. The class also implements the <kbd class="calibre13">CourseBeanRemote</kbd> interface, which is defined in the <kbd class="calibre13">CourseManagementEJBClient</kbd> project. This interface is a shared interface (a client calling EJB needs to access this interface):</li>
</ol>
<pre class="calibre35">@Stateless 
@LocalBean 
public class CourseBean implements CourseBeanRemote { 
    public CourseBean() { 
    } 
} </pre>
<p class="calibre3">The interface is annotated with <kbd class="calibre13">@Remote</kbd>:</p>
<pre class="calibre25">@Remote 
public interface CourseBeanRemote { 
 
} </pre>
<p class="calibre3">Now, the question is how do we return <kbd class="calibre13">Course</kbd> information from our EJB? The EJB will call JPA APIs to get instances of the <kbd class="calibre13">Course</kbd> entity, but do we want EJB to return instances of the <kbd class="calibre13">Course</kbd> entity or should it return instances of lightweight <strong class="calibre5">data transfer object</strong> (<strong class="calibre5"><span class="calibre12">DTO</span></strong>)? Each has its own advantages. If we return a <kbd class="calibre13">Course</kbd> entity, then we do not need to transfer data between objects; which we will have to do in the case of DTO (transfer data from the entity to the corresponding DTO). However, passing entities between layers may not be a good idea if the EJB client is not in the same application, and you may not want to expose your data model to external applications. Furthermore, by passing back JPA entities you are forcing the client application to depend on JPA libraries in its implementation.</p>
<p class="calibre3">DTOs are lightweight, and you can expose only those fields that you want your clients to use. However, you will have to transfer data between entities and DTOs.</p>
<p class="calibre3">If your EJBs are going to be used by the client in the same application, then it could be easier to transfer entities to the client from the EJBs. However, if your client is not part of the same EJB application, or when you want to expose the EJB as a web service (we will learn how to create web services in <a target="_blank" href="part0176.html#57R300-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55" class="calibre9">Chapter 9</a>, <em class="calibre21">Creating Web Services</em>), then you may need to use DTOs.</p>
<p class="calibre3">In our application, we will see examples of both the approaches, that is, an EJB method returning JPA entities as well as DTOs. Remember that we have created <kbd class="calibre13">CourseBean</kbd> as a remote as well as a local bean (no-interface view). Implementation of the remote interface method will return DTOs and that of the local method will return JPA entities.</p>
<p class="calibre3">Let's now add the <kbd class="calibre13">getCourses</kbd> method to the EJB. We will create <kbd class="calibre13">CourseDTO</kbd>, a data transfer object, which is a POJO, and returns instances of the DTO from the <kbd class="calibre13">getCourses</kbd> method. This DTO needs to be in the <kbd class="calibre13">CourseManagementEJBsClient</kbd> project because it will be shared between the EJB and its client.</p>
<p class="calibre3">Create the following class in the <kbd class="calibre13">packt.book.jee.eclipse.ch7.dto</kbd> package in the <kbd class="calibre13">CourseManagementEJBsClient</kbd> project:</p>
<pre class="calibre25">package packt.book.jee.eclipse.ch7.dto; 
 
public class CourseDTO { 
  private int id; 
  private int credits; 
  private String name; 
  public int getId() { 
    return id; 
  } 
  public void setId(int id) { 
    this.id = id; 
  } 
  public int getCredits() { 
    return credits; 
  } 
  public void setCredits(int credits) { 
    this.credits = credits; 
  } 
  public String getName() { 
    return name; 
  } 
  public void setName(String name) { 
    this.name = name; 
  } 
} </pre>
<p class="calibre3">Add the following method to <kbd class="calibre13">CourseBeanRemote</kbd>:</p>
<pre class="calibre25">public List&lt;CourseDTO&gt; getCourses(); </pre>
<p class="calibre3">We need to implement this method in <kbd class="calibre13">CourseBean</kbd> EJB. To get the courses from the database, the EJB needs to first get an instance of <kbd class="calibre13">EntityManager</kbd>. Recall that in <a target="_blank" href="part0073.html#25JP20-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55" class="calibre9"><span>Chapter 4</span></a>, <em class="calibre21">Creating JEE Database Applications,</em> we created <kbd class="calibre13">EntityManagerFactory</kbd> and got an instance of <kbd class="calibre13">EntityManager</kbd> from it. Then, we passed that instance to the service class, which actually got the data from the database using JPA APIs.</p>
<p class="calibre3">JEE application servers make injecting <kbd class="calibre13">EntityManager</kbd> very easy. You just need to create the <kbd class="calibre13">EntityManager</kbd> field in the EJB class and annotate it with <kbd class="calibre13">@PersistenceContext(unitName="&lt;name_as_specified_in_persistence.xml&gt;")</kbd>. The <kbd class="calibre13">unitName</kbd> attribute is optional if there is only one persistence unit defined in <kbd class="calibre13">persistence.xml</kbd>. Open the <kbd class="calibre13">CourseBean</kbd> class and add the following declaration:</p>
<pre class="calibre25">@PersistenceContext 
EntityManager entityManager; </pre>
<p class="calibre3">EJBs are managed objects, and the EJB container injects <kbd class="calibre13">EntityManager</kbd> after EJBs are created.</p>
<div class="packt_tip"><br class="calibre26"/>
Auto injection of objects is a part of JEE features called <strong class="calibre182">Context and Dependency Injection</strong> (<strong class="calibre182">CDI</strong>). See <a href="https://javaee.github.io/tutorial/cdi-basic.html#GIWHB" class="calibre17">https://javaee.github.io/tutorial/cdi-basic.html#GIWHB</a> for information on CDI.</div>
<p class="calibre3">Let's now add a method to <kbd class="calibre13">CourseBean</kbd> EJB that will return a list of <kbd class="calibre13">Course</kbd> entities. We will name this method <kbd class="calibre13">getCourseEntities</kbd>. This method will be called by the <kbd class="calibre13">getCourses</kbd> method in the same EJB, which will then convert the list of entities to DTOs. The method <kbd class="calibre13">getCourseEntities</kbd> can also be called by any web application, because the EJB exposes no-interface view (using the <kbd class="calibre13">@LocalBean</kbd> annotation):</p>
<pre class="calibre25">public List&lt;Course&gt; getCourseEntities() { 
//Use named query created in Course entity using @NameQuery <br class="title-page-name"/> annotation.      TypedQuery&lt;Course&gt; courseQuery = <br class="title-page-name"/> entityManager.createNamedQuery("Course.findAll", Course.class); 
      return courseQuery.getResultList(); 
} </pre>
<p class="calibre3">After implementing the <kbd class="calibre13">getCourses</kbd> method (defined in our remote business interface called <kbd class="calibre13">CourseBeanRemote</kbd>), we have <kbd class="calibre13">CourseBean</kbd>, as follows:</p>
<pre class="calibre25">@Stateless 
@LocalBean 
public class CourseBean implements CourseBeanRemote { 
  @PersistenceContext 
  EntityManager entityManager; 
 
    public CourseBean() { 
    } 
 
    public List&lt;Course&gt; getCourseEntities() { 
      //Use named query created in Course entity using @NameQuery <br class="title-page-name"/>       annotation.      TypedQuery&lt;Course&gt; courseQuery = <br class="title-page-name"/> entityManager.createNamedQuery("Course.findAll", Course.class); 
      return courseQuery.getResultList(); 
    } 
 
  @Override 
  public List&lt;CourseDTO&gt; getCourses() { 
    //get course entities first 
    List&lt;Course&gt; courseEntities = getCourseEntities(); 
 
    //create list of course DTOs. This is the result we will <br class="title-page-name"/>     return 
    List&lt;CourseDTO&gt; courses = new ArrayList&lt;CourseDTO&gt;(); 
 
    for (Course courseEntity : courseEntities) { 
      //Create CourseDTO from Course entity 
      CourseDTO course = new CourseDTO(); 
      course.setId(courseEntity.getId()); 
      course.setName(courseEntity.getName()); 
      course.setCredits(course.getCredits()); 
      courses.add(course); 
    } 
    return courses; 
  } 
} </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Creating JSF and managed beans</h1>
                
            
            <article>
                
<p class="calibre3">We will now create a JSF page to display courses in the <kbd class="calibre13">CourseManagementWeb</kbd> project. We will also create a managed bean that will call the <kbd class="calibre13">getCourses</kbd> method of <kbd class="calibre13">CourseEJB</kbd>. See the <em class="calibre21">Java Server Faces</em> section in <a target="_blank" href="part0037.html#1394Q0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55" class="calibre9"><span>Chapter 2</span></a>, <em class="calibre21">Creating a Simple JEE Web Application</em>, for details about JSF.</p>
<p class="calibre3">As explained in <a target="_blank" href="part0037.html#1394Q0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55" class="calibre9"><span>Chapter 2</span></a>, <em class="calibre21">Creating a Simple JEE Web Application</em>, we need to add JSF Servlet and mapping to <kbd class="calibre13">web.xml</kbd>. Open <kbd class="calibre13">web.xml</kbd> from the <kbd class="calibre13">CourseManagementWeb</kbd> project. You can open this file either by double-clicking the <span class="calibre12">Deployment Descriptor: </span><span class="calibre12">CourseManagementWeb</span> node (under the project in <span class="calibre12">Project Explorer</span>) or from the <kbd class="calibre13">WebContent/Web-INF</kbd> folder (again, under the project in <span class="calibre12">Project Explorer</span>). Add the following servlet declaration and mapping (within the <kbd class="calibre13">web-app</kbd> node):</p>
<pre class="calibre25">&lt;servlet&gt; 
  &lt;servlet-name&gt;JSFServlet&lt;/servlet-name&gt; 
  &lt;servlet-class&gt;javax.faces.webapp.FacesServlet&lt;/servlet-class&gt; 
  &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; 
&lt;/servlet&gt; 
 
&lt;servlet-mapping&gt; 
  &lt;servlet-name&gt;JSFServlet&lt;/servlet-name&gt; 
  &lt;url-pattern&gt;*.xhtml&lt;/url-pattern&gt; 
&lt;/servlet-mapping&gt; </pre>
<p class="calibre3">The <kbd class="calibre13">CourseManagementWeb</kbd> project needs to access the business interface of EJB, which is in <kbd class="calibre13">CourseManagementEJBsClient</kbd>. So, we need to add the reference of <kbd class="calibre13">CourseManagementEJBsClient</kbd> to <kbd class="calibre13">CourseManagementWeb</kbd>. Open the project properties of <kbd class="calibre13">CourseManagementWeb</kbd> (right-click on the <kbd class="calibre13">CourseManagementWeb</kbd> project and select <span class="calibre12">Properties</span>) and select <span class="calibre12">Java Build Path</span>. Click on the <span class="calibre12">Projects</span> tab, and then click the <span class="calibre12">Add...</span> button. Select <kbd class="calibre13">CourseManagementEJBsClient</kbd> from the list and click <span class="calibre12">OK</span>:</p>
<div class="packt_figure1"><br class="title-page-name"/>
<img src="../images/00174.jpeg" class="calibre183"/></div>
<div class="packt_figure1">Figure 7.22: Adding project reference</div>
<p class="calibre3">Now, let's create a managed bean for the JSF that we are going to create later. Create a <kbd class="calibre13">CourseJSFBean</kbd> class in the <kbd class="calibre13">packt.book.jee.eclipse.ch7.web.bean</kbd> package in the <kbd class="calibre13">CourseManagementWeb</kbd> project (Java source files go in the <kbd class="calibre13">src</kbd> folder under the <span class="calibre12">Java Resources</span> group):</p>
<pre class="calibre25">import java.util.List; 
import javax.ejb.EJB; 
import javax.faces.bean.ManagedBean; 
import packt.book.jee.eclipse.ch7.dto.CourseDTO; 
import packt.book.jee.eclipse.ch7.ejb.CourseBeanRemote; 
 
@ManagedBean(name="Course") 
public class CourseJSFBean { 
  @EJB 
  CourseBeanRemote courseBean; 
 
  public List&lt;CourseDTO&gt; getCourses() { 
    return courseBean.getCourses(); 
  } 
} </pre>
<p class="calibre3">JSF beans are managed beans, so we can have the container inject EJBs using the <kbd class="calibre13">@EJB</kbd> annotation. In the preceding code we have referenced <kbd class="calibre13">CourseBean</kbd> with its remote interface, <kbd class="calibre13">CourseBeanRemote</kbd>. We then created a method called <kbd class="calibre13">getCourses</kbd>, which calls the method with the same name on <kbd class="calibre13">Course</kbd> EJB and returns the list of <kbd class="calibre13">CourseDTO</kbd> objects.<br class="calibre6"/>
Note that we have set the <kbd class="calibre13">name</kbd> attribute in the <kbd class="calibre13">@ManagedBean</kbd> annotation. This managed bean would be accessed from JSF as variable <kbd class="calibre13">Course</kbd>.</p>
<p class="calibre3">We will now create the JSF page, <kbd class="calibre13">course.xhtml</kbd>. Right-click on <span class="calibre12">WebContent</span> group in the <kbd class="calibre13">CourseManagementWeb</kbd> project, and select <span class="calibre12">New</span> | <span class="calibre12">File</span>. Create <kbd class="calibre13">courses.xhtml</kbd> with the following content:</p>
<pre class="calibre25">&lt;html  
  
 &gt; 
 
&lt;head&gt; 
  &lt;title&gt;Courses&lt;/title&gt; 
&lt;/head&gt; 
&lt;body&gt; 
  &lt;h2&gt;Courses&lt;/h2&gt; 
  &lt;h:dataTable value="#{Course.courses}" var="course"&gt; 
      &lt;h:column&gt; 
      &lt;f:facet name="header"&gt;Name&lt;/f:facet&gt; 
      #{course.name} 
    &lt;/h:column&gt; 
      &lt;h:column&gt; 
      &lt;f:facet name="header"&gt;Credits&lt;/f:facet&gt; 
      #{course.credits} 
    &lt;/h:column&gt; 
  &lt;/h:dataTable&gt; 
&lt;/body&gt; 
&lt;/html&gt; </pre>
<p class="calibre3">The page uses the <kbd class="calibre13">dataTable</kbd> tag (<a href="https://docs.oracle.com/javaee/7/javaserver-faces-2-2/vdldocs-jsp/h/dataTable.html" class="calibre9"><span>https://docs.oracle.com/javaee/7/javaserver-faces-2-2/vdldocs-jsp/h/dataTable.html</span></a>), which receives the data to populate from the <kbd class="calibre13">Course</kbd> managed bean (which is actually the <kbd class="calibre13">CourseJSFBean</kbd> class). <kbd class="calibre13">Course.courses</kbd> in the expression language syntax is a short-form for <kbd class="calibre13">Course.getCourses()</kbd>. This results in a call to the <kbd class="calibre13">getCourses</kbd> method of the <kbd class="calibre13">CourseJSFBean</kbd> class.</p>
<p class="calibre3">Each element of the list returned by <kbd class="calibre13">Course.courses</kbd>, which is <kbd class="calibre13">List</kbd> of <kbd class="calibre13">CourseDTO</kbd>, is represented by the <kbd class="calibre13">course</kbd> variable (in the <kbd class="calibre13">var</kbd> attribute value). We then display the name and credits of each course in the table using the <kbd class="calibre13">column</kbd> child tag.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Running the example</h1>
                
            
            <article>
                
<p class="calibre3">Before we can run the example, we need to start the GlassFish Server and deploy our JEE application in it:</p>
<ol class="calibre14">
<li value="1" class="calibre11">Start the GlassFish Server.</li>
<li value="2" class="calibre11">Once it is started, right-click on the GlassFish Server in the <span>Servers</span> <span>view and select the</span> <span>Add and Remove...</span> <span>menu option:</span></li>
</ol>
<div class="packt_figure1"><img src="../images/00175.jpeg" class="calibre184"/></div>
<div class="packt_figure1">Figure 7.23: Adding a project to GlassFish for deployment</div>
<ol start="3" class="calibre14">
<li class="calibre11" value="3"><span>Select the EAR project and click on the</span> <span>Add</span> <span>button. Then, click</span> <span>Finish</span><span>.</span><br class="title-page-name"/>
<span>The selected EAR application will be deployed in the server:</span></li>
</ol>
<div class="packt_figure1"><img src="../images/00176.jpeg" class="calibre185"/></div>
<div class="packt_figure1">Figure 7.24: Application deployed in GlassFish</div>
<ol start="4" class="calibre14">
<li value="4" class="calibre11">To run the JSF page, <kbd class="calibre13">course.xhtml</kbd>, right-click on it in <span>Project Explorer</span><br class="title-page-name"/>
and select <span>Run As</span> | <span>Run on Server</span>. The page will be opened in the internal Eclipse browser and courses in the MySQL database will be displayed on the page.</li>
</ol>
<p class="calibre3">Note that we can use <kbd class="calibre13">CourseBean</kbd> (EJB) as a local bean in <kbd class="calibre13">CourseJSFBean</kbd>, because they are in the same application deployed on the same server. To do this, add a reference of the <kbd class="calibre13">CourseManagementEJBs</kbd> project in the build path of <kbd class="calibre13">CourseManagementWeb</kbd> (open the project properties of <kbd class="calibre13">CourseManagementWeb</kbd>, select <span class="calibre12">Java Build Path</span>, select the <span class="calibre12">Projects</span> tab, and click the <span class="calibre12">Add...</span> button. Select the <kbd class="calibre13">CourseManagementEJBs</kbd> project and add its reference).</p>
<p class="calibre3">Then, in the <kbd class="calibre13">CourseJSFBean</kbd> class, remove the declaration of <kbd class="calibre13">CourseBeanRemote</kbd> and add one for <kbd class="calibre13">CourseBean</kbd>:</p>
<pre class="calibre25">  //@EJB 
  //CourseBeanRemote courseBean; 
   
  @EJB 
  CourseBean courseBean; </pre>
<p class="calibre3">When you make any changes in the code, the EAR project needs to be redeployed in the GlassFish Server. In <span class="calibre12">Servers</span> view, you can see whether redeployment is needed by checking the status of the server. If it is <span class="calibre12">[Started, Synchronized]</span>, then no redeployment is needed. However, if it is <span class="calibre12">[Started, Republish]</span>, then redeployment is required. Just click on the server node and select the <span class="calibre12">Publish</span> menu option.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Creating EAR for deployment outside Eclipse</h1>
                
            
            <article>
                
<p class="calibre3">In the last section, we learned how to deploy an application to GlassFish from Eclipse. This works fine during development, but finally you will need to create the EAR file for deployment to an external server. To create the EAR file from the project, right-click on the EAR project (in our example, it is <kbd class="calibre13">CourseManagementEJBsEAR</kbd>) and select <span class="calibre12">Export</span> | <span class="calibre12">EAR </span><span class="calibre12">file</span>:</p>
<div class="packt_figure1"><br class="title-page-name"/>
<img src="../images/00177.jpeg" class="calibre186"/></div>
<div class="packt_figure1">Figure 7.25: Exporting to EAR file</div>
<p class="calibre3">Select the destination folder and click <span class="calibre12">Finish</span>. This file can then be deployed in GlassFish using the management console or by copying it to the <kbd class="calibre13">autodeploy</kbd> folder in GlassFish.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Creating a JEE project using Maven</h1>
                
            
            <article>
                
<p class="calibre3">In this section, we will learn how to create JEE projects with EJBs using Maven. Creating Maven projects may be preferable to Eclipse JEE projects because builds can be automated. We have seen many details of creating EJBs, JPA entities, and other classes in the previous section, so we won't repeat all that information here. We have also learned how to create Maven projects in <a target="_blank" href="part0037.html#1394Q0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55" class="calibre9"><span>Chapter 2</span></a>, <em class="calibre21">Creating a Simple JEE Web Application,</em> and <a target="_blank" href="part0057.html#1MBG20-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55" class="calibre9"><span>Chapter 3</span></a>, <em class="calibre21">Source Control Management in Eclipse,</em> so the basic details of creating a Maven project will not be repeated either. We will focus mainly on how to create EJB projects using Maven. We will create the following projects:</p>
<ul class="calibre10">
<li class="calibre11"><kbd class="calibre13">CourseManagementMavenEJBs</kbd>: This project contains EJBs</li>
<li class="calibre11"><kbd class="calibre13">CourseManagementMavenEJBClient</kbd>: This project contains shared interfaces and objects between an EJB project and the client projects</li>
<li class="calibre11"><kbd class="calibre13">CourseManagementMavenWAR</kbd>: This is a web project containing a JSF page and a managed bean</li>
<li class="calibre11"><kbd class="calibre13">CourseManagementMavenEAR</kbd>: This project creates the EAR file that can be deployed in GlassFish</li>
<li class="calibre11"><kbd class="calibre13">CourseManagement</kbd>: This project is the overall parent project that builds all the previously mentioned projects</li>
</ul>
<p class="calibre3">We still start with <kbd class="calibre13">CourseManagementMavenEJBs</kbd>. This project should generate the EJB JAR file. Let's create a Maven project with the following details:</p>
<table border="1" class="calibre49">
<tbody class="calibre50">
<tr class="calibre51">
<td class="calibre52">
<p class="calibre3"><strong class="calibre5"> Field</strong></p>
</td>
<td class="calibre52">
<p class="calibre3"><strong class="calibre5">Value</strong></p>
</td>
</tr>
<tr class="calibre51">
<td class="calibre52">
<p class="calibre3"><span class="calibre12">Group ID</span></p>
</td>
<td class="calibre52">
<p class="calibre3"><span class="calibre12">packt.book.jee.eclipse.ch7.maven</span></p>
</td>
</tr>
<tr class="calibre51">
<td class="calibre52">
<p class="calibre3"><span class="calibre12">Artifact ID</span></p>
</td>
<td class="calibre52">
<p class="calibre3"><span class="calibre12">CourseManagementMavenEJBClient</span></p>
</td>
</tr>
<tr class="calibre51">
<td class="calibre52">
<p class="calibre3"><span class="calibre12">Version</span></p>
</td>
<td class="calibre52">
<p class="calibre3"><span class="calibre12">1</span></p>
</td>
</tr>
<tr class="calibre51">
<td class="calibre52">
<p class="calibre3"><span class="calibre12">Packaging</span></p>
</td>
<td class="calibre52">
<p class="calibre3"><span class="calibre12">jar</span></p>
</td>
</tr>
</tbody>
</table>
<div class="title-page-name"/>
<p class="calibre3"> </p>
<p class="calibre3"> </p>
<p class="calibre3">We need to add the dependency of JEE APIs to our EJB project. Let's add the dependency of <kbd class="calibre13">javax.javaee-api</kbd>. Since we are going to deploy this project in GlassFish, which comes with its own JEE implementation and libraries, we will scope this dependency as provided. Add the following in <kbd class="calibre13">pom.xml</kbd>:</p>
<pre class="calibre25">  &lt;dependencies&gt; 
    &lt;dependency&gt; 
      &lt;groupId&gt;javax&lt;/groupId&gt; 
      &lt;artifactId&gt;javaee-api&lt;/artifactId&gt; 
      &lt;version&gt;8.0&lt;/version&gt; 
      &lt;scope&gt;provided&lt;/scope&gt; 
    &lt;/dependency&gt; 
  &lt;/dependencies&gt; </pre>
<p class="calibre3">When we create the EJBs in this project, we need to create local or remote business interfaces in a shared project (client project). Therefore, we will create <kbd class="calibre13">CourseManagementMavenEJBClient</kbd> with the following details:</p>
<table border="1" class="calibre49">
<tbody class="calibre50">
<tr class="calibre51">
<td class="calibre52">
<p class="calibre3"><strong class="calibre5">Field</strong></p>
</td>
<td class="calibre52">
<p class="calibre3"><strong class="calibre5">Values</strong></p>
</td>
</tr>
<tr class="calibre51">
<td class="calibre52">
<p class="calibre3"><span class="calibre12">Group ID</span></p>
</td>
<td class="calibre52">
<p class="calibre3"><span class="calibre12">packt.book.jee.eclipse.ch7.maven</span></p>
</td>
</tr>
<tr class="calibre51">
<td class="calibre52">
<p class="calibre3"><span class="calibre12">Artifact ID</span></p>
</td>
<td class="calibre52">
<p class="calibre3"><span class="calibre12">CourseManagementMavenEJBs</span></p>
</td>
</tr>
<tr class="calibre51">
<td class="calibre52">
<p class="calibre3"><span class="calibre12">Version</span></p>
</td>
<td class="calibre52">
<p class="calibre3"><span class="calibre12">1</span></p>
</td>
</tr>
<tr class="calibre51">
<td class="calibre52">
<p class="calibre3"><span class="calibre12">Packaging</span></p>
</td>
<td class="calibre52">
<p class="calibre3"><span class="calibre12">jar</span></p>
</td>
</tr>
</tbody>
</table>
<div class="title-page-name"/>
<p class="calibre3"> </p>
<p class="calibre3"> </p>
<p class="calibre3">This shared project also needs to access EJB annotations. So, add the same dependency for <kbd class="calibre13">javax.javaee-api</kbd> that we added previously to the <kbd class="calibre13">pom.xml</kbd> file of the <kbd class="calibre13">CourseManagementMavenEJBClient</kbd> project.</p>
<p class="calibre3">We will create a <kbd class="calibre13">packt.book.jee.eclipse.ch7.ejb</kbd> package in this project and create a remote interface. Create a <kbd class="calibre13">CourseBeanRemote</kbd> interface (just as we created in the <em class="calibre21">Creating stateless EJB</em> section of this chapter). Furthermore, create a <kbd class="calibre13">CourseDTO</kbd> class in the <kbd class="calibre13">packt.book.jee.eclipse.ch7.dto</kbd> package. This class is the same as the one that we created in the <em class="calibre21">Creating stateless EJB</em> section.</p>
<p class="calibre3">We are going to create a <kbd class="calibre13">Course</kbd> JPA entity in the <kbd class="calibre13">CourseManagementMavenEJBs</kbd> project. Before we do that, let's convert this project to a JPA project. Right-click on the project in <span class="calibre12">Package Explorer</span> and select <span class="calibre12">Configure</span> | <span class="calibre12">Convert to JPA Project</span>. In the JPA configuration wizard, select the following JPA facet details:</p>
<table border="1" class="calibre49">
<tbody class="calibre50">
<tr class="calibre51">
<td class="calibre52">
<p class="calibre3"><strong class="calibre5">Fields</strong></p>
</td>
<td class="calibre52">
<p class="calibre3"><strong class="calibre5">Values</strong></p>
</td>
</tr>
<tr class="calibre51">
<td class="calibre52">
<p class="calibre3"><span class="calibre12">Platform</span></p>
</td>
<td class="calibre52">
<p class="calibre3"><span class="calibre12">Generic 2.1</span></p>
</td>
</tr>
<tr class="calibre51">
<td class="calibre52">
<p class="calibre3"><span class="calibre12">JPA Implementation</span></p>
</td>
<td class="calibre52">
<p class="calibre3"><span class="calibre12">Disable Library Configuration</span></p>
</td>
</tr>
</tbody>
</table>
<div class="title-page-name"/>
<p class="calibre3"> </p>
<p class="calibre3">JPA wizard creates a <kbd class="calibre13">META-INF</kbd> folder in the <kbd class="calibre13">src</kbd> folder of the project and creates <kbd class="calibre13">persistence.xml</kbd>. Open <kbd class="calibre13">persistence.xml</kbd> and click on the <span class="calibre12">Connection</span> tab. We have already created the MySQL datasource in GlassFish (see the <em class="calibre21">Configuring datasource in GlassFish</em> section). Enter the JNDI name of the datasource, <kbd class="calibre13">jdbc/CourseManagement</kbd>, in the <span class="calibre12">JTA data source</span> field.</p>
<p class="calibre3">Create a <kbd class="calibre13">Course</kbd> entity in <kbd class="calibre13">packt.book.jee.eclipse.ch7.jpa</kbd>, as described in the <em class="calibre21">Creating JPA entity</em> section. Before we create the EJB in this project, let's add an EJB facet to this project. Right-click on the project and select <span class="calibre12">Properties</span>. Click on the <span class="calibre12">Project Facets</span> group and select the <span class="calibre12">EJB Module</span> checkbox. Set version to the latest one (at the time of writing, the latest version was 3.2). We will now create the implementation class of the remote session bean interface that we created previously. Right-click on the <kbd class="calibre13">CourseManagementMavenEJBs</kbd> project and select the <span class="calibre12">New</span> | <span class="calibre12">Session Bean</span> menu. Create the EJB class with the following details:</p>
<table border="1" class="calibre49">
<tbody class="calibre50">
<tr class="calibre51">
<td class="calibre52">
<p class="calibre3"><strong class="calibre5">Fields</strong></p>
</td>
<td class="calibre52">
<p class="calibre3"><strong class="calibre5">Values</strong></p>
</td>
</tr>
<tr class="calibre51">
<td class="calibre52">
<p class="calibre3"><span class="calibre12">Java package</span></p>
</td>
<td class="calibre52">
<p class="calibre3"><span class="calibre12">packt.book.jee.eclipse.ch7.ejb</span></p>
</td>
</tr>
<tr class="calibre51">
<td class="calibre52">
<p class="calibre3"><span class="calibre12">Class name</span></p>
</td>
<td class="calibre52">
<p class="calibre3"><span class="calibre12">CourseBean</span></p>
</td>
</tr>
<tr class="calibre51">
<td class="calibre52">
<p class="calibre3"><span class="calibre12">State type</span></p>
</td>
<td class="calibre52">
<p class="calibre3"><span class="calibre12">Stateless</span></p>
</td>
</tr>
</tbody>
</table>
<div class="title-page-name"/>
<p class="calibre3"> </p>
<p class="calibre3">Do not select any business interface, because we have already created the business interface in the <kbd class="calibre13">CourseManagementMavenEJBClient</kbd> project. Click <span class="calibre12">Next</span>. On the next page, select <kbd class="calibre13">CourseBeanRemote</kbd>. Eclipse will show errors at this point because <kbd class="calibre13">CourseManagementMavenEJBs</kbd> does not know about <kbd class="calibre13">CourseManagementMavenEJBClient</kbd>, which contains the <kbd class="calibre13">CourseBeanRemote</kbd> interface, used by <kbd class="calibre13">CourseBean</kbd> in the EJB project. Adding the Maven dependency (in <kbd class="calibre13">pom.xml</kbd>) for <kbd class="calibre13">CourseManagementMavenEJBClient</kbd> in <kbd class="calibre13">CourseManagementMavenEJBs</kbd> and implementing the <kbd class="calibre13">getCourses</kbd> method in the EJB class should fix the compilation errors. Now complete the implementation of the <kbd class="calibre13">CourseBean</kbd> class as described in the <em class="calibre21">Creating stateless EJB</em> section of this chapter. Make sure that EJB is marked as <kbd class="calibre13">Remote</kbd>:</p>
<pre class="calibre25">@Stateless 
@Remote 
public class CourseBean implements CourseBeanRemote { 
... 
} </pre>
<p class="calibre3">Let's create a web application project for course management using Maven. Create a Maven project with the following details:</p>
<table border="1" class="calibre49">
<tbody class="calibre50">
<tr class="calibre51">
<td class="calibre52">
<p class="calibre3"><strong class="calibre5">Fields</strong></p>
</td>
<td class="calibre52">
<p class="calibre3"><strong class="calibre5">Values</strong></p>
</td>
</tr>
<tr class="calibre51">
<td class="calibre52">
<p class="calibre3"><span class="calibre12">Group ID</span></p>
</td>
<td class="calibre52">
<p class="calibre3"><span class="calibre12">packt.book.jee.eclipse.ch7.maven</span></p>
</td>
</tr>
<tr class="calibre51">
<td class="calibre52">
<p class="calibre3"><span class="calibre12">Artifact ID</span></p>
</td>
<td class="calibre52">
<p class="calibre3"><span class="calibre12">CourseManagementMavenWebApp</span></p>
</td>
</tr>
<tr class="calibre51">
<td class="calibre52">
<p class="calibre3"><span class="calibre12">Version</span></p>
</td>
<td class="calibre52">
<p class="calibre3"><span class="calibre12">1</span></p>
</td>
</tr>
<tr class="calibre51">
<td class="calibre52">
<p class="calibre3"><span class="calibre12">Packaging</span></p>
</td>
<td class="calibre52">
<p class="calibre3"><span class="calibre12">war</span></p>
</td>
</tr>
</tbody>
</table>
<p class="calibre3"> </p>
<p class="calibre3">To create <kbd class="calibre13">web.xml</kbd> in this project, right-click on the project and select <span class="calibre12">Java EE<br class="calibre6"/>
Tools</span> | <span class="calibre12">Generate Deployment Descriptor Stub</span>. The <kbd class="calibre13">web.xml</kbd> file is created in the <kbd class="calibre13">src/main/webapp/WEB-INF</kbd> folder. Open <kbd class="calibre13">web.xml</kbd> and add the servlet definition and mapping for JSF (see the <em class="calibre21">Creating JSF and managed bean</em> section of this chapter). Add the dependency of the <kbd class="calibre13">CourseManagementMavenEJBClient</kbd> project and <kbd class="calibre13">javax</kbd>. <kbd class="calibre13">javaee-api</kbd> in <kbd class="calibre13">pom.xml</kbd> of the <kbd class="calibre13">CourseManagementMavenWebApp</kbd> project so that the web project has access to the EJB business interface declared in the shared project and also to EJB annotations.</p>
<p class="calibre3">Let's now create a <kbd class="calibre13">CourseJSFBean</kbd> class in the web project as described in the <em class="calibre21">Creating JSF and managed bean</em> section. Note that this will reference the remote interface of the EJB in the managed bean, as follows:</p>
<pre class="calibre25">@ManagedBean(name="Course") 
public class CourseJSFBean { 
  @EJB 
  CourseBeanRemote courseBean; 
 
  public List&lt;CourseDTO&gt; getCourses() { 
    return courseBean.getCourses(); 
  } 
} </pre>
<p class="calibre3">Create <kbd class="calibre13">course.xhtml</kbd> in the <kbd class="calibre13">webapp</kbd> folder as described in the <em class="calibre21">Creating JSF and managed bean</em> section.</p>
<p class="calibre3">Let's now create a <kbd class="calibre13">CourseManagementMavenEAR</kbd> project with the following details:</p>
<table border="1" class="calibre49">
<tbody class="calibre50">
<tr class="calibre51">
<td class="calibre52">
<p class="calibre3"><strong class="calibre5">Fields</strong></p>
</td>
<td class="calibre52">
<p class="calibre3"><strong class="calibre5">Values</strong></p>
</td>
</tr>
<tr class="calibre51">
<td class="calibre52">
<p class="calibre3"><span class="calibre12">Group ID</span></p>
</td>
<td class="calibre52">
<p class="calibre3"><span class="calibre12">packt.book.jee.eclipse.ch7.maven</span></p>
</td>
</tr>
<tr class="calibre51">
<td class="calibre52">
<p class="calibre3"><span class="calibre12">Artifact ID</span></p>
</td>
<td class="calibre52">
<p class="calibre3"><span class="calibre12">CourseManagementMavenEAR</span></p>
</td>
</tr>
<tr class="calibre51">
<td class="calibre52">
<p class="calibre3"><span class="calibre12">Version</span></p>
</td>
<td class="calibre52">
<p class="calibre3"><span class="calibre12">1</span></p>
</td>
</tr>
<tr class="calibre51">
<td class="calibre52">
<p class="calibre3"><span class="calibre12">Packaging</span></p>
</td>
<td class="calibre52">
<p class="calibre3"><span class="calibre12">ear</span></p>
</td>
</tr>
</tbody>
</table>
<div class="title-page-name"/>
<div class="title-page-name"> </div>
<p class="calibre3">You will have to type <kbd class="calibre13">ear</kbd> in the <span class="calibre12">Packaging file</span>; there is no <kbd class="calibre13">ear</kbd> option in the drop-down list. Add dependencies of <kbd class="calibre13">web</kbd>, <kbd class="calibre13">ejb</kbd>, and client projects to <kbd class="calibre13">pom.xml</kbd>, as follows:</p>
<pre class="calibre25">  &lt;dependencies&gt; 
    &lt;dependency&gt; 
      &lt;groupId&gt;packt.book.jee.eclipse.ch7.maven&lt;/groupId&gt; 
      &lt;artifactId&gt;CourseManagementMavenEJBClient&lt;/artifactId&gt; 
      &lt;version&gt;1&lt;/version&gt; 
    &lt;type&gt;jar&lt;/type&gt; 
    &lt;/dependency&gt; 
    &lt;dependency&gt; 
      &lt;groupId&gt;packt.book.jee.eclipse.ch7.maven&lt;/groupId&gt; 
      &lt;artifactId&gt;CourseManagementMavenEJBs&lt;/artifactId&gt; 
      &lt;version&gt;1&lt;/version&gt; 
      &lt;type&gt;ejb&lt;/type&gt; 
    &lt;/dependency&gt; 
    &lt;dependency&gt; 
      &lt;groupId&gt;packt.book.jee.eclipse.ch7.maven&lt;/groupId&gt; 
      &lt;artifactId&gt;CourseManagementMavenWebApp&lt;/artifactId&gt; 
      &lt;version&gt;1&lt;/version&gt; 
      &lt;type&gt;war&lt;/type&gt; 
    &lt;/dependency&gt; 
  &lt;/dependencies&gt; </pre>
<p class="calibre3">Make sure to set <kbd class="calibre13">&lt;type&gt;</kbd> of each dependency properly. You also need to update JNDI URLs for any name changes.</p>
<p class="calibre3">Maven does not have built-in support to package EAR. However, there is a Maven plugin for EAR. You can find details of this plugin at <a href="https://maven.apache.org/plugins/maven-ear-plugin/" class="calibre9"><span>https://maven.apache.org/plugins/maven-ear-plugin/</span></a> and <a href="https://maven.apache.org/plugins/maven-ear-plugin/modules.html" class="calibre9"><span>https://maven.apache.org/plugins/maven-ear-plugin/modules.html</span></a>. We need to add this plugin to our <kbd class="calibre13">pom.xml</kbd> and configure its parameters. Our EAR file will contain the JAR for the EJB project, the client project, and the WAR for the web project. Right-click on <kbd class="calibre13">pom.xml</kbd> of the EAR project, and select <span class="calibre12">Maven</span> | <span class="calibre12">Add Plugin</span>. Type <kbd class="calibre13">ear</kbd> in the <span class="calibre12">Filter</span> box, and select the latest plugin version under <span class="calibre12">maven-ear-plugin</span>. Make sure that you also install the <span class="calibre12">maven-acr-plugin</span> plugin. Configure the EAR plugin in the <kbd class="calibre13">pom.xml</kbd> details, as follows:</p>
<pre class="calibre25">&lt;build&gt; 
  &lt;plugins&gt; 
    &lt;plugin&gt; 
       &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; 
       &lt;artifactId&gt;maven-acr-plugin&lt;/artifactId&gt; 
       &lt;version&gt;1.0&lt;/version&gt; 
       &lt;extensions&gt;true&lt;/extensions&gt; 
    &lt;/plugin&gt; 
 
    &lt;plugin&gt; 
      &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; 
      &lt;artifactId&gt;maven-ear-plugin&lt;/artifactId&gt; 
      &lt;version&gt;2.10&lt;/version&gt; 
      &lt;configuration&gt; 
         &lt;version&gt;6&lt;/version&gt; 
      &lt;defaultLibBundleDir&gt;lib&lt;/defaultLibBundleDir&gt; 
      &lt;modules&gt; 
      &lt;webModule&gt; 
      &lt;groupId&gt;packt.book.jee.eclipse.ch7.maven&lt;/groupId&gt; 
      &lt;artifactId&gt;CourseManagementMavenWebApp&lt;/artifactId&gt; 
      &lt;/webModule&gt; 
      &lt;ejbModule&gt; 
      &lt;groupId&gt;packt.book.jee.eclipse.ch7.maven&lt;/groupId&gt; 
      &lt;artifactId&gt;CourseManagementMavenEJBs&lt;/artifactId&gt; 
      &lt;/ejbModule&gt; 
      &lt; jarModule &gt; 
      &lt;groupId&gt;packt.book.jee.eclipse.ch7.maven&lt;/groupId&gt; 
      &lt;artifactId&gt;CourseManagementMavenEJBClient&lt;/artifactId&gt; 
      &lt;/ jarModule &gt; 
      &lt;/modules&gt; 
      &lt;/configuration&gt; 
    &lt;/plugin&gt; 
    &lt;/plugins&gt; 
  &lt;/build&gt; </pre>
<p class="calibre3">After modifying <kbd class="calibre13">pom.xml</kbd>, sometimes Eclipse may display the following error:</p>
<pre class="calibre25">Project configuration is not up-to-date with pom.xml. Run Maven-&gt;Update Project or use Quick Fix... </pre>
<p class="calibre3">In such cases, right-click on the project and select <span class="calibre12">Maven</span> | <span class="calibre12">Update </span><span class="calibre12">Project</span>.</p>
<p class="calibre3">The last project that we create in this section is <kbd class="calibre13">CourseManagement</kbd>, which will be the container project for all other EJB projects. When this project is installed, it should build and install all the contained projects. Create a Maven project with the following details:</p>
<table border="1" class="calibre49">
<tbody class="calibre50">
<tr class="calibre51">
<td class="calibre52">
<p class="calibre3"><strong class="calibre5">Fields</strong></p>
</td>
<td class="calibre52">
<p class="calibre3"><strong class="calibre5">Values</strong></p>
</td>
</tr>
<tr class="calibre51">
<td class="calibre52">
<p class="calibre3"><span class="calibre12">Group ID</span></p>
</td>
<td class="calibre52">
<p class="calibre3"><span class="calibre12">packt.book.jee.eclipse.ch7.maven</span></p>
</td>
</tr>
<tr class="calibre51">
<td class="calibre52">
<p class="calibre3"><span class="calibre12">Artifact ID</span></p>
</td>
<td class="calibre52">
<p class="calibre3"><span class="calibre12">CourseManagement</span></p>
</td>
</tr>
<tr class="calibre51">
<td class="calibre52">
<p class="calibre3"><span class="calibre12">Version</span></p>
</td>
<td class="calibre52">
<p class="calibre3"><span class="calibre12">1</span></p>
</td>
</tr>
<tr class="calibre51">
<td class="calibre52">
<p class="calibre3"><span class="calibre12">Packaging</span></p>
</td>
<td class="calibre52">
<p class="calibre3"><span class="calibre12">Pom</span></p>
</td>
</tr>
</tbody>
</table>
<div class="title-page-name"/>
<p class="calibre3"> </p>
<p class="calibre3">Open <kbd class="calibre13">pom.xml</kbd> and click on the <span class="calibre12">Overview</span> tab. Expand the <span class="calibre12">Modules</span> group, and add all the other projects as modules. The following modules should be listed in <kbd class="calibre13">pom.xml</kbd>:</p>
<pre class="calibre25">  &lt;modules&gt; 
    &lt;module&gt;../CourseManagementMavenEAR&lt;/module&gt; 
    &lt;module&gt;../CourseManagementMavenEJBClient&lt;/module&gt; 
    &lt;module&gt;../CourseManagementMavenEJBs&lt;/module&gt; 
    &lt;module&gt;../CourseManagementMavenWebApp&lt;/module&gt; 
  &lt;/modules&gt; </pre>
<p class="calibre3">Right-click on the <kbd class="calibre13">CourseManagement</kbd> project and select <span class="calibre12">Run As</span> | <span class="calibre12">Maven Install</span>. This builds all EJB projects, and an EAR file is created in the target folder of the <kbd class="calibre13">CourseManagementMavenEAR</kbd> project. You can deploy this EAR in GlassFish from its management console, or you can right-click on the configured GlassFish Server in the <span class="calibre12">Servers</span> view of Eclipse, select the <span class="calibre12">Add and Remove...</span> option, and deploy the EAR project from within Eclipse. Browse to <kbd class="calibre13">http://localhost:8080/CourseManagementMavenWebApp/course.xhtml</kbd> to see the list of courses displayed by the <kbd class="calibre13">course.xhtml</kbd> JSF page.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            <article>
                
<p class="calibre3">EJBs are ideal for writing business logic in web applications. They can act as the perfect bridge between web interface components such as JSF, servlet, or JSP and data access objects such as JDO. EJBs can be distributed across multiple JEE application servers (this could improve application scalability), and their life cycle is managed by the container. EJBs can be easily injected into managed objects or can be looked up using JNDI.</p>
<p class="calibre3">Eclipse JEE makes creating and consuming EJBs very easy. Just like we saw how Tomcat can be configured and managed within Eclipse, JEE application servers, such as GlassFish, can also be managed from within Eclipse.</p>
<p class="calibre3">In the next chapter, we will learn how to create web applications using Spring MVC. Although Spring is not part of JEE, it is a popular framework to implement the MVC pattern in JEE web applications. Spring can also work with many of the JEE specifications.</p>


            </article>

            
        </section>
    </body></html>