- en: Chapter 4. Configuring Cucumber
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章 配置 Cucumber
- en: 'In this chapter, we will look at the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨以下食谱：
- en: Integrating Cucumber with JUnit
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 Cucumber 与 JUnit 集成
- en: Overriding the Cucumber Options
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 覆盖 Cucumber 选项
- en: Running Strict and Running Dry
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行严格和运行干燥
- en: Configuring the Cucumber Console output
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置 Cucumber 控制台输出
- en: Directing the Cucumber output to a file
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 Cucumber 输出定向到文件
- en: Configuring the naming conventions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置命名约定
- en: Introduction
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: When we talk about using Cucumber for behavior-driven development, we often
    talk about Feature files, Scenarios, Background, and Glue Code (Step Definitions).
    There isn't an iota of doubt that you won't be able to implement Cucumber until
    you understand the concepts mentioned earlier, but an area that is really important
    and is very useful in day-to-day Cucumber life is configuring Cucumber.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论使用 Cucumber 进行行为驱动开发时，我们经常谈论 Feature 文件、场景、背景和粘合代码（Step Definitions）。毫无疑问，在你理解前面提到的概念之前，你将无法实现
    Cucumber，但一个真正重要且在日常 Cucumber 生活中非常有用的领域是配置 Cucumber。
- en: In this chapter, we will start with integrating Cucumber with JUnit and then
    start understanding the different configurations that we can do with `@CucumberOptions`
    annotation.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将从将 Cucumber 与 JUnit 集成开始，然后开始了解我们可以使用 `@CucumberOptions` 注解进行的不同配置。
- en: Integrating Cucumber with JUnit
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 Cucumber 与 JUnit 集成
- en: Until now, we have run Cucumber tests either from Eclipse or from a Terminal,
    but how can we use automation frameworks to work with Cucumber?
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已从 Eclipse 或终端运行 Cucumber 测试，但如何使用自动化框架与 Cucumber 一起工作？
- en: How do we integrate Cucumber with JUnit Framework? Let's take a look at this
    in the next section.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何将 Cucumber 与 JUnit 框架集成？让我们在下一节中看看。
- en: How to do it…
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'We need to create a Java class in the `CucumberOptions` package with an empty
    body and the `@RunWith` annotation. This is how the class should look like:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在 `CucumberOptions` 包中创建一个具有空体和 `@RunWith` 注解的 Java 类。这个类应该看起来像这样：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: How it works…
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Cucumber ships with a JUnit runner, `Cucumber.api.junit.Cucumber`. This class
    tells JUnit to invoke `Cucumber JUnit runner`. It will search for Feature files
    and run them, providing the output back to JUnit in a format that it understands.
    Executing this class as any JUnit test class will run all the Features found on
    the classpath in the same package as this class.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Cucumber 随带一个 JUnit 运行器，`Cucumber.api.junit.Cucumber` 类。这个类告诉 JUnit 调用 `Cucumber
    JUnit 运行器`。它将搜索 Feature 文件并运行它们，以 JUnit 理解的格式将输出返回给 JUnit。将此类作为任何 JUnit 测试类执行将运行与该类同一包中的所有
    Feature。
- en: Note
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The name of the `JUnit` class is irrelevant and the class should be empty.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`JUnit` 类的名称无关紧要，并且该类应该是空的。'
- en: Overriding the Cucumber Options
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 覆盖 Cucumber 选项
- en: Sometimes, depending on the requirements, we would like to override default
    Cucumber behavior, such as reporting or the project structure, and so on. We can
    configure Cucumber via the Terminal, but mostly we run Cucumber with JUnit. So
    how do we configure Cucumber with JUnit Runners, let's see this in our next section.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，根据需求，我们可能希望覆盖默认的 Cucumber 行为，例如报告或项目结构等。我们可以通过终端配置 Cucumber，但大多数情况下我们使用 JUnit
    运行 Cucumber。那么我们如何配置 Cucumber 与 JUnit 运行器，让我们在下一节中看看。
- en: How to do it…
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Add `@CucumberOptions` to the `RunCuckeTest.java` class and import `Cucumber.api.CucumberOptions`.
    This is how the updated code for `RunCukeTest.java` should look like:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `@CucumberOptions` 添加到 `RunCuckeTest.java` 类中，并导入 `Cucumber.api.CucumberOptions`。`RunCukeTest.java`
    的更新代码应该看起来像这样：
- en: '[PRE1]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, let''s specify configurations where our Feature files and Step Definitions
    are located and which Tags are used. This is how the code for `RunCukeTest.java`
    should look like:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们指定我们的 Feature 文件和 Step Definitions 所在的配置文件以及使用的 Tags。这是 `RunCukeTest.java`
    代码应该看起来像这样：
- en: '[PRE2]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Refer to the screenshot for more clarity:'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 参考截图以获得更多清晰度：
- en: '![How to do it…](img/image00146.jpeg)'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何做…](img/image00146.jpeg)'
- en: How it works…
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The `@CucumberOptions` annotation provides the same options as the Cucumber
    Terminal line. For example, we can specify the path to Feature files and to Step
    Definitions.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`@CucumberOptions` 注解提供了与 Cucumber 终端行相同的选项。例如，我们可以指定 Feature 文件和 Step Definitions
    的路径。'
- en: 'The different options that are available are as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 可用的不同选项如下：
- en: '| Element | Purpose | Default |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| 元素 | 目的 | 默认 |'
- en: '| --- | --- | --- |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `dryRun` | true (skips the execution of Glue Code) | FALSE |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| `dryRun` | true（跳过粘合代码的执行） | FALSE |'
- en: '| `strict` | true (will fail execution if there are undefined or pending steps)
    | FALSE |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| `strict` | true（如果有未定义或挂起的步骤，将失败执行） | FALSE |'
- en: '| `Features` | These are the paths to the Feature(s) | {} |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| `Features` | 这些是 Feature 文件的路径 | {} |'
- en: '| `glue` | This declares where to look for Glue Code (Stepdefs and hooks) |
    {} |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| `glue` | 这表示在哪里查找粘合代码（步骤定义和钩子） | {} |'
- en: '| `Tags` | This is which Tags in the Features should be executed | {} |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| `Tags` | 这表示 Features 中哪些标签应该执行 | {} |'
- en: '| `monochrome` | This is whether or not to use monochrome output | FALSE |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| `monochrome` | 这表示是否使用单色输出 | FALSE |'
- en: '| `plugin` | This declares what formatter(s) to use and also miscellaneous
    options | {} |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| `plugin` | 这表示声明使用哪些格式化程序（s）以及一些其他选项 | {} |'
- en: 'Let''s understand the options we have used in this recipe:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解在这个配方中我们使用的选项：
- en: '**Features**: This option is used to specify the path to the Feature files.
    When Cucumber starts execution, it looks for the `.Feature` files at the path/folder
    mentioned in the **FEATURE** option. Whichever files are with the `.Feature` extension
    at the path mentioned in the **FEATURE** option, are executed.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Features**: 此选项用于指定 Feature 文件的路径。当 Cucumber 开始执行时，它会查找在 **FEATURE** 选项中提到的路径/文件夹中的
    `.Feature` 文件。在 **FEATURE** 选项中提到的路径中，具有 `.Feature` 扩展名的任何文件都将被执行。'
- en: '**Glue**: The **GLUE** option is to specify where the Step Definitions and
    Glue Code are present. Whenever Cucumber encounters a Step, the Cucumber looks
    for a Step Definition inside all the files present in the folder mentioned in
    the **GLUE** option. This also holds true for Hooks.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Glue**: **GLUE** 选项用于指定步骤定义和粘合代码的位置。每当 Cucumber 遇到步骤时，Cucumber 都会在 **GLUE**
    选项中提到的文件夹中所有文件内寻找步骤定义。这也适用于钩子。'
- en: '**Tags**: This option helps you decide which Tags in the Features should be
    executed or, for that matter, which Tags should not be executed. For example,
    in our code, whichever Scenario will be Tagged with `@sanity` will be executed
    and whichever is Tagged with `@wip` will not be executed because of `~` mentioned
    before the `@wip` Tag. `~` in front of any Tag tells Cucumber to skip the Scenarios/Features
    tagged with that Tag.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Tags**: 此选项帮助您决定在 Features 中哪些标签应该执行，或者换句话说，哪些标签不应该执行。例如，在我们的代码中，任何被标记为 `@sanity`
    的场景都将被执行，而任何被标记为 `@wip` 的场景将不会被执行，因为 `@wip` 标签之前有 `~`。任何标签前的 `~` 都告诉 Cucumber
    跳过带有该标签的场景/Feature。'
- en: Note
  id: totrans-46
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Options that accept multiple values do so in the form of a list. In the preceding
    table, those Options have been `{}` marked in the Default column.
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 接受多个值的选项以列表的形式接受。在先前的表中，这些选项在默认列中已被标记为 `{}`。
- en: Running Strict and Running Dry
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行严格和运行干燥
- en: When a Cucumber project becomes big, it becomes very important that we keep
    the integrity of the system intact. It should not happen that the addition/modification
    of Scenarios is breaking the system. So, how to quickly check whether all the
    Steps have an associated Step Definition defined (without executing the code in
    those Step Definitions)? Let's understand that in our upcoming section.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Cucumber 项目变得很大时，保持系统完整性变得非常重要。不应该发生添加/修改场景会破坏系统的情况。那么，如何快速检查所有步骤是否都有相关的步骤定义（而不执行这些步骤定义中的代码）？让我们在接下来的部分中了解这一点。
- en: How to do it…
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: Add the `dryRun` option to `@CucumberOptions` and set its value to `true`.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `dryRun` 选项添加到 `@CucumberOptions` 并将其值设置为 `true`。
- en: Add the `strict` option to `@CucumberOptions` and set its value to `false`.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `strict` 选项添加到 `@CucumberOptions` 并将其值设置为 `false`。
- en: Add the `monochrome` option to `@CucumberOptions` and set its value to `true`.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `monochrome` 选项添加到 `@CucumberOptions` 并将其值设置为 `true`。
- en: 'This is how our `RunCukeTest.Java` class should look like:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们的 `RunCukeTest.Java` 类应该看起来像：
- en: '[PRE3]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: How it works…
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: 'Let''s understand `dryRun`, and `chrome`:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解 `dryRun` 和 `chrome`：
- en: '**dryRun**: If the `dryRun` option is set to `true`, Cucumber only checks if
    all the Steps have their corresponding Step Definitions defined and the code mentioned
    in the Step Definitions is not executed and vice versa.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**dryRun**: 如果将 `dryRun` 选项设置为 `true`，Cucumber 只会检查所有步骤是否都有相应的步骤定义，并且步骤定义中提到的代码不会执行，反之亦然。'
- en: This is used to validate whether we have defined a Step Definition for each
    Step or not. Consider if someone has added new Scenarios to the project and wants
    to check whether he has missed any Step Definitions. He assigns `true` to the
    `dryRun` option and runs all Scenarios. Cucumber checks for matching Step Definitions
    for all Scenarios, without executing the code between Step Definitions, and returns
    the result. This technique saves a lot of time as compared to Cucumber executing
    the code in Step Definitions.
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这用于验证我们是否为每个步骤定义了步骤定义。考虑如果有人向项目中添加了新的场景，并希望检查他是否遗漏了任何步骤定义。他将`dryRun`选项设置为`true`并运行所有场景。Cucumber会检查所有场景的匹配步骤定义，而不执行步骤定义之间的代码，并返回结果。与Cucumber在步骤定义中执行代码相比，这种技术可以节省大量时间。
- en: '**strict**: If the `strict` option is set to `false`, and at execution time
    if Cucumber encounters any undefined/pending Steps, then Cucumber does not fail
    the execution and undefined Steps are skipped, and the build is successful. This
    is what the Console output looks like:![How it works…](img/image00147.jpeg)'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**严格模式**: 如果将`strict`选项设置为`false`，并且在执行时Cucumber遇到任何未定义/挂起的步骤，那么Cucumber不会使执行失败，并且会跳过未定义的步骤，构建成功。控制台输出如下所示：![如何工作…](img/image00147.jpeg)'
- en: 'If Option is set to `true`, and at execution time, if Cucumber encounters any
    Undefined/Pending Steps, then Cucumber fails the execution and undefined Steps
    are marked as failure. This is what the Console output looks like:'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果选项设置为`true`，并且在执行时，如果Cucumber遇到任何未定义/挂起的步骤，那么Cucumber将使执行失败，并将未定义的步骤标记为失败。控制台输出如下所示：
- en: '![How it works…](img/image00148.jpeg)'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何工作…](img/image00148.jpeg)'
- en: '**Monochrome**: If the `monochrome` option is set to `false`, then the console
    output is not as readable as it should be. The output when the `monochrome` option
    is set to `false` is shown in the following screenshot:![How it works…](img/image00149.jpeg)'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单色模式**: 如果将`monochrome`选项设置为`false`，那么控制台输出将不如预期那样易于阅读。当`monochrome`选项设置为`false`时的输出如下所示：![如何工作…](img/image00149.jpeg)'
- en: 'The output when the `monochrome` option is set to `true` is shown in the following
    screenshot:'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当将`monochrome`选项设置为`true`时，输出如下所示：
- en: '![How it works…](img/image00150.jpeg)'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何工作…](img/image00150.jpeg)'
- en: Configuring the Cucumber Console output
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置Cucumber控制台输出
- en: When we execute Cucumber Scenarios, it generates an output to the terminal or
    the eclipse console. There is a default behavior associated with that output and
    we can also configure that output as per our needs also. So how do we modify the
    default behavior, let's see this in the next section.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们执行Cucumber场景时，它会在终端或Eclipse控制台中生成输出。该输出有一个默认行为，我们也可以根据需要配置该输出。那么我们如何修改默认行为呢？让我们在下一节中看看。
- en: How to do it…
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Add the `plugin` option to `@CucumberOptions` and set its value to `{"progress"}`.
    This is how the `@CucumberOptions` code looks like:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`plugin`选项添加到`@CucumberOptions`中，并将其值设置为`{"progress"}`。这是`@CucumberOptions`代码的示例：
- en: '[PRE4]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: If we run the Scenarios now via the Terminal, this is what our output looks
    like:![How to do it…](img/image00151.jpeg)
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们现在通过终端运行场景，我们的输出将如下所示：![如何操作…](img/image00151.jpeg)
- en: 'Instead of the `progress` plugin, we can also use the `pretty` plugin, which
    is more verbose as compared to the `progress` plugin. This is what the code looks
    like:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与`progress`插件相比，我们也可以使用`pretty`插件，它的输出比`progress`插件更详细。代码如下所示：
- en: '[PRE5]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This is what the output looks like:![How to do it…](img/image00152.jpeg)
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输出如下所示：![如何操作…](img/image00152.jpeg)
- en: 'If we are more concerned about the time taken by each Step Definition, then
    we should use the `usage` plugin. This is what the `@CucumberOptions` code looks
    like:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们更关注每个步骤定义所花费的时间，那么我们应该使用`usage`插件。这是`@CucumberOptions`代码的示例：
- en: '[PRE6]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This is what the output looks like:![How to do it…](img/image00153.jpeg)
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输出将如下所示：![如何操作…](img/image00153.jpeg)
- en: 'If you are expecting some Scenarios to fail, and want to re-run the failed
    Scenarios, only then use the `Rerun` plugin. This is what the code for `@CucumberOptions`
    looks like:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你期望某些场景会失败，并且想要重新运行失败的场景，那么只有在这种情况下才使用`Rerun`插件。这是`@CucumberOptions`代码的示例：
- en: '[PRE7]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This is what the output looks like:![How to do it…](img/image00154.jpeg)
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输出如下所示：![如何操作…](img/image00154.jpeg)
- en: How it works…
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理
- en: 'Let''s understand the different plugins used in the preceding Steps:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解在前面的步骤中使用到的不同插件：
- en: '**progress**: This is Cucumber''s default plugin and produces one character
    per Step. Each character represents the status of each Step:'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**进度**：这是 Cucumber 的默认插件，每个步骤产生一个字符。每个字符代表每个步骤的状态：'
- en: '`.` means passing'
  id: totrans-84
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.` 表示通过'
- en: '`U` means undefined'
  id: totrans-85
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`U` 表示未定义'
- en: '`-` means skipped (or a Scenario Outline Step)'
  id: totrans-86
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-` 表示跳过（或场景概述步骤）'
- en: '`F` means failing'
  id: totrans-87
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`F` 表示失败'
- en: '**pretty**: This is a more verbose plugin with information such as which Step
    matched which Step Definition, arguments and the location of Steps, and so on.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**pretty**：这是一个更详细的插件，包含有关哪个步骤匹配哪个步骤定义、参数和步骤位置等信息。'
- en: '**usage**: This sorts the Step Definitions by their average execution time.
    The output from the `usage` plugin is useful for quickly finding slow parts in
    your code but it is also a great way to get an overview of your Step Definitions.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用法**：这将按平均执行时间对步骤定义进行排序。`用法` 插件的输出对于快速找到代码中的慢速部分非常有用，同时也是获取步骤定义概览的好方法。'
- en: '**rerun**: This plugin outputs the location of failing Scenarios so that these
    can be directly used in the next execution. If all the Scenarios are passing,
    then the `rerun` plugin does not produce anything.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**重试**：此插件输出失败的场景位置，以便可以直接用于下一次执行。如果所有场景都通过，则 `重试` 插件不会产生任何内容。'
- en: Directing the Cucumber output to a file
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 Cucumber 输出定向到文件
- en: Cucumber integrates business logic with code, so our focus is on business rather
    than code. The same philosophy is also followed in the Cucumber reports. Cucumber
    reports are more about business utility rather than to do with more charts.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Cucumber 将业务逻辑与代码集成，因此我们的重点是业务而不是代码。相同的理念也体现在 Cucumber 报告中。Cucumber 报告更多地关注业务实用性，而不是与更多图表相关。
- en: Robust automation frameworks generate very good and detailed reports, which
    can be shared with all stake holders. There are multiple options available for
    reports which can be used depending on the requirement. Let's check out how to
    use reports extensively in our next section.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 强大的自动化框架生成非常好的详细报告，可以与所有利益相关者共享。根据需求有多种报告选项可供使用。让我们在下一节中查看如何广泛使用报告。
- en: How to do it…
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'For HTML reports, add `html:target/Cucumber` to the `@CucumberOptions` plugin
    option. This is what the code for `@CucumberOptions` looks like:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于 HTML 报告，请在 `@CucumberOptions` 插件选项中添加 `html:target/Cucumber`。以下是 `@CucumberOptions`
    代码的示例：
- en: '[PRE8]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'For JSON reports, add `json:target_json/Cucumber.json` to the `@CucumberOptions`
    plugin option. This is what the code for `@CucumberOptions` looks like:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于 JSON 报告，请在 `@CucumberOptions` 插件选项中添加 `json:target_json/Cucumber.json`。以下是
    `@CucumberOptions` 代码的示例：
- en: '[PRE9]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'For JUnit reports, add `junit:target_json/Cucumber_junit.xml` to the `@CucumberOptions`
    plugin option. This is what the code for `@CucumberOptions` looks like:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于 JUnit 报告，请在 `@CucumberOptions` 插件选项中添加 `junit:target_json/Cucumber_junit.xml`。以下是
    `@CucumberOptions` 代码的示例：
- en: '[PRE10]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: How it works…
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何工作…
- en: 'By default, the plugin''s output is redirected to `STDOUT` and if we want to
    store that output to a file format, we need to redirect the output to that file.
    The syntax is as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，插件输出被重定向到 `STDOUT`，如果我们想将输出存储到文件格式，我们需要将输出重定向到该文件。语法如下：
- en: '[PRE11]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Let''s understand each output in detail:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细了解每个输出：
- en: '**HTML**: This will generate an HTML report at the location mentioned in the
    formatter itself. This is what the HTML file looks like:![How it works…](img/image00155.jpeg)'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**HTML**：这将生成一个位于格式化器本身提到的位置的 HTML 报告。以下是 HTML 文件的外观：![如何工作…](img/image00155.jpeg)'
- en: '**JSON**: This report contains all the information from the gherkin source
    in the JSON format. This report is meant to be postprocessed into another visual
    format by third-party tools, such as Cucumber Jenkins. This is what JSON reports
    look like:![How it works…](img/image00156.jpeg)'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JSON**：此报告包含来自 Gherkin 源的 JSON 格式的所有信息。此报告旨在通过第三方工具（如 Cucumber Jenkins）进行后处理，转换为另一种可视化格式。以下是
    JSON 报告的外观：![如何工作…](img/image00156.jpeg)'
- en: '**JUnit**: This report generates XML files just like Apache Ant''s `junitreport`
    task. This XML format is understood by most continuous integration servers, who
    will use it to generate visual reports. This is what JUnit reports look like:![How
    it works…](img/image00157.jpeg)'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JUnit**：此报告生成与 Apache Ant 的 `junitreport` 任务类似的 XML 文件。这种 XML 格式被大多数持续集成服务器理解，它们将使用它来生成可视化报告。以下是
    JUnit 报告的外观：![如何工作…](img/image00157.jpeg)'
- en: Configuring the naming conventions
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置命名约定
- en: As Cucumber can be implemented in multiple languages, developers with multiple
    language knowledge and background can work on the same project. So, sometimes
    it might be difficult for teams to manage the naming conventions, such as underscore
    or camel case.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Cucumber可以用多种语言实现，具有多种语言知识和背景的开发者可以在同一个项目上工作。因此，有时团队可能难以管理命名约定，例如下划线或驼峰命名法。
- en: Cucumber lets the team choose the naming convention. Depending on the naming
    convention, Cucumber generates the method names for Step Definitions. Let's see
    how it can be done in the next section.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Cucumber允许团队选择命名约定。根据命名约定，Cucumber为步骤定义生成方法名。让我们在下一节看看它是如何实现的。
- en: How to do it…
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'If you want to use camel case, then add the following code to `@CucumberOptions`:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您想使用驼峰命名法，那么请将以下代码添加到`@CucumberOptions`中：
- en: '[PRE12]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If you want to use underscore, then add the following code to `@CucumberOptions`.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您想使用下划线，那么请将以下代码添加到`@CucumberOptions`中。
- en: '[PRE13]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This is what the code for `RunCukeTest.Java` looks like:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这就是`RunCukeTest.Java`代码的样子：
- en: '[PRE14]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: How it works…
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何工作…
- en: 'Let''s understand the `Snippets` option in detail:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细了解一下`Snippets`选项：
- en: '**Snippets**: This option is typed, so you''ll need to use one of the constants
    provided, that is, `SnippetType.CAMELCASE` or `SnippetType.UNDERSCORE`. Remember
    to import `Cucumber.api.SnippetType`. The default option is underscore. The Step
    Definition suggestion if we chose camel case is shown as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '**片段**：此选项是键入的，因此您需要使用提供的其中一个常量，即`SnippetType.CAMELCASE`或`SnippetType.UNDERSCORE`。请记住导入`Cucumber.api.SnippetType`。默认选项是下划线。如果我们选择驼峰命名法，步骤定义的建议如下所示：'
- en: '![How it works…](img/image00158.jpeg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作…](img/image00158.jpeg)'
