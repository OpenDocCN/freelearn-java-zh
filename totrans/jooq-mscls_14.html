<html><head></head><body>
		<div id="_idContainer061">
			<h1 id="_idParaDest-210"><em class="italic"><a id="_idTextAnchor209"/>Chapter 11</em>: jOOQ Keys</h1>
			<p>Choosing the proper type of keys for our tables has a significant benefit on our queries. jOOQ sustains this statement by supporting a wide range of keys, from the well-known unique and primary keys to the fancy embedded and synthetic/surrogate keys. The most commonly used synthetic identifiers (or surrogate identifiers) are numerical or UUIDs. In comparison with natural keys, surrogate identifiers don't have a meaning or a correspondent in the real world. A surrogate identifier can be generated by a Numerical Sequence Generator (for instance, an identity or sequence) or by a Pseudorandom Number Generator (for instance, a GUID or UUID). Moreover, let me use this context to recall that in clustered environments, most relational databases rely on <em class="italic">numerical sequences</em> and different offsets per node to avoid the risk of conflicts. Use <em class="italic">numerical sequences</em> instead of UUIDs because they require less memory than UUIDs (a UUID requires 16 bytes, while <strong class="source-inline">BIGINT</strong> requires 8 bytes and <strong class="source-inline">INTEGER</strong> 4 bytes) and the index usage is more performant. Moreover, since UUIDs are not sequential, they introduce performance penalties at a clustered indexes level. More precisely, we will discuss an issue known as <em class="italic">index fragmentation</em>, which is caused by the fact that UUIDs are random. Some databases (for instance, MySQL 8.0) come with significant improvements in mitigating UUID performance penalties (there are three new functions – <strong class="source-inline">UUID_TO_BIN</strong>, <strong class="source-inline">BIN_TO_UUID</strong>, and <strong class="source-inline">IS_UUID</strong>) while other databases are still prone to these issues. As Rick James highlights, <em class="italic">"If you cannot avoid UUIDs (which would be my first recommendation) then..."</em> It is recommended to read his article (<a href="http://mysql.rjweb.org/doc.php/uuid">http://mysql.rjweb.org/doc.php/uuid</a>) for a deeper understanding of the main issues and potential solutions.</p>
			<p>For now, let's get back to our chapter, which will cover the following topics: </p>
			<ul>
				<li>Fetching a database-generated primary key</li>
				<li>Suppressing a primary key return on updatable records</li>
				<li>Updating a primary key of an updatable record</li>
				<li>Using database sequences</li>
				<li>Inserting a SQL Server IDENTITY</li>
				<li>Fetching the Oracle ROWID pseudo-column</li>
				<li>Comparing composite primary keys</li>
				<li>Working with embedded keys</li>
				<li>Working with jOOQ synthetic objects</li>
				<li>Overriding primary keys</li>
			</ul>
			<p>Let's get started!</p>
			<h1 id="_idParaDest-211"><a id="_idTextAnchor210"/>Technical requirements</h1>
			<p>The code for this chapter can be found on GitHub at <a href="https://github.com/PacktPublishing/jOOQ-Masterclass/tree/master/Chapter11">https://github.com/PacktPublishing/jOOQ-Masterclass/tree/master/Chapter11</a>.</p>
			<h1 id="_idParaDest-212"><a id="_idTextAnchor211"/>Fetching the database-generated primary key</h1>
			<p>A<a id="_idIndexMarker1107"/> typical scenario consists of fetching a database-generated (identity) primary key after an <strong class="source-inline">INSERT</strong> operation is executed via the <strong class="source-inline">insertInto()</strong>method or the updatable record's <strong class="source-inline">insert()</strong>method. If you are using <strong class="source-inline">insertInto()</strong> (<strong class="source-inline">DSL.insertInto()</strong> or <strong class="source-inline">DSLContext.insertInto()</strong>), the database-generated primary key can be obtained via the <strong class="source-inline">returningResult()</strong>/<strong class="source-inline">returning()</strong> methods. For instance, the identity primary key of <strong class="source-inline">SALE</strong> is shaped in MySQL via <strong class="source-inline">AUTO_INCREMENT</strong>, in SQL Server via <strong class="source-inline">IDENTITY</strong>, and for historic reasons (because both now support standard SQL <strong class="source-inline">IDENTITY</strong> columns), in PostgreSQL and Oracle via database sequences. In all these cases, the generated identity primary key of <strong class="source-inline">SALE</strong> can be fetched as here (<strong class="source-inline">SALE.SALE_ID</strong>):</p>
			<pre class="source-code">long insertedId = ctx.insertInto(SALE, SALE.FISCAL_YEAR, </pre>
			<pre class="source-code">    SALE.SALE_, SALE.EMPLOYEE_NUMBER, SALE.FISCAL_MONTH, </pre>
			<pre class="source-code">    SALE.REVENUE_GROWTH)</pre>
			<pre class="source-code"> .values(2004, 2311.42, 1370L, 1, 0.0)</pre>
			<pre class="source-code"> .returningResult(SALE.SALE_ID)</pre>
			<pre class="source-code"> .fetchOneInto(long.class);</pre>
			<pre class="source-code"> // .fetchOne(); to fetch Record1&lt;Long&gt;</pre>
			<p>Alternatively, a convenient approach relies on the <strong class="source-inline">getIdentity()</strong> method, as shown here:</p>
			<pre class="source-code">.returningResult(SALE.getIdentity().getField())</pre>
			<p>However, this approach is useful when your table has a single identity column; otherwise, it is better to explicitly list the identities that should be returned. However, don't get me wrong here – even if some databases (for example, PostgreSQL) support multiple identities, that is quite an unusual approach, which personally I don't like to use, but I'll cover it in this chapter. Also, check this tweet to get more details: <a href="https://twitter.com/lukaseder/status/1205046981833482240">https://twitter.com/lukaseder/status/1205046981833482240</a>.</p>
			<p>Now, the <strong class="source-inline">insertedId</strong> variable holds the database-generated primary key as a <strong class="source-inline">Record1&lt;Long&gt;</strong>. Getting the <strong class="source-inline">long</strong> value can be done via <strong class="source-inline">fetchOne().value1()</strong> or directly via <strong class="source-inline">.fetchOneInto(long.class)</strong>. The same<a id="_idIndexMarker1108"/> practice is apparent for a bulk insert (a multi-record insert). This time, the generated primary keys are stored in <strong class="source-inline">Result&lt;Record1&lt;Long&gt;&gt;</strong> or <strong class="source-inline">List&lt;Long&gt;</strong>:</p>
			<pre class="source-code">List&lt;Long&gt; insertedIds = ctx.insertInto(SALE, </pre>
			<pre class="source-code">    SALE.FISCAL_YEAR,SALE.SALE_, SALE.EMPLOYEE_NUMBER, </pre>
			<pre class="source-code">    SALE.FISCAL_MONTH, SALE.REVENUE_GROWTH)</pre>
			<pre class="source-code"> .values(2004, 2311.42, 1370L, 1, 0.0)</pre>
			<pre class="source-code"> .values(2003, 900.21, 1504L, 1, 0.0)</pre>
			<pre class="source-code"> .values(2005, 1232.2, 1166L, 1, 0.0)</pre>
			<pre class="source-code"> .returningResult(SALE.getIdentity().getField())</pre>
			<pre class="source-code"> // or, .returningResult(SALE.SALE_ID)</pre>
			<pre class="source-code"> .collect(intoList());</pre>
			<pre class="source-code"> // or, .fetchInto(Long.class);</pre>
			<p>For a special case when we cannot provide an identity, jOOQ allows us to use the handy <strong class="source-inline">lastID()</strong> method:</p>
			<pre class="source-code">ctx.insertInto(SALE, SALE.FISCAL_YEAR, SALE.SALE_, </pre>
			<pre class="source-code">               SALE.EMPLOYEE_NUMBER, SALE.FISCAL_MONTH, </pre>
			<pre class="source-code">               SALE.REVENUE_GROWTH)</pre>
			<pre class="source-code">   .values(2002, 5411.42, 1504L, 1, 0.0)</pre>
			<pre class="source-code">   .execute();</pre>
			<pre class="source-code">//meanwhile, a concurrent transaction can sneak a INSERT</pre>
			<pre class="source-code">var lastId = ctx.lastID();</pre>
			<p>However, the <strong class="source-inline">lastID()</strong> method has at least two shortcomings that deserve our attention. In a <a id="_idIndexMarker1109"/>concurrent transactional environment (for instance, a web application), there is no guarantee that the returned value belongs to the previous <strong class="source-inline">INSERT</strong> statement, since a concurrent transaction can sneak another <strong class="source-inline">INSERT</strong> between our <strong class="source-inline">INSERT</strong> and the <strong class="source-inline">lastID()</strong> call. In such a case, the returned value belongs to the <strong class="source-inline">INSERT</strong> statement executed by the concurrent transaction. In addition, <strong class="source-inline">lastID()</strong> is not quite useful in the case of bulk inserts, since it returns only the last-generated primary key (but maybe this is exactly what you need). </p>
			<p>If you are inserting an updatable record, jOOQ will automatically return the generated identity primary key and populate the updatable record field, as shown here:</p>
			<pre class="source-code">SaleRecord sr = ctx.newRecord(SALE);</pre>
			<pre class="source-code">sr.setFiscalYear(2021);</pre>
			<pre class="source-code">...</pre>
			<pre class="source-code">sr.insert();</pre>
			<pre class="source-code">// here you can call sr.getSaleId()</pre>
			<p>After insert, calling <strong class="source-inline">sr.getSaleId()</strong> returns the primary key generated by the database for this record. The same thing can be accomplished via jOOQ's DAO while inserting a POJO:</p>
			<pre class="source-code">private final SaleRepository saleRepository; // injected DAO</pre>
			<pre class="source-code">Sale s = new Sale(); // jooq.generated.tables.pojos.Sale</pre>
			<pre class="source-code">s.setFiscalYear(2020);</pre>
			<pre class="source-code">...</pre>
			<pre class="source-code">saleRepository.insert(s);</pre>
			<pre class="source-code">// here you can call s.getSaleId()</pre>
			<p>This time, jOOQ<a id="_idIndexMarker1110"/> set the generated primary key in the inserted POJO. You can find these examples in the <em class="italic">Keys</em> bundled code.</p>
			<h1 id="_idParaDest-213"><a id="_idTextAnchor212"/>Suppressing a primary key return on updatable records</h1>
			<p>In <a id="_idIndexMarker1111"/>the previous section, you saw that <a id="_idIndexMarker1112"/>jOOQ automatically fetches and sets the generated primary key for updatable records. Suppressing this action can be done via the <strong class="source-inline">withReturnIdentityOnUpdatableRecord()</strong> flag setting. In some dialects, a database round trip (the <strong class="source-inline">lastID()</strong> style) can be prevented, so this is mostly a performance feature. By default, this flag is <strong class="source-inline">true</strong>, but if we explicitly set it to <strong class="source-inline">false</strong>, then jOOQ will no longer attempt to fetch the generated primary key:</p>
			<pre class="source-code">DSLContext derivedCtx = ctx.configuration().derive(</pre>
			<pre class="source-code"> new Settings().withReturnIdentityOnUpdatableRecord(false))</pre>
			<pre class="source-code">               .dsl();</pre>
			<pre class="source-code"> SaleRecord sr = derivedCtx.newRecord(SALE);</pre>
			<pre class="source-code"> sr.setFiscalYear(2021);</pre>
			<pre class="source-code"> ...</pre>
			<pre class="source-code"> sr.insert();</pre>
			<p>This <a id="_idIndexMarker1113"/>time, calling<a id="_idIndexMarker1114"/> <strong class="source-inline">sr.getSaleId()</strong> returns <strong class="source-inline">null</strong>.</p>
			<h1 id="_idParaDest-214"><a id="_idTextAnchor213"/>Updating a primary key of an updatable record</h1>
			<p>As a <a id="_idIndexMarker1115"/>good practice, a primary key should <a id="_idIndexMarker1116"/>never be updated anyway. But, who am I to judge?!</p>
			<p>By default, calling the <strong class="source-inline">store()</strong> method after changing (to a non-null value) the primary key of an updatable record previously loaded via jOOQ causes an <strong class="source-inline">INSERT</strong> statement to be executed. However, we can force jOOQ to generate and execute an <strong class="source-inline">UPDATE</strong> of the primary key via the <strong class="source-inline">withUpdatablePrimaryKeys()</strong> flag setting:</p>
			<pre class="source-code">DSLContext derivedCtx = ctx.configuration().derive(</pre>
			<pre class="source-code">  new Settings().withUpdatablePrimaryKeys(true)).dsl();</pre>
			<pre class="source-code"> SaleRecord sr = derivedCtx.selectFrom(SALE)</pre>
			<pre class="source-code">    .where(SALE.SALE_ID.eq(2L))</pre>
			<pre class="source-code">    .fetchSingle();</pre>
			<pre class="source-code"> sr.setSaleId(new_primary_key);</pre>
			<pre class="source-code"> sr.store(); // UPDATE primary key</pre>
			<p>Of course, we <a id="_idIndexMarker1117"/>can also update the primary key via <a id="_idIndexMarker1118"/>an explicit <strong class="source-inline">UPDATE</strong>, and if you really have to do it, then go for this instead of a jOOQ flag:</p>
			<pre class="source-code">ctx.update(SALE)</pre>
			<pre class="source-code">   .set(SALE.SALE_ID, sr.getSaleId() + 1)</pre>
			<pre class="source-code">   .where(SALE.SALE_ID.eq(sr.getSaleId()))</pre>
			<pre class="source-code">   .execute();</pre>
			<p>You can find these examples in the <em class="italic">Keys</em> bundled code.</p>
			<h1 id="_idParaDest-215"><a id="_idTextAnchor214"/>Using database sequences</h1>
			<p>To yield <a id="_idIndexMarker1119"/>sequential numbers, databases such as PostgreSQL, SQL Server, and Oracle rely on sequences. A database sequence lives independently from tables – it can be associated with the primary key and non-primary key columns, it can be auto-generated (as in the case of PostgreSQL (<strong class="source-inline">BIG</strong>)<strong class="source-inline">SERIAL</strong>), it can be used across multiple tables, it can have independent permissions, it can have cycles, it can increment values in its own transactions to guarantee uniqueness across transactions using it, we can explicitly alter its values by setting minimum, maximum, increment, and current values, and so on. </p>
			<p>For instance, let's consider the following sequence (<strong class="source-inline">employee_seq</strong>), defined in our PostgreSQL schema for the <strong class="source-inline">employee.employee_number</strong> primary key:</p>
			<pre class="source-code">CREATE SEQUENCE "employee_seq" START 100000 INCREMENT 10 </pre>
			<pre class="source-code">       MINVALUE 100000 MAXVALUE 10000000 </pre>
			<pre class="source-code">       OWNED BY "employee"."employee_number";</pre>
			<pre class="source-code">CREATE TABLE "employee" (</pre>
			<pre class="source-code">  "employee_number" BIGINT NOT NULL,</pre>
			<pre class="source-code">  ...</pre>
			<pre class="source-code">);</pre>
			<p>The <strong class="source-inline">employee_seq</strong> sequence doesn't produce sequence values automatically on your insertions, so the application must explicitly manipulate it. On the other hand, the <strong class="source-inline">sale_seq</strong> sequence produces sequence values automatically on your insertions, and it looks like the following code block (you'll get an automatic value when the <strong class="source-inline">SALE_ID</strong> column is omitted from the <strong class="source-inline">INSERT</strong> statement or <strong class="source-inline">DEFAULT</strong> or <strong class="source-inline">DEFAULT VALUES</strong> is used; when users set <strong class="source-inline">SALE_ID</strong> to <strong class="source-inline">NULL</strong> explicitly, there's going to be a constraint violation error):</p>
			<pre class="source-code">CREATE SEQUENCE "sale_seq" START 1000000; </pre>
			<pre class="source-code">CREATE TABLE "sale" (</pre>
			<pre class="source-code">  "sale_id" BIGINT NOT NULL DEFAULT NEXTVAL ('"sale_seq"'),  </pre>
			<pre class="source-code">  ...</pre>
			<pre class="source-code">);</pre>
			<p>For each such sequence, the jOOQ Code Generator produces an <strong class="source-inline">org.jooq.Sequence</strong> instance in <strong class="source-inline">Sequences</strong> (take your time to check the <strong class="source-inline">jooq.generated.Sequences</strong> class). For <strong class="source-inline">employee_seq</strong>, we get this:</p>
			<pre class="source-code">public static final Sequence&lt;Long&gt; EMPLOYEE_SEQ = </pre>
			<pre class="source-code">  Internal.createSequence("employee_seq", Public.PUBLIC, </pre>
			<pre class="source-code">   SQLDataType.BIGINT.nullable(false), 100000, 10, 100000, </pre>
			<pre class="source-code">    10000000, false, null);</pre>
			<p>The jOOQ <a id="_idIndexMarker1120"/>API exposes several methods for obtaining information about a sequence. Among them, we have the following suggested methods (you can find out more in the jOOQ documentation):</p>
			<pre class="source-code">String name = EMPLOYEE_SEQ.getName();</pre>
			<pre class="source-code">Field&lt;Long&gt; start = EMPLOYEE_SEQ.getStartWith();</pre>
			<pre class="source-code">Field&lt;Long&gt; min = EMPLOYEE_SEQ.getMinvalue();</pre>
			<pre class="source-code">Field&lt;Long&gt; max = EMPLOYEE_SEQ.getMaxvalue();</pre>
			<pre class="source-code">Field&lt;Long&gt; inc = EMPLOYEE_SEQ.getIncrementBy();</pre>
			<p>Besides these methods, we have three more that are very useful in daily tasks –<strong class="source-inline">currval()</strong>, <strong class="source-inline">nextval()</strong>, and <strong class="source-inline">nextvals()</strong>. The first one (<strong class="source-inline">currval()</strong>) attempts to return the <em class="italic">current</em> value in the sequence. This can be obtained in a <strong class="source-inline">SELECT</strong> statement:</p>
			<pre class="source-code">long cr = ctx.fetchValue(EMPLOYEE_SEQ.currval());</pre>
			<pre class="source-code">long cr = ctx.select(EMPLOYEE_SEQ.currval())</pre>
			<pre class="source-code">  .fetchSingle().value1();</pre>
			<pre class="source-code">long cr = ctx.select(EMPLOYEE_SEQ.currval())</pre>
			<pre class="source-code">  .fetchSingleInto(Long.class); // or, fetchOneInto()</pre>
			<p>The second <a id="_idIndexMarker1121"/>one, <strong class="source-inline">nextval()</strong>, attempts to return the <em class="italic">next</em> value in the sequence. It can be used as follows:</p>
			<pre class="source-code">long nv = ctx.fetchValue(EMPLOYEE_SEQ.nextval());</pre>
			<pre class="source-code">long nv = ctx.select(EMPLOYEE_SEQ.nextval())</pre>
			<pre class="source-code">  .fetchSingle().value1();</pre>
			<pre class="source-code">long nv = ctx.select(EMPLOYEE_SEQ.nextval())</pre>
			<pre class="source-code">  .fetchSingleInto(Long.class); // or, fetchOneInto()</pre>
			<p>And here is a <strong class="source-inline">SELECT</strong> statement that fetches both, the current and the next value:</p>
			<pre class="source-code">Record2&lt;Long, Long&gt; vals = ctx.fetchSingle(</pre>
			<pre class="source-code">           EMPLOYEE_SEQ.nextval(), EMPLOYEE_SEQ.currval());</pre>
			<pre class="source-code">Record2&lt;Long, Long&gt; vals = ctx.select(EMPLOYEE_SEQ.nextval(), </pre>
			<pre class="source-code">           EMPLOYEE_SEQ.currval()) .fetchSingle();</pre>
			<p>A potential issue of using sequences consists of selecting <strong class="source-inline">currval()</strong> from the sequence before <em class="italic">initializing</em> it within your session by selecting <strong class="source-inline">nextval()</strong> for it. Commonly, when you are in such a scenario, you'll get an explicit error that mentions that <strong class="source-inline">currval()</strong> is not yet defined in this session (for instance, in Oracle, this is ORA-08002). By executing <strong class="source-inline">INSERT</strong> or calling <strong class="source-inline">nextval()</strong> (for instance, in <strong class="source-inline">SELECT</strong> as the previous one), you'll initialize <strong class="source-inline">currval()</strong> as well.</p>
			<p>If the sequence can produce values automatically then the best way to insert a new record is to simply omit the primary key field. Since <strong class="source-inline">sale_seq</strong> can produce values automatically, an <strong class="source-inline">INSERT</strong> can be like this:</p>
			<pre class="source-code">ctx.insertInto(SALE, SALE.FISCAL_YEAR, SALE.SALE_, </pre>
			<pre class="source-code">               SALE.EMPLOYEE_NUMBER, SALE.FISCAL_MONTH, </pre>
			<pre class="source-code">               SALE.REVENUE_GROWTH)</pre>
			<pre class="source-code">   .values(2005, 1370L, 1282.641, 1, 0.0)</pre>
			<pre class="source-code">   .execute();</pre>
			<p>The database <a id="_idIndexMarker1122"/>will use <strong class="source-inline">sale_seq</strong> to assign a value to the <strong class="source-inline">SALE_ID</strong> field (the primary key of <strong class="source-inline">SALE</strong>). This is like using any other type of identity associated with a primary key.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">There is no need to explicitly call the <strong class="source-inline">currval()</strong> or <strong class="source-inline">nextval()</strong> method as long as you don't have a specific case that requires a certain sequence value from a sequence that is auto-generated (for example, from (<strong class="source-inline">BIG</strong>)<strong class="source-inline">SERIAL</strong>) or set as default (for example, as <strong class="source-inline">NOT NULL DEFAULT NEXTVAL ("'sale_seq'")</strong>). Simply omit the primary key field (or whatever field uses the sequence) and let the database generate it.</p>
			<p>However, if the sequence cannot automatically produce values (for instance, <strong class="source-inline">employee_seq</strong>), then an <strong class="source-inline">INSERT</strong> statement must rely on an explicit call of the <strong class="source-inline">nextval()</strong> method:</p>
			<pre class="source-code">ctx.insertInto(EMPLOYEE, EMPLOYEE.EMPLOYEE_NUMBER,    </pre>
			<pre class="source-code">               EMPLOYEE.LAST_NAME, EMPLOYEE.FIRST_NAME, ...)</pre>
			<pre class="source-code">   .values(EMPLOYEE_SEQ.nextval(),</pre>
			<pre class="source-code">      val("Lionel"), val("Andre"), ...)</pre>
			<pre class="source-code">   .execute();</pre>
			<p>Pay attention to how you interpret and use the <strong class="source-inline">currval()</strong> and <strong class="source-inline">nextval()</strong> methods. Once you fetch a sequence value via <strong class="source-inline">nextval()</strong> (for instance, via <strong class="source-inline">SELECT</strong>), you can safely use it later in subsequent queries (<strong class="source-inline">INSERT</strong>) because the database will not give this value to other (concurrent) transactions. So, <strong class="source-inline">nextval()</strong> is safe to be used by multiple concurrent transactions. On the other hand, in the case of <strong class="source-inline">currval()</strong>, you have to be aware of some aspects. Check this code:</p>
			<pre class="source-code">ctx.insertInto(SALE, SALE.FISCAL_YEAR, SALE.SALE_,  </pre>
			<pre class="source-code">               SALE.EMPLOYEE_NUMBER, SALE.FISCAL_MONTH, </pre>
			<pre class="source-code">               SALE.REVENUE_GROWTH)</pre>
			<pre class="source-code">   .values(2020, 900.25, 1611L, 1, 0.0)</pre>
			<pre class="source-code">   .execute();</pre>
			<pre class="source-code">// another transaction can INSERT and currval() is modified</pre>
			<pre class="source-code">long cr = ctx.fetchValue(SALE_SEQ.currval());</pre>
			<p>So, between<a id="_idIndexMarker1123"/> the previous <strong class="source-inline">INSERT</strong> and <strong class="source-inline">SELECT</strong> of the current value, another transaction can execute <strong class="source-inline">INSERT</strong>, and <strong class="source-inline">currval()</strong> is modified/incremented (generally speaking, another transaction performs an action that updates the current value). This means that there is no guarantee that <strong class="source-inline">cr</strong> holds the value of <strong class="source-inline">SALE_ID</strong> of our <strong class="source-inline">INSERT</strong> (<strong class="source-inline">SALE_ID</strong> and <strong class="source-inline">cr</strong> can be different). If all we need is to get <strong class="source-inline">SALE_ID</strong> of our <strong class="source-inline">INSERT</strong>, then the best approach is to rely on <strong class="source-inline">returningResult(SALE.SALE_ID)</strong>, as you saw in the <em class="italic">Fetching a database-generated primary key</em> section.</p>
			<p>Obviously, attempting to use the fetched <strong class="source-inline">currval()</strong> in subsequent <strong class="source-inline">UPDATE</strong>, <strong class="source-inline">DELETE</strong>, and so on statements falls under the same statement. For instance, there is no guarantee that the following <strong class="source-inline">UPDATE</strong> will update our previous <strong class="source-inline">INSERT</strong>:</p>
			<pre class="source-code">ctx.update(SALE)</pre>
			<pre class="source-code">   .set(SALE.FISCAL_YEAR, 2005)</pre>
			<pre class="source-code">   .where(SALE.SALE_ID.eq(cr))</pre>
			<pre class="source-code">   .execute();</pre>
			<p>Another <a id="_idIndexMarker1124"/>approach that should be avoided in a concurrent transactional environment is the following:</p>
			<pre class="source-code">ctx.deleteFrom(SALE)</pre>
			<pre class="source-code">   .where(SALE.SALE_ID.eq(ctx.fetchValue(SALE_SEQ.currval())))</pre>
			<pre class="source-code">   .execute();</pre>
			<p>Even if this looks like a single query statement, it is not. This is materialized in a <strong class="source-inline">SELECT </strong>of the current value followed by a <strong class="source-inline">DELETE</strong>. Between these two statements, a concurrent transaction can still perform an <strong class="source-inline">INSERT</strong> that alters the current value (or, generally speaking, any kind of action that modifies/advances a sequence and returns a new value). Also, pay attention to these kinds of queries:</p>
			<pre class="source-code">ctx.deleteFrom(SALE)</pre>
			<pre class="source-code">   .where(SALE.SALE_ID.eq(SALE_SEQ.currval()))</pre>
			<pre class="source-code">   .execute();</pre>
			<p>This renders a single <strong class="source-inline">DELETE</strong>, as shown here (the PostgreSQL dialect):</p>
			<pre class="source-code">DELETE FROM "public"."sale" WHERE </pre>
			<pre class="source-code">  "public"."sale"."sale_id" = currval('"public"."sale_seq"')</pre>
			<p>This time, you<a id="_idIndexMarker1125"/> definitely refer to the latest current value, whatever it is. For instance, this may result in deleting the latest inserted record (not necessarily by us), or it may hit a current value that is not associated with any record yet.</p>
			<p>Furthermore, performing multi-inserts or batch inserts can take advantage of inlined <strong class="source-inline">nextval()</strong> references or pre-fetch a certain number of values via <strong class="source-inline">nextvals()</strong>:</p>
			<pre class="source-code">List&lt;Long&gt; ids1 = ctx.fetchValues(EMPLOYEE_SEQ.nextvals(10));</pre>
			<pre class="source-code">List&lt;Long&gt; ids2 = ctx.fetch(EMPLOYEE_SEQ</pre>
			<pre class="source-code">   .nextvals(10)).into(Long.class);</pre>
			<pre class="source-code">List&lt;Record1&lt;Long&gt;&gt; ids3 = ctx.fetch(</pre>
			<pre class="source-code">   EMPLOYEE_SEQ.nextvals(10));</pre>
			<p>At this point, <strong class="source-inline">ids1</strong>, <strong class="source-inline">ids2</strong>, and <strong class="source-inline">ids3</strong> hold in memory 10 values that can be used in subsequent queries. Until we exhaust these values, there is no need to fetch others. This way, we reduce the <a id="_idIndexMarker1126"/>number of database round trips. Here is an example of a multi-insert:</p>
			<pre class="source-code">for (int i = 0; i &lt; ids.size(); i++) {</pre>
			<pre class="source-code"> ctx.insertInto(EMPLOYEE, EMPLOYEE.EMPLOYEE_NUMBER, </pre>
			<pre class="source-code">                EMPLOYEE.LAST_NAME...)</pre>
			<pre class="source-code">   .values(ids1.get(i), "Lionel", ...)</pre>
			<pre class="source-code">   .execute();</pre>
			<pre class="source-code">}</pre>
			<p>The pre-fetched values can be used to pre-set IDs of <strong class="source-inline">Record</strong> as well:</p>
			<pre class="source-code">EmployeeRecord er = new EmployeeRecord(ids1.get(0),</pre>
			<pre class="source-code">  // or, ids2.get(0).value1(), </pre>
			<pre class="source-code">  "Lionel", ...);  </pre>
			<p>You can find these examples in the <em class="italic">Keys</em> bundled code.</p>
			<h1 id="_idParaDest-216"><a id="_idTextAnchor215"/>Inserting a SQL Server IDENTITY</h1>
			<p>This is not the first time<a id="_idIndexMarker1127"/> in this book that we have talked about inserting SQL Server <strong class="source-inline">IDENTITY</strong> values, but let's consider this section a must-have for this chapter. The problem consists of the fact that SQL Server doesn't allow us to specify an explicit value for an <strong class="source-inline">IDENTITY</strong> field as the <strong class="source-inline">PRODUCT</strong> primary key:</p>
			<pre class="source-code">CREATE TABLE [product] (</pre>
			<pre class="source-code">  [product_id] BIGINT NOT NULL IDENTITY,</pre>
			<pre class="source-code">  ...</pre>
			<pre class="source-code">);</pre>
			<p>In other words, the following <strong class="source-inline">INSERT</strong> statement will cause the following error – <em class="italic">Cannot insert explicit value for identity column in table 'product' when IDENTITY_INSERT is set to OFF</em>:</p>
			<pre class="source-code">ctx.insertInto(PRODUCT, PRODUCT.PRODUCT_ID, </pre>
			<pre class="source-code">               PRODUCT.PRODUCT_LINE, PRODUCT.CODE, </pre>
			<pre class="source-code">               PRODUCT.PRODUCT_NAME)</pre>
			<pre class="source-code">   .values(5555L, "Classic Cars", 599302L, "Super TX Audi")</pre>
			<pre class="source-code">   .onDuplicateKeyIgnore();</pre>
			<p>So, the solution to this error is contained in the message. We have to set <strong class="source-inline">IDENTITY_INSERT</strong> to <strong class="source-inline">ON</strong>. However, this should be done in the SQL Server <em class="italic">current session context</em>. In other words, we have to issue the settings of <strong class="source-inline">IDENTITY_INSERT</strong> and the actual <strong class="source-inline">INSERT</strong> statements in the same batch, as shown here:</p>
			<pre class="source-code">Query q1 = ctx.query("SET IDENTITY_INSERT [product] ON");</pre>
			<pre class="source-code">Query q2 = ctx.insertInto(PRODUCT, PRODUCT.PRODUCT_ID, </pre>
			<pre class="source-code">    PRODUCT.PRODUCT_LINE, PRODUCT.CODE, PRODUCT.PRODUCT_NAME)</pre>
			<pre class="source-code">  .values(5555L, "Classic Cars", 599302L, "Super TX Audi")</pre>
			<pre class="source-code">  .onDuplicateKeyIgnore(); // this will lead to a MERGE</pre>
			<pre class="source-code">Query q3 = ctx.query("SET IDENTITY_INSERT [product] OFF");</pre>
			<pre class="source-code">ctx.batch(q1, q2, q3).execute();</pre>
			<p>This time, there is no <a id="_idIndexMarker1128"/>issue with inserting it into the <strong class="source-inline">IDENTITY</strong> column. You can find these examples in the <em class="italic">Keys</em> (for SQL Server) bundled code.</p>
			<h1 id="_idParaDest-217"><a id="_idTextAnchor216"/>Fetching the Oracle ROWID pseudo-column</h1>
			<p>If you are a fan of the<a id="_idIndexMarker1129"/> Oracle database, then it is impossible not to have heard about the ROWID pseudo-column. However, as a quick reminder, the ROWID pseudo-column is associated with each row by Oracle, and its main goal is to return the address of the row. The information contained by ROWID can be used to locate a certain row. In jOOQ, we can refer to ROWID via the <strong class="source-inline">rowid()</strong> method. </p>
			<p>For instance, the following statement inserts a new <strong class="source-inline">SALE</strong> and fetches the generated primary key and the ROWID:</p>
			<pre class="source-code">ctx.insertInto(SALE, SALE.FISCAL_YEAR, SALE.SALE_, </pre>
			<pre class="source-code">               SALE.EMPLOYEE_NUMBER, SALE.FISCAL_MONTH, </pre>
			<pre class="source-code">               SALE.REVENUE_GROWTH)</pre>
			<pre class="source-code">   .values(2004, 2311.42, 1370L, 1, 0.0)</pre>
			<pre class="source-code">   .returningResult(SALE.SALE_ID, rowid())</pre>
			<pre class="source-code">   .fetchOne();  </pre>
			<p>The <strong class="source-inline">rowid()</strong> method returns a <strong class="source-inline">String</strong>, representing the value of ROWID (for instance, <em class="italic">AAAVO3AABAAAZzBABE</em>). We can use the ROWID for subsequent queries, such as locating a record:</p>
			<pre class="source-code">String rowid = ...;</pre>
			<pre class="source-code">var result = ctx.selectFrom(SALE)</pre>
			<pre class="source-code">   .where(rowid().eq(rowid))</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>However, as Lukas Eder shared: <em class="italic">"ROWIDs are not guaranteed to remain stable, so clients should never keep them around for long (for instance, outside of a transaction). But they can be useful to identify a row in a table without a primary key (for instance, a logging table)."</em></p>
			<p>In the <a id="_idIndexMarker1130"/>bundled code, <em class="italic">Keys</em> (for Oracle), you can also see an example of using <strong class="source-inline">rowid()</strong> in the <strong class="source-inline">SELECT</strong>, <strong class="source-inline">UPDATE</strong>, and <strong class="source-inline">DELETE</strong> statements.</p>
			<h1 id="_idParaDest-218"><a id="_idTextAnchor217"/>Comparing composite primary keys</h1>
			<p>By definition, a <a id="_idIndexMarker1131"/>composite primary key involves two or more columns that should uniquely identify a record. A composite primary key is usually a natural key (even if it is composed of references to surrogate keys) and can often be preferable to surrogate keys in relationship tables: <a href="https://blog.jooq.org/2019/03/26/the-cost-of-useless-surrogate-keys-in-relationship-tables/">https://blog.jooq.org/2019/03/26/the-cost-of-useless-surrogate-keys-in-relationship-tables/</a>. This means that predicates based on composite keys must contain all the involved columns. For instance, the <strong class="source-inline">PRODUCTLINE</strong> table has a composite key as (<strong class="source-inline">PRODUCT_LINE</strong>, <strong class="source-inline">CODE</strong>), and we can write a predicate for fetching a certain record by chaining the fields of the composite key via <strong class="source-inline">and()</strong>, as follows:</p>
			<pre class="source-code">var result = ctx.selectFrom(PRODUCTLINE)</pre>
			<pre class="source-code"> .where(PRODUCTLINE.PRODUCT_LINE.eq("Classic Cars")</pre>
			<pre class="source-code">   .and(PRODUCTLINE.CODE.eq(599302L)))</pre>
			<pre class="source-code"> .fetchSingle();</pre>
			<p>Alternatively, we can separate fields from values using <strong class="source-inline">row()</strong> (the <strong class="source-inline">eq()</strong> method doesn't require an explicit <strong class="source-inline">row()</strong> constructor, so use it as you like):</p>
			<pre class="source-code">var result = ctx.selectFrom(PRODUCTLINE)</pre>
			<pre class="source-code">  .where(row(PRODUCTLINE.PRODUCT_LINE, PRODUCTLINE.CODE)</pre>
			<pre class="source-code">    .eq(row("Classic Cars", 599302L)))</pre>
			<pre class="source-code">  .fetchSingle();</pre>
			<p>Using <strong class="source-inline">row()</strong> is also useful in conjunction with <strong class="source-inline">in()</strong>, <strong class="source-inline">notIn()</strong>, and so on:</p>
			<pre class="source-code">result = ctx.selectFrom(PRODUCTLINE)</pre>
			<pre class="source-code">  .where(row(PRODUCTLINE.PRODUCT_LINE, PRODUCTLINE.CODE)    </pre>
			<pre class="source-code">  .in(row("Classic Cars", 599302L),</pre>
			<pre class="source-code">      row("Trains", 123333L),</pre>
			<pre class="source-code">      row("Motorcycles", 599302L)))</pre>
			<p>Practically, in all these examples (available in <em class="italic">Keys</em>), you have to ensure that you don't forget any<a id="_idIndexMarker1132"/> column of the composite key. This may become a struggle for composite keys containing more than two fields and/or in cases where the predicates involve more related conditions, and it is difficult to visually isolate the composite key fields.</p>
			<p>A better approach is to employ embedded keys.</p>
			<h1 id="_idParaDest-219"><a id="_idTextAnchor218"/>Working with embedded keys</h1>
			<p>As part of the <a id="_idIndexMarker1133"/>embeddable types introduced in <a href="B16833_07.xhtml#_idTextAnchor110"><em class="italic">Chapter 7</em></a>, <em class="italic">Types, Converters, and Bindings,</em> we have jOOQ-embedded keys. An embedded key is materialized by the jOOQ Code Generator into the implementation of the jOOQ <strong class="source-inline">org.jooq.EmbeddableRecord</strong> interface and a handy POJO class. An embedded key extends the default implementation of the <strong class="source-inline">org.jooq.EmbeddableRecord</strong> interface, which is <strong class="source-inline">org.jooq.impl.EmbeddableRecordImpl</strong>. </p>
			<p>We can define embedded keys for primary and unique keys. Practically, we indicate to jOOQ the primary/unique keys that should become embedded keys, and jOOQ will generate the corresponding artifacts for each primary/unique key, as well as for each foreign key referencing these primary/unique keys. Roughly, embedded keys mirror the primary/unique keys and the corresponding foreign keys in Java classes.</p>
			<p>However, in order to employ embedded keys, we need the following configuration:</p>
			<pre class="source-code">// Maven and standalone</pre>
			<pre class="source-code">&lt;database&gt;</pre>
			<pre class="source-code">  ...</pre>
			<pre class="source-code">  &lt;embeddablePrimaryKeys&gt;.*&lt;/embeddablePrimaryKeys&gt;</pre>
			<pre class="source-code">  &lt;embeddableUniqueKeys&gt;.*&lt;/embeddableUniqueKeys&gt;</pre>
			<pre class="source-code">&lt;/database&gt;</pre>
			<pre class="source-code">// Gradle</pre>
			<pre class="source-code">database {</pre>
			<pre class="source-code">  ...</pre>
			<pre class="source-code">  embeddablePrimaryKeys = '.*'</pre>
			<pre class="source-code">  embeddableUniqueKeys = '.*'</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">// programmatic</pre>
			<pre class="source-code">.withEmbeddablePrimaryKeys(".*")</pre>
			<pre class="source-code">.withEmbeddableUniqueKeys(".*")</pre>
			<p>Most probably, you'll not rely on a <strong class="source-inline">.*</strong> regular expression, since you'll not want to transform all your primary/unique keys into embedded keys. For instance, you may prefer to use embedded keys for composite keys only, so you have to use the proper regular expression for your case. Speaking about composite keys, how about creating an embedded key for the <a id="_idIndexMarker1134"/>composite key of <strong class="source-inline">PRODUCTLINE</strong> (introduced in the previous section)?</p>
			<pre class="source-code">CREATE TABLE [productline] (</pre>
			<pre class="source-code">  [product_line] VARCHAR(50) NOT NULL,</pre>
			<pre class="source-code">  [code] BIGINT NOT NULL,</pre>
			<pre class="source-code">  ...</pre>
			<pre class="source-code">  CONSTRAINT [productline_pk]</pre>
			<pre class="source-code">    PRIMARY KEY ([product_line],[code])</pre>
			<pre class="source-code">);</pre>
			<p>Indicate to jOOQ that we are interested in the (<strong class="source-inline">product_line</strong>, <strong class="source-inline">code</strong>) primary key via <strong class="source-inline">&lt;embeddablePrimaryKeys&gt;productline_pk&lt;/embeddablePrimaryKeys&gt;</strong>, where <strong class="source-inline">productline_pk</strong> represents the name of the constraint that defines our composite primary key (if you want to list multiple constraints/primary keys, then use <strong class="source-inline">|</strong> as a separator).</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">As a rule of thumb, it's always a good idea to explicitly name your constraints. This way, you never have to bother with dealing with vendor-specific generated names and potential issues. If you are not convinced that you should always name your constraints, then I suggest you read this meaningful article: <a href="https://blog.jooq.org/how-to-quickly-rename-all-primary-keys-in-oracle/">https://blog.jooq.org/how-to-quickly-rename-all-primary-keys-in-oracle/</a>.</p>
			<p class="callout">However, notice that MySQL ignores the constraint names on the primary key and defaults all to <strong class="source-inline">PRIMARY</strong>. In such a case, you cannot refer to a composite primary key via the name of its constraint but instead as <strong class="source-inline">KEY_tablename_PRIMARY</strong>. For instance, instead of <strong class="source-inline">productline_pk</strong>, use <strong class="source-inline">KEY_productline_PRIMARY</strong>.</p>
			<p>At this point, jOOQ is ready to generate the classes for this embedded key, but let's take another action and customize the names of these classes. At this point, jOOQ relies on the default matcher strategy, so the names will be <strong class="source-inline">ProductlinePkRecord.java</strong> and <strong class="source-inline">ProductlinePk.java</strong>. But, we prefer <strong class="source-inline">EmbeddedProductlinePkRecord.java</strong> and <strong class="source-inline">EmbeddedProductlinePk.java</strong> respectively. As you already know, whenever we talk about renaming jOOQ things, we can rely on a configurative/programmatic matcher strategy and regular<a id="_idIndexMarker1135"/> expressions (note that the <strong class="source-inline">(?i:...)</strong> directive is a thing to render the expression case-insensitive). In this case, we have the following:</p>
			<pre class="source-code">&lt;strategy&gt;</pre>
			<pre class="source-code"> &lt;matchers&gt;</pre>
			<pre class="source-code">  &lt;embeddables&gt;</pre>
			<pre class="source-code">   &lt;embeddable&gt;</pre>
			<pre class="source-code">    &lt;expression&gt;.*_pk&lt;/expression&gt;</pre>
			<pre class="source-code">    &lt;recordClass&gt;</pre>
			<pre class="source-code">     &lt;expression&gt;Embedded_$0_Record&lt;/expression&gt;</pre>
			<pre class="source-code">     &lt;transform&gt;PASCAL&lt;/transform&gt;</pre>
			<pre class="source-code">    &lt;/recordClass&gt;</pre>
			<pre class="source-code">    &lt;pojoClass&gt;</pre>
			<pre class="source-code">     &lt;expression&gt;Embedded_$0&lt;/expression&gt;</pre>
			<pre class="source-code">     &lt;transform&gt;PASCAL&lt;/transform&gt;</pre>
			<pre class="source-code">    &lt;/pojoClass&gt;</pre>
			<pre class="source-code">   &lt;/embeddable&gt;</pre>
			<pre class="source-code">  &lt;/embeddables&gt;</pre>
			<pre class="source-code"> &lt;/matchers&gt;</pre>
			<pre class="source-code">&lt;/strategy&gt;</pre>
			<p>Okay, so far, so good! At this point, the jOOQ Code Generator is ready to materialize our embedded key in <strong class="source-inline">EmbeddedProductlinePkRecord.java</strong> and <strong class="source-inline">EmbeddedProductlinePk.java</strong>. Also, jOOQ generates the <strong class="source-inline">PRODUCTLINE_PK</strong> field in the <strong class="source-inline">Productline</strong> class (see <strong class="source-inline">jooq.generated.tables.Productline</strong>), representing the embedded primary key.</p>
			<p>Moreover, the jOOQ<a id="_idIndexMarker1136"/> Code Generator searches the foreign keys referencing our composite key, and it should find the following two:</p>
			<pre class="source-code">CREATE TABLE [product] (</pre>
			<pre class="source-code">  [product_line] VARCHAR(50) DEFAULT NULL,</pre>
			<pre class="source-code">  [code] BIGINT NOT NULL,</pre>
			<pre class="source-code">  ...</pre>
			<pre class="source-code">  CONSTRAINT [product_productline_fk]</pre>
			<pre class="source-code">    FOREIGN KEY ([product_line],[code]) </pre>
			<pre class="source-code">    REFERENCES [productline] ([product_line],[code])</pre>
			<pre class="source-code">);</pre>
			<pre class="source-code">CREATE TABLE [productlinedetail] (</pre>
			<pre class="source-code">  [product_line] VARCHAR(50) NOT NULL,</pre>
			<pre class="source-code">  [code] BIGINT NOT NULL,</pre>
			<pre class="source-code">  ...</pre>
			<pre class="source-code">  CONSTRAINT [productlinedetail_productline_fk]</pre>
			<pre class="source-code">    FOREIGN KEY ([product_line],[code]) </pre>
			<pre class="source-code">    REFERENCES [productline] ([product_line],[code])  </pre>
			<pre class="source-code">);</pre>
			<p>For the <strong class="source-inline">product_productline_fk</strong> and <strong class="source-inline">productlinedetail_productline_fk</strong> constraints (of our foreign keys), jOOQ generates the <strong class="source-inline">PRODUCT_PRODUCTLINE_FK</strong> field in the <strong class="source-inline">Product</strong> class (see <strong class="source-inline">jooq.generated.tables.Product</strong>) and the <strong class="source-inline">PRODUCTLINEDETAIL_PRODUCTLINE_FK</strong> field in the <strong class="source-inline">Productlinedetail</strong> class (see <strong class="source-inline">jooq.generated.tables.Productlinedetail</strong>).</p>
			<p>Now, let's practice! For <a id="_idIndexMarker1137"/>instance, let's assume that we want to fetch the composite primary key of <strong class="source-inline">PRODUCTLINE</strong> and the creation date. Most probably, without using the embedded key, our <strong class="source-inline">SELECT</strong> statement will be something like this:</p>
			<pre class="source-code">var result = ctx.select(PRODUCTLINE.PRODUCT_LINE, </pre>
			<pre class="source-code">           PRODUCTLINE.CODE, PRODUCTLINE.CREATED_ON) ...</pre>
			<p>We know that <strong class="source-inline">PRODUCT_LINE</strong> and <strong class="source-inline">CODE</strong> form our composite key. However, for someone who is not very familiar with our schema, it will be more convenient and less risky to rely on the <strong class="source-inline">PRODUCTLINE_PK</strong> embedded key and write this:</p>
			<pre class="source-code">// Result&lt;Record2&lt;EmbeddedProductlinePkRecord, LocalDate&gt;&gt;</pre>
			<pre class="source-code">var result = ctx.select(PRODUCTLINE.PRODUCTLINE_PK, </pre>
			<pre class="source-code">                        PRODUCTLINE.CREATED_ON)...</pre>
			<p>Obviously, this is less verbose and much more expressive. There is no risk of forgetting a field of the composite key or mixing composite key fields with other fields (which just increases confusion), and we can add/remove a column from the composite key without modifying this code. Once we rerun the Code Generator, jOOQ will shape <strong class="source-inline">PRODUCTLINE_PK</strong> accordingly.</p>
			<p>We can access data via getters, as shown here:</p>
			<pre class="source-code">// '.get(0)' returns the first </pre>
			<pre class="source-code">// Record2&lt;EmbeddedProductlinePkRecord, LocalDate&gt;,</pre>
			<pre class="source-code">// while '.value1()' returns the EmbeddedProductlinePkRecord</pre>
			<pre class="source-code">result.get(0).value1().getProductLine()</pre>
			<pre class="source-code">result.get(0).value1().getCode()</pre>
			<p>Moreover, since the<a id="_idIndexMarker1138"/> embedded key takes advantage of a generated POJO as well, we can fetch the composite key directly in the POJO. Look at how cool this is:</p>
			<pre class="source-code">List&lt;EmbeddedProductlinePk&gt; result =    </pre>
			<pre class="source-code">   ctx.select(PRODUCTLINE.PRODUCTLINE_PK)</pre>
			<pre class="source-code">      .from(PRODUCTLINE)</pre>
			<pre class="source-code">      .where(PRODUCTLINE.IMAGE.isNull())</pre>
			<pre class="source-code">      .fetchInto(EmbeddedProductlinePk.class);</pre>
			<p>The <strong class="source-inline">EmbeddedProductlinePk</strong> POJO exposes getters and setters to access the parts of the embedded composite key.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">Embedded keys are the embeddable types most prone to overlapping. By default, jOOQ tries to elegantly solve each overlapping case to our benefit, but when the ambiguity cannot be clarified, jOOQ will log such cases, and it's your job to act accordingly.</p>
			<p>Let's go further and see other examples. For instance, searching a composite key in a certain collection of composite keys can be done, as shown here:</p>
			<pre class="source-code">var result = ctx.selectFrom(PRODUCTLINE)</pre>
			<pre class="source-code">  .where(PRODUCTLINE.PRODUCTLINE_PK.in(</pre>
			<pre class="source-code">    new EmbeddedProductlinePkRecord("Classic Cars", 599302L),</pre>
			<pre class="source-code">    new EmbeddedProductlinePkRecord("Vintage Cars", 223113L)))</pre>
			<pre class="source-code">  .fetch();</pre>
			<p>Alternatively, joining <strong class="source-inline">PRODUCTLINE</strong> and <strong class="source-inline">PRODUCT</strong> can be done, as shown here (both the primary and<a id="_idIndexMarker1139"/> foreign keys produce the primary key record):</p>
			<pre class="source-code">var result = ctx.select(PRODUCTLINE.PRODUCTLINE_PK,</pre>
			<pre class="source-code">              PRODUCT.PRODUCT_ID, PRODUCT.PRODUCT_NAME)</pre>
			<pre class="source-code">   .from(PRODUCTLINE)</pre>
			<pre class="source-code">   .join(PRODUCT)</pre>
			<pre class="source-code">   .on(PRODUCTLINE.PRODUCTLINE_PK.eq(</pre>
			<pre class="source-code">          PRODUCT.PRODUCT_PRODUCTLINE_FK))</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>Again, the code is less verbose and more expressive. However, more importantly, there is no risk of forgetting a column of the composite key in the join predicate. In addition, since both primary and foreign keys produce the primary key record, the predicate is valid only if we rely on matching primary/foreign key columns. This goes beyond type checking, since there is no risk of comparing wrong fields (for instance, fields that don't belong to the composite key but have the same type as the fields of the composite key).</p>
			<p>As Lukas Eder mentioned: <em class="italic">"The type checking aspect is also interesting for single-column key types. With embeddable types, column types become "semantic," and what would otherwise be two compatible Field&lt;Long&gt; columns no longer are compatible. So, specifically in the case of JOIN predicates, it will no longer be possible to accidentally compare the wrong columns in on(). This could even help detect a forgotten foreign key constraint."</em> (<a href="https://twitter.com/anghelleonard/status/1499751304532533251">https://twitter.com/anghelleonard/status/1499751304532533251</a>)</p>
			<p>This is a good <a id="_idIndexMarker1140"/>opportunity to reflect on your favorite way to express the <strong class="source-inline">JOIN</strong> predicate with composite keys in jOOQ. The following figure summarizes several approaches, including a simple <strong class="source-inline">and()</strong>, using <strong class="source-inline">row()</strong>, an implicit join, a synthetic <strong class="source-inline">onKey()</strong>, and embedded keys:</p>
			<div>
				<div id="_idContainer060" class="IMG---Figure">
					<img src="image/Figure_11.1.jpg" alt="Figure 11.1 – The JOIN predicate with composite keys&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.1 – The JOIN predicate with composite keys</p>
			<p>How about updating/deleting/inserting an embedded key? Well, these examples speak for themselves:</p>
			<pre class="source-code">EmbeddedProductlinePkRecord pk = new </pre>
			<pre class="source-code">    EmbeddedProductlinePkRecord("Turbo Jets", 908844L);</pre>
			<pre class="source-code">ctx.update(PRODUCTLINE)</pre>
			<pre class="source-code">   .set(PRODUCTLINE.TEXT_DESCRIPTION, "Not available")</pre>
			<pre class="source-code">   .where(PRODUCTLINE.PRODUCTLINE_PK.eq(pk))</pre>
			<pre class="source-code">   .execute();</pre>
			<pre class="source-code">ctx.deleteFrom(PRODUCTLINE)</pre>
			<pre class="source-code">   .where(PRODUCTLINE.PRODUCTLINE_PK.eq(pk))</pre>
			<pre class="source-code">   .execute();</pre>
			<pre class="source-code">ctx.insertInto(PRODUCTLINE, PRODUCTLINE.PRODUCTLINE_PK, </pre>
			<pre class="source-code">               PRODUCTLINE.TEXT_DESCRIPTION)</pre>
			<pre class="source-code">   .values(pk, "Some cool turbo engines")</pre>
			<pre class="source-code">   .execute();</pre>
			<p>Practice these <a id="_idIndexMarker1141"/>examples in <em class="italic">EmbeddedCompositeKeys</em> (for SQL Server and Oracle). Alternatively, if you prefer to start with embedded keys for simple primary keys, then you can check out the <em class="italic">EmbeddedSimpleKeys</em> application (for SQL Server and Oracle). Next, let's talk about jOOQ synthetic objects.</p>
			<h1 id="_idParaDest-220"><a id="_idTextAnchor219"/>Working with jOOQ synthetic objects</h1>
			<p>jOOQ <em class="italic">synthetic objects</em> is a<a id="_idIndexMarker1142"/> powerful and exciting feature introduced in version 3.14 that reveals its full usability with database (updatable) views, databases that you cannot but want to alter, and legacy databases that have some <em class="italic">missing parts</em>. By <em class="italic">missing parts</em>, we mean identities, primary keys, unique keys, and foreign keys that simply don't exist, or do exist but are not enabled or reported by the database (and are not present in the database metadata). The jOOQ Code Generator can tackle this aspect by producing synthetic objects that emulate these <em class="italic">missing parts</em>. Let's adopt<a id="_idIndexMarker1143"/> the learning by example technique to see how synthetic objects work.</p>
			<h2 id="_idParaDest-221"><a id="_idTextAnchor220"/>Synthetic primary/foreign keys</h2>
			<p>Let's <a id="_idIndexMarker1144"/>consider that <a id="_idIndexMarker1145"/>we have the following two database views (in PostgreSQL):</p>
			<pre class="source-code">CREATE OR REPLACE VIEW "customer_master" AS</pre>
			<pre class="source-code">SELECT "customerdetail"."city",</pre>
			<pre class="source-code">       "customerdetail"."country",       </pre>
			<pre class="source-code">       "customerdetail"."state",</pre>
			<pre class="source-code">       "customerdetail"."postal_code",</pre>
			<pre class="source-code">       ...</pre>
			<pre class="source-code">FROM "customer"</pre>
			<pre class="source-code">JOIN "customerdetail" </pre>
			<pre class="source-code">  ON "customerdetail"."customer_number" =      </pre>
			<pre class="source-code">     "customer"."customer_number"</pre>
			<pre class="source-code">WHERE "customer"."first_buy_date" IS NOT NULL;</pre>
			<pre class="source-code">CREATE OR REPLACE VIEW "office_master" AS</pre>
			<pre class="source-code">SELECT "office"."city",</pre>
			<pre class="source-code">       "office"."country",</pre>
			<pre class="source-code">       "office"."state",</pre>
			<pre class="source-code">       "office"."postal_code",</pre>
			<pre class="source-code">       ... </pre>
			<pre class="source-code">FROM "office"</pre>
			<pre class="source-code">WHERE "office"."city" IS NOT NULL;</pre>
			<p>Exactly as in the case of regular tables, jOOQ generates the corresponding records, tables, and POJOs for these views, so you'll have <strong class="source-inline">CustomerMasterRecord</strong> (a non-updatable record because the view is non-updatable) and <strong class="source-inline">OfficeMasterRecord</strong> (an updatable record because the view is updatable) in <strong class="source-inline">jooq.generated.tables.records</strong>, and <strong class="source-inline">CustomerMaster</strong> and <strong class="source-inline">OfficeMaster</strong> in <strong class="source-inline">jooq.generated.tables</strong> and <strong class="source-inline">jooq.generated.tables.pojos</strong> respectively.</p>
			<p>Next, let's<a id="_idIndexMarker1146"/> indulgently assume that a triad (<strong class="source-inline">country</strong>, <strong class="source-inline">state</strong>, and <strong class="source-inline">city</strong>) uniquely identifies a <a id="_idIndexMarker1147"/>customer and an office, and we want to find customers that are in the same area as an office. For this, we can write <strong class="source-inline">LEFT JOIN</strong>, as shown in the following:</p>
			<pre class="source-code">ctx.select(CUSTOMER_MASTER.CUSTOMER_NAME, </pre>
			<pre class="source-code">           CUSTOMER_MASTER.CREDIT_LIMIT,  </pre>
			<pre class="source-code">           CUSTOMER_MASTER.CITY.as("customer_city"), </pre>
			<pre class="source-code">           OFFICE_MASTER.CITY.as("office_city"), </pre>
			<pre class="source-code">           OFFICE_MASTER.PHONE)</pre>
			<pre class="source-code">   .from(CUSTOMER_MASTER)</pre>
			<pre class="source-code">   .leftOuterJoin(OFFICE_MASTER)</pre>
			<pre class="source-code">   .on(row(CUSTOMER_MASTER.COUNTRY, CUSTOMER_MASTER.STATE, </pre>
			<pre class="source-code">           CUSTOMER_MASTER.CITY)</pre>
			<pre class="source-code">     .eq(row(OFFICE_MASTER.COUNTRY, OFFICE_MASTER.STATE,   </pre>
			<pre class="source-code">             OFFICE_MASTER.CITY)))</pre>
			<pre class="source-code">   .orderBy(CUSTOMER_MASTER.CUSTOMER_NAME)</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>Look at the <strong class="source-inline">JOIN</strong> statement's predicate! It is verbose and prone to mistakes. Moreover, if we modify (for instance, rename or remove) any of the columns involved in this predicate, then we have to adjust this predicate as well. However, there is nothing we can do, since a database view doesn't support primary/foreign keys, right? Actually, here is exactly where synthetic keys enter the scene. If jOOQ were able to give us a composite synthetic primary key for <strong class="source-inline">OFFICE_MASTER</strong> and a synthetic foreign key for <strong class="source-inline">CUSTOMER_MASTER</strong> referencing the <strong class="source-inline">OFFICE_MASTER</strong> synthetic primary key, then we could simplify and reduce the risk of mistakes in our <strong class="source-inline">JOIN</strong>. Practically, we could express our <strong class="source-inline">JOIN</strong> as an implicit <strong class="source-inline">JOIN</strong> or via <strong class="source-inline">onKey()</strong> exactly as in the case of regular tables.</p>
			<p>However, remember that we said to <em class="italic">indulgently assume the uniqueness</em>. Note that we don't even need to make an assumption of uniqueness for the natural key (<strong class="source-inline">country</strong>, <strong class="source-inline">state</strong>, and <strong class="source-inline">city</strong>). Synthetic <strong class="bold">primary keys/unique keys</strong> (<strong class="bold">PK/UK</strong>) can even be used to enable some cool features for things that aren't actually candidate keys, or even unique. For example, there may be hundreds of reports that calculate stuff based on this "location relationship," and normalizing is not possible because this is a data warehouse, and so on.</p>
			<p>Going further, jOOQ <a id="_idIndexMarker1148"/>synthetic keys are shaped at the configuration level. For<a id="_idIndexMarker1149"/> Maven and standalone configuration, we need the following intuitive snippet of code that defines the <strong class="source-inline">office_master_pk</strong> synthetic composite primary key and the <strong class="source-inline">office_master_fk</strong> synthetic foreign key (you should have no problem understanding this code by simply following the tag's name and its content in the context of previous database views):</p>
			<pre class="source-code">&lt;database&gt;</pre>
			<pre class="source-code"> ...</pre>
			<pre class="source-code"> &lt;syntheticObjects&gt;</pre>
			<pre class="source-code">  &lt;primaryKeys&gt;</pre>
			<pre class="source-code">   &lt;primaryKey&gt;</pre>
			<pre class="source-code">    &lt;name&gt;office_master_pk&lt;/name&gt;</pre>
			<pre class="source-code">    &lt;tables&gt;office_master&lt;/tables&gt;</pre>
			<pre class="source-code">    &lt;fields&gt;</pre>
			<pre class="source-code">     &lt;field&gt;country&lt;/field&gt;</pre>
			<pre class="source-code">     &lt;field&gt;state&lt;/field&gt;</pre>
			<pre class="source-code">     &lt;field&gt;city&lt;/field&gt;</pre>
			<pre class="source-code">    &lt;/fields&gt;</pre>
			<pre class="source-code">   &lt;/primaryKey&gt;</pre>
			<pre class="source-code">  &lt;/primaryKeys&gt;</pre>
			<pre class="source-code">  &lt;foreignKeys&gt;</pre>
			<pre class="source-code">   &lt;foreignKey&gt;</pre>
			<pre class="source-code">    &lt;name&gt;office_master_fk&lt;/name&gt;</pre>
			<pre class="source-code">    &lt;tables&gt;customer_master&lt;/tables&gt;</pre>
			<pre class="source-code">    &lt;fields&gt;</pre>
			<pre class="source-code">     &lt;field&gt;country&lt;/field&gt;</pre>
			<pre class="source-code">     &lt;field&gt;state&lt;/field&gt;</pre>
			<pre class="source-code">     &lt;field&gt;city&lt;/field&gt;</pre>
			<pre class="source-code">    &lt;/fields&gt;</pre>
			<pre class="source-code">    &lt;referencedTable&gt;office_master&lt;/referencedTable&gt;</pre>
			<pre class="source-code">    &lt;referencedFields&gt;</pre>
			<pre class="source-code">     &lt;field&gt;country&lt;/field&gt;</pre>
			<pre class="source-code">     &lt;field&gt;state&lt;/field&gt;</pre>
			<pre class="source-code">     &lt;field&gt;city&lt;/field&gt;</pre>
			<pre class="source-code">    &lt;/referencedFields&gt;</pre>
			<pre class="source-code">   &lt;/foreignKey&gt;</pre>
			<pre class="source-code">  &lt;/foreignKeys&gt;</pre>
			<pre class="source-code"> &lt;/syntheticObjects&gt;</pre>
			<pre class="source-code">&lt;/database&gt;</pre>
			<p>You can find the<a id="_idIndexMarker1150"/> guidance for <a id="_idIndexMarker1151"/>Gradle and the programmatic approach (which, in jOOQ style, is very intuitive as well) in the jOOQ manual.</p>
			<p>Now, after running the jOOQ Code Generator, our <strong class="source-inline">JOIN</strong> can take advantage of the generated synthetic keys and be simplified via the synthetic <strong class="source-inline">onKey()</strong>, introduced in <a href="B16833_06.xhtml#_idTextAnchor093"><em class="italic">Chapter 6</em></a>, <em class="italic">Tackling Different Kinds of JOIN Statements</em>. So, now we can write this:</p>
			<pre class="source-code">ctx.select(CUSTOMER_MASTER.CUSTOMER_NAME, </pre>
			<pre class="source-code">           CUSTOMER_MASTER.CREDIT_LIMIT, </pre>
			<pre class="source-code">           CUSTOMER_MASTER.CITY.as("customer_city"),</pre>
			<pre class="source-code">           OFFICE_MASTER.CITY.as("office_city"), </pre>
			<pre class="source-code">           OFFICE_MASTER.PHONE)</pre>
			<pre class="source-code">   .from(CUSTOMER_MASTER)</pre>
			<pre class="source-code">   .leftOuterJoin(OFFICE_MASTER)</pre>
			<pre class="source-code">   .onKey()</pre>
			<pre class="source-code">   .orderBy(CUSTOMER_MASTER.CUSTOMER_NAME)</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>In comparison to the previous approach, this is less verbose, less prone to mistakes, and robust against subsequent modification of the columns involved with the synthetic key. Of course, you can use <strong class="source-inline">onKey()</strong> to write <strong class="source-inline">INNER JOIN</strong> and <strong class="source-inline">RIGHT JOIN</strong> statements and so on. However, without synthetic keys, the usage of <strong class="source-inline">onKey()</strong> leads to <strong class="source-inline">DataAccessException</strong> – <em class="italic">No matching Key found between tables ["classicmodels"."customer_master"] and ["classicmodels"."office_master"]</em>.</p>
			<p>Even if <strong class="source-inline">onKey()</strong> works just fine, you'll most probably find synthetic <strong class="bold">foreign keys </strong>(<strong class="bold">FKs</strong>) even more powerful for implicit joins between views. Unlike <strong class="source-inline">onKey()</strong>, which can lead to ambiguities in complex <strong class="source-inline">JOIN</strong> graphs (or even in simple ones), implicit joins are always non-ambiguous. </p>
			<p>So, sticking<a id="_idIndexMarker1152"/> to <strong class="source-inline">LEFT JOIN</strong>, the previous <strong class="source-inline">JOIN</strong> can be simplified and reinforced even <a id="_idIndexMarker1153"/>more by adopting an implicit <strong class="source-inline">JOIN</strong>:</p>
			<pre class="source-code">ctx.select(CUSTOMER_MASTER.CUSTOMER_NAME, </pre>
			<pre class="source-code">        CUSTOMER_MASTER.CREDIT_LIMIT, </pre>
			<pre class="source-code">        CUSTOMER_MASTER.CITY.as("customer_city"),</pre>
			<pre class="source-code">        CUSTOMER_MASTER.officeMaster().CITY.as("office_city"), </pre>
			<pre class="source-code">        CUSTOMER_MASTER.officeMaster().PHONE)</pre>
			<pre class="source-code">   .from(CUSTOMER_MASTER)</pre>
			<pre class="source-code">   .orderBy(CUSTOMER_MASTER.CUSTOMER_NAME)</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>So cool! There are no explicit columns in the join predicate, and we can modify the composite key without risks! Once we run the jOOQ Code Generator to reflect the changes, this code will work out of the box.</p>
			<p>However, the<a id="_idIndexMarker1154"/> implicit join example here might lead to a peculiar weirdness. Since this is a <a id="_idIndexMarker1155"/>synthetic foreign key, and the synthetic primary key isn't actually/truly unique (we've just indulgently assumed the uniqueness), projecting an implicit join path means that we might get a Cartesian Product just from the projection, which is very surprising in SQL. A projection should never affect the cardinality of the result, but here we are... Perhaps this is a good opportunity to explore the <strong class="source-inline">UNIQUE()</strong> predicate to check whether their "candidate" key is actually unique: <a href="https://www.jooq.org/doc/latest/manual/sql-building/conditional-expressions/unique-predicate/">https://www.jooq.org/doc/latest/manual/sql-building/conditional-expressions/unique-predicate/</a>.</p>
			<p>You can practice this example in <em class="italic">SyntheticPkKeysImplicitJoin</em>.</p>
			<h3>Embedded keys for synthetic keys</h3>
			<p>Next, let's assume<a id="_idIndexMarker1156"/> that we want to fetch some data from the <strong class="source-inline">OFFICE_MASTER</strong> table, based on a given set of <strong class="source-inline">country</strong>, <strong class="source-inline">state</strong>, and <strong class="source-inline">city</strong> triads. At this point, we can write this:</p>
			<pre class="source-code">ctx.select(OFFICE_MASTER.OFFICE_CODE, OFFICE_MASTER.PHONE)</pre>
			<pre class="source-code">   .from(OFFICE_MASTER)</pre>
			<pre class="source-code">   .where(row(OFFICE_MASTER.COUNTRY, OFFICE_MASTER.STATE, </pre>
			<pre class="source-code">          OFFICE_MASTER.CITY).in(</pre>
			<pre class="source-code">      row("USA", "MA", "Boston"),</pre>
			<pre class="source-code">      row("USA", "CA", "San Francisco")))</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>However, we know that (<strong class="source-inline">country</strong>, <strong class="source-inline">state</strong>, <strong class="source-inline">city</strong>) is actually our synthetic key. This means that if we define an embedded key for this synthetic key, then we should take advantage of embedded keys, exactly as we saw earlier in the <em class="italic">Working with embedded keys</em> section. Since the synthetic key name is <strong class="source-inline">office_master_pk</strong>, the embedded keys resume to this:</p>
			<pre class="source-code">&lt;embeddablePrimaryKeys&gt;</pre>
			<pre class="source-code"> office_master_pk</pre>
			<pre class="source-code">&lt;/embeddablePrimaryKeys&gt;</pre>
			<p>Rerun the jOOQ Code Generator to generate the jOOQ artifacts corresponding to this embedded key, <strong class="source-inline">OfficeMasterPkRecord</strong>, and the <strong class="source-inline">OfficeMasterPk</strong> POJO. This time, we can rewrite our query, as shown here:</p>
			<pre class="source-code">ctx.select(OFFICE_MASTER.OFFICE_CODE, OFFICE_MASTER.PHONE)</pre>
			<pre class="source-code">   .from(OFFICE_MASTER)</pre>
			<pre class="source-code">   .where(OFFICE_MASTER.OFFICE_MASTER_PK.in(</pre>
			<pre class="source-code">     new OfficeMasterPkRecord("USA", "MA", "Boston"),</pre>
			<pre class="source-code">     new OfficeMasterPkRecord("USA", "CA", "San Francisco")))</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>Alternatively, maybe<a id="_idIndexMarker1157"/> we want to fetch an embedded key value in the <strong class="source-inline">OfficeMasterPk</strong> POJO:</p>
			<pre class="source-code">List&lt;OfficeMasterPk&gt; result = </pre>
			<pre class="source-code">   ctx.select(OFFICE_MASTER.OFFICE_MASTER_PK)</pre>
			<pre class="source-code">      .from(OFFICE_MASTER)</pre>
			<pre class="source-code">      .where(OFFICE_MASTER.OFFICE_CODE.eq("1"))</pre>
			<pre class="source-code">      .fetchInto(OfficeMasterPk.class);</pre>
			<p>How about a <strong class="source-inline">JOIN</strong>, using explicitly <strong class="source-inline">OFFICE_MASTER_PK</strong> and <strong class="source-inline">OFFICE_MASTER_FK</strong>?</p>
			<pre class="source-code">ctx.select(CUSTOMER_MASTER.CUSTOMER_NAME, ...)</pre>
			<pre class="source-code">   .from(CUSTOMER_MASTER)</pre>
			<pre class="source-code">   .innerJoin(OFFICE_MASTER)</pre>
			<pre class="source-code">     .on(OFFICE_MASTER.OFFICE_MASTER_PK</pre>
			<pre class="source-code">       .eq(CUSTOMER_MASTER.OFFICE_MASTER_FK))</pre>
			<pre class="source-code">   .orderBy(CUSTOMER_MASTER.CUSTOMER_NAME)</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>Alternatively, maybe <a id="_idIndexMarker1158"/>an update that has a predicate based on the embedded key:</p>
			<pre class="source-code">ctx.update(OFFICE_MASTER)</pre>
			<pre class="source-code">   .set(OFFICE_MASTER.PHONE, "+16179821809")</pre>
			<pre class="source-code">   .where(OFFICE_MASTER.OFFICE_MASTER_PK.eq(</pre>
			<pre class="source-code">       new OfficeMasterPkRecord("USA", "MA", "Boston")))</pre>
			<pre class="source-code">   .execute();</pre>
			<p>You can practice these examples in <em class="italic">EmbeddedSyntheticKeys</em> for PostgreSQL.</p>
			<h3>Using navigation methods</h3>
			<p>Furthermore, if we inspect<a id="_idIndexMarker1159"/> the generated <strong class="source-inline">jooq.generated.Keys</strong>, we notice the following generated keys for <strong class="source-inline">OFFICE_MASTER</strong> and <strong class="source-inline">CUSTOMER_MASTER</strong>:</p>
			<pre class="source-code">UniqueKey&lt;OfficeMasterRecord&gt; OFFICE_MASTER_PK = ...</pre>
			<pre class="source-code">ForeignKey&lt;CustomerMasterRecord, OfficeMasterRecord&gt;</pre>
			<pre class="source-code">             CUSTOMER_MASTER__OFFICE_MASTER_FK = ...</pre>
			<p>These keys are quite useful in conjunction with jOOQ navigation methods – <strong class="source-inline">fetchParent()</strong>, <strong class="source-inline">fetchChildren()</strong>, <strong class="source-inline">fetchChild()</strong>, and so on. These methods were introduced in <a href="B16833_09.xhtml#_idTextAnchor162"><em class="italic">Chapter 9</em></a>, <em class="italic">CRUD, Transactions, and Locking</em>, and here are two examples of using them to navigate our views:</p>
			<pre class="source-code">CustomerMasterRecord cmr = ctx.selectFrom(CUSTOMER_MASTER)</pre>
			<pre class="source-code"> .where(CUSTOMER_MASTER.CUSTOMER_NAME</pre>
			<pre class="source-code">  .eq("Classic Legends Inc.")).fetchSingle();      </pre>
			<pre class="source-code">OfficeMasterRecord parent = cmr.fetchParent(</pre>
			<pre class="source-code"> Keys.CUSTOMER_MASTER__OFFICE_MASTER_FK);</pre>
			<pre class="source-code">List&lt;CustomerMasterRecord&gt; children =  </pre>
			<pre class="source-code"> parent.fetchChildren(Keys.CUSTOMER_MASTER__OFFICE_MASTER_FK);</pre>
			<p>You can practice <a id="_idIndexMarker1160"/>these examples in <em class="italic">SyntheticPkKeysNavigation</em> for PostgreSQL.</p>
			<h2 id="_idParaDest-222"><a id="_idTextAnchor221"/>Synthetic unique keys</h2>
			<p>In the previous section, we used a <a id="_idIndexMarker1161"/>composite synthetic primary key built on the triad <strong class="source-inline">country</strong>, <strong class="source-inline">state</strong>, and <strong class="source-inline">city</strong>. However, if we look carefully, we notice that both views select <strong class="source-inline">postal_code</strong> as well. Since we don't have two offices in the same city, we can consider that <strong class="source-inline">postal_code</strong> (which has <strong class="source-inline">CONSTRAINT "office_postal_code_uk" UNIQUE ("postal_code")</strong> in the <strong class="source-inline">office</strong> table) is a unique key for <strong class="source-inline">office_master</strong> (of course, in reality, you have to pay attention to such assumptions; maybe the best way to represent an address is via <strong class="source-inline">BLOB</strong>, but let's continue with what we have). This means that we can use a synthetic unique key as well. By simply replacing the <strong class="source-inline">&lt;primaryKeys/&gt;</strong> tag with the <strong class="source-inline">&lt;uniqueKeys/&gt;</strong> tag, as shown here, we set up <strong class="source-inline">postal_code</strong> as a synthetic unique key:</p>
			<pre class="source-code">&lt;syntheticObjects&gt;</pre>
			<pre class="source-code"> &lt;uniqueKeys&gt;</pre>
			<pre class="source-code">  &lt;uniqueKey&gt;</pre>
			<pre class="source-code">   &lt;name&gt;office_master_uk&lt;/name&gt;</pre>
			<pre class="source-code">   &lt;tables&gt;office_master&lt;/tables&gt;</pre>
			<pre class="source-code">   &lt;fields&gt;</pre>
			<pre class="source-code">    &lt;field&gt;postal_code&lt;/field&gt;</pre>
			<pre class="source-code">   &lt;/fields&gt;</pre>
			<pre class="source-code">  &lt;/uniqueKey&gt;</pre>
			<pre class="source-code"> &lt;/uniqueKeys&gt;</pre>
			<pre class="source-code"> &lt;foreignKeys&gt;</pre>
			<pre class="source-code">  &lt;foreignKey&gt;</pre>
			<pre class="source-code">   &lt;name&gt;customer_office_master_fk&lt;/name&gt;</pre>
			<pre class="source-code">   &lt;tables&gt;customer_master&lt;/tables&gt;</pre>
			<pre class="source-code">   &lt;fields&gt;</pre>
			<pre class="source-code">    &lt;field&gt;postal_code&lt;/field&gt;</pre>
			<pre class="source-code">   &lt;/fields&gt;</pre>
			<pre class="source-code">   &lt;referencedTable&gt;office_master&lt;/referencedTable&gt;</pre>
			<pre class="source-code">   &lt;referencedFields&gt;</pre>
			<pre class="source-code">    &lt;field&gt;postal_code&lt;/field&gt;</pre>
			<pre class="source-code">   &lt;/referencedFields&gt;</pre>
			<pre class="source-code">  &lt;/foreignKey&gt;</pre>
			<pre class="source-code"> &lt;/foreignKeys&gt;</pre>
			<pre class="source-code">&lt;/syntheticObjects&gt;</pre>
			<p>The good news is <a id="_idIndexMarker1162"/>that our <strong class="source-inline">JOIN</strong> statements that rely on synthetic keys will work out of the box, even if we switched from a composite synthetic primary key to a simple synthetic unique key. The bundled code is <em class="italic">SyntheticUniqueKeysImplicitJoin</em> for PostgreSQL.</p>
			<h2 id="_idParaDest-223"><a id="_idTextAnchor222"/>Synthetic identities</h2>
			<p>As you saw earlier, jOOQ can <a id="_idIndexMarker1163"/>fetch an identity primary key after executing an insert (via <strong class="source-inline">insertInto()…returningResult(pk)</strong> or inserting an updatable record). However, not all identity columns must be primary keys as well. For instance, our <strong class="source-inline">PRODUCT</strong> table from PostgreSQL has two identity columns – one is also the primary key (<strong class="source-inline">PRODUCT_ID</strong>), while the second one is just a simple identity column (<strong class="source-inline">PRODUCT_UID</strong>):</p>
			<pre class="source-code">CREATE TABLE "product" (</pre>
			<pre class="source-code">  "product_id" BIGINT</pre>
			<pre class="source-code">               NOT NULL DEFAULT NEXTVAL ('"product_seq"'),</pre>
			<pre class="source-code">  …</pre>
			<pre class="source-code">  "product_id" BIGINT GENERATED BY DEFAULT AS IDENTITY </pre>
			<pre class="source-code">                     (START WITH 10 INCREMENT BY 10),</pre>
			<pre class="source-code">  CONSTRAINT "product"pk" PRIMARY KEY ("product_id"),</pre>
			<pre class="source-code">  ...</pre>
			<pre class="source-code">) ;</pre>
			<p>Fetching both identities via <strong class="source-inline">insertInto() … returningResult(pk)</strong> can be done quite easily:</p>
			<pre class="source-code">var result = ctx.insertInto(PRODUCT)</pre>
			<pre class="source-code">  .set(PRODUCT.PRODUCT_LIN", "Vintage Cars")</pre>
			<pre class="source-code">  .set(PRODUCT.CODE, 223113L)</pre>
			<pre class="source-code">  .set(PRODUCT.PRODUCT_NAME, "Rolls-Royce Dawn Drophead")</pre>
			<pre class="source-code">  .returningResult(PRODUCT.PRODUCT_ID, PRODUCT.PRODUCT_UID)</pre>
			<pre class="source-code">  .fetch();</pre>
			<pre class="source-code">result.get(0).value1(); // valid primary key (PRODUCT_ID)</pre>
			<pre class="source-code">result.get(0).value2(); // valid identity key (PRODUCT_UID)</pre>
			<p>There is no <a id="_idIndexMarker1164"/>surprise here, since <strong class="source-inline">returningResult()</strong> instructs jOOQ to return all columns enlisted as an argument. However, inserting a record represents a more interesting case:</p>
			<pre class="source-code">ProductRecord pr = ctx.newRecord(PRODUCT);</pre>
			<pre class="source-code">pr.setProductLine("Classic Cars");</pre>
			<pre class="source-code">pr.setCode(599302L);</pre>
			<pre class="source-code">pr.setProductName("1967 Chevrolet Camaro RS");</pre>
			<pre class="source-code">pr.insert();</pre>
			<pre class="source-code">pr.getProductId();  // valid primary key (PRODUCT_ID)</pre>
			<pre class="source-code">pr.getProductUid(); // valid identity key (PRODUCT_UID) WOW!</pre>
			<p>That's cool! Besides the identity primary key, jOOQ has also populated the record with the database-generated <strong class="source-inline">PRODUCT_UID</strong>. So, as long as the database reports a column as being an identity, jOOQ can detect it and act accordingly. </p>
			<p>Okay, let's next <a id="_idIndexMarker1165"/>focus on our Oracle schema that defines the <strong class="source-inline">PRODUCT</strong> table, like this:</p>
			<pre class="source-code">CREATE TABLE product (</pre>
			<pre class="source-code">  product_id NUMBER(10) DEFAULT product_seq.nextval </pre>
			<pre class="source-code">                        NOT NULL,</pre>
			<pre class="source-code">  ...</pre>
			<pre class="source-code">  product_uid NUMBER(10) DEFAULT product_uid_seq.nextval </pre>
			<pre class="source-code">                        NOT NULL,</pre>
			<pre class="source-code">  CONSTRAINT product_pk PRIMARY KEY (product_id),</pre>
			<pre class="source-code">  ...</pre>
			<pre class="source-code">);</pre>
			<pre class="source-code">CREATE SEQUENCE product_seq START WITH 1000000 INCREMENT BY 1;</pre>
			<pre class="source-code">CREATE SEQUENCE product_uid_seq START WITH 10 INCREMENT BY 10;</pre>
			<p>In this scenario, <strong class="source-inline">insertInto() … returningResult()</strong> works as excepted, but after inserting a <strong class="source-inline">ProductRecord</strong>, we get back only the identity primary key (<strong class="source-inline">PRODUCT_ID</strong>), while calling <strong class="source-inline">getProductUid()</strong> will return <strong class="source-inline">null</strong>. In other words, jOOQ detected only <strong class="source-inline">PRODUCT_ID</strong> as being a primary key column, while <strong class="source-inline">PRODUCT_UID</strong> was not reported by the database as being an identity column. However, here is where the jOOQ synthetic identities come to the rescue. Synthetic identities allow us to configure jOOQ to treat as formal identities those columns that are not reported by the database as being identities. In this particular case, <strong class="source-inline">PRODUCT_UID</strong> falls under this <a id="_idIndexMarker1166"/>umbrella, so here is the jOOQ-expected configuration for Maven (and standalone):</p>
			<pre class="source-code">&lt;syntheticObjects&gt;</pre>
			<pre class="source-code"> &lt;identities&gt;</pre>
			<pre class="source-code">  &lt;identity&gt;</pre>
			<pre class="source-code">   &lt;tables&gt;product&lt;/tables&gt;</pre>
			<pre class="source-code">   &lt;fields&gt;product_uid&lt;/fields&gt;</pre>
			<pre class="source-code">  &lt;/identity&gt;</pre>
			<pre class="source-code"> &lt;/identities&gt;</pre>
			<pre class="source-code">&lt;/syntheticObjects&gt;</pre>
			<p>If you have multiple tables/identities, then enlist them, separated by <strong class="source-inline">|</strong> as regular expressions. This time, after running the Code Generator and inserting a new <strong class="source-inline">ProductRecord</strong>, jOOQ fetches both <strong class="source-inline">PRODUCT_ID</strong> (check it via <strong class="source-inline">getProductId()</strong>) and <strong class="source-inline">PRODUCT_UID</strong> (check it via <strong class="source-inline">getProductUid()</strong>, which should return a valid integer). Moreover, this works for Oracle versions where formal identity columns are emulated using sequences and triggers (prior to Oracle 12c). So, another cool <a id="_idIndexMarker1167"/>feature of jOOQ has been revealed.</p>
			<p>The bundled code samples are <em class="italic">DetectIdentity</em> (for PostgreSQL) and <em class="italic">SyntheticIdentity</em> (for Oracle).</p>
			<h2 id="_idParaDest-224"><a id="_idTextAnchor223"/>Hooking computed columns</h2>
			<p>A <em class="italic">computed column</em> is a <a id="_idIndexMarker1168"/>column that cannot be written to. Its value is<a id="_idIndexMarker1169"/> computed from a given <em class="italic">expression</em>. When a column is computed on read (for instance, in <strong class="source-inline">SELECT</strong> statements) it is known as a <strong class="source-inline">VIRTUAL</strong> column (in DDL, such columns appear roughly expressed as <strong class="source-inline">… GENERATED ALWAYS AS &lt;expression&gt; VIRTUAL</strong> ). Typically, <strong class="source-inline">VIRTUAL</strong> columns don’t exist/appear in the database schema. On the other hand, a column that is computed on write (for instance, in <strong class="source-inline">INSERT</strong>, <strong class="source-inline">UPDATE</strong>, <strong class="source-inline">MERGE</strong> statements) is known as a <strong class="source-inline">STORED</strong> column (in DDL, some common syntax is <strong class="source-inline">... GENERATED ALWAYS AS &lt;expression&gt; STORED</strong>). Such columns exist/appear in your database schema.</p>
			<h3>Server side computed columns</h3>
			<p>In<a id="_idIndexMarker1170"/> this context, jOOQ 3.16 added support for <em class="italic">server side computed columns</em>. jOOQ ‘s Code Generator is capable of detecting server side computed columns and marking<a id="_idIndexMarker1171"/> them as <em class="italic">read-only</em> (https://www.jooq.org/doc/latest/manual/co<a href="http://de-generation/codegen-advanced/codegen-config-database/codegen-database-readonly-columns/">de-generation/codegen-advanced/codegen-config-database/codegen-database-readonly-columns/</a>). In other words, for your convenience, such columns are automatically excluded from DML statements and occur only in <strong class="source-inline">SELECT</strong> statements. However, jOOQ allows us to fine tune read-only columns via a bunch of settings available at <a href="https://www.jooq.org/doc/latest/manual/sql-building/column-expressions/readonly-columns/">https://www.jooq.org/doc/latest/manual/sql-building/column-expressions/readonly-columns/</a>. Moreover, jOOQ supports <em class="italic">synthetic read-only columns</em>, which<a id="_idIndexMarker1172"/> are recognized by jOOQ if we configure them via <strong class="source-inline">&lt;readonlyColumns/&gt;</strong>, <strong class="source-inline">&lt;readonlyColumn/&gt;</strong> tags (Maven). You can explore this very exciting topic in jOOQ documentation at <a href="https://www.jooq.org/doc/latest/manual/code-generation/codegen-advanced/codegen-config-database/codegen-database-synthetic-objects/codegen-database-synthetic-readonly-columns/">https://www.jooq.org/doc/latest/manual/code-generation/codegen-advanced/codegen-config-database/codegen-database-synthetic-objects/codegen-database-synthetic-readonly-columns/</a>, but for  now, let’s get back to the computed columns topic.</p>
			<p>So, not all dialects support server side computed columns or expressions based on scalar subqueries (even correlated ones), or implicit joins. jOOQ 3.17 comes with a powerful feature that covers these limitations, and this feature is known as <em class="italic">client side computed columns</em>.</p>
			<h3>Client side computed columns</h3>
			<p>Check out the<a id="_idIndexMarker1173"/> following<a id="_idIndexMarker1174"/> configuration of a client side computed column (<strong class="source-inline">VIRTUAL</strong> alike):</p>
			<pre class="source-code">&lt;database&gt;</pre>
			<pre class="source-code"> …</pre>
			<pre class="source-code"> &lt;!-- Prepare the synthetic keys --&gt;</pre>
			<pre class="source-code"> &lt;syntheticObjects&gt;                                </pre>
			<pre class="source-code">  &lt;columns&gt;</pre>
			<pre class="source-code">   &lt;column&gt;</pre>
			<pre class="source-code">    &lt;name&gt;REFUND_AMOUNT&lt;/name&gt;                                        </pre>
			<pre class="source-code">    &lt;tables&gt;BANK_TRANSACTION&lt;/tables&gt;</pre>
			<pre class="source-code">    &lt;type&gt;DECIMAL(10,2)&lt;/type&gt;</pre>
			<pre class="source-code">   &lt;/column&gt;                                     </pre>
			<pre class="source-code">  &lt;/columns&gt;</pre>
			<pre class="source-code"> &lt;/syntheticObjects&gt; </pre>
			<pre class="source-code">                                    </pre>
			<pre class="source-code"> &lt;!-- Now tell the code generator </pre>
			<pre class="source-code">      how to compute the values --&gt;</pre>
			<pre class="source-code"> &lt;forcedTypes&gt;</pre>
			<pre class="source-code">  &lt;forcedType&gt;</pre>
			<pre class="source-code">   &lt;generator&gt;</pre>
			<pre class="source-code">    ctx -&gt; payment().INVOICE_AMOUNT.minus(</pre>
			<pre class="source-code">           DSL.sum(TRANSFER_AMOUNT))</pre>
			<pre class="source-code">   &lt;/generator&gt;</pre>
			<pre class="source-code">   &lt;includeExpression&gt;REFUND_AMOUNT&lt;/includeExpression&gt;</pre>
			<pre class="source-code">  &lt;/forcedType&gt;                                        </pre>
			<pre class="source-code"> &lt;/forcedTypes&gt;  </pre>
			<pre class="source-code">&lt;/database&gt;</pre>
			<p>Because the<a id="_idIndexMarker1175"/> forced type matches a synthetic column (<strong class="source-inline">REFUND_AMOUNT</strong>), jOOQ<a id="_idIndexMarker1176"/> semantics stands for a <strong class="source-inline">VIRTUAL</strong> computed column. So, the column does not exist in the database schema, but the computation (here, an implicit join, but correlated subqueries is also a supported option) will be automatically present in all of your <strong class="source-inline">SELECT</strong> statements containing this column. In the bundled code available for SQL Server, <em class="italic">SyntheticComputedColumns</em>, you can see a query sample that uses the virtual column, <strong class="source-inline">BANK_TRANSACTION.REFUND_AMOUNT</strong>.</p>
			<p>Now, check this out:</p>
			<pre class="source-code">&lt;database&gt;</pre>
			<pre class="source-code"> &lt;!-- Tell the code generator how to </pre>
			<pre class="source-code">      compute the values for an existing column --&gt;</pre>
			<pre class="source-code"> &lt;forcedTypes&gt;</pre>
			<pre class="source-code">  &lt;forcedType&gt;</pre>
			<pre class="source-code">   &lt;generator&gt;</pre>
			<pre class="source-code">     ctx -&gt; DSL.concat(OFFICE.COUNTRY, DSL.inline(“, “), </pre>
			<pre class="source-code">            OFFICE.STATE, DSL.inline(“, “), OFFICE.CITY)</pre>
			<pre class="source-code">   &lt;/generator&gt;</pre>
			<pre class="source-code">   &lt;includeExpression&gt;</pre>
			<pre class="source-code">    OFFICE.ADDRESS_LINE_FIRST</pre>
			<pre class="source-code">   &lt;/includeExpression&gt;</pre>
			<pre class="source-code">  &lt;/forcedType&gt;                                                          </pre>
			<pre class="source-code"> &lt;/forcedTypes&gt;  </pre>
			<pre class="source-code">&lt;/database&gt;</pre>
			<p>This time, the forced<a id="_idIndexMarker1177"/> type matches an actual column (<strong class="source-inline">OFFICE.ADDRESS_LINE_FIRST</strong>), so jOOQ<a id="_idIndexMarker1178"/> applies the semantics of a <strong class="source-inline">STORED</strong> computed column. In other words, the DML statements will be transformed to reflect the correct computation of the value, which will be written to your schema. You can check out an example in the bundled code, <em class="italic">StoredComputedColumns</em>, available for SQL Server. Moreover, if you are able to, take the time to read this great article: <a href="https://blog.jooq.org/create-dynamic-views-with-jooq-3-17s-new-virtual-client-side-computed-columns/">https://blog.jooq.org/create-dynamic-views-with-jooq-3-17s-new-virtual-client-side-computed-columns/</a>.</p>
			<h1 id="_idParaDest-225"><a id="_idTextAnchor224"/>Overriding primary keys</h1>
			<p>Let's consider the following <a id="_idIndexMarker1179"/>schema fragment (from PostgreSQL):</p>
			<pre class="source-code">CREATE TABLE "customer" (</pre>
			<pre class="source-code">  "customer_number" BIGINT NOT NULL </pre>
			<pre class="source-code">                         DEFAULT NEXTVAL ('"customer_seq"'),</pre>
			<pre class="source-code">  "customer_name" VARCHAR(50) NOT NULL, </pre>
			<pre class="source-code">  ... </pre>
			<pre class="source-code">  CONSTRAINT "customer_pk" PRIMARY KEY ("customer_number"), </pre>
			<pre class="source-code">  CONSTRAINT "customer_name_uk" UNIQUE ("customer_name") </pre>
			<pre class="source-code">  ... </pre>
			<pre class="source-code">); </pre>
			<pre class="source-code">CREATE TABLE "department" ( </pre>
			<pre class="source-code">  "department_id" SERIAL NOT NULL, </pre>
			<pre class="source-code">  "code" INT NOT NULL, </pre>
			<pre class="source-code">  ... </pre>
			<pre class="source-code">  CONSTRAINT "department_pk" PRIMARY KEY ("department_id"), </pre>
			<pre class="source-code">  CONSTRAINT "department_code_uk" UNIQUE ("code") </pre>
			<pre class="source-code">  ... </pre>
			<pre class="source-code">);</pre>
			<p>The following is an example of updating a <strong class="source-inline">CUSTOMER</strong>: </p>
			<pre class="source-code">CustomerRecord cr = ctx.selectFrom(CUSTOMER)</pre>
			<pre class="source-code">  .where(CUSTOMER.CUSTOMER_NAME.eq("Mini Gifts ..."))</pre>
			<pre class="source-code">  .fetchSingle();</pre>
			<pre class="source-code">cr.setPhone("4159009544");</pre>
			<pre class="source-code">cr.store();   </pre>
			<p>Here is an example of updating a <strong class="source-inline">DEPARTMENT</strong>:</p>
			<pre class="source-code">DepartmentRecord dr = ctx.selectFrom(DEPARTMENT)</pre>
			<pre class="source-code">  .where(DEPARTMENT.DEPARTMENT_ID.eq(1))</pre>
			<pre class="source-code">  .fetchSingle();</pre>
			<pre class="source-code">dr.setTopic(new String[] {"promotion", "market", "research"});</pre>
			<pre class="source-code">dr.store();</pre>
			<p>From <a href="B16833_09.xhtml#_idTextAnchor162"><em class="italic">Chapter 9</em></a>, <em class="italic">CRUD, Transaction, and Locking</em>, we know how <strong class="source-inline">store()</strong> works; therefore, we<a id="_idIndexMarker1180"/> know that the generated SQLs will rely on the <strong class="source-inline">CUSTOMER</strong> primary key and the <strong class="source-inline">DEPARTMENT</strong> primary key (the same behavior applies to <strong class="source-inline">update()</strong>, <strong class="source-inline">merge()</strong>, <strong class="source-inline">delete()</strong>, and <strong class="source-inline">refresh()</strong>). For instance, <strong class="source-inline">cr.store()</strong> executes the following <strong class="source-inline">UPDATE</strong>:</p>
			<pre class="source-code">UPDATE "public"."customer" SET "phone" = ?</pre>
			<pre class="source-code"><strong class="bold">WHERE "public"."customer"."customer_number" = ?</strong></pre>
			<p>Since <strong class="source-inline">CUSTOMER_NUMBER</strong> is the primary key of <strong class="source-inline">CUSTOMER</strong>, jOOQ uses it for appending the predicate to this <strong class="source-inline">UPDATE</strong>.</p>
			<p>On the other hand, <strong class="source-inline">dr.store()</strong> executes this <strong class="source-inline">UPDATE</strong>:</p>
			<pre class="source-code">UPDATE "public"."department" SET "topic" = ?::text[]</pre>
			<pre class="source-code"><strong class="bold">WHERE ("public"."department"."name" = ?</strong></pre>
			<pre class="source-code"><strong class="bold">       AND "public"."department"."phone" = ?)</strong></pre>
			<p>Something doesn't look right here, since our schema reveals that the primary key of <strong class="source-inline">DEPARTMENT</strong> is <strong class="source-inline">DEPARTMENT_ID</strong>, so why does jOOQ use here a composite predicate containing <strong class="source-inline">DEPARTMENT_NAME</strong> and <strong class="source-inline">DEPARTMENT_PHONE</strong>? This may look confusing, but the answer is quite simple. We actually defined a synthetic primary key (<strong class="source-inline">department_name</strong> and <strong class="source-inline">department_phone</strong>), which we reveal here:</p>
			<pre class="source-code">&lt;syntheticObjects&gt;</pre>
			<pre class="source-code"> &lt;primaryKeys&gt;</pre>
			<pre class="source-code">  &lt;primaryKey&gt;</pre>
			<pre class="source-code">   &lt;name&gt;synthetic_department_pk&lt;/name&gt;</pre>
			<pre class="source-code">   &lt;tables&gt;department&lt;/tables&gt;</pre>
			<pre class="source-code">   &lt;fields&gt;</pre>
			<pre class="source-code">    &lt;field&gt;name&lt;/field&gt;</pre>
			<pre class="source-code">    &lt;field&gt;phone&lt;/field&gt;</pre>
			<pre class="source-code">   &lt;/fields&gt;</pre>
			<pre class="source-code">  &lt;/primaryKey&gt;</pre>
			<pre class="source-code"> &lt;/primaryKeys&gt;</pre>
			<pre class="source-code">&lt;/syntheticObjects&gt;</pre>
			<p>That's cool! So, jOOQ has used the synthetic key in place of the schema primary key. We can say that we overrode the scheme's primary key with a synthetic key.  </p>
			<p>Let's do it again! For instance, let's suppose that we want to instruct jOOQ to use the <strong class="source-inline">customer_name</strong> unique key for <strong class="source-inline">cr.store()</strong> and the <strong class="source-inline">code</strong> unique key for <strong class="source-inline">dr.store()</strong>. This means <a id="_idIndexMarker1181"/>that we need the following configuration:</p>
			<pre class="source-code">&lt;syntheticObjects&gt;</pre>
			<pre class="source-code"> &lt;primaryKeys&gt;</pre>
			<pre class="source-code">  &lt;primaryKey&gt;</pre>
			<pre class="source-code">   &lt;name&gt;synthetic_customer_name&lt;/name&gt;</pre>
			<pre class="source-code">   &lt;tables&gt;customer&lt;/tables&gt;</pre>
			<pre class="source-code">   &lt;fields&gt;</pre>
			<pre class="source-code">    &lt;field&gt;customer_name&lt;/field&gt;</pre>
			<pre class="source-code">   &lt;/fields&gt;</pre>
			<pre class="source-code">  &lt;/primaryKey&gt;</pre>
			<pre class="source-code">  &lt;primaryKey&gt;</pre>
			<pre class="source-code">   &lt;name&gt;synthetic_department_code&lt;/name&gt;</pre>
			<pre class="source-code">   &lt;tables&gt;department&lt;/tables&gt;</pre>
			<pre class="source-code">   &lt;fields&gt;</pre>
			<pre class="source-code">    &lt;field&gt;code&lt;/field&gt;</pre>
			<pre class="source-code">   &lt;/fields&gt;</pre>
			<pre class="source-code">  &lt;/primaryKey&gt;</pre>
			<pre class="source-code"> &lt;/primaryKeys&gt;</pre>
			<pre class="source-code">&lt;/syntheticObjects&gt;</pre>
			<p>This configuration <a id="_idIndexMarker1182"/>overrides the schema defaults, and the generated SQL becomes the following:</p>
			<pre class="source-code">UPDATE "public"."customer" SET "phone" = ?</pre>
			<pre class="source-code"><strong class="bold">WHERE "public"."customer"."customer_name" = ?</strong></pre>
			<pre class="source-code">UPDATE "public"."department" SET "topic" = ?::text[]</pre>
			<pre class="source-code"><strong class="bold">WHERE "public"."department"."code" = ?</strong></pre>
			<p>Cool, right?! The complete example is named <em class="italic">OverridePkKeys</em> for PostgreSQL.</p>
			<h1 id="_idParaDest-226"><a id="_idTextAnchor225"/>Summary </h1>
			<p>I hope you enjoyed this short but comprehensive chapter about jOOQ keys. The examples from this chapter covered popular aspects of dealing with different kinds of keys, from unique/primary keys to jOOQ-embedded and synthetic keys. I really hope that you don't stop at these examples and get curious to deep dive into these amazing jOOQ features – for instance, an interesting topic that deserves your attention is read-only columns: <a href="https://www.jooq.org/doc/dev/manual/sql-building/column-expressions/readonly-columns/">https://www.jooq.org/doc/dev/manual/sql-building/column-expressions/readonly-columns/</a>.</p>
			<p>In the next chapter, we will tackle pagination and dynamic queries.</p>
		</div>
	</body></html>