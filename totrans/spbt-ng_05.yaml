- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building APIs with Spring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, you learned about the concepts and advantages of PostgreSQL
    and set it up on your local machine using the installer or the Docker container.
    You know how to configure **Spring Data Java Persistence API** (**Spring Data
    JPA**) on our project and use its provided repositories to perform **Create, Read,
    Update**, and **Delete** (**CRUD**) operations on our database with less boilerplate
    code. Lastly, you have also learned to connect your application with PostgreSQL
    using the **Java Database Connectivity** (**JDBC**) driver and Spring Data JPA.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will create your Spring Boot **application programming interface**
    (**API**) project; we will focus on coding, making our models, and adding controllers
    and services to develop our endpoints. We will also add **Remote Dictionary Server**
    (**Redis**) for caching to help improve our application performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Starting the server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding models
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding controllers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding Redis for caching
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are no technical requirements for this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The link to the finished version of this chapter can be found here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Spring-Boot-and-Angular/tree/main/Chapter-05/superheroes](https://github.com/PacktPublishing/Spring-Boot-and-Angular/tree/main/Chapter-05/superheroes)'
  prefs: []
  type: TYPE_NORMAL
- en: Starting the server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will now attempt to run our Spring Boot application on
    our server but first, let’s have a recap of the previous chapter: we learned how
    to configure Spring Data JPA and connect our application to our PostgreSQL database,
    and—most importantly—we have installed all of the needed dependencies in our application.
    These are all prerequisites before running the Spring Boot application.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following examples, we will be using an application named `spring-boot-superheroes`.
    We will generate a new Spring Boot application using **Spring Initializr** with
    the same dependencies. Throughout developing our application, we will also show
    you several ways to write the different parts of your API, such as how to write
    models, services, and controllers. These are the most common ways used now in
    the industry. Still, first things first: let’s proceed with running our Spring
    Boot application.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We assume that you have already generated your Spring Boot application with
    the needed dependencies. However, if you have missed this part or are unsure whether
    all dependencies are included on your generated project, let’s list again all
    the dependencies we installed in the previous chapter, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Spring Data JPA**: Dependency for adding Spring Data JPA used for built-in
    data store-related implementation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**PostgreSQL Driver**: A JDBC and **Reactive Relational Database Connectivity**
    (**R2DBC**) driver that will allow the connection of Java applications to the
    PostgreSQL database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**H2 Database**: An in-memory database that supports JDBC API and R2DBC access;
    this is commonly used for unit testing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you have successfully initialized your application with the listed dependencies,
    open your project in your preferred **integrated development environment** (**IDE**);
    we will be using IntelliJ for Spring Boot in the following examples. Then, proceed
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Expand the project folder; we will see several folders inside, as indicated
    in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: "![Figure 5.1 – Project structure of \uFEFFthe Spring Boot application](img/B18159_05_01.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 5.1 – Project structure of the Spring Boot application
  prefs: []
  type: TYPE_NORMAL
- en: We can see the files and folders in our Spring Boot application in the preceding
    screenshot. We can find our main class, named `SuperHeroesApplication`, under
    `src/main/java`. This main class will be used in running our application on the
    server.
  prefs: []
  type: TYPE_NORMAL
- en: '`application.properties` is also an important file that we need to configure,
    as this is where all the properties are placed that are necessary for connecting
    to our database.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `application.properties` file, and we should set the following configuration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This configuration will allow us to connect to our **PostgreSQL database** on
    our local machine. Remember that the database should exist on our PostgreSQL servers;
    otherwise, our application will not run successfully. If you haven’t created your
    database, open **pgAdmin** and enter your master password; on the left panel,
    expand the **Servers** section.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will see the PostgreSQL instance on your local machine. Right-click on
    the instance, select `postgres` user. This will now access the databases on our
    server, as illustrated in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.2 – Accessing PostgreSQL server using pgAdmin](img/B18159_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.2 – Accessing PostgreSQL server using pgAdmin
  prefs: []
  type: TYPE_NORMAL
- en: 'After successfully accessing the server, right-click on **Database**, select
    **Create**, and click on **Database**; this will open the following modal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.3 – Creating a database](img/B18159_05_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.3 – Creating a database
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding screenshot, we named our database `SpringDevDB` and set the
    `postgres` user value in the **Owner** field. Click **Save**, and our database
    is all set in our server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our Spring Boot application is now ready to run on our server; in your IntelliJ
    IDE, click on **Add Configuration**, found on the upper-right side of the panel.
    This will open the modal where we will configure our entry point to run our application,
    as illustrated in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.4 – Adding configuration for Spring Boot](img/B18159_05_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.4 – Adding configuration for Spring Boot
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on `SuperheroesApplication`, and this will automatically fill the program
    arguments with the correct fully qualified name of the class, as illustrated in
    the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.5 – Configuration for application](img/B18159_05_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.5 – Configuration for application
  prefs: []
  type: TYPE_NORMAL
- en: Click on **Apply** and then click **OK** to save the configuration changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the upper-right panel of the IDE, select the created configuration and run
    the project by clicking on the green play icon. The application will run on the
    installed Tomcat server on the default port `8080`; we can also use the terminal
    to check whether the Spring Boot project has successfully started on the server.
    You can see the process running in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.6 – Spring Boot logs](img/B18159_05_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.6 – Spring Boot logs
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding screenshot, we can see that our application has started successfully;
    we are also connected to our PostgreSQL database, and we can now start writing
    our code.
  prefs: []
  type: TYPE_NORMAL
- en: We will now try to create our application models in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Adding models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will now write code for our application, and the first thing
    we will create is models. In simple terms, models are the object of our application;
    the models will serve as our entities and will define our tables in the database.
  prefs: []
  type: TYPE_NORMAL
- en: Once we create models and run the application, this will also generate tables
    in our database automatically with the help of annotations, which will also be
    discussed throughout this example.
  prefs: []
  type: TYPE_NORMAL
- en: Creating models with DTOs and Lombok
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will first show you how to write models using Lombok and **data transfer
    objects** (**DTOs**). First, we will discuss DTOs.
  prefs: []
  type: TYPE_NORMAL
- en: DTOs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: DTOs are responsible for carrying data between processes to reduce the number
    of method calls. DTOs are **plain old Java objects** (**POJOs**) that commonly
    consist of data accessors.
  prefs: []
  type: TYPE_NORMAL
- en: 'DTOs are very useful for creating representations of our entities to have views
    for clients without affecting the pattern and design. Let’s have an example use
    case for DTOs. You can see this here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we have created an example domain model that will represent
    entities in our database. There are instances where we would not want to include
    some information on sending data to the client, which is where DTOs would enter
    the scene. We will create two DTOs for the blog model used for getting and creating
    data, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example DTO, we have created a `BlogDTO` class that will be
    used for retrieving data; our objective is to hide the author’s name, thus not
    including it as a field in the DTO. The code is illustrated in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The next DTO we have created is `BlogCreationDTO`, which will create a new blog.
    We can see that all fields necessary to create a new blog are included.
  prefs: []
  type: TYPE_NORMAL
- en: The created DTOs will be used for our controllers in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Lombok
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Lombok** is a third-party library used to reduce boilerplate code using annotations.
    Lombok allows us to avoid repetitive code, especially in creating models such
    as getter and setter methods.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s have a comparison between a model without Lombok and a model using Lombok,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code example, we have created a blog model without using Lombok;
    we can see that we have created a getter and setter method for each field, and
    we have also created constructors with and without arguments. The code in this
    example is still manageable.
  prefs: []
  type: TYPE_NORMAL
- en: Still, if our model is required to contain more fields, we need to create setters
    and getters for the new fields, creating more boilerplate code inside our model
    and sacrificing the maintainability of our code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The class and annotations should be as shown in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding screenshot, we have used Lombok to create our blog model, and
    we can see that a considerable amount of code has been omitted from the model.
    The `@Data` annotation generates setter and getter methods, a `toString()` method,
    and a constructor with required arguments.
  prefs: []
  type: TYPE_NORMAL
- en: '`@AllArgsConstructor` and `@NoArgsConstructor` are accountable for the constructor
    with all and no arguments.'
  prefs: []
  type: TYPE_NORMAL
- en: The advantage of using Lombok is evident in the previous examples; it makes
    code easier to read and less error-prone, promotes easy cleanup and maintainability,
    and gives effortless logging and debugging.
  prefs: []
  type: TYPE_NORMAL
- en: Model application
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have learned about the importance of DTO and Lombok, let’s go back
    to our Spring Boot application. Under the `java` folder, right-click on the package
    and select **Package**. This will display a small window that will allow you to
    enter a new package.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we will create a new package named `antiHero`. After completing
    the new package, we will create two new packages under `antiHero`, calling them
    `dto` and `entity`. You can see the packages in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.7 – Project structure after the creation of packages](img/B18159_05_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.7 – Project structure after the creation of packages
  prefs: []
  type: TYPE_NORMAL
- en: 'Our project structure should now look just as it is presented in the preceding
    screenshot. Let’s first create our entity; right-click on the entity package we
    have created, and then click on `AntiHeroEntity` and click on the **OK** button.
    The process is illustrated in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.8 – Creating an entity](img/B18159_05_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.8 – Creating an entity
  prefs: []
  type: TYPE_NORMAL
- en: 'We will see a newly generated class under the `entity` package, and it will
    have the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'An entity was automatically generated with the `@Entity` and `@Table` annotations
    that will be used to identify this model as an object in the database. The current
    code will have some issues, stating that the entity does not have a **primary
    key** (**PK**); in this case, we will add the following to our model:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@Data`: Lombok annotations that will set the getter and setter methods, the
    `toString()` method, and `@RequiredArgsConstructor`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@AllArgsConstructor`: Lombok annotations for generating a constructor for
    the model with all fields as arguments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@NoArgsConstructor`: Lombok annotations for generating a constructor for the
    model with no arguments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@Id`: Found under `javax.persistence.*`, this will determine the model’s PK.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@GeneratedValue`: Used on the PK to determine which generation type will be
    used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@NotNull`: Found under `javax.validation.constraints` and validates that a
    specific field cannot be null.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The dependency should be installed by adding the following code to `pom.xml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: After adding the dependency to `pom.xml`, right-click on your project and select
    **Maven** | **Reload project** to install the new dependency.
  prefs: []
  type: TYPE_NORMAL
- en: 'After successfully adding the Lombok annotations, PK, validations, and fields
    to our model, we will have the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'After adding all the preceding packages, we can now start writing our class
    and the annotations, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code block, we can see that we have added a PK of the `UUID`
    type; this will be automatically generated once we insert new anti-hero data into
    our database. The type is defined using the `@GeneratedValue` annotation, where
    we have also indicated that the strategy will be using an auto generator. We have
    also added several fields that will be used to store the anti-hero information.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have successfully created our entity; now, we will create a DTO for the
    anti-hero entity. Right-click on the `dto` package, select `AntiHeroDto`. After
    successfully creating the DTO, we will place the following code into it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code example, we have added fields that we only want to display
    as we send the anti-hero data to the client; in this case, we have removed the
    `createdAt` field in our DTO. We have also added `@Getter` and `@Setter` annotations
    to generate getter and setter methods for our DTO, and lastly, we have also added
    `@NotNull` validation to match our constraint with the entity.
  prefs: []
  type: TYPE_NORMAL
- en: We have successfully created our DTO and models with Lombok in our application.
    In the next section, we will make our services responsible for the CRUD functionalities
    of our Spring Boot application.
  prefs: []
  type: TYPE_NORMAL
- en: Writing services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will now write the services for our application, but first,
    let’s discuss the primary purpose of services in Spring Boot. Services are classes
    where we place all of our business logic; this is where we will write our CRUD
    functionalities with the help of JPA repositories. In this case, we will not only
    make our service class but will also create our JPA repository.
  prefs: []
  type: TYPE_NORMAL
- en: JPA repository
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As discussed in [*Chapter 4*](B18159_04.xhtml#_idTextAnchor079), *Setting Up
    the Database and Spring Data JPA*, the JPA repository is a widely used specification
    for managing relational data in Java applications. It helps develop Spring by
    reducing boilerplate code by not implementing read and write operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is simple to create a JPA repository in Spring Boot; having said that, the
    JPA library provides classes such as `CrudRepository` that we can use to extend
    our classes. Let’s make one in our Spring Boot application example. Proceed as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click on our `antiHero` package, select **New**, and click on the **Package**
    option.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new package named `repository`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After creating the new package, right-click on the `repository` package, select
    **New**, and click on the **Class** option.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As the small modal pops up, switch to the `AntiHeroRepository`. The following
    code will be generated:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We have created our interface, but this is just a simple interface. We will
    extend our interface with the `CrudRepository` class to convert it to a JPA repository,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '`AntiHeroRepository`, as we have already extended it with `CrudRepository<Type,
    ID>`, will have methods that have the following functionalities:'
  prefs: []
  type: TYPE_NORMAL
- en: Persisting, updating, and deleting one of the blog entities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding one or multiple blogs by their PKs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Counting all blogs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Validating whether a single blog exists
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We have successfully created our JPA repository; our next step is to do our
    service. Our goal is to create a service that will have the capability to get
    an entire list, get a single database in a PK, insert new data, update selected
    data, and delete data. We can achieve this through the following methods provided
    by the JPA repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '`findAll()`: Gets all the existing data in a specific entity'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`findById(Id)`: Finds a particular database by PK'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`save()`: Inserts new data in the table'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`save(data)`: Updates existing data in the table'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`deleteById(id)`: Deletes specific data in the table by PK'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now that we have successfully identified the methods we need for our service,
    let’s next create our service. Right-click on the `antiHero` package and create
    a new package named `service`; after creating the new package, create a new class
    under the `service` package called `AntiHeroService`, and we will place the following
    methods inside the service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s discuss the preceding code; we have added several methods to our service,
    and these are explained in more detail here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Iterable<AntiHeroEntity> findAllAntiHeroes()`: This method calls `findAll()`
    from `AntiHeroRepository`, which returns an `Iterable` instance of `AntiHeroEntity`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AntiHeroEntity findAntiHeroById(UUID id)`: This method calls `findById(id)`
    from `AntiHeroRepository`, which returns a single `AntiHeroEntity` instance based
    on the `Id` value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`removeAntiHeroById(UUID id)`: This method calls `deleteById(id)` from `AntiHeroRepository`,
    which deletes a single `AntiHeroEntity` instance based on the `Id` value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void AntiHeroEntity addAntiHero(AntiHeroEntity antiHero)`: This method calls
    `save()` from `AntiHeroRepository` and inserts a new `AntiHeroEntity` instance
    in the database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void updateAntiHero(UUID id, AntiHeroEntity antiHero)`: This method calls
    `save(antiHero)` from `AntiHeroRepository`, which updates a specific `AntiHeroEntity`
    instance in the database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After successfully adding the method for our service, we will add `@AllArgsConstructor`
    and `@Service` annotations to `AntiHeroService`. `@AllArgsConstructor` is an annotation
    from Lombok that will generate a constructor that requires one argument of each
    field; in our example, this will produce the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This will now allow the wiring of our `AntiHeroRepository` dependency on our
    service.
  prefs: []
  type: TYPE_NORMAL
- en: The `@Service` annotation, on the other hand, is functional when we want Spring
    Context to autodetect classes based on their classification.
  prefs: []
  type: TYPE_NORMAL
- en: We have now successfully created our service with CRUD methods, but what if
    something went wrong as we call our service? For example, the **identifier** (**ID**)
    of the anti-hero we have passed may not exist. We would want to catch the error
    and return an understandable message to the user. Now, we will create runtime
    exception handling for our service.
  prefs: []
  type: TYPE_NORMAL
- en: Runtime exceptions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Runtime exceptions** are also known as unchecked exceptions. These are programming
    errors and will happen upon the current execution of our application. This should
    be prevented directly by the developers.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Some known runtime exceptions are listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`IndexOutOfBoundsException`: This exception occurs when we access an index
    of an array string or an iterable that is out of range, as illustrated in the
    following code snippet:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`IllegalArgumentException`: This exception occurs when a method has been passed
    by an illegal argument, as illustrated in the following code snippet:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`NullPointerException`: This exception occurs when a variable is accessed that
    does not point to any object or is simply null, as illustrated in the following
    code snippet:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'These are just common runtime exceptions that we use in our application; we
    can also create runtime exceptions using the `RunTimeException` class. In this
    example, let’s create a `NotFoundException` runtime exception that we will use
    to get a non-existent ID. Proceed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Under the `main` package, create a new package named `exception`; after successfully
    creating the package, create a class named `NotFoundException`. We will extend
    our created class with the `RunTimeException` class and will add the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding code snippet, we have declared several methods with `NotFoundException`
    with different arguments; having successfully created our custom exception, we
    can now use it on our service.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go back to `AntiHeroService`, and we will add the following method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding code example, we have created a new method named `findOrThrow()`;
    this is also calling the `findById()` method. The only difference is that it checks
    whether the given ID exists on the database; otherwise, it will throw something
    based on our code. In this case, we would want to throw a `NotFoundException`
    runtime exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'After this, we can use it now on `findAntiHeroById()` by replacing `findById()`
    with the `findOrThrow()` method and also add it to the `updateAntiHero()` and
    `deleteAntiHero()` methods to check whether the data exists before updating or
    deleting it. The code to accomplish this is illustrated here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We have now successfully created our service for our application. The next section
    will discuss how to make controllers and define endpoints in our code.
  prefs: []
  type: TYPE_NORMAL
- en: Adding controllers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This section will now discuss the use of controllers and how to create them
    in our application. **Controllers** are responsible for intercepting incoming
    requests and converting the payload of the request for the internal structure
    of the data; this is also where we will define our endpoint paths that will be
    available for access for our frontend applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'In creating controllers, we will use several annotations, as described here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@RestController`: This is a specialized form of the `@Controller` annotation;
    compared to using the `@Controller` annotation, it already includes both the `@Controller`
    and `@ResponseBody` annotation, not needing to specify the `@ResponseBody` annotation
    on each method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@RequestMapping`: This is an annotation used to map **HyperText Transfer Protocol**
    (**HTTP**) requests to the methods of **REpresentational State Transfer** (**REST**)
    controllers. It is also where we define a base path for the controller.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@GetMapping`: This maps HTTP `GET` requests on a method; the annotation is
    a shortcut for `@RequestMapping(method =` `RequestMethod.GET)`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@PutMapping`: This maps HTTP `PUT` requests on a method; the annotation is
    a shortcut for `@RequestMapping(method =` `RequestMethod.PUT)`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@PostMapping`: This maps HTTP `POST` requests on a method; the annotation
    is a shortcut for `@RequestMapping(method =` `RequestMethod.POST`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@DeleteMapping`: This maps HTTP `DELETE` requests on a method; the annotation
    is a shortcut for `@RequestMapping(method =` `RequestMethod.DELETE)`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@PathVariable`: This annotation is used to get the value of endpoint parameters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@Valid`: This annotation is used to check the validity of an object; it is
    commonly used on the request body to check whether a passed request is a valid
    object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have successfully identified the annotations we will use for our controller.
    We can now create our controller. Under the `antiHero` package, create a new package
    named `controller`, and after completing the `controller` package, create a new
    class called `AntiHeroController`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `AntiHeroController` class, we will use the `@AllArgsConstructor`, `@RestController`,
    and `@RequestMapping` annotations, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: Our controller is now configured; the next step is to place our dependencies
    inside our controller. We have used the `@AllArgsContructor` annotation. We don’t
    need to create a constructor method with the parameters; we only need to define
    dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: First, we will determine the `AntiHeroService` class where all our CRUD logic
    is baked. The next one is `ModelMapper`; this is important, seeing as we need
    to convert our entity into a DTO when we use it as a response, and vice versa
    if we want to read an object from a request body. `ModelMapper` will easily map
    the values of an entity to a DTO object with the same property.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install the dependency, we just need to add the following code to our `pom.xml`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'After successfully adding the `ModelMapper` dependency, we need to define our
    `ModelMapper` dependency as a Bean in our configuration to use it on our application.
    To achieve this, we will create a new package named `config` under the `main`
    package, and we will create a new class called `ModelMapperConfig`. After creating
    a new class, we will add a new method annotated with `@Bean` and return a new
    instance of `ModelMapper`. The code is illustrated in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Our configuration is all done, and now, we can add `AntiHeroService` and `ModelMapper`
    to our controller, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'We now have our controllers with the needed dependencies. Now, let’s create
    two functions that will convert our entity into a DTO, or vice versa. As mentioned
    a while ago, we will be using the `ModelMapper` dependency to make these methods,
    and in this case, we will add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: We have created two functions in the preceding code example. First, we created
    the `convertToDto()` method, which will convert the given `AntiHeroEntity` instance
    into an `AntiHeroDto` instance, for which we have used the `map()` method from
    `ModelMapper` to map the entity’s values. The second function is the `convertToEntity()`
    method, which converts the DTO into an entity.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can create mappings for our CRUD methods. Let’s first start a method
    that will return a specific entity base on the `id` value; we will use the `@GetMapping`
    annotation to identify that this will use a `GET` request, and we will add `/{id}`
    as a parameter to indicate that we can pass the entity ID as a dynamic parameter
    in the endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: 'In creating the method, we will use the `@PathVariable` annotation to get the
    value of `/{id}` in the endpoint and define it as a `UUID` type. Lastly, we will
    call the `service.findAntiHeroById()` function under `AntiHeroService` and pass
    the retrieved ID to get the entity in the database, and we will use the `convertToDto()`
    function to convert it to a DTO. The code is illustrated in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: Now, to create the `create` mapping, we will use the `@PostMapping` annotation
    to identify that this will use a `POST` request, we will use the `@RequestBody`
    annotation to get the object on the request body, and we can also use the `@Valid`
    annotation to check whether the object is a valid entity.
  prefs: []
  type: TYPE_NORMAL
- en: 'In creating the function, we will call the `convertToEntity()` method to convert
    the object into an entity, and we will call the `service.addAntiHero()` method
    to insert the converted entity into the database. The code is illustrated in the
    following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: The next thing we need to create is the `PUT` mapping. We will use the `@PutMapping`
    annotation to identify that this will use a `PUT` request, the same as how we
    created the `GET` mapping. We will add `/{id}` as a parameter, and we will also
    use the `@RequestBody` annotation to get the object on the request body and the
    `@PathVariable` annotation to get the value of `id` in the parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'In implementing the function, we will also call the `convertToEntity()` method
    and call the `service.updateAntiHero(id, entity)` method to update the specific
    entity with the DTO values. The code is illustrated in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: Next, we’ll create `DELETE` mapping. We will use the `@DeleteMapping` annotation
    to identify that this will use a `DELETE` request. We will also add `/{id}` as
    a parameter to receive the ID of the entity we need to delete, and we will add
    the `@PathVariable` annotation to get the value of `id`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement the method, we simply call the `service.removeAntiHeroById()`
    method to delete the specific entity in the database, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'And lastly, we need to create a method that will return all the entities in
    the database. One way we can implement this is using `StreamSupport` to convert
    our retrieved list into a stream and convert each object into a DTO, but first,
    we will create a method that returns a type of `List<AntiHeroDto>` with the `@GetMapping`
    annotation. After completing the method, we will now call the `service.findAllAntiHeroes()`
    method to get the entities in the database. Since this returns to an `Iterable`
    instance, we will convert it into a stream and transform it into a list using
    `Collectors.toList()`. The code is illustrated in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'After successfully retrieving and converting the data into a list, we want
    each object converted into a DTO. We can achieve this by converting the list into
    a stream. Call the `convertToDto()` method and convert it to a list again, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'We will return the converted list in response, and our method will now look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'We have successfully created mappings on our controller, and our code should
    look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: We have completed our Spring Boot application, we have created our models and
    DTO that defines the structure of our object, we have built services that are
    responsible for the business logic, and we have created controllers that map the
    HTTP requests in our applications, so our endpoint will work as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Still, we can improve our backend in terms of performance, and we can do this
    with caching mechanisms. In the next section, we will discuss the concepts and
    application of Redis.
  prefs: []
  type: TYPE_NORMAL
- en: Adding Redis for caching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will now discuss Redis, which can improve the performance
    of our REST applications. Redis is an open source, in-memory, key-value data store
    that allows data to reside in memory to enable low latency and faster data access.
    Compared to traditional databases, Redis doesn’t require disk access, having all
    data cached in the memory, which gives a quicker response.
  prefs: []
  type: TYPE_NORMAL
- en: It is now widely used, especially for large applications that receive millions
    of requests. It is compatible with different data structures such as strings,
    lists, sets, hashes, bitmaps, and geospatial and is compatible with **Publish/Subscribe**
    (**Pub/Sub**), used for real-time chat applications.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the Redis server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before using Redis on our Spring Boot application, we will need to install the
    Redis server in our terminal. Let’s discuss how to install Redis on different
    operating systems.
  prefs: []
  type: TYPE_NORMAL
- en: macOS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Redis is simple to install in a macOS system; we can use Homebrew to install
    Redis and execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'After successful installation, we can set the Redis server to start automatically
    with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: And we have successfully installed and run our Redis server on macOS.
  prefs: []
  type: TYPE_NORMAL
- en: Ubuntu Linux
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For installing Redis on Ubuntu OS, we will execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: This will automatically install and start the Redis server on port `6739`, and
    we have successfully installed and run our Redis server on Linux.
  prefs: []
  type: TYPE_NORMAL
- en: Windows
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For installing Redis on Windows, we can install the different versions from
    the following link: [https://github.com/microsoftarchive/redis/releases](https://github.com/microsoftarchive/redis/releases),
    download the `.zip` or `.msi` file, and extract to your chosen directory. Run
    the `Redis-server.exe` file to start the Redis server on port `6739`.'
  prefs: []
  type: TYPE_NORMAL
- en: Thus, we have successfully installed and run our Redis server on Windows. We
    can now use Redis on our Spring Boot application.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Redis on Spring Boot
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have successfully configured and started the Redis server on our local machine;
    our next step is to use Redis in our developed Spring Boot project. We’ll now
    follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we need to do is include the Redis dependency; to achieve this,
    we need to add the following code to our `pom.xml` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE95]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE96]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE97]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE98]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE99]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE100]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE101]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE102]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE103]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE104]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE105]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After successfully adding the Redis dependency, we will add our `config` package.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a class named `RedisConfig`. We will use the `@Configuration` annotation
    to identify whether this class has Bean definition methods that will be bootstrapped
    on the execution of the application. We will also add the following method to
    our class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE107]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE108]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE109]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE110]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE111]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE112]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE113]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`jedisConnectionFactory()` is the method used to identify the connection properties
    for our Redis server; this uses default values since we have not specified connection
    properties.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Still, if our Redis server is hosted on a different server, hosted on a different
    port, or has a username and password, we can use the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`redisStandaloneConfiguration.setHostName("host")`: This sets the host **Uniform
    Resource Locator** (**URL**) where the Redis server is running.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`redisStandaloneConfiguration.setPort("port")`: This sets the port where the
    application will connect.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`redisStandaloneConfiguration.setUsername("username")`: This sets the username
    for the Redis server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`redisStandaloneConfiguration.setPassword("password")`: This sets the password
    for the Redis server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next step is to use the connection factory to create a Redis template; this
    is used for Redis data interactions. It allows the automatic serialization and
    deserialization between objects and binary data stored in the Redis server.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will create a method that will also use the `@Bean` annotation; we will
    create a new Redis template and set the connection factory with the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE115]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After successfully creating the template instance with the connection factory,
    we can also define serializers depending on the data structures. If we want to
    use the default serializer, which is `JdkSerializationRedisSerializer`, we will
    just return a template instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code snippet, we have used different serializers for different
    data structures:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE117]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE118]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE119]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE120]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE121]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE122]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE123]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE124]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE125]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE126]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE127]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE128]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE129]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE130]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE131]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE132]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE133]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE134]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The last thing we need to do is add the `@RedishHash` annotation to our entity.
    This serves as a mark for objects as an aggregate root to be stored on the Redis
    hash; in our example, we will use it on `AntiHeroEntity`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE136]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE137]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE138]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: And this will successfully use the Redis server to cache data on our Spring
    Boot application as operations are executed.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With this, we have reached the end of this chapter. Let’s have a recap of the
    valuable things you have learned. You have learned how to start the Spring Boot
    application on a Tomcat server using IntelliJ. You have also known how to create
    a complete Spring Boot application step by step by creating entities, using Lombok
    and DTOs, writing services with CRUD logic with the help of JPA repositories,
    and creating controllers using HTTP annotations and `ModelMapper` for converting
    entities to DTO, and vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, you have also learned how to configure a Redis server and use it on
    a Spring Boot application.
  prefs: []
  type: TYPE_NORMAL
- en: The skills you have learned here will make your code readable and concise because
    of the Lombok and JPA repositories.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will be learning how to create documentation for our
    APIs using `springdoc-openapi` and Swagger UI.
  prefs: []
  type: TYPE_NORMAL
