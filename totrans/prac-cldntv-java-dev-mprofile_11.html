<html><head></head><body>
		<div id="_idContainer045">
			<h1 id="_idParaDest-148"><em class="italic"><a id="_idTextAnchor159"/>Chapter 8</em>: Building and Testing Your Cloud-Native Application</h1>
			<p>In the previous chapters, we've looked at various MicroProfile technologies in isolation. Now, let's come back to our example application, the <strong class="bold">IBM Stock Trader</strong>, first introduced in <a href="B17377_03_Final_SB_epub.xhtml#_idTextAnchor049"><em class="italic">Chapter 3</em></a>, <em class="italic">Introducing the IBM Stock Trader Cloud-Native Application</em>, to see those in use across various microservices. In this chapter, we'll focus on how to build those microservices, how to construct the container image for each and push them to an image registry, how to unit test them, and the usage of various MicroProfile features.</p>
			<p>In this chapter, we're going to cover the following main topics: </p>
			<ul>
				<li>Compiling the Stock Trader microservices</li>
				<li>Building the Stock Trader container images</li>
				<li>Testing the Stock Trader microservices</li>
				<li>Stock Trader usage of MicroProfile</li>
			</ul>
			<p>By the end of this chapter, you will be familiar with how to build the various pieces of such a cloud-native application, how to try out each of them, and how to demonstrate their usage.</p>
			<h1 id="_idParaDest-149"><a id="_idTextAnchor160"/>Technical requirements</h1>
			<p>To build and test the microservices as described in this section, you will need to have the following tools installed:</p>
			<ul>
				<li><strong class="bold">Java Development Kit</strong> (<strong class="bold">JDK</strong>) – Java 8 or later:  <a href="http://ibm.biz/GetSemeru">http://ibm.biz/GetSemeru</a></li>
				<li>Apache Maven: <a href="https://maven.apache.org">https://maven.apache.org</a></li>
				<li>A Git client: <a href="https://git-scm.com">https://git-scm.com</a></li>
				<li>A Docker client: <a href="https://www.docker.com/products ">https://www.docker.com/products</a></li>
			</ul>
			<h1 id="_idParaDest-150"><a id="_idTextAnchor161"/>Compiling the Stock Trader microservices</h1>
			<p>In this <a id="_idIndexMarker919"/>section, we will look at how to create a local copy of the source code for each microservice, and how to compile it and package it up into an archive that can be deployed onto an application server.</p>
			<h2 id="_idParaDest-151"><a id="_idTextAnchor162"/>GitHub</h2>
			<p>A public <a id="_idIndexMarker920"/>GitHub<a id="_idIndexMarker921"/> organization called <em class="italic">IBMStockTrader</em>, at <a href="https://github.com/IBMStockTrader">https://github.com/IBMStockTrader</a>, contains repositories for each of the dozen or so microservices comprising the application.</p>
			<p>Let's focus on the <strong class="source-inline">trader</strong> repository, and clone its contents:</p>
			<p class="source-code">jalcorn@Johns-MBP-8 StockTrader % git clone   https://github.com/IBMStockTrader/trader</p>
			<p class="source-code">Cloning into 'trader'...</p>
			<p class="source-code">remote: Enumerating objects: 2840, done.</p>
			<p class="source-code">remote: Counting objects: 100% (247/247), done.</p>
			<p class="source-code">remote: Compressing objects: 100% (132/132), done.</p>
			<p class="source-code">remote: Total 2840 (delta 58), reused 0 (delta 0), pack-  reused 2593</p>
			<p class="source-code">Receiving objects: 100% (2840/2840), 28.25 MiB | 322.00   KiB/s, done.</p>
			<p class="source-code">Resolving deltas: 100% (1049/1049), done.</p>
			<p class="source-code">jalcorn@Johns-MBP-8 StockTrader % cd trader</p>
			<p class="source-code">jalcorn@Johns-MBP-8 trader % ls</p>
			<p class="source-code">BUILD.md             Jenkinsfile             lab</p>
			<p class="source-code">CONTRIBUTING.md      Jenkinsfiledemo         manifest.yml</p>
			<p class="source-code">Dockerfile           LICENSE                 manifests</p>
			<p class="source-code">Dockerfile-build     README.md           pipeline-template.yaml</p>
			<p class="source-code">Dockerfile-lang      build_parameters.sh     pom.xml</p>
			<p class="source-code">Dockerfile-tools     chart                   src</p>
			<p class="source-code">Dockerfile.basicregistry cli-config.yml</p>
			<p class="source-code">jalcorn@Johns-MBP-8 trader %</p>
			<p>The most <a id="_idIndexMarker922"/>important <a id="_idIndexMarker923"/>files here are <strong class="source-inline">Dockerfile</strong> and the <strong class="source-inline">pom.xml</strong> (both of which we'll discuss shortly), and the <strong class="source-inline">src</strong> directory, which contains all of the source code. This includes the Java code (under <strong class="source-inline">src/main/java</strong> – each of the Stock Trader microservices has its own sub-package under <strong class="source-inline">com.ibm.hybrid.cloud.sample.stocktrader</strong>), the web artifacts (under <strong class="source-inline">src/main/webapp</strong>), and the Open Liberty configuration (under <strong class="source-inline">src/main/liberty/config</strong> – we'll look at this further in the <em class="italic">Building the Stock Trader container images</em> section). All of the microservices in the application follow this same structure. Let's take a look at the contents of the <strong class="source-inline">src</strong> directory:</p>
			<div>
				<div id="_idContainer039" class="IMG---Figure">
					<img src="image/B17377_08_01.jpg" alt="Figure 8.1 – Source code layout in the IBMStockTrader Git repositories&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.1 – Source code layout in the IBMStockTrader Git repositories</p>
			<p>Now that we've seen the source code structure in each Git repository, let's look at how to use <em class="italic">Maven</em> to build it <a id="_idIndexMarker924"/>and package the results up for deployment to the Docker container<a id="_idIndexMarker925"/> for the Open Liberty application server.</p>
			<h2 id="_idParaDest-152"><a id="_idTextAnchor163"/>Maven</h2>
			<p>The <strong class="source-inline">pom.xml</strong> file<a id="_idIndexMarker926"/> tells <a id="_idIndexMarker927"/>Maven what to build and how. Here are the steps:</p>
			<ol>
				<li>First, you need to include the following stanza in the <strong class="source-inline">pom.xml</strong> file so that usage of <strong class="source-inline">org.eclipse.microprofile.*</strong> packages will compile:<p class="source-code">        &lt;dependency&gt;</p><p class="source-code">           &lt;groupId&gt;org.eclipse.microprofile&lt;/groupId&gt;</p><p class="source-code">           &lt;artifactId&gt;microprofile&lt;/artifactId&gt;</p><p class="source-code">           &lt;version&gt;4.0.1&lt;/version&gt;</p><p class="source-code">           &lt;type&gt;pom&lt;/type&gt;</p><p class="source-code">           &lt;scope&gt;provided&lt;/scope&gt;</p><p class="source-code">        &lt;/dependency&gt;</p><p>This is the <em class="italic">umbrella</em> dependency that puts all of the MicroProfile 4 features on the compile-time classpath. You can also just choose particular MicroProfile features if you prefer; for example, to put just <em class="italic">MicroProfile Health</em> on the compile-time classpath, you'd specify <strong class="source-inline">org.eclipse.microprofile.health</strong>.</p><p>Note the <strong class="source-inline">&lt;scope&gt;provided&lt;/scope&gt;</strong> line – this tells Maven that, though it should add such JAR files to the compile-time classpath, it should <em class="italic">NOT</em> bundle such JAR files inside the WAR file being built. The application server (Open Liberty, in our case) hosting the WAR file <em class="italic">provides</em> such JAR files, and having an additional copy inside the application can cause class loader issues, so we tell it <strong class="source-inline">provided</strong> to avoid that.</p></li>
				<li>Next, let's use Maven to build our <strong class="source-inline">Trader</strong> microservice. Most modern <strong class="bold">Integrated Development Environments</strong> (<strong class="bold">IDE</strong>s) have built-in Maven support so<a id="_idIndexMarker928"/> that you can run a build via a<a id="_idIndexMarker929"/> click in a <strong class="bold">Graphical User Interface </strong>(<strong class="bold">GUI</strong>). But <a id="_idIndexMarker930"/>here, we'll look at how to use <a id="_idIndexMarker931"/>Maven from a Terminal window.<p>If you don't have Maven installed, on a Mac you can use the command <strong class="source-inline">brew install maven</strong> to install it. Note that Maven also depends on Java, and you will need the <strong class="source-inline">JAVA_HOME</strong> environment variable to point to your Java installation. Let's use <strong class="source-inline">mvn compile</strong> to compile our code:</p><p class="source-code"><strong class="bold">jalcorn@Johns-MBP-8 trader % mvn compile</strong></p><p class="source-code"><strong class="bold">[INFO] Scanning for projects...</strong></p><p class="source-code"><strong class="bold">[INFO] </strong></p><p class="source-code"><strong class="bold">[INFO] --------&lt; com.stocktrader:trader &gt;-------------</strong></p><p class="source-code"><strong class="bold">[INFO] Building StockTrader - trader 1.0-SNAPSHOT</strong></p><p class="source-code"><strong class="bold">[INFO] ----------------[ war ]-----------------------</strong></p><p class="source-code"><strong class="bold">[INFO] --- maven-resources-plugin:2.6:resources   (default-resources) @ trader ---</strong></p><p class="source-code"><strong class="bold">[INFO] Using 'UTF-8' encoding to copy filtered </strong><strong class="bold">  resources.</strong></p><p class="source-code"><strong class="bold">[INFO] Copying 1 resource</strong></p><p class="source-code"><strong class="bold">[INFO] </strong></p><p class="source-code"><strong class="bold">[INFO] --- maven-compiler-plugin:3.1:compile (default-  compile) @ trader ---</strong></p><p class="source-code"><strong class="bold">[INFO] Changes detected - recompiling the module!</strong></p><p class="source-code"><strong class="bold">[INFO] Compiling 15 source files to /Users/jalcorn   StockTrader/trader/target/classes</strong></p><p class="source-code"><strong class="bold">[INFO] -----------------------------------------------</strong></p><p class="source-code"><strong class="bold">[INFO] BUILD SUCCESS</strong></p><p class="source-code"><strong class="bold">[INFO] -----------------------------------------------</strong></p><p class="source-code"><strong class="bold">[INFO] Total time:  1.913 s</strong></p><p class="source-code"><strong class="bold">[INFO] Finished at: 2021-05-09T12:26:19-05:00</strong></p><p class="source-code"><strong class="bold">[INFO] -----------------------------------------------</strong></p><p class="source-code"><strong class="bold">jalcorn@Johns-MBP-8 trader %</strong></p><p>As you can see, it takes less than a couple of seconds to compile all of the code. Of course, if <a id="_idIndexMarker932"/>any <a id="_idIndexMarker933"/>compilation errors occurred, they will be shown when this is run.</p></li>
				<li>Next, let's package up the WAR file, via <strong class="source-inline">mvn package</strong>. Some of the several pages of output are snipped out to save space, but the important part is shown here:<p class="source-code"><strong class="bold">jalcorn@Johns-MBP-8 trader % mvn package</strong></p><p class="source-code"><strong class="bold">[INFO] Scanning for projects...</strong></p><p class="source-code"><strong class="bold">[INFO] </strong></p><p class="source-code"><strong class="bold">[INFO] ---------&lt; com.stocktrader:trader &gt;------------</strong></p><p class="source-code"><strong class="bold">[INFO] Building StockTrader - trader 1.0-SNAPSHOT</strong></p><p class="source-code"><strong class="bold">[INFO] --------------[ war ]--------------------------</strong></p><p class="source-code"><strong class="bold">[INFO] --- maven-war-plugin:2.6:war (default-war) @   trader ---</strong></p><p class="source-code"><strong class="bold">[INFO] Packaging webapp</strong></p><p class="source-code"><strong class="bold">[INFO] Assembling webapp [trader] in </strong></p><p class="source-code"><strong class="bold">  [/Users/jalcorn/StockTrader/trader/target/TraderUI]</strong></p><p class="source-code"><strong class="bold">[INFO] Processing war project</strong></p><p class="source-code"><strong class="bold">[INFO] Copying webapp resources   [/Users/jalcorn/StockTrader/trader/src/main/webapp]</strong></p><p class="source-code"><strong class="bold">[INFO] Webapp assembled in [180 msecs]</strong></p><p class="source-code"><strong class="bold">[INFO] Building war: /Users/jalcorn/StockTrader/trader   /target/TraderUI.war</strong></p><p class="source-code"><strong class="bold">[INFO] -----------------------------------------------</strong></p><p class="source-code"><strong class="bold">[INFO] BUILD SUCCESS</strong></p><p class="source-code"><strong class="bold">[INFO] -----------------------------------------------</strong></p><p class="source-code"><strong class="bold">[INFO] Total time:  </strong><strong class="bold">28.813 s</strong></p><p class="source-code"><strong class="bold">[INFO] Finished at: 2021-05-09T12:26:03-05:00</strong></p><p class="source-code"><strong class="bold">[INFO] -----------------------------------------------</strong></p><p class="source-code"><strong class="bold">jalcorn@Johns-MBP-8 trader %</strong></p><p>Note that <a id="_idIndexMarker934"/>the<a id="_idIndexMarker935"/> command <strong class="source-inline">mvn package</strong>, which takes about half a minute due to starting and stopping the Open Liberty server, actually does run the compile as well, so you would only use the command <strong class="source-inline">mvn compile</strong> directly when wanting a very fast way to check for compile errors.</p></li>
				<li>Lastly, we can run some basic integration tests via the command <strong class="source-inline">mvn verify</strong>. <p>This will execute any test classes you might have under <strong class="source-inline">src/test/java</strong> (highly recommended, to catch problems early), such as our <strong class="source-inline">HealthEndpointIT.java</strong> and <strong class="source-inline">HomePageIT.java</strong> under <strong class="source-inline">src/test/java/com/ibm/hybrid/cloud/sample/stocktrader/trader/test</strong>:</p><p class="source-code"><strong class="bold">jalcorn@Johns-MBP-8 trader % mvn verify </strong></p><p class="source-code"><strong class="bold">[INFO] Scanning for projects...</strong></p><p class="source-code"><strong class="bold">[INFO] </strong></p><p class="source-code"><strong class="bold">[INFO] ----------&lt; com.stocktrader:trader &gt;-----------</strong></p><p class="source-code"><strong class="bold">[INFO] Building StockTrader - trader 1.0-SNAPSHOT</strong></p><p class="source-code"><strong class="bold">[INFO] </strong></p><p class="source-code"><strong class="bold">[INFO] --- maven-failsafe-plugin:3.0.0-M5:integration-  </strong><strong class="bold">test (default) @ trader ---</strong></p><p class="source-code"><strong class="bold">[INFO] </strong></p><p class="source-code"><strong class="bold">[INFO] -----------------------------------------------</strong></p><p class="source-code"><strong class="bold">[INFO]  T E S T S</strong></p><p class="source-code"><strong class="bold">[INFO] -----------------------------------------------</strong></p><p class="source-code"><strong class="bold">[INFO] Running com.ibm.hybrid.cloud.sample.stocktrader</strong></p><p class="source-code"><strong class="bold">  .trader.test.HealthEndpointIT</strong></p><p class="source-code"><strong class="bold">Testing endpoint http://localhost:9080/health/ready</strong></p><p class="source-code"><strong class="bold">Testing endpoint http://localhost:9080/health/live</strong></p><p class="source-code"><strong class="bold">[INFO] Tests run: 2, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 1.149 s - in com.ibm.hybrid .cloud.sample.stocktrader.trader.test.HealthEndpointIT</strong></p><p class="source-code"><strong class="bold">[INFO] Running com.ibm.hybrid.cloud.sample.stocktrader   .trader.test.HomePageIT</strong></p><p class="source-code"><strong class="bold">Testing endpoint http://localhost:9080/trader/login</strong></p><p class="source-code"><strong class="bold">Response code : 404, retrying ... (0 of 5)</strong></p><p class="source-code"><strong class="bold">[INFO] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 3.02 s - in com.ibm.hybrid.cloud .sample.stocktrader.trader.test.HomePageIT</strong></p><p class="source-code"><strong class="bold">[INFO] </strong></p><p class="source-code"><strong class="bold">[INFO] Results:</strong></p><p class="source-code"><strong class="bold">[INFO] </strong></p><p class="source-code"><strong class="bold">[INFO] Tests run: 3, Failures: 0, Errors: 0, Skipped: 0</strong></p><p class="source-code"><strong class="bold">[INFO] </strong></p><p class="source-code"><strong class="bold">[INFO] -----------------------------------------------</strong></p><p class="source-code"><strong class="bold">[INFO] BUILD SUCCESS</strong></p><p class="source-code"><strong class="bold">[INFO] -----------------------------------------------</strong></p><p class="source-code"><strong class="bold">[INFO] Total time:  15.277 s</strong></p><p class="source-code"><strong class="bold">[INFO] Finished at: 2021-05-09T12:52:12-05:00</strong></p><p class="source-code"><strong class="bold">[INFO] -----------------------------------------------</strong></p><p class="source-code"><strong class="bold">jalcorn@Johns-MBP-8 trader %</strong></p><p>Again, some <a id="_idIndexMarker936"/>output (related to things like<a id="_idIndexMarker937"/> starting the server) was snipped out for brevity, but the important parts are shown. Note that it's normal to see some <strong class="source-inline">404</strong> errors, as tests sometimes start trying to hit URLs before the server is fully started; that's why it retries up to <em class="italic">5</em> times before giving up.</p></li>
			</ol>
			<p>Now that we've seen how to compile, package, and test our code, let's look at how to containerize it and test the container.</p>
			<h1 id="_idParaDest-153"><a id="_idTextAnchor164"/>Building the Stock Trader container images</h1>
			<p>As<a id="_idIndexMarker938"/> discussed in previous sections, we use <em class="italic">Open Liberty</em> as the application server hosting most of the Stock Trader microservices. And we use <em class="italic">Docker</em> to produce the container images that ultimately get run in a Kubernetes cluster such as the <em class="italic">OpenShift Container Platform</em> cluster.</p>
			<p>The following subsections will describe how we configure the server, and how we package it up into a container image.</p>
			<h2 id="_idParaDest-154"><a id="_idTextAnchor165"/>Open Liberty</h2>
			<p>There <a id="_idIndexMarker939"/>are a<a id="_idIndexMarker940"/> variety of MicroProfile<a id="_idIndexMarker941"/> compliant Java application servers on the market. As a reminder from <a href="B17377_03_Final_SB_epub.xhtml#_idTextAnchor049"><em class="italic">Chapter 3</em></a>,<em class="italic"> Introducing the IBM Stock Trader Cloud-Native Application</em>, most of the Stock Trader microservices (Trader, Broker, Broker-Query, Portfolio, Account, Trade History, Messaging, Notification-Slack, Collector, and Looper) are based on the open source Open Liberty application server. For variety, there are three other microservices based on different servers:</p>
			<ul>
				<li>Stock Quote, which <a id="_idIndexMarker942"/>runs on Red Hat's <strong class="bold">Quarkus</strong>.</li>
				<li>Notification-Twitter, which<a id="_idIndexMarker943"/> runs on <strong class="bold">traditional WebSphere Application Server</strong> (<strong class="bold">tWAS</strong>).</li>
				<li>Tradr is the only non-Java microservice, which is written in Node.js.</li>
			</ul>
			<p>But here, we'll focus on the ones that run on Open Liberty.</p>
			<p>The most important file for configuring an Open Liberty server is the <strong class="source-inline">server.xml</strong> file. This defines the features that should be enabled in the server, and the configuration for each of those features. You can enable all of the MicroProfile 4.1 features by listing the <strong class="source-inline">microProfile-4.1</strong> feature in your <strong class="source-inline">server.xml</strong> as follows:</p>
			<p class="source-code">    &lt;featureManager&gt;</p>
			<p class="source-code">        &lt;feature&gt;microProfile-4.1&lt;/feature&gt;</p>
			<p class="source-code">    &lt;/featureManager&gt;</p>
			<p>Otherwise just like with the Maven dependencies, if you prefer to enable fewer features, such as if you only want <em class="italic">MicroProfile Health</em> and <em class="italic">MicroProfile Metrics</em>, you can instead list them separately as shown here:</p>
			<p class="source-code">    &lt;featureManager&gt;</p>
			<p class="source-code">        &lt;feature&gt;mpHealth-3.1&lt;/feature&gt;</p>
			<p class="source-code">        &lt;feature&gt;mpMetrics-3.1&lt;/feature&gt;</p>
			<p class="source-code">    &lt;/featureManager&gt;</p>
			<p>In addition to the features you enable, some of them support stanzas for configuration. Many of the Java Enterprise Edition resources are configured here, such as the following:</p>
			<ul>
				<li>JDBC DataSources for talking to relational databases such as IBM DB2.</li>
				<li>JMS ActivationSpecs for talking to messaging systems such as IBM MQ.</li>
				<li>CloudantDatabase for talking to a NoSQL datastore such as IBM Cloudant.</li>
			</ul>
			<p>For the <a id="_idIndexMarker944"/>MicroProfile features in particular, here is <a id="_idIndexMarker945"/>how the Stock Trader microservices configure the <em class="italic">MicroProfile JWT</em> and <em class="italic">MicroProfile Metrics</em> features:</p>
			<p class="source-code">    &lt;mpJwt id="stockTraderJWT" audiences="${JWT_AUDIENCE}"       issuer="${JWT_ISSUER}" keyName="jwtSigner"         ignoreApplicationAuthMethod="false" expiry="12h"           sslRef="defaultSSLConfig"/&gt;</p>
			<p class="source-code">    &lt;mpMetrics authentication="false"/&gt;</p>
			<p>These features have been discussed in the previous chapters, so we won't repeat that here. One thing to note though is that we are referencing environment variables such as <strong class="source-inline">${JWT_ISSUER}</strong>, rather than hardcoding such values; this way, we don't have to rebuild the container image if we want to modify the values – instead, we would just update the value in a Kubernetes <em class="italic">ConfigMap</em> or <em class="italic">Secret</em>, and our operator would configure the <strong class="source-inline">.yaml</strong> file for the <em class="italic">Deployment</em> to obtain and pass the appropriate values as environment variables.</p>
			<p>Beyond the <strong class="source-inline">server.xml</strong> file, other Open Liberty-specific files in the <strong class="source-inline">src/main/liberty/config</strong> directory include <strong class="source-inline">jvm.options</strong> (used to pass JVM system properties, and so on), and your key store and/or trust store files (such as <strong class="source-inline">key.p12</strong> and <strong class="source-inline">trust.p12</strong> in the <strong class="source-inline">src/main/liberty/config/resources/security</strong> directory). The files are laid out here in the same directory structure as is required in the Open Liberty server so that we can just copy the entire directory into the appropriate location in the Docker container for Open Liberty, as we'll see in the next section.</p>
			<h2 id="_idParaDest-155"><a id="_idTextAnchor166"/>Docker</h2>
			<p>Once you have <a id="_idIndexMarker946"/>all<a id="_idIndexMarker947"/> of the input files ready that need to become part of the Docker container image, you use a <strong class="source-inline">Dockerfile</strong> to say what files you want copied where. You can also run commands other than <strong class="source-inline">COPY</strong>, such as setting file permissions or installing additional tools in the container:</p>
			<ol>
				<li value="1">First, let's take a look at the <strong class="source-inline">Dockerfile</strong> for the Trader microservice:<p class="source-code"><strong class="bold"># If building locally, you have to complete a maven build first, before running the Docker build</strong></p><p class="source-code"><strong class="bold">FROM openliberty/open-liberty:kernel-slim-java11-openj9-ubi</strong></p><p class="source-code"><strong class="bold">USER root</strong></p><p class="source-code"><strong class="bold">COPY --chown=1001:0 src/main/liberty/config /config</strong></p><p class="source-code"><strong class="bold"># This script will add the requested XML snippets to enable Liberty features and grow image to be fit-for-purpose using featureUtility. </strong></p><p class="source-code"><strong class="bold"># Only available in 'kernel-slim'. The 'full' tag already includes all features for convenience.</strong></p><p class="source-code"><strong class="bold">RUN features.sh</strong></p><p class="source-code"><strong class="bold">COPY --chown=1001:0 target/TraderUI.war /config/apps/TraderUI.war</strong></p><p class="source-code"><strong class="bold">USER 1001</strong></p><p class="source-code"><strong class="bold">RUN configure.sh</strong></p><p>The first (non-comment) line says we want to start from the Open Liberty container image. Since the tag we are using does not specify a specific (monthly) release of Open Liberty (such as 21.0.0.7, which is the release in the seventh month of 2021), it is a good idea to do an explicit <strong class="source-inline">docker pull</strong> of the image before running a build, to ensure you have the latest (as Docker would think you already have an image with such a tag, even though the one you have locally might be <a id="_idIndexMarker948"/>many months old). For example, do<a id="_idIndexMarker949"/> the following:</p><p class="source-code"><strong class="bold">jalcorn@Johns-MBP-8 trader % docker pull openliberty/open-liberty:kernel-slim-java11-openj9-ubi</strong></p><p class="source-code"><strong class="bold">kernel-slim-java11-openj9-ubi: Pulling from openliberty/open-liberty</strong></p><p class="source-code"><strong class="bold">Digest: sha256:e072abc78effdbff787b6af34aeaab 29315a6f9f2b376896a0bf09706a5438d6</strong></p><p class="source-code"><strong class="bold">Status: Image is up to date for openliberty/open-liberty:kernel-slim-java11-openj9-ubi</strong></p><p class="source-code"><strong class="bold">docker.io/openliberty/open-liberty:kernel-slim-java11-openj9-ubi</strong></p><p class="source-code"><strong class="bold">jalcorn@Johns-MBP-8 trader %</strong></p><p>Note that this<a id="_idIndexMarker950"/> is requesting an image based on the <strong class="bold">Universal Base Image</strong> (<strong class="bold">UBI</strong>), which<a id="_idIndexMarker951"/> is a special build of <strong class="bold">Red Hat Enterprise Linux</strong> (<strong class="bold">RHEL</strong>) 8.4 that is optimized for Docker. It also says you want an image that includes Java 11 (there are other tags, such as for Java 8 or Java 15). And lastly, it says you want to start from the <strong class="source-inline">kernel-slim</strong> image, which means no features beyond the kernel are packaged in the image, in the interest of size. </p><p>The next important line says we want to copy the <strong class="source-inline">src/main/liberty/config</strong> directory into the <strong class="source-inline">/config</strong> directory in the container image. This <strong class="source-inline">/config</strong> directory is actually a soft link to <strong class="source-inline">/opt/ol/wlp/usr/servers/defaultServer</strong> in Open Liberty (or to <strong class="source-inline">/opt/ibm/wlp/usr/servers/defaultServer</strong> on commercial WebSphere Liberty, which you'd get via <strong class="source-inline">FROM ibmcom/websphere-liberty:kernel-java11-openj9-ubi</strong>). We copy the whole directory (and its subdirectories), rather than a separate <strong class="source-inline">COPY</strong> per file, to reduce the number of layers in the resulting Docker image.</p></li>
				<li>Next, we run a script called <strong class="source-inline">features.sh</strong>, which downloads all of the features we specify in <strong class="source-inline">server.xml</strong> we copied into the Docker image in the previous step. If instead of using the <strong class="source-inline">kernel-slim</strong> image we had instead used the <strong class="source-inline">full</strong> image, this step would not be needed. Note we want to run this before we copy our WAR file (that Maven produced) into the container so that we don't need <a id="_idIndexMarker952"/>to rerun this time-consuming step <a id="_idIndexMarker953"/>each time we make a small change to our application.</li>
				<li>Next, we copy our WAR file (or the Messaging microservice copies in an <strong class="source-inline">ear</strong> file instead, as it has our one EJB – an MDB) into the container. Note <strong class="source-inline">--chown 1001:0</strong>, which tells it what user and group should own the file – without this, the server, which does <em class="italic">NOT</em> run as root, would not have authority to access the files.</li>
				<li>Finally, we run the <strong class="source-inline">configure.sh</strong> script, which does some further tweaking of file permissions, and which builds the shared class cache to improve performance.</li>
				<li>Let's now run our build, which will execute each line of the <strong class="source-inline">Dockerfile</strong>:<p class="source-code"><strong class="bold">jalcorn@Johns-MBP-8 trader % docker build -t trader .[+] Building 45.7s (10/10) FINISHED </strong></p><p class="source-code"><strong class="bold"> =&gt; [internal] load build definition from Dockerfile 0.0s</strong></p><p class="source-code"><strong class="bold"> =&gt; =&gt; transferring dockerfile: 37B 0.0s</strong></p><p class="source-code"><strong class="bold"> =&gt; [internal] load .dockerignore 0.0s</strong></p><p class="source-code"><strong class="bold"> =&gt; =&gt; transferring context: 2B 0.0s</strong></p><p class="source-code"><strong class="bold"> =&gt; [internal] load metadata for docker.io/openliberty /open-liberty:k  0.0s</strong></p><p class="source-code"><strong class="bold"> =&gt; [1/5] FROM docker.io/openliberty/open-liberty:kernel-slim-java11-  0.0s</strong></p><p class="source-code"><strong class="bold"> =&gt; [internal] load build context 0.3s</strong></p><p class="source-code"><strong class="bold"> =&gt; =&gt; transferring context: 11.41MB 0.2s</strong></p><p class="source-code"><strong class="bold"> =&gt; CACHED [2/5] COPY --chown=1001:0 src/main/liberty/config /config   0.0s</strong></p><p class="source-code"><strong class="bold"> =&gt; CACHED [3/5] RUN features.sh 0.0s</strong></p><p class="source-code"><strong class="bold"> =&gt; [4/5] COPY --chown=1001:0 target/TraderUI.war /config/apps/Trader  0.1s</strong></p><p class="source-code"><strong class="bold"> =&gt; [5/5] RUN configure.sh 44.8s</strong></p><p class="source-code"><strong class="bold"> =&gt; exporting to image 0.4s</strong></p><p class="source-code"><strong class="bold"> =&gt; =&gt; exporting layers 0.4s</strong></p><p class="source-code"><strong class="bold"> =&gt; =&gt; writing image sha256:d0a03e6e7fd2873a8361aa9c9c   ad22dd614686778  0.0s</strong></p><p class="source-code"><strong class="bold"> =&gt; =&gt; naming to docker.io/library/trader 0.0s</strong></p><p class="source-code"><strong class="bold">jalcorn@Johns-MBP-8 trader %</strong></p></li>
				<li>We now <a id="_idIndexMarker954"/>have <a id="_idIndexMarker955"/>a Docker image produced, which we can push to an image registry, so that it's available for your <a id="_idIndexMarker956"/>operator to access and use in a Kubernetes environment such as the <strong class="bold">OpenShift Container Platform</strong> (<strong class="bold">OCP</strong>). For example, here we push it to Docker Hub:<p class="source-code"><strong class="bold">jalcorn@Johns-MBP-8 trader % docker tag trader:latest ibmstocktrader/trader:latest</strong></p><p class="source-code"><strong class="bold">jalcorn@Johns-MBP-8 trader % docker push ibmstocktrader/trader:latest</strong></p><p class="source-code"><strong class="bold">The push refers to repository [docker.io/ibmstocktrader/trader]</strong></p><p class="source-code"><strong class="bold">c139b5a83739: Pushing   13.9MB/62.74MB</strong></p><p class="source-code"><strong class="bold">dae5b07894dc: Pushing  2.888MB/11.4MB</strong></p><p class="source-code"><strong class="bold">0b797df05047: Pushing  5.893MB/69.17MB</strong></p><p class="source-code"><strong class="bold">7daae910987c: Pushed </strong></p><p class="source-code"><strong class="bold">3efa9ea44ae4: Layer already exists </strong></p><p class="source-code"><strong class="bold">7d02e9817200: Layer already exists </strong></p><p class="source-code"><strong class="bold">267522994240: Layer already exists </strong></p><p class="source-code"><strong class="bold">0db07c8859ff: Layer already exists </strong></p><p class="source-code"><strong class="bold">2b4eefc8e725: Layer already exists </strong></p><p class="source-code"><strong class="bold">8a9f64ec0b16: Layer already exists </strong></p><p class="source-code"><strong class="bold">9b61e11e8907: Layer already exists </strong></p><p class="source-code"><strong class="bold">09b9a9d4c9f4: Layer already exists </strong></p><p class="source-code"><strong class="bold">83713a30b4bb: Layer already exists </strong></p><p class="source-code"><strong class="bold">1e8cd6732429: Layer already exists </strong></p><p class="source-code"><strong class="bold">476579af086a: Layer already exists</strong></p><p class="source-code"><strong class="bold">jalcorn@Johns-MBP-8 trader %</strong></p></li>
			</ol>
			<p>Now that <a id="_idIndexMarker957"/>we've <a id="_idIndexMarker958"/>built the <em class="italic">Trader</em> microservice, repeat the aforementioned steps for the <em class="italic">Stock Quote</em> microservice, which we'll also use later in this chapter. As a quick recap, run the following commands:</p>
			<ul>
				<li><strong class="source-inline">git clone https://github.com/IBMStockTrader/stock-quote</strong></li>
				<li><strong class="source-inline">cd stock-quote</strong></li>
				<li><strong class="source-inline">mvn package</strong></li>
				<li><strong class="source-inline">docker build -t stock-quote .</strong></li>
			</ul>
			<p>In the next <a id="_idIndexMarker959"/>section, we will look at how to test the container images we just built.</p>
			<h1 id="_idParaDest-156"><a id="_idTextAnchor167"/>Testing the Stock Trader microservices</h1>
			<p>Now that we've<a id="_idIndexMarker960"/> learned how to build our microservices, the next important step, before deploying them to an OpenShift environment, is to first perform some unit tests on them to make sure they are working as desired.</p>
			<h2 id="_idParaDest-157"><a id="_idTextAnchor168"/>Testing the frontend microservice</h2>
			<p>We<a id="_idIndexMarker961"/> can perform such unit tests by using locally installed Docker on our laptops. Let's run the Docker container we just built for Trader, and try it out:</p>
			<p class="source-code">jalcorn@Johns-MBP-8 portfolio % docker run -p 9443:9443 -e JWT_AUDIENCE=test -e JWT_ISSUER=test -e TEST_MODE=true trader:latest</p>
			<p class="source-code">Launching defaultServer (Open Liberty 21.0.0.4/wlp-1.0.51.cl210420210407-0944) on Eclipse OpenJ9 VM, version 11.0.11+9 (en_US)</p>
			<p class="source-code">[AUDIT] CWWKE0001I: The server defaultServer has been launched.</p>
			<p class="source-code">&lt;snip&gt;</p>
			<p class="source-code">[INFO] SRVE0169I: Loading Web Module: Trader UI.</p>
			<p class="source-code">[INFO] SRVE0250I: Web Module Trader UI has been bound to default_host.</p>
			<p class="source-code">[AUDIT] CWWKT0016I: Web application available (default_host): http://5708495d563b:9080/trader/</p>
			<p class="source-code">[AUDIT] CWWKZ0001I: Application TraderUI started in 5.701 seconds.</p>
			<p class="source-code">[AUDIT] CWWKF0012I: The server installed the following features: [appSecurity-2.0, appSecurity-3.0, cdi-2.0, distributedMap-1.0, el-3.0, federatedRegistry-1.0, jaxrs-2.1, jaxrsClient-2.1, jndi-1.0, json-1.0, jsonb-1.0, jsonp-1.1, jsp-2.3, jwt-1.0, jwtSso-1.0, ldapRegistry-3.0, microProfile-4.0, monitor-1.0, mpConfig-2.0, mpFaultTolerance-3.0, mpHealth-3.0, mpJwt-1.2, mpMetrics-3.0, mpOpenAPI-2.0, mpOpenTracing-2.0, mpRestClient-2.0, oauth-2.0, openidConnectClient-1.0, opentracing-2.0, servlet-4.0, ssl-1.0, transportSecurity-1.0].</p>
			<p class="source-code">[INFO] CWWKF0008I: Feature update completed in 8.604 seconds.</p>
			<p class="source-code">[AUDIT] CWWKF0011I: The defaultServer server is ready to run a smarter planet. The defaultServer server started in 9.631 seconds.</p>
			<p>This <strong class="source-inline">docker run</strong> command<a id="_idIndexMarker962"/> starts the container, tells it to expose its port <strong class="source-inline">9443</strong> (the default HTTPS port for Open Liberty), and passes a few environment variables. </p>
			<p class="callout-heading">Note </p>
			<p class="callout">The environment variable<strong class="source-inline"> TEST_MODE</strong> is used to facilitate testing the Trader microservice, which usually needs connectivity to a Broker microservice. It has an option to bypass that and work with hardcoded data.</p>
			<p>Now that our container is running, let's hit <strong class="source-inline">https://localhost:9443/trader</strong> in a browser. After logging in (as <strong class="source-inline">stock</strong>/<strong class="source-inline">trader</strong>), we can see the hardcoded <strong class="source-inline">TEST_MODE</strong> data:</p>
			<div>
				<div id="_idContainer040" class="IMG---Figure">
					<img src="image/B17377_08_02.jpg" alt="Figure 8.2 – Testing the Trader UI microservice via docker run&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.2 – Testing the Trader UI microservice via docker run</p>
			<p>Congratulations, you <a id="_idIndexMarker963"/>have successfully tested the <em class="italic">Trader</em> microservice in a container!</p>
			<h2 id="_idParaDest-158"><a id="_idTextAnchor169"/>Testing a backend microservice</h2>
			<p>Testing a<a id="_idIndexMarker964"/> frontend microservice in a browser is pretty straightforward since the web browser takes care of login cookies for you, but when it comes to testing one of the backend microservices, it is a bit more<a id="_idIndexMarker965"/> difficult, due <a id="_idIndexMarker966"/>to the use of the <strong class="bold">JSON Web Token</strong> (<strong class="bold">JWT</strong>) for <strong class="bold">Single Sign-On</strong> (<strong class="bold">SSO</strong>) purposes.  The <em class="italic">Stock Quote</em> microservice is an example of such a backend microservice that uses <strong class="bold">MicroProfile JWT</strong> to <a id="_idIndexMarker967"/>ensure that no caller is allowed in without first having passed a login challenge, which returns a JWT upon success.</p>
			<p>Start the Docker container for the Stock Quote microservice we built earlier via <strong class="source-inline">docker run -p 9080:9080 -e JWT_AUDIENCE=test -e JWT_ISSUER=test stock-quote:latest</strong>. Like before, this exposes a port so that we can communicate with it; in this case, it is port <strong class="source-inline">9080</strong>, used for standard (unencrypted) HTTP access.</p>
			<p>However, just directly invoking the REST API exposed by the Stock Quote microservice, by running a command such as <strong class="source-inline">curl http://localhost:9080/stock-quote/TEST</strong>, will result in a <strong class="source-inline">401</strong> error being returned due to the missing SSO credentials.</p>
			<p class="callout-heading">Note</p>
			<p class="callout"><strong class="source-inline">TEST</strong> is another special value that returns hardcoded data, bypassing the call to the internet to get an actual stock quote.</p>
			<p>We can address this problem by using our frontend Trader microservice to do a login and then looking in the Web Inspector built into the browser to find out the value of the JWT cookie. This will be a little different in each browser; in my case, I'm using Safari on my Mac, and I select <strong class="bold">Develop</strong> | <strong class="bold">Show Web Inspector</strong> from the menu bar. Then I just find the <strong class="bold">summary</strong> request (this is the servlet showing all of the portfolios) and copy the value of its <strong class="bold">JWT</strong> cookie to the clipboard:</p>
			<div>
				<div id="_idContainer041" class="IMG---Figure">
					<img src="image/B17377_08_03_new.jpg" alt="Figure 8.3 – Getting the JWT value from the Web Inspector&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption"> </p>
			<p class="figure-caption">Figure 8.3 – Getting the JWT value from the Web Inspector</p>
			<p>Then <a id="_idIndexMarker968"/>just paste that big string into an <strong class="source-inline">Authorization</strong> header in <strong class="source-inline">curl</strong>, as shown here:</p>
			<p class="source-code">jalcorn@Johns-MBP-8 StockTrader % curl -H "Authorization: eyJraWQiOiJWeUltUHBWVG1RY0ZfeV9SdVdHZmh1YkRGd1cxYjQ1d3FO QU1mUWZmV3hBIiwidHlwIjoiSldUIiwiYWxnIjoiUlMyNTYifQ.eyJ0b2tlbl 90eXBlIjoiQmVhcmVyIiwiYXVkIjoic3RvY2stdHJhZGVyIiwic3ViIjoic3R vY2siLCJ1cG4iOiJzdG9jayIsImdyb3VwcyI6WyJTdG9ja1RyYWRlciJdLCJy ZWFsbSI6IkJhc2ljUmVnaXN0cnkiLCJpc3MiOiJodHRwOi8vc3RvY2stdHJhZG VyLmlibS5jb20iLCJleHAiOjE2MjIxNTA0MDUsImlhdCI6MTYyMjE0MzIwNX0.k2z65b36MJU4fhpqq7S66pYV8rwZalT3aQK-hoOnINeVarg6k3AHIP6lN_ZHsT KX5W4b8q81o5gC0KSdEFN6VSi3qdC7a02aotICbuuZh459F7IuPOC5rWbwrUa kznNxh2I7s8Nurhcb2_UDq1WM0POyZYMpuDokys-CeH5w3QyLZ7tx_IS6czU9 yh17bX4pp3eNH0JLCZybB_i-rBHh8cwzKLk3q73CvPhHJ2jw_zw79viaSUs WOeIkF21S-iB2v4PYw7nTz54pp02pu_eHi8W-hRCebN0O7xsG_JNZUPEgloN b9O8b0d_7V8qyKD5m_YpSh45y_CZ9j82i_Ho_9A " http://localhost:90 80/stock-quote/TEST </p>
			<p class="source-code">{"date":"2021-05-10","price":123.45,"symbol":</p>
			<p class="source-code">"TEST","time":0}% jalcorn@Johns-MBP-8 StockTrader %</p>
			<p>As you can see, we got back a stock price of <strong class="source-inline">123.45</strong> from this quick unit test of our backend Stock Quote microservice. Note that JWTs automatically expire, so after a while, you'll have to do this again to get a fresh one if your <strong class="source-inline">curl</strong> calls start getting rejected. Of course, there are also GUI REST test clients that can simplify this common issue of how to pass credentials to a backend service.</p>
			<p>Now that we've seen the approach for how to build and test the containers for each of our <a id="_idIndexMarker969"/>microservices, let's dive a bit deeper into the usage of MicroProfile 4.1 features in the Stock Trader application.</p>
			<h1 id="_idParaDest-159"><a id="_idTextAnchor170"/>Using MicroProfile features in Stock Trader</h1>
			<p>Let's start <a id="_idIndexMarker970"/>with<a id="_idIndexMarker971"/> a view of which Stock Trader microservices use which MicroProfile features. Note that there are two ways a microservice can benefit from a given MicroProfile feature – implicitly or explicitly:</p>
			<ul>
				<li>In the implicit case, just listing the feature in your <strong class="source-inline">server.xml</strong> file gives you value; for example, you can obtain default implementations for readiness and liveness probes just by enabling the <strong class="source-inline">mpHealth-3.1</strong> feature.</li>
				<li>In the explicit case, you directly code to the APIs offered by the feature, such as implementing your own custom logic for whether your microservice is healthy by coding to classes in the <strong class="source-inline">org.eclipse.microprofile.health</strong> package from within your own Java classes.</li>
			</ul>
			<p>In the following table, we can see which microservices use which feature, with the <em class="italic">not</em> sign meaning not at all, the <em class="italic">dash</em> meaning implicit usage, and the <em class="italic">checkmark</em> meaning explicit usage:</p>
			<div>
				<div id="_idContainer042" class="IMG---Figure">
					<img src="image/Table_01_new.jpg" alt="Table 8.1 – MicroProfile usage in each Stock Trader microservice&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Table 8.1 – MicroProfile usage in each Stock Trader microservice</p>
			<p>Note<a id="_idIndexMarker972"/> that <a id="_idIndexMarker973"/>the tWAS-based Notification-Twitter and the Node.js-based Tradr aren't listed (since they don't run on a MicroProfile-compliant server) and that the Messaging microservice is just an MDB with no HTTP endpoint, so most MicroProfile features don't apply to it. Also, with Stock Trader, we tend to use the (Istio-based) <em class="italic">OpenShift Service Mesh</em> to define our Fault Tolerance policies via <strong class="source-inline">.yaml</strong> files, rather than <a id="_idIndexMarker974"/>directly coding to the mpFaultTolerance<a id="_idIndexMarker975"/> feature.</p>
			<h2 id="_idParaDest-160"><a id="_idTextAnchor171"/>Implicit usage of MicroProfile features</h2>
			<p>MicroProfile<a id="_idIndexMarker976"/> delivers significant benefits to applications that are being modernized to a MicroProfile-compliant application server, even if the applications aren't updated to code to the APIs of the various MicroProfile features. This can be useful, such as in situations where you are modernizing from the traditional WebSphere Application Server to Open Liberty, but don't want to have to make a lot of code updates. In the following sub-sections, we'll examine which MicroProfile features can provide such implicit benefits.</p>
			<h3>MicroProfile Health</h3>
			<p>As<a id="_idIndexMarker977"/> mentioned <a id="_idIndexMarker978"/>previously, you can get automatic implementations of the Kubernetes startup, readiness, and liveness probes, just by enabling the <strong class="source-inline">mpHealth-3.1</strong> feature in your <strong class="source-inline">server.xml</strong> file. Note that startup probes are relatively new in Kubernetes, added in version 1.16, which corresponds to OpenShift version 4.3. And support for them was added rather recently in MicroProfile, starting in version 4.1, which is the first version containing MicroProfile Health version 3.1.</p>
			<p>A startup probe is useful if your application takes a long time to start (such as if it loads and caches a lot of data from a database).</p>
			<p>A readiness probe is important so that work won't get routed to a newly started pod until it is actually ready to process such requests.</p>
			<p>The default readiness implementation will return <strong class="source-inline">false</strong> until the server and all of its applications are fully started, and from then on will return <strong class="source-inline">true</strong>, until a signal is received that the server is stopping (such as when a <em class="italic">HorizontalPodAutoscaler</em> scales down the number of pods for a deployment). This is also the default startup probe implementation – so really, you only get additional value from a startup probe, above and beyond what you get from the default readiness probe implementation if you provide your own explicit implementation.</p>
			<p>The default liveness implementation will return <strong class="source-inline">true</strong> as long as the server can process inbound HTTP requests. This will usually be the case unless all of the threads in the web container are hung/in use, or something really bad like an <strong class="source-inline">OutOfMemoryError</strong> has occurred. Kubernetes will automatically kill any pod that fails its liveness probe a specified consecutive number of times and start a fresh one to replace it.</p>
			<p>Here are the<a id="_idIndexMarker979"/> results of directly calling the startup, readiness, and<a id="_idIndexMarker980"/> liveness probes on our container:</p>
			<p class="source-code">jalcorn@Johns-MBP-8 StockTrader % curl http://localhost:9080/health/started </p>
			<p class="source-code">{"checks":[],"status":"UP"}</p>
			<p class="source-code">% jalcorn@Johns-MBP-8 StockTrader % curl http://localhost:9080/health/ready</p>
			<p class="source-code">{"checks":[],"status":"UP"}% </p>
			<p class="source-code">jalcorn@Johns-MBP-8 StockTrader % curl http://localhost:9080/health/live </p>
			<p class="source-code">{"checks":[],"status":"UP"}% </p>
			<p class="source-code">jalcorn@Johns-MBP-8 StockTrader %</p>
			<h3>MicroProfile metrics</h3>
			<p>There <a id="_idIndexMarker981"/>are<a id="_idIndexMarker982"/> three kinds of metrics: base, vendor, and application. The first two kinds will be available automatically to anyone that periodically scrapes the <strong class="source-inline">/metrics</strong> endpoint (such as <em class="italic">Prometheus</em>), just by enabling the <strong class="source-inline">mpMetrics-3.0</strong> feature in the <strong class="source-inline">server.xml</strong> file. The third kind is only available when the application is coded to the annotations or explicit API calls from the <strong class="source-inline">org.eclipse.microprofile.metrics</strong> package.</p>
			<p>Base metrics are defined by the MicroProfile Metrics specification, and generally include JVM-level metrics related to heap size, garbage collection, and thread counts, in addition to various counters and timings. Vendor metrics vary by each application server, and include things such as JDBC and JMS connection pool usage and other things that the app server manages for you. Let's take a look at a few of the available base and vendor metrics (the full set would take many pages to display) from our running Stock Quote container:</p>
			<p class="source-code">jalcorn@Johns-MBP-8 StockTrader % curl http://localhost:9080/metrics</p>
			<p class="source-code"># TYPE base_classloader_loadedClasses_count gauge</p>
			<p class="source-code"># HELP base_classloader_loadedClasses_count Displays the number of classes that are currently loaded in the Java virtual machine.</p>
			<p class="source-code">base_classloader_loadedClasses_count 12491</p>
			<p class="source-code"># TYPE base_thread_count gauge</p>
			<p class="source-code"># HELP base_thread_count Displays the current number of live threads including both daemon and non-daemon threads.</p>
			<p class="source-code">base_thread_count 53</p>
			<p class="source-code"># TYPE base_memory_usedHeap_bytes gauge</p>
			<p class="source-code"># HELP base_memory_usedHeap_bytes Displays the amount of used heap memory in bytes.</p>
			<p class="source-code">base_memory_usedHeap_bytes 6.675884E7</p>
			<p class="source-code"># TYPE vendor_servlet_request_total counter</p>
			<p class="source-code"># HELP vendor_servlet_request_total The number of visits to this servlet since the start of the server.</p>
			<p class="source-code">vendor_servlet_request_total{servlet="StockQuote_com_ibm_hybrid_cloud_sample_stocktrader_stockquote_StockQuote"} 1</p>
			<p class="source-code"># TYPE vendor_threadpool_size gauge</p>
			<p class="source-code"># HELP vendor_threadpool_size The size of the thread pool.</p>
			<p class="source-code">vendor_threadpool_size{pool="Default_Executor"} 8</p>
			<p class="source-code"># TYPE vendor_servlet_responseTime_total_seconds gauge</p>
			<p class="source-code"># HELP vendor_servlet_responseTime_total_seconds The total response time of this servlet since the start of the server.</p>
			<p class="source-code">vendor_servlet_responseTime_total_seconds{servlet="StockQuote_com_ibm_hybrid_cloud_sample_stocktrader_stockquote_StockQuote"} 0.9500412</p>
			<p class="source-code">jalcorn@Johns-MBP-8 StockTrader %</p>
			<h3>MicroProfile OpenTracing</h3>
			<p>Another<a id="_idIndexMarker983"/> of the <a id="_idIndexMarker984"/>observability-related features is MicroProfile OpenTracing. This will automatically generate trace spans for any JAX-RS operation, simply by enabling the <strong class="source-inline">mpOpenTracing-2.0</strong> feature. These trace spans are sent to any registered tracer, such as for Jaeger. If you have the Jaeger tracer registered, you should see the following in your container's output, indicating that trace spans are being sent on each JAX-RS operation:</p>
			<p class="source-code">[INFO] Initialized tracer=JaegerTracer(version=Java-1.5.0, serviceName=StockQuote, reporter=CompositeReporter(reporters=[RemoteReporter(sender=UdpSender(host=localhost, port=6831), closeEnqueueTimeout=1000), LoggingReporter(logger=org.slf4j.impl.JDK14LoggerAdapter(io.jaegertracing.internal.reporters.LoggingReporter))]), sampler=RemoteControlledSampler (maxOperations=2000, manager=HttpSamplingManager(hostPort=localhost:5778), sampler=ProbabilisticSampler(tags={sampler.type=probabilistic, sampler.param=0.001})), tags={hostname=5f0 6cf0b9a96, jaeger.version=Java-1.5.0, ip=172.17.0.2}, zipkinSharedRpcSpan=false, expandExceptionLogs=false, useTraceId128Bit=false)</p>
			<p class="source-code">[INFO] CWMOT1001I: A JaegerTracer instance was created for the StockQuote application.  Tracing information is sent to localhost:6831.</p>
			<p>The other important feature of MicroProfile Open Tracing is that a <em class="italic">span</em> can chain to as many calls as needed, so rather than just seeing one span showing that A called B and another span showing that B called C, a span could encompass showing the call path from A to B to C, including when they occurred, how long each part took, and much more. Being able to see, for example, a span that includes Trader calling Broker calling Portfolio calling Stock Quote is valuable to those wanting to see how all of these various microservices fit together at runtime, and whether they are performing as expected.</p>
			<h3>MicroProfile OpenAPI</h3>
			<p>The <a id="_idIndexMarker985"/>MicroProfile <a id="_idIndexMarker986"/>OpenAPI feature is quite cool since it will generate documentation about your JAX-RS class, simply by enabling the <strong class="source-inline">mpOpenAPI-2.0</strong> feature in your <strong class="source-inline">server.xml</strong> file. If someone wants to know what operations your microservice makes available, all they have to do is <strong class="source-inline">curl http://localhost:9080/openapi</strong> to get a <strong class="source-inline">.yaml</strong> file that explains each of the available operations, their input parameters, and the data structure they return.</p>
			<p>One nice bonus item you get with Open Liberty is the ability to have it generate a human-friendly <a id="_idIndexMarker987"/>web page rendering of this information (sometimes this is referred to as the Swagger UI). Just hit <strong class="source-inline">http://localhost:9080/openapi/ui</strong> in a browser to see an HTML rendering. Let's take a look at the HTML rendering for our Broker microservice:</p>
			<div>
				<div id="_idContainer043" class="IMG---Figure">
					<img src="image/B17377_08_04.jpg" alt="Figure 8.4 – The MicroProfile OpenAPI UI&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.4 – The MicroProfile OpenAPI UI</p>
			<p>Here we can see there's a <strong class="bold">GET</strong> operation that takes no path parameters (that returns a summary of all portfolios), as well as <strong class="bold">GET</strong>, <strong class="bold">PUT</strong>, <strong class="bold">POST</strong>, and <strong class="bold">DELETE</strong> operations for a particular portfolio, and a couple of other operations (one sends feedback to the <em class="italic">Watson Tone Analyzer</em>, and the other gets the return on investment for a particular portfolio). We <a id="_idIndexMarker988"/>also can see the structure <a id="_idIndexMarker989"/>of the <strong class="source-inline">Broker</strong> JSON object that these operations return.</p>
			<p>We can also drill into one of the operations and see details about it – let's pick the <strong class="bold">PUT</strong> operation that's used to update a portfolio with a trade of stock:</p>
			<div>
				<div id="_idContainer044" class="IMG---Figure">
					<img src="image/B17377_08_05.jpg" alt="Figure 8.5 – Operation details in the MicroProfile OpenAPI UI&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.5 – Operation details in the MicroProfile OpenAPI UI</p>
			<p>Now we<a id="_idIndexMarker990"/> can <a id="_idIndexMarker991"/>see what path and query parameters are expected, and can even click the <strong class="bold">Try it out</strong> button, which will let us fill in values for each of those parameters, and then click <strong class="bold">Execute</strong> to actually invoke the desired operation. It also shows us the corresponding <strong class="source-inline">curl</strong> command for what we've entered in each field of the form, and the results of invoking the operation.</p>
			<h3>MicroProfile JWT</h3>
			<p>The final <a id="_idIndexMarker992"/>MicroProfile<a id="_idIndexMarker993"/> feature that offers implicit value is MicroProfile JWT. Simply by enabling the <strong class="source-inline">mpJWT-1.2</strong> feature in your <strong class="source-inline">server.xml</strong> file (and a few other stanzas in the <strong class="source-inline">server.xml</strong> file, a stanza in the WAR file's <strong class="source-inline">web.xml</strong>, and a signing key in your <strong class="source-inline">keystore/truststore</strong>), you can cause the app server to reject any calls that don't have the required JWT in either the Authorization HTTP header or in a cookie.</p>
			<p>This is a very powerful feature, in that you get nice single sign-on enforcement, without having to edit your Java code at all. If someone tries to invoke your microservice without attaching an appropriate JWT, it will get rejected with a <strong class="source-inline">403</strong> error:</p>
			<p class="source-code">jalcorn@Johns-MBP-8 StockTrader % </p>
			<p class="source-code">curl -I http://localhost:9080/broker</p>
			<p class="source-code">HTTP/1.1 403 Forbidden</p>
			<p class="source-code">X-Powered-By: Servlet/4.0</p>
			<p class="source-code">Content-Type: text/html;charset=ISO-8859-1</p>
			<p class="source-code">$WSEP: </p>
			<p class="source-code">Content-Language: en-US</p>
			<p class="source-code">Connection: Close</p>
			<p class="source-code">Date: Tue, 11 May 2021 05:27:45 GMT</p>
			<p class="source-code">jalcorn@Johns-MBP-8 StockTrader %</p>
			<p>When this occurs, you will see the following message get logged by your container:</p>
			<p class="source-code">[ERROR] CWWKS5522E: The MicroProfile JWT feature cannot perform authentication because a MicroProfile JWT cannot be found in the request.</p>
			<p>Getting such powerful security enforcement, without any Java coding on your part, is a very nice feature provided by MicroProfile!</p>
			<h1 id="_idParaDest-161"><a id="_idTextAnchor172"/>Summary</h1>
			<p>You should now have a feel for how to build and unit test any of the microservices in the Stock Trader application. You should also now be comfortable with how to containerize such microservices, and then run such containers and invoke such microservices.</p>
			<p>Note that, often, rather than running such build steps as we've covered in this chapter manually from Command Prompt, you will have a DevOps pipeline that runs such steps for you, such as automatically kicking off via a webhook when you commit a change to your Git repository. For example, see this blog entry on such a CI/CD pipeline for the Trader microservice, which also performs various security and compliance checks: <a href="https://medium.com/cloud-engagement-hub/are-your-ci-cd-processes-compliant-cee6db1cf82a">https://medium.com/cloud-engagement-hub/are-your-ci-cd-processes-compliant-cee6db1cf82a</a>. But it's good to understand how to do stuff manually, rather than it just seeming like some magical, mysterious thing occurs to get to where your container image is built and available in your image registry.</p>
			<p>We've also covered how Stock Trader benefits from many of the MicroProfile features, even though it is not explicitly coded to such features. The fact that modernizing to a MicroProfile-compliant app server offers such benefits "for free," without your developers having to spend time modifying their code, is a strong motivator for engaging in such an application modernization effort.</p>
			<p>In the next chapter, we will look at how to deploy this application to an OpenShift cluster, via its operator, and will look at how we can use it to perform some <em class="italic">Day 2</em> operations.</p>
		</div>
	</body></html>