- en: '*Chapter 5*: Strings, Input/Output,and Files'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you will be presented with the `String` class methods in more
    detail. We will also discuss popular string utilities from standard libraries
    and the Apache Commons project. An overview of Java input/output streams and the
    related classes of the `java.io` packages will follow, along with some classes
    of the `org.apache.commons.io` package. The file-managing classes and their methods
    are described in a dedicated section. After completing this chapter, you will
    be able to write code that processes strings and files, using standard Java API
    and Apache Commons utilities.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: String processing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I/O streams
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: File management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apache Commons’ `FileUtils` and `IOUtils` utilities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To be able to execute the code examples provided in this chapter, you will
    need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A computer with a Microsoft Windows, Apple macOS, or Linux operating system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Java SE version 17 or later
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An IDE or code editor you prefer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The instructions for how to set up a Java SE and IntelliJ IDEA editor were provided
    in [*Chapter 1*](B18388_01_ePub.xhtml#_idTextAnchor015), *Getting Started with
    Java 17*, in this book. The files with the code examples for this chapter are
    available in the GitHub repository at [https://github.com/PacktPublishing/Learn-Java-17-Programming.git](https://github.com/PacktPublishing/Learn-Java-17-Programming.git)
    in the [examples/src/main/java/com/packt/learnjava/ch05_stringsIoStreams](https://examples/src/main/java/com/packt/learnjava/ch05_stringsIoStreams)
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: String processing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In mainstream programming, `String` probably is the most popular class. In [*Chapter
    1*](B18388_01_ePub.xhtml#_idTextAnchor015), *Getting Started with Java 17*, we
    learned about this class, its literals, and its specific feature called `String`
    class methods and utility classes from the standard library, and the `StringUtils`
    class from the `org.apache.commons.lang3` package in particular.
  prefs: []
  type: TYPE_NORMAL
- en: Methods of the String class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `String` class has more than 70 methods that enable analyzing, modifying,
    and comparing strings, and converting numeric literals into the corresponding
    string literals. To see all the methods of the `String` class, please refer to
    the Java API online at [https://docs.oracle.com/en/java/javase](https://docs.oracle.com/en/java/javase).
  prefs: []
  type: TYPE_NORMAL
- en: String analysis
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `length()` method returns the number of characters in the string, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The following `isEmpty()` method returns `true` when the length of the string
    (count of characters) is `0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The `indexOf()` and `lastIndexOf()` methods return the position of the specified
    substring in the string shown in this code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the first character in the string has a position (index) of
    `0`, and the absence of the specified substring results in the index `-1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `matches()` method applies the regular expression (passed as an argument)
    to the string as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Regular expressions are outside the scope of this book. You can learn about
    them at [https://www.regular-expressions.info](https://www.regular-expressions.info).
    In the preceding example, the `[a-z]+` expression matches one or more letters
    only.
  prefs: []
  type: TYPE_NORMAL
- en: String comparison
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In [*Chapter 3*](B18388_03_ePub.xhtml#_idTextAnchor079), *Java Fundamentals*,
    we talked about the `equals()` method that returns `true` only when two `String`
    objects or literals are spelled exactly the same way. The following code snippet
    demonstrates how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Another `String` class, the `equalsIgnoreCase()` method, does a similar job
    but ignores the difference in the characters’ case, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The `contentEquals()` method acts similar to the `equals()` method, as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The difference is that the `equals()` method checks whether both values are
    represented by the `String` class, while `contentEquals()` compares only the characters
    (content) of the character sequence. The character sequence can be represented
    by `String`, `StringBuilder`, `StringBuffer`, `CharBuffer`, or any other class
    that implements a `CharSequence` interface. Nevertheless, the `contentEquals()`
    method will return `true` if both sequences contain the same characters, while
    the `equals()` method will return `false` if one of the sequences is not created
    by the `String` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `contains()` method returns `true` if the `string` contains a certain substring,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The `startsWith()` and `endsWith()` methods perform a similar check but only
    at the start of the string or the end of the string value, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The `compareTo()` and `compareToIgnoreCase()` methods compare strings lexicographically
    – based on the Unicode value of each character in the strings. They return the
    value `0` if the strings are equal, a negative integer value if the first string
    is lexicographically less (has a smaller Unicode value) than the second string,
    and a positive integer value if the first string is lexicographically greater
    than the second string (has a bigger Unicode value), as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: From this code snippet, you can see that the `compareTo()` and `compareToIgnoreCase()`
    methods are based on the code points of the characters that compose the strings.
    The reason the `s4` string is bigger than the `s5` string by `32` is because the
    code point of the `a` character (`97`) is bigger than the code point of the `A`
    character (`65`) by `32`.
  prefs: []
  type: TYPE_NORMAL
- en: The given example also shows that the `codePointAt()` method returns the code
    point of the character located in the string at the specified position. The code
    points were described in the *Integral types* section of [*Chapter 1*](B18388_01_ePub.xhtml#_idTextAnchor015),
    *Getting Started with Java 17*.
  prefs: []
  type: TYPE_NORMAL
- en: String transformation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `substring()` method returns the substring, starting with the specified
    position (index), as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The `format()` method uses the passed-in first argument as a template and inserts
    the other arguments in the corresponding position of the template sequentially.
    The following code example prints the sentence `Hey, Nick! Give me 2 apples, please!`
    three times:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: The `%s` and `%d` symbols are called `java.util.Formatter` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `concat()` method works the same way as the arithmetic operator (`+`),
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'The following `join()` method acts similarly but allows the addition of a delimiter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'The following group of the `replace()`, `replaceFirst()`, and `replaceAll()`
    methods replace certain characters in the string with the provided ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: The first line of the preceding code replaces all the instances of `"bc"` with
    `"42"`. The second replaces only the first instance of `"bc"` with `"42"`, and
    the last one replaces all the substrings that match the provided regular expression
    with `"42"`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `toLowerCase()` and `toUpperCase()` methods change the case of the whole
    string, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'The `split()` method breaks the string into substrings, using the provided
    character as the delimiter, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'There are several `valueOf()` methods that transform the values of a primitive
    type to a `String` type, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: There are also the `()` and `getChars()` methods that transform a string to
    an array of a corresponding type, while the `chars()` method creates an `IntStream`
    of characters (their code points). We will talk about streams in [*Chapter 14*](B18388_14_ePub.xhtml#_idTextAnchor296),
    *Java Standard Streams*.
  prefs: []
  type: TYPE_NORMAL
- en: Methods added with Java 11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Java 11 introduced several new methods in the `String` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `repeat()` method allows you to create a new `String` value based on multiple
    concatenations of the same string, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'The `isBlank()` method returns `true` if the string has a length of `0` or
    consists of white spaces only, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'The `stripLeading()` method removes leading white spaces from the string, the
    `stripTrailing()` method removes trailing white spaces, and the `strip()` method
    removes both, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, the `lines()` method breaks the string by line terminators and
    returns a `Stream<String>` of resulting lines. A line terminator is an escape
    sequence line feed (`\n`) (`\u000a`), a carriage return (`\r`) (`\u000d`), or
    a carriage return followed immediately by a line feed (`\r\n`) (`\u000d\u000a`),
    such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18388_Figure_5.1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We will talk about streams in [*Chapter 14*](B18388_14_ePub.xhtml#_idTextAnchor296),
    *Java Standard Streams*.
  prefs: []
  type: TYPE_NORMAL
- en: String utilities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In addition to the `String` class, there are many other classes that have methods
    that process the `String` values. Among the most useful is the `StringUtils` class
    of the `org.apache.commons.lang3` package from a project called an `pom.xml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'The `StringUtils` class is the favorite of many programmers. It complements
    methods of the `String` class by providing the following null-safe operations
    (when a method is implemented in such a way – by checking the values for null,
    for example – that it does not throw `NullPointerException`):'
  prefs: []
  type: TYPE_NORMAL
- en: '`isBlank(CharSequence cs)`: Returns `true` if the input value is white space,
    empty (`""`), or `null`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`isNotBlank(CharSequence cs)`: Returns `false` when the preceding method returns
    `true`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`isEmpty(CharSequence cs)`: Returns `true` if the input value is empty (`""`)
    or `null`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`isNotEmpty(CharSequence cs)`: Returns `false` when the preceding method returns
    `true`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`trim(String str)`: Removes leading and trailing white space from the input
    value and processes `null`, empty (`""`), and white space, as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`trimToNull(String str)`: Removes leading and trailing white space from the
    input value and processes `null`, empty (`""`), and white space, as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`trimToEmpty(String str)`: Removes leading and trailing white space from the
    input value and processes `null`, empty (`""`), and white space, as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`strip(String str)`, `stripToNull(String str)`, and `stripToEmpty(String str)`:
    Produces the same result as the preceding `trim(String str)`, `trimToNull(String
    str)`, and `trimToEmpty(String str)` methods but uses a more extensive definition
    of white space (based on `Character.isWhitespace(int codepoint)`) and thus removes
    the same characters as the `trim(String str)`, `trimToNull(String str)`, and `trimToEmpty(String
    str)` methods do, and more'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`strip(String str, String stripChars)`, `stripAccents(String input)`, `stripAll(String...
    strs)`, `stripAll(String[] strs, String stripChars)`, `stripEnd(String str, String
    stripChars)`, and `stripStart(String str, String stripChars)`: Removes particular
    characters from particular parts of `String` or `String[]` array elements'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`startsWith(CharSequence str, CharSequence prefix)`, `startsWithAny(CharSequence
    string, CharSequence... searchStrings)`, `startsWithIgnoreCase(CharSequence str,
    CharSequence prefix)`, and similar `endsWith*()` methods: Checks whether a `String`
    value starts (or ends) with a certain prefix (or suffix)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`indexOf`, `lastIndexOf`, `contains`: Checks an index in a null-safe manner'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`indexOfAny`, `lastIndexOfAny`, `indexOfAnyBut`, `lastIndexOfAnyBut`: Returns
    an index'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`containsOnly`, `containsNone`, and `containsAny`: Checks whether the value
    contains certain characters or not'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`substring`, `left`, `right`, and `mid`: Returns a substring in a null-safe
    manner'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`substringBefore`, `substringAfter`, `substringBetween`: Returns a substring
    from a relative position'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`split` or `join`: Splits or joins a value (respectively)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`remove` and `delete`: Eliminates a substring'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`replace` and `overlay`: Replaces a value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`chomp` and `chop`: Removes the end'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`appendIfMissing`: Adds a value if not present'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`prependIfMissing`: Prepends a prefix to the start of the `String` value if
    not present'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`leftPad`, `rightPad`, `center`, and `repeat`: Adds padding'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`upperCase`, `lowerCase`, `swapCase`, `capitalize`, and `uncapitalize`: Changes
    the case'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`countMatches`: Returns the number of the substring occurrences'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`isWhitespace`, `isAsciiPrintable`, `isNumeric`, `isNumericSpace`, `isAlpha`,
    `isAlphaNumeric`, `isAlphaSpace`, and `isAlphaNumericSpace`: Checks the presence
    of a certain type of characters'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`isAllLowerCase` and `isAllUpperCase`: Checks the case'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`defaultString`, `defaultIfBlank`, and `defaultIfEmpty`: Returns a default
    value if `null`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rotate`: Rotates characters using a circular shift'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`reverse` and `reverseDelimited`: Reverses characters or delimited groups of
    characters'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`abbreviate` and `abbreviateMiddle`: Abbreviates a value using an ellipsis
    or another value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`difference`: Returns the differences in values'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getLevenshteinDistance`: Returns the number of changes needed to transform
    one value into another'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see, the `StringUtils` class has a very rich (we have not listed
    everything) set of methods for string analysis, comparison, and transformation
    that complements the methods of the `String` class.
  prefs: []
  type: TYPE_NORMAL
- en: I/O streams
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Any software system has to receive and produce some kind of data that can be
    organized as a set of isolated input/output or as a stream of data. A stream can
    be limited or endless. A program can read from a stream (which is called an **input
    stream**) or write to a stream (which is called an **output stream**). The Java
    I/O stream is either byte-based or character-based, meaning that its data is interpreted
    either as raw bytes or as characters.
  prefs: []
  type: TYPE_NORMAL
- en: The `java.io` package contains classes that support many, but not all, possible
    data sources. It is built for the most part around input from and to files, network
    streams, and internal memory buffers. It does not contain many classes necessary
    for network communication. They belong to `java.net`, `javax.net`, and other packages
    of a Java networking API. Only after the networking source or destination is established
    (a network socket, for example) can a program read and write data using the `InputStream`
    and `OutputStream` classes of the `java.io` package.
  prefs: []
  type: TYPE_NORMAL
- en: The classes of the `java.nio` package have pretty much the same functionality
    as the classes of `java.io` packages. But, in addition, they can work in *non-blocking*
    mode, which can substantially increase performance in certain situations. We will
    talk about non-blocking processing in [*Chapter 15*](B18388_15_ePub.xhtml#_idTextAnchor315),
    *Reactive Programming*.
  prefs: []
  type: TYPE_NORMAL
- en: Stream data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Input data has to be binary – expressed in 0s and 1s – at the very least because
    that is the format a computer can read. Data can be read or written one byte at
    a time or an array of several bytes at a time. These bytes can remain binary or
    can be interpreted as characters.
  prefs: []
  type: TYPE_NORMAL
- en: In the first case, they can be read as bytes or byte arrays by the descendants
    of the `InputStream` and `OutputStream` classes, such as (omitting the package
    name if the class belongs to the `java.io` package) `ByteArrayInputStream`, `ByteArrayOutputStream`,
    `FileInputStream`, `FileOutputStream`, `ObjectInputStream`, `ObjectOutputStream`,
    `javax.sound.sampled.AudioInputStream`, and `org.omg.CORBA.portable.OutputStream`;
    which one you use depends on the source or destination of the data. The `InputStream`
    and `OutputStream` classes themselves are abstract and cannot be instantiated.
  prefs: []
  type: TYPE_NORMAL
- en: In the second case, data that can be interpreted as characters is called `Reader`
    and `Writer`, which are abstract classes too. Examples of their sub-classes are
    `CharArrayReader` and `CharArrayWriter`, `InputStreamReader` and `OutputStreamWriter`,
    `PipedReader` and `PipedWriter`, and `StringReader` and `StringWriter`.
  prefs: []
  type: TYPE_NORMAL
- en: You may have noticed that we listed the classes in pairs. But not every input
    class has a matching output specialization – for example, there are the `PrintStream`
    and `PrintWriter` classes that support output to a printing device, but there
    is no corresponding input partner, not by name at least. However, there is a `java.util.Scanner`
    class that parses input text in a known format.
  prefs: []
  type: TYPE_NORMAL
- en: There is also a set of buffer-equipped classes that help to improve performance
    by reading or writing a bigger chunk of data at a time, especially in cases when
    access to a source or destination takes a long time.
  prefs: []
  type: TYPE_NORMAL
- en: In the rest of this section, we will review classes of the `java.io` package
    and some popular related classes from other packages.
  prefs: []
  type: TYPE_NORMAL
- en: The InputStream class and its subclasses
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the Java Class Library, the `InputStream` abstract class has the following
    direct implementations: `ByteArrayInputStream`, `FileInputStream`, `ObjectInputStream`,
    `PipedInputStream`, `SequenceInputStream`, `FilterInputStream`, and `javax.sound.sampled.AudioInputStream`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'All of them can be used as they are or override the following methods of the
    `InputStream` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '`int available()`: Returns the number of bytes available for reading'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void close()`: Closes the stream and releases the resources'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void mark(int readlimit)`: Marks a position in the stream and defines how
    many bytes can be read'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`boolean markSupported()`: Returns `true` if the marking is supported'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`static InputStream nullInputStream()`: Creates an empty stream'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`abstract int read()`: Reads the next byte in the stream'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`int read(byte[] b)`: Reads data from the stream into the `b` buffer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`int read(byte[] b, int off, int len)`: Reads `len` or fewer bytes from the
    stream into the `b` buffer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`byte[] readAllBytes()`: Reads all the remaining bytes from the stream'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`int readNBytes(byte[] b, int off, int len)`: Reads `len` or fewer bytes into
    the `b` buffer at the `off` offset'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`byte[] readNBytes(int len)`: Reads `len` or fewer bytes into the `b` buffer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void reset()`: Resets the reading location to the position where the `mark()`
    method was last called'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`long skip(long n)`: Skips `n` or fewer bytes of the stream; returns the actual
    number of bytes skipped'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`long transferTo(OutputStream out)`: Reads from the input stream and writes
    to the provided output stream byte by byte; returns the actual number of bytes
    transferred'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`abstract int read()` is the only method that has to be implemented, but most
    of the descendants of this class override many of the other methods too.'
  prefs: []
  type: TYPE_NORMAL
- en: ByteArrayInputStream
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `ByteArrayInputStream` class allows reading a byte array as an input stream.
    It has the following two constructors that create an object of the class and define
    the buffer used to read the input stream of bytes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ByteArrayInputStream(byte[] buffer)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ByteArrayInputStream(byte[] buffer, int offset, int length)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The second of the constructors allows you to set, in addition to the buffer,
    the offset and the length of the buffer too. Let’s look at an example and see
    how this class can be used. We will assume there is a source of the `byte[]` array
    with data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: The `bytesSource()` method produces the array of bytes that fills the buffer
    that is passed into the constructor of the `ByteArrayInputStream` class as a parameter.
    The resulting stream is then read byte by byte using the `read()` method until
    the end of the stream is reached (and the `read()` method returns `-1`). Each
    new byte is printed out (without a line feed and with white space after it, so
    all the read bytes are displayed in one line separated by the white space).
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding code is usually expressed in a more compact form, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of just printing the bytes, they can be processed in any other manner
    necessary, including interpreting them as characters, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: But, in such a case, it is better to use one of the `Reader` classes that are
    specialized for character processing. We will talk about them in the *Reader and
    writer classes and their subclasses* section.
  prefs: []
  type: TYPE_NORMAL
- en: FileInputStream
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `FileInputStream` class gets data from a file in a filesystem – the raw
    bytes of an image, for example. It has the following three constructors:'
  prefs: []
  type: TYPE_NORMAL
- en: '`FileInputStream(File file)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FileInputStream(String name)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FileInputStream(FileDescriptor fdObj)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Each constructor opens the file specified as the parameter. The first constructor
    accepts the `File` object; the second, the path to the file in the filesystem;
    and the third, the file descriptor object that represents an existing connection
    to an actual file in the filesystem. Let’s look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `src/main/resources` folder, we have created the `hello.txt` file that
    has only one line in it – `Hello!`. The output of the preceding example looks
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface'
  prefs: []
  type: TYPE_NORMAL
- en: Description automatically generated](img/B18388_Figure_5.2.png)
  prefs: []
  type: TYPE_NORMAL
- en: 'After reading bytes from the `hello.txt` file, we decided, for demo purposes,
    to cast each `byte` to `char` so that you can see that the code does read from
    the specified file, but the `FileReader` class is a better choice for text file
    processing (we will discuss it shortly). Without the cast, the result would be
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: 'By the way, because the `src/main/resources` folder is placed by the IDE (using
    Maven) on the classpath, a file placed in it can also be accessed via a class
    loader that creates a stream using its own `InputStream` implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: The `InputOutputStream` class in the preceding example is not a class from some
    library. It is just the main class we used to run the example. The `InputOutputStream.class.getResourceAsStream()`
    construct allows you to use the same classloader that has loaded the `InputOutputStream`
    class for the purpose of finding a file on the classpath and creating a stream
    that contains its content. In the *File management* section, we will present other
    ways of reading a file too.
  prefs: []
  type: TYPE_NORMAL
- en: ObjectInputStream
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The set of methods of the `ObjectInputStream` class is much bigger than the
    set of methods of any other `InputStream` implementation. The reason for that
    is that it is built around reading the values of the object fields that can be
    of various types. In order for `ObjectInputStream` to be able to construct an
    object from the input stream of data, the object has to be *deserializable*, which
    means it has to be *serializable* in the first place – that is, to be convertible
    into a byte stream. Usually, it is done for the purpose of transporting objects
    over a network. At the destination, the serialized objects are deserialized, and
    the values of the original objects are restored.
  prefs: []
  type: TYPE_NORMAL
- en: 'Primitive types and most Java classes, including the `String` class and primitive
    type wrappers, are serializable. If a class has fields of custom types, they have
    to be made serializable by implementing `java.io.Serizalizable`. How to do that
    is outside the scope of this book. For now, we are going to use only the serializable
    types. Let’s look at this class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: We have to tell the compiler that it is serializable. Otherwise, the compilation
    will fail. It is done in order to make sure that, before stating that the class
    is serializable, the programmer either reviewed all the fields and made sure they
    are serializable or has implemented the methods necessary for the serialization.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we can create an input stream and use `ObjectInputStream` for deserialization,
    we need to serialize the object first. That is why we first use `ObjectOutputStream`
    and `FileOutputStream` to serialize an object and write it into the `someClass.bin`
    file. We will talk more about them in the *The OutputStream class and its subclasses*
    section. Then, we read from the file using `FileInputStream` and deserialize the
    file content using `ObjectInputStream`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: Note that the file has to be created first before the preceding code is run.
    We will show how it can be done in the *Creating files and directories* section.
    And, as a reminder, we have used the `try-with-resources` statement because `InputStream`
    and `OutputStream` both implement the `Closeable` interface.
  prefs: []
  type: TYPE_NORMAL
- en: PipedInputStream
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A piped input stream has a very particular specialization; it is used as one
    of the mechanisms of communication between threads. One thread reads from a `PipedInputStream`
    object and passes data to another thread that writes data to a `PipedOutputStream`
    object. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, data can be moved in the opposite direction when one thread
    reads from a `PipedOutputStream` object and another thread writes to a `PipedInputStream`
    object as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: Those who work in this area are familiar with the message, `Broken pipe`, which
    means that the supplying data pipe stream has stopped working.
  prefs: []
  type: TYPE_NORMAL
- en: 'The piped streams can also be created without any connection and connected
    later, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: 'As an example, here are two classes that are going to be executed by different
    threads – first, the `PipedOutputWorker` class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE189]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE193]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE194]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE195]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE196]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE197]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE198]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE199]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE200]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE201]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE202]'
  prefs: []
  type: TYPE_PRE
- en: 'The `PipedOutputWorker` class has the `run()` method (because it implements
    a `Runnable` interface) that writes into the stream the three numbers `1`, `2`,
    and `3`, and then closes. Now, let’s look at the `PipedInputWorker` class, as
    shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE203]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE204]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE205]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE206]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE207]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE208]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE209]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE210]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE211]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE212]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE213]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE214]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE215]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE216]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE217]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE218]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE219]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE220]'
  prefs: []
  type: TYPE_PRE
- en: 'It also has a `run()` method (because it implements a `Runnable` interface)
    that reads from the stream and prints out each byte until the stream ends (indicated
    by `-1`). Now, let’s connect these pipes and execute a `run()` method of these
    classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE221]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE222]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE223]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE224]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE225]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE226]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE227]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE228]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE229]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE230]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the objects of the workers were passed into the constructor
    of the `Thread` class. The `start()` method of the `Thread` object executes the
    `run()` method of the passed in `Runnable`. And we see the results as expected
    –`PipedInputWorker` prints all the bytes written to the piped stream by `PipedOutputWorker`.
    We will go into more detail about threads in [*Chapter 8*](B18388_08_ePub.xhtml#_idTextAnchor187),
    *Multithreading and Concurrent Processing*.
  prefs: []
  type: TYPE_NORMAL
- en: SequenceInputStream
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `SequenceInputStream` class concatenates input streams passed into one
    of the following constructors as parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`SequenceInputStream(InputStream s1, InputStream s2)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SequenceInputStream(Enumeration<InputStream> e)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SequenceInputStream` class reads from the first input string until it ends,
    whereupon it reads from the second one, and so on, until the end of the last of
    the streams. As an example, let’s create a `howAreYou.txt` file (with the text,
    `How are you?`) in the `resources` folder next to the `hello.txt` file. The `SequenceInputStream`
    class can then be used as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE231]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE232]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE233]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE234]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE235]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE236]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE237]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE238]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE239]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE240]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE241]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE242]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE243]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE244]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE245]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE246]'
  prefs: []
  type: TYPE_PRE
- en: Similarly, when an enumeration of input streams is passed in, each of the streams
    is read (and printed in our case) until the end.
  prefs: []
  type: TYPE_NORMAL
- en: FilterInputStream
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `FilterInputStream` class is a wrapper around the `InputStream` object
    passed as a parameter in the constructor. Here is the constructor and the two
    `read()` methods of the `FilterInputStream` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE247]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE248]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE249]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE250]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE251]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE252]'
  prefs: []
  type: TYPE_PRE
- en: All the other methods of the `InputStream` class are overridden similarly; the
    function is delegated to the object assigned to the `in` property.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, the constructor is protected, which means that only the child
    has access to it. Such a design hides from the client the actual source of the
    stream and forces the programmer to use one of the `FilterInputStream` class extensions:
    `BufferedInputStream`, `CheckedInputStream`, `DataInputStream`, `PushbackInputStream`,
    `javax.crypto.CipherInputStream`, `java.util.zip.DeflaterInputStream`, `java.util.zip.InflaterInputStream`,
    `java.security.DigestInputStream`, or `javax.swing.ProgressMonitorInputStream`.
    Alternatively, you can create a custom extension. But, before creating your own
    extension, look at the listed classes and see if one of them fits your needs.
    Here is an example of using a `BufferedInputStream` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE253]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE254]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE255]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE256]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE257]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE258]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE259]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE260]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE261]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE262]'
  prefs: []
  type: TYPE_PRE
- en: The `BufferedInputStream` class uses the buffer to improve performance. When
    the bytes from the stream are skipped or read, the internal buffer is automatically
    refilled with as many bytes as necessary at the time, from the contained input
    stream.
  prefs: []
  type: TYPE_NORMAL
- en: The `CheckedInputStream` class adds a checksum of the data being read that allows
    the verification of the integrity of the input data using the `getChecksum()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: The `DataInputStream` class reads and interprets input data as primitive Java
    data types in a machine-independent way.
  prefs: []
  type: TYPE_NORMAL
- en: The `PushbackInputStream` class adds the ability to push back the read data
    using the `unread()` method. It is useful in situations when the code has the
    logic of analyzing the just-read data and deciding to unread it, so it can be
    reread at the next step.
  prefs: []
  type: TYPE_NORMAL
- en: The `javax.crypto.CipherInputStream` class adds `Cipher` to the `read()` methods.
    If `Cipher` is initialized for decryption, `javax.crypto.CipherInputStream` will
    attempt to decrypt the data before returning.
  prefs: []
  type: TYPE_NORMAL
- en: The `java.util.zip.DeflaterInputStream` class compresses data in the deflate
    compression format.
  prefs: []
  type: TYPE_NORMAL
- en: The `java.util.zip.InflaterInputStream` class uncompresses data in the deflate
    compression format.
  prefs: []
  type: TYPE_NORMAL
- en: The `java.security.DigestInputStream` class updates the associated message digest
    using the bits going through the stream. The `on (boolean on)` method turns the
    `digest` function on or off. The calculated digest can be retrieved using the
    `getMessageDigest()` method.
  prefs: []
  type: TYPE_NORMAL
- en: The `javax.swing.ProgressMonitorInputStream` class provides a monitor of the
    progress of reading from `InputStream`. The monitor object can be accessed using
    the `getProgressMonitor()` method.
  prefs: []
  type: TYPE_NORMAL
- en: javax.sound.sampled.AudioInputStream
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `AudioInputStream` class represents an input stream with a specified audio
    format and length. It has the following two constructors:'
  prefs: []
  type: TYPE_NORMAL
- en: '`AudioInputStream (InputStream stream, AudioFormat format, long length)`: Accepts
    the stream of audio data, the requested format, and the length in sample frames'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AudioInputStream (TargetDataLine line)`: Accepts the target data line indicated'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `javax.sound.sampled.AudioFormat` class describes audio-format properties
    such as channels, encoding, frame rate, and similar. The `javax.sound.sampled.TargetDataLine`
    class has the `open()` method that opens the line with the specified format and
    the `read()` method that reads audio data from the data line’s input buffer.
  prefs: []
  type: TYPE_NORMAL
- en: There is also the `javax.sound.sampled.AudioSystem` class, and its methods handle
    `AudioInputStream` objects. They can be used for reading from an audio file, a
    stream, or a URL, and they write to an audio file. They also can be used to convert
    an audio stream to another audio format.
  prefs: []
  type: TYPE_NORMAL
- en: The OutputStream class and its subclasses
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `OutputStream` class is a peer of the `InputStream` class that writes data
    instead of reading. It is an abstract class that has the following direct implementations
    in the `ByteArrayOutputStream`, `FilterOutputStream`, `ObjectOutputStream`, `PipedOutputStream`,
    and `FileOutputStream`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `FileOutputStream` class has the following direct extensions: `BufferedOutputStream`,
    `CheckedOutputStream`, `DataOutputStream`, `PrintStream`, `javax.crypto.CipherOutputStream`,
    `java.util.zip.DeflaterOutputStream`, `java.security.DigestOutputStream`, and
    `java.util.zip.InflaterOutputStream`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'All of them can be used as they are or override the following methods of the
    `OutputStream` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '`void close()`: Closes the stream and releases the resources'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void flush()`: Forces the remaining bytes to be written out'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`static OutputStream nullOutputStream()`: Creates a new `OutputStream` that
    writes nothing'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void write(byte[] b)`: Writes the provided byte array to the output stream'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void write(byte[] b, int off, int len)`: Writes `len` bytes of the provided
    byte array, starting at the `off` offset, to the output stream'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`abstract void write(int b)`: Writes the provided byte to the output stream'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The only method that has to be implemented is `abstract void write(int b)`,
    but most of the descendants of the `OutputStream` class override many of the other
    methods too.
  prefs: []
  type: TYPE_NORMAL
- en: After learning about the input streams in the *The InputStream class and its
    subclasses* section, all of the `OutputStream` implementations, except the `PrintStream`
    class, should be intuitively familiar to you. So, we will discuss here only the
    `PrintStream` class.
  prefs: []
  type: TYPE_NORMAL
- en: PrintStream
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `PrintStream` class adds to another output stream the ability to print
    data as characters. We have actually used it already many times. The `System`
    class has an object of the `PrintStream` class set as a `System.out` public static
    property. This means that every time we print something using `System.out`, we
    are using the `PrintStream` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE263]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s look at another example of the `PrintStream` class usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE264]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE265]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE266]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE267]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE268]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE269]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE270]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the `PrintStream` class takes the `FileOutputStream` object
    and prints the characters generated by it. In this case, it prints out all the
    bytes that `FileOutputStream` writes to the file. By the way, there is no need
    to create the destination file explicitly. If absent, it will be created automatically
    inside the `FileOutputStream` constructor. If we open the file after the preceding
    code is run, we will see one line in it – `"Hi there!"`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, the same result can be achieved using another `PrintStream`
    constructor that takes the `File` object, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE271]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE272]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE273]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE274]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE275]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE276]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE277]'
  prefs: []
  type: TYPE_PRE
- en: 'An even simpler solution can be created using the third variation of the `PrintStream`
    constructor that takes the filename as a parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE278]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE279]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE280]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE281]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE282]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE283]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous two examples are possible because the `PrintStream` constructor
    uses the `FileOutputStream` class behind the scenes, exactly as we did it in the
    first example of the `PrintStream` class usage. So, the `PrintStream` class has
    several constructors just for convenience, but all of them essentially have the
    same functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '`PrintStream(File file)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PrintStream(File file, String csn)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PrintStream(File file, Charset charset)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PrintStream(String fileName)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PrintStream(String fileName, String csn)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PrintStream(String fileName, Charset charset)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PrintStream(OutputStream out)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PrintStream(OutputStream out, boolean autoFlush)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PrintStream(OutputStream out, boolean autoFlush, String encoding)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PrintStream(OutputStream out, boolean autoFlush, Charset charset)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Some of the constructors also take a `Charset` instance or just its name (`String
    csn`), which allows you to apply a different mapping between sequences of 16-bit
    Unicode code units and sequences of bytes. You can see all available charsets
    by just printing them out, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE284]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE285]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE286]'
  prefs: []
  type: TYPE_PRE
- en: Other constructors take `boolean autoFlush` as a parameter. This parameter indicates
    (when `true`) that the output buffer should be flushed automatically when an array
    is written or the symbol end-of-line is encountered.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once an object of `PrintStream` is created, it provides a variety of methods,
    as listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`void print(T value)`: Prints the value of any `T` primitive type passed in
    without moving to another line'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void print(Object obj)`: Calls the `toString()` method on the passed in object
    and prints the result without moving to another line; does not generate `NullPointerException`
    in case the passed-in object is `null` and prints `null` instead'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void println(T value)`: Prints the value of any `T` primitive type passed
    in and moves to another line'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void println(Object obj)`: Calls the `toString()` method on the passed-in
    object, prints the result, and moves to another line; does not generate `NullPointerException`
    in case the passed-in object is `null` and prints `null` instead'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void println()`: Just moves to another line'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PrintStream printf(String format, Object... values)`: Substitutes the placeholders
    in the provided `format` string with the provided `values` and writes the result
    into the stream'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PrintStream printf(Locale l, String format, Object... args)`: The same as
    the preceding method but applies localization using the provided `Local` object;
    if the provided `Local` object is `null`, no localization is applied, and this
    method behaves exactly like the preceding one'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PrintStream format(String format, Object... args)` and `PrintStream format(Locale
    l, String format, Object... args)`: Behaves the same way as `PrintStream printf(String
    format, Object... values)` and `PrintStream printf(Locale l, String format, Object...
    args)` (already described in the list), such as the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE287]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding example, (`%`) indicates a formatting rule. The following symbol
    (`s`) indicates a `String` value. Other possible symbols in this position can
    be (`d`) (decimal), (`f`) (floating-point), and so on. The symbol (`n`) indicates
    a new line (the same as the (`\n`) escape character). There are many formatting
    rules. All of them are described in the documentation for the `java.util.Formatter`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: '`PrintStream append(char c)`, `PrintStream append(CharSequence c)`, and `PrintStream
    append(CharSequence c, int start, int end)`: Appends the provided character to
    the stream, such as the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE288]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With this, we conclude the discussion of the `OutputStream` subclass and now
    turn our attention to another class hierarchy – the `Reader` and `Writer` classes
    and their subclasses from the JCL.
  prefs: []
  type: TYPE_NORMAL
- en: The Reader and Writer classes and their subclasses
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we mentioned several times already, the `Reader` and `Writer` classes are
    very similar in their function to the `InputStream` and `OutputStream` classes
    but specialize in processing texts. They interpret stream bytes as characters
    and have their own independent `InputStream` and `OutputStream` class hierarchy.
    It is possible to process stream bytes as characters without `Reader` and `Writer`
    or any of their subclasses. We have seen such examples in the preceding sections
    describing the `InputStream` and `OutputStream` classes. However, using the `Reader`
    and `Writer` classes makes text processing simpler and code easier to read.
  prefs: []
  type: TYPE_NORMAL
- en: Reader and its subclasses
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `Reader` class is an abstract class that reads streams as characters. It
    is an analog to `InputStream` and has the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`abstract void close()`: Closes the stream and other used resources'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void mark(int readAheadLimit)`: Marks the current position in the stream'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`boolean markSupported()`: Returns `true` if the stream supports the `mark()`
    operation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`static Reader nullReader()`: Creates an empty `Reader` that reads no characters'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`int read()`: Reads one character'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`int read(char[] buf)`: Reads characters into the provided `buf` array and
    returns the count of the read characters'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`abstract int read(char[] buf, int off, int len)`: Reads the `len` characters
    into an array starting from the `off` index'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`int read(CharBuffer target)`: Attempts to read characters into the provided
    `target` buffer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`boolean ready()`: Returns `true` when the stream is ready to be read'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void reset()`: Resets the mark; however, not all streams support this operation,
    with some supporting it but not supporting a mark being set in the first place'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`long skip(long n)`: Attempts to skip the `n` characters; returns the count
    of skipped characters'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`long transferTo(Writer out)`: Reads all characters from this reader and writes
    the characters to the provided `Writer` object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see, the only methods that need to be implemented are the two abstract
    `read()` and `close()` methods. Nevertheless, many children of this class override
    other methods too, sometimes for better performance or different functionality.
    The `Reader` subclasses in the JCL are `CharArrayReader`, `InputStreamReader`,
    `PipedReader`, `StringReader`, `BufferedReader`, and `FilterReader`. The `BufferedReader`
    class has a `LineNumberReader` subclass, and the `FilterReader` class has a `PushbackReader`
    subclass.
  prefs: []
  type: TYPE_NORMAL
- en: Writer and its subclasses
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The abstract `Writer` class writes to character streams. It is an analog to
    `OutputStream` and has the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Writer append(char c)`: Appends the provided character to the stream'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Writer append(CharSequence c)`: Appends the provided character sequence to
    the stream'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Writer append(CharSequence c, int start, int end)`: Appends a subsequence
    of the provided character sequence to the stream'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`abstract void close()`: Flushes and closes the stream and related system resources'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`abstract void flush()`: Flushes the stream'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`static Writer nullWriter()`: Creates a new `Writer` object that discards all
    characters'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void write(char[] c)`: Writes an array of `c` characters'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`abstract void write(char[] c, int off, int len)`: Writes the `len` elements
    of an array of `c` characters, starting from the `off` index'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void write(int c)`: Writes one character'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void write(String str)`: Writes the provided string'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void write(String str, int off, int len)`: Writes a substring of the `len`
    length from the provided `str` string, starting from the `off` index'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see, the three abstract methods, `write(char[], int, int)`, `flush()`,
    and `close()`, must be implemented by the children of this class. They also typically
    override other methods too.
  prefs: []
  type: TYPE_NORMAL
- en: The `Writer` subclasses in the JCL are `CharArrayWriter`, `OutputStreamWriter`,
    `PipedWriter`, `StringWriter`, `BufferedWriter`, `FilterWriter`, and `PrintWriter`.
    The `OutputStreamWriter` class has a `FileWriter` subclass.
  prefs: []
  type: TYPE_NORMAL
- en: Other classes of the java.io package
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Other classes of the `java.io` package include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Console`: Allows interaction with the character-based console device, associated
    with the current Java Virtual Machine instance'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`StreamTokenizer`: Takes an input stream and parses it into `tokens`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ObjectStreamClass`: The serialization’s descriptor for classes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ObjectStreamField`: A description of a serializable field from a serializable
    class'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RandomAccessFile`: Allows random access for reading from and writing to a
    file, but its discussion is outside the scope of this book'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`File`: Allows creating and managing files and directories; described in the
    *File management* section'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Console
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are several ways to create and run a **Java Virtual Machine** (**JVM**)
    instance that executes an application. If the JVM is started from a command line,
    a console window is automatically opened. It allows you to type on the display
    from the keyboard; however, the JVM can be started by a background process too.
    In such a case, a console is not created.
  prefs: []
  type: TYPE_NORMAL
- en: To check programmatically whether a console exists, you can invoke the `System.console()`
    static method. If no console device is available, then an invocation of that method
    will return `null`. Otherwise, it will return an object of the `Console` class
    that allows interaction with the console device and the application user.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create the following `ConsoleDemo` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE289]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE290]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE291]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE292]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE293]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE294]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE295]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE296]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run it from the IDE, as we usually do, the result will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18388_Figure_5.3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: That is because the JVM was not launched from the command line. In order to
    do it, let’s compile our application and create a `.jar` file by executing the
    `mvn clean package` Maven command in the root directory of the project. (We assume
    that you have Maven installed on your computer.) It will delete the `target` folder,
    then recreate it, compile all the `.java` files to the corresponding `.class`
    files in the `target` folder, and then archive them in a `.jar` file, `learnjava-1.0-SNAPSHOT.jar`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can launch the `ConsoleDemo` application from the same project root
    directory using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE297]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding `–cp` command option depicts a classpath, so in our case, we
    tell the JVM to look for the classes in the `.jar` file in the folder target.
    The command is shown in two lines because the page width cannot accommodate it.
    But if you want to run it, make sure you do it as one line. The result will be
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18388_Figure_5.4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This tells us that we have the `Console` class object now. Let’s see what we
    can do with it. The class has the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`String readLine()`: Waits until the user hits the *Enter* key and reads the
    line of text from the console'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`String readLine(String format, Object... args)`: Displays a prompt (the message
    produced after the provided format had the placeholders substituted with the provided
    arguments), waits until the user hits the *Enter* key, and reads the line of text
    from the console; if no arguments (`args`) are provided, it displays the format
    as the prompt'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`char[] readPassword()`: Performs the same function as the `readLine()` function
    but without echoing the typed characters'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`char[] readPassword(String format, Object... args)`: Performs the same function
    as `readLine(String format, Object... args)` but without echoing the typed characters'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To run each of the following code sections individually, you need to comment
    out the `console1()` call in the `main` method and uncomment `console2()` or `console3()`,
    recompile using `mvn package`, and then rerun the `java` command shown previously.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s demonstrate the preceding methods with the following example (the `console2()`
    method):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE298]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE299]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE300]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE301]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE302]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE303]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE304]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE305]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE306]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE307]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE308]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE309]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE310]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE311]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE312]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of the preceding example is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18388_Figure_5.6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Some IDEs cannot run these examples and throw `NullPointerException`. If that
    is the case, run the console-related examples from the command line, as described
    previously. Don’t forget to run the `maven package` command every time you change
    code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another group of `Console` class methods can be used in conjunction with the
    previously demonstrated methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Console format(String format, Object... args)`: Substitutes the placeholders
    in the provided `format` string with the provided `args` values and displays the
    result'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Console printf(String format, Object... args)`: Behaves the same way as the
    `format()` method'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As an example, look at the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE313]'
  prefs: []
  type: TYPE_PRE
- en: 'It produces the same result as this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE314]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, the last three methods of the `Console` class are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`PrintWriter writer()`: Creates a `PrintWriter` object associated with this
    console that can be used for producing an output stream of characters'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Reader reader()`: Creates a `Reader` object associated with this console that
    can be used for reading the input as a stream of characters'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void flush()`: Flushes the console and forces any buffered output to be written
    immediately'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is an example of their usage (the `console3()` method):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE315]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE316]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE317]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE318]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE319]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE320]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE321]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE322]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE323]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE324]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE325]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of the preceding code looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18388_Figure_5.7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '`Reader` and `PrintWriter` can also be used to create other `Input` and `Output`
    streams that we have been talking about in this section.'
  prefs: []
  type: TYPE_NORMAL
- en: StreamTokenizer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `StreamTokenizer` class parses the input stream and produces tokens. Its
    `StreamTokenizer(Reader r)` constructor accepts a `Reader` object that is the
    source of the tokens. Every time the `int nextToken()` method is called on the
    `StreamTokenizer` object, the following happens:'
  prefs: []
  type: TYPE_NORMAL
- en: The next token is parsed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `StreamTokenizer` instance field, `ttype`, is populated by the value that
    indicates the token type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `ttype` value can be one of the following integer constants: `TT_WORD`,
    `TT_NUMBER`, `TT_EOL` (end-of-line), or `TT_EOF` (end-of-stream).'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If the `ttype` value is `TT_WORD`, the `StreamTokenizer` instance, the `sval`
    field, is populated by the `String` value of the token.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If the `ttype` value is `TT_NUMBER`, the `StreamTokenizer` instance field, `nval`,
    is populated by the `double` value of the token.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `lineno()` method of the `StreamTokenizer` instance returns the current
    line number.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let’s look at an example before talking about other methods of the `StreamTokenizer`
    class. Let’s assume that, in the project `resources` folder, there is a `tokens.txt`
    file that contains the following four lines of text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE326]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE327]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE328]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE329]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code will read the file and tokenize its content (the `streamTokenizer()`
    method of the `InputOutputStream` class):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE330]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE331]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE332]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE333]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE334]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE335]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE336]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE337]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE338]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE339]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE340]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE341]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE342]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE343]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE344]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE345]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE346]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE347]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE348]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE349]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE350]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE351]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE352]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE353]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE354]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE355]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE356]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run this code, the result will be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18388_Figure_5.8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We have used the `BufferedReader` class, which is a good practice for higher
    efficiency, but in our case, we can easily avoid it, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE357]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE358]'
  prefs: []
  type: TYPE_PRE
- en: 'The result would not change. We also used the following three methods that
    we have not described yet:'
  prefs: []
  type: TYPE_NORMAL
- en: '`void eolIsSignificant(boolean flag)`: Indicates whether the end-of-line should
    be treated as a token'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void commentChar(int ch)`: Indicates which character starts a comment, so
    the rest of the line is ignored'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`int lineno()`: Returns the current line number'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following methods can be invoked using the `StreamTokenizer` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '`void lowerCaseMode(boolean fl)`: Indicates whether a word token should be
    lowercase'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void ordinaryChar(int ch)`, `void ordinaryChars(int low, int hi)`: Indicate
    a specific character or the range of characters that have to be treated as *ordinary*
    (not as a comment character, word component, string delimiter, white space, or
    number character)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void parseNumbers()`: Indicates that a word token that has the format of a
    double-precision floating-point number has to be interpreted as a number, rather
    than a word'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void pushBack()`: Forces the `nextToken()` method to return the current value
    of the `ttype` field'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void quoteChar(int ch)`: Indicates that the provided character has to be interpreted
    as the beginning and the end of the string value that has to be taken as-is (as
    a quote)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void resetSyntax()`: Resets this tokenizer’s syntax table so that all characters
    are *ordinary*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void slashSlashComments(boolean flag)`: Indicates that C++-style comments
    have to be recognized'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void slashStarComments(boolean flag)`: Indicates that C-style comments have
    to be recognized'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`String toString()`: Returns the string representation of the token and the
    line number'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void whitespaceChars(int low, int hi)`: Indicates the range of characters
    that have to be interpreted as white space'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void wordChars(int low, int hi)`: Indicates the range of characters that have
    to be interpreted as a word'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see, using the wealth of the preceding methods allows you to fine-tune
    the text interpretation.
  prefs: []
  type: TYPE_NORMAL
- en: ObjectStreamClass and ObjectStreamField
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `ObjectStreamClass` and `ObjectStreamField` classes provide access to the
    serialized data of a class loaded in the JVM. The `ObjectStreamClass` object can
    be found/created using one of the following lookup methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`static ObjectStreamClass lookup(Class cl)`: Finds the descriptor of a serializable
    class'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`static ObjectStreamClass lookupAny(Class cl)`: Finds the descriptor for any
    class, whether serializable or not'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After `ObjectStreamClass` is found and the class is serializable (implementing
    the `Serializable` interface), it can be used to access the `ObjectStreamField`
    objects, each containing information about one serialized field. If the class
    is not serializable, there is no `ObjectStreamField` object associated with any
    of the fields.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at an example. Here is the method that displays information obtained
    from the `ObjectStreamClass` and `ObjectStreamField` objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE359]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE360]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE361]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE362]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE363]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE364]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE365]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE366]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE367]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE368]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE369]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE370]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE371]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE372]'
  prefs: []
  type: TYPE_PRE
- en: 'To demonstrate how it works, we will create a serializable `Person1` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE373]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE374]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE375]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE376]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE377]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE378]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE379]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE380]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE381]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE382]'
  prefs: []
  type: TYPE_PRE
- en: 'We did not add methods because only the object state is serializable, not the
    methods. Now, let’s run the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE383]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE384]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE385]'
  prefs: []
  type: TYPE_PRE
- en: 'The result will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18388_Figure_5.9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, there is information about the class name and all field names
    and types. There are also two other methods that can be called using the `ObjectStreamField`
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '`boolean isPrimitive()`: Returns `true` if this field has a primitive type'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`boolean isUnshared()`: Returns `true` if this field is unshared (private or
    accessible only from the same package)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, let’s create a non-serializable `Person2` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE386]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE387]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE388]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE389]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE390]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE391]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE392]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE393]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE394]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, we will run the code that only looks up the class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE395]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE396]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE397]'
  prefs: []
  type: TYPE_PRE
- en: 'As expected, the non-serializable object was not found using the `lookup()`
    method. In order to find a non-serializable object, we need to use the `lookupAny()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE398]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE399]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE400]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run the preceding example, the result will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18388_Figure_5.10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: From a non-serializable object, we were able to extract information about the
    class but not about the fields.
  prefs: []
  type: TYPE_NORMAL
- en: The java.util.Scanner class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `java.util.Scanner` class is typically used to read input from a keyboard
    but can also read text from any object that implements the `Readable` interface
    (this interface only has the `int read(CharBuffer buffer)` method). It breaks
    the input value by a delimiter (white space is a default delimiter) into tokens
    that are processed using different methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we can read an input from `System.in` – a standard input stream,
    which typically represents keyboard input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE401]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE402]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE403]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE404]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE405]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE406]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE407]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE408]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE409]'
  prefs: []
  type: TYPE_PRE
- en: 'It accepts many lines (each line ends after the *Enter* key is pressed) until
    the line `end` is entered, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18388_Figure_5.11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Alternatively, `Scanner` can read lines from a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE410]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE411]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE412]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE413]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE414]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE415]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE416]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE417]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we have used the `tokens.txt` file again. The results are as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18388_Figure_5.12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To demonstrate `Scanner` breaking the input by a delimiter, let’s run the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE418]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE419]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE420]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE421]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE422]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18388_Figure_5.13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To use another delimiter, it can be set as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE423]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE424]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE425]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE426]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE427]'
  prefs: []
  type: TYPE_PRE
- en: 'The result remains the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18388_Figure_5.14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It is also possible to use a regular expression for extracting the tokens, but
    that topic is outside the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: The `Scanner` class has many other methods that make its usage applicable to
    a variety of sources and required results. The `findInLine()`, `findWithinHorizon()`,
    `skip()`, and `findAll()` methods do not use the delimiter; they just try to match
    the provided pattern. For more information, refer to the Scanner documentation
    ([https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/Scanner.html](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/Scanner.html)).
  prefs: []
  type: TYPE_NORMAL
- en: File management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already used some methods for finding, creating, reading, and writing
    files using the JCL classes. We had to do it in order to support a demo code of
    input/output streams. In this section, we are going to talk about file management
    using the JCL in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `File` class from the `java.io` package represents the underlying filesystem.
    An object of the `File` class can be created with one of the following constructors:'
  prefs: []
  type: TYPE_NORMAL
- en: '`File(String pathname)`: Creates a new `File` instance based on the provided
    pathname'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`File(String parent, String child)`: Creates a new `File` instance based on
    the provided parent pathname and a child pathname'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`File(File parent, String child)`: Creates a new `File` instance based on the
    provided parent `File` object and a child pathname'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`File(URI uri)`: Creates a new `File` instance based on the provided `URI`
    object that represents the pathname'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will now see some examples of the constructors’ usage while talking about
    creating and deleting files.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and deleting files and directories
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create a file or directory in the filesystem, you need first to construct
    a new `File` object using one of the constructors listed in the *File management*
    section. For example, assuming that the filename is `FileName.txt`, the `File`
    object can be created as `new File("FileName.txt")`. If the file has to be created
    inside a directory, then either a path has to be added in front of the filename
    (when it is passed into the constructor) or one of the other three constructors
    has to be used, such as the following (see the `createFile2()` method in the `Files`
    class):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE428]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE429]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE430]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE431]'
  prefs: []
  type: TYPE_PRE
- en: 'Note the usage of `File.separator` instead of the slash symbols, (`/`) or (`\`).
    That is because `File.separator` returns the platform-specific slash symbol. Here
    is an example of another `File` constructor usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE432]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE433]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE434]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE435]'
  prefs: []
  type: TYPE_PRE
- en: 'Yet another constructor can be used as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE436]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE437]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE438]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE439]'
  prefs: []
  type: TYPE_PRE
- en: 'However, if you prefer or have to use a `File` object like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE440]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE441]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE442]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE443]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE444]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, one of the following methods has to be invoked on the newly created `File`
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '`boolean createNewFile()`: If a file with this name does not yet exist, creates
    a new file and returns `true`; otherwise, returns `false`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`static File createTempFile(String prefix, String suffix)`: Creates a file
    in the temporary-file directory'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`static File createTempFile(String prefix, String suffix, File directory)`:
    Creates the directory; the provided prefix and suffix are used to generate the
    directory name'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If the file you would like to create has to be placed inside a directory that
    does not exist yet, one of the following methods has to be used first, invoked
    on the `File` object that represents the filesystem path to the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '`boolean mkdir()`: Creates the directory with the provided name'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`boolean mkdirs()`: Creates the directory with the provided name, including
    any necessary but nonexistent parent directories'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Before we look at a code example, we need to explain how the `delete()` method
    works:'
  prefs: []
  type: TYPE_NORMAL
- en: '`boolean delete()`: Deletes the file or empty directory, which means you can
    delete the file but not all of the directories, as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE445]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s look at how to overcome this limitation in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE446]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE447]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE448]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE449]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE450]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE451]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE452]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE453]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE454]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE455]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE456]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE457]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE458]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE459]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE460]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE461]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE462]'
  prefs: []
  type: TYPE_PRE
- en: This example creates and deletes a file and all related directories. Notice
    our usage of the `org.apache.commons.lang3.StringUtils` class, which we discussed
    in the *String utilities* section. It allowed us to remove from the path the just-deleted
    directory and to continue doing it until all the nested directories are deleted,
    and the top-level directory is deleted last.
  prefs: []
  type: TYPE_NORMAL
- en: Listing files and directories
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following methods can be used for listing directories and the files in
    them:'
  prefs: []
  type: TYPE_NORMAL
- en: '`String[] list()`: Returns the names of the files and directories in the directory'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`File[] listFiles()`: Returns the `File` objects that represent the files and
    directories in the directory'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`static File[] listRoots()`: Lists the available filesystem roots'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In order to demonstrate the preceding methods, let’s assume we have created
    the directories and two files in them, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE463]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE464]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE465]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE466]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE467]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE468]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE469]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE470]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE471]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE472]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, we should be able to run the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE473]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE474]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE475]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE476]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE477]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE478]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE479]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE480]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE481]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE482]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE483]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE484]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE485]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE486]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE487]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE488]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE489]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE490]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE491]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE492]'
  prefs: []
  type: TYPE_PRE
- en: 'The result should be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18388_Figure_5.15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The demonstrated methods can be enhanced by adding the following filters to
    them so that they will list only the files and directories that match the filter:'
  prefs: []
  type: TYPE_NORMAL
- en: '`String[] list(FilenameFilter filter)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`File[] listFiles(FileFilter filter)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`File[] listFiles(FilenameFilter filter)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, a discussion of the file filters is outside the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Apache Commons’ FileUtils and IOUtils utilities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A popular companion of JCL is the Apache Commons project ([https://commons.apache.org](https://commons.apache.org)),
    which provides many libraries that complement the JCL functionality. The classes
    of the `org.apache.commons.io` package are contained in the following root package
    and sub-packages:'
  prefs: []
  type: TYPE_NORMAL
- en: The `org.apache.commons.io` root package contains utility classes with static
    methods for common tasks, such as the popular `FileUtils` and `IOUtils` classes,
    described in the *FileUtils class* and *Class IOUtils class* sections respectively.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `org.apache.commons.io.input` package contains classes that support input
    based on the `InputStream` and `Reader` implementations, such as `XmlStreamReader`
    or `ReversedLinesFileReader`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `org.apache.commons.io.output` package contains classes that support output
    based on the `OutputStream` and `Writer` implementations, such as `XmlStreamWriter`
    or `StringBuilderWriter`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `org.apache.commons.io.filefilter` package contains classes that serve as
    file filters, such as `DirectoryFileFilter` or `RegexFileFilter`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `org.apache.commons.io.comparator` package contains various implementations
    of `java.util.Comparator` for files such as `NameFileComparator`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `org.apache.commons.io.serialization` package provides a framework for controlling
    the deserialization of classes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `org.apache.commons.io.monitor` package allows monitoring filesystems, checking
    for a directory, and file creating, updating, or deleting. You can launch the
    `FileAlterationMonitor` object as a thread and create an object of `FileAlterationObserver`
    that performs a check of the changes in the filesystem at a specified interval.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refer to the Apache Commons project documentation ([https://commons.apache.org/](https://commons.apache.org/))
    for more details.
  prefs: []
  type: TYPE_NORMAL
- en: The FileUtils class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The popular `org.apache.commons.io.FileUtils` class allows you to do all possible
    operations with files, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Writing to a file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading from a file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making a directory, including parent directories
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copying files and directories
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deleting files and directories
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting to and from a URL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Listing files and directories by filter and extension
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comparing file content
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting a file last-changed date
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calculating a checksum
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you plan to manage files and directories programmatically, it is imperative
    that you study the documentation of this class on the Apache Commons project website
    ([https://commons.apache.org/proper/commons-io/javadocs/api-2.7/org/apache/commons/io/FileUtils.html](https://commons.apache.org/proper/commons-io/javadocs/api-2.7/org/apache/commons/io/FileUtils.html)).
  prefs: []
  type: TYPE_NORMAL
- en: The IOUtils class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`org.apache.commons.io.IOUtils` is another very useful utility class that provides
    the following general I/O stream manipulation methods:'
  prefs: []
  type: TYPE_NORMAL
- en: The `closeQuietly` methods that close a stream, ignoring nulls and exceptions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `toXxx/read` methods that read data from a stream
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `write` methods that write data to a stream
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `copy` methods that copy all the data from one stream to another
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `contentEquals` methods that compare the content of two streams
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All the methods in this class that read a stream are buffered internally, so
    there is no need to use the `BufferedInputStream` or `BufferedReader` class. The
    `copy` methods all use `copyLarge` methods behind the scenes that substantially
    increase their performance and efficiency.
  prefs: []
  type: TYPE_NORMAL
- en: This class is indispensable for managing the I/O streams. See more details about
    this class and its methods on the Apache Commons project website ([https://commons.apache.org/proper/commons-io/javadocs/api-2.7/org/apache/commons/io/IOUtils.html](https://commons.apache.org/proper/commons-io/javadocs/api-2.7/org/apache/commons/io/IOUtils.html)).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have discussed the `String` class methods that allow analyzing,
    comparing, and transforming strings. We have also discussed popular string utilities
    from the JCL and the Apache Commons project. Two big sections of this chapter
    were dedicated to the input/output streams and the supporting classes in the JCL
    and the Apache Commons project. The file-managing classes and their methods were
    also discussed and demonstrated in specific code examples. Now, you should be
    able to write code that processes strings and files, using standard Java API and
    Apache Commons utilities.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will present the Java Collections framework and its
    three main interfaces, `List`, `Set`, and `Map`, including discussion and demonstration
    of generics. We will also discuss utility classes for managing arrays, objects,
    and `time`/`date` values.
  prefs: []
  type: TYPE_NORMAL
- en: Quiz
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What does the following code print?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE493]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`3`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`2`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`1`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`0`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What does the following code print?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE494]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`Error`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Exception`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`true`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`false`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What does the following code print?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE495]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`wx`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`x6`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`%w`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Exception`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What does the following code print?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE496]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`ab4242`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`ab42ab42`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`ab422`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Error`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What does the following code print?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE497]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`false false`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`false true`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`true true`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`true false`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select all correct statements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A stream can represent a data source.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: An input stream can write to a file.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A stream can represent a data destination.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: An output stream can display data on a screen.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select all correct statements about the classes of the `java.io` package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Reader extends `InputStream`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Reader extends `OutputStream`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Reader extends `java.lang.Object`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Reader extends `java.lang.Input`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select all correct statements about the classes of the `java.io` package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Writer extends `FilterOutputStream`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Writer extends `OutputStream`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Writer extends `java.lang.Output`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Writer extends `java.lang.Object`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select all correct statements about the classes of the `java.io` package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`PrintStream` extends `FilterOutputStream`.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`PrintStream` extends `OutputStream`.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`PrintStream` extends `java.lang.Object`.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`PrintStream` extends `java.lang.Output`.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What does the following code do?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE498]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Creates two directories and a file in the `demo2` directory
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Creates one directory and a file in it
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Does not create any directory
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Exception
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
