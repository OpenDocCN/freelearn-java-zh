- en: '*Chapter 5*: Strings, Input/Output,and Files'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you will be presented with the `String` class methods in more
    detail. We will also discuss popular string utilities from standard libraries
    and the Apache Commons project. An overview of Java input/output streams and the
    related classes of the `java.io` packages will follow, along with some classes
    of the `org.apache.commons.io` package. The file-managing classes and their methods
    are described in a dedicated section. After completing this chapter, you will
    be able to write code that processes strings and files, using standard Java API
    and Apache Commons utilities.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: String processing
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I/O streams
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: File management
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apache Commons’ `FileUtils` and `IOUtils` utilities
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To be able to execute the code examples provided in this chapter, you will
    need the following:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: A computer with a Microsoft Windows, Apple macOS, or Linux operating system
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Java SE version 17 or later
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An IDE or code editor you prefer
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The instructions for how to set up a Java SE and IntelliJ IDEA editor were provided
    in [*Chapter 1*](B18388_01_ePub.xhtml#_idTextAnchor015), *Getting Started with
    Java 17*, in this book. The files with the code examples for this chapter are
    available in the GitHub repository at [https://github.com/PacktPublishing/Learn-Java-17-Programming.git](https://github.com/PacktPublishing/Learn-Java-17-Programming.git)
    in the [examples/src/main/java/com/packt/learnjava/ch05_stringsIoStreams](https://examples/src/main/java/com/packt/learnjava/ch05_stringsIoStreams)
    folder.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: String processing
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In mainstream programming, `String` probably is the most popular class. In [*Chapter
    1*](B18388_01_ePub.xhtml#_idTextAnchor015), *Getting Started with Java 17*, we
    learned about this class, its literals, and its specific feature called `String`
    class methods and utility classes from the standard library, and the `StringUtils`
    class from the `org.apache.commons.lang3` package in particular.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: Methods of the String class
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `String` class has more than 70 methods that enable analyzing, modifying,
    and comparing strings, and converting numeric literals into the corresponding
    string literals. To see all the methods of the `String` class, please refer to
    the Java API online at [https://docs.oracle.com/en/java/javase](https://docs.oracle.com/en/java/javase).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: String analysis
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `length()` method returns the number of characters in the string, as shown
    in the following code:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The following `isEmpty()` method returns `true` when the length of the string
    (count of characters) is `0`:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `indexOf()` and `lastIndexOf()` methods return the position of the specified
    substring in the string shown in this code snippet:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As you can see, the first character in the string has a position (index) of
    `0`, and the absence of the specified substring results in the index `-1`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: 'The `matches()` method applies the regular expression (passed as an argument)
    to the string as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Regular expressions are outside the scope of this book. You can learn about
    them at [https://www.regular-expressions.info](https://www.regular-expressions.info).
    In the preceding example, the `[a-z]+` expression matches one or more letters
    only.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式超出了本书的范围。您可以在 [https://www.regular-expressions.info](https://www.regular-expressions.info)
    了解它们。在上面的示例中，`[a-z]+` 表达式仅匹配一个或多个字母。
- en: String comparison
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字符串比较
- en: 'In [*Chapter 3*](B18388_03_ePub.xhtml#_idTextAnchor079), *Java Fundamentals*,
    we talked about the `equals()` method that returns `true` only when two `String`
    objects or literals are spelled exactly the same way. The following code snippet
    demonstrates how it works:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第3章*](B18388_03_ePub.xhtml#_idTextAnchor079) 的 *Java 基础* 中，我们讨论了 `equals()`
    方法，它仅在两个 `String` 对象或字面量拼写完全相同的情况下返回 `true`。以下代码片段演示了它是如何工作的：
- en: '[PRE12]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Another `String` class, the `equalsIgnoreCase()` method, does a similar job
    but ignores the difference in the characters’ case, as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个 `String` 类，`equalsIgnoreCase()` 方法执行类似的工作，但忽略字符的大小写差异，如下所示：
- en: '[PRE19]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `contentEquals()` method acts similar to the `equals()` method, as shown
    here:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`contentEquals()` 方法与 `equals()` 方法类似，如下所示：'
- en: '[PRE23]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The difference is that the `equals()` method checks whether both values are
    represented by the `String` class, while `contentEquals()` compares only the characters
    (content) of the character sequence. The character sequence can be represented
    by `String`, `StringBuilder`, `StringBuffer`, `CharBuffer`, or any other class
    that implements a `CharSequence` interface. Nevertheless, the `contentEquals()`
    method will return `true` if both sequences contain the same characters, while
    the `equals()` method will return `false` if one of the sequences is not created
    by the `String` class.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 区别在于 `equals()` 方法检查两个值是否都由 `String` 类表示，而 `contentEquals()` 仅比较字符序列（内容）。字符序列可以由
    `String`、`StringBuilder`、`StringBuffer`、`CharBuffer` 或任何实现 `CharSequence` 接口的类表示。尽管如此，如果两个序列包含相同的字符，则
    `contentEquals()` 方法将返回 `true`，而如果其中一个序列不是由 `String` 类创建的，则 `equals()` 方法将返回 `false`。
- en: 'The `contains()` method returns `true` if the `string` contains a certain substring,
    as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`contains()` 方法返回 `true` 如果 `string` 包含某个子字符串，如下所示：'
- en: '[PRE27]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The `startsWith()` and `endsWith()` methods perform a similar check but only
    at the start of the string or the end of the string value, as shown in the following
    code:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`startsWith()` 和 `endsWith()` 方法执行类似的检查，但仅检查字符串值的开头或结尾，如下面的代码所示：'
- en: '[PRE32]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The `compareTo()` and `compareToIgnoreCase()` methods compare strings lexicographically
    – based on the Unicode value of each character in the strings. They return the
    value `0` if the strings are equal, a negative integer value if the first string
    is lexicographically less (has a smaller Unicode value) than the second string,
    and a positive integer value if the first string is lexicographically greater
    than the second string (has a bigger Unicode value), as shown here:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`compareTo()` 和 `compareToIgnoreCase()` 方法按字典顺序比较字符串——基于字符串中每个字符的 Unicode 值。如果字符串相等，则返回
    `0`；如果第一个字符串在字典顺序上小于第二个字符串（具有较小的 Unicode 值），则返回负整数值；如果第一个字符串在字典顺序上大于第二个字符串（具有较大的
    Unicode 值），则返回正整数值，如下所示：'
- en: '[PRE39]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: From this code snippet, you can see that the `compareTo()` and `compareToIgnoreCase()`
    methods are based on the code points of the characters that compose the strings.
    The reason the `s4` string is bigger than the `s5` string by `32` is because the
    code point of the `a` character (`97`) is bigger than the code point of the `A`
    character (`65`) by `32`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 从这段代码片段中，您可以看到 `compareTo()` 和 `compareToIgnoreCase()` 方法是基于组成字符串的字符的代码点。`s4`
    字符串比 `s5` 字符串大 `32` 的原因是 `a` 字符的代码点（`97`）比 `A` 字符的代码点（`65`）大 `32`。
- en: The given example also shows that the `codePointAt()` method returns the code
    point of the character located in the string at the specified position. The code
    points were described in the *Integral types* section of [*Chapter 1*](B18388_01_ePub.xhtml#_idTextAnchor015),
    *Getting Started with Java 17*.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 给定的示例还表明，`codePointAt()` 方法返回字符串中指定位置的字符的代码点。代码点在 [*第1章*](B18388_01_ePub.xhtml#_idTextAnchor015)
    的 *整数类型* 部分进行了描述，*Java 17 入门*。
- en: String transformation
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字符串转换
- en: 'The `substring()` method returns the substring, starting with the specified
    position (index), as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`substring()` 方法返回从指定位置（索引）开始的子字符串，如下所示：'
- en: '[PRE45]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The `format()` method uses the passed-in first argument as a template and inserts
    the other arguments in the corresponding position of the template sequentially.
    The following code example prints the sentence `Hey, Nick! Give me 2 apples, please!`
    three times:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`format()` 方法使用传入的第一个参数作为模板，并按顺序将其他参数插入模板的相应位置。以下代码示例打印了句子 `Hey, Nick! Give
    me 2 apples, please!` 三次：'
- en: '[PRE53]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The `%s` and `%d` symbols are called `java.util.Formatter` class.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`%s` 和 `%d` 符号被称为 `java.util.Formatter` 类。'
- en: 'The `concat()` method works the same way as the arithmetic operator (`+`),
    as shown here:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`concat()` 方法与算术运算符 (`+`) 的工作方式相同，如下所示：'
- en: '[PRE59]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The following `join()` method acts similarly but allows the addition of a delimiter:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 `join()` 方法的工作方式类似，但允许添加分隔符：
- en: '[PRE65]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'The following group of the `replace()`, `replaceFirst()`, and `replaceAll()`
    methods replace certain characters in the string with the provided ones:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 `replace()`、`replaceFirst()` 和 `replaceAll()` 方法组将字符串中的某些字符替换为提供的字符：
- en: '[PRE70]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: The first line of the preceding code replaces all the instances of `"bc"` with
    `"42"`. The second replaces only the first instance of `"bc"` with `"42"`, and
    the last one replaces all the substrings that match the provided regular expression
    with `"42"`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的第一行将所有 `"bc"` 实例替换为 `"42"`。第二行只替换第一个 `"bc"` 实例为 `"42"`，最后一行替换所有与提供的正则表达式匹配的子字符串为
    `"42"`。
- en: 'The `toLowerCase()` and `toUpperCase()` methods change the case of the whole
    string, as shown here:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`toLowerCase()` 和 `toUpperCase()` 方法改变整个字符串的大小写，如下所示：'
- en: '[PRE76]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'The `split()` method breaks the string into substrings, using the provided
    character as the delimiter, as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`split()` 方法将字符串拆分为子字符串，使用提供的字符作为分隔符，如下所示：'
- en: '[PRE78]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'There are several `valueOf()` methods that transform the values of a primitive
    type to a `String` type, such as the following:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个 `valueOf()` 方法可以将原始类型的值转换为 `String` 类型，如下所示：
- en: '[PRE82]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: There are also the `()` and `getChars()` methods that transform a string to
    an array of a corresponding type, while the `chars()` method creates an `IntStream`
    of characters (their code points). We will talk about streams in [*Chapter 14*](B18388_14_ePub.xhtml#_idTextAnchor296),
    *Java Standard Streams*.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 还有 `()` 和 `getChars()` 方法可以将字符串转换为相应类型的数组，而 `chars()` 方法创建一个字符的 `IntStream`（它们的代码点）。我们将在
    [*第14章*](B18388_14_ePub.xhtml#_idTextAnchor296) 中讨论流，*Java 标准流*。
- en: Methods added with Java 11
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Java 11 添加的方法
- en: Java 11 introduced several new methods in the `String` class.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: Java 11 在 `String` 类中引入了几个新方法。
- en: 'The `repeat()` method allows you to create a new `String` value based on multiple
    concatenations of the same string, as shown in the following code:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`repeat()` 方法允许你根据相同字符串的多次连接创建一个新的 `String` 值，如下面的代码所示：'
- en: '[PRE85]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'The `isBlank()` method returns `true` if the string has a length of `0` or
    consists of white spaces only, such as the following:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`isBlank()` 方法如果字符串长度为 `0` 或仅由空白字符组成，则返回 `true`，如下所示：'
- en: '[PRE88]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'The `stripLeading()` method removes leading white spaces from the string, the
    `stripTrailing()` method removes trailing white spaces, and the `strip()` method
    removes both, as shown here:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`stripLeading()` 方法从字符串中删除前导空白字符，`stripTrailing()` 方法删除尾随空白字符，而 `strip()` 方法删除两者，如下所示：'
- en: '[PRE91]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'And finally, the `lines()` method breaks the string by line terminators and
    returns a `Stream<String>` of resulting lines. A line terminator is an escape
    sequence line feed (`\n`) (`\u000a`), a carriage return (`\r`) (`\u000d`), or
    a carriage return followed immediately by a line feed (`\r\n`) (`\u000d\u000a`),
    such as the following:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`lines()` 方法通过行终止符拆分字符串，并返回一个包含结果的 `Stream<String>` 行。行终止符是一个转义序列换行符 (`\n`)
    (`\u000a`)、回车符 (`\r`) (`\u000d`) 或回车符后立即跟换行符 (`\r\n`) (`\u000d\u000a`)，如下所示：
- en: '[PRE100]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'The output of the preceding code is as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下：
- en: '![](img/B18388_Figure_5.1.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18388_Figure_5.1.jpg)'
- en: We will talk about streams in [*Chapter 14*](B18388_14_ePub.xhtml#_idTextAnchor296),
    *Java Standard Streams*.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 [*第14章*](B18388_14_ePub.xhtml#_idTextAnchor296) 中讨论流，*Java 标准流*。
- en: String utilities
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串实用工具
- en: 'In addition to the `String` class, there are many other classes that have methods
    that process the `String` values. Among the most useful is the `StringUtils` class
    of the `org.apache.commons.lang3` package from a project called an `pom.xml` file:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `String` 类之外，还有许多其他类具有处理 `String` 值的方法。其中最有用的是来自名为 `pom.xml` 文件的项目中的 `org.apache.commons.lang3`
    包的 `StringUtils` 类：
- en: '[PRE102]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '[PRE105]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '[PRE106]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'The `StringUtils` class is the favorite of many programmers. It complements
    methods of the `String` class by providing the following null-safe operations
    (when a method is implemented in such a way – by checking the values for null,
    for example – that it does not throw `NullPointerException`):'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '`isBlank(CharSequence cs)`: Returns `true` if the input value is white space,
    empty (`""`), or `null`'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`isNotBlank(CharSequence cs)`: Returns `false` when the preceding method returns
    `true`'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`isEmpty(CharSequence cs)`: Returns `true` if the input value is empty (`""`)
    or `null`'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`isNotEmpty(CharSequence cs)`: Returns `false` when the preceding method returns
    `true`'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`trim(String str)`: Removes leading and trailing white space from the input
    value and processes `null`, empty (`""`), and white space, as follows:'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE107]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '`trimToNull(String str)`: Removes leading and trailing white space from the
    input value and processes `null`, empty (`""`), and white space, as follows:'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE108]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '`trimToEmpty(String str)`: Removes leading and trailing white space from the
    input value and processes `null`, empty (`""`), and white space, as follows:'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE109]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '`strip(String str)`, `stripToNull(String str)`, and `stripToEmpty(String str)`:
    Produces the same result as the preceding `trim(String str)`, `trimToNull(String
    str)`, and `trimToEmpty(String str)` methods but uses a more extensive definition
    of white space (based on `Character.isWhitespace(int codepoint)`) and thus removes
    the same characters as the `trim(String str)`, `trimToNull(String str)`, and `trimToEmpty(String
    str)` methods do, and more'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`strip(String str, String stripChars)`, `stripAccents(String input)`, `stripAll(String...
    strs)`, `stripAll(String[] strs, String stripChars)`, `stripEnd(String str, String
    stripChars)`, and `stripStart(String str, String stripChars)`: Removes particular
    characters from particular parts of `String` or `String[]` array elements'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`startsWith(CharSequence str, CharSequence prefix)`, `startsWithAny(CharSequence
    string, CharSequence... searchStrings)`, `startsWithIgnoreCase(CharSequence str,
    CharSequence prefix)`, and similar `endsWith*()` methods: Checks whether a `String`
    value starts (or ends) with a certain prefix (or suffix)'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`indexOf`, `lastIndexOf`, `contains`: Checks an index in a null-safe manner'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`indexOfAny`, `lastIndexOfAny`, `indexOfAnyBut`, `lastIndexOfAnyBut`: Returns
    an index'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`containsOnly`, `containsNone`, and `containsAny`: Checks whether the value
    contains certain characters or not'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`substring`, `left`, `right`, and `mid`: Returns a substring in a null-safe
    manner'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`substringBefore`, `substringAfter`, `substringBetween`: Returns a substring
    from a relative position'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`split` or `join`: Splits or joins a value (respectively)'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`remove` and `delete`: Eliminates a substring'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`replace` and `overlay`: Replaces a value'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`chomp` and `chop`: Removes the end'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`appendIfMissing`: Adds a value if not present'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`prependIfMissing`: Prepends a prefix to the start of the `String` value if
    not present'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`leftPad`, `rightPad`, `center`, and `repeat`: Adds padding'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`leftPad`、`rightPad`、`center` 和 `repeat`：添加填充'
- en: '`upperCase`, `lowerCase`, `swapCase`, `capitalize`, and `uncapitalize`: Changes
    the case'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`upperCase`、`lowerCase`、`swapCase`、`capitalize` 和 `uncapitalize`：更改大小写'
- en: '`countMatches`: Returns the number of the substring occurrences'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`countMatches`: 返回子字符串出现的次数'
- en: '`isWhitespace`, `isAsciiPrintable`, `isNumeric`, `isNumericSpace`, `isAlpha`,
    `isAlphaNumeric`, `isAlphaSpace`, and `isAlphaNumericSpace`: Checks the presence
    of a certain type of characters'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isWhitespace`、`isAsciiPrintable`、`isNumeric`、`isNumericSpace`、`isAlpha`、`isAlphaNumeric`、`isAlphaSpace`
    和 `isAlphaNumericSpace`：检查是否存在某种类型的字符'
- en: '`isAllLowerCase` and `isAllUpperCase`: Checks the case'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isAllLowerCase` 和 `isAllUpperCase`：检查大小写'
- en: '`defaultString`, `defaultIfBlank`, and `defaultIfEmpty`: Returns a default
    value if `null`'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`defaultString`、`defaultIfBlank` 和 `defaultIfEmpty`：如果为 `null` 则返回默认值'
- en: '`rotate`: Rotates characters using a circular shift'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rotate`: 使用循环移位旋转字符'
- en: '`reverse` and `reverseDelimited`: Reverses characters or delimited groups of
    characters'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reverse` 和 `reverseDelimited`：反转字符或分隔的字符组'
- en: '`abbreviate` and `abbreviateMiddle`: Abbreviates a value using an ellipsis
    or another value'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`abbreviate` 和 `abbreviateMiddle`：使用省略号或其他值缩略值'
- en: '`difference`: Returns the differences in values'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`difference`: 返回值之间的差异'
- en: '`getLevenshteinDistance`: Returns the number of changes needed to transform
    one value into another'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getLevenshteinDistance`: 返回将一个值转换为另一个值所需的变化次数'
- en: As you can see, the `StringUtils` class has a very rich (we have not listed
    everything) set of methods for string analysis, comparison, and transformation
    that complements the methods of the `String` class.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`StringUtils` 类提供了一套非常丰富的（我们并未列出所有）用于字符串分析、比较和转换的方法，这些方法与 `String` 类的方法相辅相成。
- en: I/O streams
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: I/O 流
- en: Any software system has to receive and produce some kind of data that can be
    organized as a set of isolated input/output or as a stream of data. A stream can
    be limited or endless. A program can read from a stream (which is called an **input
    stream**) or write to a stream (which is called an **output stream**). The Java
    I/O stream is either byte-based or character-based, meaning that its data is interpreted
    either as raw bytes or as characters.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 任何软件系统都必须接收和产生某种可以组织为一系列独立的输入/输出或数据流的类型的数据。一个流可以是有限的或无限的。程序可以从流中读取（称为 **输入流**）或向流中写入（称为
    **输出流**）。Java I/O 流要么基于字节，要么基于字符，这意味着其数据要么被解释为原始字节，要么被解释为字符。
- en: The `java.io` package contains classes that support many, but not all, possible
    data sources. It is built for the most part around input from and to files, network
    streams, and internal memory buffers. It does not contain many classes necessary
    for network communication. They belong to `java.net`, `javax.net`, and other packages
    of a Java networking API. Only after the networking source or destination is established
    (a network socket, for example) can a program read and write data using the `InputStream`
    and `OutputStream` classes of the `java.io` package.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.io` 包包含支持许多但不是所有可能数据源的类。它主要围绕从文件、网络流和内部内存缓冲区输入和输出构建。它不包含许多必要的网络通信类。它们属于
    `java.net`、`javax.net` 和其他 Java 网络API的包。只有当网络源或目的地建立（例如网络套接字）之后，程序才能使用 `java.io`
    包中的 `InputStream` 和 `OutputStream` 类读取和写入数据。'
- en: The classes of the `java.nio` package have pretty much the same functionality
    as the classes of `java.io` packages. But, in addition, they can work in *non-blocking*
    mode, which can substantially increase performance in certain situations. We will
    talk about non-blocking processing in [*Chapter 15*](B18388_15_ePub.xhtml#_idTextAnchor315),
    *Reactive Programming*.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.nio` 包的类几乎与 `java.io` 包的类具有相同的功能。但是，除此之外，它们还可以在 *非阻塞* 模式下工作，这在某些情况下可以显著提高性能。我们将在
    [*第15章*](B18388_15_ePub.xhtml#_idTextAnchor315) *响应式编程* 中讨论非阻塞处理。'
- en: Stream data
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 流数据
- en: Input data has to be binary – expressed in 0s and 1s – at the very least because
    that is the format a computer can read. Data can be read or written one byte at
    a time or an array of several bytes at a time. These bytes can remain binary or
    can be interpreted as characters.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 输入数据至少必须是二进制的一——用 0 和 1 表示——因为这是计算机可以读取的格式。数据可以一次读取或写入一个字节，或者一次读取或写入几个字节的数组。这些字节可以是二进制格式，也可以被解释为字符。
- en: In the first case, they can be read as bytes or byte arrays by the descendants
    of the `InputStream` and `OutputStream` classes, such as (omitting the package
    name if the class belongs to the `java.io` package) `ByteArrayInputStream`, `ByteArrayOutputStream`,
    `FileInputStream`, `FileOutputStream`, `ObjectInputStream`, `ObjectOutputStream`,
    `javax.sound.sampled.AudioInputStream`, and `org.omg.CORBA.portable.OutputStream`;
    which one you use depends on the source or destination of the data. The `InputStream`
    and `OutputStream` classes themselves are abstract and cannot be instantiated.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一种情况下，`InputStream`和`OutputStream`类的后代，如（如果类属于`java.io`包则省略包名）`ByteArrayInputStream`、`ByteArrayOutputStream`、`FileInputStream`、`FileOutputStream`、`ObjectInputStream`、`ObjectOutputStream`、`javax.sound.sampled.AudioInputStream`和`org.omg.CORBA.portable.OutputStream`，可以将它们作为字节或字节数组读取；你使用哪一个取决于数据源或目的地。`InputStream`和`OutputStream`类本身是抽象的，不能被实例化。
- en: In the second case, data that can be interpreted as characters is called `Reader`
    and `Writer`, which are abstract classes too. Examples of their sub-classes are
    `CharArrayReader` and `CharArrayWriter`, `InputStreamReader` and `OutputStreamWriter`,
    `PipedReader` and `PipedWriter`, and `StringReader` and `StringWriter`.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二种情况下，可以解释为字符的数据被称为`Reader`和`Writer`，它们也是抽象类。它们的子类示例包括`CharArrayReader`和`CharArrayWriter`、`InputStreamReader`和`OutputStreamWriter`、`PipedReader`和`PipedWriter`以及`StringReader`和`StringWriter`。
- en: You may have noticed that we listed the classes in pairs. But not every input
    class has a matching output specialization – for example, there are the `PrintStream`
    and `PrintWriter` classes that support output to a printing device, but there
    is no corresponding input partner, not by name at least. However, there is a `java.util.Scanner`
    class that parses input text in a known format.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到我们成对地列出了类。但并非每个输入类都有对应的输出特殊化——例如，有`PrintStream`和`PrintWriter`类支持输出到打印设备，但没有相应的输入伙伴，至少不是按名称。然而，有一个`java.util.Scanner`类可以解析已知格式的输入文本。
- en: There is also a set of buffer-equipped classes that help to improve performance
    by reading or writing a bigger chunk of data at a time, especially in cases when
    access to a source or destination takes a long time.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一组配备了缓冲区的类，通过一次读取或写入更大的数据块来提高性能，尤其是在访问源或目的地耗时较长的情况下。
- en: In the rest of this section, we will review classes of the `java.io` package
    and some popular related classes from other packages.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的其余部分，我们将回顾`java.io`包中的类以及来自其他包的一些流行的相关类。
- en: The InputStream class and its subclasses
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`InputStream`类及其子类'
- en: 'In the Java Class Library, the `InputStream` abstract class has the following
    direct implementations: `ByteArrayInputStream`, `FileInputStream`, `ObjectInputStream`,
    `PipedInputStream`, `SequenceInputStream`, `FilterInputStream`, and `javax.sound.sampled.AudioInputStream`.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java类库中，`InputStream`抽象类有以下直接实现：`ByteArrayInputStream`、`FileInputStream`、`ObjectInputStream`、`PipedInputStream`、`SequenceInputStream`、`FilterInputStream`和`javax.sound.sampled.AudioInputStream`。
- en: 'All of them can be used as they are or override the following methods of the
    `InputStream` class:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都可以直接使用，或者覆盖`InputStream`类的以下方法：
- en: '`int available()`: Returns the number of bytes available for reading'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int available()`: 返回可读取的字节数'
- en: '`void close()`: Closes the stream and releases the resources'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void close()`: 关闭流并释放资源'
- en: '`void mark(int readlimit)`: Marks a position in the stream and defines how
    many bytes can be read'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void mark(int readlimit)`: 在流中标记一个位置并定义可以读取的字节数'
- en: '`boolean markSupported()`: Returns `true` if the marking is supported'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boolean markSupported()`: 如果标记被支持则返回`true`'
- en: '`static InputStream nullInputStream()`: Creates an empty stream'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`static InputStream nullInputStream()`: 创建一个空流'
- en: '`abstract int read()`: Reads the next byte in the stream'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`abstract int read()`: 读取流中的下一个字节'
- en: '`int read(byte[] b)`: Reads data from the stream into the `b` buffer'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int read(byte[] b)`: 从流中读取数据到`b`缓冲区'
- en: '`int read(byte[] b, int off, int len)`: Reads `len` or fewer bytes from the
    stream into the `b` buffer'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int read(byte[] b, int off, int len)`: 从流中读取`len`或更少的字节到`b`缓冲区'
- en: '`byte[] readAllBytes()`: Reads all the remaining bytes from the stream'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`byte[] readAllBytes()`: 从流中读取所有剩余的字节'
- en: '`int readNBytes(byte[] b, int off, int len)`: Reads `len` or fewer bytes into
    the `b` buffer at the `off` offset'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int readNBytes(byte[] b, int off, int len)`: 将`len`或更少的字节读取到`b`缓冲区的`off`偏移量'
- en: '`byte[] readNBytes(int len)`: Reads `len` or fewer bytes into the `b` buffer'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`byte[] readNBytes(int len)`: 将`len`或更少的字节读取到`b`缓冲区'
- en: '`void reset()`: Resets the reading location to the position where the `mark()`
    method was last called'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void reset()`: 将读取位置重置为`mark()`方法上次调用时的位置'
- en: '`long skip(long n)`: Skips `n` or fewer bytes of the stream; returns the actual
    number of bytes skipped'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`long skip(long n)`: 跳过`n`或更少的字节流；返回实际跳过的字节数'
- en: '`long transferTo(OutputStream out)`: Reads from the input stream and writes
    to the provided output stream byte by byte; returns the actual number of bytes
    transferred'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`long transferTo(OutputStream out)`: 从输入流读取并逐字节写入提供的输出流；返回实际传输的字节数'
- en: '`abstract int read()` is the only method that has to be implemented, but most
    of the descendants of this class override many of the other methods too.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '`abstract int read()`是唯一必须实现的方法，但这个类的许多子类也覆盖了许多其他方法。'
- en: ByteArrayInputStream
  id: totrans-230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ByteArrayInputStream
- en: 'The `ByteArrayInputStream` class allows reading a byte array as an input stream.
    It has the following two constructors that create an object of the class and define
    the buffer used to read the input stream of bytes:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '`ByteArrayInputStream`类允许将字节数组作为输入流读取。它有以下两个构造函数，用于创建类的对象并定义用于读取字节数字输入流的缓冲区：'
- en: '`ByteArrayInputStream(byte[] buffer)`'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ByteArrayInputStream(byte[] buffer)`'
- en: '`ByteArrayInputStream(byte[] buffer, int offset, int length)`'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ByteArrayInputStream(byte[] buffer, int offset, int length)`'
- en: 'The second of the constructors allows you to set, in addition to the buffer,
    the offset and the length of the buffer too. Let’s look at an example and see
    how this class can be used. We will assume there is a source of the `byte[]` array
    with data:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个构造函数允许你设置缓冲区，包括缓冲区的偏移量和长度。让我们看一个例子，看看这个类是如何使用的。我们将假设有一个`byte[]`数组的数据源：
- en: '[PRE110]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '[PRE111]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '[PRE112]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'Then, we can write the following:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以写出以下内容：
- en: '[PRE113]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '[PRE114]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '[PRE115]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '[PRE116]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '[PRE117]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '[PRE118]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: '[PRE119]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: '[PRE120]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '[PRE121]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: '[PRE122]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: The `bytesSource()` method produces the array of bytes that fills the buffer
    that is passed into the constructor of the `ByteArrayInputStream` class as a parameter.
    The resulting stream is then read byte by byte using the `read()` method until
    the end of the stream is reached (and the `read()` method returns `-1`). Each
    new byte is printed out (without a line feed and with white space after it, so
    all the read bytes are displayed in one line separated by the white space).
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '`bytesSource()`方法产生一个字节数组，该数组填充了传递给`ByteArrayInputStream`类构造函数的缓冲区作为参数。然后使用`read()`方法逐字节读取流，直到到达流的末尾（并且`read()`方法返回`-1`）。每个新的字节被打印出来（没有换行符，并在其后有空白，因此所有读取的字节都在一行中显示，由空白分隔）。'
- en: 'The preceding code is usually expressed in a more compact form, as follows:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码通常以更紧凑的形式表达，如下所示：
- en: '[PRE123]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '[PRE124]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '[PRE125]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: '[PRE126]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: '[PRE127]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: '[PRE128]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: '[PRE129]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: '[PRE130]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: '[PRE131]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'Instead of just printing the bytes, they can be processed in any other manner
    necessary, including interpreting them as characters, such as the following:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是仅仅打印字节，它们可以以任何其他必要的方式进行处理，包括将它们解释为字符，如下所示：
- en: '[PRE132]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: '[PRE133]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: '[PRE134]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: '[PRE135]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: '[PRE136]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: '[PRE137]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: '[PRE138]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: '[PRE139]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: '[PRE140]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: '[PRE141]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: But, in such a case, it is better to use one of the `Reader` classes that are
    specialized for character processing. We will talk about them in the *Reader and
    writer classes and their subclasses* section.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，在这种情况下，最好使用专门用于字符处理的`Reader`类之一。我们将在*读取器和写入器类及其子类*部分中讨论它们。
- en: FileInputStream
  id: totrans-272
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: FileInputStream
- en: 'The `FileInputStream` class gets data from a file in a filesystem – the raw
    bytes of an image, for example. It has the following three constructors:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '`FileInputStream`类从文件系统中的文件获取数据——例如图像的原始字节。它有以下三个构造函数：'
- en: '`FileInputStream(File file)`'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FileInputStream(File file)`'
- en: '`FileInputStream(String name)`'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FileInputStream(String name)`'
- en: '`FileInputStream(FileDescriptor fdObj)`'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FileInputStream(FileDescriptor fdObj)`'
- en: 'Each constructor opens the file specified as the parameter. The first constructor
    accepts the `File` object; the second, the path to the file in the filesystem;
    and the third, the file descriptor object that represents an existing connection
    to an actual file in the filesystem. Let’s look at the following example:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 每个构造函数都打开指定的文件。第一个构造函数接受`File`对象；第二个，文件系统中的文件路径；第三个，表示文件系统中的实际文件连接的文件描述符对象。让我们看看以下示例：
- en: '[PRE142]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: '[PRE143]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: '[PRE144]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: '[PRE145]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: '[PRE146]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: '[PRE147]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: '[PRE148]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: '[PRE149]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: '[PRE150]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: '[PRE151]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: 'In the `src/main/resources` folder, we have created the `hello.txt` file that
    has only one line in it – `Hello!`. The output of the preceding example looks
    as follows:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在`src/main/resources`文件夹中，我们创建了`hello.txt`文件，其中只有一行内容——`Hello!`。前面示例的输出如下：
- en: '![Graphical user interface'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '![图形用户界面'
- en: Description automatically generated](img/B18388_Figure_5.2.png)
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 自动生成的描述](img/B18388_Figure_5.2.png)
- en: 'After reading bytes from the `hello.txt` file, we decided, for demo purposes,
    to cast each `byte` to `char` so that you can see that the code does read from
    the specified file, but the `FileReader` class is a better choice for text file
    processing (we will discuss it shortly). Without the cast, the result would be
    the following:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在从`hello.txt`文件读取字节之后，我们决定，出于演示目的，将每个`byte`转换为`char`，这样你就可以看到代码确实是从指定的文件中读取的，但`FileReader`类是处理文本文件更好的选择（我们很快就会讨论它）。如果没有进行转换，结果将是以下内容：
- en: '[PRE152]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: '[PRE153]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: 'By the way, because the `src/main/resources` folder is placed by the IDE (using
    Maven) on the classpath, a file placed in it can also be accessed via a class
    loader that creates a stream using its own `InputStream` implementation:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一下，因为`src/main/resources`文件夹是由IDE（使用Maven）放置在类路径上的，所以放在其中的文件也可以通过创建使用其自己的`InputStream`实现的流的类加载器来访问：
- en: '[PRE154]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: '[PRE155]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: '[PRE156]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: '[PRE157]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: '[PRE158]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: '[PRE159]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: '[PRE160]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: '[PRE161]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: '[PRE162]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: The `InputOutputStream` class in the preceding example is not a class from some
    library. It is just the main class we used to run the example. The `InputOutputStream.class.getResourceAsStream()`
    construct allows you to use the same classloader that has loaded the `InputOutputStream`
    class for the purpose of finding a file on the classpath and creating a stream
    that contains its content. In the *File management* section, we will present other
    ways of reading a file too.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，`InputOutputStream`类不是来自某个库的类。它只是我们用来运行示例的主类。`InputOutputStream.class.getResourceAsStream()`构造函数允许你使用加载了`InputOutputStream`类的相同类加载器，用于在类路径上查找文件并创建包含其内容的流。在*文件管理*部分，我们将介绍其他读取文件的方法。
- en: ObjectInputStream
  id: totrans-305
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ObjectInputStream
- en: The set of methods of the `ObjectInputStream` class is much bigger than the
    set of methods of any other `InputStream` implementation. The reason for that
    is that it is built around reading the values of the object fields that can be
    of various types. In order for `ObjectInputStream` to be able to construct an
    object from the input stream of data, the object has to be *deserializable*, which
    means it has to be *serializable* in the first place – that is, to be convertible
    into a byte stream. Usually, it is done for the purpose of transporting objects
    over a network. At the destination, the serialized objects are deserialized, and
    the values of the original objects are restored.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '`ObjectInputStream`类的方法集比任何其他`InputStream`实现的方法集都要大。这是因为它是围绕读取各种类型的对象字段值构建的。为了使`ObjectInputStream`能够从数据输入流中构造一个对象，该对象必须是*可反序列化的*，这意味着它首先必须是*可序列化的*——也就是说，可以转换成字节流。通常，这是为了在网络中传输对象。在目的地，序列化的对象被反序列化，原始对象的值被恢复。'
- en: 'Primitive types and most Java classes, including the `String` class and primitive
    type wrappers, are serializable. If a class has fields of custom types, they have
    to be made serializable by implementing `java.io.Serizalizable`. How to do that
    is outside the scope of this book. For now, we are going to use only the serializable
    types. Let’s look at this class:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 基本数据类型和大多数Java类，包括`String`类和基本数据类型包装器，都是可序列化的。如果一个类有自定义类型的字段，它们必须通过实现`java.io.Serializable`来使其可序列化。如何实现这一点超出了本书的范围。现在，我们将只使用可序列化类型。让我们看看这个类：
- en: '[PRE163]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: '[PRE164]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: '[PRE165]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: '[PRE166]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: We have to tell the compiler that it is serializable. Otherwise, the compilation
    will fail. It is done in order to make sure that, before stating that the class
    is serializable, the programmer either reviewed all the fields and made sure they
    are serializable or has implemented the methods necessary for the serialization.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须告诉编译器它是可以序列化的。否则，编译将失败。这样做是为了确保在声明类是可序列化之前，程序员要么审查了所有字段并确保它们是可序列化的，要么实现了序列化所需的必要方法。
- en: 'Before we can create an input stream and use `ObjectInputStream` for deserialization,
    we need to serialize the object first. That is why we first use `ObjectOutputStream`
    and `FileOutputStream` to serialize an object and write it into the `someClass.bin`
    file. We will talk more about them in the *The OutputStream class and its subclasses*
    section. Then, we read from the file using `FileInputStream` and deserialize the
    file content using `ObjectInputStream`:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以创建输入流并使用`ObjectInputStream`进行反序列化之前，我们需要首先序列化对象。这就是为什么我们首先使用`ObjectOutputStream`和`FileOutputStream`来序列化一个对象并将其写入`someClass.bin`文件。我们将在*输出流类及其子类*部分更多地讨论它们。然后，我们使用`FileInputStream`从文件中读取，并使用`ObjectInputStream`反序列化文件内容：
- en: '[PRE167]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: '[PRE168]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: '[PRE169]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: '[PRE170]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: '[PRE171]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: '[PRE172]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: '[PRE173]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: '[PRE174]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: '[PRE175]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: '[PRE176]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: '[PRE177]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: '[PRE178]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: Note that the file has to be created first before the preceding code is run.
    We will show how it can be done in the *Creating files and directories* section.
    And, as a reminder, we have used the `try-with-resources` statement because `InputStream`
    and `OutputStream` both implement the `Closeable` interface.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: PipedInputStream
  id: totrans-327
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A piped input stream has a very particular specialization; it is used as one
    of the mechanisms of communication between threads. One thread reads from a `PipedInputStream`
    object and passes data to another thread that writes data to a `PipedOutputStream`
    object. Here is an example:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE179]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: '[PRE180]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: 'Alternatively, data can be moved in the opposite direction when one thread
    reads from a `PipedOutputStream` object and another thread writes to a `PipedInputStream`
    object as follows:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE181]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: '[PRE182]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: Those who work in this area are familiar with the message, `Broken pipe`, which
    means that the supplying data pipe stream has stopped working.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: 'The piped streams can also be created without any connection and connected
    later, as shown here:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE183]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: '[PRE184]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: '[PRE185]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: 'As an example, here are two classes that are going to be executed by different
    threads – first, the `PipedOutputWorker` class, as follows:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE186]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: '[PRE187]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: '[PRE188]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: '[PRE189]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: '[PRE190]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: '[PRE191]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: '[PRE192]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: '[PRE193]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: '[PRE194]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: '[PRE195]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: '[PRE196]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: '[PRE197]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: '[PRE198]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: '[PRE199]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE199]'
- en: '[PRE200]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE200]'
- en: '[PRE201]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: '[PRE202]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: 'The `PipedOutputWorker` class has the `run()` method (because it implements
    a `Runnable` interface) that writes into the stream the three numbers `1`, `2`,
    and `3`, and then closes. Now, let’s look at the `PipedInputWorker` class, as
    shown here:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE203]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE203]'
- en: '[PRE204]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE204]'
- en: '[PRE205]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE205]'
- en: '[PRE206]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE206]'
- en: '[PRE207]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE207]'
- en: '[PRE208]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE208]'
- en: '[PRE209]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE209]'
- en: '[PRE210]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE210]'
- en: '[PRE211]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE211]'
- en: '[PRE212]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE212]'
- en: '[PRE213]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE213]'
- en: '[PRE214]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE214]'
- en: '[PRE215]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE215]'
- en: '[PRE216]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE216]'
- en: '[PRE217]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE217]'
- en: '[PRE218]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE218]'
- en: '[PRE219]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE219]'
- en: '[PRE220]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE220]'
- en: 'It also has a `run()` method (because it implements a `Runnable` interface)
    that reads from the stream and prints out each byte until the stream ends (indicated
    by `-1`). Now, let’s connect these pipes and execute a `run()` method of these
    classes:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE221]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE221]'
- en: '[PRE222]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE222]'
- en: '[PRE223]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE223]'
- en: '[PRE224]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE224]'
- en: '[PRE225]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE225]'
- en: '[PRE226]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE226]'
- en: '[PRE227]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE227]'
- en: '[PRE228]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE228]'
- en: '[PRE229]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE229]'
- en: '[PRE230]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE230]'
- en: As you can see, the objects of the workers were passed into the constructor
    of the `Thread` class. The `start()` method of the `Thread` object executes the
    `run()` method of the passed in `Runnable`. And we see the results as expected
    –`PipedInputWorker` prints all the bytes written to the piped stream by `PipedOutputWorker`.
    We will go into more detail about threads in [*Chapter 8*](B18388_08_ePub.xhtml#_idTextAnchor187),
    *Multithreading and Concurrent Processing*.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: SequenceInputStream
  id: totrans-388
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `SequenceInputStream` class concatenates input streams passed into one
    of the following constructors as parameters:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: '`SequenceInputStream(InputStream s1, InputStream s2)`'
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SequenceInputStream(Enumeration<InputStream> e)`'
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SequenceInputStream` class reads from the first input string until it ends,
    whereupon it reads from the second one, and so on, until the end of the last of
    the streams. As an example, let’s create a `howAreYou.txt` file (with the text,
    `How are you?`) in the `resources` folder next to the `hello.txt` file. The `SequenceInputStream`
    class can then be used as follows:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE231]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE231]'
- en: '[PRE232]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE232]'
- en: '[PRE233]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE233]'
- en: '[PRE234]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE234]'
- en: '[PRE235]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE235]'
- en: '[PRE236]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE236]'
- en: '[PRE237]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE237]'
- en: '[PRE238]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE238]'
- en: '[PRE239]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE239]'
- en: '[PRE240]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE240]'
- en: '[PRE241]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE241]'
- en: '[PRE242]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE242]'
- en: '[PRE243]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE243]'
- en: '[PRE244]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE244]'
- en: '[PRE245]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE245]'
- en: '[PRE246]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE246]'
- en: Similarly, when an enumeration of input streams is passed in, each of the streams
    is read (and printed in our case) until the end.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: FilterInputStream
  id: totrans-410
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `FilterInputStream` class is a wrapper around the `InputStream` object
    passed as a parameter in the constructor. Here is the constructor and the two
    `read()` methods of the `FilterInputStream` class:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE247]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE247]'
- en: '[PRE248]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE248]'
- en: '[PRE249]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE249]'
- en: '[PRE250]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE250]'
- en: '[PRE251]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE251]'
- en: '[PRE252]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE252]'
- en: All the other methods of the `InputStream` class are overridden similarly; the
    function is delegated to the object assigned to the `in` property.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, the constructor is protected, which means that only the child
    has access to it. Such a design hides from the client the actual source of the
    stream and forces the programmer to use one of the `FilterInputStream` class extensions:
    `BufferedInputStream`, `CheckedInputStream`, `DataInputStream`, `PushbackInputStream`,
    `javax.crypto.CipherInputStream`, `java.util.zip.DeflaterInputStream`, `java.util.zip.InflaterInputStream`,
    `java.security.DigestInputStream`, or `javax.swing.ProgressMonitorInputStream`.
    Alternatively, you can create a custom extension. But, before creating your own
    extension, look at the listed classes and see if one of them fits your needs.
    Here is an example of using a `BufferedInputStream` class:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE253]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE253]'
- en: '[PRE254]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE254]'
- en: '[PRE255]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE255]'
- en: '[PRE256]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE256]'
- en: '[PRE257]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE257]'
- en: '[PRE258]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE258]'
- en: '[PRE259]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE259]'
- en: '[PRE260]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE260]'
- en: '[PRE261]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE261]'
- en: '[PRE262]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE262]'
- en: The `BufferedInputStream` class uses the buffer to improve performance. When
    the bytes from the stream are skipped or read, the internal buffer is automatically
    refilled with as many bytes as necessary at the time, from the contained input
    stream.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: The `CheckedInputStream` class adds a checksum of the data being read that allows
    the verification of the integrity of the input data using the `getChecksum()`
    method.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
- en: The `DataInputStream` class reads and interprets input data as primitive Java
    data types in a machine-independent way.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
- en: The `PushbackInputStream` class adds the ability to push back the read data
    using the `unread()` method. It is useful in situations when the code has the
    logic of analyzing the just-read data and deciding to unread it, so it can be
    reread at the next step.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: The `javax.crypto.CipherInputStream` class adds `Cipher` to the `read()` methods.
    If `Cipher` is initialized for decryption, `javax.crypto.CipherInputStream` will
    attempt to decrypt the data before returning.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: The `java.util.zip.DeflaterInputStream` class compresses data in the deflate
    compression format.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: The `java.util.zip.InflaterInputStream` class uncompresses data in the deflate
    compression format.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
- en: The `java.security.DigestInputStream` class updates the associated message digest
    using the bits going through the stream. The `on (boolean on)` method turns the
    `digest` function on or off. The calculated digest can be retrieved using the
    `getMessageDigest()` method.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
- en: The `javax.swing.ProgressMonitorInputStream` class provides a monitor of the
    progress of reading from `InputStream`. The monitor object can be accessed using
    the `getProgressMonitor()` method.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
- en: javax.sound.sampled.AudioInputStream
  id: totrans-439
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `AudioInputStream` class represents an input stream with a specified audio
    format and length. It has the following two constructors:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
- en: '`AudioInputStream (InputStream stream, AudioFormat format, long length)`: Accepts
    the stream of audio data, the requested format, and the length in sample frames'
  id: totrans-441
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AudioInputStream (TargetDataLine line)`: Accepts the target data line indicated'
  id: totrans-442
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `javax.sound.sampled.AudioFormat` class describes audio-format properties
    such as channels, encoding, frame rate, and similar. The `javax.sound.sampled.TargetDataLine`
    class has the `open()` method that opens the line with the specified format and
    the `read()` method that reads audio data from the data line’s input buffer.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
- en: There is also the `javax.sound.sampled.AudioSystem` class, and its methods handle
    `AudioInputStream` objects. They can be used for reading from an audio file, a
    stream, or a URL, and they write to an audio file. They also can be used to convert
    an audio stream to another audio format.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
- en: The OutputStream class and its subclasses
  id: totrans-445
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `OutputStream` class is a peer of the `InputStream` class that writes data
    instead of reading. It is an abstract class that has the following direct implementations
    in the `ByteArrayOutputStream`, `FilterOutputStream`, `ObjectOutputStream`, `PipedOutputStream`,
    and `FileOutputStream`.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
- en: 'The `FileOutputStream` class has the following direct extensions: `BufferedOutputStream`,
    `CheckedOutputStream`, `DataOutputStream`, `PrintStream`, `javax.crypto.CipherOutputStream`,
    `java.util.zip.DeflaterOutputStream`, `java.security.DigestOutputStream`, and
    `java.util.zip.InflaterOutputStream`.'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
- en: 'All of them can be used as they are or override the following methods of the
    `OutputStream` class:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
- en: '`void close()`: Closes the stream and releases the resources'
  id: totrans-449
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void flush()`: Forces the remaining bytes to be written out'
  id: totrans-450
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`static OutputStream nullOutputStream()`: Creates a new `OutputStream` that
    writes nothing'
  id: totrans-451
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void write(byte[] b)`: Writes the provided byte array to the output stream'
  id: totrans-452
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void write(byte[] b, int off, int len)`: Writes `len` bytes of the provided
    byte array, starting at the `off` offset, to the output stream'
  id: totrans-453
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`abstract void write(int b)`: Writes the provided byte to the output stream'
  id: totrans-454
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The only method that has to be implemented is `abstract void write(int b)`,
    but most of the descendants of the `OutputStream` class override many of the other
    methods too.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
- en: After learning about the input streams in the *The InputStream class and its
    subclasses* section, all of the `OutputStream` implementations, except the `PrintStream`
    class, should be intuitively familiar to you. So, we will discuss here only the
    `PrintStream` class.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
- en: PrintStream
  id: totrans-457
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `PrintStream` class adds to another output stream the ability to print
    data as characters. We have actually used it already many times. The `System`
    class has an object of the `PrintStream` class set as a `System.out` public static
    property. This means that every time we print something using `System.out`, we
    are using the `PrintStream` class:'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE263]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE263]'
- en: 'Let’s look at another example of the `PrintStream` class usage:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE264]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE264]'
- en: '[PRE265]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE265]'
- en: '[PRE266]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE266]'
- en: '[PRE267]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE267]'
- en: '[PRE268]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE268]'
- en: '[PRE269]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE269]'
- en: '[PRE270]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE270]'
- en: As you can see, the `PrintStream` class takes the `FileOutputStream` object
    and prints the characters generated by it. In this case, it prints out all the
    bytes that `FileOutputStream` writes to the file. By the way, there is no need
    to create the destination file explicitly. If absent, it will be created automatically
    inside the `FileOutputStream` constructor. If we open the file after the preceding
    code is run, we will see one line in it – `"Hi there!"`.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, the same result can be achieved using another `PrintStream`
    constructor that takes the `File` object, as follows:'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE271]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE271]'
- en: '[PRE272]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE272]'
- en: '[PRE273]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE273]'
- en: '[PRE274]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE274]'
- en: '[PRE275]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE275]'
- en: '[PRE276]'
  id: totrans-475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE276]'
- en: '[PRE277]'
  id: totrans-476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE277]'
- en: 'An even simpler solution can be created using the third variation of the `PrintStream`
    constructor that takes the filename as a parameter:'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE278]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE278]'
- en: '[PRE279]'
  id: totrans-479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE279]'
- en: '[PRE280]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE280]'
- en: '[PRE281]'
  id: totrans-481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE281]'
- en: '[PRE282]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE282]'
- en: '[PRE283]'
  id: totrans-483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE283]'
- en: 'The previous two examples are possible because the `PrintStream` constructor
    uses the `FileOutputStream` class behind the scenes, exactly as we did it in the
    first example of the `PrintStream` class usage. So, the `PrintStream` class has
    several constructors just for convenience, but all of them essentially have the
    same functionality:'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
- en: '`PrintStream(File file)`'
  id: totrans-485
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PrintStream(File file, String csn)`'
  id: totrans-486
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PrintStream(File file, Charset charset)`'
  id: totrans-487
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PrintStream(String fileName)`'
  id: totrans-488
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PrintStream(String fileName, String csn)`'
  id: totrans-489
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PrintStream(String fileName, Charset charset)`'
  id: totrans-490
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PrintStream(OutputStream out)`'
  id: totrans-491
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PrintStream(OutputStream out, boolean autoFlush)`'
  id: totrans-492
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PrintStream(OutputStream out, boolean autoFlush, String encoding)`'
  id: totrans-493
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PrintStream(OutputStream out, boolean autoFlush, Charset charset)`'
  id: totrans-494
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Some of the constructors also take a `Charset` instance or just its name (`String
    csn`), which allows you to apply a different mapping between sequences of 16-bit
    Unicode code units and sequences of bytes. You can see all available charsets
    by just printing them out, as shown here:'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE284]'
  id: totrans-496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE284]'
- en: '[PRE285]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE285]'
- en: '[PRE286]'
  id: totrans-498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE286]'
- en: Other constructors take `boolean autoFlush` as a parameter. This parameter indicates
    (when `true`) that the output buffer should be flushed automatically when an array
    is written or the symbol end-of-line is encountered.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
- en: 'Once an object of `PrintStream` is created, it provides a variety of methods,
    as listed here:'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
- en: '`void print(T value)`: Prints the value of any `T` primitive type passed in
    without moving to another line'
  id: totrans-501
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void print(Object obj)`: Calls the `toString()` method on the passed in object
    and prints the result without moving to another line; does not generate `NullPointerException`
    in case the passed-in object is `null` and prints `null` instead'
  id: totrans-502
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void println(T value)`: Prints the value of any `T` primitive type passed
    in and moves to another line'
  id: totrans-503
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void println(Object obj)`: Calls the `toString()` method on the passed-in
    object, prints the result, and moves to another line; does not generate `NullPointerException`
    in case the passed-in object is `null` and prints `null` instead'
  id: totrans-504
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void println()`: Just moves to another line'
  id: totrans-505
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PrintStream printf(String format, Object... values)`: Substitutes the placeholders
    in the provided `format` string with the provided `values` and writes the result
    into the stream'
  id: totrans-506
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PrintStream printf(Locale l, String format, Object... args)`: The same as
    the preceding method but applies localization using the provided `Local` object;
    if the provided `Local` object is `null`, no localization is applied, and this
    method behaves exactly like the preceding one'
  id: totrans-507
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PrintStream format(String format, Object... args)` and `PrintStream format(Locale
    l, String format, Object... args)`: Behaves the same way as `PrintStream printf(String
    format, Object... values)` and `PrintStream printf(Locale l, String format, Object...
    args)` (already described in the list), such as the following:'
  id: totrans-508
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE287]'
  id: totrans-509
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE287]'
- en: In the preceding example, (`%`) indicates a formatting rule. The following symbol
    (`s`) indicates a `String` value. Other possible symbols in this position can
    be (`d`) (decimal), (`f`) (floating-point), and so on. The symbol (`n`) indicates
    a new line (the same as the (`\n`) escape character). There are many formatting
    rules. All of them are described in the documentation for the `java.util.Formatter`
    class.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
- en: '`PrintStream append(char c)`, `PrintStream append(CharSequence c)`, and `PrintStream
    append(CharSequence c, int start, int end)`: Appends the provided character to
    the stream, such as the following:'
  id: totrans-511
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE288]'
  id: totrans-512
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE288]'
- en: With this, we conclude the discussion of the `OutputStream` subclass and now
    turn our attention to another class hierarchy – the `Reader` and `Writer` classes
    and their subclasses from the JCL.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
- en: The Reader and Writer classes and their subclasses
  id: totrans-514
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we mentioned several times already, the `Reader` and `Writer` classes are
    very similar in their function to the `InputStream` and `OutputStream` classes
    but specialize in processing texts. They interpret stream bytes as characters
    and have their own independent `InputStream` and `OutputStream` class hierarchy.
    It is possible to process stream bytes as characters without `Reader` and `Writer`
    or any of their subclasses. We have seen such examples in the preceding sections
    describing the `InputStream` and `OutputStream` classes. However, using the `Reader`
    and `Writer` classes makes text processing simpler and code easier to read.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
- en: Reader and its subclasses
  id: totrans-516
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `Reader` class is an abstract class that reads streams as characters. It
    is an analog to `InputStream` and has the following methods:'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
- en: '`abstract void close()`: Closes the stream and other used resources'
  id: totrans-518
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void mark(int readAheadLimit)`: Marks the current position in the stream'
  id: totrans-519
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`boolean markSupported()`: Returns `true` if the stream supports the `mark()`
    operation'
  id: totrans-520
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`static Reader nullReader()`: Creates an empty `Reader` that reads no characters'
  id: totrans-521
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`int read()`: Reads one character'
  id: totrans-522
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`int read(char[] buf)`: Reads characters into the provided `buf` array and
    returns the count of the read characters'
  id: totrans-523
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`abstract int read(char[] buf, int off, int len)`: Reads the `len` characters
    into an array starting from the `off` index'
  id: totrans-524
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`int read(CharBuffer target)`: Attempts to read characters into the provided
    `target` buffer'
  id: totrans-525
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`boolean ready()`: Returns `true` when the stream is ready to be read'
  id: totrans-526
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void reset()`: Resets the mark; however, not all streams support this operation,
    with some supporting it but not supporting a mark being set in the first place'
  id: totrans-527
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`long skip(long n)`: Attempts to skip the `n` characters; returns the count
    of skipped characters'
  id: totrans-528
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`long transferTo(Writer out)`: Reads all characters from this reader and writes
    the characters to the provided `Writer` object'
  id: totrans-529
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see, the only methods that need to be implemented are the two abstract
    `read()` and `close()` methods. Nevertheless, many children of this class override
    other methods too, sometimes for better performance or different functionality.
    The `Reader` subclasses in the JCL are `CharArrayReader`, `InputStreamReader`,
    `PipedReader`, `StringReader`, `BufferedReader`, and `FilterReader`. The `BufferedReader`
    class has a `LineNumberReader` subclass, and the `FilterReader` class has a `PushbackReader`
    subclass.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
- en: Writer and its subclasses
  id: totrans-531
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The abstract `Writer` class writes to character streams. It is an analog to
    `OutputStream` and has the following methods:'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
- en: '`Writer append(char c)`: Appends the provided character to the stream'
  id: totrans-533
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Writer append(CharSequence c)`: Appends the provided character sequence to
    the stream'
  id: totrans-534
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Writer append(CharSequence c, int start, int end)`: Appends a subsequence
    of the provided character sequence to the stream'
  id: totrans-535
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`abstract void close()`: Flushes and closes the stream and related system resources'
  id: totrans-536
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`abstract void flush()`: Flushes the stream'
  id: totrans-537
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`static Writer nullWriter()`: Creates a new `Writer` object that discards all
    characters'
  id: totrans-538
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void write(char[] c)`: Writes an array of `c` characters'
  id: totrans-539
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`abstract void write(char[] c, int off, int len)`: Writes the `len` elements
    of an array of `c` characters, starting from the `off` index'
  id: totrans-540
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void write(int c)`: Writes one character'
  id: totrans-541
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void write(String str)`: Writes the provided string'
  id: totrans-542
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void write(String str, int off, int len)`: Writes a substring of the `len`
    length from the provided `str` string, starting from the `off` index'
  id: totrans-543
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see, the three abstract methods, `write(char[], int, int)`, `flush()`,
    and `close()`, must be implemented by the children of this class. They also typically
    override other methods too.
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
- en: The `Writer` subclasses in the JCL are `CharArrayWriter`, `OutputStreamWriter`,
    `PipedWriter`, `StringWriter`, `BufferedWriter`, `FilterWriter`, and `PrintWriter`.
    The `OutputStreamWriter` class has a `FileWriter` subclass.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
- en: Other classes of the java.io package
  id: totrans-546
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Other classes of the `java.io` package include the following:'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
- en: '`Console`: Allows interaction with the character-based console device, associated
    with the current Java Virtual Machine instance'
  id: totrans-548
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`StreamTokenizer`: Takes an input stream and parses it into `tokens`'
  id: totrans-549
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ObjectStreamClass`: The serialization’s descriptor for classes'
  id: totrans-550
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ObjectStreamField`: A description of a serializable field from a serializable
    class'
  id: totrans-551
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RandomAccessFile`: Allows random access for reading from and writing to a
    file, but its discussion is outside the scope of this book'
  id: totrans-552
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`File`: Allows creating and managing files and directories; described in the
    *File management* section'
  id: totrans-553
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Console
  id: totrans-554
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are several ways to create and run a **Java Virtual Machine** (**JVM**)
    instance that executes an application. If the JVM is started from a command line,
    a console window is automatically opened. It allows you to type on the display
    from the keyboard; however, the JVM can be started by a background process too.
    In such a case, a console is not created.
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
- en: To check programmatically whether a console exists, you can invoke the `System.console()`
    static method. If no console device is available, then an invocation of that method
    will return `null`. Otherwise, it will return an object of the `Console` class
    that allows interaction with the console device and the application user.
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create the following `ConsoleDemo` class:'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE289]'
  id: totrans-558
  prefs: []
  type: TYPE_PRE
  zh: '[PRE289]'
- en: '[PRE290]'
  id: totrans-559
  prefs: []
  type: TYPE_PRE
  zh: '[PRE290]'
- en: '[PRE291]'
  id: totrans-560
  prefs: []
  type: TYPE_PRE
  zh: '[PRE291]'
- en: '[PRE292]'
  id: totrans-561
  prefs: []
  type: TYPE_PRE
  zh: '[PRE292]'
- en: '[PRE293]'
  id: totrans-562
  prefs: []
  type: TYPE_PRE
  zh: '[PRE293]'
- en: '[PRE294]'
  id: totrans-563
  prefs: []
  type: TYPE_PRE
  zh: '[PRE294]'
- en: '[PRE295]'
  id: totrans-564
  prefs: []
  type: TYPE_PRE
  zh: '[PRE295]'
- en: '[PRE296]'
  id: totrans-565
  prefs: []
  type: TYPE_PRE
  zh: '[PRE296]'
- en: 'If we run it from the IDE, as we usually do, the result will be as follows:'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18388_Figure_5.3.jpg)'
  id: totrans-567
  prefs: []
  type: TYPE_IMG
- en: That is because the JVM was not launched from the command line. In order to
    do it, let’s compile our application and create a `.jar` file by executing the
    `mvn clean package` Maven command in the root directory of the project. (We assume
    that you have Maven installed on your computer.) It will delete the `target` folder,
    then recreate it, compile all the `.java` files to the corresponding `.class`
    files in the `target` folder, and then archive them in a `.jar` file, `learnjava-1.0-SNAPSHOT.jar`.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can launch the `ConsoleDemo` application from the same project root
    directory using the following command:'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE297]'
  id: totrans-570
  prefs: []
  type: TYPE_PRE
  zh: '[PRE297]'
- en: 'The preceding `–cp` command option depicts a classpath, so in our case, we
    tell the JVM to look for the classes in the `.jar` file in the folder target.
    The command is shown in two lines because the page width cannot accommodate it.
    But if you want to run it, make sure you do it as one line. The result will be
    as follows:'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18388_Figure_5.4.jpg)'
  id: totrans-572
  prefs: []
  type: TYPE_IMG
- en: 'This tells us that we have the `Console` class object now. Let’s see what we
    can do with it. The class has the following methods:'
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
- en: '`String readLine()`: Waits until the user hits the *Enter* key and reads the
    line of text from the console'
  id: totrans-574
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`String readLine(String format, Object... args)`: Displays a prompt (the message
    produced after the provided format had the placeholders substituted with the provided
    arguments), waits until the user hits the *Enter* key, and reads the line of text
    from the console; if no arguments (`args`) are provided, it displays the format
    as the prompt'
  id: totrans-575
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`char[] readPassword()`: Performs the same function as the `readLine()` function
    but without echoing the typed characters'
  id: totrans-576
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`char[] readPassword(String format, Object... args)`: Performs the same function
    as `readLine(String format, Object... args)` but without echoing the typed characters'
  id: totrans-577
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To run each of the following code sections individually, you need to comment
    out the `console1()` call in the `main` method and uncomment `console2()` or `console3()`,
    recompile using `mvn package`, and then rerun the `java` command shown previously.
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s demonstrate the preceding methods with the following example (the `console2()`
    method):'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE298]'
  id: totrans-580
  prefs: []
  type: TYPE_PRE
  zh: '[PRE298]'
- en: '[PRE299]'
  id: totrans-581
  prefs: []
  type: TYPE_PRE
  zh: '[PRE299]'
- en: '[PRE300]'
  id: totrans-582
  prefs: []
  type: TYPE_PRE
  zh: '[PRE300]'
- en: '[PRE301]'
  id: totrans-583
  prefs: []
  type: TYPE_PRE
  zh: '[PRE301]'
- en: '[PRE302]'
  id: totrans-584
  prefs: []
  type: TYPE_PRE
  zh: '[PRE302]'
- en: '[PRE303]'
  id: totrans-585
  prefs: []
  type: TYPE_PRE
  zh: '[PRE303]'
- en: '[PRE304]'
  id: totrans-586
  prefs: []
  type: TYPE_PRE
  zh: '[PRE304]'
- en: '[PRE305]'
  id: totrans-587
  prefs: []
  type: TYPE_PRE
  zh: '[PRE305]'
- en: '[PRE306]'
  id: totrans-588
  prefs: []
  type: TYPE_PRE
  zh: '[PRE306]'
- en: '[PRE307]'
  id: totrans-589
  prefs: []
  type: TYPE_PRE
  zh: '[PRE307]'
- en: '[PRE308]'
  id: totrans-590
  prefs: []
  type: TYPE_PRE
  zh: '[PRE308]'
- en: '[PRE309]'
  id: totrans-591
  prefs: []
  type: TYPE_PRE
  zh: '[PRE309]'
- en: '[PRE310]'
  id: totrans-592
  prefs: []
  type: TYPE_PRE
  zh: '[PRE310]'
- en: '[PRE311]'
  id: totrans-593
  prefs: []
  type: TYPE_PRE
  zh: '[PRE311]'
- en: '[PRE312]'
  id: totrans-594
  prefs: []
  type: TYPE_PRE
  zh: '[PRE312]'
- en: 'The result of the preceding example is as follows:'
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18388_Figure_5.6.jpg)'
  id: totrans-596
  prefs: []
  type: TYPE_IMG
- en: Some IDEs cannot run these examples and throw `NullPointerException`. If that
    is the case, run the console-related examples from the command line, as described
    previously. Don’t forget to run the `maven package` command every time you change
    code.
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
- en: 'Another group of `Console` class methods can be used in conjunction with the
    previously demonstrated methods:'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
- en: '`Console format(String format, Object... args)`: Substitutes the placeholders
    in the provided `format` string with the provided `args` values and displays the
    result'
  id: totrans-599
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Console printf(String format, Object... args)`: Behaves the same way as the
    `format()` method'
  id: totrans-600
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As an example, look at the following line:'
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE313]'
  id: totrans-602
  prefs: []
  type: TYPE_PRE
  zh: '[PRE313]'
- en: 'It produces the same result as this line:'
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE314]'
  id: totrans-604
  prefs: []
  type: TYPE_PRE
  zh: '[PRE314]'
- en: 'And finally, the last three methods of the `Console` class are as follows:'
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
- en: '`PrintWriter writer()`: Creates a `PrintWriter` object associated with this
    console that can be used for producing an output stream of characters'
  id: totrans-606
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Reader reader()`: Creates a `Reader` object associated with this console that
    can be used for reading the input as a stream of characters'
  id: totrans-607
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void flush()`: Flushes the console and forces any buffered output to be written
    immediately'
  id: totrans-608
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is an example of their usage (the `console3()` method):'
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE315]'
  id: totrans-610
  prefs: []
  type: TYPE_PRE
  zh: '[PRE315]'
- en: '[PRE316]'
  id: totrans-611
  prefs: []
  type: TYPE_PRE
  zh: '[PRE316]'
- en: '[PRE317]'
  id: totrans-612
  prefs: []
  type: TYPE_PRE
  zh: '[PRE317]'
- en: '[PRE318]'
  id: totrans-613
  prefs: []
  type: TYPE_PRE
  zh: '[PRE318]'
- en: '[PRE319]'
  id: totrans-614
  prefs: []
  type: TYPE_PRE
  zh: '[PRE319]'
- en: '[PRE320]'
  id: totrans-615
  prefs: []
  type: TYPE_PRE
  zh: '[PRE320]'
- en: '[PRE321]'
  id: totrans-616
  prefs: []
  type: TYPE_PRE
  zh: '[PRE321]'
- en: '[PRE322]'
  id: totrans-617
  prefs: []
  type: TYPE_PRE
  zh: '[PRE322]'
- en: '[PRE323]'
  id: totrans-618
  prefs: []
  type: TYPE_PRE
  zh: '[PRE323]'
- en: '[PRE324]'
  id: totrans-619
  prefs: []
  type: TYPE_PRE
  zh: '[PRE324]'
- en: '[PRE325]'
  id: totrans-620
  prefs: []
  type: TYPE_PRE
  zh: '[PRE325]'
- en: 'The result of the preceding code looks as follows:'
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18388_Figure_5.7.jpg)'
  id: totrans-622
  prefs: []
  type: TYPE_IMG
- en: '`Reader` and `PrintWriter` can also be used to create other `Input` and `Output`
    streams that we have been talking about in this section.'
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
- en: StreamTokenizer
  id: totrans-624
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `StreamTokenizer` class parses the input stream and produces tokens. Its
    `StreamTokenizer(Reader r)` constructor accepts a `Reader` object that is the
    source of the tokens. Every time the `int nextToken()` method is called on the
    `StreamTokenizer` object, the following happens:'
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
- en: The next token is parsed.
  id: totrans-626
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `StreamTokenizer` instance field, `ttype`, is populated by the value that
    indicates the token type:'
  id: totrans-627
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `ttype` value can be one of the following integer constants: `TT_WORD`,
    `TT_NUMBER`, `TT_EOL` (end-of-line), or `TT_EOF` (end-of-stream).'
  id: totrans-628
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If the `ttype` value is `TT_WORD`, the `StreamTokenizer` instance, the `sval`
    field, is populated by the `String` value of the token.
  id: totrans-629
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If the `ttype` value is `TT_NUMBER`, the `StreamTokenizer` instance field, `nval`,
    is populated by the `double` value of the token.
  id: totrans-630
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `lineno()` method of the `StreamTokenizer` instance returns the current
    line number.
  id: totrans-631
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let’s look at an example before talking about other methods of the `StreamTokenizer`
    class. Let’s assume that, in the project `resources` folder, there is a `tokens.txt`
    file that contains the following four lines of text:'
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE326]'
  id: totrans-633
  prefs: []
  type: TYPE_PRE
  zh: '[PRE326]'
- en: '[PRE327]'
  id: totrans-634
  prefs: []
  type: TYPE_PRE
  zh: '[PRE327]'
- en: '[PRE328]'
  id: totrans-635
  prefs: []
  type: TYPE_PRE
  zh: '[PRE328]'
- en: '[PRE329]'
  id: totrans-636
  prefs: []
  type: TYPE_PRE
  zh: '[PRE329]'
- en: 'The following code will read the file and tokenize its content (the `streamTokenizer()`
    method of the `InputOutputStream` class):'
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE330]'
  id: totrans-638
  prefs: []
  type: TYPE_PRE
  zh: '[PRE330]'
- en: '[PRE331]'
  id: totrans-639
  prefs: []
  type: TYPE_PRE
  zh: '[PRE331]'
- en: '[PRE332]'
  id: totrans-640
  prefs: []
  type: TYPE_PRE
  zh: '[PRE332]'
- en: '[PRE333]'
  id: totrans-641
  prefs: []
  type: TYPE_PRE
  zh: '[PRE333]'
- en: '[PRE334]'
  id: totrans-642
  prefs: []
  type: TYPE_PRE
  zh: '[PRE334]'
- en: '[PRE335]'
  id: totrans-643
  prefs: []
  type: TYPE_PRE
  zh: '[PRE335]'
- en: '[PRE336]'
  id: totrans-644
  prefs: []
  type: TYPE_PRE
  zh: '[PRE336]'
- en: '[PRE337]'
  id: totrans-645
  prefs: []
  type: TYPE_PRE
  zh: '[PRE337]'
- en: '[PRE338]'
  id: totrans-646
  prefs: []
  type: TYPE_PRE
  zh: '[PRE338]'
- en: '[PRE339]'
  id: totrans-647
  prefs: []
  type: TYPE_PRE
  zh: '[PRE339]'
- en: '[PRE340]'
  id: totrans-648
  prefs: []
  type: TYPE_PRE
  zh: '[PRE340]'
- en: '[PRE341]'
  id: totrans-649
  prefs: []
  type: TYPE_PRE
  zh: '[PRE341]'
- en: '[PRE342]'
  id: totrans-650
  prefs: []
  type: TYPE_PRE
  zh: '[PRE342]'
- en: '[PRE343]'
  id: totrans-651
  prefs: []
  type: TYPE_PRE
  zh: '[PRE343]'
- en: '[PRE344]'
  id: totrans-652
  prefs: []
  type: TYPE_PRE
  zh: '[PRE344]'
- en: '[PRE345]'
  id: totrans-653
  prefs: []
  type: TYPE_PRE
  zh: '[PRE345]'
- en: '[PRE346]'
  id: totrans-654
  prefs: []
  type: TYPE_PRE
  zh: '[PRE346]'
- en: '[PRE347]'
  id: totrans-655
  prefs: []
  type: TYPE_PRE
  zh: '[PRE347]'
- en: '[PRE348]'
  id: totrans-656
  prefs: []
  type: TYPE_PRE
  zh: '[PRE348]'
- en: '[PRE349]'
  id: totrans-657
  prefs: []
  type: TYPE_PRE
  zh: '[PRE349]'
- en: '[PRE350]'
  id: totrans-658
  prefs: []
  type: TYPE_PRE
  zh: '[PRE350]'
- en: '[PRE351]'
  id: totrans-659
  prefs: []
  type: TYPE_PRE
  zh: '[PRE351]'
- en: '[PRE352]'
  id: totrans-660
  prefs: []
  type: TYPE_PRE
  zh: '[PRE352]'
- en: '[PRE353]'
  id: totrans-661
  prefs: []
  type: TYPE_PRE
  zh: '[PRE353]'
- en: '[PRE354]'
  id: totrans-662
  prefs: []
  type: TYPE_PRE
  zh: '[PRE354]'
- en: '[PRE355]'
  id: totrans-663
  prefs: []
  type: TYPE_PRE
  zh: '[PRE355]'
- en: '[PRE356]'
  id: totrans-664
  prefs: []
  type: TYPE_PRE
  zh: '[PRE356]'
- en: 'If we run this code, the result will be the following:'
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18388_Figure_5.8.jpg)'
  id: totrans-666
  prefs: []
  type: TYPE_IMG
- en: 'We have used the `BufferedReader` class, which is a good practice for higher
    efficiency, but in our case, we can easily avoid it, like this:'
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE357]'
  id: totrans-668
  prefs: []
  type: TYPE_PRE
  zh: '[PRE357]'
- en: '[PRE358]'
  id: totrans-669
  prefs: []
  type: TYPE_PRE
  zh: '[PRE358]'
- en: 'The result would not change. We also used the following three methods that
    we have not described yet:'
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
- en: '`void eolIsSignificant(boolean flag)`: Indicates whether the end-of-line should
    be treated as a token'
  id: totrans-671
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void commentChar(int ch)`: Indicates which character starts a comment, so
    the rest of the line is ignored'
  id: totrans-672
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`int lineno()`: Returns the current line number'
  id: totrans-673
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following methods can be invoked using the `StreamTokenizer` object:'
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
- en: '`void lowerCaseMode(boolean fl)`: Indicates whether a word token should be
    lowercase'
  id: totrans-675
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void ordinaryChar(int ch)`, `void ordinaryChars(int low, int hi)`: Indicate
    a specific character or the range of characters that have to be treated as *ordinary*
    (not as a comment character, word component, string delimiter, white space, or
    number character)'
  id: totrans-676
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void parseNumbers()`: Indicates that a word token that has the format of a
    double-precision floating-point number has to be interpreted as a number, rather
    than a word'
  id: totrans-677
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void pushBack()`: Forces the `nextToken()` method to return the current value
    of the `ttype` field'
  id: totrans-678
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void quoteChar(int ch)`: Indicates that the provided character has to be interpreted
    as the beginning and the end of the string value that has to be taken as-is (as
    a quote)'
  id: totrans-679
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void resetSyntax()`: Resets this tokenizer’s syntax table so that all characters
    are *ordinary*'
  id: totrans-680
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void slashSlashComments(boolean flag)`: Indicates that C++-style comments
    have to be recognized'
  id: totrans-681
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void slashStarComments(boolean flag)`: Indicates that C-style comments have
    to be recognized'
  id: totrans-682
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`String toString()`: Returns the string representation of the token and the
    line number'
  id: totrans-683
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void whitespaceChars(int low, int hi)`: Indicates the range of characters
    that have to be interpreted as white space'
  id: totrans-684
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void wordChars(int low, int hi)`: Indicates the range of characters that have
    to be interpreted as a word'
  id: totrans-685
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see, using the wealth of the preceding methods allows you to fine-tune
    the text interpretation.
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
- en: ObjectStreamClass and ObjectStreamField
  id: totrans-687
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `ObjectStreamClass` and `ObjectStreamField` classes provide access to the
    serialized data of a class loaded in the JVM. The `ObjectStreamClass` object can
    be found/created using one of the following lookup methods:'
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
- en: '`static ObjectStreamClass lookup(Class cl)`: Finds the descriptor of a serializable
    class'
  id: totrans-689
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`static ObjectStreamClass lookupAny(Class cl)`: Finds the descriptor for any
    class, whether serializable or not'
  id: totrans-690
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After `ObjectStreamClass` is found and the class is serializable (implementing
    the `Serializable` interface), it can be used to access the `ObjectStreamField`
    objects, each containing information about one serialized field. If the class
    is not serializable, there is no `ObjectStreamField` object associated with any
    of the fields.
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at an example. Here is the method that displays information obtained
    from the `ObjectStreamClass` and `ObjectStreamField` objects:'
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE359]'
  id: totrans-693
  prefs: []
  type: TYPE_PRE
  zh: '[PRE359]'
- en: '[PRE360]'
  id: totrans-694
  prefs: []
  type: TYPE_PRE
  zh: '[PRE360]'
- en: '[PRE361]'
  id: totrans-695
  prefs: []
  type: TYPE_PRE
  zh: '[PRE361]'
- en: '[PRE362]'
  id: totrans-696
  prefs: []
  type: TYPE_PRE
  zh: '[PRE362]'
- en: '[PRE363]'
  id: totrans-697
  prefs: []
  type: TYPE_PRE
  zh: '[PRE363]'
- en: '[PRE364]'
  id: totrans-698
  prefs: []
  type: TYPE_PRE
  zh: '[PRE364]'
- en: '[PRE365]'
  id: totrans-699
  prefs: []
  type: TYPE_PRE
  zh: '[PRE365]'
- en: '[PRE366]'
  id: totrans-700
  prefs: []
  type: TYPE_PRE
  zh: '[PRE366]'
- en: '[PRE367]'
  id: totrans-701
  prefs: []
  type: TYPE_PRE
  zh: '[PRE367]'
- en: '[PRE368]'
  id: totrans-702
  prefs: []
  type: TYPE_PRE
  zh: '[PRE368]'
- en: '[PRE369]'
  id: totrans-703
  prefs: []
  type: TYPE_PRE
  zh: '[PRE369]'
- en: '[PRE370]'
  id: totrans-704
  prefs: []
  type: TYPE_PRE
  zh: '[PRE370]'
- en: '[PRE371]'
  id: totrans-705
  prefs: []
  type: TYPE_PRE
  zh: '[PRE371]'
- en: '[PRE372]'
  id: totrans-706
  prefs: []
  type: TYPE_PRE
  zh: '[PRE372]'
- en: 'To demonstrate how it works, we will create a serializable `Person1` class:'
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE373]'
  id: totrans-708
  prefs: []
  type: TYPE_PRE
  zh: '[PRE373]'
- en: '[PRE374]'
  id: totrans-709
  prefs: []
  type: TYPE_PRE
  zh: '[PRE374]'
- en: '[PRE375]'
  id: totrans-710
  prefs: []
  type: TYPE_PRE
  zh: '[PRE375]'
- en: '[PRE376]'
  id: totrans-711
  prefs: []
  type: TYPE_PRE
  zh: '[PRE376]'
- en: '[PRE377]'
  id: totrans-712
  prefs: []
  type: TYPE_PRE
  zh: '[PRE377]'
- en: '[PRE378]'
  id: totrans-713
  prefs: []
  type: TYPE_PRE
  zh: '[PRE378]'
- en: '[PRE379]'
  id: totrans-714
  prefs: []
  type: TYPE_PRE
  zh: '[PRE379]'
- en: '[PRE380]'
  id: totrans-715
  prefs: []
  type: TYPE_PRE
  zh: '[PRE380]'
- en: '[PRE381]'
  id: totrans-716
  prefs: []
  type: TYPE_PRE
  zh: '[PRE381]'
- en: '[PRE382]'
  id: totrans-717
  prefs: []
  type: TYPE_PRE
  zh: '[PRE382]'
- en: 'We did not add methods because only the object state is serializable, not the
    methods. Now, let’s run the following code:'
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE383]'
  id: totrans-719
  prefs: []
  type: TYPE_PRE
  zh: '[PRE383]'
- en: '[PRE384]'
  id: totrans-720
  prefs: []
  type: TYPE_PRE
  zh: '[PRE384]'
- en: '[PRE385]'
  id: totrans-721
  prefs: []
  type: TYPE_PRE
  zh: '[PRE385]'
- en: 'The result will be as follows:'
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18388_Figure_5.9.jpg)'
  id: totrans-723
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, there is information about the class name and all field names
    and types. There are also two other methods that can be called using the `ObjectStreamField`
    object:'
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
- en: '`boolean isPrimitive()`: Returns `true` if this field has a primitive type'
  id: totrans-725
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`boolean isUnshared()`: Returns `true` if this field is unshared (private or
    accessible only from the same package)'
  id: totrans-726
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, let’s create a non-serializable `Person2` class:'
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE386]'
  id: totrans-728
  prefs: []
  type: TYPE_PRE
  zh: '[PRE386]'
- en: '[PRE387]'
  id: totrans-729
  prefs: []
  type: TYPE_PRE
  zh: '[PRE387]'
- en: '[PRE388]'
  id: totrans-730
  prefs: []
  type: TYPE_PRE
  zh: '[PRE388]'
- en: '[PRE389]'
  id: totrans-731
  prefs: []
  type: TYPE_PRE
  zh: '[PRE389]'
- en: '[PRE390]'
  id: totrans-732
  prefs: []
  type: TYPE_PRE
  zh: '[PRE390]'
- en: '[PRE391]'
  id: totrans-733
  prefs: []
  type: TYPE_PRE
  zh: '[PRE391]'
- en: '[PRE392]'
  id: totrans-734
  prefs: []
  type: TYPE_PRE
  zh: '[PRE392]'
- en: '[PRE393]'
  id: totrans-735
  prefs: []
  type: TYPE_PRE
  zh: '[PRE393]'
- en: '[PRE394]'
  id: totrans-736
  prefs: []
  type: TYPE_PRE
  zh: '[PRE394]'
- en: 'This time, we will run the code that only looks up the class, as follows:'
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE395]'
  id: totrans-738
  prefs: []
  type: TYPE_PRE
  zh: '[PRE395]'
- en: '[PRE396]'
  id: totrans-739
  prefs: []
  type: TYPE_PRE
  zh: '[PRE396]'
- en: '[PRE397]'
  id: totrans-740
  prefs: []
  type: TYPE_PRE
  zh: '[PRE397]'
- en: 'As expected, the non-serializable object was not found using the `lookup()`
    method. In order to find a non-serializable object, we need to use the `lookupAny()`
    method:'
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE398]'
  id: totrans-742
  prefs: []
  type: TYPE_PRE
  zh: '[PRE398]'
- en: '[PRE399]'
  id: totrans-743
  prefs: []
  type: TYPE_PRE
  zh: '[PRE399]'
- en: '[PRE400]'
  id: totrans-744
  prefs: []
  type: TYPE_PRE
  zh: '[PRE400]'
- en: 'If we run the preceding example, the result will be as follows:'
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18388_Figure_5.10.jpg)'
  id: totrans-746
  prefs: []
  type: TYPE_IMG
- en: From a non-serializable object, we were able to extract information about the
    class but not about the fields.
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
- en: The java.util.Scanner class
  id: totrans-748
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `java.util.Scanner` class is typically used to read input from a keyboard
    but can also read text from any object that implements the `Readable` interface
    (this interface only has the `int read(CharBuffer buffer)` method). It breaks
    the input value by a delimiter (white space is a default delimiter) into tokens
    that are processed using different methods.
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we can read an input from `System.in` – a standard input stream,
    which typically represents keyboard input:'
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE401]'
  id: totrans-751
  prefs: []
  type: TYPE_PRE
  zh: '[PRE401]'
- en: '[PRE402]'
  id: totrans-752
  prefs: []
  type: TYPE_PRE
  zh: '[PRE402]'
- en: '[PRE403]'
  id: totrans-753
  prefs: []
  type: TYPE_PRE
  zh: '[PRE403]'
- en: '[PRE404]'
  id: totrans-754
  prefs: []
  type: TYPE_PRE
  zh: '[PRE404]'
- en: '[PRE405]'
  id: totrans-755
  prefs: []
  type: TYPE_PRE
  zh: '[PRE405]'
- en: '[PRE406]'
  id: totrans-756
  prefs: []
  type: TYPE_PRE
  zh: '[PRE406]'
- en: '[PRE407]'
  id: totrans-757
  prefs: []
  type: TYPE_PRE
  zh: '[PRE407]'
- en: '[PRE408]'
  id: totrans-758
  prefs: []
  type: TYPE_PRE
  zh: '[PRE408]'
- en: '[PRE409]'
  id: totrans-759
  prefs: []
  type: TYPE_PRE
  zh: '[PRE409]'
- en: 'It accepts many lines (each line ends after the *Enter* key is pressed) until
    the line `end` is entered, as follows:'
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18388_Figure_5.11.jpg)'
  id: totrans-761
  prefs: []
  type: TYPE_IMG
- en: 'Alternatively, `Scanner` can read lines from a file:'
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE410]'
  id: totrans-763
  prefs: []
  type: TYPE_PRE
  zh: '[PRE410]'
- en: '[PRE411]'
  id: totrans-764
  prefs: []
  type: TYPE_PRE
  zh: '[PRE411]'
- en: '[PRE412]'
  id: totrans-765
  prefs: []
  type: TYPE_PRE
  zh: '[PRE412]'
- en: '[PRE413]'
  id: totrans-766
  prefs: []
  type: TYPE_PRE
  zh: '[PRE413]'
- en: '[PRE414]'
  id: totrans-767
  prefs: []
  type: TYPE_PRE
  zh: '[PRE414]'
- en: '[PRE415]'
  id: totrans-768
  prefs: []
  type: TYPE_PRE
  zh: '[PRE415]'
- en: '[PRE416]'
  id: totrans-769
  prefs: []
  type: TYPE_PRE
  zh: '[PRE416]'
- en: '[PRE417]'
  id: totrans-770
  prefs: []
  type: TYPE_PRE
  zh: '[PRE417]'
- en: 'As you can see, we have used the `tokens.txt` file again. The results are as
    follows:'
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18388_Figure_5.12.jpg)'
  id: totrans-772
  prefs: []
  type: TYPE_IMG
- en: 'To demonstrate `Scanner` breaking the input by a delimiter, let’s run the following
    code:'
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE418]'
  id: totrans-774
  prefs: []
  type: TYPE_PRE
  zh: '[PRE418]'
- en: '[PRE419]'
  id: totrans-775
  prefs: []
  type: TYPE_PRE
  zh: '[PRE419]'
- en: '[PRE420]'
  id: totrans-776
  prefs: []
  type: TYPE_PRE
  zh: '[PRE420]'
- en: '[PRE421]'
  id: totrans-777
  prefs: []
  type: TYPE_PRE
  zh: '[PRE421]'
- en: '[PRE422]'
  id: totrans-778
  prefs: []
  type: TYPE_PRE
  zh: '[PRE422]'
- en: 'The result is as follows:'
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18388_Figure_5.13.jpg)'
  id: totrans-780
  prefs: []
  type: TYPE_IMG
- en: 'To use another delimiter, it can be set as follows:'
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE423]'
  id: totrans-782
  prefs: []
  type: TYPE_PRE
  zh: '[PRE423]'
- en: '[PRE424]'
  id: totrans-783
  prefs: []
  type: TYPE_PRE
  zh: '[PRE424]'
- en: '[PRE425]'
  id: totrans-784
  prefs: []
  type: TYPE_PRE
  zh: '[PRE425]'
- en: '[PRE426]'
  id: totrans-785
  prefs: []
  type: TYPE_PRE
  zh: '[PRE426]'
- en: '[PRE427]'
  id: totrans-786
  prefs: []
  type: TYPE_PRE
  zh: '[PRE427]'
- en: 'The result remains the same:'
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18388_Figure_5.14.jpg)'
  id: totrans-788
  prefs: []
  type: TYPE_IMG
- en: It is also possible to use a regular expression for extracting the tokens, but
    that topic is outside the scope of this book.
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
- en: The `Scanner` class has many other methods that make its usage applicable to
    a variety of sources and required results. The `findInLine()`, `findWithinHorizon()`,
    `skip()`, and `findAll()` methods do not use the delimiter; they just try to match
    the provided pattern. For more information, refer to the Scanner documentation
    ([https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/Scanner.html](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/Scanner.html)).
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
- en: File management
  id: totrans-791
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already used some methods for finding, creating, reading, and writing
    files using the JCL classes. We had to do it in order to support a demo code of
    input/output streams. In this section, we are going to talk about file management
    using the JCL in more detail.
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
- en: 'The `File` class from the `java.io` package represents the underlying filesystem.
    An object of the `File` class can be created with one of the following constructors:'
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
- en: '`File(String pathname)`: Creates a new `File` instance based on the provided
    pathname'
  id: totrans-794
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`File(String parent, String child)`: Creates a new `File` instance based on
    the provided parent pathname and a child pathname'
  id: totrans-795
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`File(File parent, String child)`: Creates a new `File` instance based on the
    provided parent `File` object and a child pathname'
  id: totrans-796
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`File(URI uri)`: Creates a new `File` instance based on the provided `URI`
    object that represents the pathname'
  id: totrans-797
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will now see some examples of the constructors’ usage while talking about
    creating and deleting files.
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
- en: Creating and deleting files and directories
  id: totrans-799
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create a file or directory in the filesystem, you need first to construct
    a new `File` object using one of the constructors listed in the *File management*
    section. For example, assuming that the filename is `FileName.txt`, the `File`
    object can be created as `new File("FileName.txt")`. If the file has to be created
    inside a directory, then either a path has to be added in front of the filename
    (when it is passed into the constructor) or one of the other three constructors
    has to be used, such as the following (see the `createFile2()` method in the `Files`
    class):'
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE428]'
  id: totrans-801
  prefs: []
  type: TYPE_PRE
  zh: '[PRE428]'
- en: '[PRE429]'
  id: totrans-802
  prefs: []
  type: TYPE_PRE
  zh: '[PRE429]'
- en: '[PRE430]'
  id: totrans-803
  prefs: []
  type: TYPE_PRE
  zh: '[PRE430]'
- en: '[PRE431]'
  id: totrans-804
  prefs: []
  type: TYPE_PRE
  zh: '[PRE431]'
- en: 'Note the usage of `File.separator` instead of the slash symbols, (`/`) or (`\`).
    That is because `File.separator` returns the platform-specific slash symbol. Here
    is an example of another `File` constructor usage:'
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE432]'
  id: totrans-806
  prefs: []
  type: TYPE_PRE
  zh: '[PRE432]'
- en: '[PRE433]'
  id: totrans-807
  prefs: []
  type: TYPE_PRE
  zh: '[PRE433]'
- en: '[PRE434]'
  id: totrans-808
  prefs: []
  type: TYPE_PRE
  zh: '[PRE434]'
- en: '[PRE435]'
  id: totrans-809
  prefs: []
  type: TYPE_PRE
  zh: '[PRE435]'
- en: 'Yet another constructor can be used as follows:'
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE436]'
  id: totrans-811
  prefs: []
  type: TYPE_PRE
  zh: '[PRE436]'
- en: '[PRE437]'
  id: totrans-812
  prefs: []
  type: TYPE_PRE
  zh: '[PRE437]'
- en: '[PRE438]'
  id: totrans-813
  prefs: []
  type: TYPE_PRE
  zh: '[PRE438]'
- en: '[PRE439]'
  id: totrans-814
  prefs: []
  type: TYPE_PRE
  zh: '[PRE439]'
- en: 'However, if you prefer or have to use a `File` object like this:'
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE440]'
  id: totrans-816
  prefs: []
  type: TYPE_PRE
  zh: '[PRE440]'
- en: '[PRE441]'
  id: totrans-817
  prefs: []
  type: TYPE_PRE
  zh: '[PRE441]'
- en: '[PRE442]'
  id: totrans-818
  prefs: []
  type: TYPE_PRE
  zh: '[PRE442]'
- en: '[PRE443]'
  id: totrans-819
  prefs: []
  type: TYPE_PRE
  zh: '[PRE443]'
- en: '[PRE444]'
  id: totrans-820
  prefs: []
  type: TYPE_PRE
  zh: '[PRE444]'
- en: 'Then, one of the following methods has to be invoked on the newly created `File`
    object:'
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
- en: '`boolean createNewFile()`: If a file with this name does not yet exist, creates
    a new file and returns `true`; otherwise, returns `false`'
  id: totrans-822
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`static File createTempFile(String prefix, String suffix)`: Creates a file
    in the temporary-file directory'
  id: totrans-823
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`static File createTempFile(String prefix, String suffix, File directory)`:
    Creates the directory; the provided prefix and suffix are used to generate the
    directory name'
  id: totrans-824
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If the file you would like to create has to be placed inside a directory that
    does not exist yet, one of the following methods has to be used first, invoked
    on the `File` object that represents the filesystem path to the file:'
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
- en: '`boolean mkdir()`: Creates the directory with the provided name'
  id: totrans-826
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`boolean mkdirs()`: Creates the directory with the provided name, including
    any necessary but nonexistent parent directories'
  id: totrans-827
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Before we look at a code example, we need to explain how the `delete()` method
    works:'
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
- en: '`boolean delete()`: Deletes the file or empty directory, which means you can
    delete the file but not all of the directories, as follows:'
  id: totrans-829
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE445]'
  id: totrans-830
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE445]'
- en: 'Let’s look at how to overcome this limitation in the following example:'
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE446]'
  id: totrans-832
  prefs: []
  type: TYPE_PRE
  zh: '[PRE446]'
- en: '[PRE447]'
  id: totrans-833
  prefs: []
  type: TYPE_PRE
  zh: '[PRE447]'
- en: '[PRE448]'
  id: totrans-834
  prefs: []
  type: TYPE_PRE
  zh: '[PRE448]'
- en: '[PRE449]'
  id: totrans-835
  prefs: []
  type: TYPE_PRE
  zh: '[PRE449]'
- en: '[PRE450]'
  id: totrans-836
  prefs: []
  type: TYPE_PRE
  zh: '[PRE450]'
- en: '[PRE451]'
  id: totrans-837
  prefs: []
  type: TYPE_PRE
  zh: '[PRE451]'
- en: '[PRE452]'
  id: totrans-838
  prefs: []
  type: TYPE_PRE
  zh: '[PRE452]'
- en: '[PRE453]'
  id: totrans-839
  prefs: []
  type: TYPE_PRE
  zh: '[PRE453]'
- en: '[PRE454]'
  id: totrans-840
  prefs: []
  type: TYPE_PRE
  zh: '[PRE454]'
- en: '[PRE455]'
  id: totrans-841
  prefs: []
  type: TYPE_PRE
  zh: '[PRE455]'
- en: '[PRE456]'
  id: totrans-842
  prefs: []
  type: TYPE_PRE
  zh: '[PRE456]'
- en: '[PRE457]'
  id: totrans-843
  prefs: []
  type: TYPE_PRE
  zh: '[PRE457]'
- en: '[PRE458]'
  id: totrans-844
  prefs: []
  type: TYPE_PRE
  zh: '[PRE458]'
- en: '[PRE459]'
  id: totrans-845
  prefs: []
  type: TYPE_PRE
  zh: '[PRE459]'
- en: '[PRE460]'
  id: totrans-846
  prefs: []
  type: TYPE_PRE
  zh: '[PRE460]'
- en: '[PRE461]'
  id: totrans-847
  prefs: []
  type: TYPE_PRE
  zh: '[PRE461]'
- en: '[PRE462]'
  id: totrans-848
  prefs: []
  type: TYPE_PRE
  zh: '[PRE462]'
- en: This example creates and deletes a file and all related directories. Notice
    our usage of the `org.apache.commons.lang3.StringUtils` class, which we discussed
    in the *String utilities* section. It allowed us to remove from the path the just-deleted
    directory and to continue doing it until all the nested directories are deleted,
    and the top-level directory is deleted last.
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
- en: Listing files and directories
  id: totrans-850
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following methods can be used for listing directories and the files in
    them:'
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
- en: '`String[] list()`: Returns the names of the files and directories in the directory'
  id: totrans-852
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`File[] listFiles()`: Returns the `File` objects that represent the files and
    directories in the directory'
  id: totrans-853
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`static File[] listRoots()`: Lists the available filesystem roots'
  id: totrans-854
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In order to demonstrate the preceding methods, let’s assume we have created
    the directories and two files in them, as follows:'
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE463]'
  id: totrans-856
  prefs: []
  type: TYPE_PRE
  zh: '[PRE463]'
- en: '[PRE464]'
  id: totrans-857
  prefs: []
  type: TYPE_PRE
  zh: '[PRE464]'
- en: '[PRE465]'
  id: totrans-858
  prefs: []
  type: TYPE_PRE
  zh: '[PRE465]'
- en: '[PRE466]'
  id: totrans-859
  prefs: []
  type: TYPE_PRE
  zh: '[PRE466]'
- en: '[PRE467]'
  id: totrans-860
  prefs: []
  type: TYPE_PRE
  zh: '[PRE467]'
- en: '[PRE468]'
  id: totrans-861
  prefs: []
  type: TYPE_PRE
  zh: '[PRE468]'
- en: '[PRE469]'
  id: totrans-862
  prefs: []
  type: TYPE_PRE
  zh: '[PRE469]'
- en: '[PRE470]'
  id: totrans-863
  prefs: []
  type: TYPE_PRE
  zh: '[PRE470]'
- en: '[PRE471]'
  id: totrans-864
  prefs: []
  type: TYPE_PRE
  zh: '[PRE471]'
- en: '[PRE472]'
  id: totrans-865
  prefs: []
  type: TYPE_PRE
  zh: '[PRE472]'
- en: 'After that, we should be able to run the following code:'
  id: totrans-866
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE473]'
  id: totrans-867
  prefs: []
  type: TYPE_PRE
  zh: '[PRE473]'
- en: '[PRE474]'
  id: totrans-868
  prefs: []
  type: TYPE_PRE
  zh: '[PRE474]'
- en: '[PRE475]'
  id: totrans-869
  prefs: []
  type: TYPE_PRE
  zh: '[PRE475]'
- en: '[PRE476]'
  id: totrans-870
  prefs: []
  type: TYPE_PRE
  zh: '[PRE476]'
- en: '[PRE477]'
  id: totrans-871
  prefs: []
  type: TYPE_PRE
  zh: '[PRE477]'
- en: '[PRE478]'
  id: totrans-872
  prefs: []
  type: TYPE_PRE
  zh: '[PRE478]'
- en: '[PRE479]'
  id: totrans-873
  prefs: []
  type: TYPE_PRE
  zh: '[PRE479]'
- en: '[PRE480]'
  id: totrans-874
  prefs: []
  type: TYPE_PRE
  zh: '[PRE480]'
- en: '[PRE481]'
  id: totrans-875
  prefs: []
  type: TYPE_PRE
  zh: '[PRE481]'
- en: '[PRE482]'
  id: totrans-876
  prefs: []
  type: TYPE_PRE
  zh: '[PRE482]'
- en: '[PRE483]'
  id: totrans-877
  prefs: []
  type: TYPE_PRE
  zh: '[PRE483]'
- en: '[PRE484]'
  id: totrans-878
  prefs: []
  type: TYPE_PRE
  zh: '[PRE484]'
- en: '[PRE485]'
  id: totrans-879
  prefs: []
  type: TYPE_PRE
  zh: '[PRE485]'
- en: '[PRE486]'
  id: totrans-880
  prefs: []
  type: TYPE_PRE
  zh: '[PRE486]'
- en: '[PRE487]'
  id: totrans-881
  prefs: []
  type: TYPE_PRE
  zh: '[PRE487]'
- en: '[PRE488]'
  id: totrans-882
  prefs: []
  type: TYPE_PRE
  zh: '[PRE488]'
- en: '[PRE489]'
  id: totrans-883
  prefs: []
  type: TYPE_PRE
  zh: '[PRE489]'
- en: '[PRE490]'
  id: totrans-884
  prefs: []
  type: TYPE_PRE
  zh: '[PRE490]'
- en: '[PRE491]'
  id: totrans-885
  prefs: []
  type: TYPE_PRE
  zh: '[PRE491]'
- en: '[PRE492]'
  id: totrans-886
  prefs: []
  type: TYPE_PRE
  zh: '[PRE492]'
- en: 'The result should be as follows:'
  id: totrans-887
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18388_Figure_5.15.jpg)'
  id: totrans-888
  prefs: []
  type: TYPE_IMG
- en: 'The demonstrated methods can be enhanced by adding the following filters to
    them so that they will list only the files and directories that match the filter:'
  id: totrans-889
  prefs: []
  type: TYPE_NORMAL
- en: '`String[] list(FilenameFilter filter)`'
  id: totrans-890
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`File[] listFiles(FileFilter filter)`'
  id: totrans-891
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`File[] listFiles(FilenameFilter filter)`'
  id: totrans-892
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, a discussion of the file filters is outside the scope of this book.
  id: totrans-893
  prefs: []
  type: TYPE_NORMAL
- en: Apache Commons’ FileUtils and IOUtils utilities
  id: totrans-894
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A popular companion of JCL is the Apache Commons project ([https://commons.apache.org](https://commons.apache.org)),
    which provides many libraries that complement the JCL functionality. The classes
    of the `org.apache.commons.io` package are contained in the following root package
    and sub-packages:'
  id: totrans-895
  prefs: []
  type: TYPE_NORMAL
- en: The `org.apache.commons.io` root package contains utility classes with static
    methods for common tasks, such as the popular `FileUtils` and `IOUtils` classes,
    described in the *FileUtils class* and *Class IOUtils class* sections respectively.
  id: totrans-896
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `org.apache.commons.io.input` package contains classes that support input
    based on the `InputStream` and `Reader` implementations, such as `XmlStreamReader`
    or `ReversedLinesFileReader`.
  id: totrans-897
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `org.apache.commons.io.output` package contains classes that support output
    based on the `OutputStream` and `Writer` implementations, such as `XmlStreamWriter`
    or `StringBuilderWriter`.
  id: totrans-898
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `org.apache.commons.io.filefilter` package contains classes that serve as
    file filters, such as `DirectoryFileFilter` or `RegexFileFilter`.
  id: totrans-899
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `org.apache.commons.io.comparator` package contains various implementations
    of `java.util.Comparator` for files such as `NameFileComparator`.
  id: totrans-900
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `org.apache.commons.io.serialization` package provides a framework for controlling
    the deserialization of classes.
  id: totrans-901
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `org.apache.commons.io.monitor` package allows monitoring filesystems, checking
    for a directory, and file creating, updating, or deleting. You can launch the
    `FileAlterationMonitor` object as a thread and create an object of `FileAlterationObserver`
    that performs a check of the changes in the filesystem at a specified interval.
  id: totrans-902
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refer to the Apache Commons project documentation ([https://commons.apache.org/](https://commons.apache.org/))
    for more details.
  id: totrans-903
  prefs: []
  type: TYPE_NORMAL
- en: The FileUtils class
  id: totrans-904
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The popular `org.apache.commons.io.FileUtils` class allows you to do all possible
    operations with files, as follows:'
  id: totrans-905
  prefs: []
  type: TYPE_NORMAL
- en: Writing to a file
  id: totrans-906
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading from a file
  id: totrans-907
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making a directory, including parent directories
  id: totrans-908
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copying files and directories
  id: totrans-909
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deleting files and directories
  id: totrans-910
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting to and from a URL
  id: totrans-911
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Listing files and directories by filter and extension
  id: totrans-912
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comparing file content
  id: totrans-913
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting a file last-changed date
  id: totrans-914
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calculating a checksum
  id: totrans-915
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you plan to manage files and directories programmatically, it is imperative
    that you study the documentation of this class on the Apache Commons project website
    ([https://commons.apache.org/proper/commons-io/javadocs/api-2.7/org/apache/commons/io/FileUtils.html](https://commons.apache.org/proper/commons-io/javadocs/api-2.7/org/apache/commons/io/FileUtils.html)).
  id: totrans-916
  prefs: []
  type: TYPE_NORMAL
- en: The IOUtils class
  id: totrans-917
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`org.apache.commons.io.IOUtils` is another very useful utility class that provides
    the following general I/O stream manipulation methods:'
  id: totrans-918
  prefs: []
  type: TYPE_NORMAL
- en: The `closeQuietly` methods that close a stream, ignoring nulls and exceptions
  id: totrans-919
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `toXxx/read` methods that read data from a stream
  id: totrans-920
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `write` methods that write data to a stream
  id: totrans-921
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `copy` methods that copy all the data from one stream to another
  id: totrans-922
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `contentEquals` methods that compare the content of two streams
  id: totrans-923
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All the methods in this class that read a stream are buffered internally, so
    there is no need to use the `BufferedInputStream` or `BufferedReader` class. The
    `copy` methods all use `copyLarge` methods behind the scenes that substantially
    increase their performance and efficiency.
  id: totrans-924
  prefs: []
  type: TYPE_NORMAL
- en: This class is indispensable for managing the I/O streams. See more details about
    this class and its methods on the Apache Commons project website ([https://commons.apache.org/proper/commons-io/javadocs/api-2.7/org/apache/commons/io/IOUtils.html](https://commons.apache.org/proper/commons-io/javadocs/api-2.7/org/apache/commons/io/IOUtils.html)).
  id: totrans-925
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-926
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have discussed the `String` class methods that allow analyzing,
    comparing, and transforming strings. We have also discussed popular string utilities
    from the JCL and the Apache Commons project. Two big sections of this chapter
    were dedicated to the input/output streams and the supporting classes in the JCL
    and the Apache Commons project. The file-managing classes and their methods were
    also discussed and demonstrated in specific code examples. Now, you should be
    able to write code that processes strings and files, using standard Java API and
    Apache Commons utilities.
  id: totrans-927
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will present the Java Collections framework and its
    three main interfaces, `List`, `Set`, and `Map`, including discussion and demonstration
    of generics. We will also discuss utility classes for managing arrays, objects,
    and `time`/`date` values.
  id: totrans-928
  prefs: []
  type: TYPE_NORMAL
- en: Quiz
  id: totrans-929
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What does the following code print?
  id: totrans-930
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE493]'
  id: totrans-931
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE493]'
- en: '`3`'
  id: totrans-932
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`2`'
  id: totrans-933
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`1`'
  id: totrans-934
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`0`'
  id: totrans-935
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What does the following code print?
  id: totrans-936
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE494]'
  id: totrans-937
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE494]'
- en: '`Error`'
  id: totrans-938
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Exception`'
  id: totrans-939
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`true`'
  id: totrans-940
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`false`'
  id: totrans-941
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What does the following code print?
  id: totrans-942
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE495]'
  id: totrans-943
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE495]'
- en: '`wx`'
  id: totrans-944
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`x6`'
  id: totrans-945
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`%w`'
  id: totrans-946
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Exception`'
  id: totrans-947
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What does the following code print?
  id: totrans-948
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE496]'
  id: totrans-949
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE496]'
- en: '`ab4242`'
  id: totrans-950
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`ab42ab42`'
  id: totrans-951
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`ab422`'
  id: totrans-952
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Error`'
  id: totrans-953
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What does the following code print?
  id: totrans-954
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE497]'
  id: totrans-955
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE497]'
- en: '`false false`'
  id: totrans-956
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`false true`'
  id: totrans-957
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`true true`'
  id: totrans-958
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`true false`'
  id: totrans-959
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select all correct statements:'
  id: totrans-960
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A stream can represent a data source.
  id: totrans-961
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: An input stream can write to a file.
  id: totrans-962
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A stream can represent a data destination.
  id: totrans-963
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: An output stream can display data on a screen.
  id: totrans-964
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select all correct statements about the classes of the `java.io` package:'
  id: totrans-965
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Reader extends `InputStream`.
  id: totrans-966
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Reader extends `OutputStream`.
  id: totrans-967
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Reader extends `java.lang.Object`.
  id: totrans-968
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Reader extends `java.lang.Input`.
  id: totrans-969
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select all correct statements about the classes of the `java.io` package:'
  id: totrans-970
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Writer extends `FilterOutputStream`.
  id: totrans-971
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Writer extends `OutputStream`.
  id: totrans-972
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Writer extends `java.lang.Output`.
  id: totrans-973
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Writer extends `java.lang.Object`.
  id: totrans-974
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select all correct statements about the classes of the `java.io` package:'
  id: totrans-975
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`PrintStream` extends `FilterOutputStream`.'
  id: totrans-976
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`PrintStream` extends `OutputStream`.'
  id: totrans-977
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`PrintStream` extends `java.lang.Object`.'
  id: totrans-978
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`PrintStream` extends `java.lang.Output`.'
  id: totrans-979
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What does the following code do?
  id: totrans-980
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE498]'
  id: totrans-981
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE498]'
- en: Creates two directories and a file in the `demo2` directory
  id: totrans-982
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Creates one directory and a file in it
  id: totrans-983
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Does not create any directory
  id: totrans-984
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Exception
  id: totrans-985
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
