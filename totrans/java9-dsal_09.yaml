- en: Chapter 9. Advanced General Purpose Data Structures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will take a look at some more interesting data structures
    that are commonly used. We will start with the concept of a priority queue. We
    will see some efficient implementations of a priority queue. In short, we will
    cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Priority queue ADT
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Heap
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Binomial forest
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sorting using a priority queue and heap
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Priority queue ADT
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A priority queue is like a queue in that you can enqueue and dequeue elements.
    However, the element that gets dequeued is the one with the minimum value of a
    feature, called its priority. We will use a comparator to compare elements and
    learn which one has the lowest priority. We will use the following interface for
    the priority queue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We require the following set of behaviors from the methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`checkMinimum`: This method must return the next value to be dequeued without
    dequeuing it. If the queue is empty, it must return null.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dequeueMinimum`: This must dequeue the element with the minimum priority and
    return it. It should return null when the queue is empty.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`enqueue`: This should insert a new element in the priority queue.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We would also like to do these operations as efficiently as possible. We will
    see two different ways to implement it.
  prefs: []
  type: TYPE_NORMAL
- en: Heap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A heap is a balanced binary tree that follows just two constraints:'
  prefs: []
  type: TYPE_NORMAL
- en: The value in any node is less than the value in either of the children. This
    property is also called the heap property.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The tree is as balanced as possible—in the sense that any level is completely
    filled before a single node is inserted in the next level.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following figure shows a sample heap:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Heap](img/00062.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1\. A sample heap
  prefs: []
  type: TYPE_NORMAL
- en: It would not be really clear until we actually discuss how to insert elements
    and remove the least element. So let's jump into it.
  prefs: []
  type: TYPE_NORMAL
- en: Insertion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first step of insertion is to insert the element in the next available position.
    The next available position is either another position in the same level or the
    first position in the next level; of course, this applies when there is no vacant
    position in the existing level.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second step is to iteratively compare the element with its parent and keep
    switching until the element is bigger than the parent, thus restoring the constraints.
    The following figure shows the steps of an insertion:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Insertion](img/00063.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2\. Heap insertion
  prefs: []
  type: TYPE_NORMAL
- en: The gray box represents the current node, and the yellow box represents the
    parent node, whose value is larger than the current node. First, the new element
    is inserted in the next available spot. It must be swapped until the constraint
    is satisfied. The parent is **6**, which is bigger than **2**, so it is swapped.
    If the parent is **3**, which is also larger than **2**, it is swapped. If the
    parent is **1**, which is less than **2**, we stop and the insertion is complete.
  prefs: []
  type: TYPE_NORMAL
- en: Removal of minimum elements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The constraint that the parent is always less than or equal to the children
    guarantees that the root is the element with the least value. This means the removal
    of the least element leads only to the removal of the top element. However, the
    empty space of the root must be filled, and elements can only be deleted from
    the last level to maintain the constraint **2**. To ensure this, the last element
    is first copied to the root and then removed. We must now iteratively move the
    new root element downward until the constraint **1** is satisfied. The following
    figure shows an example of a delete operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Removal of minimum elements](img/00064.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Heap deletion
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one question though, since any parent can have two children: which
    one should we compare and swap with? The answer is simple. We need the parent
    to be less than both the children; this means we must compare and swap with the
    minimum value of the children.'
  prefs: []
  type: TYPE_NORMAL
- en: Analysis of complexity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, let''s check out the height of a heap for a given number of nodes. The
    first layer contains just the root. The second layer contains a maximum of two
    nodes. The third layer contains four. Indeed, if any layer contains m elements,
    the next layer will contain, at the maximum, the children of all these *m* elements.
    Since each node can have two children, the maximum number of elements in the next
    layer will be *2m*. This shows that the number of elements in layer l is *2* ^(l-1).
    So, a full heap of height *h* will have total *1+2+4+...+ 2* ^(h-1) *= 2* ^h*-1*
    nodes. Therefore, a heap of height *h* can have maximum *2* *h+1* *-1* nodes.
    What is the minimum number of nodes in a heap of height *h*. Well, since only
    the last level can have unfilled positions, the heap must be full, except the
    last layer. The last layer can have one node minimum. So, the minimum number of
    nodes in a heap of height *h* is *(2* ^(h-1) *-1) + 1 = 2* ^(h-1). Hence, if the
    number of nodes is *n*, then we have this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We also have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Combining the preceding two expressions, we get this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's assume that adding a new element to the end of the heap is a constant
    time operation or *θ(lg n)*. We will see that this operation can be made this
    efficient. Now we deal with the complexity of a trickle up operation. Since in
    each compare-and-swap operation, we only compare with the parent and never backtrack,
    the maximum number of swaps that can happen in a trickle up operation equals the
    height of the heap *h*. Hence, the insertion is *O(lg n)*. This means that the
    insert operation itself is *O(lg n)*.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, for the trickle down operation, we can only do as many swaps as the
    height of the heap. So trickling down is also *O(lg n)*. Now if we assume that
    removing the root node and copying the last element to the root is at the maximum
    *O(lg n)*, we can conclude that the delete operation is also *O(lg n)*.
  prefs: []
  type: TYPE_NORMAL
- en: Serialized representation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A heap can be represented as a list of numbers without any blanks in the middle.
    The trick is to list the elements in order after each level. Positions from 1
    through *n* for an *n* element heap adopt the following conventions:'
  prefs: []
  type: TYPE_NORMAL
- en: For any element at index *j*, the parent is at index *j/2*, where '*/*' represents
    an integer division. This means divide *j* by two and ignore the remainder if
    any.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For any element at index *j*, the children are *j*2* and *j*2+1*. One can verify
    that this is the same as the first formula written the other way round.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The representation of our example tree is shown in the following figure. We
    have just flattened the process of writing a tree one entire level before another.
    We retained the tree edges, and one can see that the parent-child relationships
    work as described previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Serialized representation](img/00065.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Array representation of a heap
  prefs: []
  type: TYPE_NORMAL
- en: With the knowledge of the array-based storage function of a heap, we can proceed
    to implement our heap.
  prefs: []
  type: TYPE_NORMAL
- en: Array-backed heap
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An array-backed heap is a fixed-sized heap implementation. We start with a
    partial implementation class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Given any index of the array (starting from `0`), find the index of the parent
    element. It involves converting the index to `1` based form (so add `1`), dividing
    by `2`, and then converting it back to `0` (so subtract `1`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Find the index of the left child using this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Swap the elements in the two indexes provided using this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'To implement the insertion, first implement a method that would trickle the
    value up until constraint `1` is satisfied. We compare the current node with the
    parent, and if the value of the parent is larger, then do a swap. We keep moving
    upwards recursively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can implement the insertion. The new element is always added to the
    end of the current list. A check is done to ensure that when the heap is full,
    an appropriate exception is thrown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, for deletion, we first implement a trickle down method that compares
    an element with its children and makes appropriate swaps until constraint 1 is
    restored. If the right child exists, the left child must also exist. This happens
    because of the balanced nature of a heap. In this case, we must compare only with
    a minimum of two children and swap them if it is necessary. When the left child
    exists but the right child does not, we only need to compare it with one element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'With the `trickleDown` method available, removing the minimum element is simple.
    We first save the current root as the minimum element, then copy the last element
    to the root position. We then call the `trickleDown` method to restore constraint
    1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we only have to use it as an implementation of the priority queue. So we
    implement the relevant methods using our `insert` and `removemin`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This completes our array-based heap implementation. It has the same problem
    as our array-based queue implementation, that is, we need to know its maximum
    size beforehand. Next, we will have an implementation of a heap that has an implementation
    in the form of a linked binary tree.
  prefs: []
  type: TYPE_NORMAL
- en: Linked heap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A linked heap is an actual binary tree where every node holds references to
    its children. We first create a skeleton structure for our heap:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'To keep track of the next position, each position is given a number, just like
    we did in our array-based representation. We have the same calculation for the
    index of the parent and children. But, in this case, looking up the value at a
    particular index requires a traversal from the root to that node. We create a
    method to do this. Note that since we are not using an array, the position starts
    from 1\. We start by finding the parent node recursively. The parent node is of
    course the node at the position that is half the value of the children. The remainder,
    when divided by 2, is the bit that tells us whether the node is to the left or
    right of the parent. We return the node accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we turn to swapping. In the case of an array-based heap, we could swap
    the values between any two indexes. However, this general implementation would
    require multiple traversals in this case. We only need to swap the values between
    a node and its parent. The `swapWithParent` takes the parent node as an argument.
    Another argument is to know whether the current node is the left or right child
    of the parent and switch references appropriately:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Insertion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Insertion involves inserting a new element at the end first and then trickling
    it in the upward direction. First, we create a trickle up method, similar to the
    one in the `ArrayHeap` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we implement the insert method. If the tree is empty, we just have to
    add a root. Otherwise, the position of the new element is *(numElements+1)*. In
    this case, it''s parent must be *((numElements+1)/2)*. Whether it should be the
    left or right child of its parent is determined by the value of *( (numElements+1)%2)*.
    A new node is then created and added to the parent as a child. Finally, `numElements`
    is incremented to keep track of the number of elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Removal of the minimal elements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Similar to the array-based heap, we need to implement a trickle down method.
    Since the left child must exist if the right child does, if the left child is
    null, the node does not have any child. But, if the right child is null and the
    left child is not, we only need to compare the current node''s value with that
    of the left child. Otherwise, compare and swap with the child that has the minimum
    value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can implement the method to remove the minimum element. If the root
    is null, it means the queue is empty. If the last element is the root, there is
    only one element and we just remove and return it. Otherwise, we copy the value
    of the root to a temporary variable, then copy the value of the last element to
    the root, and finally, trickle down the root:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we implement the methods required to make it a valid priority queue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This completes our priority queue implementation using heaps. We will now introduce
    a different way of implementing a priority queue. It is called a binomial forest,
    which comprises our next section.
  prefs: []
  type: TYPE_NORMAL
- en: Complexity of operations in ArrayHeap and LinkedHeap
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have already seen that if we can append an element to the end of a heap in
    at most *O(lg n)*, where n is the number of elements already in the heap, we can
    perform both insertion and removal of the minimum element *θ(lg n)* times. In
    the case of `ArrayHeap`, insertion of a new element implies just setting the value
    of an element in an array at a known index. This is a constant time operation.
    So, in `ArrayHeap`, both the insertion and removal of minimum element are *θ(lg
    n)*. Checking the minimum element is just the check the value at index zero of
    the array and hence is constant time.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of `LinkedHeap`, insertion of a new element at the end involves
    traversing the tree to the end position. Since the height of the tree is *θ(lg
    n)*, this operation is also *θ(lg n)*. This means, the insertion and deletion
    operation in `LinkedHeap` is also *θ(lg n)*. Checking the minimum element means
    just checking the value at the root, and this operation is constant time.
  prefs: []
  type: TYPE_NORMAL
- en: Binomial forest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A binomial forest is a very interesting data structure. But, to discuss it,
    we need to first start with a binomial tree. A binomial tree is a tree in which
    a combination of two smaller binomial trees of the same size are combined in a
    particular way:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Binomial forest](img/00066.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Binomial tree
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding figure shows how binomial trees combine to create larger binomial
    trees. In the first row, two binomial trees of height 1 combine to create a new
    binomial tree of height 2\. In the second row, two binomial trees of height 2
    combine to create a new binomial tree of height 3\. In the final example, two
    binomial trees of height 3 combine to create a binomial tree of height 4, and
    it continues. The two trees that are combined together are not treated symmetrically.
    Instead, the root of one becomes the parent of the other. The next figure shows
    one more step in the sequence and then shows a different way to look at a binomial
    tree. In the last row, I have highlighted the subtrees differently. Notice how:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Binomial forest](img/00067.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6\. The other way of thinking about a binomial tree
  prefs: []
  type: TYPE_NORMAL
- en: Each subtree is a binomial tree. Not only that, the first subtree is a binomial
    tree of height 1, the second one of height 2, third one of height 3, and so on.
    So, another way of thinking about a binomial tree is that it is a root and a sequence
    of subtrees that are binomial trees of consecutive heights up to one less than
    the height of the entire tree. Both these views are required in our discussion.
    The first view is needed when analyzing the idea and the second when implementing
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Why call it a binomial tree?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Remember the choose function we discussed in [Chapter 4](part0028_split_000.html#QMFO2-eeeded97b5e248ac807bb1bec4d7c800
    "Chapter 4. Detour – Functional Programming"), *Detour - Functional Programming*?
    There, I pointed out that it is also called the binomial coefficient. Let''s see
    how it is related to a binomial tree. Suppose we have a binomial tree of height
    h and we want to find out the number of nodes at level l. Let''s assume that for
    a tree of height h, the number of nodes is *f(t,r)*, where *t=h-1* and *r = l-1*.
    The reason for taking a variable that is one less than the height and level will
    become clearer a little later. Basically, *t* is the height of the tree that starts
    from *0* instead of *1*, and *r* is the level that starts from zero. Now this
    tree is obviously a tree of only one element or it is made up of two trees of
    height *h-1 = t*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Why call it a binomial tree?](img/00068.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7\. The rationale for naming it a binomial tree
  prefs: []
  type: TYPE_NORMAL
- en: 'We will call these two subtrees this: red subtree and green subtree. This is
    because they are colored this way in the preceding figure. The levels are highlighted
    using dashed lines. It is clear from the picture that the nodes at the level *r*
    in the complete tree is either at level *r* in the red tree or at level *r-1*
    in the green tree. Both the red and green trees are trees of height *h-1*. This
    means the following: *f(t,r) = f(t-1,r) + f(t-1,r-1)*. This equation is the same
    as what we have for the choose function we have already discussed. The only thing
    we have to check is the boundary conditions. The top level (that is *t=0*) always
    has only one node, so *f(t,0) = 1*. We also know that the number of levels in
    the tree has to be less than or equal to the height of the tree, so we have *f(t,r)
    = 0* if *t <r*. So, *f(t,t) = f(t-1,t) + f(t-1,t-1) = 0 + f(t-1,t-1) = f(t-1,t-1)*
    for any *t*. In the same way, *f(t-1,t-1) = f(t-2,t-2) = f(t-3,t-3) = … = f(0,0)
    = 1* (because *f(t,0) = 1*). Therefore, all the conditions of the `choose` function
    are satisfied; hence we can see *f(t,r) = choose(t,r) = choose(h-1, l-1)*. Since
    the *choose* function is also called the binomial coefficient, this gives the
    binomial tree its name.'
  prefs: []
  type: TYPE_NORMAL
- en: Number of nodes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'What is the number of nodes n in a binomial tree of height *h*? When *h=1,*
    we only have one node. A tree of height 2 is made up of two trees of height 1,
    a tree of height 3 is made up of two trees of height 2, and so on. So, for the
    increment of 1 in height, the number of nodes must be twice as much as the original
    number. That is, when *h=1, n=1; h=2, n=2; h=3, n=4,...* In general, this should
    be the case: *n = 2* ^(h-1)*= 2* ^t. Here *t* is the height starting from zero.'
  prefs: []
  type: TYPE_NORMAL
- en: Notice also that we can say that the number of nodes *n* in a tree is the sum
    of the number of nodes in each level, which is *choose(t, r)*, where *r* is the
    level starting from *0* to *t*. The two formulas must be equal, so the sum *choose(t,
    0) + choose(t, 1) + choose(t, 2) + … + choose(t, t)* equals *2* ^t. This is a
    proof of this relationship. There are other proofs as well, but this is a valid
    proof too.
  prefs: []
  type: TYPE_NORMAL
- en: The heap property
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Of course, with only this structure, we have no way of making sure of having
    some easy way of figuring out the minimum element. So, we also enforce the heap
    property on a binomial tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The heap property](img/00069.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8\. Preserving heap property while merging.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the property: the value of any node is smaller than the value of each
    of its children. When merging two trees to make one, the only thing we need to
    do to preserve the heap property is to use the heap with the lesser value at its
    top node as the top subtree and the one with the higher value at its top node
    as the subordinate subtree. This is shown in the preceding figure. The red tree
    happens to have a higher value in the root node than that of the green tree. Hence,
    the red tree must be the subordinate tree. The heap property ensures that the
    root of any binomial tree holds the minimum element.'
  prefs: []
  type: TYPE_NORMAL
- en: Binomial forest
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So how do we make a queue out of this? Firstly, note that any tree will have
    nodes with at least the power of 2\. But, in a queue, we want an arbitrary number
    of elements. So we store these elements in more than one tree. Any number can
    be expressed as the sum of the power of 2 because any number can be expressed
    in binary form. Suppose we need to store 20 nodes. The number 20 in binary is
    10100\. So we need two binomial trees: one with height 5 and 16 nodes and one
    with height 3 and four nodes. A queue is built using a collection of binomial
    trees to store the nodes. Hence it is called a binomial forest.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we discuss how to insert new elements and remove the minimum element,
    we need to understand how to merge two binomial forests. We have already seen
    that the numbers of elements are represented according to binary form. Just write
    the number in binary form, and if 1 exists, it means there is a tree of height
    that is equal to one plus its position from right to left. When we merge two forests,
    the number of elements of the merged forest is the sum of the number of elements
    in the forests that need to be merged. This means the result will have trees of
    sizes where the binary representation of the sum will have the number 1\. We can
    find this binary representation by performing a binary addition of the binary
    representations of the node''s source number. For example, let''s merge two forests:
    one with 12 elements and one with 10 elements. Their binary representations will
    be 1100 and 1010, respectively. If we do a binary addition, we have 1100 + 1010
    = 10110\. This means the original trees had trees of heights 3, 5 and 4, 5 and
    the result must have trees of heights 3, 4, and 6\. The merge happens the same
    way we do a binary addition. The trees are stored in sequence, and we have empty
    places that represent zeros in the binary representation. While merging, each
    tree represents a bit and it has the number of nodes that the bit represents.
    We take the corresponding bit from each forest and also consider a carry. All
    these trees must either be empty or have exactly the same number of nodes. Then,
    we merge them to create the resulting bits.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To do any binary addition, we have input of three bits for each bit: one from
    each of the input and a carry. We need to compute both the output bit and the
    next carry. Similarly, while merging two trees, we need to compute the output
    tree and the carry tree from the given input trees (two) and a carry tree. Once
    the merging is done, inserting and removing `min` is simple.'
  prefs: []
  type: TYPE_NORMAL
- en: The `insert` simply merges a forest with a single tree using a single node.
    Removing the minimum element is a little more complicated operation. The first
    step is to find out the minimum. We know every tree has the minimum element at
    its root. So we need to walk through all the trees while comparing the root elements
    to find the minimum element and the tree that has it. Removing it is simply taking
    the root off, leaving a list of subtrees that make a forest of consecutive heights
    of trees. Therefore, we can merge the subtrees in the main forest to complete
    the removal process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see the implementation. First, we create a skeleton class. A binomial
    tree has a root, which contains a value and a list of subtrees. The list of subtrees
    is like a dense forest. The list of trees in the forest is stored in a linked
    list. We use `DoublyLinkedList` because we need to remove the last element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'As discussed earlier, we will start with the merge operation now. First we
    need to merge two trees, which we will use to merge two forests. Merging two trees
    is a simple constant time operation. Merging with a null tree does not change
    the tree. The two trees being merged should be of the same size. We need to simply
    compare the root elements. The tree with the smaller value in its root will get
    the other as a child:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we want to check the minimum element in constant time, just like in a
    heap, we will store the minimum element in a state variable. We will also store
    its position in the `allTrees` list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We will define a method to find out and update the variables. Since the smallest
    element in any tree is the root, we only have to go through the root to find the
    minimum element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'To implement the merging of two forests, we need to first implement how to
    compute the output and carry the tree out of the two input trees and a carry tree.
    These methods are fairly simple. We need to understand that both the input and
    the carry must be of the same size if they are not null. The height of the output
    must be the same as the height of the output, and the height of the carry must
    be one more than the height of the input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to enhance the `ListIterator` class in our imperative `LinkedList`
    implementation so that we can modify the value of any node while iterating through
    it. We use the following implementation to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'With these methods available, we can implement the merging of two forests or
    two lists of trees:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Insert` method is very simple to implement with the merge available. Just
    merge a list containing one tree with the value 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Removal of the minimum element is a little more complex. It involves removing
    the tree with the minimum value and then considering its root as the minimum element.
    Once this is done, the subtrees need to be merged with the original forest. If
    the last tree is being removed, we must actually remove it from the list. This
    is the same as not writing a leading zero in binary representation. Otherwise,
    we only set the value to `null` so that we know it is a zero bit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can implement the methods required to use it as a priority queue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: This completes our implementation of a binomial queue.
  prefs: []
  type: TYPE_NORMAL
- en: Complexity of operations in a binomial forest
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We already know that the number of nodes in a binomial tree of height *h* is
    *2h-1*. The question is, if we want to store n elements, what should be the maximum
    height of the trees in the forest? We have seen that the trees we need are as
    per the binary expression of the integer *n*. The most significant bit of the
    binary representation of *n* is the floor of (*lg n*), that is the greatest integer
    less than or equal to *lg n*. We will write this as *lg n*. The height of the
    tree representing this bit is *1 + lg n*. The length of the list holding the trees
    in the forest is also *1 + lg n= θ(lg n)*. Both in the case of an insertion and
    removal of a new element, a merge operation is involved. The merge operation is
    constant time for each pair of input trees and one carry. So, the number of operations
    for a merge operation of two forests is this: *constant times the number of trees
    in the largest forest = θ(lg n)*, where *n* is the number of trees in the largest
    forest.'
  prefs: []
  type: TYPE_NORMAL
- en: At the time of insertion, we just merge a new forest of only one tree and one
    element. So this operation is *θ(lg n)*, where n is the number of elements in
    the original forest.
  prefs: []
  type: TYPE_NORMAL
- en: The removal process involves two steps. The first is to remove the minimum element.
    This involves a constant time operation, which is used to remove the tree with
    the minimum element, and a merge operation, which is *θ(lg n)*, as seen already.
    The second step/operation is to update the tree with the minimum element. This
    involves scanning the roots of all the trees; therefore, it is *θ(lg n)*, just
    like the merge operation. So, as a whole, the removal process is also *θ(lg n)*.
  prefs: []
  type: TYPE_NORMAL
- en: Checking the minimum element is of course constant time, as we have it referenced
    already.
  prefs: []
  type: TYPE_NORMAL
- en: Sorting using a priority queue
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since a priority queue always returns the minimum element, if we insert all
    input elements and then keep dequeuing them, they would be dequeued in sorted
    order. This can be used to sort a list of elements. In our example, we will add
    a new method called the `LinkedList` implementation. This implementation sorts
    the elements using `PriorityQueue`. First insert all the elements into the priority
    queue. Then, dequeue the elements and append them back to the linked list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Both enqueue and dequeue have *θ(lg n)* complexity, and we have to enqueue
    and dequeue each of the elements. We have already seen this: *lg 1 + lg 2 + …
    + lg n = θ(n lg n)*. So, the enqueueing and dequeueing of the elements is *θ(n
    lg n)*, which means the sort is *θ(n lg n)*, which is asymptotically optimal.'
  prefs: []
  type: TYPE_NORMAL
- en: In-place heap sort
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can use an array-based heap implementation to do an in-place sort of the
    elements of an array. The trick is to use the same array for backing the heap.
    In the beginning, we simply insert the elements in the heap from the beginning
    of the array. We achieve this by replacing the array in the heap, except the one
    that is passed. Since the heap also uses the space from the beginning, it does
    not overwrite the elements we are still to insert. While dequeuing the elements,
    we start saving them from the end of the array, as this is the part that is being
    freed up by the heap. This means we want the largest element to be dequeued first.
    This is achieved by simply using a comparator that is the opposite of the one
    that is passed. We add this static method to our `ArrayHeap` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This is actually a sort using a priority queue as shown before, except that
    here we are sharing the array with the priority queue. Hence, this sort is also
    *θ(n lg n)*, just as before.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed priority queues and their implementation. Priority
    queues are important data structures that are used in a lot of problems. We saw
    two implementations of a priority queue, a heap, and a binomial forest. We also
    saw how to use priority queues for sorting, which is asymptotically optimal. A
    variation of this allowed us to sort an array in place using an array-based heap.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will discuss the concept of graphs, which are very useful,
    almost ubiquitous ADTs, and data structures that are used in many real-life applications.
  prefs: []
  type: TYPE_NORMAL
