- en: Using Build Tools and Testing Java Modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we looked at several strategies and approaches to migrate
    an existing Java code base to Java 9\. In this chapter, we'll wrap up our journey
    of Java 9 modularity by looking at two important topics that you are very likely
    to encounter, irrespective of whether you are migrating a legacy code base or
    creating a new modular application from scratch. They are build tool integration
    and unit testing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s what we''ll cover in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Integrating Java 9 modules with the Maven build process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with a multi-module Java 9 Maven project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing unit test cases for Java 9 modules using JUnit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling new access issues and challenges with testing in Java 9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Considering that build systems and unit testing are extremely common and important
    parts of a modern Java developer's workflow, it may seem odd that we are tackling
    both these topics in the final chapter of this book. This is for a good reason.
    Understanding and working with these concepts requires an understanding of a lot
    of the topics we've covered in the last few chapters. Now that you have explored
    concepts such as open modules in [Chapter 9](part0134.html#3VPBC0-ed2405f4162b4f86b565edd6b6d679fb),
    *Module Design Patterns and Strategies*, and automatic modules in [Chapter 11](part0172.html#5410O0-ed2405f4162b4f86b565edd6b6d679fb),
    *Migrating Your Code to Java 9*, you are all set to tackle this chapter with ease!
  prefs: []
  type: TYPE_NORMAL
- en: Integrating with Apache Maven
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Two of the build systems that are very commonly used in the Java landscape are
    Apache Maven and Gradle. When you are working on an enterprise Java application,
    it's very likely that you'll have to deal with one of these two options. In this
    book so far, we've been working with the command line to get the compiler and
    runtime to execute. However, that's rarely a reasonable thing to do in a complex
    project. So, what does it take to use such a build system in a Java 9 modular
    application?
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing this, Maven has a workable integration with Java 9, while
    Gradle is still in active development. Thus, we'll only be covering Apache Maven
    integration in this book. It's only a matter of time before the Java tooling ecosystem
    catches up to the modularity changes in Java 9, so it shouldn't be surprising
    to see better integration and an overall experience of using these tools with
    Java 9 over time.
  prefs: []
  type: TYPE_NORMAL
- en: Let's examine the way you can create a Maven project that contains and builds
    a Java 9 modular application.
  prefs: []
  type: TYPE_NORMAL
- en: A Maven refresher
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter assumes you are familiar with at least the basic concepts of Maven,
    but here is a quick refresher. Maven is, among other things, a project build tool.
    It is based on convention and provides a formal structure to organize your code,
    name your artifacts, and establish dependencies on other projects. This may sound
    very similar to what we've been doing with Java 9 modularity, but it isn't. Unlike
    the Java platform module system, Maven is concerned with building (or assembling)
    your artifacts, and not verifying compile time or runtime accuracy.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you create a Maven artifact, you assign *coordinates* to it: the group
    name, the artifact name, and the version. You specify this in a file called `pom.xml`.
    This file also lets you specify dependencies on other Maven artifacts so that
    when the build process runs, Maven can fetch the necessary dependencies and make
    them available to the Java compiler or runtime.'
  prefs: []
  type: TYPE_NORMAL
- en: Using Maven with Java 9 modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you bring Java 9 modules into the picture, you can see that there are
    two parallel concepts of modules here: the Maven concept of an artifact with the
    definition in `pom.xml` and the Java platform concept of a module with the module
    definition in `module-info.java`. However, these two work surprisingly well when
    you collapse the two and have each Maven project containing one Java 9 module.'
  prefs: []
  type: TYPE_NORMAL
- en: Consider the following folder structure of a single Maven project. The code
    is in the `lib` folder. It is a typical Maven project. It has a `pom.xml` descriptor
    that contains the Maven coordinates for this artifact. However, it also has the
    module-info.java in the `src/main/java` folder that sets it up as a Java 9 module!
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00106.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'With this approach, the idea is to create a Maven artifact for each Java 9
    module. This means that you''ll need to come up with two separate names:'
  prefs: []
  type: TYPE_NORMAL
- en: The coordinates for the Maven artifact--comprising of group name and artifact
    name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The name of the Java 9 module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, when it comes to establishing dependencies between two of these modules,
    you will need to specify dependencies in two places. Let''s say, for example,
    that you have two Maven Java 9 projects called **A** and **B**. In order to specify
    that A is dependent on B, you need to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a `<dependency>` tag in the Maven `pom.xml` file of A specifying the Maven
    coordinates of B
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add a  `requires` declaration in the `module-info.java` file of A specifying
    the module name of B
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The advantage of this approach is that Maven takes care of fetching the necessary
    artifacts and placing them in the module path. Then, the Java platform module
    system has everything it needs when the compiler or runtime executes! Note that
    this doesn't work if you miss either one of these two dependency configurations.
    If you forget to specify the Maven dependency, Maven will not fetch the artifact
    and place it in the module path. If you forget to add the requires declaration
    in `module-info.java`, your code cannot access the types in the dependency, even
    though Maven has made it available in the module path.
  prefs: []
  type: TYPE_NORMAL
- en: While this works great for one or two modules, this can also get tricky to manage
    when you are dealing with an application consisting of multiple modules. In such
    situations, we can leverage the multi-module project feature of Maven to better
    organize multiple Maven + Java 9 modules.
  prefs: []
  type: TYPE_NORMAL
- en: Working on a multi-module Java 9 Maven project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s look at a sample Maven multi-module project. Let''s say we want to build
    two Java modules: `packt.main` and `packt.lib`. The `packt.lib` module contains
    a library class `Lib` with a method called `sampleMethod`, and the `packt.main`
    module contains a class `App` with a main method calling `sampleMethod` from `Lib`.
    Thus, `packt.main` has to read `packt.lib`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00107.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'You''ve already learned that you should have one Maven project corresponding
    to each Java module. However, in order to ease the development, and to leverage
    the concept of a multi-module project in Maven, we can instead create a parent
    root Maven artifact. Now, both the modules of our application can be Maven child
    projects, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00108.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The code is available in the `12-build-tools-and-testing/01-maven-integration`
    folder. There is a root Maven module at the root directory. This module acts as
    a parent module. This is just a Maven container to facilitate the build process.
    We don't really need a corresponding Java module for this. Within the root folder
    are two child Maven projects `main` and `lib`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, its `pom.xml` at the root (truncated for brevity):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The packaging node in the XML specifies the pom value, indicating that this
    is a parent pom. It has two module declarations indicating the two Maven child
    modules that it is a parent to. Don't be confused by the use of the term modules
    here. We are talking about Maven modules, not Java 9 modules.
  prefs: []
  type: TYPE_NORMAL
- en: Within each child module, main and lib, it's just like we've seen so far. They
    are standard Maven projects, but with the `module-info.java` file in the `src/main/java`
    location making them Java 9 modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the complete folders structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00109.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Since the main project is using a type from the lib project, both the Maven
    and Java dependencies are configured.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the main project''s `pom.xml` file specifying the dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'And here''s its `module-info.java` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Building the multi-module project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we build, make sure you have the latest version of Maven installed in
    your path. Running the following command should give you the Maven version that''s
    installed on your machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: If you don't see this output, you'll need to download Apache Maven from [https://maven.apache.org](https://maven.apache.org/plugins/maven-compiler-plugin/)
    and add the `bin` folder on the download to your operating system's `PATH` variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try to build this project. There are inclusions in the root project''s
    `pom.xml` to make this ready to be built on Java 9\. Following is the Maven compiler
    plugin used to set the Java version to 9:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'With this, you should be able to run Maven''s build command and have the Java
    9 compiler compile our classes. Switch to the `12-build-tools-and-testing/01-maven-integration/root`
    directory and run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The output below, truncated for readability, indicates that all the modules
    have been compiled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Executing the multi-module project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to execute the class with the  `main` method as a Maven lifecycle,
    we use the `exec-maven-plugin`. This is also possible thanks to the configuration
    in the root project''s `pom.xml` file. Here''s the listing that specifies this
    configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As is typical with Maven configuration, this looks verbose. However, what's
    interesting for us is the configuration section. We are configuring the `java`
    command, so you have the executable path here mapped from `$JAVA_HOME`. We are
    also passing in the two arguments we should be very familiar with now--the `--module-path` argument
    indicating where the compiled modules are, and the `--module` indicating what's
    the module and class containing the main method.
  prefs: []
  type: TYPE_NORMAL
- en: Note that for the `--module-path` argument, we aren't specifying the path manually.
    This is because Maven is compiling the modules for us, so we want Maven itself
    to supply us with the path where it has placed the compiled classes. That is done
    using the special `<modulepath />` tag. We'll discuss the module path in Maven
    in a bit more detail in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch to the `12-build-tools-and-testing/01-maven-integration/root/main` directory
    and run the following command to call the `exec` plugin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the truncated output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `Library method called!` line is the output of the  `main` method calling
    the library method and printing the message to the console.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the exec plugin's module path
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While there are several advantages to using Maven this way, one significant
    advantage is how easy it becomes to manage the directories during the compile
    and build step. When we ran `javac` manually, we always had to manually specify
    the *output* directory where all the compiled classes would go. When we ran `java`,
    we had to make sure the module path contained the output location of classes,
    as well as any dependent modules and libraries. Maven takes that work away from
    us. Thanks to the `<modulepath/>` line that we added as the module path argument
    to `exec-maven-plugin`, Maven automatically constructs the module path for us.
    Here''s what Maven adds to the module path:'
  prefs: []
  type: TYPE_NORMAL
- en: It automatically includes the build location of the project. We ran the plugin
    on the `main` project. Maven makes sure the compiled classes from `main` are available
    in the module path.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It automatically makes sure the dependencies are in the module path as well.
    In the `main` project's `pom.xml`, we specified a dependency on `lib` . Maven
    acknowledges the dependency and automatically includes the complied `lib` module
    into the module path!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It automatically includes dependencies that aren't Java 9 modules too! Let's
    say your `pom.xml` file specifies a dependency on a third-party library that isn't
    migrated to Java 9 yet. Maven automatically adds those jars to the module path
    as well. Guess what happens when you add a pre-Java 9 JAR into the module path?
    They become automatic modules! Your modules can use the `requires` syntax to depend
    on them, just like any Java 9 module. Thus, your workflow becomes extremely simple
    and consistent when dealing with dependencies, be it Java 9 or older.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit testing modules with Java 9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The readability and accessibility constraints pose new and interesting problems
    when it comes to testing in Java 9\. Let''s look back at the way we''ve always
    been unit testing code in Java. Here are two common practices:'
  prefs: []
  type: TYPE_NORMAL
- en: The unit test code typically resides in a separate source folder that is added
    to the classpath. This is to separate the test code from the actual application
    code and to also make it easy to exclude the test folder when building an application
    for deployment.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The unit test classes typically share the same package as the class under test.
    This is to make sure the test classes can access the package-private members of
    the classes under test, even though they are in a completely different location.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These two design decisions work well when classes are in the classpath, because
    we know that the physical location of the classes in the classpath doesn''t matter.
    However, all that is changing with Java 9! Here''s how:'
  prefs: []
  type: TYPE_NORMAL
- en: In Java 9, the test code could face access restrictions due to strong encapsulation.
    Your Java 9 classes under test are in a module. So, the only way to access all
    the types in your module from your test classes is to put your test classes in
    the same module as well! This is not ideal because, when you build and ship a
    Java module, the entire contents go with it. The only other option is to keep
    your test classes outside the module and only test the classes that are *exported*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you keep your tests in a separate folder and in a separate module, you cannot
    have your test classes share the same package as the classes under test. This
    will cause the split package problem since the same package exists in both the
    application module and the test module. Thus, you cannot access and test package-private
    members
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Considering these challenges, one way to work around them is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a separate test module for every module you need to test.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write test cases that test the exported module interface.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you need to write tests for any internal types that aren't exported by the
    module, use `--add-exports` overrides during test execution. Yes, `--add-exports`
    isn't a good idea for application code, but it's a reasonable workaround for testing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing a Java 9 module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's examine how this works by testing the `packt.sortutil` from the sample
    address book viewer application. The code is available at the `12-build-tools-and-testing/02-testing`
    location. The `src` folder contains the `packt.sortutil` module--the module under
    test.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test this, we can create a new test module: `packt.sortutil.test`. A good
    convention to follow is to name the test modules with the name of the module being
    tested followed by `.test`. Here''s the module definition for `packt.sortutil.test`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'By declaring the dependency on the module, you can access its exported types
    and test them through code. Here''s a sample class in the test module that verifies
    that the output is accurate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Compiling and running the code with assertions enabled (the `-ea` argument)
    tells us that our tests have passed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: You should not see any output, which indicates all assertions have successfully
    passed.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating with JUnit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While writing classes with main methods can get the job done with unit testing,
    we can do better. You typically write tests in Java using a framework such as
    JUnit. JUnit is a complete testing framework with handy life cycle hooks and annotations
    that you can use to write tests easily. Let's look at converting our test module
    to use JUnit.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Get the JUnit jars. You can either download them from the JUnit website ([http://junit.org/junit4/](http://junit.org/junit4/))
    or download them from Maven Central. It also has a dependency on the hamcrest
    core JAR file, so download that too. Place the JARs in a `lib` folder. We intend
    to add this location to the module path. The downloaded JAR files are available
    in the `lib` folder at `12-build-tools-and-testing/02-testing/src/packt.sortutil.test`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Use the JUnit annotations in your test code. Here''s the new `SortUtilTest`
    written as a JUnit test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Specify that the test module has a dependency on the JUnit library. Since the
    JUnit JAR will be added to the classpath, it will be treated as an automatic module.
    So, to establish dependency, you'll need to figure out what the automatic module
    name will be from the JAR file name. The JAR file downloaded is called `junit-4.12.jar`.
    Stripping off the `.jar` extension and the version number, we'll end up with the
    automatic module--`name - junit`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Declare the test module as  `open`. The way JUnit works is by scanning the annotations
    on your classes to figure out what to do. So, it needs access to the test classes
    in your test module. You can either export the necessary packages or declare them
    as open. I prefer the latter, since we only need to enable reflective access to
    JUnit.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here''s the updated module definition of the `packt.sortutil.test` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s compile and run the test to see what the behavior is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The only change this time is the addition of the lib directory as the module
    path. This lets the Java platform treat the JUnit JAR as an automatic module,
    which is what we need. This should succeed without any errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'What happens if we run this now? We are running the JUnit test runner class,
    so that''s what we need to specify in the core JUnit runner class `JUnitCore`
    (in the automatic module `junit`) as value to the `--module` argument to Java.
    Following that is the fully qualified name of the class under test--`SortUtilTest`.
    Here''s what the command looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Will it work? It will not! Here''s the error you should see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Turns out Java is unable to find the `SortUtilTest` class. Why is that? The
    compiled module is available in the out directory that we've passed to the `--module-path`
    option! There's a reason why it does not see the class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Think back to the module resolution discussion in [Chapter 8](part0124.html#3M85O0-ed2405f4162b4f86b565edd6b6d679fb),
    U*nderstanding Linking and Using jlink*. The module resolution is a traversal
    of dependent modules originating from the starting point--the module you specify
    in the `--module` argument. Since the starting point here is the JUnit automatic
    module, the module resolution process never resolves the application or test modules.
    This is because the JUnit automatic module does not read our modules! The way
    to solve this problem and have the runtime see our modules is using the `--add-modules`
    option. Passing our test module using this option should result in the execution
    completing successfully:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Note that we did not have to add the `packt.sortutil` module to the `--add-modules`
    option. Just the test module sufficed. This is because the test module has an
    explicit dependency on `packt.sortutil` through the requires declaration, and
    so the module resolution process now picks it up automatically!
  prefs: []
  type: TYPE_NORMAL
- en: Wrapping up
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With this, we come to the end of our exploration of Java 9 modularity together.
    You now have a good understanding of Java 9 modularity and more importantly, how
    to use the feature and the related concepts in your code. This is certainly an
    exciting new addition to the Java language, and we, as developers, have both the
    ability and the responsibility to use these features wisely and well.
  prefs: []
  type: TYPE_NORMAL
- en: While this is the end of the book, I hope you are excited and well equipped
    to continue your journey into learning about and building awesome modular applications
    in Java.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered two important aspects of Java programming that play
    a significant role in most real-world Java applications--build systems and testing.
    We looked at how we can use Maven to structure our projects and align Maven's
    multi-module project concepts with Java 9 modular applications. We examined how
    such an application looks like, and learned how to compile and execute the application
    through Maven lifecycle processes. We then learned about how testing can be incorporated
    into a Java modular application. We looked at some of the challenges with testing
    that result from some constraints that Java modularity introduces to the language
    and how to work around them. We then created a JUnit test case and leveraged the
    JUnit framework to execute a module test case.
  prefs: []
  type: TYPE_NORMAL
