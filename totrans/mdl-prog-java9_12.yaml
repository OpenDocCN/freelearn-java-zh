- en: Using Build Tools and Testing Java Modules
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用构建工具和测试Java模块
- en: In the previous chapter, we looked at several strategies and approaches to migrate
    an existing Java code base to Java 9\. In this chapter, we'll wrap up our journey
    of Java 9 modularity by looking at two important topics that you are very likely
    to encounter, irrespective of whether you are migrating a legacy code base or
    creating a new modular application from scratch. They are build tool integration
    and unit testing.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们探讨了将现有的Java代码库迁移到Java 9的几种策略和方法。在本章中，我们将通过探讨两个你很可能遇到的重要主题来结束我们的Java
    9模块化之旅，无论你是迁移遗留代码库还是从头开始创建新的模块化应用程序。它们是构建工具集成和单元测试。
- en: 'Here''s what we''ll cover in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下内容：
- en: Integrating Java 9 modules with the Maven build process
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将Java 9模块与Maven构建过程集成
- en: Working with a multi-module Java 9 Maven project
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与多模块Java 9 Maven项目一起工作
- en: Writing unit test cases for Java 9 modules using JUnit
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用JUnit为Java 9模块编写单元测试用例
- en: Handling new access issues and challenges with testing in Java 9
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理Java 9中的新访问问题和测试挑战
- en: Considering that build systems and unit testing are extremely common and important
    parts of a modern Java developer's workflow, it may seem odd that we are tackling
    both these topics in the final chapter of this book. This is for a good reason.
    Understanding and working with these concepts requires an understanding of a lot
    of the topics we've covered in the last few chapters. Now that you have explored
    concepts such as open modules in [Chapter 9](part0134.html#3VPBC0-ed2405f4162b4f86b565edd6b6d679fb),
    *Module Design Patterns and Strategies*, and automatic modules in [Chapter 11](part0172.html#5410O0-ed2405f4162b4f86b565edd6b6d679fb),
    *Migrating Your Code to Java 9*, you are all set to tackle this chapter with ease!
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到构建系统和单元测试是现代Java开发者工作流程中极其常见且重要的部分，我们在这本书的最后一章同时处理这两个主题可能看起来有些奇怪。这有一个很好的原因。理解和处理这些概念需要理解我们在前几章中讨论的许多主题。现在，你已经探索了诸如[第9章](part0134.html#3VPBC0-ed2405f4162b4f86b565edd6b6d679fb)中的开放模块、“模块设计模式和策略”以及[第11章](part0172.html#5410O0-ed2405f4162b4f86b565edd6b6d679fb)中的自动模块“将您的代码迁移到Java
    9”等概念，你现在可以轻松地应对这一章节了！
- en: Integrating with Apache Maven
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与Apache Maven集成
- en: Two of the build systems that are very commonly used in the Java landscape are
    Apache Maven and Gradle. When you are working on an enterprise Java application,
    it's very likely that you'll have to deal with one of these two options. In this
    book so far, we've been working with the command line to get the compiler and
    runtime to execute. However, that's rarely a reasonable thing to do in a complex
    project. So, what does it take to use such a build system in a Java 9 modular
    application?
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java领域，有两个非常常用的构建系统是Apache Maven和Gradle。当你在一个企业Java应用程序上工作时，你很可能必须处理这两个选项之一。到目前为止，我们在本书中一直使用命令行来获取编译器和运行时执行。然而，在复杂的项目中，这很少是合理的事情。那么，在Java
    9模块化应用程序中使用这样的构建系统需要什么？
- en: At the time of writing this, Maven has a workable integration with Java 9, while
    Gradle is still in active development. Thus, we'll only be covering Apache Maven
    integration in this book. It's only a matter of time before the Java tooling ecosystem
    catches up to the modularity changes in Java 9, so it shouldn't be surprising
    to see better integration and an overall experience of using these tools with
    Java 9 over time.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，Maven已经与Java 9有了可行的集成，而Gradle仍在积极开发中。因此，我们在这本书中只涵盖Apache Maven的集成。Java工具生态系统赶上Java
    9的模块化变化只是时间问题，因此随着时间的推移，看到更好的集成和使用这些工具与Java 9的整体体验不会令人惊讶。
- en: Let's examine the way you can create a Maven project that contains and builds
    a Java 9 modular application.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看你可以如何创建一个包含并构建Java 9模块化应用程序的Maven项目。
- en: A Maven refresher
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Maven快速回顾
- en: This chapter assumes you are familiar with at least the basic concepts of Maven,
    but here is a quick refresher. Maven is, among other things, a project build tool.
    It is based on convention and provides a formal structure to organize your code,
    name your artifacts, and establish dependencies on other projects. This may sound
    very similar to what we've been doing with Java 9 modularity, but it isn't. Unlike
    the Java platform module system, Maven is concerned with building (or assembling)
    your artifacts, and not verifying compile time or runtime accuracy.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章假设你至少熟悉Maven的基本概念，但这里有一个快速回顾。Maven，在其他方面，是一个项目构建工具。它基于约定并提供了一种正式的结构来组织你的代码、命名你的工件以及在其他项目上建立依赖关系。这听起来可能与我们一直在使用的Java
    9模块化非常相似，但实际上并不相同。与Java平台模块系统不同，Maven关注的是构建（或组装）你的工件，而不是验证编译时间或运行时准确性。
- en: 'When you create a Maven artifact, you assign *coordinates* to it: the group
    name, the artifact name, and the version. You specify this in a file called `pom.xml`.
    This file also lets you specify dependencies on other Maven artifacts so that
    when the build process runs, Maven can fetch the necessary dependencies and make
    them available to the Java compiler or runtime.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建一个Maven工件时，你给它分配**坐标**：组名、工件名和版本。你在这个名为`pom.xml`的文件中指定这些信息。此文件还允许你指定对其他Maven工件依赖项，以便在构建过程运行时，Maven可以获取必要的依赖项并将它们提供给Java编译器或运行时。
- en: Using Maven with Java 9 modules
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Maven与Java 9模块
- en: 'When you bring Java 9 modules into the picture, you can see that there are
    two parallel concepts of modules here: the Maven concept of an artifact with the
    definition in `pom.xml` and the Java platform concept of a module with the module
    definition in `module-info.java`. However, these two work surprisingly well when
    you collapse the two and have each Maven project containing one Java 9 module.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将Java 9模块引入场景时，你可以看到这里有两种并行的模块概念：Maven关于在`pom.xml`中定义的工件的概念和Java平台关于在`module-info.java`中定义的模块的概念。然而，当你将这两个合并，并且每个Maven项目包含一个Java
    9模块时，这两个概念出奇地好地协同工作。
- en: Consider the following folder structure of a single Maven project. The code
    is in the `lib` folder. It is a typical Maven project. It has a `pom.xml` descriptor
    that contains the Maven coordinates for this artifact. However, it also has the
    module-info.java in the `src/main/java` folder that sets it up as a Java 9 module!
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下单个Maven项目的文件夹结构。代码位于`lib`文件夹中。这是一个典型的Maven项目。它有一个包含此工件Maven坐标的`pom.xml`描述符。然而，它还有一个位于`src/main/java`文件夹中的`module-info.java`文件，将其设置为Java
    9模块！
- en: '![](img/00106.jpeg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00106.jpeg)'
- en: 'With this approach, the idea is to create a Maven artifact for each Java 9
    module. This means that you''ll need to come up with two separate names:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 采用这种方法，目的是为每个Java 9模块创建一个Maven工件。这意味着你需要想出两个不同的名称：
- en: The coordinates for the Maven artifact--comprising of group name and artifact
    name
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Maven工件坐标——包括组名和工件名
- en: The name of the Java 9 module
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 9模块的名称
- en: 'Now, when it comes to establishing dependencies between two of these modules,
    you will need to specify dependencies in two places. Let''s say, for example,
    that you have two Maven Java 9 projects called **A** and **B**. In order to specify
    that A is dependent on B, you need to do the following:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当涉及到在两个这些模块之间建立依赖关系时，你需要在两个地方指定依赖项。比如说，例如，你拥有两个名为**A**和**B**的Maven Java 9项目。为了指定A依赖于B，你需要执行以下操作：
- en: Add a `<dependency>` tag in the Maven `pom.xml` file of A specifying the Maven
    coordinates of B
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在A的Maven `pom.xml`文件中添加一个`<dependency>`标签，指定B的Maven坐标
- en: Add a  `requires` declaration in the `module-info.java` file of A specifying
    the module name of B
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在A的`module-info.java`文件中添加一个`requires`声明，指定B的模块名称
- en: The advantage of this approach is that Maven takes care of fetching the necessary
    artifacts and placing them in the module path. Then, the Java platform module
    system has everything it needs when the compiler or runtime executes! Note that
    this doesn't work if you miss either one of these two dependency configurations.
    If you forget to specify the Maven dependency, Maven will not fetch the artifact
    and place it in the module path. If you forget to add the requires declaration
    in `module-info.java`, your code cannot access the types in the dependency, even
    though Maven has made it available in the module path.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的优点是Maven负责获取必要的工件并将它们放置在模块路径中。然后，当编译器或运行时执行时，Java平台模块系统就有了一切所需！请注意，如果你遗漏了这两个依赖配置中的任何一个，这就不起作用了。如果你忘记指定Maven依赖项，Maven将不会获取工件并将其放置在模块路径中。如果你忘记在`module-info.java`中添加requires声明，即使Maven已经在模块路径中提供了它，你的代码也无法访问依赖项中的类型。
- en: While this works great for one or two modules, this can also get tricky to manage
    when you are dealing with an application consisting of multiple modules. In such
    situations, we can leverage the multi-module project feature of Maven to better
    organize multiple Maven + Java 9 modules.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当你处理由多个模块组成的应用程序时，虽然这对一个或两个模块来说效果很好，但这也可能变得难以管理。在这种情况下，我们可以利用Maven的多模块项目功能来更好地组织多个Maven
    + Java 9模块。
- en: Working on a multi-module Java 9 Maven project
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在一个多模块Java 9 Maven项目中工作
- en: 'Let''s look at a sample Maven multi-module project. Let''s say we want to build
    two Java modules: `packt.main` and `packt.lib`. The `packt.lib` module contains
    a library class `Lib` with a method called `sampleMethod`, and the `packt.main`
    module contains a class `App` with a main method calling `sampleMethod` from `Lib`.
    Thus, `packt.main` has to read `packt.lib`, as shown here:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个示例Maven多模块项目。假设我们想要构建两个Java模块：`packt.main`和`packt.lib`。`packt.lib`模块包含一个名为`Lib`的库类，它有一个名为`sampleMethod`的方法，而`packt.main`模块包含一个名为`App`的类，它有一个主方法调用`Lib`中的`sampleMethod`。因此，`packt.main`必须读取`packt.lib`，如下所示：
- en: '![](img/00107.jpeg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00107.jpeg)'
- en: 'You''ve already learned that you should have one Maven project corresponding
    to each Java module. However, in order to ease the development, and to leverage
    the concept of a multi-module project in Maven, we can instead create a parent
    root Maven artifact. Now, both the modules of our application can be Maven child
    projects, as shown here:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经了解到你应该有一个Maven项目对应于每个Java模块。然而，为了简化开发并利用Maven中多模块项目的概念，我们可以创建一个父根Maven工件。现在，我们应用程序的模块都可以是Maven子项目，如下所示：
- en: '![](img/00108.jpeg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00108.jpeg)'
- en: The code is available in the `12-build-tools-and-testing/01-maven-integration`
    folder. There is a root Maven module at the root directory. This module acts as
    a parent module. This is just a Maven container to facilitate the build process.
    We don't really need a corresponding Java module for this. Within the root folder
    are two child Maven projects `main` and `lib`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 代码位于`12-build-tools-and-testing/01-maven-integration`文件夹中。在根目录中有一个根Maven模块。这个模块充当父模块。这只是一个Maven容器，用于简化构建过程。我们实际上不需要为这个创建相应的Java模块。在根文件夹中是两个子Maven项目`main`和`lib`。
- en: 'Here, its `pom.xml` at the root (truncated for brevity):'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，它的根目录下的`pom.xml`（为了简洁而截断）：
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The packaging node in the XML specifies the pom value, indicating that this
    is a parent pom. It has two module declarations indicating the two Maven child
    modules that it is a parent to. Don't be confused by the use of the term modules
    here. We are talking about Maven modules, not Java 9 modules.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: XML中的packaging节点指定了pom值，表示这是一个父pom。它有两个模块声明，表示它是两个Maven子模块的父模块。在这里使用术语模块时不要混淆。我们在这里谈论的是Maven模块，而不是Java
    9模块。
- en: Within each child module, main and lib, it's just like we've seen so far. They
    are standard Maven projects, but with the `module-info.java` file in the `src/main/java`
    location making them Java 9 modules.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个子模块中，主模块和lib模块，就像我们之前看到的那样。它们是标准的Maven项目，但在`src/main/java`位置有一个`module-info.java`文件，使它们成为Java
    9模块。
- en: 'The following screenshot shows the complete folders structure:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的截图显示了完整的文件夹结构：
- en: '![](img/00109.jpeg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00109.jpeg)'
- en: Since the main project is using a type from the lib project, both the Maven
    and Java dependencies are configured.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 由于主项目使用lib项目中的一个类型，因此配置了Maven和Java依赖项。
- en: 'Here''s the main project''s `pom.xml` file specifying the dependency:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是主项目的`pom.xml`文件，指定了依赖项：
- en: '[PRE1]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'And here''s its `module-info.java` file:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是这个`module-info.java`文件：
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Building the multi-module project
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建多模块项目
- en: 'Before we build, make sure you have the latest version of Maven installed in
    your path. Running the following command should give you the Maven version that''s
    installed on your machine:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们构建之前，请确保你的路径中安装了最新的 Maven 版本。运行以下命令应该会给出你机器上安装的 Maven 版本：
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: If you don't see this output, you'll need to download Apache Maven from [https://maven.apache.org](https://maven.apache.org/plugins/maven-compiler-plugin/)
    and add the `bin` folder on the download to your operating system's `PATH` variable.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有看到这个输出，你需要从 [https://maven.apache.org](https://maven.apache.org/plugins/maven-compiler-plugin/)
    下载 Apache Maven，并将下载的 `bin` 文件夹添加到你的操作系统的 `PATH` 变量中。
- en: 'Let''s try to build this project. There are inclusions in the root project''s
    `pom.xml` to make this ready to be built on Java 9\. Following is the Maven compiler
    plugin used to set the Java version to 9:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试构建这个项目。在根项目的 `pom.xml` 中有包含项，使其准备好在 Java 9 上构建。以下是用于设置 Java 版本为 9 的 Maven
    编译器插件：
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'With this, you should be able to run Maven''s build command and have the Java
    9 compiler compile our classes. Switch to the `12-build-tools-and-testing/01-maven-integration/root`
    directory and run the following command:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个方法，你应该能够运行 Maven 的构建命令，并让 Java 9 编译器编译我们的类。切换到 `12-build-tools-and-testing/01-maven-integration/root`
    目录，并运行以下命令：
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The output below, truncated for readability, indicates that all the modules
    have been compiled:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的输出，为了可读性进行了截断，表明所有模块都已编译：
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Executing the multi-module project
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行多模块项目
- en: 'In order to execute the class with the  `main` method as a Maven lifecycle,
    we use the `exec-maven-plugin`. This is also possible thanks to the configuration
    in the root project''s `pom.xml` file. Here''s the listing that specifies this
    configuration:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将具有 `main` 方法的类作为 Maven 生命周期执行，我们使用 `exec-maven-plugin`。这也得益于根项目 `pom.xml`
    文件中的配置。以下是指定此配置的列表：
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As is typical with Maven configuration, this looks verbose. However, what's
    interesting for us is the configuration section. We are configuring the `java`
    command, so you have the executable path here mapped from `$JAVA_HOME`. We are
    also passing in the two arguments we should be very familiar with now--the `--module-path` argument
    indicating where the compiled modules are, and the `--module` indicating what's
    the module and class containing the main method.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如同 Maven 配置的典型情况，这看起来有些冗长。然而，对我们来说，有趣的是配置部分。我们正在配置 `java` 命令，因此你在这里将可执行路径从 `$JAVA_HOME`
    映射过来。我们还在传递我们现在应该非常熟悉的两个参数--表示编译模块位置的 `--module-path` 参数，以及表示包含主方法的模块和类的 `--module`
    参数。
- en: Note that for the `--module-path` argument, we aren't specifying the path manually.
    This is because Maven is compiling the modules for us, so we want Maven itself
    to supply us with the path where it has placed the compiled classes. That is done
    using the special `<modulepath />` tag. We'll discuss the module path in Maven
    in a bit more detail in the following section.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，对于 `--module-path` 参数，我们并没有手动指定路径。这是因为 Maven 在为我们编译模块，所以我们希望 Maven 本身提供给我们它放置编译类的路径。这是通过特殊的
    `<modulepath />` 标签完成的。我们将在下一节中更详细地讨论 Maven 中的模块路径。
- en: 'Switch to the `12-build-tools-and-testing/01-maven-integration/root/main` directory
    and run the following command to call the `exec` plugin:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 切换到 `12-build-tools-and-testing/01-maven-integration/root/main` 目录，并运行以下命令来调用
    `exec` 插件：
- en: '[PRE8]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Here''s the truncated output:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是截断后的输出：
- en: '[PRE9]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `Library method called!` line is the output of the  `main` method calling
    the library method and printing the message to the console.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`Library method called!` 这一行是 `main` 方法调用库方法并将消息打印到控制台的输出。'
- en: Understanding the exec plugin's module path
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 exec 插件的模块路径
- en: 'While there are several advantages to using Maven this way, one significant
    advantage is how easy it becomes to manage the directories during the compile
    and build step. When we ran `javac` manually, we always had to manually specify
    the *output* directory where all the compiled classes would go. When we ran `java`,
    we had to make sure the module path contained the output location of classes,
    as well as any dependent modules and libraries. Maven takes that work away from
    us. Thanks to the `<modulepath/>` line that we added as the module path argument
    to `exec-maven-plugin`, Maven automatically constructs the module path for us.
    Here''s what Maven adds to the module path:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然使用Maven这种方式有几个优点，但一个显著的优势是，在编译和构建步骤中管理目录变得非常容易。当我们手动运行`javac`时，我们总是必须手动指定所有编译后的类将放入的*输出*目录。当我们运行`java`时，我们必须确保模块路径包含类的输出位置，以及任何依赖的模块和库。Maven为我们承担了这项工作。多亏了我们添加到`exec-maven-plugin`模块路径参数中的`<modulepath/>`行，Maven自动为我们构建模块路径。以下是Maven添加到模块路径中的内容：
- en: It automatically includes the build location of the project. We ran the plugin
    on the `main` project. Maven makes sure the compiled classes from `main` are available
    in the module path.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它自动包括项目的构建位置。我们在`main`项目上运行了插件。Maven确保`main`编译后的类在模块路径中可用。
- en: It automatically makes sure the dependencies are in the module path as well.
    In the `main` project's `pom.xml`, we specified a dependency on `lib` . Maven
    acknowledges the dependency and automatically includes the complied `lib` module
    into the module path!
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它自动确保依赖项也在模块路径中。在`main`项目的`pom.xml`中，我们指定了一个对`lib`的依赖。Maven承认这个依赖，并自动将编译后的`lib`模块包含到模块路径中！
- en: It automatically includes dependencies that aren't Java 9 modules too! Let's
    say your `pom.xml` file specifies a dependency on a third-party library that isn't
    migrated to Java 9 yet. Maven automatically adds those jars to the module path
    as well. Guess what happens when you add a pre-Java 9 JAR into the module path?
    They become automatic modules! Your modules can use the `requires` syntax to depend
    on them, just like any Java 9 module. Thus, your workflow becomes extremely simple
    and consistent when dealing with dependencies, be it Java 9 or older.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它自动包括那些不是Java 9模块的依赖项！假设你的`pom.xml`文件指定了一个依赖于尚未迁移到Java 9的第三方库。Maven会自动将这些jar文件添加到模块路径中。猜猜当你将一个Java
    9之前的JAR文件添加到模块路径中会发生什么？它们变成了自动模块！你的模块可以使用`requires`语法来依赖它们，就像任何Java 9模块一样。因此，当处理依赖项时，无论是Java
    9还是更早的版本，你的工作流程都变得极其简单和一致。
- en: Unit testing modules with Java 9
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Java 9进行单元测试模块
- en: 'The readability and accessibility constraints pose new and interesting problems
    when it comes to testing in Java 9\. Let''s look back at the way we''ve always
    been unit testing code in Java. Here are two common practices:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当在Java 9中进行测试时，可读性和可访问性约束带来了新的和有趣的问题。让我们回顾一下我们一直使用的Java单元测试代码的方式。以下是两种常见的做法：
- en: The unit test code typically resides in a separate source folder that is added
    to the classpath. This is to separate the test code from the actual application
    code and to also make it easy to exclude the test folder when building an application
    for deployment.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试代码通常位于一个单独的源文件夹中，该文件夹被添加到类路径中。这是为了将测试代码与实际的应用程序代码分开，同时也便于在构建部署应用程序时排除测试文件夹。
- en: The unit test classes typically share the same package as the class under test.
    This is to make sure the test classes can access the package-private members of
    the classes under test, even though they are in a completely different location.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试类通常与被测试的类共享相同的包。这是为了确保测试类可以访问被测试类的包私有成员，即使它们位于完全不同的位置。
- en: 'These two design decisions work well when classes are in the classpath, because
    we know that the physical location of the classes in the classpath doesn''t matter.
    However, all that is changing with Java 9! Here''s how:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当类在类路径中时，这两个设计决策效果很好，因为我们知道类路径中类的物理位置并不重要。然而，所有这些在Java 9中都在改变！以下是这样做的方法：
- en: In Java 9, the test code could face access restrictions due to strong encapsulation.
    Your Java 9 classes under test are in a module. So, the only way to access all
    the types in your module from your test classes is to put your test classes in
    the same module as well! This is not ideal because, when you build and ship a
    Java module, the entire contents go with it. The only other option is to keep
    your test classes outside the module and only test the classes that are *exported*.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Java 9中，测试代码可能会因为强封装而面临访问限制。您正在测试的Java 9类位于一个模块中。因此，要从测试类中访问模块中的所有类型，唯一的方法是将测试类也放在同一个模块中！这并不是一个好的选择，因为当您构建和分发Java模块时，整个内容都会随之而来。另一个选择是将测试类放在模块外部，并且只测试那些*导出*的类。
- en: If you keep your tests in a separate folder and in a separate module, you cannot
    have your test classes share the same package as the classes under test. This
    will cause the split package problem since the same package exists in both the
    application module and the test module. Thus, you cannot access and test package-private
    members
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您将测试放在单独的文件夹和单独的模块中，您的测试类就不能与被测试类共享相同的包。这会导致拆分包问题，因为相同的包存在于应用程序模块和测试模块中。因此，您无法访问和测试包私有成员。
- en: 'Considering these challenges, one way to work around them is as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这些挑战，一种绕过它们的方法如下：
- en: Create a separate test module for every module you need to test.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为每个需要测试的模块创建一个单独的测试模块。
- en: Write test cases that test the exported module interface.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写测试用例以测试导出模块接口。
- en: If you need to write tests for any internal types that aren't exported by the
    module, use `--add-exports` overrides during test execution. Yes, `--add-exports`
    isn't a good idea for application code, but it's a reasonable workaround for testing.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您需要为模块未导出的任何内部类型编写测试，请在测试执行期间使用`--add-exports`覆盖。是的，`--add-exports`对于应用程序代码来说不是一个好主意，但它是一个合理的测试解决方案。
- en: Testing a Java 9 module
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试Java 9模块
- en: Let's examine how this works by testing the `packt.sortutil` from the sample
    address book viewer application. The code is available at the `12-build-tools-and-testing/02-testing`
    location. The `src` folder contains the `packt.sortutil` module--the module under
    test.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过测试示例地址簿查看器应用程序中的`packt.sortutil`来检查这是如何工作的。代码位于`12-build-tools-and-testing/02-testing`位置。`src`文件夹包含`packt.sortutil`模块--即测试的模块。
- en: 'To test this, we can create a new test module: `packt.sortutil.test`. A good
    convention to follow is to name the test modules with the name of the module being
    tested followed by `.test`. Here''s the module definition for `packt.sortutil.test`:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 要进行测试，我们可以创建一个新的测试模块：`packt.sortutil.test`。遵循的一个好惯例是将测试模块命名为要测试的模块名称后跟`.test`。以下是`packt.sortutil.test`的模块定义：
- en: '[PRE10]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'By declaring the dependency on the module, you can access its exported types
    and test them through code. Here''s a sample class in the test module that verifies
    that the output is accurate:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 通过声明对模块的依赖，您可以访问其导出类型并通过代码进行测试。以下是测试模块中的一个示例类，它验证输出是否准确：
- en: '[PRE11]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Compiling and running the code with assertions enabled (the `-ea` argument)
    tells us that our tests have passed:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 使用断言启用（`-ea`参数）编译和运行代码告诉我们测试已经通过：
- en: '[PRE12]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: You should not see any output, which indicates all assertions have successfully
    passed.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 您不应该看到任何输出，这表明所有断言都已成功通过。
- en: Integrating with JUnit
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与JUnit集成
- en: While writing classes with main methods can get the job done with unit testing,
    we can do better. You typically write tests in Java using a framework such as
    JUnit. JUnit is a complete testing framework with handy life cycle hooks and annotations
    that you can use to write tests easily. Let's look at converting our test module
    to use JUnit.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然使用带有main方法的类进行单元测试可以完成任务，但我们还可以做得更好。您通常使用JUnit这样的框架在Java中编写测试。JUnit是一个完整的测试框架，它提供了方便的生命周期钩子和注释，您可以使用它们轻松地编写测试。让我们看看如何将我们的测试模块转换为使用JUnit。
- en: 'Here are the steps:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是步骤：
- en: Get the JUnit jars. You can either download them from the JUnit website ([http://junit.org/junit4/](http://junit.org/junit4/))
    or download them from Maven Central. It also has a dependency on the hamcrest
    core JAR file, so download that too. Place the JARs in a `lib` folder. We intend
    to add this location to the module path. The downloaded JAR files are available
    in the `lib` folder at `12-build-tools-and-testing/02-testing/src/packt.sortutil.test`.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取 JUnit JAR 文件。您可以从 JUnit 网站 ([http://junit.org/junit4/](http://junit.org/junit4/))
    下载，或者从 Maven Central 下载。它还依赖于 hamcrest core JAR 文件，所以也要下载它。将 JAR 文件放在 `lib` 文件夹中。我们打算将此位置添加到模块路径中。下载的
    JAR 文件位于 `lib` 文件夹的 `12-build-tools-and-testing/02-testing/src/packt.sortutil.test`。
- en: 'Use the JUnit annotations in your test code. Here''s the new `SortUtilTest`
    written as a JUnit test:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的测试代码中使用 JUnit 注解。以下是将 `SortUtilTest` 编写为 JUnit 测试的新代码：
- en: '[PRE13]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Specify that the test module has a dependency on the JUnit library. Since the
    JUnit JAR will be added to the classpath, it will be treated as an automatic module.
    So, to establish dependency, you'll need to figure out what the automatic module
    name will be from the JAR file name. The JAR file downloaded is called `junit-4.12.jar`.
    Stripping off the `.jar` extension and the version number, we'll end up with the
    automatic module--`name - junit`.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指定测试模块依赖于 JUnit 库。由于 JUnit JAR 将被添加到类路径中，它将被视为一个自动模块。因此，为了建立依赖关系，您需要从 JAR 文件名中找出自动模块的名称。下载的
    JAR 文件名为 `junit-4.12.jar`。去掉 `.jar` 扩展名和版本号，我们得到自动模块--`name - junit`。
- en: Declare the test module as  `open`. The way JUnit works is by scanning the annotations
    on your classes to figure out what to do. So, it needs access to the test classes
    in your test module. You can either export the necessary packages or declare them
    as open. I prefer the latter, since we only need to enable reflective access to
    JUnit.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将测试模块声明为 `open`。JUnit 的工作方式是通过扫描您类上的注解来确定要做什么。因此，它需要访问您测试模块中的测试类。您可以选择导出必要的包或将它们声明为
    open。我更喜欢后者，因为我们只需要启用对 JUnit 的反射访问。
- en: 'Here''s the updated module definition of the `packt.sortutil.test` module:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 `packt.sortutil.test` 模块的更新模块定义：
- en: '[PRE14]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Let''s compile and run the test to see what the behavior is:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编译并运行测试以查看行为：
- en: '[PRE15]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The only change this time is the addition of the lib directory as the module
    path. This lets the Java platform treat the JUnit JAR as an automatic module,
    which is what we need. This should succeed without any errors.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这次唯一的更改是将 lib 目录添加为模块路径。这使得 Java 平台将 JUnit JAR 视为一个自动模块，这正是我们所需要的。这应该会成功，没有任何错误。
- en: 'What happens if we run this now? We are running the JUnit test runner class,
    so that''s what we need to specify in the core JUnit runner class `JUnitCore`
    (in the automatic module `junit`) as value to the `--module` argument to Java.
    Following that is the fully qualified name of the class under test--`SortUtilTest`.
    Here''s what the command looks like:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在运行它会发生什么？我们正在运行 JUnit 测试运行器类，所以我们需要在核心 JUnit 运行器类 `JUnitCore`（在自动模块 `junit`
    中）中将它指定为 `--module` 参数的值给 Java。接下来是正在测试的类的完全限定名--`SortUtilTest`。以下是命令的样子：
- en: '[PRE16]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Will it work? It will not! Here''s the error you should see:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这会工作吗？不会！以下是您应该看到的错误：
- en: '[PRE17]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Turns out Java is unable to find the `SortUtilTest` class. Why is that? The
    compiled module is available in the out directory that we've passed to the `--module-path`
    option! There's a reason why it does not see the class.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 结果发现 Java 无法找到 `SortUtilTest` 类。为什么？编译后的模块位于我们传递给 `--module-path` 选项的 out 目录中！它没有看到这个类是有原因的。
- en: 'Think back to the module resolution discussion in [Chapter 8](part0124.html#3M85O0-ed2405f4162b4f86b565edd6b6d679fb),
    U*nderstanding Linking and Using jlink*. The module resolution is a traversal
    of dependent modules originating from the starting point--the module you specify
    in the `--module` argument. Since the starting point here is the JUnit automatic
    module, the module resolution process never resolves the application or test modules.
    This is because the JUnit automatic module does not read our modules! The way
    to solve this problem and have the runtime see our modules is using the `--add-modules`
    option. Passing our test module using this option should result in the execution
    completing successfully:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下第8章中关于模块解析的讨论，[理解链接和使用jlink](part0124.html#3M85O0-ed2405f4162b4f86b565edd6b6d679fb)。模块解析是从起点——你在`--module`参数中指定的模块——开始的依赖模块的遍历。由于这里的起点是JUnit自动模块，模块解析过程永远不会解析应用程序或测试模块。这是因为JUnit自动模块不会读取我们的模块！要解决这个问题并让运行时看到我们的模块，可以使用`--add-modules`选项。使用此选项传递我们的测试模块应该会导致执行成功完成：
- en: '[PRE18]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Note that we did not have to add the `packt.sortutil` module to the `--add-modules`
    option. Just the test module sufficed. This is because the test module has an
    explicit dependency on `packt.sortutil` through the requires declaration, and
    so the module resolution process now picks it up automatically!
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们不需要将`packt.sortutil`模块添加到`--add-modules`选项中。只需测试模块就足够了。这是因为测试模块通过requires声明明确依赖于`packt.sortutil`，因此模块解析过程现在会自动获取它！
- en: Wrapping up
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: With this, we come to the end of our exploration of Java 9 modularity together.
    You now have a good understanding of Java 9 modularity and more importantly, how
    to use the feature and the related concepts in your code. This is certainly an
    exciting new addition to the Java language, and we, as developers, have both the
    ability and the responsibility to use these features wisely and well.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，我们就一起结束了对Java 9模块化的探索。你现在对Java 9模块化有了很好的理解，更重要的是，你了解了如何在代码中使用这个特性和相关概念。这无疑是Java语言的一个令人兴奋的新增功能，作为开发者，我们既有能力也有责任明智且有效地使用这些功能。
- en: While this is the end of the book, I hope you are excited and well equipped
    to continue your journey into learning about and building awesome modular applications
    in Java.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这本书的内容到此结束，但我希望你能感到兴奋，并且已经准备好继续你的旅程，深入了解并构建令人惊叹的Java模块化应用程序。
- en: Summary
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered two important aspects of Java programming that play
    a significant role in most real-world Java applications--build systems and testing.
    We looked at how we can use Maven to structure our projects and align Maven's
    multi-module project concepts with Java 9 modular applications. We examined how
    such an application looks like, and learned how to compile and execute the application
    through Maven lifecycle processes. We then learned about how testing can be incorporated
    into a Java modular application. We looked at some of the challenges with testing
    that result from some constraints that Java modularity introduces to the language
    and how to work around them. We then created a JUnit test case and leveraged the
    JUnit framework to execute a module test case.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了Java编程的两个重要方面，这在大多数现实世界的Java应用程序中都发挥着重要作用——构建系统和测试。我们探讨了如何使用Maven来构建我们的项目，并将Maven的多模块项目概念与Java
    9模块化应用程序对齐。我们检查了这样的应用程序看起来像什么，并学习了如何通过Maven的生命周期过程编译和执行应用程序。然后我们学习了如何将测试集成到Java模块化应用程序中。我们探讨了由于Java模块化引入到语言中的一些约束导致的测试挑战，以及如何绕过它们。然后我们创建了一个JUnit测试用例，并利用JUnit框架执行模块测试用例。
