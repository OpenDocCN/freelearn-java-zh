- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Working with Date and Time
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与日期和时间一起工作
- en: This chapter includes 20 problems covering different date-time topics. These
    problems are mainly focused on the `Calendar` API and on the JDK Date/Time API.
    About the latter, we will cover some less popular APIs such as `ChronoUnit`, `ChronoField`,
    `IsoFields`, `TemporalAdjusters`, and so on.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包括20个问题，涵盖不同的日期时间主题。这些问题主要关注`Calendar` API和JDK Date/Time API。关于后者，我们将介绍一些不太流行的API，如`ChronoUnit`，`ChronoField`，`IsoFields`，`TemporalAdjusters`等。
- en: At the end of this chapter, you’ll have a ton of tips and tricks in your tool
    belt that will be very useful for solving a wide range of real-world date-time
    problems.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，你将拥有大量的技巧和窍门在你的工具箱中，这将非常有用，可以解决各种现实世界的日期时间问题。
- en: Problems
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Use the following problems to test your programming prowess on date and time.
    I strongly encourage you to give each problem a try before you turn to the solutions
    and download the example programs:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下问题来测试你在日期和时间上的编程能力。我强烈建议你在查看解决方案并下载示例程序之前尝试每个问题：
- en: '**Defining a day period**: Write an application that goes beyond AM/PM flags
    and split the day into four periods: *night*, *morning*, *afternoon*, and *evening*.
    Depending on the given date-time and time zone generate one of these periods.'
  id: totrans-6
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**定义一天的时间段**：编写一个应用程序，它超越了AM/PM标志，并将一天分为四个时间段：*夜间*，*早晨*，*下午*和*傍晚*。根据给定的日期时间和时区生成这些时间段之一。'
- en: '**Converting between Date and YearMonth**: Write an application that converts
    between `java.util.Date` and `java.time.YearMonth` and vice versa.'
  id: totrans-7
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**在Date和YearMonth之间转换**：编写一个应用程序，在`java.util.Date`和`java.time.YearMonth`之间进行转换，反之亦然。'
- en: '**Converting between int and YearMonth**: Let’s consider that a `YearMonth`
    is given (for instance, 2023-02). Convert it to an integer representation (for
    instance, 24277) that can be converted back to `YearMonth`.'
  id: totrans-8
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**在int和YearMonth之间转换**：假设给定一个`YearMonth`（例如，2023-02）。将其转换为整数表示（例如，24277），该整数可以转换回`YearMonth`。'
- en: '**Converting week/year to Date**: Let’s consider that two integers are given
    representing a week and a year (for instance, week 10, year 2023). Write a program
    that converts 10-2023 to a `java.util.Date` via `Calendar` and to a `LocalDate`
    via the `WeekFields` API. Also, do vice versa: from a given `Date`/`LocalDate`
    extract the year and the week as integers.'
  id: totrans-9
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**将周/年转换为Date**：假设给定两个整数，分别表示周和年（例如，第10周，2023年）。编写一个程序，通过`Calendar`将10-2023转换为`java.util.Date`，通过`WeekFields`
    API将10-2023转换为`LocalDate`。反之亦然：从给定的`Date`/`LocalDate`中提取年份和周作为整数。'
- en: '**Checking for a leap year**: Let’s consider that an integer is given representing
    a year. Write an application that checks if this year is a leap year. Provide
    at least three solutions.'
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**检查闰年**：假设给定一个表示年份的整数。编写一个应用程序来检查这一年是否是闰年。提供至少三种解决方案。'
- en: '**Calculating the quarter of a given date**: Let’s consider that a `java.util.Date`
    is given. Write a program that returns the quarter containing this date as an
    integer (1, 2,3, or 4) and as a string (Q1, Q2, Q3, or Q4).'
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**计算给定日期的季度**：假设给定一个`java.util.Date`。编写一个程序，返回包含此日期的季度作为整数（1，2，3或4）和作为字符串（Q1，Q2，Q3或Q4）。'
- en: '**Getting the first and last day of a quarter**: Let’s consider that a `java.util.Date`
    is given. Write a program that returns the first and last day of the quarter containing
    this date. Represent the returned days as `Date` (implementation based on `Calendar`)
    and `LocalDate` (implementation based on the JDK 8 Date/Time API).'
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**获取季度的第一天和最后一天**：假设给定一个`java.util.Date`。编写一个程序，返回包含此日期的季度的第一天和最后一天。以`Date`（基于`Calendar`的实现）和`LocalDate`（基于JDK
    8 Date/Time API的实现）表示返回的日期。'
- en: '**Extracting the months from a given quarter**: Let’s consider that a quarter
    is given (as an integer, a string (Q1, Q2, Q3, or Q4), or a `LocalDate`). Write
    a program that extracts the names of the months of this quarter.'
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**从给定季度中提取月份**：假设给定一个季度（作为一个整数，一个字符串（Q1，Q2，Q3或Q4），或一个`LocalDate`）。编写一个程序，提取该季度的月份名称。'
- en: '**Computing pregnancy due date**: Write a pregnancy due date calculator.'
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**计算预产期**：编写一个预产期计算器。'
- en: '**Implementing a stopwatch**: Write a program that implements a stopwatch via
    `System.nanoTime()` and via `Instant.now()`.'
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**实现计时器**：编写一个程序，通过`System.nanoTime()`和`Instant.now()`实现计时器。'
- en: '**Extracting the count of milliseconds since midnight**: Let’s consider that
    a `LocalDateTime` is given. Write an application that counts the milliseconds
    passed from midnight to this `LocalDateTime`.'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**提取自午夜以来的毫秒数**：假设给出了一个`LocalDateTime`。编写一个应用程序，计算从午夜到这个`LocalDateTime`经过的毫秒数。'
- en: '**Splitting a date-time range into equal intervals**: Let’s assume that we
    have a date-time range given via two `LocalDateTime` instances, and an integer,
    `n`. Write an application that splits the given range into `n` equal intervals
    (`n` equal `LocalDateTime` instances).'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**将日期时间范围分割成等间隔**：假设我们有一个日期时间范围，通过两个`LocalDateTime`实例给出，以及一个整数`n`。编写一个应用程序，将给定的范围分割成`n`个等间隔（`n`个等`LocalDateTime`实例）。'
- en: '**Explaining the difference between Clock.systemUTC() and Clock.systemDefaultZone()**:Explain
    via meaningful examples what is the difference between `systemUTC()` and `systemDefaultZone()`.'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**解释Clock.systemUTC()和Clock.systemDefaultZone()之间的区别**：通过有意义的示例解释`systemUTC()`和`systemDefaultZone()`之间的区别。'
- en: '**Displaying the names of the days of the week**: Display the names of the
    days of the week via the `java.text.DateFormatSymbols` API.'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**显示一周中各天的名称**：通过`java.text.DateFormatSymbols` API显示一周中各天的名称。'
- en: '**Getting the first and last day of the year**: Let’s consider that an integer
    representing a year is given. Write a program that returns the first and last
    day of this year. Provide a solution based on the `Calendar` API and one based
    on the JDK 8 Date/Time API.'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**获取一年中的第一天和最后一天**：假设给出了一个表示年份的整数。编写一个程序，返回这一年的第一天和最后一天。提供一个基于`Calendar` API的解决方案和一个基于JDK
    8 Date/Time API的解决方案。'
- en: '**Getting the first and last day of the week**: Let’s assume that we have an
    integer representing a number of weeks (for instance, 3 represents three consecutive
    weeks starting from the current date). Write a program that returns the first
    and last day of each week. Provide a solution based on the `Calendar` API and
    one based on the JDK 8 Date/Time API.'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**获取一周的第一天和最后一天**：假设我们有一个整数表示周数（例如，3代表从当前日期开始的连续三周）。编写一个程序，返回每周的第一天和最后一天。提供一个基于`Calendar`
    API的解决方案和一个基于JDK 8 Date/Time API的解决方案。'
- en: '**Calculating the middle of the month**: Provide an application containing
    a snippet based on the `Calendar` API, and one based on the JDK 8 Date/Time API
    for calculating the middle of the given month as a `Date`, respectively as a `LocalDate`.'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**计算月份的中间日期**：提供一个包含基于`Calendar` API的代码片段的应用程序，以及一个基于JDK 8 Date/Time API的应用程序，分别用于计算给定月份的中间日期作为一个`Date`对象，以及作为一个`LocalDate`对象。'
- en: '**Getting the number of quarters between two dates**: Let’s consider that a
    date-time range is given via two `LocalDate` instances. Write a program that counts
    the number of quarters contained in this range.'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**计算两个日期之间的季度数**：假设通过两个`LocalDate`实例给出了一个日期时间范围。编写一个程序，计算这个范围内包含的季度数。'
- en: '**Converting Calendar to** **LocalDateTime**: Write a program that converts
    the given `Calendar` into a `LocalDateTime` (default time zone), respectively
    into a `ZonedDateTime` (for the Asia/Calcutta time zone).'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**将Calendar转换为LocalDateTime**：编写一个程序，将给定的`Calendar`转换为`LocalDateTime`（默认时区），或者转换为`ZonedDateTime`（亚洲/加尔各答时区）。'
- en: '**Getting the number of weeks between two dates**: Let’s assume that we have
    a date-time range given as two `Date` instances or as two `LocalDateTime` instances.
    Write an application that returns the number of weeks contained in this range.
    For the `Date` range, write a solution based on the `Calendar` API, while for
    the `LocalDateTime` range, write a solution based on the JDK 8 Date/Time API.'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**计算两个日期之间的周数**：假设我们有一个日期时间范围，以两个`Date`实例或两个`LocalDateTime`实例给出。编写一个应用程序，返回这个范围内包含的周数。对于`Date`范围，基于`Calendar`
    API编写一个解决方案，而对于`LocalDateTime`范围，基于JDK 8 Date/Time API编写一个解决方案。'
- en: The following sections describe solutions to the preceding problems. Remember
    that there usually isn’t a single correct way to solve a particular problem. Also,
    remember that the explanations shown here include only the most interesting and
    important details needed to solve the problems. Download the example solutions
    to see additional details and to experiment with the programs at [https://github.com/PacktPublishing/Java-Coding-Problems-Second-Edition/tree/main/Chapter03](https://github.com/PacktPublishing/Java-Coding-Problems-Second-Edition/tree/main/Chapter03).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 以下部分描述了前面问题的解决方案。请记住，通常没有一种正确的方式来解决特定的问题。此外，请记住，这里所示的解释仅包括解决这些问题所需的最有趣和最重要的细节。下载示例解决方案以查看更多细节，并实验程序，请访问
    [https://github.com/PacktPublishing/Java-Coding-Problems-Second-Edition/tree/main/Chapter03](https://github.com/PacktPublishing/Java-Coding-Problems-Second-Edition/tree/main/Chapter03)。
- en: 68\. Defining a day period
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 68. 定义一天的时间段
- en: 'Let’s imagine that we want to say hello to a friend from another country (in
    a different time zone) via a message such as *Good morning*, *Good afternoon*,
    and so on based on their local time. So, having access to AM/PM flags is not enough,
    because we consider that a day (24 hours) can be represented by the following
    periods:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们想象一下，我们想要根据另一个国家（不同时区）的朋友的当地时间，通过像 *早上好*，*下午好* 等消息来向他们打招呼。所以，仅仅有 AM/PM 标志是不够的，因为我们认为一天（24
    小时）可以表示为以下时间段：
- en: 9:00 PM (or 21:00) – 5:59 AM = night
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 晚上 9:00（或 21:00）– 上午 5:59 = 夜晚
- en: 6:00 AM – 11:59 AM = morning
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 早上 6:00 – 上午 11:59 = 上午
- en: 12:00 PM – 5:59 PM (or 17:59) = afternoon
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下午 12:00 – 晚上 5:59（或 17:59）= 下午
- en: 6:00 PM (or 18:00) – 8:59 PM (or 20:59) = evening
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下午 6:00（或 18:00）– 晚上 8:59（或 20:59）= 晚上
- en: Before JDK 16
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 JDK 16 之前
- en: 'First, we have to obtain the time corresponding to our friend’s time zone.
    For this, we can start from our local time given as a `java.util.Date`, `java.time.LocalTime`,
    and so on. If we start from a `java.util.Date`, then we can obtain the time in
    our friend’s time zone as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须获得我们朋友时区对应的时间。为此，我们可以从我们的本地时间开始，给定为 `java.util.Date`，`java.time.LocalTime`
    等。如果我们从 `java.util.Date` 开始，那么我们可以按照以下方式获得我们朋友时区的时间：
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here, `date` is a `new Date()` and `zoneId` is `java.time.ZoneId`. Of course,
    we can pass the zone ID as a `String` and use the `ZoneId.of(String zoneId)` method
    to get the `ZoneId` instance.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`date` 是 `new Date()`，而 `zoneId` 是 `java.time.ZoneId`。当然，我们可以将区域 ID 作为 `String`
    传递，并使用 `ZoneId.of(String zoneId)` 方法来获取 `ZoneId` 实例。
- en: 'If we prefer to start from `LocalTime.now()`, then we can obtain the time in
    our friend’s time zone as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望从 `LocalTime.now()` 开始，那么我们可以获得我们朋友时区的时间如下：
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Next, we can define the day periods as a bunch of `LocalTime` instances and
    add some conditions to determine the current period. The following code exemplifies
    this statement:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以定义一天的时间段为一组 `LocalTime` 实例，并添加一些条件来确定当前时间段。以下代码示例说明了这一点：
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now, let’s see how we can do this in JDK 16+.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何在 JDK 16+ 中实现这一点。
- en: JDK 16+
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JDK 16+
- en: 'Starting with JDK 16+, we can go beyond AM/PM flags via the following strings:
    *in the morning*, *in the afternoon*, *in the evening*, and *at night*.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 从 JDK 16+ 开始，我们可以通过以下字符串超越 AM/PM 标志：*早上*，*下午*，*晚上* 和 *夜晚*。
- en: These friendly outputs are available via the new pattern, `B`. This pattern
    is available starting with JDK 16+ via `DateTimeFormatter` and `DateTimeFormatterBuilder`
    (you should be familiar with these APIs from *Chapter 1*, *Problem 18*, shown
    in *Figure 1.18*).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这些友好的输出可以通过新的模式 `B` 获取。这个模式从 JDK 16+ 开始通过 `DateTimeFormatter` 和 `DateTimeFormatterBuilder`
    可用（你应该熟悉这些 API，如 *第 1 章*，*问题 18*，在 *图 1.18* 中所示）。
- en: 'So, the following code uses the `DateTimeFormatter` to exemplify the usage
    of pattern `B`, representing a period of the day:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，以下代码使用 `DateTimeFormatter` 来举例说明模式 `B` 的使用，表示一天中的时间段：
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Here is an output for Australia/Melbourne:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是澳大利亚/墨尔本的一个输出示例：
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You can see more examples in the bundled code. Feel free to challenge yourself
    to adjust this code to reproduce the result from the first example.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在捆绑的代码中看到更多示例。请随意挑战自己调整此代码以重现第一个示例的结果。
- en: 69\. Converting between Date and YearMonth
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 69. 日期与 YearMonth 之间的转换
- en: 'Converting a `java.util.Date` to JDK 8 `java.time.YearMonth` can be done based
    on `YearMonth.from(TemporalAccessor temporal)`. A `TemporalAccessor` is an interface
    (more precisely, a framework-level interface) that exposes read-only access to
    any temporal object including date, time, and offset (a combination of these is
    also allowed). So, if we convert the given `java.util.Date` to `java.time.LocalDate`,
    then the result of the conversion can be passed to `YearMonth.from()` as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `java.util.Date` 转换为 JDK 8 的 `java.time.YearMonth` 可以基于 `YearMonth.from(TemporalAccessor
    temporal)` 实现。`TemporalAccessor` 是一个接口（更确切地说，是一个框架级接口），它提供了对任何时间对象的只读访问，包括日期、时间和偏移量（这些的组合也是允许的）。因此，如果我们把给定的
    `java.util.Date` 转换为 `java.time.LocalDate`，那么转换的结果可以传递给 `YearMonth.from()` 如下所示：
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Vice versa can be obtained via `Date.from(Instant instant)` as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 反过来可以通过 `Date.from(Instant instant)` 获取，如下所示：
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Well, that was easy, wasn’t it?
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这很简单，不是吗？
- en: 70\. Converting between int and YearMonth
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 70. 在 int 和 YearMonth 之间进行转换
- en: 'Consider that we have `YearMonth.now()` and we want to convert it to an integer
    (for example, this can be useful for storing a year/month date in a database using
    a numeric field). Check out the solution:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有 `YearMonth.now()`，我们想将其转换为整数（例如，这可能在将年/月日期存储在数据库的数字字段中时很有用）。查看以下解决方案：
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The *proleptic-month* is a `java.time.temporal.TemporalField`, which basically
    represents a date-time field such as *month-of-year* (our case) or *minute-of-hour*.
    The proleptic-month starts from 0 and counts the months sequentially from year
    0\. So, `getLong()` returns the value of the specified field (here, the proleptic-month)
    from this year-month as a `long`. We can cast this `long` to `int` since the proleptic-month
    shouldn’t go beyond the `int` domain (for instance, for 2023/2 the returned `int`
    is 24277).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '*proleptic-month* 是一个 `java.time.temporal.TemporalField`，它基本上代表一个日期时间字段，如 *year-of-month*（我们的情况）或
    *minute-of-hour*。proleptic-month 从 0 开始，并按顺序从年份 0 计算月份。因此，`getLong()` 返回从今年月份中指定的字段（在这里是
    proleptic-month）的值作为一个 `long`。我们可以将这个 `long` 强制转换为 `int`，因为 proleptic-month 不应该超出
    `int` 范围（例如，对于 2023/2 返回的 `int` 是 24277）。'
- en: 'Vice versa can be accomplished as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 反过来可以通过以下方式完成：
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: You can start from any year/month. The 1970/1 (known as the *epoch* and the
    starting point for `java.time.Instant`) choice was just an arbitrary choice.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从任何年/月开始。1970/1（称为 *epoch* 和 `java.time.Instant` 的起点）的选择只是一个任意的选择。
- en: 71\. Converting week/year to Date
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 71. 将周/年转换为 Date
- en: 'Let’s consider the year 2023, week 10\. The corresponding date is Sun Mar 05
    15:15:08 EET 2023 (of course, the time component is relative). Converting the
    year/week to `java.util.Date` can be done via the `Calendar` API as in the following
    self-explanatory snippet of code:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑 2023 年，第 10 周。相应的日期是 Sun Mar 05 15:15:08 EET 2023（当然，时间部分是相对的）。将年/周转换为
    `java.util.Date` 可以通过 `Calendar` API 实现，如下所示的自解释代码片段：
- en: '[PRE9]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If you prefer to obtain a `LocalDate` instead of a `Date` then you can easily
    perform the corresponding conversion or you can rely on `java.time.temporal.WeekFields`.
    This API exposes several fields for working with *week-of-year*, *week-of-month*,
    and *day-of-week*. This being said, here is the previous solution written via
    `WeekFields` to return a `LocalDate`:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你更喜欢获取 `LocalDate` 而不是 `Date`，那么你可以轻松地进行相应的转换，或者你可以依赖 `java.time.temporal.WeekFields`。这个
    API 提供了用于处理 *year-of-week*、*month-of-week* 和 *day-of-week* 的几个字段。话虽如此，以下是通过 `WeekFields`
    编写的先前解决方案，用于返回 `LocalDate`：
- en: '[PRE10]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'On the other hand, if we have a `java.util.Date` and we want to extract the
    year and the week from it, then we can use the `Calendar` API. Here, we extract
    the year:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果我们有一个 `java.util.Date`，我们想从中提取年和周，那么我们可以使用 `Calendar` API。在这里，我们提取年份：
- en: '[PRE11]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'And here, we extract the week:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们提取周：
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Getting the year and the week from a `LocalDate` is easy thanks to `ChronoField.YEAR`
    and `ChronoField.ALIGNED_WEEK_OF_YEAR`:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `ChronoField.YEAR` 和 `ChronoField.ALIGNED_WEEK_OF_YEAR`，从 `LocalDate` 中获取年和周很容易：
- en: '[PRE13]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Of course, getting the week can be accomplished via `WeekFields` as well:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，获取周也可以通过 `WeekFields` 实现：
- en: '[PRE14]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Challenge yourself to obtain week/month and day/week from a `Date`/`LocalDate`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 挑战自己从 `Date`/`LocalDate` 中获取周/月和日/周。
- en: 72\. Checking for a leap year
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 72. 检查闰年
- en: 'This problem becomes easy as long as we know what a leap year is. In a nutshell,
    a leap year is any year divisible by 4 (so, `year % 4 == 0`) that it is not a
    century (for instance, 100, 200, …, n00). However, if the year represents a century
    that is divisible by 400 (so, `year % 400 == 0`), then it is a leap year. In this
    context, our code is just a simple chain of `if` statements as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 只要我们知道了什么是闰年，这个问题就变得简单了。简而言之，闰年是指任何可以被4整除的年份（即`year % 4 == 0`），且不是世纪年（例如，100，200，……，n00）。然而，如果这个世纪年可以被400整除（即`year
    % 400 == 0`），那么它就是一个闰年。在这种情况下，我们的代码只是一个简单的`if`语句链，如下所示：
- en: '[PRE15]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'But, this code can be condensed using the `GregorianCalendar` as well:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，这段代码可以使用`GregorianCalendar`来简化：
- en: '[PRE16]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Or, starting with JDK 8, we can rely on the `java.time.Year` API as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，从JDK 8开始，我们可以依赖于`java.time.Year` API，如下所示：
- en: '[PRE17]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the bundled code, you can see more approaches.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在捆绑的代码中，你可以看到更多的方法。
- en: 73\. Calculating the quarter of a given date
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 73. 计算给定日期的季度
- en: A year has 4 quarters (commonly denoted as Q1, Q2, Q3, and Q4) and each quarter
    has 3 months. If we consider that January is 0, February is 1, …, and December
    is 11, then we can observe that January/3 = 0, February/3 =0, March/3 = 0, and
    0 can represent Q1\. Next, 3/3 = 1, 4/3 = 1, 5/3 = 1, so 1 can represent Q2\.
    Based on the same logic, 6/3 = 2, 7/3 = 2, 8/3 = 2, so 2 can represent Q3\. Finally,
    9/3 = 3, 10/3 = 3, 11/3 = 3, so 3 represents Q4.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 一年有4个季度（通常表示为Q1，Q2，Q3和Q4），每个季度有3个月。如果我们考虑1月是0，2月是1，……，12月是11，那么我们可以观察到1月/3 =
    0，2月/3 = 0，3月/3 = 0，0可以代表Q1。接下来，3/3 = 1，4/3 = 1，5/3 = 1，所以1可以代表Q2。基于同样的逻辑，6/3
    = 2，7/3 = 2，8/3 = 2，所以2可以代表Q3。最后，9/3 = 3，10/3 = 3，11/3 = 3，所以3代表Q4。
- en: 'Based on this statement and the `Calendar` API, we can obtain the following
    code:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这个声明和`Calendar` API，我们可以获得以下代码：
- en: '[PRE18]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'But, starting with JDK 8, we can rely on `java.time.temporal.IsoFields`. This
    class contains fields (and units) that follow the calendar system based on the
    ISO-8601 standard. Among these artifacts, we have the *week-based-year* and the
    one that we are interested in, *quarter-of-year*. This time, let’s return the
    quarter as an integer:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 但从JDK 8开始，我们可以依赖于`java.time.temporal.IsoFields`。这个类包含基于ISO-8601标准的日历系统中的字段（和单位）。在这些元素中，我们有基于周的年份和我们所感兴趣的*年份季度*。这次，让我们将季度作为整数返回：
- en: '[PRE19]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In the bundled code, you can see more examples including one that uses `DateTimeFormatter.ofPattern("QQQ")`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在捆绑的代码中，你可以看到更多示例，包括一个使用`DateTimeFormatter.ofPattern("QQQ")`的示例。
- en: 74\. Getting the first and last day of a quarter
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 74. 获取一个季度的第一天和最后一天
- en: 'Let’s assume that we represent the first and last day of a quarter via this
    simple class:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们假设我们通过这个简单的类来表示一个季度的第一天和最后一天：
- en: '[PRE20]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Next, we have a `java.util.Date` and we want the first and the last day of
    the quarter containing this date. For this, we can use JDK 8’s `IsoFields.DAY_OF_QUARTER`
    (we introduced `IsoFields` in the previous problem). But, before we can use `IsoFields`,
    we have to convert the given `java.util.Date` to a `LocalDate` as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有一个`java.util.Date`，我们想要获取包含这个日期的季度的第一天和最后一天。为此，我们可以使用JDK 8的`IsoFields.DAY_OF_QUARTER`（我们在前一个问题中介绍了`IsoFields`）。但在我们能够使用`IsoFields`之前，我们必须将给定的`java.util.Date`转换为`LocalDate`，如下所示：
- en: '[PRE21]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Once we have the given `Date` as a `LocalDate`, we can easily extract the first
    day of the quarter via `IsoFields.DAY_OF_QUARTER`. Next, we add 2 months to this
    day to move into the last month of the quarter (a quarter has 3 months, so a year
    has 4 quarters) and we rely on `java.time.temporal.TemporalAdjusters`, more precisely
    on `lastDayOfMonth()` to obtain the last day of the quarter. Finally, we convert
    the two obtained `LocalDate` instances to `Date` instances. Here is the complete
    code:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了给定的`Date`作为`LocalDate`，我们就可以通过`IsoFields.DAY_OF_QUARTER`轻松地提取季度的第一天。接下来，我们将2个月加到这一天，进入季度的最后一个月（一个季度有3个月，所以一年有4个季度），我们依赖于`java.time.temporal.TemporalAdjusters`，更确切地说，依赖于`lastDayOfMonth()`来获取季度的最后一天。最后，我们将两个获得的`LocalDate`实例转换为`Date`实例。以下是完整的代码：
- en: '[PRE22]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Of course, these conversions are not needed if you work directly with `LocalDate`.
    But, this way, you have a chance to learn more.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果你直接使用`LocalDate`，这些转换就不需要了。但这样，你就有机会学习更多。
- en: In the bundled code, you can find more examples, including one that relies entirely
    on the `Calendar` API.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在捆绑的代码中，你可以找到更多示例，包括一个完全依赖于`Calendar` API的示例。
- en: 75\. Extracting the months from a given quarter
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 75. 从给定的季度中提取月份
- en: This problem becomes quite easy to solve if we are familiar with JDK 8’s `java.time.Month`.
    Via this API, we can find the first month (0 for January, 1 for February, …) of
    a quarter containing the given `LocalDate` as `Month.from(LocalDate).firstMonthOfQuarter().getValue()`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们熟悉JDK 8的`java.time.Month`，这个问题就变得相当容易解决。通过这个API，我们可以找到包含给定`LocalDate`的季度的第一个月（1月为0，2月为1，……），即`Month.from(LocalDate).firstMonthOfQuarter().getValue()`。
- en: 'Once we have the first month, it is easy to obtain the other two as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了第一个月，很容易获得其他两个，如下所示：
- en: '[PRE23]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'How about passing the quarter itself as an argument? This can be done as a
    number (1, 2, 3, or 4) or as a string (Q1, Q2, Q3, or Q4). If the given `quarter`
    is a number, then the first month of the quarter can be obtained as `quarter`
    * 3 – 2, where the `quarter` is 1, 2, 3, or 4\. This time, let’s express the code
    in a functional style:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 关于将季度本身作为参数传递，这可以通过数字（1、2、3或4）或字符串（Q1、Q2、Q3或Q4）来实现。如果给定的`quarter`是数字，那么季度的第一个月可以通过`quarter
    * 3 – 2`来获得，其中`quarter`是1、2、3或4。这次，让我们以函数式风格表达代码：
- en: '[PRE24]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Of course, if you find it more concise, then you can use `IntStream.range(qmonth,
    qmonth+2)` instead of `IntStream.of()`. In the bundled, code you can find more
    examples.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果你觉得更简洁，那么你可以使用`IntStream.range(qmonth, qmonth+2)`而不是`IntStream.of()`。在捆绑的代码中，你可以找到更多示例。
- en: 76\. Computing pregnancy due date
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 76. 计算预产期
- en: 'Let’s start with these two constants:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从这两个常数开始：
- en: '[PRE25]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Let’s consider the first day as a `LocalDate` and we want to write a calculator
    that prints the pregnancy due date, the number of remaining days, the number of
    passed days, and the current week.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将第一天视为一个`LocalDate`，并编写一个计算器，打印预产期、剩余天数、已过天数和当前周数。
- en: 'Basically, the pregnancy due date is obtained by adding the `PREGNANCY_DAYS`
    to the given first day. Further, the number of remaining days is the difference
    between today and the given first day, while the number of passed days is `PREGNANCY_DAYS`
    minus the number of remaining days. Finally, the current week is obtained as the
    number of passed days divided by 7 (since a week has 7 days). Based on these statements,
    the code speaks for itself:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，预产期是通过将`PREGNANCY_DAYS`加到给定第一天来获得的。进一步，剩余天数是今天和给定第一天之间的差值，而已过天数是`PREGNANCY_DAYS`减去剩余天数。最后，当前周数是通过将已过天数除以7（因为一周有7天）来获得的。基于这些陈述，代码自解释：
- en: '[PRE26]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: See if you can think of a way to use this to calculate another important date.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 看看你是否能想到一种方法来计算另一个重要的日期。
- en: 77\. Implementing a stopwatch
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 77. 实现一个计时器
- en: A classical implementation for a stopwatch relies on `System.nanoTime()`, `System.currentTimeMillis()`,
    or on `Instant.now()`. In all cases, we have to provide support for starting and
    stopping the stopwatch, and some helpers to obtain the measured time in different
    time units.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 一个经典的计时器实现依赖于`System.nanoTime()`、`System.currentTimeMillis()`或`Instant.now()`。在所有情况下，我们必须提供启动和停止计时器的支持，以及一些辅助函数来以不同的时间单位获取测量的时间。
- en: 'While the solutions based on `Instant.now()` and `currentTimeMillis()` are
    available in the bundled code, here we’ll show the one based on `System.nanoTime()`:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然基于`Instant.now()`和`currentTimeMillis()`的解决方案在捆绑代码中可用，但这里我们将展示基于`System.nanoTime()`的解决方案：
- en: '[PRE27]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'If you need to return the measured time in milliseconds or seconds as well,
    then simply add the following two helpers:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要以毫秒或秒为单位返回测量的时间，那么只需添加以下两个辅助函数：
- en: '[PRE28]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This approach is based on `System.nanoTime()` for measuring the elapsed time
    with high accuracy. This approach returns a high-resolution time in nanoseconds
    that doesn’t rely on a system clock or any other wall clock (as `Instant.now()`
    or `System.currentTimeMillis()` does), so it is not exposed to common issues of
    wall clocks such as leap second, time uniformity, synchronicity issues, and so
    on.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法基于`System.nanoTime()`来测量高精度的经过时间。这种方法返回以纳秒为单位的分辨率高的时间，不依赖于系统时钟或任何其他墙钟（如`Instant.now()`或`System.currentTimeMillis()`），因此它不受墙钟常见问题的影响，如闰秒、时间均匀性、同步性问题等。
- en: Whenever you need a professional tool for measuring elapsed time, rely on Micrometer
    ([https://micrometer.io/](https://micrometer.io/)), JMH ([https://openjdk.org/projects/code-tools/jmh/](https://openjdk.org/projects/code-tools/jmh/)),
    Gatling ([https://gatling.io/open-source/](https://gatling.io/open-source/)),
    and so on.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 无论何时你需要一个专业的测量经过时间的工具，请依赖Micrometer ([https://micrometer.io/](https://micrometer.io/))、JMH
    ([https://openjdk.org/projects/code-tools/jmh/](https://openjdk.org/projects/code-tools/jmh/))、Gatling
    ([https://gatling.io/open-source/](https://gatling.io/open-source/))等等。
- en: 78\. Extracting the count of milliseconds since midnight
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 78. 提取自午夜以来的毫秒数
- en: 'So, we have a date-time (let’s say a `LocalDateTime` or `LocalTime`) and we
    want to know how many milliseconds have passed from midnight to this date-time.
    Let’s consider that the given date-time is right now:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们有一个日期时间（让我们假设是一个 `LocalDateTime` 或 `LocalTime`），我们想知道从午夜到这个日期时间已经过去了多少毫秒。让我们考虑给定的日期时间是现在：
- en: '[PRE29]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Midnight is relative to `now`, so we can find the difference as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 午夜相对于 `now` 是相对的，因此我们可以找到以下差异：
- en: '[PRE30]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Finally, compute the difference in milliseconds between midnight and now. This
    can be accomplished in several ways, but probably the most concise solution relies
    on `java.time.temporal.ChronoUnit`. This API exposes a set of units useful to
    manipulate a date, time, or date-time including milliseconds:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，计算午夜和现在之间的差异（以毫秒为单位）。这可以通过多种方式完成，但可能最简洁的解决方案依赖于 `java.time.temporal.ChronoUnit`。此
    API 提供了一组用于操作日期、时间或日期时间的单位，包括毫秒：
- en: '[PRE31]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In the bundled code, you can see more examples of `ChronoUnit`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在捆绑的代码中，你可以看到更多关于 `ChronoUnit` 的示例。
- en: 79\. Splitting a date-time range into equal intervals
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 79. 将日期时间范围分割成等间隔
- en: 'Let’s consider a date-time range (bounded by a start date and an end date represented
    by two `LocalDateTime` instances) and an integer `n`. In order to split the given
    range into `n` equal intervals, we start by defining a `java.time.Duration` as
    follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个日期时间范围（由两个 `LocalDateTime` 实例表示的起始日期和结束日期界定）和一个整数 `n`。为了将给定的范围分割成 `n`
    个等间隔，我们首先定义一个 `java.time.Duration` 如下：
- en: '[PRE32]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Having this date-time range, we can rely on `dividedBy()` to obtain a copy
    of it divided by the specified `n`:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个日期时间范围，我们可以依赖 `dividedBy()` 来获取它的一个副本，该副本被指定为 `n` 分割：
- en: '[PRE33]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Finally, we can begin from the start date (the left head of the range) and
    repeatedly increment it with the `interval` value until we reach the end date
    (the right head of the range). After each step, we store the new date in a list
    that will be returned at the end. Here is the complete code:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以从起始日期（范围的左端头）开始，并反复用 `interval` 值增加它，直到我们达到结束日期（范围的右端头）。在每一步之后，我们将新的日期存储在一个列表中，该列表将在最后返回。以下是完整的代码：
- en: '[PRE34]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The resulting `listOfDates` will contain `n` dates at equal intervals.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 结果的 `listOfDates` 将包含 `n` 个等间隔的日期。
- en: 80\. Explaining the difference between Clock.systemUTC() and Clock.systemDefaultZone()
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 80. 解释 Clock.systemUTC() 和 Clock.systemDefaultZone() 之间的差异
- en: 'Let’s start with the following three lines of code:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从以下三行代码开始：
- en: '[PRE35]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The output reveals that the first two lines are similar. Both of them display
    the default time zone (in my case, Europe/Bucharest):'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示前两行是相似的。它们都显示了默认时区（在我的情况下，是欧洲/布加勒斯特）：
- en: '[PRE36]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The third line is different. Here, we see `Z` time zone, which is specific
    to the UTC time zone and indicates the presence of a zone offset:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 第三行是不同的。在这里，我们看到 `Z` 时区，它是特定于 UTC 时区的，表示存在时区偏移：
- en: '[PRE37]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'On the other hand, creating an `Instant` reveals that `Clock.systemUTC()` and
    `Clock.systemDefaultZone()` produce the same result:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，创建一个 `Instant` 显示 `Clock.systemUTC()` 和 `Clock.systemDefaultZone()` 产生相同的结果：
- en: '[PRE38]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The instant time is the same in all three cases:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在这三种情况下，瞬时时间都是相同的：
- en: '[PRE39]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'But, the difference occurs when we try to create a date, time, or date-time
    from these two clocks. For instance, let’s create a `LocalDateTime` from `Clock.systemUTC()`:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，当我们尝试从这两个时钟创建日期、时间或日期时间时，差异就出现了。例如，让我们从 `Clock.systemUTC()` 创建一个 `LocalDateTime`：
- en: '[PRE40]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'And, a `LocalDateTime` from `Clock.systemDefaultZone()`:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 以及，从 `Clock.systemDefaultZone()` 创建一个 `LocalDateTime`：
- en: '[PRE41]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: My time (default time zone, Europe/Bucharest) is 07:26:17\. But, the time via
    `Clock.systemUTC()` is 05:26:17\. This is because Europe/Bucharest is at an offset
    of UTC-2, so `systemUTC()` produces the date-time in the UTC time zone, while
    `systemDefaultZone()` produces the date-time in the current default time zone.
    However, both of them produce the same `Instant`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我的时区（默认时区，欧洲/布加勒斯特）是 07:26:17。但是，通过 `Clock.systemUTC()` 的时间是 05:26:17。这是因为欧洲/布加勒斯特位于
    UTC-2 的偏移量，所以 `systemUTC()` 产生 UTC 时区的日期时间，而 `systemDefaultZone()` 产生当前默认时区的日期时间。然而，它们都产生了相同的
    `Instant`。
- en: 81\. Displaying the names of the days of the week
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 81. 显示星期几的名称
- en: One of the hidden gems in Java is `java.text.DateFormatSymbols`. This class
    is a wrapper for date-time formatting data such as the names of the days of the
    week, and the names of the months. All these names are localizable.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: Java 中的一颗隐藏的宝石是 `java.text.DateFormatSymbols`。这个类是日期时间格式化数据（如星期几的名称和月份的名称）的包装器。所有这些名称都是可本地化的。
- en: 'Typically, you will use `DateFormatSymbols` via a `DateFormat` such as `SimpleDateFormat`,
    but in order to solve this problem, we can use it directly as in the following
    code:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，您会通过 `DateFormat`（如 `SimpleDateFormat`）使用 `DateFormatSymbols`，但为了解决这个问题，我们可以直接使用它，如下面的代码所示：
- en: '[PRE42]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'This code will output the weekdays’ names as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将按以下方式输出星期的名称：
- en: '[PRE43]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Challenge yourself to come up with another solution.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 挑战自己，想出另一种解决方案。
- en: 82\. Getting the first and last day of the year
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 82. 获取年的第一天和最后一天
- en: 'Getting the first and last day of the given year (as a numeric value) can be
    done via `LocalDate` and the handy `TemporalAdjusters`, `firstDayOfYear()`, and
    `lastDayOfYear()`. First, we create a `LocalDate` from the given year. Next, we
    use this `LocalDate` with `firstDayOfYear()`/`lastDayOfYear()` as in the following
    code:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 获取给定年份（作为数值）的第一天和最后一天可以通过 `LocalDate` 和方便的 `TemporalAdjusters`，`firstDayOfYear()`
    和 `lastDayOfYear()` 实现。首先，我们从给定年份创建一个 `LocalDate`。接下来，我们使用这个 `LocalDate` 与 `firstDayOfYear()`/`lastDayOfYear()`
    结合，如下面的代码所示：
- en: '[PRE44]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'And, for the last day, the code is almost similar:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 对于最后一天，代码几乎相同：
- en: '[PRE45]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: If the flag argument (`name`) is `false`, then we return the first/last day
    via `LocalDate.toString()`, so we will get something like 2020-01-01 (the first
    day of 2020) and 2020-12-31 (the last day of 2020). If this flag argument is `true`,
    then we rely on the `EEEE` pattern to return only the name of the first/last day
    of the year as Wednesday (the first day of 2020) and Thursday (the last day of
    2020).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如果标志参数（`name`）为 `false`，则我们通过 `LocalDate.toString()` 返回第一/最后一天，因此我们将得到类似 2020-01-01（2020年的第一天）和
    2020-12-31（2020年的最后一天）的结果。如果这个标志参数为 `true`，则我们依赖于 `EEEE` 模式来返回年份的第一/最后一天的名字，例如星期三（2020年的第一天）和星期四（2020年的最后一天）。
- en: In the bundle code, you can also find a solution to this problem via the `Calendar`
    API.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在捆绑的代码中，您还可以找到一个基于 `Calendar` API 的解决方案。
- en: 83\. Getting the first and last day of the week
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 83. 获取周的第一天和最后一天
- en: 'Let’s assume given an integer (`nrOfWeeks`) representing the number of weeks
    that we want to extract the first and last day of each week starting from now.
    For instance, for the given `nrOfWeeks` = 3 and a local date such as 06/02/2023,
    we want this:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 假设给定一个整数（`nrOfWeeks`）表示我们想要提取从现在开始每周的第一天和最后一天的周数。例如，对于给定的 `nrOfWeeks` = 3 和一个本地日期，例如
    06/02/2023，我们想要这样：
- en: '[PRE46]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This is much easier than it might seem. We just need a loop from 0 to `nrOfWeeks`
    and two `TemporalAdjusters` to fit the first/last day of each week. More precisely,
    we need the `nextOrSame(DayOfWeek dayOfWeek)` and `previousOrSame(DayOfWeek dayOfWeek)`
    adjusters.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这比看起来要简单得多。我们只需要从 0 到 `nrOfWeeks` 的循环，以及两个 `TemporalAdjusters` 来适应每周的第一天/最后一天。更确切地说，我们需要
    `nextOrSame(DayOfWeek dayOfWeek)` 和 `previousOrSame(DayOfWeek dayOfWeek)` 调整器。
- en: The `nextOrSame()` adjuster’s role is to adjust the current date to the first
    occurrence of the given *day of week* after the date being adjusted (this can
    be *next or same*). On the other hand, the `previousOrSame()` adjuster’s role
    is to adjust the current date to the first occurrence of the given *day of week*
    before the date being adjusted (this can be *previous or same*). For instance,
    if today is [Tuesday 07/02/2023], then `previousOrSame(DayOfWeek.MONDAY)` will
    return [Monday 06/02/2023], and `nextOrSame(DayOfWeek.SUNDAY)` will return [Sunday
    12/02/2023].
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`nextOrSame()` 调整器的角色是将当前日期调整为调整日期之后给定 *星期几* 的首次出现（这可以是 *下个或相同*）。另一方面，`previousOrSame()`
    调整器的角色是将当前日期调整为调整日期之前给定 *星期几* 的首次出现（这可以是 *之前或相同*）。例如，如果今天是 [星期二 07/02/2023]，那么
    `previousOrSame(DayOfWeek.MONDAY)` 将返回 [星期一 06/02/2023]，而 `nextOrSame(DayOfWeek.SUNDAY)`
    将返回 [星期日 12/02/2023]。'
- en: 'Based on these statements, we can solve our problem via the following code:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这些陈述，我们可以通过以下代码解决问题：
- en: '[PRE47]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: In the bundled code, you can also see a solution based on the `Calendar` API.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在捆绑的代码中，您还可以看到一个基于 `Calendar` API 的解决方案。
- en: 84\. Calculating the middle of the month
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 84. 计算月份中旬
- en: 'Let’s imagine that we have a `LocalDate` and we want to calculate from it another
    `LocalDate` representing the middle of the month. This can be achieved in seconds
    if we know that the `LocalDate` API has a method named `lengthOfMonth()`, which
    returns an integer representing the length of the month in days. So, all we have
    to do is calculate `lengthOfMonth()`/2 as in the following code:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们想象我们有一个 `LocalDate`，我们想要从它计算出代表月份中旬的另一个 `LocalDate`。如果我们知道 `LocalDate` API
    有一个名为 `lengthOfMonth()` 的方法，它返回一个表示月份天数的整数，那么这可以在几秒钟内完成。所以，我们只需要计算 `lengthOfMonth()`/2，如下面的代码所示：
- en: '[PRE48]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: In the bundled code, you can see a solution based on the `Calendar` API.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在捆绑的代码中，您可以看到一个基于 `Calendar` API 的解决方案。
- en: 85\. Getting the number of quarters between two dates
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 85. 获取两个日期之间的季度数
- en: 'This is just another problem that requires us to have a deep grasp of the Java
    Date/Time API. This time, we talk about `java.time.temporal.IsoFields`, which
    was introduced in *Problem 73*. One of the ISO fields is `QUARTER_YEARS`, which
    is a temporal unit representing the concept of a *quarter-year*. So, having two
    `LocalDate` instances, we can write this:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是另一个需要我们深入掌握 Java 日期/时间 API 的问题。这次，我们要讨论的是 `java.time.temporal.IsoFields`，它在
    *问题 73* 中被引入。ISO 字段之一是 `QUARTER_YEARS`，它是一个表示 *季度* 概念的时间单位。因此，拥有两个 `LocalDate`
    实例，我们可以写出以下代码：
- en: '[PRE49]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Feel free to challenge yourself to provide a solution for `java.util.Date`/`Calendar`.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 随意挑战自己，为 `java.util.Date`/`Calendar` 提供解决方案。
- en: 86\. Converting Calendar to LocalDateTime
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 86. 将 Calendar 转换为 LocalDateTime
- en: 'In *Problem 68*, you saw that converting a `java.util.Date` (date) to a `LocalTime`
    can be done as follows:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *问题 68* 中，你看到将 `java.util.Date`（日期）转换为 `LocalTime` 可以如下进行：
- en: '[PRE50]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'In the same manner, we can convert a `java.util.Date` to a `LocalDateTime`
    (here, `zoneId` was replaced with `ZoneId.systemDefault()`):'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 以同样的方式，我们可以将 `java.util.Date` 转换为 `LocalDateTime`（这里，`zoneId` 被替换为 `ZoneId.systemDefault()`）：
- en: '[PRE51]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'We also know that we can obtain a `java.util.Date` from a `Calendar` via the
    `getTime()` method. So, by gluing the pieces of the puzzle together, we obtain
    the following code:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还知道，我们可以通过 `getTime()` 方法从 `Calendar` 获取 `java.util.Date`。因此，通过拼凑拼图碎片，我们得到以下代码：
- en: '[PRE52]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The same result but following a shorter path can be obtained like this:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过以下更简短的路径获得相同的结果：
- en: '[PRE53]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Or, even shorter, like this:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，甚至更短，如下所示：
- en: '[PRE54]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'But, this code assumes that the time zone of the given `Calendar` is the default
    time zone. If the calendar has a different time zone (for instance, Asia/Calcutta),
    then we might expect back a `ZonedDateTime` instead of a `LocalDateTime`. This
    means that we should adjust the previous code accordingly:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，此代码假设给定 `Calendar` 的时间区域是默认时间区域。如果日历有不同的时区（例如，亚洲/加尔各答），那么我们可能会期望返回 `ZonedDateTime`
    而不是 `LocalDateTime`。这意味着我们应该相应地调整之前的代码：
- en: '[PRE55]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Again, some shorter versions are available, but we’ve not shown these as they
    are less expressive:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，有一些更简短的版本可用，但我们没有展示这些，因为它们表达性较差：
- en: '[PRE56]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Done!
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 完成！
- en: 87\. Getting the number of weeks between two dates
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 87. 获取两个日期之间的周数
- en: 'If the given two dates are instances of `LocalDate`(`Time`), then we can rely
    on `java.time.temporal.ChronoUnit`. This API exposes a set of units useful to
    manipulate a date, time, or date-time and we have used it before in *Problem 78*.
    This time, let’s use it again to compute the number of weeks between two dates:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如果给定的两个日期是 `LocalDate`（`Time`）的实例，那么我们可以依赖 `java.time.temporal.ChronoUnit`。此
    API 提供了一组用于操作日期、时间或日期时间的单元，我们之前在 *问题 78* 中已经使用过。这次，让我们再次使用它来计算两个日期之间的周数：
- en: '[PRE57]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'On the other hand, if the given dates are `java.util.Date`, then you can choose
    to convert them to `LocalDateTime` and use the previous code or to rely on the
    `Calendar` API. Using the `Calendar` API is about looping from the start date
    to the end date while incrementing the calendar date week by week:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果给定的日期是 `java.util.Date`，那么你可以选择将它们转换为 `LocalDateTime` 并使用之前的代码，或者依赖于
    `Calendar` API。使用 `Calendar` API 是从开始日期到结束日期循环，每周递增日历日期：
- en: '[PRE58]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: When the calendar date is after the end date, we have the number of weeks.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 当日历日期超过结束日期时，我们就有周数了。
- en: Summary
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Mission accomplished! I hope you enjoyed this short chapter filled to the brim
    with tips and tricks about manipulating date-time in real-world applications.
    I strongly encourage you to also read the homologous chapter from *Java Coding
    Problems*, *First Edition*, which contains another 20 problems covering other
    date-time topics.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 任务完成！我希望你喜欢这个充满技巧和窍门的简短章节，这些技巧和窍门关于在现实世界应用程序中操作日期和时间。我强烈建议你阅读来自 *Java 编程问题*，*第一版*
    的同类型章节，其中包含另外 20 个涵盖其他日期/时间主题的问题。
- en: Join our community on Discord
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的 Discord 社区
- en: 'Join our community’s Discord space for discussions with the author and other
    readers:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们社区的 Discord 空间，与作者和其他读者进行讨论：
- en: '[https://discord.gg/8mgytp5DGQ](https://discord.gg/8mgytp5DGQ )'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://discord.gg/8mgytp5DGQ](https://discord.gg/8mgytp5DGQ )'
- en: '![](img/QR_Code1139613064111216156.png)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code1139613064111216156.png)'
