- en: Operational Patterns
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作模式
- en: 'In this chapter, we will explore operational patterns, focusing in particular
    on why we use them and how they impact application projects. We will then cover
    performance and scalability patterns as well as management and monitoring patterns.
    After reading this chapter, we will have learned about the concept of operational
    patterns. The topics we will cover in this chapter are as follows:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨操作模式，特别是关注为什么我们使用它们以及它们如何影响应用项目。然后，我们将涵盖性能和可扩展性模式以及管理和监控模式。阅读本章后，我们将了解操作模式的概念。本章将涵盖以下主题：
- en: The concept of operational patterns
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作模式的概念
- en: The concept of performance and scalability patterns
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能和可扩展性模式的概念
- en: The concept of management and monitoring patterns
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理和监控模式的概念
- en: Explaining the concept of operational patterns
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解释操作模式的概念
- en: 'To solve a problem successfully, we need to evaluate a number of important
    steps so as to ensure that the chance of error is minimized. These steps are as
    follows:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 要成功解决问题，我们需要评估多个重要步骤，以确保错误的可能性最小化。这些步骤如下：
- en: Correctly identifying the problem
  id: totrans-7
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正确识别问题
- en: Defining the operations needed to solve the problem
  id: totrans-8
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义解决问题的操作
- en: Developing the operations needed to solve the problem
  id: totrans-9
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开发解决问题的操作
- en: In a business environment, both in an application project and in other areas,
    responding to problems quickly is integral to the success of a task. It is also
    important that we create a well-defined process for solving problems that will
    increase the chance of success, keep our work organized, and result in a more
    reliable solution.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在商业环境中，无论是在应用项目中还是在其他领域，快速响应问题是任务成功的关键。同时，我们还需要创建一个定义明确的解决问题流程，这将增加成功的可能性，使我们的工作更有条理，并导致更可靠的解决方案。
- en: In the first step, as mentioned previously,we identify the problem that needs
    to be resolved. Here, it is very important to define the boundaries of the problem
    and to assess whether or not the identified issue is indeed the problem.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一步，如前所述，我们确定需要解决的问题。在这里，定义问题的边界以及评估所识别的问题是否确实是问题，这一点非常重要。
- en: Next, we define a high-level solution to the problem. In this step, the solution
    will be described, but without worrying about how it will be implemented. Instead,
    we focus on the threads or operations of the solution at a high level of thought. High-level,
    middle-level, and low-level thought refers to the degree of generic thinking,
    where high-level thinking is more generic than middle-level, which, in turn, is
    more generic than low-level.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们为问题定义一个高级解决方案。在这一步，解决方案将被描述，但无需担心如何实现。相反，我们关注在较高层次思想中的解决方案的线索或操作。高级、中级和低级思想指的是通用思考的程度，其中高级思想比中级更通用，而中级思想又比低级思想更通用。
- en: In the third step, we develop the operations needed to solve the problems. In
    this step, the work is more practical, so we need to work with a middle and low
    level of thought.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在第三步，我们开发出解决问题的操作。在这一步，工作更加实际，因此我们需要以中低层次的思想进行工作。
- en: The operational patterns work by promoting common high-level solutions to problems
    that occur repeatedly. However, although operational patterns describe solutions
    to a problem, they don't care about how the solutions are developed. These patterns
    therefore help us to simplify the problem and its solution and then define a good,
    executable process.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 操作模式通过促进对重复出现的问题的常见高级解决方案来工作。然而，尽管操作模式描述了问题的解决方案，但它们并不关心解决方案是如何开发的。因此，这些模式帮助我们简化问题和解决方案，并定义一个良好、可执行的过程。
- en: Explaining the concept of performance and scalability patterns
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解释性能和可扩展性模式的概念
- en: In a business environment, processes and tasks need to be completed quickly
    in order to generate responses and solutions. With this in mind, the application
    also needs to be more performative and scaleable. Performance refers to how quickly
    an application responds to requests, and scalability refers to the application's
    capacity to respond to an increase in requests without affecting its performance
    or capacity. In other words, performance is more about the time it takes to serve
    a request, whereas scalability is about the system being able to upgrade and downgrade
    resources where needed.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在商业环境中，为了生成响应和解决方案，过程和任务需要快速完成。考虑到这一点，应用程序也需要更加高效和可扩展。性能指的是应用程序响应请求的速度，而可扩展性指的是应用程序在增加请求时能够响应而不影响其性能或容量的能力。换句话说，性能更多地关于服务请求所需的时间，而可扩展性是关于系统能够根据需要升级和降级资源。
- en: In a business environment, problems with regard to performance are generally
    problems surrounding read data or external resources (such as file systems or
    other applications in a network). Performance problems generated by incorrect
    logic or algorithms are rarer because business environments generally have logic
    without a hard code, or codes with a long mathematical calculus. The algorithms
    of business environments generally use logic to read and save data via roles;
    therefore, performance growth generally consists of reading and writing data and
    accessing resources as quickly as possible.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在商业环境中，关于性能的问题通常是围绕读取数据或外部资源（如文件系统或网络中的其他应用程序）的问题。由于商业环境通常没有硬编码的逻辑或具有长数学计算的代码，因此由错误的逻辑或算法引起的性能问题较为罕见。商业环境的算法通常使用逻辑通过角色读取和保存数据；因此，性能增长通常包括尽可能快地读取和写入数据以及访问资源。
- en: Scalability is directly linked to performance because it consists of growing
    the scale of an application. In other words, if we grow the scale of an application,
    we should be able to respond to an increase in requests without impacting performance,
    or the application will respond to requests with increased performance.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 可扩展性与性能直接相关，因为它包括扩展应用程序的规模。换句话说，如果我们扩展了应用程序的规模，我们应该能够响应请求的增加而不影响性能，否则应用程序将以增加的性能响应请求。
- en: 'Performance and scalability patterns are operational patterns used for solving
    common problems with performance and scalability that provide applications with
    high-performance and availability at all times. We will cover the following performance
    and scalability patterns in this chapter:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 性能和可扩展性模式是用于解决性能和可扩展性常见问题的操作模式，它们为应用程序提供始终如一的高性能和可用性。在本章中，我们将介绍以下性能和可扩展性模式：
- en: '**Cache-aside**: This pattern loads data into a cache from a data store on
    demand.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缓存旁路（Cache-aside）**: 这种模式根据需求从数据存储中将数据加载到缓存中。'
- en: '**CQRS**: This pattern segregates operations that read data from operations
    that update data by using separate interfaces.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CQRS（Command Query Responsibility Segregation）**: 这种模式通过使用单独的接口将读取数据的操作与更新数据的操作分离。'
- en: '**Event sourcing**: This pattern uses an append-only store to record the actions
    taken on data in a domain.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事件溯源（Event sourcing）**: 这种模式使用只追加存储来记录对领域内数据所采取的操作。'
- en: '**Index table**: This pattern creates indexes over the fields in data stores
    that are frequently referenced by queries.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**索引表（Index table）**: 这种模式在数据存储中创建索引，这些索引经常被查询引用。'
- en: '**Materialized view**: This pattern generates pre-populated views over the
    data in one or more data stores when the data isn''t ideally formatted for the
    required query operations.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**物化视图（Materialized view）**: 当数据不是理想地格式化以进行所需的查询操作时，这种模式会在一个或多个数据存储中生成预填充的视图。'
- en: '**Sharding**: This pattern divides a data store into a set of horizontal partitions
    or shards.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分片（Sharding）**: 这种模式将数据存储划分为一组水平分区或分片。'
- en: '**Static content hosting**: This pattern deploys static content to a cloud-based
    storage service that can deliver data directly to a client.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**静态内容托管（Static content hosting）**: 这种模式将静态内容部署到可以直接向客户端交付数据的基于云的存储服务。'
- en: The cache-aside pattern
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓存旁路模式
- en: As mentioned previously, increased performance generally means minimizing the
    time it takes to read data. One way to do this is through the cache-aside pattern.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，提高性能通常意味着最小化读取数据所需的时间。实现这一目标的一种方法是通过缓存旁路模式。
- en: The cache-aside pattern is a pattern that loads data into a cache from a data
    store on demand. It also updates data to the data store if the application updates
    any data cache. The data is loaded into the cache if the user requests it and
    it is not available. So, when next accessing this data, the application will read
    from the cache and respond to the user. This pattern helps us to maintain consistency
    between data in the cache and the data store. A cache is another data source that
    maintains copies of data from the original data store, permitting the application
    to read data quickly. However, this pattern does not guarantee consistency between
    the data store and the cache, because another application can update data from
    the data store and thus make the cache stale.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存旁路模式是一种按需从数据存储将数据加载到缓存中的模式。如果应用程序更新了任何数据缓存，它也会将数据更新到数据存储。当用户请求数据且数据不可用时，数据会被加载到缓存中。因此，当再次访问此数据时，应用程序将从缓存中读取并响应用户。这种模式帮助我们保持缓存中的数据和数据存储之间的数据一致性。缓存是另一个数据源，它维护着从原始数据存储中复制的数据，允许应用程序快速读取数据。然而，这种模式并不能保证数据存储和缓存之间的数据一致性，因为另一个应用程序可以更新数据存储中的数据，从而使缓存过时。
- en: 'The following diagram illustrates how the cache-aside pattern works:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示说明了缓存旁路模式的工作原理：
- en: '![](img/b75f290a-7fe0-4d86-9510-faa576b2139d.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b75f290a-7fe0-4d86-9510-faa576b2139d.png)'
- en: As we can see, when an application reads any data from the data store, the application
    first consults the data on the cache. However, if the data does not exist, then
    the application consults the data in the data store. When an application consults
    data in the data store, the data returned by the data store is then loaded in
    the cache to allow the application to read the data faster in future. When an
    application updates the data contained in a cache, the data is saved in the data
    store and the data of the cache is then either updated or invalidated.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，当应用程序从数据存储读取任何数据时，应用程序首先咨询缓存中的数据。然而，如果数据不存在，则应用程序会咨询数据存储中的数据。当应用程序咨询数据存储中的数据时，数据存储返回的数据随后被加载到缓存中，以便应用程序在将来更快地读取数据。当应用程序更新缓存中的数据时，数据将被保存到数据存储中，然后缓存中的数据将被更新或使无效。
- en: When to use the cache-aside pattern
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 何时使用缓存旁路模式
- en: It is recommended that the cache-aside pattern is used when data isn't updated
    frequently, or when concurrent updates are infrequent. It is important to note
    that the cache-aside pattern should only be used when necessary. This is because
    the cache increases the complexity of applications, as dirty readings involving
    data definitions can sometimes occur. With this in mind, we recommend that you
    only apply this pattern if reading data is a slow process.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 建议在数据不经常更新或并发更新不频繁时使用缓存旁路模式。重要的是要注意，缓存旁路模式只有在必要时才应使用。这是因为缓存增加了应用程序的复杂性，因为涉及数据定义的脏读有时可能发生。考虑到这一点，我们建议您只有在读取数据是一个缓慢的过程时才应用此模式。
- en: The lifetime of cached data
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓存数据的生命周期
- en: The lifetime of cached data is a very important issue regarding the cache-aside
    pattern because the lifetime policy establishes whether or not the cache is efficient.
    The lifetime defines the data's expiry time according to an expiration policy
    that invalidates data and removes it from the cache if it's not accessed within
    a specified time limit. Defining a good lifetime policy therefore means defining
    a lifetime that is neither too long nor too short. It is also highly recommended
    that you do not create a global expiration policy but rather one for each type
    of item in the data store. This is because some data is updated more frequently
    than others.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存数据的生命周期是关于缓存旁路模式的一个重要问题，因为生命周期策略决定了缓存是否高效。生命周期定义了数据的过期时间，根据一个过期策略，如果数据在指定的时间限制内未被访问，则该策略将使数据无效并从缓存中移除。因此，定义一个好的生命周期策略意味着定义一个既不太长也不太短的生命周期。还强烈建议您不要创建一个全局过期策略，而应该为数据存储中的每种类型的项目创建一个。这是因为某些数据比其他数据更新得更频繁。
- en: Evicting data
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 驱除数据
- en: Some caches have a limited size and require a policy in order to evict data.
    In addition to this, some caches select the least recently-used data to evict.
    However, we can customize this policy, and we can even use our own logic for removing
    data from the cache. Generally, the logic used to remove data is limited in size,
    but we can also use logic regarding updates.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 一些缓存有有限的大小，并需要策略来弹出数据。此外，一些缓存选择最近最少使用的数据来弹出。然而，我们可以自定义此策略，甚至可以使用我们自己的逻辑从缓存中删除数据。通常，用于删除数据的逻辑大小有限，但我们也可以使用有关更新的逻辑。
- en: Evicting data is different to setting an expiration policy because the expiration
    policy is a static logic that removes data in a cache when it expires. Eviction
    data, however, involves dynamic logic. An expiration policy allows us to minimize
    the chance of getting a dirty reading, whereas evicting data allows us to create
    logic that minimizes the chance of the cache reaching its limit and optimizes
    the consistency of the cache data.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 弹出数据与设置过期策略不同，因为过期策略是一种静态逻辑，当数据过期时从缓存中删除数据。然而，弹出数据涉及动态逻辑。过期策略允许我们最小化脏读的可能性，而弹出数据允许我们创建逻辑，以最小化缓存达到其限制的可能性并优化缓存数据的一致性。
- en: Priming the cache
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓存预热
- en: We may want to start our cache with data optimized for application use. We should
    therefore populate the cache with data from the startup process of an application.
    It is very important to point out that we need to evaluate the expiration time
    of the data loaded in such a startup process; if the data expires before the application
    uses it, loading the startup process data is unnecessary.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能希望以针对应用程序使用优化的数据开始我们的缓存。因此，我们应该使用应用程序启动过程中的数据填充缓存。重要的是指出，我们需要评估在启动过程中加载的数据的过期时间；如果数据在应用程序使用之前过期，则加载启动过程数据是不必要的。
- en: Consistency
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一致性
- en: The cache-aside pattern does not guarantee consistency between the data in the
    cache and the data in the data store. This is because an external application
    or resource can update data that is not reflected in the cache at any time. Consistency
    is very important to remember when implementing in order to avoid the risk of
    dirty readings.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存旁路模式不能保证缓存中的数据与数据存储中的数据之间的一致性。这是因为外部应用程序或资源可以在任何时间更新缓存中没有反映的数据。在实现时记住一致性非常重要，以避免脏读的风险。
- en: Local (in-memory) caching
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本地（内存）缓存
- en: In order to improve the process of reading data, a cache can be local and in-memory
    as long as that data is accessed frequently. As the local cache is private, another
    cache will need to be created. In this instance, data can be replicated to any
    local cache. To implement a local cache, we need to have a server with enough
    memory to permit our application and to ensure we do not cause memory overflow.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提高读取数据的过程，只要数据被频繁访问，缓存可以是本地和内存的。由于本地缓存是私有的，因此需要创建另一个缓存。在这种情况下，数据可以复制到任何本地缓存。为了实现本地缓存，我们需要一个具有足够内存的服务器，以允许我们的应用程序运行，并确保我们不会导致内存溢出。
- en: The CQRS pattern
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CQRS 模式
- en: In an application, executing commands to read and write data from the data store
    using the same model or entity is a good approach. This is because managing data
    is generally easy in programming, and we can also use a scaffold to generate a
    project. However, when there is a lot of write data present, and the risk of concurrent
    write operations is high, the need to merge data is more urgent. When we use the
    same model to execute read and write data, the operation of reading data generally
    reads all the data within a model, and the operation of writing data generally
    writes all data in the model. Sometimes, however, we need to write fewer columns
    of data than there is in the model. In addition, using a single model to read
    and write data can increase security because some data is for querying only.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序中，使用相同的模型或实体执行从数据存储读取和写入数据的命令是一种好方法。这是因为管理数据在编程中通常很容易，我们还可以使用脚手架来生成项目。然而，当存在大量写入数据，并且并发写入操作的风险很高时，合并数据的需求更为迫切。当我们使用相同的模型来执行读取和写入数据时，读取数据的操作通常读取模型中的所有数据，写入数据的操作通常写入模型中的所有数据。有时，我们可能需要写入比模型中更少的列数据。此外，使用单个模型读取和写入数据可以提高安全性，因为某些数据仅供查询使用。
- en: '**CQRS (Command and Query Responsibility Segregation****)** is a pattern that
    segregates read operations from write operations, creating a separate and decoupled
    interface for these operations. With this in mind, we need to create a model to
    read data and another model to write data, while only using the data needed for
    these operations.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '**CQRS（命令和查询责任分离）**是一种将读取操作与写入操作分离的模型，为这些操作创建了一个独立且解耦的接口。考虑到这一点，我们需要创建一个用于读取数据的模型和另一个用于写入数据的模型，同时只使用这些操作所需的数据。'
- en: When to use the CQRS pattern
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 何时使用CQRS模式
- en: It is recommended that the CQRS pattern is used when an application has a complex
    business role and its data is updated frequently by resources or events, therefore
    increasing the risk of a write operation. Implementing this pattern is also recommended
    when performance problems generated by the merging of data and write operations
    are concurrent. The use of the CQRS pattern increases the complexity of applications,
    so this pattern should only be used when necessary.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 建议在应用程序具有复杂业务角色且其数据频繁由资源或事件更新，从而增加写入操作风险时使用CQRS模式。当数据合并和写入操作产生的性能问题并发时，也建议实施此模式。使用CQRS模式会增加应用程序的复杂性，因此此模式仅在必要时使用。
- en: The event sourcing pattern
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件源模式
- en: In a typical approach, an application changes the state of data when a user
    works with it. However, this approach can often slow down performance and responsiveness
    and can also generate other concurrent updates. Unless we use an additional mechanism,
    we don't have a mechanism to audit and log operations or generate history.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在典型的方法中，当用户与数据交互时，应用程序会改变数据的状态。然而，这种方法经常会减慢性能和响应速度，也可能生成其他并发更新。除非我们使用额外的机制，否则我们没有审计和记录操作或生成历史记录的机制。
- en: Event sourcing is a pattern that maintains the current data state and saves
    data update events in an event repository. This repository works as an append-only
    store, and when the data is accessed by a consumer, it receives the event and
    applies the update on the domain. Using this pattern promotes performance by decoupling
    the event logic and scalability and by auditing all actions applied to the data.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 事件源是一种模式，它维护当前的数据状态，并将数据更新事件保存到事件存储库中。此存储库作为一个只追加存储，当消费者访问数据时，它会接收事件并在领域上应用更新。使用此模式通过解耦事件逻辑和可伸缩性以及审计对数据应用的所有操作来提高性能。
- en: Understanding the event of event sourcing
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解事件源事件
- en: In the event sourcing pattern, an event is considered an update that will be
    applied to the data. When a user requests a data update, the application will
    not update it in real-time but will instead get the data, create an imperative
    description of an update, and save the event with that description. This event
    is then saved in the event repository. Note that the consumer of an event can
    be another application or resource.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在事件源模式中，事件被视为将应用于数据的更新。当用户请求数据更新时，应用程序不会实时更新它，而是获取数据，创建一个更新的强制描述，并保存带有该描述的事件。然后，该事件被保存在事件存储库中。请注意，事件消费者可以是另一个应用程序或资源。
- en: Using the event sourcing pattern, the end user is able to see older versions
    of data because the data is only updated when the event is saved on the event
    repository and running. With this in mind, the end user will not see the update
    in real-time, as the update is scheduled and can be executed at any time. Remember
    that the event repository can be a relational database, file system, or another
    data source.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 使用事件源模式，最终用户能够看到数据的旧版本，因为数据仅在事件存储库上保存并运行时才更新。考虑到这一点，最终用户将不会实时看到更新，因为更新是计划好的，可以在任何时间执行。记住，事件存储库可以是关系数据库、文件系统或其他数据源。
- en: The consumer can be a component of the same application that saves the event
    in the event repository or it can be another application. The consumer of the
    event always checks whether it can run it when it receives one.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 消费者可以是保存事件到事件存储库的同一应用程序的一部分，也可以是另一个应用程序。事件消费者在接收到事件时总是检查它是否可以运行它。
- en: Promoting performance
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提高性能
- en: Using the event sourcing pattern should increase performance. This is because
    any updates can be done by a consumer at any time, and the update actions can
    lock data and impact data queries. This process, therefore, minimizes the risk
    of update operations colliding. Furthermore, the update operation can be done
    as a background process run on the server.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 使用事件源模式应提高性能。这是因为任何更新都可以由消费者在任何时候完成，更新操作可以锁定数据并影响数据查询。因此，这个过程最小化了更新操作冲突的风险。此外，更新操作可以作为在服务器上运行的背景进程完成。
- en: Promoting decoupling
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 促进解耦
- en: Using the event sourcing pattern will also promote the decoupling of event logic
    because the updates can be done by another application or resource. The event
    publisher doesn't need to know about the event consumer, and an event can be divided
    to permit numerous applications or resources to execute part of the update process.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 使用事件源模式也将促进事件逻辑的解耦，因为更新可以由另一个应用程序或资源完成。事件发布者不需要了解事件消费者，事件可以被分割以允许多个应用程序或资源执行更新过程的某一部分。
- en: Promoting scalability
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 促进可伸缩性
- en: Using the event sourcing pattern will promote scalability because it also promotes
    the decoupling of the event publisher and event consumer. Therefore, we can replicate
    both the event publisher and event consumer once the measure of the request to
    an application or resource has been considered.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 使用事件源模式将促进可伸缩性，因为它也促进了事件发布者和事件消费者的解耦。因此，一旦考虑了向应用程序或资源的请求量，我们就可以复制事件发布者和事件消费者。
- en: Promoting auditing
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 促进审计
- en: Using the event sourcing pattern will promote the auditing of all actions applied
    to the data because the history of an event can be used to regenerate old information
    about data. This is because the event repository does not allow you to update
    or delete events. All data history is displayed in an event repository.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 使用事件源模式将促进对应用于数据的所有操作的审计，因为事件的历史可以用来重新生成关于数据的老信息。这是因为事件存储库不允许您更新或删除事件。所有数据历史都在事件存储库中显示。
- en: Explaining the index table pattern
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解释索引表模式
- en: These days, the volume of data is ever-increasing, and applications need to
    be able to read a large quantity of data. To make it possible to read data faster,
    it is common to resort to a data structure or index. In a business environment,
    data can be organized as a collection of entities that have a primary key. However,
    we also want to be able to read data using attributes that don't contain an index
    as a filter in a query. The following diagram illustrates the data organization;
    if data stays organized, we can use an algorithm that retrieves it faster.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这些天，数据量不断增长，应用程序需要能够读取大量数据。为了能够更快地读取数据，通常需要求助于数据结构或索引。在商业环境中，数据可以组织为具有主键的实体集合。然而，我们还想能够使用不包含索引的属性作为查询中的过滤器来读取数据。以下图表说明了数据组织；如果数据保持组织良好，我们可以使用一个检索速度更快的算法。
- en: The relational database works with an index and allows us to create one in order
    to read data faster. Other data stores will not work with an index to read data,
    so we need to create our own index mechanism to promote faster data reading.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 关系型数据库通过索引工作，并允许我们创建索引以加快数据读取速度。其他数据存储不会使用索引来读取数据，因此我们需要创建自己的索引机制以促进更快的数据读取。
- en: 'The index table pattern is a pattern that creates a table that organizes data
    using other data or a specific key. Using this, we can read data quicker. The
    pattern works using three strategies; they are as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 索引表模式是一种创建使用其他数据或特定键组织数据的表的模式。使用此模式，我们可以更快地读取数据。该模式使用三种策略；如下所述：
- en: Duplicating data and organizing it in different keys
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复制数据并在不同的键中组织它
- en: Creating index tables organized by different keys and referencing the original
    data using the primary key
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建按不同键组织并使用主键引用原始数据的索引表
- en: Creating index tables organized by different keys that duplicate frequently-retrieved
    fields
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建按不同键组织且重复频繁检索字段的索引表
- en: 'The following diagram illustrates the first strategy:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表说明了第一种策略：
- en: '![](img/4c1da75f-97c5-40ad-9f51-7a0e6e3ea66c.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图表](img/4c1da75f-97c5-40ad-9f51-7a0e6e3ea66c.png)'
- en: 'In the strategy shown in the following diagram, the data is duplicated in each
    index table. This works according to denormalization and is more appropriate for
    use with mostly static data. The following diagram illustrates the second strategy:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下图中展示的策略中，数据在每个索引表中重复。这根据反规范化工作，更适合用于主要静态数据。以下图示说明了第二种策略：
- en: '![](img/3d15ada3-c328-4762-a131-24baac12357f.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3d15ada3-c328-4762-a131-24baac12357f.png)'
- en: 'In the strategy shown in the following diagram, the data is organized according
    to different keys and references the original data using the primary key. In this
    strategy, the primary key of data is retrieved first by an attribute and then
    by using an ID. The following diagram illustrates the third strategy:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下图中展示的策略中，数据是根据不同的键组织起来的，并使用主键引用原始数据。在这个策略中，数据的主键首先通过一个属性检索，然后通过使用ID。以下图示说明了第三种策略：
- en: '![](img/18af210b-5e2c-4aeb-a918-d957a44a1769.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/18af210b-5e2c-4aeb-a918-d957a44a1769.png)'
- en: In the strategy shown in the preceding diagram, the data is organized according
    to different keys that duplicate frequently-retrieved attributes in partially
    normalized index tables.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一个图中展示的策略中，数据是根据不同的键组织起来的，这些键在部分归一化的索引表中频繁地重复检索属性。
- en: An index table pattern is a good mechanism for retrieving data quicker. However,
    overusing this pattern can generate a performance problem during data updates,
    as they require us to reorganize our index tables.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 索引表模式是一个快速检索数据的良好机制。然而，过度使用此模式可能会在数据更新期间产生性能问题，因为它们需要我们重新组织我们的索引表。
- en: The materialized view pattern
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 物化视图模式
- en: Occasionally, business roles need read data that requires non-trivial queries.
    The user may sometimes need to see data that is made by combining data from different
    physical locations. This often causes performance problems, making the reading
    of data slow. For relational data, these locations are tables. To increase performance,
    therefore, one strategy can be to create a pre-populated view of data from multiple
    physical locations. Consequently, when the application executes a query, the data
    will already be made and will, therefore, be returned faster.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，业务角色需要读取需要非平凡查询的数据。用户有时可能需要看到由不同物理位置组合而成的数据。这通常会导致性能问题，使得读取数据变慢。对于关系型数据，这些位置是表。因此，为了提高性能，一种策略可以是创建来自多个物理位置的预填充视图。因此，当应用程序执行查询时，数据已经准备好，因此可以更快地返回。
- en: 'The materialized view pattern is a pattern that creates and materializes data
    in a format the application requires in a query. If the query consults data with
    joins or data that needs to be calculated, the materialized view pattern increase
    the performance, making it possible to read data faster. Note that data in a materialized
    view is never updated in a materialized view; it is simply a snapshot of the actual
    data. When the real data is updated, the materialized view will need to be rebuilt.
    The following diagram illustrates the materialized view pattern:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 物化视图模式是一种创建和物化数据以符合应用程序在查询中所需格式的模式。如果查询涉及连接或需要计算的数据，物化视图模式可以提高性能，使得读取数据更快。请注意，物化视图中的数据永远不会在物化视图中更新；它只是实际数据的快照。当实际数据更新时，物化视图需要重建。以下图示说明了物化视图模式：
- en: '![](img/b4bbeb1c-9339-4579-a71c-c415e48e3e57.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b4bbeb1c-9339-4579-a71c-c415e48e3e57.png)'
- en: Rebuilding the materialized view
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重建物化视图
- en: When data on the data source changes the materialized view, the materialized
    view must be rebuilt in order to reflect the changes. Rebuilding a materialized
    view can be done with either an automated or manual process. To define the strategy
    needed for rebuilding the materialized view, we first need to define whether the
    data will allow a dirty reading, as well as looking into the impact of such a
    reading. If the data cannot have a dirty reading, the materialized view needs
    to be rebuilt at the same time the original data is updated.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当数据源上的数据发生变化时，必须重建物化视图以反映这些变化。重建物化视图可以通过自动或手动过程完成。为了定义重建物化视图所需的策略，我们首先需要定义数据是否允许脏读，以及查看这种读取的影响。如果数据不能有脏读，那么物化视图需要在原始数据更新的同时重建。
- en: When to use the materialized view pattern
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 何时使用物化视图模式
- en: The materialized view pattern can promote a big increase in performance. This
    is because any data is read without performing joins or calculus to retrieve the
    data. However, if the data changes too rapidly, the materialized view will be
    rebuilt more times than necessary, which will impact performance.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 物化视图模式可以显著提高性能。这是因为任何数据读取都不需要执行连接或计算来检索数据。然而，如果数据变化得太快，物化视图将比必要的次数重建更多次，这会影响性能。
- en: The benefit of using the materialized view pattern is inversely proportional
    to the speed of changes in the original data. Therefore, the use of a materialized
    view is recommended when data is rarely modified and is not dynamic.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '使用物化视图模式的好处与原始数据变化速度成反比。因此，当数据很少修改且不动态时，建议使用物化视图。 '
- en: Explaining the sharding pattern
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解释分片模式
- en: If we have a table that grows rapidly and generates problems reading and writing
    data in a business environment, we need to apply a solution that deals with the
    problem of performance as well as the problem with data volume.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有一个快速增长的表，在业务环境中读取和写入数据时会产生问题，我们需要应用一个既能解决性能问题又能解决数据量问题的解决方案。
- en: The sharding pattern is a pattern that divides a data store horizontally into
    partitions or shards. This can improve scalability and performance. The shards
    can run in the same node or in multiples nodes, but each shard has the same schema.
    When we divide a single database into shards, the rows of the database are distributed
    between them. Furthermore, a sharding pattern can be implemented by the database,
    if it has support, or by the application.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 分片模式是一种将数据存储水平分割成分区或分片的模式。这可以提高可扩展性和性能。分片可以在同一个节点或多个节点上运行，但每个分片具有相同的模式。当我们把单个数据库分割成分片时，数据库的行会在它们之间分布。此外，如果数据库支持，分片模式可以通过数据库实现，或者通过应用程序实现。
- en: 'The sharding pattern has three common strategies used during implementation.
    These strategies include the following:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 分片模式在实施过程中有三种常见的策略。这些策略包括以下内容：
- en: '**The lookup strategy**: This strategy divides data into shards and the sharding
    logic implements a map that routes a request to the data using a shard key. After
    this, each shard is identified by a shard key and contains its own set of data.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**查找策略**：这种策略将数据分成多个分片，并通过分片逻辑实现一个映射，使用分片键将请求路由到数据。之后，每个分片通过分片键来识别，并包含其自己的数据集。'
- en: '**The range strategy**: This strategy divides data into shards and the sharding
    logic implementation group related data together. These shards are identified
    by the shard key. This strategy is useful when we want to retrieve data using
    a range query.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**范围策略**：这种策略将数据分成多个分片，并通过分片逻辑将相关数据分组在一起。这些分片通过分片键来识别。当我们需要使用范围查询来检索数据时，这种策略非常有用。'
- en: '**The hash strategy**: This strategy divides data into shards and the sharding
    logic implementation allows an even distribution of data between the shards. These
    shards are identified by a shard key. Here, the shards are balanced and reduce
    the risk of a disproportionate amount of load in a shard.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**哈希策略**：这种策略将数据分成多个分片，并通过分片逻辑实现数据在分片之间的均匀分布。这些分片通过分片键来识别。在这里，分片是平衡的，减少了分片中负载不均的风险。'
- en: When to use the sharding pattern
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 何时使用分片模式
- en: There are benefits to using the sharding pattern, but a downside is that it
    can also increase the complexity of a project. Because of this, this pattern should only be
    used when necessary, as increasing the complexity of a project increases the chance
    of errors occurring.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 使用分片模式的好处是显而易见的，但同时也可能增加项目的复杂性。正因为如此，这个模式只有在必要时才应该使用，因为增加项目的复杂性会增加出现错误的机会。
- en: The sharding pattern should be used when the performance of retrieving data
    needs to be increased – in particular, when the data set is very large. The shards
    reduce the amount of data that is used to retrieve data, thereby increasing performance.
    Furthermore, using the sharding pattern makes it possible to scale the data store
    and also makes data highly available.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要提高数据检索性能时，应该使用分片模式——特别是在数据集非常大的时候。分片减少了用于检索数据的数据量，从而提高了性能。此外，使用分片模式使得数据存储可以扩展，并且数据可以高度可用。
- en: Explaining the concept of management and monitoring patterns
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解释管理和监控模式的概念
- en: The volume of applications running in a cloud is ever-increasing and these applications
    commonly run in a remote data center. Because of this, we don't have full control
    over the infrastructure of an application, and it can become difficult to manage
    and monitor applications running remotely.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在云中运行的应用程序数量不断增加，这些应用程序通常在远程数据中心运行。因此，我们无法完全控制应用程序的基础设施，管理远程运行的应用程序可能会变得困难。
- en: 'The management and monitoring patterns were created to allow us to manage and
    monitor our applications and expose runtime information about the application
    that supports business changes and customization without having to redeploy the
    application. Using this pattern, we can decouple the monitoring logic from the
    application logic, and we can also update the ambassador without impacting the
    application. In this section, we will explain the following management and monitoring
    patterns:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 管理和监控模式被创建出来，以便我们能够管理和监控我们的应用程序，并在不重新部署应用程序的情况下，暴露关于应用程序的运行时信息，以支持业务变更和定制。使用此模式，我们可以将监控逻辑与应用程序逻辑解耦，并且我们还可以更新使节而不影响应用程序。在本节中，我们将解释以下管理和监控模式：
- en: The ambassador pattern
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使节模式
- en: The health endpoint monitoring pattern
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 健康端点监控模式
- en: The external configuration store pattern
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外部配置存储模式
- en: The ambassador pattern
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使节模式
- en: In some cases, you may want to implement features such as routing, metering,
    or monitoring on a cloud application; you may also want to update network configurations.
    However, it is sometimes difficult to maintain the application and update codes. Furthermore,
    there may be some libraries that are not maintained by us and therefore cannot
    be modified.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，您可能想在云应用程序上实现路由、计费或监控等功能；您可能还希望更新网络配置。然而，有时维护应用程序和更新代码可能很困难。此外，可能有一些库不是由我们维护的，因此无法修改。
- en: 'The ambassador pattern creates an external process including all of the logic,
    libraries, and frameworks needed to fulfill the requirements of management and
    monitoring. This external process acts as a proxy between the applications or
    external services. The following diagram illustrates the ambassador pattern:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 使节模式创建了一个外部进程，包括满足管理和监控需求所需的所有逻辑、库和框架。该外部进程充当应用程序或外部服务之间的代理。以下图展示了使节模式：
- en: '![](img/be6a4470-b874-4d69-ab30-1f1077966d69.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/be6a4470-b874-4d69-ab30-1f1077966d69.png)'
- en: When to use the ambassador pattern
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 何时使用使节模式
- en: The purpose of the ambassador pattern is to indicate when a supported cloud
    is needed for connectivity requirements, or to indicate when applications need
    to be modified. The ambassador pattern can also help with building a common set
    of client connectivity features for multiple languages or frameworks. However,
    when there is critical request latency, this pattern is not recommended. This
    is because the ambassador pattern introduces overhead on the network that can
    impact an application.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 使节模式的目的是在需要支持云以连接需求时或需要修改应用程序时进行指示。使节模式还可以帮助为多种语言或框架构建一组通用的客户端连接功能。然而，当存在关键请求延迟时，不建议使用此模式。这是因为使节模式在网络中引入了开销，可能会影响应用程序。
- en: Explaining the health endpoint monitoring pattern
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解释健康端点监控模式
- en: In a business environment, applications always need to be available and to perform
    correctly. It is, therefore, necessary to monitor whether this is the case for
    all services. Monitoring applications on the cloud, however, is often difficult.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在商业环境中，应用程序始终需要可用并正确执行。因此，有必要监控所有服务是否如此。然而，在云上监控应用程序通常很困难。
- en: 'The health endpoint monitoring pattern implements a health monitor by sending
    requests to endpoints on the application and verifying the status returned by
    them. This pattern then analyzes the result returned by the application and performs
    the health verification check, as illustrated in the following diagram:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 健康端点监控模式通过向应用程序的端点发送请求并验证它们返回的状态来实现健康监控。然后，该模式分析应用程序返回的结果并执行健康验证检查，如下面的图所示：
- en: '![](img/6bd44735-5a2a-473c-83e3-52b4c81878c5.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6bd44735-5a2a-473c-83e3-52b4c81878c5.png)'
- en: In the preceding diagram, we can see the **Application** and the **Agent**.
    This represents a solution that sends a request to the application and the service
    and checks its returns. Note that the **Agent** checks the **Data Store** too.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在前图中，我们可以看到**应用程序**和**代理**。这代表了一种向应用程序和服务发送请求并检查其返回结果的解决方案。请注意，**代理**还检查**数据存储**。
- en: 'The health endpoint monitoring pattern can perform the following checks:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 健康端点监控模式可以执行以下检查：
- en: Validating the response code; on the HTTP protocol, the return of status 200 denotes
    success
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证响应代码；在HTTP协议中，状态码200表示成功
- en: Checking the content of the response to detected errors
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查检测到的错误响应的内容
- en: Measuring the time interval between a request and its response
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测量请求与其响应之间的时间间隔
- en: Checking resources or services located outside the application
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查位于应用程序外部资源或服务
- en: Checking the expiration of SSL certificates
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查SSL证书的过期情况
- en: Validating the URL returned by the DNS lookup to ensure correct entries
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证DNS查找返回的URL以确保正确条目
- en: When to use the health endpoint monitoring pattern
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 何时使用健康端点监控模式
- en: The health endpoint monitoring pattern is recommended for monitoring a web application
    or service's availability and performance. It can help with monitoring the middle-tier
    and shared service in order to identify and isolate a failure.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 健康端点监控模式建议用于监控Web应用程序或服务的可用性和性能。它可以帮助监控中间层和共享服务，以便识别和隔离故障。
- en: Using this pattern can help to identify a failure early and also apply the actions
    needed to solve the problem, something that has only a minor impact on the end
    user. Today, the capacity to identify failures quickly is very important to businesses.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此模式可以帮助早期识别故障并采取解决问题的必要措施，这对最终用户的影响很小。今天，快速识别故障的能力对商业来说非常重要。
- en: Explaining the external configuration store pattern
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解释外部配置存储模式
- en: An application always needs to follow a set of configurations in order to perform
    its functions and promote services. Generally, these configurations are made by
    files that the application reads and gets information from. These configuration
    files are often deployed with an application package. Some updates in these configuration
    files require the redeployment of an application, thus increasing the complexity
    of updates in the configuration files. Furthermore, deploying the configuration
    files together with the application requires the creation of each configuration
    file for each application, and these files cannot be shared.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序始终需要遵循一组配置才能执行其功能并推广服务。通常，这些配置是通过应用程序读取并从中获取信息的文件来实现的。这些配置文件通常与应用程序包一起部署。这些配置文件中的某些更新需要重新部署应用程序，从而增加了配置文件更新的复杂性。此外，与应用程序一起部署配置文件需要为每个应用程序创建每个配置文件，并且这些文件不能共享。
- en: 'The external configuration store pattern creates an external repository for
    configuration patterns, providing an interface for permitting applications to
    read configuration files. Using this, we can update the configuration files without
    having to redeploy applications, and we can also share configurations between
    several applications, making the environment more organized and easier to manage,
    as illustrated in the following diagram:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 外部配置存储模式创建一个外部配置模式仓库，为应用程序提供读取配置文件的接口。使用此接口，我们可以更新配置文件而无需重新部署应用程序，我们还可以在多个应用程序之间共享配置，使环境更加有序且易于管理，如下图所示：
- en: '![](img/82947dd7-7258-49ca-a8c0-b6da2793a51f.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/82947dd7-7258-49ca-a8c0-b6da2793a51f.png)'
- en: As you can see in the preceding diagram, the applications read the configurations
    from a common location called the repository of configuration. If the configuration
    files are then updated, all applications will see the update.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，应用程序从称为配置仓库的公共位置读取配置。如果配置文件随后被更新，所有应用程序都将看到更新。
- en: When to use the external configuration store pattern
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 何时使用外部配置存储模式
- en: The use of the external configuration store pattern is recommended when sharing
    configuration files with applications or when updates are required without the
    redeployment of an application. Sharing configuration files allows us to easily
    manage the configurations of an application, as all applications will see and
    be impacted by the update, which is done in one location. Using this pattern will
    also minimize the risk of error when updating the configuration file, so the use
    of this pattern is a good practice to adopt.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 当与应用程序共享配置文件或在无需重新部署应用程序的情况下需要更新时，建议使用外部配置存储模式。共享配置文件使我们能够轻松管理应用程序的配置，因为所有应用程序都将看到并受到在单一位置进行的更新的影响。使用此模式还可以最大限度地减少更新配置文件时的错误风险，因此采用此模式是一种良好的实践。
- en: Summary
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored operational patterns, performance and scalability
    patterns, and management and monitoring patterns. We also looked at why we should
    use these operational patterns and how to evaluate the best use for them.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了操作模式、性能和可扩展性模式以及管理和监控模式。我们还讨论了为什么我们应该使用这些操作模式以及如何评估它们的最优使用方式。
- en: On the topic of performance and scalability patterns, we looked at performance
    and scalability patterns such as cache-aside, CQRS, event sourcing, index table,
    materialized view, and sharding. Then, we explained each pattern's concept, what
    the benefits of it are, and when to implement it. We are now familiar with the
    techniques required for increasing the performance of an enterprise application,
    as well as how to make the application scalable.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在性能和可扩展性模式的话题上，我们研究了如缓存旁路、CQRS、事件溯源、索引表、物化视图和分片等性能和可扩展性模式。然后，我们解释了每个模式的概念、它的好处以及何时实现它。我们现在熟悉了提高企业应用程序性能所需的技术，以及如何使应用程序可扩展。
- en: On the topic of management and monitoring patterns, we explored management and
    monitoring patterns such as ambassador patterns, health endpoint monitoring patterns,
    and external configuration store patterns. We explained each pattern's concept,
    what the benefits of it are, and when to implement it. We are now familiar with
    the techniques required for managing and monitoring an enterprise application.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在管理和监控模式的话题上，我们探讨了如大使模式、健康端点监控模式和外部配置存储模式等管理和监控模式。我们解释了每个模式的概念、它的好处以及何时实现它。我们现在熟悉了管理和监控企业应用程序所需的技术。
- en: In the next chapter, we will look at the Eclipse MicroProfile project and its
    specifications.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨 Eclipse MicroProfile 项目及其规范。
