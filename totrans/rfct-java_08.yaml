- en: '8'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Crafting Quality Every Day
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While trying to give you advice on keeping your code clean and your design clear,
    it’s also important to talk about some practices that will help you little by
    little, day by day. Apart from dedicating specific moments to refactoring, maintaining
    a consistent level of quality in your day-to-day work is essential for the overall
    health and efficiency of your software development process. Achieving this doesn’t
    always require extensive time or effort; small, targeted actions can make a significant
    difference. By incorporating the practices we’re about to describe into your daily
    routine, you can not only prevent the accumulation of technical debt but also
    improve the overall quality and maintainability of your code base. These efforts
    may seem small in isolation but, collectively, they can have a substantial impact
    on the long-term success of your software projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Code versioning
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code formatting and style
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code reviews
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pair programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Documentation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why you’re doing what you’re doing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A hard dose of reality
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code versioning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I have a soft spot for code versioning, and that’s weird, I get it. It was one
    of the first things I had to learn the hard way when I started working right after
    graduation. Incredibly, no one had ever mentioned code versioning throughout my
    entire computer science studies. This makes me think that maybe my degree program
    was lacking in this regard, and it shows how important code versioning is in the
    life of a developer from day one.
  prefs: []
  type: TYPE_NORMAL
- en: Anyway, let’s get to the point. To tell you what code versioning is, I could
    start by saying that it is something that can save your day when things go wrong;
    I’ll admit that it sounds a bit too generic as a description, so I’ll go into
    detail.
  prefs: []
  type: TYPE_NORMAL
- en: '**Version control** is like a time machine for your files. It keeps track of
    all the changes you make so you can easily jump back to any previous version when
    needed. This system is usually referred to as a **versioning control system**
    (**VCS**) and there are many implementations of them. With a VCS, you can turn
    back the clock on individual files or the entire project, check how things have
    changed over time, figure out who messed with something that’s causing trouble,
    identify when an issue was introduced, and much more. Plus, using a VCS means
    that if you mess things up or lose files, you’ve got a safety net for easy recovery,
    and it doesn’t add much complexity to your workflow. Changes are typically marked
    with a code, often called the “revision number,” “revision level,” or just “revision.”
    For instance, the original set of files is labeled “revision 1.” When the first
    change happens, it becomes “revision 2,” and this pattern continues. Every revision
    comes with a timestamp and the name of the person who made the change. Revisions
    can be compared, restored, and, in some cases, merged, making it a powerful way
    to manage the evolution of files. The advantages of a VCS increase as the complexity
    of the project increases and the number of team members increases.'
  prefs: []
  type: TYPE_NORMAL
- en: As we already said, VCSs are useful for reverting errors; in case of trouble,
    you can restore your class, your package, and your module to a previous version
    that was still okay and start again. But this is not the only reason why everyone
    in this industry must use a VCS.
  prefs: []
  type: TYPE_NORMAL
- en: Developers can collaborate and team up on a project using VCSs. They can all
    access the database at the same time to check out past versions, making it simpler
    for them to collaborate effectively, regardless of their geographical locations.
    Version control also allows developers to maintain a historical record of changes,
    attributing them to specific contributors. This capability empowers them to roll
    back to earlier document versions and gain insights into how various team members’
    contributions have shaped the project’s evolution. In the realm of collaborative
    development, it’s essential to have a clear understanding of the commits being
    added to the repository and the reasons behind these commits to prevent conflicts
    and ensure the stability of the source code. Collaborative platforms (for example,
    GitHub and GitLab) that are built around VCSs offer centralized repositories (we’ll
    jump into that later), tools for issue tracking and management, as well as threaded
    discussions and forums. These features streamline a team-oriented approach to
    the software development life cycle.
  prefs: []
  type: TYPE_NORMAL
- en: Graph structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In graph theory, think of revisions like a tree growing from a main line. Picture
    *branches* coming out of this main line, forming a tree shape. Even though it’s
    more complex and looks like a graph, you can simplify it in your mind as a “tree
    with merges” for practical use.
  prefs: []
  type: TYPE_NORMAL
- en: 'Revisions happen one after another over time and can be put in a specific order,
    either by their revision number or the time they were made. Each revision is based
    on the ones before it, but sometimes, you can completely replace an earlier revision
    by getting rid of everything and putting in new stuff. In the simplest case, with
    no extra branches or undoing, each revision is only connected to the one just
    before it, making a straight line. The latest version is called the **HEAD** revision.
    In graph theory terms, if you think of each revision as a point and each connection
    between revisions like an arrow (usually going from older to newer, following
    the timeline), this setup makes a straight-line graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.1 – A very basic sequence of revisions](img/B20912_08_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.1 – A very basic sequence of revisions
  prefs: []
  type: TYPE_NORMAL
- en: 'When there is branching (that is, there are different paths) or we have to
    get back to an older revision, creating a situation where a revision depends on
    one older than the one just before it, the graph changes into a directed tree.
    In this tree, each point may have more than one next point. This creates multiple
    endpoints, representing revisions without any more changes (the “latest revision
    on each branch”). In theory, the tree may not have a favorite endpoint (the “main”
    latest revision), but usually, one endpoint is chosen as the **HEAD**. If a new
    revision is based on the **HEAD**, it either becomes the new **HEAD** or starts
    a new **BRANCH**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.2 – Branching from the trunk](img/B20912_08_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.2 – Branching from the trunk
  prefs: []
  type: TYPE_NORMAL
- en: 'The list of revisions from the starting point to the **HEAD**, called the trunk
    or mainline in graph theory, makes a simple straight-line graph. However, if a
    revision can be based on more than one previous revision (when a point can have
    more than one parent), it’s called a **MERGE**. This is one of the trickier parts
    of revision control. It often happens when changes occur in different branches
    (usually two), and these changes are combined into one branch that includes both
    sets of changes. If these changes overlap, it can be hard or even impossible to
    merge them without manual help or rewriting (these situations are known as **conflicts**):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.3 – Merging a branch into a trunk (a merge commit is created)](img/B20912_08_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.3 – Merging a branch into a trunk (a merge commit is created)
  prefs: []
  type: TYPE_NORMAL
- en: When merges happen, the graph stops being a tree, as points can have more than
    one parent. Instead, it becomes a rooted **directed acyclic graph** (**DAG**).
    This graph doesn’t have cycles “by definition” because parents always existed
    in the past, it’s rooted because it has a starting node given by the very first
    commit and it’s directed because you can navigate through it only in a given direction
    (we could say the direction of time) and never in the opposite direction. If there’s
    a trunk, merges from branches are like “external” additions to the tree. The changes
    in the branch are bundled as a patch, and applied to the **HEAD** of the trunk,
    creating a new version without directly mentioning the branch and keeping the
    tree structure. So, even though the actual relationships make a DAG, you can think
    of it as a tree with merges, and the trunk itself is a straight path.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to performing the **MERGE** operation, code versioning systems
    also offer the option to perform the so-called **rebase**. This action shifts
    the whole branch of new changes to start from the latest point in the main branch.
    It includes all the recent changes in the main branch. However, instead of making
    a **MERGE** commit, rebasing rewrites the project history by making entirely new
    commits for each original commit in the branch. Putting it more simply, it’s like
    you take the whole branch and “attach” it at the end of the main one:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.4 – Rebase operation](img/B20912_08_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.4 – Rebase operation
  prefs: []
  type: TYPE_NORMAL
- en: Rebasing has a big advantage because it makes your project history cleaner.
    It does this by removing the extra merge commits that git merge often creates.
    Additionally, rebasing creates a completely straight-line project history, allowing
    you to trace the development from the latest feature to the very start of the
    project without any diverging paths.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve seen how a VCS works at a general level, it’s time to take a
    look at how the three main types worked before and how they work now.
  prefs: []
  type: TYPE_NORMAL
- en: Local VCSs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Though quite ancient, this approach has fallen out of use, especially in professional
    settings – I haven’t even witnessed its use. Yet, as the initial example of a
    VCS, it’s worth mentioning it so that we can contrast it with modern practices.
  prefs: []
  type: TYPE_NORMAL
- en: In the past, a common version control method involved duplicating files into
    a separate directory, sometimes with timestamps for meticulous record-keeping.
    Despite its simplicity, this method was error-prone, with users easily losing
    track of their current directory and making unintended modifications or overwrites.
    To tackle these issues, programmers developed local VCSs with straightforward
    databases to log changes made to files under revision control.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of a local VCS:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.5 – A local VCS](img/B20912_08_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.5 – A local VCS
  prefs: []
  type: TYPE_NORMAL
- en: One of the most popular tools of this kind was RCS, which has been a thing for
    a while; it was also distributed among macOS’s Developer Kit.
  prefs: []
  type: TYPE_NORMAL
- en: Centralized VCSs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To address collaboration challenges among developers using different systems,
    **centralized version control systems** (**CVCSs**) such as CVS or Subversion
    were created. These systems store all versioned files on a central server, allowing
    multiple users to access and retrieve files:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.6 – A CVCS schema](img/B20912_08_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.6 – A CVCS schema
  prefs: []
  type: TYPE_NORMAL
- en: While this method facilitated project coordination and administration, it had
    a major drawback – the centralized server was a single point of failure. If it
    went down, collaboration and file-saving became impossible, and data loss risked
    the entire project history. This limitation led to the evolution of today’s VCSs.
  prefs: []
  type: TYPE_NORMAL
- en: Distributed VCSs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A **distributed version control system** (**DVCS**) is a type of VCS that allows
    multiple users to work on a project while having their own local copies of the
    entire project’s repository. In a distributed CVS, each user has a complete copy
    of the project’s history and can make changes independently on their local copy.
    These changes can be tracked, merged, and shared with others seamlessly.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the most well-known distributed CVS systems is **Git**. Git enables
    developers to work on a project offline, make commits to their local repository,
    and then synchronize their changes with a central repository or other team members’
    repositories when they are ready. Here is a DVCS schema:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.7 – A distributed VCS schema](img/B20912_08_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.7 – A distributed VCS schema
  prefs: []
  type: TYPE_NORMAL
- en: Distributed CVS systems offer several advantages, such as increased flexibility,
    improved collaboration, and better handling of projects with geographically distributed
    teams. Each contributor has a full copy of the project’s history, which provides
    redundancy and makes it harder to lose data. Additionally, DVCS systems allow
    for more branching and merging capabilities, making it easier to manage concurrent
    work on the same project.
  prefs: []
  type: TYPE_NORMAL
- en: Branching strategies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To keep your code base organized and have a smooth workflow, it’s a good idea
    to follow what’s called a **branching strategy**.
  prefs: []
  type: TYPE_NORMAL
- en: Branches are like separate workspaces for developers to build new features or
    fix issues in a software project. We saw that branches can be combined with the
    main code when the work is finished. This separation helps you avoid mixing up
    changes and makes it easier to fix mistakes. If everyone works on their branch,
    no one should mess up what others are doing.
  prefs: []
  type: TYPE_NORMAL
- en: A branching strategy is a plan that software teams use for writing, combining,
    and deploying code when they use VCSs. It’s like a set of rules that tells developers
    how to work with the shared code.
  prefs: []
  type: TYPE_NORMAL
- en: This strategy is crucial because it keeps things organized and prevents problems
    when many developers are working at the same time. Without it, there could be
    conflicts when everyone tries to add their changes simultaneously. This would
    slow down the process of getting code ready to use – and cause a certain amount
    of frustration!
  prefs: []
  type: TYPE_NORMAL
- en: By following a branching strategy, developers can work together without causing
    issues. It lets teams work on different things at the same time and release code
    faster with fewer conflicts. It’s all about having a clear process for making
    changes to the code; you can set up your own branching models, of course, but
    there are a bunch of them that have become quite successful over the years. The
    one we’re about to show will use only Distributed VCSs since are the only ones
    that are still in use.
  prefs: []
  type: TYPE_NORMAL
- en: Trunk-based development
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Trunk-based development** is a way of working where all developers make their
    changes directly in the main part of the code, which we call the **trunk**. This
    is the part of the code that’s ready to be used in the project. Developers are
    encouraged to save their work often and use special techniques to manage changes
    that aren’t ready yet.'
  prefs: []
  type: TYPE_NORMAL
- en: We also focus on automated testing, meaning the computer checks if the code
    is working well all the time. We do this to make sure any changes we make are
    tested thoroughly before they are used in the project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, if a task takes a long time, a developer might create a separate
    branch from the main code, make changes there, and then bring those changes back
    to the main part when they’re done. But the main idea in trunk-based development
    is to use separate branches as little as possible and have everyone work together
    on the main part of the code most of the time. The following diagram represents
    a very simple sequence of commits (a graph made by only one, linear path) that
    have been done on a single branch:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.8 – In trunk-based development, each commit is done on the main
    branch](img/B20912_08_8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.8 – In trunk-based development, each commit is done on the main branch
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how the trunk-based branching model works in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Work in the main code**: Instead of making separate branches, work directly
    in the **MAIN** (trunk) branch.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Make small, frequent updates**: Make small and regular changes to the code.
    This makes it easier to check and reduces the chances of problems.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Use continuous integration** (**CI**): Frequently combine and test the code
    to catch issues early, prevent conflicts, and keep the code ready for release.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Merge changes often**: Regularly bring your changes back into the main code,
    keeping it current and lowering the chance of conflicts.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At first glance, it doesn’t seem so bad. There are some pros – for instance,
    it encourages teamwork and quick feedback (there could be a merge conflict or
    a failing test), helps find problems early and fix them fast, speeds up adding
    new features, keeps the code organized by having everyone work on one branch,
    and lowers the complexity of dealing with many branches. When applied together
    with **test-driven development** (**TDD**) and a **continuous integration/continuous
    deployment** (**CI/CD**) pipeline, you can guarantee that your code is still working
    correctly. Under a certain number of circumstances, it can be a valid approach.
  prefs: []
  type: TYPE_NORMAL
- en: 'But there’s a great drawback: this model is not scalable since it might not
    work well for big teams or complex projects. If the main code goes bad, everything
    is affected. Moreover, we need strong automated testing and CI. As I mentioned
    previously, it can be a valid alternative if some conditions (conditions that,
    to tell the truth, should always be put in place) are respected.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see something a bit different.
  prefs: []
  type: TYPE_NORMAL
- en: Feature branching
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Feature branching** is a widely used approach where a fresh branch is made
    for a particular feature or code change. This lets developers work on the feature
    separately without messing with the **MAIN** branch. Once the feature is finished,
    it can be merged back into the **MAIN** branch using a pull request.'
  prefs: []
  type: TYPE_NORMAL
- en: What is a pull request?
  prefs: []
  type: TYPE_NORMAL
- en: A **pull request** is a mechanism used in version control systems, such as Git,
    to propose changes to a codebase. It is a request to merge a set of changes made
    in a feature branch into the main or target branch. The process typically involves
    a developer creating a branch, making changes, pushing those changes to a remote
    repository, and then submitting a pull request for review by others. The pull
    request allows team members to discuss, review, and test the proposed changes
    before they are merged into the main codebase, helping maintain code quality and
    collaboration in software development projects. More on this in the *Further*
    *reading* section.
  prefs: []
  type: TYPE_NORMAL
- en: 'This request permits other team members to inspect the changes and propose
    adjustments or enhancements before adding the feature to the **MAIN** branch:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.9 – In feature branching, each new feature is developed on a dedicated
    branch](img/B20912_08_9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.9 – In feature branching, each new feature is developed on a dedicated
    branch
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, let’s see the workflow in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Set up feature branches**: For each of the tasks you’re working on, create
    a dedicated branch. Each of these branches should originate from the **MAIN**
    branch.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Develop the feature**: Implement your feature into the **Feature** branch
    and commit as many times as you need. This branch must contain only commits related
    to that particular feature and nothing else (when I say nothing, I mean nothing:
    remember that this change set will go straight to production one day – you don’t
    want to mix things up).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Initiate a pull request**: When your development is complete and you’ve tested
    everything and you’re happy with that, you can create a pull request to merge
    your changes into the **MAIN** branch.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Examine and approve**: The changes are checked by other developers, who will
    give their approval or suggest some modifications (basically, they can start a
    conversation). In this way, potential issues and errors can be caught before the
    code becomes part of the **MAIN** branch.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Merge the feature branch**: Now that your feature has been implemented, and
    the pull request has been examined and approved, the **Feature** branch can be
    merged back into the **MAIN** branch.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Tidy up**: Delete the **Feature** branch.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As you can see, we have raised a bit the complexity of getting the **MAIN**
    branch to stay as clean as possible. The primary goal is to maintain the stable
    version on the **MAIN** branch while supporting concurrent feature development.
    In general, the code can be well-organized and tested (no merges into the **MAIN**
    branch until all tests are passed). Change tracking is improved. Using this strategy,
    we can insert code reviews in our workflow (see the next section).
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, new challenges arise when we’re managing and updating multiple
    branches, with potential delays in merging changes into the **MAIN** branch due
    to lengthy reviews. Of course, having multiple branches can create conflicts.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s look at a very, very popular branching strategy.
  prefs: []
  type: TYPE_NORMAL
- en: GitFlow
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**GitFlow** is a way of managing branches in Git. It mainly uses two long-lasting
    branches, **MAIN** and **DEVELOP**, which stay throughout the project’s life.
    It also uses short-lived branches such as **FEATURE**, **RELEASE**, and **HOTFIX**.
    These are created when needed and removed once they’ve done their job.'
  prefs: []
  type: TYPE_NORMAL
- en: The **MAIN** branch holds the stable, ready-to-use code, while the **DEVELOP**
    branch is where all the active development happens. **FEATURE** branches are for
    working on new features or changes, **RELEASE** branches help with getting ready
    for a new release, and **HOTFIX** branches are for quickly fixing critical problems
    in the production code.
  prefs: []
  type: TYPE_NORMAL
- en: 'GitFlow is a bit hard to understand at first. On the **MAIN** branch, we have
    the stable version, and on the **DEVELOP** branch, we have the “next” version.
    Each **FEATURE** branch hosts a specific feature that is being developed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.10 – GitFlow schema](img/B20912_08_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.10 – GitFlow schema
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the detailed workflow:'
  prefs: []
  type: TYPE_NORMAL
- en: Start working on a branch called `develop`. Use this branch for your current
    development; this branch must be created from the `main` branch.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, when you begin working on something new (or on a bug fix), create `feature`
    branches; these must be created starting from the `develop` branch.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When you’ve finished working on your feature, just merge your feature branch
    into `develop`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When it’s time to prepare for a new release, create a `release` branch from
    the `develop` branch. Assign a clear and descriptive name, incorporating the version
    number, such as “release/1.0.” Test it deeply to identify and address any bugs,
    ensuring its readiness for production.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the release is ready, combine it with the main part and mark it with a
    version number. Use a pull request to have the code checked and approved by other
    team members.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start over again. Once the release is done, go back to the `develop` branch
    and start over with a new `feature` branch.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Some critical problems may arise due to something that is in the main branch;
    in this case, we want to follow a faster procedure, and not risk deploying the
    feature we’re still developing.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Make a hotfix branch from the main. This branch is crucial for quickly fixing
    important problems or bugs in the production code that can’t wait for the next
    release. It’s like a priority lane for bug fixing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the hotfix is done and has been tested, merge it into both the `develop`
    and main parts to ensure the fix works for both ongoing development and the production
    code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This approach offers a structured approach to code change management, separating
    ongoing development from stable releases and promoting the use of short-lived
    **FEATURE**, **RELEASE**, and **HOTFIX** branches. Code reviews and testing are
    even more facilitated. At the end of the day, GitFlow provides a predictable development
    flow.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, it is undeniably more intricate than other branching strategies.
    Also, it may lead to a larger number of branches (you have to create a branch
    even for really small features or issues); consequently, there’s potential for
    merge conflicts. It is also clear that GitFlow requires a certain level of discipline
    and adherence to the process, and some may perceive it as overly prescriptive
    or inflexible.
  prefs: []
  type: TYPE_NORMAL
- en: 'In summary, no branching model is perfect. Analyze your need and choose one;
    no one says that it cannot be a mix of the models we just presented. I often saw,
    for instance, **HOTFIX** made directly into the **MAIN** branch and other times
    a **HOTFIX** branch opened, depending on the complexity involved in the fix. Also,
    consider that merging is often time-consuming: not only is the merge itself in
    case of conflicts but also the fact that usually, a merge requires a new build.
    If your build is slow, merging your branch to the **MAIN** branch could take time.'
  prefs: []
  type: TYPE_NORMAL
- en: Best practices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although it might sound like a simple task, almost like saving a file in the
    cloud so that you don’t lose it if your computer gets stolen, managing files and
    project versions is another crucial aspect of improving your project management.
    Speaking from experience, it’s good not to underestimate this matter; it’s one
    of the things that sets someone who cares apart. Here are some tips we feel like
    sharing; as usual, it’s all quite flexible and based on our experience.
  prefs: []
  type: TYPE_NORMAL
- en: 'Make it a habit to commit to your work frequently and at the earliest opportunity.
    By doing this, you ensure that each commit captures a specific set of related
    changes. Keep your commits small and focused on a single task or feature. However,
    remember not to commit unfinished work as this can potentially disrupt the stability
    of the code base and create issues (golden rule: do not break the build on the
    main branch!). Instead, break your work into smaller, logical chunks, and commit
    them as you complete each part (or use a feature flag if you feel like that’s
    the case). This practice helps maintain a clean and reliable version history,
    making it easier to track the evolution of your project and collaborate effectively
    with your team.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Always run tests on your code before you commit changes. Testing helps ensure
    that a commit is not just functioning as expected but also that it doesn’t introduce
    any unintended problems or errors into the code base (golden rule: do not break
    the build on the main branch! Yes, I know I already said that). This step is crucial
    because sharing untested commits with your fellow developers can lead to confusion,
    disruptions in the project, and a lot of extra work down the line. By rigorously
    testing your changes before committing, you not only safeguard the stability of
    the project but also demonstrate your commitment to quality and collaboration
    within the development team. It’s a smart practice to help maintain a smooth and
    efficient workflow, building trust among your colleagues, and reducing the need
    for extensive debugging or troubleshooting later on. Remember, a well-tested commit
    is a valuable contribution to the project.'
  prefs: []
  type: TYPE_NORMAL
- en: When writing a commit message, aim for clarity and conciseness. The summary
    should be a brief yet informative glimpse into the nature of your changes, emphasizing
    their intent and how they distinguish themselves from the previous state of the
    code. In addition to a well-written summary, consider providing a more detailed
    description of your changes in the body of the commit message. This helps fellow
    developers, and even your future self, understand the context and significance
    of your modifications. Another valuable practice is linking your code changes
    to relevant work items or issues, enhancing traceability and project management.
    By associating your commits with specific tasks or tickets, you create a more
    organized and transparent system for tracking the progress of your work. For example,
    a common practice for Jira users (Jira is a very popular issue tracker) is to
    include the issue ID in the commit message. At the end of the day, your commit
    message serves as a crucial communication tool within your development team. A
    well-structured message ensures that your contributions are easily understood
    and integrated into the project’s development history, facilitating collaboration
    and maintaining a clear record of your work.
  prefs: []
  type: TYPE_NORMAL
- en: 'One last piece of advice: when managing sensitive information such as passwords,
    it is crucial to exercise vigilant caution. Avoid the inadvertent exposure of
    production passwords and adopt alternative methods for secure storage. One recommended
    approach is to leverage a specialized system such as Vault, which provides a secure
    and centralized repository for managing sensitive credentials. By steering clear
    of committing production passwords directly and opting for such dedicated systems,
    you enhance the overall security posture of your data handling practices. This
    proactive approach not only mitigates the risk of inadvertent leaks but also ensures
    a more robust and scalable solution for safeguarding critical authentication information.'
  prefs: []
  type: TYPE_NORMAL
- en: Code formatting and style
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here’s another part of our job that may seem basic, but no one talks about it...
    except when something goes wrong! From my experience, I believe that this is one
    of the things where developers have different ideas, maybe not entirely, but after
    all, we are precise people, and we all have our little quirks in how we arrange
    the code. As unimportant as it may seem, formatting the code correctly is important.
  prefs: []
  type: TYPE_NORMAL
- en: Code formatting means arranging your computer program in a neat and organized
    way. It’s like making sure your writing follows specific rules so that it’s easy
    to read and understand. When you format your code, you decide on things such as
    how much space to leave between lines, where to put curly braces, and how to name
    things. This makes your code more readable, consistent, and easier to work with.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are various rules and habits to follow when arranging code in Java, but,
    in our opinion, it’s also something very intuitive, almost like a natural skill
    for us software engineers. We’d bet that even without discussing it, we all know
    which one we prefer between the following two code snippets. Here’s the first
    one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the second one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We think we all prefer the first snippet, and that’s because the second one
    lacks proper indentation, which is the first and crucial aspect of how we format
    our code. However, no matter the style, the entire team needs to stick to the
    same standard, which means a set of internal rules that we all expect everyone
    to follow. Rules need to be established for each of the aspects that govern code
    formatting; let’s take a look at the main ones.
  prefs: []
  type: TYPE_NORMAL
- en: Indentation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We use indentation to help us move through a file’s structure. If you think
    about it, a Java source file is a hierarchy of elements: we have the entire file,
    and then we have the classes inside it. Within classes, there are methods, and
    within methods, we have blocks, and so on, in a repeating pattern, including `if`
    statements, loops, and more. To help us navigate through all of this, we use indentation.
    Without indentation, even the simplest methods would be hard to understand. As
    we’ve mentioned before, code is designed to be run by machines but also to be
    understood by humans:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Understanding this very simple code takes much longer if the method is not
    properly indented. This code prints one string if the given number is even and
    another if it’s odd. Understanding this method would have been much quicker if
    it had been indented correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'There are mainly two aspects related to indentation: when to break to a new
    line and how much to move the indented code to the right. For example, you can
    choose to indent the code with a tab or four spaces, or whatever you prefer, so
    long as everyone follows the same style.'
  prefs: []
  type: TYPE_NORMAL
- en: There are some widely used standards and conventions, such as **Oracle’s Java
    Code Conventions** and the **Google Java Style Guide** (both of which are mentioned
    in the *Further reading* section). The first one recommends using four spaces
    for indentation, while the second suggests two. As you can see, it’s a pretty
    diverse world of choices! But, as I’ve mentioned before, what’s important is that
    everyone on the team uses the same set of rules.
  prefs: []
  type: TYPE_NORMAL
- en: Braces and whitespaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Braces play a crucial role in delineating code blocks in Java. The two most
    prevalent brace styles are the **One True Brace Style** (**1TBS**) and **Allman
    Style**.
  prefs: []
  type: TYPE_NORMAL
- en: 'In 1TBS, the opening brace is placed at the end of the line, and the closing
    brace is put on a new line, indented to align with the opening line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In Allman Style, both the opening and closing braces are positioned on their
    individual lines, maintaining the same indentation level as the starting line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'No matter which style you choose, it’s crucial to consistently apply it throughout
    your code base. Furthermore, always include spaces around operators to enhance
    readability:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Both Google and Oracle use 1TBS. Also, Robert Martin’s *Clean Code* suggests
    this. For what it is worth, we also suggest it!
  prefs: []
  type: TYPE_NORMAL
- en: Line length and wrapping
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A simple guideline for the length of lines in your code is to keep them between
    80 and 100 characters (Oracle says 80, Google says 100). Fun fact: the 80-character
    limit for code lines can be traced back to Herman Hollerith, who won the contract
    for processing the 1890 US Census. He used 80-column punched cards to handle the
    data. His company later evolved into IBM.'
  prefs: []
  type: TYPE_NORMAL
- en: 'By keeping your lines between 80 and 100 characters, your code will be easy
    to read on different screen sizes and resolutions. If a line gets too long, you
    can split it into multiple lines while following these examples:'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you have lots of things separated by commas in a method call, you can
    break the line after a comma:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you have a long math expression, you can break the line before an operator:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When you have a long condition, you can wrap it like this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Since the `&&` operator has higher precedence than the `||` operator, line wrapping
    aligns with this logic, making it easier to read.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'For long string concatenations, you can wrap them like this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'However, note that the combination of string formatting and text blocks in
    Java 17 should allow us to bypass this problem. A **text block** refers to a language
    feature that allows you to define multiline strings in a more readable and maintainable
    way. It’s a way to embed blocks of text without the need for cumbersome concatenation
    or escape characters. For example:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When using Lambda expressions, you can align wrapped lines with the opening
    delimiter like this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As Google’s style guide says, you should never split a line right next to the
    arrow in a Lambda, except when the Lambda’s body is just a single, unbraced expression;
    then, you can put a line break right after the arrow.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Comments and documentation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can comment on Java code in three ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Use Javadoc comments (`/** ... */`) for describing classes, interfaces, methods,
    and fields (these are sometimes called documentation comments)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use single-line comments (`//`) for brief explanations, clarifications, or marking
    TODOs (there are sometimes called implementation comments)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use block comments (`/* ... */`) for more extended explanations, especially
    when explaining intricate algorithms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Google Java Style Guide has a specific section for Javadoc’s comments only
    since they are the most important ones. Documentation (Javadoc) is crucial to
    explain to others how to use your code, and that’s why is important to be strict
    when you write it... because you write it, right?
  prefs: []
  type: TYPE_NORMAL
- en: Since we’ve already discussed everything about the form that comments should
    take in code, let me say a few words about the substance of comments. Comments
    for generating Javadoc are crucial, no doubt about it. They don’t explain how
    the code works but rather the behavior of the method. They clarify any specifics
    about the parameters and the situations in which exceptions are raised.
  prefs: []
  type: TYPE_NORMAL
- en: However, I’ve often seen comments being misused. First and foremost, commenting
    out code that is considered unnecessary is not a good practice. If the code is
    unnecessary, please delete it. If you’re concerned about making mistakes, remember
    that VCSs act as a safety net, allowing you to retrieve deleted code with minimal
    effort.
  prefs: []
  type: TYPE_NORMAL
- en: At times, I’ve come across comments related to the implementation. In the case
    of particularly complex code that’s hard to follow, a comment can be helpful.
    However, it should never be seen as a substitute for cleaning up the code to make
    it more understandable. If the code isn’t written well, don’t think you can fix
    it by adding comments. Rewrite the code. Additionally, it’s common for such comments
    not to get updated when the logic of the method changes. The method does one thing,
    but the comment says something else, leading to confusion.
  prefs: []
  type: TYPE_NORMAL
- en: Other types of comments that I don’t find particularly useful, except for rare
    exceptions, are the infamous `TODO` and `FIXME`. If you know you need to fix something,
    just fix it. If you can’t do it right away, record the task in your task management
    system (for example, Jira) and move on. Putting `FIXME` in the code only adds
    confusion. When someone sees that `FIXME` in 2 years, they’ll wonder, “Why hasn’t
    it been fixed yet? Maybe it’s not important.” The same goes for `TODO`.
  prefs: []
  type: TYPE_NORMAL
- en: In summary, we advise you to write as few comments as possible in your code.
    Instead, focus on explaining why you’re making a particular choice and the reasons
    that led you down one path instead of another. As Robert Martin says in *Clean
    Code*, you have to explain your intent.
  prefs: []
  type: TYPE_NORMAL
- en: Naming conventions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Naming conventions play a vital role in enhancing program comprehension and
    improving code readability. They serve as a set of guidelines that, when followed,
    make code more accessible and easier to grasp. These conventions not only contribute
    to readability but also convey essential information about the purpose of an identifier.
    This additional context helps developers understand the role of the identifier,
    whether it represents a constant, package, class, or another entity within the
    code. These conventions are essential tools for effective code communication and
    can significantly aid in the comprehension and maintenance of software systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'Both Google’s and Oracle’s conventions define in-depth rules for naming the
    various components and they have many touchpoints:'
  prefs: []
  type: TYPE_NORMAL
- en: Google’s style guide specifies that identifiers are made up of ASCII letters
    and digits, and occasionally, underscores, as specified by the `\w+` regular expression.
    Special prefixes or suffixes such as `model_`, `cModel`, and `c_name` are not
    used in identifier names.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UpperCamelCase`, which means the first letter of each word is capitalized.
    Class names are typically related to things and are usually nouns, such as `Student`
    or `ImmutableList`. Interface names can also be nouns or noun phrases, such as
    `Set`, or they might sometimes be adjectives or adjective phrases, such as `Serializable`.
    When it comes to naming annotation types, there aren’t specific rules or widely
    accepted conventions. Google’s style guide also specifies that for test classes,
    their names end with `Test`. If a test class covers a single class, it takes the
    name of that class and adds `Test` to the end.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lowerCamelCase`, where the first letter is in lowercase and subsequent words
    are capitalized, such as `sendMessage` or `stop`. Method names are typically related
    to actions or what the method does, and they are like verbs or phrases, such as
    `sendNotification` or `initialize`. Google’s style guide also specifies that method
    names in the `JUnit` test could have underscores to separate different parts of
    the name. Each part is also written in `lowerCamelCase` – for example, `publishPost_translateToUserLanguage`.
    There isn’t a single correct way to name test methods, so you have some flexibility
    here.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UPPER_SNAKE_CASE`, meaning they are written in all uppercase letters with
    words separated by a single underscore. Constants are like unchanging values in
    your code. They are represented as `static final` fields, which means they never
    change once they are set. These constants are deeply immutable, meaning they can’t
    be modified in any way, and they don’t have methods that cause any noticeable
    side effects. Examples of constants include simple data types such as numbers,
    text (strings), unchangeable value types, and even things set to `null`. But here’s
    the key: if anything about this value can change or be observed differently over
    time, it’s not a constant (you could have guessed that).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lowerCamelCase`, where the first letter is lowercase, and subsequent words
    are capitalized. When it comes to naming parameters in public methods, it’s a
    good practice to avoid using single-character names whenever possible. As Robert
    Martin’s *Clean Code* states, using more descriptive names makes it easier for
    others to understand the purpose of the parameter (just think about naming a parameter
    `x`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lowerCamelCase`. Even if a local variable is declared as `final` and remains
    unchanged, it’s not regarded as a constant, and therefore, it should not be named
    like a constant.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automated tools
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We cannot think of implementing all these rules by hand every time we write
    a line of code. Well, it used to be done that way once, but even I am not old
    enough to have seen it! Fortunately, we have automatic tools at our disposal that
    help us on various levels.
  prefs: []
  type: TYPE_NORMAL
- en: For example, **integrated development environments** (**IDEs**) play a significant
    role in supporting code formatting by providing tools and features to help developers
    adhere to coding standards and automatically format their code. IDEs facilitate
    code formatting by performing auto-indentation – that is, automatically indenting
    code blocks – making it easier to read and understand the code’s structure. Indentation
    can be customized according to the coding standards of your project. Furthermore,
    most IDEs allow developers to define and customize code style preferences. These
    preferences include settings for indentation, brace placement, line wrapping,
    and naming conventions. Developers can tailor these settings to match the coding
    standards of their project or organization. IDEs come with built-in or customizable
    code formatters that automatically format your code based on the defined coding
    style preferences. These formatters ensure that your code follows the established
    standards consistently.
  prefs: []
  type: TYPE_NORMAL
- en: But don’t worry, you don’t have to set up all the nitty-gritty of your IDE’s
    formatting settings details; most of them – especially the most used ones – have
    the chance to export the so-called **code style formatter**. You just have to
    discover how your IDE does it (or just google it), export your file, and make
    sure everyone in the team is using that file, importing it in their IDE. When
    you format your code in your IDE – via the relative command or shortcut – the
    code style will be the same for everyone... everyone who’s using the same IDE,
    of course. Yes, because these code styles are specific for each IDE; NetBeans’
    one is different from Eclipse’s one.
  prefs: []
  type: TYPE_NORMAL
- en: There are many solutions to this problem. For example, you could try to manually
    edit your exported code style file (which is always a text file) so that it adapts
    to the destination IDE; however, I don’t feel like advising you to do that. A
    possible solution could be to use a cross-IDE tool, a tool that is essentially
    the same for everyone. For example, there is a tool called **CodeConfig** ([https://editorconfig.org](https://editorconfig.org))
    that allows you to configure a code style and can be installed on numerous different
    IDEs (many, such as IntelliJ, support it natively). Alternatively, you could move
    the problem somewhere else.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re working on a Java project, you’re probably using a build automation
    tool such as Gradle or Maven. These tools allow you to compile code, among other
    things, and, in general, simplify the entire development life cycle. As you know,
    there are various plugins available for these tools. Some of them directly modify
    the code itself – in this book, we’ve seen examples such as Lombok and MapStruct.
  prefs: []
  type: TYPE_NORMAL
- en: Some plugins intend to check your code for any problems with code style. One
    of the most famous is Checkstyle. The Apache Maven Checkstyle Plugin (see the
    *Further reading* section) integrates the Checkstyle tool into your Maven build
    process to enforce coding style and standards on your Java source code. Checkstyle
    is an open source static code analysis tool that checks your Java code against
    a set of predefined coding conventions and style rules. You define your coding
    style rules and preferences in a Checkstyle configuration file, typically named
    `checkstyle.xml`. This file specifies which coding standards you want to enforce,
    such as naming conventions, indentation, and formatting rules. Then, the Apache
    Maven Checkstyle Plugin is configured in your project’s `pom.xml` file. You specify
    the Checkstyle rules file and other settings to be used during the build. When
    you run a Maven build (for example, via `mvn clean install`), the Apache Maven
    Checkstyle Plugin is executed as part of the build process. It scans your Java
    source code files for violations of the defined coding standards. If Checkstyle
    detects any violations, it generates a report that lists the issues found in your
    code. This report can be viewed in various formats, such as HTML or XML. You can
    configure the plugin to either fail the build if violations are found or generate
    a warning report without failing the build. The choice depends on your project’s
    requirements. The Apache Maven Checkstyle Plugin is useful to get an overview
    of any problems you might have, but it does not fix them for you.
  prefs: []
  type: TYPE_NORMAL
- en: Some plugins handle code formatting. By integrating these plugins into your
    development process, you can ensure that your code is automatically formatted
    with every build, without the need for manual intervention. A Maven plugin that
    you could use is **maven-formatter-plugin** ([https://code.revelc.net/formatter-maven-plugin](https://code.revelc.net/formatter-maven-plugin)),
    which, by default, supports the “Eclipse style” but can be configured with any
    code style. We haven’t eliminated the complexity of the “file transfer” step,
    but we’ve integrated code formatting into our development cycle. But we can be
    even smarter than that.
  prefs: []
  type: TYPE_NORMAL
- en: In software companies, CI/CD tools such as GitLab or Jenkins are now widespread.
    If you’re new to the concept, a CI/CD pipeline is an automated workflow that streamlines
    the software development and delivery process. It starts with CI, where developers
    frequently merge their code changes into a shared repository. Automated builds,
    testing, and code analysis are performed to ensure code quality and identify issues
    early. **Continuous delivery** (**CD**) follows CI and involves deploying code
    changes to staging or pre-production environments. Additional testing and quality
    checks are conducted to simulate production conditions. After successful testing,
    the code can be automatically deployed to the production environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'When it comes to formatting and styling code, you can set up an automatic system
    that checks how code is written. Every time new pieces of code are pushed into
    the repository, this automatic system checks if the code follows formatting rules.
    Depending on how we set up this system, it can be a simple check that tells us
    if the code isn’t written correctly, or it can be stricter and stop the process
    if there are serious issues (though this rarely happens). Furthermore, this system
    can do something really helpful: it can fix poorly written code so that it follows
    the shared rules of our group or company. In practice, this system “re-commits”
    the same pieces of code, but this time, they are formatted correctly. This means
    we might not have to worry about fixing the code manually anymore.'
  prefs: []
  type: TYPE_NORMAL
- en: 'One last side note: formatting code in the same way is also important to reduce
    merge conflicts and unintentional code commits. Let’s imagine that Developer A
    uses `CodeStyleA`, while Developer B uses `CodeStyleB` (as expected). Developer
    A makes a small change, let’s say a five-line method, inside a class. Being diligent,
    they initiate code formatting for the entire class using their IDE. Since Developer
    A is using their personalized `CodeStyleA`, they will likely unintentionally commit
    other parts of the class that weren’t the intended focus of the change. This results
    in lines that were altered by Developer A but, in a way, weren’t supposed to be.
    On the other hand, Developer B is making changes to the same class but in a different
    place. When they need to push their code, they find the same lines changed by
    Developer A, but only because Developer A *incorrectly formatted* the code. This
    may seem like an edge case, but it’s not uncommon – I’ve seen it happen many times.
    It’s not a disaster by any means, but it’s time wasted that can be saved with
    a bit of care.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve discussed code versioning and style, let’s talk about a practice
    that can’t be emphasized enough.
  prefs: []
  type: TYPE_NORMAL
- en: Code reviews
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Code reviews**, often also called **peer reviews**, are a very powerful tool
    for developers’ daily work. We could almost say that they are fundamental, but
    the truth is that under certain conditions, it is possible to choose whether to
    perform them or not, provided, however, that if not, other methodologies are implemented.
    But let’s go in order and try to understand what a code review is.'
  prefs: []
  type: TYPE_NORMAL
- en: A code review can be implemented in slightly different forms, but it typically
    consists of submitting a piece of code to one or more developers who did not write
    that code; these people are usually referred to as “reviewers.” So, for example,
    if you own a certain task and you developed the relative code, before deploying
    it in production (or usually even before merging your feature branch on your main
    branch, depending on your “framework”), your code is reviewed by some other teammate
    who did not write a single line of that code. The aim is not to judge and the
    benefits are vast.
  prefs: []
  type: TYPE_NORMAL
- en: First of all, there is a sort of quality assurance. It allows developers to
    catch and rectify defects, bugs, and vulnerabilities in the code before it reaches
    the end users. By detecting issues early in the development process, code review
    significantly reduces the cost and effort required to fix them in later stages
    of development or after deployment.
  prefs: []
  type: TYPE_NORMAL
- en: Beyond catching bugs, code review can also reveal design flaws and inefficiencies
    in the code. By discussing and suggesting improvements during code review, developers
    can refine the software’s architecture, making it more robust and scalable.
  prefs: []
  type: TYPE_NORMAL
- en: Maybe even more important – but this is arguable – is knowledge sharing. Code
    review is a learning opportunity for all team members. It promotes knowledge sharing
    and mentorship, where experienced developers can guide less experienced ones.
    This collaborative aspect fosters a culture of continuous learning and improvement
    within the development team.
  prefs: []
  type: TYPE_NORMAL
- en: Code review ensures that the code adheres to a consistent coding style and follows
    the project’s coding guidelines. This consistency makes the code base more maintainable
    and understandable, especially when multiple developers are working on the same
    project. Remember, your code is only clean if everyone on the team thinks it is!
  prefs: []
  type: TYPE_NORMAL
- en: 'Then comes one of my favorite aspects: that code review encourages effective
    communication within the development team. Developers engage in discussions about
    the code, which can lead to a better understanding of the project’s goals and
    requirements, resulting in a more aligned and cohesive team. This, in my opinion,
    also encourages a culture of feedback, which is crucial within companies and teams;
    it is one of the moments in which we learn to communicate our feedback effectively
    and, above all, in which we learn to receive it, appreciating it for what it is
    – that is, a gift to our professional growth. Trust the touchy-feely – the code
    review is one of the most learned moments.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A code review becomes more effective if you set some sort of rules, I dare
    almost say limits to what you are going to observe: are we looking for inefficiencies,
    are we trying to make the code cleaner, are we looking for bugs, are we doing
    all these things? No problem, just agree and set expectations. Keep code review
    sessions short and sweet. Decide on what works for your team, such as maybe sticking
    to a rule of not going over 1 hour or reviewing more than 200 lines of code at
    a time. This keeps things productive.'
  prefs: []
  type: TYPE_NORMAL
- en: As much as possible, use tools and automation. For example, tools such as GitHub
    help us with code reviews, with the ability to compare different versions of code,
    write comments, and more. Automatic tools for static code analysis, which were
    already addressed in the previous chapters, allow us – if integrated into pipelines,
    for example – to avoid the most common inaccuracies such as the organization of
    imports, code formatting, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Again, the human factor is fundamental. Try to be constructive in giving feedback
    and try to be “open-minded” in receiving it; it’s not a race, it’s a cooperation
    between equals. The goal must only be to achieve a common result and to do it
    together. Code review should be a constructive process, not a blame game. Use
    polite language and provide suggestions for improvement rather than criticizing
    the author. The goal is to enhance the code, not demotivate the developer. Make
    sure everyone on your team, whether they’re new or experienced, takes part in
    code reviews. It helps newer team members learn about the code and allows them
    to have their work checked by more experienced developers. This way, the workload
    can be balanced, and it’s easier to manage when someone is absent or leaves the
    team.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, appointing a moderator or lead developer to facilitate the code review
    process can be a key element in maintaining its effectiveness. They serve as a
    guiding force, ensuring that the review discussions stay productive and on track.
    The moderator’s responsibilities encompass structuring the review process, clarifying
    expectations for both authors and reviewers, mediating discussions, and balancing
    feedback. They also play a vital role in prioritizing issues, documenting outcomes,
    and mentoring less-experienced developers.
  prefs: []
  type: TYPE_NORMAL
- en: To be honest, there are also some disadvantages in code reviews – that is why
    they’re sometimes not well-seen by tech-illiterate managers.
  prefs: []
  type: TYPE_NORMAL
- en: The review process has the potential to extend the time it takes to release
    a software update. This delay occurs because reviewers and authors must collaborate
    to address issues, which can be time-consuming. Furthermore, reviewers may not
    be able to expedite the review process due to their existing workload. However,
    this hurdle can be mitigated through the utilization of code review tools equipped
    with automated testing capabilities. These tools effectively identify common errors,
    thereby freeing up valuable developer time that can be redirected toward tackling
    more complex software engineering challenges.
  prefs: []
  type: TYPE_NORMAL
- en: Developers often find themselves juggling a substantial workload, and the need
    for a code review can divert their attention from other critical tasks that demand
    their immediate attention. This diversion poses a dilemma for team members who
    must choose between completing their ongoing responsibilities or pausing their
    work to conduct a code review. In either scenario, work somewhere within the organization
    is delayed. To alleviate this issue, team members can implement strategies such
    as a reviewer rotation system or maintain a list of domain experts who can share
    the reviewing burden. These measures prevent any single developer from becoming
    overwhelmed by a multitude of review requests.
  prefs: []
  type: TYPE_NORMAL
- en: When developers are tasked with reviewing a substantial code alteration, the
    review process tends to consume a considerable amount of time. Assessing large
    code changes can be particularly challenging, and reviewers may feel compelled
    to expedite the process to meet deadlines, potentially compromising the quality
    of feedback. An effective solution to this challenge is the practice of incremental
    code development. This approach allows reviewers to examine smaller code segments
    multiple times, as opposed to grappling with a massive code change all at once.
    This not only enhances the quality of the review but also streamlines the overall
    process.
  prefs: []
  type: TYPE_NORMAL
- en: There are different types of code reviews, which we will list in order of effectiveness,
    starting with the one that we think is the least effective.
  prefs: []
  type: TYPE_NORMAL
- en: Email pass-arounds
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Email pass-arounds** are a common way of dealing with small issues and tiny
    bits of code. You can do this by sending emails or using code tools. In an email
    pass-around, the person who made the code changes sends an email to those who
    need to check it. It’s like looking at someone’s screen over their shoulder, and
    it’s quite easy to use. You don’t need a lot of training, and you can start right
    away. Of course, think of “email” as “a direct message to someone…” I mean, who
    uses email to communicate with their teammates nowadays?! It can, of course, be
    a Slack message, or a “merge request” on GitLab... anything.'
  prefs: []
  type: TYPE_NORMAL
- en: The advantages of using email pass-arounds include ease of setup, remote and
    asynchronous review possibilities, and automatic reviews in some code management
    systems.
  prefs: []
  type: TYPE_NORMAL
- en: However, there are drawbacks to email pass-arounds, such as the time it takes
    to collect necessary files, difficulty in tracking and following conversations
    within email threads, the absence of a definite end date for the review, uncertainty
    about whether the changes were implemented, and challenges in measuring its effectiveness.
    In all honesty, I found references to this practice only “in literature;” I’ve
    never seen it happen.
  prefs: []
  type: TYPE_NORMAL
- en: Code review automation tools
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Teams sometimes use automated tools to save time and ensure they deliver high-quality
    code. These tools can automatically collect and display code changes, streamline
    feedback through comments, and even help find and fix vulnerabilities using **static
    application security** **testing** (**SAST**).
  prefs: []
  type: TYPE_NORMAL
- en: Think of these tool-assisted reviews as a valuable addition to other review
    methods. They help maintain coding standards, identify vulnerabilities, collect
    data efficiently, and streamline the review process. However, some teams might
    be tempted to rely solely on these tools and skip involving team members in code
    reviews. It’s crucial to view these tools as enhancements to the process rather
    than replacements.
  prefs: []
  type: TYPE_NORMAL
- en: Tool-assisted reviews can simplify data collection and metrics, and free up
    developers to focus on their work. There are some disadvantages, too, that rely
    on the developer’s need to manage and maintain the tools – some tools are often
    really expensive and do not completely remove the necessity of a human review.
  prefs: []
  type: TYPE_NORMAL
- en: In-person (or remote) teamwork reviews
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In these reviews, two developers work together, either in person or through
    a shared screen online. One developer is the author who made the code changes,
    and the other is the reviewer. The author explains the changes they made and why
    they chose those solutions. The reviewer asks questions and gives suggestions,
    kind of like how team members work together when pairing. The author can make
    small changes during the review and note bigger fixes for later.
  prefs: []
  type: TYPE_NORMAL
- en: 'Advantages are pretty straightforward: in-person meetings (sometimes, they’re
    also called over-the-shoulder reviews) are easy to set up and complete, and of
    course, can be done remotely. They’re quicker than pair programming (which we’ll
    delve into in a minute).'
  prefs: []
  type: TYPE_NORMAL
- en: However, it can happen that the reviewer may not be as connected to the code;
    in this case, a lot of time would be needed to explain the background and all
    of the nitty-gritty of the code – or, even worse, the review would be done hastily,
    quicker than necessary. In this context, there could be some lack of objectivity;
    without knowing the context (basically, all the code under review just “rained”
    over the reviewer’s head), you can’t be sure that all the needed implementations
    were made. In general, it’s tricky to understand how well the code is doing.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we’re getting to what we think is the most effective review technique,
    even though it’s not entirely a review technique. Pair programming is a lot more
    than that.
  prefs: []
  type: TYPE_NORMAL
- en: Pair programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Perhaps it is simplistic to talk about pair programming as a mere code review
    technique, but this is just the starting point.
  prefs: []
  type: TYPE_NORMAL
- en: '**Pair programming** is a software development technique that requires each
    feature to be created by a pair of programmers, working on the same workstation
    (also, consider being able to do it remotely by sharing the screen). A person
    writes the code and is called the driver; the other, the navigator, makes a sort
    of instant revision of every line that is written at the time it is written. The
    driver focuses on the details of the implementation, while the navigator takes
    a broader view, reviews the code, and helps with problem-solving.'
  prefs: []
  type: TYPE_NORMAL
- en: It is a very powerful technique that has many advantages and – inevitably –
    some disadvantages. Let’s get to know them.
  prefs: []
  type: TYPE_NORMAL
- en: Advantages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The quality of the software improves: programmers are led to bring their different
    experiences together, bringing different points of view and different approaches.
    Pair programmers work closely together throughout the development process, discussing
    design decisions, code structure, and potential improvements in real-time. Having
    two sets of eyes on the code can lead to cleaner code, fewer bugs, and more robust
    solutions. What’s best, the navigator can catch errors and suggest improvements
    as they arise. Two minds working together often lead to more creative and effective
    problem-solving. Programmers can bounce ideas off each other and explore different
    solutions. Since code is reviewed in real-time, it’s more likely that issues are
    spotted and corrected before they become major problems, reducing the debugging
    and maintenance effort.'
  prefs: []
  type: TYPE_NORMAL
- en: Another immediate advantage is knowledge sharing. Pair programming helps distribute
    knowledge and expertise among team members (or even among members of different
    teams, who are working together to bring in their respective knowledge). It’s
    an effective way to transfer skills and best practices from more experienced developers
    to less experienced ones. Pair programming can be more powerful than any knowledge-sharing
    session.
  prefs: []
  type: TYPE_NORMAL
- en: Also, to be considered is a certain element of team building and improvement
    of communication in general within the team. By collaborating closely, you can
    hone all those soft skills needed in your daily work with other people and maybe
    even your feedback culture.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, pair programming increases focus – it significantly boosts focus by
    minimizing distractions. The shared responsibility between the “driver” and “navigator”
    fosters a concentrated mindset, reducing the likelihood of drifting. This collaborative
    approach ensures constant code review and real-time communication, creating an
    environment where both individuals are actively engaged in problem-solving. In
    essence, pair programming not only deters distractions but actively cultivates
    a focused and productive development atmosphere. Something may change when pair
    programming is done from a remote location, but not that much.
  prefs: []
  type: TYPE_NORMAL
- en: One factor to consider is the level of seniority of the two programmers, both
    in general and on the individual task. For example, pairing two experienced developers
    could be the right choice to boost productivity. A pair made by two novice developers
    is unlikely to happen, even if it could bring some problems, given my lack of
    what we could call a “role model.” Anyway, it’s still better than two novice programmers
    working independently. The expert-novice pair is one of the most common; this
    kind of pairing can foster the introduction of fresh ideas as less experienced
    individuals are often more inclined to question established practices. Simultaneously,
    the experts, while being asked to clarify established methods, are encouraged
    to reevaluate them. Nonetheless, within this pairing dynamic, a novice who feels
    intimidated might become a passive observer, hesitating to actively engage. Similarly,
    certain experts may lack the patience necessary to facilitate productive participation
    from novices. Some refer to this phenomenon as “watch the master.”
  prefs: []
  type: TYPE_NORMAL
- en: Disadvantages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first disadvantage – perhaps the most obvious one, and the one that your
    tech-illiterate manager might argue with – is that with pair programming, you
    have two people doing the work of one. If this is not true (we have previously
    seen all the advantages and peculiarities of pair programming, in which the roles
    are distinct and several jobs are carried out at the same time) it is true that
    pair programming is resource-intensive as you have two programmers who take care
    of the same task. In a world where there are never enough developers to do all
    the work, this could be a problem to address.
  prefs: []
  type: TYPE_NORMAL
- en: It is also undeniable that the code will be ready in a longer time; if two people
    take care of the same task, it is obvious that the “busy” tasks will be fewer
    in absolute number. In the case of very tight deadlines, this could be a problem.
  prefs: []
  type: TYPE_NORMAL
- en: It would be better, then, to balance the level of seniority of the two programmers
    involved so as not to create “watch the master” situations or excessive tutoring
    of a junior resource.
  prefs: []
  type: TYPE_NORMAL
- en: In our opinion, pair programming needs to be properly modulated. Not all tasks
    are suitable for pair programming. Let’s imagine a repetitive task without too
    much-added value, something that is not complicated from any point of view – it
    is just very long. The added value that a possible driver can give would be very
    small; in that case, it would be much better, in our opinion, to opt for a classic
    “delayed” code review process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Moreover, pair programming might not be for everybody: some people just don’t
    get along, or others prefer to work individually. In this case, it’s better not
    to force the hand on this practice, or start with short sessions (let’s say, an
    hour or so).'
  prefs: []
  type: TYPE_NORMAL
- en: I have used pair programming a lot in my career, and I must point out that it
    has also happened that some colleagues did not feel suitable for pair programming,
    especially in contexts where the percentage of time for which this practice is
    carried out is greater than individual programming. Some people prefer to work
    alone, perhaps exploring freely, following only the logical thread of their thoughts
    and perhaps converging with teammates only later. The humble advice we would like
    to give in these cases is not to force the hand with pair programming or in any
    case to agree at a team level – as trivial as it may be, I think it is the only
    thing that can work in this case.
  prefs: []
  type: TYPE_NORMAL
- en: A very interesting paper about the costs and benefits of pair programming can
    be found in the *Further* *reading* section.
  prefs: []
  type: TYPE_NORMAL
- en: Styles of pair programming
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Pair programming is hard. You have to be extremely focused, especially – I would
    say – in the role of the navigator. Pair programming can be both exhausting and
    fulfilling. Typically, most programmers can only effectively pair for about 5
    to 6 hours a day. Therefore, it’s important to schedule breaks and regularly switch
    pairs. There are many ways in which you can manage your pair; in the following
    sections, we’ll see some of them.
  prefs: []
  type: TYPE_NORMAL
- en: Driver and navigator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is the classic pair programming style. The **driver** is the individual
    in control of the keyboard, concentrating on accomplishing the current small task
    while temporarily setting aside broader concerns. They are encouraged to vocalize
    their actions as they perform them. The **navigator**, who’s positioned as an
    observer while the driver operates the keyboard, actively assesses the code in
    real-time, provides guidance, and communicates their thoughts. The navigator maintains
    awareness of larger issues and potential bugs, taking note of prospective next
    actions or obstacles as they arise.
  prefs: []
  type: TYPE_NORMAL
- en: 'A typical workflow typically follows these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start with a well-defined, preferably small task.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Reach a consensus on a singular, manageable objective at a time. This can be
    defined by a unit test, for example.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Regularly interchange roles and the keyboard. This shared, active participation
    maintains energy levels and enhances comprehension. What does “regularly” mean?
    We’ll see shortly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the role of the navigator, refrain from getting lost in the immediate tactical
    details of coding since the driver focuses on those. Your responsibility is to
    step back and complement your partner’s tactical approach with medium-term thinking.
    Jot down upcoming tasks, potential roadblocks, and ideas on sticky notes. Discuss
    them after the completion of the current tiny goal to avoid disrupting the driver’s
    workflow.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ping-pong pairing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The **ping-pong pairing** technique is closely aligned with TDD and is particularly
    effective when you have a well-defined task that can be approached in a test-driven
    manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '“Ping”: Developer A initiates by creating a failing test.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '“Pong”: Developer B responds by writing the code necessary to make the test
    pass.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Developer B then takes the lead by initiating the next “ping,” which involves
    creating the next failing test.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After each “pong,” it’s common practice to collaboratively refactor the code.
    This step aligns with the “Red – Green – Refactor” approach, which we encountered
    in the previous chapters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Strong-style pairing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Strong-style pairing** is a method that helps people learn by working closely
    together. It’s like a mentor teaching a newbie.'
  prefs: []
  type: TYPE_NORMAL
- en: The main rule is, “Before you do something on the computer, talk to someone
    else about it.” In this method, the experienced person usually guides the less
    experienced one. The important thing is that the learner must trust the teacher
    and not worry if they don’t understand everything at first. Questions and discussions
    can happen after they try things out.
  prefs: []
  type: TYPE_NORMAL
- en: This method is a bit like having someone watch over your shoulder, but it’s
    really good for teaching. It’s best for getting started with new things, but you
    shouldn’t use it too much. The goal is for the learner to become more independent
    over time. That’s when you know the teaching has worked.
  prefs: []
  type: TYPE_NORMAL
- en: Time management
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It’s important to manage your time in pair programming; deciding how long a
    person should remain a driver and how long they should be a navigator greatly
    changes the developer experience in pair programming. A very well-known technique
    – but I must say very little used – is the **Pomodoro technique**.
  prefs: []
  type: TYPE_NORMAL
- en: This method can be integrated with most of the pairing approaches mentioned,
    helping maintain focus. Pair programming can be tiring, so having prompts for
    breaks and switching roles is beneficial.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Pomodoro technique is a time management method that was developed by Francesco
    Cirillo in the late 1980s. It’s designed to help people enhance productivity and
    maintain focus. For all the non-Italian speakers out there: “*Pomodoro*” means
    “*tomato*” and it refers to a simple Pomodoro-shaped kitchen timer.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how this technique works:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Set a timer**: Choose a task you want to work on. Set a timer for 25 minutes,
    which is called one “Pomodoro.” During this time, you commit to working on the
    task with full concentration.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Work intensely**: While the timer is running, work on your task with focused,
    undivided attention. Avoid distractions, such as checking your phone or email.
    I’m not saying that you should also ignore calls from your wife, but it’s strongly
    recommended; to use this book as an excuse.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Take a short break**: When the timer rings after 25 minutes, take a short
    5-minute break. Use this time to relax, stretch, or do something unrelated to
    work. It’s a brief reward for your focused effort.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Repeat**: After the short break, go back to another 25-minute Pomodoro session.
    Keep repeating these cycles of work and short breaks.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Longer break**: After completing four Pomodoro sessions (totaling 2 hours
    of work), take a longer break of 15-30 minutes. Use this time to recharge and
    plan your next tasks.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Pomodoro technique aims to leverage the benefits of focused, concentrated
    work while preventing burnout. It encourages you to break your work into smaller,
    manageable chunks with built-in breaks. This method can help improve time management,
    reduce procrastination, and boost overall productivity. It’s particularly useful
    for tasks that require deep concentration, not only programming; we think it should
    be taught at school.
  prefs: []
  type: TYPE_NORMAL
- en: The Pomodoro technique can be used to manage pair programming sessions; whenever
    a Pomodoro ends, the driver and navigator switch roles. You decide if this technique
    is good or if it is too “rigid.” These and all the others are just suggestions
    – it’s up to you to find the right size and the right pace of work.
  prefs: []
  type: TYPE_NORMAL
- en: Documentation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we talk about documentation, we can talk about a lot of things. In general,
    the term *documentation* refers to the process of creating and maintaining written
    records and materials that describe various aspects of a software project. This
    documentation serves multiple purposes and is essential for the successful development,
    maintenance, and understanding of software systems.
  prefs: []
  type: TYPE_NORMAL
- en: In simple terms, this means we can have different kinds of documentation in
    software development – some very technical, and others not so much.
  prefs: []
  type: TYPE_NORMAL
- en: Requirements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Requirements documentation** is where you define what the software should
    be like. It’s like the building plan for the software.'
  prefs: []
  type: TYPE_NORMAL
- en: Requirements documentation in software development is like making a detailed
    wish list or set of instructions for what a new piece of software should do. It’s
    a way to precisely define and describe what the software needs to achieve and
    how it should behave. This documentation outlines the features, functions, and
    qualities the software should have to meet the needs of its users or the business.
  prefs: []
  type: TYPE_NORMAL
- en: This documentation is crucial because it acts as a guide for the software developers.
    It helps them understand the expectations and goals set by the clients or stakeholders.
    Think of it as a blueprint that details the foundation and boundaries within which
    the software will be designed, built, and tested. Requirements documentation is
    like drawing a map that shows the path for building the right software that fulfills
    specific needs and functions as intended.
  prefs: []
  type: TYPE_NORMAL
- en: Requirements documentation is a phase that comes after the collection and analysis
    phases. I refer you to the *Further reading* section for more in-depth information.
    Once gathered, it’s uncommon for requirements to be simply written in a lengthy
    and formal textual document. According to our experience, what happens more often
    is that spreadsheets or specialized tools are used. If spreadsheets are used,
    each requirement is typically represented by a row, and each attribute of the
    requirements, such as an ID, a description, a priority, a reporter, and so on,
    is represented by a column. The same information, and often much more, is managed
    through specific software for “issue tracking,” such as Jira or Redmine. Requirements
    documentation then becomes the collection of information – the issues – stored
    in these tools. It’s widely used, especially in Agile development frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: Architecture documentation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Architecture documentation**, also known as **software architecture description**,
    is a unique form of design document. If design documents derive directly from
    the code, architecture documents are a step forward (someone says they’re the
    third derivative, starting from the first one, which is the code). These documents
    contain very little information that is specific to the code itself; the nitty-gritty
    of the implementation must be kept away. They don’t explain how to code a particular
    function or why a specific function is designed the way it is. Instead, they outline
    the general requirements and reasons that lead to the creation of such functions.
    A well-crafted architecture document is concise in details but rich in explanations
    – also rich in images and graphs, I would say. It might offer suggestions for
    lower-level design but delegates the actual exploration and trade studies to other
    documents.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Architectural documentation is probably the first thing that a new member of
    your team would read. That’s one of the reasons why we’re saying it’s crucial:
    software architecture documentation helps different people involved in a project
    to have a common understanding of how the system works.'
  prefs: []
  type: TYPE_NORMAL
- en: 'One way to document your architecture is the typical one: just draw a bunch
    of boxes on a whiteboard and connect them with arrows and lines! Or... there’s
    a more structured approach called **C4**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The C4 approach, also known as the **C4 model**, is a framework for visualizing
    and documenting software architecture. It was created by Simon Brown and is designed
    to provide a clear and concise way to represent and communicate the architecture
    of a software system. **C4** stands for **Context**, **Containers**, **Components**,
    and **Code**, which are the four levels of abstraction in this model:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Context diagram** (**C1**): This is the highest level and provides an overview
    of the entire system, showing its interactions with external entities and systems.
    It helps establish the system’s boundaries and its place in the broader ecosystem.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Container diagram** (**C2**): The next level, the container diagram, focuses
    on the high-level building blocks within the system. It represents containers,
    such as web servers, databases, mobile apps, and more, and shows how they interact
    with each other.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Component diagram** (**C3**): Below containers, the component diagram delves
    into the internal structure of each container, breaking them down into individual
    components or services. This level provides more detail about how each container
    works internally.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Code** (**C4**): At the lowest level, you have the actual source code, where
    the details of the individual components are documented. This level includes class
    diagrams, code snippets, and other fine-grained details.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The C4 approach is a way to create a hierarchy of visual representations to
    describe and understand a software system’s architecture. It helps in simplifying
    complex systems, making it easier to communicate and collaborate on software design
    and development.
  prefs: []
  type: TYPE_NORMAL
- en: Diving deeper into this approach would be a bit outside the scope of this book,
    so I suggest that you visit the official C4 website. A link has been provided
    in the *Further* *reading* section.
  prefs: []
  type: TYPE_NORMAL
- en: Technical documentation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Technical documentation** covers a lot of stuff, and it even includes architectural
    documentation. But in this case, I wanted to point out a specific kind of documentation.
    It’s the one that gets into the nitty-gritty details, such as code, modules, APIs,
    microservices, and other low-level stuff. It’s way more detailed than what you’d
    usually find in architectural documentation.'
  prefs: []
  type: TYPE_NORMAL
- en: Documentation can come in various shapes and sizes, ranging from elaborate design
    documents to straightforward README files. The choice of format depends on the
    specific product, system, or service being described. Regardless of the form it
    takes, the primary goal of technical documentation is to assist developers in
    resolving issues without requiring them to undertake additional research.
  prefs: []
  type: TYPE_NORMAL
- en: Even if is often disregarded, technical documentation is crucial; unfortunately,
    it’s also very hard to do and very time-consuming. It’s the very first thing that
    is ignored when your time runs out. “We’ll do it” and you never will. So, our
    suggestion here is to include the writing of the documentation in your daily work;
    in other words, in your software development life cycle. For example, you could
    agree on a “definition of done” (a checklist or set of criteria that determines
    when a task or project is considered completed and meets the required quality
    standards) that includes documentation.
  prefs: []
  type: TYPE_NORMAL
- en: There are various types of documentation you should take care of.
  prefs: []
  type: TYPE_NORMAL
- en: '**SDK documentation**: SDK documentation provides instructions for integrating
    new software into an existing application. It covers software usage, capabilities,
    and interactions with other applications, making it essential for developers to
    enhance app features.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Source code documentation**: Source code documentation includes code examples
    to guide developers in software usage. Focus on explaining necessary parts rather
    than everything in the code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Release notes**: Release notes are technical documents detailing changes
    in a new product release, such as new features, bug fixes, and known issues. Developers
    and testers use them to grasp what’s new.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Knowledge base documentation**: This document houses knowledge that developers
    can use for software development and maintenance. It covers tools, languages,
    methods, design principles, how-to guides, troubleshooting, and FAQs, fostering
    knowledge sharing and efficiency in software development.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**API documentation**: API documentation explains how a program’s interface
    functions, offering details about methods, parameters, and what the API returns.
    It may come as tutorials or guides, aiding developers in understanding and using
    the API.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are a couple of tools we want to suggest that can improve your API documentation
    and automate it – partially, at least.
  prefs: []
  type: TYPE_NORMAL
- en: Swagger
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first one is really widespread, and it’s called **Swagger**. Swagger is
    an open source framework and a suite of tools that enables you to design, build,
    and document RESTful web services. It provides a way to describe and document
    the functionality of an API in a standardized and machine-readable format, often
    in JSON or YAML.
  prefs: []
  type: TYPE_NORMAL
- en: 'Swagger offers several key benefits, apart from the documentation itself: it
    can also generate client and server code in various programming languages, reducing
    the effort needed to integrate with the API. A very useful feature is that it
    includes tools for testing and debugging APIs, making it easier to identify and
    resolve issues. Last but not least, Swagger uses the **OpenAPI Specification**
    (formerly known as the **Swagger Specification**), a widely adopted standard for
    describing RESTful APIs. This promotes consistency and interoperability among
    different systems and developers.'
  prefs: []
  type: TYPE_NORMAL
- en: 'How can you integrate Swagger into your application? It’s a piece of cake,
    especially if you’re using Spring Boot. Supposing you’re using Maven, it’s enough
    to add a couple of dependencies in your POM file. If you’re using also **Spring
    Boot 3**, it’s only one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In other cases, you will have to add some other dependencies and a couple of
    configurations. Nothing difficult and nothing long. You’ll find an excellent tutorial
    in the *Further* *reading* section.
  prefs: []
  type: TYPE_NORMAL
- en: 'And then? Nothing – that’s it! Now, let’s suppose we have a “classic” REST
    controller written in Java, something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can assume from the `@RestController` annotation, this class exposes
    its public methods as public APIs. The first one returns a list of employees and
    takes no input parameters (it doesn’t handle HTTP statutes, nor pagination...
    it’s just an example!); the second one is needed to insert a new employee and
    it has a body defined by the `Employee` class. Swagger can understand all of this
    and automatically generate an OpenAPI-compliant documentation. The following screenshot
    is just a part of the huge JSON that is generated by Swagger to adhere to the
    OpenAPI standard:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.11 – Huge JSON generated by Swagger](img/B20912_08_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.11 – Huge JSON generated by Swagger
  prefs: []
  type: TYPE_NORMAL
- en: 'This JSON has been left intentionally incomplete since it is... well, incomprehensible
    for the human brain. Luckily enough, Swagger kicks in with a UI that interprets
    all this madness and gives us a beautiful web page. Something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.12 – Two very basic endpoints exposed by swagger-ui](img/B20912_08_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.12 – Two very basic endpoints exposed by swagger-ui
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the very basic version of it. By clicking on the single endpoint (that
    is, one of those writings in colorful boxes, such as **/employees**), you’ll get
    its details, and you can also try it out:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.13 – By clicking on a single method, some more details will be displayed](img/B20912_08_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.13 – By clicking on a single method, some more details will be displayed
  prefs: []
  type: TYPE_NORMAL
- en: 'With Swagger annotations, you can detail your API documentation as much as
    you like. In the `POST` method that creates a new employee, you can see a parameter
    of the `CreateEmployee` type that represents the body for the `POST` call. The
    fields of that class could be annotated like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Swagger would generate the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.14 – Details of the request body rendered by swagger-ui](img/B20912_08_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.14 – Details of the request body rendered by swagger-ui
  prefs: []
  type: TYPE_NORMAL
- en: A tool like Swagger, with its UI, guarantees massive value with minimum effort.
    Keeping your documentation up-to-date should be also simpler because everything
    – the code and its documentation – is in one place.
  prefs: []
  type: TYPE_NORMAL
- en: Spring REST Docs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The second tool I would suggest to document your (`REST`) APIs is called **Spring
    REST Docs**. Spring REST Docs is a part of the Spring Framework, a popular framework
    for building Java-based enterprise applications. Specifically, Spring REST Docs
    is an extension for documenting RESTful APIs developed using Spring. It helps
    developers create accurate and consistent documentation for their RESTful web
    services by leveraging tests written in Spring Framework.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how Spring REST Docs typically works:'
  prefs: []
  type: TYPE_NORMAL
- en: Developers write tests for their REST API endpoints using the Spring Framework’s
    testing tools. These tests can include HTTP requests and responses.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Spring REST Docs processes these tests and generates documentation based on
    the test results. It can generate documentation in various formats, such as AsciiDoc,
    Markdown, or HTML. This is a very cool thing: documentation is kept up-to-date
    in case of changes in the code.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The generated documentation can be included in the API documentation, making
    it easier for other developers or consumers to understand how to use the API effectively.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Spring REST Docs is especially useful in projects where maintaining accurate
    and up-to-date API documentation is crucial. By using actual tests to generate
    the documentation, it ensures that the documentation accurately reflects the behavior
    of the API. This approach promotes consistency between the code and its documentation
    and helps developers and consumers better understand how to interact with the
    API.
  prefs: []
  type: TYPE_NORMAL
- en: Good practices for documentation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Writing and maintaining documentation is fundamental yet hard. Doing it the
    right way is not very common – not at all! – and will take your team to the next
    level. Here’s some advice based on our experience and also on our mistakes.
  prefs: []
  type: TYPE_NORMAL
- en: Incorporate documentation into the development flow
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One common reason software teams skip documentation is that they’re always waiting
    for that perfect moment when they have loads of free time. But let’s face it –
    in the fast-paced world of software, that moment rarely arrives with all the new
    projects and initiatives on the horizon.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, here’s the hack: make documentation a natural part of your design process.
    Think of it as a crucial step that’s part of the whole deal, not some extra task
    you squeeze in later. Sure, it might add a bit more time, but that extra effort
    will pay off when you need to handle or expand your system down the road. Plus,
    your team will be all set to tackle those unexpected curveballs like pros.'
  prefs: []
  type: TYPE_NORMAL
- en: Write comprehensive documentation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Comprehensive documentation for your software architecture is an absolute must
    for ensuring the seamless maintenance and expansion of your systems. This documentation
    functions as a valuable resource, particularly when crucial members of your engineering
    team move on, safeguarding essential knowledge from being lost. Moreover, it streamlines
    the process of conveying vital information about the system to a diverse range
    of stakeholders.
  prefs: []
  type: TYPE_NORMAL
- en: While there may be those who argue that code alone suffices as documentation
    (I would agree with that, actually, but only if you add the adjective “good” to
    the word “code”), it is vital to acknowledge that comprehensive documentation
    offers invaluable context for decision-making and is accessible to both technical
    and non-technical stakeholders.
  prefs: []
  type: TYPE_NORMAL
- en: Up-to-date documentation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Maintaining up-to-date documentation is essential as outdated documentation
    can lead to the same issues as having no documentation at all. Documentation that
    accurately reflects the current state of the system is crucial to ensure informed
    decision-making and to prevent critical errors caused by referencing outdated
    information during updates or changes.
  prefs: []
  type: TYPE_NORMAL
- en: Tailored documentation for specific audiences
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Customizing software architecture documentation to cater to specific audiences
    is essential. Not all stakeholders have the same information requirements, and
    attempting to fit all the details into a single document can hinder the ease of
    finding information. It might even discourage individuals from using the documentation
    altogether.
  prefs: []
  type: TYPE_NORMAL
- en: To ensure the effectiveness of documentation, it’s crucial to provide the appropriate
    level of context for the intended audience. For instance, business executives
    may not require in-depth technical and code details, whereas engineers may find
    it challenging to fulfill their responsibilities without access to such technical
    specifics.
  prefs: []
  type: TYPE_NORMAL
- en: We can give you all the advice in the world, and guide you toward all the best
    practices possible, but unfortunately, we must acknowledge that these good habits
    are sometimes unwelcome to non-technical individuals. In the next section, we’ll
    have a chat about it.
  prefs: []
  type: TYPE_NORMAL
- en: A hard dose of reality
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The aspects we’ve talked about, as well as many others, will help you add activities
    to your daily work that will make your code, your project, and your work better.
    By including all of this in your development cycle, maybe right from the beginning
    of a project, it will undoubtedly be easier to be diligent in this regard.
  prefs: []
  type: TYPE_NORMAL
- en: However, we must tell you something undeniable – sometimes, some of these practices
    can cause disagreements between tech-savvy and non-tech-savvy people. What we’ve
    noticed is that there’s often a very different view of how work is organized,
    especially in terms of tasks. Of course, even the concept of code quality may
    not matter at all to certain managers or partners who are not used to writing
    code. But let’s go step by step.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, pair programming can be seen by management as resource-intensive
    because it requires two developers to work on the same task, potentially increasing
    labor costs. It could also be because the target is arguably more long-term. However,
    management often prioritizes short-term project goals, such as meeting deadlines
    and immediate deliverables, which may not align with the collaborative nature
    of pair programming. The benefits of pair programming, such as improved code quality
    and reduced defects, often manifest in the long term. However, these benefits
    may not be immediately visible to management, which can lead to skepticism. In
    general, there could also be a simple lack of familiarity: some managers may not
    be familiar with the practice and may be hesitant to introduce a process they
    don’t fully understand. Also, introducing pair programming may disrupt established
    workflows within the organization, leading to resistance from management.'
  prefs: []
  type: TYPE_NORMAL
- en: Documentation also suffers some of these perceived fears. Why stop documenting
    something that is already working? Why not go ahead and do another task instead?
    Some managers may not fully understand the importance of documentation in terms
    of reducing errors, enhancing collaboration, and easing onboarding of new team
    members. This lack of understanding can lead to underestimating its value. Also,
    some managers may perceive the time spent on documentation as time that could
    be used for more coding or direct project work, potentially leading to underutilization
    of developer resources.
  prefs: []
  type: TYPE_NORMAL
- en: Between the two, I have to say that pair programming is the practice that meets
    more resistance, at least from my point of view. All the practices that we’ve
    covered in this chapter are important, but getting along is also crucial! Try
    to introduce all of these practices or at least some pieces of them; try to adapt,
    try to prioritize. To address concerns, developers, and management can engage
    in open communication to explain the long-term advantages of pair programming,
    documentation, and so on, how they can improve code quality and project quality,
    reduce defects, and enhance knowledge sharing. They can also discuss how it can
    lead to faster problem-solving and overall efficiency in the development process.
    Management can work to strike a balance between immediate project needs and the
    long-term benefits of such practices.
  prefs: []
  type: TYPE_NORMAL
- en: The importance of knowing what you’re doing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this more informal part of this chapter, we want to offer one last piece
    of advice about the things you do every day. It’s not just a technical tip; it’s
    more like advice from a friend, something I wish someone had told me when I started
    my career.
  prefs: []
  type: TYPE_NORMAL
- en: When you work on a project, a task, or anything else, always keep in mind why
    you chose to do it. Ask yourself, “Why am I doing this?” It’s not just about staying
    motivated; there’s more to it than that.
  prefs: []
  type: TYPE_NORMAL
- en: First of all, this will help you avoid feeling like a random monkey hitting
    keys on a keyboard. It will also help you understand how your work contributes
    to the development of a project or a company. Having clear goals for your work,
    whether they’re short-term, medium-term, or long-term, will keep you focused on
    your task without getting distracted by other things. If your work has a specific
    purpose, and even better, if that purpose is something you believe in, your productivity
    will increase, and your work will be better.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing why you’re doing something, and understanding the purpose behind it,
    will lead to better decision-making. When faced with doubts or uncertainties,
    having a clear goal in mind will guide your choices and prevent future disappointments.
    When we have detailed plans for specific actions at both upcoming milestones and
    our ultimate goals, every decision appears to align seamlessly.
  prefs: []
  type: TYPE_NORMAL
- en: One of the decisions you’ll have to make includes prioritizing your tasks within
    a project. Should you do one thing before the other? Which task will take more
    time compared to the value it will generate? Well, if you know what you’re doing
    – in other words, if you have a clear goal – this will likely assist your decision-making
    and set a smoother path toward project completion.
  prefs: []
  type: TYPE_NORMAL
- en: If you know your goal, you can probably also understand how far you are from
    reaching it. In other words, knowing your “why” helps you measure your progress.
    Imagine a team or a developer who is simply told to do something, completely disconnected
    from the context, something like “Write a method that returns this output given
    this input” – I don’t think this happens much after school, but let’s say it does.
    This person wouldn’t have the slightest idea of how their work is contributing
    and where they stand on the journey toward the final goal. This person would do
    a worse job.
  prefs: []
  type: TYPE_NORMAL
- en: In a book on refactoring, it’s important to mention that understanding the “why”
    behind things helps in writing better code and, when necessary, refactoring it
    more effectively. Writing down the reasons for doing something, perhaps in a comment
    alongside complex code, can assist developers in rewriting it more efficiently.
    This, along with good test coverage and everything we’ve already discussed in
    the previous chapters, greatly aids both the comprehension of the current code
    and any potential rewriting efforts.
  prefs: []
  type: TYPE_NORMAL
- en: Ask questions, and keep asking yourself and others. If you’re in a position
    where a manager or a partner is guiding you on task prioritization – for instance,
    if you work within a framework that involves a product owner – always ask why
    one thing is chosen over another. What benefits will it bring? How much will it
    cost, and how much will it earn for the company? Is there data to support this
    decision? I’m not saying to start a war, absolutely not, but always try to “challenge”
    your colleagues in this sense.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we tried to provide you with some advice on introducing small
    but significant changes that will greatly benefit your work. We explored how you
    can version your code and offered some branching models that the community has
    found effective over the years. Versioning your code is important, but let’s version
    beautiful code! We discussed how code reviews can be helpful and how to incorporate
    them into your everyday work. We dedicated an entire section to a particular form
    of code review, which is pair programming. We also delved into documentation,
    distinguishing between various types and providing guidance, especially for technical
    documentation of REST APIs. Lastly, we addressed the real-world implementation
    of these practices, which can sometimes face resistance, particularly in medium
    to small-sized companies.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll take a step back and discuss how these various elements
    communicate with each other. We’ll talk about best practices, identify issues
    (bad smells), and provide some advice on refactoring your architectures.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Extreme Programming Explained: Embrace Change*, by Kent Beck, Addison-Weasley'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'On pair programming: [https://martinfowler.com/articles/on-pair-programming.html](https://martinfowler.com/articles/on-pair-programming.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Llewellyn’s strong-style pairing: [https://llewellynfalco.blogspot.com/2014/06/llewellyns-strong-style-pairing.html](https://llewellynfalco.blogspot.com/2014/06/llewellyns-strong-style-pairing.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Costs and benefits of pair programming*, by A. Cockburn and L. Williams: [https://collaboration.csc.ncsu.edu/laurie/Papers/XPSardinia.PDF](https://collaboration.csc.ncsu.edu/laurie/Papers/XPSardinia.PDF)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A great tool for remote teams who want to use Pomodoro: [https://cuckoo.team/](https://cuckoo.team/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Pull Request*, an article by Martin Fowler: [https://martinfowler.com/bliki/PullRequest.html](https://martinfowler.com/bliki/PullRequest.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'GitFlow original post: [https://nvie.com/posts/a-successful-git-branching-model/](https://nvie.com/posts/a-successful-git-branching-model/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'How to write a good commit message: [https://www.freecodecamp.org/news/how-to-write-better-git-commit-messages/](https://www.freecodecamp.org/news/how-to-write-better-git-commit-messages/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Google Java style guide: [https://google.github.io/styleguide/javaguide.html](https://google.github.io/styleguide/javaguide.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Oracle Java conventions: [https://www.oracle.com/technetwork/java/codeconventions-150003.pdf](https://www.oracle.com/technetwork/java/codeconventions-150003.pdf)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: About comments and formatting, *Chapters 4* and *5* of Robert C. Martin, *Clean*
    *Code*, Pearson
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Introduction to the Apache Maven Checkstyle Plugin: [https://www.baeldung.com/checkstyle-java](https://www.baeldung.com/checkstyle-java)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'About collecting, documenting, and managing software requirements: [*Chapter
    2*](B20912_02.xhtml#_idTextAnchor042) of Giuseppe Bonocore’s *Hands-on software
    architecture in* *Java*, Packt'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The C4 model for visualizing software architecture ([https://c4model.com/](https://c4model.com/))
    and Giuseppe Bonocore’s *Hands-on software architecture in Java*, [*Chapter* *1*](B20912_01.xhtml#_idTextAnchor014),
    Packt
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Tutorial for setting up Swagger by Baeldung: [https://www.baeldung.com/swagger-2-documentation-for-spring-rest-api](https://www.baeldung.com/swagger-2-documentation-for-spring-rest-api)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Spring REST docs: [https://docs.spring.io/spring-restdocs/docs/current/reference/htmlsingle/](https://docs.spring.io/spring-restdocs/docs/current/reference/htmlsingle/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
