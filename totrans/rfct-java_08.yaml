- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Crafting Quality Every Day
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 每日打造高质量
- en: While trying to give you advice on keeping your code clean and your design clear,
    it’s also important to talk about some practices that will help you little by
    little, day by day. Apart from dedicating specific moments to refactoring, maintaining
    a consistent level of quality in your day-to-day work is essential for the overall
    health and efficiency of your software development process. Achieving this doesn’t
    always require extensive time or effort; small, targeted actions can make a significant
    difference. By incorporating the practices we’re about to describe into your daily
    routine, you can not only prevent the accumulation of technical debt but also
    improve the overall quality and maintainability of your code base. These efforts
    may seem small in isolation but, collectively, they can have a substantial impact
    on the long-term success of your software projects.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 当试图给你建议，保持你的代码整洁和设计清晰时，讨论一些能帮助你逐渐、日积月累的实践也很重要。除了专门留出时间进行重构外，保持日常工作中的一致质量水平对于软件开发过程的整体健康和效率至关重要。实现这一点并不总是需要大量的时间或精力；小的、有针对性的行动可以产生重大影响。通过将我们即将描述的实践融入你的日常工作中，你不仅可以防止技术债务的积累，还可以提高代码库的整体质量和可维护性。这些努力单独看起来可能微不足道，但集体来看，它们可以对软件项目的长期成功产生重大影响。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Code versioning
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码版本控制
- en: Code formatting and style
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码格式和风格
- en: Code reviews
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码审查
- en: Pair programming
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对接编程
- en: Documentation
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文档
- en: Why you’re doing what you’re doing
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你为什么要做你现在正在做的事情
- en: A hard dose of reality
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现实的一剂苦药
- en: Code versioning
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码版本控制
- en: I have a soft spot for code versioning, and that’s weird, I get it. It was one
    of the first things I had to learn the hard way when I started working right after
    graduation. Incredibly, no one had ever mentioned code versioning throughout my
    entire computer science studies. This makes me think that maybe my degree program
    was lacking in this regard, and it shows how important code versioning is in the
    life of a developer from day one.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我对代码版本控制情有独钟，这很奇怪，我明白。这是我毕业后刚开始工作时不得不艰难学习的第一件事之一。令人难以置信的是，在整个计算机科学学习中，没有人提到过代码版本控制。这让我想，也许我的学位课程在这方面有所欠缺，这也显示了代码版本控制对于开发者从第一天起的生活是多么重要。
- en: Anyway, let’s get to the point. To tell you what code versioning is, I could
    start by saying that it is something that can save your day when things go wrong;
    I’ll admit that it sounds a bit too generic as a description, so I’ll go into
    detail.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，让我们直奔主题。为了告诉你什么是代码版本控制，我可以说，这是一种在事情出错时能救你一命的东西；我必须承认，作为一个描述，这听起来有点太泛泛而谈了，所以我会详细说明。
- en: '**Version control** is like a time machine for your files. It keeps track of
    all the changes you make so you can easily jump back to any previous version when
    needed. This system is usually referred to as a **versioning control system**
    (**VCS**) and there are many implementations of them. With a VCS, you can turn
    back the clock on individual files or the entire project, check how things have
    changed over time, figure out who messed with something that’s causing trouble,
    identify when an issue was introduced, and much more. Plus, using a VCS means
    that if you mess things up or lose files, you’ve got a safety net for easy recovery,
    and it doesn’t add much complexity to your workflow. Changes are typically marked
    with a code, often called the “revision number,” “revision level,” or just “revision.”
    For instance, the original set of files is labeled “revision 1.” When the first
    change happens, it becomes “revision 2,” and this pattern continues. Every revision
    comes with a timestamp and the name of the person who made the change. Revisions
    can be compared, restored, and, in some cases, merged, making it a powerful way
    to manage the evolution of files. The advantages of a VCS increase as the complexity
    of the project increases and the number of team members increases.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**版本控制**就像是你的文件的时光机。它记录了你所做的所有更改，以便你可以在需要时轻松地跳转到任何以前的版本。这个系统通常被称为**版本控制系统**（**VCS**），并且有许多实现。使用VCS，你可以将单个文件或整个项目的时间倒流，查看随着时间的推移事物是如何变化的，找出谁弄乱了导致麻烦的东西，确定问题何时被引入，等等。此外，使用VCS意味着如果你搞砸了或者丢失了文件，你有一个安全网可以轻松恢复，而且它不会给你的工作流程增加太多复杂性。更改通常用代码标记，通常称为“修订号”、“修订级别”，或者简单地称为“修订”。例如，原始文件集被标记为“修订1”。当第一次更改发生时，它变为“修订2”，这种模式继续。每个修订都带有时间戳和更改人的姓名。修订可以进行比较、恢复，在某些情况下还可以合并，这使得它成为管理文件演变的一种强大方式。VCS的优势随着项目复杂性的增加和团队成员数量的增加而增加。'
- en: As we already said, VCSs are useful for reverting errors; in case of trouble,
    you can restore your class, your package, and your module to a previous version
    that was still okay and start again. But this is not the only reason why everyone
    in this industry must use a VCS.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所说的，VCSs对于回滚错误很有用；在遇到麻烦时，你可以将你的类、你的包和你的模块恢复到之前仍然可以正常工作的版本，然后重新开始。但这并不是这个行业中每个人都必须使用VCS的唯一原因。
- en: Developers can collaborate and team up on a project using VCSs. They can all
    access the database at the same time to check out past versions, making it simpler
    for them to collaborate effectively, regardless of their geographical locations.
    Version control also allows developers to maintain a historical record of changes,
    attributing them to specific contributors. This capability empowers them to roll
    back to earlier document versions and gain insights into how various team members’
    contributions have shaped the project’s evolution. In the realm of collaborative
    development, it’s essential to have a clear understanding of the commits being
    added to the repository and the reasons behind these commits to prevent conflicts
    and ensure the stability of the source code. Collaborative platforms (for example,
    GitHub and GitLab) that are built around VCSs offer centralized repositories (we’ll
    jump into that later), tools for issue tracking and management, as well as threaded
    discussions and forums. These features streamline a team-oriented approach to
    the software development life cycle.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者可以使用版本控制系统（VCSs）在项目上进行协作和团队协作。他们可以同时访问数据库以检查历史版本，这使得无论他们的地理位置如何，都能更有效地协作。版本控制还允许开发者维护变更的历史记录，并将这些变更归因于特定的贡献者。这种能力使他们能够回滚到较早的文档版本，并深入了解各个团队成员的贡献如何塑造项目的演变。在协作开发的领域，了解添加到存储库的提交以及这些提交背后的原因至关重要，以防止冲突并确保源代码的稳定性。围绕VCS构建的协作平台（例如，GitHub和GitLab）提供集中式存储库（我们稍后会详细介绍），问题跟踪和管理工具，以及线程式讨论和论坛。这些功能简化了面向团队的软件开发生命周期方法。
- en: Graph structure
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 图结构
- en: In graph theory, think of revisions like a tree growing from a main line. Picture
    *branches* coming out of this main line, forming a tree shape. Even though it’s
    more complex and looks like a graph, you can simplify it in your mind as a “tree
    with merges” for practical use.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在图论中，将修订想象成从主线生长出来的树。想象一下从这条主线延伸出来的*分支*，形成一个树状结构。尽管它更复杂，看起来像是一个图，但你可以在心中将其简化为“带有合并的树”以供实际使用。
- en: 'Revisions happen one after another over time and can be put in a specific order,
    either by their revision number or the time they were made. Each revision is based
    on the ones before it, but sometimes, you can completely replace an earlier revision
    by getting rid of everything and putting in new stuff. In the simplest case, with
    no extra branches or undoing, each revision is only connected to the one just
    before it, making a straight line. The latest version is called the **HEAD** revision.
    In graph theory terms, if you think of each revision as a point and each connection
    between revisions like an arrow (usually going from older to newer, following
    the timeline), this setup makes a straight-line graph:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 修订随着时间的推移一个接一个地发生，并且可以根据它们的修订号或创建时间进行排序。每个修订版都是基于之前的修订版，但有时，你可以通过去除所有内容并添加新内容来完全替换一个较早的修订版。在最简单的情况下，没有额外的分支或撤销，每个修订版只与它前面的一个修订版相连，形成一条直线。最新版本被称为**HEAD**修订版。在图论术语中，如果你把每个修订版看作一个点，每个修订版之间的连接看作一个箭头（通常从旧到新，遵循时间线），这种设置会形成一个直线图：
- en: '![Figure 8.1 – A very basic sequence of revisions](img/B20912_08_1.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图8.1 – 非常基本的修订序列](img/B20912_08_1.jpg)'
- en: Figure 8.1 – A very basic sequence of revisions
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1 – 非常基本的修订序列
- en: 'When there is branching (that is, there are different paths) or we have to
    get back to an older revision, creating a situation where a revision depends on
    one older than the one just before it, the graph changes into a directed tree.
    In this tree, each point may have more than one next point. This creates multiple
    endpoints, representing revisions without any more changes (the “latest revision
    on each branch”). In theory, the tree may not have a favorite endpoint (the “main”
    latest revision), but usually, one endpoint is chosen as the **HEAD**. If a new
    revision is based on the **HEAD**, it either becomes the new **HEAD** or starts
    a new **BRANCH**:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当存在分支（即有不同路径）或者我们需要回退到旧版本时，就会形成一个修订版依赖于比它更早的修订版的情况，此时图会变成一个有向树。在这个树中，每个点可能有多于一个的后续点。这会创建多个端点，代表没有更多更改的修订版（每个分支上的“最新修订版”）。理论上，这个树可能没有首选端点（“主要”最新修订版），但通常会选择一个端点作为**HEAD**。如果一个新修订版基于**HEAD**，它要么成为新的**HEAD**，要么开始一个新的**BRANCH**：
- en: '![Figure 8.2 – Branching from the trunk](img/B20912_08_2.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图8.2 – 从主干分支](img/B20912_08_2.jpg)'
- en: Figure 8.2 – Branching from the trunk
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2 – 从主干分支
- en: 'The list of revisions from the starting point to the **HEAD**, called the trunk
    or mainline in graph theory, makes a simple straight-line graph. However, if a
    revision can be based on more than one previous revision (when a point can have
    more than one parent), it’s called a **MERGE**. This is one of the trickier parts
    of revision control. It often happens when changes occur in different branches
    (usually two), and these changes are combined into one branch that includes both
    sets of changes. If these changes overlap, it can be hard or even impossible to
    merge them without manual help or rewriting (these situations are known as **conflicts**):'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 从起点到**HEAD**的修订版列表，在图论中称为主干或主线，形成了一个简单的直线图。然而，如果一个修订版可以基于多个之前的修订版（当一个点可以有多个父节点时），它就被称为**MERGE**。这是版本控制中比较复杂的一部分。这通常发生在不同分支（通常是两个）发生更改时，这些更改被合并到一个包含两组更改的分支中。如果这些更改重叠，在没有人工帮助或重写的情况下合并它们可能很困难，甚至不可能（这些情况被称为**冲突**）：
- en: '![Figure 8.3 – Merging a branch into a trunk (a merge commit is created)](img/B20912_08_3.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图8.3 – 将分支合并到主干（创建了一个合并提交）](img/B20912_08_3.jpg)'
- en: Figure 8.3 – Merging a branch into a trunk (a merge commit is created)
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.3 – 将分支合并到主干（创建了一个合并提交）
- en: When merges happen, the graph stops being a tree, as points can have more than
    one parent. Instead, it becomes a rooted **directed acyclic graph** (**DAG**).
    This graph doesn’t have cycles “by definition” because parents always existed
    in the past, it’s rooted because it has a starting node given by the very first
    commit and it’s directed because you can navigate through it only in a given direction
    (we could say the direction of time) and never in the opposite direction. If there’s
    a trunk, merges from branches are like “external” additions to the tree. The changes
    in the branch are bundled as a patch, and applied to the **HEAD** of the trunk,
    creating a new version without directly mentioning the branch and keeping the
    tree structure. So, even though the actual relationships make a DAG, you can think
    of it as a tree with merges, and the trunk itself is a straight path.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当发生合并时，图不再是一个树，因为点可以有多个父节点。相反，它变成了一个有根的**有向无环图**（**DAG**）。这个图“按定义”没有循环，因为父节点总是存在于过去，它有根，因为它有一个由第一个提交给出的起始节点，它是定向的，因为您只能按给定方向导航（我们可以说时间的方向）而无法反向导航。如果有主干，从分支到合并就像是对树的“外部”添加。分支中的更改被捆绑成一个补丁，并应用到主干**HEAD**上，创建一个新版本，而不直接提及分支，并保持树结构。因此，尽管实际关系构成了一个DAG，但您可以将它视为一个带有合并的树，而主干本身是一条直线。
- en: 'In addition to performing the **MERGE** operation, code versioning systems
    also offer the option to perform the so-called **rebase**. This action shifts
    the whole branch of new changes to start from the latest point in the main branch.
    It includes all the recent changes in the main branch. However, instead of making
    a **MERGE** commit, rebasing rewrites the project history by making entirely new
    commits for each original commit in the branch. Putting it more simply, it’s like
    you take the whole branch and “attach” it at the end of the main one:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 除了执行**MERGE**操作外，代码版本控制系统还提供了执行所谓的**rebase**选项。这个动作将整个新更改分支移至主分支的最新点开始。它包括主分支中的所有最近更改。然而，与执行**MERGE**提交不同，rebase通过为分支中的每个原始提交创建全新的提交来重写项目历史。简单来说，就像是您将整个分支“附加”到主分支的末尾：
- en: '![Figure 8.4 – Rebase operation](img/B20912_08_4.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图8.4 – Rebase操作](img/B20912_08_4.jpg)'
- en: Figure 8.4 – Rebase operation
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.4 – Rebase操作
- en: Rebasing has a big advantage because it makes your project history cleaner.
    It does this by removing the extra merge commits that git merge often creates.
    Additionally, rebasing creates a completely straight-line project history, allowing
    you to trace the development from the latest feature to the very start of the
    project without any diverging paths.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Rebasing有一个很大的优点，因为它可以使您的项目历史更干净。它是通过删除git merge经常创建的额外合并提交来做到这一点的。此外，rebase创建了一个完全直线型项目历史，允许您从最新功能追溯到项目的起始点，没有任何分叉路径。
- en: Now that we’ve seen how a VCS works at a general level, it’s time to take a
    look at how the three main types worked before and how they work now.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经从一般层面了解了版本控制系统的工作原理，现在是时候看看三种主要类型在以前是如何工作的，以及它们现在是如何工作的了。
- en: Local VCSs
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 本地版本控制系统
- en: Though quite ancient, this approach has fallen out of use, especially in professional
    settings – I haven’t even witnessed its use. Yet, as the initial example of a
    VCS, it’s worth mentioning it so that we can contrast it with modern practices.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这种方法相当古老，但它已经不再使用，尤其是在专业环境中——我甚至没有见证过它的使用。然而，作为版本控制系统的初始示例，提一下它是值得的，这样我们可以将其与现代实践进行对比。
- en: In the past, a common version control method involved duplicating files into
    a separate directory, sometimes with timestamps for meticulous record-keeping.
    Despite its simplicity, this method was error-prone, with users easily losing
    track of their current directory and making unintended modifications or overwrites.
    To tackle these issues, programmers developed local VCSs with straightforward
    databases to log changes made to files under revision control.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去，一种常见的版本控制方法是将文件复制到一个单独的目录中，有时带有时间戳以进行细致的记录。尽管这种方法很简单，但它容易出错，用户很容易失去对当前目录的跟踪，并做出无意中的修改或覆盖。为了解决这些问题，程序员开发了具有简单数据库的本地版本控制系统，以记录受版本控制文件所做的更改。
- en: 'Here is an example of a local VCS:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个本地版本控制系统的示例：
- en: '![Figure 8.5 – A local VCS](img/B20912_08_5.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图8.5 – 本地版本控制系统](img/B20912_08_5.jpg)'
- en: Figure 8.5 – A local VCS
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.5 – 本地版本控制系统
- en: One of the most popular tools of this kind was RCS, which has been a thing for
    a while; it was also distributed among macOS’s Developer Kit.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这类最受欢迎的工具之一是RCS，它已经存在一段时间了；它也分布在macOS的Developer Kit中。
- en: Centralized VCSs
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集中式版本控制系统
- en: 'To address collaboration challenges among developers using different systems,
    **centralized version control systems** (**CVCSs**) such as CVS or Subversion
    were created. These systems store all versioned files on a central server, allowing
    multiple users to access and retrieve files:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决使用不同系统的开发者之间的协作挑战，创建了如CVS或Subversion之类的**集中式版本控制系统**（**CVCSs**）。这些系统将所有版本化的文件存储在中央服务器上，允许多个用户访问和检索文件：
- en: '![Figure 8.6 – A CVCS schema](img/B20912_08_6.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![图8.6 – 一个CVCS架构](img/B20912_08_6.jpg)'
- en: Figure 8.6 – A CVCS schema
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.6 – 一个CVCS架构
- en: While this method facilitated project coordination and administration, it had
    a major drawback – the centralized server was a single point of failure. If it
    went down, collaboration and file-saving became impossible, and data loss risked
    the entire project history. This limitation led to the evolution of today’s VCSs.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这种方法促进了项目的协调和管理，但它有一个主要的缺点——集中式服务器是单一故障点。如果它崩溃，协作和文件保存将变得不可能，数据丢失风险会危及整个项目历史。这种限制导致了今天VCSs的演变。
- en: Distributed VCSs
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分布式VCS
- en: A **distributed version control system** (**DVCS**) is a type of VCS that allows
    multiple users to work on a project while having their own local copies of the
    entire project’s repository. In a distributed CVS, each user has a complete copy
    of the project’s history and can make changes independently on their local copy.
    These changes can be tracked, merged, and shared with others seamlessly.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '**分布式版本控制系统**（**DVCS**）是一种允许多个用户在拥有整个项目仓库的本地副本的同时工作的版本控制系统。在分布式版本控制系统中，每个用户都有项目历史的完整副本，可以在本地副本上独立进行更改。这些更改可以无缝跟踪、合并和与他人共享。'
- en: 'One of the most well-known distributed CVS systems is **Git**. Git enables
    developers to work on a project offline, make commits to their local repository,
    and then synchronize their changes with a central repository or other team members’
    repositories when they are ready. Here is a DVCS schema:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 最著名的分布式版本控制系统之一是**Git**。Git允许开发者离线工作，对本地仓库进行提交，然后在准备就绪时将他们的更改与中央仓库或其他团队成员的仓库同步。以下是一个分布式版本控制系统（DVCS）的架构图：
- en: '![Figure 8.7 – A distributed VCS schema](img/B20912_08_7.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![图8.7 – 一个分布式VCS架构](img/B20912_08_7.jpg)'
- en: Figure 8.7 – A distributed VCS schema
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.7 – 一个分布式VCS架构
- en: Distributed CVS systems offer several advantages, such as increased flexibility,
    improved collaboration, and better handling of projects with geographically distributed
    teams. Each contributor has a full copy of the project’s history, which provides
    redundancy and makes it harder to lose data. Additionally, DVCS systems allow
    for more branching and merging capabilities, making it easier to manage concurrent
    work on the same project.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 分布式版本控制系统提供了几个优点，例如增加了灵活性、改善了协作，以及更好地处理地理上分布的团队的项目。每个贡献者都有项目历史的完整副本，这提供了冗余，并使得数据丢失的可能性更小。此外，DVCS系统允许进行更多的分支和合并操作，使得管理同一项目上的并发工作变得更加容易。
- en: Branching strategies
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分支策略
- en: To keep your code base organized and have a smooth workflow, it’s a good idea
    to follow what’s called a **branching strategy**.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持代码库的有序性和流畅的工作流程，遵循所谓的**分支策略**是一个好主意。
- en: Branches are like separate workspaces for developers to build new features or
    fix issues in a software project. We saw that branches can be combined with the
    main code when the work is finished. This separation helps you avoid mixing up
    changes and makes it easier to fix mistakes. If everyone works on their branch,
    no one should mess up what others are doing.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 分支就像是开发者为构建新功能或修复软件项目中的问题而设立的独立工作区。我们注意到，当工作完成时，分支可以与主代码合并。这种分离有助于你避免混淆更改，并使纠正错误变得更加容易。如果每个人都在自己的分支上工作，那么就不应该有人打乱他人的工作。
- en: A branching strategy is a plan that software teams use for writing, combining,
    and deploying code when they use VCSs. It’s like a set of rules that tells developers
    how to work with the shared code.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 分支策略是软件团队在使用版本控制系统（VCSs）编写、组合和部署代码时所采用的一种计划。它就像一套规则，告诉开发者如何与共享代码一起工作。
- en: This strategy is crucial because it keeps things organized and prevents problems
    when many developers are working at the same time. Without it, there could be
    conflicts when everyone tries to add their changes simultaneously. This would
    slow down the process of getting code ready to use – and cause a certain amount
    of frustration!
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这种策略至关重要，因为它保持了事物的有序性，并防止了当许多开发者同时工作时出现的问题。如果没有它，当每个人都试图同时添加他们的更改时，可能会出现冲突。这将减缓代码准备就绪的过程，并导致一定程度的挫败感！
- en: By following a branching strategy, developers can work together without causing
    issues. It lets teams work on different things at the same time and release code
    faster with fewer conflicts. It’s all about having a clear process for making
    changes to the code; you can set up your own branching models, of course, but
    there are a bunch of them that have become quite successful over the years. The
    one we’re about to show will use only Distributed VCSs since are the only ones
    that are still in use.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 通过遵循分支策略，开发者可以协作工作而不会引起问题。它允许团队同时处理不同的事情，并更快地发布代码，冲突更少。这全部关于有一个明确的流程来对代码进行更改；当然，你可以设置自己的分支模型，但多年来已经有一系列模型变得相当成功。我们即将展示的模型将仅使用分布式版本控制系统（Distributed
    VCSs），因为它们是目前唯一仍在使用的系统。
- en: Trunk-based development
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 主干开发
- en: '**Trunk-based development** is a way of working where all developers make their
    changes directly in the main part of the code, which we call the **trunk**. This
    is the part of the code that’s ready to be used in the project. Developers are
    encouraged to save their work often and use special techniques to manage changes
    that aren’t ready yet.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '**主干开发**是一种工作方式，其中所有开发者都直接在代码的主要部分进行更改，我们称之为**主干**。这是代码中准备用于项目的部分。鼓励开发者经常保存他们的工作，并使用特殊技术来管理尚未准备好的更改。'
- en: We also focus on automated testing, meaning the computer checks if the code
    is working well all the time. We do this to make sure any changes we make are
    tested thoroughly before they are used in the project.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还专注于自动化测试，这意味着计算机会持续检查代码是否运行良好。我们这样做是为了确保我们做出的任何更改在使用于项目之前都经过了彻底的测试。
- en: 'Sometimes, if a task takes a long time, a developer might create a separate
    branch from the main code, make changes there, and then bring those changes back
    to the main part when they’re done. But the main idea in trunk-based development
    is to use separate branches as little as possible and have everyone work together
    on the main part of the code most of the time. The following diagram represents
    a very simple sequence of commits (a graph made by only one, linear path) that
    have been done on a single branch:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，如果一项任务耗时较长，开发者可能会从主代码中创建一个单独的分支，在那里进行更改，完成后将这些更改合并回主部分。但在主干开发中，主要思想是尽可能少地使用单独的分支，并让每个人大部分时间都在代码的主部分上一起工作。以下图表示了一个非常简单的提交序列（由一条单一的线性路径构成的图）在一个单独的分支上完成的：
- en: '![Figure 8.8 – In trunk-based development, each commit is done on the main
    branch](img/B20912_08_8.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图8.8 – 在主干开发中，每个提交都是在主分支上完成的](img/B20912_08_8.jpg)'
- en: Figure 8.8 – In trunk-based development, each commit is done on the main branch
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.8 – 在主干开发中，每个提交都是在主分支上完成的
- en: 'Here’s how the trunk-based branching model works in detail:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是主干分支模型如何详细工作的说明：
- en: '**Work in the main code**: Instead of making separate branches, work directly
    in the **MAIN** (trunk) branch.'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**在主代码中工作**：而不是创建单独的分支，直接在**MAIN**（主干）分支上工作。'
- en: '**Make small, frequent updates**: Make small and regular changes to the code.
    This makes it easier to check and reduces the chances of problems.'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**进行小而频繁的更新**：对代码进行小而规律的改变。这使得检查更容易，并减少了问题的可能性。'
- en: '**Use continuous integration** (**CI**): Frequently combine and test the code
    to catch issues early, prevent conflicts, and keep the code ready for release.'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**使用持续集成（CI**）：频繁地合并和测试代码，以尽早发现问题，防止冲突，并保持代码准备就绪以发布。'
- en: '**Merge changes often**: Regularly bring your changes back into the main code,
    keeping it current and lowering the chance of conflicts.'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**经常合并更改**：定期将你的更改合并回主代码，保持其最新状态，并降低冲突的可能性。'
- en: At first glance, it doesn’t seem so bad. There are some pros – for instance,
    it encourages teamwork and quick feedback (there could be a merge conflict or
    a failing test), helps find problems early and fix them fast, speeds up adding
    new features, keeps the code organized by having everyone work on one branch,
    and lowers the complexity of dealing with many branches. When applied together
    with **test-driven development** (**TDD**) and a **continuous integration/continuous
    deployment** (**CI/CD**) pipeline, you can guarantee that your code is still working
    correctly. Under a certain number of circumstances, it can be a valid approach.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 初看之下，这似乎并不糟糕。有一些优点——例如，它鼓励团队合作和快速反馈（可能会有合并冲突或失败的测试），有助于及早发现问题并快速修复，加快添加新功能，通过让每个人在一个分支上工作来保持代码的整洁，并降低处理多个分支的复杂性。当与**测试驱动开发**（**TDD**）和**持续集成/持续部署**（**CI/CD**）管道一起应用时，你可以保证代码仍然正确工作。在特定情况下，这可以是一个有效的方法。
- en: 'But there’s a great drawback: this model is not scalable since it might not
    work well for big teams or complex projects. If the main code goes bad, everything
    is affected. Moreover, we need strong automated testing and CI. As I mentioned
    previously, it can be a valid alternative if some conditions (conditions that,
    to tell the truth, should always be put in place) are respected.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 但有一个很大的缺点：这个模型不可扩展，因为它可能不适合大型团队或复杂项目。如果主代码出问题，一切都会受到影响。此外，我们需要强大的自动化测试和CI。正如我之前提到的，如果满足某些条件（实际上，这些条件应该始终得到实施），它可以是一个有效的替代方案。
- en: Let’s see something a bit different.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些不同之处。
- en: Feature branching
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 功能分支
- en: '**Feature branching** is a widely used approach where a fresh branch is made
    for a particular feature or code change. This lets developers work on the feature
    separately without messing with the **MAIN** branch. Once the feature is finished,
    it can be merged back into the **MAIN** branch using a pull request.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '**功能分支**是一种广泛使用的方法，为特定的功能或代码更改创建一个新的分支。这允许开发者在不干扰**MAIN**分支的情况下单独工作。一旦功能完成，就可以通过拉取请求将其合并回**MAIN**分支。'
- en: What is a pull request?
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是拉取请求？
- en: A **pull request** is a mechanism used in version control systems, such as Git,
    to propose changes to a codebase. It is a request to merge a set of changes made
    in a feature branch into the main or target branch. The process typically involves
    a developer creating a branch, making changes, pushing those changes to a remote
    repository, and then submitting a pull request for review by others. The pull
    request allows team members to discuss, review, and test the proposed changes
    before they are merged into the main codebase, helping maintain code quality and
    collaboration in software development projects. More on this in the *Further*
    *reading* section.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '**拉取请求**是版本控制系统（如Git）中用来提议对代码库进行更改的一种机制。它是一个将功能分支中做出的更改合并到主分支或目标分支的请求。这个过程通常涉及开发者创建一个分支，进行更改，将这些更改推送到远程仓库，然后提交一个拉取请求供他人审查。拉取请求允许团队成员在更改合并到主代码库之前进行讨论、审查和测试，有助于维护代码质量和软件开发项目的协作。更多内容请参阅*进一步阅读*部分。'
- en: 'This request permits other team members to inspect the changes and propose
    adjustments or enhancements before adding the feature to the **MAIN** branch:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这个请求允许其他团队成员检查更改，并在将功能添加到**MAIN**分支之前提出调整或改进：
- en: '![Figure 8.9 – In feature branching, each new feature is developed on a dedicated
    branch](img/B20912_08_9.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![图8.9 - 在功能分支中，每个新功能都在一个专门的分支上开发](img/B20912_08_9.jpg)'
- en: Figure 8.9 – In feature branching, each new feature is developed on a dedicated
    branch
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.9 - 在功能分支中，每个新功能都在一个专门的分支上开发
- en: 'Again, let’s see the workflow in detail:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，让我们详细看看工作流程：
- en: '**Set up feature branches**: For each of the tasks you’re working on, create
    a dedicated branch. Each of these branches should originate from the **MAIN**
    branch.'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**设置功能分支**：对于你正在处理的每个任务，创建一个专门的分支。这些分支都应该源自**MAIN**分支。'
- en: '**Develop the feature**: Implement your feature into the **Feature** branch
    and commit as many times as you need. This branch must contain only commits related
    to that particular feature and nothing else (when I say nothing, I mean nothing:
    remember that this change set will go straight to production one day – you don’t
    want to mix things up).'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**开发功能**：将你的功能实现到**Feature**分支，并按需多次提交。这个分支必须只包含与该特定功能相关的提交，不能包含其他内容（当我说是其他内容时，我的意思是其他内容：记住，这个更改集有一天会直接进入生产——你不想把事情搞混）。'
- en: '**Initiate a pull request**: When your development is complete and you’ve tested
    everything and you’re happy with that, you can create a pull request to merge
    your changes into the **MAIN** branch.'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**发起拉取请求**：当你的开发完成，你已经测试了一切，并且对此满意时，你可以创建一个拉取请求，将你的更改合并到 **MAIN** 分支。'
- en: '**Examine and approve**: The changes are checked by other developers, who will
    give their approval or suggest some modifications (basically, they can start a
    conversation). In this way, potential issues and errors can be caught before the
    code becomes part of the **MAIN** branch.'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**审查和批准**：其他开发者会检查这些变更，他们可能会给出批准或建议一些修改（基本上，他们可以开始对话）。这样，潜在的问题和错误可以在代码成为 **MAIN**
    分支的一部分之前被发现。'
- en: '**Merge the feature branch**: Now that your feature has been implemented, and
    the pull request has been examined and approved, the **Feature** branch can be
    merged back into the **MAIN** branch.'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**合并功能分支**：现在你的功能已经实现，并且拉取请求已经经过审查并获得批准，**Feature** 分支可以合并回 **MAIN** 分支。'
- en: '**Tidy up**: Delete the **Feature** branch.'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**整理**：删除 **Feature** 分支。'
- en: As you can see, we have raised a bit the complexity of getting the **MAIN**
    branch to stay as clean as possible. The primary goal is to maintain the stable
    version on the **MAIN** branch while supporting concurrent feature development.
    In general, the code can be well-organized and tested (no merges into the **MAIN**
    branch until all tests are passed). Change tracking is improved. Using this strategy,
    we can insert code reviews in our workflow (see the next section).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们略微提高了将 **MAIN** 分支保持尽可能干净复杂度。主要目标是保持 **MAIN** 分支上的稳定版本，同时支持并发功能开发。一般来说，代码可以很好地组织并测试（直到所有测试通过，不得将代码合并到
    **MAIN** 分支）。变更跟踪得到改善。使用这种策略，我们可以在工作流程中插入代码审查（见下一节）。
- en: On the other hand, new challenges arise when we’re managing and updating multiple
    branches, with potential delays in merging changes into the **MAIN** branch due
    to lengthy reviews. Of course, having multiple branches can create conflicts.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，当我们管理和更新多个分支时，新的挑战出现了，由于漫长的审查，合并更改到 **MAIN** 分支可能会出现潜在的延迟。当然，拥有多个分支可能会产生冲突。
- en: Now, let’s look at a very, very popular branching strategy.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看一个非常、非常流行的分支策略。
- en: GitFlow
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: GitFlow
- en: '**GitFlow** is a way of managing branches in Git. It mainly uses two long-lasting
    branches, **MAIN** and **DEVELOP**, which stay throughout the project’s life.
    It also uses short-lived branches such as **FEATURE**, **RELEASE**, and **HOTFIX**.
    These are created when needed and removed once they’ve done their job.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '**GitFlow** 是一种在 Git 中管理分支的方法。它主要使用两个长期存在的分支，**MAIN** 和 **DEVELOP**，这两个分支贯穿整个项目的生命周期。它还使用一些短期分支，如
    **FEATURE**、**RELEASE** 和 **HOTFIX**。这些分支在需要时创建，一旦完成工作就会删除。'
- en: The **MAIN** branch holds the stable, ready-to-use code, while the **DEVELOP**
    branch is where all the active development happens. **FEATURE** branches are for
    working on new features or changes, **RELEASE** branches help with getting ready
    for a new release, and **HOTFIX** branches are for quickly fixing critical problems
    in the production code.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '**MAIN** 分支持有稳定、可用的代码，而 **DEVELOP** 分支是所有活跃开发发生的地方。**FEATURE** 分支用于开发新功能或变更，**RELEASE**
    分支有助于为新版本做准备，而 **HOTFIX** 分支用于快速修复生产代码中的关键问题。'
- en: 'GitFlow is a bit hard to understand at first. On the **MAIN** branch, we have
    the stable version, and on the **DEVELOP** branch, we have the “next” version.
    Each **FEATURE** branch hosts a specific feature that is being developed:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: GitFlow 在一开始可能有点难以理解。在 **MAIN** 分支上，我们有稳定版本，而在 **DEVELOP** 分支上，我们有“下一个”版本。每个
    **FEATURE** 分支都承载着一个正在开发的具体功能：
- en: '![Figure 8.10 – GitFlow schema](img/B20912_08_10.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.10 – GitFlow 架构](img/B20912_08_10.jpg)'
- en: Figure 8.10 – GitFlow schema
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.10 – GitFlow 架构
- en: 'Here’s the detailed workflow:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这是详细的流程：
- en: Start working on a branch called `develop`. Use this branch for your current
    development; this branch must be created from the `main` branch.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始在一个名为 `develop` 的分支上工作。使用这个分支进行当前的开发；这个分支必须从 `main` 分支创建。
- en: Then, when you begin working on something new (or on a bug fix), create `feature`
    branches; these must be created starting from the `develop` branch.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，当你开始处理新事物（或修复错误）时，创建 `feature` 分支；这些分支必须从 `develop` 分支开始创建。
- en: When you’ve finished working on your feature, just merge your feature branch
    into `develop`.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你完成对功能的修改后，只需将你的功能分支合并到 `develop`。
- en: When it’s time to prepare for a new release, create a `release` branch from
    the `develop` branch. Assign a clear and descriptive name, incorporating the version
    number, such as “release/1.0.” Test it deeply to identify and address any bugs,
    ensuring its readiness for production.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 到了准备新发布的时候，从`develop`分支创建一个`release`分支。赋予一个清晰且描述性的名称，包括版本号，例如“release/1.0。”进行深度测试以识别和解决任何错误，确保其生产就绪。
- en: When the release is ready, combine it with the main part and mark it with a
    version number. Use a pull request to have the code checked and approved by other
    team members.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当发布准备就绪时，将其与主分支合并，并标记版本号。使用拉取请求让其他团队成员检查和批准代码。
- en: Start over again. Once the release is done, go back to the `develop` branch
    and start over with a new `feature` branch.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新开始。一旦发布完成，回到`develop`分支，然后从一个新的`feature`分支开始。
- en: Some critical problems may arise due to something that is in the main branch;
    in this case, we want to follow a faster procedure, and not risk deploying the
    feature we’re still developing.
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于主分支中的某些问题，可能会出现一些关键问题；在这种情况下，我们希望遵循更快的程序，而不是冒险部署我们仍在开发的功能。
- en: Make a hotfix branch from the main. This branch is crucial for quickly fixing
    important problems or bugs in the production code that can’t wait for the next
    release. It’s like a priority lane for bug fixing.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从主分支创建一个hotfix分支。这个分支对于快速修复生产代码中的重要问题或错误至关重要，这些错误不能等待下一个发布。它就像一个优先级通道，用于修复错误。
- en: Once the hotfix is done and has been tested, merge it into both the `develop`
    and main parts to ensure the fix works for both ongoing development and the production
    code.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦hotfix完成并经过测试，将其合并到`develop`和主分支，以确保修复对持续开发和生产代码都有效。
- en: This approach offers a structured approach to code change management, separating
    ongoing development from stable releases and promoting the use of short-lived
    **FEATURE**, **RELEASE**, and **HOTFIX** branches. Code reviews and testing are
    even more facilitated. At the end of the day, GitFlow provides a predictable development
    flow.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法为代码变更管理提供了一种结构化的方法，将持续开发与稳定发布分开，并促进使用短期存在的**FEATURE**、**RELEASE**和**HOTFIX**分支。代码审查和测试也更为便利。最终，GitFlow提供了一个可预测的开发流程。
- en: On the other hand, it is undeniably more intricate than other branching strategies.
    Also, it may lead to a larger number of branches (you have to create a branch
    even for really small features or issues); consequently, there’s potential for
    merge conflicts. It is also clear that GitFlow requires a certain level of discipline
    and adherence to the process, and some may perceive it as overly prescriptive
    or inflexible.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，这无疑比其他分支策略更复杂。此外，它可能导致分支数量增加（即使是真正的小功能或问题，你也必须创建一个分支）；因此，合并冲突的可能性增加。很明显，GitFlow需要一定的纪律和对流程的遵守，有些人可能会认为它过于规定或缺乏灵活性。
- en: 'In summary, no branching model is perfect. Analyze your need and choose one;
    no one says that it cannot be a mix of the models we just presented. I often saw,
    for instance, **HOTFIX** made directly into the **MAIN** branch and other times
    a **HOTFIX** branch opened, depending on the complexity involved in the fix. Also,
    consider that merging is often time-consuming: not only is the merge itself in
    case of conflicts but also the fact that usually, a merge requires a new build.
    If your build is slow, merging your branch to the **MAIN** branch could take time.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，没有哪种分支模型是完美的。分析你的需求，选择一个；没有人说它不能是我们刚才提出的模型的混合。例如，我经常看到**HOTFIX**直接合并到**MAIN**分支，有时根据修复的复杂性，会打开一个**HOTFIX**分支。此外，考虑合并通常很耗时：不仅合并本身在出现冲突时耗时，而且通常合并还需要新的构建。如果你的构建速度慢，将分支合并到**MAIN**分支可能会花费时间。
- en: Best practices
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最佳实践
- en: Although it might sound like a simple task, almost like saving a file in the
    cloud so that you don’t lose it if your computer gets stolen, managing files and
    project versions is another crucial aspect of improving your project management.
    Speaking from experience, it’s good not to underestimate this matter; it’s one
    of the things that sets someone who cares apart. Here are some tips we feel like
    sharing; as usual, it’s all quite flexible and based on our experience.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这可能听起来像是一项简单的任务，几乎就像在云端保存文件以防电脑被盗一样，但管理文件和项目版本是提高项目管理效率的另一个关键方面。从经验来看，不要低估这个问题；这是区分关心与否的人的一个因素。以下是我们想分享的一些技巧；像往常一样，这些都是相当灵活的，基于我们的经验。
- en: 'Make it a habit to commit to your work frequently and at the earliest opportunity.
    By doing this, you ensure that each commit captures a specific set of related
    changes. Keep your commits small and focused on a single task or feature. However,
    remember not to commit unfinished work as this can potentially disrupt the stability
    of the code base and create issues (golden rule: do not break the build on the
    main branch!). Instead, break your work into smaller, logical chunks, and commit
    them as you complete each part (or use a feature flag if you feel like that’s
    the case). This practice helps maintain a clean and reliable version history,
    making it easier to track the evolution of your project and collaborate effectively
    with your team.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 将频繁且尽早提交您的作品成为一种习惯。通过这样做，您确保每个提交都捕获一组特定的相关更改。保持您的提交小而专注，针对单个任务或功能。然而，请记住不要提交未完成的工作，因为这可能会破坏代码库的稳定性并产生问题（黄金法则：不要在主分支上破坏构建！）。相反，将您的工作分解成更小的、逻辑上合理的块，并在完成每个部分时提交它们（或者如果您觉得那样合适，可以使用功能标志）。这种做法有助于保持干净和可靠的版本历史，使跟踪项目的演变和与团队有效协作变得更加容易。
- en: 'Always run tests on your code before you commit changes. Testing helps ensure
    that a commit is not just functioning as expected but also that it doesn’t introduce
    any unintended problems or errors into the code base (golden rule: do not break
    the build on the main branch! Yes, I know I already said that). This step is crucial
    because sharing untested commits with your fellow developers can lead to confusion,
    disruptions in the project, and a lot of extra work down the line. By rigorously
    testing your changes before committing, you not only safeguard the stability of
    the project but also demonstrate your commitment to quality and collaboration
    within the development team. It’s a smart practice to help maintain a smooth and
    efficient workflow, building trust among your colleagues, and reducing the need
    for extensive debugging or troubleshooting later on. Remember, a well-tested commit
    is a valuable contribution to the project.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在提交更改之前，始终运行您的代码测试。测试有助于确保提交不仅按预期工作，而且不会向代码库引入任何未预料到的问题或错误（黄金法则：不要在主分支上破坏构建！是的，我知道我已经说过）。这一步骤至关重要，因为与您的同事共享未经测试的提交可能会导致混淆、项目中断以及后续的大量额外工作。通过在提交之前严格测试您的更改，您不仅保护了项目的稳定性，而且展示了您对质量和开发团队内协作的承诺。这是一种明智的做法，有助于保持顺畅和高效的流程，在同事之间建立信任，并减少后期进行大量调试或故障排除的需求。记住，经过良好测试的提交是对项目的宝贵贡献。
- en: When writing a commit message, aim for clarity and conciseness. The summary
    should be a brief yet informative glimpse into the nature of your changes, emphasizing
    their intent and how they distinguish themselves from the previous state of the
    code. In addition to a well-written summary, consider providing a more detailed
    description of your changes in the body of the commit message. This helps fellow
    developers, and even your future self, understand the context and significance
    of your modifications. Another valuable practice is linking your code changes
    to relevant work items or issues, enhancing traceability and project management.
    By associating your commits with specific tasks or tickets, you create a more
    organized and transparent system for tracking the progress of your work. For example,
    a common practice for Jira users (Jira is a very popular issue tracker) is to
    include the issue ID in the commit message. At the end of the day, your commit
    message serves as a crucial communication tool within your development team. A
    well-structured message ensures that your contributions are easily understood
    and integrated into the project’s development history, facilitating collaboration
    and maintaining a clear record of your work.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写提交信息时，目标是要清晰和简洁。摘要应该是对您更改本质的简要但信息丰富的概述，强调其意图以及它们如何与代码的先前状态区分开来。除了撰写良好的摘要外，还应考虑在提交信息的正文中提供您更改的更详细描述。这有助于其他开发人员，甚至您未来的自己，理解修改的上下文和重要性。另一个有价值的做法是将您的代码更改链接到相关的工作项或问题，增强可追溯性和项目管理。通过将您的提交与特定的任务或票据关联起来，您创建了一个更组织化和透明的系统，用于跟踪您工作的进度。例如，对于Jira用户（Jira是一个非常受欢迎的问题跟踪器）来说，一个常见的做法是在提交信息中包含问题ID。最终，您的提交信息在您的开发团队内部是一个至关重要的沟通工具。一个结构良好的信息确保您的贡献容易被理解和集成到项目的开发历史中，促进协作并保持您工作记录的清晰。
- en: 'One last piece of advice: when managing sensitive information such as passwords,
    it is crucial to exercise vigilant caution. Avoid the inadvertent exposure of
    production passwords and adopt alternative methods for secure storage. One recommended
    approach is to leverage a specialized system such as Vault, which provides a secure
    and centralized repository for managing sensitive credentials. By steering clear
    of committing production passwords directly and opting for such dedicated systems,
    you enhance the overall security posture of your data handling practices. This
    proactive approach not only mitigates the risk of inadvertent leaks but also ensures
    a more robust and scalable solution for safeguarding critical authentication information.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一条建议：当管理敏感信息，如密码时，必须非常谨慎。避免无意中泄露生产密码，并采用安全存储的替代方法。一种推荐的方法是利用专门的系统，如Vault，它提供了一个安全且集中的存储库来管理敏感凭证。通过避免直接提交生产密码并选择这样的专用系统，你可以提高数据处理实践的整体安全性。这种主动的方法不仅降低了意外泄露的风险，而且还确保了一个更强大和可扩展的解决方案来保护关键的认证信息。
- en: Code formatting and style
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码格式化和风格
- en: Here’s another part of our job that may seem basic, but no one talks about it...
    except when something goes wrong! From my experience, I believe that this is one
    of the things where developers have different ideas, maybe not entirely, but after
    all, we are precise people, and we all have our little quirks in how we arrange
    the code. As unimportant as it may seem, formatting the code correctly is important.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们工作的一部分，可能看起来很基础，但没有人谈论它...除非出了问题！根据我的经验，我认为这是开发者们有不同的看法的地方，也许不是完全不同，但毕竟，我们是精确的人，我们在安排代码的方式上都有自己的小习惯。尽管这看起来可能并不重要，但正确地格式化代码是非常重要的。
- en: Code formatting means arranging your computer program in a neat and organized
    way. It’s like making sure your writing follows specific rules so that it’s easy
    to read and understand. When you format your code, you decide on things such as
    how much space to leave between lines, where to put curly braces, and how to name
    things. This makes your code more readable, consistent, and easier to work with.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 代码格式化意味着以整洁和有序的方式安排你的计算机程序。这就像确保你的写作遵循特定的规则，以便易于阅读和理解。当你格式化代码时，你会决定诸如行间距、在哪里放置花括号以及如何命名事物等问题。这使得你的代码更易于阅读、一致，并且更容易处理。
- en: 'There are various rules and habits to follow when arranging code in Java, but,
    in our opinion, it’s also something very intuitive, almost like a natural skill
    for us software engineers. We’d bet that even without discussing it, we all know
    which one we prefer between the following two code snippets. Here’s the first
    one:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中安排代码时，有许多规则和习惯需要遵循，但据我们看来，这也很直观，几乎就像是我们软件工程师的一种自然技能。我们敢打赌，即使没有讨论，我们也都知道在以下两个代码片段中我们更喜欢哪一个。这是第一个：
- en: '[PRE0]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here’s the second one:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这是第二点：
- en: '[PRE1]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We think we all prefer the first snippet, and that’s because the second one
    lacks proper indentation, which is the first and crucial aspect of how we format
    our code. However, no matter the style, the entire team needs to stick to the
    same standard, which means a set of internal rules that we all expect everyone
    to follow. Rules need to be established for each of the aspects that govern code
    formatting; let’s take a look at the main ones.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们认为我们都更喜欢第一个片段，这是因为第二个片段缺少适当的缩进，这是我们格式化代码的第一个和最重要的方面。然而，无论风格如何，整个团队都需要坚持相同的标准，这意味着一套我们都期望每个人遵循的内部规则。需要为每个影响代码格式的方面制定规则；让我们看看主要的几个。
- en: Indentation
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缩进
- en: 'We use indentation to help us move through a file’s structure. If you think
    about it, a Java source file is a hierarchy of elements: we have the entire file,
    and then we have the classes inside it. Within classes, there are methods, and
    within methods, we have blocks, and so on, in a repeating pattern, including `if`
    statements, loops, and more. To help us navigate through all of this, we use indentation.
    Without indentation, even the simplest methods would be hard to understand. As
    we’ve mentioned before, code is designed to be run by machines but also to be
    understood by humans:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用缩进来帮助我们浏览文件的结构。如果你这么想，Java源文件是一个元素层次结构：我们有一个整个文件，然后是其中的类。在类内部，有方法，在方法内部，我们有块，以此类推，包括`if`语句、循环等。为了帮助我们导航所有这些，我们使用缩进。没有缩进，即使是简单的方法也难以理解。正如我们之前提到的，代码是为了让机器运行，同时也是为了让人类理解：
- en: '[PRE2]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Understanding this very simple code takes much longer if the method is not
    properly indented. This code prints one string if the given number is even and
    another if it’s odd. Understanding this method would have been much quicker if
    it had been indented correctly:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果方法没有正确缩进，理解这段非常简单的代码需要更长的时间。这段代码根据给定的数字是偶数还是奇数打印一个字符串。如果这段代码正确缩进，理解这个方法将会更快：
- en: '[PRE3]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'There are mainly two aspects related to indentation: when to break to a new
    line and how much to move the indented code to the right. For example, you can
    choose to indent the code with a tab or four spaces, or whatever you prefer, so
    long as everyone follows the same style.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 与缩进相关的主要有两个方面：何时换行以及将缩进代码向右移动多少。例如，你可以选择使用制表符或四个空格来缩进代码，或者你喜欢的任何方式，只要每个人都遵循相同的风格。
- en: There are some widely used standards and conventions, such as **Oracle’s Java
    Code Conventions** and the **Google Java Style Guide** (both of which are mentioned
    in the *Further reading* section). The first one recommends using four spaces
    for indentation, while the second suggests two. As you can see, it’s a pretty
    diverse world of choices! But, as I’ve mentioned before, what’s important is that
    everyone on the team uses the same set of rules.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 存在一些广泛使用的标准和约定，例如 **Oracle的Java代码约定** 和 **Google Java风格指南**（这两者都在*进一步阅读*部分提到）。第一个建议使用四个空格进行缩进，而第二个建议使用两个。正如我之前提到的，重要的是团队中的每个人都使用相同的规则集。
- en: Braces and whitespaces
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 花括号和空格
- en: Braces play a crucial role in delineating code blocks in Java. The two most
    prevalent brace styles are the **One True Brace Style** (**1TBS**) and **Allman
    Style**.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 花括号在Java中在界定代码块中起着至关重要的作用。最普遍使用的花括号风格是**真正的唯一花括号风格**（**1TBS**）和**Allman风格**。
- en: 'In 1TBS, the opening brace is placed at the end of the line, and the closing
    brace is put on a new line, indented to align with the opening line, like this:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在1TBS中，开花括号放在行尾，闭花括号放在新行上，缩进以与开行对齐，如下所示：
- en: '[PRE4]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In Allman Style, both the opening and closing braces are positioned on their
    individual lines, maintaining the same indentation level as the starting line:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在Allman风格中，开闭花括号都位于各自的行上，保持与起始行的相同缩进级别：
- en: '[PRE5]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'No matter which style you choose, it’s crucial to consistently apply it throughout
    your code base. Furthermore, always include spaces around operators to enhance
    readability:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你选择哪种风格，在整个代码库中一致地应用它至关重要。此外，始终在运算符周围包含空格以提高可读性：
- en: '[PRE6]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Both Google and Oracle use 1TBS. Also, Robert Martin’s *Clean Code* suggests
    this. For what it is worth, we also suggest it!
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: Google和Oracle都使用1TBS。Robert Martin的*Clean Code*也建议这样做。就其价值而言，我们也建议这样做！
- en: Line length and wrapping
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 行长度和换行
- en: 'A simple guideline for the length of lines in your code is to keep them between
    80 and 100 characters (Oracle says 80, Google says 100). Fun fact: the 80-character
    limit for code lines can be traced back to Herman Hollerith, who won the contract
    for processing the 1890 US Census. He used 80-column punched cards to handle the
    data. His company later evolved into IBM.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 对于代码行长的一个简单指南是保持它们在80到100个字符之间（Oracle说80，Google说100）。有趣的事实：代码行80个字符的限制可以追溯到Herman
    Hollerith，他赢得了处理1890年美国人口普查的合同。他使用80列穿孔卡片来处理数据。他的公司后来发展成为IBM。
- en: 'By keeping your lines between 80 and 100 characters, your code will be easy
    to read on different screen sizes and resolutions. If a line gets too long, you
    can split it into multiple lines while following these examples:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 通过保持你的行在80到100个字符之间，你的代码将在不同的屏幕尺寸和分辨率上易于阅读。如果一行太长，你可以根据以下示例将其拆分为多行：
- en: 'When you have lots of things separated by commas in a method call, you can
    break the line after a comma:'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你在方法调用中有很多由逗号分隔的项目时，你可以在逗号后断行：
- en: '[PRE7]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If you have a long math expression, you can break the line before an operator:'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你有一个长的数学表达式，你可以在运算符之前断行：
- en: '[PRE8]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'When you have a long condition, you can wrap it like this:'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你有一个长的条件时，你可以这样换行：
- en: '[PRE9]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Since the `&&` operator has higher precedence than the `||` operator, line wrapping
    aligns with this logic, making it easier to read.
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于 `&&` 运算符的优先级高于 `||` 运算符，换行符对齐符合这种逻辑，使得代码更易于阅读。
- en: 'For long string concatenations, you can wrap them like this:'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于长字符串连接，你可以这样换行：
- en: '[PRE10]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'However, note that the combination of string formatting and text blocks in
    Java 17 should allow us to bypass this problem. A **text block** refers to a language
    feature that allows you to define multiline strings in a more readable and maintainable
    way. It’s a way to embed blocks of text without the need for cumbersome concatenation
    or escape characters. For example:'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然而，请注意，在 Java 17 中，字符串格式化和文本块的组合应该允许我们绕过这个问题。**文本块**是指一种语言特性，允许你以更易于阅读和维护的方式定义多行字符串。这是一种在不使用繁琐的连接或转义字符的情况下嵌入文本块的方法。例如：
- en: '[PRE11]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'When using Lambda expressions, you can align wrapped lines with the opening
    delimiter like this:'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当使用 Lambda 表达式时，你可以将包裹的行与开头分隔符对齐，如下所示：
- en: '[PRE12]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As Google’s style guide says, you should never split a line right next to the
    arrow in a Lambda, except when the Lambda’s body is just a single, unbraced expression;
    then, you can put a line break right after the arrow.
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如 Google 风格指南所述，你永远不应该在 Lambda 表达式的箭头旁边拆分一行，除非 Lambda 的主体只是一个单独的、无括号的表达式；那时，你可以在箭头后面放置一个换行符。
- en: Comments and documentation
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 注释和文档
- en: 'You can comment on Java code in three ways:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用三种方式对 Java 代码进行注释：
- en: Use Javadoc comments (`/** ... */`) for describing classes, interfaces, methods,
    and fields (these are sometimes called documentation comments)
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Javadoc 注释 (`/** ... */`) 来描述类、接口、方法和字段（这些有时被称为文档注释）
- en: Use single-line comments (`//`) for brief explanations, clarifications, or marking
    TODOs (there are sometimes called implementation comments)
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用单行注释 (`//`) 来提供简短的解释、澄清或标记 TODO（有时被称为实现注释）
- en: Use block comments (`/* ... */`) for more extended explanations, especially
    when explaining intricate algorithms
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用块注释 (`/* ... */`) 来提供更详细的解释，尤其是在解释复杂的算法时
- en: The Google Java Style Guide has a specific section for Javadoc’s comments only
    since they are the most important ones. Documentation (Javadoc) is crucial to
    explain to others how to use your code, and that’s why is important to be strict
    when you write it... because you write it, right?
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: Google Java 风格指南有一个专门的部分来描述 Javadoc 的注释，因为它们是最重要的。文档（Javadoc）对于解释如何使用你的代码至关重要，这就是为什么在编写它时必须严格……因为你是在编写它，对吧？
- en: Since we’ve already discussed everything about the form that comments should
    take in code, let me say a few words about the substance of comments. Comments
    for generating Javadoc are crucial, no doubt about it. They don’t explain how
    the code works but rather the behavior of the method. They clarify any specifics
    about the parameters and the situations in which exceptions are raised.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经讨论了代码中注释应该采取的形式，让我谈谈注释的内容。用于生成 Javadoc 的注释无疑是至关重要的。它们不解释代码是如何工作的，而是解释方法的特性。它们澄清了关于参数和抛出异常的情况的任何具体细节。
- en: However, I’ve often seen comments being misused. First and foremost, commenting
    out code that is considered unnecessary is not a good practice. If the code is
    unnecessary, please delete it. If you’re concerned about making mistakes, remember
    that VCSs act as a safety net, allowing you to retrieve deleted code with minimal
    effort.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我经常看到注释被误用。首先，注释掉被认为是不必要的代码并不是一个好的做法。如果代码是不必要的，请删除它。如果你担心出错，请记住版本控制系统（VCSs）就像一个安全网，允许你以最小的努力恢复已删除的代码。
- en: At times, I’ve come across comments related to the implementation. In the case
    of particularly complex code that’s hard to follow, a comment can be helpful.
    However, it should never be seen as a substitute for cleaning up the code to make
    it more understandable. If the code isn’t written well, don’t think you can fix
    it by adding comments. Rewrite the code. Additionally, it’s common for such comments
    not to get updated when the logic of the method changes. The method does one thing,
    but the comment says something else, leading to confusion.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我会遇到与实现相关的注释。对于特别复杂且难以理解的代码，注释可能会有所帮助。然而，它永远不应该被视为清理代码以使其更易于理解的替代品。如果代码写得不好，不要以为通过添加注释就能修复它。重写代码。此外，这样的注释在方法逻辑发生变化时通常不会更新。方法做了一件事，但注释说的是另一件事，导致混淆。
- en: Other types of comments that I don’t find particularly useful, except for rare
    exceptions, are the infamous `TODO` and `FIXME`. If you know you need to fix something,
    just fix it. If you can’t do it right away, record the task in your task management
    system (for example, Jira) and move on. Putting `FIXME` in the code only adds
    confusion. When someone sees that `FIXME` in 2 years, they’ll wonder, “Why hasn’t
    it been fixed yet? Maybe it’s not important.” The same goes for `TODO`.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我觉得不太有用的其他类型注释，除了少数例外，是臭名昭著的`TODO`和`FIXME`。如果你知道你需要修复某些东西，就立即修复它。如果你不能立即完成，就在你的任务管理系统中（例如，Jira）记录这个任务，然后继续。在代码中放置`FIXME`只会增加混淆。当有人在未来两年看到这个`FIXME`时，他们会想，“为什么还没有修复？也许它并不重要。”对于`TODO`也是同样的道理。
- en: In summary, we advise you to write as few comments as possible in your code.
    Instead, focus on explaining why you’re making a particular choice and the reasons
    that led you down one path instead of another. As Robert Martin says in *Clean
    Code*, you have to explain your intent.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，我们建议你在代码中尽可能少地写注释。相反，专注于解释你为什么做出特定的选择，以及导致你选择这条路径而不是另一条路径的原因。正如罗伯特·马丁在*Clean
    Code*中所说，你必须解释你的意图。
- en: Naming conventions
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命名约定
- en: Naming conventions play a vital role in enhancing program comprehension and
    improving code readability. They serve as a set of guidelines that, when followed,
    make code more accessible and easier to grasp. These conventions not only contribute
    to readability but also convey essential information about the purpose of an identifier.
    This additional context helps developers understand the role of the identifier,
    whether it represents a constant, package, class, or another entity within the
    code. These conventions are essential tools for effective code communication and
    can significantly aid in the comprehension and maintenance of software systems.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 命名约定在增强程序理解力和提高代码可读性方面发挥着至关重要的作用。它们作为一套指南，遵循这些指南可以使代码更易于访问和理解。这些约定不仅有助于可读性，还传达了关于标识符目的的重要信息。这种额外的上下文有助于开发者理解标识符的作用，无论是代表常量、包、类还是代码中的其他实体。这些约定是有效代码沟通的重要工具，可以显著帮助理解和维护软件系统。
- en: 'Both Google’s and Oracle’s conventions define in-depth rules for naming the
    various components and they have many touchpoints:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 谷歌和甲骨文的约定都为命名各种组件定义了深入细致的规则，并且它们有许多交集：
- en: Google’s style guide specifies that identifiers are made up of ASCII letters
    and digits, and occasionally, underscores, as specified by the `\w+` regular expression.
    Special prefixes or suffixes such as `model_`, `cModel`, and `c_name` are not
    used in identifier names.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 谷歌的风格指南规定，标识符由ASCII字母、数字以及偶尔的下划线组成，这由`\w+`正则表达式指定。在标识符名称中不使用特殊的前缀或后缀，如`model_`、`cModel`和`c_name`。
- en: '`UpperCamelCase`, which means the first letter of each word is capitalized.
    Class names are typically related to things and are usually nouns, such as `Student`
    or `ImmutableList`. Interface names can also be nouns or noun phrases, such as
    `Set`, or they might sometimes be adjectives or adjective phrases, such as `Serializable`.
    When it comes to naming annotation types, there aren’t specific rules or widely
    accepted conventions. Google’s style guide also specifies that for test classes,
    their names end with `Test`. If a test class covers a single class, it takes the
    name of that class and adds `Test` to the end.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UpperCamelCase`，意味着每个单词的首字母都大写。类名通常与事物相关，通常是名词，例如`Student`或`ImmutableList`。接口名称也可以是名词或名词短语，例如`Set`，或者有时可能是形容词或形容词短语，例如`Serializable`。当涉及到命名注解类型时，并没有特定的规则或广泛接受的约定。谷歌的风格指南还规定，测试类的名称以`Test`结尾。如果一个测试类只覆盖一个类，它将采用那个类的名称，并在末尾添加`Test`。'
- en: '`lowerCamelCase`, where the first letter is in lowercase and subsequent words
    are capitalized, such as `sendMessage` or `stop`. Method names are typically related
    to actions or what the method does, and they are like verbs or phrases, such as
    `sendNotification` or `initialize`. Google’s style guide also specifies that method
    names in the `JUnit` test could have underscores to separate different parts of
    the name. Each part is also written in `lowerCamelCase` – for example, `publishPost_translateToUserLanguage`.
    There isn’t a single correct way to name test methods, so you have some flexibility
    here.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lowerCamelCase`，其中第一个字母小写，后续单词首字母大写，例如`sendMessage`或`stop`。方法名称通常与动作或方法执行的操作相关，它们类似于动词或短语，例如`sendNotification`或`initialize`。谷歌的风格指南还规定，`JUnit`测试中的方法名称可以使用下划线来分隔名称的不同部分。每个部分也以`lowerCamelCase`编写——例如，`publishPost_translateToUserLanguage`。命名测试方法没有唯一正确的方法，因此在这里你有一定的灵活性。'
- en: '`UPPER_SNAKE_CASE`, meaning they are written in all uppercase letters with
    words separated by a single underscore. Constants are like unchanging values in
    your code. They are represented as `static final` fields, which means they never
    change once they are set. These constants are deeply immutable, meaning they can’t
    be modified in any way, and they don’t have methods that cause any noticeable
    side effects. Examples of constants include simple data types such as numbers,
    text (strings), unchangeable value types, and even things set to `null`. But here’s
    the key: if anything about this value can change or be observed differently over
    time, it’s not a constant (you could have guessed that).'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UPPER_SNAKE_CASE`，意味着它们全部大写，单词之间用一个单下划线分隔。常量就像代码中的不变值。它们以`static final`字段的形式表示，这意味着一旦设置就永远不会改变。这些常量是深度不可变的，意味着它们不能以任何方式修改，并且没有引起任何明显副作用的方法。常量的例子包括简单的数据类型，如数字、文本（字符串）、不可变值类型，甚至设置为`null`的东西。但关键是：如果这个值有任何可以改变或随时间不同观察的地方，它就不是常量（你可能已经猜到了）。'
- en: '`lowerCamelCase`, where the first letter is lowercase, and subsequent words
    are capitalized. When it comes to naming parameters in public methods, it’s a
    good practice to avoid using single-character names whenever possible. As Robert
    Martin’s *Clean Code* states, using more descriptive names makes it easier for
    others to understand the purpose of the parameter (just think about naming a parameter
    `x`).'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lowerCamelCase`，其中第一个字母小写，后续单词首字母大写。在公共方法中命名参数时，尽可能避免使用单字符名称是一种良好的实践。正如罗伯特·马丁的《*Clean
    Code*》所述，使用更具描述性的名称使其他人更容易理解参数的目的（想想给一个参数命名为`x`）。'
- en: '`lowerCamelCase`. Even if a local variable is declared as `final` and remains
    unchanged, it’s not regarded as a constant, and therefore, it should not be named
    like a constant.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lowerCamelCase`。即使局部变量被声明为`final`并且保持不变，它也不被视为常量，因此，不应像常量那样命名。'
- en: Automated tools
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自动化工具
- en: We cannot think of implementing all these rules by hand every time we write
    a line of code. Well, it used to be done that way once, but even I am not old
    enough to have seen it! Fortunately, we have automatic tools at our disposal that
    help us on various levels.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们无法想象每次编写代码时都手动实现所有这些规则。嗯，曾经有过这样做的时候，但即使我还不老到能看到那个时代！幸运的是，我们有自动工具可供使用，它们在各个层面上帮助我们。
- en: For example, **integrated development environments** (**IDEs**) play a significant
    role in supporting code formatting by providing tools and features to help developers
    adhere to coding standards and automatically format their code. IDEs facilitate
    code formatting by performing auto-indentation – that is, automatically indenting
    code blocks – making it easier to read and understand the code’s structure. Indentation
    can be customized according to the coding standards of your project. Furthermore,
    most IDEs allow developers to define and customize code style preferences. These
    preferences include settings for indentation, brace placement, line wrapping,
    and naming conventions. Developers can tailor these settings to match the coding
    standards of their project or organization. IDEs come with built-in or customizable
    code formatters that automatically format your code based on the defined coding
    style preferences. These formatters ensure that your code follows the established
    standards consistently.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，**集成开发环境**（**IDEs**）在支持代码格式化方面发挥着重要作用，它们通过提供工具和功能来帮助开发者遵守编码标准并自动格式化代码。IDEs通过执行自动缩进来简化代码格式化——也就是说，自动缩进代码块——这使得代码更容易阅读和理解其结构。缩进可以根据项目的编码标准进行自定义。此外，大多数IDE允许开发者定义和自定义代码风格偏好。这些偏好包括缩进、括号放置、换行和命名约定的设置。开发者可以根据项目的或组织的编码标准调整这些设置。IDEs自带或可自定义的代码格式化器会根据定义的代码风格偏好自动格式化代码。这些格式化器确保代码始终遵循既定的标准。
- en: But don’t worry, you don’t have to set up all the nitty-gritty of your IDE’s
    formatting settings details; most of them – especially the most used ones – have
    the chance to export the so-called **code style formatter**. You just have to
    discover how your IDE does it (or just google it), export your file, and make
    sure everyone in the team is using that file, importing it in their IDE. When
    you format your code in your IDE – via the relative command or shortcut – the
    code style will be the same for everyone... everyone who’s using the same IDE,
    of course. Yes, because these code styles are specific for each IDE; NetBeans’
    one is different from Eclipse’s one.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 但别担心，你不必设置IDE格式化设置的所有细节；其中大部分——尤其是最常用的——都有机会导出所谓的**代码风格格式化器**。你只需要发现你的IDE是如何做到的（或者直接谷歌一下），导出你的文件，并确保团队中的每个人都使用该文件，将其导入到他们的IDE中。当你通过相对命令或快捷键在IDE中格式化代码时，代码风格对每个人来说都是相同的……当然，是使用相同IDE的每个人。是的，因为这些代码风格是针对每个IDE的；NetBeans的与Eclipse的不同。
- en: There are many solutions to this problem. For example, you could try to manually
    edit your exported code style file (which is always a text file) so that it adapts
    to the destination IDE; however, I don’t feel like advising you to do that. A
    possible solution could be to use a cross-IDE tool, a tool that is essentially
    the same for everyone. For example, there is a tool called **CodeConfig** ([https://editorconfig.org](https://editorconfig.org))
    that allows you to configure a code style and can be installed on numerous different
    IDEs (many, such as IntelliJ, support it natively). Alternatively, you could move
    the problem somewhere else.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个问题，有许多解决方案。例如，你可以尝试手动编辑你的导出代码风格文件（它始终是一个文本文件），使其适应目标IDE；然而，我不建议你这样做。一个可能的解决方案是使用跨IDE工具，一个对每个人来说本质上都是相同的工具。例如，有一个名为**CodeConfig**（[https://editorconfig.org](https://editorconfig.org)）的工具，它允许你配置代码风格，并且可以在许多不同的IDE上安装（许多，如IntelliJ，原生支持它）。或者，你也可以将问题转移到其他地方。
- en: If you’re working on a Java project, you’re probably using a build automation
    tool such as Gradle or Maven. These tools allow you to compile code, among other
    things, and, in general, simplify the entire development life cycle. As you know,
    there are various plugins available for these tools. Some of them directly modify
    the code itself – in this book, we’ve seen examples such as Lombok and MapStruct.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在处理Java项目，你可能会使用Gradle或Maven等构建自动化工具。这些工具允许你编译代码，以及其他事情，并且通常简化了整个开发周期。正如你所知，这些工具有各种插件可用。其中一些直接修改代码本身——在这本书中，我们看到了Lombok和MapStruct等示例。
- en: Some plugins intend to check your code for any problems with code style. One
    of the most famous is Checkstyle. The Apache Maven Checkstyle Plugin (see the
    *Further reading* section) integrates the Checkstyle tool into your Maven build
    process to enforce coding style and standards on your Java source code. Checkstyle
    is an open source static code analysis tool that checks your Java code against
    a set of predefined coding conventions and style rules. You define your coding
    style rules and preferences in a Checkstyle configuration file, typically named
    `checkstyle.xml`. This file specifies which coding standards you want to enforce,
    such as naming conventions, indentation, and formatting rules. Then, the Apache
    Maven Checkstyle Plugin is configured in your project’s `pom.xml` file. You specify
    the Checkstyle rules file and other settings to be used during the build. When
    you run a Maven build (for example, via `mvn clean install`), the Apache Maven
    Checkstyle Plugin is executed as part of the build process. It scans your Java
    source code files for violations of the defined coding standards. If Checkstyle
    detects any violations, it generates a report that lists the issues found in your
    code. This report can be viewed in various formats, such as HTML or XML. You can
    configure the plugin to either fail the build if violations are found or generate
    a warning report without failing the build. The choice depends on your project’s
    requirements. The Apache Maven Checkstyle Plugin is useful to get an overview
    of any problems you might have, but it does not fix them for you.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 一些插件旨在检查你的代码是否存在任何与代码风格相关的问题。其中最著名的是Checkstyle。Apache Maven Checkstyle Plugin（参见*进一步阅读*部分）将Checkstyle工具集成到你的Maven构建过程中，以强制执行Java源代码的编码风格和标准。Checkstyle是一个开源的静态代码分析工具，它将你的Java代码与一组预定义的编码约定和风格规则进行比较。你可以在Checkstyle配置文件中定义你的编码风格规则和偏好，通常命名为`checkstyle.xml`。此文件指定了你想要强制执行的编码标准，例如命名约定、缩进和格式化规则。然后，在项目的`pom.xml`文件中配置Apache
    Maven Checkstyle Plugin。你指定要使用的Checkstyle规则文件和其他设置。当你运行Maven构建（例如，通过`mvn clean
    install`）时，Apache Maven Checkstyle Plugin作为构建过程的一部分执行。它扫描你的Java源代码文件，查找违反定义的编码标准的情况。如果Checkstyle检测到任何违规，它将生成一个报告，列出代码中找到的问题。此报告可以以各种格式查看，例如HTML或XML。你可以配置插件，如果发现违规，则使构建失败或生成警告报告而不使构建失败。选择取决于你的项目需求。Apache
    Maven Checkstyle Plugin有助于了解你可能遇到的问题概述，但它不会为你修复这些问题。
- en: Some plugins handle code formatting. By integrating these plugins into your
    development process, you can ensure that your code is automatically formatted
    with every build, without the need for manual intervention. A Maven plugin that
    you could use is **maven-formatter-plugin** ([https://code.revelc.net/formatter-maven-plugin](https://code.revelc.net/formatter-maven-plugin)),
    which, by default, supports the “Eclipse style” but can be configured with any
    code style. We haven’t eliminated the complexity of the “file transfer” step,
    but we’ve integrated code formatting into our development cycle. But we can be
    even smarter than that.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 一些插件处理代码格式化。通过将这些插件集成到你的开发过程中，你可以确保每次构建时代码都会自动格式化，无需手动干预。你可以使用的Maven插件是**maven-formatter-plugin**（[https://code.revelc.net/formatter-maven-plugin](https://code.revelc.net/formatter-maven-plugin)），默认情况下支持“Eclipse风格”，但可以配置为任何代码风格。我们还没有消除“文件传输”步骤的复杂性，但我们已经将代码格式化集成到我们的开发周期中。但我们还可以更聪明一些。
- en: In software companies, CI/CD tools such as GitLab or Jenkins are now widespread.
    If you’re new to the concept, a CI/CD pipeline is an automated workflow that streamlines
    the software development and delivery process. It starts with CI, where developers
    frequently merge their code changes into a shared repository. Automated builds,
    testing, and code analysis are performed to ensure code quality and identify issues
    early. **Continuous delivery** (**CD**) follows CI and involves deploying code
    changes to staging or pre-production environments. Additional testing and quality
    checks are conducted to simulate production conditions. After successful testing,
    the code can be automatically deployed to the production environment.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件公司中，GitLab或Jenkins等CI/CD工具现在非常普遍。如果你对这个概念还不太熟悉，CI/CD管道是一个自动化的工作流程，它简化了软件开发和交付过程。它从CI开始，开发者经常将他们的代码更改合并到一个共享的仓库中。执行自动构建、测试和代码分析以确保代码质量和早期识别问题。**持续交付**（**CD**）紧随CI之后，涉及将代码更改部署到预发布或生产环境。进行额外的测试和质量检查以模拟生产条件。测试成功后，代码可以自动部署到生产环境。
- en: 'When it comes to formatting and styling code, you can set up an automatic system
    that checks how code is written. Every time new pieces of code are pushed into
    the repository, this automatic system checks if the code follows formatting rules.
    Depending on how we set up this system, it can be a simple check that tells us
    if the code isn’t written correctly, or it can be stricter and stop the process
    if there are serious issues (though this rarely happens). Furthermore, this system
    can do something really helpful: it can fix poorly written code so that it follows
    the shared rules of our group or company. In practice, this system “re-commits”
    the same pieces of code, but this time, they are formatted correctly. This means
    we might not have to worry about fixing the code manually anymore.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到代码的格式化和样式时，你可以设置一个自动系统来检查代码的编写方式。每次将新的代码片段推送到仓库时，这个自动系统都会检查代码是否遵循格式化规则。根据我们如何设置这个系统，它可能只是一个简单的检查，告诉我们代码是否编写正确，或者它可能更加严格，如果存在严重问题则会停止进程（尽管这种情况很少发生）。此外，这个系统还可以做一些非常有帮助的事情：它可以修复编写不良的代码，使其遵循我们团队或公司的共享规则。在实践中，这个系统会“重新提交”相同的代码片段，但这次它们是格式化正确的。这意味着我们可能再也不必担心手动修复代码了。
- en: 'One last side note: formatting code in the same way is also important to reduce
    merge conflicts and unintentional code commits. Let’s imagine that Developer A
    uses `CodeStyleA`, while Developer B uses `CodeStyleB` (as expected). Developer
    A makes a small change, let’s say a five-line method, inside a class. Being diligent,
    they initiate code formatting for the entire class using their IDE. Since Developer
    A is using their personalized `CodeStyleA`, they will likely unintentionally commit
    other parts of the class that weren’t the intended focus of the change. This results
    in lines that were altered by Developer A but, in a way, weren’t supposed to be.
    On the other hand, Developer B is making changes to the same class but in a different
    place. When they need to push their code, they find the same lines changed by
    Developer A, but only because Developer A *incorrectly formatted* the code. This
    may seem like an edge case, but it’s not uncommon – I’ve seen it happen many times.
    It’s not a disaster by any means, but it’s time wasted that can be saved with
    a bit of care.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一点补充：以相同的方式格式化代码也很重要，可以减少合并冲突和意外的代码提交。让我们想象一下，开发者A使用`CodeStyleA`，而开发者B使用`CodeStyleB`（正如预期的那样）。开发者A在类内部进行了一些小的更改，比如说一个五行的方法。由于他们勤奋，他们使用他们的IDE对整个类进行了代码格式化。由于开发者A使用他们个性化的`CodeStyleA`，他们可能会无意中提交其他部分的代码，而这些代码并不是更改的重点。这导致了一些被开发者A更改的行，但以某种方式，这些行本不应该被更改。另一方面，开发者B正在对同一个类进行更改，但位置不同。当他们需要推送他们的代码时，他们发现开发者A更改了相同的行，但这仅仅是因为开发者A*错误地格式化了*代码。这可能看起来像是一个边缘情况，但这种情况并不罕见——我见过很多次。这绝对不是灾难，但这是可以通过一点小心就能节省的时间。
- en: Now that we’ve discussed code versioning and style, let’s talk about a practice
    that can’t be emphasized enough.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经讨论了代码版本控制和样式，让我们谈谈一个不能过分强调的实践。
- en: Code reviews
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码审查
- en: '**Code reviews**, often also called **peer reviews**, are a very powerful tool
    for developers’ daily work. We could almost say that they are fundamental, but
    the truth is that under certain conditions, it is possible to choose whether to
    perform them or not, provided, however, that if not, other methodologies are implemented.
    But let’s go in order and try to understand what a code review is.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '**代码审查**，通常也称为**同行评审**，是开发者日常工作中一个非常强大的工具。我们几乎可以说它们是基本的，但事实是，在特定条件下，可以选择是否执行它们，然而，如果没有执行，则必须实施其他方法。但让我们按顺序来，试着理解什么是代码审查。'
- en: A code review can be implemented in slightly different forms, but it typically
    consists of submitting a piece of code to one or more developers who did not write
    that code; these people are usually referred to as “reviewers.” So, for example,
    if you own a certain task and you developed the relative code, before deploying
    it in production (or usually even before merging your feature branch on your main
    branch, depending on your “framework”), your code is reviewed by some other teammate
    who did not write a single line of that code. The aim is not to judge and the
    benefits are vast.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 代码审查可以以略微不同的形式实施，但它通常包括将一段代码提交给一个或多个没有编写该代码的开发者；这些人通常被称为“审查者”。例如，如果你负责某个任务并开发了相关的代码，在将其部署到生产环境（或者通常在将你的功能分支合并到主分支之前，取决于你的“框架”）之前，你的代码会由某个其他队友进行审查，而这个队友没有编写该代码的任何一行。目的是不是评判，其好处是巨大的。
- en: First of all, there is a sort of quality assurance. It allows developers to
    catch and rectify defects, bugs, and vulnerabilities in the code before it reaches
    the end users. By detecting issues early in the development process, code review
    significantly reduces the cost and effort required to fix them in later stages
    of development or after deployment.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，这是一种质量保证。它允许开发者捕捉并纠正代码中的缺陷、错误和漏洞，在代码到达最终用户之前。通过在开发早期阶段发现问题，代码审查显著降低了在开发后期或部署后修复这些问题的成本和努力。
- en: Beyond catching bugs, code review can also reveal design flaws and inefficiencies
    in the code. By discussing and suggesting improvements during code review, developers
    can refine the software’s architecture, making it more robust and scalable.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 除了捕捉错误之外，代码审查还可以揭示代码中的设计缺陷和不效率。通过在代码审查期间讨论和提出改进建议，开发者可以完善软件的架构，使其更健壮和可扩展。
- en: Maybe even more important – but this is arguable – is knowledge sharing. Code
    review is a learning opportunity for all team members. It promotes knowledge sharing
    and mentorship, where experienced developers can guide less experienced ones.
    This collaborative aspect fosters a culture of continuous learning and improvement
    within the development team.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 可能更重要的是——但这是有争议的——是知识共享。代码审查是所有团队成员的学习机会。它促进了知识共享和导师制，经验丰富的开发者可以指导经验不足的同事。这种协作方面在开发团队中培养了一种持续学习和改进的文化。
- en: Code review ensures that the code adheres to a consistent coding style and follows
    the project’s coding guidelines. This consistency makes the code base more maintainable
    and understandable, especially when multiple developers are working on the same
    project. Remember, your code is only clean if everyone on the team thinks it is!
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 代码审查确保代码遵循一致的编码风格并遵循项目的编码指南。这种一致性使得代码库更易于维护和理解，尤其是在多个开发者共同参与同一项目时。记住，只有当团队中的每个人都认为代码是干净的，你的代码才算干净！
- en: 'Then comes one of my favorite aspects: that code review encourages effective
    communication within the development team. Developers engage in discussions about
    the code, which can lead to a better understanding of the project’s goals and
    requirements, resulting in a more aligned and cohesive team. This, in my opinion,
    also encourages a culture of feedback, which is crucial within companies and teams;
    it is one of the moments in which we learn to communicate our feedback effectively
    and, above all, in which we learn to receive it, appreciating it for what it is
    – that is, a gift to our professional growth. Trust the touchy-feely – the code
    review is one of the most learned moments.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 然后是我最喜欢的一个方面：代码审查鼓励开发团队内部的有效沟通。开发者会就代码进行讨论，这可能导致对项目目标和要求的更好理解，从而形成一个更协调和团结的团队。在我看来，这也鼓励了一种反馈文化，这在公司和团队中至关重要；这是我们学会有效沟通反馈的时刻，更重要的是，这是我们学会接受反馈的时刻，欣赏它所代表的一切——那就是，它是我们职业成长的礼物。相信那些“摸不着边际”的感觉——代码审查是最能学到东西的时刻之一。
- en: 'A code review becomes more effective if you set some sort of rules, I dare
    almost say limits to what you are going to observe: are we looking for inefficiencies,
    are we trying to make the code cleaner, are we looking for bugs, are we doing
    all these things? No problem, just agree and set expectations. Keep code review
    sessions short and sweet. Decide on what works for your team, such as maybe sticking
    to a rule of not going over 1 hour or reviewing more than 200 lines of code at
    a time. This keeps things productive.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你为代码审查设定一些规则，甚至可以说是观察的界限：我们是寻找低效之处，还是试图让代码更简洁，是在寻找错误，还是所有这些都要做？没问题，只要达成一致并设定期望。保持代码审查会议简短而精炼。决定对团队有效的方法，比如可能坚持不超过1小时或一次审查超过200行代码的规则。这有助于保持工作效率。
- en: As much as possible, use tools and automation. For example, tools such as GitHub
    help us with code reviews, with the ability to compare different versions of code,
    write comments, and more. Automatic tools for static code analysis, which were
    already addressed in the previous chapters, allow us – if integrated into pipelines,
    for example – to avoid the most common inaccuracies such as the organization of
    imports, code formatting, and so on.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 尽可能多地使用工具和自动化。例如，GitHub这样的工具帮助我们进行代码审查，具有比较不同版本代码、写评论等功能。静态代码分析的自动工具，在前面的章节中已经提到，如果集成到管道中，例如，可以避免最常见的错误，如导入的组织、代码格式化等。
- en: Again, the human factor is fundamental. Try to be constructive in giving feedback
    and try to be “open-minded” in receiving it; it’s not a race, it’s a cooperation
    between equals. The goal must only be to achieve a common result and to do it
    together. Code review should be a constructive process, not a blame game. Use
    polite language and provide suggestions for improvement rather than criticizing
    the author. The goal is to enhance the code, not demotivate the developer. Make
    sure everyone on your team, whether they’re new or experienced, takes part in
    code reviews. It helps newer team members learn about the code and allows them
    to have their work checked by more experienced developers. This way, the workload
    can be balanced, and it’s easier to manage when someone is absent or leaves the
    team.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，人为因素是至关重要的。在提供反馈时尽量保持建设性，在接收反馈时尽量“开放心态”；这不是一场竞赛，而是平等之间的合作。目标必须只能是实现一个共同的结果，并且一起实现。代码审查应该是一个建设性的过程，而不是一场指责游戏。使用礼貌的语言并提供改进建议，而不是批评作者。目标是提高代码质量，而不是让开发者失去动力。确保团队中的每个人，无论是新手还是经验丰富，都参与代码审查。这有助于新成员了解代码，并允许他们的工作由经验丰富的开发者检查。这样，工作量可以平衡，当有人缺席或离开团队时，管理起来也更容易。
- en: Sometimes, appointing a moderator or lead developer to facilitate the code review
    process can be a key element in maintaining its effectiveness. They serve as a
    guiding force, ensuring that the review discussions stay productive and on track.
    The moderator’s responsibilities encompass structuring the review process, clarifying
    expectations for both authors and reviewers, mediating discussions, and balancing
    feedback. They also play a vital role in prioritizing issues, documenting outcomes,
    and mentoring less-experienced developers.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，指派一个调解员或主要开发者来促进代码审查过程可能是保持其有效性的关键要素。他们作为引导力量，确保审查讨论保持高效并按计划进行。调解员的职责包括构建审查流程、明确作者和审查者的期望、调解讨论以及平衡反馈。他们还在优先处理问题、记录结果和指导经验不足的开发者方面发挥着至关重要的作用。
- en: To be honest, there are also some disadvantages in code reviews – that is why
    they’re sometimes not well-seen by tech-illiterate managers.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 说实话，代码审查也有一些缺点——这就是为什么它们有时不被技术不熟练的管理者看好。
- en: The review process has the potential to extend the time it takes to release
    a software update. This delay occurs because reviewers and authors must collaborate
    to address issues, which can be time-consuming. Furthermore, reviewers may not
    be able to expedite the review process due to their existing workload. However,
    this hurdle can be mitigated through the utilization of code review tools equipped
    with automated testing capabilities. These tools effectively identify common errors,
    thereby freeing up valuable developer time that can be redirected toward tackling
    more complex software engineering challenges.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 审查过程有可能延长发布软件更新所需的时间。这种延迟发生是因为审查者和作者必须合作解决问题，这可能很耗时。此外，由于他们现有的工作负载，审查者可能无法加快审查过程。然而，这种障碍可以通过使用配备自动化测试功能的代码审查工具来缓解。这些工具有效地识别常见错误，从而释放出宝贵的开发者时间，可以将这些时间重新分配给解决更复杂的软件工程挑战。
- en: Developers often find themselves juggling a substantial workload, and the need
    for a code review can divert their attention from other critical tasks that demand
    their immediate attention. This diversion poses a dilemma for team members who
    must choose between completing their ongoing responsibilities or pausing their
    work to conduct a code review. In either scenario, work somewhere within the organization
    is delayed. To alleviate this issue, team members can implement strategies such
    as a reviewer rotation system or maintain a list of domain experts who can share
    the reviewing burden. These measures prevent any single developer from becoming
    overwhelmed by a multitude of review requests.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者经常发现自己手头的工作量很大，而代码审查的需求可能会分散他们的注意力，使他们无法立即关注其他关键任务。这种分散注意力的情况为团队成员带来了困境，他们必须在完成手头的工作或暂停工作以进行代码审查之间做出选择。在任何情况下，组织内部的工作都会被推迟。为了缓解这个问题，团队成员可以实施一些策略，例如审查者轮换制度或维护一份领域专家名单，这些专家可以分担审查负担。这些措施可以防止任何单个开发者被大量的审查请求压垮。
- en: When developers are tasked with reviewing a substantial code alteration, the
    review process tends to consume a considerable amount of time. Assessing large
    code changes can be particularly challenging, and reviewers may feel compelled
    to expedite the process to meet deadlines, potentially compromising the quality
    of feedback. An effective solution to this challenge is the practice of incremental
    code development. This approach allows reviewers to examine smaller code segments
    multiple times, as opposed to grappling with a massive code change all at once.
    This not only enhances the quality of the review but also streamlines the overall
    process.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 当开发者被分配审查大量代码更改的任务时，审查过程往往会消耗大量时间。评估大量代码更改可能特别具有挑战性，并且审查员可能会感到有必要加快进程以满足截止日期，这可能会损害反馈的质量。解决这一挑战的有效方法是增量代码开发实践。这种方法允许审查员多次检查较小的代码段，而不是一次性处理大量的代码更改。这不仅提高了审查质量，还简化了整个过程。
- en: There are different types of code reviews, which we will list in order of effectiveness,
    starting with the one that we think is the least effective.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 代码审查有不同的类型，我们将按有效性顺序列出，从我们认为最不有效的那一种开始。
- en: Email pass-arounds
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 电子邮件传递
- en: '**Email pass-arounds** are a common way of dealing with small issues and tiny
    bits of code. You can do this by sending emails or using code tools. In an email
    pass-around, the person who made the code changes sends an email to those who
    need to check it. It’s like looking at someone’s screen over their shoulder, and
    it’s quite easy to use. You don’t need a lot of training, and you can start right
    away. Of course, think of “email” as “a direct message to someone…” I mean, who
    uses email to communicate with their teammates nowadays?! It can, of course, be
    a Slack message, or a “merge request” on GitLab... anything.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '**电子邮件传递**是处理小问题和少量代码的常见方式。你可以通过发送电子邮件或使用代码工具来完成这项工作。在电子邮件传递中，对代码进行更改的人会向需要检查它的人发送电子邮件。这就像从别人的肩膀后面看他们的屏幕一样，使用起来相当简单。你不需要很多培训，可以立即开始。当然，把“电子邮件”想成“直接给某人的消息……”我的意思是，现在谁还用电子邮件与队友沟通？！当然，它也可以是Slack消息，或者GitLab上的“合并请求”……任何东西都可以。'
- en: The advantages of using email pass-arounds include ease of setup, remote and
    asynchronous review possibilities, and automatic reviews in some code management
    systems.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 使用电子邮件传递的优点包括设置简单、远程和异步审查的可能性，以及在某些代码管理系统中的自动审查。
- en: However, there are drawbacks to email pass-arounds, such as the time it takes
    to collect necessary files, difficulty in tracking and following conversations
    within email threads, the absence of a definite end date for the review, uncertainty
    about whether the changes were implemented, and challenges in measuring its effectiveness.
    In all honesty, I found references to this practice only “in literature;” I’ve
    never seen it happen.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，电子邮件传递存在一些缺点，例如收集必要文件所需的时间、在电子邮件线程中跟踪和跟进对话的困难、缺乏明确的审查截止日期、对更改是否实施的不确定性，以及衡量其有效性的挑战。坦白说，我只在“文献中”看到过这种做法；我从未见过它发生。
- en: Code review automation tools
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码审查自动化工具
- en: Teams sometimes use automated tools to save time and ensure they deliver high-quality
    code. These tools can automatically collect and display code changes, streamline
    feedback through comments, and even help find and fix vulnerabilities using **static
    application security** **testing** (**SAST**).
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 团队有时会使用自动化工具来节省时间并确保他们交付高质量的代码。这些工具可以自动收集和显示代码更改，通过注释简化反馈，甚至可以帮助使用**静态应用程序安全测试**（**SAST**）来查找和修复漏洞。
- en: Think of these tool-assisted reviews as a valuable addition to other review
    methods. They help maintain coding standards, identify vulnerabilities, collect
    data efficiently, and streamline the review process. However, some teams might
    be tempted to rely solely on these tools and skip involving team members in code
    reviews. It’s crucial to view these tools as enhancements to the process rather
    than replacements.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些工具辅助的审查视为对其他审查方法的宝贵补充。它们有助于维护编码标准、识别漏洞、高效收集数据，并简化审查过程。然而，一些团队可能会倾向于完全依赖这些工具，并跳过让团队成员参与代码审查。将这些工具视为过程的增强而不是替代品至关重要。
- en: Tool-assisted reviews can simplify data collection and metrics, and free up
    developers to focus on their work. There are some disadvantages, too, that rely
    on the developer’s need to manage and maintain the tools – some tools are often
    really expensive and do not completely remove the necessity of a human review.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 工具辅助的审查可以简化数据收集和指标，并让开发者能够专注于他们的工作。也有一些缺点，这依赖于开发者管理和维护工具的需求——一些工具往往非常昂贵，并不能完全消除人工审查的必要性。
- en: In-person (or remote) teamwork reviews
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 面对面（或远程）团队合作审查
- en: In these reviews, two developers work together, either in person or through
    a shared screen online. One developer is the author who made the code changes,
    and the other is the reviewer. The author explains the changes they made and why
    they chose those solutions. The reviewer asks questions and gives suggestions,
    kind of like how team members work together when pairing. The author can make
    small changes during the review and note bigger fixes for later.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些审查中，两位开发者一起工作，要么面对面，要么通过在线共享屏幕。一位开发者是编写代码变更的作者，另一位是审查者。作者解释他们所做的变更以及为什么选择那些解决方案。审查者提问并给出建议，有点像团队成员在结对时一起工作。作者可以在审查期间进行小的修改，并记录较大的修复以供以后处理。
- en: 'Advantages are pretty straightforward: in-person meetings (sometimes, they’re
    also called over-the-shoulder reviews) are easy to set up and complete, and of
    course, can be done remotely. They’re quicker than pair programming (which we’ll
    delve into in a minute).'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 优势相当直接：面对面会议（有时也称为肩并肩审查）很容易安排和完成，当然，也可以远程进行。它们比结对编程（我们稍后会深入探讨）更快。
- en: However, it can happen that the reviewer may not be as connected to the code;
    in this case, a lot of time would be needed to explain the background and all
    of the nitty-gritty of the code – or, even worse, the review would be done hastily,
    quicker than necessary. In this context, there could be some lack of objectivity;
    without knowing the context (basically, all the code under review just “rained”
    over the reviewer’s head), you can’t be sure that all the needed implementations
    were made. In general, it’s tricky to understand how well the code is doing.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，可能会发生的情况是，审查者可能并不那么熟悉代码；在这种情况下，需要大量的时间来解释背景和代码的所有细节——或者，更糟糕的是，审查可能会草率完成，比必要的更快。在这种情况下，可能会缺乏客观性；如果不了解背景（基本上，所有待审查的代码都“雨点般”地落在审查者头上），就无法确保所有必要的实现都已完成。总的来说，理解代码的表现情况很棘手。
- en: Now, we’re getting to what we think is the most effective review technique,
    even though it’s not entirely a review technique. Pair programming is a lot more
    than that.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们正在接近我们认为最有效的审查技术，尽管它并不完全是一种审查技术。结对编程远不止于此。
- en: Pair programming
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结对编程
- en: Perhaps it is simplistic to talk about pair programming as a mere code review
    technique, but this is just the starting point.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 将结对编程仅仅视为一种代码审查技术可能过于简单，但这只是起点。
- en: '**Pair programming** is a software development technique that requires each
    feature to be created by a pair of programmers, working on the same workstation
    (also, consider being able to do it remotely by sharing the screen). A person
    writes the code and is called the driver; the other, the navigator, makes a sort
    of instant revision of every line that is written at the time it is written. The
    driver focuses on the details of the implementation, while the navigator takes
    a broader view, reviews the code, and helps with problem-solving.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '**结对编程**是一种软件开发技术，要求每个功能都由一对程序员共同创建，他们在同一工作站上工作（同时，也可以考虑通过共享屏幕远程完成）。一个人编写代码，被称为驾驶员；另一个人，即导航员，在代码编写的同时对所写的每一行进行即时修订。驾驶员专注于实现细节，而导航员则从更广阔的角度审视代码，并帮助解决问题。'
- en: It is a very powerful technique that has many advantages and – inevitably –
    some disadvantages. Let’s get to know them.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种非常强大的技术，具有许多优点和——不可避免地——一些缺点。让我们来了解它们。
- en: Advantages
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 优势
- en: 'The quality of the software improves: programmers are led to bring their different
    experiences together, bringing different points of view and different approaches.
    Pair programmers work closely together throughout the development process, discussing
    design decisions, code structure, and potential improvements in real-time. Having
    two sets of eyes on the code can lead to cleaner code, fewer bugs, and more robust
    solutions. What’s best, the navigator can catch errors and suggest improvements
    as they arise. Two minds working together often lead to more creative and effective
    problem-solving. Programmers can bounce ideas off each other and explore different
    solutions. Since code is reviewed in real-time, it’s more likely that issues are
    spotted and corrected before they become major problems, reducing the debugging
    and maintenance effort.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 软件质量得到提升：程序员被引导将他们的不同经验结合起来，带来不同的观点和不同的方法。结对程序员在整个开发过程中紧密合作，实时讨论设计决策、代码结构和潜在改进。有两双眼睛审视代码可以导致代码更干净、错误更少、解决方案更稳健。最好的是，导航员可以在出现错误时捕捉到并提出改进建议。两个大脑一起工作通常会导致更具创造性和有效的问题解决。程序员可以互相激发想法，探索不同的解决方案。由于代码是实时审查的，因此更容易在问题成为大问题之前发现并纠正，从而减少调试和维护的工作量。
- en: Another immediate advantage is knowledge sharing. Pair programming helps distribute
    knowledge and expertise among team members (or even among members of different
    teams, who are working together to bring in their respective knowledge). It’s
    an effective way to transfer skills and best practices from more experienced developers
    to less experienced ones. Pair programming can be more powerful than any knowledge-sharing
    session.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个直接的优势是知识共享。结对编程有助于在团队成员之间（甚至在不同团队之间，他们共同工作以带来各自的知识）分配知识和专业技能。这是一种将技能和最佳实践从经验更丰富的开发者转移到经验较少的开发者的有效方式。结对编程可能比任何知识共享会议都更有力。
- en: Also, to be considered is a certain element of team building and improvement
    of communication in general within the team. By collaborating closely, you can
    hone all those soft skills needed in your daily work with other people and maybe
    even your feedback culture.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还需要考虑团队建设和团队内部沟通的整体提升。通过紧密合作，你可以磨练在日常工作与他人交流中所需的那些软技能，也许甚至包括你的反馈文化。
- en: Moreover, pair programming increases focus – it significantly boosts focus by
    minimizing distractions. The shared responsibility between the “driver” and “navigator”
    fosters a concentrated mindset, reducing the likelihood of drifting. This collaborative
    approach ensures constant code review and real-time communication, creating an
    environment where both individuals are actively engaged in problem-solving. In
    essence, pair programming not only deters distractions but actively cultivates
    a focused and productive development atmosphere. Something may change when pair
    programming is done from a remote location, but not that much.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，结对编程提高了专注力——它通过最小化干扰显著提高了专注力。在“驾驶员”和“导航员”之间的共同责任促进了专注的心态，减少了分心的可能性。这种协作方法确保了持续的代码审查和实时沟通，创造了一个两个人都积极参与问题解决的环境。本质上，结对编程不仅阻止了干扰，而且积极地培养了一个专注和高效的开发氛围。当远程进行结对编程时，可能会有所变化，但不会太多。
- en: One factor to consider is the level of seniority of the two programmers, both
    in general and on the individual task. For example, pairing two experienced developers
    could be the right choice to boost productivity. A pair made by two novice developers
    is unlikely to happen, even if it could bring some problems, given my lack of
    what we could call a “role model.” Anyway, it’s still better than two novice programmers
    working independently. The expert-novice pair is one of the most common; this
    kind of pairing can foster the introduction of fresh ideas as less experienced
    individuals are often more inclined to question established practices. Simultaneously,
    the experts, while being asked to clarify established methods, are encouraged
    to reevaluate them. Nonetheless, within this pairing dynamic, a novice who feels
    intimidated might become a passive observer, hesitating to actively engage. Similarly,
    certain experts may lack the patience necessary to facilitate productive participation
    from novices. Some refer to this phenomenon as “watch the master.”
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 需要考虑的一个因素是两位程序员的资历水平，无论是总体上还是针对具体任务。例如，将两位经验丰富的开发者配对可能是提高生产力的正确选择。由两位新手开发者组成的配对不太可能发生，尽管它可能会带来一些问题，鉴于我缺乏所谓的“榜样”。无论如何，这总比两位新手程序员独立工作要好。专家-新手配对是最常见的；这种配对可以促进新想法的引入，因为经验较少的个人通常更倾向于质疑既定做法。同时，专家在要求阐明既定方法的同时，也被鼓励重新评估它们。然而，在这种配对动态中，感到受威胁的新手可能会成为被动的观察者，犹豫不决地不愿积极参与。同样，某些专家可能缺乏促进新手有效参与所需的耐心。有些人将这种现象称为“观摩大师”。
- en: Disadvantages
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缺点
- en: The first disadvantage – perhaps the most obvious one, and the one that your
    tech-illiterate manager might argue with – is that with pair programming, you
    have two people doing the work of one. If this is not true (we have previously
    seen all the advantages and peculiarities of pair programming, in which the roles
    are distinct and several jobs are carried out at the same time) it is true that
    pair programming is resource-intensive as you have two programmers who take care
    of the same task. In a world where there are never enough developers to do all
    the work, this could be a problem to address.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个缺点——可能是最明显的一个，也是你的技术盲经理可能会争论的一个——就是结对编程意味着两个人做一个人的工作。如果这不是真的（我们之前已经看到了结对编程的所有优点和特殊性，其中角色是不同的，同时进行多项工作），那么结对编程确实是资源密集型的，因为有两个程序员负责同一项任务。在一个开发者永远不够用来做所有工作的世界里，这可能是一个需要解决的问题。
- en: It is also undeniable that the code will be ready in a longer time; if two people
    take care of the same task, it is obvious that the “busy” tasks will be fewer
    in absolute number. In the case of very tight deadlines, this could be a problem.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 不可否认的是，代码将需要更长的时间才能完成；如果两个人负责同一项任务，显然“忙碌”的任务在绝对数量上会更少。在非常紧张的截止日期的情况下，这可能会成为一个问题。
- en: It would be better, then, to balance the level of seniority of the two programmers
    involved so as not to create “watch the master” situations or excessive tutoring
    of a junior resource.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，平衡两位程序员的资历水平会更好，这样就不会造成“观摩大师”的情况或对初级资源的过度指导。
- en: In our opinion, pair programming needs to be properly modulated. Not all tasks
    are suitable for pair programming. Let’s imagine a repetitive task without too
    much-added value, something that is not complicated from any point of view – it
    is just very long. The added value that a possible driver can give would be very
    small; in that case, it would be much better, in our opinion, to opt for a classic
    “delayed” code review process.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们看来，结对编程需要适当调节。并非所有任务都适合结对编程。让我们想象一个没有太多附加价值、从任何角度看都不复杂的重复性任务——它只是非常耗时。可能驾驶员可以提供的附加价值非常小；在这种情况下，我们认为，选择经典的“延迟”代码审查过程会更好。
- en: 'Moreover, pair programming might not be for everybody: some people just don’t
    get along, or others prefer to work individually. In this case, it’s better not
    to force the hand on this practice, or start with short sessions (let’s say, an
    hour or so).'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，结对编程可能并不适合所有人：有些人合不来，或者有些人更喜欢独立工作。在这种情况下，最好不要强迫这种做法，或者从短会话开始（比如说，一个小时左右）。
- en: I have used pair programming a lot in my career, and I must point out that it
    has also happened that some colleagues did not feel suitable for pair programming,
    especially in contexts where the percentage of time for which this practice is
    carried out is greater than individual programming. Some people prefer to work
    alone, perhaps exploring freely, following only the logical thread of their thoughts
    and perhaps converging with teammates only later. The humble advice we would like
    to give in these cases is not to force the hand with pair programming or in any
    case to agree at a team level – as trivial as it may be, I think it is the only
    thing that can work in this case.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的职业生涯中，我大量使用了结对编程，并且必须指出，有时一些同事并不觉得适合结对编程，尤其是在这种实践的时间比例大于个人编程的背景下。有些人更喜欢独自工作，可能自由探索，只跟随他们思想的逻辑线索，也许稍后才会与队友会合。在这些情况下，我们愿意给出的谦卑建议是不要强迫使用结对编程，或者在任何情况下，在团队层面达成一致——尽管这可能微不足道，我认为这是在这种情况下唯一可行的方法。
- en: A very interesting paper about the costs and benefits of pair programming can
    be found in the *Further* *reading* section.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在*进一步阅读*部分可以找到一篇关于结对编程成本和收益的非常有趣的论文。
- en: Styles of pair programming
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结对编程的风格
- en: Pair programming is hard. You have to be extremely focused, especially – I would
    say – in the role of the navigator. Pair programming can be both exhausting and
    fulfilling. Typically, most programmers can only effectively pair for about 5
    to 6 hours a day. Therefore, it’s important to schedule breaks and regularly switch
    pairs. There are many ways in which you can manage your pair; in the following
    sections, we’ll see some of them.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 结对编程很难。你必须非常专注，尤其是——我可以说——在导航员的角色上。结对编程可能既累人又满足。通常，大多数程序员每天只能有效地结对大约5到6小时。因此，安排休息和定期更换搭档很重要。你可以用很多方法来管理你的结对；在接下来的章节中，我们将看到其中的一些。
- en: Driver and navigator
  id: totrans-237
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 驾驶员和导航员
- en: This is the classic pair programming style. The **driver** is the individual
    in control of the keyboard, concentrating on accomplishing the current small task
    while temporarily setting aside broader concerns. They are encouraged to vocalize
    their actions as they perform them. The **navigator**, who’s positioned as an
    observer while the driver operates the keyboard, actively assesses the code in
    real-time, provides guidance, and communicates their thoughts. The navigator maintains
    awareness of larger issues and potential bugs, taking note of prospective next
    actions or obstacles as they arise.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这是经典的结对编程风格。**驾驶员**是控制键盘的个人，专注于完成当前的小任务，同时暂时将更广泛的问题放在一边。他们被鼓励在执行时大声说出他们的行动。**导航员**，在驾驶员操作键盘时被视为观察者，实时评估代码，提供指导，并传达他们的想法。导航员保持对更大问题和潜在错误的意识，记录下出现的前瞻性下一步行动或障碍。
- en: 'A typical workflow typically follows these steps:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 典型的流程通常遵循以下步骤：
- en: Start with a well-defined, preferably small task.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从一个定义良好、最好是小的任务开始。
- en: Reach a consensus on a singular, manageable objective at a time. This can be
    defined by a unit test, for example.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一次中就达成一个单一、可管理的目标共识。例如，这可以由一个单元测试来定义。
- en: Regularly interchange roles and the keyboard. This shared, active participation
    maintains energy levels and enhances comprehension. What does “regularly” mean?
    We’ll see shortly.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定期交换角色和键盘。这种共享的积极参与保持了能量水平并增强了理解。什么是“定期”？我们很快就会看到。
- en: In the role of the navigator, refrain from getting lost in the immediate tactical
    details of coding since the driver focuses on those. Your responsibility is to
    step back and complement your partner’s tactical approach with medium-term thinking.
    Jot down upcoming tasks, potential roadblocks, and ideas on sticky notes. Discuss
    them after the completion of the current tiny goal to avoid disrupting the driver’s
    workflow.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在导航员的角色中，避免陷入编码的即时战术细节，因为驾驶员专注于这些。你的责任是退后一步，用中长期思考来补充你搭档的战术方法。在便利贴上记下即将到来的任务、潜在的障碍和想法。在完成当前的小目标后讨论它们，以避免打断驾驶员的工作流程。
- en: Ping-pong pairing
  id: totrans-244
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Ping-pong结对
- en: 'The **ping-pong pairing** technique is closely aligned with TDD and is particularly
    effective when you have a well-defined task that can be approached in a test-driven
    manner:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '**ping-pong结对**技术与TDD紧密相关，当你有一个可以以测试驱动方式处理的明确任务时尤其有效：'
- en: '“Ping”: Developer A initiates by creating a failing test.'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: “Ping”：开发者A通过创建一个失败的测试来启动。
- en: '“Pong”: Developer B responds by writing the code necessary to make the test
    pass.'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: “Pong”：开发者B通过编写使测试通过的必要代码来回应。
- en: Developer B then takes the lead by initiating the next “ping,” which involves
    creating the next failing test.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开发者B随后发起下一次“ping”，这涉及到创建下一个失败的测试。
- en: After each “pong,” it’s common practice to collaboratively refactor the code.
    This step aligns with the “Red – Green – Refactor” approach, which we encountered
    in the previous chapters.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在每次“pong”之后，通常的做法是共同重构代码。这一步骤与我们在前几章中遇到的“红-绿-重构”方法相一致。
- en: Strong-style pairing
  id: totrans-250
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 强风格结对
- en: '**Strong-style pairing** is a method that helps people learn by working closely
    together. It’s like a mentor teaching a newbie.'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '**强风格结对**是一种通过紧密合作来帮助人们学习的方法。它就像一个导师在教新手。'
- en: The main rule is, “Before you do something on the computer, talk to someone
    else about it.” In this method, the experienced person usually guides the less
    experienced one. The important thing is that the learner must trust the teacher
    and not worry if they don’t understand everything at first. Questions and discussions
    can happen after they try things out.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 主要规则是，“在你电脑上做任何事情之前，先和某人谈谈。”在这个方法中，经验丰富的人通常会指导经验不足的人。重要的是学习者必须信任老师，并且不必担心他们一开始是否理解一切。在尝试过之后，可以提问和讨论。
- en: This method is a bit like having someone watch over your shoulder, but it’s
    really good for teaching. It’s best for getting started with new things, but you
    shouldn’t use it too much. The goal is for the learner to become more independent
    over time. That’s when you know the teaching has worked.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法有点像有人在你的肩膀上监督你，但它对教学非常有用。它最适合开始新事物，但你不应过度使用它。目标是让学习者随着时间的推移变得更加独立。那时你就知道教学已经成功了。
- en: Time management
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 时间管理
- en: It’s important to manage your time in pair programming; deciding how long a
    person should remain a driver and how long they should be a navigator greatly
    changes the developer experience in pair programming. A very well-known technique
    – but I must say very little used – is the **Pomodoro technique**.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在结对编程中管理你的时间很重要；决定一个人应该作为驾驶员多久，以及他们应该作为领航员多久，这极大地改变了开发者在使用结对编程时的体验。一个非常著名的技术——但我必须说，使用得很少——是**番茄工作法**。
- en: This method can be integrated with most of the pairing approaches mentioned,
    helping maintain focus. Pair programming can be tiring, so having prompts for
    breaks and switching roles is beneficial.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法可以与大多数提到的结对方法相结合，有助于保持专注。结对编程可能会很累，所以有提示进行休息和角色切换是有益的。
- en: 'The Pomodoro technique is a time management method that was developed by Francesco
    Cirillo in the late 1980s. It’s designed to help people enhance productivity and
    maintain focus. For all the non-Italian speakers out there: “*Pomodoro*” means
    “*tomato*” and it refers to a simple Pomodoro-shaped kitchen timer.'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 番茄工作法是一种由弗朗西斯科·奇里洛在20世纪80年代末开发的时间管理方法。它旨在帮助人们提高生产力和保持专注。对于所有非意大利语使用者来说：“*番茄钟*”意味着“*番茄*”，它指的是一个简单的番茄形状的厨房计时器。
- en: 'Here’s how this technique works:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是这种技术的工作原理：
- en: '**Set a timer**: Choose a task you want to work on. Set a timer for 25 minutes,
    which is called one “Pomodoro.” During this time, you commit to working on the
    task with full concentration.'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**设定计时器**：选择一个你想要工作的任务。设定一个25分钟的计时器，这被称为一个“番茄钟”。在这段时间里，你承诺全神贯注地专注于这个任务。'
- en: '**Work intensely**: While the timer is running, work on your task with focused,
    undivided attention. Avoid distractions, such as checking your phone or email.
    I’m not saying that you should also ignore calls from your wife, but it’s strongly
    recommended; to use this book as an excuse.'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**集中精力工作**：当计时器运行时，专注于你的任务，不要分心，比如查看手机或电子邮件。我并不是说你也应该忽略来自你妻子的电话，但强烈建议；用这本书作为借口。'
- en: '**Take a short break**: When the timer rings after 25 minutes, take a short
    5-minute break. Use this time to relax, stretch, or do something unrelated to
    work. It’s a brief reward for your focused effort.'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**短暂休息**：当25分钟后计时器响起时，进行短暂的5分钟休息。利用这段时间放松、伸展或做一些与工作无关的事情。这是对你专注努力的短暂奖励。'
- en: '**Repeat**: After the short break, go back to another 25-minute Pomodoro session.
    Keep repeating these cycles of work and short breaks.'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**重复**：短暂的休息后，回到另一个25分钟的番茄钟会话。继续重复这些工作和短暂休息的周期。'
- en: '**Longer break**: After completing four Pomodoro sessions (totaling 2 hours
    of work), take a longer break of 15-30 minutes. Use this time to recharge and
    plan your next tasks.'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Pomodoro technique aims to leverage the benefits of focused, concentrated
    work while preventing burnout. It encourages you to break your work into smaller,
    manageable chunks with built-in breaks. This method can help improve time management,
    reduce procrastination, and boost overall productivity. It’s particularly useful
    for tasks that require deep concentration, not only programming; we think it should
    be taught at school.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: The Pomodoro technique can be used to manage pair programming sessions; whenever
    a Pomodoro ends, the driver and navigator switch roles. You decide if this technique
    is good or if it is too “rigid.” These and all the others are just suggestions
    – it’s up to you to find the right size and the right pace of work.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: Documentation
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we talk about documentation, we can talk about a lot of things. In general,
    the term *documentation* refers to the process of creating and maintaining written
    records and materials that describe various aspects of a software project. This
    documentation serves multiple purposes and is essential for the successful development,
    maintenance, and understanding of software systems.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: In simple terms, this means we can have different kinds of documentation in
    software development – some very technical, and others not so much.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: Requirements
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Requirements documentation** is where you define what the software should
    be like. It’s like the building plan for the software.'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: Requirements documentation in software development is like making a detailed
    wish list or set of instructions for what a new piece of software should do. It’s
    a way to precisely define and describe what the software needs to achieve and
    how it should behave. This documentation outlines the features, functions, and
    qualities the software should have to meet the needs of its users or the business.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: This documentation is crucial because it acts as a guide for the software developers.
    It helps them understand the expectations and goals set by the clients or stakeholders.
    Think of it as a blueprint that details the foundation and boundaries within which
    the software will be designed, built, and tested. Requirements documentation is
    like drawing a map that shows the path for building the right software that fulfills
    specific needs and functions as intended.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: Requirements documentation is a phase that comes after the collection and analysis
    phases. I refer you to the *Further reading* section for more in-depth information.
    Once gathered, it’s uncommon for requirements to be simply written in a lengthy
    and formal textual document. According to our experience, what happens more often
    is that spreadsheets or specialized tools are used. If spreadsheets are used,
    each requirement is typically represented by a row, and each attribute of the
    requirements, such as an ID, a description, a priority, a reporter, and so on,
    is represented by a column. The same information, and often much more, is managed
    through specific software for “issue tracking,” such as Jira or Redmine. Requirements
    documentation then becomes the collection of information – the issues – stored
    in these tools. It’s widely used, especially in Agile development frameworks.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 需求文档是在收集和分析阶段之后的阶段。我建议您参考*进一步阅读*部分以获取更深入的信息。一旦收集完毕，需求通常不会简单地写成一份冗长正式的文本文档。根据我们的经验，更常见的情况是使用电子表格或专用工具。如果使用电子表格，每个需求通常由一行表示，而需求的每个属性，如ID、描述、优先级、报告人等，则由一列表示。相同的信息，以及更多内容，通过“问题跟踪”软件（如Jira或Redmine）进行管理。需求文档随后成为存储在这些工具中的信息集合——问题。它在敏捷开发框架中广泛使用。
- en: Architecture documentation
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 架构文档
- en: '**Architecture documentation**, also known as **software architecture description**,
    is a unique form of design document. If design documents derive directly from
    the code, architecture documents are a step forward (someone says they’re the
    third derivative, starting from the first one, which is the code). These documents
    contain very little information that is specific to the code itself; the nitty-gritty
    of the implementation must be kept away. They don’t explain how to code a particular
    function or why a specific function is designed the way it is. Instead, they outline
    the general requirements and reasons that lead to the creation of such functions.
    A well-crafted architecture document is concise in details but rich in explanations
    – also rich in images and graphs, I would say. It might offer suggestions for
    lower-level design but delegates the actual exploration and trade studies to other
    documents.'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '**架构文档**，也称为**软件架构描述**，是一种独特的设计文档形式。如果设计文档直接来自代码，那么架构文档就是向前迈出的一步（有人说它是从第一个，也就是代码开始的第三阶导数）。这些文档包含的信息很少是针对代码本身的；实现细节必须保持分离。它们不解释如何编写特定的函数或为什么特定的函数被设计成这样。相反，它们概述了导致创建此类函数的一般需求和原因。一份精心制作的架构文档在细节上简洁但解释丰富——我还会说，它还包含丰富的图像和图表。它可能会提供对较低级别设计的建议，但将实际探索和权衡研究委托给其他文档。'
- en: 'Architectural documentation is probably the first thing that a new member of
    your team would read. That’s one of the reasons why we’re saying it’s crucial:
    software architecture documentation helps different people involved in a project
    to have a common understanding of how the system works.'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 架构文档可能是你的团队新成员首先阅读的内容。这就是我们说它至关重要的原因之一：软件架构文档帮助项目中的不同人员对系统的工作方式有一个共同的理解。
- en: 'One way to document your architecture is the typical one: just draw a bunch
    of boxes on a whiteboard and connect them with arrows and lines! Or... there’s
    a more structured approach called **C4**.'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 记录你的架构的一种方式是典型的做法：在白板上画一堆盒子，并用箭头和线条将它们连接起来！或者...还有一种更结构化的方法，称为**C4**。
- en: 'The C4 approach, also known as the **C4 model**, is a framework for visualizing
    and documenting software architecture. It was created by Simon Brown and is designed
    to provide a clear and concise way to represent and communicate the architecture
    of a software system. **C4** stands for **Context**, **Containers**, **Components**,
    and **Code**, which are the four levels of abstraction in this model:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: C4方法，也称为**C4模型**，是一种用于可视化和记录软件架构的框架。它由Simon Brown创建，旨在提供一种清晰简洁的方式来表示和传达软件系统的架构。**C4**代表**上下文**、**容器**、**组件**和**代码**，这是该模型中的四个抽象级别：
- en: '**Context diagram** (**C1**): This is the highest level and provides an overview
    of the entire system, showing its interactions with external entities and systems.
    It helps establish the system’s boundaries and its place in the broader ecosystem.'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**上下文图**（**C1**）：这是最高级别，提供了整个系统的概览，显示了它与外部实体和系统的交互。它有助于确定系统的边界及其在更广泛生态系统中的位置。'
- en: '**Container diagram** (**C2**): The next level, the container diagram, focuses
    on the high-level building blocks within the system. It represents containers,
    such as web servers, databases, mobile apps, and more, and shows how they interact
    with each other.'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**容器图**（**C2**）：下一级别，容器图关注系统中的高级构建块。它表示容器，如Web服务器、数据库、移动应用等，并显示它们之间的交互。'
- en: '**Component diagram** (**C3**): Below containers, the component diagram delves
    into the internal structure of each container, breaking them down into individual
    components or services. This level provides more detail about how each container
    works internally.'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**组件图**（**C3**）：在容器之下，组件图深入到每个容器的内部结构，将它们分解为单个组件或服务。这一级别提供了更多关于每个容器内部工作方式的细节。'
- en: '**Code** (**C4**): At the lowest level, you have the actual source code, where
    the details of the individual components are documented. This level includes class
    diagrams, code snippets, and other fine-grained details.'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**代码**（**C4**）：在最低级别，你有实际的源代码，其中记录了各个组件的详细信息。这一级别包括类图、代码片段和其他细粒度细节。'
- en: The C4 approach is a way to create a hierarchy of visual representations to
    describe and understand a software system’s architecture. It helps in simplifying
    complex systems, making it easier to communicate and collaborate on software design
    and development.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: C4方法是一种创建视觉表示层次结构以描述和理解软件系统架构的方式。它有助于简化复杂系统，使得软件设计和开发中的沟通和协作更加容易。
- en: Diving deeper into this approach would be a bit outside the scope of this book,
    so I suggest that you visit the official C4 website. A link has been provided
    in the *Further* *reading* section.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 深入探讨这种方法会超出本书的范围，所以我建议您访问官方C4网站。在*进一步阅读*部分提供了一个链接。
- en: Technical documentation
  id: totrans-285
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 技术文档
- en: '**Technical documentation** covers a lot of stuff, and it even includes architectural
    documentation. But in this case, I wanted to point out a specific kind of documentation.
    It’s the one that gets into the nitty-gritty details, such as code, modules, APIs,
    microservices, and other low-level stuff. It’s way more detailed than what you’d
    usually find in architectural documentation.'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '**技术文档**涵盖了大量的内容，甚至包括架构文档。但在这个案例中，我想指出一种特定的文档。它涉及到细节，比如代码、模块、API、微服务和其他低级内容。它比你在架构文档中通常找到的更详细。'
- en: Documentation can come in various shapes and sizes, ranging from elaborate design
    documents to straightforward README files. The choice of format depends on the
    specific product, system, or service being described. Regardless of the form it
    takes, the primary goal of technical documentation is to assist developers in
    resolving issues without requiring them to undertake additional research.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 文档可以有多种形状和大小，从复杂的设计文档到简单的README文件。格式选择取决于所描述的具体产品、系统或服务。无论形式如何，技术文档的主要目标是帮助开发者解决问题，而无需他们进行额外的研究。
- en: Even if is often disregarded, technical documentation is crucial; unfortunately,
    it’s also very hard to do and very time-consuming. It’s the very first thing that
    is ignored when your time runs out. “We’ll do it” and you never will. So, our
    suggestion here is to include the writing of the documentation in your daily work;
    in other words, in your software development life cycle. For example, you could
    agree on a “definition of done” (a checklist or set of criteria that determines
    when a task or project is considered completed and meets the required quality
    standards) that includes documentation.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 即使它经常被忽视，技术文档至关重要；不幸的是，它也非常难以完成且耗时。当时间紧迫时，它往往是首先被忽视的东西。“我们会做的”而你永远不会去做。因此，我们的建议是将文档的编写纳入你的日常工作；换句话说，在你的软件开发生命周期中。例如，你可以同意一个“完成定义”（一个清单或一系列标准，用于确定任务或项目何时被认为完成并达到所需的质量标准），其中包括文档。
- en: There are various types of documentation you should take care of.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该注意各种类型的文档。
- en: '**SDK documentation**: SDK documentation provides instructions for integrating
    new software into an existing application. It covers software usage, capabilities,
    and interactions with other applications, making it essential for developers to
    enhance app features.'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SDK文档**：SDK文档提供了将新软件集成到现有应用程序中的说明。它涵盖了软件的使用、功能以及与其他应用程序的交互，对于开发者增强应用功能来说是必不可少的。'
- en: '**Source code documentation**: Source code documentation includes code examples
    to guide developers in software usage. Focus on explaining necessary parts rather
    than everything in the code.'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**源代码文档**：源代码文档包括代码示例，以指导开发人员使用软件。重点在于解释必要的部分，而不是代码中的所有内容。'
- en: '**Release notes**: Release notes are technical documents detailing changes
    in a new product release, such as new features, bug fixes, and known issues. Developers
    and testers use them to grasp what’s new.'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**发布说明**：发布说明是技术文档，详细说明了新产品发布中的更改，如新功能、错误修复和已知问题。开发人员和测试人员使用它们来了解新内容。'
- en: '**Knowledge base documentation**: This document houses knowledge that developers
    can use for software development and maintenance. It covers tools, languages,
    methods, design principles, how-to guides, troubleshooting, and FAQs, fostering
    knowledge sharing and efficiency in software development.'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**知识库文档**：此文档包含开发人员可用于软件开发和维护的知识。它涵盖了工具、语言、方法、设计原则、如何指南、故障排除和常见问题解答，促进了软件开发中的知识共享和效率。'
- en: '**API documentation**: API documentation explains how a program’s interface
    functions, offering details about methods, parameters, and what the API returns.
    It may come as tutorials or guides, aiding developers in understanding and using
    the API.'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**API文档**：API文档解释了程序接口的功能，提供了关于方法、参数以及API返回内容的详细信息。它可能以教程或指南的形式出现，帮助开发人员理解和使用API。'
- en: There are a couple of tools we want to suggest that can improve your API documentation
    and automate it – partially, at least.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想推荐一些工具，可以帮助您改进API文档并自动化它——至少部分如此。
- en: Swagger
  id: totrans-296
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Swagger
- en: The first one is really widespread, and it’s called **Swagger**. Swagger is
    an open source framework and a suite of tools that enables you to design, build,
    and document RESTful web services. It provides a way to describe and document
    the functionality of an API in a standardized and machine-readable format, often
    in JSON or YAML.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个非常普遍，被称为**Swagger**。Swagger是一个开源框架和一系列工具，使您能够设计、构建和记录RESTful Web服务。它提供了一种以标准化和机器可读的格式描述和记录API功能的方法，通常使用JSON或YAML。
- en: 'Swagger offers several key benefits, apart from the documentation itself: it
    can also generate client and server code in various programming languages, reducing
    the effort needed to integrate with the API. A very useful feature is that it
    includes tools for testing and debugging APIs, making it easier to identify and
    resolve issues. Last but not least, Swagger uses the **OpenAPI Specification**
    (formerly known as the **Swagger Specification**), a widely adopted standard for
    describing RESTful APIs. This promotes consistency and interoperability among
    different systems and developers.'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: Swagger提供了几个关键的好处，除了文档本身之外：它还可以在多种编程语言中生成客户端和服务器代码，从而减少与API集成的努力。一个非常实用的功能是它包括用于测试和调试API的工具，这使得识别和解决问题更加容易。最后但同样重要的是，Swagger使用**OpenAPI规范**（以前称为**Swagger规范**），这是一个广泛采用的标准，用于描述RESTful
    API。这促进了不同系统和开发者之间的一致性和互操作性。
- en: 'How can you integrate Swagger into your application? It’s a piece of cake,
    especially if you’re using Spring Boot. Supposing you’re using Maven, it’s enough
    to add a couple of dependencies in your POM file. If you’re using also **Spring
    Boot 3**, it’s only one:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 您如何将Swagger集成到您的应用程序中？这很简单，尤其是如果您正在使用Spring Boot。假设您正在使用Maven，您只需在POM文件中添加几个依赖项。如果您也在使用**Spring
    Boot 3**，那么只需要一个：
- en: '[PRE13]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In other cases, you will have to add some other dependencies and a couple of
    configurations. Nothing difficult and nothing long. You’ll find an excellent tutorial
    in the *Further* *reading* section.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他情况下，您可能需要添加一些其他依赖项和一些配置。没有什么困难的，也没有什么长的。您将在“**进一步阅读**”部分找到一个出色的教程。
- en: 'And then? Nothing – that’s it! Now, let’s suppose we have a “classic” REST
    controller written in Java, something like this:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 然后？什么都没有——就这样！现在，假设我们有一个用Java编写的“经典”REST控制器，类似于这样：
- en: '[PRE14]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'As you can assume from the `@RestController` annotation, this class exposes
    its public methods as public APIs. The first one returns a list of employees and
    takes no input parameters (it doesn’t handle HTTP statutes, nor pagination...
    it’s just an example!); the second one is needed to insert a new employee and
    it has a body defined by the `Employee` class. Swagger can understand all of this
    and automatically generate an OpenAPI-compliant documentation. The following screenshot
    is just a part of the huge JSON that is generated by Swagger to adhere to the
    OpenAPI standard:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.11 – Huge JSON generated by Swagger](img/B20912_08_11.jpg)'
  id: totrans-305
  prefs: []
  type: TYPE_IMG
- en: Figure 8.11 – Huge JSON generated by Swagger
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: 'This JSON has been left intentionally incomplete since it is... well, incomprehensible
    for the human brain. Luckily enough, Swagger kicks in with a UI that interprets
    all this madness and gives us a beautiful web page. Something like this:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.12 – Two very basic endpoints exposed by swagger-ui](img/B20912_08_12.jpg)'
  id: totrans-308
  prefs: []
  type: TYPE_IMG
- en: Figure 8.12 – Two very basic endpoints exposed by swagger-ui
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the very basic version of it. By clicking on the single endpoint (that
    is, one of those writings in colorful boxes, such as **/employees**), you’ll get
    its details, and you can also try it out:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.13 – By clicking on a single method, some more details will be displayed](img/B20912_08_13.jpg)'
  id: totrans-311
  prefs: []
  type: TYPE_IMG
- en: Figure 8.13 – By clicking on a single method, some more details will be displayed
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: 'With Swagger annotations, you can detail your API documentation as much as
    you like. In the `POST` method that creates a new employee, you can see a parameter
    of the `CreateEmployee` type that represents the body for the `POST` call. The
    fields of that class could be annotated like this:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Swagger would generate the following output:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.14 – Details of the request body rendered by swagger-ui](img/B20912_08_14.jpg)'
  id: totrans-316
  prefs: []
  type: TYPE_IMG
- en: Figure 8.14 – Details of the request body rendered by swagger-ui
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: A tool like Swagger, with its UI, guarantees massive value with minimum effort.
    Keeping your documentation up-to-date should be also simpler because everything
    – the code and its documentation – is in one place.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: Spring REST Docs
  id: totrans-319
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The second tool I would suggest to document your (`REST`) APIs is called **Spring
    REST Docs**. Spring REST Docs is a part of the Spring Framework, a popular framework
    for building Java-based enterprise applications. Specifically, Spring REST Docs
    is an extension for documenting RESTful APIs developed using Spring. It helps
    developers create accurate and consistent documentation for their RESTful web
    services by leveraging tests written in Spring Framework.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how Spring REST Docs typically works:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: Developers write tests for their REST API endpoints using the Spring Framework’s
    testing tools. These tests can include HTTP requests and responses.
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Spring REST Docs processes these tests and generates documentation based on
    the test results. It can generate documentation in various formats, such as AsciiDoc,
    Markdown, or HTML. This is a very cool thing: documentation is kept up-to-date
    in case of changes in the code.'
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The generated documentation can be included in the API documentation, making
    it easier for other developers or consumers to understand how to use the API effectively.
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Spring REST Docs is especially useful in projects where maintaining accurate
    and up-to-date API documentation is crucial. By using actual tests to generate
    the documentation, it ensures that the documentation accurately reflects the behavior
    of the API. This approach promotes consistency between the code and its documentation
    and helps developers and consumers better understand how to interact with the
    API.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: Good practices for documentation
  id: totrans-326
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Writing and maintaining documentation is fundamental yet hard. Doing it the
    right way is not very common – not at all! – and will take your team to the next
    level. Here’s some advice based on our experience and also on our mistakes.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: Incorporate documentation into the development flow
  id: totrans-328
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One common reason software teams skip documentation is that they’re always waiting
    for that perfect moment when they have loads of free time. But let’s face it –
    in the fast-paced world of software, that moment rarely arrives with all the new
    projects and initiatives on the horizon.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: 'So, here’s the hack: make documentation a natural part of your design process.
    Think of it as a crucial step that’s part of the whole deal, not some extra task
    you squeeze in later. Sure, it might add a bit more time, but that extra effort
    will pay off when you need to handle or expand your system down the road. Plus,
    your team will be all set to tackle those unexpected curveballs like pros.'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: Write comprehensive documentation
  id: totrans-331
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Comprehensive documentation for your software architecture is an absolute must
    for ensuring the seamless maintenance and expansion of your systems. This documentation
    functions as a valuable resource, particularly when crucial members of your engineering
    team move on, safeguarding essential knowledge from being lost. Moreover, it streamlines
    the process of conveying vital information about the system to a diverse range
    of stakeholders.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: While there may be those who argue that code alone suffices as documentation
    (I would agree with that, actually, but only if you add the adjective “good” to
    the word “code”), it is vital to acknowledge that comprehensive documentation
    offers invaluable context for decision-making and is accessible to both technical
    and non-technical stakeholders.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: Up-to-date documentation
  id: totrans-334
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Maintaining up-to-date documentation is essential as outdated documentation
    can lead to the same issues as having no documentation at all. Documentation that
    accurately reflects the current state of the system is crucial to ensure informed
    decision-making and to prevent critical errors caused by referencing outdated
    information during updates or changes.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: Tailored documentation for specific audiences
  id: totrans-336
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Customizing software architecture documentation to cater to specific audiences
    is essential. Not all stakeholders have the same information requirements, and
    attempting to fit all the details into a single document can hinder the ease of
    finding information. It might even discourage individuals from using the documentation
    altogether.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: To ensure the effectiveness of documentation, it’s crucial to provide the appropriate
    level of context for the intended audience. For instance, business executives
    may not require in-depth technical and code details, whereas engineers may find
    it challenging to fulfill their responsibilities without access to such technical
    specifics.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: We can give you all the advice in the world, and guide you toward all the best
    practices possible, but unfortunately, we must acknowledge that these good habits
    are sometimes unwelcome to non-technical individuals. In the next section, we’ll
    have a chat about it.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: A hard dose of reality
  id: totrans-340
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The aspects we’ve talked about, as well as many others, will help you add activities
    to your daily work that will make your code, your project, and your work better.
    By including all of this in your development cycle, maybe right from the beginning
    of a project, it will undoubtedly be easier to be diligent in this regard.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: However, we must tell you something undeniable – sometimes, some of these practices
    can cause disagreements between tech-savvy and non-tech-savvy people. What we’ve
    noticed is that there’s often a very different view of how work is organized,
    especially in terms of tasks. Of course, even the concept of code quality may
    not matter at all to certain managers or partners who are not used to writing
    code. But let’s go step by step.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, pair programming can be seen by management as resource-intensive
    because it requires two developers to work on the same task, potentially increasing
    labor costs. It could also be because the target is arguably more long-term. However,
    management often prioritizes short-term project goals, such as meeting deadlines
    and immediate deliverables, which may not align with the collaborative nature
    of pair programming. The benefits of pair programming, such as improved code quality
    and reduced defects, often manifest in the long term. However, these benefits
    may not be immediately visible to management, which can lead to skepticism. In
    general, there could also be a simple lack of familiarity: some managers may not
    be familiar with the practice and may be hesitant to introduce a process they
    don’t fully understand. Also, introducing pair programming may disrupt established
    workflows within the organization, leading to resistance from management.'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: Documentation also suffers some of these perceived fears. Why stop documenting
    something that is already working? Why not go ahead and do another task instead?
    Some managers may not fully understand the importance of documentation in terms
    of reducing errors, enhancing collaboration, and easing onboarding of new team
    members. This lack of understanding can lead to underestimating its value. Also,
    some managers may perceive the time spent on documentation as time that could
    be used for more coding or direct project work, potentially leading to underutilization
    of developer resources.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: Between the two, I have to say that pair programming is the practice that meets
    more resistance, at least from my point of view. All the practices that we’ve
    covered in this chapter are important, but getting along is also crucial! Try
    to introduce all of these practices or at least some pieces of them; try to adapt,
    try to prioritize. To address concerns, developers, and management can engage
    in open communication to explain the long-term advantages of pair programming,
    documentation, and so on, how they can improve code quality and project quality,
    reduce defects, and enhance knowledge sharing. They can also discuss how it can
    lead to faster problem-solving and overall efficiency in the development process.
    Management can work to strike a balance between immediate project needs and the
    long-term benefits of such practices.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: The importance of knowing what you’re doing
  id: totrans-346
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this more informal part of this chapter, we want to offer one last piece
    of advice about the things you do every day. It’s not just a technical tip; it’s
    more like advice from a friend, something I wish someone had told me when I started
    my career.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: When you work on a project, a task, or anything else, always keep in mind why
    you chose to do it. Ask yourself, “Why am I doing this?” It’s not just about staying
    motivated; there’s more to it than that.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: First of all, this will help you avoid feeling like a random monkey hitting
    keys on a keyboard. It will also help you understand how your work contributes
    to the development of a project or a company. Having clear goals for your work,
    whether they’re short-term, medium-term, or long-term, will keep you focused on
    your task without getting distracted by other things. If your work has a specific
    purpose, and even better, if that purpose is something you believe in, your productivity
    will increase, and your work will be better.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: Knowing why you’re doing something, and understanding the purpose behind it,
    will lead to better decision-making. When faced with doubts or uncertainties,
    having a clear goal in mind will guide your choices and prevent future disappointments.
    When we have detailed plans for specific actions at both upcoming milestones and
    our ultimate goals, every decision appears to align seamlessly.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: One of the decisions you’ll have to make includes prioritizing your tasks within
    a project. Should you do one thing before the other? Which task will take more
    time compared to the value it will generate? Well, if you know what you’re doing
    – in other words, if you have a clear goal – this will likely assist your decision-making
    and set a smoother path toward project completion.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: If you know your goal, you can probably also understand how far you are from
    reaching it. In other words, knowing your “why” helps you measure your progress.
    Imagine a team or a developer who is simply told to do something, completely disconnected
    from the context, something like “Write a method that returns this output given
    this input” – I don’t think this happens much after school, but let’s say it does.
    This person wouldn’t have the slightest idea of how their work is contributing
    and where they stand on the journey toward the final goal. This person would do
    a worse job.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: In a book on refactoring, it’s important to mention that understanding the “why”
    behind things helps in writing better code and, when necessary, refactoring it
    more effectively. Writing down the reasons for doing something, perhaps in a comment
    alongside complex code, can assist developers in rewriting it more efficiently.
    This, along with good test coverage and everything we’ve already discussed in
    the previous chapters, greatly aids both the comprehension of the current code
    and any potential rewriting efforts.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: Ask questions, and keep asking yourself and others. If you’re in a position
    where a manager or a partner is guiding you on task prioritization – for instance,
    if you work within a framework that involves a product owner – always ask why
    one thing is chosen over another. What benefits will it bring? How much will it
    cost, and how much will it earn for the company? Is there data to support this
    decision? I’m not saying to start a war, absolutely not, but always try to “challenge”
    your colleagues in this sense.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-355
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we tried to provide you with some advice on introducing small
    but significant changes that will greatly benefit your work. We explored how you
    can version your code and offered some branching models that the community has
    found effective over the years. Versioning your code is important, but let’s version
    beautiful code! We discussed how code reviews can be helpful and how to incorporate
    them into your everyday work. We dedicated an entire section to a particular form
    of code review, which is pair programming. We also delved into documentation,
    distinguishing between various types and providing guidance, especially for technical
    documentation of REST APIs. Lastly, we addressed the real-world implementation
    of these practices, which can sometimes face resistance, particularly in medium
    to small-sized companies.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll take a step back and discuss how these various elements
    communicate with each other. We’ll talk about best practices, identify issues
    (bad smells), and provide some advice on refactoring your architectures.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  id: totrans-358
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Extreme Programming Explained: Embrace Change*, by Kent Beck, Addison-Weasley'
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'On pair programming: [https://martinfowler.com/articles/on-pair-programming.html](https://martinfowler.com/articles/on-pair-programming.html)'
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Llewellyn’s strong-style pairing: [https://llewellynfalco.blogspot.com/2014/06/llewellyns-strong-style-pairing.html](https://llewellynfalco.blogspot.com/2014/06/llewellyns-strong-style-pairing.html)'
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Costs and benefits of pair programming*, by A. Cockburn and L. Williams: [https://collaboration.csc.ncsu.edu/laurie/Papers/XPSardinia.PDF](https://collaboration.csc.ncsu.edu/laurie/Papers/XPSardinia.PDF)'
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A great tool for remote teams who want to use Pomodoro: [https://cuckoo.team/](https://cuckoo.team/)'
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Pull Request*, an article by Martin Fowler: [https://martinfowler.com/bliki/PullRequest.html](https://martinfowler.com/bliki/PullRequest.html)'
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'GitFlow original post: [https://nvie.com/posts/a-successful-git-branching-model/](https://nvie.com/posts/a-successful-git-branching-model/)'
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'How to write a good commit message: [https://www.freecodecamp.org/news/how-to-write-better-git-commit-messages/](https://www.freecodecamp.org/news/how-to-write-better-git-commit-messages/)'
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Google Java style guide: [https://google.github.io/styleguide/javaguide.html](https://google.github.io/styleguide/javaguide.html)'
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Oracle Java conventions: [https://www.oracle.com/technetwork/java/codeconventions-150003.pdf](https://www.oracle.com/technetwork/java/codeconventions-150003.pdf)'
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: About comments and formatting, *Chapters 4* and *5* of Robert C. Martin, *Clean*
    *Code*, Pearson
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Introduction to the Apache Maven Checkstyle Plugin: [https://www.baeldung.com/checkstyle-java](https://www.baeldung.com/checkstyle-java)'
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'About collecting, documenting, and managing software requirements: [*Chapter
    2*](B20912_02.xhtml#_idTextAnchor042) of Giuseppe Bonocore’s *Hands-on software
    architecture in* *Java*, Packt'
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The C4 model for visualizing software architecture ([https://c4model.com/](https://c4model.com/))
    and Giuseppe Bonocore’s *Hands-on software architecture in Java*, [*Chapter* *1*](B20912_01.xhtml#_idTextAnchor014),
    Packt
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Tutorial for setting up Swagger by Baeldung: [https://www.baeldung.com/swagger-2-documentation-for-spring-rest-api](https://www.baeldung.com/swagger-2-documentation-for-spring-rest-api)'
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Spring REST docs: [https://docs.spring.io/spring-restdocs/docs/current/reference/htmlsingle/](https://docs.spring.io/spring-restdocs/docs/current/reference/htmlsingle/)'
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
