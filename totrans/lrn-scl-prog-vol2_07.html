<html><head></head><body>
        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">More on Functions</h1>
                
            
            <article>
                
<div class="packt_quote">"The problems are solved, not by giving new information, but by arranging what we have known since long."</div>
<div class="packt_quote1">– Ludwig Wittgenstein</div>
<p class="calibre2">One of the reasons we choose to write a function is because it can make our code more readable and look more concise. It's also better, when providing a solution, to break our problem statements down into components/actions and form corresponding functions for them. In this manner, it's going to be easier to solve problems with any programming language that provides function constructs (almost all languages provide such constructs because they are important). Scala provides a variety of ways in which we can write functions to achieve things. Our intention in this chapter is to learn <em class="calibre18">how.</em> If you remember correctly, we touched upon functions in Scala in <a href="part0092.html#2NNJO0-921a8f8dca2a47ea817d3e6755fa0e84" class="calibre10">Chapter 4</a>, <em class="calibre18">Giving Meaning to Programs with Functions</em>. We discussed how we can declare functions and call them using different sets of parameters. We've already learned about function evaluation strategies and the important concepts of function literals and partial functions, and these concepts will help us better understand what we're going to learn in this chapter. Let's take a look. We'll continue with function literals then discuss the following:</p>
<ul class="calibre7">
<li class="calibre8">Methods</li>
<li class="calibre8">Functions versus methods</li>
<li class="calibre8">Closures</li>
<li class="calibre8">Higher-order functions</li>
<li class="calibre8">Partially applied functions</li>
<li class="calibre8">Currying</li>
</ul>
<p class="calibre2">Higher-order functions take you to a new universe where it's fun to use functions, return functions, and find other ways we can use those functions. We'll end up our discussion in this chapter with higher-order functions. For now, let's continue our understanding of function literals.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Function literals</h1>
                
            
            <article>
                
<p class="calibre2">A function literal, in simple terms, is a representation of an action that can be performed to specify the input and output parameter types:</p>
<pre class="calibre19">(value1: Int, value2: Int) =&gt; Int </pre>
<p class="calibre2">This line represents a function literal, which is easily readable. It displays a function that takes two values, <kbd class="calibre11">value1</kbd> and <kbd class="calibre11">value2</kbd> of type <kbd class="calibre11">Int</kbd>, and returns another, <kbd class="calibre11">Int</kbd><em class="calibre18">.</em> We've seen some examples of it, such as our <kbd class="calibre11">ColorPrinter</kbd> example where we were simply able to print color as well as simple black and white pages using just one function named <kbd class="calibre11">printPages</kbd>:</p>
<pre class="calibre19">def printPages(doc: Document, lastIndex: Int, print: (Int) =&gt; Unit) = if(lastIndex &lt;= doc.numOfPages) for(i &lt;- 1 to lastIndex) print(i) 
 
val colorPrint = (index: Int) =&gt; println(s"Printing Color Page $index.") 
                                        
val simplePrint = (index: Int) =&gt; println(s"Printing Simple Page $index.") 
 
println("---------Method V1-----------") 
printPages(Document(15, "DOCX"), 5, colorPrint) 
 
println("---------Method V2-----------") 
printPages(Document(15, "DOCX"), 2, simplePrint) </pre>
<p class="calibre2">Our <kbd class="calibre11">colorPrint</kbd> and <kbd class="calibre11">simplePrint</kbd> values are examples of function literals of the following type:</p>
<pre class="calibre19">(index: Int) =&gt; Unit</pre>
<p class="calibre2">The <kbd class="calibre11">Unit</kbd> <span>type</span> here represents the absence of a return type. In other words, don't expect any output from the function literal. We discussed this concept in <a href="part0092.html#2NNJO0-921a8f8dca2a47ea817d3e6755fa0e84" class="calibre10">Chapter 4</a>, <em class="calibre18">Giving Meaning to Programs with Functions</em>, where we answered the <em class="calibre18">what</em> and <em class="calibre18">how</em> of func<span>tion literals. So now, let's answer the</span> <em class="calibre18">why</em><span>, and by</span> <em class="calibre18">why</em> <span>we mean the problem it solves. We'll take the preceding example of it. Take a closer look and you'll see that we abstracted the problem statement. If we had declared specific functions for simple and color pages, they would have spoken for themselves, such as in the following example.</span></p>
<p class="calibre2">Here's a <kbd class="calibre11">printColorPages</kbd> <span>function,</span> which takes a <kbd class="calibre11">Document</kbd>, <kbd class="calibre11">lastIndex</kbd> page number, <kbd class="calibre11">startIndex</kbd> page number, and then prints color pages. The same goes for <kbd class="calibre11">printSimplePages</kbd>:</p>
<pre class="calibre19">def printColorPages(doc: Document, lastIndex: Int, startIndex: Int) = if(lastIndex &lt;= doc.numOfPages) for(i &lt;- startIndex to lastIndex) colorPrint(i) 
 
def printSimplePages(doc: Document, lastIndex: Int, startIndex: Int) = if(lastIndex &lt;= doc.numOfPages) for(i &lt;- startIndex to lastIndex) simplePrint(i) </pre>
<p class="calibre2">There are code smells here and they are as follows:</p>
<ul class="calibre7">
<li class="calibre8">In both of these functions only the implementation part varies, that is, <kbd class="calibre11">colorPrint</kbd> and <kbd class="calibre11">simplePrint</kbd></li>
<li class="calibre8">In both of the implementations, input and output parameters do not vary</li>
<li class="calibre8">Let's take both implementations out and pass them as parameters. It's going to be a function literal of the same form as the function:</li>
</ul>
<pre class="calibre36">(index: Int) =&gt; Unit </pre>
<p class="calibre2">By answering these kinds of questions we get to our end function. It looks as follows:</p>
<pre class="calibre19">def printPages(doc: Document, lastIndex: Int, print: (Int) =&gt; Unit) = if(lastIndex &lt;= doc.numOfPages) for(i &lt;- 1 to lastIndex) print(i) </pre>
<p class="calibre2">I hope it's now clear how we go through this kind of refactoring. The best thing about it is that it will all come easily to you once you write the code yourself. One more thing we would like to know about the representation is that when you specify these literals and assign them to a value, you should know how they differ. The following representation is going to help you do that. Let's take a look at the following figure:</p>
<div class="cdpaligncenter"><img src="../images/00031.jpeg" class="calibre39"/></div>
<div class="cdpaligncenter1">Function values and function literals</div>
<p class="calibre2">In the preceding figure, we can see two forms. The one on the left is called a function value and the one on the right is a function literal. Function values are runtime objects. The question arises, <em class="calibre18">runtime objects of which type</em>? The answer is a <kbd class="calibre11">Function1</kbd> type, which is a trait in Scala and declared in the following form:</p>
<pre class="calibre19">trait Function1[-T1, +R] extends AnyRef </pre>
<p class="calibre2">In brackets, [], we have specified the type parameters; we'll learn about these in <a href="part0194.html#5P0D40-921a8f8dca2a47ea817d3e6755fa0e84" class="calibre10">Chapter 10</a>, <em class="calibre18">Advanced Functional Programming.</em> For now, just understand that these two specify that our implementation of <kbd class="calibre11">Function1</kbd> is going to take an input parameter of the first type <kbd class="calibre11">T1</kbd> and the output will be of type <kbd class="calibre11">R</kbd><em class="calibre18">.</em> Basically, our literal representation is just an anonymous instantiation of this trait and we can verify how the compiled version of it looks. The <kbd class="calibre11">javap</kbd> representation of the previous function literal looks as follows:</p>
<pre class="calibre19">public static scala.Function1&lt;java.lang.Object, scala.runtime.BoxedUnit&gt; colorPrint() 
 
public static void printPages(chapter4.Document, int, scala.Function1&lt;java.lang.Object, scala.runtime.BoxedUnit&gt;, scala.Function0&lt;java.lang.Object&gt;) </pre>
<p class="calibre2">The preceding representation means that the following are equivalent:</p>
<div class="cdpaligncenter"><img class="image-border15" src="../images/00032.jpeg"/></div>
<p class="calibre2">Here, on the right-hand side, we override the <kbd class="calibre11">apply</kbd> method for the <kbd class="calibre11">Function1</kbd> trait<em class="calibre18">.</em> Does it look more concise written in a literal way? Yes! That's why Scala has this syntax. Also, it means that a function value of this type is going to support all methods defined in <kbd class="calibre11">Function1</kbd>. We know that the trait has an <kbd class="calibre11">apply</kbd> method that's an abstract member from the trait. We also have a few concrete members such as the following:</p>
<pre class="calibre19">def andThen[A](g: (R) ⇒ A): (T1) ⇒ A 
 
def compose[A](g: (A) ⇒ T1): (A) ⇒ R </pre>
<p class="calibre2">We'll try to understand these method implementations using an example. Take a look at the following code snippet. We have two function literals, <kbd class="calibre11">incrementByOne</kbd> and <kbd class="calibre11">isEven</kbd><em class="calibre18">,</em> and we want to form another method that performs these two operations in sequence. We can use <kbd class="calibre11">andThen</kbd> for this. Check out our implementation of <kbd class="calibre11">incrementAndCheckForEven</kbd>. It looks like plain English, telling the Scala compiler, "I'll provide you with an integer, please first execute the <kbd class="calibre11">incrementByOne</kbd> function and then check for even numbers.":</p>
<pre class="calibre19">val incrementByOne = (num: Int) =&gt; num + 1 
 
val isEven = (num: Int) =&gt; num % 2 == 0 
 
val incrementAndCheckForEven = incrementByOne andThen isEven 
 
println(s"Representing andThen function ${incrementAndCheckForEven(1)}") </pre>
<p class="calibre2">Take a look at the following for a better understanding:</p>
<pre class="calibre19">def andThen[A](g: (R) ⇒ A): (T1) ⇒ A </pre>
<p class="calibre2">This tells us that <kbd class="calibre11">isEven</kbd> is the function literal <kbd class="calibre11">g</kbd><em class="calibre18">,</em> that is, of form <kbd class="calibre11">(R) =&gt; A</kbd>. The type <kbd class="calibre11">R</kbd> for our implementation is <kbd class="calibre11">Int</kbd> and X is <kbd class="calibre11">Boolean</kbd>. The return type of <kbd class="calibre11">andThen</kbd> is <kbd class="calibre11">g(apply(x))</kbd>.</p>
<p class="calibre2">In the same manner, we can also find use cases for our <kbd class="calibre11">compose</kbd> function<em class="calibre18">.</em> The difference between <kbd class="calibre11">andThen</kbd> and <kbd class="calibre11">compose</kbd> can be understood with the help of two example functions—<kbd class="calibre11">f</kbd> and <kbd class="calibre11">g</kbd>:</p>
<ul class="calibre7">
<li class="calibre8">In case of <kbd class="calibre11">andThen(g):f(x) == g(apply(x))</kbd></li>
<li class="calibre8">In case of <kbd class="calibre11">compose(g): f(x) == apply(g(x))</kbd></li>
</ul>
<p class="calibre2">You can do the remaining mathematics, but it's fun forming such a pipeline of operations using literals because they are readable and easy to implement. This example brings our discussion of function literals to an end but believe me, we'll be using these a lot in practice.</p>
<p class="calibre2">Up till now, we've been using the terms method and function interchangeably but the reality is a bit different. These two are different. The question is <em class="calibre18">how</em>, so let's start by talking about the methods to learn more.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Methods</h1>
                
            
            <article>
                
<p class="calibre2">We've already seen Scala methods and used them many times so far. However, to differentiate between methods and functions, we'll take a look at the Scala methods once again. What are methods in Scala? Throughout our discussion of methods, we'll look at several definitions of what a method is. Let's start with what a method may contain:</p>
<div class="cdpaligncenter"><img src="../images/00033.jpeg" class="calibre40"/></div>
<div class="cdpaligncenter1">Method signature</div>
<p class="calibre2">As you can see, we start our method with a few modifiers such as annotations, or keywords such as <kbd class="calibre11">final</kbd> and so on. This is followed by a <kbd class="calibre11">def</kbd> keyword, method name, parameter list, and then a return type that is optional. Scala methods are intelligent enough to infer the return type. Usually, a return type for a method is what the last expression evaluates to. Check out the following example:</p>
<pre class="calibre19">object Methods { 
 
  def filePrinter() = { 
    println("Version 0") 
    val filesHere = (new File(".")).listFiles() 
    for(file &lt;- filesHere) 
      println(file) 
  } 
 
  def main(args: Array[String]): Unit = { 
    filePrinter() 
  } 
 
} </pre>
<p class="calibre2">The result is as follows:</p>
<pre class="calibre19">Version 0 
./.idea 
./FirstProject.iml 
./out 
./src </pre>
<p class="calibre2">In the preceding example, we have a method named <kbd class="calibre11">filePrinter</kbd>, which does nothing but print the filenames in the current directory one by one. It's worth noticing a few things. We have used a <kbd class="calibre11">def</kbd> keyword<em class="calibre18">,</em> an assignment operator, and braces. We've preferred to omit specifying the return type, that is, <kbd class="calibre11">Unit</kbd> in our case. Methods which do not return any specific type except <kbd class="calibre11">Unit</kbd> can also be written in procedure syntax. In procedure syntax, we omit the assignment operator and directly define the method instead:</p>
<pre class="calibre19">def filePrinterV2() { 
  println("Version 2") 
  val filesHere = (new File(".")).listFiles() 
  for(file &lt;- filesHere) 
    println(file) 
} </pre>
<p class="calibre2">In the preceding code, we wrote a method that prints all the filenames from the current directory. Now, take a look at the following:</p>
<pre class="calibre19">import java.io.File 
 
object Methods { 
 
  def filePrinter() = { 
    println("Version 0") 
    val filesHere = (new File(".")).listFiles() 
    for(file &lt;- filesHere) 
      println(file) 
  } 
 
  def filePrinterV1() 
  { 
    println("Version 1") 
    val filesHere = (new File(".")).listFiles() 
    for(file &lt;- filesHere) 
      println(file) 
  } 
 
  def filePrinterV2() { 
    println("Version 2") 
    val filesHere = (new File(".")).listFiles() 
    for(file &lt;- filesHere) 
      println(file) 
  } 
 
  def filePrinterV3() = println("Version 3") 
    val filesHere = (new File(".")).listFiles() 
    for(file &lt;- filesHere) 
      println(file) 
 
  def main(args: Array[String]): Unit = { 
    filePrinter() 
    filePrinterV1() 
    filePrinterV2() 
    filePrinterV3() 
  } 
 
} </pre>
<p class="calibre2">We have four representations for our <kbd class="calibre11">filePrinter</kbd> method in the form of different versions, from <kbd class="calibre11">V0</kbd> to <kbd class="calibre11">V3</kbd>. Our intention is the same for all four methods. We want to print the filenames in the current directory. Can you guess which ones will work?</p>
<p class="calibre2">If you're done with guessing, let's take a look at the output:</p>
<pre class="calibre19">./.idea 
./FirstProject.iml 
./out 
./src 
Version 0 
./.idea 
./FirstProject.iml 
./out 
./src 
Version 1 
./.idea 
./FirstProject.iml 
./out 
./src 
Version 2 
./.idea 
./FirstProject.iml 
./out 
./src 
Version 3 </pre>
<p class="calibre2">Here's the output of our file printers. By taking a closer look, you'll see that for <kbd class="calibre11">filePrinter</kbd> versions <kbd class="calibre11">V0</kbd>, <kbd class="calibre11">V1</kbd>, and <kbd class="calibre11">V2</kbd>, the output is correct but for version <kbd class="calibre11">V3</kbd>, it's not. Plus, the sequence of evaluation tells us that from somewhere in our code, we're printing filenames. You might realize that it's because of the way we tried to define version v3 of our method. The <kbd class="calibre11">filePrinterV3</kbd> <span>method</span> defines only a simple <kbd class="calibre11">println</kbd>. The Scala compiler treats subsequent statements outside the scope of our method. Well, we can ensure these kind of mistakes don't happen.</p>
<p class="calibre2">We can do this by explicitly specifying the return type of our methods. Specifying the return type makes the Scala compiler take care of such mistakes and then notifies you at compile time.</p>
<p class="calibre2">A thing to note about methods in Scala is that they are <strong class="calibre1">non-value</strong> types. This means no instance or no object at runtime. This notion causes us to investigate what we mean by this and how it works. This statement also provides a major difference between functions and methods. Let's investigate the difference.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Functions versus methods</h1>
                
            
            <article>
                
<p class="calibre2">At the beginning of the chapter, we mentioned that we usually use the terms <strong class="calibre1">function</strong> and <strong class="calibre1">method</strong> interchangeably. But the reality is different. In Scala, these two are different concepts altogether. We'll use several examples to help understand this.</p>
<p class="calibre2"><span>We'll take a look at all the differences, f</span>rom syntactical differences to semantic differences. We'll also look at when to use what: a function or a method. For now, let's use a previous example. For the <kbd class="calibre11">colorPrinter</kbd> function, in both versions, we'll define a method and give it the name, <kbd class="calibre11">colorPrintV3</kbd>:</p>
<pre class="calibre19">val colorPrint = (index: Int) =&gt; println(s"Printing Color Page $index.") 
 
 
val colorPrintV2 = new Function1[Int, Unit]{ 
  override def apply(index: Int): Unit = 
    println(s"Printing Color Page $index.") 
} 
 
def colorPrintV3(index: Int) = println(s"Printing Color Page $index.") </pre>
<p class="calibre2">The way we can call these is similar. Syntactically there's no difference:</p>
<pre class="calibre19">println("---------Function V1-----------") 
printPages(Document(15, "DOCX"), 2, colorPrint) 
 
println("---------Function V2-----------") 
printPages(Document(15, "DOCX"), 2, colorPrintV2) 
 
println("---------Method V3-----------") 
printPages(Document(15, "DOCX"), 2, colorPrintV3) </pre>
<p class="calibre2">Here, <kbd class="calibre11">colorPrint</kbd> and <kbd class="calibre11">colorPrintV2</kbd> are functions and <kbd class="calibre11">colorPrintV3</kbd> is a method. In the preceding use case, we passed all these as literals. This looks similar, and it also works in a similar way. It also provides output:</p>
<pre class="calibre19">---------Function V1----------- 
Printing Color Page 1. 
Printing Color Page 2. 
---------Function V2----------- 
Printing Color Page 1. 
Printing Color Page 2. 
---------Method V3----------- 
Printing Color Page 1. 
Printing Color Page 2.  </pre>
<p class="calibre2">We said that methods and functions in Scala are different, but the way we use them and the results are similar. This happens because the compiler helps to convert a method into a function dynamically when it sees the possibility of doing it. So this is our counter-statement to this conflicting situation. We better investigate this.</p>
<p class="calibre2">We'll check class files generated by the compiler. Our intention is to investigate these three:</p>
<ul class="calibre7">
<li class="calibre8"><kbd class="calibre11">colorPrint</kbd></li>
<li class="calibre8"><kbd class="calibre11">colorPrintV2</kbd></li>
<li class="calibre8"><kbd class="calibre11">colorPrintV3</kbd></li>
</ul>
<p class="calibre2">The files generated by the compiler is as follows:</p>
<p class="calibre2"> </p>
<pre class="calibre19">:&gt; javap ColorPrinter.class <br class="title-page-name"/><span>Compiled from "FuncLiterals.scala"</span><br class="title-page-name"/>public final class chapter4.ColorPrinter { 
  public static void main(java.lang.String[]); 
  public static void delayedInit(scala.Function0&lt;scala.runtime.BoxedUnit&gt;); 
  public static void delayedEndpoint$chapter4$ColorPrinter$1(); 
  public static long executionStart(); 
 
  public static void colorPrintV3(int); 
 
  public static scala.Function1&lt;java.lang.Object, scala.runtime.BoxedUnit&gt; colorPrintV2(); 
 
  public static scala.Function1&lt;java.lang.Object, scala.runtime.BoxedUnit&gt; colorPrint(); 
 
  public static void printPages(chapter4.Document, int, scala.Function1&lt;java.lang.Object, scala.runtime.BoxedUnit&gt;, scala.Function0&lt;java.lang.Object&gt;); 
 
  public static boolean printerSwitch(); 
} </pre>
<p class="calibre2">When we observe the preceding compiled class representation of the <kbd class="calibre11">colorPrint</kbd> series of functions, it becomes clear that the way Scala treats them internally is different. The takeaway points from this are:</p>
<ul class="calibre7">
<li class="calibre8">Scala function literals are compiled down to the form of a FunctionX trait (X here, is a placeholder for a number, meaning, the number of parameters this function is going to support). We've already seen that this FunctionX trait comes with more methods such as <kbd class="calibre11">apply</kbd>, <kbd class="calibre11">andThen</kbd>, and <kbd class="calibre11">compose</kbd>.</li>
<li class="calibre8">Scala methods are compiled down to normal Java methods.</li>
<li class="calibre8">Finally, methods suited to the context of an object, for example, the <kbd class="calibre11">apply</kbd> method from the FunctionX trait, only get called on anonymous instances of FunctionX, so the following makes sense for the <kbd class="calibre11">apply</kbd> method:</li>
</ul>
<pre class="calibre36">colorPrintV2(3) </pre>
<p class="calibre2">The preceding code is equivalent to the following:</p>
<pre class="calibre19">new Function1[Int, Unit]().apply(3) </pre>
<p class="calibre2">This tells us that Scala does some magic with the function syntax at compile time. Also, we know that our literals are <em class="calibre18">Ffunction objects</em> so we can perform operations like <kbd class="calibre11">toString</kbd>, as well as equality operations on them. Hence, the following is valid:</p>
<pre class="calibre19">colorPrint == colorPrintV2 //false </pre>
<p class="calibre2">However, the compiler won't let you perform the following:</p>
<pre class="calibre19">colorPrint == colorPrintV3 //Compile Time Error </pre>
<p class="calibre2">The reason for this is that <kbd class="calibre11">colorPrintV3</kbd> is a method and not a value type. Also if you try to call <kbd class="calibre11">toString</kbd> on <kbd class="calibre11">colorPrintV3</kbd>, the compiler will complain about it and won't let you perform such operations on a method type. The Scala compiler automatically converts a method to its literal equivalent and provides a way to explicitly perform it. We use the following syntax for that:</p>
<pre class="calibre19">val colorPrintV4 = colorPrintV3 _ </pre>
<p class="calibre2">Take a look at the trailing underscore. This syntactic sugar is enough to tell the Scala compiler to convert the method to a function. Now, you may call <kbd class="calibre11">toString</kbd>, create a function pipeline, or use <kbd class="calibre11">andThen</kbd> or <kbd class="calibre11">compose</kbd> methods on <kbd class="calibre11">colorPrintV4</kbd>. We can even perform equality methods on it. So that's how methods and functions are different in Scala, but now the question arises when to choose what?</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Methods or functions?</h1>
                
            
            <article>
                
<p class="calibre2">Now that you have an idea about the difference between a method and a function, you might be wondering where and when to use what. Should I prefer a function over a method or the opposite? Earlier, we defined a <kbd class="calibre11">colorPrinterV3</kbd> <span>method</span> and passed that to our higher-order <kbd class="calibre11">printPages</kbd> <span>function</span> (we'll talk about higher-order functions in later sections)<em class="calibre18">.</em> Now that you know that the compiler has to put some extra effort into converting the method into its function equivalent, it becomes obvious that in use cases where we're depending upon higher-order functions, it's a good choice to have functions in scope so that we can communicate properly. Apart from that, it's also obvious that defining a function instead of a method gives us more functionality options. We've seen examples of methods such as <kbd class="calibre11">andThen</kbd> and <kbd class="calibre11">compose</kbd>. These methods let us enhance the functionality. Performance-wise, there's not much of a difference in the usage. There are a few scenarios where only methods are the solution:</p>
<ul class="calibre7">
<li class="calibre8">We can provide default values for method parameters, but that's not possible for functions.</li>
<li class="calibre8">In a parent-child class relationship, when we override a method from a superclass, we can still access the parent class version of that method using a <kbd class="calibre11">super</kbd> call. However, once you override a function, you can't make a super call and are stuck with the implementation.</li>
</ul>
<p class="calibre2">So it's wise to choose which one to use depending on the requirements you have. Functions provide us with more chaining capabilities. We may choose to use whichever suits us the best.</p>
<p class="calibre2">For now, let's again take a look at the snippet we have, and see if we can make some more modifications:</p>
<pre class="calibre19">object ColorPrinter extends App { 
 
  val printerSwitch = false 
 
 def printPages(doc: Document, lastIndex: Int, print: (Int) =&gt; Unit, isPrinterOn: =&gt; Boolean) = { 
 
    if(lastIndex &lt;= doc.numOfPages &amp;&amp; isPrinterOn) for(i &lt;- 1 to lastIndex) print(i) 
 
  } 
 
  val colorPrint = (index: Int) =&gt; println(s"Printing Color Page $index.") 
 
  val colorPrintV2 = new Function1[Int, Unit]{ 
    override def apply(index: Int): Unit = 
      println(s"Printing Color Page $index.") 
  } 
 
  println("---------Function V1-----------") 
  printPages(Document(15, "DOCX"), 2, colorPrint, !printerSwitch) 
   
  println("---------Function V2-----------") 
  printPages(Document(15, "DOCX"), 2, colorPrintV2, !printerSwitch) 
   
} 
 
case class Document(numOfPages: Int, typeOfDoc: String) </pre>
<p class="calibre2">I'm using this <kbd class="calibre11">Printer</kbd> example because it's easy to understand and we've already seen bits and pieces of it. So, when taking a look at the calling of the <kbd class="calibre11">printPages</kbd> function, we may want to do some refactoring. First, we know the logic that checks if the printer is ON or OFF by checking <kbd class="calibre11">printerSwitch</kbd> value. Moreover, every time we call <kbd class="calibre11">printPages</kbd>, we have to pass the <kbd class="calibre11">!printerSwitch</kbd> parameter. We want to omit this extra burden of telling the printer to check if it's on or not. We want the printer to already know that, that's what we're going to do. But in a programming context, is it possible to refer to <kbd class="calibre11">printerSwitch</kbd> from the inner scope of the <kbd class="calibre11">printPages</kbd> function? Yes, it's possible if we choose to use a closure. Let's discuss closures and how we can define them in Scala.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">What are closures?</h1>
                
            
            <article>
                
<p class="calibre2">We'll solve the problem in the previous section using closures. But first, let's explain the concept of a <strong class="calibre1">closure</strong><em class="calibre18">.</em> In programming terminology, a closure has more than one definition:</p>
<ul class="calibre7">
<li class="calibre8">A closure is simply a function value that gets created at runtime and encompasses a reference to a free variable that's not in the local scope</li>
<li class="calibre8">A closure in practical terms is a function that you can pass around that retains the same scope and values as the ones it had at the time of creation</li>
</ul>
<p class="calibre2">What do we mean by these statements? Let's check that using a very simple, but a fun example:</p>
<pre class="calibre19">object AClosure extends App { 
 
  var advertisement = "Buy an IPhone7" 
 
  val playingShow = (showName: String) =&gt; println(s"Playing $showName. Here's the advertisement: $advertisement") 
 
  playingShow("GOT") 
  advertisement = "Buy an IPhone8" 
 
  playingShow("GOF") 
 
} </pre>
<p class="calibre2">The result is as follows:</p>
<pre class="calibre19">Playing GOT. Here's the advertisement: Buy an IPhone7<br class="title-page-name"/>Playing GOF. Here's the advertisement: Buy an IPhone8</pre>
<p class="calibre2">So, you're getting it, aren't you? Here, we created a function that expects a <kbd class="calibre11">showName</kbd> and plays it. That doesn't go so smoothly and we get to watch some advertisements. That's what is happening in the preceding code. It's obvious that the use case is not practical, but it's easy to understand the concept. We're trying to refer to a variable that's not in the local scope of our <kbd class="calibre11">playingShow</kbd> function<em class="calibre18">.</em> When we tried using this function for the first time, the runtime representation of <kbd class="calibre11">playingShow</kbd> was referring to the iPhone 7 advertisement. Then we time travel, and the second time we called <kbd class="calibre11">playingShow</kbd>, we watched an advertisement that was different from the previous one. The point to take away is the runtime representation of our <kbd class="calibre11">playingShow</kbd> is called a closure. Some terminology included with a closure are <em class="calibre18">open terms</em> and <em class="calibre18">closed terms.</em> Here, in our example, <kbd class="calibre11">advertisement</kbd> is called a free variable because it doesn't reside in the local scope of our <em class="calibre18">function</em>/<em class="calibre18">closure</em> whereas the <kbd class="calibre11">showName</kbd> parameter, which we explicitly referred to, is called a <em class="calibre18">bound</em> variable<em class="calibre18">.</em> When we try to form a function literal with only bound variables, it's called a closed term. And the other way around, when you include a free variable, it makes an open term.</p>
<p class="calibre2">A closed term example is as follows:</p>
<pre class="calibre19">(showName: String) =&gt; println(s"Playing $showName. No Advertisement") </pre>
<p class="calibre2">An open term example is as follows:</p>
<pre class="calibre19">(showName: String) =&gt; println(s"Playing $showName. Here's the advertisement: $advertisement") </pre>
<p class="calibre2">One more thing to note is that a closure only keeps the reference to the free variables. That's the reason we were able to detect the change in the value of <kbd class="calibre11">advertisement</kbd>.</p>
<p class="calibre2">Now that you've some idea about closures<em class="calibre18">,</em> let's get back to the refactoring of the <kbd class="calibre11">printPages</kbd> function. Our intended behavior was that the printer should already know how to switch before printing. We can omit the function literal specified in <kbd class="calibre11">printPages</kbd>. Then there are two possible solutions:</p>
<pre class="calibre19">val printerSwitch = false 
 
def printPages(doc: Document, lastIndex: Int, print: (Int) =&gt; Unit) = { 
 
  if(lastIndex &lt;= doc.numOfPages) for(i &lt;- 1 to lastIndex) print(i) 
 
} 
 
val colorPrint = (index: Int) =&gt; if(!printerSwitch) println(s"Printing Color Page $index.") 
 
val colorPrintV2 = new Function1[Int, Unit]{ 
  override def apply(index: Int): Unit = 
    if(!printerSwitch) println(s"Printing Color Page $index.") 
} </pre>
<p class="calibre2">In the preceding snippet, we've removed the <kbd class="calibre11">isPrinterOn</kbd> function literal and added the explicit <kbd class="calibre11">printerSwitch</kbd> check in two functions, <kbd class="calibre11">colorPrint</kbd> and <kbd class="calibre11">colorPrintV2</kbd>. This is possible because we were sure about the printer functionality driven by the switch. Also, we removed the extra burden of passing this function literal each time we call for a print. This is a fine and acceptable solution to our problem and the reason we're trying out this example is that it's using a closure in the solution. When we include <kbd class="calibre11">printerSwitch</kbd>, which is not in the local scope of our <kbd class="calibre11">colorPrint</kbd> function literal<em class="calibre18">,</em> we make it a closure. Then, as with our last example, the runtime representation of our <kbd class="calibre11">colorPrint</kbd> is going to keep the reference of our <kbd class="calibre11">printerSwitch</kbd> forming a closure<em class="calibre18">.</em> The refactor seems fine, but it can be enhanced, let's check out the second solution:</p>
<pre class="calibre19">val printerSwitch = false 
 
def printPages(doc: Document, lastIndex: Int, print: (Int) =&gt; Unit) = { 
 
  if(lastIndex &lt;= doc.numOfPages &amp;&amp; !printerSwitch) for(i &lt;- 1 to lastIndex) print(i) 
 
} 
 
val colorPrint = (index: Int) =&gt; println(s"Printing Color Page $index.") 
 
val colorPrintV2 = new Function1[Int, Unit]{ 
  override def apply(index: Int): Unit = 
    println(s"Printing Color Page $index.") 
} </pre>
<p class="calibre2">What we've done in the second solution is we removed <kbd class="calibre11">isPrinterOn</kbd> from our <kbd class="calibre11">printPages</kbd> <span>function's</span> parameter list and put the implementation with <kbd class="calibre11">!printerSwitch</kbd>. This makes our <kbd class="calibre11">printPages</kbd> function a closure and somehow we were able to reduce code duplication in <kbd class="calibre11">colorPrint</kbd> and <kbd class="calibre11">colorPrintV2</kbd>. So this is another alternative we have to our solution.</p>
<p class="calibre2">I hope you get the idea of what a closure is and how it can be used. We also learned that closures don't solve any problems that can't be solved without them. They are just an alternative to getting things done in a concise manner. We also saw a closure carry state with them; this is a concept defined in many languages and in languages where there's no state present such as <strong class="calibre1">Haskell</strong>, hence these are used to carry <em class="calibre18">immutable state.</em> However, these are an essential and fun alternative to solving a particular problem. In Scala, there are several such tool type constructs available, using which we can make our code smell good, a closure is one of them.</p>
<p class="calibre2">We've talked a lot about functions, methods, and closures. During which we've come up with various higher-order functions. So now, we're kind of comfortable with the concept of higher-order functions. When we see one, it doesn't feel odd or doesn't make us feel uncomfortable. Great, then let's discuss them in detail. You already have some idea about the power of them in a functional programming context. We'll explore them more.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Higher-order functions</h1>
                
            
            <article>
                
<p class="calibre2">We know that we can only pass a first-class value object as an argument to a method or a function. For example, take this simple method:</p>
<pre class="calibre19">def sum(a: Int, b: Int) = a + b </pre>
<p class="calibre2">This is a method named <kbd class="calibre11">sum</kbd> and declares two parameters <kbd class="calibre11">a</kbd> and <kbd class="calibre11">b</kbd>. Now, to use this method, we will pass arguments. In the argument list, it's obvious we'll have to pass values of the integer type. It's clear that any type, if it's a value, can be declared as a function parameter and can be used as an argument while calling a function.</p>
<p class="calibre2">In Scala, function literals are nothing more than function trait objects, hence it's obvious that we can declare them as parameters and use them as arguments. This gives rise to functions which contain functions as parameters, and function calls which contain function literals as arguments. These types of functions are called <strong class="calibre1">higher-order functions</strong> (<strong class="calibre1">HOF</strong>). Using higher-order functions has its own advantages. We've already seen a couple of those. W<span>herever we define abstract syntax in</span> libraries, frameworks, or code, higher-order functions are used at large. If you think about how these behaviors/functions can be used in higher orders, you'll come up with a few of the following scenarios:</p>
<ul class="calibre7">
<li class="calibre8">Function as an output</li>
<li class="calibre8">Function as an input</li>
<li class="calibre8">Function as a parameter</li>
</ul>
<p class="calibre2">The preceding scenarios specify three conditions where we can use function literals as higher-order functions. Take a look at the following figure to get a clear picture:</p>
<div class="cdpaligncenter"><img class="image-border16" src="../images/00034.jpeg"/></div>
<div class="cdpaligncenter1">A few forms of higher-order functions</div>
<p class="calibre2">As shown in the table, we have used a function literal of form <kbd class="calibre11">int =&gt; int</kbd>, which means a function that takes an integer as an input and gives back another integer after performing some operation on it. The first form in the figure takes an integer as an input parameter and returns a function literal of form <kbd class="calibre11">int -&gt; int</kbd>. In the second form, we are taking a function literal of form <kbd class="calibre11">int -&gt; int</kbd>, and giving an integer as an output. In the final form, we are expecting an integer and a function literal of the same form <kbd class="calibre11">int -&gt; int</kbd> as a parameter. Let's see a few examples to see things clearer:</p>
<pre class="calibre19">object HOFs extends App { 
 
  def multiplier10(x : Int): Int =&gt; Int = x =&gt; x * 10   //functionAsOutput 
 
  def intOpPerformer(g: Int =&gt; Int) : Int = g(5)        //functionAsInput 
 
  def multiplicator(x: Int)(g: Int =&gt; Int): Int = g(x)  //functionAsParameter 
 
  println(s"functionAsInput Result: ${intOpPerformer(multiplier10(5))}") 
 
  println(s"functionAsParameter Result: ${multiplicator(5)(multiplier10(5))}") 
 
} </pre>
<p class="calibre2">The result is as follows:</p>
<pre class="calibre19">functionAsInput Result: 50 
functionAsParameter Result: 50 </pre>
<p class="calibre2">In the preceding code, we defined all three forms. The first gives a function as an output, named <kbd class="calibre11">multiplier10</kbd>, the form itself is explanatory. It takes an integer and returns a function literal that is a multiplier of 10.</p>
<p class="calibre2">The second one is a higher-order method which takes a function literal as input and outputs an integer as a result. The <kbd class="calibre11">intOpPerformer</kbd> <span>method,</span> as the name suggests, performs an operation of type <kbd class="calibre11">Int =&gt; Int</kbd>, be it a multiplication operation or any other operation. Whichever we pass, it's going to be used and the output will be an integer as mentioned in the signature. We can call the function by providing an input function literal:</p>
<pre class="calibre19">intOpPerformer(multiplier10(5)) </pre>
<p class="calibre2">So this is another way we can utilize the higher-order nature of a function. There's one more, the third version, where we pass this function literal as part of the parameter list and it applies the first parameter value to the second parameter function and gives an integer result. The <kbd class="calibre11">multiplicator</kbd> function is an example of such a construct. We have used the curried form of the function. We'll learn about currying in subsequent sections:</p>
<pre class="calibre19">multiplicator(5)(multiplier10(5)) </pre>
<p class="calibre2">These are the ways we can incorporate higher-order functions and all of them solve certain problems. By removing code duplication, we can abstract out the pattern and make a higher-order version of our function. That's how we use them.</p>
<p class="calibre2">Our famous <kbd class="calibre11">ColorPrinter</kbd> example also uses higher-order functions:</p>
<pre class="calibre19">def printPages(doc: Document, lastIndex: Int, print: (Int) =&gt; Unit, isPrinterOn: =&gt; Boolean) = { 
 
    if(lastIndex &lt;= doc.numOfPages &amp;&amp; isPrinterOn) for(i &lt;- 1 to lastIndex) print(i) 
 
  }  </pre>
<p class="calibre2">Here, <kbd class="calibre11">print</kbd> is a higher-order function that we are passing as a parameter. A close look will explain it better. The <kbd class="calibre11">colorPrint</kbd> <span>argument</span> itself is a function literal:</p>
<pre class="calibre19">printPages(Document(15, "DOCX"), 2, colorPrint, !printerSwitch) 
 
val colorPrint = (index: Int) =&gt; println(s"Printing Color Page $index.") </pre>
<p class="calibre2">This is possible just because <kbd class="calibre11">colorPrint</kbd> is a value object. While we are on the subject, sometimes you may read: "Functional languages treat functions as first class values." What do we mean by <em class="calibre18">first class values</em>? It means that the way we declare an integer or string value and use them as parameters. In the same way, we can declare a function literal and use it as a parameter in other functions.</p>
<p class="calibre2">Higher-order functions make it a lot easier to compose functions or chains of functions to perform a complex task in an easy and readable manner. Needless to say, utility functions such as <kbd class="calibre11">map</kbd>, <kbd class="calibre11">flatmap</kbd>, <kbd class="calibre11">filter</kbd>, <kbd class="calibre11">fold</kbd>, and so on are all higher-order functions. In Scala or any other programming language, functions such as <kbd class="calibre11">map</kbd>, <kbd class="calibre11">filter</kbd>, or <kbd class="calibre11">flatmap</kbd> are a result of trying to solve a particular pattern of problem. Hence, it's obvious that we take a part of a certain pattern from our functions and replace it with a higher-order function. The idea for this action is to abstract out the implementation in the form of a function literal.</p>
<p class="calibre2">A simple example, to get a better understanding, is a simple mathematical operation for two integers. Take a look at the following:</p>
<pre class="calibre19">def add(a: Int, b: Int) = a + b 
 
def multiply(a: Int, b: Int) = a * b 
 
def subtract(a: Int, b: Int) = a - b 
 
def modulus(a: Int, b: Int) = a % b </pre>
<p class="calibre2">In the preceding code are a few methods that take two input parameters and perform a particular operation. Using these is also pretty easy:</p>
<pre class="calibre19">add(10, 5) 
subtract(10, 5) 
multiply(10, 5) 
modulus(10, 5) </pre>
<p class="calibre2">But as good programmers, it's our duty to check the implementation details, even if the solution is working. When you do that, you get to see that all four implementations have many things in common. All four methods have two parameters but the definition proves to be different as each method is performing a different operation. In a sense, we know we can abstract out the signature and implementation details in the form of function literals and form a higher-order function. So we take steps for that.</p>
<ul class="calibre7">
<li class="calibre8">First, we create function literal versions of all four implementations, which have a form of <kbd class="calibre11">(Int, Int) =&gt; Int</kbd> and we come up with something like the following:</li>
</ul>
<pre class="calibre36">val add = (a: Int, b: Int) =&gt; a + b 
val multiply = (a: Int, b: Int) =&gt; a * b 
val subtract = (a: Int, b: Int) =&gt; a - b 
val modulus = (a: Int, b: Int) =&gt; a % b </pre>
<p class="calibre37">This ensures that we can pass these literals without worrying about internal dynamic conversions.</p>
<ul class="calibre7">
<li class="calibre8">Then, we write the abstracted out method that takes one such function literal and two integer parameters to perform the operation on. The result looks something like the following:</li>
</ul>
<pre class="calibre36">def operation(op: (Int, Int) =&gt; Int, a: Int, b: Int) : Int = op(a, b) </pre>
<p class="calibre37">Here, <kbd class="calibre11">operation</kbd> is the higher-order method which takes a function literal and two parameters and calls the function passed with the other parameters.</p>
<p class="calibre2">Now, using the higher-order method is as easy as calling any other function:</p>
<pre class="calibre19">operation(add, 10, 5) 
operation(subtract, 10, 5) 
operation(multiply, 10, 5) 
operation(modulus, 10, 5) </pre>
<p class="calibre2">You may ask whether this makes sense. We still wrote the same (with a couple of extra) lines of code. So let's remove the literals we wrote, as those are just literals we named. We can directly use the functionality by providing what you intend to do dynamically to our <kbd class="calibre11">operation</kbd> function. Our code looks like the following after the final implementation:</p>
<pre class="calibre19">object HOFs extends App { 
   
  def operation(op: (Int, Int) =&gt; Int, a: Int, b: Int) : Int = op(a,b) 
 
  println(operation((a, b) =&gt; a + b, 10, 5)) 
  println(operation((a, b) =&gt; a * b, 10, 5)) 
  println(operation((a, b) =&gt; a - b, 10, 5)) 
  println(operation((a, b) =&gt; a % b, 10, 5)) 
 
} </pre>
<p class="calibre2">The result is as follows:</p>
<pre class="calibre19">15 
50 
5 
0 </pre>
<p class="calibre2">The real function required is just a one-liner, the <kbd class="calibre11">operation</kbd> higher-order function. The next few lines are the calls to the previous <kbd class="calibre11">operation</kbd> function. One thing to note, on the calling side of the <kbd class="calibre11">operation</kbd> function we didn't provide the <kbd class="calibre11">a</kbd> and <kbd class="calibre11">b</kbd> type of parameters. That's because Scala is powerful enough to understand that an <kbd class="calibre11">operation</kbd> functions first parameter expects the same type as we are providing.</p>
<p class="calibre2">I hope this example helps you to understand the concept of higher-order functions. In practice, the more you use them, the more you get to see the power of them. A couple of forms exist, using which we solve problems.</p>
<p class="calibre2">Now that we've seen more than one representation and one use case of higher-order functions, let's take a look at another way of calling functions using currying. You may have heard about currying as a concept. Here, our motto is to understand what Currying is and what purpose it solves.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Currying</h1>
                
            
            <article>
                
<p class="calibre2">Scala allows you to pass multiple parameters in functions or methods. We may want to create intermediate versions of such functions. This gives us more than one version of a single function. In other words, we can break down every function with multiple parameters into single parameter functions. Why would we want to create single parameter functions? The answer to this is, we can leverage it for function composition. For example, we can launch a website with the help of a domain name, hosting, and web platform. See the following example:</p>
<pre class="calibre19">WebsitePlatform =&gt; DomainName =&gt; Host </pre>
<p class="calibre2">If you have a function that takes a domain name, another function that takes a website platform, and another function that takes a hosting platform as a parameter, you can compose them together to have a full-fledged website. Functional composition is powerful because it gives you more options together with intermediate functions. A normal function would look like the following:</p>
<pre class="calibre19">def makeWebsite(platform: WebsitePlatform, domainName: DomainName, host: Host) = println(s"Making $domainName using $platform with hosting from $host ") </pre>
<p class="calibre2">This form of a method does not provide you with the same power that you have when you compose a function. As mentioned, in Scala it's possible to convert our functions to a curried form or convert functions with multiple parameters into a function with single parameters. For that Haskell Curry has provided the concept of currying. Here's an example to help us understand this. We'll take the same example of making a website. The problem statement is clear. We want to compose intermediate functions where we can pass multiple, single parameter lists. The end function should look like the following:</p>
<pre class="calibre19">def makeWebsite(platform: WebsitePlatform)(domainName: DomainName)(host: Host): Unit </pre>
<p class="calibre2">Here, <kbd class="calibre11">WebsitePlatform</kbd>, <kbd class="calibre11">DomainName</kbd>, and <kbd class="calibre11">Host</kbd> are the types we choose to use. We can create these using Scala, providing the <kbd class="calibre11">type</kbd> keyword. A form of the preceding function is as follows:</p>
<pre class="calibre19">WebsitePlatform =&gt; DomainName =&gt; Host =&gt; Unit </pre>
<p class="calibre2">Suppose you want to have an intermediate function that does not have to deal with the website platform, and simply creates a WordPress.com platform account for the intended account. The function should return something like the following:</p>
<pre class="calibre19">DomainName =&gt; Host =&gt; Unit </pre>
<p class="calibre2">The same goes for the other two intermediate versions. For example, you want to create a dummy website with the default WordPress.com (<a href="https://wordpress.com/" class="calibre10">https://wordpress.com/</a>) platform and a dummy WordPress URL for your website. The version then looks like the following:</p>
<pre class="calibre19">Host =&gt; Unit </pre>
<p class="calibre2">The final version deals with all the defaults using bluehost.com as the default hosting provider and creating a website for you. An example application would look like the following:</p>
<pre class="calibre19">object Curried extends App { 
 
  type WebsitePlatform = String 
  type DomainName = String 
  type Host = String 
 
  def makeWebsite(platform: WebsitePlatform)(domainName: DomainName)(host: Host) = 
    println(s"Making $domainName using $platform with hosting from $host ") 
 
 
  val wordPress: DomainName =&gt; Host =&gt; Unit = makeWebsite("WordPress") 
 
  val wordPressDummyDotCom : Host =&gt; Unit = wordPress("dummy123.com") 
 
  val blueHostedWordPressDummyDotCom : Unit = wordPressDummyDotCom("Bluehost.com") 
 
  blueHostedWordPressDummyDotCom<br class="title-page-name"/><br class="title-page-name"/> }</pre>
<p class="calibre2">The result is as follows:</p>
<pre class="calibre19">Making dummy123.com using WordPress with hosting from Bluehost.com </pre>
<p class="calibre2">Did you take a look at the preceding code? We used composition, step-by-step, to make a default website creator that uses WordPress.com as a website platform, bluehost.com as hosting provider, and some dummy URI as URL. Let's try to understand how this is working. The first thing that we did was just add a syntactic enhancement for a better understanding. The three types we declared using the type keywords are just strings. These strings are, of course, for demonstration purposes. They can be of different types. Then we declared the curried version of a method that takes three different single parameter lists. The definition is not very important right now, we're just printing.</p>
<p class="calibre2">Then comes the interesting part. We created an intermediate version of our function, named <kbd class="calibre11">wordPress</kbd>, and the return type of this function is <kbd class="calibre11">DomainName =&gt; Host =&gt; Unit</kbd>. In the very next step, we created another intermediate function named <kbd class="calibre11">wordPressDummyDotCom</kbd> that is particular to WordPress.com and uses a dummy URL. In the same way, we again composed another function that gives another default website component. The advantage of this is that we can create multiple versions with different website platforms and thus things will be easier for the client of your program, as you're providing multiple versions of default functions for almost every set of parameters. For that, we have used nothing more than the curried form of our function. It is so common to convert or write curried versions of your function in Scala, that the language has a default way of doing it. In Scala, it's possible to convert a function with multiple parameters to its curried counterpart.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Converting a function with multiple parameters to curried form</h1>
                
            
            <article>
                
<p class="calibre2">In Scala, we have a function called <kbd class="calibre11">curried</kbd><em class="calibre18">,</em> using which we can convert our functions to a curried form. Let's see a simple example for a better understanding:</p>
<pre class="calibre19">def add = (x: Int, y: Int) =&gt; x + y 
 
val addCurried = add.curried 
 
println(add(5,6)) 
println(addCurried(5)(6)) </pre>
<p class="calibre2">The result is as follows:</p>
<pre class="calibre19">11 
11 </pre>
<p class="calibre2">Here, we defined a simple two-parameter function literal named <kbd class="calibre11">add</kbd>. Then, we used a Scala-provided function named <kbd class="calibre11">curried</kbd> to convert the function to its curried form. We named the result <kbd class="calibre11">addCurried</kbd>. With that, we were able to call both functions and got the same result.</p>
<p class="calibre2">There's also a way to uncurry curried functions. We have this <kbd class="calibre11">uncurried</kbd> method, using which we can convert the curried function to uncurried form:</p>
<pre class="calibre19">val addCurriedUncurried = Function.uncurried(addCurried) 
 
println(addCurriedUncurried(5,6)) </pre>
<p class="calibre2">The result is as follows:</p>
<pre class="calibre19">11 </pre>
<p class="calibre2">This is how we use currying in Scala. There are similar constructs that we can use in Scala to fulfill the same intentions, and we call them <em class="calibre18">partially applied functions</em>. These are different to currying. Let's discuss the topic in detail.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Partially applied functions</h1>
                
            
            <article>
                
<p class="calibre2">Partially applied functions, as the name suggests, apply the functions partially. It means that for functions with multiple parameters in a parameter list, we don't provide a value for each of the parameters. If we don't want to provide parameters we just leave them blank. Now that we know this, let's look at a similar example to the one we looked at when learning currying. With this, you'll be able to differentiate between the two.</p>
<p class="calibre2">First, take a look at the multiple parameter functions, which we'll convert to partially applied forms:</p>
<pre class="calibre19">def makeWebsite(platform: WebsitePlatform, domainName: DomainName, host: Host) = 
  println(s"Making $domainName using $platform with hosting from $host ") </pre>
<p class="calibre2">Here, <kbd class="calibre11">makeWebsite</kbd>, as we have already seen, takes three parameters, <kbd class="calibre11">platform</kbd>, <kbd class="calibre11">domainName</kbd>, and <kbd class="calibre11">host</kbd>. Take a look at an application we can create with various intermediate or partially applied functions:</p>
<pre class="calibre19">object PaF extends App { 
 
  type WebsitePlatform = String 
  type DomainName = String 
  type Host = String 
  type Protocol = String 
 
  def makeWebsite(platform: WebsitePlatform, domainName: DomainName, host: Host) = 
    println(s"Making $domainName using $platform with hosting from $host ") 
 
  val wordPressSite: (DomainName, Host) =&gt; Unit = makeWebsite("WordPress", _: DomainName, _: Host) 
 
  val makeExampleDotCom: (WebsitePlatform, Host) =&gt; Unit = makeWebsite(_: WebsitePlatform, 
      "example.com", 
      _: Host 
    ) 
 
  val makeBlueHostingExampleDotCom: (WebsitePlatform) =&gt; Unit = makeWebsite(_: WebsitePlatform, 
    "example.com", 
    "bluehost.com" 
    ) 
   
  makeWebsite("Wordpress", "anyDomain.com", "Godaddy.com") 
  wordPressSite("example.com", "Godaddy.com") 
  makeExampleDotCom("Wordpress", "bluehost.com") 
  makeBlueHostingExampleDotCom("Blogger") 
 
} </pre>
<p class="calibre2">The result is as follows:</p>
<pre class="calibre19">Making anyDomain.com using Wordpress with hosting from Godaddy.com  
Making example.com using WordPress with hosting from Godaddy.com  
Making example.com using Wordpress with hosting from bluehost.com  
Making example.com using Blogger with hosting from bluehost.com </pre>
<p class="calibre2">So, here we can see three partially applied functions. Take a look at the first one:</p>
<pre class="calibre19">val wordPressSite: (DomainName, Host) =&gt; Unit = makeWebsite("WordPress", _: DomainName, _: Host) </pre>
<p class="calibre2">The function name suggests what this does. We can expect this function to provide a partially applied function for <kbd class="calibre11">WebsitePlatform</kbd>, and that's the reason the return type of the function is of the following form:</p>
<pre class="calibre19">(DomainName, Host) =&gt; Unit </pre>
<p class="calibre2">To use this function, we simply provide the unapplied parameters and it works:</p>
<pre class="calibre19">  wordPressSite("example.com", "Godaddy.com") </pre>
<p class="calibre2">In the same way, we also described other versions, let's take a look at them. For one of them, we provided a default dummy URL for our website, the website platform, and hosting service that we can provide at the time of calling the same:</p>
<pre class="calibre19">val makeExampleDotCom: (WebsitePlatform, Host) =&gt; Unit = makeWebsite(_: WebsitePlatform, 
      "example.com", 
      _: Host 
    ) </pre>
<p class="calibre2">The version returns back the type as follows:</p>
<pre class="calibre19">(WebsitePlatform, Host) =&gt; Unit </pre>
<p class="calibre2">When we take a look at the implementation part, we see that the unapplied parameters are replaced with an underscore. We've also provided the types explicitly with the parameters. So, in a way, <em class="calibre18">partially applied functions</em> solve almost the same kind of problems that currying solved for us. Also, we know that <em class="calibre18">partial functions</em> have a similar concept. As we've already gone through <em class="calibre18">partial functions,</em> we must know that they are just functions that are defined for a particular set of input values. Hence, we should be able to differentiate between these three concepts.</p>
<p class="calibre2">With this discussion of <em class="calibre18">partially applied functions</em>, we have come to the end of our chapter. Let's summarize what we have learned.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            <article>
                
<p class="calibre2">In this chapter, we enhanced our knowledge of functions in Scala. We started with the basic method and function definitions, investigated the difference between them, and looked at how Scala treats them. We also saw that Scala is intelligent enough to convert a method to a function whenever needed. Then we took the discussion further and talked about closures. We got to know what <em class="calibre18">closures</em> are and then we had a solid discussion regarding higher-order functions in Scala. That was essential as we were already using higher-order functions and we saw multiple forms of them. Afterwards, we looked at currying and talked about <em class="calibre18">partially applied functions.</em> We know that partially applied functions are different from <em class="calibre18">partial functions</em> and <em class="calibre18">currying.</em> So now we have a solid understanding of functions in Scala because we have investigated them thoroughly.</p>
<p class="calibre2">Now it's time to go further and learn about a few advanced functional constructs. The knowledge gained in this chapter will help us do that in the next chapter, where we'll learn about advanced functional constructs.</p>


            </article>

            
        </section>
    </body></html>