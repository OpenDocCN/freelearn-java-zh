- en: Chapter 10. Securing WildFly Applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we described how to manage your application server.
    The next stop in our journey will be learning about security, which is a key element
    of any Enterprise application. You must be able to control and restrict who is
    permitted to access your applications and what operations users may perform.
  prefs: []
  type: TYPE_NORMAL
- en: The Java Enterprise Edition specification defines a simple role-based security
    model for Enterprise JavaBeans and web components. The implementation of WildFly
    security is delivered by the **Picketbox** framework (formerly known as JBoss
    Security), which is part of the application server and provides the authentication,
    authorization, auditing, and mapping capabilities for Java applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the list of topics we will cover in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: A short introduction to the Java security API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The foundation of the WildFly security subsystem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining and applying login modules to secure Java EE applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the **Secure Sockets Layer** (**SSL**) protocol to encrypt the traffic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Approaching the Java security API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Java EE security services provide a robust and easily configurable security
    mechanism to authenticate users and authorize access to application functions
    and the associated data. To better understand the topics related to security,
    we should first lay out some basic definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Authentication**: This is the process by which you can verify who is currently
    executing an application, regardless of whether it is an EJB or a servlet (and
    so on). Authentication is usually performed by means of a `Login` module contained
    in a web/standalone application. The Java EE specification provides only general
    requirements that must be met by all compliant containers. This means that every
    application server provides its own authentication mechanisms, which is a problem
    when it comes to portability of applications and their configuration.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Authorization**: This is the process by which you can verify if a user has
    the right (permission) to access system resources or invoke certain operations.
    Authorization, therefore, presupposes that authentication has occurred; it would
    be impossible to grant any access control if you don''t know who the user is first.
    Java EE specification provides means to authorize a user''s actions. The authorization
    declarations are usually portable between different application servers. The difference
    between authentication and authorization is depicted in the following diagram:![Approaching
    the Java security API](img/00079.jpeg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In Java EE, the containers are responsible for providing application security.
    A container basically provides two types of security: declarative and programmatic.
    Let''s take a look at both of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Declarative security**: This expresses an application component''s security
    requirements by means of deployment descriptors. Because deployment descriptor
    information is contained in an external file, it can be changed without the need
    to modify the source code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For example, Enterprise JavaBeans components use an EJB deployment descriptor,
    which must be named `ejb-jar.xml` and placed in the `META-INF` folder of the EJB
    JAR file.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Web components use a web application deployment descriptor named `web.xml`,
    which is located in the `WEB-INF` directory.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Since the release of Java EE 5, you can apply declarative security by means
    of annotations just like we have for other key APIs (EJB, web services, and so
    on). Annotations are specified within a class file, and when the application is
    deployed, the application server translates this information internally.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Programmatic security**: This is embedded in an application and used to make
    security decisions. It can be used when declarative security alone is not sufficient
    to express the security model of an application. The Java EE security API allows
    the developer to test whether or not the current user has access to a specific
    role, using the following calls:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`isUserInRole()` for servlets and JSPs (adopted in `javax.servlet.http.HttpServletRequest`)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`isCallerInRole()` for EJBs (adopted in `javax.ejb.SessionContext`)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Additionally, there are other API calls that provide access to the user''s
    identity, which are as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`getUserPrincipal()` for servlets and JSPs (adopted in `javax.servlet.http.HttpServletRequest`)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getCallerPrincipal()` for EJBs (adopted in `javax.ejb.SessionContext`)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Using these APIs, you can develop arbitrarily complex authorization models.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The WildFly security subsystem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'WildFly security qualifies as an extension to the application server and is
    included, by default, both in standalone and domain servers using the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'WildFly defines security policies using two terms: security realms and security
    domains. Security realms are configuration sets mapped to external connectors
    (for example, EJB remoting and management interface). They allow every connection
    type to have its own appropriate authentication and authorization properties defined.
    For instance, both management and application realms define two separate files,
    which store the allowed usernames. Additionally, the application realm contains
    a reference to a file that defines user role.'
  prefs: []
  type: TYPE_NORMAL
- en: The configuration defined in the security realm is then passed to a security
    domain requested by the deployed application. The security domain defines a set
    of login modules that are responsible for checking the user's credentials and
    creating a security principal representing the client (along with a set of roles
    for the requester).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an extract from the default security subsystem contained in
    the server configuration file, which contains the `RealmDirect` login that will
    be used in the next section to secure the Ticket example application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Configuration files are defined in the security realm using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the configuration is pretty short as it relies largely on default
    values, especially for high-level structures such as the security management area.
    By defining your own security management options, you could, for example, override
    the default authentication/authorization managers with your implementations. Since
    it is likely that you will not need to override these interfaces, we will rather
    concentrate on the `security-domain` element, which is the core aspect of WildFly
    security.
  prefs: []
  type: TYPE_NORMAL
- en: A security domain can be thought of as a Customs Office for foreigners. Before
    the request crosses WildFly borders, the security domain performs all the required
    authentication and authorization checks and eventually notifies if he/she can
    proceed or not.
  prefs: []
  type: TYPE_NORMAL
- en: Security domains are generally configured at server startup and subsequently
    bound into the JNDI tree under the key `java:/jaas/`. Within the security domain,
    you can configure login authentication modules so that you can easily change your
    authentication provider by simply changing its `login-module` element.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several implementations of login modules available out of the box;
    there is obviously not enough room here to describe in detail the features of
    each module, though we will offer a comprehensive description of some popular
    options, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: The `RealmDirect` login module, which can be used for basic file-based authentication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Database` login module, which checks user credentials against a relational
    database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Should you need further information about login modules, check out the WildFly
    documentation at:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.jboss.org/author/display/WFLY8/Security+subsystem+configuration](https://docs.jboss.org/author/display/WFLY8/Security+subsystem+configuration)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://docs.jboss.org/author/display/WFLY8/Security+Realms](https://docs.jboss.org/author/display/WFLY8/Security+Realms)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up your first login module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the following section, we will demonstrate how to secure an application
    using the `RealmDirect` security domain, which was introduced earlier. The `RealmDirect`
    login module is based on the following two files:'
  prefs: []
  type: TYPE_NORMAL
- en: '`application-users.properties`: This contains the list of usernames and passwords'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`application-roles.properties`: This contains the mapping between the users
    and their roles'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These files are located in the application server configuration folder and
    they are updated each time you add a new user via the `add-user.sh/add-user.cmd`
    script. For our purpose, we will create a new application user named `demouser`,
    which belongs to the role `Manager`, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up your first login module](img/00080.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Once the user is added, the `application-users.properties` file will contain
    the username and the MD5 encoding of the password, shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Conversely, the `application-roles.properties` file will contain the roles
    granted to the `demouser` username once logged in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Using the login module in the Ticket web application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can now apply the `RoleDirect` login module in the Ticket web application
    described in [Chapter 4](part0028_split_000.html#page "Chapter 4. Learning Context
    and Dependency Injection"), *Learning Context and Dependency Injection* (you could
    pick the version from another chapter if you like). We will first show how to
    provide a BASIC web authentication, and then we will show a slightly more complex
    example using FORM-based authentication.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: BASIC-access authentication is the simplest way to provide a username and password
    when making a request through a browser.
  prefs: []
  type: TYPE_NORMAL
- en: It works by sending an encoded string containing the user credentials. This
    Base64-encoded string is transmitted and decoded by the receiver, resulting in
    colon-separated username and password strings. When it comes to safety, BASIC
    authentication is usually not the best solution. The password can be stolen during
    the transmission, so SSL is a must in order to protect it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Turning on web authentication requires the `security-constraints` element to
    be defined in the web application configuration file (`web.xml`), as shown in
    the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This configuration will add a security constraint on any JSP/servlet of the
    web application that will restrict access to users authenticated with the role
    `Manager`. All login modules shown in the earlier section define this role, so
    you can just use the login module that suits your needs best.
  prefs: []
  type: TYPE_NORMAL
- en: 'From Java EE 7, there are two more methods to express your security constraints.
    Firstly, you can use a new container provided role: `**`. It indicates that you
    are referring to any authenticated user, without taking its roles into account.'
  prefs: []
  type: TYPE_NORMAL
- en: The second one is the `deny-http-uncovered-methods` tag, which can be used in
    a `web.xml` file to forbid access to every HTTP method that is not covered by
    a separate security constraint.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next configuration tweak needs to be performed on the JBoss web deployment''s
    descriptor, `WEB-INF/jboss-web.xml`. You need to declare the security domain here,
    which will be used to authenticate the users. Since we are using `RealmDirect`,
    which is part of the other built-in login module, we will need to include the
    `java:/jaas/other` context information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The following diagram illustrates the whole configuration sequence applied
    to a `Database` login module:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the login module in the Ticket web application](img/00081.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Once you have deployed your application, the outcome should be a blocking pop
    up requesting user authentication. The window will look a little different on
    every browser and its appearance cannot be changed.
  prefs: []
  type: TYPE_NORMAL
- en: Logging in with `demouser` username and the valid password will grant access
    to the application with the `Manager` role.
  prefs: []
  type: TYPE_NORMAL
- en: Switching to FORM-based security
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'FORM-based authentication lets developers customize the authentication user
    interface, adapting it, for example, to your company''s standards. Configuring
    it in your application requires you to basically modify just the `login-config`
    stanza of the security section of your `web.xml` file. Within it, we will define
    a login landing page (`login.xhtml`) and an error page (`error.xhtml`), in case
    the login fails. The code snippet for it is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The login form must contain fields to enter a username and password. These
    fields must be named `j_username` and `j_password`, respectively. The authentication
    form should post these values to the `j_security_check` logical name. All these
    names beginning with `j_` are standardized by the Java Servlet specification—we
    just need to follow the convention in order to let the automatic mechanisms work.
    Here''s a simple `login.xhtml` page, which can be used to pass the required values
    to the security system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: For the sake of brevity, we won't include the error page, which will simply
    alert that the user entered an incorrect combination of username and password.
    The expected outcome is the following login screen, which will intercept all user
    access to your application and grant access to the default home page if the `username`
    and `password` credentials are correct.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Database login module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `UserRoles` login module is a good starting point to learn how to put together
    all the pieces required to secure a web application. In real-world cases, there
    are better alternatives to protect your applications, such as the `Database` login
    module. A database security domain follows the same logic exposed in the earlier
    example; it just stores the credentials within the database. In order to run this
    example, we will refer to a data source defined in [Chapter 5](part0030_split_000.html#page
    "Chapter 5. Combining Persistence with CDI"), *Combining Persistence with CDI*
    (bound at the JNDI name `java:jboss/datasources/wflydevelopment`), which needs
    to be deployed on the application server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to get this configuration working, you have to first create the required
    tables and insert some sample data in it using the following queries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the `admin` user will map again to the `Manager` role. One caveat
    of this configuration is that it uses clear text passwords in the database; so
    before rolling this module into production, you should consider adding additional
    security to your login module. Let's see how to do this in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Encrypting passwords
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Storing passwords in the database as a clear text string is not considered a
    good practice; as a matter of fact, a database has even more potential security
    holes than a regular filesystem. Imagine, for example, that a DBA added a public
    synonym for some tables, forgetting that one of those tables held sensitive information
    such as application passwords, as shown in the following screenshot! You then
    need to be sure that no potential attackers will ever be able to deliver the following
    query.
  prefs: []
  type: TYPE_NORMAL
- en: '![Encrypting passwords](img/00082.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Fortunately, securing application passwords is relatively easy; you can add
    a few extra options to your login module, specifying that the stored passwords
    are encrypted using a message digest algorithm. For example, in the `Database`
    login module, you should add the following highlighted options at the bottom:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Here, we specified that the password will be hashed against an SHA hash algorithm;
    alternatively, you can use any other algorithm allowed by your JCA provider.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For an excellent introduction to hashing algorithms, refer to [http://www.unixwiz.net/techtips/iguide-crypto-hashes.html](http://www.unixwiz.net/techtips/iguide-crypto-hashes.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'For the sake of completeness, we include a small application as follows, which
    generates the Base64 hashed password that is to be inserted in `Database`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the main program with `admin` as the argument will generate the hash
    `jGl25bVBBBW96Qi9Te4V37Fnqchz/Eu4qB9vKrRIqRg=`. This hash will be your updated
    password, which needs to be updated in your database, as shown in the following
    screenshot. Update the password using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: You can update it with any SQL client of your choice.
  prefs: []
  type: TYPE_NORMAL
- en: '![Encrypting passwords](img/00083.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Using the Database login module in your application
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Once you are done with the login module configuration, don''t forget to reference
    it through the JBoss web deployment''s descriptor, `WEB-INF/jboss-web.xml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Securing EJBs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Be careful! There is more than one `SecurityDomain` API available. You have
    to include `org.jboss.ejb3.annotation.SecurityDomain`. The `@RolesAllowed` annotation,
    on the other hand, needs to import `javax.annotation.security.RolesAllowed`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The JBoss-specific annotations can be found in the following maven dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Annotations can also be applied at the method level; for example, if we want
    to secure just the `bookSeat` object of the `TheatreBookerBean` class, we will
    tag the `bookSeat` method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'What if you don''t want to use annotations to establish security roles? For
    example, if you have a security role that is used crosswise by all your EJB applications,
    perhaps it is simpler to use a plain old XML configuration instead of tagging
    all EJBs with annotations. In this scenario, you have to declare the security
    constraints first in the generic `META-INF/ejb-jar.xml` file, shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, inside the `META-INF/jboss-ejb3.xml` configuration file, just add a reference
    to your security domain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s a snapshot illustrating the role configuration of the EJB file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Securing EJBs](img/00084.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you want to use a login module via EJB remoting, you must configure your
    security realm accordingly using the JAAS entry, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Additionally, you should place the following entries in `jbossyourjboss-ejb-client-properties`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: These entries will ensure (besides passing the credentials), that the transmitted
    password will not be additionally hashed by the remoting mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: Securing web services
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Web service authorization can basically be carried out in two ways, depending
    on whether we are dealing with a POJO-based web service or an EJB-based web service.     Security changes to POJO web services are identical to those we introduced for
    servlets/JSP, consistent in defining the `security-constraints` element in `web.xml`
    and the login modules in `jboss-web.xml`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are using a web client to access your web service, it is all you need
    to get authenticated. If you are using a standalone client, you will need to specify
    the credentials in the JAX-WS Factory. The following is an example of how to access
    the secured `CalculatePowerService` instance, which was described in [Chapter
    7](part0038_split_000.html#page "Chapter 7. Adding Web Services to Your Applications"),
    *Adding Web Services to Your Applications*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'What about EJB-based web services? The configuration is slightly different;
    since the security domain is not specified in web descriptors, we have to provide
    it by means of annotations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the `@org.jboss.ws.api.annotation.Webcontext` annotation basically
    reflects the same configuration options as that of POJO-based web services, with
    BASIC authentication and unrestricted WSDL access.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `@WebContext` annotation can be found in the following dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The `@org.jboss.ejb3.annotation.SecurityDomain` annotation should be familiar
    to you since we introduced it to illustrate how to secure an EJB. As you can see,
    it's a replacement for the information contained in the `jboss-web.xml` file,
    except that the security domain is referenced directly by `dbdomain` (instead
    of `java:/jaas/dbdomain`).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The previous security configuration can also be specified by means of the `META-INF/ejb-jar.xml`
    and `META-INF/jboss-ejb3.xml` file in case you prefer using standard configuration
    files.
  prefs: []
  type: TYPE_NORMAL
- en: 'To pass your login credentials to the web service, you can use the `RequestContext`
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The username and password values will be passed to the login module defined
    in the security domain, just like in every other authentication method.
  prefs: []
  type: TYPE_NORMAL
- en: Securing the transport layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you were to create a mission-critical application with just the bare concepts
    you learned until now, you would be exposed to all sorts of security threats.
    For example, if you need to design a payment gateway, where the credit card information
    is transmitted by means of an EJB or servlet, using just the authorization and
    authentication stack is really not enough, as the sensitive information is still
    sent across a network and it could be disclosed by a hacker.
  prefs: []
  type: TYPE_NORMAL
- en: In order to prevent disclosure of critical information to unauthorized individuals
    or systems, you have to use a protocol that provides encryption of the information.
    Encryption is the conversion of data into a form that cannot be understood by
    unauthorized people. Conversely, decryption is the process of converting encrypted
    data back into its original form so that it can be understood.
  prefs: []
  type: TYPE_NORMAL
- en: The protocols used to secure the communication are SSL and TLS, the latter being
    considered a replacement for the older SSL.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The differences between the two protocols are minor and very technical. In
    short, TLS uses stronger encryption algorithms and has the ability to work on
    different ports. For the rest of this chapter, we will refer to SSL for both protocols.
    Check out Wikipedia for more information on it: [http://en.wikipedia.org/wiki/Transport_Layer_Security](http://en.wikipedia.org/wiki/Transport_Layer_Security).'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two basic techniques to encrypt information: symmetric encryption
    (also called secret-key encryption) and asymmetric encryption (also called public-key
    encryption).'
  prefs: []
  type: TYPE_NORMAL
- en: Symmetric encryption is the oldest and best-known technique. It is based on
    a secret key, which is applied to the text of a message to change the content
    in a particular way. As long as both the sender and recipient know the secret
    key, they can encrypt and decrypt all messages that use this key. These encryption
    algorithms typically work fast and are well suited to encrypt blocks of messages
    at once.
  prefs: []
  type: TYPE_NORMAL
- en: One significant issue with symmetric algorithms is the requirement of a safe
    administrative organization to distribute keys to users. This generally results
    in increased overhead from the administrative aspect while the keys remain vulnerable
    to unauthorized disclosure and potential abuse.
  prefs: []
  type: TYPE_NORMAL
- en: For this reason, a mission-critical enterprise system usually relies on the
    asymmetric encryption algorithms, which tend to be easier to employ, manage, and
    are ultimately more secure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Asymmetric cryptography, also known as **public-key cryptography**, is based
    on the concept that the key used to encrypt is not the same as the key that is
    used to decrypt the message. In practice, each user holds a couple of keys: the
    public key that is distributed to other parties and the private key that is kept
    as a secret. Each message is encrypted with the recipient''s public key and can
    only be decrypted (by the recipient) with his private key, as shown in the following
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Securing the transport layer](img/00085.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Using asymmetric encryption, you can be sure that your message cannot be disclosed
    to a third party. However, there is still one vulnerability.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose you want to exchange some valuable information with a business partner
    and to that end are requesting his public key by telephone or email. A fraudulent
    user intercepts your e-mail or simply listens to your conversation and quickly
    sends you a fake mail with his public key. Now, even if your data transmission
    is secured, it will be directed to the wrong person!
  prefs: []
  type: TYPE_NORMAL
- en: In order to solve this issue, we need a document to verify that the public key
    belongs to a particular individual. This document is called a **digital certificate**
    or public-key certificate. A digital certificate consists of a formatted block
    of data that contains the name of the certificate holder (which may be either
    a user or system name) and the holder's public key, along with the digital signature
    of a **Certification Authority** (**CA**) for authentication. The CA attests that
    the sender's name is the one associated with the public key in the document.
  prefs: []
  type: TYPE_NORMAL
- en: '![Securing the transport layer](img/00086.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Public key certificates are commonly used to secure the interaction with websites.
    By default, the web browser ships with a set of predefined CAs; they are used
    to verify that the public certificate served to a browser when you enter a secure
    site has actually been issued by the owner of the website. In short, if you connect
    your browser to `https://www.abc.com` and your browser doesn't give any certificate
    warning, you can safely interact with the entity in charge of the site, that is,
    unless the site or your browser has been hacked. However, this is another story.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Simple authentication and client authentication**'
  prefs: []
  type: TYPE_NORMAL
- en: In the previous example, we depicted a simple authentication, (also called server
    authentication). In this scenario, the only party that needs to prove its identity
    is the server.
  prefs: []
  type: TYPE_NORMAL
- en: SSL, however, is able to perform mutual authentication (also called client or
    two-way authentication); here too, the server requests a client certificate during
    the SSL handshake over the network.
  prefs: []
  type: TYPE_NORMAL
- en: Client authentication requires a client certificate in the x.509 format from
    a CA. The x.509 format is an industry-standard format for SSL certificates. In
    the next section, we will explore which tools are available to generate digital
    certificates, and how to get your certificates signed by a CA.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling the Secure Socket Layer on WildFly
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: WildFly uses the **Java Secure Socket Extension** (**JSSE**), which is bundled
    in the Java SE to leverage the SSL/TLS communication.
  prefs: []
  type: TYPE_NORMAL
- en: 'An Enterprise application can be secured at two different locations: the HTTP
    level for web applications, and the RMI level for applications using EJB. HTTP
    communication is handled by the web subsystem within the `standalone.xml`/`domain.xml`
    file. Securing the RMI transport is, on the other hand, not always a compelling
    requirement of your applications. Actually, in most production environments, WildFly
    is placed behind a firewall.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see from the following diagram, this implies that your EJBs are
    not directly exposed to untrusted networks, which usually connect through the
    web server placed in a demilitarized zone:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Enabling the Secure Socket Layer on WildFly](img/00087.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: In order to get started with WildFly and SSL, we need a tool that generates
    a public/private key pair in the form of an x.509 certificate for use by the SSL
    server sockets. This is covered in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Certificate management tools
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One tool that can be used to set up a digital certificate is **keytool**, a
    key and certificate management utility that ships with the Java SE. It enables
    users to administer their own public/private key pairs and associated certificates
    for use in self-authentication (where the user authenticates himself or herself
    to other users or services) or data integrity and authentication services, using
    digital signatures. It also allows users to cache the public keys (in the form
    of certificates) of their communicating peers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The keytool stores the keys and certificates in a file termed keystore, a repository
    of certificates used to identify a client or server. Typically, a keystore contains
    a client or server''s identity, which is protected by a password. Let''s see an
    example of the keystore generation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This command creates the keystore named `wildfly.keystore` in the working directory,
    and assigns it the password `mypassword`. It generates a public/private key pair
    for the entity whose unique name has the common name `John Smith`, organization
    `PacktPub`, and two-letter country code `GB`.
  prefs: []
  type: TYPE_NORMAL
- en: The result of this action will be a self-signed certificate (using the RSA signature
    algorithm), which includes the public key and the unique name. This certificate
    will be valid for 180 days, and is associated with the private key in a keystore
    entry referred to by the alias `wflyalias`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A self-signed certificate is a certificate that has not been verified by a CA
    and thus, leaves you vulnerable to the classic man-in-the-middle attack. A self-signed
    certificate is only suitable for in-house use or for testing while you wait for
    your real certificate to arrive.
  prefs: []
  type: TYPE_NORMAL
- en: Securing the HTTP communication with a self-signed certificate
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now let's see how you can use this keystore file to secure your WildFly web
    channel. Open your server configuration file and locate the web subsystem.
  prefs: []
  type: TYPE_NORMAL
- en: 'Within the web subsystem, you have to first change the default `http-listener`
    and `socket-binding` to `https-listener` and `"https"`, and add the `security-realm`
    element to it. Next, you have to insert an `ssl` stanza within it, which contains
    the details of your `keystore` object (in our example, we dropped the file `jboss.keystore`
    into the server configuration directory):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we referenced `EJBRealm` in the configuration, but we still
    need to define it. We will do this in the next sections.
  prefs: []
  type: TYPE_NORMAL
- en: Generating the server and client certificates
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Start by generating a public/private key pair for the entity whose unique name
    has the common name `John Smith`, organization `PacktPub`, and two-letter country
    code `GB`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Next, export the server's public key into a certificate named `sslPublicKey.cer`
    that uses the password `mypassword`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have finished configuring the server, we will generate a key pair
    for the client too. We will do this by using the alias `ejbclientalias` and the
    same properties as we did for the server''s `keystore` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The client public key will also be exported to a certificate named `clientPublicKey.cer`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, in order to complete the SSL handshake successfully, we need to first
    import the client''s public key into the server''s `truststore` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The server certificate also needs to be trusted by the client. You have two
    available options to solve this issue, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Import the server certificate into the client's JDK bundle of certificates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a new repository of certificates trusted by the client (`truststore`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Importing the server certificate into the client JDK means executing a certificate
    import into the client's certified authorities.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: We just have to replace the path we used with our actual JDK path and use the
    client store's password in order to complete this operation (the default value
    is `changeit`).
  prefs: []
  type: TYPE_NORMAL
- en: Otherwise, if you want to import the certificate into a newly created `truststore`
    object, just substitute the `cacerts` destination with your client's `truststore`
    object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you choose the latter option, you need to add the following properties to
    your client''s JDK arguments, which will override the default JDK''s `truststore`
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Creating an SSL-aware security realm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Within WildFly, security realms are used to secure access to the management
    interfaces, HTTP interface, and remote JNDI and EJB access. Within a security
    realm, it is also possible to define an identity for the server; this identity
    can be used for both inbound connections to the server and outbound connections
    being established by the server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, in order to enable SSL communication for our EJB communication and
    HTTP, we will define a security realm (named `EJBRealm`) that is bound to a server
    identity, which references the server''s `keystore` object, shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Besides containing the location where SSL certificates are stored, this security
    realm also contains the authentication policy used by your EJBs, which is defined
    by the JAAS's security domain, named `ejb-security-domain`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a security domain definition, which is a simple file-based
    security domain containing the user credentials and roles in the files `ejb-users.properties`
    and `ejb-roles.properties`, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can imagine, you need to create the two property files, each with some
    values in them. For example, here''s the `ejb-user.properties` file to be placed
    in the server configuration''s folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the corresponding `ejb-roles.properties` file that grants
    the role `ejbRole` to the `adminUser` role:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The last configuration effort would be to specify it in the `security-realm`
    attribute of your `remoting` connector''s element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Let's check the outcome of our work. First, we will try out the HTTPS connection.
  prefs: []
  type: TYPE_NORMAL
- en: 'You have to restart WildFly to activate the changes. You should see the following
    log at the bottom of your console, which informs you about the new HTTPS channel
    running on port 8443:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screen is what will be displayed by the Internet Explorer (don''t
    try this at home) browser (the same kind of error message, with a different format,
    will be displayed by other browsers such as Firefox and Google Chrome) if you
    try to access the Ticket example using the secured channel (for example, `https://localhost:8443/ticket-agency-cdi`):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating an SSL-aware security realm](img/00088.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: What happened? Once you establish a secure connection with the web server, the
    server certificate is sent to the browser. Since the certificate has not been
    signed by any recognized CA, the browser security sandbox warns the user about
    the potential security threat.
  prefs: []
  type: TYPE_NORMAL
- en: This is an in-house test so we can safely proceed by choosing **Continue to
    this website**. That's all you need to do in order to activate the Secure Socket
    Layer with a self-signed certificate.
  prefs: []
  type: TYPE_NORMAL
- en: Securing HTTP communication with a certificate signed by a CA
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Having your certificate signed requires a **certificate-signing request** (**CSR**)
    to be issued to a CA, which will return a signed certificate to be installed on
    your server. This implies a cost for your organization, which depends on how many
    certificates you request, the encryption strength, and other factors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Firstly, generate a CSR using the newly created `keystore` and keyentry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'This will create a new certificate request named `certreq.csr`, bearing the
    following format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous certificate needs to be transmitted to the CA. At the end of the
    enrollment phase, the CA will return a signed certificate, which needs to be imported
    into your keychain. The following code assumes you saved your CA certificate in
    a file named `signed_ca.txt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Now, your web browser will recognize your new certificate as being signed by
    a CA, so it won't complain about not being able to validate the certificate.
  prefs: []
  type: TYPE_NORMAL
- en: Securing EJB communication
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: EJB clients interact with the Enterprise EJB tier using the RMI-IIOP protocol.
    The RMI-IIOP protocol has been developed by Sun to combine the RMI programming
    model with the IIOP underlying transport.
  prefs: []
  type: TYPE_NORMAL
- en: 'Securing the EJB transport is required for applications that have strict secure
    policies, which cannot be carried out using clear text transmission. In order
    to do this, we need to be sure to complete the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: First, generate the SSL certificates and then store the client's public key
    in the server's `keystore` object and the server's public key on the client's
    `truststore;` we've already done this in order to prepare our HTTPS connector.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we need to create an SSL-aware security realm, which will be used by the
    `remoting` transport. We can use the one created for the HTTPS communication.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we need to apply some changes to our EJB application so that it actually
    uses the SSL secure channel. We will cover this in the next subsection.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connecting to an SSL-aware security realm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As you saw in [Chapter 3](part0023_split_000.html#page "Chapter 3. Introducing
    Java EE 7 – EJBs"), *Introducing Java EE 7 – EJBs*, the RMI-IIOP connection properties
    are specified in the `jboss-ejb-client.properties` file, which needs to be tweaked
    a bit to enable SSL connections:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The `SSL_ENABLED` option, when set to `true`, enables the `remoting` connector's
    SSL communication.
  prefs: []
  type: TYPE_NORMAL
- en: The `STARTTLS` option specifies whether to use the **Tunneled Transport Layer
    Security** (**TTLS**) mode at startup or when needed.
  prefs: []
  type: TYPE_NORMAL
- en: The `SASL_POLICY_NOANONYMOUS` option specifies whether **Simple Authentication
    and Security Layer** (**SASL**) mechanisms, which accept anonymous logins, are
    permitted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, since our security realm also includes an authentication security
    domain, we can choose to restrict access to some methods by specifying a `@RolesAllowed`
    annotation, which requires the role `ejbRole`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to activate the security domain on your EJBs, we need to mention it
    in the assembly descriptor of your `jboss-ejb3.xml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Now, redeploy the Ticket EJB example application, following the directions contained
    in [Chapter 3](part0023_split_000.html#page "Chapter 3. Introducing Java EE 7
    – EJBs"), *Introducing Java EE 7 – EJBs*, and execute the client.
  prefs: []
  type: TYPE_NORMAL
- en: If the connection is successful, then you have configured a fully working and
    secured remoting connection.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We started this chapter by discussing the basic concepts of security and the
    difference between authentication and authorization.
  prefs: []
  type: TYPE_NORMAL
- en: WildFly uses the PicketBox framework sitting on top of the **Java Authentication
    and Authorization Service** (**JAAS**), which secures all the Java EE technologies
    running in the application. The core section of the security subsystem is contained
    in the security-domain element that performs all the required **authorization**
    and **authentication** checks.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we took a much closer look at the login modules, which are used to store
    the user credentials and their associated roles. In particular, you learned how
    to apply the file-based `UserRoles` login module and the `Database` login module.
    Each login module can be used by Enterprise applications in either a programmatic
    or declarative way. While programmatic security can provide a fine-grained security
    model, you should consider using declarative security, which allows a clean separation
    between the business layer and the security policies.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, in the last section of this chapter, we covered how to encrypt the
    communication channel using the Secure Socket Layer and the certificates produced
    by the `keytool` Java utility.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to discuss clustering, which is the environment
    where critical applications are deployed.
  prefs: []
  type: TYPE_NORMAL
