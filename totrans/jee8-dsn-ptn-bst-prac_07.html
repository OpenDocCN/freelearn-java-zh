<html><head></head><body><div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Microservice Patterns</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">In this chapter, we will learn about what microservices patterns are. We will also compare these with the monolithic patterns, looking at the advantages and drawbacks of a microservices-based application, as well as learn when to use microservices. Furthermore, we will also demonstrate how to switch from a traditional monolithic application to a microservices application, using implementation <span class="calibre10">examples</span><span class="calibre10"> </span><span class="calibre10">throughout. We will then look at the design patterns used to compose the microservices. After reading this chapter, you will be able to identify the parts of an application code that are eligible to be microservices, and you will also know how to implement a microservices-pattern-based application using Java EE 8.</span></p>
<p class="mce-root"><span class="calibre10">The following topics will be covered in this chapter:</span></p>
<ul class="calibre15">
<li class="calibre16"><span class="calibre5">Explaining microservices patterns</span></li>
<li class="calibre16">Explaining how microservices architecture works</li>
<li class="calibre16">Explaining when to use microservices architecture</li>
<li class="calibre16">Advantages and drawbacks of a microservices-based application</li>
<li class="calibre16">Microservices architecture patterns</li>
<li class="calibre16">Implementing microservices</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Explaining microservices patterns</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Many years ago, I had the opportunity to work as a system architect and developer on an administrative–financial system. This involved the use of modules, such as accounts receivable and accounts payable, inventory control, purchasing, payroll, accounting, and so on.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root">The whole system was composed of several modules, and the delivery of the system was constructed in a modular way too. At the end of the application development, we had a large, integrated system with many dependencies between the modules. It was obvious that the system should be integrated, and we knew that very well. However, this integration was made with many dependencies and a strong coupling between modules. Sometime later, we also discovered that the dependencies and strong coupling were unnecessary.</p>
<p class="mce-root">We faced a lot of problems in maintaining the application (such as difficulty in implementing new frameworks and excessive bureaucracy), including the fact that whenever there was a need to include a functionality that originated from a requirement, we had to find the part of the code that was responsible for the problem, make the change, test it, and make a redeployment of the entire application. In addition to this, other related issues <span class="calibre10">sometimes</span><span class="calibre10"> a</span><span class="calibre10">ppeared, such as using a third-party library or framework to implement this new functionality. There was a bit of bureaucracy to that too. In short, a lot of time was spent on changing the application, and this only got worse as the application became larger.</span></p>
<p class="mce-root">After the system was ready, we wondered what it would be like if each module had its own life—that is, if each module behaved as a mini-application, so that it could be deployed without impacting the other modules. Furthermore, if each module could be developed practically in parallel, and there was minimum coupling required, then that would be very beneficial to the development and maintenance of the application.</p>
<p class="mce-root">Bringing it back to the present day, we noticed that among the several characteristics <span class="calibre10">that are most often desired</span> for the components of a system, we can highlight low coupling, which guarantees parallel development and much better maintenance.</p>
<p class="mce-root">There is an architecture pattern called <em class="calibre12">microservices architecture</em> that partitions the application into several small services that have specific functions or responsibilities with very low coupling between these services, and which provides very good features, such as excellent evolutionary maintenance. </p>
<p class="mce-root">When it comes to an architecture that is based on microservices, it is much easier to implement each of the modules of the administrative–financial application as mini-applications. An accounts payable module, for example, would need its front end, and would depend on the combination of some microservices (such as a service that provides the constant accounts, another that provides the variable accounts, another that provides the payroll, and so on) in order to work.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root">Of course, there are advantages and drawbacks to the microservices-based approach, and we should look closely at an application to determine whether it is worth using this architecture. The architecture based on microservices acts as a counterpoint to the traditional monolithic architecture in which the modules are much more coupled. So to discuss the architecture of microservices and establish a better definition of what microservices are, we must talk about monolithic architecture. This is exactly what we will do next.</p>
<p class="mce-root">Here is a brief comparison between microservices and SOA. Some people like to refer to microservices architecture as a lightweight SOA. Both architectures aim to break a monolithic scenario to increase scalability and maintenance. However, while SOA is enterprise-oriented, where applications can speak more easily, microservices are small, integrated services that form one or more business functionalities. This is the main difference—microservices are the result of the <span class="calibre10">functional</span><span class="calibre10"> </span><span class="calibre10">decomposition of a monolithic application into small, smart, and loosely coupled (such as SOA) components with well-defined responsibilities and easy maintenance.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Inside a monolithic application</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">A typical application contains a presentation layer, which is the client side of the application, a persistence layer or database, and an intermediary layer, which is the server side of the application and contains the business logic. The layer that interests us is the intermediary layer. This receives the requests from the client layer, performs some business logic, <span class="calibre10">accesses the database if necessary (executing queries and updates),</span> and provides the result to the client layer.</p>
<p class="mce-root">This server-side layer generally consists of several modules or services. Although the application has a modular architecture, t<span class="calibre10">he application is deployed and packaged as a monolithic block. Modules represented by classes and files are contained in packaging files (EAR, WAR). These files are deployed together and belong to the same deployment.</span> Most Java-based applications are packaged in a single <kbd class="calibre18">.war</kbd> or <kbd class="calibre18">.ear</kbd> file.</p>
<p class="mce-root">The following diagram shows an example of an academic–financial system in a college:</p>
<p class="cdpaligncenter2"><img src="Images/3be57cdf-3210-4813-837b-ca04056c6012.png" width="695" height="353" class="calibre67"/></p>
<p class="mce-root">The various <span class="calibre10">modules of the application are deployed to a single file on the <strong class="calibre8">Application Server</strong>. Generally, the application runs in a single process:</span></p>
<p class="cdpaligncenter2"><img src="Images/62b64fd4-034f-49ee-b55a-2c9d32ee4075.png" width="608" height="182" class="calibre68"/></p>
<p class="mce-root">For simple applications with a limited number of business tasks, the monolithic way of doing things such as coding (there is usually only one language for server-side coding, and there is a unique data persistence technology), testing, and deploying is also fairly simple. However, some serious problems appear as the application begins to grow in complexity and the microservices will also be used to solve these problems. Later in this chapter, we will have a specific section showing the advantages and drawbacks of microservices architecture.</p>
<p class="mce-root"/>
<p class="mce-root">Here are some of these problems:</p>
<ul class="calibre15">
<li class="calibre16">Difficulty in implementing new features and fixing bugs</li>
<li class="calibre16"><span class="calibre5">Long application startup time </span></li>
<li class="calibre16"><span class="calibre5">Inefficient continuous deployment</span></li>
<li class="calibre16"><span class="calibre5">Low reliability</span></li>
<li class="calibre16"><span class="calibre5">Difficulty using new frameworks and technologies</span></li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Difficulty in implementing new features and fixing bugs</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Over the years, the application grows and more lines of code are added to preexisting codes. Even when approaching the code with caution using the best object-oriented practices and patterns (low coupling and code reuse), the number of classes and libraries tends to grow. Maintenance becomes much more difficult. Common problems may arise, such as an increase in the responsibilities of some classes. This issue is more critical because the development team always changes. The code becomes more difficult to understand and some required changes can be <span class="calibre10">made </span><span class="calibre10">incorrectly</span><span class="calibre10">. As a consequence of this, we have a delay in implementation.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Long application startup time </h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">As an application gets bigger (more classes, libs, and files), its initialization slows down, and the developer will take a lot of time to start up the application. Doing this several times a day greatly increases development time, so this is another factor that impacts the maintenance of the application.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Inefficient continuous deployment</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">For each required change in the application, you need to deploy it in its entirety. Continuous deployment is very difficult because every time a part of the code is changed, the entire application must be deployed. Of course, in a test environment, you can group multiple changes together and make a single deployment. However, this is still inefficient as it requires all implementations to be completed. This scenario becomes worse for applications that require a deployment to be in production several times a day.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Low reliability</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">The modules of a monolithic application usually run in the same process. Any error or bug in a module (such as a memory leak) impacts the entire process and, consequently, the entire application. Even if an application is executed with several nodes of the clustering system, and even if there are several instances of the application, the problem can be propagated by the other instances of the application<span class="calibre10"> </span><span class="calibre10">if the error is due to the code</span><span class="calibre10">.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Difficulty using new frameworks and technologies</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">In a large monolithic application with thousands and thousands of lines of written <span class="calibre10">code</span><span class="calibre10">, replacing a framework or even including new features is difficult because it will require changes in many parts of the application. Sometimes we should rewrite almost all of the code; situations like this are very common. The quality of the product does not improve, and the effort to maintain this quality gets much higher because the development team does not have enough time to introduce the new framework.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">The scale cube</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root"><em class="calibre12">The Art of Scalability</em> by Martin L. Abbott and Michael T. Fisher presents a three-dimensional scalability model called the scale cube. See the following diagram for more details:</p>
<p class="cdpaligncenter2"><img src="Images/859f2c4f-d115-455f-9098-74995155afdc.png" width="475" height="295" class="calibre69"/></p>
<p class="mce-root">This model shows that we can scale an application in three different ways, which are listed as follows:</p>
<ul class="calibre15">
<li class="calibre16"><span class="calibre5"><strong class="calibre3"><em class="calibre19">X-</em>axis scaling:</strong> This is the most common model, and proposes the execution of multiple clones of an application under the supervision of a load balancer. This type of scalability is also called <strong class="calibre3">horizontal scalability</strong>, where the solution for meeting the demand is the addition of more servers.</span></li>
<li class="calibre16"><span class="calibre5"><strong class="calibre3"><em class="calibre19">Z-</em>axis scaling:</strong> This is similar to <em class="calibre19">X</em>-axis<em class="calibre19"> </em>scaling (multiple instances running the same code), but in this case, each server takes responsibility for a part of the data. This type of scalability uses the concept of sharding, most commonly in the database.</span></li>
<li class="calibre16"><span class="calibre5"><strong class="calibre3"><em class="calibre19">Y-</em>axis scaling:</strong> This has the strategy of decomposing the application in different services. </span>The architecture of microservices is an example of <em class="calibre19">Y</em>-axis scaling. Using this scalability approach, a monolithic application is decomposed into a set of services. Each service is responsible for a set of related functionalities.</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">What microservices actually are</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">We can define microservices architecture as a way to develop an application using a set of small, low-coupling, independent, and deployable services. Each microservice is very well-defined, meaning that each microservice is responsible for a single task that is well-defined. </p>
<p class="mce-root">So, microservices are small components that perform a specific job and may be used to benefit a business. Therefore, when developing an application under the architecture of microservices, we must break this same application into small components that are the microservices. As well as the other characteristics that we will see later, microservices can be changed and deployed without degrading the application itself.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Microservices are not a silver bullet</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Like any technological solution, there are advantages and drawbacks to microservices, which will be explored later in this chapter. If microservices are applied well, <span class="calibre10">then they will increase the reliability and scalability of an application that grows in complexity. However, the very nature of microservices can bring problems when they are poorly implemented.</span></p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root">The strong independence of microservices means that they can be created using different languages, and can communicate using different protocols and APIs. In addition, an application may contain numerous microservices that are used for the benefit of the business. The plurality and quantity of the microservices make the control of these same microservices quite complex. Some extra care and energy should be taken in the implementation of an application based on microservices architecture.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Explaining how microservices architecture works</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Although there is still no formal model to follow when implementing microservices architecture, we can highlight some common characteristics. We can also verify good practices when developing microservices.</p>
<p class="mce-root">With one or more related functionalities, a microservice is a small portion of the application that is used to benefit the business. From this definition of microservices, we will now look at each of the following common characteristics of microservices in detail:</p>
<ul class="calibre15">
<li class="calibre16">The application is decomposed into smaller components</li>
<li class="calibre16">Multitask teams</li>
<li class="calibre16">Product focus</li>
<li class="calibre16">Simpler and smarter processing.</li>
<li class="calibre16">Decentralized governance of libraries and APIs</li>
<li class="calibre16">Single responsibility principle</li>
<li class="calibre16">Fault tolerance</li>
<li class="calibre16">Evolutionary systems</li>
<li class="calibre16">Decentralized data</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">The application is decomposed into smaller components</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">While developing an application based on microservices architecture, we should consider breaking the application into smaller components that will be changed and deployed separately (as opposed to a monolithic application that must be fully deployed with every change of code). However, splitting an application into small services that act independently requires a longer development time. </p>
<p class="mce-root">The following diagram shows the access of the client of an application to a business component:</p>
<p class="cdpaligncenter2"><img src="Images/799b5bef-8c91-4a3c-af2b-e6feea7000c4.png" width="616" height="340" class="calibre70"/></p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root">The following diagram shows the same client accessing the same functionality via microservices:</p>
<p class="cdpaligncenter2"><img src="Images/106c1994-3abe-45a5-99ff-863d6d9d79c8.png" width="439" height="245" class="calibre71"/></p>
<p class="mce-root">Because microservices are small and independent, they can cause problems with accessing more complex services. These problems are described as follows:</p>
<ul class="calibre15">
<li class="calibre16"><strong class="calibre3">Calls to several microservices to meet a functionality</strong>: Generally, clients need services or functionalities that involve calls to several microservices. For example, in an academic–financial management system, a client who wants rich detail on the history of a college student may have to access many microservices. So, <span class="calibre5">making multiple calls to various microservices reduces network performance, and this is critical when there is a mobile client.</span></li>
<li class="calibre16"><strong class="calibre3">Microservices can use different protocols</strong>: Because microservices are independent, they may require different protocols to be accessed, such as REST, WebSocket, and so on. In other words, there is no uniformity of protocol for accessing microservices, and w<span class="calibre5">e can imagine how time-consuming it would be to have to communicate with each of these microservices.</span></li>
<li class="calibre16"><strong class="calibre3">Different types of clients</strong>: There are different types of clients, such as mobile clients and desktop clients. Each of these clients also has different needs. The amount of information offered to a mobile client is generally less rich than that offered for a desktop client. Another important issue is that network performance is different for these different types of client. A mobile network is slower than a local network.</li>
</ul>
<p class="mce-root">In the following diagram, we can see an example of a set of functionalities that are found in a system and their respective calls to the various microservices of the application:</p>
<p class="cdpaligncenter2"><img src="Images/8cde92e1-8972-4cc2-9d7f-4c92707806b9.png" class="calibre72"/></p>
<p class="mce-root">The price to pay for decomposing an application into a set of microservices is quite clear. Controlling the various calls to microservices is a complex task, and there is still the question of having a single database. In these cases, transaction control becomes more complex.</p>
<p class="mce-root">To meet this set of problems, there is a solution called the API gateway that establishes a type of frontend for the clients of the application based on microservices. The API gateway interposes between clients and microservices. Sometimes, the request is just a call to a microservice, but in other cases, the API gateway functions as a coarse granulation layer that receives the request to a service and makes several calls to microservices.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root">We can see this in the following diagram:</p>
<p class="cdpaligncenter2"><img src="Images/2623eee3-a700-40bd-8100-c6850b72f430.png" class="calibre73"/></p>
<p class="mce-root">Access to the various microservices from the client application works in the same way as if we were using an API. The <strong class="calibre8"><span class="calibre10">API </span>Gateway</strong> is in charge of accessing the different microservices and worrying about the different protocols used for this access. However, depending on the type of client application (whether it is a mobile app or a browser application, for instance), a certain system functionality may be different. For example, if we are in a mobile application, the amount of information that would be consulted in accessing the student's history would be less than a browser application would access (either because the presentation screens are different or because of performance issues in accessing the various microservices). Taking this problem <span class="calibre10">into account, </span><span class="calibre10">besides being an interface layer for microservice calls, </span><span class="calibre10">the API gateway can still offer a specific API for each type of client.</span></p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"><span class="calibre10">So, a client mobile would access a mobile API, while a web client or a browser would access a web API. We can see this in the following diagram:</span></p>
<p class="cdpaligncenter2"><img src="Images/871ac169-b065-4e3e-8341-06e5f81c2cfb.png" class="calibre74"/></p>
<p class="mce-root">In short, the <strong class="calibre8"><span class="calibre10">API G</span>ateway</strong> works as a general translator. So, the client focuses on the business and not on the translation for the requests or the answers. In addition, the client can make one call instead of several calls (if the functionality requires numerous microservices), which effectively improves network performance.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Multitask teams</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">In a monolithic application, there are specialized teams in each part of the application—a database team, a team that develops in the backend (Java), and a design team.</p>
<p class="mce-root">In a microservice-based application, there is a multitask team, which is responsible for all parts of the microservice. Consequently, the team must be a generalist. But we know that even for a monolithic application, the developer often works as a full stack developer, and has the task of developing all parts of the application.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Product focus</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">In a monolithic application, the focus is always the application project, and the code is usually delivered to the application customer. However, in a microservices-based application, the focus is always on the product. The team that is responsible for the microservice can change and evolve the product without the typical delays experienced in a monolithic application. The product belongs to the development team that is responsible for the microservice, as shown in the following diagram:</p>
<div class="cdpaligncenter"><img src="Images/7f03d386-d564-4ae1-92ca-04346ceda145.png" width="442" height="411" class="calibre75"/></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Simpler and smarter processing</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Microservices perform specialized and intelligent tasks through an extremely practical operation—there is a request, something is processed, and a response is returned to the microservice client.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Decentralized governance of libraries and APIs</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Microservices are used and called in one or more points of an application, or they are used by various applications. Furthermore, we must keep in mind the independent nature of microservices. As a result, there is a natural encouragement for the decentralization and governance of APIs and libraries. This means that microservice developers should use the tools that they think are necessary for microservice development, as long as the interface with the client does not change.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Single responsibility principle</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">A microservice should always have a small set of responsibilities. This definition is based on a principle called the single responsibility principle, which states that <em class="calibre12">a class must have only one reason to change</em>. In other words, a class with more than one motive to change would have more responsibilities, and would not be cohesive. This would create problems, such as high coupling between the responsibilities of a class, difficulty in reusing code, and difficult maintenance. </p>
<p class="mce-root">A class that had methods that are responsible for calculation, as well as methods for formatting the result, would be an example of a class with little cohesion. Let's look at the following example:</p>
<pre class="mce-root2">class Insurance {    <br class="calibre2"/>    public double calculateCotation (...) {...}<br class="calibre2"/>    public String generatePDF (...){...}<br class="calibre2"/>    public String generateXLS (...){...}<br class="calibre2"/>}</pre>
<p class="mce-root">The first method (<kbd class="calibre18">calculateCotation</kbd>) is directly related to the business domain and the others (<kbd class="calibre18">generatePDF</kbd> and <kbd class="calibre18">generateXLS</kbd>) are related to the presentation of the calculated values.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<div class="packt_infobox">The SRP principle is part of a set of five principles called SOLID principles, which were popularized by Robert Cecil Martin (colloquially known as Uncle Bob) after the publication of his book <em class="calibre19">Agile Software Development: Principles, Patterns, and Practices</em>. In fact, these five principles are a subset of several principles reported in the book. The SOLID principles are principles of object-oriented programming, a paradigm whose purpose is to keep code more organized and easy to read. We can make an association between the word "solid" and the expression "solid code". Each of the five letters of the acronym SOLID is an initial of a principle:<br class="calibre2"/>
<br class="calibre2"/>
 <strong class="calibre3">S</strong>ingle responsibility principle (SRP)<br class="calibre2"/>
<strong class="calibre3"> O</strong>pen closed principle (OCP)<br class="calibre2"/>
<strong class="calibre3"> L</strong>iskov substitution principle (LSP)<br class="calibre2"/>
<strong class="calibre3"> I</strong>nterface segregation principle (ISP)<br class="calibre2"/>
<strong class="calibre3"> D</strong>ependency inversion principle (DIP)</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Fault tolerance</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Because an application is now decomposed into multiple microservices, there is a greater chance of failure because one or more microservices can and probably will fail.</p>
<p class="mce-root">Implementing a microservice-based application should take this into account. A microservice is implemented in such a way that it has a small impact in the case of failure and there is a recovery as soon as possible. As a result, the microservices-based application must be developed with fault tolerance as its goal. Of course, such an implementation increases the complexity of development.</p>
<p class="mce-root">The recovery task is facilitated because of the nature of the microservice. Because it is a small service, it can be created or initialized quickly.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Evolutionary systems</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">A microservices-based architecture is ideal for systems that have increased requirements and functionality over time. Systems that have a significant increase in business need services that can be reused. They also need a clear separation between their responsibilities, which are offered precisely by microservices. </p>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Decentralized data</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Each microservice has its own database—that is, each microservice has its own way of managing data, instead of a single, centralized database for the entire application, or even for the whole company. This means that, depending on the services, the databases may be quite different. We can have a relational database (or more than one), we can have NoSQL of several types as a documentary database, a graph database, or other kinds of database.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Explaining when to use microservices architecture</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Taking into account the characteristics of an application based on the architecture of microservices, we can establish some criteria of when to use microservices <span class="calibre10">architecture, as shown in the following bullet list</span><span class="calibre10">:</span></p>
<ul class="calibre15">
<li class="calibre16">When a system grows in its amount of requirements and functionalities, meaning that it has evolved quickly. In this case, the system begins to mix the responsibilities between its modules.</li>
<li class="calibre16">When we need to reuse services.</li>
<li class="calibre16">When the centralization of the APIs begins to block the evolution of the system.</li>
<li class="calibre16">When there is a need for new features, APIs, libraries, and frameworks, and we do not want to rewrite all of the software for this.</li>
</ul>
<p class="mce-root">Imagine that we have a sensational and innovative business model, and we must quickly make an application available for customers to enjoy this business. The adoption of a monolithic model, in principle, would make the application develop quickly, with quick tests and deployments as well. At this point, we might not have to think about the evolution of the system—we now want to think about the company's financial goal. Unfortunately, immediate profit may obscure the development of software that could offer greater profits in the future.</p>
<p class="mce-root">There are two conflicting issues:</p>
<ul class="calibre15">
<li class="calibre16">Delivering the product quickly so you can reach customers, capitalize the company, and think about the evolutionary scale of the product later, running the risk of creating software with poor maintenance</li>
<li class="calibre16">Once we have identified the criteria for using a microservices strategy, spending more time developing the application based on microservices</li>
</ul>
<p class="mce-root">At this point, both the architecture and project management teams should have some questions in mind:</p>
<ul class="calibre15">
<li class="calibre16">Will the application evolve?</li>
<li class="calibre16"><span class="calibre5">Does the team multitask</span>?</li>
<li class="calibre16">How will much development time initially be spent on a microservices product compared to a monolithic product?</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">How to decompose an application into microservices</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">We have two possibilities for decomposing an application—Either there is a monolithic application and we want to decompose it into microservices, or the application does not exist and we want to use the microservices strategy to create it.</p>
<p class="mce-root">In the case of existing monolithic applications, it is always possible to establish an intermediate stage, starting with a monolithic system to create a hybrid architecture, for example. At this intermediate stage, there may not be an immediate need or sufficient time to change the entire monolithic application and replace it with another one based on microservices architecture. For example, we have the critical issue of the single database.</p>
<p class="mce-root">There is not really a definite model for decomposition, but we can perform some tasks that may help:</p>
<ul class="calibre15">
<li class="calibre16">Identifying microservices</li>
<li class="calibre16">Taking care of the process of extracting application modules that are candidates for microservices</li>
<li class="calibre16">Establishing a hexagonal model for the application</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Identifying microservices</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Microservices can be very varied. There are technical microservices that are used throughout the application and that meet nonfunctional requirements, and there are microservices that are related to the application business application.</p>
<p class="mce-root">We can use two approaches in order to create business microservices—using business capabilities or use cases:</p>
<ul class="calibre15">
<li class="calibre16"><strong class="calibre3">Business capabilities:</strong> This indicates the ability to generate value for the business application. <span class="calibre5">The decomposition is small and each service would have a larger scope. </span>For example, in an application that manages a college, we can have the following business capabilities such as Professor Management Service, Student Management <span class="calibre5">Service, </span>Course Management <span class="calibre5">Service, </span>Student Financial Management <span class="calibre5">Service, </span><span class="calibre5">College Events Service.</span></li>
<li class="calibre16"><strong class="calibre3">Use case:</strong> We can perform a decomposition in services based on the use cases. In this case, t<span class="calibre5">he decomposition is large. </span>For example, a college might have a Student Enrolment Service, Payment of Monthly Fee Service, Test Review Service, and a Student's Academic Situation Service. </li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Taking care of the process of extracting application modules that are candidates for microservices</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Here, we must extract the application components or modules with well-defined interfaces. These modules would be eligible to become microservices. Looking at these module interfaces, we have to try to find out which of the following two situations is the case:</p>
<ul class="calibre15">
<li class="calibre16">The modules are independent, meaning that the services are well-defined and have few responsibilities. Here, we must take care not to generate monolithic modules.</li>
<li class="calibre16">The modules are reusable. Some clear examples of modules that can be reused would be modules with more technical tasks that are used throughout all of the application, such as a print service, an email service, a storage service, a document download service, and so on. Modules with a higher business content—such as a ticket payment service, a credit card payment service, and so on—can also be reused.</li>
</ul>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root">Let's look at the example shown in the following diagram:</p>
<p class="cdpaligncenter2"><img src="Images/11e28fe2-ca88-48da-bbd3-4b5d7beedd46.png" width="616" height="305" class="calibre76"/></p>
<p class="mce-root">When creating technical microservices, we must be careful not to carry <span class="calibre10">a functionality of the business </span><span class="calibre10">along with it.</span></p>
<p class="mce-root">Once this first approach is made, we still have a monolithic block that represents the core business. We can perform a decomposition of this block based on business capabilities or use case, and we can also discover new business modules with well-defined interfaces. We can then have modules such as a <strong class="calibre8">Student Status Service</strong>, <strong class="calibre8">Professor Service</strong>, <strong class="calibre8">College Event Service</strong>, and <strong class="calibre8">Financial Student Service</strong>. In addition, we can have microservices of the business with finer granularity, such as a <strong class="calibre8">Ticket Payment Service</strong>. </p>
<p class="mce-root">Let's look at the following diagram:</p>
<p class="cdpaligncenter2"><img src="Images/66164aec-c17a-4d22-8a54-ae93eed2650a.png" width="696" height="295" class="calibre77"/></p>
<p class="mce-root">Similarly, business-connected microservices must not carry the responsibilities of other microservice candidate modules. This means that we have to see the size of each microservice, and this is related to their own responsibilities. The microservice should have few responsibilities, characterizing a cohesive service (we always have to remember the SRP principle). One way to avoid dependent services is to remember the independent nature of microservices. If there are two microservices that need to be deployed together, or one does not exist without the other, then these services should <span class="calibre10">most likely </span><span class="calibre10">only </span><span class="calibre10">be</span><span class="calibre10"> </span><span class="calibre10">one service. </span></p>
<p class="mce-root">Another way to obtain this decomposition is to design our application in the hexagonal model, which we will see in the following section.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Establishing a hexagonal model for the application</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">A typical application keeps its various functional modules together. Generally, this typical application has a hexagonal structure or architecture (we will see a better definition of the hexagonal architecture <span class="calibre10">later)</span><span class="calibre10"> with the core business in the center of the structure. The core business contains all the management of the services offered by the application. There are also links with the various components external to this core, such as messaging services, database, client machines, and so on. These connections with the external world have specific adapters and protocols, such as a database adapter, REST API, Web API, Messaging API, WebSocket protocol, and so on, as shown in the following diagram:</span></p>
<p class="cdpaligncenter2"><img src="Images/f7884783-f603-46d2-88aa-3d033c5599d1.png" width="525" height="336" class="calibre78"/></p>
<p class="mce-root">The idea behind the hexagonal model is to isolate the application's core domain from access to technical infrastructures, such as the database, message queue, storage, and so on. As previously <span class="calibre10">stated</span><span class="calibre10">, once the core domain is isolated, we can analyze it more deeply and try to extract the services connected to the business.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Advantages and drawbacks of a microservices-based application</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Like any other technology, there are advantages and disadvantages in using microservices-based architecture. Several problems may appear during the implementation of microservices, but the advantages can overcome the complexity encountered during development. </p>
<p class="mce-root">The following are the advantages of the microservices architecture:</p>
<ul class="calibre15">
<li class="calibre16">Small multitask team.</li>
<li class="calibre16">Services can be written in different languages. This is a positive point because depending on the service, a specific language may provide more tools than another in obtaining the functionality served by the service.</li>
<li class="calibre16">The deployment is faster and integration is performed more automatically. Changes of requirements mean only the deployment<span class="calibre5"> </span>of the related microservice.</li>
<li class="calibre16">The latest libraries, frameworks, and technologies can be quickly used.</li>
<li class="calibre16">Greater fault tolerance.</li>
<li class="calibre16">The microservice is related to the product and not to the project. The developer has more freedom and thus can develop the service more quickly.</li>
<li class="calibre16">The knowledge of microservices is transmitted more quickly to the development team. Consequently, the necessary changes and maintenance of the code are made more quickly.</li>
</ul>
<p class="mce-root"><span class="calibre10">The following are the drawbacks of the microservices architecture:</span></p>
<ul class="calibre15">
<li class="calibre16">The independence of microservices can bring complexity because the services can have different protocols for both communication and data.</li>
<li class="calibre16">The increase of microservices makes the control and management of these services more complicated. For example, In order to maintain fault tolerance, there must be more programming effort.</li>
<li class="calibre16">As well as the problem of services with different protocols, the communication between the services is also more complex because some application functionalities may involve calls to several microservices, worsening network traffic. The developer, in these cases, should use tools and strategies such as the API gateway.</li>
<li class="calibre16">Transaction control is a complicating factor, especially when migrating from monolithic systems to an architecture based on microservices—for example, in situations in which a particular functionality or use case needs several microservices.</li>
<li class="calibre16">Each microservice runs in a single process, which means increasing memory consumption.</li>
<li class="calibre16">Tests are more difficult to perform because the application is distributed across microservices.</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Microservices architecture patterns</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">So far, we have seen that microservices architecture is based on the functional decomposition that produces independent, self-sufficient services that may have different ways of communicating with the outside world using well-defined interfaces. This favors low coupling and well-defined functions, allowing high cohesion (well-defined responsibilities with a reduced number of functions).</p>
<p class="mce-root">Although the services act independently, the purpose of these services is to create an application—that is, a set of business-related functionalities. </p>
<p class="mce-root">Based on these characteristics, we can extract some patterns that can be used for the implementation of the microservices architecture. Here are some of these patterns:</p>
<ul class="calibre15">
<li class="calibre16">Aggregator pattern</li>
<li class="calibre16">Proxy pattern</li>
<li class="calibre16">Chained pattern</li>
<li class="calibre16">Branch pattern</li>
<li class="calibre16">Asynchronous messaging pattern</li>
</ul>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Aggregator pattern</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">As the name itself suggests, this pattern establishes the existence or creation of a somewhat more complex service that invokes the functions of more internal services. Consequently, this aggregating microservice acts as an intermediary service that is a composition of other microservices, in the sense that it calls the microservices, obtains the individual responses from each microservice, and applies the necessary business rule, returning the final response to the client. Let's look at the following diagram:</p>
<div class="cdpaligncenter"><img src="Images/c7298a5f-3d9f-4276-bab5-0fd124ab5577.png" width="499" height="357" class="calibre79"/></div>
<p class="mce-root">This diagram appears to show that a few parts of the solutions are repeated, which characterizes the existence of a design pattern. We can make a comparison with a microservice that acts as a business facade, calling specific microservices to perform a more complex functionality on an application business level. On a larger scale, this same aggregator microservice may act as a microservice individual that is called by another aggregator microservice at a higher level. It is clear that having great knowledge of the application's business rules is vital.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Proxy pattern</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">This pattern is a variation of the aggregator pattern, but with one important difference. There is no data collection for all the internal microservices, meaning that there is no aggregation. The proxy pattern directs the call to a specific microservice and the analysis of the request is what determines which microservice should be called (a typical behavior of a proxy pattern).</p>
<p class="mce-root"/>
<p class="mce-root">However, there may be some benefit in the implementation of this proxy. Immediately before the response is returned to the client, there may be a transformation of this response to the format expected by the requesting client. Remember that different clients (including web browsers, mobile devices, and so on) can make the request.<span class="calibre10"> Let's look at the following diagram:</span></p>
<div class="cdpaligncenter"><img src="Images/926052e2-307e-4fda-831a-a2400c6604f7.png" width="507" height="361" class="calibre80"/></div>
<p class="mce-root"/>
<p class="mce-root">We can now see why an API gateway is clearly based on aggregator and proxy patterns.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Chained pattern</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">The purpose of the chained pattern is to present a more consistent and definitive final response to the client using a chain of services that communicate sequentially. In this way, <strong class="calibre8">Service A</strong> that acts as a first service in the chain communicate with <strong class="calibre8">Service B</strong>. <strong class="calibre8">Service B</strong> communicates with <strong class="calibre8">Service C</strong>, and so on. The calls are synchronous and the client remains locked until the final response returns from <strong class="calibre8">Service A</strong> to the client. </p>
<p class="mce-root">It is important to note here that the requests that arrive at the chain services may be different. In this way, the request sent from <strong class="calibre8">Service A</strong> to <strong class="calibre8">Service B</strong> may be very different from the request sent from <strong class="calibre8">Service B</strong> to <strong class="calibre8">Service C</strong>, and so on. In the same way, the response of the services may also be different. The response from <strong class="calibre8">Service C</strong> to <strong class="calibre8">Service B</strong> may be different from the response from <strong class="calibre8">Service B</strong> to <strong class="calibre8">Service A</strong>.<span class="calibre10"> </span></p>
<p class="mce-root"><span class="calibre10">Let's look at the following diagram:</span></p>
<div class="cdpaligncenter"><img src="Images/bbfeb09a-9a91-4be8-b976-bc725f6b5280.png" width="753" height="97" class="calibre81"/></div>
<p class="mce-root">A practical example of this implementation is the generation of data for the printing of bank slips. Let's suppose that a bank provides two soap web services. One for registering the bank bill data in the bank and the other for getting the bank bill data registered with the bank. Our application contains two defined microservices—<strong class="calibre8">Service A</strong>, which registers the bank bill data in the data bank (that is, it calls the first registration web service); and <strong class="calibre8">Service B</strong>, which gets the definitive bank bill data, such as the code bar (meaning that it calls the second query web service), and returns the data for the bank bill generation.</p>
<p class="mce-root">A client application informs the bank data of a user to <strong class="calibre8"><span class="calibre10">Service</span></strong><span class="calibre10"><strong class="calibre8"> A</strong>. <strong class="calibre8">Service A</strong> is responsible for registering with the banking institution and, with the return of this registration, <strong class="calibre8">Service A</strong> makes a request to <strong class="calibre8">Service B</strong>. <strong class="calibre8">Service B</strong> then gets the definitive data for the generation of the bank bill. <strong class="calibre8">Service B</strong> passes this data to <strong class="calibre8">Service A</strong>, and it can then apply some transformation to that data and return it to the client.</span></p>
<p class="mce-root">This same example can be implemented using the aggregator pattern. However, whenever a sequential order of steps is required to produce a final response, we can think of the chain pattern as a solution.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Branch pattern</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">The branch pattern works as an extension of the aggregator pattern and can call different service chains in parallel. In the branch pattern implementation example, a first service, called <strong class="calibre8">Service A</strong>, is called by the client and can act as an aggregator, calling service chains to compose the response. Alternatively, based on the request, a specific service chain is called, thereby acting as a proxy pattern. <span class="calibre10">Let's look at the following diagram:</span></p>
<div class="cdpaligncenter"><img src="Images/4891478c-fe9f-4e96-974b-d9e3cc9870bb.png" width="691" height="339" class="calibre82"/></div>
<p class="mce-root">In fact, the main difference between the chain pattern and the branch pattern is the calling of different microservice chains. However, if we make an abstraction, and consider each chain as an individual microservice, in essence, we will have an aggregator or a proxy pattern.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Asynchronous pattern</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">When we think of microservices in practical terms, we immediately think of microservices implemented using the REST protocol. However, microservices based on a REST pattern are synchronous and therefore blocking. Sometimes, we need microservices that can be called asynchronously. The asynchronous mechanism is developed with techniques that are specific to each application (message queue, sending asynchronous events, and so on). Let's look at the following diagram:</p>
<div class="cdpaligncenter"><img src="Images/ce831d37-99a1-4052-aa9a-d713ea877f37.png" width="726" height="209" class="calibre83"/></div>
<p class="mce-root"><strong class="calibre8">Service A</strong> receives the request from the client and calls <strong class="calibre8">Service B</strong> in a synchronous manner. However, <strong class="calibre8">Service B</strong> depends on <strong class="calibre8">Service C</strong> and calls it asynchronously through a message queue, for example. <strong class="calibre8">Service C</strong> reads the message from the queue, does the required logical processing, and <span class="calibre10">also</span><span class="calibre10"> </span><span class="calibre10">returns a response to <strong class="calibre8">Service B</strong> using the queue mechanism. (We should always keep in mind the independence of the services that are being called.)</span></p>
<p class="mce-root">A way of communicating between <strong class="calibre8">Service B</strong> and <strong class="calibre8">Service C</strong> could be that <strong class="calibre8">Service B</strong> sends a request message to a <kbd class="calibre18">QRequest</kbd> queue and listens for a response from a <kbd class="calibre18">QReply</kbd> queue. <strong class="calibre8">Service C</strong> then reads the request message from the <kbd class="calibre18">QRequest</kbd> queue, performs the necessary processing, and sends a response to the <kbd class="calibre18">QReply</kbd> queue. <strong class="calibre8">Service B</strong> reads the response message from the <kbd class="calibre18">QReply</kbd> <span class="calibre10">queue</span><span class="calibre10">, applies a transformation or adds some other information, and then sends the response to <strong class="calibre8">Service A</strong>. It is clear that the specific details of this implementation should be taken into account, such as waiting for <strong class="calibre8">Service C</strong> to time out.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Implementing microservices</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">The idea behind the implementation of microservices in our example is to implement a microservice that provides the bank data for a client to generate a payment slip. The data returned will be the barcode of the payment slip.</p>
<p class="mce-root">The bank provides two <span class="calibre10">SOAP </span>web services, one to register the payment slip with the bank and one to provide the data for generating the payment slip that was already registered. As a result, we will make two microservices, one for registering the payment slip data and another for the query of the payment slip that <span class="calibre10">was already registered.</span> Each of these microservices will call the related web service. Next, we will construct a third, more complex microservice that will add two calls: a call to the registration microservice and another to retrieve what was registered. Let's look at the following diagram:</p>
<div class="cdpaligncenter"><img src="Images/260e087a-54a7-43c8-abe8-a4926fbc13e0.png" class="calibre84"/></div>
<p class="mce-root">We could, i<span class="calibre10">n fact,</span><span class="calibre10"> </span><span class="calibre10">make a microservice chain here; however, we opted for the aggregator pattern because we assume that multiple payment slips may have been previously batch-registered.</span></p>
<p class="mce-root">We will make three classes—one for each microservice. Each microservice will be implemented as a REST <span class="calibre10">resource</span>. To make the code simpler, we use only one request class and only one response class for the two microservices; the registering and querying microservices.</p>
<p class="mce-root">The <span class="calibre10">payment slip registering class is as follows</span>:</p>
<pre class="mce-root2">@Path ("/register")<br class="calibre2"/>public class PaymentRegisterService {<br class="calibre2"/>    @Path ("/paymentSlip/")<br class="calibre2"/>    @POST<br class="calibre2"/>    @Produces (MediaType.APPLICATION_JSON)<br class="calibre2"/>    @Consumes (MediaType.APPLICATION_JSON)<br class="calibre2"/>    public Response register (RequestVO requestVO) {<br class="calibre2"/>       // calls the bank register web service:<br class="calibre2"/>       // ...<br class="calibre2"/>       // Prepare the response with the register web service data:<br class="calibre2"/>       ResponseVO responseVO = new ResponseVO();<br class="calibre2"/>       responseVO.setRegisterNumber (7554433452L); // this is a simulation    //because this information must be returned from the bank's web service <br class="calibre2"/>       responseVO.setUserName (requestVO.getUserName());<br class="calibre2"/>       responseVO.setValue (requestVO.getValue());<br class="calibre2"/>       responseVO.setStatus ("OK"); // everything is supposed to be correct<br class="calibre2"/>       return Response.ok (responseVO).build();<br class="calibre2"/>    }<br class="calibre2"/>}</pre>
<p class="mce-root"><span class="calibre10">The following is the payment slip query class:</span></p>
<pre class="mce-root2">@Path ("/query")<br class="calibre2"/>public class PaymentQueryService {<br class="calibre2"/>    @Path ("/paymentSlip/")<br class="calibre2"/>    @POST<br class="calibre2"/>    @Produces (MediaType.APPLICATION_JSON)<br class="calibre2"/>    @Consumes (MediaType.APPLICATION_JSON)<br class="calibre2"/>    public Response query (RequestVO requestVO) {<br class="calibre2"/>        // calls the bank query web service:<br class="calibre2"/>        // ...<br class="calibre2"/>        // Prepare the response with the query web service data:<br class="calibre2"/>        ResponseVO responseVO = new ResponseVO();<br class="calibre2"/>        responseVO.setCodeBar("8888999977776666");// this is a simulation //because this information must be returned from the bank's web service <br class="calibre2"/>        responseVO.setUserName (requestVO.getUserName());<br class="calibre2"/>        responseVO.setStatus ("OK"); // everything is supposed to be correct<br class="calibre2"/>        responseVO.setValue(requestVO.getValue());<br class="calibre2"/>        return Response.ok (responseVO).build();<br class="calibre2"/>    }<br class="calibre2"/>}</pre>
<p class="mce-root">The following is the aggregator class:</p>
<pre class="mce-root2">@Path ("/bank")<br class="calibre2"/>public class PaymentSlipGenerating {<br class="calibre2"/>    private static String BASE_PATH = "http://localhost:8080/microservice/ws";<br class="calibre2"/>    @Inject private UserService userService;<br class="calibre2"/>    private Response callMicroservice (String path, Object entity) {<br class="calibre2"/>        Client client = ClientBuilder.newClient();<br class="calibre2"/>        WebTarget target = client.target (BASE_PATH);<br class="calibre2"/>        Response resp = target.path (path).request().post(Entity.json (entity));<br class="calibre2"/>        return resp;<br class="calibre2"/>    }<br class="calibre2"/>    @Path ("/paymentSlip/{id}/{value}")<br class="calibre2"/>    @GET<br class="calibre2"/>    @Produces (MediaType.APPLICATION_JSON)<br class="calibre2"/>    public Response getPaymentSlipData (@PathParam("id") long id,  @PathParam("value") String strValue) {<br class="calibre2"/>        // get the payment slip value:<br class="calibre2"/>        double value = convertToValue (strValue);<br class="calibre2"/>        // get the user information from local DataBase:<br class="calibre2"/>        User user = userService.getUserById (id);<br class="calibre2"/><br class="calibre2"/>        // prepare the payment slip registering request:<br class="calibre2"/>        RequestVO registerRequest = new RequestVO();<br class="calibre2"/>        registerRequest.setUserCode (user.getCode());<br class="calibre2"/>        registerRequest.setUserName (user.getName());<br class="calibre2"/>        registerRequest.setValue (value);<br class="calibre2"/>        // call registering microservice:<br class="calibre2"/>        Response resp = callMicroservice ("/register/paymentSlip", registerRequest);<br class="calibre2"/>        ResponseVO responseRegisterVO = resp.readEntity (ResponseVO.class); <br class="calibre2"/>        // prepare the payment slip query request:<br class="calibre2"/>        RequestVO queryRequest = new RequestVO();<br class="calibre2"/>        queryRequest.setUserName(registerRequest.getUserName());<br class="calibre2"/>        queryRequest.setRegisterNumber (responseRegisterVO.getRegisterNumber());<br class="calibre2"/>        queryRequest.setValue (value);<br class="calibre2"/>        // call query microservice:<br class="calibre2"/>        resp = callMicroservice ("/query/paymentSlip", registerRequest);<br class="calibre2"/>        ResponseVO responseQueryVO = resp.readEntity (ResponseVO.class); <br class="calibre2"/><br class="calibre2"/>        return Response.ok (responseQueryVO).build();<br class="calibre2"/>     }<br class="calibre2"/>}<br class="calibre2"/><br class="calibre2"/></pre>
<p class="mce-root">Any client can then call this aggregator microservice in order to obtain the barcode and other information to generate the payment slip.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">In almost every section of this book, we have shown that, besides being solutions to recurrent problems, patterns aim at the reuse of and low coupling between application components. Following this principle, the decomposition of an application into small independent parts that perform intelligent and specific tasks allows this application to evolve in a natural and organized way. These small parts with specific tasks are called microservices, and the method of developing a system based on the decomposition of the application into these small parts is called microservices architecture.</p>
<p class="mce-root"/>
<p class="mce-root">However, like any technology, there are pros and cons to this. Developing an application and thinking about the control of the various microservices is a complex task, but once the microservices are well defined, the application is able to evolve much better than a monolithic application. In this way, the maintenance of the application is done more quickly, with the addition of new functionalities and the updating of the current functionalities.</p>
<p class="mce-root">The inclusion of new frameworks, APIs, and libraries is done much more quickly thanks to the decentralization of microservices. Teaching microservices to future development teams is also faster and easier, and deployment is also faster because there is no need to redeploy the entire application because of a change in one part of the application. We also looked at a mechanism called an API gateway. The API gateway establishes a type of frontend for the various clients of the application based on microservices, translating the clients' calls to the microservices.</p>
<p class="mce-root"/>
<p class="mce-root">Finally, in this chapter, we looked at some of the main design patterns that are used in the development of the microservices architecture, such as the aggregator pattern, the proxy pattern, and the chained pattern.</p>
<p class="mce-root">The next chapter, <a href="91a5c7ea-6a16-4af1-b89a-0f918d4feb4e.xhtml" target="_blank" class="calibre14 pcalibre pcalibre3 pcalibre2 pcalibre1">Chapter 8</a>, <em class="calibre12">Cloud-Native Application Patterns</em>, will address the cloud-native application pattern. Here, we'll look at a cloud application, as well as some of the key patterns that must be followed when developing an application in the cloud.</p>


            </article>

            
        </section>
    </div>



  </body></html>