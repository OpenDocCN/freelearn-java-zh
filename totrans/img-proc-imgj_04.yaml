- en: Chapter 4. Image Segmentation and Feature Extraction with ImageJ
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章：使用ImageJ进行图像分割和特征提取
- en: 'The previous chapter looked at processing images to view and correct imperfections
    in acquisition. This chapter will introduce techniques for segmenting images and
    extracting features that are relevant for processing and analysis. The following
    topics will be covered in this chapter:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 上一章探讨了处理图像以查看和纠正采集中的缺陷。本章将介绍分割图像和提取与处理和分析相关的特征的技术。本章将涵盖以下主题：
- en: Image segmentation
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图像分割
- en: Morphological processing
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 形态学处理
- en: Image filtering and convolution
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图像过滤和卷积
- en: Feature extraction
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特征提取
- en: Image segmentation
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图像分割
- en: For many steps in image analysis, it is important to split the image into two
    separate (non-overlapping) components. These components are usually labeled as
    background and foreground. Generally speaking, the background is the part of the
    image we are not directly interested in when we analyze the image. We normally
    restrict our analysis to parts of the image that are deemed as the foreground.
    This splitting into two components is called segmentation and is primarily based
    on pixel intensity. This is important if you wish to count and measure a number
    of unique objects of a specific type or measure the intensity of a single complex
    object while excluding the background from the measurement.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在图像分析的许多步骤中，将图像分成两个独立的（非重叠的）部分非常重要。这些部分通常被标记为背景和前景。一般来说，当我们分析图像时，背景是我们不直接感兴趣的图像部分。我们通常将分析限制在被认为是前景的图像部分。这种将图像分成两个部分的过程称为分割，主要是基于像素强度。如果您希望计数和测量特定类型的多个独特对象或测量单个复杂对象的强度，同时排除背景，这是很重要的。
- en: Image thresholding
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 图像阈值化
- en: To achieve the split of an image into background and foreground, we will set
    a threshold value. Values below this threshold will be classified as one group,
    while pixels with higher or equal values will be classified as another group.
    In general, the background in fluorescent images contains values close to black
    (that is, a dark background), while brightfield images have background values
    closer to white (a light background). The output of thresholding is an image called
    a mask in ImageJ, which is a binary image. Its pixels have only two values (0
    and 255).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将图像分割成背景和前景，我们将设置一个阈值值。低于此阈值的值将被分类为一组，而值更高或等于阈值的像素将被分类为另一组。一般来说，荧光图像的背景包含接近黑色的值（即，深色背景），而明场图像的背景值更接近白色（浅色背景）。阈值化的输出是一个在ImageJ中称为掩模的图像，它是一个二值图像。其像素只有两个值（0和255）。
- en: We will look at how to perform basic thresholding on a grayscale image first.
    After that, we will look at the possibilities for thresholding a color image.
    The difference between these two image types stems from the fact that a color
    image does not have an easy way of setting a threshold. Each pixel contains three
    values (red, green, and blue), and a single threshold value does not segment the
    image in useful ways generally.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将探讨如何在灰度图像上执行基本的阈值化。之后，我们将探讨对彩色图像进行阈值化的可能性。这两种图像类型之间的区别在于，彩色图像没有一种简单的方法来设置阈值。每个像素包含三个值（红色、绿色和蓝色），而单个阈值值通常不能以有用的方式分割图像。
- en: Thresholding grayscale images
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 阈值化灰度图像
- en: We will start by taking a grayscale image from the sample images and segmenting
    it. For this example, we will use the **Blobs** image. Thresholding would be the
    first step if you wanted to measure the size of each individual blob as well as
    get a count of the number of blobs in the image. Note that for small images such
    as this example, counting could be done by hand. However, if you need to do this
    for a large number of images, this method of counting by hand would be very tedious.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从一个示例图像中获取一个灰度图像并对其进行分割。对于这个例子，我们将使用**Blob**图像。如果您想测量每个单独的Blob的大小以及获取图像中Blob数量的计数，阈值化将是第一步。请注意，对于像这个例子这样的小图像，计数可以手动完成。然而，如果您需要为大量图像执行此操作，这种手动计数方法将非常繁琐。
- en: 'To set a threshold, go to **Image** | **Adjust** | **Threshold…** or press
    *Ctrl* + *Shift* + *T*. The threshold dialog will open with a few options:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置阈值，请转到**图像** | **调整** | **阈值…**或按*Ctrl* + *Shift* + *T*。阈值对话框将打开，并带有几个选项：
- en: '![Thresholding grayscale images](img/Insert_image_4909_03b_01.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![阈值化灰度图像](img/Insert_image_4909_03b_01.jpg)'
- en: 'For fluorescent images, the **Dark background** checkbox needs to be selected,
    while for brightfield images, it needs to be deselected (unless you use darkfield
    illumination methods). The methods available can be set in the drop-down list
    on the left-hand side. The default method is based on the **IsoData** method.
    The **IsoData** method determines the value of the threshold based on the following
    procedure:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 对于荧光图像，需要选中**暗背景**复选框，而对于明场图像，则需要取消选中（除非您使用暗场照明方法）。可用的方法可以在左侧的下拉列表中设置。默认方法基于**IsoData**方法。**IsoData**方法根据以下程序确定阈值值：
- en: Take an initial value for the threshold *T*
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为阈值 *T* 设置一个初始值
- en: Calculate the average intensity of the background (*BG*) and the foreground
    (*FG*) pixels based on the value of *T*
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据阈值 *T* 的值计算背景 (*BG*) 和前景 (*FG*) 像素的平均强度
- en: If the average of *BG* and *FG* in step *ii* is not equal to *T*, increment
    the threshold value *T* and repeat step *ii*
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果步骤 *ii* 中 *BG* 和 *FG* 的平均值不等于 *T*，则增加阈值值 *T* 并重复步骤 *ii*
- en: For more information and references on thresholding methods, refer to the Fiji
    website at [http://fiji.sc/Auto_Threshold#Available_methods](http://fiji.sc/Auto_Threshold#Available_methods)
    for an overview. The drop-down list on the right-hand side gives the option to
    show the effect of the thresholding. When **Red** is selected, the foreground
    selection is displayed as red while the background stays in grayscale.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 更多有关阈值化方法的信息和参考资料，请参阅Fiji网站上的[http://fiji.sc/Auto_Threshold#Available_methods](http://fiji.sc/Auto_Threshold#Available_methods)，以获取概述。右侧的下拉列表提供了显示阈值化效果的选择。当选择**红色**时，前景选择以红色显示，而背景保持为灰度。
- en: 'Once you have the threshold set, you can create a binary image by pressing
    **Apply** in the threshold window or by going to **Edit** | **Selection** | **Create
    Mask**. The former method will modify your original image, while the latter method
    will open a new window with the thresholded image. The red parts (that is, the
    above-threshold values) in the original image are now white, while the non-red
    parts (that is, the below-threshold values) in the original image are now black.
    Sometimes, the threshold is not perfect and has gaps or holes in places where
    the signal was not even. You will learn how to deal with these issues in the *Morphological
    processing* section. The three stages of this process are shown in the following
    image:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦设置了阈值，您可以通过在阈值窗口中按**应用**或通过转到**编辑** | **选择** | **创建蒙版**来创建二值图像。前者将修改您的原始图像，而后者将打开一个包含阈值化图像的新窗口。原始图像中的红色部分（即高于阈值的值）现在是白色，而原始图像中的非红色部分（即低于阈值的值）现在是黑色。有时，阈值可能并不完美，在信号甚至不存在的地方有间隙或孔洞。您将在*形态学处理*部分学习如何处理这些问题。此过程的三个阶段如下面的图像所示：
- en: '![Thresholding grayscale images](img/Insert_image_4909_03b_02.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![阈值灰度图像](img/Insert_image_4909_03b_02.jpg)'
- en: The image in the left panel is the original image. The middle panel shows the
    auto threshold with the foreground areas in red. The right panel shows the resulting
    mask that was created based on the threshold.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 左侧面板中的图像是原始图像。中间面板显示了带有红色前景区域的自动阈值。右侧面板显示了基于阈值创建的结果蒙版。
- en: Thresholding color images
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 阈值化彩色图像
- en: As mentioned earlier, color images are more complicated to segment. When talking
    about color images, it is important to distinguish between RGB images and multichannel
    stacks. The latter can be thresholded just fine using the techniques described
    in the previous section. Multichannel stacks can be seen as individual grayscale
    images that were given a specific LUT to appear colored. RGB images, on the other
    hand, are a little more complex. If the image only contains pixels that are red,
    green, or blue, you could convert the image into a multichannel image.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，彩色图像的分割更复杂。当谈到彩色图像时，区分RGB图像和多通道堆叠非常重要。后者可以使用上一节中描述的技术很好地进行阈值化。多通道堆叠可以看作是给定了特定LUT以呈现颜色的单个灰度图像。另一方面，RGB图像稍微复杂一些。如果图像只包含红色、绿色或蓝色的像素，则可以将图像转换为多通道图像。
- en: 'To segment an RGB image with more colors, you need to transform the image to
    a different color space. To select the foreground based on color, the HSB color
    space is more convenient. As we saw in the [Chapter 2](ch02.html "Chapter 2. Basic
    Image Processing with ImageJ"), *Basic Image Processing with ImageJ*, the color
    information in HSB images is a separate channel encoded in grayscale values. When
    you want to set a threshold on an RGB color image in ImageJ and Fiji, the **Threshold
    Color** dialog opens automatically:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 要分割具有更多颜色的RGB图像，您需要将图像转换为不同的颜色空间。要基于颜色选择前景，HSB颜色空间更为方便。正如我们在[第2章](ch02.html
    "第2章。使用ImageJ的基本图像处理")中看到的，*使用ImageJ的基本图像处理*，HSB图像中的颜色信息是单独的通道，以灰度值编码。当您想在ImageJ和Fiji中设置RGB颜色图像的阈值时，会自动打开**阈值颜色**对话框：
- en: '![Thresholding color images](img/Insert_image_4909_03b_03.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![阈值化颜色图像](img/Insert_image_4909_03b_03.jpg)'
- en: 'By default, it opens in the HSB color space, where the top chart shows the
    distribution of the hue channel. The two sliders underneath indicate which colors
    you wish to select. In this case, orange is selected. The second panel shows the
    controls for saturation. As the sliders are far to the right, we only select bright
    orange colors. Finally, the third panel at the bottom shows the controls for brightness,
    which is set for a wide range of brightness values starting at the mid-level.
    This example shows you how to select a specific range of colors. In this case,
    the threshold was set to select the hair of the clown in the **Clown** sample
    image:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，它以HSB颜色空间打开，顶部图表显示了色调通道的分布。下方的两个滑块指示您希望选择的颜色。在这种情况下，选择了橙色。第二个面板显示了饱和度的控制。由于滑块位于最右侧，我们只选择了明亮的橙色。最后，底部第三个面板显示了亮度控制，亮度值从中等水平开始，覆盖了广泛的亮度范围。这个例子展示了如何选择特定范围的色彩。在这种情况下，阈值被设置为选择**小丑**样本图像中的头发：
- en: '![Thresholding color images](img/Insert_image_4909_03b_04.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![阈值化颜色图像](img/Insert_image_4909_03b_04.jpg)'
- en: As you can see, the threshold is not perfect. There are small areas on the cheek
    and near the nose that are also within the threshold. Furthermore, there are also
    gaps in the area that are part of the hair, especially around the right eye and
    in the top-right corner of the image.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，阈值并不完美。脸颊和鼻子附近的小区域也位于阈值内。此外，该区域中还有间隙，尤其是右眼周围和图像右上角。
- en: The threshold method list has the same methods as the standard ImageJ threshold
    dialog, and it works only on the brightness channel. The **Original** button is
    similar to the **Reset** option in the grayscale threshold dialog. The **Select**
    button will convert the thresholded region into a selection. The **Sample** button
    will use a selected portion of the image to generate a threshold based on the
    hue, saturation, and brightness channels in that area.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 阈值方法列表具有与标准ImageJ阈值对话框相同的方法，并且它仅在亮度通道上工作。**原始**按钮类似于灰度阈值对话框中的**重置**选项。**选择**按钮将阈值化区域转换为选择。**样本**按钮将使用图像的一部分来生成基于该区域的色调、饱和度和亮度通道的阈值。
- en: Morphological processing
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 形态学处理
- en: After segmenting the image into the two components, you are left with a mask
    or binary image. As was clear from the examples, these masks are not always suitable
    for direct measurement. Imperfections in the image may result in gaps in objects
    or small discontinuities in structures. Also, some areas might be detected as
    foreground when they are actually not really objects of interest. You could manually
    correct this by converting the missing pixels to white or black in order to include
    or exclude them, respectively. In some cases, this might be the only possible
    recourse. However, in many cases, there are a few processing steps available that
    can fix these problems in a systematic way. These steps are called morphological
    processing, which we will examine in greater detail in the next section.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在将图像分割成两个组件之后，您将得到一个掩码或二值图像。从示例中可以看出，这些掩码并不总是适合直接测量。图像中的不完美可能导致物体之间出现间隙或结构中的小不连续性。此外，某些区域可能被检测为前景，而实际上它们并不是真正感兴趣的对象。您可以通过将缺失的像素转换为白色或黑色来手动纠正这一点，分别包括或排除它们。在某些情况下，这可能是最可能的解决方案。然而，在许多情况下，有一些处理步骤可以系统地解决这些问题。这些步骤被称为形态学处理，我们将在下一节中更详细地探讨。
- en: Morphological operators
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 形态学算子
- en: 'ImageJ supports the two main principal operators for morphological processing:
    **erode** and **dilate**. It also has functions for filling holes, skeletonizing,
    and watershedding binary images, which will be discussed in a later section. These
    functions will be explained in the upcoming sections using a few basic examples.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: ImageJ支持两种主要的形态学处理运算符：**腐蚀**和**膨胀**。它还具有填充孔洞、骨架化和分水岭处理二值图像的功能，这些将在后面的章节中讨论。这些功能将通过一些基本示例在即将到来的章节中进行解释。
- en: Erode and dilate
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 腐蚀和膨胀
- en: 'To start with, we will look at the basic operators **erode** and **dilate**.
    The erode operator takes a foreground pixel (**FG**) and looks at the surrounding
    pixels in a 3 x 3 neighborhood. Based on the number of FG pixels, the pixel will
    be changed to a background pixel (**BG**), or it stays as an FG pixel. The dilate
    operator functions in the opposite way. ImageJ determines whether a pixel will
    be changed or not based on the binary options, which can be set by going to **Process**
    | **Binary** | **Options…**:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将查看基本的运算符**腐蚀**和**膨胀**。腐蚀运算符会取一个前景像素（**FG**），并查看3 x 3邻域内的周围像素。根据FG像素的数量，像素将被改变为背景像素（**BG**），或者它保持为FG像素。膨胀运算符则相反。ImageJ根据二进制选项确定像素是否改变，这些选项可以通过访问**处理**
    | **二值** | **选项…**来设置：
- en: '![Erode and dilate](img/Insert_image_4909_03b_05.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![腐蚀和膨胀](img/Insert_image_4909_03b_05.jpg)'
- en: '**Iterations** determines how many times the operator is repeated, and **Count**
    determines the number of pixels used for the threshold that determines whether
    a pixel is switched or not. **EDM output** determines where the results from distance
    mapping functions are written. When **Overwrite** is selected, the distance mapping
    overwrites the pixels in your mask image. **Pad edges when eroding** determines
    whether pixels will be eroded when they are located on the edge of the image.
    When selected, there will be no erosion at the edges of the image.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '**迭代次数**决定了运算符重复的次数，**计数**决定了用于确定像素是否切换的阈值所使用的像素数量。**EDM输出**决定了距离映射函数的结果写入的位置。当选择**覆盖**时，距离映射会覆盖遮罩图像中的像素。**腐蚀时填充边缘**决定了当像素位于图像边缘时是否进行腐蚀。当选择时，图像边缘将不会有腐蚀。'
- en: For the following example, I will assume that the number of iterations is set
    to `1`, the count to `1`, and the black background is unchecked.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 对于以下示例，我将假设迭代次数设置为`1`，计数设置为`1`，并且未勾选黑色背景。
- en: Open the `4909_03b_binary.tif` image in ImageJ. It is available on the Packt
    website.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在ImageJ中打开`4909_03b_binary.tif`图像。它可在Packt网站上找到。
- en: Set a threshold for the image using `0` for the top slider and `75` for the
    bottom slider, using the default method. Leave the dark background unchecked.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用默认方法，通过顶部滑块设置图像的阈值使用`0`，底部滑块使用`75`。不要勾选深色背景。
- en: Select **Edit** | **Selection** | **Create Mask** to generate a new image or
    press **Apply** in the threshold dialog to overwrite the original image.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**编辑** | **选择** | **创建遮罩**以生成一个新的图像，或在阈值对话框中按**应用**以覆盖原始图像。
- en: Finally, select the masked image and press *Ctrl* + *Shift* + *I* to invert
    the image so that it has a white background. You should now have the following
    result (the original is on the left-hand side and the mask is on the right-hand
    side):![Erode and dilate](img/Insert_image_4909_03b_06.jpg)
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，选择遮罩图像，并按*Ctrl* + *Shift* + *I*来反转图像，使其具有白色背景。你现在应该得到以下结果（原始图像在左侧，遮罩在右侧）：![腐蚀和膨胀](img/Insert_image_4909_03b_06.jpg)
- en: When you look closely at the masked image, you will appreciate that there are
    a few small problems. Most notably, the letter **a** in **Binary** and **ImageJ**
    is broken in three disconnected parts. Also, the letters **p** and **g** are not
    entirely complete and have a break but are not completely disconnected. For humans,
    this is not a large problem. We can easily fill in the gaps in our minds and read
    the text. Computers, on the other hand, may have a more difficult time trying
    to decipher the text. We will now look at the effect of binary operators on this
    mask. You will also see how this may solve our problem of fragmented letters.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 当你仔细观察被遮罩的图像时，你会注意到存在一些小问题。最值得注意的是，**二进制**和**ImageJ**中的字母**a**被分成三个不相连的部分。此外，字母**p**和**g**并不完全完整，有一个断裂但并未完全断开。对于人类来说，这并不是一个大问题。我们可以在脑海中轻松填补这些空白并阅读文本。然而，另一方面，计算机可能更难尝试解读文本。我们现在将探讨二进制运算符对这一遮罩的影响。你也会看到这如何解决我们碎片化字母的问题。
- en: Select the masked image and go to **Process** | **Binary** | **Options…** to
    open the options dialog. This will show a few more options now that we have a
    masked image, most notably the **Do** drop-down menu and the **Preview** checkbox.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择蒙版图像，然后转到**处理** | **二值** | **选项…**以打开选项对话框。现在我们有了蒙版图像，将显示一些额外的选项，最值得注意的是**执行**下拉菜单和**预览**复选框。
- en: Zoom in on one of the letters a using the magnification tool or the *+* key
    on the keyboard.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用放大工具或键盘上的**+**键放大字母**a**。
- en: Select **Erode** from the **Do** drop-down menu and check the **Preview** checkbox,
    but don't press OK!
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**执行**下拉菜单中选择**腐蚀**，并勾选**预览**复选框，但不要按确定！
- en: In preview mode, you will notice that the entire mask went white, and the text
    completely disappeared when you selected the erode operator. When you increase
    the value in the **Count** field, you will start to notice that parts of the text
    will start to come back. With a value of `3`, some pixels are visible, while a
    value of `7` or `8` gives you most of the text unscathed. When the value is set
    to `8`, the only victim of the erode operation is the isolated pixel of the letter
    **a**. All the other pixels remain intact, but this isolated pixel is removed.
    This is one of the most used applications of the erode operator—removing isolated
    single pixels caused by noise in your image.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在预览模式下，你会注意到整个蒙版变成了白色，当你选择了腐蚀操作时，文本完全消失了。当你增加**计数**字段中的值时，你将开始注意到文本的部分开始恢复。当值为`3`时，一些像素可见，而值为`7`或`8`则几乎保留了所有文本。当值设置为`8`时，腐蚀操作的唯一受害者是字母**a**的孤立像素。所有其他像素保持完好，但这个孤立像素被移除了。这是腐蚀操作最常用的应用之一——移除由图像中的噪声引起的孤立单个像素。
- en: Note
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: When using **Erode**, isolated pixels can be removed, but the entire mask becomes
    smaller, reducing the area that we would like to measure. Using **Dilate** directly
    after an **Erode** operation (or using **Open**), we can remove isolated pixels
    while still preserving the area we would like to measure. Once an FG pixel is
    lost because of **Erode**, it can never return, no matter how many times you use
    **Dilate**!
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用**腐蚀**时，可以移除孤立像素，但整个蒙版会变得更小，从而减少了我们想要测量的区域。在**腐蚀**操作之后直接使用**膨胀**（或使用**开运算**），我们可以在保留我们想要测量的区域的同时移除孤立像素。一旦由于**腐蚀**而丢失前景像素，它就永远无法返回，无论你使用多少次**膨胀**！
- en: Now, select **Dilate** from the **Do** drop-down menu, set **Count** to `1`
    again, and see what the effect is. When you use the dilate operator, the text
    will become thicker, but it also fills in the gaps in the letters. This outcome
    is much more useful. However, there are a few problems here. The bottom tail of
    the letter **g** as well as the opening of the letter **e** are now filled in.
    By increasing **Count** to `2`, this problem is ameliorated, and the letter **e**
    as well as the tail of the letter **g** are open again. When **Count** is `2`,
    **Dilate** fixes the problem of the fragments. However, our letters are now much
    thicker, and some letters have merged. Take a look at **eJ** in the word **ImageJ**.
    The tail of the letter **e** is directly connected to the tail of the letter **J**.
    We would now like to take two steps. First, we want to dilate the mask to fill
    the gaps, and then, we want to erode the mask to get rid of the connected letters.
    Executing the operators in succession on the mask can perform this combination.
    First, we will dilate the mask, and then, we will erode the result. However, there
    is also a special function that performs both steps in this order called **Close**.
    If you want to perform the steps in the opposite order (first erode and then dilate),
    you can use the **Open** function.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，从**执行**下拉菜单中选择**膨胀**，将**计数**设置为`1`，看看效果如何。当你使用膨胀操作时，文本会变得更粗，但它也会填充字母中的间隙。这种结果更有用。然而，这里有几个问题。字母**g**的底部尾巴以及字母**e**的开口现在被填充了。通过将**计数**增加到`2`，这个问题得到了改善，字母**e**以及字母**g**的尾巴再次打开。当**计数**为`2`时，**膨胀**修复了碎片问题。然而，我们的字母现在变得非常粗，一些字母合并了。看看单词**ImageJ**中的**eJ**。字母**e**的尾巴直接连接到字母**J**的尾巴。我们现在想采取两个步骤。首先，我们想要膨胀蒙版以填充间隙，然后，我们想要腐蚀蒙版以去除连接的字母。对蒙版连续执行操作可以完成这种组合。首先，我们将膨胀蒙版，然后我们将腐蚀结果。然而，还有一个特殊功能可以按此顺序执行这两个步骤，称为**闭合**。如果你想按相反的顺序执行步骤（先腐蚀然后膨胀），可以使用**开运算**。
- en: 'When you select the **Close** option in the drop-down menu, you can see the
    result of this action. The result is OK, but not that great. The fact that the
    result in this case is not that great is caused by the fact that we used different
    values of **Count** for each step. The **Dilate** operator worked best when we
    used `2`, while the **Erode** operator worked best when we used a value of `7`
    or `8`. For this example, it is better to perform the **Dilate** and **Erode**
    operators in succession with specific values for count in each step. In the following
    images, the **Close** operation was used with a value of `2` for count, while
    the succession of **Dilate** and **Erode** were performed using `2` and `5`, respectively
    (the left-hand-side image is the original mask):'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在下拉菜单中选择**闭运算**选项时，你可以看到这个动作的结果。结果是OK，但并不那么出色。在这种情况下，结果并不那么好的原因是我们在每个步骤中使用了不同的**计数**值。**膨胀**操作在我们使用`2`时效果最好，而**腐蚀**操作在`7`或`8`时效果最好。对于这个例子，最好以每个步骤中特定的计数值连续执行**膨胀**和**腐蚀**操作。在以下图像中，**闭运算**使用了`2`的计数值，而**膨胀**和**腐蚀**的连续操作分别使用了`2`和`5`（左侧图像是原始掩码）：
- en: '![Erode and dilate](img/Insert_image_4909_03b_07.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![腐蚀和膨胀](img/Insert_image_4909_03b_07.jpg)'
- en: As can be seen in the middle and right panels, both methods have their advantages
    and drawbacks. The **Close** operation (middle panel) filled in the letter **e**,
    and there is still an isolated pixel that is part of the letter **a**. However,
    the letters themselves still have good details. The manual successive dilate/erode
    steps (right panel) preserved the hole in the letter e as well as the details
    of the letter **g**. However, the details of the letter **a** are less pronounced.
    Specifically, the *serif* (the small hook at the bottom-right corner of the letter
    **a**) is completely lost.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如中间和右侧面板所示，两种方法都有其优点和缺点。**闭运算**（中间面板）填充了字母**e**，并且仍然有一个孤立的像素是字母**a**的一部分。然而，字母本身仍然有很好的细节。手动连续膨胀/腐蚀步骤（右侧面板）保留了字母**e**中的孔以及字母**g**的细节。然而，字母**a**的细节不太明显。具体来说，*衬线*（字母**a**右下角的小钩）完全丢失了。
- en: Skeletonize and watershed
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 骨架化和分水岭
- en: After processing the mask using **Dilate**, **Erode**, **Open**, and **Close**,
    we may want to reduce the mask to the most basic features. The core of the letters
    that we segmented earlier is formed by the strokes. Each character consists of
    a set of strokes in different directions, which together define the character.
    In ImageJ, we can recreate these strokes using the skeletonize function, which
    can be found by going to **Process** | **Binary** | **Skeletonize** in the menu
    or by selecting it from the **Do** drop-down menu in the binary options dialog.
    **Skeletonize** looks at each pixel's neighbors and removes a pixel if it is flanked
    by other FG pixels. This leads to reducing the mask to a single pixel width mask.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用**膨胀**、**腐蚀**、**开运算**和**闭运算**处理掩码后，我们可能希望将掩码简化到最基本特征。我们之前分割的字母的核心是由笔画构成的。每个字符由一组不同方向的笔画组成，这些笔画共同定义了字符。在ImageJ中，我们可以使用骨架化功能来重新创建这些笔画，该功能可以通过在菜单中选择**处理**
    | **二值** | **骨架化**来找到，或者通过在二值选项对话框的**做**下拉菜单中选择它。**骨架化**会检查每个像素的邻居，如果像素被其他前景像素包围，则会移除该像素。这导致将掩码简化为单像素宽度的掩码。
- en: 'When applied to the result of the masks after our close (left panel) and successive
    dilate/erode (right panel) operations, the results are as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 将闭运算（左侧面板）和连续膨胀/腐蚀（右侧面板）操作的结果应用于掩码，结果如下：
- en: '![Skeletonize and watershed](img/Insert_image_4909_03b_08.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![骨架化和分水岭](img/Insert_image_4909_03b_08.jpg)'
- en: The result from the **Close** operation (left panel) is not very satisfactory.
    The letter **e** is unrecognizable and looks more like a letter **c**. The successive
    dilate/erode operation (right panel) has a slightly better result due to the skeletonize
    operations. Although the letters look a bit funny and wobbly, all the important
    strokes are present.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '**闭运算**操作的结果（左侧面板）并不令人满意。字母**e**无法识别，看起来更像字母**c**。连续的膨胀/腐蚀操作（右侧面板）由于骨架化操作而略有改善。尽管字母看起来有点滑稽和摇摆，但所有重要的笔画都存在。'
- en: The watershed function separates objects that are touching. We will look at
    the effect of this operation using the blobs sample image. You could apply it
    to the text example. However, the problem in the text example was the fact that
    objects needed to be joined not separated.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 分水岭功能将分离接触的物体。我们将通过使用连通区域样本图像来查看此操作的效果。你也可以将其应用于文本示例。然而，文本示例中的问题是物体需要连接而不是分离。
- en: Open the **Blobs** image from the sample images.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从样本图像中打开**连通区域**图像。
- en: Set a threshold using the **Default** method, leave the **Dark background**
    box unchecked, and click on **Apply** to create the mask.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**默认**方法设置阈值，不勾选**暗背景**框，然后点击**应用**以创建掩码。
- en: Now, go to **Process** | **Binary** | **Watershed** from the menu.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，从菜单中选择**处理** | **二值** | **分水岭**。
- en: 'The result will look as follows, with the original mask to the left and the
    result of the watershed operation to the right:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将如下所示，左侧为原始掩码，右侧为分水岭操作的结果：
- en: '![Skeletonize and watershed](img/Insert_image_4909_03b_09.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![骨架化和分水岭](img/Insert_image_4909_03b_09.jpg)'
- en: As can be seen, four blobs were split into two separate objects each. This operation
    looks for areas that are pinched. When an object has a narrow part between two
    thicker parts (similar to the middle of an 8), it will be separated along the
    narrow part. Notice, however, that this does not work for some of the blobs (indicated
    by blue rectangles). When there is no pinch in the outline, the watershed algorithm
    will not split the object. This would be very useful if you wish to quantify the
    number of objects when you know that objects can overlap. However, you may run
    into problems if you wish to measure object size or area. As the overlapping area
    cannot be measured accurately, the measurements for overlapping objects will underestimate
    the actual size. This problem can be solved by assuming that the objects have
    a regular shape, such as an oval, but this might not hold in many cases. In ImageJ,
    this latter assumption can be used using the particle analyzer, which will be
    discussed in [Chapter 5](ch05.html "Chapter 5. Basic Measurements with ImageJ"),
    *Basic Measurements with ImageJ*. The best way to solve this problem is by making
    sure that the amount of overlap is reduced, which might require changes in your
    sample preparation or acquisition.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如所示，四个连通区域被分割成两个独立的对象。此操作寻找被挤压的区域。当一个物体在两个较厚的部分之间有一个狭窄的部分（类似于数字8的中间），它将沿着狭窄部分被分割。然而，请注意，这并不适用于某些连通区域（用蓝色矩形表示）。当轮廓没有挤压时，分水岭算法不会分割物体。如果你知道物体可以重叠，并且想要量化物体的数量时，这将非常有用。然而，如果你想要测量物体的大小或面积，可能会遇到问题。因为重叠区域无法准确测量，重叠物体的测量值将低估实际大小。这个问题可以通过假设物体具有规则形状（如椭圆形）来解决，但在许多情况下这可能不成立。在ImageJ中，可以使用颗粒分析器使用这个后者的假设，这将在[第5章](ch05.html
    "第5章。使用ImageJ的基本测量")，*使用ImageJ的基本测量*中讨论。解决这个问题的最好方法是确保重叠量减少，这可能需要改变你的样本制备或采集。
- en: Image filtering
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图像滤波
- en: The previous section looked at ways to segment the image in the foreground and
    background using a threshold. It also looked at ways to derive a result suitable
    for analysis with the use of morphological operators. The morphological operators
    were used to clean the results of the threshold by removing isolated pixels. In
    most real-life applications, these isolated pixels are due to the effect of noise
    in your image-acquisition system. Some of the noise can be removed using the techniques
    described in the previous chapter, but this may not remove all the noise. In this
    section, we will look at ways to use filters to remove noise and prepare images
    to create masks. Filtering can be a step that is inserted before thresholding
    and morphological processing. If your images are high contrast and have extremely
    low levels of noise, this might not be required. However, this is relatively rare.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 上一节探讨了使用阈值分割前景和背景的方法。它还探讨了使用形态学算子得到适合分析的结果的方法。形态学算子被用来通过去除孤立像素来清理阈值的结果。在大多数实际应用中，这些孤立像素是由于图像采集系统中的噪声效应造成的。一些噪声可以使用上一章中描述的技术去除，但这可能不会去除所有噪声。在本节中，我们将探讨使用过滤器去除噪声并准备图像以创建掩码的方法。滤波可以是插入在阈值和形态学处理之前的一个步骤。如果你的图像对比度很高且噪声水平极低，这可能不是必需的。然而，这种情况相对罕见。
- en: 'There are two categories of filtering, depending on the type of domain that
    is used for filtering. Images can be seen in two different domains: the **spatial**
    and the **frequency** domain. The most recognizable to humans is the spatial domain.
    This is an image as we recognize it from our cameras. Each location in space has
    a value, and the combination of an area filled with closely spaced locations with
    differing values forms an image. If all the values were identical, the image would
    appear uniform as a single color or gray. In the case of digital images, locations
    are specified by the pixels that form the image, and the value is represented
    as a gray value or an RGB value.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 根据用于滤波的域类型，滤波可以分为两类。图像可以在两个不同的域中看到：**空间域**和**频域**。对人类来说最易识别的是空间域。这是我们通过相机认识到的图像。空间中的每个位置都有一个值，由具有不同值的紧密排列的位置区域组合形成的图像。如果所有值都相同，图像将呈现为单一颜色或灰度均匀。在数字图像的情况下，位置由构成图像的像素指定，值以灰度值或RGB值表示。
- en: The frequency domain is less recognizable to humans. An image in the frequency
    domain is represented by the rate of change of values or frequency. Humans recognize
    frequency in terms of wavelengths of light. Light with a higher frequency will
    appear blue/violet, while light with a lower frequency will appear orange/red.
    However, in image processing, the frequency of an image is determined by the way
    pixel intensities change within an image, and not necessarily the color of the
    pixels. I will start with filtering in the frequency domain, as this is more complex.
    Note that most of the filtering for image processing is done in the spatial domain
    with excellent results.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 频域对人类来说不太容易识别。频域中的图像是通过值的改变率或频率来表示的。人类通过光波的波长来识别频率。频率较高的光看起来是蓝色/紫色，而频率较低的光看起来是橙色/红色。然而，在图像处理中，图像的频率是由图像中像素强度变化的方式决定的，而不一定是像素的颜色。我将从频域滤波开始，因为这更为复杂。请注意，图像处理的大部分滤波都是在空间域中进行的，并且效果非常好。
- en: Filtering in the frequency domain
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 频域滤波
- en: 'Filtering of images is based on a transformation technique described by Joseph
    Fourier in 1822\. This transformation takes data in one domain and transforms
    it to a different domain and back again. For image processing, the transformation
    goes from the *spatial domain* to the *frequency domain*. The spatial domain considers
    points to be in a space, either a plane (2D) or a volume (3D). Each location of
    a point has an intensity value, which changes over different locations for most
    images. The rate at which the intensities change along a dimension determines
    the frequency. Take a look at this artificial image:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图像滤波基于1822年由约瑟夫·傅里叶描述的变换技术。这种变换将一个域中的数据转换到另一个域，然后再转换回来。对于图像处理，这种变换是从**空间域**到**频域**的转换。空间域考虑点位于空间中，要么是平面（2D），要么是体积（3D）。每个点的位置都有一个强度值，对于大多数图像，这个值会随着不同位置而变化。强度沿一个维度变化的速率决定了频率。看看这张人工图像：
- en: '![Filtering in the frequency domain](img/Insert_image_4909_03b_10.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![频域滤波](img/Insert_image_4909_03b_10.jpg)'
- en: 'If we look at the profile of intensity along the width of the image as well
    as along the height of the image in the middle, we would get the following results
    (horizontal profile to the left and vertical profile to the right):'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们观察图像宽度方向以及中间图像高度方向上的强度轮廓，我们会得到以下结果（水平轮廓在左侧，垂直轮廓在右侧）：
- en: '![Filtering in the frequency domain](img/Insert_image_4909_03b_11.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![频域滤波](img/Insert_image_4909_03b_11.jpg)'
- en: As is obvious from these plots, there is a clear difference in the rate of intensity
    changes. The horizontal profile (left) shows fast changes in intensity over distance,
    while the vertical profile (right) shows no change whatsoever. Another way of
    describing this is that the frequency along the horizontal profile is large, while
    it is low on the vertical axis.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 从这些图中很明显可以看出，强度变化率存在明显的差异。水平轮廓（左侧）显示了强度随距离的快速变化，而垂直轮廓（右侧）则完全没有变化。另一种描述方式是，水平轮廓上的频率较高，而垂直轴上的频率较低。
- en: 'The Fourier transform will calculate the frequencies in the spatial domain
    and plot them as frequencies in the *X* and *Y* direction. The idea of the transform
    is based on the fact that any signal can be described as the (infinite) sum of
    harmonic functions (that is, sines and cosines) with different frequencies. These
    frequencies are represented by the coefficients for the sines and cosines, which
    are displayed as gray values by ImageJ in an image. We will obtain the Fourier
    transform that is, **Fast Fourier Transform** (**FFT**) of the artificial image
    by going to **Process** | **FFT** | **FFT** from the menu:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 傅里叶变换将计算空间域中的频率，并将它们作为*x*和*y*方向上的频率绘制出来。变换的思想基于这样一个事实，即任何信号都可以描述为不同频率的谐波函数（即正弦和余弦函数）的（无限）和。这些频率由正弦和余弦的系数表示，ImageJ以灰度值的形式在图像中显示这些系数。我们可以通过从菜单中选择**处理**
    | **FFT** | **FFT**来获得人工图像的傅里叶变换，即**快速傅里叶变换**（**FFT**）：
- en: '![Filtering in the frequency domain](img/Insert_image_4909_03b_12.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![频域滤波](img/Insert_image_4909_03b_12.jpg)'
- en: The center (that is, origin) of the image has a frequency of 0, while the horizontal
    line through the origin represents the frequencies along the *x* axis of the image.
    The values in the quadrants determine the frequencies along the diagonals of the
    image. Values close to the center of the image represent low frequencies, while
    values close to the edge represent higher frequencies. As there is only a change
    in frequency along the *X* coordinates of the image, the transformed image shows
    only vertical lines. If the pattern had been diagonal, the lines in the transformed
    image would also be diagonal.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图像的中心（即原点）的频率为0，而通过原点的水平线代表图像的*x*轴上的频率。象限中的值决定了图像对角线上的频率。靠近图像中心的值代表低频率，而靠近边缘的值代表较高频率。由于图像沿*x*坐标的变化只有频率的变化，因此变换后的图像只显示垂直线。如果模式是斜的，变换后的图像中的线条也将是斜的。
- en: Note
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The dashed appearance of the lines in the transformed image is caused by the
    fact that the input image was not square. The width is 512, but the height only
    128 pixels. If the image were a 512 x 512 square, the transformed image would
    only show a row of dots along the *x* axis through the origin. If you halved the
    height of the sample image, the dashes become roughly twice as long.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 变换后的图像中线条的虚线外观是由输入图像不是正方形造成的。宽度是512，但高度只有128像素。如果图像是512 x 512的正方形，变换后的图像将只显示通过原点的*x*轴上的一行点。如果你将样本图像的高度减半，虚线将大约变为两倍长。
- en: 'When we use the FFT image as input, we can create the original image when we
    select **Process** | **FFT** | **Inverse FFT** from the menu:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用FFT图像作为输入时，我们可以通过从菜单中选择**处理** | **FFT** | **逆FFT**来创建原始图像：
- en: '![Filtering in the frequency domain](img/Insert_image_4909_03b_13.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![频域滤波](img/Insert_image_4909_03b_13.jpg)'
- en: Note that since we used the FFT and immediately the inversed FFT, we actually
    did not apply any filtering. The image before and after the transform is identical.
    This is a very desirable feature of the transform, because this means that the
    transform is lossless. No information was lost during the process. To actually
    filter the image, we need to modify the transformed image by modifying the pixel
    values in the transformed image.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，由于我们使用了FFT和立即的逆FFT，实际上我们没有应用任何滤波。变换前后的图像是相同的。这是变换的一个非常理想的特点，因为这意味着变换是无损的。在过程中没有丢失任何信息。要实际滤波图像，我们需要通过修改变换图像中的像素值来修改变换后的图像。
- en: 'To apply some (crude) filtering, we will take the following steps:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 要应用一些（粗略的）滤波，我们将采取以下步骤：
- en: Select the transformed image.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择变换后的图像。
- en: 'Go to **Edit** | **Selection** | **Specify…** from the menu and enter the following
    values: **Width** as `255`, **Height** as `255`, **X coordinate** as `0`, and
    **Y coordinate** as `0`. Then, press **OK**.'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从菜单中选择**编辑** | **选择** | **指定…**并输入以下值：**宽度**为`255`，**高度**为`255`，**X坐标**为`0`，**Y坐标**为`0`。然后，按**确定**。
- en: Open the color picker by going to **Image** | **Color** | **Color Picker** from
    the menu or pressing *Ctrl* + *Shift* + *K* on the keyboard.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过从菜单中选择**图像** | **颜色** | **颜色选择器**或按*Ctrl* + *Shift* + *K*键在键盘上打开颜色选择器。
- en: Make sure that the foreground is set to black by clicking on the little icon
    of a black-and-white square in the bottom-right corner of the color picker.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保通过点击颜色选择器右下角的小黑白方块图标将前景设置为黑色。
- en: Now, fill the selection that we specified with black by going to **Edit** |
    **Fill** or by pressing *Ctrl* + *F*.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，通过转到**编辑** | **填充**或按*Ctrl* + *F*来用黑色填充我们指定的选择区域。
- en: Repeat steps 2 and 5, but now, specify the selection to have the *X* and *Y*
    coordinates of `257`.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复步骤2和5，但现在，指定选择区域的*X*和*Y*坐标为`257`。
- en: Finally, go to **Process** | **FFT** | **Inverse FFT** from the menu to generate
    the filtered image.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，从菜单中选择**处理** | **FFT** | **逆FFT**以生成滤波后的图像。
- en: 'If you followed the instructions, your FFT image would look as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你遵循了指示，你的FFT图像将如下所示：
- en: '![Filtering in the frequency domain](img/Insert_image_4909_03b_14.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![频率域中的滤波](img/Insert_image_4909_03b_14.jpg)'
- en: 'The inverse FFT image will look as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 逆FFT图像将如下所示：
- en: '![Filtering in the frequency domain](img/Insert_image_4909_03b_15.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![频率域中的滤波](img/Insert_image_4909_03b_15.jpg)'
- en: 'As can be seen in the inverse FFT image, there are now significant differences
    before and after the manipulations. For instance, the frequency in the vertical
    direction is different. Each bar now changes intensity as you go from top to bottom.
    Try the same routine, but this time, specify the selection using the following
    parameters in step 2, and skip step 6:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如在逆FFT图像中所示，经过操作前后存在显著差异。例如，垂直方向上的频率不同。现在，每根条形图从上到下强度都会发生变化。尝试相同的程序，但这次在步骤2中，使用以下参数指定选择区域，并跳过步骤6：
- en: '**Width**: `64`'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**宽度**: `64`'
- en: '**Height**: `512`'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高度**: `512`'
- en: '**X coordinate**: `272`'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**X坐标**: `272`'
- en: '**Y coordinate**: `0`'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Y坐标**: `0`'
- en: 'After filling in the selection with black and calculating the inverse FFT,
    the image will appear as shown here in the right panel. You have specifically
    removed a small subset of the frequencies from the frequency domain. After calculating
    the inverse FFT, you will get the following result (zoomed area in the top-left
    corner):'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在用黑色填充选择区域并计算逆FFT后，图像将如右面板所示。你已特别从频率域中移除了一小部分频率。在计算逆FFT后，你将得到以下结果（左上角缩放区域）：
- en: '![Filtering in the frequency domain](img/Insert_image_4909_03b_16.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![频率域中的滤波](img/Insert_image_4909_03b_16.jpg)'
- en: On the left-hand side, you see the original image, and on the right-hand side
    is the filtered image. As the region selected and removed entailed the lower frequencies,
    the higher frequencies remain resulting in a greater change in the intensity values
    along the horizontal axis.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在左侧，你看到的是原始图像，在右侧是滤波后的图像。由于选择和移除的区域涉及低频，高频保持不变，导致沿水平轴的强度值变化更大。
- en: As this example is very artificial, the results here are not necessarily practical
    for analysis. However, if you have an image that is corrupted by high-frequency
    intensity changes (for example, imaging noise), you know you have to remove the
    frequencies at the edge of the FFT transform. On the other hand, if you have a
    slow gradient of intensity changes (for example, uneven illumination), you need
    to remove the low frequencies in the FFT transform. Using black to remove the
    frequencies, you're creating a filter that excludes the frequencies covered by
    your selection. If you filled the selection with white, you would include all
    the selected frequencies covered by your selection. In the next section, we will
    look at filtering in the spatial domain, which is slightly more intuitive to apply.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个例子非常人为，这里的结果不一定适用于分析。然而，如果你有一个被高频强度变化（例如，成像噪声）损坏的图像，你知道你必须移除FFT变换边缘的频率。另一方面，如果你有一个强度变化的缓慢梯度（例如，不均匀照明），你需要移除FFT变换中的低频。使用黑色移除频率，你正在创建一个排除你选择覆盖的频率的滤波器。如果你用白色填充选择区域，你会包括所有被选择覆盖的频率。在下一节中，我们将探讨空间域中的滤波，这稍微更容易应用。
- en: Image filtering in the spatial domain
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 空间域图像滤波
- en: 'Filtering in the spatial domain involves using a filter, usually referred to
    as a **kernel**. This filter transforms every pixel using a method called **convolution**.
    Convolution involves taking a center pixel with a small array of neighboring pixels
    (usually 3 x 3) and multiplying the intensities with a set of weights as defined
    in the kernel. The sum of the multiplications will become the new pixel intensity
    for the center pixel. In the following example, there is a part of an image (left),
    the kernel (middle), and the outcome of the convolution (right):'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在空间域中进行滤波涉及使用一个滤波器，通常称为**核**。这个滤波器通过一种称为**卷积**的方法转换每个像素。卷积包括取一个中心像素及其周围的小数组像素（通常是3
    x 3），并将这些像素的强度与核中定义的权重相乘。乘积的总和将成为中心像素的新强度。在以下示例中，有一个图像的一部分（左侧），核（中间），以及卷积的结果（右侧）：
- en: '![Image filtering in the spatial domain](img/Insert_image_4909_03b_17.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![空间域中的图像滤波](img/Insert_image_4909_03b_17.jpg)'
- en: 'The center pixel (highlighted in orange) and the surrounding pixels in a 3
    x 3 neighborhood are multiplied with the kernel (middle). The result of the convolution
    is shown on the right-hand side. The value of the center pixel used to be 128,
    but is now 78 after convolution. The kernel shown in this example is a simple
    smoothing filter (also called a **box** filter). The main effect of this filter
    is that it averages pixels, resulting in a blurring of the image. The following
    image is a detail from the **Boats** sample image, before (left) and after (right)
    convolving with the box filter:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 中心像素（橙色突出显示）及其3 x 3邻域内的周围像素与核（中间）相乘。卷积的结果显示在右侧。中心像素的值原本是128，但卷积后变为78。在这个示例中显示的核是一个简单的平滑滤波器（也称为**方框**滤波器）。这个滤波器的主要效果是平均像素，导致图像模糊。以下图像是“Boats”样本图像的细节，在卷积前（左侧）和卷积后（右侧）：
- en: '![Image filtering in the spatial domain](img/Insert_image_4909_03b_18.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![空间域中的图像滤波](img/Insert_image_4909_03b_18.jpg)'
- en: 'When you change the filter size to 7 x 7, the effect of the smoothing will
    be much stronger, as more pixels in the neighborhood will influence the value
    of the center pixel. When using the box filter with a size of 7 x 7, each weight
    will be equal to 1/49\. The result for the same image will look as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将滤波器大小更改为7 x 7时，平滑的效果将会更强烈，因为更多的邻域像素将影响中心像素的值。当使用7 x 7大小的方框滤波器时，每个权重将等于1/49。相同图像的结果将如下所示：
- en: '![Image filtering in the spatial domain](img/Insert_image_4909_03b_19.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![空间域中的图像滤波](img/Insert_image_4909_03b_19.jpg)'
- en: Notice that the filtering has almost completely smoothed the letters, making
    them unrecognizable. The box filter functions as a low-pass filter—only low frequencies
    in the image will remain. This is caused by the fact that fast changes in intensity
    will be smoothed out more aggressively by the box filter than the low frequencies.
    Even though this filtering happens in the spatial domain, the effects are also
    reflected in the frequency domain.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到滤波几乎完全平滑了字母，使它们难以辨认。方框滤波器充当低通滤波器——图像中只有低频部分会保留。这是由于快速变化的强度会被方框滤波器比低频更强烈地平滑掉。尽管这种滤波发生在空间域中，但效果也会在频域中反映出来。
- en: 'To recreate the preceding images, follow these steps on the **Boats** image
    from the sample images:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 要重新创建前面的图像，请在样本图像中的“Boats”图像上按照以下步骤操作：
- en: Select **Process** | **Filters** | **Convolve…** from the menu and remove everything
    in the text field in the dialog that opens.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从菜单中选择**处理** | **滤波器** | **卷积…**，并在打开的对话框中的文本字段中删除所有内容。
- en: Type three 1s separated by a space and press enter. Repeat this twice.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入三个用空格分隔的1，然后按回车。重复此操作两次。
- en: Make sure that the **Normalize kernel** checkbox is selected and press **OK**.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保选中了**归一化核**复选框，然后按**确定**。
- en: The image now looks a little less sharp as it has been convolved with a 3 x
    3 box filter.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在图像看起来稍微不那么清晰了，因为它已经与一个3 x 3的方框滤波器进行了卷积。
- en: If you want to convolve with a 7 x 7 box filter, just type seven rows of seven
    1s separated by spaces, and repeat the steps on a newly opened Boats image to
    see the effect of kernel size.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要使用一个7 x 7的方框滤波器进行卷积，只需输入七行，每行七个用空格分隔的1，然后在新建的“Boats”图像上重复这些步骤，以查看核大小的影响。
- en: Note
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: When applying the kernel on an image that was already convolved, the effect
    will be larger than when the image wasn't convolved yet. When using the 3 x 3
    box filter twice in succession, the effect will be the same as running a 3 x 3
    box filter with weights of 1/81 per pixel (*1/9 * 1/9*).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 当将核应用于已经卷积过的图像时，效果会比图像尚未卷积时更大。当连续两次使用3 x 3箱形滤波器时，效果等同于运行权重为每像素1/81的3 x 3箱形滤波器（*1/9
    * 1/9*）。
- en: The result of filtering using a kernel depends on the values of the weights
    that you specify and the kernel's size. Typically, there are two types of kernel
    that can be separated based on the sum of their weights. When the sum of the weights
    in a kernel adds up to 1, the kernel is called normalized. The advantage of a
    normalized kernel is that the result of the convolution will not exceed the maximum
    pixel value allowed by the bit depth of the image. When the **Normalized kernel**
    checkbox is checked in the **Convolve** dialog, ImageJ will automatically take
    care of the normalization. Non-normalized kernels can exhibit clamping artifacts.
    When the sum of the kernel exceeds 1, the result of convolution may exceed the
    maximum allowable value (that is, 255 for 8-bit images). When this happens, the
    value after the transformation will be clamped at the maximum value. This clamping
    may result in artifacts such as blocks of white pixels.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 使用核进行滤波的结果取决于您指定的权重值和核的大小。通常，根据其权重的总和，可以将核分为两种类型。当一个核中权重的总和为1时，该核被称为归一化核。归一化核的优势在于卷积的结果不会超过图像位深允许的最大像素值。当在**卷积**对话框中勾选**归一化核**复选框时，ImageJ将自动处理归一化。非归一化核可能会出现夹断伪影。当一个核的权重总和超过1时，卷积的结果可能会超过最大允许值（即8位图像的255）。当这种情况发生时，变换后的值将被夹断在最大值。这种夹断可能会导致如白色像素块等伪影。
- en: 'The box filter is a very simple filter, but it does not discriminate any features
    in the image. It averages evenly in all directions. Other filters exist that actually
    enhance certain features in your image. An example of such a filter is the **Mexican
    hat** filter. This filter emphasizes the center pixel over the surrounding pixels:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 箱形滤波器是一个非常简单的滤波器，但它不会在图像中区分任何特征。它在所有方向上均匀平均。其他滤波器实际上可以增强图像中的某些特征。这类滤波器的例子是**墨西哥帽**滤波器。这个滤波器强调中心像素相对于周围像素：
- en: '![Image filtering in the spatial domain](img/Insert_image_4909_03b_20.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![空间域图像滤波](img/Insert_image_4909_03b_20.jpg)'
- en: 'The Mexican hat filter is shaped a little like a sombrero, hence the name.
    It makes areas with high contrast become bright, while areas of uniform intensity
    become darker. Applied on the **Boats** image, the result looks as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 墨西哥帽滤波器形状有点像墨西哥草帽，因此得名。它使得高对比度区域变亮，而均匀强度的区域变暗。应用于**Boats**图像，结果如下：
- en: '![Image filtering in the spatial domain](img/Insert_image_4909_03b_21.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![空间域图像滤波](img/Insert_image_4909_03b_21.jpg)'
- en: What stands out immediately is the fact that the edges of the letters are greatly
    emphasized. This makes sense because the contrast is relatively strong. These
    are black letters on a mostly even light-gray background. The only edges that
    are not clearly recognizable are the points where the letters touch each other
    and the places where the ropes hide parts of the letters. You can imagine that
    this filter might also work well for the text example and the segmentation of
    the blobs mentioned earlier. It basically functions as a high-pass filter. Only
    regions with fast changes in intensity are emphasized, while regions with slow
    changes in intensity (that is, low frequencies) are reduced.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 立即引人注目的是字母边缘被极大地强调。这很合理，因为对比度相对较强。这些是黑色字母，背景主要是均匀的浅灰色。唯一不清晰可辨的边缘是字母接触的点以及绳索隐藏字母部分的地方。你可以想象这个过滤器也可能对文本示例和前面提到的blob分割效果很好。它基本上作为一个高通滤波器工作。只有强度变化快的区域被强调，而强度变化慢的区域（即低频）被减少。
- en: Besides entering kernel weights manually, ImageJ and Fiji also have some common
    filter kernels that can be accessed by going to **Process** | **Filters**. Two
    of the most often used filter kernels include the **Gaussian Blur…** and the **Mean…**
    filter. The latter is identical to the box filter. The former is similar to the
    Mexican hat filter. However, it does not use negative values in the kernel. The
    **Gaussian Blur** filter smoothens the image just like a box filter does, but
    it does it in a more gradual way. The advantage of **Gaussian Blur** is that it
    can have fewer artifacts when you apply it. The response of the filter in the
    frequency domain is also better, making it possible to combine spatial and frequency
    domain filtering.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 除了手动输入核权重外，ImageJ和Fiji还有一些常见的滤波器核，可以通过访问**处理**|**滤波器**来获取。最常用的两个滤波器核包括**高斯模糊…**和**均值…**滤波器。后者与方滤波器相同。前者类似于墨西哥帽滤波器。然而，它不使用核中的负值。**高斯模糊**滤波器平滑图像的方式与方滤波器相同，但它以更渐进的方式完成。**高斯模糊**的优势在于，当你应用它时，可以产生更少的伪影。滤波器在频域的响应也更好，这使得结合空间域和频域滤波成为可能。
- en: Next, we will look at some operators that can be used to detect specific features
    in an image that may be relevant for processing. These operators also use convolution,
    but they have different properties compared to the filters described earlier.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨一些可以用于检测图像中可能对处理相关的特定特征的算子。这些算子也使用卷积，但它们与前面描述的滤波器具有不同的特性。
- en: Feature extraction
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 特征提取
- en: As we saw in the earlier sections, filters can be used to isolate different
    frequencies using filters. By convolving an image with a Mexican hat filter, high
    frequencies are preserved, while using the box filter has the opposite effect.
    The difference between the filters in this section and the filters in the previous
    section is in specificity. The Mexican hat filter had no preference for direction.
    When there was an edge with sharp contrast (quick change in intensity), the filter
    had a strong effect. However, sometimes, you are only interested in a specific
    type of edge. Let's assume that we only want to detect vertical edges. The Mexican
    hat filter will give us all the edges in all directions, not just the vertical
    ones. This will be the topic of the following section.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在前面的章节中看到的，可以使用滤波器通过滤波器隔离不同的频率。通过将图像与墨西哥帽滤波器卷积，可以保留高频，而使用方滤波器则产生相反的效果。本节中滤波器与上一节中滤波器的区别在于特异性。墨西哥帽滤波器没有方向偏好。当存在具有尖锐对比度（强度快速变化）的边缘时，滤波器有强烈的效果。然而，有时你只对特定类型的边缘感兴趣。假设我们只想检测垂直边缘。墨西哥帽滤波器将给我们所有方向的边缘，而不仅仅是垂直的。这将是下一节的主题。
- en: Edge detection
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 边缘检测
- en: 'To detect only vertical edges, we need to create a kernel that emphasizes pixels
    that are in a vertical orientation. The following kernels can detect different
    orientations of edges:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 要检测仅垂直的边缘，我们需要创建一个强调垂直方向的像素的核。以下核可以检测不同方向的边缘：
- en: '![Edge detection](img/Insert_image_4909_03b_22.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![边缘检测](img/Insert_image_4909_03b_22.jpg)'
- en: To perform the **Sobel edge** detection, you can use the **Find Edges** command
    from the **Process** menu. This command will run both the horizontal and the vertical
    Sobel kernel over the image.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行**Sobel边缘**检测，您可以使用**处理**菜单中的**查找边缘**命令。此命令将在图像上运行水平和垂直的Sobel核。
- en: 'Finally, there is also the **Canny procedure** for edge detection that involves
    five steps. This procedure was developed by John F. Canny and consists of the
    following steps:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，还有用于边缘检测的**Canny过程**，它涉及五个步骤。此过程由John F. Canny开发，包括以下步骤：
- en: Apply Gaussian smoothing to remove noise.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用高斯平滑以去除噪声。
- en: Detect gradients in the image using edge detection.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用边缘检测在图像中检测梯度。
- en: Thin edges using convolution with a kernel such as the Mexican hat.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用类似墨西哥帽的核通过卷积细化边缘。
- en: Apply two different thresholds to determine weak and strong edges.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用两个不同的阈值来确定弱边和强边。
- en: Remove weak edges that are not connected to strong edges.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 移除那些未连接到强边的弱边。
- en: The first three steps involve using different kernels for smoothing, edge detection,
    and edge thinning in succession. Note that the first step is only required if
    the image is degraded by noise. If the contrast is high and noise is absent, this
    step can be skipped. This step is also the weakest point of the procedure. Both
    noise and edges are forms of high-frequency signals, and the Gaussian filter smoothens
    both equally. If noise is present, techniques that reduce the noise specifically
    while leaving the edges intact should show great improvement.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 前三个步骤涉及依次使用不同的核进行平滑、边缘检测和边缘细化。请注意，如果图像因噪声而退化，则第一步是必需的。如果对比度高且没有噪声，则可以跳过这一步。这一步也是整个流程中最薄弱的点。噪声和边缘都是高频信号的形式，高斯滤波器对两者进行同等程度的平滑。如果存在噪声，那些在保留边缘的同时专门减少噪声的技术应该会显示出显著的改进。
- en: Summary
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we looked at ways to separate an image into foreground and
    background. We saw different methods to set the threshold in grayscale and color
    images. We applied filtering in the spatial and frequency domains to aid in cleaning
    the image and extracting edges for further processing. All these steps will help
    us when we wish to measure objects in the image, which is the topic of the next
    chapter.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了将图像分离为前景和背景的方法。我们看到了在灰度和彩色图像中设置阈值的不同方法。我们应用了空间域和频域中的滤波来帮助清洁图像并提取边缘以供进一步处理。所有这些步骤都将帮助我们，当我们希望测量图像中的对象时，这是下一章的主题。
