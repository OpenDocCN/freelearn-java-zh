<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Better Management of the OS Process</h1>
                </header>
            
            <article>
                
<p>In this chapter, we will cover the following recipes:</p>
<ul>
<li>Spawning a new process</li>
<li>Redirecting the process output and error streams to file</li>
<li>Changing the working directory of a subprocess</li>
<li>Setting the environment variable for a subprocess</li>
<li>Running shell scripts</li>
<li>Obtaining the process information of the current JVM</li>
<li>Obtaining the process information of the spawned process</li>
<li>Managing the spawned process</li>
<li>Enumerating live processes in the system</li>
<li>Connecting multiple processes using pipe</li>
<li>Managing subprocesses</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introduction</h1>
                </header>
            
            <article>
                
<p>How often have you ended up writing code that spawns a new process? Not often. However, there would be situations that ask for writing such code. In such cases, you resort to using a third-party API such as Apache Commons Exec (<a href="https://commons.apache.org/proper/commons-exec/">https://commons.apache.org/proper/commons-exec/</a>) and the like. Why was this? Wasn't the Java API sufficient? No, it wasn't, at least until Java 9. Now with Java 9, we have quite a few more features added to the process API. </p>
<p>Until Java 7, redirecting the input, output, and error streams was not trivial. With Java 7, there were new APIs introduced, which allowed the redirecting of the input, output, and error to other processes (pipe), to a file, or to a standard input/output. Then in Java 8, there were a few more APIs introduced. In Java 9, there are new APIs for the following areas:</p>
<ul>
<li>Get the process information, such as <strong>process ID</strong> (<strong>PID</strong>), the user who launched the process, the time it has been running for, and so on</li>
<li>Enumerate the processes running in the system</li>
<li>Manage the subprocesses and get access to the process tree by navigating up the process hierarchy</li>
</ul>
<p>In this chapter, we will look at a few recipes that will help you explore the new things in the process API, and you will also get to know the changes that have been introduced from the times of <kbd>Runtime.getRuntime().exec()</kbd>. And you all know that using that was a crime.</p>
<div class="packt_infobox">All the recipes can only be executed on the Linux platform because we will be using Linux-specific commands while spawning a new process from Java code. There are two ways to execute the script <kbd>run.sh</kbd> on Linux:<br/>
<ul>
<li><kbd><span>sh run.sh</span></kbd></li>
<li><kbd><span>chmod +x run.sh &amp;&amp; ./run.sh</span></kbd></li>
</ul>
</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Spawning a new process</h1>
                </header>
            
            <article>
                
<p>In this recipe, we will see how to spawn a new process using <kbd>ProcessBuilder</kbd>. We will also see how to make use of the input, output, and error streams. This should be a very straightforward and common recipe. However, the aim of introducing this is to make this chapter a bit more complete and not just to focus on Java 9 features.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>There is a command in Linux called <kbd>free</kbd>, which shows the amount of RAM free and used by the system. It accepts an option, <kbd>-m</kbd>, to show the output in megabytes. So, just running free <kbd>-m</kbd> gives us the following output: </p>
<div class="CDPAlignCenter CDPAlign"><img height="49" width="489" class="alignnone size-full wp-image-1434 image-border" src="assets/48b5277b-4cb0-4391-bab4-03fc949e5b9f.png"/></div>
<p>We will be running the preceding code from within the Java program.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Create an instance of <kbd>ProcessBuilder</kbd> by providing the required command and its options: </li>
</ol>
<pre>        ProcessBuilder pBuilder = new ProcessBuilder("free", "-m");</pre>
<p style="padding-left: 60px">An alternate way to specify the command and options is as follows:</p>
<pre>        pBuilder.command("free", "-m");</pre>
<ol start="2">
<li>Set up the input and output streams for the process builder and other properties, such as the directory of execution and environment variables. After that, invoke <kbd>start()</kbd> on the <kbd>ProcessBuilder</kbd> instance to spawn the process and get a reference to the <kbd>Process</kbd> object:</li>
</ol>
<pre>        Process p = pBuilder.inheritIO().start();</pre>
<p style="padding-left: 60px">The <kbd>inheritIO()</kbd> function sets the standard I/O of the spawned subprocess to be the same as that of the current Java process.</p>
<ol start="3">
<li>We then wait for the completion of the process, or for 1 second, whichever is sooner, as shown in the following code:</li>
</ol>
<pre>        if(p.waitFor(1, TimeUnit.SECONDS)){
          System.out.println("process completed successfully");
        }else{
          System.out.println("waiting time elapsed, process did <br/>                              not complete");   
          System.out.println("destroying process forcibly");
          p.destroyForcibly();
        }</pre>
<p style="padding-left: 60px">If it doesn't complete in the time specified, then we kill the process by invoking the <span><kbd>destroyForcibly()</kbd> method.</span></p>
<ol start="4">
<li>Compile and run the code by using the following commands:</li>
</ol>
<pre><strong>      $ javac -d mods --module-source-path src $(find src -name *.java)
      $ java -p mods -m process/com.packt.process.NewProcessDemo</strong></pre>
<ol start="5">
<li>The output we get is as follows:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img height="55" width="512" class="image-border" src="assets/ceba2731-e3c6-47fc-9840-45df293995d7.png"/></div>
<p>The code for this recipe can be found at <kbd>chp8/1_spawn_new_process</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>There are two ways to let <kbd>ProcessBuilder</kbd> know which command to run:</p>
<ol>
<li>By passing the command and its options to the constructor while creating the <kbd>ProcessBuilder</kbd> object.</li>
<li>By passing <span>the command and its options as parameters to the <kbd>command()</kbd> method of the <kbd>ProcessBuilder</kbd> object.</span></li>
</ol>
<p>Before spawning the process, we can do the following:</p>
<ul>
<li>We can change the directory of execution by using the <kbd>directory()</kbd> method </li>
<li>We can redirect the input stream, output stream, and error streams to file or to another process</li>
<li>We can provide the required environment variables for the subprocess</li>
</ul>
<p>We will see all these activities in their respective recipes in this chapter.</p>
<p>A new process is spawned when the <kbd>start()</kbd> method is invoked and the caller gets a reference to this subprocess in the form of an instance of the <kbd>Process</kbd> class. Using this <kbd>Process</kbd> object, we can do a lot of things, such as the following:</p>
<ul>
<li>Get information about the process, including its PID</li>
<li>Get the output and error streams</li>
<li>Check for the completion of the process</li>
<li>Destroy the process</li>
<li>Associate the tasks to be performed once the process completes </li>
<li>Check for the subprocesses spawned by the process</li>
<li>Find the parent process of the process if it exists</li>
</ul>
<p>In our recipe, we <kbd>waitFor</kbd> 1 second or the completion of the process (whichever occurs first). If the process has completed, then <kbd>waitFor</kbd> returns <kbd>true</kbd>; else, it returns <kbd>false</kbd>. If the process doesn't complete, we can kill the process by invoking the <kbd>destroyForcibly()</kbd> method on the <kbd>Process</kbd> object.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Redirecting the process output and error streams to file</h1>
                </header>
            
            <article>
                
<p>In this recipe, we will see how to deal with the output and error streams of a process spawned from the Java code. We will write the output or error produced by the spawned process to a file. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>In this recipe, we will make use of the <kbd>iostat</kbd> command. This command is used for reporting the CPU and I/O statistics for different devices and partitions. Let's run the command and see what it reports:</p>
<pre><strong>$ iostat</strong></pre>
<div class="packt_infobox">In some Linux distributions, such as Ubuntu, <kbd>iostat</kbd> is not installed by default. You can install the utility by running <kbd>sudo apt-get install sysstat</kbd>.</div>
<p>The output of the preceding command is as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img height="104" width="557" class="image-border" src="assets/693e431b-2fd6-4e5e-b98b-d5de51ea76d6.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Create a new <kbd>ProcessBuilder</kbd> object by specifying the command to be executed:</li>
</ol>
<pre>        ProcessBuilder pb = new ProcessBuilder("iostat");</pre>
<ol start="2">
<li>Redirect the output and error streams to the file's output and error, respectively:</li>
</ol>
<pre>        pb.redirectError(new File("error"))
          .redirectOutput(new File("output"));</pre>
<ol start="3">
<li>Start the process, and wait for it to complete:</li>
</ol>
<pre>        Process p = pb.start();
        int exitValue = p.waitFor();</pre>
<ol start="4">
<li>Read the content of the output file:</li>
</ol>
<pre>        Files.lines(Paths.get("output"))<br/>                         .forEach(l -&gt; System.out.println(l));</pre>
<ol start="5">
<li>Read the content of the error file. This is created only if there is some error in the command:</li>
</ol>
<pre>        Files.lines(Paths.get("error"))<br/>                         .forEach(l -&gt; System.out.println(l));</pre>
<div class="packt_infobox">Step 4 and 5 are for our reference. This has nothing to do with <kbd>ProcessBuilder</kbd> or the process spawned. Using these two lines of code, we can inspect what was written to the output and error files by the process.</div>
<p style="padding-left: 60px">The complete code can be found at <kbd>chp8/2_redirect_to_file</kbd>.</p>
<ol start="6">
<li>Compile the code by using the following command:</li>
</ol>
<pre><strong>      $ javac -d mods --module-source-path src $(find src -name *.java)</strong></pre>
<ol start="7">
<li>Run the code by using the following command:</li>
</ol>
<pre><strong>      $ java -p mods -m process/com.packt.process.RedirectFileDemo</strong></pre>
<p>We will get the following output:</p>
<div class="CDPAlignCenter CDPAlign"><img height="133" width="540" class="image-border" src="assets/259d9294-e4d8-4e41-9e8b-f4e67b81c859.png"/></div>
<p>We can see that as the command executed successfully; there is nothing in the error file. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There is more...</h1>
                </header>
            
            <article>
                
<p>You can provide an erroneous command to <kbd>ProcessBuilder</kbd> and then see the error get written to the error file and nothing in the output file. You could do this by changing the <kbd>ProcessBuilder</kbd> instance creation as follows:</p>
<pre>ProcessBuilder pb = new ProcessBuilder("iostat", "-Z");</pre>
<p>Compile and run by using the commands given earlier in the <em>How to do it...</em> section.</p>
<p>You will see that there is an error reported in the error file but nothing in the output file:</p>
<div class="CDPAlignCenter CDPAlign"><img height="110" width="479" class="image-border" src="assets/1f1fc4ab-0a88-4efd-ba11-2b29135604a8.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Changing the working directory of a subprocess</h1>
                </header>
            
            <article>
                
<p>Often, you would want a process to be executed in the context of some path, such as listing the files in some directory. In order to do so, we will have to tell <kbd>ProcessBuilder</kbd> to launch the process in the context of a given location. We can achieve this by using the <kbd>directory()</kbd> method. This method serves two purposes: </p>
<ol>
<li>Returns the current directory of execution when we don't pass any parameter.</li>
<li>Sets the current directory of execution to the passed value when we pass a parameter.</li>
</ol>
<p>In this recipe, we will see how to execute the <kbd>tree</kbd> command to recursively traverse all the directories from the current directory and print it in the form of a tree. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>Generally, the <kbd>tree</kbd> command doesn't come preinstalled. So, you will have to install the package that contains the command. To install on an Ubuntu/Debian-based system, run the following command:</p>
<pre><strong>sudo apt-get install tree</strong></pre>
<p>To install on Linux, which supports the <kbd>yum</kbd> package manager, run the following command:</p>
<pre><strong>yum install tree</strong></pre>
<p>To verify your installation, just run the <kbd>tree</kbd> command, and you should be able to see the current directory structure printed. For me, it's something like this:</p>
<div class="CDPAlignCenter CDPAlign"><img height="413" width="292" class="image-border" src="assets/d78da25f-a88e-4949-8854-e0d13f107208.png"/></div>
<p>There are multiple options supported by the <kbd>tree</kbd> command. It's for you to explore. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Create a new <kbd>ProcessBuilder</kbd> object:</li>
</ol>
<pre>        ProcessBuilder pb = new ProcessBuilder();</pre>
<ol start="2">
<li>Set the command to <kbd>tree</kbd> and the output and error to the same as that of the current Java process:</li>
</ol>
<pre>        pb.command("tree").inheritIO();</pre>
<ol start="3">
<li>Set the directory to whatever directory you want. I set it as the root folder:</li>
</ol>
<pre>        pb.directory(new File("/root"));</pre>
<ol start="4">
<li>Start the process and wait for it to exit:</li>
</ol>
<pre>        Process p = pb.start();
        int exitValue = p.waitFor();</pre>
<ol start="5">
<li>Compile and run using the following commands:</li>
</ol>
<pre><strong>      $ javac -d mods --module-source-path src $(find src -name *.java)
      $ java -p mods -m process/com.packt.process.ChangeWorkDirectoryDemo</strong></pre>
<ol start="6">
<li>The output will be the recursive contents of the directory, specified in the <kbd>directory()</kbd> method of the <kbd>ProcessBuilder</kbd> object, printed in a tree like format.</li>
</ol>
<p><span>The complete code can be found at <kbd>chp8/2_redirect_to_file</kbd>.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>The <kbd>directory()</kbd> method accepts the path of the working directory for <kbd>Process</kbd>. The path is specified as an instance of <kbd>File</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Setting the environment variable for a subprocess</h1>
                </header>
            
            <article>
                
<p>Environment variables are just like any other variables that we have in our programming languages. They have a name and hold some value, which can be varied. These are used by the Linux/Windows commands or the shell/batch scripts to perform different operations. These are called environment variables because they are present in the environment of the process/command/script getting executed. Generally, the process inherits the environment variables from the parent process. </p>
<p>They are accessed in different ways in different operating systems. In Windows, they are accessed as <kbd>%ENVIRONMENT_VARIABLE_NAME%</kbd>, and in Unix-based operating systems, they are accessed as <kbd>$ENVIRONMENT_VARIABLE_NAME</kbd>.</p>
<p>In Unix-based systems, you can use the <kbd>printenv</kbd> command to print all the environment variables available for the process, and in Windows-based systems, you can use the <kbd>SET</kbd> command.</p>
<p>In this recipe, we will pass some environment variables to our subprocess and make use of the <kbd>printenv</kbd> command to print all the environment variables available.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Create an instance of <kbd>ProcessBuilder</kbd>:</li>
</ol>
<pre>        ProcessBuilder pb = new ProcessBuilder();</pre>
<ol start="2">
<li>Set the command to <kbd>printenv</kbd> and the output and error streams to the same as that of the current Java process:</li>
</ol>
<pre>        pb.command("printenv").inheritIO();</pre>
<ol start="3">
<li>Provide the environment variables, <kbd>COOKBOOK_VAR1</kbd> with the value, <kbd>First variable</kbd>, <span><kbd>COOKBOOK_VAR2</kbd> with the value, <kbd>Second variable</kbd>, and <kbd>COOKBOOK_VAR3</kbd> with the value, <kbd>Third variable</kbd>:</span></li>
</ol>
<pre>        Map&lt;String, String&gt; environment = pb.environment();
        environment.put("COOKBOOK_VAR1", "First variable");
        environment.put("COOKBOOK_VAR2", "Second variable");
        environment.put("COOKBOOK_VAR3", "Third variable");<span>
</span></pre>
<ol start="4">
<li>Start the process and wait for it to complete:</li>
</ol>
<pre>        Process p = pb.start();
        int exitValue = p.waitFor();</pre>
<p style="padding-left: 60px" class="mce-root">The complete code for this recipe can be found at <kbd>chp8/4_environment_variables</kbd>.</p>
<ol start="5">
<li>Compile and run the code by using the following commands:</li>
</ol>
<pre><strong>      $ javac -d mods --module-source-path src $(find src -name *.java)</strong>
      <strong>$ java -p mods -m process/com.packt.process.EnvironmentVariableDemo</strong></pre>
<p>The output you get is as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img height="90" width="319" class="image-border" src="assets/d4b2d50e-1cc7-44d2-915b-5a94a0a93849.png"/></div>
<p>You can see the three variables printed among other variables.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>When you invoke the <kbd>environment()</kbd> method on the instance of <kbd>ProcessBuilder</kbd>, it copies the environment variables of the current process, populates them in an instance of <kbd>HashMap</kbd>, and returns it to the caller code.</p>
<div class="packt_infobox">All the work of loading the environment variables is done by a package private final class, <kbd>ProcessEnvironment</kbd>, which actually extends <kbd>HashMap</kbd>.</div>
<p>We then make use of this map to populate our own environment variables, but we need not set the map back to <kbd>ProcessBuilder</kbd> because we will have a reference to the map object and not a copy. Any changes made to the map object will reflect in the actual map object held by the <kbd>ProcessBuilder</kbd> instance. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Running shell scripts</h1>
                </header>
            
            <article>
                
<p>We generally collect a set of commands used in performing an operation in a file, called a shell script in the Unix world and batch file in Windows. The commands present in these files are executed sequentially, with the exceptions being when you have conditional blocks or loops in the scripts. </p>
<p>These shell scripts are evaluated by the shell in which they get executed. Different types of shells available are <kbd>bash</kbd>, <kbd>csh</kbd>, <kbd>ksh</kbd>, and so on. The <kbd>bash</kbd> shell is the most commonly used shell.</p>
<p>In this recipe, we will write a simple shell script and then invoke the same from the Java code using the <kbd>ProcessBuilder</kbd> and <kbd>Process</kbd> objects.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>First, let's write our shell script. This script does the following:</p>
<ol>
<li>Print the value of the environment variable, <kbd>MY_VARIABLE</kbd>.</li>
<li>Execute the <kbd>tree</kbd> command.</li>
<li>Execute the <kbd>iostat</kbd> command.</li>
</ol>
<p>Let's create a shell script file by the name, <kbd>script.sh</kbd>, with the following commands in it:</p>
<pre><strong>echo $MY_VARIABLE;
echo "Running tree command";
tree;
echo "Running iostat command"
iostat;</strong></pre>
<p>You can place the <kbd>script.sh</kbd> in your home folder that is, in the <kbd>/home/&lt;username&gt;</kbd>. Now let's see how we can execute this from Java.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Create a new instance of <kbd>ProcessBuilder</kbd>:</li>
</ol>
<pre>        ProcessBuilder pb = new ProcessBuilder();</pre>
<ol start="2">
<li>Set the directory of execution to point to the directory of the shell script file:</li>
</ol>
<pre>         pb.directory(new File("/root"));</pre>
<div class="packt_tip">Note that the above path passed while creating the <kbd>File</kbd> object will depend on where you have place your script <kbd>script.sh</kbd>. In our case we had it placed in <kbd>/root</kbd>. You might have copied the script in <kbd>/home/yourname</kbd> and accordingly the <kbd>File</kbd> object will be created as <kbd>new File("/home/yourname")</kbd>. </div>
<ol start="3">
<li>Set an environment variable that would be used by the shell script:</li>
</ol>
<pre>        Map&lt;String, String&gt; environment = pb.environment();
        environment.put("MY_VARIABLE", "From your parent Java process");</pre>
<ol start="4">
<li>Set the command to be executed and also the arguments to be passed to the command. Also, set the output and error streams for the process to same as that of the current Java process:</li>
</ol>
<pre>         pb.command("/bin/bash", "script.sh").inheritIO();</pre>
<ol start="5">
<li>Start the process, and wait for it to execute completely:</li>
</ol>
<pre>         Process p = pb.start();
         int exitValue = p.waitFor();</pre>
<p>You can get the complete code from <kbd>chp8/5_running_shell_script</kbd>.</p>
<p>You can compile and run the code by using the following commands:</p>
<pre><strong>$ javac -d mods --module-source-path src $(find src -name *.java)</strong><br/><strong>$ java -p mods -m process/com.packt.process.RunningShellScriptDemo</strong></pre>
<p>The output we get is as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img height="347" width="511" class="image-border" src="assets/050b7cc9-3a85-4df5-a062-783dc95e78c4.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>You must make note of two things in this recipe:</p>
<ol>
<li>Change the working directory of the process to the location of the shell script.</li>
<li>Use <kbd>/bin/bash</kbd> to execute the shell script. </li>
</ol>
<p>If you don't do step 1, then you'll have to use the absolute path for the shell script file. However, in the recipe, we did do step 1, and hence, we just use the shell script name for the <kbd>/bin/bash</kbd> command.</p>
<p>Step 2 is basically how you would want to execute the shell script. The way to do so is to pass the shell script to the interpreter, which will interpret and execute the script. That is what the following line of code does:</p>
<pre><strong>pb.command("/bin/bash", "script.sh")</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Obtaining the process information of the current JVM</h1>
                </header>
            
            <article>
                
<p>A running process has a set of attributes associated with it, such as the following:</p>
<ul>
<li><strong>PID</strong>: This uniquely identifies the process</li>
<li><strong>Owner</strong>: This is the name of the user who launched the process</li>
<li><strong>Command</strong>: This is the command that runs under the process</li>
<li><strong>CPU time</strong>: This indicates the time for which the process has been active</li>
<li><strong>Start time</strong>: This indicates the time when the process was launched</li>
</ul>
<p>These are a few attributes that we are generally interested in. Perhaps, we would also be interested in CPU usage or memory usage. Now, getting this information from within Java was not possible prior to Java 9. However, in Java 9, a new set of APIs have been introduced, which enables us to get the basic information about the process. </p>
<p>In this recipe, we will see how to get the process information for the current Java process, that is, the process that is executing your code.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Create a simple class and use <kbd>ProcessHandle.current()</kbd> to get <kbd>ProcessHandle</kbd> for the current Java process:</li>
</ol>
<pre>        ProcessHandle handle = ProcessHandle.current();</pre>
<ol start="2">
<li>We have added some code, which will add some running time to the code:</li>
</ol>
<pre>        for ( int i = 0 ; i &lt; 100; i++){
          Thread.sleep(1000);
        }</pre>
<ol start="3">
<li>Use the <kbd>info()</kbd> method on the instance of <kbd>ProcessHandle</kbd> to get an instance of <kbd>ProcessHandle.Info</kbd>:</li>
</ol>
<pre>        ProcessHandle.Info info = handle.info();</pre>
<ol start="4">
<li>Use the instance of <kbd>ProcessHandle.Info</kbd> to get all the information made available by the interface:</li>
</ol>
<pre>        System.out.println("Command line: " + info.commandLine().get());
        System.out.println("Command: " + info.command().get());
        System.out.println("Arguments: " + 
                     String.join(" ", info.arguments().get()));
        System.out.println("User: " + info.user().get());
        System.out.println("Start: " + info.startInstant().get());
        System.out.println("Total CPU Duration: " + 
                     info.totalCpuDuration().get().toMillis() +"ms");</pre>
<ol start="5">
<li>Use the <kbd>pid()</kbd> method of <kbd>ProcessHandle</kbd> to get the process ID of the current Java process:</li>
</ol>
<pre>        System.out.println("PID: " + handle.pid());</pre>
<ol start="6">
<li>We will also print the end time using the time at which the code is about to end. This will give us an idea of the execution time of the process:</li>
</ol>
<pre>        Instant end = Instant.now();
        System.out.println("End: " + end);</pre>
<p>You can get the complete code from <kbd>chp8/6_current_process_info</kbd>.</p>
<p>Compile and run the code by using the following commands:</p>
<pre><strong>$ javac -d mods --module-source-path src $(find src -name *.java) <br/>$ java -p mods -m process/com.packt.process.CurrentProcessInfoDemo</strong></pre>
<p>The output you see will be something like this:</p>
<div class="CDPAlignCenter CDPAlign"><img height="127" width="707" class="image-border" src="assets/7ee17e84-3a52-4fc4-a9b3-20f425888b5d.png"/></div>
<div class="packt_infobox">It will take some time till the program completes execution.<br/>
One observation to be made is that even if the program ran for around 2 minutes, the total CPU duration was 350ms. This is the time period during which the CPU was busy.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>To give more control to the native processes and get its information, a new interface called <kbd>ProcessHandle</kbd> has been added to the Java API. Using <kbd>ProcessHandle</kbd>, you can control the process execution as well as get some information about the process. The interface has another inner interface called <kbd>ProcessHandle.Info</kbd>. This interface provides APIs to get information about the process. </p>
<p>There are multiple ways to get hold of the <kbd>ProcessHandle</kbd> object for a process. Some of the ways are as follows:</p>
<ul>
<li><kbd>ProcessHandle.current()</kbd>: This is used to get the <kbd>ProcessHandle</kbd> instance for the current Java process</li>
<li><kbd>Process.toHandle()</kbd>: This is used to get <kbd>ProcessHandle</kbd> for a given <kbd>Process</kbd> object</li>
<li><kbd>ProcessHandle.of(pid)</kbd>: This is used to get <kbd>ProcessHandle</kbd> for a process identified by the given PID </li>
</ul>
<p>In our recipe, we make use of the first approach, that is, we use <kbd>ProcessHandle.current()</kbd>. This gives us a handle on the current Java process. Invoking the <kbd>info()</kbd> method on the <kbd>ProcessHandle</kbd> instance will give us an instance of the implementation of the <kbd>ProcessHandle.Info</kbd> interface, which we can make use of to get the process information, as shown in the recipe code. </p>
<div class="packt_infobox"><kbd>ProcessHandle</kbd> and <kbd>ProcessHandle.Info</kbd> are interfaces. The JDK provider, that is, Oracle JDK or Open JDK, will provide implementations for these interfaces. Oracle JDK has a class called <kbd>ProcessHandleImpl</kbd>, which implements <kbd>ProcessHandle</kbd> and another inner class within <kbd>ProcessHandleImpl</kbd> called <kbd>Info</kbd>, which implements the <kbd>ProcessHandle.Info</kbd> interface. So, whenever you call one of the aforementioned methods to get a <kbd>ProcessHandle</kbd> object, an instance of <kbd>ProcessHandleImpl</kbd> is returned.<br/>
The same goes with the <kbd>Process</kbd> class as well. It is an abstract class and Oracle JDK provides an implementation called <kbd>ProcessImpl</kbd>, which implements the abstract methods in the <kbd>Process</kbd> class.<br/>
In all the recipes in this chapter, any mention of the instance of <kbd>ProcessHandle</kbd> or the <kbd>ProcessHandle</kbd> object will refer to the instance or object of <kbd>ProcessHandleImpl</kbd> or any other implementation class provided by the JDK you are using.<br/>
Also, any mention of the instance of <kbd>ProcessHandle.Info</kbd> or the <kbd>ProcessHandle.Info</kbd> object will refer to the instance or object of <kbd>ProcessHandleImpl.Info</kbd> or any other implementation class provided by the JDK you are using.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Obtaining the process information of the spawned process</h1>
                </header>
            
            <article>
                
<p>In our previous recipe, we saw how to get the process information for the current Java process. In this recipe, we will look at how to get the process information for a process spawned by the Java code, that is, by the current Java process. The APIs used will be the same as we saw in the previous recipe, except for the way the instance of <kbd>ProcessHandle</kbd> is implemented. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>In this recipe, we will make use of a Unix command, <kbd>sleep</kbd>, which is used to pause the execution for a period of time in seconds. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Spawn a new process from the Java code, which runs the <kbd>sleep</kbd> command:</li>
</ol>
<pre>        ProcessBuilder pBuilder = new ProcessBuilder("sleep", "20");
        Process p = pBuilder.inheritIO().start();</pre>
<ol start="2">
<li>Get the <kbd>ProcessHandle</kbd> instance for this spawned process:</li>
</ol>
<pre>        ProcessHandle handle = p.toHandle();</pre>
<ol start="3">
<li>Wait for the spawned process to complete execution:</li>
</ol>
<pre>        int exitValue = p.waitFor();</pre>
<ol start="4">
<li>Use <kbd>ProcessHandle</kbd> to get the <kbd>ProcessHandle.Info</kbd> instance and use its APIs to get the required information. Alternatively, we can even use the <kbd>Process</kbd> object directly to get <kbd>ProcessHandle.Info</kbd> by using the <kbd>info()</kbd> method in the <kbd>Process</kbd> class:</li>
</ol>
<pre>        ProcessHandle.Info info = handle.info();
  
        System.out.println("Command line: " + info.commandLine().get());
        System.out.println("Command: " + info.command().get());
        System.out.println("Arguments: " + String.join(" ", 
                           info.arguments().get()));
        System.out.println("User: " + info.user().get());
        System.out.println("Start: " + info.startInstant().get());
        System.out.println("Total CPU time(ms): " + 
                           info.totalCpuDuration().get().toMillis());
        System.out.println("PID: " + handle.pid());</pre>
<p>You can get the complete code from <kbd>chp8/7_spawned_process_info</kbd>.</p>
<p>Compile and run the code by using the following commands:</p>
<pre><strong>$ javac -d mods --module-source-path src $(find src -name *.java)<br/>$ java -p mods -m process/com.packt.process.SpawnedProcessInfoDemo</strong></pre>
<p>Alternatively, there is a <kbd>run.sh</kbd> script in <kbd>chp8\7_spawned_process_info</kbd>, which you can run from any Unix-based system as <kbd>/bin/bash run.sh</kbd>.</p>
<p>The output you see will be something like this:</p>
<div class="CDPAlignCenter CDPAlign"><img height="111" width="219" class="image-border" src="assets/be482dc1-a8b5-4687-ae4e-b449b96f6d99.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Managing the spawned process</h1>
                </header>
            
            <article>
                
<p>There are a few methods, such as <kbd>destroy()</kbd>, <kbd>destroyForcibly()</kbd> (added in Java 8), <kbd>isAlive()</kbd> (added in Java 8), and <kbd>supportsNormalTermination()</kbd> (added in Java 9), which can be used to control the process spawned. These methods are available on the <kbd>Process</kbd> object as well as on the <kbd>ProcessHandle</kbd> object. Here, controlling would be just to check if the process is alive and if yes, then destroy the process. </p>
<p>In this recipe, we will spawn a long running process and do the following:</p>
<ul>
<li>Check for its liveliness</li>
<li>Check if it can be stopped normally, that is, depending on the platform, the process has to be stopped by just using destroy or by using force destroy</li>
<li>Stop the process</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li><span>Spawn a new process from the Java code, which runs the <kbd>sleep</kbd> command for say 1 minute, that is, 60 seconds:</span></li>
</ol>
<pre><span>        ProcessBuilder pBuilder = new ProcessBuilder("sleep", "60");
        Process p = pBuilder.inheritIO().start();
</span></pre>
<ol start="2">
<li>Wait for, say, 10 seconds:</li>
</ol>
<pre><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>p.waitFor(10, TimeUnit.SECONDS);</pre>
<ol start="3">
<li>Check whether the process is alive:</li>
</ol>
<pre><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>boolean isAlive = p.isAlive();
<span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>System.out.println("Process alive? " + isAlive);</pre>
<ol start="4">
<li>Check whether the process can be stopped normally:</li>
</ol>
<pre><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>boolean normalTermination = p.supportsNormalTermination();
<span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>System.out.println("Normal Termination? " + normalTermination);</pre>
<ol start="5">
<li>Stop the process and check for its liveliness:</li>
</ol>
<pre><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>p.destroy();
<span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>isAlive = p.isAlive();
<span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>System.out.println("Process alive? " + isAlive);</pre>
<p><span>You can get the complete code from <kbd>chp8\8_manage_spawned_process</kbd>.</span></p>
<p>We have provided a utility script called <kbd>run.sh</kbd>, which you can use to compile and run the code: <kbd>sh run.sh</kbd>.</p>
<p>The output we get is as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img height="63" width="179" class="image-border" src="assets/067f50c7-4562-4d69-8d92-0c3374da1ab8.png"/></div>
<div class="packt_infobox">If we are running the program on Windows, <kbd>supportsNormalTermination()</kbd> returns <kbd>false</kbd>, but on Unix <kbd>supportsNormalTermination()</kbd> returns <kbd>true</kbd> (as seen in the preceding output as well).</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Enumerating live processes in the system</h1>
                </header>
            
            <article>
                
<p>In Windows, you open up the <span class="packt_screen">Windows Task Manger</span> to view the processes currently active, and in Linux, you use the <kbd>ps</kbd> command with its varied options to view the processes along with other details, such as user, time spent, command, and so on.</p>
<p> </p>
<p>In Java 9, a new API has been added, called <kbd>ProcessHandle</kbd>, which deals with controlling and getting information about the processes. One of the methods of the API is <kbd>allProcesses()</kbd>, which returns a snapshot of all the processes visible to the current process. In this recipe, we will look at how the method works and what information we can extract from the API.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Use the <kbd>allProcesses()</kbd> method on the <kbd>ProcessHandle</kbd> interface to get a stream of the currently active processes:</li>
</ol>
<pre>         Stream&lt;ProcessHandle&gt; liveProcesses = <br/>                       ProcessHandle.allProcesses();</pre>
<ol start="2">
<li>Iterate over the stream using <kbd>forEach()</kbd> and pass a lambda expression to print the details available:</li>
</ol>
<pre>         liveProcesses.forEach(ph -&gt; {
           ProcessHandle.Info phInfo = ph.info();
           System.out.println(phInfo.command().orElse("") +" " + 
                              phInfo.user().orElse(""));
         });</pre>
<p><span>You can get the complete code from <kbd>chp8/9_enumerate_all_processes</kbd>.</span></p>
<p>We have provided a utility script called <kbd>run.sh</kbd>, which you can use to compile and run the code: <kbd>sh run.sh</kbd>.</p>
<p>The output we get is as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img height="198" width="271" class="image-border" src="assets/5c0213b4-0cf2-4d1f-95b9-692d15e89fc2.png"/> </div>
<p>In the preceding output, we are printing the command name as well as the user of the process. We have shown a small part of the output. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Connecting multiple processes using pipe</h1>
                </header>
            
            <article>
                
<p>In Unix, it's common to pipe a set of commands together using the <kbd>|</kbd> symbol to create a pipeline of activities, where the input for the command is the output from the previous command. This way, we can process the input to get the desired output. </p>
<p>A common scenario is when you want to search for something or some pattern in the log files or for an occurrence of some text in the log file. In such scenarios, you can create a pipeline, wherein you pass the required log file data via a series of commands, namely: <kbd>cat</kbd>, <kbd>grep</kbd>, <kbd>wc -l</kbd>, and so on. </p>
<p>In this recipe, we will make use of the Iris dataset from the UCI machine learning repository available at <a href="https://archive.ics.uci.edu/ml/datasets/Iris">https://archive.ics.uci.edu/ml/datasets/Iris</a> to create a pipeline, wherein we will count the number of occurrences of each type of flower. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>We have already downloaded the Iris flower dataset, which can be found at <kbd>chp8/10_connecting_process_pipe/iris.data</kbd> of the code download for this book. </p>
<p>If you happen to look at the <kbd>Iris</kbd> data, you will see there are 150 rows of the following format:</p>
<pre>4.7,3.2,1.3,0.2,Iris-setosa</pre>
<p>Here, there are multiple attributes separated by a comma (<kbd>,</kbd>) and the attributes are as follows:</p>
<ul>
<li>Sepal length in cm</li>
<li>Sepal width in cm</li>
<li>Petal length in cm</li>
<li>Petal width in cm</li>
<li>Class:
<ul>
<li>Iris Setosa</li>
<li>Iris Versicolour</li>
<li>Iris Virginica</li>
</ul>
</li>
</ul>
<p>In this recipe, we will find the total number of flowers in each class, namely <span>Setosa, </span><span>Versicolour, and </span><span>Virginica.</span></p>
<p>We will make use of a pipeline with the following commands (using a Unix-based operating system):</p>
<pre><strong>$ cat iris.data.txt | cut -d',' -f5 | uniq -c</strong></pre>
<p>The output we get is as follows:</p>
<pre><strong>50 Iris-setosa
50 Iris-versicolor
50 Iris-virginica
1</strong></pre>
<p>The 1 at the end is for the new line available at the end of the file. So, there are 50 flowers of each class. Let us dissect the above shell command pipeline and understand the function of each of them:</p>
<ul>
<li><kbd>cat</kbd>: This command reads the file given as the argument</li>
<li><kbd>cut</kbd>: This splits each line by using the character given in the <kbd>-d</kbd> option and returns the value in the column identified by the <kbd>-f</kbd> option. </li>
<li><kbd>uniq</kbd>: This returns a unique list from the given values, and when the <kbd>-c</kbd> option is used, it returns how many times each unique value is present in the list</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Create a list of <kbd>ProcessBuilder</kbd> objects, which will hold the <kbd>ProcessBuilder</kbd> instances participating in our pipeline. Also, redirect the output of the last process in the pipeline to the standard output of the current Java process:</li>
</ol>
<pre>         List&lt;ProcessBuilder&gt; pipeline = List.of(
           new ProcessBuilder("cat", "iris.data.txt"),
           new ProcessBuilder("cut", "-d", ",", "-f", "5"),
           new ProcessBuilder("uniq", "-c")
               .redirectOutput(ProcessBuilder.Redirect.INHERIT)
         );</pre>
<ol start="2">
<li>Use the <kbd>startPipeline()</kbd> method of <kbd>ProcessBuilder</kbd> and pass the list of <kbd>ProcessBuilder</kbd> objects to start the pipeline. It will return a list of <kbd>Process</kbd> objects, each representing a <kbd>ProcessBuilder</kbd> object in the list:</li>
</ol>
<pre>         List&lt;Process&gt; processes = ProcessBuilder.startPipeline(pipeline);</pre>
<ol start="3">
<li>Get the last process in the list and <kbd>waitFor</kbd> it to complete:</li>
</ol>
<pre>         int exitValue = processes.get(processes.size() - 1).waitFor();</pre>
<p><span>You can get the complete code from <kbd>chp8/10_connecting_process_pipe</kbd>.</span></p>
<p>We have provided a utility script called <kbd>run.sh</kbd>, which you can use to compile and run the code: <kbd>sh run.sh</kbd>.</p>
<p>The output we get is as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img height="58" width="158" class="image-border" src="assets/ab389c1c-187d-4d9a-a794-bd65c5dd1b65.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>The <kbd>startPipeline()</kbd> method starts a <kbd>Process</kbd> for each <kbd>ProcessBuilder</kbd> object in the list. Except for the first and the last processes, it redirects the output of one process to the input of another process by using <kbd>ProcessBuilder.Redirect.PIPE</kbd>. If you have provided <kbd>redirectOutput</kbd> for any intermediate process as something other than <kbd>ProcessBuilder.Redirect.PIPE</kbd>, then there will be an error thrown, something similar to the following: </p>
<pre><strong>Exception in thread "main" java.lang.IllegalArgumentException: builder redirectOutput() must be PIPE except for the last builder: INHERIT.</strong> </pre>
<p>It states that any builder except for the last should redirect its output to the next process. The same is applicable for <kbd>redirectInput</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Managing subprocesses</h1>
                </header>
            
            <article>
                
<p>When a process launches another process, the launched process becomes the subprocess of the launching process. The launched process, in turn, can launch another process and this chain can continue. This results in a process tree. Often, we would have to deal with a buggy subprocess and might want to kill that subprocess, or we might want to know the subprocesses that are launched and might want to get some information about it. </p>
<p>In Java 9, two new APIs in the <kbd>Process</kbd> class have been added: <kbd>children()</kbd> and <kbd>descendants()</kbd>. The <kbd>children()</kbd> API allows you to get a list of the snapshot of processes that are the immediate children of the current process, and the <kbd>descendants()</kbd> API provides a snapshot of processes that are recursively <kbd>children()</kbd> of the current process, that is, they are invoking <kbd>children()</kbd> recursively on each child process.</p>
<p>In this recipe, we will look at both the <kbd>children()</kbd> and <kbd>descendants()</kbd> APIs and see what information we can gather from the snapshot of the process.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>Let's create a simple shell script, which we will be using in the recipe. This script can be found at <kbd>chp8/11_managing_sub_process/script.sh</kbd>:</p>
<pre><strong>echo "Running tree command";
tree;
sleep 60;
echo "Running iostat command";
iostat;</strong></pre>
<p>In the preceding script, we are running the commands, <kbd>tree</kbd> and <kbd>iostat</kbd>, separated by a sleep time of 1 minute. If you want to know about these commands, please refer to the <em>Running shell scripts</em> recipe of this chapter. The sleep command, when executed from within the bash shell, creates a new subprocess each time it is invoked.</p>
<p>We will create, say, 10 instances of <kbd>ProcessBuilder</kbd> to run the preceding shell script and launch them simultaneously.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>We will create 10 instances of <kbd>ProcessBuilder</kbd> to run our shell script (available at <span><kbd>chp8/11_managing_sub_process/script.sh</kbd>). We are not concerned with its output, so let's discard the output of the commands by redirecting the output to a predefined redirect called <kbd>ProcessHandle.Redirect.DISCARD</kbd>:</span></li>
</ol>
<pre><span>        for ( int i = 0; i &lt; 10; i++){
          new ProcessBuilder("/bin/bash", "script.sh")
              .redirectOutput(ProcessBuilder.Redirect.DISCARD)
</span><span>              .start();
        }</span></pre>
<ol start="2">
<li>Get the handle for the current process:</li>
</ol>
<pre>        ProcessHandle currentProcess = ProcessHandle.current();</pre>
<ol start="3">
<li>Use the current process to get its children using the <kbd>children()</kbd> API and iterate over each of its children to print their information. Once we have an instance of <kbd>ProcessHandle</kbd>, we can do multiple things, such as destroy the process, get its process information, and so on:</li>
</ol>
<pre>        System.out.println("Obtaining children");
        currentProcess.children().forEach(pHandle -&gt; {
          System.out.println(pHandle.info());
        });</pre>
<ol start="4">
<li>Use the current process to get all the subprocesses that are its descendants using the <kbd>descendants()</kbd> API and iterate over each of them to print their information:</li>
</ol>
<pre>        currentProcess.descendants().forEach(pHandle -&gt; {
          System.out.println(pHandle.info());
        });</pre>
<p><span>You can get the complete code from <kbd>chp8/11_managing_sub_process</kbd>.</span></p>
<p>We have provided a utility script called <kbd>run.sh</kbd>, which you can use to compile and run the code: <kbd>sh run.sh</kbd>.</p>
<p>The output we get is as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img height="444" width="870" class="image-border" src="assets/12b81bda-e9c9-4e50-9f1b-7655ebef5d7d.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>The APIs, <kbd>children()</kbd>, and <kbd>descendants()</kbd>, return <kbd>Stream</kbd> of <kbd>ProcessHandler</kbd> for each of the processes, which are either direct children or descendants of the current process. Using the instance of <kbd>ProcessHandler</kbd>, we can perform the following operations:</p>
<ol>
<li>Get the process information.</li>
<li>Check the status of the process.</li>
<li>Stop the process.</li>
</ol>


            </article>

            
        </section>
    </body></html>