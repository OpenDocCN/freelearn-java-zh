<html><head></head><body><div class="chapter" title="Chapter&#xA0;10.&#xA0;Web Services with JAX-WS"><div class="titlepage"><div><div><h1 class="title"><a id="ch10"/>Chapter 10. Web Services with JAX-WS</h1></div></div></div><p>The Java EE specification includes the JAX-WS API as one of its technologies. JAX-WS is the standard way to develop <a id="id954" class="indexterm"/>
<span class="strong"><strong>Simple Object Access Protocol</strong></span> (<span class="strong"><strong>SOAP</strong></span>) web services on the Java platform. It stands for <span class="strong"><strong>Java API for XML Web Services</strong></span>. JAX-WS<a id="id955" class="indexterm"/> is a high-level API; invoking web services via JAX-WS is done via remote procedure calls. JAX-WS is a very natural API for Java developers.</p><p>Web services are application programming interfaces that can be invoked remotely. Web services can be invoked from clients written in any programming language.</p><p>Some of the topics we will cover include:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Developing web services with the JAX-WS API</li><li class="listitem" style="list-style-type: disc">Developing web service clients with the JAX-WS API</li><li class="listitem" style="list-style-type: disc">Adding attachments to web service calls</li><li class="listitem" style="list-style-type: disc">Exposing EJBs as web services</li><li class="listitem" style="list-style-type: disc">Securing web services</li></ul></div><div class="section" title="Developing web services with the JAX-WS API"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec53"/>Developing web services with the JAX-WS API</h1></div></div></div><p>JAX-WS is a high-level API that simplifies development of SOAP-based web services. Developing a web service via JAX-WS<a id="id956" class="indexterm"/> consists of writing a class with public methods to be exposed as web services. The class needs to be decorated with the <code class="literal">@WebService</code> annotation. All public methods in the class are<a id="id957" class="indexterm"/> automatically exposed as web services, they can optionally be decorated with the <code class="literal">@WebMethod</code> annotation<a id="id958" class="indexterm"/>. The following example illustrates this process:</p><div class="informalexample"><pre class="programlisting">package net.ensode.glassfishbook;

import javax.jws.WebMethod;
import javax.jws.WebService;

<span class="strong"><strong>@WebService</strong></span>
public class Calculator {

<span class="strong"><strong>    @WebMethod</strong></span>
    public int add(int first, int second) {
        return first + second;
    }

<span class="strong"><strong>    @WebMethod</strong></span>
    public int subtract(int first, int second) {
        return first - second;
    }
}</pre></div><p>The preceding class exposes its two methods as web services. The <code class="literal">add()</code> method<a id="id959" class="indexterm"/> simply adds the two <code class="literal">int</code> primitives it receives as parameters and returns the result. The <code class="literal">subtract()</code> method <a id="id960" class="indexterm"/>subtracts<a id="id961" class="indexterm"/> its two parameters and returns the result.</p><p>We indicate that the class implements a web service by decorating it with the <code class="literal">@WebService</code> annotation. Any methods that we would like exposed as web services can be decorated with the <code class="literal">@WebMethod</code> annotation<a id="id962" class="indexterm"/>; however, this isn't necessary, as all public methods are automatically exposed as web services.</p><p>To deploy our web service, we need to package it in a <code class="literal">.war</code> file. Before Java EE 6, all valid <code class="literal">.war</code> files were required to contain a <code class="literal">web.xml</code> deployment descriptor in their <code class="literal">WEB-INF</code> directory. As we have already covered in previous chapters, this deployment descriptor is optional when <a id="id963" class="indexterm"/>working with Java EE 6 (and later) and is not required to deploy a web service under this environment.</p><p>If we choose to add a <code class="literal">web.xml</code> deployment descriptor, nothing needs to be added to the <code class="literal">.war</code> file's <code class="literal">web.xml</code> in order to successfully deploy our web service. Simply having an empty <code class="literal">&lt;web-app&gt;</code> element in the deployment descriptor will be enough to successfully deploy our WAR file, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;web-app  version="2.5"
  
  xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"&gt;
&lt;/web-app&gt;</pre></div><p>After compiling, packaging, and deploying the code, we can verify that it was successfully deployed by logging into the GlassFish admin web console and expanding the <span class="strong"><strong>Applications</strong></span> node<a id="id964" class="indexterm"/> on the left-hand side. We should see our newly deployed web service listed under this node, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/6886EN_10_01.jpg" alt="Developing web services with the JAX-WS API"/></div><p>In the preceding screenshot,<a id="id965" class="indexterm"/> notice that there is a <span class="strong"><strong>View Endpoint</strong></span> link at the bottom right of the page. Clicking on that button takes us to the <a id="id966" class="indexterm"/>
<span class="strong"><strong>Web Service Endpoint Information</strong></span> page <a id="id967" class="indexterm"/>shown in the following screenshot, which has some information about our web service:</p><div class="mediaobject"><img src="graphics/6886EN_10_02.jpg" alt="Developing web services with the JAX-WS API"/></div><p>Notice that there is a link labeled <span class="strong"><strong>Tester:</strong></span> in the preceding screenshot; clicking on this link takes us to an automatically <a id="id968" class="indexterm"/>generated page<a id="id969" class="indexterm"/> that allows us to test our web service. This page looks like the following screenshot:</p><div class="mediaobject"><img src="graphics/6886EN_10_03.jpg" alt="Developing web services with the JAX-WS API"/></div><p>To test methods, we can simply enter some parameters in the text fields and click on the appropriate button. For example, <a id="id970" class="indexterm"/>entering the <a id="id971" class="indexterm"/>values <code class="literal">2</code> and <code class="literal">3</code> in the text fields corresponding to the <code class="literal">add</code> method<a id="id972" class="indexterm"/> and clicking on the <span class="strong"><strong>add</strong></span> button<a id="id973" class="indexterm"/> would result in the following output:</p><div class="mediaobject"><img src="graphics/6886EN_10_04.jpg" alt="Developing web services with the JAX-WS API"/></div><p>JAX-WS uses the SOAP protocol behind the scenes to exchange information between web service clients and servers. By scrolling down the preceding page, we can see the SOAP request<a id="id974" class="indexterm"/> and response generated by our test, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/6886EN_10_05.jpg" alt="Developing web services with the JAX-WS API"/></div><p>As application developers, we don't need to concern ourselves too much with these SOAP requests, since they are automatically taken care of by the JAX-WS API.</p><p>Web service clients need a <span class="strong"><strong>Web Services Definition Language</strong></span> (<span class="strong"><strong>WSDL</strong></span>) file <a id="id975" class="indexterm"/>in order to generate executable code that they can use to invoke the web service. WSDL is a standard XML-based<a id="id976" class="indexterm"/> interface definition language that defines the functionality of a web service.</p><p>WSDL files are typically placed in<a id="id977" class="indexterm"/> a web server and accessed by the client via its URL. When deploying web services developed using JAX-WS, a WSDL file is automatically generated for us. We can see it, along with its URL, by clicking on the <span class="strong"><strong>View WSDL</strong></span> link on the <span class="strong"><strong>Web Service Endpoint Information</strong></span> page, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/6886EN_10_06.jpg" alt="Developing web services with the JAX-WS API"/></div><p>Notice the WSDL URL in the browser's location text field. We will need this URL when developing a client for<a id="id978" class="indexterm"/> our web service.</p><div class="section" title="Developing a web service client"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec69"/>Developing a web service client</h2></div></div></div><p>As mentioned earlier, executable<a id="id979" class="indexterm"/> code needs to be generated from the WSDL of a web service. A web service client will then invoke this executable code to access the web service.</p><p>GlassFish includes a utility to generate<a id="id980" class="indexterm"/> Java code from a WSDL. The name of the utility is <code class="literal">wsimport</code>. It can be found under <code class="literal">[glassfish installation directory]/glassfish/bin/</code>. The only required argument for <code class="literal">wsimport</code> is the URL of the WSDL, which corresponds to the web service, for example, <code class="literal">wsimport</code> <code class="literal">http://localhost:8080/calculatorservice/CalculatorService?wsdl</code>.</p><p>The command in the preceding screenshot will generate the following compiled Java classes that allow client applications to access our web service:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Add.class</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">AddResponse.class</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Calculator.class</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">CalculatorService.class</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">ObjectFactory.class</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">package-info.class</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Subtract.class</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">SubtractResponse.class</code></li></ul></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note38"/>Note</h3><p>
<span class="strong"><strong>Keeping the Generated Source Code</strong></span>
</p><p>By default, the source code for the generated class files is automatically deleted; it can be kept by passing the <code class="literal">-keep</code> parameter<a id="id981" class="indexterm"/> to <code class="literal">wsimport</code>.</p></div></div><p>These classes need to be added <a id="id982" class="indexterm"/>to the client's CLASSPATH in order for them to be accessible to the client's code.</p><p>In addition to the command-line tool, GlassFish includes a custom ANT task to generate code from a WSDL. The<a id="id983" class="indexterm"/> following ANT build script illustrates its usage:</p><div class="informalexample"><pre class="programlisting">&lt;project name="calculatorserviceclient" default="wsimport" basedir="."&gt; 
  &lt;target name="wsimport"&gt; 
    &lt;taskdef name="wsimport"  
       classname="com.sun.tools.ws.ant.WsImport"&gt; 
       &lt;classpath path="/opt/glassfish-4.0/glassfish/modules/webservices-osgi.jar"/&gt;
       &lt;classpath path="/opt/glassfish-4.0/glassfish/modules/jaxb-osgi.jar"/&gt;
       &lt;classpath path="/opt/glassfish-4.0/glassfish/lib/javaee.jar"/&gt;
    &lt;/taskdef&gt; 
     &lt;wsimport wsdl=" HYPERLINK "http://localhost:8080/calculatorservice/CalculatorService?wsdl"http://localhost:8080/calculatorservice/CalculatorService?wsdl"xendorsed="true"/&gt;
  &lt;/target&gt;
&lt;/project&gt;</pre></div><p>The preceding example is a very minimal ANT build script that only illustrates how to set up the custom <code class="literal">&lt;wsimport&gt;</code> ANT target. In reality, the ANT build script for the project would have several other targets for compilation, building a <code class="literal">.war</code> file, and so on.</p><p>Since <code class="literal">&lt;wsimport&gt;</code> is a<a id="id984" class="indexterm"/> custom ANT target and it is not standard, we need to add a <code class="literal">&lt;taskdef&gt;</code> element to our ANT build script. We need to set the <code class="literal">name</code> and <code class="literal">classname</code> attributes as illustrated in the example. Additionally, we need to add the following <code class="literal">.jar</code> files to the task's CLASSPATH via nested <code class="literal">&lt;classpath&gt;</code> elements:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">webservices-osgi.jar</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">jaxb-osgi.jar</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">javaee.jar</code></li></ul></div><p>The <code class="literal">webservices-osgi.jar</code> and <code class="literal">jaxb-osgi.jar</code> files can be found under the <code class="literal">[glassfish installation directory]/glassfish/modules</code> directory. The <code class="literal">javaee.jar</code> file contains all the Java EE APIs and can be found under <code class="literal">[glassfish installation directory]/glassfish/lib</code>.</p><p>Once we set up the custom <code class="literal">&lt;wsimport&gt;</code> task via the <code class="literal">&lt;taskdef&gt;</code> element, we are ready to use it. We need to indicate the WSDL location via its <code class="literal">wsdl</code> attribute. Once this task executes, the Java code that is required to access the web service defined by the WSDL is generated.</p><p>JDK 1.6 comes bundled with JAX-WS 2.1. If we are using this version of the JDK, we need to tell ANT to use the JAX-WS 2.2 API included with GlassFish. This can be done easily by setting the <code class="literal">xendorsed</code> attribute of the custom <code class="literal">wsimport</code> ANT task to <code class="literal">true</code>.</p><p>Readers using Maven to build their <a id="id985" class="indexterm"/>projects can take advantage of Maven's <code class="literal">AntRun</code> plugin<a id="id986" class="indexterm"/> to execute the <code class="literal">wsimport</code> ANT target when building their code. This approach is illustrated in the following <code class="literal">pom.xml</code> file.</p><div class="informalexample"><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8" ?&gt; 
&lt;project   xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;groupId&gt;net.ensode.glassfishbook&lt;/groupId&gt;
  &lt;artifactId&gt;calculatorserviceclient&lt;/artifactId&gt;
  &lt;packaging&gt;jar&lt;/packaging&gt;
  &lt;name&gt;Simple Web Service Client&lt;/name&gt;
  &lt;version&gt;1.0&lt;/version&gt;
  &lt;url&gt;http://maven.apache.org&lt;/url&gt;
  &lt;repositories&gt;
    &lt;repository&gt;
      &lt;id&gt;maven2-repository.dev.java.net&lt;/id&gt;
      &lt;name&gt;Java.net Repository for Maven 2&lt;/name&gt;
      &lt;url&gt;http://download.java.net/maven/2/&lt;/url&gt;
    &lt;/repository&gt;
  &lt;/repositories&gt;
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;javax&lt;/groupId&gt;
      &lt;artifactId&gt;javaee-api&lt;/artifactId&gt;
      &lt;version&gt;6.0&lt;/version&gt;
      &lt;scope&gt;provided&lt;/scope&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
  &lt;build&gt;
    &lt;finalName&gt;calculatorserviceclient&lt;/finalName&gt;
    &lt;plugins&gt;
      &lt;plugin&gt;
        &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
        &lt;artifactId&gt;maven-antrun-plugin&lt;/artifactId&gt;
        &lt;executions&gt;
          &lt;execution&gt;
            &lt;phase&gt;generate-sources&lt;/phase&gt;
            &lt;configuration&gt;
              &lt;tasks&gt;
                &lt;property name="target.dir" value="target" /&gt;
                &lt;delete dir="${target.dir}/classes/com/testapp/ws/client" /&gt;
                &lt;delete dir="${target.dir}/generated-sources/main/java/com/testapp/ws/client" /&gt;
                &lt;mkdir dir="${target.dir}/classes" /&gt;
                &lt;mkdir dir="${target.dir}/generated-sources/main/java" /&gt;
                &lt;taskdef name="wsimport" classname="com.sun.tools.ws.ant.WsImport"&gt;
                  &lt;classpath path="/home/heffel/sges-v3/glassfish/modules/webservices-osgi.jar" /&gt;
                  &lt;classpath path="/home/heffel/sges-v3/glassfish/modules/jaxb-osgi.jar" /&gt;
                  &lt;classpath path="/home/heffel/sges-v3/glassfish/lib/javaee.jar" /&gt;
                &lt;/taskdef&gt;
                &lt;wsimport wsdl="http://localhost:8080/calculatorservice/CalculatorService?wsdl" destdir="${target.dir}/classes" verbose="true" keep="true" sourceDestDir="${target.dir}/generated-sources/main/java" xendorsed="true" /&gt;
              &lt;/tasks&gt;
              &lt;sourceRoot&gt;${project.build.directory}/generated-sources/main/java&lt;/sourceRoot&gt;
            &lt;/configuration&gt;
            &lt;goals&gt;
              &lt;goal&gt;run&lt;/goal&gt;
            &lt;/goals&gt;
          &lt;/execution&gt;
        &lt;/executions&gt;
      &lt;/plugin&gt;
      &lt;plugin&gt;
        &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
        &lt;artifactId&gt;maven-jar-plugin&lt;/artifactId&gt;
        &lt;configuration&gt;
          &lt;archive&gt;
            &lt;manifest&gt;
              &lt;mainClass&gt;net.ensode.glassfishbook.CalculatorServiceClient&lt;/mainClass&gt;
              &lt;addClasspath&gt;true&lt;/addClasspath&gt;
            &lt;/manifest&gt;
          &lt;/archive&gt;
        &lt;/configuration&gt;
      &lt;/plugin&gt;
      &lt;plugin&gt;
        &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
        &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
        &lt;configuration&gt;
          &lt;source&gt;1.6&lt;/source&gt;
          &lt;target&gt;1.6&lt;/target&gt;
        &lt;/configuration&gt;
      &lt;/plugin&gt;
    &lt;/plugins&gt;
  &lt;/build&gt;
&lt;/project&gt;</pre></div><p>Nested in the <code class="literal">pom.xml</code> file's <code class="literal">&lt;configuration&gt;</code> tag, corresponding to the <code class="literal">AntRun</code> plugin, we place any ANT tasks we need to execute. Unsurprisingly, the body of this tag in our example looks nearly identical to the ANT build file we just discussed.</p><p>Now that we know how to build our code with ANT or Maven, we can develop a simple client to access our web service, using the following code:</p><div class="informalexample"><pre class="programlisting">package net.ensode.glassfishbook;

import javax.xml.ws.WebServiceRef;

public class CalculatorServiceClient {

<span class="strong"><strong>    @WebServiceRef(wsdlLocation = "http://localhost:8080/calculatorservice/CalculatorService?wsdl")</strong></span>
    private static CalculatorService calculatorService;

    public void calculate() {
<span class="strong"><strong>        Calculator calculator = calculatorService.getCalculatorPort();</strong></span>

        System.out.println("1 + 2 = "
                + calculator.add(1, 2));
        System.out.println("1 - 2 = "
                + calculator.subtract(1, 2));
    }

    public static void main(String[] args) {
        new CalculatorServiceClient().calculate();
    }
}</pre></div><p>The <code class="literal">@WebServiceRef</code> annotation<a id="id987" class="indexterm"/> injects an instance of the web service into our client application. Its <code class="literal">wsdlLocation</code> attribute contains the URL of the WSDL that corresponds to the web service we are invoking.</p><p>Notice that the web service<a id="id988" class="indexterm"/> class is an instance of a class called <code class="literal">CalculatorService</code>. This class was created when we invoked the <code class="literal">wsimport</code> utility. The <code class="literal">wsimport</code> utility always generates a class whose name is the name of the class we implemented plus the <code class="literal">Service</code> suffix. We use<a id="id989" class="indexterm"/> this service class to obtain an instance of the web service class we developed. In our example, we do this by invoking the <code class="literal">getCalculatorPort()</code> method<a id="id990" class="indexterm"/> on the <code class="literal">CalculatorService</code> instance. In general, the method invoked to get an instance of our web service class follows the pattern <code class="literal">getNamePort()</code>, where <code class="literal">Name</code> is the name of the class we wrote to implement the web service. Once we get an instance of our web service class, we can simply invoke its methods like with any regular Java object.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note39"/>Note</h3><p>Strictly speaking, the <code class="literal">getNamePort()</code> method<a id="id991" class="indexterm"/> of the service class returns an instance of a class that implements an interface generated by <code class="literal">wsimport</code>. This interface is given the name of our web service class and declares all of the methods we declared to be web services. For all practical purposes, the object returned is equivalent to our web service class.</p></div></div><p>Recall from our previous discussion that in order for resource injection to work in a standalone client (that does not get deployed to GlassFish), we need to execute it through the <code class="literal">appclient</code> utility. Assuming we packaged our client in a <code class="literal">.jar</code> file called <code class="literal">calculatorserviceclient.jar</code>, the command to execute would be the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>appclient -client calculatorserviceclient.jar</strong></span>
</pre></div><p>After entering the preceding command in the command line, we should see the following output of our client on the console:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>1 + 2 = 3</strong></span>
<span class="strong"><strong>1 - 2 = -1</strong></span>
</pre></div><p>In this example, we passed<a id="id992" class="indexterm"/> primitive types as parameters and return values. Of course, it is also possible to pass objects both as parameters and as return values. Unfortunately, not all standard Java classes or primitive types can be used as method parameters or return values when invoking web services. <a id="id993" class="indexterm"/>The reason for this is that behind the scenes, method parameters and return types get mapped to XML definitions, and not all types can be properly mapped.</p><p>Valid types that can be <a id="id994" class="indexterm"/>used in JAX-WS web service calls are listed as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">java.awt.Image</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">java.lang.Object</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Java.lang.String</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">java.math.BigDecimal</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">java.math.BigInteger</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">java.net.URI</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">java.util.Calendar</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">java.util.Date</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">java.util.UUID</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">javax.activation.DataHandler</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">javax.xml.datatype.Duration</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">javax.xml.datatype.XMLGregorianCalendar</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">javax.xml.namespace.QName</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">javax.xml.transform.Source</code></li></ul></div><p>Additionally, the following primitive types can be used:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">boolean</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">byte</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">byte[]</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">double</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">float</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">int</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">long</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">short</code></li></ul></div><p>We can also use our own custom classes as method parameters and/or return values for web service methods, but member variables of our classes must be one of the types listed in the preceding list.</p><p>Additionally, arrays can be used both as method parameters or return values, however, when executing <code class="literal">wsimport</code>, these arrays get converted to <code class="literal">Lists</code>, generating a mismatch between the method<a id="id995" class="indexterm"/> signature in the web service and the method call invoked in the client. For this reason, it is preferred to use <code class="literal">Lists</code> as method parameters and/or return values, since this is also valid and does not create a mismatch between the client and the server.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note40"/>Note</h3><p>JAX-WS internally uses the <span class="strong"><strong>Java Architecture for XML Binding</strong></span> (<span class="strong"><strong>JAXB</strong></span>)<a id="id996" class="indexterm"/> to create SOAP messages from method calls. The types we are allowed to use for method calls and return values are the ones that JAXB supports. You can get more information on JAXB at <a class="ulink" href="https://jaxb.dev.java.net/">https://jaxb.dev.java.net/</a>.</p></div></div></div><div class="section" title="Sending attachments to web services"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec70"/>Sending attachments to web services</h2></div></div></div><p>In addition to sending and accepting the data types discussed in the previous sections, web service methods can<a id="id997" class="indexterm"/> send and accept file attachments. The following example illustrates how to do this:</p><div class="informalexample"><pre class="programlisting">package net.ensode.glassfishbook;

import java.io.FileOutputStream;
import java.io.IOException;

import javax.activation.DataHandler;
import javax.jws.WebMethod;
import javax.jws.WebService;

@WebService
public class FileAttachment {

  @WebMethod
<span class="strong"><strong>  public void attachFile(DataHandler dataHandler) {</strong></span>
    FileOutputStream fileOutputStream;
    try {

      // substitute "/tmp/attachment.gif" with
      // a valid path, if necessary.
<span class="strong"><strong>      fileOutputStream = new FileOutputStream(</strong></span>
<span class="strong"><strong>          "/tmp/attachment.gif");</strong></span>

<span class="strong"><strong>      dataHandler.writeTo(fileOutputStream);</strong></span>

      fileOutputStream.flush();
      fileOutputStream.close();
    } catch (IOException e) {
      e.printStackTrace();
    }

  }
}</pre></div><p>In order to write a web service method that receives one or more attachments, all we need to do is to add a parameter of type <code class="literal">javax.activation.DataHandler</code> for each attachment the method will receive. In the preceding example code, the <code class="literal">attachFile()</code> method<a id="id998" class="indexterm"/> takes a single parameter of this type and simply writes it to the filesystem.</p><p>Just like with any standard web service, the preceding code needs to be packaged in a WAR file and deployed. <a id="id999" class="indexterm"/>Once deployed, a WSDL will automatically be generated. We then need to execute the <code class="literal">wsimport</code> utility<a id="id1000" class="indexterm"/> to generate the code that our web service client can use to access the web service. As previously discussed, the <code class="literal">wsimport</code> utility can be invoked directly from the command line or via a custom ANT target.</p><p>Once we have executed <code class="literal">wsimport</code> to generate code to access the web service, we can write and compile our client code as follows:</p><div class="informalexample"><pre class="programlisting">package net.ensode.glassfishbook;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.channels.FileChannel;

import javax.xml.ws.WebServiceRef;

public class FileAttachmentServiceClient {

  @WebServiceRef(wsdlLocation = "http://localhost:8080/fileattachmentservice/"+ "FileAttachmentService?wsdl")
  private static FileAttachmentService fileAttachmentService;

  public static void main(String[] args) {
    FileAttachment fileAttachment = fileAttachmentService.
        getFileAttachmentPort();
    File fileToAttach = new File("src/main/resources/logo.gif");

<span class="strong"><strong>    byte[] fileBytes = fileToByteArray(fileToAttach);</strong></span>

<span class="strong"><strong>    fileAttachment.attachFile(fileBytes);</strong></span>
    System.out.println("Successfully sent attachment.");
  }

  static byte[] fileToByteArray(File file) {
    byte[] fileBytes = null;

    try {
      FileInputStream fileInputStream;
      fileInputStream = new FileInputStream(file);

      FileChannel fileChannel = fileInputStream.getChannel();
      fileBytes = new byte[(int) fileChannel.size()];
      ByteBuffer byteBuffer = ByteBuffer.wrap(fileBytes);
      fileChannel.read(byteBuffer);
    } catch (IOException e) {
      e.printStackTrace();
    }
    return fileBytes;
  }
}</pre></div><p>A web service client that needs to send one or more attachments to the web service first obtains an instance of the web service as usual. It then creates an instance of <code class="literal">java.io.File</code>, passing the location of the file to attach as its constructor's parameter.</p><p>Once we have an instance of <code class="literal">java.io.File</code> containing the file we wish to attach, we then need to convert the file to a byte array and pass this byte array to the web service method that expects an attachment.</p><p>Notice that the parameter type used when the client invokes a method expecting an attachment is different from <a id="id1001" class="indexterm"/>the parameter type of the method in the web server code. The method in the web server code expects an instance of <code class="literal">javax.activation.DataHandler</code> for each attachment. However, the code generated by <code class="literal">wsimport</code> expects an array of bytes for each attachment. These arrays of bytes are converted to the right type (<code class="literal">javax.activation.DataHandler</code>) behind the scenes by the code generated by <code class="literal">wsimport</code>. We as application developers don't need to concern ourselves with the details <a id="id1002" class="indexterm"/>of why this happens. We just need to keep in mind that when sending attachments to a web service method, the parameter types will be different in the web service code and in the client invocation.</p></div></div></div>
<div class="section" title="Exposing EJBs as web services"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec54"/>Exposing EJBs as web services</h1></div></div></div><p>In addition to creating web services<a id="id1003" class="indexterm"/> as described in the previous section, public methods of stateless session beans can easily be exposed as web services. The following<a id="id1004" class="indexterm"/> example illustrates how to do this:</p><div class="informalexample"><pre class="programlisting">package net.ensode.glassfishbook;

import javax.ejb.Stateless;
import javax.jws.WebService;

@Stateless
<span class="strong"><strong>@WebService</strong></span>
public class DecToHexBean {

  public String convertDecToHex(int i) {
    return Integer.toHexString(i);
  }
}</pre></div><p>As we can see, the only thing we need to do to expose a stateless session bean's public methods is decorate its class declaration with the <code class="literal">@WebService</code> annotation<a id="id1005" class="indexterm"/>. Since the class is a stateless session bean, it also needs to be decorated with the <code class="literal">@Stateless</code> annotation<a id="id1006" class="indexterm"/>.</p><p>Just like regular stateless session beans, the ones whose methods are exposed as web services need to be deployed in a <code class="literal">.jar</code> file. Once deployed, we can see the new web service under the <span class="strong"><strong>Applications</strong></span> node in the GlassFish administration web console. Clicking on the application's node, we can see some details in the GlassFish console, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/6886EN_10_07.jpg" alt="Exposing EJBs as web services"/></div><p>Notice that the value in the <span class="strong"><strong>Type</strong></span> column for our new web service is <span class="strong"><strong>StatelessSessionBean</strong></span>. This allows us to see at a glance that the web service is implemented as an <span class="strong"><strong>Enterprise JavaBean</strong></span> (<span class="strong"><strong>EJB</strong></span>).</p><p>Just like standard web services, <a id="id1007" class="indexterm"/>EJB web services automatically <a id="id1008" class="indexterm"/>generate a WSDL to be used by its clients upon deployment; it can be accessed the same way by clicking on the <span class="strong"><strong>View EndPoint</strong></span> link.</p><div class="section" title="EJB web service clients"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec71"/>EJB web service clients</h2></div></div></div><p>The following class<a id="id1009" class="indexterm"/> illustrates the procedure to be followed to access EJB web service methods from a client application:</p><div class="informalexample"><pre class="programlisting">package net.ensode.glassfishbook;

import javax.xml.ws.WebServiceRef;

public class DecToHexClient {

  @WebServiceRef(wsdlLocation = "http://localhost:8080/DecToHexBeanService/DecToHexBean?wsdl")
  private static DecToHexBeanService decToHexBeanService;

  public void convert() {
    DecToHexBean decToHexBean = decToHexBeanService.getDecToHexBeanPort();

    System.out.println("decimal 4013 in hex is: "
        + decToHexBean.convertDecToHex(4013));
  }

  public static void main(String[] args) {
    new DecToHexClient().convert();
  }
}</pre></div><p>As we can see, nothing special needs to be done when accessing an EJB web service from a client. The procedure is the same as with standard web services.</p><p>Since the preceding example<a id="id1010" class="indexterm"/> is a standalone application, it needs<a id="id1011" class="indexterm"/> to be executed via the <code class="literal">appclient</code> application as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>appclient -client ejbwsclient.jar</strong></span>
</pre></div><p>The preceding command results in the following output:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>decimal 4013 in hex is: fad</strong></span>
</pre></div></div></div>
<div class="section" title="Securing web services"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec55"/>Securing web services</h1></div></div></div><p>Just like with regular web applications, web services can be secured so that only authorized users can access<a id="id1012" class="indexterm"/> them. This can be accomplished by modifying the web service's <code class="literal">web.xml</code> deployment descriptor, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;web-app  version="2.5"
         
         xsi:schemaLocation="http://java.sun.com/xml/ns/javaee
         http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"&gt;
<span class="strong"><strong>  &lt;security-constraint&gt;</strong></span>
<span class="strong"><strong>    &lt;web-resource-collection&gt;</strong></span>
<span class="strong"><strong>      &lt;web-resource-name&gt;Calculator Web Service&lt;/web-resource-name&gt;</strong></span>
<span class="strong"><strong>      &lt;url-pattern&gt;/CalculatorService/*&lt;/url-pattern&gt;</strong></span>
<span class="strong"><strong>      &lt;http-method&gt;POST&lt;/http-method&gt;</strong></span>
<span class="strong"><strong>    &lt;/web-resource-collection&gt;</strong></span>
<span class="strong"><strong>    &lt;auth-constraint&gt;</strong></span>
<span class="strong"><strong>      &lt;role-name&gt;user&lt;/role-name&gt;</strong></span>
<span class="strong"><strong>    &lt;/auth-constraint&gt;</strong></span>
<span class="strong"><strong>  &lt;/security-constraint&gt;</strong></span>
<span class="strong"><strong>  &lt;login-config&gt;</strong></span>
<span class="strong"><strong>    &lt;auth-method&gt;BASIC&lt;/auth-method&gt;</strong></span>
<span class="strong"><strong>    &lt;realm-name&gt;file&lt;/realm-name&gt;</strong></span>
<span class="strong"><strong>  &lt;/login-config&gt;</strong></span>
&lt;/web-app&gt;</pre></div><p>In this example, we modify our calculator service so that only authorized users can access it. Notice that the modifications needed to secure the web service are no different from the modifications needed to secure any regular web application. The URL pattern to be used for the <code class="literal">&lt;url-pattern&gt;</code> element<a id="id1013" class="indexterm"/> can be obtained by clicking on the <span class="strong"><strong>View WSDL</strong></span> link corresponding to our service. In our example, the URL for the link is:</p><p>
<code class="literal">http://localhost:8080/calculatorservice/CalculatorService?wsdl</code>
</p><p>The value to be used for <code class="literal">&lt;url-pattern&gt;</code> is the value right after the context root (<code class="literal">/CalculatorService</code> in our example) and before the question mark, followed by a slash and an asterisk.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note41"/>Note</h3><p>Notice that the preceding <code class="literal">web.xml</code> deployment descriptor only secures HTTP <code class="literal">POST</code> requests. The reason for this is that <code class="literal">wsimport</code> uses a <code class="literal">GET</code> request to obtain the WSDL and generate the appropriate code. If <code class="literal">GET</code> requests are secured, <code class="literal">wsimport</code> will fail, since it will be denied access to the WSDL.</p></div></div><p>The following code illustrates how a standalone client can access a secured web service:</p><div class="informalexample"><pre class="programlisting">package net.ensode.glassfishbook;

import javax.xml.ws.BindingProvider;
import javax.xml.ws.WebServiceRef;

public class CalculatorServiceClient {
  
  @WebServiceRef(
  wsdlLocation = "http://localhost:8080/securecalculatorservice/CalculatorService?wsdl")
  private static CalculatorService calculatorService;

  public void calculate() {
    //add a user named "joe" with a password of "password"
    //to the file realm to successfuly execute the web service.
    //"joe" must belong to the group "appuser".
    Calculator calculator = calculatorService.getCalculatorPort();
<span class="strong"><strong>    ((BindingProvider) calculator).getRequestContext().put(</strong></span>
<span class="strong"><strong>        BindingProvider.USERNAME_PROPERTY, "joe");</strong></span>
<span class="strong"><strong>    ((BindingProvider) calculator).getRequestContext().put(</strong></span>
<span class="strong"><strong>        BindingProvider.PASSWORD_PROPERTY, "password");</strong></span>

    System.out.println("1 + 2 = " + calculator.add(1, 2));
    System.out.println("1 - 2 = " + calculator.subtract(1, 2));
  }

  public static void main(String[] args) {
    new CalculatorServiceClient().calculate();
  }
}</pre></div><p>The preceding code is a modified version of the <code class="literal">Calculator</code> service standalone client we saw earlier in the chapter. This version was modified to access the secure version of the service. As can be seen in the code, all we need to do to access the secured version of the server is put a username and a<a id="id1014" class="indexterm"/> password in the request context. The username and password must be valid for the realm used to authenticate the web service.</p><p>We can add the username and password to the request context by casting our web service endpoint class to <code class="literal">javax.xml.ws.BindingProvider</code> and calling its <code class="literal">getRequestContext()</code> method<a id="id1015" class="indexterm"/>. This method returns a <code class="literal">java.util.Map</code> instance. We can then simply add the username and password by calling the <code class="literal">put</code> method<a id="id1016" class="indexterm"/> of <code class="literal">Map</code> and using the constants <code class="literal">USERNAME_PROPERTY</code> and <code class="literal">PASSWORD_PROPERTY</code> defined in <code class="literal">BindingProvider</code> as keys, and the corresponding <code class="literal">String</code> objects as values.</p></div>
<div class="section" title="Securing EJB web services"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec56"/>Securing EJB web services</h1></div></div></div><p>Just like standard web services,<a id="id1017" class="indexterm"/> EJBs exposed as web services can be secured so that only authorized clients can access them. This can be accomplished by configuring the EJB via the <code class="literal">glassfish-ejb-jar.xml</code> file as follows:</p><div class="informalexample"><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE glassfish-ejb-jar PUBLIC "-//GlassFish.org//DTD GlassFish Application Server 3.1 EJB 3.1//EN" "http://glassfish.org/dtds/glassfish-ejb-jar_3_1-1.dtd"&gt;
&lt;glassfish-ejb-jar&gt;
    &lt;ejb&gt;
        &lt;ejb-name&gt;SecureDecToHexBean&lt;/ejb-name&gt;
<span class="strong"><strong>        &lt;webservice-endpoint&gt;                </strong></span>
<span class="strong"><strong>            &lt;port-component-name&gt;</strong></span>
<span class="strong"><strong>              SecureDecToHexBean</strong></span>
<span class="strong"><strong>            &lt;/port-component-name&gt;</strong></span>
<span class="strong"><strong>            &lt;login-config&gt;</strong></span>
<span class="strong"><strong>                &lt;auth-method&gt;BASIC&lt;/auth-method&gt;</strong></span>
<span class="strong"><strong>                &lt;realm&gt;file&lt;/realm&gt;</strong></span>
<span class="strong"><strong>            &lt;/login-config&gt;</strong></span>
<span class="strong"><strong>        &lt;/webservice-endpoint&gt;</strong></span>
    &lt;/ejb&gt;
&lt;/glassfish-ejb-jar&gt;</pre></div><p>As seen in the preceding deployment descriptor, security is set up differently for EJBs exposed as web services rather than with standard EJBs. For EJBs exposed as web services, the security configuration is<a id="id1018" class="indexterm"/> done inside the <code class="literal">&lt;webservice-endpoint&gt;</code> element of the <code class="literal">glassfish-ejb-jar.xml</code> file.</p><p>The <code class="literal">&lt;port-component-name&gt;</code> element<a id="id1019" class="indexterm"/> must be set to the name of the EJB we are exposing as a web service. This name is defined in the <code class="literal">&lt;ejb-name&gt;</code> element for the EJB.</p><p>The <code class="literal">&lt;login-config&gt;</code> element is very similar to the corresponding element in a web application's <code class="literal">web.xml</code> deployment descriptor. The <code class="literal">&lt;login-config&gt;</code> element<a id="id1020" class="indexterm"/> must contain an authorization method, defined by its <code class="literal">&lt;auth-method&gt;</code> subelement, and a realm to use for authentication. The realm is defined by the <code class="literal">&lt;realm&gt;</code> subelement.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note42"/>Note</h3><p>Do not use the <code class="literal">@RolesAllowed</code> annotation<a id="id1021" class="indexterm"/> for EJBs intended to be exposed as web services. This annotation is intended for when the EJB methods are accessed through its remote or local interface. If an EJB or one or more of its methods are decorated with this annotation, then invoking the method will fail with a security exception.</p></div></div><p>Once we configure an EJB web service for authentication, we package it in a <code class="literal">.jar</code> file, and then deploy it as usual. The EJB web service is now ready to be accessed by clients.</p><p>The following code example illustrates how an EJB web service client can access a secure EJB web service:</p><div class="informalexample"><pre class="programlisting">package net.ensode.glassfishbook;

import javax.xml.ws.BindingProvider;
import javax.xml.ws.WebServiceRef;

public class DecToHexClient {

  @WebServiceRef(
  wsdlLocation = "http://localhost:8080/SecureDecToHexBeanService/SecureDecToHexBean?wsdl")
  private static SecureDecToHexBeanService secureDecToHexBeanService;

  public void convert() {
    SecureDecToHexBean secureDecToHexBean = secureDecToHexBeanService.
        getSecureDecToHexBeanPort();
    ((BindingProvider) secureDecToHexBean).getRequestContext().put(
        BindingProvider.USERNAME_PROPERTY, "joe");
    ((BindingProvider) secureDecToHexBean).getRequestContext().put(
        BindingProvider.PASSWORD_PROPERTY, "password");

    System.out.println("decimal 4013 in hex is: "
        + secureDecToHexBean.convertDecToHex(4013));
  }

  public static void main(String[] args) {
    new DecToHexClient().convert();
  }
}</pre></div><p>As we can see in the previous<a id="id1022" class="indexterm"/> example, the procedure for accessing an EJB exposed as a web service is identical to accessing a standard web service. The implementation of the web service is irrelevant to the client.</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec57"/>Summary</h1></div></div></div><p>In this chapter, we covered how to develop web services and web service clients via the JAX-WS API. We explained how to incorporate web service code generation for web service clients when using ANT or Maven as a build tool. We also covered the valid types that can be used for remote method calls via JAX-WS. Additionally, we discussed how to send attachments to a web service. We also covered how to expose EJB methods as web services. Lastly, we covered how to secure web services so that they are not accessible to unauthorized clients.</p><p>In the next chapter, we will cover RESTful web services with JAX-RS.</p></div></body></html>