<html><head></head><body>
<div id="_idContainer079">
<h1 class="hapter-number" id="_idParaDest-89"><a id="_idTextAnchor089"/><span class="koboSpan" id="kobo.1.1">10</span></h1>
<h1 id="_idParaDest-90"><a id="_idTextAnchor090"/><span class="koboSpan" id="kobo.2.1">Assembling the Application</span></h1>
<p><span class="koboSpan" id="kobo.3.1">Now that we have implemented some use cases, web adapters, and persistence adapters, we need to assemble them into a working application. </span><span class="koboSpan" id="kobo.3.2">As discussed in </span><a href="B19916_04.xhtml#_idTextAnchor037"><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.4.1">Chapter 4</span></em></span></a><span class="koboSpan" id="kobo.5.1">, </span><em class="itali"><span class="koboSpan" id="kobo.6.1">Organizing Code</span></em><span class="koboSpan" id="kobo.7.1">, we rely on a </span><strong class="bold"><span class="koboSpan" id="kobo.8.1">dependency injection</span></strong><span class="koboSpan" id="kobo.9.1"> mechanism to instantiate our classes and wire them together at start-up time. </span><span class="koboSpan" id="kobo.9.2">In this chapter, we’ll discuss some approaches to doing this with plain Java and the Spring and Spring </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">Boot frameworks.</span></span></p>
<h1 id="_idParaDest-91"><a id="_idTextAnchor091"/><span class="koboSpan" id="kobo.11.1">Why even care about assembly?</span></h1>
<p><span class="koboSpan" id="kobo.12.1">Why aren’t we just instantiating the use cases and adapters when and where we need them? </span><span class="koboSpan" id="kobo.12.2">Because we want to keep the code dependencies pointed in the right direction. </span><span class="koboSpan" id="kobo.12.3">Remember: all dependencies should point inward, toward the domain code of our application, so that the domain code doesn’t have to change when something in the outer </span><span class="No-Break"><span class="koboSpan" id="kobo.13.1">layers changes.</span></span></p>
<p><span class="koboSpan" id="kobo.14.1">If a use case </span><a id="_idIndexMarker207"/><span class="koboSpan" id="kobo.15.1">needs to call a persistence adapter and just instantiates it itself, we have created a code dependency in the </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">wrong direction.</span></span></p>
<p><span class="koboSpan" id="kobo.17.1">This is why we created outgoing port interfaces. </span><span class="koboSpan" id="kobo.17.2">The use case only knows the interface and is provided an implementation of this interface </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">at runtime.</span></span></p>
<p><span class="koboSpan" id="kobo.19.1">A nice side effect of this programming style is that the code we’re creating is much easier to test. </span><span class="koboSpan" id="kobo.19.2">If we can pass all objects a class needs into its constructor, we can choose to pass in mocks instead of the real objects, which makes it easy to create an isolated unit test for </span><span class="No-Break"><span class="koboSpan" id="kobo.20.1">the class.</span></span></p>
<p><span class="koboSpan" id="kobo.21.1">So, who’s responsible for creating our object instances? </span><span class="koboSpan" id="kobo.21.2">And how do we do it without violating the </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.22.1">Dependency Rule</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.23.1">?</span></span></p>
<p><span class="koboSpan" id="kobo.24.1">The answer is that there must be a configuration component that is neutral to our architecture and that has a dependency to all classes in order to instantiate them, as shown in </span><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.25.1">Figure 10</span></em></span><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.26.1">.1</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.27.1">.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer074">
<span class="koboSpan" id="kobo.28.1"><img alt="Figure 10.1 – A neutral configuration component may access all classes in order to instantiate them" src="image/Figure_10.1_B19916.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.29.1">Figure 10.1 – A neutral configuration component may access all classes in order to instantiate them</span></p>
<p><span class="koboSpan" id="kobo.30.1">In the </span><em class="itali"><span class="koboSpan" id="kobo.31.1">Clean Architecture</span></em><span class="koboSpan" id="kobo.32.1"> introduced in </span><a href="B19916_03.xhtml#_idTextAnchor029"><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.33.1">Chapter 3</span></em></span></a><span class="koboSpan" id="kobo.34.1">, </span><em class="itali"><span class="koboSpan" id="kobo.35.1">Inverting Dependencies</span></em><span class="koboSpan" id="kobo.36.1">, this configuration component </span><a id="_idIndexMarker208"/><span class="koboSpan" id="kobo.37.1">would be in the outermost circle, which may access all inner layers, as defined by the </span><span class="No-Break"><span class="koboSpan" id="kobo.38.1">Dependency Rule.</span></span></p>
<p><span class="koboSpan" id="kobo.39.1">The configuration component is responsible for assembling a working application from the parts we provided. </span><span class="koboSpan" id="kobo.39.2">It must do </span><span class="No-Break"><span class="koboSpan" id="kobo.40.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.41.1">Create web </span><span class="No-Break"><span class="koboSpan" id="kobo.42.1">adapter instances.</span></span></li>
<li><span class="koboSpan" id="kobo.43.1">Ensure that HTTP requests are actually routed to the </span><span class="No-Break"><span class="koboSpan" id="kobo.44.1">web adapters.</span></span></li>
<li><span class="koboSpan" id="kobo.45.1">Create use </span><span class="No-Break"><span class="koboSpan" id="kobo.46.1">case instances.</span></span></li>
<li><span class="koboSpan" id="kobo.47.1">Provide web adapters with use </span><span class="No-Break"><span class="koboSpan" id="kobo.48.1">case instances.</span></span></li>
<li><span class="koboSpan" id="kobo.49.1">Create persistence </span><span class="No-Break"><span class="koboSpan" id="kobo.50.1">adapter instances.</span></span></li>
<li><span class="koboSpan" id="kobo.51.1">Provide use cases with persistence </span><span class="No-Break"><span class="koboSpan" id="kobo.52.1">adapter instances.</span></span></li>
<li><span class="koboSpan" id="kobo.53.1">Ensure that the persistence adapters can actually access </span><span class="No-Break"><span class="koboSpan" id="kobo.54.1">the database.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.55.1">Besides that, the configuration component should be able to access certain sources of configuration parameters, such as configuration files or command-line parameters. </span><span class="koboSpan" id="kobo.55.2">During application assembly, the configuration component then passes these parameters on </span><a id="_idIndexMarker209"/><span class="koboSpan" id="kobo.56.1">to the application components to control behavior such as which database to access or which server to use to </span><span class="No-Break"><span class="koboSpan" id="kobo.57.1">send emails.</span></span></p>
<p><span class="koboSpan" id="kobo.58.1">These are a lot of responsibilities (read: reasons to change). </span><span class="koboSpan" id="kobo.58.2">Aren’t we violating the </span><strong class="bold"><span class="koboSpan" id="kobo.59.1">Single Responsibility Principle</span></strong><span class="koboSpan" id="kobo.60.1"> here? </span><span class="koboSpan" id="kobo.60.2">Yes, we are, but if we want to keep the rest of the application clean, we need an outside component that takes care of the wiring. </span><span class="koboSpan" id="kobo.60.3">And this component has to know all the moving parts to assemble them into a </span><span class="No-Break"><span class="koboSpan" id="kobo.61.1">working application.</span></span></p>
<h1 id="_idParaDest-92"><a id="_idTextAnchor092"/><span class="koboSpan" id="kobo.62.1">Assembling via plain code</span></h1>
<p><span class="koboSpan" id="kobo.63.1">There are </span><a id="_idIndexMarker210"/><span class="koboSpan" id="kobo.64.1">several ways to implement a configuration component </span><a id="_idIndexMarker211"/><span class="koboSpan" id="kobo.65.1">responsible for assembling the application. </span><span class="koboSpan" id="kobo.65.2">If we’re building an application without the support of a dependency injection framework, we can create such a component with </span><span class="No-Break"><span class="koboSpan" id="kobo.66.1">plain code:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer075">
<span class="koboSpan" id="kobo.67.1"><img alt="" src="image/code-10.1.jpg"/></span>
</div>
</div>
<p><span class="koboSpan" id="kobo.68.1">This code snippet is a simplified example of how such a configuration component might look. </span><span class="koboSpan" id="kobo.68.2">In Java, an application is started from the </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.69.1">main</span></strong><span class="koboSpan" id="kobo.70.1"> method. </span><span class="koboSpan" id="kobo.70.2">Within this method, we instantiate all </span><a id="_idIndexMarker212"/><span class="koboSpan" id="kobo.71.1">the classes we need, from the web controller to </span><a id="_idIndexMarker213"/><span class="koboSpan" id="kobo.72.1">the persistence adapter, and wire </span><span class="No-Break"><span class="koboSpan" id="kobo.73.1">them together.</span></span></p>
<p><span class="koboSpan" id="kobo.74.1">Finally, we call the mystic method </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.75.1">startProcessingWebRequests()</span></strong><span class="koboSpan" id="kobo.76.1">, </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.77.1">w</span></strong><span class="koboSpan" id="kobo.78.1">hich exposes the web controller via HTTP.</span><span id="footnote-034-backlink"><a class="_idFootnoteLink _idGenColorInherit" href="#footnote-034"><span class="koboSpan" id="kobo.79.1">1</span></a></span><span class="supers ript"> </span><span class="koboSpan" id="kobo.80.1">The application is then ready to </span><span class="No-Break"><span class="koboSpan" id="kobo.81.1">process requests.</span></span></p>
<div class="_idFootnote" epub:type="footnote" id="footnote-034">
<p><a class="_idFootnoteAnchor _idGenColorInherit" href="#footnote-034-backlink"><span class="koboSpan" id="kobo.82.1">1</span></a><span class="koboSpan" id="kobo.83.1">	The method </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.84.1">startProcessingWebRequests()</span></strong><span class="koboSpan" id="kobo.85.1">is just a placeholder for any bootstrapping logic that is necessary to expose our web adapters via HTTP. </span><span class="koboSpan" id="kobo.85.2">We don’t really want to implement this ourselves. </span><span class="koboSpan" id="kobo.85.3">In a real-world application, a framework does that </span><span class="No-Break"><span class="koboSpan" id="kobo.86.1">for us</span></span><span class="No-Break"><span class="koboSpan" id="kobo.87.1">.</span></span></p>
</div>
<p><span class="koboSpan" id="kobo.88.1">This plain code approach is the most basic way of assembling an application. </span><span class="koboSpan" id="kobo.88.2">It has some </span><span class="No-Break"><span class="koboSpan" id="kobo.89.1">drawbacks, however:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.90.1">First of all, the preceding code is for an application that has only a single web controller, use case, and persistence adapter. </span><span class="koboSpan" id="kobo.90.2">Imagine how much code like this we would have to produce to bootstrap a full-blown </span><span class="No-Break"><span class="koboSpan" id="kobo.91.1">enterprise application!</span></span></li>
<li><span class="koboSpan" id="kobo.92.1">Second, since we’re instantiating all classes ourselves from outside of their packages, those classes all need to be public. </span><span class="koboSpan" id="kobo.92.2">This means, for example, that the Java compiler doesn’t prevent a use case from directly accessing a persistence adapter since it’s public. </span><span class="koboSpan" id="kobo.92.3">It would be nice if we could avoid unwanted dependencies like this by using </span><span class="No-Break"><span class="koboSpan" id="kobo.93.1">package-private visibility.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.94.1">Luckily, there are dependency injection frameworks that can do the dirty work for us while still </span><a id="_idIndexMarker214"/><span class="koboSpan" id="kobo.95.1">maintaining package-private dependencies. </span><span class="koboSpan" id="kobo.95.2">The Spring framework </span><a id="_idIndexMarker215"/><span class="koboSpan" id="kobo.96.1">is currently the most popular one in the Java world. </span><span class="koboSpan" id="kobo.96.2">Spring also provides web and database support, among a lot of other things, so we don’t have to implement the mystic </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.97.1">startProcessingWebRequests()</span></strong><span class="koboSpan" id="kobo.98.1"> method </span><span class="No-Break"><span class="koboSpan" id="kobo.99.1">after all.</span></span></p>
<h1 id="_idParaDest-93"><a id="_idTextAnchor093"/><span class="koboSpan" id="kobo.100.1">Assembling via Spring’s classpath scanning</span></h1>
<p><span class="koboSpan" id="kobo.101.1">If we use the Spring framework to assemble our application, the result is called the </span><strong class="bold"><span class="koboSpan" id="kobo.102.1">application context</span></strong><span class="koboSpan" id="kobo.103.1">. </span><span class="koboSpan" id="kobo.103.2">The </span><a id="_idIndexMarker216"/><span class="koboSpan" id="kobo.104.1">application context contains all objects that together make up the</span><a id="_idIndexMarker217"/><span class="koboSpan" id="kobo.105.1"> application (</span><strong class="bold"><span class="koboSpan" id="kobo.106.1">beans</span></strong><span class="koboSpan" id="kobo.107.1"> in </span><span class="No-Break"><span class="koboSpan" id="kobo.108.1">Java lingo).</span></span></p>
<p><span class="koboSpan" id="kobo.109.1">Spring offers </span><a id="_idIndexMarker218"/><span class="koboSpan" id="kobo.110.1">several approaches to assemble </span><a id="_idIndexMarker219"/><span class="koboSpan" id="kobo.111.1">an application context, each having its own </span><a id="_idIndexMarker220"/><span class="koboSpan" id="kobo.112.1">advantages and drawbacks. </span><span class="koboSpan" id="kobo.112.2">Let’s start by discussing the most popular (and most convenient) approach: </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.113.1">classpath scanning</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.114.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.115.1">With classpath scanning, Spring goes through all classes that are available in a certain slice of the classpath and searches for classes that are annotated with the </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.116.1">@Component</span></strong><span class="koboSpan" id="kobo.117.1"> annotation. </span><span class="koboSpan" id="kobo.117.2">The framework then creates an object from each of these classes. </span><span class="koboSpan" id="kobo.117.3">The classes should have a constructor that takes all required fields as an argument, like our </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.118.1">AccountPersistenceAdapter</span></strong><span class="koboSpan" id="kobo.119.1"> from </span><a href="B19916_07.xhtml#_idTextAnchor062"><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.120.1">Chapter 7</span></em></span></a><em class="itali"><span class="koboSpan" id="kobo.121.1">, Implementing a </span></em><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.122.1">Persistence Adapter</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.123.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer076">
<span class="koboSpan" id="kobo.124.1"><img alt="" src="image/code-10.2.jpg"/></span>
</div>
</div>
<p><span class="koboSpan" id="kobo.125.1">In this case, we didn’t even write the constructor ourselves, but instead let the Lombok library do it </span><a id="_idIndexMarker221"/><span class="koboSpan" id="kobo.126.1">for us using the </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.127.1">@RequiredArgsConstructor</span></strong><span class="koboSpan" id="kobo.128.1"> annotation, which creates a constructor that takes all </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.129.1">final</span></strong><span class="koboSpan" id="kobo.130.1"> fields </span><span class="No-Break"><span class="koboSpan" id="kobo.131.1">as arguments.</span></span></p>
<p><span class="koboSpan" id="kobo.132.1">Spring will </span><a id="_idIndexMarker222"/><span class="koboSpan" id="kobo.133.1">find this constructor and search for </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.134.1">@Component</span></strong><span class="koboSpan" id="kobo.135.1">-annotated classes of the required argument types and instantiate them in a similar manner to add them to the application context. </span><span class="koboSpan" id="kobo.135.2">Once all required objects are available, it will finally call the constructor of </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.136.1">AccountPersistenceAdapter</span></strong><span class="koboSpan" id="kobo.137.1"> and add the resulting object to the application context </span><span class="No-Break"><span class="koboSpan" id="kobo.138.1">as well.</span></span></p>
<p><span class="koboSpan" id="kobo.139.1">Classpath scanning is a very convenient way of assembling an application. </span><span class="koboSpan" id="kobo.139.2">We only have to sprinkle some </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.140.1">@Component</span></strong><span class="koboSpan" id="kobo.141.1"> annotations across the code base and provide the </span><span class="No-Break"><span class="koboSpan" id="kobo.142.1">right constructors.</span></span></p>
<p><span class="koboSpan" id="kobo.143.1">We can also create our own stereotype annotation for Spring to pick up. </span><span class="koboSpan" id="kobo.143.2">We could, for example, create a </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.144.1">@</span></strong><span class="No-Break"><strong class="sour e-inline"><span class="koboSpan" id="kobo.145.1">PersistenceAdapter</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.146.1"> annotation:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer077">
<span class="koboSpan" id="kobo.147.1"><img alt="" src="image/code-10.3.jpg"/></span>
</div>
</div>
<p><span class="koboSpan" id="kobo.148.1">This annotation is meta-annotated with </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.149.1">@Component</span></strong><span class="koboSpan" id="kobo.150.1"> to let Spring know that it should be picked up during classpath scanning. </span><span class="koboSpan" id="kobo.150.2">We could now use </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.151.1">@PersistenceAdapter</span></strong><span class="koboSpan" id="kobo.152.1"> instead of </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.153.1">@Component</span></strong><span class="koboSpan" id="kobo.154.1"> to mark our persistence adapter classes as parts of our application. </span><span class="koboSpan" id="kobo.154.2">With this annotation, we have made our architecture more evident to people reading </span><span class="No-Break"><span class="koboSpan" id="kobo.155.1">the code.</span></span></p>
<p><span class="koboSpan" id="kobo.156.1">The classpath </span><a id="_idIndexMarker223"/><span class="koboSpan" id="kobo.157.1">scanning approach has its drawbacks, however. </span><span class="koboSpan" id="kobo.157.2">First, it’s invasive in that it requires us to add a framework-specific annotation </span><a id="_idIndexMarker224"/><span class="koboSpan" id="kobo.158.1">to our classes. </span><span class="koboSpan" id="kobo.158.2">If you’re a Clean Architecture hardliner, you’d say that this is forbidden as it binds our code to a </span><span class="No-Break"><span class="koboSpan" id="kobo.159.1">specific framework.</span></span></p>
<p><span class="koboSpan" id="kobo.160.1">I’d say that in usual application development, a single annotation on a class is not such a big deal and can easily be refactored, if at </span><span class="No-Break"><span class="koboSpan" id="kobo.161.1">all necessary.</span></span></p>
<p><span class="koboSpan" id="kobo.162.1">In other contexts, however, like when building a library or a framework for other developers to use, this might be a no-go since we don’t want to encumber our users with a dependency on the </span><span class="No-Break"><span class="koboSpan" id="kobo.163.1">Spring framework.</span></span></p>
<p><span class="koboSpan" id="kobo.164.1">Another potential drawback of the classpath scanning approach is that magic things might happen. </span><span class="koboSpan" id="kobo.164.2">And by </span><em class="itali"><span class="koboSpan" id="kobo.165.1">magic</span></em><span class="koboSpan" id="kobo.166.1">, I mean the bad kind of magic causing inexplicable effects that might take days to figure out if you’re not a </span><span class="No-Break"><span class="koboSpan" id="kobo.167.1">Spring expert.</span></span></p>
<p><span class="koboSpan" id="kobo.168.1">Magic happens because classpath scanning is a very blunt weapon to use for application assembly. </span><span class="koboSpan" id="kobo.168.2">We simply point Spring at the parent package of our application and tell it to go looking for </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.169.1">@Component</span></strong><span class="koboSpan" id="kobo.170.1">-annotated classes within </span><span class="No-Break"><span class="koboSpan" id="kobo.171.1">this package.</span></span></p>
<p><span class="koboSpan" id="kobo.172.1">Do you know every single class that exists within your application by heart? </span><span class="koboSpan" id="kobo.172.2">Probably not. </span><span class="koboSpan" id="kobo.172.3">There are bound to be some classes that we don’t actually want to have in the application context. </span><span class="koboSpan" id="kobo.172.4">Perhaps this class even manipulates the application context in evil ways, causing errors that are hard </span><span class="No-Break"><span class="koboSpan" id="kobo.173.1">to track.</span></span></p>
<p><span class="koboSpan" id="kobo.174.1">Let’s look at an alternative approach that gives us a little </span><span class="No-Break"><span class="koboSpan" id="kobo.175.1">more control.</span></span></p>
<h1 id="_idParaDest-94"><a id="_idTextAnchor094"/><span class="koboSpan" id="kobo.176.1">Assembling via Spring’s Java Config</span></h1>
<p><span class="koboSpan" id="kobo.177.1">While classpath </span><a id="_idIndexMarker225"/><span class="koboSpan" id="kobo.178.1">scanning is the cudgel of application assembly, Spring’s Java Config is the scalpel.</span><span id="footnote-033-backlink"><a class="_idFootnoteLink _idGenColorInherit" href="#footnote-033"><span class="koboSpan" id="kobo.179.1">2</span></a></span><span class="koboSpan" id="kobo.180.1"> This approach is similar to the plain code approach introduced earlier in this chapter, but it’s less</span><a id="_idIndexMarker226"/><span class="koboSpan" id="kobo.181.1"> messy and provides us with a framework so that we don’t have to code everything </span><span class="No-Break"><span class="koboSpan" id="kobo.182.1">by hand.</span></span></p>
<div class="_idFootnote" epub:type="footnote" id="footnote-033">
<p><a class="_idFootnoteAnchor _idGenColorInherit" href="#footnote-033-backlink"><span class="koboSpan" id="kobo.183.1">2</span></a><span class="koboSpan" id="kobo.184.1">	Cudgel versus scalpel: if you don’t spend far too many hours of your life killing monsters in role-playing video games like me and don’t know what a cudgel is, a cudgel is a stick with a weighted end that can be used as a weapon. </span><span class="koboSpan" id="kobo.184.2">It’s a very blunt weapon that can do a lot of damage without having to aim </span><span class="No-Break"><span class="koboSpan" id="kobo.185.1">particularly well</span></span><span class="No-Break"><span class="koboSpan" id="kobo.186.1">.</span></span></p>
</div>
<p><span class="koboSpan" id="kobo.187.1">In this approach, we create configuration classes, each responsible for constructing a set of beans that are to be added to the </span><span class="No-Break"><span class="koboSpan" id="kobo.188.1">application context.</span></span></p>
<p><span class="koboSpan" id="kobo.189.1">For example, we could create a configuration class that is responsible for instantiating all our </span><span class="No-Break"><span class="koboSpan" id="kobo.190.1">persistence adapters:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer078">
<span class="koboSpan" id="kobo.191.1"><img alt="" src="image/code-10.4.jpg"/></span>
</div>
</div>
<p><span class="koboSpan" id="kobo.192.1">The </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.193.1">@Configuration</span></strong><span class="koboSpan" id="kobo.194.1"> annotation marks this class as a configuration class to be picked up by Spring’s classpath scanning. </span><span class="koboSpan" id="kobo.194.2">So, in this case, we’re still using classpath scanning, but we only pick up our configuration classes instead of every single bean, which reduces the chance of evil </span><span class="No-Break"><span class="koboSpan" id="kobo.195.1">magic happening.</span></span></p>
<p><span class="koboSpan" id="kobo.196.1">The beans themselves are created within the </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.197.1">@Bean</span></strong><span class="koboSpan" id="kobo.198.1">-annotated factory methods of our configuration classes. </span><span class="koboSpan" id="kobo.198.2">In the preceding case, we add a persistence adapter to the application context. </span><span class="koboSpan" id="kobo.198.3">It needs two repositories and a mapper as input to its constructor. </span><span class="koboSpan" id="kobo.198.4">Spring automatically provides these objects as input to the </span><span class="No-Break"><span class="koboSpan" id="kobo.199.1">factory methods.</span></span></p>
<p><span class="koboSpan" id="kobo.200.1">But where does Spring get the repository objects from? </span><span class="koboSpan" id="kobo.200.2">If they are created manually in a factory method of another configuration class, then Spring will automatically provide them as parameters to the factory methods of the preceding code example. </span><span class="koboSpan" id="kobo.200.3">In this case, however, they are created by Spring itself, triggered by the </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.201.1">@EnableJpaRepositories</span></strong><span class="koboSpan" id="kobo.202.1"> annotation. </span><span class="koboSpan" id="kobo.202.2">If Spring Boot finds this annotation, it will automatically provide implementations for all Spring Data repository interfaces we </span><span class="No-Break"><span class="koboSpan" id="kobo.203.1">have defined.</span></span></p>
<p><span class="koboSpan" id="kobo.204.1">If you’re familiar with</span><a id="_idIndexMarker227"/><span class="koboSpan" id="kobo.205.1"> Spring Boot, you might know that we could have added </span><span class="No-Break"><span class="koboSpan" id="kobo.206.1">the </span></span><span class="No-Break"><strong class="sour e-inline"><span class="koboSpan" id="kobo.207.1">@EnableJpa</span></strong></span><strong class="sour e-inline"><span class="koboSpan" id="kobo.208.1">
Repositories</span></strong><span class="koboSpan" id="kobo.209.1"> annotation to the main application class instead of our custom configuration class. </span><span class="koboSpan" id="kobo.209.2">Yes, this is possible, but it will activate JPA repositories every time the application is started up, even if we start the </span><a id="_idIndexMarker228"/><span class="koboSpan" id="kobo.210.1">application within a test that doesn’t actually need persistence. </span><span class="koboSpan" id="kobo.210.2">So, by moving such “feature annotations” into a separate configuration “module,” we’ve just become much more flexible and can start up parts of our application instead of always having to start the </span><span class="No-Break"><span class="koboSpan" id="kobo.211.1">whole thing.</span></span></p>
<p><span class="koboSpan" id="kobo.212.1">With the </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.213.1">PersistenceAdapterConfiguration</span></strong><span class="koboSpan" id="kobo.214.1"> class, we have created a tightly scoped persistence module that instantiates all objects we need in our persistence layer. </span><span class="koboSpan" id="kobo.214.2">It will be automatically picked up by Spring’s classpath scanning while we still have full control over which beans are actually added to the </span><span class="No-Break"><span class="koboSpan" id="kobo.215.1">application context.</span></span></p>
<p><span class="koboSpan" id="kobo.216.1">Similarly, we could create configuration classes for web adapters, or for certain modules within our application layer. </span><span class="koboSpan" id="kobo.216.2">We can now create an application context that contains certain modules but mocks the beans of other modules, which gives us great flexibility in tests. </span><span class="koboSpan" id="kobo.216.3">We could even push the code of each of those modules into its own code base, package, or JAR file without </span><span class="No-Break"><span class="koboSpan" id="kobo.217.1">much refactoring.</span></span></p>
<p><span class="koboSpan" id="kobo.218.1">Also, this approach does not force us to sprinkle </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.219.1">@Component</span></strong><span class="koboSpan" id="kobo.220.1"> annotations all over our code base, like the classpath scanning approach does. </span><span class="koboSpan" id="kobo.220.2">So, we can keep our application layer clean without any dependency on the Spring framework (or any other framework, for </span><span class="No-Break"><span class="koboSpan" id="kobo.221.1">that matter).</span></span></p>
<p><span class="koboSpan" id="kobo.222.1">There is a catch with this solution, however. </span><span class="koboSpan" id="kobo.222.2">If the configuration class is not within the same package as the classes of the beans it creates (the persistence adapter classes in this case), those classes must be public. </span><span class="koboSpan" id="kobo.222.3">To restrict visibility, we can use packages as module boundaries</span><a id="_idIndexMarker229"/><span class="koboSpan" id="kobo.223.1"> and create a dedicated configuration class within</span><a id="_idIndexMarker230"/><span class="koboSpan" id="kobo.224.1"> each package. </span><span class="koboSpan" id="kobo.224.2">This way, we cannot use sub-packages, though, as will be discussed in </span><a href="B19916_12.xhtml#_idTextAnchor105"><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.225.1">Chapter 12</span></em></span></a><span class="koboSpan" id="kobo.226.1">,</span><em class="itali"><span class="koboSpan" id="kobo.227.1"> Enforcing </span></em><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.228.1">Architecture Boundaries</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.229.1">.</span></span></p>
<h1 id="_idParaDest-95"><a id="_idTextAnchor095"/><span class="koboSpan" id="kobo.230.1">How does this help me build maintainable software?</span></h1>
<p><span class="koboSpan" id="kobo.231.1">Spring and Spring Boot (and similar frameworks) provide a lot of features that make our lives easier. </span><span class="koboSpan" id="kobo.231.2">One of the main features is assembling the application out of the parts (classes) that we, as application </span><span class="No-Break"><span class="koboSpan" id="kobo.232.1">developers, provide.</span></span></p>
<p><span class="koboSpan" id="kobo.233.1">Classpath scanning is a very convenient feature. </span><span class="koboSpan" id="kobo.233.2">We only have to point Spring to a package and it assembles an application from the classes it finds. </span><span class="koboSpan" id="kobo.233.3">This allows for rapid development, with us not having to think about the application as </span><span class="No-Break"><span class="koboSpan" id="kobo.234.1">a whole.</span></span></p>
<p><span class="koboSpan" id="kobo.235.1">Once the code base grows, however, this quickly leads to a lack of transparency. </span><span class="koboSpan" id="kobo.235.2">We don’t know which beans exactly are loaded into the application context. </span><span class="koboSpan" id="kobo.235.3">Also, we cannot easily start up isolated parts of the application context to use </span><span class="No-Break"><span class="koboSpan" id="kobo.236.1">in tests.</span></span></p>
<p><span class="koboSpan" id="kobo.237.1">By creating a dedicated configuration component responsible for assembling our application, we can liberate our application code from this responsibility (read: “reason for change” – remember the “S” in “SOLID”?). </span><span class="koboSpan" id="kobo.237.2">We’re rewarded with highly cohesive modules that we can start up in isolation from each other and that we can easily move around within our code base. </span><span class="koboSpan" id="kobo.237.3">As usual, this comes at the price of spending some extra time to maintain this </span><span class="No-Break"><span class="koboSpan" id="kobo.238.1">configuration component.</span></span></p>
<p><span class="koboSpan" id="kobo.239.1">We’ve talked a lot about different options of how to do things “the right way” in this and the previous chapters. </span><span class="koboSpan" id="kobo.239.2">However, sometimes “the right way” is not feasible. </span><span class="koboSpan" id="kobo.239.3">In the next chapter, we’ll talk about shortcuts, the price we pay for them, and when they’re </span><span class="No-Break"><span class="koboSpan" id="kobo.240.1">worth taking.</span></span></p>
</div>
</body></html>