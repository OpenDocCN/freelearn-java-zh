- en: Chapter 9. Securing Java EE Applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will cover how to secure Java EE applications by taking
    advantage of GlassFish's built-in security features.
  prefs: []
  type: TYPE_NORMAL
- en: Java EE security relies on the **Java Authentication and Authorization Service**
    (**JAAS**) API. As we will see, securing Java EE applications requires very little
    coding for the most part. Securing an application is achieved by setting up users
    and security groups to a security realm in the application server and then configuring
    our applications to rely on a specific security realm for authentication and authorization.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the topics we will cover in this chapter include:'
  prefs: []
  type: TYPE_NORMAL
- en: Admin realms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: File realms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Certificate realms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating self-signed security certificates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JDBC realms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom realms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Security realms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Security realms are, in essence, collections of users and related security groups.
    A user can belong to one or more security groups. The groups that the user belongs
    to define what actions the system will allow the user to perform. For example,
    an application can have regular users that can only use basic application functionality,
    and it can have administrators that, in addition to being able to use basic application
    functionality, can add additional users to the system.
  prefs: []
  type: TYPE_NORMAL
- en: Security realms store user information (user name, password, and security groups).
    Therefore, applications don't need to implement this functionality and can simply
    be configured to obtain this information from a security realm. A security realm
    can be used by more than one application.
  prefs: []
  type: TYPE_NORMAL
- en: Predefined security realms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'GlassFish comes preconfigured with three predefined security realms: **admin-realm**,
    **file**, and **certificate**. The **admin-realm** is used to manage the user''s
    access to the GlassFish web console and shouldn''t be used for other applications.
    The **file** realm stores user information in a file. The **certificate** realm
    looks for a client-side certificate to authenticate the user.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the predefined realms in the GlassFish web console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Predefined security realms](img/6886EN_09_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In addition to the predefined security realms, we can add additional realms
    with very little effort. We will cover how to do this later in this chapter, but
    first let's discuss GlassFish's predefined security realms.
  prefs: []
  type: TYPE_NORMAL
- en: The admin-realm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The admin-realm has a predefined user called **admin**, which belongs to a predefined
    group called **asadmin**.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate how to add users to a realm, let''s add a new user to the admin-realm.
    This will allow an additional user to log in to the GlassFish web console. In
    order to add a user to admin-realm, log in to the GlassFish web console and expand
    the **Configurations** node on the left-hand side. Then expand the **server-config**
    node, followed by the **Security** node. Then expand the **Realms** node and click
    on **admin-realm**. The main area of the page should look like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The admin-realm](img/6886EN_09_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To add a user to the realm, click on the button to the top-left labeled **Manage
    Users**. The main area of the page should now look like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The admin-realm](img/6886EN_09_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To add a new user to the realm, simply click on the **New...** button to the
    top-left of the screen and then enter the new user information as shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The admin-realm](img/6886EN_09_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As shown in this screenshot, we added a new user named `root`, added this user
    to the `asadmin` group, and entered this user's password.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The GlassFish web console will only allow users in the **asadmin** group to
    log in. Failing to add our user to this security group will prevent him/her from
    logging in to the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now see our newly created user in the list of admin-realm users, as
    can be seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The admin-realm](img/6886EN_09_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We have successfully added a new user for the GlassFish web console. We can
    test this new account by logging in to the console with this new user's credentials.
  prefs: []
  type: TYPE_NORMAL
- en: The file realm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The second predefined realm in GlassFish is the file realm. This realm stores
    user information encrypted in a text file. Adding users to this realm is very
    similar to adding users to **admin-realm**. We can add a user by navigating to
    **Configurations** | **server-config** | **Security** | **Realm**. Under the **Realm**
    node, click on **file**, then on the **Manage Users** button, and finally on the
    **New...** button. The main area of the page should look like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The file realm](img/6886EN_09_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Since this realm is meant to be used for our applications, we can come up with
    our own groups. Groups are useful to give the same permissions to several users.
    For example, all users requiring administrative permissions can be added to an
    admin group (the name of the group is, of course, arbitrary).
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we added a user with the user ID `peter` to the groups `appuser`
    and `appadmin`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Clicking on the **OK** button should save the new user and take us to the user
    list for this realm, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The file realm](img/6886EN_09_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Clicking on the **New...** button allows us to add additional users to the
    realm. Let''s add an additional user named `joe` belonging only to the `appuser`
    group, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The file realm](img/6886EN_09_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As we have seen in this section, adding users to the file realm is very simple.
    We will now illustrate how to authenticate and authorize users via the file realm.
  prefs: []
  type: TYPE_NORMAL
- en: Basic authentication via the file realm
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In the previous section, we covered how to add users to the file realm and how
    to assign these users to groups. In this section, we will illustrate how to secure
    a web application so that only properly authenticated and authorized users can
    access it. This web application will use the file realm for user access control.
  prefs: []
  type: TYPE_NORMAL
- en: 'The application will consist of a few very simple JSF pages. All authentication
    logic is taken care of by the application server; therefore, the only place we
    need to make modifications in order to secure the application is in its deployment
    descriptors, `web.xml` and `glassfish-web.xml`. We will first discuss `web.xml`,
    which is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `<security-constraint>` element defines who can access pages matching a
    certain URL pattern. The URL pattern of the pages is defined inside the `<url-pattern>`
    element, which, as shown in the example, must be nested inside a `<web-resource-collection>`
    element. Roles allowed to access the pages are defined in the `<role-name>` element,
    which must be nested inside an `<auth-constraint>` element.
  prefs: []
  type: TYPE_NORMAL
- en: In our example, we define two sets of pages to be protected. The first set of
    pages are those whose URLs start with `/admin`. These pages can be accessed only
    by users belonging to the admin group. The second set of pages are the rest of
    the pages, defined by the URL pattern of `/*`. Only users with the role `user`
    can access these pages. It is worth noting that the second set of pages is a superset
    of the first set, that is, any page whose URL matches `/admin/*` also matches
    `/*`. In cases like these, the most specific case wins. In this particular case,
    users with the role `user` (and without the role `admin`) will not be able to
    access any page whose URL starts with `/admin`.
  prefs: []
  type: TYPE_NORMAL
- en: The next element we need to add to `web.xml` in order to protect our pages is
    the `<login-config>` element. This element must contain an `<auth-method>` element,
    which defines the authorization method for the application. Valid values for this
    element include `BASIC`, `DIGEST`, `FORM`, and `CLIENT-CERT`.
  prefs: []
  type: TYPE_NORMAL
- en: '`BASIC` indicates that basic authentication will be used. This type of authentication
    will result in a browser-generated pop up prompting the user for a username and
    password to be displayed the first time a user tries to access a protected page.
    Unless using the HTTPS protocol, when using basic authentication, the user''s
    credentials are Base64 encoded, not encrypted. It would be fairly easy for an
    attacker to decode these credentials; therefore, using basic authentication is
    not recommended.'
  prefs: []
  type: TYPE_NORMAL
- en: The `DIGEST` authentication value is similar to basic authentication, except
    that it uses an MD5 digest to encrypt the user credentials instead of sending
    them Base64 encoded.
  prefs: []
  type: TYPE_NORMAL
- en: The `FORM` authentication value uses a custom HTML or JSP page containing an
    HTML form with the username and password fields. The values in the form are then
    checked against the security realm for user authentication and authorization.
    Unless using HTTPS, user credentials are sent in clear text when using form-based
    authentication; therefore, using HTTPS is recommended since it encrypts the data.
    We will cover setting up GlassFish to use HTTPS later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The `CLIENT-CERT` authentication value uses client-side certificates to authenticate
    and authorize the user.
  prefs: []
  type: TYPE_NORMAL
- en: The `<realm-name>` element of `<login-config>` indicates what security realm
    to use to authenticate and authorize the user. In this particular example, we
    are using the file realm.
  prefs: []
  type: TYPE_NORMAL
- en: All of the `web.xml` elements we have discussed in this section can be used
    with any security realm; they are not tied to the file realm. The only thing that
    ties our application to the file realm is the value of the `<realm-name>` element.
    Something else to keep in mind is that not all authentication methods are supported
    by all realms. The file realm supports only basic and form-based authentication.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we can successfully authenticate our users, we need to link the user
    roles defined in `web.xml` with the groups defined in the realm. We accomplish
    this in the `glassfish-web.xml` deployment descriptor as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As can be seen in the preceding example, the `glassfish-web.xml` deployment
    descriptor can have one or more `<security-role-mapping>` elements. One of these
    elements is needed for each role defined in each `<auth-constraint>` tag in `web.xml`.
    The `<role-name>` subelement indicates the role to map. Its value must match the
    value of the corresponding `<role-name>` element in `web.xml`. The `<group-name>`
    subelement must match the value of a security group in the realm used to authenticate
    users in the application.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, the first `<security-role-mapping>` element maps the `admin`
    role defined in the application's `web.xml` deployment descriptor to the `appadmin`
    group we created when adding users to the file realm earlier in the chapter. The
    second `<security-role-mapping>` element maps the `user` role in `web.xml` to
    the `appuser` group in the file realm.
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned earlier, there is nothing we need to do in our code in order to
    authenticate and authorize users. All we need to do is modify the application''s
    deployment descriptors as described in this section. Since our application is
    nothing but a few simple pages, we will not show the source code for them. The
    structure of our application is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Basic authentication via the file realm](img/6886EN_09_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Based on the way we set up our application in the deployment descriptors, users
    with the role `user` will be able to access the two pages at the root of the application
    (`index.xhtml` and `random.xhtml`). Only users with the role `admin` will be able
    to access any pages under the `admin` folder, which in this particular case is
    a single page named `index.xhtml`.
  prefs: []
  type: TYPE_NORMAL
- en: 'After packaging and deploying our application and pointing the browser to the
    URL of any of its pages, we should see a pop up asking for a **User Name** and
    **Password**, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Basic authentication via the file realm](img/6886EN_09_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'After entering the correct username and password, we are directed to the page
    we were attempting to see, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Basic authentication via the file realm](img/6886EN_09_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At this point, the user can navigate to any page he/she is allowed to access
    in the application, either by following links or by typing in the URL in the browser,
    without having to reenter his/her username and password.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that we logged in as the user `joe`; this user belongs only to the `user`
    role. Therefore, he does not have access to any page that starts with `/admin`
    as the URL. If `joe` tries to access one of these pages, he will get an HTTP error
    reporting **HTTP Status 403-Forbidden**, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Basic authentication via the file realm](img/6886EN_09_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Only users belonging to the `admin` role can see pages that match the URL shown
    in the screenshot. When we were adding users to the file realm, we added a user
    named `peter` that had this role. If we log in as `peter`, we will be able to
    see the requested page. For basic authentication, the only possible way to log
    out of the application is to close the browser. Therefore, to log in as `peter`,
    we need to close and reopen the browser. Once logged in as Peter, we will see
    a window as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Basic authentication via the file realm](img/6886EN_09_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As mentioned before, one disadvantage of the basic authentication method we
    used in this example is that login information is not encrypted. One way to get
    around this is to use the HTTPS (HTTP over SSL) protocol. When using this protocol,
    all information between the browser and the server is encrypted.
  prefs: []
  type: TYPE_NORMAL
- en: 'The easiest way to use HTTPS is by modifying the application''s `web.xml` deployment
    descriptor as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, all we need to do to have the application be accessed only through
    HTTPS is to add a `<user-data-constraint>` element containing a nested `<transport-guarantee>`
    element to each set of pages we want to encrypt. Sets of pages to be protected
    are declared in the `<security-constraint>` elements in the `web.xml` deployment
    descriptor.
  prefs: []
  type: TYPE_NORMAL
- en: Now, when we access the application through the (unsecure) HTTP port (by default,
    it is 8080), the request is automatically forwarded to the (secure) HTTPS port
    (by default, 8181).
  prefs: []
  type: TYPE_NORMAL
- en: In our example, we set the value of the `<transport-guarantee>` element to `CONFIDENTIAL`.
    This has the effect of encrypting all the data between the browser and the server.
    Also, if the request is made through the unsecured HTTP port, it is automatically
    forwarded to the secured HTTPS port.
  prefs: []
  type: TYPE_NORMAL
- en: Another valid value for the `<transport-guarantee>` element is `INTEGRAL`. When
    using this value, the integrity of the data between the browser and the server
    is guaranteed. In other words, the data cannot be changed in transit. When using
    this value, requests made over HTTP are not automatically forwarded to HTTPS.
    If a user attempts to access a secure page via HTTP when this value is used, the
    browser will deny the request and return a 403 (Access Denied) error.
  prefs: []
  type: TYPE_NORMAL
- en: The third and last valid value for the `<transport-guarantee>` element is `NONE`.
    When using this value, no guarantees are made about the integrity or confidentiality
    of the data. The `NONE` value is the default value used when the `<transport-guarantee>`
    element is not present in the application's `web.xml` deployment descriptor.
  prefs: []
  type: TYPE_NORMAL
- en: 'After making the preceding modifications to the `web.xml` deployment descriptor,
    redeploying the application, and pointing the browser to any of the pages in the
    application, we should see the following warning page when accessing our application
    on Firefox:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Basic authentication via the file realm](img/6886EN_09_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'After expanding the **I Understand the Risks** node and clicking on the button
    labeled **Add Exception...**, we should see a window similar to the one shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Basic authentication via the file realm](img/6886EN_09_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'After clicking on the button labeled **Confirm Security Exception**, we are
    prompted for a username and password. After entering the appropriate credentials,
    we are allowed access to the requested page as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Basic authentication via the file realm](img/6886EN_09_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The reason we see this warning is that, in order for a server to use the HTTPS
    protocol, it must have an SSL certificate. Typically, SSL certificates are issued
    by **Certificate Authorities** (**CA**) such as Verisign or Thawte. These certificate
    authorities digitally sign the certificate. By doing this, they certify that the
    server belongs to the entity it claims it belongs to.
  prefs: []
  type: TYPE_NORMAL
- en: A digital certificate from one of these certificate authorities typically costs
    around USD 400 and expires after a year. Since the cost of these certificates
    may be prohibitive for development or testing purposes, GlassFish comes preconfigured
    with a self-signed SSL certificate. Since this certificate has not been signed
    by a certificate authority, the browser shows a warning window when we try to
    access a secured page via HTTPS.
  prefs: []
  type: TYPE_NORMAL
- en: Notice the URL in the screenshot. The protocol is set to HTTPS, and the port
    is 8181\. The URL we pointed the browser to was `http://localhost:8080/filerealmauthhttps`,
    because of the modifications we made to the application's `web.xml` deployment
    descriptor, the request was automatically redirected to this URL. Of course, users
    may directly type in the secure URL and it will work without a problem.
  prefs: []
  type: TYPE_NORMAL
- en: Any data transferred over HTTPS is encrypted, including the username and password
    entered in the pop-up window generated by the browser. Using HTTPS allows us to
    safely use basic authentication. However, basic authentication has a disadvantage,
    which is that the only way that users can log out of the application is to close
    the browser. If we need to allow users to log out of the application without closing
    the browser, we need to use form-based authentication.
  prefs: []
  type: TYPE_NORMAL
- en: Form-based authentication
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We need to make some modifications to the application''s `web.xml` deployment
    descriptor to use form-based authentication, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: When using form-based authentication, we simply use `FORM` as the value of the
    `<auth-method>` element in `web.xml`. When using this authentication method, we
    need to provide a login page and a login error page. We indicate the URLs for
    the login and login error pages as the values of the `<form-login-page>` and `<form-error-page>`
    elements, respectively. As we can see in the example, these elements must be nested
    inside the `<form-login-config>` element.
  prefs: []
  type: TYPE_NORMAL
- en: 'The markup for the login page for our application is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Please note that even though our login page is a JSF page, it uses a standard
    `<form>` tag as opposed to the JSF-specific `<h:form>` tag. The reason for this
    is that the form's action attribute value must be `j_security_check` and it is
    not possible to set this attribute in the JSF `<h:form>` tag. Similarly, the input
    fields in the form are standard HTML fields, as opposed to their JSF-specific
    counterparts.
  prefs: []
  type: TYPE_NORMAL
- en: The login page for an application using form-based authentication must contain
    a form whose method is `POST` and whose action is `j_security_check`. We don't
    need to implement the authentication code as it is supplied by the application
    server.
  prefs: []
  type: TYPE_NORMAL
- en: The form in the login page must contain a text field named `j_username`. This
    text field is meant to hold the username. Additionally, the form must contain
    a password field named `j_password`, meant for the password. Of course, the form
    must contain a submit button to submit the data to the server.
  prefs: []
  type: TYPE_NORMAL
- en: The only requirement for a login page is for it to have a form whose attributes
    match those in our example, and the `j_username` and `j_password` input fields
    as described in the preceding paragraph.
  prefs: []
  type: TYPE_NORMAL
- en: There are no special requirements for the error page. Of course, it should show
    an error message telling the user that login was unsuccessful. However, it can
    contain anything we wish. The error page for our application simply tells the
    user that there was an error logging in and links back to the login page to give
    the user a chance to log back in.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to a login page and a login error page, we added a CDI named bean
    to our application. This allows us to implement the logout functionality, something
    that wasn''t possible when we were using basic authentication. The code to implement
    the logout functionality is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The first few lines of the logout method are meant to get a reference to the
    `HttpSession` object. Once we obtain this object, all we need to do is invalidate
    the session by invoking its `invalidate()` method. In our code, we redirect the
    response to the index page. Since the session is invalid at this point, the security
    mechanism automatically directs the user to the login page.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are now ready to test form-based authentication. After building our application,
    deploying it, and pointing the browser to any of its pages, we should see our
    login page rendered in the browser as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Form-based authentication](img/6886EN_09_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If we submit invalid credentials, we are automatically forwarded to the login
    error page, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Form-based authentication](img/6886EN_09_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can click on the **Try again** link to try again. After entering the valid
    credentials, we are allowed into the application. The following screenshot shows
    the screen after a successful login:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Form-based authentication](img/6886EN_09_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As we can see, we added a **Logout** link to the page. This link directs the
    user to the `logout()` method of our CDI named bean, which, as mentioned before,
    simply invalidates the session. From the user's point of view, this link will
    simply log them out and direct them to the login screen.
  prefs: []
  type: TYPE_NORMAL
- en: The certificate realm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The certificate realm uses client-side certificates for authentication. Just
    like server-side certificates, client-side certificates are typically obtained
    from a certificate authority such as Verisign or Thawte. These certificate authorities
    verify that the certificate really belongs to who it says it belongs to.
  prefs: []
  type: TYPE_NORMAL
- en: Obtaining a certificate from a certificate authority costs money and takes some
    time. It might not be practical to obtain a certificate from one of the certificate
    authorities when we are developing and/or testing our application. Fortunately,
    we can create self-signed certificates for testing purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Creating self-signed certificates
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We can create self-signed certificates with little effort with the **keytool**
    utility included with the **Java Development Kit** (**JDK**).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We will only briefly cover some of the keytool utility features, specifically
    the features that are necessary to create and import self-signed certificates
    into GlassFish and the browser. To learn more about the keytool utility, refer
    to [http://docs.oracle.com/javase/7/docs/technotes/tools/solaris/keytool.html](http://docs.oracle.com/javase/7/docs/technotes/tools/solaris/keytool.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can generate a self-signed certificate by typing in the following command
    in the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This command assumes that the keytool utility is in the system path. This tool
    can be found in the `bin` directory under the directory where JDK is installed.
  prefs: []
  type: TYPE_NORMAL
- en: Substitute the values for the `-storepass` and `-keypass` parameters with your
    own password. Both of these passwords must be the same in order to successfully
    use the certificate to authenticate the client. You may choose any value for the
    `-alias` parameter. You may also choose any value for the `-keystore` parameter.
    However, the value must end in `.p12`, since this command generates a file that
    needs to be imported into the web browser, and it won't be recognized unless it
    has the `.p12` extension.
  prefs: []
  type: TYPE_NORMAL
- en: 'After entering the above command from the command line, keytool will prompt
    for some information as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: After entering the data for each prompt, keytool will generate the certificate.
    It will be stored in the current directory, and the name of the file will be the
    value we used for the `-keystore` parameter (`client_keystore.p12` in the example).
  prefs: []
  type: TYPE_NORMAL
- en: 'To be able to use this certificate to authenticate ourselves, we need to import
    it into the browser. The procedure, although similar, varies from browser to browser.
    In Firefox, this can be accomplished by going to the **Preferences** menu, clicking
    on the **Advanced** icon at the top of the pop-up window that appears, and then
    clicking on the **Certificates** tab as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating self-signed certificates](img/6886EN_09_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We then need to navigate to **View Certificates** | **Your Certificates** |
    **Import** on the window that appears. Then navigate and select our certificate
    from the directory in which it was created. At this point, Firefox will ask us
    for the password used to encrypt the certificate; in our example, we used `wonttellyou`
    as the password. After entering the password, we should see a pop-up window confirming
    that our certificate was successfully imported. We should then see it in the list
    of certificates, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating self-signed certificates](img/6886EN_09_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We have now added our certificate to Firefox so that it can be used to authenticate
    us. If you are using another browser, the procedure will be similar. Consult your
    browser's documentation for details.
  prefs: []
  type: TYPE_NORMAL
- en: 'The certificate we created in the previous step needs to be exported into a
    format that GlassFish can understand. We can accomplish this by running the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The value for the `-alias`, `-keystore`, and `-storepass` parameters must match
    the values used in the previous command. You may choose any value for the `-file`
    parameter, but it is recommended for the value to end in the `.cer` extension.
  prefs: []
  type: TYPE_NORMAL
- en: Since our certificate was not issued by a certificate authority, GlassFish by
    default will not recognize it as a valid certificate. GlassFish knows what certificates
    to trust based on the certificate authority that created them. This is implemented
    through the storing of certificates for these various authorities in a keystore
    named `cacerts.jks`. This keystore can be found at `[glassfish installation directory]/glassfish/domains/domain1/config/cacerts.jks`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order for GlassFish to accept our certificate, we need to import it into
    the `cacerts` keystore. This can be accomplished by issuing the following command
    from the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, keytool will display the following certificate information in
    the command line and ask us if we want to trust it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Once we add the certificate to the `cacerts.jks` keystore, we need to restart
    the domain for the change to take effect.
  prefs: []
  type: TYPE_NORMAL
- en: What we are effectively doing here is adding ourselves as a certificate authority
    that GlassFish will trust. This, of course, should not be done in a production
    system.
  prefs: []
  type: TYPE_NORMAL
- en: The value for the `-file` parameter must match the value we used for this same
    parameter when we exported the certificate.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Note that `changeit` is the default password for the `-keypass` and `-storepass`
    parameters for the `cacerts.jks` keystore. This value can be changed by issuing
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This command will prompt for the existing as well as the new master password.
    The `–savemasterpassword=true` parameter is optional; it saves the master password
    into a file called `master-password` in the root directory of the domain. If we
    don't use this parameter when changing the master password, then we will need
    to enter the master password every time we want to start the domain.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have created a self-signed certificate, imported it into our browser,
    and established ourselves as a certificate authority that GlassFish will trust,
    we are ready to develop an application that will use client-side certificates
    for authentication.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring applications to use the certificate realm
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Since we are taking advantage of Java EE security features, we don''t need
    to modify any code in order to use the security realm. All we need to do is modify
    the application''s configuration on its deployment descriptors, `web.xml` and
    `glassfish-web.xml`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The main difference between this `web.xml` deployment descriptor and the one
    we saw in the previous section is the contents of the `<login-config>` element.
    In this case, we declared `CLIENT-CERT` as the authorization method and `certificate`
    as the realm to use to authenticate. This will have the effect of GlassFish asking
    the browser for a client certificate before allowing a user into the application.
  prefs: []
  type: TYPE_NORMAL
- en: When using client certificate authentication, the request must always be made
    via HTTPS. Therefore, it is a good idea to add the `<transport-guarantee>` element
    with a value of `CONFIDENTIAL` to the `web.xml` deployment descriptor. Recall
    from the previous section that this has the effect of forwarding any requests
    through the HTTP port to the HTTPS port. If we don't add this value to the `web.xml`
    deployment descriptor, any requests through the HTTP port will fail, since client
    certificate authentication cannot be done through the HTTP protocol.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that we declared that only users with the role `user` can access any
    page in the system. We did this by adding the role `user` to the `<role-name>`
    element nested inside the `<auth-constraint>` element of the `<security-constraint>`
    element in the `web.xml` deployment descriptor. In order to allow access to authorized
    users, we need to add them to this role. This is done in the `glassfish-web.xml`
    deployment descriptor as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This assignment is done by mapping the principal user to a role in a `<security-role-mapping>`
    element in the `glassfish-web.xml` deployment descriptor; its `<role-name>` subelement
    must contain the role name, and the `<principal-name>` subelement must contain
    the username. This username is taken from the certificate.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are not sure of the name to use, it can be obtained from the certificate
    with the keytool utility as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The value to use as `<principal-name>` is the line after `Owner:`. Please note
    that the value of `<principal-name>` must be in the same line as its open and
    closing elements `(<principal-name>` and `</principal-name>`). If there are newline
    or carriage return characters before or after the value, they are interpreted
    as being part of the value and validation will fail.
  prefs: []
  type: TYPE_NORMAL
- en: Since our application has a single user and a single role, we are ready to deploy
    it. If we had more users, we would have to add additional `<security-role-mapping>`
    elements to our `glassfish-web.xml` deployment descriptor, at least one per user.
    If we had users that belong to more than one role, then we would add a `<security-role-mapping>`
    element for each role the user belongs to, using the `<principal-name>` value
    corresponding to the user's certificate for each one of them.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are now ready to test our application. After we deploy it and point the
    browser to any page in the application, we should see a screen like the following
    (assuming the browser hasn''t been configured to provide a default certificate
    any time a server requests one):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Configuring applications to use the certificate realm](img/6886EN_09_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'After clicking on the **OK** button, we are allowed to access the application,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Configuring applications to use the certificate realm](img/6886EN_09_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Before allowing access to the application, GlassFish checks the certificate
    authority that issued the certificate (since we self-signed the certificate, the
    owner of the certificate and the certificate authority are the same), checking
    against the list of trusted certificate authorities. Since we added ourselves
    as a trusted authority by importing our self-signed certificate into the `cacerts.jks`
    keystore, GlassFish recognizes the certificate authority as a valid one. It then
    gets the principal name from the certificate and compares it against entries in
    the application's `glassfish-web.xml` file. Since we added ourselves to this deployment
    descriptor and gave ourselves a valid role, we are allowed into the application.
  prefs: []
  type: TYPE_NORMAL
- en: Defining additional realms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In addition to the three preconfigured security realms we discussed in the previous
    section, we can create additional realms for application authentication. We can
    create realms that behave exactly like the file realm or admin-realm. We can also
    create realms that behave like the certificate realm. Additionally, we can create
    realms that use other methods of authentication. We can authenticate users against
    an LDAP database and against a relational database and, when GlassFish is installed
    on a Solaris server, use Solaris authentication within GlassFish. Also, if none
    of the predefined authentication mechanisms fit our needs, we can implement our
    own.
  prefs: []
  type: TYPE_NORMAL
- en: Defining additional file realms
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the administration console, expand the **Configurations** node, followed
    by the **server-config** node, and then the **Security** node. Click on the **Realms**
    node and then on the **New...** button on the resulting page in the main area
    of the web console.
  prefs: []
  type: TYPE_NORMAL
- en: 'We should now see a screen like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Defining additional file realms](img/6886EN_09_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: All we need to do to create an additional realm is enter a unique name for it
    in the **Name** field, pick `com.sun.enterprise.security.auth.realm.file.FileRealm`
    for the **Class Name** field, and enter a value for the **JAAS Context** and **Key
    File** fields; the value for the **Key File** field must be the absolute path
    to a file where user information will be stored and, for the file realm, the value
    for the **JAAS Context** field must always be `fileRealm`.
  prefs: []
  type: TYPE_NORMAL
- en: After entering all of the required information, we can click on the **OK** button
    and our new realm will be created. We can then use it just like the predefined
    file realm. Applications wanting to authenticate against this new realm must use
    its name as the value of the `<realm-name>` element in the application's `web.xml`
    deployment descriptor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, a custom file realm can be added from the command line via the
    `asadmin` utility by executing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `create-auth-realm` argument tells `asadmin` that we want to create a new
    security realm. The value of the `--classname` parameter corresponds to the security
    realm class name. Notice that it matches the value we selected above in the web
    console. The `--property` parameter allows us to pass properties and their values;
    the value of this parameter must be a colon (`:`) separated list of properties
    and their values. The last argument of this command is the name we wish to give
    our security realm.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although it is easier to set up security realms via the web console, doing it
    through the `asadmin` command-line utility has the advantage that it is easily
    scriptable, allowing us to save this command in a script and easily configure
    several GlassFish instances.
  prefs: []
  type: TYPE_NORMAL
- en: Defining additional certificate realms
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To define an additional certificate realm, we simply need to enter its name
    in the **Name** field and pick `com.sun.enterprise.security.auth.realm.certificate.CertificateRealm`
    as the value of the `Class Name` field and then click on **OK** to create our
    new realm, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Defining additional certificate realms](img/6886EN_09_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Applications wanting to use this new realm for authentication must use its name
    as the value of the `<realm-name>` element in the `web.xml` deployment descriptor
    and specify `CLIENT-CERT` as the value of its `<auth-method>` element. Of course,
    client certificates must be present and configured as explained in the *Configuring
    applications to use the certificate realm* section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, a custom certificate realm can be created on the command line
    via the `asadmin` utility by executing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we don't need to pass any properties as we had to when we created
    the custom file realm. Therefore, all we need to do is pass the appropriate value
    to the `--classname` parameter and specify the new security realm name.
  prefs: []
  type: TYPE_NORMAL
- en: Defining an LDAP realm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can easily set up a realm to authenticate against an **LDAP** (**Lightweight
    Directory Access Protocol**) database. In order to do this, we need to, in addition
    to the obvious step of entering a name for the realm, select `com.sun.enterprise.security.auth.realm.ldap.LDAPRealm`
    as the **Class Name** value for a new realm. We then need to enter a URL for the
    directory server in the **Directory** field and the base distinguished name to
    be used to search user data as the value of the **Base DN** field, as shown in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Defining an LDAP realm](img/6886EN_09_26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At the time of this writing, GlassFish had a bug that prevents LDAP realms from
    being added successfully from the web admin console. In this section, we explain
    what should happen, not what actually happens. Hopefully, by the time you read
    this, the issue will be fixed.
  prefs: []
  type: TYPE_NORMAL
- en: Adding an LDAP realm from the command line, as explained later in this section,
    works properly though.
  prefs: []
  type: TYPE_NORMAL
- en: After creating an LDAP realm, applications can use it to authenticate against
    the LDAP database. The name of the realm needs to be used as the value of the
    `<realm-name>` element in the application's `web.xml` deployment descriptor. The
    value of the `<auth-method>` element must be either `BASIC` or `FORM`.
  prefs: []
  type: TYPE_NORMAL
- en: Users and roles in the LDAP database can be mapped to groups in the application's
    `glassfish-web.xml` deployment descriptor using the `<principal-name>`, `<role-name>`,
    and `<group-name>` elements as discussed earlier in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create an LDAP realm from the command line, we need to use the following
    syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Note that, in this case, the value of the `--property` parameter is between
    quotes. This is necessary because we need to escape some of the characters in
    its value, such as all the colons and equal signs. To escape these special characters,
    we simply prefix them with a backslash (`\`).
  prefs: []
  type: TYPE_NORMAL
- en: Defining a Solaris realm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When GlassFish is installed on a Solaris server, it can take advantage of the
    operating system authentication mechanism via a Solaris Realm. There are no special
    properties for this type of realm; all we need to do to create one is pick a name
    for it and select `com.sun.enterprise.security.auth.realm.solaris.SolarisRealm`
    as the value of the **Class Name** field and enter `solarisRealm` as the value
    of the **JAAS Context** field, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Defining a Solaris realm](img/6886EN_09_27.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The **JAAS Context** field must be set to `solarisRealm`. After adding the realm,
    applications can authenticate against it using basic or form-based authentication.
    Operating system groups and users can be mapped to application roles defined in
    the application's `web.xml` deployment descriptor via the `<principal-name>`,
    `<role-name>`, and `<group-name>` elements in its `glassfish-web.xml` deployment
    descriptor.
  prefs: []
  type: TYPE_NORMAL
- en: 'A Solaris realm can be created from the command line by executing the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Defining a JDBC realm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another type of realm we can create is a JDBC realm. This type of realm uses
    user information stored in database tables for user authentication.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to illustrate how to authenticate against a JDBC realm, we need to
    create a database to hold user information. The following entity-relationship
    diagram shows an example database we could use to authenticate against a JDBC
    realm:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Defining a JDBC realm](img/6886EN_09_28.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Our database consists of three tables. A `USERS` table holding user information
    and a `GROUPS` table holding group information are two of them. Since there is
    a many-to-many relationship between `USERS` and `GROUPS`, we need to add a join
    table to preserve data normalization. The name of this third table is `USER_GROUPS`.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the `PASSWORD` column of the `USERS` table is of type `CHAR(32)`.
    The reason we chose this type instead of `VARCHAR` is that we will be hashing
    passwords using the MD5 hashing algorithm, and these hashes are always 32 characters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Passwords can be easily encrypted in the expected format by using the `java.security.MessageDigest`
    class included with the JDK. The following example code will accept a clear-text
    password and create an MD5 hash out of it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The main functionality of the preceding class is defined in its `encryptPassword()`
    method. It basically accepts a clear-text string and digests it using the MD5
    algorithm using the `digest()` method of an instance of `java.security.MessageDigest`.
    It then encodes the digest as a series of hexadecimal numbers. This encoding is
    necessary because GlassFish by default expects MD5-digested passwords to be hex
    encoded.
  prefs: []
  type: TYPE_NORMAL
- en: When using JDBC realms, application users and groups are not added to the realm
    via the GlassFish console. Instead, they are added by inserting data into the
    appropriate tables.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have the database that will hold user credentials in place, we are ready
    to create a new JDBC realm.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create a JDBC realm by entering its name in the **Name** field of the
    **New Realm** form in the GlassFish web console and then selecting `com.sun.enterprise.security.auth.realm.jdbc.JDBCRealm`
    as the value of the **Class Name** field, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Defining a JDBC realm](img/6886EN_09_29.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'There are a number of other properties we need to set for our new JDBC realm,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Defining a JDBC realm](img/6886EN_09_30.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The **JAAS Context** field must be set to `jdbcRealm` for JDBC realms. The value
    of the **JNDI** property must be the JNDI name of the data source corresponding
    to the database that contains the realm's user and group data. The value of the
    **User Table** property must be the name of the table that contains username and
    password information.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Notice that, in the preceding screenshot, we used `V_USER_ROLE` as the value
    for the **User Table** property. `V_USER_ROLE` is a database view that contains
    both user and group information. We didn't use the `USERS` table directly because
    GlassFish assumes that both the user table and the group table contain a column
    containing the username. Doing this results in having duplicate data. To avoid
    this situation, we created a view that we could use as the value of both the **User
    Table** and **Group Table** (to be discussed shortly) properties.
  prefs: []
  type: TYPE_NORMAL
- en: The **User Name Column** property must contain the column in the **User Table**
    property that contains the usernames. The **Password Column** property value must
    be the name of the column in the **User Table** property that contains the user's
    password. The value of the **Group Table** property must be the name of the table
    containing user groups. The **Group Name Column** property must contain the name
    of the column in the **Group Table** property containing user group names.
  prefs: []
  type: TYPE_NORMAL
- en: All other properties are optional and, in most cases, left blank. Of special
    interest is the **Digest Algorithm** property. This property allows us to specify
    the message digest algorithm to use to hash the user's password. Valid values
    for this property include all algorithms supported by the JDK. These algorithms
    are MD2, MD5, SHA-1, SHA-256, SHA-384, and SHA-512\. Additionally, if we wish
    to store user passwords in clear text, we can do so by using the value `none`
    for this property.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: MD2, MD5, and SHA-1 are not very secure, and in most cases should not be used.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have defined our JDBC realm, we need to configure our application via
    its `web.xml` and `glassfish-web.xml` deployment descriptors. Configuring an application
    to rely on a JDBC realm for authorization and authentication is done just like
    when using any other type of realm.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to declaring that we will rely on the JDBC realm for authentication
    and authorization, just like with other types of realms, we need to map the roles
    defined in the `web.xml` deployment descriptor to security group names. This is
    accomplished in the `glassfish-web.xml` deployment descriptor.
  prefs: []
  type: TYPE_NORMAL
- en: 'A JDBC realm can be created from the command line by executing the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Defining custom realms
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Although the predefined realm types should cover the vast majority of cases,
    we can create custom realm types if the provided ones don''t meet our needs. Doing
    so involves coding custom `Realm` and `LoginModule` classes. Let''s first discuss
    the custom `Realm` class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Our custom `Realm` class must extend `com.sun.enterprise.security.auth.realm.IASRealm`.
    This class can be found inside the `security.jar` file, and therefore this JAR
    file must be added to the CLASSPATH before our `Realm` class can be successfully
    compiled.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `security.jar` file can be found under `[glassfish installation directory]/glassfish/modules`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When using Maven or Ivy dependency management, this JAR file can be found in
    the following repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://download.java.net/maven/glassfish](http://download.java.net/maven/glassfish)'
  prefs: []
  type: TYPE_NORMAL
- en: The group ID is `org.glassfish.security` and the artifact ID is `security`.
  prefs: []
  type: TYPE_NORMAL
- en: Our class must override a method called `getGroupNames()`. This method takes
    a single string as a parameter and returns an `Enumeration` parameter. The `String`
    parameter is for the username of the user that is attempting to log in to the
    realm. The `Enumeration` parameter must contain a collection of strings indicating
    what groups the user belongs to. In our simple example, we simply hardcoded the
    groups. In a real application, these groups would be obtained from some kind of
    persistent storage (database, file, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: The next method our `Realm` class must override is the `getAuthType()` method.
    This method must return a `String` containing a description of the type of authentication
    used by this realm.
  prefs: []
  type: TYPE_NORMAL
- en: The `getGroupNames()` and `getAuthType()` methods are declared as abstract in
    the `IASRealm` (parent) class. Although the `getJAASContext()` method is not abstract,
    we should nevertheless override it, since the value it returns is used to determine
    the type of authentication to use from the application server's `login.conf` file.
    The return value of this method is used to map the realm to the corresponding
    login module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, our `Realm` class must contain a method to authenticate the user.
    We are free to call it anything we want. Additionally, we can use as many parameters
    of any type as we wish. Our simple example has the values for a single username
    and password hardcoded. Again, a real application would obtain valid credentials
    from some kind of persistent storage. This method is meant to be called from the
    corresponding login module class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Our login module class must extend `com.sun.appserv.security.AppservPasswordLoginModule`.
    This class is also inside the `security.jar` file. Our login module class only
    needs to override a single method, namely `authenticateUser()`. This method takes
    no parameters and must throw a `LoginException` if user authentication is unsuccessful.
    The `_currentRealm` variable is defined in the parent class and is of type `com.sun.enterprise.security.auth.realm`.
    The `Realm` class is the parent of all `Realm` classes. This variable is initialized
    before the `authenticateUser()` method is executed. The `LoginModule` class must
    verify that this class is of the expected type (`SimpleRealm` in our example).
    If it is not, a `LoginException` must be thrown.
  prefs: []
  type: TYPE_NORMAL
- en: Two other variables that are defined in the parent class and initialized before
    the `authenticateUser()` method is executed are `_username` and `_password`. These
    variables contain the credentials the user entered in the login form (for form-based
    authentication) or pop-up window (for basic authentication). Our example simply
    passes these values to the `Realm` class so that it can verify the user credentials.
  prefs: []
  type: TYPE_NORMAL
- en: The `authenticateUser()` method must call the parent class's `commitUserAuthentication()`
    method upon successful authentication. This method takes an array of string objects
    containing the group the user belongs to. Our example simply invokes the `getGroupNames()`
    method defined in the `Realm` class and adds the elements of the `Enumeration`
    parameter it returns to an array; it then passes that array to `commitUserAuthentication()`.
  prefs: []
  type: TYPE_NORMAL
- en: GlassFish is unaware of the existence of our custom realm and login module classes.
    We need to add these classes to GlassFish's CLASSPATH. The easiest way to do this
    is to copy the JAR file containing our custom realm and login module at `[glassfish
    installation directory]/glassfish/domains/domain1/lib`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last step we need to follow before we can authenticate applications against
    our custom realm is to add our new custom realm to the domain''s `login.conf`
    file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The value before the opening brace must match the return value of the `getJAASContext()`
    method defined in the `Realm` class. It is in this file that the `Realm` and `LoginModule`
    classes are linked to each other. The GlassFish domain needs to be restarted for
    this change to take effect.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are now ready to use our custom realm to authenticate users in our applications.
    We need to add a new realm of the type we created via GlassFish''s admin console
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Defining custom realms](img/6886EN_09_31.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To create our realm, as usual, we need to give it a name. Instead of selecting
    a class name from the dropdown, we need to type it into the text field. Our custom
    realm didn''t have any properties; therefore, we don''t have to add any in this
    example. If it did, they would be added by clicking on the **Add Property** button
    and entering the property name and corresponding value. Our realm would then get
    the properties by overriding the `init()` method from its parent class. This method
    has the following signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The instance of `java.util.Properties` it takes as a parameter would be prepopulated
    with the properties entered in the page shown in the screenshot (our custom realm
    doesn't have any properties, but for those that do, properties are entered the
    page shown in the screenshot).
  prefs: []
  type: TYPE_NORMAL
- en: Once we have added the pertinent information for our new custom realm, we can
    use it just like we use any of the predefined realms. Applications need to specify
    its name as the value of the `<realm-name>` element of the application's `web.xml`
    deployment descriptor. Nothing extraordinary needs to be done at the application
    level.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like with standard realms, custom realms can be added via the `asadmin`
    command-line utility, for example, for our custom realm, we would execute the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered how to use GlassFish's default realms to authenticate
    our web applications. We covered the file realm, which stores user information
    in a flat file, and the certificate realm, which requires client-side certificates
    for user authentication.
  prefs: []
  type: TYPE_NORMAL
- en: We then covered how to create additional realms that behave just like the default
    realms by using the realm classes included with GlassFish.
  prefs: []
  type: TYPE_NORMAL
- en: We also covered how to use additional `Realm` classes included in GlassFish
    to create realms that authenticate against an LDAP database, against a relational
    database, and how to create realms that integrate with a Solaris server's authentication
    mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we covered how to create custom `Realm` classes for cases where the
    included ones don't fit our needs.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will cover SOAP web services with JAX-WS.
  prefs: []
  type: TYPE_NORMAL
