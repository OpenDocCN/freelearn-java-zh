- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Conditional Statements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 3*](B19793_03.xhtml#_idTextAnchor067), we learned about Java operators.
    We discussed two important properties of operators, namely, precedence and associativity.
    Precedence helps group shared operands. When precedence levels match, associativity
    is then used for grouping.
  prefs: []
  type: TYPE_NORMAL
- en: We discussed the unary operators – prefix and postfix increment/decrement, cast,
    and logical NOT. We also covered the binary operators – arithmetic, relational,
    logical, bitwise, and compound assignment. We learned about the behavior of the
    `+` symbol when one (or both) operands is a string. We discussed the logical AND
    (`&&`) and logical OR (`||`) and their short-circuiting property. Finally, the
    ternary operator, with its three operands, was covered.
  prefs: []
  type: TYPE_NORMAL
- en: We also learned about Java casting. This can be done implicitly, known as **implicit
    promotion** or **widening**. The other alternative is explicit casting, known
    as **narrowing**. When narrowing, we must cast to the target type in order to
    remove the compiler error. Lastly, we discussed compile-time constants, which,
    because their values never change, enable the compiler to apply different rules.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know about operators, let us do something interesting with them.
    By the end of this chapter, you will be able to use Java’s operators to create
    conditional statements. Conditional statements enable us to make decisions. In
    addition, you will understand a fundamental concept in Java, namely, scope.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding scope
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring `if` statements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mastering `switch` statements and expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code for this chapter can be found on GitHub at [https://github.com/PacktPublishing/Learn-Java-with-Projects/tree/main/ch4](https://github.com/PacktPublishing/Learn-Java-with-Projects/tree/main/ch4).
  prefs: []
  type: TYPE_NORMAL
- en: Understanding scope
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In programming, scope defines where a variable is/is not usable within a program.
    This is often referred to as the visibility of the variable. In other words, where
    in the code is the variable “visible”. Java uses **block scope**. In order to
    explain Java’s scope, we must first understand what a block is.
  prefs: []
  type: TYPE_NORMAL
- en: What is a block?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Curly braces delimit a block of code. In other words, a block starts with the
    opening curly brace, `{`, and ends with the closing curly brace, `}`. Note that
    the braces face each other, as in `{ }`. A variable is visible and available for
    use, from where it is declared in the block, to the closing `}` of that block.
    *Figure 4**.1* presents a code example to help explain:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1 – Block scope in Java](img/B19793_04_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.1 – Block scope in Java
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding figure, we declare an `int` variable, `x`, on line 5 and initialize
    it to `1`. The current block of code is the group of Java statements surrounded
    by `{ }`. Therefore, the `x` variable’s block of code starts on line 4, where
    the opening curly brace is, and ends on line 15, where the closing curly brace
    is. Thus, the scope of `x` is from line 5, where it is declared, to line 15 (the
    closing curly brace of the current scope). When we refer to `x` on line 6, there
    is no issue, as `x` is in scope.
  prefs: []
  type: TYPE_NORMAL
- en: On line 8, we start a new block/scope with `{`. Though somewhat unusual, as
    there is no code preceding `{` on line 8, lines 8 to 12 define a valid code block.
    Note that variables from the outer scope are visible within this inner (nested)
    scope. This is shown on line 11 where, in the inner scope, we refer to a variable
    declared in the outer scope, namely `x`, without any issue.
  prefs: []
  type: TYPE_NORMAL
- en: The inverse is not true, however; a variable defined in an inner scope is not
    visible in the outer scope. The `y` variable is in scope from where it is declared
    (line 9 of the inner scope) to line 12 (the closing curly brace of that scope).
    Thus, we get a compiler error on line 14 where, in the outer scope, we refer to
    the `y` variable.
  prefs: []
  type: TYPE_NORMAL
- en: Indentation
  prefs: []
  type: TYPE_NORMAL
- en: Indentation really helps with the identification of code blocks and, consequently,
    scopes. The style we use is to start the code block at the end of the line. For
    example, in *Figure 4**.1*, note the opening curly brace `{` on line 3\. The closing
    curly brace `}` for that code block (and thus the scope) is on line 16\. From
    an indentation point of view, the closing curly brace `}` is directly under the
    `public` keyword from line 3\. More specifically, the closing curly brace is directly
    under the ‘p’ in `public`. While not necessary for compilation, it does make your
    code easier to read and maintain – the scope starts on line 3 and to find where
    the scope ends, one just scans down the program to find the matching curly brace
    `}` which lines up under `public` (from line 3).
  prefs: []
  type: TYPE_NORMAL
- en: Line 4 also defines a block and thus a scope. Line 15 contains the matching
    curly brace `}` for that scope – note that the closing curly brace is lined up
    under the keyword `public` (from line 4). Thankfully, the editors are a great
    help in keeping your code properly indented.
  prefs: []
  type: TYPE_NORMAL
- en: In summary, blocks are defined with `{ }`. As Java uses block scope, the code
    blocks define the scope of where a variable can be used. Variables are visible
    in nested scopes, but not vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand scope in Java, let us examine conditional logic in Java.
    We will start with `if` statements.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring if statements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As their name suggests, conditional statements are based on the evaluation
    of a condition. The result of this condition is either `true` or `false` – in
    other words, a boolean. *Figure 4**.2* introduces the syntax of the overall `if`
    statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.2 – The if statement syntax](img/B19793_04_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.2 – The if statement syntax
  prefs: []
  type: TYPE_NORMAL
- en: The square brackets `[]` in the preceding figure denote something as optional.
    For example, both the `else if` statements and the `else` statement are optional.
    The `if` statement itself is mandatory. The three ellipses, `...`, indicate that
    you can have as many `else if` statements as you like (or none at all).
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the overall syntax, let us break it down into smaller pieces.
  prefs: []
  type: TYPE_NORMAL
- en: The if statement itself
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As stated earlier, an `if` statement evaluates a `boolean` expression. This
    `boolean` expression is enclosed in parentheses. Curly braces that delimit a block
    of code are optional if there is only one statement after the `if` clause. However,
    it is considered good practice to always explicitly declare a block of code. *Figure
    4**.3* demonstrates both styles:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.3 – Simple if statements](img/B19793_04_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.3 – Simple if statements
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let us explain the code. Note the indentation, which is automatically
    facilitated by the code editors. This makes it easier to see the statements that
    are governed by the various `if` statements. Both lines 9 and 11 demonstrate simple
    `if` statements that control just one statement. Line 9 controls line 10\. This
    means that if line 9 is true, line 10 is executed. If line 9 is false then line
    10 is skipped. Similarly, if line 11 is true: line 12 is executed; if line 11
    is false, line 12 is skipped.'
  prefs: []
  type: TYPE_NORMAL
- en: However, if you wish to execute two or more statements when an `if` statement
    is true, a code block is required. This is demonstrated by lines 13 to 16\. If
    the boolean expression on line 13 evaluates to true, then both of the statements
    on lines 14 and 15 will be executed. This is because they are in a code block.
  prefs: []
  type: TYPE_NORMAL
- en: As regards the running program, with `x` initialized to `5` and `y` to `4`,
    when line 9 executes, it is true (as `5 > 4`). Therefore, line 10 executes and
    therefore the output from *Figure 4**.3* is `5 > 4`. Lines 11 and 13 are both
    executed but as they both evaluate to false, nothing else is output to the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'What if, on line 8, we initialized the variables as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`int` `x=4, y=5;`'
  prefs: []
  type: TYPE_NORMAL
- en: Now, `if(x > y)` is false and line 10 is not executed; `if(x < y)` is true and
    line 12 outputs `4 < 5` to the screen; `if(x == y)` is also false, so lines 14
    and 15 are not executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, let us make the variables equal by changing line 8 as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`int` `x=4, y=4;`'
  prefs: []
  type: TYPE_NORMAL
- en: Now, `if(x > y)` is false so line 10 is not executed; `if(x < y)` is also false
    so line 12 is not executed; however, `if(x == y)` is true, so line 14 builds up
    the string `s` to be “4 == 4” and line 15 outputs it.
  prefs: []
  type: TYPE_NORMAL
- en: Note the indentation, which is automatically facilitated by the code editors.
    This makes it easier to see the statements that are governed by the various `if`
    statements.
  prefs: []
  type: TYPE_NORMAL
- en: else if statements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In *Figure 4**.3*, there is no code to cater to the situations where an `if`
    expression evaluates to false. This is where the `else if` statement comes in.
    *Figure 4**.4* shows an `else if` in code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.4 – else if statements](img/B19793_04_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.4 – else if statements
  prefs: []
  type: TYPE_NORMAL
- en: As `x` is 4 and `y` is 5 (line 19), the `if` expression on line 20 evaluates
    to false and thus control jumps to line 22 where the first `else` `if` is evaluated.
    As this evaluates to true, line 23 is executed. *Now, no other branch will be
    evaluated*. In other words, the next line of code executed after line 23 is line
    27\. Note that, as per good coding practice, each branch is coded as a block,
    even though there is only one statement in each block.
  prefs: []
  type: TYPE_NORMAL
- en: Had `x` been initialized to `5`, then lines 20 and 22 would both have evaluated
    to false. Line 24 would be true, and thus, line 25 would be executed.
  prefs: []
  type: TYPE_NORMAL
- en: For situations where the `if` and `else if` statements do not match, we can
    use the `else` statement. Let us discuss that now.
  prefs: []
  type: TYPE_NORMAL
- en: else statements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The code in *Figure 4**.4* evaluates all possible scenarios when comparing `x`
    and `y`. Either `x` is greater than, less than, or equal to `y`. This logic lends
    itself nicely to introducing the `else` statement. The `else` statement is a *catch-all*.
    As per `[]` in *Figure 4**.2*, the `else` clause is optional. If present, it must
    be coded at the end after any `if` and/or `else if` clauses. *Figure 4**.5* is
    *Figure 4**.4* refactored using an `else` clause, except that the values of `x`
    and `y` in *Figure 4**.5* are now the same.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.5 – else statement](img/B19793_04_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.5 – else statement
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 4**.5*, as both `x` and `y` are `4`, lines 31 and 33 evaluate to
    `false`. However, there is no condition on line 35 as it is simply an `else` statement
    (as opposed to `else if`). This means that the code block beginning on line 35
    is executed automatically and line 36 is executed.
  prefs: []
  type: TYPE_NORMAL
- en: With regard to `if else` statements, it is important to understand a subtle
    problem that can arise known as the “dangling `else`” problem.
  prefs: []
  type: TYPE_NORMAL
- en: Dangling else
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Consider the following unindented code, which uses no code blocks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This code has two `if` statements but only one `else` statement. Which `if`
    statement does `else` match with? The rule is: when an `else` statement is looking
    to match with `if`, it will match with the nearest *unmatched* `if` as it progresses
    back up through the code.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Following this rule, the `else` statement matches with the second `if` (line
    3) as that `if` statement has not yet been matched. This means that the `if` statement
    on line 2 remains unmatched. The code, when written using proper indentation,
    is much clearer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This is confirmed by the output. If `flag` is true, the output is `"True True"`;
    if `flag` is false, however, nothing is output to the screen. Interestingly, there
    is no way line 6 can now be reached (as `boolean` variables have only two values:
    `true` and `false`).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using code blocks makes the code even easier to understand, as can be seen
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This is why using code blocks, even for one statement, is very helpful. Throughout
    the book, we will use proper indentation and code blocks to aid clarity and ease
    of understanding.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let us look at a more involved example. This example (and others to follow)
    use the pre-defined `Scanner` class from the Java **Application Programming Interface**
    (**API**). The API is a suite of pre-defined types (for example classes) that
    are available for our use. We will cover these topics as we progress through the
    book but suffice to say that the API is extremely useful as it provides pre-defined
    and well-tested code for our use.
  prefs: []
  type: TYPE_NORMAL
- en: The `Scanner` class resides in the `java.util` package. Therefore, we need to
    briefly discuss both packages and the `Scanner` class.
  prefs: []
  type: TYPE_NORMAL
- en: Packages
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A package is a group of related types, such as classes, that we can use. Conveniently,
    many are already available for us to use in the API.
  prefs: []
  type: TYPE_NORMAL
- en: 'To gain access to these types, we need to “import” them into our code. For
    this purpose, Java provides the `import` keyword. Any `import` statements go at
    the top of your file. We can import a whole package using the `*` wildcard; for
    example: `import java.util.*;`. We can also import a particular type explicitly
    by naming it in the `import` statement; for example: `import java.util.Scanner;`.'
  prefs: []
  type: TYPE_NORMAL
- en: When you precede the type with its package name, such as `java.util.Scanner`,
    this is known as the “fully qualified name”. We could omit the `import` statement
    and simply refer each time to `Scanner` using its fully qualified name; in other
    words, everywhere `Scanner` is mentioned, replace it with `java.util.Scanner`.
    Generally speaking, however, importing the type and using its non-qualified name
    is preferred.
  prefs: []
  type: TYPE_NORMAL
- en: There is one package that is automatically available (imported) for us and that
    is the `java.lang` package. For example, the `String` class resides in `java.lang`
    and that is why we never have to import anything to get access to the `String`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: Scanner class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is helpful to know that while `Scanner` is a versatile class, for our purposes,
    we will simply use `Scanner` to enable us to retrieve keyboard input from the
    user. With this in mind, note that `System.in` used in the examples refers to
    the standard input stream which is already open and ready to supply input data.
    Typically, this corresponds to the keyboard. `System.in` is therefore perfect
    for getting input data from the user via the keyboard. The `Scanner` class provides
    various methods for parsing/interpreting the keyboard input. For example, when
    the user types in a number at the keyboard, the method `nextInt()` provides that
    number to us as an `int` primitive. We will avail of these methods in our examples.
  prefs: []
  type: TYPE_NORMAL
- en: Nested if statements
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have discussed packages and `Scanner`, in *Figure 4**.6* and *Figure
    4**.7*, we discuss a more involved `if-else` example that deals with input from
    the user (via the keyboard). Both figures relate to the one example. *Figure 4**.6*
    focuses on the declaration of constants to make the code more readable. In addition,
    *Figure 4**.6* also focuses on declaring and using `Scanner`. On the other hand,
    *Figure 4**.7* focuses on the subsequent `if-else` structure.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.6 – Using Scanner to get input from the keyboard](img/B19793_04_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.6 – Using Scanner to get input from the keyboard
  prefs: []
  type: TYPE_NORMAL
- en: Lines 11 to 14 define constants using the keyword `final`. This means that their
    values cannot change. It is good practice to use uppercase identifiers for constants
    (where words are separated by underscores). This will make the code in *Figure
    4**.7* more readable; in other words, instead of comparing `month` with `1` (which,
    in this context, means January), we will compare `month` with `JAN`, which reads
    better. For brevity’s sake, we have declared three constants per line but you
    can easily declare one per line also.
  prefs: []
  type: TYPE_NORMAL
- en: Line 16 in *Figure 4**.6* creates our `Scanner` object reference, `sc`. Essentially,
    we are creating a reference, namely `sc`, which refers to the `Scanner` object
    created using the `new` keyword. As stated previously, `System.in` means that
    `sc` is looking at the keyboard. This reference is what we will use to interact
    with `Scanner`, much like a remote control is used to interact with a television.
  prefs: []
  type: TYPE_NORMAL
- en: Line 17 prompts the user to enter a month (`1..12`) on the keyboard. This is
    actually very important because, without the prompt, the cursor will just blink
    and the user will wonder what they should type in. Line 18 is where `Scanner`
    really comes into its own. Here we use the `nextInt()` method to get in a number.
    For the moment, just know that when we call `sc.nextInt()`, Java does not return
    to our code until the user has typed in something and hit the return key. For
    the moment, we will make the (convenient) assumption that it is an integer. We
    will store the `int` primitive returned in our own `int` primitive, `month`. Now,
    in our code, we can use what the user typed in. *Figure 4**.7* shows this in action.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.7 – A complex if statement](img/B19793_04_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.7 – A complex if statement
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the code presented in the preceding image is a *continuation* of
    *Figure 4**.6*. On line 20, we declare an `int` variable, namely `numDays`, and
    initialize it to `0`. Lines 21 to 22 are the start of the `if` statement. Using
    the `boolean` logical OR operator, the `if` statement checks to see whether the
    `month` value matches any of the constants defined in *Figure 4**.6*. In the background,
    the constant values are used, so in reality, the `if` statement is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Note that the `month` variable must be specified each time. In other words,
    `if(month == JAN || MAR || MAY || JUL || AUG || OCT || DEC)` will *not* compile.
  prefs: []
  type: TYPE_NORMAL
- en: So, assuming that the user typed in `1` (representing January), `month` becomes
    `1` and, as a result, lines 21 to 22 evaluate to true and `numDays` is set to
    `31` on line 23\. The logic is the same if the user types in `3`, `5`, `7`, `8`,
    `10`, and `12`, representing March, May, July, August, October, and December,
    respectively.
  prefs: []
  type: TYPE_NORMAL
- en: If the user types in `4` (representing April), lines 21 to 22 evaluate to false
    and the `else if` statement on line 24 is evaluated. Line 24 evaluates to true
    and `numdays` is set to `30` on line 25\. The logic is the same if the user types
    in `6`, `9`, and `11`, representing June, September, and November, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let us deal with the user typing in `2`, representing February. The `if`
    condition on lines 21 to 22 and the `else if` condition on line 24 both evaluate
    to false. Line 26 evaluates to true. Now, we need to review the leap year logic.
    Of course, February has 28 days every year (as do all the months!) but has one
    extra day when the year is a leap year. The logic for determining whether a year
    is a leap year is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`year` is a multiple of 400 => leap year'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`year` is a multiple of 4 AND `year` is *not* a multiple of 100 => leap year'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following are all leap years: 2000 (satisfies scenario A), 2012, and 2016
    (both satisfy scenario B).'
  prefs: []
  type: TYPE_NORMAL
- en: As the leap year algorithm depends on the year, we first need the year from
    the user. Lines 27 to 28 accomplish this. We then encounter a nested `if` statement
    from lines 30 to 34, which determines, according to the logic just outlined, whether
    the year entered by the user is a leap year. Line 30 implements the logic for
    both scenarios A and B. Whether `year` is a multiple of 400 is achieved with `(year
    % 400 == 0)`. The condition of `year` being a multiple of 4 and not a multiple
    of 100 is achieved with
  prefs: []
  type: TYPE_NORMAL
- en: '`(year % 4 == 0 && !( year % 100 == 0))`. The fact that either condition satisfies
    the leap year calculation is achieved by using the logical OR operator between
    them. Assuming a year of 2000, line 30 would be true and `numDays` is set to `29`.
    Assuming a year of 1900, the `if` statement on line 30 is false and, as there
    is no condition on line 32 (it is just an `else` statement), line 33 is executed,
    setting `numDays` to `28`.'
  prefs: []
  type: TYPE_NORMAL
- en: An invalid `month` value of, for example, `25` or `-3` would result in the `else`
    branch on line 35 being executed. An error message would be output to the screen
    on line 36 as a result.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lines 38 to 40 output the number of days provided that `numDays` was changed
    from its initial value of `0`. The `if` statement on line 38 prevents the message
    `"Number of days is: 0"` from appearing on the screen if the user typed in an
    invalid `month` value.'
  prefs: []
  type: TYPE_NORMAL
- en: That concludes our treatment of the `if` statement. Now, let us examine both
    `switch` statements and expressions, which can, in certain situations, be a more
    elegant option.
  prefs: []
  type: TYPE_NORMAL
- en: Mastering switch statements and expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Complicated `if` statements, with many `else if` branches and an `else` branch
    can be verbose. The `switch` structure can, in many situations, be more concise
    and elegant. Let us start with `switch` statements.
  prefs: []
  type: TYPE_NORMAL
- en: switch statements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Firstly, let us examine the syntax of the `switch` statement. *Figure 4**.8*
    introduces the syntax.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.8 – The switch statement syntax](img/B19793_04_8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.8 – The switch statement syntax
  prefs: []
  type: TYPE_NORMAL
- en: A `switch` statement evaluates an expression. As of Java 21, the expression
    can be an integral primitive (excluding `long`) or any reference type. This means
    that we can `switch` on primitive variables of type `byte`, `char`, `short`, or
    `int` and also `switch` on class types, enum types, record types and array types.
    The `case` labels can now include a `null` label. Java 21 also brought in *pattern
    matching for switch*. We will present another `switch` example demonstrating this
    feature when we have those topics covered ([*Chapter 9*](B19793_09.xhtml#_idTextAnchor205)).
    Until then, we will focus on the more traditional `switch`.
  prefs: []
  type: TYPE_NORMAL
- en: Wrapper types
  prefs: []
  type: TYPE_NORMAL
- en: 'For each of the primitive types, there is a corresponding class, known as a
    “wrapper type”: `byte` (wrapped by `Byte`), `short` (`Short`), `int` (`Integer`),
    `long` (`Long`), `float` (`Float`), `double` (`Double`), `boolean` (`Boolean`),
    and `char` (`Character`). They are so called because they represent objects that
    encapsulate the primitive. As they are class types, useful methods are available.
    For example, `int val = Integer.parseInt("22");` converts the `String "22"` into
    the number `22`, stored in `val`, where we can perform arithmetic.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The expression just evaluated is compared against the `case` labels. The `case`
    labels are compile-time constants of the same type as the `switch` expression.
    If there is a match with a `case` label, the associated block of code is executed
    (note: no need for curly braces in the `case` or `default` blocks). To exit the
    `case` block, ensure you insert a `break` statement. The `break` statement exits
    the `switch` block. However, the `break` statement is optional. If you omit the
    `break` statement, the code *falls through* to the next `case` label (or `default`),
    even though there is no match.'
  prefs: []
  type: TYPE_NORMAL
- en: The `default` keyword is used to specify a code block to execute if none of
    the `case` labels match. Typically, it is coded at the end of the `switch` block
    but this is not mandatory. In effect, `default` can appear anywhere in the `switch`
    block with similar semantics (this is a poor programming practice, however).
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 4**.9* presents an example.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.9 – switch on a String example](img/B19793_04_9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.9 – switch on a String example
  prefs: []
  type: TYPE_NORMAL
- en: Using the `Scanner` class, lines 18 to 20 ask and retrieve from the user a sport.
    Note that the `Scanner` method used on this occasion is `next()`, which returns
    a `String` type (as opposed to a primitive type).
  prefs: []
  type: TYPE_NORMAL
- en: Lines 21 to 31 present the `switch` block. Note that the `case` labels on lines
    22 and 25 are both `String` compile-time constants. If the user types in `"Soccer"`,
    the `case` label on line 22 matches, and both lines 23 and 24 will execute. Interestingly,
    even though there are two statements to be executed, there is no need for curly
    braces here. This is a feature of `switch` blocks. As line 22 matched, line 23
    will execute, and `"I play soccer"` will be echoed to the screen. The `break`
    statement on line 24 ensures that the `switch` block is exited and that the `"Rugby"`
    section is not executed.
  prefs: []
  type: TYPE_NORMAL
- en: If, on the other hand, the user types in `"Rugby"`, line 25 matches, and `"I
    play Rugby"` is echoed to the screen. Again, the `break` statement, this time
    on line 27, ensures that the `switch` block is exited and that the `default` section
    is not executed.
  prefs: []
  type: TYPE_NORMAL
- en: If the user typed in `"Tennis"`, then neither of the `case` labels on lines
    22 and 25 will match. This is when the `default` section comes into play. When
    there are no matches with any `case` label, the `default` section is executed.
    Typically, the `default` section is coded at the end of the `switch` block and
    the `break` statement is traditionally inserted for completeness.
  prefs: []
  type: TYPE_NORMAL
- en: Case labels are case-sensitive
  prefs: []
  type: TYPE_NORMAL
- en: Note that the `case` labels are case-sensitive. In other words, in *Figure 4**.9*,
    if the user types in `"soccer"`, the `case` label on line 22 will *not* match.
    The `"Rugby"` case label will not match either, naturally. Thus, the default section
    will execute, and `"Unknown sport"` will echo (print) to the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Let us look at another example. *Figure 4**.10* is a `switch` statement based
    on integers.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.10 – switch on an integer example](img/B19793_04_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.10 – switch on an integer example
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding figure, line 37 declares a compile-time constant, `two`, and
    initializes it to the integer literal, `2`. Line 38 starts the `switch` block
    by switching on an `int` variable named `number`, which was declared and initialized
    based on user input, on line 36\. All of the `case` labels in the `switch` block
    must now be integers – be they literal values as on lines 39 to 43 and line 47,
    or compile-time constants as on line 46\. Note that if the `two` variable is not
    *final*, a compile-time error is generated (as it is no longer a constant).
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we have multiple labels together, such as, lines 39-43\. This
    section of code can be read as *if number is 1 or 3 or 5 or 7 or 9, then do the
    following*. So, for example, if the user types in `1`, the `case` label on line
    39 matches. This is known as the *entry point* of the `switch` statement. As there
    is no `break` statement on line 39, the code *falls through* to line 40, even
    though line 40 has a `case` label for `3`. Again, line 40 has no `break` statement
    and the code *falls through* to line 41\. In fact, the code keeps executing from
    the entry point until it reaches a `break` statement (or the end of the `switch`
    statement itself). This *fall-through* behavior is what enables the *if it’s 1
    or 3 or 5 or 7 or 9* type logic to work. If this *fall-through* behavior were
    not present, we would have to duplicate lines 44 to 45 for each of the `case`
    labels! Line 44 uses the `String` append to output that the number entered is
    odd, by appending `"is odd"` to the number – for example, `"7 is odd"`. Line 45
    is the `break` statement that ensures we exit the `switch` block.
  prefs: []
  type: TYPE_NORMAL
- en: Line 46 is just to demonstrate that compile-time constants work for `case` labels.
    Line 47 shows that the `case` labels can be organized in a horizontal fashion
    if so desired. Remember, the use of indentation and spacing is just for human
    readability – the compiler just sees one long sequence of characters. So, lines
    46 to 47 match for the numbers 2, 4, 6, 8, and 10\. Again, the *fall-through*
    logic is used to keep the code concise. Lines 48 to 49 output that that number
    is even and `break` out of the `switch` block.
  prefs: []
  type: TYPE_NORMAL
- en: Line 50 is the `default` section, which caters to any numbers outside of the
    `1..10` range. Line 51 outputs that the number entered is out of range, and line
    52 is the `break` statement. While the `break` statement is not strictly needed
    here (as `default` is at the bottom of the `switch` statement), it is considered
    good practice to include it.
  prefs: []
  type: TYPE_NORMAL
- en: Let us rewrite the code in *Figure 4**.7* using a `switch` statement instead
    of a complicated `if-else` statement. Note that *Figure 4**.6* is still relevant
    in declaring `Scanner` and the constants used; this is why we separated *Figure
    4**.6* (so we could use it with both the `if` and `switch` code). *Figure 4**.11*
    represents *Figure 4**.7* refactored using a `switch` statement.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.11 – Refactoring an if statement with a switch statement](img/B19793_04_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.11 – Refactoring an if statement with a switch statement
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding figure, we can see the `switch` statement starts on line 23\.
    The first group of `case` labels is on line 24 and the second group is on line
    27\. February, the odd one out, has a `case` label to itself (line 30). Finally,
    the `default` label is on line 40\. Personally speaking, I find the use of `switch`
    in this example preferable due to the absence of the multiple logical OR expressions
    required in *Figure 4**.7* (lines 21 to 22 and 24).
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have covered valid `switch` statements, let us examine, in *Figure
    4**.12*, a few scenarios where compiler errors can arise.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.12 – Some switch compiler errors](img/B19793_04_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.12 – Some switch compiler errors
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding figure, we are switching on a `byte` variable, `b`. Recall
    that the valid `byte` range is `-128` to `+127`. Line 60 demonstrates that the
    minimum and maximum values are fine. Line 63 shows that, as `128` is out of range
    for our `byte` type `b`, the `case` labels that are out of range of the `switch`
    variable cause a compiler error. Line 64 was fine until line 65 used the same
    `case` label – `case` label duplicates are not allowed.
  prefs: []
  type: TYPE_NORMAL
- en: We will finish our discussion on `switch` by discussing `switch` expressions.
  prefs: []
  type: TYPE_NORMAL
- en: switch expressions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Like all expressions, `switch` expressions evaluate to a single value and, therefore,
    enable us to return values. All the `switch` examples so far have been `switch`
    *statements*, which return nothing. Note that in a `switch` expression, `break`
    statements are not allowed.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, `switch` *expressions* return something – either implicitly
    or explicitly (using `yield`). We will explain `yield` shortly, but note that
    `yield` cannot be used in a `switch` statement (as they do not return anything).
    In addition, `switch` statements can *fall through*, whereas `switch` expressions
    do not. These differences are encapsulated in *Table 4.1*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 4.1 – Comparison of switch statements versus switch expressions](img/B19793_04_Table_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Table 4.1 – Comparison of switch statements versus switch expressions
  prefs: []
  type: TYPE_NORMAL
- en: Let us look at some example code to demonstrate the differences. *Figure 4**.13*
    is the traditional `switch` statement.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.13 – A traditional switch statement](img/B19793_04_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.13 – A traditional switch statement
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding figure, we are switching on the `String` variable, `name`.
    As it is initialized to `"Jane"`, line 19 is true and line 23 sets `nLetters`
    to `4` (the number of letters in “Jane”). The `break` statement on line 24 ensures
    that there is no fall-through to line 27\. Line 39 outputs `4` to the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the code is quite verbose and requires the correct use of the `break`
    statement to prevent fall through. Plus, these `break` statements are tedious
    to write and easy to forget. *Figure 4**.14* represents *Figure 4**.13* written
    using a `switch` expression.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.14 – A switch expression](img/B19793_04_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.14 – A switch expression
  prefs: []
  type: TYPE_NORMAL
- en: The preceding figure shows the new `case` label where the labels are comma-delimited
    and an arrow token separates the labels from the expression (or code block). There
    is no `break` statement required anywhere as there is no fall-through behavior
    to worry about. As `name` is still `"Jane"` (from *Figure 4**.13*, line 17), line
    42 is executed, which initializes/returns `4` into `nLetters`. Thus, line 50 outputs
    `4`. Note that the list of `case` labels in a `switch` expression must be exhaustive.
    In almost all cases, this means that a `default` clause is required. The `default`
    clause in this example executes a code block (lines 45-48), where an error is
    output to the screen and using the `yield` keyword, `nLetters` is initialized
    to (an error value of) `–1`.
  prefs: []
  type: TYPE_NORMAL
- en: We can omit the need for the `nLetters` variable by returning the expression
    value straight into the `System.out.println()` statement. *Figure 4**.15* demonstrates
    this.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.15 – A switch expression returning straight to System.out.println()](img/B19793_04_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.15 – A switch expression returning straight to System.out.println()
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding figure, there is no variable used to store the result of the
    `switch` expression. This makes the code even more concise. The result of the
    `switch` expression is returned straight into the `System.out.println()` statement.
    Again, `4` is output to the screen.
  prefs: []
  type: TYPE_NORMAL
- en: The yield keyword
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Figure 4**.14* and *Figure 4**.15* were simple `switch` expressions, where
    (for the most part), to the right of the arrow token was the value to be returned.
    However, instead of simply returning a value, what if you wished to execute a
    code block? This is where `yield` is used. *Figure 4**.16* shows the use of `yield`
    in a `switch` expression.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.16 – A switch expression using yield](img/B19793_04_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.16 – A switch expression using yield
  prefs: []
  type: TYPE_NORMAL
- en: The preceding figure highlights the fact that, if you need to execute more than
    one statement in a `switch` expression, you must provide a code block. This is
    shown with the curly braces for lines 61-64, 65-68, 69-72 and 73-76\. To return
    an expression result from a code block we use `yield`. This is what is done on
    lines 63, 67, 71 and 75, where `4`, `5`, `6` and `–1` are returned, respectively.
    As `name` is still `"Jane"`, line 63 returns `4` from the `switch` expression,
    initializing `nLetters` to `4`. Therefore, line 78 outputs `4`.
  prefs: []
  type: TYPE_NORMAL
- en: To aid flexibility, you can, up to a point, mix the syntaxes. In other words,
    regular `case` labels can be used in `switch` expressions, and the new `case`
    labels syntax can be used in `switch` statements. However, as stated earlier,
    `break` only appears in `switch` *statements* and `yield` only appears (if required)
    in switch *expressions*. *Figure 4**.17* is a refactor of the verbose `switch`
    statement in *Figure 4**.13*, where the new `case` labels are used in a `switch`
    statement.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.17 – A switch statement using new case labels and an arrow token](img/B19793_04_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.17 – A switch statement using new case labels and an arrow token
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding figure, the labels are comma-delimited and the arrow token
    is present. As before, on the right of the arrow token, we have the initialization
    of `nLetters` to the number of letters in the name. However, in contrast to *Figure
    4**.13*, as we are using the arrow token, no `break` statements are required.
    Note however that curly braces are required for a code block as per the `default`
    clause (lines 86-89).
  prefs: []
  type: TYPE_NORMAL
- en: We can also use the regular `case` labels with `switch` expressions. This is
    shown in *Figure 4**.18*, which is a refactored version of *Figure 4**.16*.
  prefs: []
  type: TYPE_NORMAL
- en: '![ Figure 4.18 – A switch expression using old-style case labels](img/B19793_04_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.18 – A switch expression using old-style case labels
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding figure, the old-style `case` labels are used. This means that
    the keyword `case` must precede each label. The curly braces for the code blocks
    can, however, be omitted. As it is a `switch` expression, where there is more
    than one statement to be executed when a match is found, we need to use `yield`
    to return the expression result. As the `name` variable has never been changed
    from `"Jane"` throughout all the examples, a match is made on line 95, resulting
    in line 99 outputting `"There are 4 letters in: Jane"` to the screen. The `yield`
    on line 100 returns `4`, and thus, `nLetters` is initialized to `4`. Finally,
    line 114 outputs `4` to the screen.'
  prefs: []
  type: TYPE_NORMAL
- en: This completes our treatment of `switch` expressions and, indeed, `switch` statements
    in general. We will now put what we have learned into practice.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We finally have the coding capability to make decisions. Mesozoic Eden is going
    to be benefiting from this so much. Let’s show off our newly acquired skills,
    shall we?
  prefs: []
  type: TYPE_NORMAL
- en: We need to determine whether a dinosaur is a carnivore or herbivore. Write an
    `if` statement that prints whether a dinosaur is a carnivore or herbivore based
    on a `boolean` variable. This information is critical for feeding and care guidelines.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Different species require different care strategies and exhibit unique behavior
    traits. Write a `switch` statement that prints a description of a dinosaur based
    on its species. This will help educate both the staff and park visitors.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Some dinosaurs are tougher to handle than others. Write an `if` statement that
    checks whether a number of years of experience is enough experience to work with
    a certain type of dinosaur. This ensures the safety of both our dinosaurs and
    employees.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We are working with beautiful but dangerous creatures. So, safety first. Write
    a program that prints a warning message if the park’s safety rating falls below
    a certain threshold. We must always be alert to potential issues that could harm
    our staff, visitors, or dinosaurs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Proper housing is essential for the dinosaurs’ well-being. Write a `switch`
    statement that assigns a dinosaur to a specific enclosure based on its size (XS,
    S, M, L, or XL).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Proper nutrition is crucial for maintaining our dinosaurs’ health. Write an
    `if` statement that determines the number of feeds a dinosaur requires per day
    based on its weight.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It is important to delegate tasks properly to keep operations running smoothly.
    Create a program that assigns different duties to employees based on their job
    titles using a `switch` statement.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The park is not open to day visitors 24/7\. Write an `if` statement that checks
    whether the park is open for them based on the time. They are open for day visitors
    from 10 A.M. to 7 P.M. This helps in managing visitor expectations and staff schedules.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Project – Task allocation system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The manager of Mesozoic Eden needs a systematic way of managing the team and
    ensuring all tasks are efficiently accomplished.
  prefs: []
  type: TYPE_NORMAL
- en: Design a simple program that assigns tasks to the Mesozoic Eden employees based
    on their roles (for example, feeding, cleaning, security, and tour guiding). The
    program should decide tasks based on time, the employee’s role, and other factors,
    such as the park’s safety rating.
  prefs: []
  type: TYPE_NORMAL
- en: This program would not only help streamline operations but also ensure the safety
    and satisfaction of our staff, visitors, and, most importantly, our dinosaurs!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we started by explaining that Java uses block scope. A block
    is delimited by `{ }`. A variable is visible from the point of declaration to
    the closing `}` of that block. As blocks (and therefore, scopes) can be nested,
    this means that a variable defined in a block is visible to any inner/nested blocks.
    The inverse is not true, however. A variable declared in an inner block is not
    visible in an outer block
  prefs: []
  type: TYPE_NORMAL
- en: Conditional statements enable us to make decisions and are based on the evaluation
    of a condition resulting in true or false. The `if` statement allows several branches
    to be evaluated. Once one branch evaluates to true and is executed, no other branch
    is evaluated. An `if` statement can be coded on its own without any `else if`
    or `else` clause. The `else if` and `else` clauses are optional. However, if an
    `else` clause is present, it must be the last clause. We saw how a complex `if`
    example can lead to code verbosity.
  prefs: []
  type: TYPE_NORMAL
- en: We briefly discussed packages and the `Scanner` class. The `Scanner` class resides
    in the `java.util` package and is very useful for retrieving keyboard input from
    the user.
  prefs: []
  type: TYPE_NORMAL
- en: We also discussed both `switch` statements and `switch` expressions. An expression
    can return a value but a statement cannot. We saw how `switch` statements can
    make complicated `if` statements more concise and elegant. The expression you
    `switch` on (typically, a variable) can be a primitive `byte`, `char`, `short`,
    or `int` type ; or a reference type. The `case` labels must be compile-time constants
    and must be in range for the `switch` variable. `switch` statements have a fall-through
    feature, which enables multiple `case` labels to use the same section of code
    without repetition. However, this fall-through behavior requires a `break` statement
    to exit the `switch` statement. This requires care, as `break` statements are
    easy to forget.
  prefs: []
  type: TYPE_NORMAL
- en: '`switch` expressions can return a value. They have no fall-through logic so
    `break` statements are not required. This makes the code more concise and less
    error-prone. If you wish to execute a code block in a `switch` expression, use
    `yield` to return the value.'
  prefs: []
  type: TYPE_NORMAL
- en: '`switch` statements do not support `yield` (as they do not return anything),
    and `switch` expressions do not support `break` (as they must return something).
    However, both of the `case` labels, namely the old-style `case X:` and the newer
    style `case A, B, C ->`, can be used with either `switch` statements or `switch`
    expressions.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know how to make decisions, we will move on to iteration in the
    next chapter, where we will examine the Java structures that enable us to repeat
    statements.
  prefs: []
  type: TYPE_NORMAL
