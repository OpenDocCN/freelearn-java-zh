<html><head></head><body><div class="chapter" title="Chapter&#xA0;11.&#xA0;Developing RESTful Web Services with JAX-RS"><div class="titlepage"><div><div><h1 class="title"><a id="ch11"/>Chapter 11. Developing RESTful Web Services with JAX-RS</h1></div></div></div><p>
<span class="strong"><strong>Representational State Transfer</strong></span> (<span class="strong"><strong>REST</strong></span>)<a id="id1023" class="indexterm"/> is an architectural style in which web services are viewed as resources and can be identified by Uniform Resource Identifiers (URIs).</p><p>Web services developed using REST are known as RESTful web services<a id="id1024" class="indexterm"/>.</p><p>Java EE 6 added support to RESTful web services through the addition of the Java API for RESTful Web Services (JAX-RS). JAX-RS had been available as a standalone API for a while, it became part of Java EE in Version 6 of the specification. In this chapter, we will cover how to develop RESTful web services through the JAX-RS.API.</p><p>The following topics will be covered in this chapter:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Introduction to RESTful web services and JAX-RS</li><li class="listitem" style="list-style-type: disc">Developing a simple RESTful web service</li><li class="listitem" style="list-style-type: disc">Developing a RESTful web service client</li><li class="listitem" style="list-style-type: disc">Path parameters</li><li class="listitem" style="list-style-type: disc">Query parameters</li></ul></div><div class="section" title="Introducing RESTful web services and JAX-RS"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec58"/>Introducing RESTful web services and JAX-RS</h1></div></div></div><p>RESTful web services are very flexible. <a id="id1025" class="indexterm"/>RESTful web services can consume several different kinds of MIME types, although they are typically written to consume and/or produce XML or JSON (JavaScript Object Notation).</p><p>Web services must support one or more of the following four HTTP methods:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">GET</code>: By convention, a <a id="id1026" class="indexterm"/><code class="literal">GET</code> request is used to retrieve an existing resource</li><li class="listitem" style="list-style-type: disc"><code class="literal">POST</code>: By convention, a <a id="id1027" class="indexterm"/><code class="literal">POST</code> request is used to update an existing resource</li><li class="listitem" style="list-style-type: disc"><code class="literal">PUT</code>: By convention, a <code class="literal">PUT</code> request is <a id="id1028" class="indexterm"/>used to create a new resource</li><li class="listitem" style="list-style-type: disc"><code class="literal">DELETE</code>: By convention, a <code class="literal">DELETE</code> reques<a id="id1029" class="indexterm"/>t is used to delete an existing resource</li></ul></div><p>We develop a RESTful web service with JAX-RS by creating a class with annotated methods that are invoked when our web service receives one of the above HTTP request methods. Once we have developed and deployed our RESTful web service, we need to develop a client that will send requests to our service. JAX-RS 2.0 introduces a standard client-side API that we can use to develop RESTful web service clients.</p></div></div>
<div class="section" title="Developing a simple RESTful web service"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec59"/>Developing a simple RESTful web service</h1></div></div></div><p>In this section, we will develop a simple web service to illustrate how to make methods in our service respond to the different HTTP request methods.</p><p>Developing a RESTful web service using JAX-RS is simple and straightforward. Each of our RESTful web services needs to<a id="id1030" class="indexterm"/> be invoked via its Unique Resource Identifier (URI). This URI is specified by the <code class="literal">@Path</code> annotation, which we need to use to decorate our RESTful web service resource class.</p><p>When developing RESTful web services, we need to develop methods that will be invoked when our web service receives an HTTP request. We need to implement methods to handle one or more of the four types of request that RESTful web services handle: <code class="literal">GET</code>, <code class="literal">POST</code>, <code class="literal">PUT</code>, and/or <code class="literal">DELETE</code>.</p><p>The JAX-RS API provides four annotations that we can use to decorate methods in our web service; the annotations are appropriately named <code class="literal">@GET</code>, <code class="literal">@POST</code>, <code class="literal">@PUT</code>, and <code class="literal">@DELETE</code>. Decorating a method in our web service with one of these annotations will make it respond to the corresponding HTTP method.</p><p>Additionally, each method in our service must produce and/or consume a specific MIME type.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip14"/>Tip</h3><p>
<span class="strong"><strong>Multipurpose Internet Mail Extensions</strong></span> (<span class="strong"><strong>MIME</strong></span>)<a id="id1031" class="indexterm"/> is a standard for transferring nonASCII text over the Internet. MIME was originally developed to send nontextual data over e-mail, but later, its use was expanded to include other forms of data transfer such as RESTful web services.</p></div></div><p>The MIME type that is going to be produced needs to be specified with the <code class="literal">@Produces</code> annotation; similarly, the<a id="id1032" class="indexterm"/> MIME type that is going to be consumed must be specified with the <code class="literal">@Consumes</code> annotation.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip15"/>Tip</h3><p>Please note that this example does not really do anything; its purpose is to illustrate how to make different methods in our RESTful web service resource class respond to the different HTTP methods.</p></div></div><p>The following example illustrates the concepts we have just explained:</p><div class="informalexample"><pre class="programlisting">package com.ensode.jaxrsintro.service;

import javax.ws.rs.Consumes;
import javax.ws.rs.DELETE;
import javax.ws.rs.GET;
import javax.ws.rs.POST;
import javax.ws.rs.PUT;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;

<span class="strong"><strong>@Path("customer")</strong></span>
public class CustomerResource {

<span class="strong"><strong>  @GET</strong></span>
<span class="strong"><strong>  @Produces("text/xml")</strong></span>
  public String getCustomer() {
    //in a "real" RESTful service, we would retrieve data from a database
    //then return an XML representation of the data.

    System.out.println("--- " + this.getClass().getCanonicalName()
        + ".getCustomer() invoked");

    return "&lt;customer&gt;\n"
        + "&lt;id&gt;123&lt;/id&gt;\n"
        + "&lt;firstName&gt;Joseph&lt;/firstName&gt;\n"
        + "&lt;middleName&gt;William&lt;/middleName&gt;\n"
        + "&lt;lastName&gt;Graystone&lt;/lastName&gt;\n"
        + "&lt;/customer&gt;\n";
  }

  /**
   * Create a new customer
   * @param customer XML representation of the customer to create
   */
<span class="strong"><strong>  @PUT</strong></span>
<span class="strong"><strong>  @Consumes("text/xml")</strong></span>
  public void createCustomer(String customerXML) {
    //in a "real" RESTful service, we would parse the XML
    //received in the customer XML parameter, then insert
    //a new row into the database.

    System.out.println("--- " + this.getClass().getCanonicalName()
        + ".createCustomer() invoked");

    System.out.println("customerXML = " + customerXML);
  }

<span class="strong"><strong>  @POST</strong></span>
<span class="strong"><strong>  @Consumes("text/xml")</strong></span>
  public void updateCustomer(String customerXML) {
    //in a "real" RESTful service, we would parse the XML
    //received in the customer XML parameter, then update
    //a row in the database.

    System.out.println("--- " + this.getClass().getCanonicalName()
        + ".updateCustomer() invoked");

    System.out.println("customerXML = " + customerXML);
  }

<span class="strong"><strong>  @DELETE</strong></span>
<span class="strong"><strong>  @Consumes("text/xml")</strong></span>
  public void deleteCustomer(String customerXML) {
    //in a "real" RESTful service, we would parse the XML
    //received in the customer XML parameter, then delete
    //a row in the database.

    System.out.println("--- " + this.getClass().getCanonicalName()
        + ".deleteCustomer() invoked");

    System.out.println("customerXML = " + customerXML);
  }
}</pre></div><p>Notice that this class<a id="id1033" class="indexterm"/> is annotated with the <code class="literal">@Path</code> annotation;<a id="id1034" class="indexterm"/> this annotation designates the Uniform Resource Identifier (URI) for our RESTful web service. The complete URI for our service will include the protocol, server name, port, context root, the REST resources path (see the next subsection), and the value passed to this annotation.</p><p>Assuming our web service <a id="id1035" class="indexterm"/>was deployed to a server called <code class="literal">example.com</code> using the HTTP protocol on port 8080, and has a context root called "jaxrsintro" and a REST resources path called <code class="literal">resources</code>, then the complete URI for our service would be <code class="literal">http://example.com:8080/jaxrsintro/resources/customer</code>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip16"/>Tip</h3><p>Since web browsers generate a GET request when pointed to a URL, we can test the GET method of our service by simply pointing the browser to our service's URI.</p></div></div><p>Notice that each of the methods in our class is annotated with one of the <code class="literal">@GET</code>, <code class="literal">@POST</code>, <code class="literal">@PUT</code>, or <code class="literal">@DELETE</code> annotations. These annotations make our methods respond to their corresponding HTTP method.</p><p>Additionally, if our method returns data to the client, we declare that the MIME type of the data should be returned in the <code class="literal">@Produces</code> annotation. In our example, only the <code class="literal">getCustomer()</code> method<a id="id1036" class="indexterm"/> returns data to the client; we wish to return data in an XML format, therefore, we set the value of the <code class="literal">@Produces</code> annotation to <code class="literal">text/xml</code>. Similarly, if our method needs to consume data from the client, we need to specify the MIME type of the data to be consumed; this is done via the <code class="literal">@Consumes</code> annotation. All methods in our service except <code class="literal">getCustomer()</code> consume data; in all cases, we expect the data to be in XML, therefore, we again specify <code class="literal">text/xml</code> as the MIME type to be consumed.</p><div class="section" title="Configuring the REST resources path for our application"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec72"/>Configuring the REST resources path for our application</h2></div></div></div><p>As briefly mentioned in<a id="id1037" class="indexterm"/> the previous section, before successfully deploying a RESTful web service developed using JAX-RS, we need to configure the REST resources path for our application. We can do this by developing a class that extends <code class="literal">javax.ws.rs.core.Application</code> and decorating it with the <code class="literal">@ApplicationPath</code> annotation.</p><div class="section" title="Configuring via the @ApplicationPath annotation"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl3sec25"/>Configuring via the @ApplicationPath annotation</h3></div></div></div><p>As mentioned in previous chapters, Java EE 6 added several new features to the Java EE specification so that<a id="id1038" class="indexterm"/> in many cases it isn't necessary to write a <code class="literal">web.xml</code> deployment descriptor. JAX-RS is no different. We can configure the REST resources path in Java code via an annotation.</p><p>To configure our REST resources path without having to rely on a <code class="literal">web.xml</code> deployment descriptor, all we need to do is write a class that extends <code class="literal">javax.ws.ApplicationPath</code> and decorate it with the <code class="literal">@ApplicationPath</code> annotation; the value passed to this annotation is the REST resources path for our services.</p><p>The following <a id="id1039" class="indexterm"/>code sample illustrates this process:</p><div class="informalexample"><pre class="programlisting">package com.ensode.jaxrsintro.service.config;

import javax.ws.rs.ApplicationPath;
import javax.ws.rs.core.Application;

<span class="strong"><strong>@ApplicationPath("resources")</strong></span>
public class JaxRsConfig extends Application {
}</pre></div><p>Notice that the class does not have to implement any methods. It simply needs to extend <code class="literal">javax.ws.rs.Application</code> and be decorated with the <code class="literal">@ApplicationPath</code> annotation.<a id="id1040" class="indexterm"/> The class must be public, may have any name, and may be placed in any package.</p></div></div><div class="section" title="Testing our web service"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec73"/>Testing our web service</h2></div></div></div><p>As we mentioned earlier, <a id="id1041" class="indexterm"/>web browsers send a <code class="literal">GET</code> request to any URLs we point them to; therefore, the easiest way to test <code class="literal">GET</code> requests to our service is by simply pointing the browser to our service's URI, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/6886_11_01.jpg" alt="Testing our web service"/></div><p>Web browsers only support <code class="literal">GET</code> and <code class="literal">POST</code> requests. To test a <code class="literal">POST</code> request through the browser, we would have to write a web application containing an HTML form that has an action attribute <a id="id1042" class="indexterm"/>value of our service's URI. Although this is simple to do for a single service, it can become cumbersome to do this for every RESTful web service we develop.</p><p>Thankfully, there is an open source command-line utility called <code class="literal">curl</code> that we can use to test our web services. The <code class="literal">curl</code> command<a id="id1043" class="indexterm"/> is included with most Linux distributions and can be easily downloaded for Windows, Mac OS X, and several other platforms. The <code class="literal">curl</code> utility can be downloaded at <a class="ulink" href="http://curl.haxx.se/">http://curl.haxx.se/</a>.</p><p>
<code class="literal">curl</code> can send all four request method types (<code class="literal">GET</code>, <code class="literal">POST</code>, <code class="literal">PUT</code> and <code class="literal">DELETE</code>) to our service. Our server's response will simply be displayed on the command-line console. <code class="literal">curl</code> takes the <code class="literal">-X</code> command-line option, which allows us to specify what request method to send; to send a <code class="literal">GET</code> request, we simply need to type the following into the command line:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>curl -XGET http://localhost:8080/jaxrsintro/resources/customer</strong></span>
</pre></div><p>This results in the following output:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&lt;customer&gt;</strong></span>
<span class="strong"><strong>&lt;id&gt;123&lt;/id&gt;</strong></span>
<span class="strong"><strong>&lt;firstName&gt;Joseph&lt;/firstName&gt;</strong></span>
<span class="strong"><strong>&lt;middleName&gt;William&lt;/middleName&gt;</strong></span>
<span class="strong"><strong>&lt;lastName&gt;Graystone&lt;/lastName&gt;</strong></span>
<span class="strong"><strong>&lt;/customer&gt;</strong></span>
</pre></div><p>This, unsurprisingly, is the same output we saw when we pointed our browser to our service's URI.</p><p>The default request method for curl is <code class="literal">GET</code>, therefore, the <code class="literal">-X</code> parameter in our previous example is redundant; we could have achieved the same result by invoking the following command from the command line:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>curl  HYPERLINK "http://localhost:8080/jaxrsintro/resources/customer"http://localhost:8080/jaxrsintro/resources/customer</strong></span>
</pre></div><p>After submitting any of the two previous commands and examining the GlassFish log, we should see the output of the <code class="literal">System.out.println()</code> statements we added to the <code class="literal">getCustomer()</code> method.</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>INFO: --- com.ensode.jaxrsintro.service.CustomerResource.getCustomer() invoked</strong></span>
</pre></div><p>For all other request method types, we need to send some data to our service. This can be accomplished by the <code class="literal">--data</code> command-line argument to the <code class="literal">curl</code> command, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>curl -XPUT -HContent-type:text/xml --data "&lt;customer&gt;&lt;id&gt;321&lt;/id&gt;&lt;firstName&gt;Amanda&lt;/firstName&gt;&lt;middleName&gt;Zoe&lt;/middleName&gt;&lt;lastName&gt;Adams&lt;/lastName&gt;&lt;/customer&gt;" http://localhost:8080/jaxrsintro/resources/customer</strong></span>
</pre></div><p>As shown in this example, we need to specify the MIME type via the curl's <code class="literal">-H</code> command-line argument using the format shown in the example.</p><p>We can verify<a id="id1044" class="indexterm"/> that the previous command worked as expected by inspecting the GlassFish log by executing the following code:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>INFO: --- com.ensode.jaxrsintro.service.CustomerResource.createCustomer() invoked</strong></span>
<span class="strong"><strong>INFO: customerXML = &lt;customer&gt;&lt;id&gt;321&lt;/id&gt;&lt;firstName&gt;Amanda&lt;/firstName&gt;&lt;middleName&gt;Zoe&lt;/middleName&gt;&lt;lastName&gt;Adams&lt;/lastName&gt;&lt;/customer&gt;</strong></span>
</pre></div><p>We can test other request method types just as easily by executing the following code:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>curl -XPOST -HContent-type:text/xml --data "&lt;customer&gt;&lt;id&gt;321&lt;/id&gt;&lt;firstName&gt;Amanda&lt;/firstName&gt;&lt;middleName&gt;Tamara&lt;/middleName&gt;&lt;lastName&gt;Adams&lt;/lastName&gt;&lt;/customer&gt;" http://localhost:8080/jaxrsintro/resources/customer</strong></span>
</pre></div><p>The GlassFish log shows the corresponding output:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>INFO: --- com.ensode.jaxrsintro.service.CustomerResource.updateCustomer() invoked</strong></span>
<span class="strong"><strong>INFO: customerXML = &lt;customer&gt;&lt;id&gt;321&lt;/id&gt;&lt;firstName&gt;Amanda&lt;/firstName&gt;&lt;middleName&gt;Tamara&lt;/middleName&gt;&lt;lastName&gt;Adams&lt;/lastName&gt;&lt;/customer&gt;</strong></span>
</pre></div><p>We can test the <code class="literal">delete</code> method by executing the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>curl -XDELETE -HContent-type:text/xml --data "&lt;customer&gt;&lt;id&gt;321&lt;/id&gt;&lt;firstName&gt;Amanda&lt;/firstName&gt;&lt;middleName&gt;Tamara&lt;/middleName&gt;&lt;lastName&gt;Adams&lt;/lastName&gt;&lt;/customer&gt;" http://localhost:8080/jaxrsintro/resources/customer</strong></span>
</pre></div><p>Again the GlassFish log shows the corresponding output:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>INFO: --- com.ensode.jaxrsintro.service.CustomerResource.deleteCustomer() invoked</strong></span>
<span class="strong"><strong>INFO: customerXML = &lt;customer&gt;&lt;id&gt;321&lt;/id&gt;&lt;firstName&gt;Amanda&lt;/firstName&gt;&lt;middleName&gt;Tamara&lt;/middleName&gt;&lt;lastName&gt;Adams&lt;/lastName&gt;&lt;/customer&gt;</strong></span>
</pre></div></div><div class="section" title="Converting data between Java and XML with JAXB"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec74"/>Converting data between Java and XML with JAXB</h2></div></div></div><p>In our previous example, we processed raw XML data. In a real application, we would more than likely parse the XML data received from the <a id="id1045" class="indexterm"/>client and use it to populate a Java object. Additionally, any XML data that we need to return to the client would have to be constructed from a Java object.</p><p>Converting data from Java to XML and back is such a common use case that the Java EE specification provides an API to do it. This API is the <span class="strong"><strong>Java API for XML Binding</strong></span> (<span class="strong"><strong>JAXB</strong></span>)<span class="strong"><strong>.</strong></span>
</p><p>JAXB makes converting<a id="id1046" class="indexterm"/> data from Java to XML transparent and simple. All we need to do is decorate the class that we wish to convert to XML with the <code class="literal">@XmlRootElement</code> annotation. The following code example illustrates how to do this:</p><div class="informalexample"><pre class="programlisting">package com.ensode.jaxrstest.entity;

import java.io.Serializable;
import javax.xml.bind.annotation.XmlRootElement;

<span class="strong"><strong>@XmlRootElement</strong></span>
public class Customer implements Serializable {

  private Long id;
  private String firstName;
  private String middleName;
  private String lastName;

  public Customer() {
  }

  public Customer(Long id, String firstName,
      String middleInitial, String lastName) {
    this.id = id;
    this.firstName = firstName;
    this.middleName = middleInitial;
    this.lastName = lastName;
  }

  public String getFirstName() {
    return firstName;
  }

  public void setFirstName(String firstName) {
    this.firstName = firstName;
  }

  public Long getId() {
    return id;
  }

  public void setId(Long id) {
    this.id = id;
  }

  public String getLastName() {
    return lastName;
  }

  public void setLastName(String lastName) {
    this.lastName = lastName;
  }

  public String getMiddleName() {
    return middleName;
  }

  public void setMiddleName(String middleName) {
    this.middleName = middleName;
  }

  @Override
  public String toString() {
    return "id = " + getId() + "\nfirstName = " + getFirstName()
        + "\nmiddleName = " + getMiddleName() + "\nlastName = "
        + getLastName();
  }
}</pre></div><p>As shown in this example, other than the <code class="literal">@XmlRootElement</code> annotation at the class level, there is nothing<a id="id1047" class="indexterm"/> unusual about the above Java class.</p><p>Once we have a class that we have decorated with the <code class="literal">@XmlRootElement </code>annotation<a id="id1048" class="indexterm"/>, we need to change the parameter type of our web service from String to our custom class, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">package com.ensode.jaxbxmlconversion.service;

import com.ensode.jaxbxmlconversion.entity.Customer;
import javax.ws.rs.Consumes;
import javax.ws.rs.DELETE;
import javax.ws.rs.GET;
import javax.ws.rs.POST;
import javax.ws.rs.PUT;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;

@Path("customer")
public class CustomerResource {

  private Customer customer;

  public CustomerResource() {
    //"fake" the data, in a real application the data
    //would come from a database.
    customer = new Customer(1L, "David",
        "Raymond", "Heffelfinger");
  }

  @GET
  @Produces("text/xml")
<span class="strong"><strong>  public Customer getCustomer() {</strong></span>
    //in a "real" RESTful service, we would retrieve data from a database
    //then return an XML representation of the data.

    System.out.println("--- " + this.getClass().getCanonicalName()
        + ".getCustomer() invoked");

<span class="strong"><strong>    return customer;</strong></span>
  }

  @POST
  @Consumes("text/xml")
<span class="strong"><strong>  public void updateCustomer(Customer customer) {</strong></span>
    //in a "real" RESTful service, JAXB would parse the XML
    //received in the customer XML parameter, then update
    //a row in the database.

    System.out.println("--- " + this.getClass().getCanonicalName()
        + ".updateCustomer() invoked");


    System.out.println("---- got the following customer: "
        + customer);
  }

  @PUT
  @Consumes("text/xml")
<span class="strong"><strong>  public void createCustomer(Customer customer) {</strong></span>
    //in a "real" RESTful service, we would insert
    //a new row into the database with the data in the
    //customer parameter

    System.out.println("--- " + this.getClass().getCanonicalName()
        + ".createCustomer() invoked");

    System.out.println("customer = " + customer);

  }

  @DELETE
  @Consumes("text/xml")
<span class="strong"><strong>  public void deleteCustomer(Customer customer) {</strong></span>
    //in a "real" RESTful service, we would delete a row
    //from the database corresponding to the customer parameter
    System.out.println("--- " + this.getClass().getCanonicalName()
        + ".deleteCustomer() invoked");

    System.out.println("customer = " + customer);
  }
}</pre></div><p>As we can see, the difference between this version of our RESTful web service and the previous one is that all parameter types and return values have been changed from <code class="literal">String</code> to <code class="literal">Customer</code>. JAXB takes care of converting our parameters and return types to and from<a id="id1049" class="indexterm"/> XML as appropriate. When using JAXB, an object of our custom class is automatically populated with data from the XML data sent from the client, return values are similarly transparently converted to XML.</p></div></div>
<div class="section" title="Developing a RESTful web service client"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec60"/>Developing a RESTful web service client</h1></div></div></div><p>Although <code class="literal">curl</code> allows us to quickly test our RESTful web services and is a developer friendly tool, it is not exactly <a id="id1050" class="indexterm"/>user friendly; we shouldn't expect to have our user enter <code class="literal">curl</code> commands in their command line to use our web service. For this reason, we need to develop a client for our services. JAX-RS 2.0 introduces a standard client-side API that we can use to easily develop RESTful web<a id="id1051" class="indexterm"/> service clients.</p><p>The following example illustrates how to use the JAX-RS client API:</p><div class="informalexample"><pre class="programlisting">package com.ensode.jaxrsintroclient;

import com.ensode.jaxbxmlconversion.entity.Customer;
import javax.ws.rs.client.Client;
import javax.ws.rs.client.ClientBuilder;
import javax.ws.rs.client.Entity;

public class App {

    public static void main(String[] args) {
        App app = new App();
        app.insertCustomer();
    }

    public void insertCustomer() {
        Customer customer = new Customer(234L, "Tamara", "A",
                "Graystone");
<span class="strong"><strong>        Client client = ClientBuilder.newClient();        </strong></span>
<span class="strong"><strong>        client.target(</strong></span>
<span class="strong"><strong>        "http://localhost:8080/jaxbxmlconversion/resources/customer").</strong></span>
<span class="strong"><strong>                request().put(</strong></span>
<span class="strong"><strong>                        Entity.entity(customer, "text/xml"),</strong></span>
<span class="strong"><strong>                        Customer.class);</strong></span>
    }
}</pre></div><p>The first thing we need to do is create an instance of <code class="literal">javax.ws.rs.client.Client</code> by invoking the static <code class="literal">newClient()</code> method<a id="id1052" class="indexterm"/> on the <code class="literal">javax.ws.rs.client.ClientBuilder</code> class.</p><p>We then invoke the <code class="literal">target()</code> method<a id="id1053" class="indexterm"/> on our <code class="literal">Client</code> instance, passing the URI of our RESTful web service as the parameter. The <code class="literal">target()</code> method returns an instance of a class implementing the <code class="literal">javax.ws.rs.client.WebTarget</code> interface.</p><p>At this point, we invoke the <code class="literal">request()</code> method<a id="id1054" class="indexterm"/> on our <code class="literal">WebTarget</code> instance; this method returns an implementation of the <code class="literal">javax.ws.rs.client.Invocation.Builder</code> interface.</p><p>In this particular example, we are sending an <code class="literal">HTTP PUT</code> request to our RESTful web service; therefore, at this point, we invoke the <code class="literal">put()</code> method of our <code class="literal">Invocation.Builder</code> implementation. The first parameter of the <code class="literal">put()</code> method is an instance of <code class="literal">javax.ws.rs.client.Entity</code>. We can create an instance of <code class="literal">javax.ws.rs.client.Entity</code> on the fly by invoking the static <code class="literal">entity()</code> method<a id="id1055" class="indexterm"/> on the <code class="literal">Entity</code> class. The first parameter for this method is the object we wish to pass to our RESTful web service and the second parameter is the String representation of the MIME type of the data we will be passing to the RESTful web service. The second parameter of the <code class="literal">put()</code> method <a id="id1056" class="indexterm"/>is the type of response the client expects from the service. After we invoke the <code class="literal">put()</code> method, an <code class="literal">HTTP PUT</code> request is sent to our RESTful web service and the method we decorated with the <code class="literal">@Put</code> annotation (<code class="literal">createCustomer()</code> in our example) is invoked. There are similar <code class="literal">get()</code>, <code class="literal">post()</code>, and <code class="literal">delete()</code> methods<a id="id1057" class="indexterm"/> we can invoke to send the corresponding HTTP requests to our RESTful web service.</p></div>
<div class="section" title="Working with query and path parameters"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec61"/>Working with query and path parameters</h1></div></div></div><p>In our previous examples, we have been working with a RESTful web service to manage a single <code class="literal">customer</code> object. In real life, this would obviously not be very helpful. The common case is to develop a RESTful web service to handle a collection of objects (customers, in our example). To determine which specific object in the collection we are working with, we can pass parameters to our RESTful web services. There are two types of parameters we can use: query and path.</p><div class="section" title="Query parameters"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec75"/>Query parameters</h2></div></div></div><p>We can add parameters to methods that will handle HTTP requests in our web service. Parameters decorated<a id="id1058" class="indexterm"/> with the <code class="literal">@QueryParam</code> annotation will be retrieved from the request URL.</p><p>The following example illustrates how to use query parameters in our JAX-RS RESTful web services:</p><div class="informalexample"><pre class="programlisting">package com.ensode.queryparams.service;

import com.ensode.queryparams.entity.Customer;
import javax.ws.rs.Consumes;
import javax.ws.rs.DELETE;
import javax.ws.rs.GET;
import javax.ws.rs.POST;
import javax.ws.rs.PUT;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;
import javax.ws.rs.QueryParam;

@Path("customer")
public class CustomerResource {

  private Customer customer;

  public CustomerResource() {
    customer = new Customer(1L, "Samuel",
        "Joseph", "Willow");
  }

  @GET
  @Produces("text/xml")
<span class="strong"><strong>  public Customer getCustomer(@QueryParam("id") Long id) {</strong></span>
    //in a "real" RESTful service, we would retrieve data from a database
    //using the supplied id.

    System.out.println("--- " + this.getClass().getCanonicalName()
        + ".getCustomer() invoked, id = " + id);

    return customer;
  }

  /**
   * Create a new customer
   * @param customer XML representation of the customer to create
   */
  @PUT
  @Consumes("text/xml")
  public void createCustomer(Customer customer) {
    //in a "real" RESTful service, we would parse the XML
    //received in the customer XML parameter, then insert
    //a new row into the database.

    System.out.println("--- " + this.getClass().getCanonicalName()
        + ".createCustomer() invoked");

    System.out.println("customer = " + customer);

  }

  @POST
  @Consumes("text/xml")
  public void updateCustomer(Customer customer) {
    //in a "real" RESTful service, we would parse the XML
    //received in the customer XML parameter, then update
    //a row in the database.

    System.out.println("--- " + this.getClass().getCanonicalName()
        + ".updateCustomer() invoked");

    System.out.println("customer = " + customer);

    System.out.println("customer= " + customer);
  }

  @DELETE
  @Consumes("text/xml")
<span class="strong"><strong>  public void deleteCustomer(@QueryParam("id") Long id) {</strong></span>
    //in a "real" RESTful service, we would invoke
    //a DAO and delete the row in the database with the
    //primary key passed as the "id" parameter.

    System.out.println("--- " + this.getClass().getCanonicalName()
        + ".deleteCustomer() invoked, id = " + id);

    System.out.println("customer = " + customer);
  }
}</pre></div><p>Notice that all we had to do was decorate the parameters with the<code class="literal"> @QueryParam</code> annotation<a id="id1059" class="indexterm"/>. This annotation allows JAX-RS to retrieve any query parameters matching the value of the <a id="id1060" class="indexterm"/>annotation and assign its value to the parameter variable.</p><p>We can add a parameter to the web service's URL just like we pass parameters to any URL:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>curl -XGET -HContent-type:text/xml http://localhost:8080/queryparams/resources/customer?id=1</strong></span>
</pre></div><div class="section" title="Sending query parameters via the JAX-RS client API"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl3sec26"/>Sending query parameters via the JAX-RS client API</h3></div></div></div><p>The JAX-RS client <a id="id1061" class="indexterm"/>API provides an easy and straightforward way of sending query parameters to RESTful web services. The following <a id="id1062" class="indexterm"/>example illustrates how to do this:</p><div class="informalexample"><pre class="programlisting">package com.ensode.queryparamsclient;

import com.ensode.queryparamsclient.entity.Customer;
import javax.ws.rs.client.Client;
import javax.ws.rs.client.ClientBuilder;

public class App {

    public static void main(String[] args) {
        App app = new App();
        app.getCustomer();
    }

    public void getCustomer() {
        Client client = ClientBuilder.newClient();
        Customer customer = client.target(
              "http://localhost:8080/queryparams/resources/customer").
<span class="strong"><strong>                queryParam("id", 1L).</strong></span>
                request().get(Customer.class);

        System.out.println("Received the following customer information:");
        System.out.println("Id: " + customer.getId());
        System.out.println("First Name: " + customer.getFirstName());
        System.out.println("Middle Name: " + customer.getMiddleName());
        System.out.println("Last Name: " + customer.getLastName());
    }
}</pre></div><p>As we can see, all we need to do to pass a parameter is invoke the <code class="literal">queryParam()</code> method<a id="id1063" class="indexterm"/> on the instance of <code class="literal">javax.ws.rs.client.WebTarget</code> returned by invoking the <code class="literal">target()</code> method on our <code class="literal">Client</code> instance. The first argument to this method is the parameter name<a id="id1064" class="indexterm"/> and it must match the value of the <code class="literal">@QueryParam</code> annotation in the web service. The second parameter is the value that we need to pass to the web service. If our web service accepts multiple parameters, we can chain <code class="literal">queryParam()</code> method<a id="id1065" class="indexterm"/> invocations, using one for each parameter that <a id="id1066" class="indexterm"/>our RESTful web service expects.</p></div></div><div class="section" title="Path parameters"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec76"/>Path parameters</h2></div></div></div><p>Another way we can pass parameters to our RESTful web services is via path parameters. The following<a id="id1067" class="indexterm"/> example illustrates how to develop a JAX-RS RESTful web service that accepts path parameters:</p><div class="informalexample"><pre class="programlisting">package com.ensode.pathparams.service;

import com.ensode.pathparams.entity.Customer;
import javax.ws.rs.Consumes;
import javax.ws.rs.DELETE;
import javax.ws.rs.GET;
import javax.ws.rs.POST;
import javax.ws.rs.PUT;
import javax.ws.rs.Path;
import javax.ws.rs.PathParam;
import javax.ws.rs.Produces;

@Path("/customer/")
public class CustomerResource {

  private Customer customer;

  public CustomerResource() {
    customer = new Customer(1L, "William",
        "Daniel", "Graystone");
  }

  @GET
  @Produces("text/xml")
<span class="strong"><strong>  @Path("{id}/")</strong></span>
<span class="strong"><strong>  public Customer getCustomer(@PathParam("id") Long id) {</strong></span>
    //in a "real" RESTful service, we would retrieve data from a database
    //using the supplied id.

    System.out.println("--- " + this.getClass().getCanonicalName()
        + ".getCustomer() invoked, id = " + id);

    return customer;
  }

  @PUT
  @Consumes("text/xml")
  public void createCustomer(Customer customer) {
    //in a "real" RESTful service, we would parse the XML
    //received in the customer XML parameter, then insert
    //a new row into the database.

    System.out.println("--- " + this.getClass().getCanonicalName()
        + ".createCustomer() invoked");

    System.out.println("customer = " + customer);

  }

  @POST
  @Consumes("text/xml")
  public void updateCustomer(Customer customer) {
    //in a "real" RESTful service, we would parse the XML
    //received in the customer XML parameter, then update
    //a row in the database.

    System.out.println("--- " + this.getClass().getCanonicalName()
        + ".updateCustomer() invoked");

    System.out.println("customer = " + customer);

    System.out.println("customer= " + customer);
  }

  @DELETE
  @Consumes("text/xml")
<span class="strong"><strong>  @Path("{id}/")</strong></span>
<span class="strong"><strong>  public void deleteCustomer(@PathParam("id") Long id) {</strong></span>
    //in a "real" RESTful service, we would invoke
    //a DAO and delete the row in the database with the
    //primary key passed as the "id" parameter.

    System.out.println("--- " + this.getClass().getCanonicalName()
        + ".deleteCustomer() invoked, id = " + id);

    System.out.println("customer = " + customer);
  }
}</pre></div><p>Any method that accepts a path parameter must be decorated with the <code class="literal">@Path</code> annotation. The <code class="literal">value</code> attribute of this annotation must be formatted as <code class="literal">"{paramName}/"</code>, where <code class="literal">paramName</code> is the <a id="id1068" class="indexterm"/>parameter the method expects to receive. Additionally, method parameters must be decorated with the <code class="literal">@PathParam</code> annotation<a id="id1069" class="indexterm"/>. The value of the <code class="literal">@PathParam</code> annotation must match the parameter name declared in the <code class="literal">@Path</code> annotation for the method.</p><p>We can pass path parameters from the command line by adjusting our web service's URI as appropriate; for example, to pass an <code class="literal">"id"</code> parameter of <code class="literal">1</code> to the <code class="literal">getCustomer() </code>method (which handles <code class="literal">HTTP GET</code> requests), we could do it from the command line as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>curl -XGET -HContent-type:text/xml http://localhost:8080/pathparams/resources/customer/1</strong></span>
</pre></div><p>This returns the expected output of an XML representation of the <code class="literal">Customer</code> object returned by<a id="id1070" class="indexterm"/> the <code class="literal">getCustomer()</code> method<a id="id1071" class="indexterm"/>, as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;&lt;customer&gt;&lt;firstName&gt;William&lt;/firstName&gt;&lt;id&gt;1&lt;/id&gt;&lt;lastName&gt;Graystone&lt;/lastName&gt;&lt;middleName&gt;Daniel&lt;/middleName&gt;&lt;/customer&gt;</strong></span>
</pre></div><div class="section" title="Sending path parameters via the JAX-RS Client API"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl3sec27"/>Sending path parameters via the JAX-RS Client API</h3></div></div></div><p>Sending path parameters to a <a id="id1072" class="indexterm"/>web service via the JAX-RS client API is easy and straightforward; all we need to do is add a couple of method invocations to<a id="id1073" class="indexterm"/> specify the path parameter and its value. The following example illustrates how to do this:</p><div class="informalexample"><pre class="programlisting">package com.ensode.pathparamsclient;

import com.ensode.pathparamsclient.entity.Customer;
import javax.ws.rs.client.Client;
import javax.ws.rs.client.ClientBuilder;

public class App {

    public static void main(String[] args) {
        App app = new App();
        app.getCustomer();
    }

    public void getCustomer() {
        Client client = ClientBuilder.newClient();
        Customer customer = client.target(
                http://localhost:8080/pathparams/resources/customer").
<span class="strong"><strong>                path("{id}").</strong></span>
<span class="strong"><strong>                resolveTemplate("id", 1L).</strong></span>
                request().get(Customer.class);

        System.out.println("Received the following customer information:");
        System.out.println("Id: " + customer.getId());
        System.out.println("First Name: " + customer.getFirstName());
        System.out.println("Middle Name: " + customer.getMiddleName());
        System.out.println("Last Name: " + customer.getLastName());
    }
}</pre></div><p>In this example, we invoke the <code class="literal">path()</code> method on the instance of <code class="literal">WebTarget</code> returned by <code class="literal">client.target()</code>. This method appends the specified path to our <code class="literal">WebTarget</code> instance; the value of this method must match the value of the <code class="literal">@Path</code> annotation in our RESTful web service.</p><p>After invoking the <code class="literal">path()</code> method<a id="id1074" class="indexterm"/> on our <code class="literal">WebTarget</code> instance, we need to invoke <code class="literal">resolveTemplate()</code>; the first parameter for this method is the name of the parameter (without the curly braces) and the second parameter<a id="id1075" class="indexterm"/> is the value we wish to pass as a parameter to our RESTful web service.</p><p>If we need to pass more than one parameter to one of our web services, we simply need to use the following format for the <code class="literal">@Path</code> parameter at the method level:</p><div class="informalexample"><pre class="programlisting">@Path("/{paramName1}/{paramName2}/")</pre></div><p>Then annotate the <a id="id1076" class="indexterm"/>corresponding method arguments with the <code class="literal">@PathParam</code> annotation, as follows:</p><div class="informalexample"><pre class="programlisting">public String someMethod(@PathParam("paramName1") String param1,
    @PathParam("paramName2") String param2)</pre></div><p>The web service can then be invoked by modifying the web service's URI to pass the parameters in the order specified in the <code class="literal">@Path</code> annotation<a id="id1077" class="indexterm"/>. For example, the following URI would pass the values <code class="literal">1</code> and <code class="literal">2</code> for <code class="literal">paramName1</code> and <code class="literal">paramName2</code>:</p><p>
<code class="literal">http://localhost:8080/contextroot/resources/customer/1/2</code>
</p><p>The previous URI will work both from the command line and through a web service client we have developed with the JAX-RS client API.</p></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec62"/>Summary</h1></div></div></div><p>In this chapter, we discussed how to develop RESTful web services using JAX-RS, a new addition to the Java EE specification.</p><p>We covered how to develop a RESTful web service by adding a few simple annotations to our code. We also explained how to automatically convert data between Java and XML by taking advantage of the Java API for XML Binding (JAXB).</p><p>We also discussed how to develop RESTful web service clients via the JAX-RS client API</p><p>Finally, we covered how to pass parameters to our RESTful web services via the <code class="literal">@PathParam</code> and <code class="literal">@QueryParam</code> annotations.</p></div></body></html>