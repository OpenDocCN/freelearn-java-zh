<html><head></head><body><div class="chapter" title="Chapter&#xA0;4.&#xA0;Scala Collections"><div class="titlepage"><div><div><h1 class="title"><a id="ch04"/>Chapter 4. Scala Collections</h1></div></div></div><p>In the previous chapter, we covered functional programming with Scala and how object-oriented and functional approaches complete each other. We also covered generic classes, which are often used with pattern matching. Finally, we covered how to create user-defined pattern matching and why it is useful.</p><p>In this chapter, we will cover the Scala Collection library. We will start by learning how to work 
<a class="indexterm" id="id176"/>with lists, which will make us familiar with some design principles of the whole collections library. Afterward, we'll generalize to sequences and cover some more relevant data structures. At the end, we'll look at how collections relate to monads and how we can use that knowledge to make some powerful abstractions in our code.
</p><p>Scala's collection library is very rich, being comprised of data structures for very different use cases and performance considerations. It is particularly rich in immutable data structures, which we will be covering in greater detail during this chapter.</p><p>Collections 
<a class="indexterm" id="id177"/>available in the Scala collection library inherit from common high-level abstract classes and traits and, as such, share some common functionalities, which makes working with them easier once you become familiar with certain methods and design principles.
</p><p>By the end of this chapter, you will be able to:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Identify the Scala collections available in the standard library</li><li class="listitem" style="list-style-type: disc">Identify how to abstract sequences by using higher-order functions</li><li class="listitem" style="list-style-type: disc">Implement the important design principles for working with Scala collections</li></ul></div><div class="section" title="Working with Lists"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec20"/>Working with Lists</h1></div></div></div><p>Lists are 
<a class="indexterm" id="id178"/>probably the most commonly used data structures in Scala programs. Learning how to work with lists is important both from a 
<a class="indexterm" id="id179"/>data structure standpoint but also as an entry point to designing programs around recursive data structures.
</p><div class="section" title="Constructing Lists"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec49"/>Constructing Lists</h2></div></div></div><p>In order
<a class="indexterm" id="id180"/> to be able to use l
<code class="literal">ists</code>, one must learn how to construct them. 
<code class="literal">Lists</code> are recursive in nature, and build upon two basic building blocks: 
<code class="literal">Nil</code> (representing the empty list) and 
<code class="literal">::</code> (pronounced cons, from the 
<code class="literal">cons</code> function of most Lisp dialects).
</p><p>We will now create Lists in Scala:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Start the Scala <code class="literal">REPL</code>, which should provide you with a prompt:<div class="informalexample"><pre class="programlisting">$ scala</pre></div></li><li class="listitem">Create a <code class="literal">list</code> of strings using the following:<div class="informalexample"><pre class="programlisting">scala&gt; val listOfStrings = "str1" :: ("str2" :: ("str3" :: Nil))
listOfStrings: List[String] = List(str1, str2, str3)</pre></div></li><li class="listitem">Show<a class="indexterm" id="id181"/> that the <code class="literal">::</code> operation is the right associative by omitting the parentheses and getting the same result:<div class="informalexample"><pre class="programlisting">scala&gt; val listOfStrings = "str1" :: "str2" :: "str3" :: Nil
listOfStrings: List[String] = List(str1, str2, str3)</pre></div></li><li class="listitem">Create lists of different types.</li><li class="listitem">Show that the <code class="literal">apply</code> method of the <code class="literal">List</code> companion object offers a convenient way to create a list from a variable number of arguments:<div class="informalexample"><pre class="programlisting">scala&gt; val listOfStrings = List("str1", "str2", "str3")
listOfStrings: List[String] = List(str1, str2, str3)</pre></div></li></ol></div><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note19"/>Note</h3><p>If you are wondering how is it possible for the 
<code class="literal">::</code> operator to be right-associative, note that the associativity of an operator is determined by the operator's last character. Operators ending in a colon 
<code class="literal">:</code> are right-associative. All other operators are left-associative. Since 
<code class="literal">::</code> ends with a colon, it is right-associative.
</p></div></div></div><div class="section" title="Operations on Lists"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec50"/>Operations on Lists</h2></div></div></div><p>The 
<code class="literal">List</code> class
<a class="indexterm" id="id182"/> provides the 
<code class="literal">head</code>, 
<code class="literal">tail,</code> and 
<code class="literal">isEmpty</code> methods. 
<code class="literal">head</code> returns the first element of the list, while the 
<code class="literal">tail</code> method returns the list without its first element. The 
<code class="literal">isEmpty</code> method
<a class="indexterm" id="id183"/> returns 
<code class="literal">true</code> if the list is empty, and 
<code class="literal">false</code> otherwise. 
<code class="literal">head</code> and 
<code class="literal">tail</code> are only defined for non-empty lists and throw an exception on empty ones.
</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note20"/>Note</h3><p>Calling 
<code class="literal">head</code> and 
<code class="literal">tail</code> in empty lists (such as 
<code class="literal">Nil.head</code> and 
<code class="literal">Nil.tail</code>) throws an exception.
</p><p>To implement the 
<code class="literal">evenInts</code> method with the following signature, use the following code:
</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>def evenInts(l: List[Int]): List[Int]</strong></span>
</pre></div></div></div><p>The 
<a class="indexterm" id="id184"/>method should return a list with all even integers of list l. Use the 
<code class="literal">head</code>, 
<code class="literal">tail,</code> and 
<code class="literal">isEmpty</code> methods of 
<code class="literal">List</code>. A possible solution for this problem is the following:
</p><div class="informalexample"><pre class="programlisting">def evenInts(l: List[Int]): List[Int] = {
  if (l.isEmpty) l
  else if (l.head % 2 == 0) l.head :: evenInts(l.tail)
  else evenInts(l.tail)
}</pre></div></div><div class="section" title="Pattern Matching on Lists"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec51"/>Pattern Matching on Lists</h2></div></div></div><p>Pattern matching is
<a class="indexterm" id="id185"/> a powerful mechanism for checking a value against a pattern in Scala and provides an idiomatic way to decompose lists. You can pattern match on 
<code class="literal">::</code>, which mimics the list structure, or on 
<code class="literal">List(...)</code> to match all of the list's values.
</p><p>Let's experiment with pattern matching in the Scala 
<code class="literal">REPL</code>. Make sure to show examples of both pattern matching with 
<code class="literal">List(...)</code> and with 
<code class="literal">::</code>.
</p><p>One possible example to show is:</p><div class="informalexample"><pre class="programlisting">val l = List(1, 2, 3, 4, 5)
List(a, b, c, d, e) = l
val h :: t = l</pre></div><p>Using 
<a class="indexterm" id="id186"/>pattern matching is generally more idiomatic than using 
<code class="literal">if</code> and 
<code class="literal">else</code> to structure programs.
</p><p>Now, we will
<a class="indexterm" id="id187"/> implement the method 
<code class="literal">evenInts</code> again. This time, we will not use the 
<code class="literal">head</code>, 
<code class="literal">tail,</code> and 
<code class="literal">isEmpty</code> methods of 
<code class="literal">List</code>: 
</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Open the file where we have written the <code class="literal">evenInts</code> method.</li><li class="listitem">Do not use the <code class="literal">head</code>, <code class="literal">tail</code>, and <code class="literal">isEmpty</code> methods of <code class="literal">list</code>.</li><li class="listitem">A possible solution for this problem is the following:<div class="informalexample"><pre class="programlisting">def evenInts(l: List[Int]): List[Int] = l match {
  case h :: t if h % 2 == 0 =&gt; h :: evenInts(t)
  case _ :: t =&gt; evenInts(t)
  case Nil =&gt; Nil
}</pre></div></li></ol></div></div><div class="section" title="First-Order Methods on List"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec52"/>First-Order Methods on List</h2></div></div></div><p>The 
<code class="literal">List</code> class provides various helpful first-order methods. A first-order method 
<a class="indexterm" id="id188"/>is one
<a class="indexterm" id="id189"/> that does not take a function as an argument. We'll cover some of the most-used methods in the following subsection.
</p></div><div class="section" title="Appending and Concatenation"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec53"/>Appending and Concatenation</h2></div></div></div><p>We've learned about 
<code class="literal">::</code> to append an element at the head of a list. If we want to 
<a class="indexterm" id="id190"/>append an element at the end of a list, we can use the 
<code class="literal">:+</code> operator. In order to concatenate two lists, we can use the 
<code class="literal">:::</code> operator. Note, however, that the 
<code class="literal">:+</code> operator has a time complexity of 
<code class="literal">O(n)</code>, where 
<code class="literal">n</code> is the number of 
<a class="indexterm" id="id191"/>elements in the list. The 
<code class="literal">:::</code> operator has a time complexity of 
<code class="literal">O(n)</code>, 
<code class="literal">n</code> being the number of elements in the first list. Note that the 
<code class="literal">:::</code> operator also has right-associativity, like the 
<code class="literal">::</code> operator.
</p><p>Example code:</p><div class="informalexample"><pre class="programlisting">scala&gt; val a = List(1, 2, 3)
a: List[Int] = List(1, 2, 3)

scala&gt; val b = List(4, 5, 6)
b: List[Int] = List(4, 5, 6)
scala&gt; val c = a ::: b
c: List[Int] = List(1, 2, 3, 4, 5, 6)

scala&gt; val d = b :+ 7
d: List[Int] = List(4, 5, 6, 7)</pre></div></div><div class="section" title="Taking the Length of a List"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec54"/>Taking the Length of a List</h2></div></div></div><p>Taking the
<a class="indexterm" id="id192"/> length of a list is a useful operation. All lists have a definite size and, as such, they provide the 
<code class="literal">length</code> method that returns their size. We'll be covering potentially infinite data structures in another topic.
</p><p>Note that 
<code class="literal">length</code> is an expensive operation on lists, as it needs to traverse the whole list 
<a class="indexterm" id="id193"/>to find its end, taking time proportional to the number of elements in the list.
</p></div><div class="section" title="Reversing a List"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec55"/>Reversing a List</h2></div></div></div><p>If you
<a class="indexterm" id="id194"/> require frequent access to the end of a list, it is convenient to reverse it once and work with the result. The 
<code class="literal">reverse</code> method creates a new list with the elements of the original list reversed. The reverse method has linear complexity.
</p></div><div class="section" title="Prefixes and Suffixes"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec56"/>Prefixes and Suffixes</h2></div></div></div><p>The 
<code class="literal">take</code> and 
<code class="literal">drop</code> methods of 
<code class="literal">List</code> return arbitrary prefixes or suffixes of a list. They 
<a class="indexterm" id="id195"/>both take an integer as an argument: the number of 
<a class="indexterm" id="id196"/>elements to take or drop, respectively.
</p><p>Example code:</p><div class="informalexample"><pre class="programlisting">scala&gt; val a = List(1, 2, 3, 4, 5)
a: List[Int] = List(1, 2, 3, 4, 5)

scala&gt; val b = a.take(2)
b: List[Int] = List(1, 2)

scala&gt; val c = a.drop(2)
c: List[Int] = List(3, 4, 5)</pre></div></div><div class="section" title="Element Selection"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec57"/>Element Selection</h2></div></div></div><p>Even though it is 
<a class="indexterm" id="id197"/>not a common operation for lists, the 
<code class="literal">List</code> class supports random element selection through its apply method:
</p><div class="informalexample"><pre class="programlisting">scala&gt; val a = List(1, 2, 3, 4, 5)
a: List[Int] = List(1, 2, 3, 4, 5)

scala&gt; a.apply(2)
res0: Int = 3</pre></div><p>Since apply
<a class="indexterm" id="id198"/> is implicitly inserted when an object appears in the function position in a method call, we can also do:
</p><div class="informalexample"><pre class="programlisting">scala&gt; a(2)
res1: Int = 3</pre></div></div><div class="section" title="Display"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec58"/>Display</h2></div></div></div><p>Use 
<code class="literal">toString</code> to get
<a class="indexterm" id="id199"/> the canonical string representation of a list:
</p><div class="informalexample"><pre class="programlisting">scala&gt; val a = List(1, 2, 3, 4, 5)
a: List[Int] = List(1, 2, 3, 4, 5)

scala&gt; a.toString
res0: String = List(1, 2, 3, 4, 5)</pre></div><p>The 
<code class="literal">mkString</code> method is a 
<a class="indexterm" id="id200"/>bit more flexible as it allows you to specify the prefix to print before all elements, the separator to print between elements, and the suffix to print after all elements. The 
<code class="literal">mkString</code> method has two overloaded variants which allow you to drop the prefix and suffix arguments if they're empty strings. You can also call 
<code class="literal">mkString</code> without arguments if you want an empty string as a separator:
</p><div class="informalexample"><pre class="programlisting">scala&gt; a.mkString("[", ", ", "]")
res1: String = [1, 2, 3, 4, 5]
scala&gt; a.mkString(", ")
res2: String = 1, 2, 3, 4, 5

scala&gt; a.mkString
res3: String = 12345</pre></div><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note21"/>Note</h3><p>Refer to the Scaladoc for the 
<code class="literal">scala.collection.</code>
<code class="literal">immutable.List</code> class at 
<a class="ulink" href="https://www.scala-lang.org/api/current/scala/collection/immutable/List.html">https://www.scala-lang.org/api/current/scala/collection/immutable/List.html</a>. If you are interested in other useful methods, you can take a look at what the class has to offer.
</p></div></div></div><div class="section" title="Activity: Creating a New Mode for Chatbot Using Lists"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec59"/>Activity: Creating a New Mode for Chatbot Using Lists</h2></div></div></div><p>In this activity, we 
<a class="indexterm" id="id201"/>will be building a new mode for the Chatbot that we created on the first day of this book. This new mode will be capable of keeping and updating a 
<code class="literal">todo</code> list of entries. We will be using 
<code class="literal">lists</code> as the primary data structure to hold our information, and we want to support at least the following commands:
</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">todo list</code>: Lists all current items the bot is currently aware of.</li><li class="listitem" style="list-style-type: disc"><code class="literal">todo new &lt;item description&gt;</code>: Inserts a new TODO item with the provided description.</li><li class="listitem" style="list-style-type: disc"><code class="literal">todo done &lt;item number&gt;:</code> Removes the item numbered &lt;item number&gt; from the list. The number of the item should be shown when using <code class="literal">todo</code> list.</li><li class="listitem" style="list-style-type: disc"><code class="literal">todo done &lt;item description&gt;</code>: Removes the item whose description matches &lt;item description&gt;. </li></ul></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Start by defining a new class that extends <code class="literal">ChatbotMode</code>. It's enough to model our TODO list items as strings, so our new mode could just be defined as <code class="literal">case class TodoList(todos: List[String]) extends ChatbotMode</code>.</li><li class="listitem">Implement the required <code class="literal">process</code> method. Regexes might come in handy to parse the <code class="literal">line</code> argument. Depending on the provided input, we want to create a new instance of <code class="literal">TodoList</code> with the value of <code class="literal">todos</code> possibly modified. Return <code class="literal">None</code> in invalid inputs (unrecognizable commands or attempts to delete a non-existent item, for example).</li><li class="listitem">Experiment with your newly defined mode in the previously implemented <a class="indexterm" id="id202"/>Chatbot. See how well it plays with the other already defined modes.</li></ol></div><p>In this section, we covered lists in the perspective of one of the major workhorses of Scala programs. We've learned the operations we can perform on lists and covered some idiomatic ways to handle lists in Scala code.</p></div></div></div>
<div class="section" title="Abstracting on Sequences"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec21"/>Abstracting on Sequences</h1></div></div></div><p>All Scala 
<a class="indexterm" id="id203"/>collections descend from a common trait called 
<code class="literal">Traversable</code>. The design adopted for Scala collections allows one 
<a class="indexterm" id="id204"/>to use higher-order functions similarly in nearly all collections, with proper return types in specific instances. Treating collections as sequences, or as containers of elements, allows one to use different data structures seamlessly.
</p><div class="section" title="The Traversable Trait"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec60"/>The Traversable Trait</h2></div></div></div><p>At the root
<a class="indexterm" id="id205"/> of the collections hierarchy is the 
<code class="literal">Traversable</code> trait. The 
<code class="literal">Traversable</code> trait has a single abstract method:
</p><div class="informalexample"><pre class="programlisting">def foreach[U](f: Elem =&gt; U)</pre></div><p>The implementation of this method is sufficient for the 
<code class="literal">Traversable</code> trait to provide a series of useful higher-order methods.
</p><p>We would like to focus on the 
<code class="literal">map</code> operations. The 
<code class="literal">map</code> method takes a function and applies it to every element of the collection.
</p><p>Let's experiment with the 
<code class="literal">map</code> method in the Scala 
<code class="literal">REPL</code> and show how it applies to different types of collections. For now, create a function that multiplies an integer by 2 and apply it to a 
<code class="literal">List</code> and an 
<code class="literal">Array</code>:
</p><div class="informalexample"><pre class="programlisting">scala&gt; def f(i: Int) = i * 2
f: (i: Int)Int

scala&gt; val l = List(1, 2, 3, 4).map(f)
l: List[Int] = List(2, 4, 6, 8)

scala&gt; val a = Array(1, 2, 3, 4).map(f)
a: Array[Int] = Array(2, 4, 6, 8)</pre></div><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note22"/>Note</h3><p>Note that the return type of the 
<code class="literal">map</code> method varies according to the collection type it is called on.
</p></div></div><p>The 
<code class="literal">flatMap</code> is 
<a class="indexterm" id="id206"/>slightly different. It takes a function from the type of elements in the collection to another collection which is then "flattened" in the returned collection.
</p><p>As an example for the 
<code class="literal">flatMap</code> method, consider a function that takes an integer and creates a list of the integer size filled with 1. See what the return value is when that function is applied to a 
<code class="literal">list</code> via 
<code class="literal">map</code> and 
<code class="literal">flatMap</code>:
</p><div class="informalexample"><pre class="programlisting">scala&gt; def f(v: Int): List[Int] = if (v == 0) Nil else 1 :: f(v - 1)
f: (v: Int)List[Int]

scala&gt; val l = List(1, 2, 3, 4).map(f)
l: List[List[Int]] = List(List(1), List(1, 1), List(1, 1, 1), List(1, 1, 1, 1))

scala&gt; val ll = List(1, 2, 3, 4).flatMap(f)
ll: List[Int] = List(1, 1, 1, 1, 1, 1, 1, 1, 1, 1)</pre></div><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note23"/>Note</h3><p>Note how the lists are flattened in the 
<code class="literal">flatMap</code> call.
</p></div></div><p>These kind of operations closely resemble those of a m
<code class="literal">onad</code>.
</p><p>A 
<code class="literal">monad</code>
<a class="indexterm" id="id207"/> is a wrapper and a mechanism of sequencing operations. It provides two basic operations: 
<code class="literal">identity</code>, to wrap a value in a 
<code class="literal">monad</code>, and 
<code class="literal">bind</code>, to transform the underlying value of a m
<code class="literal">onad</code>. 
<code class="literal">Monads</code> will be covered in greater detail in 
<a class="link" href="ch07.html" title="Chapter 7. Functional Idioms">Chapter 7</a>, 
<span class="emphasis"><em>Functional Idioms</em></span>, so don't worry if you don't quite grasp all the intricacies of them just yet.
</p><p>The monadic mechanism
<a class="indexterm" id="id208"/> of chaining 
<code class="literal">flatMaps</code> is so common that Scala provides a special syntax for it in for-comprehensions.
</p><p>Monadic operations provide the programmer with a way to abstract and chain computations, where 
<code class="literal">map</code> and 
<code class="literal">flatMap</code> are the glue. The fact that 
<code class="literal">map</code> and 
<code class="literal">flatMap</code> are higher-order functions, in other words, they take other functions as arguments, allows the programmer to reuse components (
<code class="literal">functions</code>) in their code.
</p><p>Other important higher-order functions provided by the collections API are 
<code class="literal">folds</code>. Generically, folds provide ways to combine elements of a container with some binary operator. Folds are different from reduces in the sense that with fold you provide a starter value, whereas with 
<code class="literal">reduce</code> you only use the elements of the container. The 
<code class="literal">*Left</code> and 
<code class="literal">*Right</code> variants determine the order in which the elements are combined.
</p><p>We will now implement sum on a List by using foldLeft. A possible solution to this problem is as follows:</p><div class="informalexample"><pre class="programlisting">def add(a: Int, b: Int) = a + b
def sum(l: List[Int]) = l.foldLeft(0)(add)
val res = sum(List(1, 2, 3, 4))
// Returns 10</pre></div></div><div class="section" title="Iterators"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec61"/>Iterators</h2></div></div></div><p>Right 
<a class="indexterm" id="id209"/>beneath the 
<code class="literal">Traversable</code> trait in the Scala collections hierarchy is the 
<code class="literal">Iterable</code> trait. An 
<code class="literal">Iterable</code> is a trait with a single abstract method:
</p><div class="informalexample"><pre class="programlisting">def iterator: Iterator[A]</pre></div><p>An 
<code class="literal">Iterator</code> provides
<a class="indexterm" id="id210"/> a method to step through the collection's elements one by one. One important thing to note is that an 
<code class="literal">Iterator</code> is mutable, as most of its operations change its state. Namely, calling 
<code class="literal">next</code> on an 
<code class="literal">iterator</code> changes the in-place position of its 
<code class="literal">head</code>. Since an 
<code class="literal">Iterator</code> is simply something with 
<code class="literal">next</code> and 
<code class="literal">hasNext</code> methods, it is possible to create an iterator that isn't backed by any collection. Since all Scala collections also descend from 
<code class="literal">Iterable</code>, all of them have an 
<code class="literal">iterator</code> method to return an 
<code class="literal">Iterator</code> for its elements.
</p></div><div class="section" title="Streams"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec62"/>Streams</h2></div></div></div><p>
<span class="strong"><strong>Streams</strong></span>
<a class="indexterm" id="id211"/>provide an implementation of lazy lists where elements are only evaluated when they are needed. Streams also have a recursive structure, similar to 
<code class="literal">Lists,</code> based on the 
<code class="literal">#::</code> and 
<code class="literal">Stream.empty</code> building blocks (analogous to 
<code class="literal">::</code> and 
<code class="literal">Nil</code>). The biggest difference is that 
<code class="literal">#::</code> is lazy, and will only evaluate the tail when elements from it are needed. One important feature of Streams is that they're memoized, so values won't be recomputed if they were already computed once. The disadvantage of this is that if you keep 
<a class="indexterm" id="id212"/>hold of a reference to the head of a 
<code class="literal">Stream</code>, you will keep references to all the elements of the 
<code class="literal">Stream</code> computed so far.
</p></div><div class="section" title="Activity: Implementing Fibonacci Series Using Streams and Iterators"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec63"/>Activity: Implementing Fibonacci Series Using Streams and Iterators</h2></div></div></div><p>In
<a class="indexterm" id="id213"/> mathematics, the sequence known as Fibonacci is defined by the number which generated by adding the two integers prior to the number. By definition, the first two integers in the series should be 1 and 1, or 0 and 1.
</p><p>Implement the infinite sequence of Fibonacci numbers using Streams and Iterators:</p><div class="informalexample"><pre class="programlisting">lazy val fibIterator: Iterator[BigInt]
lazy val fibStream: Stream[BigInt]</pre></div><p>One possible solution for these implementations is the following:</p><div class="informalexample"><pre class="programlisting">lazy val fibStream: Stream[BigInt] = BigInt(0) #:: BigInt(1) #:: 
fibStream.zip(fibStream.tail).map { n =&gt; n._1 + n._2 }
lazy val fibIterator = new Iterator[BigInt] {
  var v1 = 0
  var v2 = 1
  val hasNext = true
  def next = {
    val res = v1
    v1 = v2
    v2 = res + v1
    res
  }
}</pre></div><p>In this section, we've covered 
<code class="literal">Traversables</code> as an abstract way to use and reason about collections in Scala. We also covered Iterators and Streams and their usefulness in implementing potentially infinite sequences.
</p></div></div>
<div class="section" title="Other Collections"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec22"/>Other Collections</h1></div></div></div><p>Now that we've covered the List and some relevant 
<code class="literal">Traversables</code> in the Scala standard library, we should also visit some other useful collections Scala provides. Even though this section has less theoretical material, this means that we'll have more time on the final activities of the chapter.
</p><div class="section" title="Sets"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec64"/>Sets</h2></div></div></div><p>
<code class="literal">Sets</code> are 
<code class="literal">Iterables</code> that
<a class="indexterm" id="id214"/> contain no duplicate elements. The 
<code class="literal">Set</code> class 
<a class="indexterm" id="id215"/>provides methods to check for the inclusion of an element in the collection, as well as combining different collections. Note that since 
<code class="literal">Set</code> inherits from 
<code class="literal">Traversable</code>, you can apply all the higher-order functions we've seen previously on it. Due to the nature of its 
<code class="literal">apply</code> method, a 
<code class="literal">Set</code> can be seen as a function of type 
<code class="literal">A =&gt;</code>
<code class="literal">Boolean</code>, which returns 
<code class="literal">true</code> if the element is present in the set, and 
<code class="literal">false</code> otherwise.
</p></div><div class="section" title="Tuples"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec65"/>Tuples</h2></div></div></div><p>A tuple is a class 
<a class="indexterm" id="id216"/>capable of containing an arbitrary number of
<a class="indexterm" id="id217"/> elements of different types. A tuple is created by enclosing its elements in parentheses. A tuple is typed according to the type of its elements.
</p><p>Let's now create tuples in REPL and access their elements by following these steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Create some tuples in the <code class="literal">REPL</code> and access their elements.</li><li class="listitem">Observe <a class="indexterm" id="id218"/>the type of the tuples created, and how it depends on the enclosing elements' types.</li><li class="listitem">Use pattern matching as a way to destructure tuples.</li></ol></div><p>The full code looks as follows:</p><div class="informalexample"><pre class="programlisting">scala&gt; val tup = (1, "str", 2.0)
tup: (Int, String, Double) = (1,str,2.0)

scala&gt; val (a, b, c) = tup
a: Int = 1
b: String = str
c: Double = 2.0

scala&gt; tup._1
res0: Int = 1

scala&gt; tup._2
res1: String = str

scala&gt; tup._3
res2: Double = 2.0

scala&gt; val pair = 1 -&gt; "str"
pair: (Int, String) = (1,str)</pre></div></div><div class="section" title="Maps"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec66"/>Maps</h2></div></div></div><p>A 
<code class="literal">Map</code> is 
<a class="indexterm" id="id219"/>an 
<code class="literal">Iterable</code> of tuples of size two (pairs of key/values), which
<a class="indexterm" id="id220"/> are also called mappings or associations. A 
<code class="literal">Map</code> can't have repeated keys. One interesting fact about maps in Scala is that 
<code class="literal">Map[A, B]</code> extends 
<code class="literal">PartialFunction[A, B]</code>, so you can use a 
<code class="literal">Map</code> in places where you need a 
<code class="literal">PartialFunction</code>.
</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note24"/>Note</h3><p>For more information, refer to the Scaladoc of the Map trait here: 
<a class="ulink" href="https://www.scala-lang.org/api/current/scala/collection/Map.html">https://www.scala-lang.org/api/current/scala/collection/Map.html</a>.
</p></div></div></div><div class="section" title="Mutable and Immutable Collections"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec67"/>Mutable and Immutable Collections</h2></div></div></div><p>So far, we've been covering mostly immutable collections (with the exception of 
<code class="literal">Iterators</code>, which 
<a class="indexterm" id="id221"/>are inherently mutable since most operations over it change its state—do note that iterators 
<a class="indexterm" id="id222"/>obtained from the 
<code class="literal">iterator</code> method of Scala collections are not expected to mutate the underlying collection). It is important to note, however, that Scala also provides a set of mutable collections in the 
<code class="literal">scala.collection.mutable</code> package. Mutable collections provide operations to change the collection in place.
</p><p>A useful 
<a class="indexterm" id="id223"/>convention for using both immutable and 
<a class="indexterm" id="id224"/>mutable collections in the same place is to import the 
<code class="literal">scala.collection.mutable</code> package and prefix collection declaration with the mutable keyword, which is 
<code class="literal">Map</code> vs 
<code class="literal">mutable.Map</code>.
</p><p>The following code shows the difference between the immutable and mutable Maps of Scala, showing that the latter has an 
<code class="literal">update</code> method that changes the collection in place:
</p><div class="informalexample"><pre class="programlisting">scala&gt; import scala.collection.mutable
import scala.collection.mutable

scala&gt; val m = Map(1 -&gt; 2, 3 -&gt; 4)
m: scala.collection.immutable.Map[Int,Int] = Map(1 -&gt; 2, 3 -&gt; 4)

scala&gt; val mm = mutable.Map(1 -&gt; 2, 3 -&gt; 4)
mm: scala.collection.mutable.Map[Int,Int] = Map(1 -&gt; 2, 3 -&gt; 4)

scala&gt; mm.update(3, 5)

scala&gt; mm
res1: scala.collection.mutable.Map[Int,Int] = Map(1 -&gt; 2, 3 -&gt; 5)

scala&gt; m.update(3, 5)
&lt;console&gt;:14: error: value update is not a member of scala.collection.immutable.Map[Int,Int]
       m.update(3, 5)
         ^

scala&gt; m.updated(3, 5)
res3: scala.collection.immutable.Map[Int,Int] = Map(1 -&gt; 2, 3 -&gt; 5)

scala&gt; m
res4: scala.collection.immutable.Map[Int,Int] = Map(1 -&gt; 2, 3 -&gt; 4)</pre></div></div><div class="section" title="Activity: Implementing the Tower of Hanoi Problem"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec68"/>Activity: Implementing the Tower of Hanoi Problem</h2></div></div></div><p>We want to 
<a class="indexterm" id="id225"/>create a solver for the Tower of Hanoi problem. If you 
<a class="indexterm" id="id226"/>are not familiar with the puzzle, visit the Wikipedia page at 
<a class="ulink" href="https://en.wikipedia.org/wiki/Tower_of_Hanoi">https://en.wikipedia.org/wiki/Tower_of_Hanoi</a> This is a good entry point for it:
</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Implement<a class="indexterm" id="id227"/> the <code class="literal">paths</code><code class="literal">inner</code> function of the following function:<div class="informalexample"><pre class="programlisting">def path(from: Int, to: Int, graph: Map[Int, List[Int]]): List[Int] = {
  def paths(from: Int): Stream[List[Int]] = ???
  paths(from).dropWhile(_.head != to).head.reverse
}</pre></div><p>The 
<code class="literal">path</code> function should return the shortest path from the 
<code class="literal">from</code> node to the 
<code class="literal">to</code> node in the 
<code class="literal">graph </code>graph. The 
<code class="literal">graph</code> is defined as an adjacency list 
<a class="indexterm" id="id228"/>encoded as a 
<code class="literal">Map[Int, List[Int]]</code>. The 
<code class="literal">path's</code>
<code class="literal">inner</code> function should return a 
<code class="literal">Stream</code> of paths in increasing length (in a breadth-first search manner).
</p></li><li class="listitem">Implement<a class="indexterm" id="id229"/> the <code class="literal">nextHanoi</code> function:<div class="informalexample"><pre class="programlisting">type HanoiState = (List[Int], List[Int], List[Int])
def nextHanoi(current: HanoiState): List[HanoiState]</pre></div><p>The 
<code class="literal">nextHanoi</code> function should return a list of valid states one can achieve from the current 
<code class="literal">HanoiState</code>. For example: 
<code class="literal">nextHanoi((List(1, 2, 3), Nil, Nil))</code> should return 
<code class="literal">List((List</code>
<code class="literal">(2, 3),List(1),List()), (List(2, 3),List(),List(1)))</code>.
</p></li><li class="listitem">Generalize the previously implemented path method to be parameterized on the type of state we're operating on:<div class="informalexample"><pre class="programlisting">def genericPath[A](from: A, to: A, nextStates: A =&gt; List[A]): List[A] = {
 def paths(current: A): Stream[List[A]] = ???
  paths(from).dropWhile(_.head != to).head.reverse
}</pre></div></li><li class="listitem">With this <a class="indexterm" id="id230"/>new implementation, you should be able to solve the Tower of Hanoi problem by calling, for example:<div class="informalexample"><pre class="programlisting">val start = (List(1, 2, 3), Nil, Nil)
val end = (Nil, Nil, List(1, 2, 3))
genericPath(start, end, nextHanoi)</pre></div></li><li class="listitem">A possible implementation of the proposed activity is the following:<div class="informalexample"><pre class="programlisting">// Does not avoid already visited nodes
def path(from: Int, to: Int, graph: Map[Int, List[Int]]): List[Int] = {
  def paths(current: Int): Stream[List[Int]] = {
    def bfs(current: Stream[List[Int]]): Stream[List[Int]] = {
      if (current.isEmpty) current
      else current.head #:: bfs(current.tail #::: graph(current.head.head).map(_ :: current.head).toStream)
    }
 
    bfs(Stream(List(current)))
  }
 
  paths(from).dropWhile(_.head != to).head.reverse
}
 
type HanoiState = (List[Int], List[Int], List[Int])
 
def nextHanoi(current: HanoiState): List[HanoiState] = {
  def setPile(state: HanoiState, i: Int, newPile: List[Int]): HanoiState = i match {
…
…
 genericPath(start, end, nextHanoi).size</pre></div></li></ol></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec23"/>Summary</h1></div></div></div><p>In this chapter, we covered the Scala Collection library. We covered how to work with lists, which will make us familiar with some design principles of the whole collections library. We also covered how to generalize to sequences and covered some more relevant data structures. Finally, we also covered how collections relate to monads and how we can use that knowledge to use some powerful abstractions in our code.</p><p>In the next chapter, we will cover the 
<code class="literal">type</code> system and polymorphism. We will also cover the different types of variance, which provides a way to constrain parameterized types. Finally, we will cover some advanced 
<code class="literal">types</code> like abstract type members, option, and so on.
</p></div></body></html>