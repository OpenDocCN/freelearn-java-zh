<html><head></head><body><div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Passing Data Between the View and the Controller</h1>
                </header>
            
            <article>
                
<p class="mce-root">In this chapter, we will learn about creating HTML forms for data acquisition. Once the data is acquired, we will then examine it. Lastly, we will examine the types of fields used to store the data.</p>
<p class="mce-root">An HTML form or web form is a document designed to collate data from a web page so that it can be stored or sent to a server for processing. These forms use different types of elements such as checkboxes, radio buttons, and text fields to accept various types of numerical or textual data. They can also include interactive elements such as buttons.</p>
<p>By the end of this chapter, you will be able to:</p>
<ul>
<li>Create HTML forms to acquire user input</li>
<li>Interpret user input in your Spring controller</li>
<li>Examine the data entered into a form</li>
<li>Explain different kinds of fields to enter information in the browser</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Form Handling</h1>
                </header>
            
            <article>
                
<p>When using web applications, there is usually a way to enter data. For example, an address book application would allow the user to enter contact information into a form and to store the input in a database. Data that is entered into a form is usually made up of pieces of information that are related to one another. For example, you could think of personal data, an address, or a bank account. HTML offers a construct called forms to allow the update or the input of data.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">HTML Forms</h1>
                </header>
            
            <article>
                
<p>The following snippet shows a very simple HTML form:</p>
<pre>&lt;html&gt;<br/>  &lt;head&gt;<br/>    &lt;title&gt;Simple Form Page<br/>    &lt;/title&gt;<br/>  &lt;/head&gt;<br/>  &lt;body&gt;<br/>    &lt;form method="post"&gt;<br/>      &lt;p&gt;Please enter your given name:<br/>        &lt;input type="text" name="givenname"/&gt;<br/>      &lt;/p&gt;<br/>      &lt;p&gt;<br/>        &lt;input type="Submit" value="Send"/&gt;<br/>     &lt;/p&gt;<br/>   &lt;/form&gt;<br/>  &lt;/body&gt;<br/>&lt;/html&gt;</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Post Data Handling</h1>
                </header>
            
            <article>
                
<p>When data is entered into a web page, it has to be transmitted to the server for further processing somehow. For this purpose, the HTTP protocol that is used for the communication between the browser; and the server implements a method to achieve this task.</p>
<p>When a form is submitted, the browser will generate a so-called request that contains all entered data as key-value pairs in the body of the request.</p>
<p>For example, if <kbd>title</kbd> has a value of My First Blog Post and <kbd>content</kbd> is set to <kbd>Hello World</kbd>, the request contains the following body:</p>
<pre>title=My+First+Blog+Post&amp;content=Hello+World</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Creating a Form Template</h1>
                </header>
            
            <article>
                
<p>Since we are using Thymeleaf to render the HTML page, we need a way to display data from the model while the view is rendered. On the other hand, the values that are submitted have to become part of the model that is processed by the controller.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Simple Input Field</h1>
                </header>
            
            <article>
                
<p>Let's say you want to ask for the given title of a blog post. In this case, you would define your input field as in the following snippet, which is an excerpt from the file present at  <a href="https://bit.ly/2D6fkpQ">https://bit.ly/2D6fkpQ</a>:</p>
<pre>&lt;input type="text"<br/>       id="title"<br/>       name="title"<br/>       th:value="${title}"&gt;</pre>
<p>This will set the model attribute named title as the value of the input field. Upon submission, a request parameter also named title will be passed to the controller.</p>
<div class="mce-root packt_tip"><br/>
In this case, you are using <kbd>th:value</kbd> or <kbd>th:text</kbd>, depending on the kind of input field you are using. For example, an <kbd>&lt;input&gt;</kbd> field expects the value to be present in the value attribute, while a <kbd>&lt;textarea&gt;</kbd> requires the pre-defined value to be present as its content.</div>
<p>The controller is now able to access the submitted value as a request parameter:</p>
<pre>@PostMapping("create")<br/>public void createFromRequestParam(<br/>    @RequestParam String title) {<br/>    log.info("The title is " + title);<br/>}</pre>
<p>Adding <kbd>required = false</kbd> to the parameter reference avoids an error being thrown when the parameter is missing from the request.</p>
<p>You can find the source of the full class in <a href="https://bit.ly/2Fx6rbI">https://bit.ly/2Fx6rbI</a> file.</p>
<p>This is a very cumbersome and error-prone method since you have to add a lot of attributes manually and are required to repeat the name of the field multiple times.</p>
<p>Fortunately, there is an easier way to pass the model or its attributes between the controller and the view in both directions, as we will see soon.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Implementing Thymeleaf Form Syntax</h1>
                </header>
            
            <article>
                
<p>The aim is to implement the Thymeleaf Form Syntax on a website.</p>
<p>The steps for completion are as follows:</p>
<ol>
<li class="mce-root">Open the project located at <a href="https://bit.ly/2p38GIR">https://bit.ly/2p38GIR</a>.</li>
<li class="mce-root">Open the <kbd>BlogPostController</kbd> class and insert the following handling method:</li>
</ol>
<pre style="padding-left: 60px">@PostMapping("create-multiple-values")<br/>public ModelAndView createBlogPostFromMultipleValues(<br/>  @RequestParam(name = "title")<br/>  String title,<br/>  @RequestParam(name = "slug")<br/>  String slug,<br/>  @RequestParam(name = "content")<br/>  String content,<br/>  @RequestParam(name = "visible", defaultValue = "visible")<br/>  boolean visible) {<br/>  BlogPost createdBlogPost = createBlogPost(title,<br/>                                            slug,<br/>                                            content,<br/>                                            visible);<br/>  return new ModelAndView(<br/>               "blogposts/show",<br/>               "blogPost",<br/>               createdBlogPost);<br/>}</pre>
<ol start="3">
<li>Open the <kbd>src/main/resource/templates/form-multiple-values.html</kbd> file and insert the following form definition:</li>
</ol>
<pre style="padding-left: 60px">&lt;form action="#" th:action="@{/blogposts/create-multiple<br/>values}" method="post"&gt;<br/>  &lt;div class="form-group"&gt;<br/>    &lt;label for="title"&gt;Title&lt;/label&gt;<br/>    &lt;input type="text"<br/>           // […]<br/>  &lt;button type="submit" class="btn btn-primary"&gt;Submit&lt;/<br/>button&gt;<br/>&lt;/form&gt;</pre>
<div class="packt_infobox"><br/>
Go to <a href="https://bit.ly/2xec8E6">https://bit.ly/2xec8E6</a> to access the complete code for the form definition code example.</div>
<ol start="4">
<li>Start the application by using the <kbd>mvnw spring-boot:run</kbd> command.</li>
</ol>
<ol start="5">
<li>Use your browser to open the URL <kbd>http://localhost:8080/blogposts/new-multiple-values</kbd> to view the following output:</li>
</ol>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/96b8da72-1ee8-4e7c-b0a0-0af691f5a5a2.png" style="width:21.92em;height:23.08em;" width="525" height="551"/></div>
<ol start="6">
<li>Now, enter the details and click on <span class="packt_screen">Submit</span>.</li>
<li>You should now see the following page, summarizing the values you've entered:</li>
</ol>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/2c7753d5-0b8d-4ef2-a2af-4c42e18e5503.png" style="width:24.83em;height:15.00em;" width="521" height="315"/></div>
<p>With this, you have utilized the Thymeleaf Form Syntax on a website to indicate the blog post's status.</p>
<div class="packt_infobox"><br/>
Go to <a href="https://bit.ly/2x6VwPp">https://bit.ly/2x6VwPp</a> to access the code for the <kbd>formmultiple-values.html</kbd> file.<br/>
Go to <a href="https://bit.ly/2CPfkfp">https://bit.ly/2CPfkfp</a> to access the code for the <kbd>FormhandlingIntroApplication.java</kbd> file.<br/>
Go to <a href="https://bit.ly/2p38GIR">https://bit.ly/2p38GIR</a> to access the folder for <kbd>form-handling/</kbd>.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Form-Backing Beans</h1>
                </header>
            
            <article>
                
<p>In a web application that uses web pages to manipulate data, you want to keep the information tightly coupled by using an object or a form-backing Bean that you can pass between the view and the controller. This kind of Bean provides getters and setters to access the value for each field in the form. In Spring MVC, this kind of object is called a <strong>Command</strong>.</p>
<p>The following code snippet shows a sample command class backing a form to display and modify a blog post. Please note the usage of Project Lombok to avoid boilerplate code for the constructor, getters, and setters:</p>
<pre>@Data<br/>public class BlogPost {<br/>    private LocalDateTime publicationDate;<br/>    private String slug;<br/>    private String title;<br/>    private String content;<br/>}</pre>
<p>As you may have noticed, this looks like a regular Java Bean; and indeed there is no difference between a Java Bean and a Spring MVC command class.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Populating a Form Bean for Editing</h1>
                </header>
            
            <article>
                
<p>Previously, we were binding single values of the model to fields of the form. When the form Bean has a lot of attributes, it can become quite cumbersome to repeat the name of the model attribute multiple times for each field.</p>
<p class="mce-root"/>
<p>Since accessing values from a form-backing Bean is a very common task, Thymeleaf provides the <kbd>th:object</kbd> attribute in <kbd>&lt;form&gt;</kbd> tags to specify the command object that will be accessed throughout the whole form:</p>
<pre>&lt;form action="#" th:action="@{/blogposts/create}"<br/>th:object="${blogPostCommand}" method="post"&gt;<br/>  &lt;input type="text" id="title" th:field="*{title}"&gt;<br/>  &lt;input type="text" id="slug" th:field="*{slug}"&gt;<br/>  &lt;button type="submit"&gt;Submit&lt;/button&gt;<br/>&lt;/form&gt;</pre>
<p>After the object has been set for the form, the Thymeleaf expression <kbd>*{...}</kbd> allows you to access the fields of that object without referencing the model attribute repeatedly.</p>
<div class="packt_tip"><br/>
Please note that there are limitations when using this attribute. It is required to use a variable expression <kbd>(${...})</kbd> specifying the name of the model attribute without any property navigation. This means that <kbd>${blogPostCommand}</kbd> is perfectly fine, while <kbd>${pageData.blogPostCommand}</kbd> would lead to an error. Also, no other <kbd>th:object</kbd> attributes are allowed inside a form.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Starting with Form Data Processing</h1>
                </header>
            
            <article>
                
<p>The aim is to use form data processing to create a blog post with a backing Bean. The steps for completion are as follows:</p>
<ol>
<li>Open the project located at <a href="https://bit.ly/2p38GIR">https://bit.ly/2p38GIR</a>.</li>
<li>Open the <kbd>CreateBlogPostCommand</kbd> class and complete the class as follows:</li>
</ol>
<pre style="padding-left: 60px">@Data<br/>public class CreateBlogPostCommand {<br/>    private String title;<br/>    private String slug;<br/>    private String content;<br/>    private boolean visible;<br/>}</pre>
<ol start="3">
<li>Open the <kbd>BlogPostController</kbd> class and insert the following handling methods:</li>
</ol>
<pre style="padding-left: 60px">@GetMapping("new-backing-bean")<br/>public ModelAndView renderFormViewForBackingBean() {<br/>    CreateBlogPostCommand createBlogPostCommand =<br/>        new CreateBlogPostCommand();<br/>    createBlogPostCommand.setTitle("Default Title");<br/><br/>    return new ModelAndView("blogposts/form-backing-bean",<br/>                            "createBlogPostCommand",<br/>                            createBlogPostCommand);<br/>}<br/><br/>} @PostMapping("create-backing-bean")<br/>public ModelAndView createBlogPostFromBackingBean(@<br/>ModelAttribute<br/>   CreateBlogPostCommand createBlogPostCommand) {<br/>    BlogPost createdBlogPost = createBlogPost(<br/>             createBlogPostCommand.getTitle(),<br/>             createBlogPostCommand.getSlug(),<br/>             createBlogPostCommand.getContent(),<br/>             createBlogPostCommand.isVisible());<br/><br/>    return new ModelAndView("blogposts/show",<br/>                            "blogPost",<br/>                            createdBlogPost);<br/>}</pre>
<ol start="4">
<li>Open the <kbd>src/main/resource/templates/form-backing-bean.html</kbd> file and insert the following form definition:</li>
</ol>
<pre style="padding-left: 60px">&lt;form action="#" th:action="@{/blogposts/create-backing-<br/>bean}" th:object="${createBlogPostCommand}" method="post"&gt;<br/>  &lt;div class="form-group"&gt;<br/>    &lt;label for="title"&gt;Title&lt;/label&gt;<br/>    &lt;input type="text"<br/>           class="form-control"<br/>            // […]<br/>    &lt;/div&gt;<br/>   &lt;button type="submit" class="btn btn-primary"&gt;Submit&lt;/<br/>button&gt;<br/>&lt;/form&gt;</pre>
<div class="packt_infobox"><br/>
Go to <a href="https://bit.ly/2NJ5IqO">https://bit.ly/2NJ5IqO</a> to access the complete code for the form definition code example.</div>
<ol start="5">
<li>Start the application by using the <kbd>mvnw spring-boot:run</kbd> command.</li>
</ol>
<ol start="6">
<li>Use your browser to open the URL <kbd>http://localhost:8080/blogposts/new-backing-bean</kbd> to view the output:</li>
</ol>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/71195786-ce49-4f80-8f85-614d99a7de19.png" style="width:34.00em;height:35.83em;" width="521" height="551"/></div>
<ol start="7">
<li>Now enter the details and click on <span class="packt_screen">Submit</span>.</li>
</ol>
<ol start="8">
<li>View the following screenshot, summarizing the values you've entered:</li>
</ol>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/247d91e4-6d4b-4977-a328-523053121e23.png" style="width:34.75em;height:21.17em;" width="525" height="319"/></div>
<p>With this, you have utilized form data processing to create a blog post with a backing Bean.</p>
<div class="packt_tip"><br/>
Go to <a href="https://bit.ly/2D3aziP">https://bit.ly/2D3aziP</a> to access the complete code for the <kbd>FormhandlingIntroApplication.java</kbd> example.<br/>
Go to <a href="https://bit.ly/2p38GIR">https://bit.ly/2p38GIR</a> to access the <kbd>form-handling/</kbd> folder.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Bean Validation</h1>
                </header>
            
            <article>
                
<p>When it comes to acquiring data, there are usually constraints regarding the validity of values. This can be a technical constraint (it has to be a number) or a business constraint (21 years or older). For this kind of validation, there is a framework called Bean Validation for JVM languages such as Java.</p>
<div class="mce-root packt_infobox"><br/>
If you want to get more information about the Java Bean Validation framework, you can visit the homepage of the project at<br/>
<a href="http://beanvalidation.org/">http://beanvalidation.org/</a>, which is a very good starting point.</div>
<p>Covering the Bean Validation framework is outside the scope of this book. However, the basic concept is that annotations are used to define the constraints of properties in a Java Bean. Validators are then used to perform the actual validation.</p>
<p>The following code snippet shows an example of a Java Bean that can be validated:</p>
<pre>@Data<br/>@NoArgsConstructor<br/>public class CreateValidatedBlogPostCommand {<br/>    @NotBlank<br/>    @Size(max = 140)<br/>    // title is not allowed to be empty<br/>    // or longer than 140 characters<br/>    private String title;<br/><br/>    @Size(min = 3, max = 60)<br/>    // slug must be between 3 and 60 characters long<br/>    private String slug;<br/><br/>    @NotBlank<br/>    // content must not be empty<br/>    private String content;<br/><br/>    private boolean visible;<br/>}</pre>
<p>Besides applying the annotations to the model classes, there is little that has to be done to validate the model. Most of the heavy lifting such as configuring the validation framework and calling the validator implementations is done by Spring. To finally perform the actual validation, the <kbd>@Validated</kbd> annotation is used in the controller method:</p>
<pre>@PostMapping("create-validated-bean")<br/>public String createBlogPostFromValidatedBean(<br/>        @Validated @ModelAttribute CreateValidatedBlogPostCommand<br/>createValidatedBlogPostCommand,<br/>        BindingResult bindingResult,<br/>        Model model) {<br/>    if (bindingResult.hasErrors()) {<br/>        return "blogposts/form-validated-bean";<br/>    }<br/>    //...<br/>    return "blogposts/show";<br/>}</pre>
<div class="packt_infobox"><br/>
As with many frameworks that have been adopted by Spring Boot, you can either use the Spring annotation (<kbd>@Validated</kbd>) or the annotation of the original project (<kbd>@Valid</kbd>).</div>
<p>Besides the <kbd>@Validated</kbd> annotation, this code also shows the usage of the <kbd>BindingResult</kbd> class, which is also passed in as a parameter. The <kbd>bindingResult</kbd> parameter is used to determine whether any validation constraint had been violated in the previous request. In the preceding example, another view will be rendered in case of validation errors than in the case of data being entered correctly. Usually, the view containing the original form will be used in those cases.</p>
<div class="packt_tip"><br/>
In general, adding the <kbd>BindingResult</kbd> to the controller method is optional. However, if it is missing or not following immediately after the model attribute to be validated, a generic error page will be shown. The reason for this is that Spring MVC determines that the controller method is not able to handle the validation error and therefore turns to the general error handler for bad requests.</div>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Adding Validation Messages to Templates</h1>
                </header>
            
            <article>
                
<p>When the user enters invalid information, it is a good practice to inform the user about this. Usually, this is done by showing additional information about what the application expects. It is even possible to modify the styling of the input field of the affected values by turning it red, for example.</p>
<p>For this case, Thymeleaf offers multiple tools to show these kinds of errors. The following lists shows some examples for a model attribute or a field named title:</p>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/71e7d4be-b86c-4bc6-9cc3-50f5101262dd.png" style="width:70.42em;height:28.58em;" width="855" height="347"/></div>
<p>If a constraint is violated and a message should be shown, the Bean Validation framework provides a default error message.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Utilizing Spring's Validation Facilities</h1>
                </header>
            
            <article>
                
<p>The aim is to validate data using Spring and Thymeleaf. The steps for completion are as follows:</p>
<ol>
<li>Open the project located at <a href="https://bit.ly/2p38GIR">https://bit.ly/2p38GIR</a>.</li>
<li>Open the <kbd>CreateValidatedBlogPostCommand</kbd> class and complete the class as follows:</li>
</ol>
<pre style="padding-left: 60px">@Data<br/>public class CreateValidatedBlogPostCommand {<br/>    @NotBlank<br/>    @Size(max = 140)<br/>    private String title;<br/>    @Size(min = 3, max = 60, message = "{slug.size}")<br/>    private String slug;<br/>    @NotBlank<br/>    private String content;<br/>    private boolean visible;<br/>}</pre>
<ol start="3">
<li>Open the <kbd>BlogPostController</kbd> class and insert the following handling methods:</li>
</ol>
<pre style="padding-left: 60px">@GetMapping("new-validated-bean")<br/>public ModelAndView renderFormViewForValidatedBean() {<br/>  CreateValidatedBlogPostCommand<br/>    createValidatedBlogPostCommand =<br/>      new CreateValidatedBlogPostCommand();<br/>createValidatedBlogPostCommand.setTitle("Default Title");<br/><br/>return new ModelAndView("blogposts/form-validated-bean",<br/>                        "createValidatedBlogPostCommand",<br/>                        createValidatedBlogPostCommand);<br/>}<br/><br/>@PostMapping("create-validated-bean")<br/>public String createBlogPostFromValidatedBean(<br/>          @Validated @ModelAttribute<br/>          CreateValidatedBlogPostCommand<br/>            createValidatedBlogPostCommand,<br/>          BindingResult bindingResult,<br/>          Model model) {<br/>  if (bindingResult.hasErrors()) {<br/>    return "blogposts/form-validated-bean";<br/>  }<br/><br/>  BlogPost createdBlogPost =<br/>             createBlogPost(<br/>               createValidatedBlogPostCommand.getTitle(),<br/>               createValidatedBlogPostCommand.getSlug(),<br/>               createValidatedBlogPostCommand.getContent(),<br/>               createValidatedBlogPostCommand.isVisible());<br/><br/> model.addAttribute("blogPost", createdBlogPost);<br/> return "blogposts/show";<br/>}</pre>
<ol start="4">
<li>Open the <kbd>src/main/resource/templates/form-validated-bean.html</kbd> file and insert the following form:</li>
</ol>
<pre style="padding-left: 60px">&lt;form action="#"<br/>      th:action="@{/blogposts/create-validated-bean}"<br/>      th:object="${createValidatedBlogPostCommand}"<br/>      // […]<br/>    &lt;/div&gt;<br/>  &lt;/div&gt;<br/>  &lt;button type="submit"<br/>          class="btn btn-primary"&gt;Submit&lt;/button&gt;<br/>&lt;/form&gt;</pre>
<div class="packt_infobox"><br/>
Go to <a href="https://bit.ly/2Ofv2Su">https://bit.ly/2Ofv2Su</a> to access the code for the form.</div>
<ol start="5">
<li>Start the application by using the <kbd>mvnw spring-boot:run</kbd> command.</li>
<li>Use your browser to open the URL <kbd>http://localhost:8080/blogposts/new-validated-bean</kbd> to obtain the following output page:</li>
</ol>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/73cd8853-ce20-47de-ba60-8cfea03b58a0.png" style="width:27.50em;height:28.92em;" width="525" height="551"/></div>
<ol start="7">
<li>Now enter the details and click on <span class="packt_screen">Submit</span>.</li>
<li>You should now see the following page, summarizing the values you've entered:</li>
</ol>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/034094f0-ce28-4a6c-b221-c724d58eeea3.png" style="width:31.00em;height:18.50em;" width="521" height="311"/></div>
<p>With this, you have utilized Spring's built-in validation feature to test the data.</p>
<div class="packt_infobox"><br/>
Go to <a href="https://bit.ly/2p4Sgjo">https://bit.ly/2p4Sgjo</a> to access the complete code for the <kbd>FormhandlingIntroApplication.java</kbd> file.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Customizing Validation Messages</h1>
                </header>
            
            <article>
                
<p>Out of the box, the Bean Validation framework provides messages for the most common kinds of validation constraint violations. However, in many cases, you want to customize these messages or provide the messages in multiple languages.</p>
<p>Each validation annotation also includes a message property that can be used to set a custom message. This could be done via a static message that is directly encoded into the source.</p>
<p>For example, <kbd>@Size(min = 3, max = 60, message = "The size is incorrect")</kbd> would display the message. The size is incorrect if the corresponding field does not meet this requirement.</p>
<p class="mce-root"/>
<p>Instead of adding the message to the source code of the application, it is a much better practice to externalize the text. To achieve this, first, a <kbd>ValidationMessages.properties</kbd> file has to be created in the <kbd>src/main/resources folder</kbd>. Once created, the messages are added to this file with a unique message key. It is a good idea to follow a naming schema. An example could be the following message property:</p>
<pre>slug.size=Size has to be between 3 and 60!</pre>
<p>In the annotation, this message can then be addressed by enclosing the key in curly brackets:</p>
<pre>@Size(min = 3, max = 60, message = "{slug.size}")<br/>private String slug;</pre>
<p>The Validation Framework will automatically get the message from the <kbd>ValidationMessages.properties</kbd> file.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Setting a New Default Message for a Validator</h1>
                </header>
            
            <article>
                
<p>Another way to customize the validation error message is to provide a new default error message for a validator. This is also done in the <kbd>ValidationMessages.properties</kbd> file. In this case, the full class name followed by .message is used as a properties key:</p>
<p><kbd>javax.validation.constraints.NotBlank.message=This field must not</kbd><br/>
<kbd>be blank!</kbd></p>
<p>In this case, all properties that are annotated with the <kbd>@NotBlank</kbd> annotation will use the provided message in case of a violation, as long as no implicit message was set using the message property of the annotation.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Setting the Message for a Bean Property</h1>
                </header>
            
            <article>
                
<p>The third way of setting a custom message is to specify the name of a property in the model. In contrast to the previous mechanisms that are provided by the Validation Framework, this one is handled by Spring MVC.</p>
<p>This time, the message is stored in the <kbd>src/main/resources/messages.properties</kbd> file. The following example demonstrates how the property key is built:</p>
<pre>NotBlank.createValidatedBlogPostCommand.title=The title must not<br/>be blank!</pre>
<p>First, the name of the annotation used for validation is used (<kbd>@NotBlank</kbd>, in the example). This is followed by the model attribute name (in this case, it's <kbd>createValidatedBlogPostCommand</kbd>). Last, the path to the property within the model class is appended (the title property).</p>
<p>In the preceding example, the message "The title must not be blank!" would be shown if the title property of the <kbd>createValidatedBlogPostCommand</kbd> model attribute is blank. For any other field that is annotated with <kbd>@NotBlank</kbd>, the message would be determined depending on the previously described mechanisms.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Providing Translation for Messages</h1>
                </header>
            
            <article>
                
<p>A final improvement that can be applied to the messages is to provide custom validation messages in multiple languages.</p>
<p>In addition to the default properties files, the messages.properties and <kbd>ValidationMessages.properties</kbd> files with the same name are followed by the language code. For example, <kbd>messages_de.properties</kbd> and <kbd>ValidationMessages_de.properties</kbd> will provide the German translations of all custom messages.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Modifying Validation Messages</h1>
                </header>
            
            <article>
                
<p>The aim is to modify and translate the validation messages.</p>
<ol>
<li>Open the project located at <a href="https://bit.ly/2p38GIR">https://bit.ly/2p38GIR</a>.</li>
<li>Open the <kbd>src/main/resources/messages.properties</kbd> file and add the following line:</li>
</ol>
<pre style="padding-left: 60px">NotBlank.createValidatedBlogPostCommand.title=The title<br/>must not be blank!</pre>
<ol start="3">
<li>Open the <kbd>src/main/resources/messages_de.properties</kbd> file and add the following line:</li>
</ol>
<pre style="padding-left: 60px">NotBlank.createValidatedBlogPostCommand.title=Der Titel<br/>darf nicht leer sein!</pre>
<ol start="4">
<li>Start the application by using the <kbd>mvnw spring-boot:run</kbd> command.</li>
<li>Use your browser to open the URL <kbd>http://localhost:8080/blogposts/new-validated-bean</kbd>.</li>
<li>Clear the title field and submit the form to view the output:</li>
</ol>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/103378f1-dbe9-4cd5-85fe-854335e2af23.png" style="width:30.83em;height:47.58em;" width="523" height="806"/></div>
<p>With this, you have customized the validation messages and provided translations for another language.</p>
<div class="packt_infobox"><br/>
Go to <a href="https://bit.ly/2p4Sgjo">https://bit.ly/2p4Sgjo</a> to access the complete code for the <kbd>FormhandlingIntroApplication.java</kbd> file.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Form Input Types and Value Binding</h1>
                </header>
            
            <article>
                
<p>After looking at how data is passed between the view and controller, this section will enable us to use the different types of input fields that are part of HTML with the Thymeleaf template engine. These values of the fields need to be bound to the attributes of the model to be processed by the controller.</p>
<p>One important aspect of using HTML forms is that there is no distinction between text, numbers, or other types of values. Java, however, is based on a strong type system that requires an explicit type. For that reason, values have to be converted from or to a text representation. This task is accomplished by converter classes that are available for the most common Java types such as number, enumeration, or Boolean. Spring will automatically find the appropriate converter implementation to convert a value from or to a textual representation.</p>
<div class="packt_infobox"><br/>
More on type conversion and how to implement custom converters can be found in the Spring framework documentation at <a href="https://docs.spring.io/spring/docs/current/spring-frameworkreference/core.html#core-convert">https://docs.spring.io/spring/docs/current/spring-frameworkreference/core.html#core-convert</a>.</div>
<p>For the rest of this chapter, we will focus on the usage of commonly used form elements to gather user input in a Spring MVC web application with Thymeleaf.</p>
<p>You can find all the sample code in the companion repository at <a href="https://bit.ly/2QIcXxv">https://bit.ly/2QIcXxv</a>. You can start the application by running <kbd>mvnw spring-boot:run</kbd> or using the IDE.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Inputting Elements for Text or Number (text, hidden, password)</h1>
                </header>
            
            <article>
                
<p>The following table lists the most common use cases for input fields:</p>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/9fba53c9-e95d-4e59-ae30-a74f5979dbfc.png" width="2334" height="923"/></div>
<p>The <kbd>.../src/main/resources/templates/inputform.html</kbd> file shows how the <kbd>&lt;input&gt;</kbd> tag is used in Thymeleaf. The most important attributes to notice are either <kbd>th:value</kbd> or <kbd>th:field</kbd> depending on how you need to address the model attribute:</p>
<pre>&lt;div&gt;<br/>    &lt;label for="textValue"&gt;Text Value:&lt;/label&gt;<br/>    &lt;input type="text" id="textValue" th:field="*{textValue}"&gt;<br/>&lt;/div&gt;<br/>&lt;div&gt;<br/>    &lt;label for="numberValue"&gt;Number Value&lt;/label&gt;<br/>    &lt;input type="number" id="numberValue"<br/>th:field="*{numberValue}"&gt;<br/>&lt;/div&gt;<br/>&lt;div&gt;<br/>    &lt;label for="passwordValue"&gt;Password Value&lt;/label&gt;<br/>    &lt;input type="password" id="passwordValue"<br/>th:field="*{passwordValue}"&gt;<br/>&lt;/div&gt;<br/>&lt;div&gt;<br/>    &lt;label for="hiddenValue"&gt;Hidden Value&lt;/label&gt;<br/>    &lt;input type="hidden" id="hiddenValue"<br/>th:field="*{hiddenValue}"&gt;<br/>&lt;/div&gt;</pre>
<div class="packt_infobox"><br/>
There are far more types available for input fields then what is being discussed here. However, the value that will be transmitted is always some kind of textual representation. For a comprehensive list of these types and their usage, the <strong>Mozilla Developer Documentation</strong> (<strong>MDN</strong>) for the input field at <a href="https://developer.mozilla.org/en/docs/Web/HTML/Element/Input">https://developer.mozilla.org/en/docs/Web/HTML/Element/Input</a> or <a href="https://html.spec.whatwg.org/multipage/forms.html">https://html.spec.whatwg.org/multipage/forms.html</a> are good starting points.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Inputting Elements for Selections (Checkbox, Radio)</h1>
                </header>
            
            <article>
                
<p>Another group of input fields we will now discuss are those used to select a single option by turning it, selecting it, or deselecting it, or choosing one element from a list of options.</p>
<p><strong>Checkboxes</strong>: Commonly uses Boolean values when enabling or disabling an option.</p>
<p><strong>Radio buttons</strong>: Commonly use plain text or numbers when selecting one value from a list of options.</p>
<p>When it comes to radio elements, it is important that all input fields belonging to the same group are also referring to by the same field or attribute of our model. Therefore, each input element will have the same <kbd>th:field</kbd> attribute attached to it:</p>
<pre>&lt;input type="radio"<br/>       id="radioVal1"<br/>       value="Radio Value 1"<br/>       th:field="*{radioValue}"&gt;<br/>&lt;label for="radioVal1"&gt;Radio Value1&lt;/label&gt;<br/>&lt;input type="radio"<br/>       id="radioVal2"<br/>       value="Radio Value 2"<br/>       th:field="*{radioValue}"&gt;<br/>&lt;label for="radioVal2"&gt;Radio Value 2&lt;/label&gt;</pre>
<p>In the preceding example from the <kbd>.../src/main/resources/templates/inputform.html</kbd> <span>file, you can see that both radio fields reference the field called <kbd>radioValue</kbd>. Since Thymeleaf will handle the field naming, the HTML name attribute can be omitted.</span></p>
<p>Writing long lists of radio options can become quite complex work. For that reason, Thymeleaf offers a set of tools to ease this task:</p>
<pre>&lt;div<br/>  th:each="dynamicRadioOption : ${dynamicRadioOptions}"&gt;<br/>     &lt;input type="radio"<br/>            th:field="*{dynamicRadioValue}"<br/>            th:value="${dynamicRadioOption}"/&gt;<br/>     &lt;label th:for="${#ids.prev('dynamicRadioValue')}"<br/>            th:text="#{${'radioValue.' + dynamicRadioOption}}"&gt;<br/>       Value<br/>  &lt;/label&gt;<br/>&lt;/div&gt;</pre>
<p>In this example, taken from the same file, a list of options is provided by the model attribute <kbd>dynamicRadioOptions</kbd>. For each element of this list, an input field of the radio type and a label is generated.</p>
<p>Note the usage of the Thymeleaf <kbd>#ids.prev()</kbd> function, which refers to the ID of the previous input field.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Input Elements for User Interaction (submit)</h1>
                </header>
            
            <article>
                
<p>The last and maybe most important input element to look at is the input element of the submit type. It renders a button that will submit the form it resides in:</p>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/5ae85360-c9a6-4582-b901-e3d4a8e1c230.png" style="width:32.83em;height:6.75em;" width="1557" height="319"/></div>
<pre>&lt;input type="submit" value="Submit"&gt;</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Select (single, multi-select)</h1>
                </header>
            
            <article>
                
<p>Another important input element used in HTML forms is the <kbd>&lt;select&gt;</kbd> element. It allows you to gain user input by presenting either a drop-down list or an inline list:</p>
<pre>&lt;div&gt;<br/>  &lt;label th:for="${#ids.next('singleSelectValue')}"&gt;<br/>    Single Select Value&lt;/label&gt;<br/>  &lt;select th:field="*{singleSelectValue}"&gt;<br/>    &lt;option th:each="selectOption : ${allSelectOptions}"<br/>            th:value="${selectOption}"<br/>            th:text="#{${'selectOption.' + selectOption}}"&gt;<br/>      selectOption<br/>   &lt;/option&gt;<br/>  &lt;/select&gt;<br/>&lt;/div&gt;</pre>
<p>The preceding example will render a drop-down menu, while the following example, where we are only adding the size attributes, renders an inline list:</p>
<pre>&lt;div&gt;<br/>  &lt;label th:for="${#ids.next('singleListValue')}"&gt;<br/>    Single List Value<br/>  &lt;/label&gt;<br/>  &lt;select th:field="*{singleListValue}" size="5"&gt;<br/>    &lt;option th:each="selectOption : ${allSelectOptions}"<br/>            th:value="${selectOption}"<br/>            th:text="#{${'selectOption.' + selectOption}}"&gt;<br/>      selectOption<br/>    &lt;/option&gt;<br/>  &lt;/select&gt;<br/>&lt;/div&gt;</pre>
<p>Both examples can be found in the <kbd>.../src/main/resources/templates/selectform.html</kbd> file.</p>
<p>This example also demonstrates the usage of another way to determine the ID of an element. In this case, the <kbd>${#ids.next()}</kbd> function will return the ID of the next field element.</p>
<p>The <kbd>&lt;select&gt;</kbd> tag will take the same kind of value as an <kbd>&lt;input&gt;</kbd> element does. This means that the model attribute will be converted to or from its textual representation. If necessary, a conversion will be performed. As shown in the preceding example, the options are rendered similar to the radio input element.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Selecting Multiple Values</h1>
                </header>
            
            <article>
                
<p>The following snippet illustrates how to allow the selection of multiple values from a list:</p>
<pre>&lt;div&gt;<br/>  &lt;label th:for="${#ids.next('multipleListValue')}"&gt;<br/>    Single List Value<br/>  &lt;/label&gt;<br/>    &lt;select th:field="*{multipleListValue}"<br/>            size="5"<br/>            multiple="multiple"&gt;<br/>        &lt;option th:each="selectOption : ${allSelectOptions}"<br/>                th:value="${selectOption}"<br/>                th:text="#{${'selectOption.' + selectOption}}"&gt;<br/>          selectOption<br/>        &lt;/option&gt;<br/>    &lt;/select&gt;<br/>&lt;/div&gt;</pre>
<p>This example can be found within the same file as the previous examples.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Textarea (Regular, Unsafe Content)</h1>
                </header>
            
            <article>
                
<p>The last element to look at is the <kbd>&lt;textarea&gt;</kbd> element. It is used to enter long texts. Its usage does not differ much from a regular text <kbd>&lt;input&gt;</kbd> field. To bind a model value to the <kbd>textarea</kbd> element, the same <kbd>th:value</kbd> or <kbd>th:field</kbd> attribute is used, just as it was previously:</p>
<pre>&lt;textarea th:field="*{textareaValue}"<br/>          th:rows="${textareaRows}"<br/>          cols="40"&gt;&lt;/textarea&gt;</pre>
<p>This example can be found in the <kbd>.../src/main/resources/templates/textareaform.html</kbd> file.</p>
<p>It's important to note that Thymeleaf also offers attributes for the rows and columns attributes of the <kbd>textarea</kbd>. As shown in the preceding example, the number of rows is provided by the model attribute named <kbd>textareaRows</kbd>.</p>
<p>There is one aspect of gathering text input that can be best demonstrated using a <kbd>textarea</kbd>, but it is important whenever free text input is allowed.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Safe/Unsafe Text</h1>
                </header>
            
            <article>
                
<p>To prevent code injection, the <kbd>th:text</kbd> attribute that is used to render text into a page will encode any text so that it is visible in an HTML page. If, for example, the value contains the text <kbd>&lt;input&gt;</kbd>, it will be encoded and outputted as <kbd>&amp;lt;input&amp;gt;</kbd> to ensure that it is displayed correctly. However, there may be use cases in which you want to display the unmodified value. In this case, you use the <kbd>th:utext</kbd> attribute, which tells Thymeleaf to output the content without any modification.</p>
<div class="packt_tip"><br/>
If you display user-generated content using <kbd>th:utext</kbd>, you are vulnerable to <strong>XSS</strong> (<strong>Cross Site Scripting</strong>) attacks, so make sure that you use this only for HTML content that you have generated or that is sanitized in a different way.</div>
<p>The following snippet, taken from the <kbd>.../src/main/resources/templates/textareadisplay.html</kbd> file, demonstrates this concept:</p>
<pre>&lt;div&gt;<br/>    &lt;span th:text="*{safeTextValue}"&gt;safeTextValue&lt;/span&gt;<br/>&lt;/div&gt;<br/>&lt;h2&gt;Text Area for Unsafe Text&lt;/h2&gt;<br/>&lt;div&gt;<br/>    &lt;span th:utext="*{unsafeTextValue}"&gt;unsafeTextValue&lt;/span&gt;<br/>&lt;/div&gt;</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Utilizing Checkboxes in Thymeleaf</h1>
                </header>
            
            <article>
                
<p>The aim is to add checkboxes and display things conditionally in Thymeleaf. The steps for completion are as follows:</p>
<ol>
<li>Open the project located at <a href="https://bit.ly/2QIcXxv">https://bit.ly/2QIcXxv</a>.</li>
<li>Open the <kbd>BlogPost</kbd> class and add the following property:</li>
</ol>
<pre style="padding-left: 60px">private boolean slugVisible;</pre>
<ol start="3">
<li>Open the <kbd>BlogPostController</kbd> class and replace the existing <kbd>initBlogPost()</kbd> method with the following implementation:</li>
</ol>
<pre style="padding-left: 60px">private BlogPost initBlogPost() {<br/>    BlogPost blogPost = new BlogPost();<br/>    blogPost.setSlugVisible(true);<br/><br/>    return blogPost;<br/>}</pre>
<ol start="4">
<li>Open the <kbd>src/main/resources/templates/blogpostform.html</kbd> file and insert the following code at the marked location:</li>
</ol>
<pre style="padding-left: 60px">&lt;div class="form-group"&gt;<br/>  &lt;label for="title"&gt;Slug &lt;input type="checkbox"<br/>                                 id="slugVisible"<br/><br/>th:field="*{slugVisible}"&gt;&lt;/label&gt;<br/>  &lt;input type="text"<br/>         th:if="*{slugVisible}"<br/>         class="form-control"<br/>         id="slug"<br/>         th:field="*{slug}"<br/>         placeholder="Blog Post Slug"&gt;<br/>&lt;/div&gt;</pre>
<p> </p>
<ol start="5">
<li>Start the application and open your browser at <kbd>http://localhost:8080</kbd>:</li>
</ol>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/aa9a66c2-cfd2-42e3-a9a1-e192a29812bb.png" style="width:22.25em;height:22.50em;" width="400" height="405"/></div>
<ol start="6">
<li>Now disable the checkbox after the <strong>Slug</strong> label and click <span class="packt_screen">Submit</span>, where you will see the following form:</li>
</ol>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/ca5f4950-a702-47f6-859e-ef871e4579e5.png" style="width:22.75em;height:21.25em;" width="398" height="371"/></div>
<p>With this, you have displayed or hidden parts of the form depending on the application state.</p>
<div class="packt_infobox"><br/>
Go to <a href="https://bit.ly/2p6hIol">https://bit.ly/2p6hIol</a> to access the code for the <kbd>InputTypesAndValueBindingApplication.java</kbd> file.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Activity: Creating a Page to Enter a New Blog Post Category</h1>
                </header>
            
            <article>
                
<p><strong>Aim</strong></p>
<p>To implement the model view and controller for categories<span> </span>and<span> </span>to extend the blog post to select a category.</p>
<p><strong>Scenario</strong></p>
<p>The Blogmania application is able to display and capture blog posts. Now, you want to add the ability to set a category to the existing application.</p>
<p><strong>Steps for Completion</strong></p>
<ol>
<li>Open the project at <a href="https://bit.ly/2Ft1iBQ">https://bit.ly/2Ft1iBQ</a>.</li>
<li>Open the empty category model class from the package folder.</li>
<li>Add an attribute of the string type called <kbd>name</kbd> to the model class and use Lombok annotations to generate all methods of a data class.</li>
<li>Open the controller class in the same package as the category class.</li>
<li>Add a field of type <kbd>list &lt;Category&gt;</kbd> that will hold all available categories.</li>
<li>Add a method to initialize a new empty category and add it to the model as an attribute.</li>
<li>Add a method with a post request mapping for <kbd>/categories</kbd>.</li>
<li>Implement the currently empty method to return the list of all categories.</li>
<li>Open the file that will contain the form for the category.</li>
<li>Add a form to enter the category name.</li>
<li>Open the file containing the form to edit a blog post.</li>
<li>Add a drop-down field to the form to generate all options.</li>
</ol>
<ol start="13">
<li>Start the application and open your browser at <kbd>http://localhost:8080</kbd> to view the output.<br/>
Take a look at the following screenshot:</li>
</ol>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/f4f94afc-b9ff-4f9b-bc37-88120dcf738f.png" style="width:32.83em;height:45.42em;" width="769" height="1065"/></div>
<ol start="14">
<li>Now click on <span class="packt_screen">Add Category</span>:</li>
</ol>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/9820b3be-6a52-42ec-9009-bec18a107dc4.png" style="width:32.67em;height:31.17em;" width="769" height="735"/></div>
<ol start="15">
<li>Enter a category title and click <span class="packt_screen">Save</span>.</li>
<li>Add as many more categories as you like.</li>
</ol>
<p> </p>
<ol start="17">
<li>Now click on the plus sign (+) in the upper-right corner:</li>
</ol>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/39c0ae77-71f7-4bba-8035-1031cfecce72.png" style="width:34.00em;height:47.00em;" width="763" height="1056"/></div>
<ol start="18">
<li>Enter a blog post and look at the list of categories.</li>
</ol>
<ol start="19">
<li>After clicking <span class="packt_screen">Save</span>, the selected category should appear under the blog post title:</li>
</ol>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/a4336401-c1f0-4d61-bbad-accf5cf0d450.png" style="width:27.58em;height:37.25em;" width="763" height="1032"/></div>
<p><strong>Outcome</strong></p>
<p>The model view and controller for categories are implemented, and the blog posts are extended to select a category.</p>
<div class="packt_infobox"><br/>
Go to <a href="https://bit.ly/2MwgE6Q">https://bit.ly/2MwgE6Q</a> to access the complete code for the <kbd>BlogmaniaApplication.java</kbd> file. <span>To refer to the detailed steps, go to the <em>Solutions</em> section at the end of </span><span>this book on page 255.</span></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we looked at how data is sent from the browser to the web application using HTTP requests. After that, we looked at the differences between the usage of multiple parameters and a form-backing Bean. Next, we discovered how to validate Beans and customize the default error messages. We then discussed various form input fields such as text input, drop-down menus, and checkboxes. With the completion of this chapter, you are now able to build web applications based on Spring Boot, Spring Web MVC, and the Thymeleaf template engine.</p>
<p>In the next chapter, we will look at RESTful APIs that, in contrast to HTML views and forms, are directed at communication between services or machines.</p>


            </article>

            
        </section>
    </div>



  </body></html>