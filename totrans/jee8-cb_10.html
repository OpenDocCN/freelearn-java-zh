<html><head></head><body><div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Using Event-Driven Programming to Build Reactive Applications</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root"><span class="calibre8">This chapter covers the following recipes:</span></p>
<ul class="calibre13">
<li class="calibre14">Building reactive applications using asynchronous servlets</li>
<li class="calibre14">Building reactive applications using events and observers</li>
<li class="calibre14">Building reactive applications using websockets</li>
<li class="calibre14">Building reactive applications using message-driven beans</li>
<li class="calibre14">Building reactive applications using JAX-RS</li>
<li class="calibre14">Building reactive applications using asynchronous session beans</li>
<li class="calibre14">Using lambdas and <kbd class="calibre16">CompletableFuture</kbd> to improve reactive applications</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Introduction</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Reactive development became a trending topic in many developers conferences, meetups, blog posts, and other countless content sources (both online and offline).</p>
<p class="mce-root">But what is a reactive application? Well, there's a official definition of it contained in something called <strong class="calibre7">The Reactive Manifesto</strong> (please refer to <a href="https://www.reactivemanifesto.org" class="pcalibre pcalibre3 pcalibre1 calibre12 pcalibre2">https://www.reactivemanifesto.org</a> for more details).</p>
<p class="mce-root">In short, according to the manifesto, reactive systems are:</p>
<ul class="calibre13">
<li class="calibre14"><strong class="calibre3">Responsive</strong>: The system responds in a timely manner if at all possible</li>
<li class="calibre14"><strong class="calibre3">Resilient</strong>: The system stays responsive in the face of failure</li>
<li class="calibre14"><strong class="calibre3">Elastic</strong>: The system stays responsive under varying workloads</li>
<li class="calibre14"><strong class="calibre3">Message driven</strong>: Reactive systems rely on asynchronous message-passing to establish a boundary between components that ensures loose coupling, isolation, and location transparency</li>
</ul>
<p class="mce-root">So, this chapter will show you how to use Java EE 8 features to meet one or more of those reactive system requirements.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Building reactive applications using asynchronous servlets</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Servlets are probably one of most well-known Java EE technologies (perhaps even the most known). Actually, servlets existed even before J2EE became a real specification.</p>
<p class="mce-root">This recipe will show you how to use servlets asynchronously.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Let's first add our Java EE 8 dependency:</p>
<pre class="calibre21">    &lt;dependency&gt;<br class="calibre2"/>        &lt;groupId&gt;javax&lt;/groupId&gt;<br class="calibre2"/>        &lt;artifactId&gt;javaee-api&lt;/artifactId&gt;<br class="calibre2"/>        &lt;version&gt;8.0&lt;/version&gt;<br class="calibre2"/>        &lt;scope&gt;provided&lt;/scope&gt;<br class="calibre2"/>    &lt;/dependency&gt;</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article class="calibre2">
                
<ol class="calibre19">
<li class="chapter">First, we create a <kbd class="calibre16">User</kbd> POJO:</li>
</ol>
<pre class="mce-root2">public class User implements Serializable{<br class="calibre2"/><br class="calibre2"/>    private Long id;<br class="calibre2"/>    private String name;<br class="calibre2"/>    <br class="calibre2"/>    public User(long id, String name){<br class="calibre2"/>        this.id = id;<br class="calibre2"/>        this.name = name;<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    public Long getId() {<br class="calibre2"/>        return id;<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    public void setId(Long id) {<br class="calibre2"/>        this.id = id;<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    public String getName() {<br class="calibre2"/>        return name;<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    public void setName(String name) {<br class="calibre2"/>        this.name = name;<br class="calibre2"/>    }<br class="calibre2"/>    <br class="calibre2"/>}</pre>
<ol start="2" class="calibre19">
<li class="chapter">Then, create a slow <kbd class="calibre16">UserBean</kbd> to return a <kbd class="calibre16">User</kbd>:</li>
</ol>
<pre class="mce-root2">@Stateless<br class="calibre2"/>public class UserBean {<br class="calibre2"/>    <br class="calibre2"/>    public User getUser(){<br class="calibre2"/>        long id = new Date().getTime();<br class="calibre2"/><br class="calibre2"/>        try {<br class="calibre2"/>            TimeUnit.SECONDS.sleep(5);<br class="calibre2"/>            return new User(id, "User " + id);<br class="calibre2"/>        } catch (InterruptedException ex) {<br class="calibre2"/>            System.err.println(ex.getMessage());<br class="calibre2"/>            return new User(id, "Error " + id);<br class="calibre2"/>        }<br class="calibre2"/>    }<br class="calibre2"/>}</pre>
<ol start="3" class="calibre19">
<li class="chapter">And finally, create our asynchronous servlet:</li>
</ol>
<pre class="mce-root2">@WebServlet(name = "UserServlet", urlPatterns = {"/UserServlet"}, asyncSupported = true)<br class="calibre2"/>public class UserServlet extends HttpServlet {<br class="calibre2"/><br class="calibre2"/>    @Inject<br class="calibre2"/>    private UserBean userBean;<br class="calibre2"/>    <br class="calibre2"/>    private final Jsonb jsonb = JsonbBuilder.create();<br class="calibre2"/>    <br class="calibre2"/>    @Override<br class="calibre2"/>    protected void doGet(HttpServletRequest req, <br class="calibre2"/>    HttpServletResponse resp) throws ServletException, <br class="calibre2"/>    IOException {<br class="calibre2"/>        AsyncContext ctx = req.startAsync();<br class="calibre2"/>        ctx.start(() -&gt; {<br class="calibre2"/>            try (PrintWriter writer = <br class="calibre2"/>            ctx.getResponse().getWriter()){<br class="calibre2"/>                writer.write(jsonb.toJson(userBean.getUser()));<br class="calibre2"/>            } catch (IOException ex) {<br class="calibre2"/>                System.err.println(ex.getMessage());<br class="calibre2"/>            }<br class="calibre2"/>            ctx.complete();<br class="calibre2"/>        });<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    @Override<br class="calibre2"/>    public void destroy() {<br class="calibre2"/>        try {<br class="calibre2"/>            jsonb.close();<br class="calibre2"/>        } catch (Exception ex) {<br class="calibre2"/>            System.err.println(ex.getMessage());<br class="calibre2"/>        }<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>}</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">From the all important things here, we should start with a simple annotation:</p>
<pre class="calibre21">asyncSupported = true</pre>
<p class="mce-root">This will tell the application server that this very servlet supports asynchronous features. By the way, you will need this in the whole servlet chain (including filters, if there are any), otherwise application server will not work.</p>
<p class="mce-root">As the servlets are instantiated by the server, we can inject other context members on it, such as our stateless bean:</p>
<pre class="calibre21">@Inject<br class="calibre2"/>private UserBean userBean;</pre>
<p class="mce-root">The main servlet method holds the actual request and response references, and the request will give us the context reference to the async API:</p>
<pre class="calibre21">AsyncContext ctx = req.startAsync();</pre>
<p class="mce-root">Then, you can execute your previous blocking function in a non-blocking way:</p>
<pre class="calibre21">ctx.start(() -&gt; {<br class="calibre2"/>    ...<br class="calibre2"/>    ctx.complete();<br class="calibre2"/>});</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article class="calibre2">
                
<ul class="calibre13">
<li class="calibre14">The full source code of this recipe is at <a href="https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter10/ch10-async-servlet" target="_blank" class="pcalibre pcalibre3 pcalibre1 calibre12 pcalibre2">https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter10/ch10-async-servlet</a>.</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Building reactive applications using events and observers</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Events and observers are a great way to write code in a reactive way without thinking too much about it, thanks to the great work done by the CDI specification.</p>
<p class="mce-root">This recipe will show you how easy is to use it to improve the user experience of your application.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Let's first add our Java EE 8 dependency:</p>
<pre class="calibre21">    &lt;dependency&gt;<br class="calibre2"/>        &lt;groupId&gt;javax&lt;/groupId&gt;<br class="calibre2"/>        &lt;artifactId&gt;javaee-api&lt;/artifactId&gt;<br class="calibre2"/>        &lt;version&gt;8.0&lt;/version&gt;<br class="calibre2"/>        &lt;scope&gt;provided&lt;/scope&gt;<br class="calibre2"/>    &lt;/dependency&gt;</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article class="calibre2">
                
<ol class="calibre19">
<li class="chapter">Let's first create a <kbd class="calibre16">User</kbd> POJO:</li>
</ol>
<pre class="mce-root2">public class User implements Serializable{<br class="calibre2"/><br class="calibre2"/>    private Long id;<br class="calibre2"/>    private String name;<br class="calibre2"/>    <br class="calibre2"/>    public User(long id, String name){<br class="calibre2"/>        this.id = id;<br class="calibre2"/>        this.name = name;<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    public Long getId() {<br class="calibre2"/>        return id;<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    public void setId(Long id) {<br class="calibre2"/>        this.id = id;<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    public String getName() {<br class="calibre2"/>        return name;<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    public void setName(String name) {<br class="calibre2"/>        this.name = name;<br class="calibre2"/>    }<br class="calibre2"/>    <br class="calibre2"/>}</pre>
<ol start="2" class="calibre19">
<li class="chapter">And then, let's create a REST endpoint with event and observer features:</li>
</ol>
<pre class="mce-root2">@Stateless<br class="calibre2"/>@Path("asyncService")<br class="calibre2"/>public class AsyncService {<br class="calibre2"/>    <br class="calibre2"/>    @Inject<br class="calibre2"/>    private Event&lt;User&gt; event;<br class="calibre2"/>    <br class="calibre2"/>    private AsyncResponse response;<br class="calibre2"/>    <br class="calibre2"/>    @GET<br class="calibre2"/>    public void asyncService(@Suspended AsyncResponse response){<br class="calibre2"/>        long id = new Date().getTime();<br class="calibre2"/>        this.response = response;<br class="calibre2"/>        event.fireAsync(new User(id, "User " + id));<br class="calibre2"/>    }<br class="calibre2"/>    </pre>
<pre class="mce-root2">    public void onFireEvent(@ObservesAsync User user){<br class="calibre2"/>        response.resume(Response.ok(user).build());<br class="calibre2"/>    }<br class="calibre2"/>}</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">First, we ask the application server to create a <kbd class="calibre16">Event</kbd> source for the <kbd class="calibre16">User</kbd> POJO:</p>
<pre class="calibre21">@Inject<br class="calibre2"/>private Event&lt;User&gt; event;</pre>
<p class="mce-root">This means that it will listen to any events fired against any <kbd class="calibre16">User</kbd> object. So what we need to do is create a method to deal with it:</p>
<pre class="calibre21">public void onFireEvent(@ObservesAsync User user){<br class="calibre2"/>    response.resume(Response.ok(user).build());<br class="calibre2"/>}</pre>
<p class="mce-root">So now this method is the proper listener. The <kbd class="calibre16">@ObserversAsync</kbd> annotation guarantees it. So once an async event is fired, it will do whatever we asked (or coded).</p>
<p class="mce-root">Then, we created a simple asynchronous endpoint to fire it:</p>
<pre class="calibre21">@GET<br class="calibre2"/>public void asyncService(@Suspended AsyncResponse response){<br class="calibre2"/>    long id = new Date().getTime();<br class="calibre2"/>    this.response = response;<br class="calibre2"/>    event.fireAsync(new User(id, "User " + id));<br class="calibre2"/>}</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article class="calibre2">
                
<ul class="calibre13">
<li class="calibre14">The full source code of this recipe is at <a href="https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter10/ch10-event-observer" target="_blank" class="pcalibre pcalibre3 pcalibre1 calibre12 pcalibre2">https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter10/ch10-event-observer</a>.</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Building reactive applications using websockets</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Websockets are a great way to create decoupled communication channels for your applications. Doing it asynchronously is even better and cooler for non-blocking features.</p>
<p class="mce-root">This recipe will show how to do it.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Let's first add our Java EE 8 dependency:</p>
<pre class="calibre21">    &lt;dependency&gt;<br class="calibre2"/>        &lt;groupId&gt;javax&lt;/groupId&gt;<br class="calibre2"/>        &lt;artifactId&gt;javaee-api&lt;/artifactId&gt;<br class="calibre2"/>        &lt;version&gt;8.0&lt;/version&gt;<br class="calibre2"/>        &lt;scope&gt;provided&lt;/scope&gt;<br class="calibre2"/>    &lt;/dependency&gt;</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article class="calibre2">
                
<ol class="calibre19">
<li class="chapter">The first thing we need is our server endpoint:</li>
</ol>
<pre class="mce-root2">@Singleton<br class="calibre2"/>@ServerEndpoint(value = "/asyncServer")<br class="calibre2"/>public class AsyncServer {<br class="calibre2"/>    <br class="calibre2"/>    private final List&lt;Session&gt; peers = Collections.synchronizedList(new ArrayList&lt;&gt;());<br class="calibre2"/>    <br class="calibre2"/>    @OnOpen<br class="calibre2"/>    public void onOpen(Session peer){<br class="calibre2"/>        peers.add(peer);<br class="calibre2"/>    }<br class="calibre2"/>    <br class="calibre2"/>    @OnClose<br class="calibre2"/>    public void onClose(Session peer){<br class="calibre2"/>        peers.remove(peer);<br class="calibre2"/>    }<br class="calibre2"/>    <br class="calibre2"/>    @OnError<br class="calibre2"/>    public void onError(Throwable t){<br class="calibre2"/>        System.err.println(t.getMessage());<br class="calibre2"/>    }<br class="calibre2"/>    <br class="calibre2"/>    @OnMessage<br class="calibre2"/>    public void onMessage(String message, Session peer){<br class="calibre2"/>        peers.stream().filter((p) -&gt; <br class="calibre2"/>        (p.isOpen())).forEachOrdered((p) -&gt; {<br class="calibre2"/>            p.getAsyncRemote().sendText(message + <br class="calibre2"/>            " - Total peers: " + peers.size());<br class="calibre2"/>        });<br class="calibre2"/>    }<br class="calibre2"/>}</pre>
<ol start="2" class="calibre19">
<li class="chapter">Then, we need a client to communicate with the server:</li>
</ol>
<pre class="mce-root2">@ClientEndpoint<br class="calibre2"/>public class AsyncClient {<br class="calibre2"/><br class="calibre2"/>    private final String asyncServer = "ws://localhost:8080<br class="calibre2"/>    /ch10-async-websocket/asyncServer";<br class="calibre2"/><br class="calibre2"/>    private Session session;<br class="calibre2"/>    private final AsyncResponse response;<br class="calibre2"/><br class="calibre2"/>    public AsyncClient(AsyncResponse response) {<br class="calibre2"/>        this.response = response;<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    public void connect() {<br class="calibre2"/>        WebSocketContainer container = <br class="calibre2"/>        ContainerProvider.getWebSocketContainer();<br class="calibre2"/>        try {<br class="calibre2"/>            container.connectToServer(this, new URI(asyncServer));<br class="calibre2"/>        } catch (URISyntaxException | DeploymentException | <br class="calibre2"/>          IOException ex) {<br class="calibre2"/>            System.err.println(ex.getMessage());<br class="calibre2"/>        }<br class="calibre2"/><br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    @OnOpen<br class="calibre2"/>    public void onOpen(Session session) {<br class="calibre2"/>        this.session = session;<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    @OnMessage<br class="calibre2"/>    public void onMessage(String message, Session session) {<br class="calibre2"/>        response.resume(message);<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    public void send(String message) {<br class="calibre2"/>        session.getAsyncRemote().sendText(message);<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    public void close(){<br class="calibre2"/>        try {<br class="calibre2"/>            session.close();<br class="calibre2"/>        } catch (IOException ex) {<br class="calibre2"/>            System.err.println(ex.getMessage());<br class="calibre2"/>        }<br class="calibre2"/>    }<br class="calibre2"/>}</pre>
<ol start="3" class="calibre19">
<li class="chapter">And finally, we need a simple REST endpoint to talk to the client:</li>
</ol>
<pre class="mce-root2">@Stateless<br class="calibre2"/>@Path("asyncService")<br class="calibre2"/>public class AsyncService {<br class="calibre2"/>    <br class="calibre2"/>    @GET<br class="calibre2"/>    public void asyncService(@Suspended AsyncResponse response){<br class="calibre2"/>        AsyncClient client = new AsyncClient(response);<br class="calibre2"/>        client.connect();<br class="calibre2"/>        client.send("Message from client " + new Date().getTime());<br class="calibre2"/>        client.close();<br class="calibre2"/>    }<br class="calibre2"/>}</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">The first important thing in our server is this annotation:</p>
<pre class="calibre21">@Singleton</pre>
<p class="mce-root">Of course, we must ensure that we have one and only one instance of the server endpoint. This will ensure that all <kbd class="calibre16">peers</kbd> are managed under the same umbrella.</p>
<p class="mce-root">Let's move on to talk about <kbd class="calibre16">peers</kbd>:</p>
<pre class="calibre21">private final List&lt;Session&gt; peers = Collections.synchronizedList<br class="calibre2"/>(new ArrayList&lt;&gt;());</pre>
<p class="mce-root">The list holding them is a synchronized list. This is important because you will add/remove peers while iterating on the list, so things could be messed up if you don't protect it.</p>
<p class="mce-root">All the default websocket methods are managed by the application server:</p>
<pre class="calibre21">@OnOpen<br class="calibre2"/>public void onOpen(Session peer){<br class="calibre2"/>    peers.add(peer);<br class="calibre2"/>}<br class="calibre2"/>    <br class="calibre2"/>@OnClose<br class="calibre2"/>public void onClose(Session peer){<br class="calibre2"/>    peers.remove(peer);<br class="calibre2"/>}<br class="calibre2"/>    <br class="calibre2"/>@OnError<br class="calibre2"/>public void onError(Throwable t){<br class="calibre2"/>    System.err.println(t.getMessage());<br class="calibre2"/>}<br class="calibre2"/>    <br class="calibre2"/>@OnMessage<br class="calibre2"/>public void onMessage(String message, Session peer){<br class="calibre2"/>    peers.stream().filter((p) -&gt; (p.isOpen())).forEachOrdered((p) -&gt; <br class="calibre2"/>    {<br class="calibre2"/>        p.getAsyncRemote().sendText(message + " - Total peers: " <br class="calibre2"/>        + peers.size());<br class="calibre2"/>    });<br class="calibre2"/>}</pre>
<p class="mce-root">Also, let's give a special mention to the code on our <kbd class="calibre16">onMessage</kbd> method:</p>
<pre class="calibre21">    @OnMessage<br class="calibre2"/>    public void onMessage(String message, Session peer){<br class="calibre2"/>        peers.stream().filter((p) -&gt; (p.isOpen())).forEachOrdered((p)<br class="calibre2"/>        -&gt; {<br class="calibre2"/>            p.getAsyncRemote().sendText(message + " - Total peers: "<br class="calibre2"/>            + peers.size());<br class="calibre2"/>        });<br class="calibre2"/>    }</pre>
<p class="mce-root">We are sending a message to the peer only if it is open.</p>
<p class="mce-root">Now looking to our client, we have a reference to the server URI:</p>
<pre class="calibre21">private final String asyncServer = "ws://localhost:8080/<br class="calibre2"/>ch10-async-websocket/asyncServer";</pre>
<p class="mce-root">Note that the protocol is <kbd class="calibre16">ws</kbd>, specific to websocket communication.</p>
<p class="mce-root">Then, we have a method to open the connection with the server endpoint:</p>
<pre class="calibre21">public void connect() {<br class="calibre2"/>    WebSocketContainer container = <br class="calibre2"/>    ContainerProvider.getWebSocketContainer();<br class="calibre2"/>    try {<br class="calibre2"/>        container.connectToServer(this, new URI(asyncServer));<br class="calibre2"/>    } catch (URISyntaxException | DeploymentException | IOException ex) {<br class="calibre2"/>        System.err.println(ex.getMessage());<br class="calibre2"/>    }<br class="calibre2"/>}</pre>
<p class="mce-root">And once we have the message confirmation from the server, we can do something about it:</p>
<pre class="calibre21">@OnMessage<br class="calibre2"/>public void onMessage(String message, Session session) {<br class="calibre2"/>    response.resume(message);<br class="calibre2"/>}</pre>
<p class="mce-root">This response will appear on the endpoint that is calling the client:</p>
<pre class="calibre21">@GET<br class="calibre2"/>public void asyncService(@Suspended AsyncResponse response){<br class="calibre2"/>    AsyncClient client = new AsyncClient(response);<br class="calibre2"/>    client.connect();<br class="calibre2"/>    client.send("Message from client " + new Date().getTime());<br class="calibre2"/>}</pre>
<p class="mce-root">We are passing the reference to the client so the client can use it to write the message on it.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article class="calibre2">
                
<ul class="calibre13">
<li class="calibre14">The full source code of this recipe is at <a href="https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter10/ch10-async-websocket" target="_blank" class="pcalibre pcalibre3 pcalibre1 calibre12 pcalibre2">https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter10/ch10-async-websocket</a>.</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Building reactive applications using message-driven beans</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">The Java Messaging Service is one of the oldest Java EE APIs, and it's been reactive since day one: just read the manifesto linked in the introduction of this chapter.</p>
<p class="mce-root">This recipe will show you how to use message-driven beans, or MDBs, to deliver and consume asynchronous messages with just a few annotations.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Let's first add our Java EE 8 dependency:</p>
<pre class="calibre21">    &lt;dependency&gt;<br class="calibre2"/>        &lt;groupId&gt;javax&lt;/groupId&gt;<br class="calibre2"/>        &lt;artifactId&gt;javaee-api&lt;/artifactId&gt;<br class="calibre2"/>        &lt;version&gt;8.0&lt;/version&gt;<br class="calibre2"/>        &lt;scope&gt;provided&lt;/scope&gt;<br class="calibre2"/>    &lt;/dependency&gt;</pre>
<p class="mce-root">To check the details about queue setup in GlassFish 5, please refer to the recipe <em class="calibre17">Using Messaging Services for Asynchronous Communication</em> at <a href="e8021c0e-e762-4e43-8d9b-5c7040a453f3.xhtml" target="_blank" class="pcalibre pcalibre3 pcalibre1 calibre12 pcalibre2">Chapter 5</a>, <em class="calibre17"><span class="calibre8">Security of Enterprise Architecture</span></em>.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article class="calibre2">
                
<ol class="calibre19">
<li class="chapter">First, we create a <kbd class="calibre16">User</kbd> POJO:</li>
</ol>
<pre class="mce-root2">public class User implements Serializable{<br class="calibre2"/><br class="calibre2"/>    private Long id;<br class="calibre2"/>    private String name;<br class="calibre2"/>    <br class="calibre2"/>    public User(long id, String name){<br class="calibre2"/>        this.id = id;<br class="calibre2"/>        this.name = name;<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    public Long getId() {<br class="calibre2"/>        return id;<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    public void setId(Long id) {<br class="calibre2"/>        this.id = id;<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    public String getName() {<br class="calibre2"/>        return name;<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    public void setName(String name) {<br class="calibre2"/>        this.name = name;<br class="calibre2"/>    }<br class="calibre2"/>    <br class="calibre2"/>}</pre>
<ol start="2" class="calibre19">
<li class="chapter">Then, we create a message sender:</li>
</ol>
<pre class="mce-root2">@Stateless<br class="calibre2"/>public class Sender {<br class="calibre2"/>    <br class="calibre2"/>    @Inject<br class="calibre2"/>    private JMSContext context;<br class="calibre2"/>    <br class="calibre2"/>    @Resource(lookup = "jms/JmsQueue")<br class="calibre2"/>    private Destination queue;<br class="calibre2"/>    <br class="calibre2"/>    public void send(User user){<br class="calibre2"/>        context.createProducer()<br class="calibre2"/>                .setDeliveryMode(DeliveryMode.PERSISTENT)<br class="calibre2"/>                .setDisableMessageID(true)<br class="calibre2"/>                .setDisableMessageTimestamp(true)<br class="calibre2"/>                .send(queue, user);<br class="calibre2"/>    }<br class="calibre2"/>    <br class="calibre2"/>}</pre>
<ol start="3" class="calibre19">
<li class="chapter">Now, we create a message consumer. This is our MDB:</li>
</ol>
<pre class="mce-root2">@MessageDriven(activationConfig = {<br class="calibre2"/>    @ActivationConfigProperty(propertyName = "destinationLookup", <br class="calibre2"/>    propertyValue = "jms/JmsQueue"),<br class="calibre2"/>    @ActivationConfigProperty(propertyName = "destinationType", <br class="calibre2"/>    propertyValue = "javax.jms.Queue")<br class="calibre2"/>})<br class="calibre2"/>public class Consumer implements MessageListener{<br class="calibre2"/><br class="calibre2"/>    @Override<br class="calibre2"/>    public void onMessage(Message msg) {<br class="calibre2"/>        try {<br class="calibre2"/>            User user = msg.getBody(User.class);<br class="calibre2"/>            System.out.println("User: " + user);<br class="calibre2"/>        } catch (JMSException ex) {<br class="calibre2"/>            System.err.println(ex.getMessage());<br class="calibre2"/>        }<br class="calibre2"/>    }<br class="calibre2"/>    <br class="calibre2"/>}</pre>
<ol start="4" class="calibre19">
<li class="chapter">And finally, we create an endpoint, just to send a mock user to the queue:</li>
</ol>
<pre class="mce-root2">@Stateless<br class="calibre2"/>@Path("mdbService")<br class="calibre2"/>public class MDBService {<br class="calibre2"/>    <br class="calibre2"/>    @Inject<br class="calibre2"/>    private Sender sender;<br class="calibre2"/>    <br class="calibre2"/>    public void mdbService(@Suspended AsyncResponse response){<br class="calibre2"/>        long id = new Date().getTime();<br class="calibre2"/>        sender.send(new User(id, "User " + id));<br class="calibre2"/>        response.resume("Message sent to the queue");<br class="calibre2"/>    }<br class="calibre2"/>}</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">We start by asking the application server a JMS context instance:</p>
<pre class="calibre21">@Inject<br class="calibre2"/>private JMSContext context;</pre>
<p class="mce-root">We also send a reference to the queue we want to work with:</p>
<pre class="calibre21">@Resource(lookup = "jms/JmsQueue")<br class="calibre2"/>private Destination queue;</pre>
<p class="mce-root">Then, using the context, we create a producer to send the message to the queue:</p>
<pre class="calibre21">context.createProducer()<br class="calibre2"/>        .setDeliveryMode(DeliveryMode.PERSISTENT)<br class="calibre2"/>        .setDisableMessageID(true)<br class="calibre2"/>        .setDisableMessageTimestamp(true)<br class="calibre2"/>        .send(queue, user);</pre>
<p class="mce-root">Pay attention to these three methods:</p>
<ul class="calibre13">
<li class="calibre14"><kbd class="calibre16">setDeliveryMode</kbd>: This method can be <kbd class="calibre16">PERSISTENT</kbd> or <kbd class="calibre16">NON_PERSISTENT</kbd>. If using <kbd class="calibre16">PERSISTENT</kbd>, the server will take special care of the message and not lose it.</li>
<li class="calibre14"><kbd class="calibre16">setDisableMessageID</kbd>: This one is used for creating <kbd class="calibre16">MessageID</kbd>, which increases the server effort to create and deliver the message and also increases its size. This property (<kbd class="calibre16">true</kbd> or <kbd class="calibre16">false</kbd>) gives a hint to the server that you are not going to need/use it, so it can improve the process.</li>
<li class="calibre14"><kbd class="calibre16">setDisableMessageTimestamp</kbd>: This is the same as for <kbd class="calibre16">setDisableMessageID</kbd>.</li>
</ul>
<p class="mce-root">Also, note that we are sending a <kbd class="calibre16">User</kbd> instance to the queue. So you can easily send object instances, not only text messages, as long as they implement the serializable interface.</p>
<p class="mce-root">The MDB itself, or our message consumer, is basically a few annotations and an interface implementation.</p>
<p class="mce-root">Here is its annotation:</p>
<pre class="calibre21">@MessageDriven(activationConfig = {<br class="calibre2"/>    @ActivationConfigProperty(propertyName = "destinationLookup", <br class="calibre2"/>    propertyValue = "jms/JmsQueue"),<br class="calibre2"/>    @ActivationConfigProperty(propertyName = "destinationType", <br class="calibre2"/>    propertyValue = "javax.jms.Queue")<br class="calibre2"/>})</pre>
<p class="mce-root">Here, we are using two properties: one to define which queue we are looking up (<kbd class="calibre16">destinationLookup</kbd>) and another to define that it is really the queue type we are using (<kbd class="calibre16">destinationType</kbd>).</p>
<p class="mce-root">Here is the implementation:</p>
<pre class="calibre21">@Override<br class="calibre2"/>public void onMessage(Message msg) {<br class="calibre2"/>    try {<br class="calibre2"/>        User user = msg.getBody(User.class);<br class="calibre2"/>        System.out.println("User: " + user);<br class="calibre2"/>    } catch (JMSException ex) {<br class="calibre2"/>        System.err.println(ex.getMessage());<br class="calibre2"/>    }<br class="calibre2"/>}</pre>
<p class="mce-root">Note that it is easy to get the <kbd class="calibre16">User</kbd> instance from the message's body:</p>
<pre class="calibre21">User user = msg.getBody(User.class);</pre>
<p class="mce-root">No heavy lifting at all.</p>
<p class="mce-root">And the endpoint used to send the message couldn't be simpler. We inject the <kbd class="calibre16">Sender</kbd> (which is a stateless bean):</p>
<pre class="calibre21">@Inject<br class="calibre2"/>private Sender sender;</pre>
<p class="mce-root">Then, we call an asynchronous method:</p>
<pre class="calibre21">public void mdbService(@Suspended AsyncResponse response){<br class="calibre2"/>    long id = new Date().getTime();<br class="calibre2"/>    sender.send(new User(id, "User " + id));<br class="calibre2"/>    response.resume("Message sent to the queue");<br class="calibre2"/>}</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article class="calibre2">
                
<ul class="calibre13">
<li class="calibre14">See the full source code of this recipe at <a href="https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter10/ch10-mdb" target="_blank" class="pcalibre pcalibre3 pcalibre1 calibre12 pcalibre2">https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter10/ch10-mdb</a>.</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Building reactive applications using JAX-RS</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">The JAX-RS API also has some great features for event-driven programming. This recipe will show you can use an async invoker from the request to write responses through callbacks.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Let's first add our Java EE 8 dependency:</p>
<pre class="calibre21">    &lt;dependency&gt;<br class="calibre2"/>        &lt;groupId&gt;javax&lt;/groupId&gt;<br class="calibre2"/>        &lt;artifactId&gt;javaee-api&lt;/artifactId&gt;<br class="calibre2"/>        &lt;version&gt;8.0&lt;/version&gt;<br class="calibre2"/>        &lt;scope&gt;provided&lt;/scope&gt;<br class="calibre2"/>    &lt;/dependency&gt;</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article class="calibre2">
                
<ol class="calibre19">
<li class="chapter">First, we create a <kbd class="calibre16">User</kbd> POJO:</li>
</ol>
<pre class="mce-root2">public class User implements Serializable{<br class="calibre2"/><br class="calibre2"/>    private Long id;<br class="calibre2"/>    private String name;<br class="calibre2"/>    <br class="calibre2"/>    public User(long id, String name){<br class="calibre2"/>        this.id = id;<br class="calibre2"/>        this.name = name;<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    public Long getId() {<br class="calibre2"/>        return id;<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    public void setId(Long id) {<br class="calibre2"/>        this.id = id;<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    public String getName() {<br class="calibre2"/>        return name;<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    public void setName(String name) {<br class="calibre2"/>        this.name = name;<br class="calibre2"/>    }<br class="calibre2"/>    <br class="calibre2"/>}</pre>
<ol start="2" class="calibre19">
<li class="chapter">Here, we define <kbd class="calibre16">UserBean</kbd>, which will act as a remote endpoint:</li>
</ol>
<pre class="mce-root2">@Stateless<br class="calibre2"/>@Path("remoteUser")<br class="calibre2"/>public class UserBean {<br class="calibre2"/><br class="calibre2"/>    @GET<br class="calibre2"/>    public Response remoteUser() {<br class="calibre2"/>        long id = new Date().getTime();<br class="calibre2"/>        try {<br class="calibre2"/>            TimeUnit.SECONDS.sleep(5);<br class="calibre2"/>            return Response.ok(new User(id, "User " + id))<br class="calibre2"/>            .build();<br class="calibre2"/>        } catch (InterruptedException ex) {<br class="calibre2"/>            System.err.println(ex.getMessage());<br class="calibre2"/>            return Response.ok(new User(id, "Error " + id))<br class="calibre2"/>            .build();<br class="calibre2"/>        }<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>}</pre>
<ol start="3" class="calibre19">
<li class="chapter">Then finally, we define a local endpoint that will consume the remote one:</li>
</ol>
<pre class="mce-root2">@Stateless<br class="calibre2"/>@Path("asyncService")<br class="calibre2"/>public class AsyncService {<br class="calibre2"/>    <br class="calibre2"/>    private Client client;<br class="calibre2"/>    private WebTarget target;<br class="calibre2"/><br class="calibre2"/>    @PostConstruct<br class="calibre2"/>    public void init() {<br class="calibre2"/>        client = ClientBuilder.newBuilder()<br class="calibre2"/>                .readTimeout(10, TimeUnit.SECONDS)<br class="calibre2"/>                .connectTimeout(10, TimeUnit.SECONDS)<br class="calibre2"/>                .build();<br class="calibre2"/>        target = client.target("http://localhost:8080/<br class="calibre2"/>        ch10-async-jaxrs/remoteUser");<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    @PreDestroy<br class="calibre2"/>    public void destroy(){<br class="calibre2"/>        client.close();<br class="calibre2"/>    }<br class="calibre2"/>    <br class="calibre2"/>    @GET<br class="calibre2"/>    public void asyncService(@Suspended AsyncResponse response){<br class="calibre2"/>        target.request().async().get(new <br class="calibre2"/>        InvocationCallback&lt;Response&gt;() {<br class="calibre2"/>            @Override<br class="calibre2"/>            public void completed(Response rspns) {<br class="calibre2"/>                response.resume(rspns);<br class="calibre2"/>            }<br class="calibre2"/><br class="calibre2"/>            @Override<br class="calibre2"/>            public void failed(Throwable thrwbl) {<br class="calibre2"/>                response.resume(Response.status(Response.Status.<br class="calibre2"/>                INTERNAL_SERVER_ERROR).entity(thrwbl.getMessage())<br class="calibre2"/>                .build());<br class="calibre2"/>            }<br class="calibre2"/>        });<br class="calibre2"/>                <br class="calibre2"/>    }<br class="calibre2"/>    <br class="calibre2"/>}</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">We start the bean by creating the communication with the remote endpoint right in the bean instantiation. Doing this will avoid the overhead of doing it later while the invocation is happening:</p>
<pre class="calibre21">private Client client;<br class="calibre2"/>private WebTarget target;<br class="calibre2"/><br class="calibre2"/>@PostConstruct<br class="calibre2"/>public void init() {<br class="calibre2"/>     client = ClientBuilder.newBuilder()<br class="calibre2"/>            .readTimeout(10, TimeUnit.SECONDS)<br class="calibre2"/>            .connectTimeout(10, TimeUnit.SECONDS)<br class="calibre2"/>            .build();<br class="calibre2"/>    target = client.target("http://localhost:8080/<br class="calibre2"/>    ch10-async-jaxrs/remoteUser");<br class="calibre2"/>}</pre>
<p class="mce-root">Then, we created an anonymous <kbd class="calibre16">InvocationCallback</kbd> implementation within our async invoker:</p>
<pre class="calibre21">        target.request().async().get(new InvocationCallback&lt;Response&gt;()   <br class="calibre2"/>        {<br class="calibre2"/>            @Override<br class="calibre2"/>            public void completed(Response rspns) {<br class="calibre2"/>                response.resume(rspns);<br class="calibre2"/>            }<br class="calibre2"/><br class="calibre2"/>            @Override<br class="calibre2"/>            public void failed(Throwable thrwbl) {<br class="calibre2"/>                System.err.println(thrwbl.getMessage());<br class="calibre2"/>            }<br class="calibre2"/>        });</pre>
<p class="mce-root">That way, we can rely on the <kbd class="calibre16">completed</kbd> and <kbd class="calibre16">failed</kbd> events and deal with them properly.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article class="calibre2">
                
<ul class="calibre13">
<li class="calibre14">See the full source code of this recipe at <a href="https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter10/ch10-async-jaxrs" target="_blank" class="pcalibre pcalibre3 pcalibre1 calibre12 pcalibre2">https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter10/ch10-async-jaxrs</a>.</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Building reactive applications using asynchronous session beans</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Session beans can also become reactive and event driven just by using annotations. This recipe will show you how to do it.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Let's first add our Java EE 8 dependency:</p>
<pre class="calibre21">    &lt;dependency&gt;<br class="calibre2"/>        &lt;groupId&gt;javax&lt;/groupId&gt;<br class="calibre2"/>        &lt;artifactId&gt;javaee-api&lt;/artifactId&gt;<br class="calibre2"/>        &lt;version&gt;8.0&lt;/version&gt;<br class="calibre2"/>        &lt;scope&gt;provided&lt;/scope&gt;<br class="calibre2"/>    &lt;/dependency&gt;</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article class="calibre2">
                
<ol class="calibre19">
<li class="chapter">First, we create a <kbd class="calibre16">User</kbd> POJO:</li>
</ol>
<pre class="mce-root2">public class User implements Serializable{<br class="calibre2"/><br class="calibre2"/>    private Long id;<br class="calibre2"/>    private String name;<br class="calibre2"/>    <br class="calibre2"/>    public User(long id, String name){<br class="calibre2"/>        this.id = id;<br class="calibre2"/>        this.name = name;<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    public Long getId() {<br class="calibre2"/>        return id;<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    public void setId(Long id) {<br class="calibre2"/>        this.id = id;<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    public String getName() {<br class="calibre2"/>        return name;<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    public void setName(String name) {<br class="calibre2"/>        this.name = name;<br class="calibre2"/>    }<br class="calibre2"/>    <br class="calibre2"/>}</pre>
<ol start="2" class="calibre19">
<li class="chapter">Then, we create our asynchronous session bean:</li>
</ol>
<pre class="mce-root2">@Stateless<br class="calibre2"/>public class UserBean {<br class="calibre2"/>    <br class="calibre2"/>    @Asynchronous<br class="calibre2"/>    public Future&lt;User&gt; getUser(){<br class="calibre2"/>        long id = new Date().getTime();<br class="calibre2"/>        User user = new User(id, "User " + id);<br class="calibre2"/>        return new AsyncResult(user);<br class="calibre2"/>    }<br class="calibre2"/>    <br class="calibre2"/>    @Asynchronous<br class="calibre2"/>    public void doSomeSlowStuff(User user){<br class="calibre2"/>        try {<br class="calibre2"/>            TimeUnit.SECONDS.sleep(5);<br class="calibre2"/>        } catch (InterruptedException ex) {<br class="calibre2"/>            System.err.println(ex.getMessage());<br class="calibre2"/>        }<br class="calibre2"/>    }<br class="calibre2"/>}</pre>
<ol start="3" class="calibre19">
<li class="chapter">And finally, we create the endpoint that will call the bean:</li>
</ol>
<pre class="mce-root2">@Stateless<br class="calibre2"/>@Path("asyncService")<br class="calibre2"/>public class AsyncService {<br class="calibre2"/>    <br class="calibre2"/>    @Inject<br class="calibre2"/>    private UserBean userBean;<br class="calibre2"/>    <br class="calibre2"/>    @GET<br class="calibre2"/>    public void asyncService(@Suspended AsyncResponse response){<br class="calibre2"/>        try {<br class="calibre2"/>            Future&lt;User&gt; result = userBean.getUser();<br class="calibre2"/>            <br class="calibre2"/>            while(!result.isDone()){<br class="calibre2"/>                try {<br class="calibre2"/>                    TimeUnit.SECONDS.sleep(1);<br class="calibre2"/>                } catch (InterruptedException ex) {<br class="calibre2"/>                    System.err.println(ex.getMessage());<br class="calibre2"/>                }<br class="calibre2"/>            }<br class="calibre2"/>            <br class="calibre2"/>            response.resume(Response.ok(result.get()).build());<br class="calibre2"/>        } catch (InterruptedException | ExecutionException ex) {<br class="calibre2"/>            System.err.println(ex.getMessage());<br class="calibre2"/>        }<br class="calibre2"/>    }<br class="calibre2"/>}</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Let's first check the <kbd class="calibre16">getUser</kbd> method from the session bean:</p>
<pre class="calibre21">    @Asynchronous<br class="calibre2"/>    public Future&lt;User&gt; getUser(){<br class="calibre2"/>        long id = new Date().getTime();<br class="calibre2"/>        User user = new User(id, "User " + id);<br class="calibre2"/>        return new AsyncResult(user);<br class="calibre2"/>    }</pre>
<p class="mce-root">Once we user the <kbd class="calibre16">@Asynchronous</kbd> annotation, we have to turn its returning value to a <kbd class="calibre16">Future</kbd> instance of something (in our case, <kbd class="calibre16">User</kbd>). </p>
<p class="mce-root">We also created a <kbd class="calibre16">void</kbd> method to show you how to create a non-blocking code with session beans:</p>
<pre class="calibre21">    @Asynchronous<br class="calibre2"/>    public void doSomeSlowStuff(User user){<br class="calibre2"/>        try {<br class="calibre2"/>            TimeUnit.SECONDS.sleep(5);<br class="calibre2"/>        } catch (InterruptedException ex) {<br class="calibre2"/>            System.err.println(ex.getMessage());<br class="calibre2"/>        }<br class="calibre2"/>    }</pre>
<p class="mce-root">And finally, we created our calling endpoint:</p>
<pre class="calibre21">    @GET<br class="calibre2"/>    public void asyncService(@Suspended AsyncResponse response){<br class="calibre2"/>        try {<br class="calibre2"/>            Future&lt;User&gt; result = userBean.getUser();<br class="calibre2"/>            <br class="calibre2"/>            while(!result.isDone()){<br class="calibre2"/>                try {<br class="calibre2"/>                    TimeUnit.SECONDS.sleep(1);<br class="calibre2"/>                } catch (InterruptedException ex) {<br class="calibre2"/>                    System.err.println(ex.getMessage());<br class="calibre2"/>                }<br class="calibre2"/>            }<br class="calibre2"/>            <br class="calibre2"/>            response.resume(Response.ok(result.get()).build());<br class="calibre2"/>        } catch (InterruptedException | ExecutionException ex) {<br class="calibre2"/>            System.err.println(ex.getMessage());<br class="calibre2"/>        }<br class="calibre2"/>    }</pre>
<p class="mce-root">As <kbd class="calibre16">getUser</kbd> returns <kbd class="calibre16">Future</kbd>, we can work with an async status check. Once it is done, we write the results in the response (also asynchronous).</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article class="calibre2">
                
<ul class="calibre13">
<li class="calibre14">See the full source code of this recipe at <a href="https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter10/ch10-async-bean" target="_blank" class="pcalibre pcalibre3 pcalibre1 calibre12 pcalibre2">https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter10/ch10-async-bean</a>.</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Using lambdas and CompletableFuture to improve reactive applications</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">The Java language always had the reputation of being a verbose language. But since the advent of lambdas, this issue has improved a lot. </p>
<p class="mce-root">We can use <span class="calibre8">lambdas</span> and also bring <kbd class="calibre16">CompletableFuture</kbd> to the party to improve not only the coding, but also the behavior of reactive applications. This recipe will show you how.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Let's first add our Java EE 8 dependency:</p>
<pre class="calibre21">    &lt;dependency&gt;<br class="calibre2"/>        &lt;groupId&gt;javax&lt;/groupId&gt;<br class="calibre2"/>        &lt;artifactId&gt;javaee-api&lt;/artifactId&gt;<br class="calibre2"/>        &lt;version&gt;8.0&lt;/version&gt;<br class="calibre2"/>        &lt;scope&gt;provided&lt;/scope&gt;<br class="calibre2"/>    &lt;/dependency&gt;</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article class="calibre2">
                
<ol class="calibre19">
<li class="chapter">First, we create a <kbd class="calibre16">User</kbd> POJO:</li>
</ol>
<pre class="mce-root2">public class User implements Serializable{<br class="calibre2"/><br class="calibre2"/>    private Long id;<br class="calibre2"/>    private String name;<br class="calibre2"/>    <br class="calibre2"/>    public User(long id, String name){<br class="calibre2"/>        this.id = id;<br class="calibre2"/>        this.name = name;<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    public Long getId() {<br class="calibre2"/>        return id;<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    public void setId(Long id) {<br class="calibre2"/>        this.id = id;<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    public String getName() {<br class="calibre2"/>        return name;<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    public void setName(String name) {<br class="calibre2"/>        this.name = name;<br class="calibre2"/>    }<br class="calibre2"/>    <br class="calibre2"/>}</pre>
<ol start="2" class="calibre19">
<li class="chapter">Then, we call <kbd class="calibre16">UserBean</kbd> to return a <kbd class="calibre16">User</kbd> instance:</li>
</ol>
<pre class="mce-root2">@Stateless<br class="calibre2"/>public class UserBean {<br class="calibre2"/><br class="calibre2"/>    public User getUser() {<br class="calibre2"/>        long id = new Date().getTime();<br class="calibre2"/>        try {<br class="calibre2"/>            TimeUnit.SECONDS.sleep(5);<br class="calibre2"/>            return new User(id, "User " + id);<br class="calibre2"/>        } catch (InterruptedException ex) {<br class="calibre2"/>            System.err.println(ex.getMessage());<br class="calibre2"/>            return new User(id, "Error " + id);<br class="calibre2"/>        }<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>}</pre>
<ol start="3" class="calibre19">
<li class="chapter">And finally, we create an async endpoint to call the bean:</li>
</ol>
<pre class="mce-root2">@Stateless<br class="calibre2"/>@Path("asyncService")<br class="calibre2"/>public class AsyncService {<br class="calibre2"/><br class="calibre2"/>    @Inject<br class="calibre2"/>    private UserBean userBean;<br class="calibre2"/><br class="calibre2"/>    @GET<br class="calibre2"/>    public void asyncService(@Suspended AsyncResponse response) <br class="calibre2"/>    {<br class="calibre2"/>        CompletableFuture<br class="calibre2"/>                .supplyAsync(() -&gt; userBean.getUser())<br class="calibre2"/>                .thenAcceptAsync((u) -&gt; {<br class="calibre2"/>                    response.resume(Response.ok(u).build());<br class="calibre2"/>                }).exceptionally((t) -&gt; {<br class="calibre2"/>                    response.resume(Response.status<br class="calibre2"/>                    (Response.Status.<br class="calibre2"/>                    INTERNAL_SERVER_ERROR).entity(t.getMessage())<br class="calibre2"/>                    .build());<br class="calibre2"/>                    return null;<br class="calibre2"/>                });<br class="calibre2"/>    }<br class="calibre2"/>}</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">We are using basically two <kbd class="calibre16">CompletableFuture</kbd> methods:</p>
<ul class="calibre13">
<li class="calibre14"><kbd class="calibre16">supplyAsync</kbd>: This will start an async call to whatever you put inside of it. We put in a lambda call.</li>
<li class="calibre14"><kbd class="calibre16">thenAcceptAsync</kbd>: Once the async process is done, the returning value will come here. Thanks to lambdas, we can call this returning value as <kbd class="calibre16">u</kbd> (and could be whatever we want). Then, we use it to write it down to the asynchronous response.</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article class="calibre2">
                
<ul class="calibre13">
<li class="calibre14">See the full source code of this recipe at <a href="https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter10/ch10-completable-future" target="_blank" class="pcalibre pcalibre3 pcalibre1 calibre12 pcalibre2">https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter10/ch10-completable-future</a>.</li>
</ul>


            </article>

            
        </section>
    </div>



  </body></html>