- en: Chapter 9. jBPM in Production
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapters, we sailed through the various functional aspects of
    jBPM and also saw how we can extend and customize jBPM for adding more features.
    Now, it is production time, and there is a change in the perspective of how the
    application is viewed by its stakeholders.
  prefs: []
  type: TYPE_NORMAL
- en: The important question now is not the functional characteristics, but the nonfunctional
    ones. People think about the stability and resilience of the application and not
    the flexibility that it gives. People think of how fast and cost-efficiently the
    application can be scaled so as to provision for more users and how less critical
    is the latency of a service.
  prefs: []
  type: TYPE_NORMAL
- en: The mettle of the application is put under fire. jBPM is ready-to-use production
    software, and in this chapter, we will discuss various facilities available in
    jBPM to make it fit into the requirements of production software. The chapter
    is structured on the basis of the major qualities of a system that has to be taken
    care of in production.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will discuss the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: How to scale
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to make applications secure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to meet availability requirements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to incorporate new changes to the system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How the system handles errors in runtime
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scalability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Scalability can be described as the capacity of a system to handle growing volumes
    of service provisioning in a controlled and cost-efficient manner. In case of
    a BPM system, there are two major use cases where the requirement of scaling can
    arise.
  prefs: []
  type: TYPE_NORMAL
- en: Scaling the modeling facility, that is, the workbench
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scaling the process runtime, with which the end customers of the application
    interact
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Scaling an application typically involves two methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Vertical scaling**: This is achieved by adding resources to the server that
    is providing the service'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Horizontal scaling**: This is achieved by adding multiple servers to provision
    the same service'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Vertical scaling involves less complexity of implementation as it asks for improving
    the hardware (usually) and configuring the application to use these resources.
    However, vertical scaling is often limited by the constraints put by cost and
    technology in building the resources. In the context of jBPM, the resources that
    can be added are the memory, processor cores, and secondary storage mechanisms.
    jBPM doesn't provide out-of-the-box functionality to explicitly cater for these
    resource improvements, but there would be improvements in throughput and performance
    by taking advantage of the underlying platforms used by the jBPM, such as the
    application server on which jBPM is deployed and JVM on which the application
    server resides.
  prefs: []
  type: TYPE_NORMAL
- en: Within the scope of this book, it is obvious that horizontal scaling would need
    a better method, and the following sections purely concentrate on horizontally
    scaling of the jBPM functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Scaling the business process modeling facility
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Scaling the modeling tool points to increasing the number of users that can
    perform modeling simultaneously. Users can choose either web tooling or Eclipse
    tooling for modeling purposes, and there can be scenarios where the modeling users
    create a single application or multiple applications.
  prefs: []
  type: TYPE_NORMAL
- en: Given the previous factors and constraints, the most obvious way to increase
    the throughput of the modeling workbench service is to increase the number of
    units that provision the service. So, we add servers and jump to face the quintessential
    problems of clustering. Each server has a separate asset repository, and if the
    users collaborate to create the same application, we need to keep the assets in
    the repository sync always.
  prefs: []
  type: TYPE_NORMAL
- en: The out-of-the-box facility that jBPM provides as the asset repository is the
    Git-backed **Virtual File System** (**VFS**), and in order to keep the file system
    in sync, jBPM suggests the use of Apache Helix, a cluster management framework.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram visualizes the deployment architecture in this scenario:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Scaling the business process modeling facility](img/9578OS_09_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Apache Helix acts as a cluster management solution, which registers all servers
    to the cluster and enables the synchronization of the repositories.
  prefs: []
  type: TYPE_NORMAL
- en: Helix internally uses Apache ZooKeeper to manage the state of the system and
    manage the notifications between the nodes.
  prefs: []
  type: TYPE_NORMAL
- en: The details of configuring VFS clustering are explicitly provided in the jBPM
    user guide; please refer to it for configuration details.
  prefs: []
  type: TYPE_NORMAL
- en: Apache Helix provides a set of functionalities that enable us to develop a fault-tolerant,
    scalable distributed system. For more details, see [http://helix.apache.org/Architecture.html](http://helix.apache.org/Architecture.html).
  prefs: []
  type: TYPE_NORMAL
- en: Scaling the process runtime
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we talk about scaling any software application, it involves increasing
    the capacity of the system to serve an increasing number of user interactions.
    In BPM-based applications, along with the increase in user interactions, the complexity
    and content of the business processes factor in for an increase in the capacity
    of the system.
  prefs: []
  type: TYPE_NORMAL
- en: Factors and considerations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The following section highlights the factors involved in finalizing the deployment
    architecture of the system and discusses the consideration made in the jBPM architecture
    to meet these increasing requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Number of processes/process instances
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Yes, this is an obvious factor: the number of process definitions that are
    part of the application and the number of process instances created from these
    process definitions use the system capacity. The process definitions are stored
    in the asset repository, and we have already discussed this in the *Scaling the
    business process modeling facility* section, but the increase in process definitions
    directs to an increase in the number of process instances that have to be managed
    by the system. The reverse is also possible, that is, a relatively small number
    of process definitions but a large number of process instances.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Process instances carry the runtime state of the process execution and by default
    in memory. However, this is not an option in a real-world scenario where the availability
    of the runtime state is critical, and so, jBPM provides mechanisms to persist
    the process instances into a database. In the context of our discussion, we have
    to note that with an increase in the number of process instances, we have to do
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Increase the capacity of the database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Increase the capacity of the memory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following diagram shows the schematic deployment architecture where there
    are multiple jBPM runtime instances having replicated VFS repositories for asset
    storage and a centralized database storing the runtime information:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Number of processes/process instances](img/9578OS_09_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The number of user interactions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'User interactions with the process runtime are for the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Interactions with the process engine for starting a process (creation of a process
    instance) or signaling an event to an already started process instance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interaction with the task service for handling the life cycle methods for human
    tasks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One other possibility is the interactions to domain-specific asynchronous workitems,
    which needs its own capacity planning.
  prefs: []
  type: TYPE_NORMAL
- en: Interactions with the process engine are performed through a dedicated KieSession
    API and come with a specific constraint; that is, interactions with a process
    instance can only be performed through the Kie session in which the process instance
    was created. Each interaction needs the instance of the Kie session where it was
    created, and jBPM provides multiple strategies for handling the scaling up of
    process interactions. jBPM allows you to choose the strategy while creating the
    runtime manager, which is in turn used to access the runtime engine and create
    sessions for interaction.
  prefs: []
  type: TYPE_NORMAL
- en: Flavors of runtime manager
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '**Singleton strategy**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By choosing this strategy, we choose to maintain a single instance of the runtime
    instance and a single instance of Kie Session for all interactions. This is the
    easiest strategy and is most favorable for low and medium loads.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The singleton strategy can be programmatically chosen as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Further, if you are using jBPM console (KIE Workbench), you can configure the
    `<runtime-strategy>` deployment descriptor tag as `SINGLETON`. A sample deployment
    descriptor is shown as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`SINGLETON` is the default strategy in the jBPM console.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can override the default deployment descriptor by using a Java option during
    the start of the server as follows: `Dorg.kie.deployment.desc.location=file:/application/configuration/deployment-descriptor.xml`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Per request strategy**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A new instance of runtime manager is provided, and the session is created and
    maintained for the request scope.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This strategy is stateless and ideal for horizontally scaling the jBPM process
    runtime instances, but the functionality in the process is limited to stateless
    facts, with no user interactions allowed other than the start process.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We can choose the per request strategy programmatically during the creation
    of runtime by the following code:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Further, for jBPM console, the deployment descriptor can be customized as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Per process instance strategy**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is the most advanced strategy taking into consideration the tradeoff between
    the scalability of the system and the overhead it put. As the name indicates,
    ksession sticks to the process instance and lives as long as the process instance
    is alive. It does not have the scalability constraints in the singleton strategy,
    and although it has a high overhead, it doesn't have the overhead limitations
    and is not scalable as the per request strategy. Thus, the per process instance
    strategy is placed in the middle of the above two and is used in most of the cases
    where jBPM is used.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We can choose the per process instance strategy programmatically during the
    creation of runtime by the following line of code:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Further, for the jBPM console, the deployment descriptor is customized as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Task service
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Task service is the dedicated component for managing human task services. The
    interactions with an application can be performed through the human tasks. jBPM
    provides a default implementation for the human task service, which is based on
    the WS-Human Task specification. The task service clients are light and go hand-in-hand
    with strategies that we have chosen for the runtime manager, and all the clients
    share the same database; therefore, scaling up of human tasks is in sync with
    the strategy chosen for the runtime manager and with the increase in the capacity
    of the database storage.
  prefs: []
  type: TYPE_NORMAL
- en: Number of timer events
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The functionality of timer events is achieved using the scheduler service. Multiple
    implementations of the scheduler service are provided by jBPM. The Quartz scheduler-based
    implementation is a fit in for a production environment. The Quartz scheduler
    supports the clustering mode, which provides both high availability and scalability,
    which works by maintaining the data or state of the schedules (or jobs) that it
    handles in a shared database between nodes.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Quartz is an open source job scheduling library that can be integrated within
    a Java application. Quartz can be used to create scheduled tasks and provide support
    for JTA transactions and clustering. For more details, see [http://quartz-scheduler.org/](http://quartz-scheduler.org/).
  prefs: []
  type: TYPE_NORMAL
- en: The Quartz scheduler can be enabled by providing the absolute path of the `quartz`
    definition file against the `org.quartz.properties` system property.
  prefs: []
  type: TYPE_NORMAL
- en: A sample `quartz` definition file is given as follows that is configured for
    use along with a PostgreSQL database.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When using the Quartz scheduler, as a prerequisite, we would have to create
    the database schemas that are used by Quartz to persist its job data. The database
    scripts provided with the Quartz distribution (jBPM uses Quartz 1.8.5\. DB scripts)
    are usually located under `QUARTZ_HOME/docs/dbTables`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The scheduler service can be configured programmatically by configuring `GlobalSchedulerService`
    in the runtime environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `globalSchedulerService` object is an implementation of `org.jbpm.process.core.timer.GlobalSchedulerService`
    and the Quartz implementation is `org.jbpm.process.core.timer.impl.QuartzSchedulerService`.
  prefs: []
  type: TYPE_NORMAL
- en: Availability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The availability of an application or system can be viewed as the total amount
    of time that it provides its services against the total time it is expected to
    do so. System availability is affected by multiple factors ranging from failure
    of the system due to hardware/software failures and the known downtime for maintenance
    and upgrades.
  prefs: []
  type: TYPE_NORMAL
- en: High availability is achieved in applications by having failover mechanisms
    using which the system can get back to its service provisioning state after a
    failure. A more optimized system would consider backup mechanisms, which it can
    immediately switch on to in a failure scenario, thus improving the availability.
    Scheduled maintenance can be done using a rolling upgrade to ensure high availability.
    The solutions are usually depicted in the form of deployment architecture, vary
    according to the software solution, and consider the trade-offs in non-functional
    requirements.
  prefs: []
  type: TYPE_NORMAL
- en: The following figure depicts the sample deployment architecture that can be
    applied to the jBPM workbench and runtime, which can cater to high-availability
    and high-throughput scenarios. The architecture considers a failover mechanism
    by having a persistent, distributed storage for all data and a load balancer with
    a passive backup to ensure the switching of nodes upon a partial failure (node
    failure). jBPM doesn't provide all the components needed in this deployment architecture
    but has to get third-party software and integrated. We discuss the applicability
    of these components in the subsequent sections.
  prefs: []
  type: TYPE_NORMAL
- en: '![Availability](img/9578OS_09_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Applicability to workbench
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Thinking about the availability of the workspace, we need to consider the following
    two things:'
  prefs: []
  type: TYPE_NORMAL
- en: Availability of the web-based user interface for modeling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Availability of the stores where the assets are created during the modeling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The service providing the web-based user interface is hosted on an application
    server, and the availability means availability provisions provided by the application
    server. Usually, the provisions are in the form of load balancer-based failover
    mechanisms, where the load balancer switches the traffic to another node when
    the node providing the service fails, and the failover mechanism ensures that
    the node will be back live within a certain timespan to provide the full potential
    throughput.
  prefs: []
  type: TYPE_NORMAL
- en: Assets are stored in a virtual file system, and by default, it is a Git-based
    repository. As we have discussed in the *Scaling the business process modeling
    facility* section, the Git-based repository can be clustered and the assets synchronized.
    So, even if one node fails, the latest assets will be restored from the other
    nodes.
  prefs: []
  type: TYPE_NORMAL
- en: Applicability to continuous improvements in processes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: From the perspective of the applications developed using the modeling facility,
    there can be continuous improvements in the application processes. The new version
    of a process can be deployed to the jBPM runtime in two ways.
  prefs: []
  type: TYPE_NORMAL
- en: The new version of the process can be deployed as a new process definition,
    and the old one can be retired by removing it from the knowledge repository so
    that no new instance of this process version is deployed. However, this approach
    absolutely doesn't handle the existing process instances. Either they should be
    allowed to continue with the earlier versions or they should be aborted and reprocessed.
    The decisions on choosing the approach should be handled case-by-case on the basis
    of the business scenario that these process definitions are handling.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the process migration facility provided by jBPM. However, the facility
    is limited to process changes that are non-conflicting.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thus, process upgrades are not a very smooth process and require careful handling.
    Further, to achieve availability, either the upgrades have to be done during low-traffic
    periods or we have to do a rolling upgrade.
  prefs: []
  type: TYPE_NORMAL
- en: Applicability to the process runtime
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Availability of the process runtime involves the availability of services to
    interact with process instances such as process instance life cycles and user
    interactions. Similar to what we discussed about the workbench facility, there
    are two things we need to consider:'
  prefs: []
  type: TYPE_NORMAL
- en: Availability of the process instance interactions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Availability of the process instance data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the availability of the process instance interactions, we need to have a
    load balancing mechanism that can switch over the traffic of one node to another
    upon a failure. Further, we need to be able to persist the process instance data
    in a nonvolatile storage for a failover. As discussed in the *Scaling the process
    runtime* section, jBPM supports the persistence of runtime information in relational
    databases.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the popular relational databases have inbuilt support for availability
    using clustered storage. This can be utilized to make sure that the persisted
    process instance data can be made highly available.
  prefs: []
  type: TYPE_NORMAL
- en: Security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Security or application security in this context refers to protecting the services
    and data provided by jBPM from unauthorized access (authentication) and at the
    same time ensuring that the users can access the set of services and data authorized
    for them (authorization).
  prefs: []
  type: TYPE_NORMAL
- en: Another important perspective that we have to consider in a BPM system is providing
    non-repudiation for all the user interactions. jBPM supports this by providing
    an audit logging facility for all runtime data changes.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Non-repudiation assures that a user cannot deny performing an action or operation
    in the system.
  prefs: []
  type: TYPE_NORMAL
- en: Securing the access of application assets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: jBPM, usually deployed in an application server, uses a JEE-compatible standard,
    that is, **Java Authentication and Authorization Service** (**JAAS**), for providing
    application security. The application server provides this service and a mechanism
    to register the users.
  prefs: []
  type: TYPE_NORMAL
- en: The default asset repository used to keep the application assets is the Git
    repository. Further, a Git repository ensures that a change to a repository handled
    by it (be it an addition of a file or a change of the file) is only allowed for
    an authorized person.
  prefs: []
  type: TYPE_NORMAL
- en: Authentication is done for the users logging in through the workbench, and for
    making changes to the repository through Eclipse, the users have to use SSH.
  prefs: []
  type: TYPE_NORMAL
- en: 'The workbench user management supports the following roles:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Admin**: The role that has full access rights. The user who plays the role
    of admin manages the BPMS.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Analyst**: The role that can do the modeling and is associated with a business
    analyst for creating processes, rules, entities, forms, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Developer**: The role that carries the baton of the process artifacts from
    the business analyst and develops fully executable code with back-end services
    and handlers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Business user**: The role that performs operation management by using task
    management features. The person assigned to this role is the end user of the application,
    who avails the functionality provided by the application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**View only user**: The role that can view the statistics of processes and
    their performance and is the primary user of the statistics dashboard.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Taking the example of jBPM installed in the JBoss application server (now renamed
    to WildFly), it provides utilities such as `add-user` to add the users and assign
    their roles.
  prefs: []
  type: TYPE_NORMAL
- en: Securing the process runtime
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The following subsections details the provisions for securing the process runtime,
    that is, securing the operation management specific operations.
  prefs: []
  type: TYPE_NORMAL
- en: Access security specific to human tasks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The workbench allows only authorized people to access the process runtime capabilities
    as discussed in the previous section. Apart from the process management access,
    inside each process definition, each human task is assigned to a user or a role
    (group).
  prefs: []
  type: TYPE_NORMAL
- en: In an environment using the whole jBPM suite of software, including the process
    modeler, we can drive this by adding more roles or groups to the system by using
    the application server capabilities. In an embedded mode, jBPM provides an extension
    point for implementing an application-specific access security mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: 'This extension can be done by implementing the `org.kie.api.task.UserGroupCallback`
    interface and embedding the application-specific logic for validating the authorization
    of the users to perform tasks. The specific method that we need to implement for
    attaining this integration is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This interface method is used for determining whether the user attached to a
    task is valid. For integrating with our application, we can implement this method
    by using the logic or service used for authentication.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This interface method is used for resolving whether the group or role attached
    to a task is valid.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This is used for resolving the groups (or roles) that are valid for a user.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `userGroupCallback` interface implementation can be attached to the process
    runtime by using the `HumanTaskService` factory. The code snippet for doing this
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The advantage of this mechanism is that we are not constrained to the user
    management functionality provided by jBPM but can develop our own. Further, jBPM
    provides a set of pre-build `userGroupCallBack` functions that can be used in
    production:'
  prefs: []
  type: TYPE_NORMAL
- en: '`org.jbpm.services.task.identity.LDAPUserGroupCallbackImpl`, as the name indicates,
    can be used for configuring it with your LDAP service.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`org.jbpm.services.task.identity.JAASUserGroupCallbackImpl`, as the name indicates,
    can be used for configuring it with your JAAS standard-specific user authentication
    mechanisms widely used in application server environments. jBPM provides adapters
    for Oracle WebLogic, IBM WebSphere, and JBoss application servers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: LDAP (which stands for Lightweight Directory Access Protocol) is an open standard,
    widely used in small and medium organizations to share user information between
    services and systems.
  prefs: []
  type: TYPE_NORMAL
- en: Audit logging
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In business domains using a BPM, the process defines the business itself. Using
    these processes, multiple systems and people in the organization interact with
    one another. In any organization, disputes regarding actions done by people or
    systems that drive these processes are common. From the perspective of application
    security, these scenarios are solved using non-repudiation mechanisms, which assure
    that no user or system can deny these actions. Audit logging is one of the widely
    used non-repudiation mechanisms, in which every action performed on the system
    is stored and is later used for resolving a dispute or analyzing the root cause
    of the dispute. Another advantage is that we can use this data to analyze and
    find out the performance and quality indicators of the business processes.
  prefs: []
  type: TYPE_NORMAL
- en: An audit log helps us to retrieve information about what happened to a process
    instance, when it happened, and who triggered it.
  prefs: []
  type: TYPE_NORMAL
- en: 'jBPM provides a generic audit logging mechanism that comprehensively covers
    the life cycle of a business process. The audit log is stored as three data models:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Process instance log**: Stores the data corresponding to interactions with
    the process instance life cycle, for example, starting of a process instance,
    stopping of a process instance, or aborting a process instance. Using the attributes
    of the instance log, we can trace back the process definition, process version,
    process instance, user identity, and so on, which are associated with a life cycle
    change.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Node instance log**: Stores the data corresponding to the life cycle of a
    node in the process. A node refers usually to an activity in the business process.
    The attributes of this data help us to trace back to the process definition, process
    version, process instance, user identity, time, and workitem on which this incident
    occurred.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Variable instance log**: Stores the data corresponding to the changes in
    process variables in a process instance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following table lists the data available in the audit log data model:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Process instance log |'
  prefs: []
  type: TYPE_TB
- en: '| --- |'
  prefs: []
  type: TYPE_TB
- en: '| **Field** | **Type** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| ID | BIGINT(20) | Identity of the log table |'
  prefs: []
  type: TYPE_TB
- en: '| Duration | BIGINT(20) | Lifetime of the process instance when the incident
    occurred |'
  prefs: []
  type: TYPE_TB
- en: '| End date | DATETIME | Represents the time when the process instance ended,
    applicable only if the process instance is stopped or aborted |'
  prefs: []
  type: TYPE_TB
- en: '| External ID | VARCHAR(255) | An external ID provided for the identification
    of a process instance from the domain data |'
  prefs: []
  type: TYPE_TB
- en: '| User identity | VARCHAR(255) | Identity of the user who initiated the process
    instance. |'
  prefs: []
  type: TYPE_TB
- en: '| Outcome | VARCHAR(255) | Outcome of the process information, primarily used
    to store information such as error code, in case the process stops due to an error
    event |'
  prefs: []
  type: TYPE_TB
- en: '| Parent process instance ID | BIGINT(20) | The identifier of the parent process
    instance |'
  prefs: []
  type: TYPE_TB
- en: '| Process ID | VARCHAR(255) | Identifier of the process definition |'
  prefs: []
  type: TYPE_TB
- en: '| Process instance ID | BIGINT(20) | Unique identifier of the process instance
    |'
  prefs: []
  type: TYPE_TB
- en: '| Process name | VARCHAR(255) | Name of the process definition |'
  prefs: []
  type: TYPE_TB
- en: '| Process version | VARCHAR(255) | Version of the process definition |'
  prefs: []
  type: TYPE_TB
- en: '| Start date | DATETIME | Date on which the process instance was started |'
  prefs: []
  type: TYPE_TB
- en: '| Status | INT(11) | ![Audit logging](img/B02011_09_Table.jpg)The preceding
    table provides the possible values of this field and what they mean |'
  prefs: []
  type: TYPE_TB
- en: '| **Node instance log** |'
  prefs: []
  type: TYPE_TB
- en: '| **Field** | **Type** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| ID | BIGINT(20) | Unique identifier |'
  prefs: []
  type: TYPE_TB
- en: '| Connection | VARCHAR(255) | Identifier of the sequence flow that led to this
    node instance |'
  prefs: []
  type: TYPE_TB
- en: '| Log date | DATETIME | Date at which the node was triggered |'
  prefs: []
  type: TYPE_TB
- en: '| External ID | VARCHAR(255) | External identifier associated with the process
    instance |'
  prefs: []
  type: TYPE_TB
- en: '| Node instance ID | VARCHAR(255) | Identifier of the node instance |'
  prefs: []
  type: TYPE_TB
- en: '| Node name | VARCHAR(255) | Name of the node from the process definition |'
  prefs: []
  type: TYPE_TB
- en: '| Node type | BIGINT(20) | The type of node or activity, for example, service
    task |'
  prefs: []
  type: TYPE_TB
- en: '| Process ID | VARCHAR(255) | Identifier of the process definition that this
    node is a part of |'
  prefs: []
  type: TYPE_TB
- en: '| Process Instance ID | BIGINT(20) | Identifier of the process instance that
    this node is a part of |'
  prefs: []
  type: TYPE_TB
- en: '| Type | INT(11) | Indicates whether the log was updated on entry or exit |'
  prefs: []
  type: TYPE_TB
- en: '| Workitem ID | BIGINT(20) | Identifier of the workitem that this node refers
    to |'
  prefs: []
  type: TYPE_TB
- en: '| **Variable instance log** |'
  prefs: []
  type: TYPE_TB
- en: '| **Field** | **Type** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| ID | BIGINT(20) | Unique identifier |'
  prefs: []
  type: TYPE_TB
- en: '| Log date | DATETIME | Time at which the change in this variable occurred
    |'
  prefs: []
  type: TYPE_TB
- en: '| External ID | VARCHAR(255) | External identifier associated with the process
    instance |'
  prefs: []
  type: TYPE_TB
- en: '| Old value | VARCHAR(255) | Previous value of the variable |'
  prefs: []
  type: TYPE_TB
- en: '| Process ID | VARCHAR(255) | Process ID of the definition |'
  prefs: []
  type: TYPE_TB
- en: '| Process instance ID | BIGINT(20) | Process instance identifier |'
  prefs: []
  type: TYPE_TB
- en: '| Value | VARCHAR(255) | Current value of the variable |'
  prefs: []
  type: TYPE_TB
- en: '| Variable ID | VARCHAR(255) | Identifier, variable name |'
  prefs: []
  type: TYPE_TB
- en: '| Variable instance ID | VARCHAR(255) | Additional information when a variable
    is defined on the composite node level to distinguish between top-level and embedded-level
    variables |'
  prefs: []
  type: TYPE_TB
- en: Apart from its use for security, this log information can be analyzed to find
    out various performance indicators of the process and the organization. The dashboard
    builder can be used to build reports from these logs.
  prefs: []
  type: TYPE_NORMAL
- en: Maintainability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The maintainability of a system can be considered to be a measure to determine
    how easily the repair actions can be performed. When we say repair, we need to
    discuss the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The ease of fixing issues in a deployed system (if any)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improvements in the system to match the changing business needs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Coping with infrastructure changes in the deployment environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the system of our consideration, a BPM, changes in business logic are more
    frequent. So, one of the main factors from a maintainability perspective is the
    ease of improving the process executable. This is one area that jBPM excels in;
    as we have already discussed in earlier chapters, jBPM provides a full-fledged
    modeling, simulation, and deployment tooling environment. The actors, from this
    perspective, business analysts and developers, can use the tooling to model, simulate,
    test, and deploy the process changes.
  prefs: []
  type: TYPE_NORMAL
- en: Another aspect is the infrastructure or the environment in which jBPM is deployed
    and maintained in production. jBPM supports multiple deployment architectures
    as discussed in [Chapter 8](ch08.html "Chapter 8. Integrating jBPM with Enterprise
    Architecture"), *Integrating jBPM with Enterprise Architecture*, and by default,
    it focuses on deployment in a JEE environment, where it is deployed inside a JEE
    application container, with persistent data storage in a conventional relational
    database.
  prefs: []
  type: TYPE_NORMAL
- en: 'The architecture of the system is based on the following standards:'
  prefs: []
  type: TYPE_NORMAL
- en: Modeling based on BPMN
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simulation based on BPsim
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Human tasks based on WS-HT
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Persistence based on JPA
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transaction management based on JTA
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The advantage is that jBPM easily fits into our current production environment,
    and as the environment evolves, so does jBPM with its development community playing
    an active role in enterprise middleware architecture. Compliance to the standards
    and modularity of the system ensures that our client doesn't fall into a vendor
    lock-in scenario, with parts of the system being easily replaceable.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous chapters, we have already explained the "how" of the functionalities
    discussed in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Fault tolerance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Fault tolerance indicates the ability to operate in a predictive manner, when
    one or more failures happen in the system. In Java-based applications, these faults
    are managed using exception handling mechanisms. jBPM is no exception; it uses
    the exception handling approach to be fault-tolerant.
  prefs: []
  type: TYPE_NORMAL
- en: Exception handling in process definitions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can specify the occurrence and the handling mechanisms that happen in a
    business process using BPMN elements, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Error events can be used to specify the occurrence of an unexpected situation.
    Compared to Java programming, this is similar to throwing an error.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compensation can be used to specify what to do when an error has occurred; this
    is similar to the catch operation construct in a Java program.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The advantage of using exception handling at a process level is that the exception
    scenarios are visible in the process, thus making the monitoring and analysis
    of these scenarios easier, thereby contributing to continuous improvements of
    the process.
  prefs: []
  type: TYPE_NORMAL
- en: Exception handling for domain-specific processes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When we define new custom workitem handlers that form custom, business-specific
    activities in a process, we can specify mechanisms to handle exception scenarios.
    jBPM by default provides the following decorators for handling an exception scenario
    in an activity:'
  prefs: []
  type: TYPE_NORMAL
- en: '`SignallingTaskHandlerDecorator`: This decorator catches an exception during
    the life cycle methods of an activity and signals the process instance using a
    configurable event. These events can be caught in the process definition, and
    subsequent actions can be taken. This decorator can be specified while registering
    the workitem handler to a session.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this example, we register a handler for sending mails by using `MailServiceHandler.class`,
    and during exception scenarios, the `"Mail-Service-Failed"` event is signaled
    to the process instance.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`LoggingTaskHandlerDcorator`: This decorator catches the exceptions during
    the life cycle methods of the activity of the logging mechanism. This feature
    can be used in less critical areas where a process exception can just be a warning
    in the log.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed the non-functional characteristics of jBPM that
    are critical in building a production-ready application based on BPM. Further,
    we discussed sample deployment architectures that are possible with jBPM to meet
    various requirements and configurations, and customization available to include
    certain characteristics in the jBPM system.
  prefs: []
  type: TYPE_NORMAL
