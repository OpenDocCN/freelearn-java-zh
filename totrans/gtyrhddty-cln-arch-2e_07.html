<html><head></head><body>
<div id="_idContainer059">
<h1 class="hapter-number" id="_idParaDest-62"><a id="_idTextAnchor062"/><span class="koboSpan" id="kobo.1.1">7</span></h1>
<h1 id="_idParaDest-63"><a id="_idTextAnchor063"/><span class="koboSpan" id="kobo.2.1">Implementing a Persistence Adapter</span></h1>
<p><span class="koboSpan" id="kobo.3.1">In </span><a href="B19916_07.xhtml"><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.4.1">Chapter 2</span></em></span></a><span class="koboSpan" id="kobo.5.1">, </span><em class="itali"><span class="koboSpan" id="kobo.6.1">What's Wrong with Layers?</span></em><span class="koboSpan" id="kobo.7.1"> I complained about a traditional layered architecture and claimed that it promotes </span><em class="itali"><span class="koboSpan" id="kobo.8.1">database-driven design</span></em><span class="koboSpan" id="kobo.9.1"> because, ultimately, everything depends on the persistence layer. </span><span class="koboSpan" id="kobo.9.2">In this chapter, we’ll have a look at how to make the persistence layer a plugin to the application layer to invert </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">this dependency.</span></span></p>
<h1 id="_idParaDest-64"><a id="_idTextAnchor064"/><span class="koboSpan" id="kobo.11.1">Dependency inversion</span></h1>
<p><span class="koboSpan" id="kobo.12.1">Instead of a persistence layer, we’ll talk about a persistence adapter that provides persistence </span><a id="_idIndexMarker131"/><span class="koboSpan" id="kobo.13.1">functionality to the domain services. </span><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.14.1">Figure 7</span></em></span><em class="itali"><span class="koboSpan" id="kobo.15.1">.1</span></em><span class="koboSpan" id="kobo.16.1"> shows how we </span><a id="_idIndexMarker132"/><span class="koboSpan" id="kobo.17.1">can apply the </span><a id="_idIndexMarker133"/><span class="koboSpan" id="kobo.18.1">Dependency Inversion Principle to do </span><span class="No-Break"><span class="koboSpan" id="kobo.19.1">just that:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer046">
<span class="koboSpan" id="kobo.20.1"><img alt="Figure 7.1 – The services from the core use ports to access the persistence adapter" src="image/Figure_07.1._B19916.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.21.1">Figure 7.1 – The services from the core use ports to access the persistence adapter</span></p>
<p><span class="koboSpan" id="kobo.22.1">Our domain services call port interfaces to access persistence functionality. </span><span class="koboSpan" id="kobo.22.2">These ports are implemented by a persistence adapter class that does the actual persistence work and is responsible for talking to </span><span class="No-Break"><span class="koboSpan" id="kobo.23.1">the database.</span></span></p>
<p><span class="koboSpan" id="kobo.24.1">In Hexagonal Architecture lingo, the persistence adapter is a </span><em class="itali"><span class="koboSpan" id="kobo.25.1">driven</span></em><span class="koboSpan" id="kobo.26.1"> or </span><em class="itali"><span class="koboSpan" id="kobo.27.1">outgoing</span></em><span class="koboSpan" id="kobo.28.1"> adapter because it’s called by our application and not the other </span><span class="No-Break"><span class="koboSpan" id="kobo.29.1">way around.</span></span></p>
<p><span class="koboSpan" id="kobo.30.1">The ports are effectively a layer of indirection between the domain services and the persistence code. </span><span class="koboSpan" id="kobo.30.2">Let’s remind ourselves that we’re adding this layer of indirection in order to be able to evolve the domain code without having to think about persistence problems, meaning without code dependencies on the persistence layer. </span><span class="koboSpan" id="kobo.30.3">Refactoring in persistence code will not lead to a code change in </span><span class="No-Break"><span class="koboSpan" id="kobo.31.1">the core.</span></span></p>
<p><span class="koboSpan" id="kobo.32.1">Naturally, at</span><a id="_idIndexMarker134"/><span class="koboSpan" id="kobo.33.1"> runtime, we still have a dependency from our application core to the persistence adapter. </span><span class="koboSpan" id="kobo.33.2">If we modify the code in the </span><a id="_idIndexMarker135"/><span class="koboSpan" id="kobo.34.1">persistence layer and introduce a bug, for example, we may still break the functionality in the application core. </span><span class="koboSpan" id="kobo.34.2">However, as long as the contracts of the ports are fulfilled, we’re free to do what we want in the persistence adapter without affecting </span><span class="No-Break"><span class="koboSpan" id="kobo.35.1">the core.</span></span></p>
<h1 id="_idParaDest-65"><a id="_idTextAnchor065"/><span class="koboSpan" id="kobo.36.1">Responsibilities of a persistence adapter</span></h1>
<p><span class="koboSpan" id="kobo.37.1">Let’s have a </span><a id="_idIndexMarker136"/><span class="koboSpan" id="kobo.38.1">look at what a persistence adapter </span><span class="No-Break"><span class="koboSpan" id="kobo.39.1">usually does:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.40.1">Takes </span><span class="No-Break"><span class="koboSpan" id="kobo.41.1">the input.</span></span></li>
<li><span class="koboSpan" id="kobo.42.1">Maps the input into </span><span class="No-Break"><span class="koboSpan" id="kobo.43.1">database format.</span></span></li>
<li><span class="koboSpan" id="kobo.44.1">Sends the input to </span><span class="No-Break"><span class="koboSpan" id="kobo.45.1">the database.</span></span></li>
<li><span class="koboSpan" id="kobo.46.1">Maps the database output into </span><span class="No-Break"><span class="koboSpan" id="kobo.47.1">application format.</span></span></li>
<li><span class="koboSpan" id="kobo.48.1">Returns </span><span class="No-Break"><span class="koboSpan" id="kobo.49.1">the output.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.50.1">The persistence adapter takes input through a port interface. </span><span class="koboSpan" id="kobo.50.2">The input model may be a domain entity or an object dedicated to a specific database operation, as specified by </span><span class="No-Break"><span class="koboSpan" id="kobo.51.1">the interface.</span></span></p>
<p><span class="koboSpan" id="kobo.52.1">It then maps the input model to a format it can work with to modify or query the database. </span><span class="koboSpan" id="kobo.52.2">In Java projects, we commonly use</span><a id="_idIndexMarker137"/><span class="koboSpan" id="kobo.53.1"> the </span><strong class="bold"><span class="koboSpan" id="kobo.54.1">Java Persistence API</span></strong><span class="koboSpan" id="kobo.55.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.56.1">JPA</span></strong><span class="koboSpan" id="kobo.57.1">) to talk to a database, so we might map the input into JPA entity objects that reflect the structure of the database tables. </span><span class="koboSpan" id="kobo.57.2">Depending on the context, mapping the input model into JPA entities may be a lot of work for little gain, so we’ll talk about strategies without mapping in </span><a href="B19916_09.xhtml#_idTextAnchor081"><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.58.1">Chapter 9</span></em></span></a><span class="koboSpan" id="kobo.59.1">, </span><em class="itali"><span class="koboSpan" id="kobo.60.1">Mapping </span></em><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.61.1">between Boundaries</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.62.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.63.1">Instead of using JPA or another object-relational mapping framework, we might use any other technique to talk to the database. </span><span class="koboSpan" id="kobo.63.2">We might map the input model into plain SQL statements and send these statements to the database, or we might serialize incoming data into files and read them back </span><span class="No-Break"><span class="koboSpan" id="kobo.64.1">from there.</span></span></p>
<p><span class="koboSpan" id="kobo.65.1">The important</span><a id="_idIndexMarker138"/><span class="koboSpan" id="kobo.66.1"> part is that the input model to the persistence adapter lies within the application core, and not within the persistence adapter itself, so that changes in the persistence adapter don’t affect </span><span class="No-Break"><span class="koboSpan" id="kobo.67.1">the core.</span></span></p>
<p><span class="koboSpan" id="kobo.68.1">Next, the persistence adapter queries the database and receives the </span><span class="No-Break"><span class="koboSpan" id="kobo.69.1">query results.</span></span></p>
<p><span class="koboSpan" id="kobo.70.1">Finally, it maps the database answer into the output model expected by the port and returns it. </span><span class="koboSpan" id="kobo.70.2">Again, it’s important that the output model lies within the application core and not within the persistence adapter to have the dependencies point in the </span><span class="No-Break"><span class="koboSpan" id="kobo.71.1">right direction.</span></span></p>
<p><span class="koboSpan" id="kobo.72.1">Aside from the fact that the input and output models lie in the application core instead of the persistence adapter itself, the responsibilities are not really different from those of a traditional </span><span class="No-Break"><span class="koboSpan" id="kobo.73.1">persistence layer.</span></span></p>
<p><span class="koboSpan" id="kobo.74.1">However, implementing a persistence adapter as described here will inevitably raise some questions that we probably wouldn’t ask when implementing a traditional persistence layer, as we’re so used to the traditional way that we don’t think </span><span class="No-Break"><span class="koboSpan" id="kobo.75.1">about them.</span></span></p>
<h1 id="_idParaDest-66"><a id="_idTextAnchor066"/><span class="koboSpan" id="kobo.76.1">Slicing port interfaces</span></h1>
<p><span class="koboSpan" id="kobo.77.1">One</span><a id="_idIndexMarker139"/><span class="koboSpan" id="kobo.78.1"> question that comes to mind when implementing services is how to slice the port interfaces that define the database operations available to the </span><span class="No-Break"><span class="koboSpan" id="kobo.79.1">application core.</span></span></p>
<p><span class="koboSpan" id="kobo.80.1">It’s a common practice to create a single repository interface that provides all database operations for a certain entity, as outlined in </span><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.81.1">Figure 7</span></em></span><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.82.1">.2</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.83.1">.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer047">
<span class="koboSpan" id="kobo.84.1"><img alt="Figure 7.2 – Centralizing all database operations into a single outgoing port interface makes all services depend on methods they don’t need" src="image/Figure_07.2._B19916.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.85.1">Figure 7.2 – Centralizing all database operations into a single outgoing port interface makes all services depend on methods they don’t need</span></p>
<p><span class="koboSpan" id="kobo.86.1">Each service that</span><a id="_idIndexMarker140"/><span class="koboSpan" id="kobo.87.1"> relies on database operations will then have a dependency on this single “broad” port interface, even if it uses only a single method from the interface. </span><span class="koboSpan" id="kobo.87.2">This means we have unnecessary dependencies in our </span><span class="No-Break"><span class="koboSpan" id="kobo.88.1">code base.</span></span></p>
<p><span class="koboSpan" id="kobo.89.1">Dependencies on methods that we don’t need in our context make the code harder to understand and test. </span><span class="koboSpan" id="kobo.89.2">Imagine that we’re writing a unit test for </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.90.1">RegisterAccountService</span></strong><span class="koboSpan" id="kobo.91.1"> from the preceding figure. </span><span class="koboSpan" id="kobo.91.2">Which of the methods of the </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.92.1">AccountRepository</span></strong><span class="koboSpan" id="kobo.93.1"> interface do we have to create a mock for? </span><span class="koboSpan" id="kobo.93.2">We have to first find out which of the </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.94.1">AccountRepository</span></strong><span class="koboSpan" id="kobo.95.1"> methods the service actually calls. </span><span class="koboSpan" id="kobo.95.2">Having mocked only part of the interface may lead to other problems, as the next person working on that test might expect the interface to be completely mocked and run into errors. </span><span class="koboSpan" id="kobo.95.3">So, they again have to do </span><span class="No-Break"><span class="koboSpan" id="kobo.96.1">some research.</span></span></p>
<p><span class="koboSpan" id="kobo.97.1">To put it in the words of Robert C. </span><span class="koboSpan" id="kobo.97.2">Martin, “</span><em class="itali"><span class="koboSpan" id="kobo.98.1">Depending on something that carries baggage that you don’t need can cause you troubles that you </span></em><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.99.1">didn’t expect.</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.100.1">”</span></span><span class="No-Break"><span id="footnote-025-backlink"><a class="_idFootnoteLink _idGenColorInherit" href="#footnote-025"><span class="koboSpan" id="kobo.101.1">1</span></a></span></span></p>
<div class="_idFootnote" epub:type="footnote" id="footnote-025">
<p><a class="_idFootnoteAnchor _idGenColorInherit" href="#footnote-025-backlink"><span class="koboSpan" id="kobo.102.1">1</span></a><span class="koboSpan" id="kobo.103.1">.	</span><span class="koboSpan" id="kobo.103.2">Interface Segregation Principle</span><em class="itali"><span class="koboSpan" id="kobo.104.1">: Clean Architecture</span></em><span class="koboSpan" id="kobo.105.1"> by Robert C. </span><span class="koboSpan" id="kobo.105.2">Martin, </span><span class="No-Break"><span class="koboSpan" id="kobo.106.1">page 86.</span></span></p>
</div>
<p><span class="koboSpan" id="kobo.107.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.108.1">Interface Segregation Principle</span></strong><span class="koboSpan" id="kobo.109.1"> provides</span><a id="_idIndexMarker141"/><span class="koboSpan" id="kobo.110.1"> an answer to this problem. </span><span class="koboSpan" id="kobo.110.2">It states that broad interfaces should be split into specific ones so that clients only know the methods they need. </span><span class="koboSpan" id="kobo.110.3">If we apply this to our outgoing ports, we might get a result as shown in </span><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.111.1">Figure 7</span></em></span><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.112.1">.3</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.113.1">.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer048">
<span class="koboSpan" id="kobo.114.1"><img alt="Figure 7.3 – Applying the Interface Segregation Principle removes unnecessary dependencies and makes the existing dependencies more visible" src="image/Figure_07.3._B19916.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.115.1">Figure 7.3 – Applying the Interface Segregation Principle removes unnecessary dependencies and makes the existing dependencies more visible</span></p>
<p><span class="koboSpan" id="kobo.116.1">Each service </span><a id="_idIndexMarker142"/><span class="koboSpan" id="kobo.117.1">now only depends on the methods it actually needs. </span><span class="koboSpan" id="kobo.117.2">What’s more, the names of the ports clearly state what they’re about. </span><span class="koboSpan" id="kobo.117.3">In a test, we no longer have to think about which methods to mock since most of the time, there is only one method </span><span class="No-Break"><span class="koboSpan" id="kobo.118.1">per port.</span></span></p>
<p><span class="koboSpan" id="kobo.119.1">Having very narrow ports such as these makes coding a plug-and-play experience. </span><span class="koboSpan" id="kobo.119.2">When working on a service, we just “plug in” the ports we need. </span><span class="koboSpan" id="kobo.119.3">There is no baggage to </span><span class="No-Break"><span class="koboSpan" id="kobo.120.1">carry around.</span></span></p>
<p><span class="koboSpan" id="kobo.121.1">Of course, the “one method per port” approach may not be applicable in all circumstances. </span><span class="koboSpan" id="kobo.121.2">There may be groups of database operations that are so cohesive and often used together that we may want to bundle them together in a </span><span class="No-Break"><span class="koboSpan" id="kobo.122.1">single interface.</span></span></p>
<h1 id="_idParaDest-67"><a id="_idTextAnchor067"/><span class="koboSpan" id="kobo.123.1">Slicing persistence adapters</span></h1>
<p><span class="koboSpan" id="kobo.124.1">In the </span><a id="_idIndexMarker143"/><span class="koboSpan" id="kobo.125.1">preceding figures, we saw a single persistence adapter class that implements all persistence ports. </span><span class="koboSpan" id="kobo.125.2">There is no rule, however, that forbids us to create more than one persistence adapter, as long as all persistence ports </span><span class="No-Break"><span class="koboSpan" id="kobo.126.1">are implemented.</span></span></p>
<p><span class="koboSpan" id="kobo.127.1">We might choose, for instance, to implement one persistence adapter per group of domain entities for which we need persistence operations (or aggregate in Domain-Driven Design lingo), as shown in </span><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.128.1">Figure 7</span></em></span><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.129.1">.4</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.130.1">.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer049">
<span class="koboSpan" id="kobo.131.1"><img alt="Figure 7.4 – We can create multiple persistence adapters, one for each aggregate" src="image/Figure_07.4._B19916.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.132.1">Figure 7.4 – We can create multiple persistence adapters, one for each aggregate</span></p>
<p><span class="koboSpan" id="kobo.133.1">This way, our </span><a id="_idIndexMarker144"/><span class="koboSpan" id="kobo.134.1">persistence adapters are automatically sliced along the seams of the domain that we support with </span><span class="No-Break"><span class="koboSpan" id="kobo.135.1">persistence functionality.</span></span></p>
<p><span class="koboSpan" id="kobo.136.1">We might split our persistence adapters into even more classes – for instance, when we want to implement a couple of persistence ports using JPA (or another object-relational mapper) and some other ports using plain SQL for better performance. </span><span class="koboSpan" id="kobo.136.2">We might then create one JPA adapter and one plain SQL adapter, each implementing a subset of the </span><span class="No-Break"><span class="koboSpan" id="kobo.137.1">persistence ports.</span></span></p>
<p><span class="koboSpan" id="kobo.138.1">Remember that our domain code doesn’t care about which class ultimately fulfills the contracts defined by the persistence ports. </span><span class="koboSpan" id="kobo.138.2">We’re free to do as we see fit in the persistence layer, as long as all ports </span><span class="No-Break"><span class="koboSpan" id="kobo.139.1">are implemented.</span></span></p>
<p><span class="koboSpan" id="kobo.140.1">The </span><em class="itali"><span class="koboSpan" id="kobo.141.1">one persistence adapter per aggregate</span></em><span class="koboSpan" id="kobo.142.1"> approach is also a good foundation to separate the persistence needs for multiple bounded contexts in the future. </span><span class="koboSpan" id="kobo.142.2">Say, after a time, we identify a bounded context responsible for use cases around billing. </span><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.143.1">Figure 7</span></em></span><em class="itali"><span class="koboSpan" id="kobo.144.1">.5</span></em><span class="koboSpan" id="kobo.145.1"> adds that new domain to </span><span class="No-Break"><span class="koboSpan" id="kobo.146.1">the application.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer050">
<span class="koboSpan" id="kobo.147.1"><img alt="Figure 7.5 – If we want to create hard boundaries between bounded contexts, each bounded context should have its own persistence adapter(s)" src="image/Figure_07.5._B19916.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.148.1">Figure 7.5 – If we want to create hard boundaries between bounded contexts, each bounded context should have its own persistence adapter(s)</span></p>
<p><span class="koboSpan" id="kobo.149.1">Each </span><a id="_idIndexMarker145"/><strong class="bold"><span class="koboSpan" id="kobo.150.1">bounded context</span></strong><span class="koboSpan" id="kobo.151.1"> has its own persistence adapter (or potentially more than one, as described previously). </span><span class="koboSpan" id="kobo.151.2">The term “bounded context” implies boundaries, which means that services of the </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.152.1">account</span></strong><span class="koboSpan" id="kobo.153.1"> context may not access persistence adapters of the </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.154.1">billing</span></strong><span class="koboSpan" id="kobo.155.1"> context, and vice versa. </span><span class="koboSpan" id="kobo.155.2">If one context needs something of the other, they can call each other’s domain services, or we can introduce an application service as a coordinator between the bounded contexts. </span><span class="koboSpan" id="kobo.155.3">We will talk more about this topic in </span><a href="B19916_13.xhtml#_idTextAnchor112"><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.156.1">Chapter 13</span></em></span></a><span class="koboSpan" id="kobo.157.1">, </span><em class="itali"><span class="koboSpan" id="kobo.158.1">Managing Multiple </span></em><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.159.1">Bounded Contexts</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.160.1">.</span></span></p>
<h1 id="_idParaDest-68"><a id="_idTextAnchor068"/><span class="koboSpan" id="kobo.161.1">An example with Spring Data JPA</span></h1>
<p><span class="koboSpan" id="kobo.162.1">Let’s have a look at a </span><a id="_idIndexMarker146"/><span class="koboSpan" id="kobo.163.1">code example that implements </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.164.1">AccountPersistenceAdapter</span></strong><span class="koboSpan" id="kobo.165.1"> from the preceding figures. </span><span class="koboSpan" id="kobo.165.2">This adapter will have to save and load accounts to and from the database. </span><span class="koboSpan" id="kobo.165.3">We already saw the </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.166.1">Account</span></strong><span class="koboSpan" id="kobo.167.1"> entity in </span><a href="B19916_05.xhtml#_idTextAnchor044"><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.168.1">Chapter 5</span></em></span></a><span class="koboSpan" id="kobo.169.1">, </span><em class="itali"><span class="koboSpan" id="kobo.170.1">Implementing a Use Case</span></em><span class="koboSpan" id="kobo.171.1">, but here is its skeleton again </span><span class="No-Break"><span class="koboSpan" id="kobo.172.1">for reference:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer051">
<span class="koboSpan" id="kobo.173.1"><img alt="" src="image/code-7.1.jpg"/></span>
</div>
</div>
<p class="allout-heading"><span class="koboSpan" id="kobo.174.1">Note</span></p>
<p class="allout"><span class="koboSpan" id="kobo.175.1">The </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.176.1">Account</span></strong><span class="koboSpan" id="kobo.177.1"> class is not a simple data class with getters and setters but instead tries to be as immutable as possible. </span><span class="koboSpan" id="kobo.177.2">It only provides factory methods that create an account in a valid state, and all mutating methods do some validation, such as checking the account balance before withdrawing money, so that we cannot create an invalid </span><span class="No-Break"><span class="koboSpan" id="kobo.178.1">domain model.</span></span></p>
<p><span class="koboSpan" id="kobo.179.1">We’ll use </span><a id="_idIndexMarker147"/><span class="koboSpan" id="kobo.180.1">Spring Data JPA to talk to the database, so we also need </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.181.1">@Entity</span></strong><span class="koboSpan" id="kobo.182.1">-annotated classes to represent the database state of </span><span class="No-Break"><span class="koboSpan" id="kobo.183.1">an account:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer052">
<span class="koboSpan" id="kobo.184.1"><img alt="" src="image/code-7.2.jpg"/></span>
</div>
</div>
<div>
<div class="IMG---Figure" id="_idContainer053">
<span class="koboSpan" id="kobo.185.1"><img alt="" src="image/code-7.3.jpg"/></span>
</div>
</div>
<p><span class="koboSpan" id="kobo.186.1">The state of an </span><a id="_idIndexMarker148"/><span class="koboSpan" id="kobo.187.1">account consists merely of an ID at this stage. </span><span class="koboSpan" id="kobo.187.2">Later, additional fields such as a user ID may be added. </span><span class="koboSpan" id="kobo.187.3">More interesting is </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.188.1">ActivityJpaEntity</span></strong><span class="koboSpan" id="kobo.189.1">, which contains all the activities of a specific account. </span><span class="koboSpan" id="kobo.189.2">We could have connected </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.190.1">ActivitiyJpaEntity</span></strong><span class="koboSpan" id="kobo.191.1"> with </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.192.1">AccountJpaEntity</span></strong><span class="koboSpan" id="kobo.193.1"> via JPA’s </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.194.1">@ManyToOne</span></strong><span class="koboSpan" id="kobo.195.1"> or </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.196.1">@OneToMany</span></strong><span class="koboSpan" id="kobo.197.1"> annotations to mark the relation between them, but we have opted to leave this out for now, as it adds side effects to the database queries. </span><span class="koboSpan" id="kobo.197.2">In fact, at this stage, it would probably be easier to use a simpler object-relational mapper than JPA to implement the persistence adapter, but we will use it anyway because we think we might need it in </span><span class="No-Break"><span class="koboSpan" id="kobo.198.1">the future.</span></span><span class="No-Break"><span id="footnote-024-backlink"><a class="_idFootnoteLink _idGenColorInherit" href="#footnote-024"><span class="koboSpan" id="kobo.199.1">2</span></a></span></span></p>
<div class="_idFootnote" epub:type="footnote" id="footnote-024">
<p><a class="_idFootnoteAnchor _idGenColorInherit" href="#footnote-024-backlink"><span class="koboSpan" id="kobo.200.1">2</span></a><span class="koboSpan" id="kobo.201.1">.	</span><span class="koboSpan" id="kobo.201.2">Java Persistence API: does that sound familiar to you? </span><span class="koboSpan" id="kobo.201.3">You choose JPA as an OR mapper because it’s the thing people use for this problem. </span><span class="koboSpan" id="kobo.201.4">A couple of months into development, you curse eager and lazy loading and the caching features, wishing for something simpler. </span><span class="koboSpan" id="kobo.201.5">JPA is a great tool, but for many problems, simpler solutions may be, well, simpler. </span><span class="koboSpan" id="kobo.201.6">Take a look at Spring Data JDBC or jOOQ as </span><span class="No-Break"><span class="koboSpan" id="kobo.202.1">an alternative.</span></span></p>
</div>
<p><span class="koboSpan" id="kobo.203.1">Next, we will use Spring Data to create repository interfaces that provide basic </span><strong class="bold"><span class="koboSpan" id="kobo.204.1">C</span></strong><strong class="bold"><span class="koboSpan" id="kobo.205.1">reate</span></strong><span class="koboSpan" id="kobo.206.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.207.1">Read</span></strong><span class="koboSpan" id="kobo.208.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.209.1">Update</span></strong><span class="koboSpan" id="kobo.210.1">, and </span><strong class="bold"><span class="koboSpan" id="kobo.211.1">Delete</span></strong><span class="koboSpan" id="kobo.212.1"> (CRUD) functionality out of the box, as well as custom queries to load certain activities</span><a id="_idIndexMarker149"/><span class="koboSpan" id="kobo.213.1"> from </span><span class="No-Break"><span class="koboSpan" id="kobo.214.1">the database:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer054">
<span class="koboSpan" id="kobo.215.1"><img alt="" src="image/code-7.4.jpg"/></span>
</div>
</div>
<div>
<div class="IMG---Figure" id="_idContainer055">
<span class="koboSpan" id="kobo.216.1"><img alt="" src="image/code-7.5.jpg"/></span>
</div>
</div>
<p><span class="koboSpan" id="kobo.217.1">Spring Boot will automatically find these repositories, and Spring Data will do its magic to provide an implementation behind the repository interface that will actually talk to </span><span class="No-Break"><span class="koboSpan" id="kobo.218.1">the database.</span></span></p>
<p><span class="koboSpan" id="kobo.219.1">Having JPA entities and repositories in place, we can implement the persistence adapter that provides the persistence functionality to </span><span class="No-Break"><span class="koboSpan" id="kobo.220.1">our application:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer056">
<span class="koboSpan" id="kobo.221.1"><img alt="" src="image/code-7.6a.jpg"/></span>
</div>
</div>
<div>
<div class="IMG---Figure" id="_idContainer057">
<span class="koboSpan" id="kobo.222.1"><img alt="" src="image/code-7.6b.jpg"/></span>
</div>
</div>
<p><span class="koboSpan" id="kobo.223.1">The persistence adapter implements two ports that are needed by the application, </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.224.1">LoadAccountPort</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.225.1">and </span></span><span class="No-Break"><strong class="sour e-inline"><span class="koboSpan" id="kobo.226.1">UpdateAccountStatePort</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.227.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.228.1">To load an account from the database, we load it from </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.229.1">AccountRepository</span></strong><span class="koboSpan" id="kobo.230.1"> and then load the activities of this account for a certain time window </span><span class="No-Break"><span class="koboSpan" id="kobo.231.1">through </span></span><span class="No-Break"><strong class="sour e-inline"><span class="koboSpan" id="kobo.232.1">ActivityRepository</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.233.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.234.1">To create a valid </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.235.1">Account</span></strong><span class="koboSpan" id="kobo.236.1"> domain entity, we also need the balance the account had before the start of this activity window, so we get the sum of all withdrawals and deposits of this account from </span><span class="No-Break"><span class="koboSpan" id="kobo.237.1">the database.</span></span></p>
<p><span class="koboSpan" id="kobo.238.1">Finally, we map all this data to an </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.239.1">Account</span></strong><span class="koboSpan" id="kobo.240.1"> domain entity and return it to </span><span class="No-Break"><span class="koboSpan" id="kobo.241.1">the caller.</span></span></p>
<p><span class="koboSpan" id="kobo.242.1">To update the</span><a id="_idIndexMarker150"/><span class="koboSpan" id="kobo.243.1"> state of an account, we iterate over all activities of the </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.244.1">Account</span></strong><span class="koboSpan" id="kobo.245.1"> entity and check whether they have IDs. </span><span class="koboSpan" id="kobo.245.2">If they don’t, they are new activities, which we then persist </span><span class="No-Break"><span class="koboSpan" id="kobo.246.1">through </span></span><span class="No-Break"><strong class="sour e-inline"><span class="koboSpan" id="kobo.247.1">ActivityRepository</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.248.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.249.1">In the scenario described previously, we have a two-way mapping between the </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.250.1">Account</span></strong><span class="koboSpan" id="kobo.251.1"> and </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.252.1">Activity</span></strong><span class="koboSpan" id="kobo.253.1"> domain models and the </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.254.1">AccountJpaEntity</span></strong><span class="koboSpan" id="kobo.255.1"> and </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.256.1">ActivityJpaEntity</span></strong><span class="koboSpan" id="kobo.257.1"> database models. </span><span class="koboSpan" id="kobo.257.2">Why do we make the effort to map back and forth? </span><span class="koboSpan" id="kobo.257.3">Couldn’t we just move the JPA annotations to the </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.258.1">Account</span></strong><span class="koboSpan" id="kobo.259.1"> and </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.260.1">Activity</span></strong><span class="koboSpan" id="kobo.261.1"> classes and directly store them as entities in </span><span class="No-Break"><span class="koboSpan" id="kobo.262.1">the database?</span></span></p>
<p><span class="koboSpan" id="kobo.263.1">Such a </span><em class="itali"><span class="koboSpan" id="kobo.264.1">no-mapping</span></em><span class="koboSpan" id="kobo.265.1"> strategy may be a valid choice, as we’ll see in </span><a href="B19916_09.xhtml#_idTextAnchor081"><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.266.1">Chapter 9</span></em></span></a><span class="koboSpan" id="kobo.267.1">, </span><em class="itali"><span class="koboSpan" id="kobo.268.1">Mapping between Boundaries</span></em><span class="koboSpan" id="kobo.269.1">, when we talk about mapping strategies. </span><span class="koboSpan" id="kobo.269.2">However, JPA then forces us to make compromises in the domain model. </span><span class="koboSpan" id="kobo.269.3">For instance, JPA requires entities to have a no-args constructor. </span><span class="koboSpan" id="kobo.269.4">Alternatively, it might be that in the persistence layer, a “many-to-one” relationship makes sense from a performance point of view, but in the domain model, we want this relationship to be the other </span><span class="No-Break"><span class="koboSpan" id="kobo.270.1">way around.</span></span></p>
<p><span class="koboSpan" id="kobo.271.1">So, if we want to create a rich domain model without making compromises to the persistence layer, we’ll have to map between the domain model and the </span><span class="No-Break"><span class="koboSpan" id="kobo.272.1">persistence model.</span></span></p>
<h1 id="_idParaDest-69"><a id="_idTextAnchor069"/><span class="koboSpan" id="kobo.273.1">What about database transactions?</span></h1>
<p><span class="koboSpan" id="kobo.274.1">We have not touched </span><a id="_idIndexMarker151"/><span class="koboSpan" id="kobo.275.1">on the topic of database transactions yet. </span><span class="koboSpan" id="kobo.275.2">Where do we put our </span><span class="No-Break"><span class="koboSpan" id="kobo.276.1">transaction boundaries?</span></span></p>
<p><span class="koboSpan" id="kobo.277.1">A transaction should span all write operations to the database that are performed within a certain use case, ensuring that all those operations can be rolled back together if one of </span><span class="No-Break"><span class="koboSpan" id="kobo.278.1">them fails.</span></span></p>
<p><span class="koboSpan" id="kobo.279.1">Since the persistence </span><a id="_idIndexMarker152"/><span class="koboSpan" id="kobo.280.1">adapter doesn’t know which other database operations are part of the same use case, it cannot decide when to open and close a transaction. </span><span class="koboSpan" id="kobo.280.2">We have to delegate this responsibility to the services that orchestrate the calls to the </span><span class="No-Break"><span class="koboSpan" id="kobo.281.1">persistence adapter.</span></span></p>
<p><span class="koboSpan" id="kobo.282.1">The easiest way to do this with Java and Spring is to add the </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.283.1">@Transactional</span></strong><span class="koboSpan" id="kobo.284.1"> annotation to the domain service classes so that Spring will wrap all public methods with </span><span class="No-Break"><span class="koboSpan" id="kobo.285.1">a transaction:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer058">
<span class="koboSpan" id="kobo.286.1"><img alt="" src="image/code-7.7.jpg"/></span>
</div>
</div>
<p><span class="koboSpan" id="kobo.287.1">But doesn’t the </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.288.1">@Transactional</span></strong><span class="koboSpan" id="kobo.289.1"> annotation introduce a dependency on a framework that we don’t want to have in our precious domain code? </span><span class="koboSpan" id="kobo.289.2">Well, yes, we have a dependency on the annotation, but we get transaction handling for that dependency! </span><span class="koboSpan" id="kobo.289.3">We wouldn’t want to build our own transaction mechanism just for the code to </span><span class="No-Break"><span class="koboSpan" id="kobo.290.1">stay “pure.”</span></span></p>
<h1 id="_idParaDest-70"><a id="_idTextAnchor070"/><span class="koboSpan" id="kobo.291.1">How does this help me build maintainable software?</span></h1>
<p><span class="koboSpan" id="kobo.292.1">Building a persistence adapter that acts as a plugin to the domain code frees the domain code from persistence details so that we can build a rich </span><span class="No-Break"><span class="koboSpan" id="kobo.293.1">domain model.</span></span></p>
<p><span class="koboSpan" id="kobo.294.1">Using narrow port interfaces, we’re flexible to implement one port in one way and another port in another way, perhaps even with a different persistence technology, without the application noticing. </span><span class="koboSpan" id="kobo.294.2">We can even switch out the complete persistence layer, as long as the port contracts </span><span class="No-Break"><span class="koboSpan" id="kobo.295.1">are obeyed.</span></span><span class="No-Break"><span id="footnote-023-backlink"><a class="_idFootnoteLink _idGenColorInherit" href="#footnote-023"><span class="koboSpan" id="kobo.296.1">3</span></a></span></span></p>
<div class="_idFootnote" epub:type="footnote" id="footnote-023">
<p><a class="_idFootnoteAnchor _idGenColorInherit" href="#footnote-023-backlink"><span class="koboSpan" id="kobo.297.1">3</span></a><span class="koboSpan" id="kobo.298.1">.	</span><span class="koboSpan" id="kobo.298.2">Switching out the persistence layer: while I have seen it happen a few times (and for good reasons), the probability of having to switch out the whole persistence layer is usually rather low. </span><span class="koboSpan" id="kobo.298.3">Even then, having dedicated persistence ports is still worthwhile, because it increases testability. </span><span class="koboSpan" id="kobo.298.4">We can easily implement an in-memory persistence adapter to be used in tests, </span><span class="No-Break"><span class="koboSpan" id="kobo.299.1">for example.</span></span></p>
</div>
<p><span class="koboSpan" id="kobo.300.1">Now that we’ve built a domain model and some adapters, let’s take a look at how we can test that they’re really doing what we expect them </span><span class="No-Break"><span class="koboSpan" id="kobo.301.1">to do.</span></span></p>
</div>
</body></html>