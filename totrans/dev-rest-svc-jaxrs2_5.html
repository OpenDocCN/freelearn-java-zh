<html><head></head><body><div class="chapter" title="Chapter&#xA0;5.&#xA0;RESTful Web Services by Example"><div class="titlepage"><div><div><h1 class="title"><a id="ch05"/>Chapter 5. RESTful Web Services by Example</h1></div></div></div><p>The APIs and technologies introduced and discussed in the previous chapters are suitable for different types of projects and use cases. This chapter covers how these APIs and technologies can fit into solutions and case-oriented software systems.</p><p>After a brief introduction of what the application is supposed to do, we will break it down and focus on every component and technology used. So bring on the extra cup of mocha and join the fun.</p><p>This chapter will cover the following two samples:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Event notification application showing Server-sent Events, <a id="id388" class="indexterm"/><span class="strong"><strong>Async Servlet</strong></span>, JSON-P API, and JAX-RS based on <a id="id389" class="indexterm"/>the <span class="strong"><strong>Twitter Search API</strong></span></li><li class="listitem" style="list-style-type: disc">Library application showing JAX-RS API, WebSockets, JSON-P API, and asynchronous JAX-RS resources to form an end-to-end solution</li></ul></div><div class="section" title="Event notification application"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec31"/>Event notification application</h1></div></div></div><p>The Twitter-based<a id="id390" class="indexterm"/> application is the first sample application that will demonstrate a HTML5-based application developed on top of Server-sent Events, JAX-RS 2.0 API, Asynchronous Servlet, and the Twitter Search API together, to dynamically update a page with more search results periodically.</p><p>The build system used for the sample application is <a id="id391" class="indexterm"/>
<span class="strong"><strong>Maven</strong></span> and the sample can be deployed in any Java EE 7-compatible application server notably GlassFish v4.0<a id="id392" class="indexterm"/>, an open source reference implementation of the Java EE 7 specification.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note08"/>Note</h3><p>Apache Maven<a id="id393" class="indexterm"/> is a build management tool. More information about Maven can be <a id="id394" class="indexterm"/>found at <a class="ulink" href="http://maven.apache.org">http://maven.apache.org</a> and more information about <a id="id395" class="indexterm"/>GlassFish can be found at<a class="ulink" href="http:// https://glassfish.java.net/"> https://glassfish.java.net/</a>
</p></div></div><div class="section" title="The project's layout"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec40"/>The project's layout</h2></div></div></div><p>The project's directory<a id="id396" class="indexterm"/> layout follows <a id="id397" class="indexterm"/>the standard Maven structure, which is briefly explained in the following table:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Source code</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">src/main/java</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This directory contains all the sources required by the library application.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">src/main/webapp</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This directory contains the JavaScript files, html files, and <code class="literal">WEB-INF/web.xml</code> file.</p>
</td></tr></tbody></table></div></div><div class="section" title="The event notification GUI"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec41"/>The event notification GUI</h2></div></div></div><p>The event notification <a id="id398" class="indexterm"/>application consists of one screen, which serves <a id="id399" class="indexterm"/>as the vehicle for showing dynamic updates based on the Twitter feeds. The screen is shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/8125EN_05_01.jpg" alt="The event notification GUI"/></div><p>The application is a <a id="id400" class="indexterm"/>basic sample showing updates as the events <a id="id401" class="indexterm"/>carrying the updates happen and are received. This could be a newer tweet coming in, or Facebook friends' updates, or any other type of events consumable by any of the Java EE-managed components. The key point is, once the channel of communication is established with the server, it is up to the server to keep sending updates as they occur. The client does not poll for updates.</p><p>In this sample, when the servlet is loaded there is an <a id="id402" class="indexterm"/>
<span class="strong"><strong>EJB timer</strong></span>, which is run every 10 seconds and activates a CDI bean that uses the Twitter Search API to get new tweets. The Twitter Search API returns the tweets in JSON format. This tweet information is then sent to the client using Server-sent Events support with JAX-RS. On the client side the JSON data is parsed to display certain information on the screen.</p></div><div class="section" title="A detailed look at the event notification application"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec42"/>A detailed look at the event notification application</h2></div></div></div><p>After an initial <a id="id403" class="indexterm"/>introduction to what the application is supposed to do, let's dissect it further and study each individual component that builds this application.</p><p>This is the order in which the details of the application will be covered:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <code class="literal">web.xml</code></li><li class="listitem" style="list-style-type: disc">The implementation of the Application class</li><li class="listitem" style="list-style-type: disc">The JAX-RS resource used in the application</li><li class="listitem" style="list-style-type: disc">The Asynchronous Servlet client used by the application</li><li class="listitem" style="list-style-type: disc">The EJB that interacts with the Twitter Search API</li></ul></div><div class="section" title="The web.xml"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec22"/>The web.xml</h3></div></div></div><p>To set up the application, <a id="id404" class="indexterm"/>configure the servlet deployment descriptor<a id="id405" class="indexterm"/> <code class="literal">web.xml</code> as follows:</p><div class="informalexample"><pre class="programlisting">&lt;display-name&gt;jersey-sse-twitter-sample&lt;/display-name&gt;

&lt;servlet&gt;
  &lt;servlet-name&gt;Jersey application&lt;/servlet-name&gt;
  &lt;servlet-class&gt;org.glassfish.jersey.servlet.ServletContainer&lt;/servlet-class&gt;
  &lt;init-param&gt;
    &lt;param-name&gt;javax.ws.rs.Application&lt;/param-name&gt;
    &lt;param-value&gt;org.glassfish.jersey.sample.sse.MyApplication&lt;/param-value&gt;
  &lt;/init-param&gt;
  &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
  &lt;async-supported&gt;true&lt;/async-supported&gt;
&lt;/servlet&gt;
&lt;servlet-mapping&gt;
  &lt;servlet-name&gt;Jersey application&lt;/servlet-name&gt;
  &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;</pre></div><p>
<code class="literal">MyApplication</code> is a subclass of <code class="literal">javax.ws.rs.Application</code>. It is used to register the JAX-RS resource so that it is known the JAX-RS API.</p><p>The <code class="literal">async-supported</code> element is set to <code class="literal">true</code> to indicate that the servlet supports asynchronous processing.</p></div><div class="section" title="The implementation of the Application class"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec23"/>The implementation of the Application class</h3></div></div></div><p>Here is the <a id="id406" class="indexterm"/>implementation of the <code class="literal">Application</code> subclass:</p><div class="informalexample"><pre class="programlisting">public class MyApplication extends Application {

  Set&lt;Class&lt;?&gt;&gt; classes = new HashSet&lt;Class&lt;?&gt;&gt;() {
    { add(ServerSentEventsResource.class);
      add(SseFeature.class);
    }
  };

  @Override
  public Set&lt;Class&lt;?&gt;&gt; getClasses() {
    return classes;
  }
}</pre></div><p>The <code class="literal">getClasses()</code> method is overridden to return the:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">ServerSentEventsResource.class</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">SseFeature.class</code></li></ul></div><p>The <code class="literal">ServerSentEventsResource</code> class is a simple JAX-RS that sends the JSON data from the Twitter Search API as Server-sent Events. We shall look at the<span class="strong"><strong> </strong></span>
<code class="literal">ServerSentEventsResource</code> in more detail in the next section.</p><p>The <code class="literal">SseFeature.class</code> is an implementation provided by <span class="strong"><strong>Jersey</strong></span> to support the <code class="literal">ServerSentEvents</code> feature. It will ensure the data is of the media type <code class="literal">"text/event-stream"</code>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip05"/>Tip</h3><p>To enable Server-sent Events feature, add <code class="literal">SseFeatures.class</code> to the list of classes returned by the <code class="literal">getClasses()</code> method in the implementation of the <code class="literal">javax.ws.rs.Application</code>.</p></div></div></div><div class="section" title="The JAX-RS resource used by the application"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec24"/>The JAX-RS resource used by the application</h3></div></div></div><p>Here is the<a id="id407" class="indexterm"/> source code of the <code class="literal">ServerSentEventsResource.java</code>. This is a simple POJO, annotated with <code class="literal">@Path</code> to <a id="id408" class="indexterm"/>identify the URI of the resource.</p><div class="informalexample"><pre class="programlisting">@Path("twittersse")
public class ServerSentEventsResource {

  static EventOutput eventOutput = new EventOutput();

  @GET
  @Produces(SseFeature.SERVER_SENT_EVENTS)
<span class="strong"><strong>  public EventOutput getMessage() {</strong></span>
    return eventOutput;
  }

  @POST
  @Consumes(MediaType.TEXT_PLAIN)
<span class="strong"><strong>  public void sendMessage(String message) throws IOException {</strong></span>
    eventOutput.write(new OutboundEvent.Builder().name("custom-message").data(String.class, message).build());
  }
}</pre></div><p>The <code class="literal">EventOutput</code> class<a id="id409" class="indexterm"/> is a channel that provides the<a id="id410" class="indexterm"/> outbound Server-sent Events. When we return the <code class="literal">EventOutput</code> object from the <code class="literal">getMessage()</code> method, the Jersey implementation keeps the connection open so that the Server-sent Events can be sent. One instance of this class corresponds with exactly one HTTP connection.</p><p>The <code class="literal">sendMessage()</code> method writes the message using the <code class="literal">eventOutput.write()</code> method. To write Server-sent Events, we use the <code class="literal">OutboundEvent.Builder()</code> method. A name <code class="literal">"custom-message"</code> is passed to this <code class="literal">OutboundEvent.Builder()</code> method and then we pass the message object to the <code class="literal">build()</code> method. The message object contains the tweets-related information for our sample.</p><p>Additionally, <code class="literal">OutboundEvent.Builder().id(id)</code> can be used to associate an ID with a Server-sent Event which is not covered previously.</p></div><div class="section" title="The Asynchronous Servlet client used by the application"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec25"/>The Asynchronous Servlet client used by the application</h3></div></div></div><p>In normal<a id="id411" class="indexterm"/> request response<a id="id412" class="indexterm"/> scenarios, a thread is kept running for each request till the response becomes available. This turns into a bottleneck in cases when the backend is taking a long time to process the requests, and the thread processing the request waits for the backend to finish preparing the required response and thus cannot take on any new incoming request.</p><p>One way to solve this would be to save the request in a centralized queue and send the request as the threads are available to process the request. Calling the <code class="literal">startAsync()</code> method stores the request/response pair in a queue, the <code class="literal">doGet()</code> method returns, and the calling thread can be recycled.</p><p>The following section discusses these concepts of asynchronous request processing with servlets.</p><p>Here is the code of the Servlet client for the application:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>@WebServlet(name = "TestClient", urlPatterns = {"/TestClient"}, asyncSupported = true)</strong></span>
public class TestClient extends HttpServlet {
  
  private final static String TARGET_URI = "http://localhost:8080/jersey-sse-twitter-sample/twittersse";</pre></div><p>This is a<a id="id413" class="indexterm"/> Servlet with <code class="literal">urlPatterns={"/TestClient"}</code> and the <code class="literal">async-supported</code> attribute set to true. The<a id="id414" class="indexterm"/> <code class="literal">async-supported</code> attribute instructs the container that this servlet process the incoming requests asynchronously and thus the container should make the necessary modification in request allocation of the processing threads.</p><p>The next snippet shows the implementation of the <code class="literal">service()</code> method that can handle the <code class="literal">GET</code> and <code class="literal">POST</code> requests:</p><div class="informalexample"><pre class="programlisting">/**
* Processes requests for both HTTP
* &lt;code&gt;GET&lt;/code&gt; and
* &lt;code&gt;POST&lt;/code&gt; methods.
*
* @param request  servlet request
* @param response servlet response
* @throws ServletException if a servlet-specific error occurs
* @throws IOException      if an I/O error occurs
*/
@Override
protected void service(final HttpServletRequest request, final HttpServletResponse response)
throws ServletException, IOException {
  response.setContentType("text/html;charset=UTF-8");
  
  try {
    
<span class="strong"><strong>    final AsyncContext asyncContext = request.startAsync();</strong></span>
<span class="strong"><strong>    asyncContext.setTimeout(600000);</strong></span>
<span class="strong"><strong>    asyncContext.addListener(new AsyncListener() {</strong></span>
      
      @Override
      public void onComplete(AsyncEvent event) throws IOException {
      }

      @Override
      public void onTimeout(AsyncEvent event) throws IOException {
        System.out.println("Timeout" + event.toString());
      }

      @Override
      public void onError(AsyncEvent event) throws IOException {
        System.out.println("Error" + event.toString());
      }

      @Override
      public void onStartAsync(AsyncEvent event) throws IOException {
      }
    });


<span class="strong"><strong>    Thread t = new Thread(new AsyncRequestProcessor(asyncContext));</strong></span>
    t.start();

    } catch (Exception e) {
    e.printStackTrace();
  }

}</pre></div><p>In the<a id="id415" class="indexterm"/> preceding<a id="id416" class="indexterm"/> snippet, an instance of the <code class="literal">AsyncContext</code> object is obtained by invoking the <code class="literal">request.startAsync()</code> method.</p><p>The <code class="literal">asyncContext.setTimeout(60000)</code> method indicates a timeout in milliseconds for the asynchronous operations of the servlet.</p><p>An implementation of an <code class="literal">AsyncListener</code> interface is added to the asynchronous context using the <code class="literal">asyncContext.addListener()</code> method.</p><p>After the <code class="literal">startAsync()</code> method is called on the request, an <code class="literal">AsyncEvent </code>object is sent to the implementation of the <code class="literal">AsyncListener</code> interface as the operation completes, there is an error, or the operation times out. As shown previously, we have an implementation of the <code class="literal">AsyncListener</code> interface that can implement the following methods <code class="literal">onComplete()</code>, <code class="literal">onError()</code>, <code class="literal">onTimeOut()</code>, or <code class="literal">onStartAsync()</code>.</p><p>The <code class="literal">AsyncRequestProcessor</code> class shown in the following code is the <code class="literal">Runnable</code> instance of the thread, which does the actual work. The <code class="literal">AsyncRequestProcessor</code> class registers the <code class="literal">EventSource</code> object to listen for the Server-sent Events, which are sent by the JAX-RS <code class="literal">ServerSentEventsResource.java</code>, covered earlier. As events occur the <code class="literal">onEvent()</code> callback<a id="id417" class="indexterm"/> is triggered and <a id="id418" class="indexterm"/>JSONP is used to parse the events.</p><div class="informalexample"><pre class="programlisting">class AsyncRequestProcessor implements Runnable {

  private final AsyncContext context;

  public AsyncRequestProcessor(AsyncContext context) {
    this.context = context;
  }

  @Override
  public void run() {
    Client client = ClientBuilder.newClient();
    context.getResponse().setContentType("text/html");
    final javax.ws.rs.client.WebTarget webTarget;
    try {
      final PrintWriter out = context.getResponse().getWriter();
      webTarget = client.target(new URI(TARGET_URI));
      out.println("&lt;html&gt;");
      out.println("&lt;head&gt;");
      out.println("&lt;title&gt;Glassfish SSE TestClient&lt;/title&gt;");
      out.println("&lt;/head&gt;");
      out.println("&lt;body&gt;");
      out.println("&lt;h1&gt;");
      out.println("Glassfish tweets");
      out.println("&lt;/h1&gt;");
      // EventSource eventSource = new EventSource(webTarget, executorService) {
        EventSource eventSource = new EventSource(webTarget) {
          @Override
          public void onEvent(InboundEvent inboundEvent) {
            try {
              //get the JSON data and parse it
              JSONObject jsonObject = JSONObject.fromObject(inboundEvent.getData(String.class,
              MediaType.APPLICATION_JSON_TYPE));
              //get the JSON data and parse it
              JsonReader jsonReader = Json.createReader (new ByteArrayInputStream(inboundEvent.getData(String.class,
              MediaType.APPLICATION_JSON_TYPE).getBytes()));
              JsonArray jsonArray = jsonReader.readArray();
              for (int i = 0; i &lt;jsonArray.size(); i++) {
                JsonObject o = ((JsonObject)jsonArray.getJsonObject(i)) ;
                out.println( o.get("text"));
                out.println("&lt;br&gt;");
                out.println("Created at " + o.get("created_at"));
                out.println("&lt;br&gt;");
                
              }
              out.println("&lt;/p&gt;");
              out.flush();
            } catch (IOException e) {
              e.printStackTrace();
            }
          }
        };
      } catch (Exception e) {
        e.printStackTrace();
      }
    }
  }
}</pre></div><p>As seen <a id="id419" class="indexterm"/>in the preceding code, we<a id="id420" class="indexterm"/> use the <span class="strong"><strong>JSR 353 Java API for JSON Processing</strong></span><a id="id421" class="indexterm"/> to create a <code class="literal">JSonReader</code> object from the <code class="literal">inboundEvent#getData()</code> method. The <code class="literal">JSONArray</code> object is returned by the <code class="literal">jsonReader.readArray()</code> method. The <code class="literal">JsnObject</code> objects are read from the array and the tweet information is displayed.</p></div><div class="section" title="The EJB that interacts with the Twitter Search API"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec26"/>The EJB that interacts with the Twitter Search API</h3></div></div></div><p>Here is the code for the EJB <a id="id422" class="indexterm"/>that will invoke the<a id="id423" class="indexterm"/> Twitter Search API. This EJB has a timer that<a id="id424" class="indexterm"/> will periodically call the Twitter Search API to get tweets for GlassFish and get the results in the JSON format.</p><div class="informalexample"><pre class="programlisting">@Stateless
@Named
public class TwitterBean {
}</pre></div><p>The <code class="literal">@Stateless</code> annotation indicates this is a stateless session bean.</p><p>
<span class="strong"><strong>Twitter v1.1 API</strong></span><a id="id425" class="indexterm"/> uses <span class="strong"><strong>OAuth</strong></span><a id="id426" class="indexterm"/> to provide authorized access to its API. Twitter offers applications the ability to issue authenticated requests on behalf of the application itself (as opposed to on behalf of a specific user). For more on <span class="strong"><strong>OAuth</strong></span> please check <a class="ulink" href="https://dev.twitter.com/docs/api/1.1/overview">https://dev.twitter.com/docs/api/1.1/overview</a>.</p><p>To run this demo, you will need to have a Twitter account and create an application based on information specified in this following link: <a class="ulink" href="https://dev.twitter.com/docs/auth/oauth">https://dev.twitter.com/docs/auth/oauth</a>. Please see the <code class="literal">Readme.txt</code> with the sample for instructions on how to run the sample.</p><p>The following code <a id="id427" class="indexterm"/>uses the <a id="id428" class="indexterm"/>
<span class="strong"><strong>twitter4j</strong></span> API from <a class="ulink" href="http://twitter4j.org/en/index.html">http://twitter4j.org/en/index.html</a> to integrate Java and the Twitter API.</p><p>Here is the code that <a id="id429" class="indexterm"/>will connect to <code class="literal">SEARCH_URL</code> and get the<a id="id430" class="indexterm"/> tweets</p><div class="informalexample"><pre class="programlisting">/**
* Since twitter uses the v1.1 API we use twitter4j to get
* the search results using OAuth
* @return a JsonArray containing tweets
* @throws TwitterException
* @throws IOException
*/
public JsonArray getFeedData() throws TwitterException, IOException {

  Properties prop = new Properties();
  
  //load a properties file
  prop.load(this.getClass().getResourceAsStream("twitter4j.properties"));
  
  //get the property value and print it out
  String consumerKey = prop.getProperty("oauth.consumerKey");
  String consumerSecret= prop.getProperty("oauth.consumerSecret");
  String accessToken = prop.getProperty("oauth.accessToken");
  String accessTokenSecret = prop.getProperty("oauth.accessTokenSecret");
  ConfigurationBuilder cb = new ConfigurationBuilder();
  cb.setDebugEnabled(true)
  .setOAuthConsumerKey(consumerKey)
  .setOAuthConsumerSecret(consumerSecret)
  .setOAuthAccessToken(accessToken)
  .setOAuthAccessTokenSecret(accessTokenSecret);
  
  TwitterFactory tf = new TwitterFactory(cb.build());
  Twitter twitter = tf.getInstance();
  Query query = new Query("glassfish");
  QueryResult result = twitter.search(query);
  JsonArrayBuilder jsonArrayBuilder  = Json.createArrayBuilder();
  for (Status status : result.getTweets()) {
    jsonArrayBuilder
    .add(Json.createObjectBuilder().
    add("text", status.getText())
    .add("created_at", status.getCreatedAt().toString()));
  }
  return jsonArrayBuilder.build() ;
}</pre></div><p>The preceding <a id="id431" class="indexterm"/>code reads the <code class="literal">twitter4j.properties</code> and <a id="id432" class="indexterm"/>creates a <code class="literal">ConfigurationBuilder</code> object with the <code class="literal">consumerKey</code>, <code class="literal">consumerSecret</code>, <code class="literal">accessToken</code>, and <code class="literal">accessTokenSecret</code> keys. Using the <code class="literal">TwitterFactory</code> API an instance<a id="id433" class="indexterm"/> of Twitter object is created. A <code class="literal">Query</code>
<span class="strong"><strong> </strong></span>object to send the search request to Twitter with the keyword <code class="literal">"glassfish"</code> is created. The <code class="literal">twitter.search</code> returns tweets that match a specified query. This method calls <a class="ulink" href="http://search.twitter.com/search.json">http://search.twitter.com/search.json</a>.</p><p>Once the <code class="literal">QueryResult</code> object is obtained, the <code class="literal">JsonArrayBuilder</code> object is used to build the JSON object containing the results. For more information on twitter4j API please check <a class="ulink" href="http://twitter4j.org/oldjavadocs/3.0.0/index.html">http://twitter4j.org/oldjavadocs/3.0.0/index.html</a>.</p><p>The EJB bean has an additional method that will invoke the <span class="strong"><strong>EJB timer</strong></span>. Here is the EJB Timer code that will send these tweets, which are obtained from the Twitter Search API, to the REST Endpoint <code class="literal">ServerSentEventsResource</code> using the <code class="literal">POST</code> method.</p><div class="informalexample"><pre class="programlisting">private final static String TARGET_URI = "http://localhost:8080/jersey-sse-twitter-sample";

@Schedule(hour = "*", minute = "*", second = "*/10")
public void sendTweets() {
  
  Client client = ClientBuilder.newClient();
  try {
    WebTarget webTarget= client.target(new URI(TARGET_URI)) ;
    JsonArray statuses = null;
    
<span class="strong"><strong>    statuses = getFeedData();</strong></span>
    webTarget.path("twittersse").request().post(Entity.json(statuses));
  }(catch Exception e) {
    e.printStackTrace();
  }
}</pre></div><p>The <code class="literal">@Schedule</code> annotation is used to schedule fetching tweets every 10 seconds. The EJB specification has more details on usages of <code class="literal">@Schedule</code>. The <code class="literal">JsonArray</code> object statuses get the feeds from the <code class="literal">getFeedData()</code> method that was covered in the earlier section.</p><p>
<code class="literal">WebTarget</code> is <a id="id434" class="indexterm"/>created with the <code class="literal">TARGET_URI</code> that is the URL <code class="literal">http://localhost:8080/jersey-sse-twitter-sample</code> where the application<a id="id435" class="indexterm"/> is deployed.</p><p>The <code class="literal">webTarget.path("twittersse")</code> <a id="id436" class="indexterm"/>method points to the location of the <code class="literal">ServerSentEventsResource</code> class covered earlier that is the REST resource.</p><p>Using the <code class="literal">request().post(Entity.text(message))</code> method the tweets that are obtained from the Twitter Search API are sent as a Text Entity.</p><p>This is the sequence of events:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">The user deploys the application and invokes the Servlet client from this URL <code class="literal">http://localhost:8080/jersey-sse-twitter-sample</code>.</li><li class="listitem">The EJB timer gets scheduled every 10 seconds.</li><li class="listitem">The EJB timer will invoke the Twitter Search API to get the tweets for <code class="literal">"glassfish"</code> in JSON format.</li><li class="listitem">The EJB timer sends the data obtained in step to the JAX-RS <code class="literal">ServerSentEventsResource</code> class using the <code class="literal">POST</code> request.</li><li class="listitem">The JAX-RS resource <code class="literal">ServerSentEventsResource</code> opens the <code class="literal">EventOutput</code> channel, which is the outbound channel for the Server-sent Events.</li><li class="listitem">The Servlet client in step 1 has the <code class="literal">EventSource</code> object open that is listening for the Server-sent Events.</li><li class="listitem">The Servlet client uses JSON-P API to parse the Twitter feeds.</li><li class="listitem">Finally the tweets are shown in the browser.</li></ol></div></div></div></div></div>
<div class="section" title="The library application"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec32"/>The library application</h1></div></div></div><p>The library application<a id="id437" class="indexterm"/> is a simple, self-contained, real-life-based application that demonstrates HTML5 technologies such as WebSockets and shows how to use JAX-RS verbs, how to write data using JSON-P API, and how to take advantage of the asynchronous aspect of processing the resources. To stay on track the application contains the components that describe the preceding technologies using a simple GUI and does not have fancy dialog boxes or very complicated business logic.</p><div class="section" title="How the application is deployed"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec43"/>How the application is deployed</h2></div></div></div><p>The build system<a id="id438" class="indexterm"/> used for the sample application is Maven and the sample can be deployed in any Java EE 7-compatible application server, notably GlassFish v4.0, which is an open source reference implementation of Java EE specification.</p></div><div class="section" title="The project's layout"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec44"/>The project's layout</h2></div></div></div><p>The project's directory<a id="id439" class="indexterm"/> layout<a id="id440" class="indexterm"/> follows the standard Maven structure, which is briefly explained in the following table:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Source code</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">src/main/java</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This directory contains all the sources required by the library application.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">src/main/webapp</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This directory contains the JavaScript files, HTML files, and the <code class="literal">WEB-INF/web.xml</code> file.</p>
</td></tr></tbody></table></div></div><div class="section" title="The library application GUI"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec45"/>The library application GUI</h2></div></div></div><p>The library application <a id="id441" class="indexterm"/>consists of <a id="id442" class="indexterm"/>one screen that serves as the vehicle for showing different rendering of the data and forms for gathering inputs. The screen is shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/8125EN_05_02.jpg" alt="The library application GUI"/></div><p>Using the screen,<a id="id443" class="indexterm"/> a user can do the following operations:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Browse the collection <a id="id444" class="indexterm"/>of books.</li><li class="listitem">Search for a book.</li><li class="listitem">Checkout a book.</li><li class="listitem">Return a book.</li><li class="listitem">Place hold on a book.</li></ol></div><p>The following table shows the action taken by a user, the details of what happens behind the scenes, and the API and technologies involved in processing the requests:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Action</p>
</th><th style="text-align: left" valign="bottom">
<p>API and technology used</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>Browse the collection of books</p>
</td><td style="text-align: left" valign="top">
<p>This task uses the JAX-RS <code class="literal">GET</code> verb to get the collection of books in the library. It uses the JSON-P API to write the data in JSON format. We use an implementation of JAX-RS <code class="literal">MessageBodyWriter</code> class, which knows how to serialize a custom class to JSON output.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Borrow a book</p>
</td><td style="text-align: left" valign="top">
<p>When a book is checked out from the library it reduces from the collection of books, which the library has. This task demonstrates the use of the JAX-RS verb <code class="literal">DELETE</code> and deletes the book from the collection.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Return a book</p>
</td><td style="text-align: left" valign="top">
<p>When a book is returned to the library it will be added to the collection of books that the library has. This task demonstrates the use of the JAX-RS verb <code class="literal">POST</code> and adds the book to the collection.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Place hold on a book</p>
</td><td style="text-align: left" valign="top">
<p>When a book is placed on hold, the library application should notify other users currently having the book to<a id="id445" class="indexterm"/> return it. Once the book<a id="id446" class="indexterm"/> is returned, a notification should be sent to the user requesting the book. This is an asynchronous operation. This task demonstrates the use of asynchronous processing of the JAX-RS resources.</p>
</td></tr></tbody></table></div></div><div class="section" title="Application interaction monitoring"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec46"/>Application interaction monitoring</h2></div></div></div><p>There is a pane that will <a id="id447" class="indexterm"/>show what is the query, which was sent to the endpoint. Additionally, we will show the output returned by the endpoint.</p></div><div class="section" title="A detailed look at the library application"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec47"/>A detailed look at the library application</h2></div></div></div><p>After an initial <a id="id448" class="indexterm"/>introduction to what the application is supposed to do, let's dissect it further and study each individual component that builds this application.</p><p>The following is the order in which the details of the application will be covered:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <code class="literal">web.xml</code></li><li class="listitem" style="list-style-type: disc">The <code class="literal">Application</code> subclass implementation in our application</li><li class="listitem" style="list-style-type: disc">The JAX-RS Entity Providers used in our application</li><li class="listitem" style="list-style-type: disc">The HTML page</li><li class="listitem" style="list-style-type: disc">JavaScript snippets and JAX-RS resource methods for the following functions:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Browsing the collection of books</li><li class="listitem" style="list-style-type: disc">Searching for a book</li><li class="listitem" style="list-style-type: disc">Checking out a book</li><li class="listitem" style="list-style-type: disc">Returning a book</li><li class="listitem" style="list-style-type: disc">Placing a hold on the book</li></ul></div></li></ul></div><div class="section" title="The web.xml"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec27"/>The web.xml</h3></div></div></div><p>To set up the application, configure the <a id="id449" class="indexterm"/>servlet<a id="id450" class="indexterm"/> deployment descriptor <code class="literal">web.xml</code> as follows:</p><div class="informalexample"><pre class="programlisting">&lt;servlet&gt;
  &lt;servlet-name&gt;org.sample.library.BookApplication&lt;/servlet-name&gt;
  &lt;init-param&gt;
    &lt;param-name&gt;javax.json.stream.JsonGenerator.prettyPrinting&lt;/param-name&gt;
    &lt;param-value&gt;true&lt;/param-value&gt;
  &lt;/init-param&gt;
  &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
&lt;/servlet&gt;

&lt;welcome-file-list&gt;
  &lt;welcome-file&gt;
    index.html
  &lt;/welcome-file&gt;
&lt;/welcome-file-list&gt;
&lt;servlet-mapping&gt;
  &lt;servlet-name&gt;org.sample.library.BookApplication&lt;/servlet-name&gt;
  &lt;url-pattern&gt;/app/*&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;</pre></div><p>In the preceding snippet, we defined a servlet to take the subclass of the JAX-RS Application <code class="literal">BookApplication</code>. The URL pattern is <code class="literal">/app/*</code>.</p></div><div class="section" title="The Application subclass"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec28"/>The Application subclass</h3></div></div></div><p>Here is the <a id="id451" class="indexterm"/>snippet of the <code class="literal">BookApplication</code> class, which is mentioned in the <code class="literal">web.xml</code> description.</p><div class="informalexample"><pre class="programlisting">public class BookApplication extends Application {
  
  @Override
  public Set&lt;Class&lt;?&gt;&gt; getClasses() {
    Set&lt;Class&lt;?&gt;&gt; classes = new HashSet&lt;Class&lt;?&gt;&gt;();
    classes.add(BooksResource.class);
    classes.add(BookCollectionWriter.class);
    classes.add(BookWriter.class);
    return classes;
  }
}</pre></div><p>The <code class="literal">BookApplication</code> class extends the JAX-RS <code class="literal">Application</code> class. In the <code class="literal">getClasses()</code> method implementation, the following are registered:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">BookResource.class</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">BookCollectionWriter.class</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">BookWriter.class</code></li></ul></div><p>The <code class="literal">BookResource</code> class is covered in detail in the next few sections, with every function of<a id="id452" class="indexterm"/> the JavaScript; the corresponding method of the <code class="literal">BookResource</code> class will be explained.</p><p>The <code class="literal">BookCollectionWriter</code> class is an implementation of a <code class="literal">MessageBodyWriter</code> interface, which takes a <code class="literal">List&lt;Book&gt;</code> object and serializes it to the JSON format. To produce the <code class="literal">application/json</code> encoded output, the <code class="literal">BookCollectionWriter</code> class uses JSON-P API.</p><p>The <code class="literal">BookWriter</code> class provides the facility to serialize the user-defined <code class="literal">Book</code> class, which is shown in the following section. The <code class="literal">Book</code> class has fields such as name of the book, author, and ISBN. Using this <code class="literal">BookWriter</code> class it is possible to convert this <code class="literal">Book</code> class into a format specified in the resource, for example, <code class="literal">"text/plain"</code> or <code class="literal">"application/json"</code>.</p></div><div class="section" title="JAX-RS Entity Provider: BookCollectionWriter"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec29"/>JAX-RS Entity Provider: BookCollectionWriter</h3></div></div></div><p>Similar to the <code class="literal">BookWriter</code> class <a id="id453" class="indexterm"/>covered in the <a id="id454" class="indexterm"/>earlier section there is a <a id="id455" class="indexterm"/>class called <code class="literal">BookCollectionWriter</code> in the<a id="id456" class="indexterm"/> sample; this is used to serialize a list of books. Here is an implementation of the <code class="literal">writeTo()</code> method in the <code class="literal">BookCollectionWriter</code> class:</p><div class="informalexample"><pre class="programlisting">@Override
public void writeTo(List&lt;Book&gt; books, Class&lt;?&gt; type, Type genericType, Annotation[] annotations, MediaType mediaType, MultivaluedMap&lt;String, Object&gt; httpHeaders, OutputStream entityStream) throws IOException, WebApplicationException {
  StringWriter writer = new StringWriter();
<span class="strong"><strong>  if (mediaType.equals(MediaType.APPLICATION_JSON_TYPE)) {</strong></span>
    JsonGenerator generator = Json.createGenerator(writer);
    Map&lt;String, Object&gt; configs;
    configs = new HashMap&lt;String, Object&gt;(1);
    configs.put(JsonGenerator.PRETTY_PRINTING, true);
    
    generator.writeStartArray();
    for (Book book: books) {
      generator.writeStartObject()
      .write("Name", book.getName())
      .write(" ISBN", book.getIsbn())
      .write("Author",book.getAuthor()) .writeEnd();
      
    }
    generator.writeEnd();
    generator.close();
    entityStream.write(writer.toString().getBytes());
<span class="strong"><strong>  } else if (mediaType.equals(MediaType.TEXT_PLAIN_TYPE)) {</strong></span>
    StringBuilder stringBuilder = new StringBuilder("Book ");
    for (Book book: books) {
      stringBuilder.append(book.toString()).append("\n");
    }
    entityStream.write(stringBuilder.toString().getBytes());
    
  }
}</pre></div><p>The preceding code does media type filtering; if the <code class="literal">mediaType</code> parameter equals <code class="literal">MediaType.APPLICATION_JSON_TYPE</code>, then it uses the JSON-P API to create a <code class="literal">JsonGenerator</code> object. Using the <code class="literal">writeStartArray()</code> and <code class="literal">writeStartObject()</code> methods of <code class="literal">JsonGenerator</code> class, the array of JSON objects is written.</p><p>If the <code class="literal">mediaType</code> parameter equals <code class="literal">MediaType.TEXT_PLAIN_TYPE</code>, then a String representation of the books is returned.</p></div><div class="section" title="The HTML page"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec30"/>The HTML page</h3></div></div></div><p>As you may recall, when the<a id="id457" class="indexterm"/> application is launched in the browser, you will <a id="id458" class="indexterm"/>see the <code class="literal">index.html</code> screen. Let's take a peek at the source code of the <code class="literal">index.html</code> file:</p><div class="informalexample"><pre class="programlisting">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;
    &lt;title&gt;Library App&lt;/title&gt;
    &lt;script src="main.js"&gt;
    &lt;/script&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1 id="helloMessage"&gt;
    &lt;/h1&gt;
    
    Please enter the following details:
    &lt;p&gt;
      Book Name:
      &lt;input type="text" value="Game of thrones" id="bookName"/&gt;
    &lt;/p&gt;
    &lt;br&gt;
    &lt;button onclick="search_onclick()"&gt;Search&lt;/button&gt;
    &lt;button onclick="checkout_onclick()"&gt;Checkout&lt;/button&gt;
    &lt;button onclick="return_onclick()"&gt;Return&lt;/button&gt;
    &lt;button onclick="hold_onclick()"&gt;Hold&lt;/button&gt;
    &lt;button onclick="browse_onclick()"&gt;Browse Collection&lt;/button&gt;
    
    &lt;h2&gt;Book Information&lt;/h2&gt;
    &lt;h3&gt;JAX-RS query sent by the Application:&lt;/h3&gt;
    
<span class="strong"><strong>    &lt;div id="query" style="border: 1px solid black; color: black; height: 6em; width: 80%"&gt;&lt;/div&gt;</strong></span>
    &lt;h3&gt;Output from the JAX-RS query&lt;/h3&gt;
<span class="strong"><strong>    &lt;div id="output" style="border: 1px solid black; color: black; height: 18em; width: 80%"&gt;&lt;/div&gt;</strong></span>
  &lt;/body&gt;
&lt;/html&gt;</pre></div><p>This is standard<a id="id459" class="indexterm"/> HTML, which uses an external JavaScript file called <code class="literal">main.js</code> to import the<a id="id460" class="indexterm"/> following functionalities:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Browsing the collection of books</li><li class="listitem" style="list-style-type: disc">Searching for a book</li><li class="listitem" style="list-style-type: disc">Checking out a book</li><li class="listitem" style="list-style-type: disc">Returning a book</li><li class="listitem" style="list-style-type: disc">Placing hold on a book</li></ul></div><p>The highlighted <code class="literal">div</code> elements <code class="literal">query</code> and <code class="literal">output</code> show the JAX-RS query and the output on the page. Every button has an <code class="literal">onclick()</code> event associated with it that calls a function in JavaScript. Each function shall be covered in detail in the next section.</p></div><div class="section" title="Browsing the collection of books"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec31"/>Browsing the collection of books</h3></div></div></div><p>When a user<a id="id461" class="indexterm"/> clicks on the <span class="strong"><strong>Browse Collection</strong></span> button on the HTML<a id="id462" class="indexterm"/> page, the input is checked and then the <code class="literal">sendBrowseRequest()</code> function<a id="id463" class="indexterm"/> is called in the JavaScript.</p><div class="section" title="Using JavaScript"><div class="titlepage"><div><div><h4 class="title"><a id="ch05lvl4sec05"/>Using JavaScript</h4></div></div></div><p>Here is the <a id="id464" class="indexterm"/>snippet of the <code class="literal">sendBrowseRequest()</code>:</p><div class="informalexample"><pre class="programlisting">function sendBrowseRequest( ) {
  var req = createRequest(); // defined above
  // Create the callback:
  req.onreadystatechange = function() {
    if (req.readyState == 4) {
      document.getElementById("query").innerHTML="GET app/library/books" ;
      document.getElementById("output").innerHTML=req.responseText;
    }
  }
  req.open("GET","app/library/books" ,true);
  req.send(null);
}</pre></div><p>The <code class="literal">createRequest()</code> function<a id="id465" class="indexterm"/> is used to create an <code class="literal">XMLHttpRequest</code> object as covered in <a class="link" href="ch02.html" title="Chapter 2. WebSockets and Server-sent Events">Chapter 2</a>, <span class="emphasis"><em>WebSockets and Server-sent Events</em></span>. The request, which is sent to the JAX-RS resource, is a <code class="literal">GET</code> request with the URI <code class="literal">/app/library/books</code> (we shall cover the JAX-RS resource in the next section). When the value of the <code class="literal">XMLHttpRequest </code>object's <code class="literal">readyState</code> is <code class="literal">4</code>, it means that the response is complete and we can get the data. In our sample, we display the <code class="literal">responseText</code> using the snippet <code class="literal">document.getElementById("output").innerHTML=req.responseText;</code>.</p></div><div class="section" title="The JAX-RS resource method for the GET request"><div class="titlepage"><div><div><h4 class="title"><a id="ch05lvl4sec06"/>The JAX-RS resource method for the GET request</h4></div></div></div><p>Here is the snippet<a id="id466" class="indexterm"/> for the <code class="literal">GET</code> request:</p><div class="informalexample"><pre class="programlisting">@GET
@Path("books")
@Produces({MediaType.TEXT_PLAIN, MediaType.APPLICATION_JSON})
public List&lt;Book&gt; browseCollection() {
  return bookService.getBooks();
} </pre></div><p>This is a very simple method that will use the <code class="literal">BookCollectionWriter</code> class that we covered earlier to output the <code class="literal">List&lt;Book&gt;</code> objects in JSON format or in the plain text format.</p></div></div><div class="section" title="Searching for a book"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec32"/>Searching for a book</h3></div></div></div><p>When a user<a id="id467" class="indexterm"/> clicks on the <span class="strong"><strong>Search</strong></span> button on the HTML page, the <code class="literal">sendSearchWSRequest()</code> function is called in the JavaScript.</p><div class="section" title="Using JavaScript"><div class="titlepage"><div><div><h4 class="title"><a id="ch05lvl4sec07"/>Using JavaScript</h4></div></div></div><p>The <code class="literal">sendSearchWSRequest()</code> function <a id="id468" class="indexterm"/>demonstrates the WebSockets functionality in our application. A WebSocket URI is initializing in the JavaScript as follows:</p><div class="informalexample"><pre class="programlisting">var wsUri = "ws://localhost:8080/libraryApp/app/websockets";
function sendSearchWSRequest(book) {
  websocket.send(book);
  console.log("Searching for: " + book);
}</pre></div><p>The <code class="literal">sendSearchWSRequest()</code> function uses the WebSocket JavaScript API to send the string <code class="literal">book</code> name to the <code class="literal">BookWebSocket</code> class shown in the following section.</p></div><div class="section" title="The WebSockets endpoint"><div class="titlepage"><div><div><h4 class="title"><a id="ch05lvl4sec08"/>The WebSockets endpoint</h4></div></div></div><p>Here is the snippet for the <a id="id469" class="indexterm"/>WebSockets's <code class="literal">ServerEndpoint</code> annotated class <code class="literal">BookWebSocket</code>:</p><div class="informalexample"><pre class="programlisting">@ServerEndpoint(value="/app/websockets")
public class BookWebSocket {
  @OnMessage
  public String searchBook(String name) {
    return "Found book " + name;
  }
}</pre></div><p>The <code class="literal">BookWebSocket</code> is a POJO that is annotated with <code class="literal">@ServerEndpoint</code> and initialized to a URI of <code class="literal">/app/websockets</code>. The <code class="literal">@OnMessage</code> annotation on the <code class="literal">searchBook()</code> method will cause this method to be invoked when the WebSockets server endpoint receives the message. The WebSockets endpoint simply returns back a string with the name of the book for the case of simplicity of the sample.</p></div></div><div class="section" title="Checking out a book"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec33"/>Checking out a book</h3></div></div></div><p>When a user clicks on the<a id="id470" class="indexterm"/> <span class="strong"><strong>Checkout</strong></span> button on the HTML page, the input is checked and then the <code class="literal">sendCheckoutRequest()</code> function is called in the JavaScript.</p><div class="section" title="Using JavaScript"><div class="titlepage"><div><div><h4 class="title"><a id="ch05lvl4sec09"/>Using JavaScript</h4></div></div></div><p>Here is the <a id="id471" class="indexterm"/>snippet of the<a id="id472" class="indexterm"/>
<code class="literal"> sendCheckoutRequest()</code> function:</p><div class="informalexample"><pre class="programlisting">function sendCheckoutRequest( book) {
  var req = createRequest(); // defined above
  ;
  // Create the callback:
  req.onreadystatechange = function() {

    if (req.readyState == 4) {
      document.getElementById("query").innerHTML="DELETE app/library/book/" + encodeURI(book.trim());
      document.getElementById("output").innerHTML=req.responseText;
      
    }
  }
  req.open("DELETE","app/library/book/" + book,true);
  req.send(null);
}</pre></div><p>The request, which<a id="id473" class="indexterm"/> is sent to the JAX-RS resource, is a <code class="literal">DELETE</code> request placed on the <code class="literal">/app/library/book/</code> URI. We will cover the JAX-RS resource in the next section.</p></div><div class="section" title="The JAX-RS resource method for the DELETE request"><div class="titlepage"><div><div><h4 class="title"><a id="ch05lvl4sec10"/>The JAX-RS resource method for the DELETE request</h4></div></div></div><p>Here is the code<a id="id474" class="indexterm"/> snippet for the <code class="literal">DELETE</code> request:</p><div class="informalexample"><pre class="programlisting">@DELETE
@Path("book/{name}")
@Produces({MediaType.TEXT_PLAIN })
@Consumes({MediaType.TEXT_PLAIN })
public Book checkoutBook(@PathParam("name") String nameOfBook) {
  return bookService.deleteBook(nameOfBook);
  
}</pre></div><p>This is a very simple method that will delete the book if it exists in the collection and send back the book details using the <code class="literal">BookWriter</code> class covered earlier.</p></div></div><div class="section" title="Returning a book"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec34"/>Returning a book</h3></div></div></div><p>When a user clicks <a id="id475" class="indexterm"/>on the <span class="strong"><strong>Return</strong></span> button on the HTML page, the input is checked and then the<code class="literal"> sendReturnRequest()</code> function is called in the JavaScript.</p><div class="section" title="Using JavaScript"><div class="titlepage"><div><div><h4 class="title"><a id="ch05lvl4sec11"/>Using JavaScript</h4></div></div></div><p>Here is the <a id="id476" class="indexterm"/>snippet of the <code class="literal">sendReturnRequest()</code> function:</p><div class="informalexample"><pre class="programlisting">function sendReturnRequest( book) {
  var req = createRequest(); // defined above
  ;
  // Create the callback:
  req.onreadystatechange = function() {

    if (req.readyState == 4) {
      document.getElementById("query").innerHTML="POST app/library/book/" + encodeURI(book.trim());
      document.getElementById("output").innerHTML=req.responseText;
      
    }
  }
  req.open("POST","app/library/book/" + book,true);
  req.send(null);
}</pre></div><p>The request, which is sent to the JAX-RS resource, is a <code class="literal">POST</code> request with <code class="literal">app/library/book/</code> as the target URI.</p></div><div class="section" title="The JAX-RS resource method for the POST request"><div class="titlepage"><div><div><h4 class="title"><a id="ch05lvl4sec12"/>The JAX-RS resource method for the POST request</h4></div></div></div><p>Here is the code snippet<a id="id477" class="indexterm"/> for the <code class="literal">POST</code> request:</p><div class="informalexample"><pre class="programlisting">@POST
@Path("book/{name}")
@Produces({MediaType.TEXT_PLAIN })
@Consumes({MediaType.TEXT_PLAIN })
public String returnBook(@PathParam("name") String nameOfBook)      {
  
  return "Successfully returned Book " + nameOfBook;
}</pre></div></div></div><div class="section" title="Placing a hold on a book"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec35"/>Placing a hold on a book</h3></div></div></div><p>When a user<a id="id478" class="indexterm"/> clicks on the <span class="strong"><strong>Hold</strong></span> button on the HTML page, the input is checked and then the <code class="literal">sendHoldRequest()</code> function is called in the JavaScript.</p><div class="section" title="Using JavaScript"><div class="titlepage"><div><div><h4 class="title"><a id="ch05lvl4sec13"/>Using JavaScript</h4></div></div></div><p>Here<a id="id479" class="indexterm"/> is the snippet of<a id="id480" class="indexterm"/> the <code class="literal">sendHoldRequest()</code> function:</p><div class="informalexample"><pre class="programlisting">function sendHoldRequest( book) {
  var req = createRequest(); // defined above
  ;
  // Create the callback:
  req.onreadystatechange = function() {

    if (req.readyState == 4) {
      document.getElementById("query").innerHTML="POST app/library/hold/" + encodeURI(book.trim());
      document.getElementById("output").innerHTML=req.responseText;
      
    }
  }
  req.open("POST","app/library/hold/" + book,true);
   req.send(null);
  
}</pre></div><p>A <code class="literal">POST</code> request is sent to the JAX-RS resource located at the <code class="literal">app/library/hold/</code> URI. The resource is described in the next section.</p></div><div class="section" title="The JAX-RS resource method for the asynchronous POST request"><div class="titlepage"><div><div><h4 class="title"><a id="ch05lvl4sec14"/>The JAX-RS resource method for the asynchronous POST request</h4></div></div></div><p>Here is the JAX-RS resource method <a id="id481" class="indexterm"/>that places a hold on a book. This is an asynchronous resource, which is covered in <a class="link" href="ch04.html" title="Chapter 4. JSON and Asynchronous Processing">Chapter 4</a>, <span class="emphasis"><em>JSON and Asynchronous Processing</em></span>:</p><div class="informalexample"><pre class="programlisting">/**
* Asynchronously reply to placing a book on hold after sleeping for sometime
*
*/
@POST
@Produces({MediaType.TEXT_PLAIN})
@Path("hold/{name}")
public void asyncEcho(@PathParam("name") final String name,  @Suspended final AsyncResponse ar) {
  TASK_EXECUTOR.submit(new Runnable() {
    
    public void run() {
      try {
        Thread.sleep(SLEEP_TIME_IN_MILLIS);
      } catch (InterruptedException ex) {
        ar.cancel();
      }
      ar.resume("Placed a hold for " + name);
    }
  });
}</pre></div><p>The parameter <code class="literal">ar</code> of type <code class="literal">AsyncResponse</code> is similar to the <code class="literal">AsyncContext</code> class in the Servlet 3.0 specification and facilitates asynchronous request execution. In this example the request is suspended for a specific duration and the response is pushed to the client with the <code class="literal">AsyncResponse.resume()</code> method.</p></div></div><div class="section" title="The Singleton EJB BookService"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec36"/>The Singleton EJB BookService</h3></div></div></div><p>Here is the<a id="id482" class="indexterm"/> code for<a id="id483" class="indexterm"/> the Singleton EJB, which stores the details about the books:</p><div class="informalexample"><pre class="programlisting">@Singleton
public class BookService {

  private static final HashMap&lt;String,Book&gt; books = new HashMap&lt;String,Book&gt;();

  public static void addBook(Book book) {
    books.put(book.getName(), book);
  }

  public static int getSize() {
    return  books.size();
  }

  public static Book deleteBook(String isbn) {
    return books.remove(isbn);
  }


  public static List&lt;Book&gt; getBooks() {
    return new ArrayList&lt;Book&gt;(books.values());
  }

  public BookService() {
    // initial content
    addBook( new Book("Java EE development using GlassFish Aplication Server","782345689","David Heffinger"));
    addBook( new Book("Java 7 JAX-WS Web Services","123456789","Deepak Vohra"));
    addBook( new Book("Netbeans IDE7 CookBook","2234555567","Rhawi Dantas"));
    addBook( new Book("Getting Started with RESTful WebServices","11233333","Bhakti Mehta, Masoud Kalali"));
    
  }
}</pre></div><p>Thus, we have seen a detailed view of the library application, which uses the different JAX-RS 2.0, WebSockets, and JSON-P APIs.</p></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec33"/>Summary</h1></div></div></div><p>This chapter covered two real life examples of RESTful Web Services. At the beginning, using the event notification sample, we demonstrated how to use Server-sent Events with asynchronous processing of servlets and how the server can push data to the clients as and when the events occur.</p><p>Continued on, in the library application we covered the JAX-RS API and also the custom message body readers, writers. We also demonstrated the use of JSON-P API. The library application showed how to use WebSockets from a JavaScript client and send messages to WebSockets endpoints.</p></div></body></html>