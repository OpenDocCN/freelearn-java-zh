- en: '16'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '16'
- en: 'Streams: Advanced Concepts'
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 流：高级概念
- en: In [*Chapter 15*](B19793_15.xhtml#_idTextAnchor377), we learned about the fundamentals
    of streams. We started by discussing what a stream pipeline is by using an analogy
    of an assembly line. We saw that items only make their way onto the assembly line
    as and when needed. This is the principle of lazy evaluation. In this analogy,
    there are several operators that operate on the data (pencils) under the supervision
    of a supervisor (Java). The supervisor will not allow any work to start until
    the terminal operation in place. As Java is now aware of the full pipeline, efficiencies
    can be introduced. Once a pencil has passed an operator, the operator cannot get
    that pencil back. Thus, streams are different to arrays or `Collection`s in that
    manner. The pencils can be processed by as many operators as necessary but only
    one operator is the terminal operation. The other operators represent intermediate
    operations (a topic in this chapter).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第15章*](B19793_15.xhtml#_idTextAnchor377)中，我们学习了流的基本概念。我们通过类比流水线来讨论什么是流管道。我们了解到，项目只有在需要时才会进入流水线。这是惰性求值的原理。在这个类比中，有几个操作员在主管（Java）的监督下对数据进行操作。主管不会允许任何工作开始，直到终端操作就绪。由于Java现在知道整个管道，可以引入效率。一旦铅笔通过一个操作员，该操作员就无法将其取回。因此，流与数组或`Collection`在这一点上有所不同。铅笔可以由所需数量的操作员处理，但只有一个操作员是终端操作。其他操作员代表中间操作（本章的主题）。
- en: 'We examined how to create streams. Streams can be created from various sources:
    arrays, collections, files, and varargs. We created both finite and infinite streams.
    Infinite streams are created using `Stream.generate()` and `Stream.iterate()`.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们探讨了如何创建流。流可以从各种来源创建：数组、集合、文件和可变参数。我们创建了有限和无限的流。无限流是通过`Stream.generate()`和`Stream.iterate()`创建的。
- en: We took a deep dive into terminal operations. Nothing happens until a terminal
    operation executes and once executed the stream is considered closed and must
    be re-streamed if you want to use it again. A reduction is an operation that examines
    all of the stream and produces a single output (primitive or `Object`). One of
    the terminal operations is the overloaded `reduce()` method which performs reductions
    on the stream. The `collect()` terminal operation is extremely useful for extracting
    data out of the stream (into a `Map` for example) for later use.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们深入研究了终端操作。直到终端操作执行，否则不会发生任何事情。一旦执行，流就被认为是关闭的，如果你想要再次使用它，必须重新流式传输。归约是一种检查整个流并产生单个输出（原始或`Object`）的操作。终端操作之一是重载的`reduce()`方法，它对流执行归约。`collect()`终端操作对于从流中提取数据（例如，到一个`Map`）以供以后使用非常有用。
- en: In this chapter, we will continue our coverage of streams. We will, with the
    aid of code examples, examine intermediate operations. Following that, we will
    discuss primitive streams and how to map streams. We will also discuss `Optional`s
    and lastly, we will finish with parallel streams.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将继续对流的讨论。我们将通过代码示例来检查中间操作。随后，我们将讨论原始流以及如何映射流。我们还将讨论`Optional`，最后，我们将以并行流结束。
- en: 'This chapter covers the following main topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了以下主要主题：
- en: Examining intermediate operations
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查中间操作
- en: Delving into primitive streams
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 深入探讨原始流
- en: Mapping streams
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 映射流
- en: Explaining `Optional`s
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释`Optional`
- en: Understanding parallel streams
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解并行流
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code for this chapter can be found on GitHub at [https://github.com/PacktPublishing/Learn-Java-with-Projects/tree/main/ch16](https://github.com/PacktPublishing/Learn-Java-with-Projects/tree/main/ch16).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在GitHub上找到，地址为[https://github.com/PacktPublishing/Learn-Java-with-Projects/tree/main/ch16](https://github.com/PacktPublishing/Learn-Java-with-Projects/tree/main/ch16)。
- en: Examining intermediate operations
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查中间操作
- en: 'As we know, a stream pipeline consists of a source, followed by zero or more
    intermediate operations, followed by a terminal operation. While the terminal
    operation is mandatory, intermediate operations are not. That said, intermediate
    operations are where pipelines get their real power as they transform the stream
    data as it flows by. Unlike terminal operations, intermediate operations produce
    a stream as a result. Let us start with `filter()`, which is taken from IntermediateOperations.java
    on the repo:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: filter(Predicate)
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `filter()` operation returns a stream containing the elements matching
    the given predicate. *Figure 16**.1* presents a code example (from `IntermediateOperations.java`
    on the repo):'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.1 - The filter(Predicate) intermediate operation in code](img/B19793_16_1.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
- en: Figure 16.1 - The filter(Predicate) intermediate operation in code
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: In this figure, the countries whose names are longer than 5 characters are output.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: distinct()
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `distinct()` operation returns a stream with duplicate elements removed.
    Internally, `distinct()` uses the `equals()` method from `Object` when comparing.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: 'It is a *stateful* intermediate operation which means it needs to keep some
    state to operate effectively. This state enables `distinct()` to operate as follows:
    if this is the first time `distinct()` has seen this object, it passes it on but
    remembers it; if `distinct()` has already seen this object, it filters it out.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 16**.2* presents a code example (from `IntermediateOperations.java`
    on the repo):'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.2 - The distinct() intermediate operation in code](img/B19793_16_2.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
- en: Figure 16.2 - The distinct() intermediate operation in code
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: In this figure, we are streaming a list of strings, where `"eagle"` is duplicated.
    We are using the very useful `Stream<T> peek(Consumer)` intermediate operation.
    This `peek()` operation executes the consumer on the data as it passes by. This
    is a great help as it enables us to view the data flowing by. The `distinct()`
    operation is in our pipeline and the `forEach()` terminal operation starts the
    streaming.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: 'When run, this code generates the following output:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The first `"eagle"` is streamed into the pipeline, where `peek()` echoes it
    to the screen, with the decoration `"Before: "`. Then `peek()` passes `"eagle"`
    on to `distinct()`. As this is the first time `distinct()` has seen `"eagle"`,
    it passes it on but remembers it. Lastly, `forEach()` takes `"eagle"` and outputs
    it prepended with the string `", After:"`, followed by a newline.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: 'Now the second `"eagle"` is streamed. The `peek()` operation outputs the details
    and passes `"eagle"` on. However, `distinct()` remembers that it has seen this
    element already and filters it out. This is why `", After: eagle"` appears only
    once in the output.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, `"EAGLE"` is streamed. This proceeds just as the first `"``eagle"` did.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: limit(long)
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `limit()` operation is a short-circuiting, stateful intermediate operation.
    We saw its short-circuiting nature put into good effect by transforming an infinite
    stream into a finite stream in [*Chapter 15*](B19793_15.xhtml#_idTextAnchor377)*.*
    Obviously, it needs to maintain some state in order to keep a count of the elements
    that have passed by. *Figure 16**.3* presents a code example (`IntermediateOperations.java`):'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.3 - The limit(long) intermediate operation in code](img/B19793_16_3.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
- en: Figure 16.3 - The limit(long) intermediate operation in code
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we are streaming a list of numbers. This example is a good
    example of lazy evaluation. The output is:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Let us examine what happens here.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: 11 is streamed, first `peek()` outputs it prepended with `"A - "` and passes
    it to `filter()` where it fails (as 11 is not > 40)
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 22 is streamed and behaves just as 11 did
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 33 is streamed and operates in a similar fashion to 11 and 22
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 44 is streamed, passes the filter, hence `"B - 44"` is output; 44 is passed
    to `limit()` which records that this is the first element it has seen, before
    passing it on; `forEach()` outputs 44 prepended with `"C - "`.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 55 is streamed and operates as 44 except that `limit()` informs Java that this
    is the second element it has passed and the limit is 2\. Java lets `forEach()`
    finish and the stream is closed.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that the first `peek()` never outputs `"A - 66"`, `"A - 77"`, `"A - 88"`,
    or `"A - 99"`. Therefore, 66, 77, 88, and 99 are never streamed - as they are
    not needed. This is another example of lazy evaluation.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now let us look at `map()`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: map(Function)
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `Stream<R> map(Function<T, R>)` operation is for transforming data. It
    creates a one-to-one mapping between elements in the stream and elements in the
    new stream returned. *Figure 16**.4* presents a code example (`IntermediateOperations.java`):'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.4 - The map(Function) intermediate operation in code](img/B19793_16_4.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
- en: Figure 16.4 - The map(Function) intermediate operation in code
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: 'The `map()` operation takes in a `Function` which, takes in one type and returns
    another, possibly different type. In this example, the lambda used, takes in a
    `String` namely `s`, and returns the `Integer` length of that `String`. The `forEach()`
    outputs the lengths of the `String`s streamed: `"book"` is `4`, `"pen"` is `3`
    and `"ruler"` is `5`.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: flatMap(Function)
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `flatMap()` operation “flattens” a stream. In other words, multiple collections/arrays
    are merged into one. For example, if we were streaming `List<String>` elements,
    they would be flattened into a stream of `String`s, which “removes” or hides each
    individual `List`. This is helpful when combining lists or for removing empty
    elements (which `flatMap()` also does). *Figure 16**.5* presents a code example
    (`IntermediateOperations.java`):'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.5 - The flatMap(Function) intermediate operation in code](img/B19793_16_5.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
- en: Figure 16.5 - The flatMap(Function) intermediate operation in code
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we are going to contrast two streams - one with `flatMap()`
    and the other without `flatMap()`. Let us start with the non-`flatMap()` stream.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将对比两个流 - 一个使用`flatMap()`，另一个不使用`flatMap()`。让我们从非`flatMap()`流开始。
- en: 'Firstly, we create the lists, the first of which is an empty list:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建列表，其中第一个是一个空列表：
- en: '[PRE2]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We then stream the three lists:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们流式传输这三个列表：
- en: '[PRE3]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We then stream and output our `streamOfLists` using `forEach()`:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用`forEach()`流式传输并输出我们的`streamOfLists`：
- en: '[PRE4]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This outputs:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这会输出：
- en: '[PRE5]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note that each element is a list (reflected by the square brackets `[ ]`) and
    that the empty list is present.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，每个元素都是一个列表（通过方括号`[ ]`反映出来），并且空列表是存在的。
- en: 'As the stream has been processed by a terminal operation (`forEach()`), the
    stream is closed. To avoid an exception, we must re-stream the source. This is
    what we do:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 由于流已经被终端操作（`forEach()`）处理，流已经关闭。为了避免异常，我们必须重新流式传输源。这就是我们做的：
- en: '[PRE6]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This second pipeline contains the `flatMap()` operation:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这个第二个管道包含`flatMap()`操作：
- en: '[PRE7]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The signature for `flatMap()` is as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`flatMap()`的签名如下：'
- en: '[PRE8]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Therefore, `flatMap()` takes in a `Function`. The function input `T`, is a `List<String>`
    and the function output `R`, is a `Stream<String>`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`flatMap()`接受一个`Function`。函数输入`T`是一个`List<String>`，函数输出`R`是一个`Stream<String>`。
- en: 'Using `forEach()` again to both start off the streaming and output the elements
    in the stream, we get the following:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 再次使用`forEach()`来启动流式传输并输出流中的元素，我们得到以下结果：
- en: '[PRE9]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note that they are all just `Strings` (no `List`s) and that the empty element
    has been removed. The `String` elements that were in the `List`s are now top-level
    elements in the stream. This is the flattening process explained earlier.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，它们都是`Strings`（没有`List`），并且空元素已经被移除。现在，列表中的`String`元素现在是流中的顶级元素。这就是前面解释的扁平化过程。
- en: sorted() and sorted(Comparator)
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: sorted() 和 sorted(Comparator)
- en: The overloaded `sorted()` operation returns a stream with the elements sorted.
    Just like sorting arrays, Java uses natural ordering unless we provide a `Comparator`.
    For example, natural ordering for numbers is ascending numeric order; natural
    ordering for `String`s is alphabetic. This operation is a stateful intermediate
    operation which means that `sorted()` needs to see all of the data before it can
    sort it. Both sorted examples are based on IntermediateOperations.java in the
    repo. *Figure 16**.6* presents a code example of `sorted(Comparator)`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 重载的`sorted()`操作返回一个已排序元素的流。就像排序数组一样，Java使用自然排序，除非我们提供`Comparator`。例如，数字的自然排序是升序数字顺序；`String`的自然排序是字母顺序。这个操作是一个有状态的中间操作，这意味着`sorted()`在排序之前需要看到所有数据。这两个排序示例都是基于repo中的IntermediateOperations.java。*图16.6*展示了`sorted(Comparator)`的代码示例。
- en: '![Figure 16.6 - The sorted(Comparator) intermediate operation in code](img/B19793_16_6.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![图16.6 - 代码中的sorted(Comparator)中间操作](img/B19793_16_6.jpg)'
- en: Figure 16.6 - The sorted(Comparator) intermediate operation in code
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.6 - 代码中的sorted(Comparator)中间操作
- en: In this example, assume the existence of a `Person` class that has both `String`
    `name` and `Integer` `age` instance variables. We start by streaming the `Person`
    objects; `"Mary"` is first, age 25 and `"John"` is second, age `23`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，假设存在一个`Person`类，它既有`String`类型的`name`实例变量，也有`Integer`类型的`age`实例变量。我们首先流式传输`Person`对象；“Mary”是第一个，年龄25岁，“John”是第二个，年龄`23`岁。
- en: 'The `sorted(Comparator)` line is interesting:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`sorted(Comparator)`这一行很有趣：'
- en: '[PRE10]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `Comparator.comparing(Function keyExtractor)` static method is a very useful
    way of generating a `Comparator`. It accepts in a `Function` that extracts a `Comparable`
    sort key - as in, a key whose type implements the `Comparable` interface. In this
    example, the `Function` input is a `Person` and the `Function` return is an `Integer`
    (the age of the person). As `Integer` implements `Comparable`, this is fine. The
    method then returns a `Comparator` that compares by that sort key. This pipeline
    is short and does not clearly demonstrate the stateful nature of `sorted()`. The
    next example will do that.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`Comparator.comparing(Function keyExtractor)`静态方法是一种生成`Comparator`的非常有用方式。它接受一个`Function`，该函数提取一个`Comparable`排序键
    - 也就是说，一个键的类型实现了`Comparable`接口。在这个例子中，`Function`输入是一个`Person`，而`Function`返回值是一个`Integer`（人的年龄）。由于`Integer`实现了`Comparable`，这是可以的。然后该方法返回一个通过该排序键比较的`Comparator`。这个管道很短，并没有清楚地展示`sorted()`的状态性。下一个例子将做到这一点。'
- en: When we output the stream, `"John"` comes out first and `"Mary"` second (the
    reverse of the order in which they were streamed). This is because we are sorting
    by `age` and `"John"`, at `23`, is younger than `"Mary"`, who is `25`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: Now let us look at another `sorted()` example. This one will demonstrate the
    stateful nature of `sorted()` and at the same time, highlight lazy evaluation.
    *Figure 16**.7* presents the code.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.7 - The stateful nature of sorted()](img/B19793_16_7.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
- en: Figure 16.7 - The stateful nature of sorted()
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we are streaming a list of `String`s (names). Names that are
    of length `3` pass the filter:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `sorted()` operation is stateful - it needs to see *all* of the data before
    it can sort that data. We also have a `limit(2)` operation which is both stateful
    and short-circuiting. It will short-circuit after 2 names have passed by. Lastly,
    the terminal operation `forEach()` starts off the streaming process and outputs
    the names as they arrive.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: 'The output is as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Let us examine what happens here. Note that the comments on the right of the
    pipeline (lines 49-55) indicate what stage each name gets to.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '`"Tim"` is streamed and passes the filter. `"Tim"` makes its way to `sorted()`
    where it is stored. Java tells `sorted()` that there is more data to be streamed
    and not to sort yet. This results in `"0\. Tim 1\. Tim"` in the output.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"Jim"` is streamed next and behaves exactly as `"Tim"`, with `sorted()` keeping
    a record that it will have to sort both `"Tim"` and `"Jim"`. Again, Java tells
    `sorted()` that there is more data to come and not to sort yet. Thus, we have
    `"0\. Jim 1\. Jim"` in the output.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"Peter"` is then streamed but fails the filter (just `"0\. Peter"` and no
    `"1\. Peter"` in the output).'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"Ann"` is streamed next and behaves exactly as `"Tim"` and `"Jim"`, with `sorted()`
    keeping a record that it will have to sort `"Tim"`, `"Jim"`, and `"Ann"`. Again,
    Java tells `sorted()` not to sort yet. Thus, we have in `"0\. Ann 1\. Ann"` in
    the output.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"Mary"` is the last name to be streamed. `"Mary"` fails the filter also (just
    “`0\. Mary`” and no `"1\. Mary"` in the output).'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As the stream is now empty, Java tells `sorted()` that it can sort the data.
    The sorted names are `"Ann"`, `"Jim"`, and `"Tim"`. So `"Ann"` now makes its way
    out of `sorted()` and onto the next stage of the stream pipeline.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `peek()` after `sorted()` outputs `"2\. Ann"` showing `"Ann"` got here.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `limit()` operation passes “Ann” on but records that it has handled one
    name.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The terminal operation `forEach()` which kick-started the whole streaming process,
    outputs `"3\. Ann"` to show that `"Ann"` got as far as here.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"Jim"` now makes its way out of `sorted()`. `"Jim"` is peeked (`"2\. Jim"`)
    and passes through `limit()`. However, `limit()` short-circuits as this is the
    second name it has handled. Java is informed of this fact.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `forEach()` operation is allowed to finish outputting `"``3\. Jim"`.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that `"Tim"` never gets out of `sorted()` and into the last `peek()` -
    there is no `"2\. Tim"` in the output.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That completes this section on intermediate operations. Let us now examine primitive
    streams.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: Delving into primitive streams
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Thus far, all our streams have been for `Object` types. For example, a `Stream<Integer>`
    caters for the wrapper class `Integer`. Java also has classes specifically tailored
    for streams of primitives. For example, assuming a stream of `int` primitives,
    rather than `Stream<Integer>`, we use `IntStream`. As we shall see shortly, primitive
    streams have some really useful methods for processing numeric data, such as `sum()`
    and `average()`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '*Table 16.1* introduces the primitive stream classes.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '| **Wrapper stream** | **Primitive stream** | **Primitives** **catered for**
    |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
- en: '| `Stream<Integer>` | `IntStream` | `int, short,` `byte, char` |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
- en: '| `Stream<Double>` | `DoubleStream` | `double, float` |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
- en: '| `Stream<Long>` | `LongStream` | `long` |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
- en: Table 16.1 - Primitive stream classes
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: In this table, the first column lists the wrapper type streams; the second column
    lists the corresponding primitive stream and the last column, enumerates the primitives
    catered for by the primitive stream from column two.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: Let us examine how to create primitive streams.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: Creating primitive streams
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As with creating `Object` streams, we can easily create primitive streams as
    well. *Figure 16**.8* presents sample code creating primitive streams (based on
    code from PrimitiveStreams.java in the repo).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.8 - Creating primitive streams](img/B19793_16_8.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
- en: Figure 16.8 - Creating primitive streams
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we create arrays of differing primitive types:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Using the overloaded `Arrays.stream()` method, we create an `IntStream`, `DoubleStream`
    and `LongStream` respectively:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: For example, the `Arrays.stream(ia)` takes in an `int[]` and returns an `IntStream`
    with the specified array as its source.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: 'We then execute the `count()` terminal operation on each of the streams. Each
    returns `3` as there are `3` primitives in each array source:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `of()` method should look familiar from how we created a regular stream
    using the `Stream` class. There is an equivalent method in `IntStream`, `DoubleStream`
    and `LongStream`. The values in the streams are specified in the varargs arguments:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Again, we execute the `count()` terminal operation on each of the streams.
    As before, `3` is returned each time, as there are `3` primitives in each of the
    streams:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We can of course create infinite streams of primitives. *Figure 16**.9*, from
    PrimitiveStreams.java in the repo, shows them being used and their equivalent
    names in the `Stream` class are familiar, namely `generate()` and `iterate()`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.9 - Infinite primitive streams](img/B19793_16_9.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
- en: Figure 16.9 - Infinite primitive streams
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we start out with the following two lines of code:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `DoubleStream.generate(DoubleSupplier)` method has equivalent versions in
    `IntStream` and `LongStream`. Its parameter `DoubleSupplier` is a functional interface
    where it produces a `double`. Thus, it is a `double` primitive version of `Supplier<T>`.
    Its functional method `double getAsDouble()` reinforces this fact. We use `limit(5)`
    to limit the infinite flow of numbers to `5` and each is output by the terminal
    operation `forEach()`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: 'We follow that with the next two lines of code:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `IntStream.iterate()` method has equivalent versions in `DoubleStream` and
    `LongStream`. It takes two arguments, an `int` seed (the starting value) and an
    `IntUnaryOperator` function. This `IntUnaryOperator` function takes in an `int`
    and returns an `int`. It is the `int` primitive specialization of `UnaryOperator<T>`.
    The stream of numbers generated are even numbers, starting at `2`. As the sequence
    of numbers is infinite, we apply a limit of 5 numbers (`2`, `4`, `6`, `8`, `10`).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: Let us now examine common primitive stream methods.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: Common primitive stream methods
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The methods just presented, namely `of()`, `generate()` and `iterate()` are
    common to `Stream<T>` as well. *Table 16.2* presents commonly used methods that
    are unique to primitive streams.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 16.2 - Common primitive stream methods](img/B19793_16_Table_02.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
- en: Table 16.2 - Common primitive stream methods
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: 'This table has two columns: the name of the method (including its return type)
    and the primitive streams. Each of the methods listed are reductions and terminal
    operations. Recall that a reduction produces a single summary result by repeatedly
    applying an operation to a sequence of input results. We saw the general form
    of reductions with the `reduce()` and `collect()` methods in the `Stream<T>` interface.
    The reductions in this table are specialized for primitives.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: Let us first examine the `sum()` method. Notice that it does not return an `Optional`
    whereas all the other methods do. This is because `0` is a valid value to return
    for the sum of an empty stream. In other words, if the stream is empty when you
    execute `sum()` - perhaps all of the data has been filtered out - then `0` is
    a valid return. The other methods in the table, however, would need to return
    an empty `Optional` in that scenario. The `IntStream` for `sum()` returns an `int`,
    the version in `LongStream` returns a `long` and the version in `DoubleStream`
    returns a `double`.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: Regarding `min()` and `max()`, both `IntStream` versions return an `OptionalInt`;
    both `LongStream` versions return an `OptionalLong` and both `DoubleStream` versions
    return an `OptionalDouble`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: The `average()` method is a little different because of the possibility of decimal
    places regardless of the type being totaled. So all three primitive stream types,
    namely `IntStream`, `LongStream`, and `DoubleStream` return an `OptionalDouble`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: Let us examine them in code (PrimitiveStreams.java in the repo). Firstly, *Figure
    16**.10* presents `min()`, `max()` and `average()`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过代码（repo中的PrimitiveStreams.java）来检查它们。首先，**图16**.10展示了`min()`、`max()`和`average()`。
- en: '![Figure 16.10 – The min(), max() and average() operations in code](img/B19793_16_10.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![图16.10 – 代码中的min()、max()和average()操作](img/B19793_16_10.jpg)'
- en: Figure 16.10 – The min(), max() and average() operations in code
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.10 – 代码中的min()、max()和average()操作
- en: 'In this figure, we start with the following code:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图中，我们从以下代码开始：
- en: '[PRE20]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Firstly, we create a stream of `int` primitives. We then execute the terminal
    operation `max()`, which starts the stream and calculates the maximum number in
    the stream, which is 30\. No need for any `Comparator` or accumulator here! We
    then use the `ifPresent(IntConsumer)` from `OptionalInt` (there are equivalents
    for `OptionalDouble` and `OptionalLong`). What this method means, is that, if
    there is a value *present* in the `OptionalInt`, output it. If the optional is
    empty, nothing is printed.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个`int`原始流。然后执行终端操作`max()`，它启动流并计算流中的最大数，即30。这里不需要任何`Comparator`或累加器！然后我们使用`OptionalInt`的`ifPresent(IntConsumer)`（对于`OptionalDouble`和`OptionalLong`也有等效方法）。这个方法的意思是，如果`OptionalInt`中存在值，则输出它。如果可选对象为空，则不打印任何内容。
- en: 'The next code segment of interest is:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 下一段有趣的代码是：
- en: '[PRE21]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In this code segment, we create a `DoubleStream` based on the values provided
    in the varargs argument. Using `min()`, we stream the values and calculate the
    minimum value. The `orElseThrow()` method means: if there is a value present,
    return that value; otherwise throw a `NoSuchElementException`.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码段中，我们根据提供的varargs参数创建一个`DoubleStream`。使用`min()`，我们流式传输值并计算最小值。`orElseThrow()`方法意味着：如果存在值，则返回该值；否则抛出`NoSuchElementException`。
- en: 'The last code segment is:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一段代码是：
- en: '[PRE22]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Here, we create a `LongStream` based on the values provided in the varargs
    argument. This is followed by executing `average()`, which both streams the values
    and calculates their average. The `orElseGet(DoubleSupplier)` method means: if
    there is a value present, return that value; otherwise return the value from the
    supplying function (a random number).'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们根据提供的varargs参数创建一个`LongStream`。随后执行`average()`，它既流式传输值又计算它们的平均值。`orElseGet(DoubleSupplier)`方法意味着：如果存在值，则返回该值；否则返回供应函数（一个随机数）的值。
- en: Let us now examine `sum()`. It is easy to see why primitive streams are useful
    in the next example, *Figure 16**.11*.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在检查`sum()`。很容易看出原始流在下一个示例（*图16**.11*）中的有用性。
- en: '![Figure 16.11 - The sum() primitive operation](img/B19793_16_11.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![图16.11 - sum()原始操作](img/B19793_16_11.jpg)'
- en: Figure 16.11 - The sum() primitive operation
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.11 - sum()原始操作
- en: 'In this figure, we start out with the following:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图中，我们首先从以下内容开始：
- en: '[PRE23]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This code creates an `int` primitive stream directly using the `IntStream.of()`
    method and uses the `sum()` terminal method to stream the numbers and return the
    sum, which is 9.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码直接使用`IntStream.of()`方法创建一个`int`原始流，并使用`sum()`终端方法流式传输数字并返回总和，即9。
- en: 'The rest of the example code, contrasts `reduce()` from `Stream<T>` and `sum()`
    from `IntStream`. Let us focus on `reduce()` first:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 示例代码的其余部分，对比了`Stream<T>`的`reduce()`和`IntStream`的`sum()`。让我们首先关注`reduce()`：
- en: '[PRE24]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Initially, we stream a list of `Integer`s into a `Stream<Integer>` and them
    sum them up by passing an accumulator function argument to `reduce()`.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，我们将一个`Integer`列表流式传输到一个`Stream<Integer>`中，然后通过传递累加函数参数给`reduce()`来求和。
- en: 'Now we will focus on how to do the same thing using `sum()`:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将关注如何使用`sum()`做同样的事情：
- en: '[PRE25]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Firstly, we stream the same numbers as a `Stream<Integer>` again - we do not
    have a stream of primitives at this point. The second line shows how easy it is
    to convert from a `Stream<Integer>` to a `Stream` of `int` primitives. Using the
    `Stream` interfaces `mapToInt()` function; we pass in our function, which takes
    in an `Integer` and returns the `int` primitive wrapped by that `Integer`. In
    this code, we are availing of auto-unboxing by simply specifying the identifier
    `n` on both sides of the arrow token in the lambda. Now that we have an `IntStream`
    object we can use the `sum()` method - which streams the integers and returns
    the sum of 6\. Note that we have deliberately left the return types visible in
    the code. This helps explain what is happening in the pipeline. In reality, you
    would code it much more concisely as follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: With each of the primitive streams, you can get summarizing statistics (summary
    data about the elements in the stream). Let us look at these in action. *Figure
    16**.12* presents `IntSummaryStatistics`.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.12 - IntSummaryStatistics in code](img/B19793_16_12.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
- en: Figure 16.12 - IntSummaryStatistics in code
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, the streams are being passed in via the following method calls:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The first invocation passes in a valid stream of integers whereas the second
    stream is empty. Once inside the `stats()` method, the terminal operation `summaryStatistics()`
    is executed on the `IntStream` passed in. The resultant `IntSummaryStatistics`
    object is now available to inspect for summary data:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The output for the first stream (5, 10, 15 and 20) is:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '`5` is output by `getMin()`; `20` is output by `getMax()`; `12.5` is output
    by `getAverage()`; `4` is output by `getCount()` and `50` is output by `getSum()`.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: 'The output for the empty stream is:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '`2147483647` (which is `Integer.MAX_VALUE`) is output by `getMin()`; `-2147483648`
    (`Integer.MIN_VALUE`) is output by `getMax()`; 0.0 is output by `getAverage()`;
    0 is output by `getCount()` and 0 is output by `getSum()`.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: With primitive streams there are now extra functional interfaces that we need
    to be aware of.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: New primitive stream interfaces
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are many new functional interfaces to be aware of. Thankfully, they follow
    a consistent naming pattern. *Table 16.3* outlines the more common ones. For further
    details please see the JavaDocs at: [https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/function/package-summary.html](https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/function/package-summary.html).'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '![Tables 16.3 (a) and (b) - New primitive stream functional interfaces](img/B19793_16_Table_03.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
- en: Tables 16.3 (a) and (b) - New primitive stream functional interfaces
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: In this figure, table A is on the left, with table B on the right. Each table
    has two columns - one for the functional interface name and one for its functional
    method.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: 'We have deliberately included the generically marked functional interfaces
    encountered earlier. This is to help contrast them with their primitive counterparts.
    The previous functional interfaces that we came across are: `Supplier<T>,` `Consumer<T>`,
    `BiConsumer<T, U>`, `Predicate<T>`, `BiPredicate<T, U>`, `Function<T, R>`, `BiFunction<T,
    U, R>`, `UnaryOperator<T>` and `BinaryOperator<T>`. Note the generic types in
    them all. Very few primitive functional interfaces use generics, as they are typed
    for a particular primitive.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: We have color-coordinated the interfaces in order to group them. So for example,
    in table A the yellow colored interfaces are the suppliers. `Supplier<T>` with
    its `T get()` functional method - as stated, this is included for comparison purposes.
    `DoubleSupplier` is the interface for generating `double` primitives. Its functional
    method is `getAsDouble()` and its return type is a `double`. The `IntSupplier`
    and `LongSupplier` interfaces follow the same pattern.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: 'Still in table A, the consumers are next, in green. `DoubleConsumer` “accepts”
    a `double` primitive and returns nothing. `IntConsumer` accepts in an `int`, returns
    nothing; and `LongConsumer` accepts in a `long`, returns nothing. All the functional
    methods are called `accept()`. Note the pattern for naming: suppliers use `DoubleSupplier`;
    consumers use `DoubleConsumer`.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: This naming convention continues with the predicates (blue). We have `DoublePredicate`
    that “tests” a `double` and returns a `boolean`. `IntPredicate` and `LongPredicate`
    behave in a similar manner - a primitive type parameter and a return type `boolean`.
    All the functional methods are called `test()`.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: In table B, we have the functions, in yellow. We have `DoubleFunction<R>` that
    “applies” a `double` and returns the type `R`. The functions are a case where
    generics are used to represent the type being returned. However, the primitive
    being applied is the important aspect here. `IntFunction<R>` and `LongFunction<R>`
    behave in a similar manner - a primitive type parameter and a return type `R`.
    All the functional methods are called `apply()`.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, in table B, we have the primitive versions of `UnaryOperator<T>` and
    `BinaryOperator<T>`. The `double` primitive version of `UnaryOperator<T>` is `DoubleUnaryOperator`
    (note the word `Double` at the start again). Recall that unary functions are functions
    that accept in one parameter and return a value; where both types are the same.
    Therefore, `DoubleUnaryOperator` has a `double` parameter and a `double` return
    type. `IntUnaryOperator` and `LongUnaryOperator` follow the same pattern.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: The `DoubleBinaryOperator`, `IntBinaryOperator` and `LongBinaryOperator` interfaces
    only differ from their unary counterparts in the number of parameters they take
    in. Therefore, `DoubleBinaryOperator` takes in two `double`s, `IntBinaryOperator`
    takes in two `int`s and `LongBinaryOperator` takes in two `long`s.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: There are other ways to create streams and that is by mapping from other streams.
    Let us examine that now.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: Mapping streams
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Again, there are many new functional interfaces to be aware of; and again, thankfully,
    they follow a consistent naming pattern. *Table 16.4* outlines the more common
    ones.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 16.4 - Mapping streams](img/B19793_16_Table_04.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
- en: Table 16.4 - Mapping streams
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: In this table, the rows represent the source stream class and the columns represent
    the target stream class. Again, we use color to help organize our explanations.
    The yellow boxes represent situations where the source and target classes are
    the same. So, for example, if you are going from a `DoubleStream` to another `DoubleStream`,
    the method is `map(DoubleUnaryOperator)`. The functional method is also listed
    - so for this example, `DoubleUnaryOperator`‘s functional method is `double applyAsDouble(double)`.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: Let us examine the brown boxes. Each of these uses a `mapToObj()` method as
    the source is a primitive stream and the target is a stream of objects. The source
    stream hints at the function to be used. For example, if the source is a `DoubleStream`
    then the `DoubleFunction` interface applies, as you are mapping from a `double`
    primitive to a type `R`. This is specified in the functional method `R` `apply(double
    value)`.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: Next the green boxes. The target stream is `DoubleStream` and hence the method
    name is `mapToDouble()`. If the source stream is a stream of objects then the
    interface is `ToDoubleFunction<T>`. Its functional method is `double` `applyAsDouble(T
    value)`, so a type `T` is input and a `double` primitive is output. Just what
    you would expect, when going from an object of type `T` to a primitive `double`.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: 'Staying with the target stream of `DoubleStream`, if the source was an `IntStream`,
    then the primitives involved are in the name of the interface: `IntToDoubleFunction`.
    No surprise that its functional method is `double` `applyAsDouble(int)`. If the
    source was a `LongStream`, then the primitives involved are again in the name
    of the interface: `LongToDoubleFunction`. No surprise either that its functional
    method is `double` `applyAsDouble(long)`.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: The blue boxes represent a target stream of `IntStream`. The method name is
    `mapToInt()`. The functional interfaces used as parameters and their functional
    methods, follow the same naming pattern as outlined for `DoubleStream`.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, the grey boxes represent a target stream of `LongStream`. The method
    name is `mapToLong()`. A similar naming pattern is again applied to the functional
    interfaces and their functional methods as shown in `DoubleStream` and `IntStream`.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: Let us look at some code examples. We will start with mapping from streams of
    objects.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: Mapping from Object streams
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first example will have a `Stream<String>` as the source and map to the
    various other streams accordingly. *Figure 16**.13* represents the code (`MappingStreams.java`
    in the repo).
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.13 - Mapping Object streams](img/B19793_16_13.jpg)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
- en: Figure 16.13 - Mapping Object streams
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: 'In this figure, we are mapping a `Stream<String>` to all the other stream types,
    including `Stream<String>` itself. The first example is:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In this case, the `map(Function<T,R>)` maps from `String` to `String`. The function
    converts the string to uppercase. The `forEach()` terminal operation starts the
    streaming process and outputs the strings.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: 'The second example is:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This time the `Stream<String>` is mapped to a `DoubleStream` (of `double` primitives).
    Notice that we must re-stream the source as the previous `forEach()` closed it.
    This pipeline uses the `mapToDouble(ToDoubleFunction<T>)` to map from a `String`
    to a `double` primitive. The function this time use the `length()` of the `String`
    which is an `int`. This `int` is upcast to a `double` in the background. The `forEach()`starts
    the stream and outputs the `double` values.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: 'The third example is:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This time the `Stream<String>` is mapped to an `IntStream`. Again we must re-stream
    the source. This pipeline uses the `mapToInt(ToIntFunction<T>)` to map from a
    `String` to an `int` primitive. We again use the `length()` function of `String`.
    As this is an `int`, no upcasting is required in the background. The `forEach()`
    terminal operation is used to start the stream and output the `int` values.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: 'The last example is:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Here, the `Stream<String>` is mapped to a `LongStream`. This pipeline uses the
    `mapToLong(ToLongFunction<T>)` to map from a `String` to a `long` primitive. As
    the `length()` of `String` returns an `int`, upcasting is done in the background.
    The `long` values are output as part of the `forEach()` terminal operation.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: Now let us examine code examples mapping from streams of primitives.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: Mapping from primitive streams
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this example, we are mapping from streams of primitives to other stream types.
    *Figure 16**.14* presents the code (`MappingStreams.java`).
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.14 - Mapping primitive streams](img/B19793_16_14.jpg)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
- en: Figure 16.14 - Mapping primitive streams
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we are streaming `int` primitives using `IntStream.of()`, and
    converting the `IntStream` to a `Stream<String>`, `DoubleStream`, `IntStream`
    and `LongStream` in turn.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the first example:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This code represents a sample pipeline for streaming `int` primitives and mapping
    them to a stream of `String` objects. The `mapToObj()` method is important here.
    It’s signature is: `Stream<R> mapToObj(IntFunction<R>)`. The lambda passed in
    is easier to understand when we look at the functional method of the functional
    interface `IntFunction<R>`. The functional method is `R apply(int value)`. In
    our example, the `int` primitive is passed in as `n` and the `String` returned
    (represented by `R` in the method signature) is the string formed by prepending
    `"Number:"` in front of the `int`. Recall that when you have a string on the left
    or the right side (or both) of a `+` the result is a `String`. The `forEach()`
    streams the `int` primitives and outputs the `Stream<String>`.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: 'The next example is:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This code is mapping from an `IntStream` to a `DoubleStream`. The `mapToDouble()`
    method is important here. It’s signature is:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '`DoubleStream` `mapToDouble(IntToDoubleFunction)`. The functional method for
    `IntToDoubleFunction` is `double applyAsDouble(int value)`. Thus, our lambda passes
    in an `int` and returns a `double`. The cast is not necessary and it just there
    to emphasize that a `double` primitive is returned.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the next example:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Here we are mapping an `IntStream` to another `IntStream`. The method `IntStream
    map(IntUnaryOperator)` is used. Its functional method is:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '`int applyAsInt(int value)` so we pass in an `int` and get back an `int`. Our
    lambda is simply multiplying the `int` coming in by 2 and returning the result.'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: 'And the last example:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This code maps an `IntStream` to a `LongStream`. The method `LongStream mapToLong(IntToLongFunction)`
    is used. Its functional method is:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '`long applyAsLong(int value)` so we pass in an `int` and get back a `long`.
    Again, the cast is not necessary, it is simply emphasizing that a `long` primitive
    is returned.'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: That completes our coverage of mapping streams. Let us now move on to examining
    `Optional`s.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: Explaining Optionals
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An `Optional` can be thought of as a container that may or may not be empty.
    As per the API, the container “may or may not contain a non-`null` value”. An
    `Optional` is primarily used as a method return type where there is a real need
    to represent “no result” and when returning `null` could cause errors. Before
    Java 8, programmers would return `null` but now, since Java 8, we can return an
    *empty* `Optional` instead. This has several advantages:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: Reduces the risk of `NullPointerException`s
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By using `Optional` as the return type, the API can now clearly state that there
    may not be a value returned
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Optional` API facilitates the functional programming style
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As well as `Optional<T>`, there are `Optional`s for the primitive types also;
    namely: `OptionalInt`, `OptionalDouble` and `OptionalLong`. We will examine them
    later.'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: Let us first look at how to create `Optional`s.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: Creating Optionals
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The API provides several `static` methods for this purpose. Let’s start with
    `Optional.of(T)`.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The `value` parameter is wrapped in an `Optional`. The `value` passed must be
    a non-`null` value. If `null` is passed in, a `NullPointerException` results.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: Now, let us look at `Optional.empty()`. This is how you create an empty Optional
    instance.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Lastly, we will examine `Optional.ofNullable(T)`.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'If the given `value` is non-`null`, this method returns the wrapped `value`
    in an `Optional`. If `null` is passed in, an empty `Optional` is returned. If
    we examine the following code:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Both of these lines do the same thing. The first line is shorthand for the
    ternary operator on the second line. The ternary operator is expressing the following:
    if `value` is `null`, `opt2` is assigned an empty `Optional`; otherwise, `opt2`
    is assigned the wrapped `value`.'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 16**.15* presents them in code (`Optionals.java` in the repo).'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.15 - Creating Optionals](img/B19793_16_15.jpg)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
- en: Figure 16.15 - Creating Optionals
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: 'The first example here creates an empty `Optional`:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: We use the `Optional.empty()` method to create an empty `Optional`. The next
    line is commented out because if you execute `get()` on an empty `Optional`, you
    will get a `NoSuchElementException` exception. The last line shows the functional
    style `ifPresent(Consumer)`. If a value is present, the given consumer is applied
    to the value; otherwise it does nothing. In this case, it does nothing as the
    `Optional` is empty.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: 'The next example creates a non-empty `Optional`:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'This time we create an `Optional` using `Optional.of()`, with the value 23\.
    The second line shows that you will get a `NullPointerException` if you pass `null`
    to `Optional.of()`. The `ifPresent()` now executes the consumer passed, which
    outputs `"``opt2: 23"`.'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: 'The next example uses `Optional.ofNullable()`:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Here we create an `Optional` using `Optional.ofNullable()`, also with the value
    23\. As the `Optional` is not empty, the consumer passed to `ifPresent()` outputs
    `"``opt3: 23"`.'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the last example:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: In this example, we use `Optional.ofNullable()` again, but this time, we pass
    in `null`. Rather than getting an exception (which is what `Optional.of(null)`
    would generate), we get an `Optional`. As the `Optional` is empty, the `ifPresent()`
    does nothing. The `isEmpty()` proves that the `Optional` is in fact empty resulting
    in `"opt4 is empty!"` being output.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know how to create `Optional`s, let us explore the API methods available.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: Using the Optional API
  id: totrans-286
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Table 16.5* represents the instance methods in `Optional`.'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: '| **Method** | **What happens if Optional** **is empty** | **What happens if
    Optional has** **a value** |'
  id: totrans-288
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-289
  prefs: []
  type: TYPE_TB
- en: '| `get()` | Throws `NoSuchElementException` | Returns the value |'
  id: totrans-290
  prefs: []
  type: TYPE_TB
- en: '| `isPresent()` | Returns `false` | Returns `true` |'
  id: totrans-291
  prefs: []
  type: TYPE_TB
- en: '| `ifPresent(Consumer)` | Does nothing | Executes `Consumer` with value |'
  id: totrans-292
  prefs: []
  type: TYPE_TB
- en: '| `orElse(T otherValue)` | Returns `otherValue` | Returns the value |'
  id: totrans-293
  prefs: []
  type: TYPE_TB
- en: '| `orElseGet(Supplier)` | Returns result of executing `Supplier` | Returns
    the value |'
  id: totrans-294
  prefs: []
  type: TYPE_TB
- en: '| `orElseThrow()` | Throws `NoSuchElementException` | Returns the value |'
  id: totrans-295
  prefs: []
  type: TYPE_TB
- en: '| `orElseThrow(Supplier)` | Throws exception returned by `Supplier`. However,
    if `Supplier` is `null`, throws a `NullPointerException` | Returns the value |'
  id: totrans-296
  prefs: []
  type: TYPE_TB
- en: Table 16.5 - Optional instance methods
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: Many of these methods enable us to write code in a more concise and expressive
    manner. `ifPresent(Consumer)` is a very good example - rather than having in `if-else`
    statement, `ifPresent(Consumer)` removes the need to code the `else` part. Additionally,
    `ifPresent(Consumer)` helps us express our intent more clearly - if a value *is
    present*, do this; otherwise do nothing.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 16**.16* presents methods from the `Optional` API in code.'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.16 - Optional methods in code](img/B19793_16_16.jpg)'
  id: totrans-300
  prefs: []
  type: TYPE_IMG
- en: Figure 16.16 - Optional methods in code
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we will use both a non-null `Optional` and an empty `Optional`
    to test the various methods. Let us start with a valid non-null `Optional`.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: Optional with a value
  id: totrans-303
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Firstly, we create an `Optional` wrapped around the `Double 60.0`:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'We then use `isPresent()` to ensure it is safe to execute the `get()` method,
    as executing `get()` on an empty `Optional` results in an exception:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: As `isPresent()` returns `true`, it is safe to execute `get()`, which returns
    `60.0` and this is output to the screen.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: 'The next 2 lines are:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: In this code segment, as there is a non-null value in `valueInOptional`, the
    consumer argument to `ifPresent()` is executed, and `60.0` is output to the screen.
    In addition, as we have a value in `valueInOptional`, the `orElse(T value)` method
    is not executed; meaning that `60.0` is output to the screen.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: Empty Optional
  id: totrans-312
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Firstly, we create an empty `Optional` by passing in `null` to `ofNullable()`:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'We then have:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The `orElse(T value)` returns `NaN` and `orElseGet(Supplier)` executes the `Supplier`
    which is to generate a random number. Note that the `Supplier` must return a `Double`
    as that is the type of `emptyOptional`.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, we have:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Both lines execute `orElseThrow()` and are mutually exclusive. What this means
    is that, to see the exception on the second line, comment out the first line.
    As the `Optional` is empty, the first line throws a `NoSuchElementException`.
    Assuming we comment out the first line and uncomment the second line, the `Supplier`
    passed in to `orElseThrow()` will return a `RuntimeException`. Note that we do
    not use the keyword `throw` in our `Supplier`. The `orElseThrow()` method will
    do that for us - our job is to give it, via the `Supplier`, an exception object
    to throw.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: Our last section regarding `Optional`s, are primitive `Optional`s.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: Primitive Optionals
  id: totrans-322
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As stated earlier, there are `Optional`s for the primitive types also; namely:
    `OptionalInt`, `OptionalDouble` and `OptionalLong`. We will look at them now.'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: '*Table 16.6* highlights the more commonly used primitive stream methods.'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: '| **OptionalInt** | **OptionalDouble** | **OptionalLong** |'
  id: totrans-325
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-326
  prefs: []
  type: TYPE_TB
- en: '| `int getAsInt()` | `double getAsDouble()` | `long getAsLong()` |'
  id: totrans-327
  prefs: []
  type: TYPE_TB
- en: '| `ifPresent(IntConsumer)``void accept(int)` | `ifPresent (DoubleConsumer)``void
    accept(double)` | `ifPresent(LongConsumer)``void accept(long)` |'
  id: totrans-328
  prefs: []
  type: TYPE_TB
- en: '| `OptionalInt of(int)` | `OptionalDouble of(double)` | `OptionalLong of(long)`
    |'
  id: totrans-329
  prefs: []
  type: TYPE_TB
- en: '| `int` `orElse(int other)` | `double orElse``     (``double other)` | `long` `orElse(long other)` |'
  id: totrans-330
  prefs: []
  type: TYPE_TB
- en: '| `orElseGet(IntSupplier)``int getAsInt()` | `orElseGet (DoubleSupplier)``double
    getAsDouble()` | `orElseGet(LongSupplier)``long getAsLong()` |'
  id: totrans-331
  prefs: []
  type: TYPE_TB
- en: '| `IntStream stream()` | `DoubleStream stream()` | `LongStream stream()` |'
  id: totrans-332
  prefs: []
  type: TYPE_TB
- en: Table 16.6 - Commonly used primitive stream methods
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: This table contrasts the more commonly used methods across the primitive streams.
    Where appropriate, the functional method is also listed, beneath the functional
    interface. For example, examining the `ifPresent(IntConsumer)` for `OptionalInt`
    shows that `IntConsumer`’s functional method is `void accept(int)`.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: Note that the return types for the `orElseGet()` methods can be deduced from
    the functional methods just below. For example, examining the `orElseGet()` for
    `OptionalInt` shows that `IntSupplier`’s functional method is `int getAsInt()`.
    Therefore, the return type for `orElseGet(IntSupplier)` is also `int`.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us examine some of these in code. *Figure 16**.17* is the example (`Optionals.java`):'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.17 - Primitive stream methods in code](img/B19793_16_17.jpg)'
  id: totrans-337
  prefs: []
  type: TYPE_IMG
- en: Figure 16.17 - Primitive stream methods in code
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: 'In this figure, we start out as follows:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: This first line uses the `IntSream` method `rangeClosed()` to generate a stream
    of integers from 1 to 10 inclusive, in steps of 1\. The `average()` method then
    calculates the average of these numbers, which is `5.5` (55/10). Note that the
    type for `optAvg` is `OptionalDouble`.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: The second uses the now familiar `ifPresent()` method. This time the consumer
    argument is a `DoubleConsumer`, which means the functional method is `void accept(double)`.
    This is what we are doing - the value of the `OptionalDouble` is used (namely
    `d`) and output.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: 'We then have:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: which uses `getAsDouble()` to return the `double` value. If no value is present,
    this method (like `get()` in `Optional<T>`) generates a `NoSuchElementException`.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: 'The next two lines are:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The first line uses the `orElseGet()` method. We pass in a `DoubleSupplier`,
    which means there is no input argument (hence the `()` in the lambda) and a `double`
    returned (`Double.NaN`). As the `OptionDouble` has a value, the value is used
    to initialize `dblAvg` and the `DoubleSupplier` is ignored. We then output the
    variable `dblAvg`.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code segment completes the example:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The first line creates an `OptionalInt` using the static `OptionalInt.of()`
    method. The second line uses the `orElseGet()` method. We pass in a `IntSupplier`,
    meaning we pass in nothing and get back in `int` (which is `0`). As `optInt` has
    a value, the value is used to initialize `age` and the `IntSupplier` is ignored.
    The third line outputs the variable `age`. The last line uses `getAsInt()` to
    return the `int` value. If no value is present in the optional, this method would
    also, like `getAsDouble()`, generate a `NoSuchElementException`. However, as `optInt`
    contains a value (of 35), it is returned and output.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: That complete the `Optional`s section. Our least section in this chapter is
    parallel streams.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: Understanding parallel streams
  id: totrans-353
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All of the streams so far have been serial streams where the results are ordered.
    With serial streams, a single thread processes one entry at a time. A parallel
    stream is processed by multiple threads executing concurrently (running on multiple
    CPUs). The stream elements are split into substreams, which are processed by multiple
    instances of the stream pipeline being executed in multiple threads. These partial
    substream results are then combined into a final result. To execute the substreams
    in parallel, the streams use the support of Java’s fork/join framework for thread
    management.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: Creating parallel streams
  id: totrans-355
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To make a stream a parallel stream is very straightforward. We have two options:
    we can use the `parallelStream()` method from the `Collection` API or the `parallel()`
    intermediate operation from the `Stream` API.'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are examples of both methods:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Let us look at an example contrasting a sequential stream with a parallel stream
    to show how easy it is to create a parallel stream. *Figure 16**.18* is the code
    (`ParalledStreams.java` in the repo):'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.18 - Creating a parallel stream](img/B19793_16_18.jpg)'
  id: totrans-360
  prefs: []
  type: TYPE_IMG
- en: Figure 16.18 - Creating a parallel stream
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us examine the sequential stream first:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: We initially generate a stream of `Stream<Integer>`. The second line uses the
    `mapToInt()` function to map the `Stream<Integer>` to an `IntStream`. In other
    words, map from a stream of `Integer` objects to a stream of `int` primitives.
    This is so we can use the `sum()` method in `IntStream`. The result, 210 is then
    output.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: 'The parallel version is:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The only difference is the call to `parallel()` on the second line. This is
    a `Stream` method. This is abstraction at its finest! The data partitioning and
    thread management are handled by the API and the JVM.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: Parallel decomposition
  id: totrans-368
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Creating parallel streams is the easy part. Things get interesting when performing
    *parallel decomposition* - where a task is broken down (decomposed) into smaller
    tasks that are executed concurrently, and their results assembled afterwards.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: With serial streams, results are ordered and therefore predictable. With parallel
    streams and parallel decomposition, this is not the case, as order is not guaranteed
    and therefore, results are unpredictable. This is because the threads take the
    subtasks in any order and return the results in any order.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us look at a simple code example demonstrating this. *Figure 16**.19* presents
    the code (`ParalledStreams.java`):'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.19 - Ordering in serial streams and lack of ordering in parallel
    streams](img/B19793_16_19.jpg)'
  id: totrans-372
  prefs: []
  type: TYPE_IMG
- en: Figure 16.19 - Ordering in serial streams and lack of ordering in parallel streams
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: 'This figure presents a `dbAction()` method that mimics a database action by
    sleeping the thread for 1 second. When the `orderedSerialStreams()` method executes,
    the output is predictable:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The integers are ordered as per the source and the operation took `5 seconds`,
    `1 second` for each value.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: 'The `unorderedParallelStreams()` method is the same as the serial version except
    that we are now creating a parallel stream. Let us examine its output:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'One can see the obvious performance benefit of parallel processing: 1 second
    versus 5 seconds. Note that this performance gain depends on the number of CPUs
    available - if this code is run on a machine with fewer processors, the gain would
    be less.'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: However, the output is now unordered as both `map()` and `forEach()` are applied
    concurrently. Instead of `forEach()`, we could use the `forEachOrdered()` terminal
    operation. This operation ensures the consumer is applied to the elements in their
    *encounter order* as they left the source. In our example, this would be `10`,
    `20`, `30`, `40`, and `50`. *Figure 16**.20* shows it in code (`ParalledStreams.java`).
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.20 - The forEachOrdered() method](img/B19793_16_20.jpg)'
  id: totrans-381
  prefs: []
  type: TYPE_IMG
- en: Figure 16.20 - The forEachOrdered() method
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: 'In this figure, the terminal operation is no longer `forEach()` but is `forEachOrdered()`.
    The output from this figure is as follows:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Now the integers are ordered and the performance gain is still significant due
    to `map()` being applied concurrently.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: Parallel reductions using reduce()
  id: totrans-386
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As order is not guaranteed with parallel streams, the results of parallel reductions
    can be unexpected. A reduction combines a stream into a single result. Recall
    that the overloaded `reduce()` operation accepted three parameters: an identity,
    an accumulator and a combiner. The combiner function is used in a parallel environment
    for combining the accumulator results. What the following examples are going to
    demonstrate is that the *accumulator and combiner must work regardless of the
    order in which they are executed*. They must be associative.'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: Associativity
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: 'An operator or function is considered associative if the following holds:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: '`(a op b) op c)` == `a op (b` `op c)`.'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, addition is associative:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: '`(2 + 3) + 4` == `2 + (3 + 4)` == `9`'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: 'However, subtraction is not associative:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: '`(2 - 3) - 4` == `-5` whereas `2 - (3 - 4)` == `3`'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: 'This is really important in parallel processing. For example:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: '`a op b op c op d` == `(a op b) op (c` `op d)`'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: If `op` is associative then `(a op b)` and `(c op d)` can be evaluated in parallel;
    and `op` then performed on the results.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us first examine a serial reduction:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: As this is a serial reduction, there is no need for a combiner. The result is
    -15\. Let us now examine the parallel version to see do we get the same result.
    *Figure 16**.21* represents the code (ParallelStreams.java).
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.21 - A parallel reduction using reduce()](img/B19793_16_21.jpg)'
  id: totrans-401
  prefs: []
  type: TYPE_IMG
- en: Figure 16.21 - A parallel reduction using reduce()
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: 'In this figure, we have expanded both the accumulator and the combiner to show
    the values as they appear:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The output is as follows (with the combiner subtask values tabbed in):'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Notice that the final result is `5`, which is incorrect. This is because subtraction
    is not associative. Interestingly, in the parallel process the identity is applied
    to multiple elements in the stream, giving us unexpected results.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: Parallel reductions using collect()
  id: totrans-408
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `collect()` method, like `reduce()` has a three-argument version, which
    accepts an accumulator and a combiner. For the first argument, rather than an
    identity, `collect()` uses a `Supplier`. The same rule applies here too - the
    accumulator and combiner operations must be able to perform in any order.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: One should use a concurrent collection, in order to avoid concurrent threads
    causing `ConcurrentModificationException`s. Another consideration is the target
    collection - if it is ordered (a `List` for example), then the background processing
    required to maintain that order may reduce performance. *Figure 16**.22* presents
    an example of a concurrent collection, namely `ConcurrentMap` in code (`ParallelStreams.java`).
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.22 - collect() returning a concurrent collection](img/B19793_16_22.jpg)'
  id: totrans-411
  prefs: []
  type: TYPE_IMG
- en: Figure 16.22 - collect() returning a concurrent collection
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: 'The output from the code is:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Therefore, the `ConcurrentMap` implementation here is a `ConcurrentHashMap`.
    This is not guaranteed but some implementation of the `ConcurrentMap` interface
    is guaranteed.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: 'The key in our map is the first letter in the name:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The value associated with the key is the name itself:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'If more than one name starts with the same letter, the names are appended,
    with a comma between the names:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: That completes our discussion on parallel streams and indeed concludes [*Chapter
    16*](B19793_16.xhtml#_idTextAnchor401)*.* Let us now put that knowledge into practice
    to reinforce the concepts.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  id: totrans-423
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To keep the park running smoothly, we need to keep track of the health of all
    dinosaurs. We need to identify any ill dinosaurs. Using a stream of `Dinosaur`
    objects, filter out dinosaurs that are ill (assuming the `isIll()` method exists
    the in `Dinosaur` class), map them to their names, and collect the results in
    a list. Lastly, print out this list of names of the dinosaurs that need immediate
    attention.
  id: totrans-424
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Managing a dinosaur park of this size involves handling large amounts of data.
    To make an announcement in the park about dinosaur feeding times, create a list
    of dinosaurs, convert it into a stream, and use the `map()` function to get a
    list of dinosaur names. Then, use the `forEach` terminal operation to print out
    a message for each dinosaur’s feeding time.
  id: totrans-425
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Keeping track of the total food required for all the dinosaurs can be tricky.
    Suppose you have an array of weights of all dinosaurs. Convert it into an `IntStream`
    and use the `sum` method to get the total weight of all dinosaurs in the park.
    This could help you estimate the total food requirements.
  id: totrans-426
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When dealing with data about dinosaurs or employees, we may encounter null references.
    To avoid a `NullPointerException` error, use `Optional` when retrieving a dinosaur
    by its name from a map of dinosaurs. If a dinosaur with the provided name doesn’t
    exist, `Optional` should return a message indicating the dinosaur hasn’t been
    found.
  id: totrans-427
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Calculating the average weight of dinosaurs can be a time-consuming operation,
    especially when dealing with a large number of dinosaurs. To speed up the process,
    use parallel streams. Convert a list of dinosaur weights into a parallel stream
    and use the average method to calculate the average weight.
  id: totrans-428
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Project – dynamic dinosaur care system
  id: totrans-429
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Integrate the Stream API into your dinosaur care system to process large volumes
    of dinosaur data, such as health records, feeding schedules, and so on. The system
    should also incorporate `Optional` and parallel streams where appropriate, optimizing
    data processing and minimizing potential null pointer exceptions.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the steps to get you there:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
- en: '`Dinosaur` class with properties such as `name`, `species`, `healthStatus`,
    and so on. There should also be a `DinosaurCareSystem` class for implementing
    the main functionalities.'
  id: totrans-432
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Stream` from the list of records and use the `filter` method to get these
    records. Here’s an example: `List<HealthRecord> criticalRecords = records.stream().filter(r
    -> r.getHealthStatus() <` `CRITICAL_THRESHOLD).collect(Collectors.toList())`.'
  id: totrans-433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Stream` to filter the schedules. Here’s an example: `List<FeedingSchedule>
    morningFeeds = schedules.stream().filter(s ->` `s.getTime().isBefore(LocalTime.NOON)).collect(Collectors.toList())`.'
  id: totrans-434
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`NullPointerException``Optional` to avoid a `NullPointerException` error. Here’s
    an example: `Optional.ofNullable(dinosaur.getTrainer()).map(Trainer::getName).orElse("No`
    `trainer assigned").`'
  id: totrans-435
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`stream()` with `parallelStream()` in the previous examples. Be aware, though,
    that not every problem is suitable for parallel processing. If the tasks have
    dependencies or need to be processed in a specific order, stick with regular streams.'
  id: totrans-436
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  id: totrans-437
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we explored advanced streaming concepts. We started by exploring
    intermediate operations, which are powerful, as they transform the stream into
    another stream. Popular intermediate operations are: `filter()`, `distinct()`,
    `limit()`, `map()`, `flatMap()`, and `sorted()`. Some of these are known as *stateful*
    as they need to maintain some state to operate effectively. Examples are `limit()`
    and `sorted()`. The `limit()` method is also *short-circuiting* as it can cause
    the pipeline to shut down even if there is more data available in the source.'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
- en: We then examined the primitive stream types in the API, namely `IntStream`,
    `LongStream` and `DoubleStream`. These types have some very useful methods for
    operating on numeric types, such as `sum()` and `average()`. We also explained
    the patterns behind the names of the new primitive stream functional interfaces
    and their functional methods.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
- en: We can create streams by mapping from another stream. There are many methods
    to do this but they follow a pattern in their naming. We examined these and explained
    the patterns.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
- en: '`Optional`s are boxes that may or may not be empty. They are mainly used as
    a method return type where there is a real need to represent “no result”. Rather
    than returning `null` (with its pitfalls), we can return an empty `Optional`.
    We can create `Optional`s using `Optional.of`, `Optional.empty()` and `Optional.ofNullable()`.
    The `Optional` API supports functional-style programming; for example, `ifPresent()`
    lets us state clearly what we want without the need for an `else` statement. We
    also examined the primitive `Optional`s, namely `OptionalInt`, `OptionalLong`
    and `OptionalDouble`.'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we looked at parallel streams, which can be easily created using the
    `Collection` API method `parallelStream()` or the `Stream` API method `parallel()`.
    While serial streams are ordered, parallel streams are not. This is due to parallel
    decomposition where tasks are broken down and re-assembled later. In a parallel
    multi-threaded environment, threads can take sub-tasks in any order and return
    the results in any order. This is fine for an associative task such as addition
    but not suitable for subtraction.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
- en: If you are using the parallel reduction methods `reduce()` and `collect()`,
    ensure that the accumulator and combiner functions are associative; as they must
    work correctly regardless of the order they are executed in.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
- en: That completes our discussion on streams. The next chapter, Concurrency will
    further solidify the last section here on parallel streams.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
