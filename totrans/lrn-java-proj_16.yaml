- en: '16'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Streams: Advanced Concepts'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 15*](B19793_15.xhtml#_idTextAnchor377), we learned about the fundamentals
    of streams. We started by discussing what a stream pipeline is by using an analogy
    of an assembly line. We saw that items only make their way onto the assembly line
    as and when needed. This is the principle of lazy evaluation. In this analogy,
    there are several operators that operate on the data (pencils) under the supervision
    of a supervisor (Java). The supervisor will not allow any work to start until
    the terminal operation in place. As Java is now aware of the full pipeline, efficiencies
    can be introduced. Once a pencil has passed an operator, the operator cannot get
    that pencil back. Thus, streams are different to arrays or `Collection`s in that
    manner. The pencils can be processed by as many operators as necessary but only
    one operator is the terminal operation. The other operators represent intermediate
    operations (a topic in this chapter).
  prefs: []
  type: TYPE_NORMAL
- en: 'We examined how to create streams. Streams can be created from various sources:
    arrays, collections, files, and varargs. We created both finite and infinite streams.
    Infinite streams are created using `Stream.generate()` and `Stream.iterate()`.'
  prefs: []
  type: TYPE_NORMAL
- en: We took a deep dive into terminal operations. Nothing happens until a terminal
    operation executes and once executed the stream is considered closed and must
    be re-streamed if you want to use it again. A reduction is an operation that examines
    all of the stream and produces a single output (primitive or `Object`). One of
    the terminal operations is the overloaded `reduce()` method which performs reductions
    on the stream. The `collect()` terminal operation is extremely useful for extracting
    data out of the stream (into a `Map` for example) for later use.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will continue our coverage of streams. We will, with the
    aid of code examples, examine intermediate operations. Following that, we will
    discuss primitive streams and how to map streams. We will also discuss `Optional`s
    and lastly, we will finish with parallel streams.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Examining intermediate operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Delving into primitive streams
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mapping streams
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explaining `Optional`s
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding parallel streams
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code for this chapter can be found on GitHub at [https://github.com/PacktPublishing/Learn-Java-with-Projects/tree/main/ch16](https://github.com/PacktPublishing/Learn-Java-with-Projects/tree/main/ch16).
  prefs: []
  type: TYPE_NORMAL
- en: Examining intermediate operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we know, a stream pipeline consists of a source, followed by zero or more
    intermediate operations, followed by a terminal operation. While the terminal
    operation is mandatory, intermediate operations are not. That said, intermediate
    operations are where pipelines get their real power as they transform the stream
    data as it flows by. Unlike terminal operations, intermediate operations produce
    a stream as a result. Let us start with `filter()`, which is taken from IntermediateOperations.java
    on the repo:'
  prefs: []
  type: TYPE_NORMAL
- en: filter(Predicate)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `filter()` operation returns a stream containing the elements matching
    the given predicate. *Figure 16**.1* presents a code example (from `IntermediateOperations.java`
    on the repo):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.1 - The filter(Predicate) intermediate operation in code](img/B19793_16_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.1 - The filter(Predicate) intermediate operation in code
  prefs: []
  type: TYPE_NORMAL
- en: In this figure, the countries whose names are longer than 5 characters are output.
  prefs: []
  type: TYPE_NORMAL
- en: distinct()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `distinct()` operation returns a stream with duplicate elements removed.
    Internally, `distinct()` uses the `equals()` method from `Object` when comparing.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is a *stateful* intermediate operation which means it needs to keep some
    state to operate effectively. This state enables `distinct()` to operate as follows:
    if this is the first time `distinct()` has seen this object, it passes it on but
    remembers it; if `distinct()` has already seen this object, it filters it out.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 16**.2* presents a code example (from `IntermediateOperations.java`
    on the repo):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.2 - The distinct() intermediate operation in code](img/B19793_16_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.2 - The distinct() intermediate operation in code
  prefs: []
  type: TYPE_NORMAL
- en: In this figure, we are streaming a list of strings, where `"eagle"` is duplicated.
    We are using the very useful `Stream<T> peek(Consumer)` intermediate operation.
    This `peek()` operation executes the consumer on the data as it passes by. This
    is a great help as it enables us to view the data flowing by. The `distinct()`
    operation is in our pipeline and the `forEach()` terminal operation starts the
    streaming.
  prefs: []
  type: TYPE_NORMAL
- en: 'When run, this code generates the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The first `"eagle"` is streamed into the pipeline, where `peek()` echoes it
    to the screen, with the decoration `"Before: "`. Then `peek()` passes `"eagle"`
    on to `distinct()`. As this is the first time `distinct()` has seen `"eagle"`,
    it passes it on but remembers it. Lastly, `forEach()` takes `"eagle"` and outputs
    it prepended with the string `", After:"`, followed by a newline.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now the second `"eagle"` is streamed. The `peek()` operation outputs the details
    and passes `"eagle"` on. However, `distinct()` remembers that it has seen this
    element already and filters it out. This is why `", After: eagle"` appears only
    once in the output.'
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, `"EAGLE"` is streamed. This proceeds just as the first `"``eagle"` did.
  prefs: []
  type: TYPE_NORMAL
- en: limit(long)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `limit()` operation is a short-circuiting, stateful intermediate operation.
    We saw its short-circuiting nature put into good effect by transforming an infinite
    stream into a finite stream in [*Chapter 15*](B19793_15.xhtml#_idTextAnchor377)*.*
    Obviously, it needs to maintain some state in order to keep a count of the elements
    that have passed by. *Figure 16**.3* presents a code example (`IntermediateOperations.java`):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.3 - The limit(long) intermediate operation in code](img/B19793_16_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.3 - The limit(long) intermediate operation in code
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we are streaming a list of numbers. This example is a good
    example of lazy evaluation. The output is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Let us examine what happens here.
  prefs: []
  type: TYPE_NORMAL
- en: 11 is streamed, first `peek()` outputs it prepended with `"A - "` and passes
    it to `filter()` where it fails (as 11 is not > 40)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 22 is streamed and behaves just as 11 did
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 33 is streamed and operates in a similar fashion to 11 and 22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 44 is streamed, passes the filter, hence `"B - 44"` is output; 44 is passed
    to `limit()` which records that this is the first element it has seen, before
    passing it on; `forEach()` outputs 44 prepended with `"C - "`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 55 is streamed and operates as 44 except that `limit()` informs Java that this
    is the second element it has passed and the limit is 2\. Java lets `forEach()`
    finish and the stream is closed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that the first `peek()` never outputs `"A - 66"`, `"A - 77"`, `"A - 88"`,
    or `"A - 99"`. Therefore, 66, 77, 88, and 99 are never streamed - as they are
    not needed. This is another example of lazy evaluation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now let us look at `map()`.
  prefs: []
  type: TYPE_NORMAL
- en: map(Function)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `Stream<R> map(Function<T, R>)` operation is for transforming data. It
    creates a one-to-one mapping between elements in the stream and elements in the
    new stream returned. *Figure 16**.4* presents a code example (`IntermediateOperations.java`):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.4 - The map(Function) intermediate operation in code](img/B19793_16_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.4 - The map(Function) intermediate operation in code
  prefs: []
  type: TYPE_NORMAL
- en: 'The `map()` operation takes in a `Function` which, takes in one type and returns
    another, possibly different type. In this example, the lambda used, takes in a
    `String` namely `s`, and returns the `Integer` length of that `String`. The `forEach()`
    outputs the lengths of the `String`s streamed: `"book"` is `4`, `"pen"` is `3`
    and `"ruler"` is `5`.'
  prefs: []
  type: TYPE_NORMAL
- en: flatMap(Function)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `flatMap()` operation “flattens” a stream. In other words, multiple collections/arrays
    are merged into one. For example, if we were streaming `List<String>` elements,
    they would be flattened into a stream of `String`s, which “removes” or hides each
    individual `List`. This is helpful when combining lists or for removing empty
    elements (which `flatMap()` also does). *Figure 16**.5* presents a code example
    (`IntermediateOperations.java`):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.5 - The flatMap(Function) intermediate operation in code](img/B19793_16_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.5 - The flatMap(Function) intermediate operation in code
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we are going to contrast two streams - one with `flatMap()`
    and the other without `flatMap()`. Let us start with the non-`flatMap()` stream.
  prefs: []
  type: TYPE_NORMAL
- en: 'Firstly, we create the lists, the first of which is an empty list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We then stream the three lists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We then stream and output our `streamOfLists` using `forEach()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This outputs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Note that each element is a list (reflected by the square brackets `[ ]`) and
    that the empty list is present.
  prefs: []
  type: TYPE_NORMAL
- en: 'As the stream has been processed by a terminal operation (`forEach()`), the
    stream is closed. To avoid an exception, we must re-stream the source. This is
    what we do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This second pipeline contains the `flatMap()` operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The signature for `flatMap()` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Therefore, `flatMap()` takes in a `Function`. The function input `T`, is a `List<String>`
    and the function output `R`, is a `Stream<String>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using `forEach()` again to both start off the streaming and output the elements
    in the stream, we get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Note that they are all just `Strings` (no `List`s) and that the empty element
    has been removed. The `String` elements that were in the `List`s are now top-level
    elements in the stream. This is the flattening process explained earlier.
  prefs: []
  type: TYPE_NORMAL
- en: sorted() and sorted(Comparator)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The overloaded `sorted()` operation returns a stream with the elements sorted.
    Just like sorting arrays, Java uses natural ordering unless we provide a `Comparator`.
    For example, natural ordering for numbers is ascending numeric order; natural
    ordering for `String`s is alphabetic. This operation is a stateful intermediate
    operation which means that `sorted()` needs to see all of the data before it can
    sort it. Both sorted examples are based on IntermediateOperations.java in the
    repo. *Figure 16**.6* presents a code example of `sorted(Comparator)`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.6 - The sorted(Comparator) intermediate operation in code](img/B19793_16_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.6 - The sorted(Comparator) intermediate operation in code
  prefs: []
  type: TYPE_NORMAL
- en: In this example, assume the existence of a `Person` class that has both `String`
    `name` and `Integer` `age` instance variables. We start by streaming the `Person`
    objects; `"Mary"` is first, age 25 and `"John"` is second, age `23`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `sorted(Comparator)` line is interesting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `Comparator.comparing(Function keyExtractor)` static method is a very useful
    way of generating a `Comparator`. It accepts in a `Function` that extracts a `Comparable`
    sort key - as in, a key whose type implements the `Comparable` interface. In this
    example, the `Function` input is a `Person` and the `Function` return is an `Integer`
    (the age of the person). As `Integer` implements `Comparable`, this is fine. The
    method then returns a `Comparator` that compares by that sort key. This pipeline
    is short and does not clearly demonstrate the stateful nature of `sorted()`. The
    next example will do that.
  prefs: []
  type: TYPE_NORMAL
- en: When we output the stream, `"John"` comes out first and `"Mary"` second (the
    reverse of the order in which they were streamed). This is because we are sorting
    by `age` and `"John"`, at `23`, is younger than `"Mary"`, who is `25`.
  prefs: []
  type: TYPE_NORMAL
- en: Now let us look at another `sorted()` example. This one will demonstrate the
    stateful nature of `sorted()` and at the same time, highlight lazy evaluation.
    *Figure 16**.7* presents the code.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.7 - The stateful nature of sorted()](img/B19793_16_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.7 - The stateful nature of sorted()
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we are streaming a list of `String`s (names). Names that are
    of length `3` pass the filter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `sorted()` operation is stateful - it needs to see *all* of the data before
    it can sort that data. We also have a `limit(2)` operation which is both stateful
    and short-circuiting. It will short-circuit after 2 names have passed by. Lastly,
    the terminal operation `forEach()` starts off the streaming process and outputs
    the names as they arrive.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Let us examine what happens here. Note that the comments on the right of the
    pipeline (lines 49-55) indicate what stage each name gets to.
  prefs: []
  type: TYPE_NORMAL
- en: '`"Tim"` is streamed and passes the filter. `"Tim"` makes its way to `sorted()`
    where it is stored. Java tells `sorted()` that there is more data to be streamed
    and not to sort yet. This results in `"0\. Tim 1\. Tim"` in the output.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"Jim"` is streamed next and behaves exactly as `"Tim"`, with `sorted()` keeping
    a record that it will have to sort both `"Tim"` and `"Jim"`. Again, Java tells
    `sorted()` that there is more data to come and not to sort yet. Thus, we have
    `"0\. Jim 1\. Jim"` in the output.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"Peter"` is then streamed but fails the filter (just `"0\. Peter"` and no
    `"1\. Peter"` in the output).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"Ann"` is streamed next and behaves exactly as `"Tim"` and `"Jim"`, with `sorted()`
    keeping a record that it will have to sort `"Tim"`, `"Jim"`, and `"Ann"`. Again,
    Java tells `sorted()` not to sort yet. Thus, we have in `"0\. Ann 1\. Ann"` in
    the output.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"Mary"` is the last name to be streamed. `"Mary"` fails the filter also (just
    “`0\. Mary`” and no `"1\. Mary"` in the output).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As the stream is now empty, Java tells `sorted()` that it can sort the data.
    The sorted names are `"Ann"`, `"Jim"`, and `"Tim"`. So `"Ann"` now makes its way
    out of `sorted()` and onto the next stage of the stream pipeline.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `peek()` after `sorted()` outputs `"2\. Ann"` showing `"Ann"` got here.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `limit()` operation passes “Ann” on but records that it has handled one
    name.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The terminal operation `forEach()` which kick-started the whole streaming process,
    outputs `"3\. Ann"` to show that `"Ann"` got as far as here.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"Jim"` now makes its way out of `sorted()`. `"Jim"` is peeked (`"2\. Jim"`)
    and passes through `limit()`. However, `limit()` short-circuits as this is the
    second name it has handled. Java is informed of this fact.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `forEach()` operation is allowed to finish outputting `"``3\. Jim"`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that `"Tim"` never gets out of `sorted()` and into the last `peek()` -
    there is no `"2\. Tim"` in the output.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That completes this section on intermediate operations. Let us now examine primitive
    streams.
  prefs: []
  type: TYPE_NORMAL
- en: Delving into primitive streams
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Thus far, all our streams have been for `Object` types. For example, a `Stream<Integer>`
    caters for the wrapper class `Integer`. Java also has classes specifically tailored
    for streams of primitives. For example, assuming a stream of `int` primitives,
    rather than `Stream<Integer>`, we use `IntStream`. As we shall see shortly, primitive
    streams have some really useful methods for processing numeric data, such as `sum()`
    and `average()`.
  prefs: []
  type: TYPE_NORMAL
- en: '*Table 16.1* introduces the primitive stream classes.'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Wrapper stream** | **Primitive stream** | **Primitives** **catered for**
    |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `Stream<Integer>` | `IntStream` | `int, short,` `byte, char` |'
  prefs: []
  type: TYPE_TB
- en: '| `Stream<Double>` | `DoubleStream` | `double, float` |'
  prefs: []
  type: TYPE_TB
- en: '| `Stream<Long>` | `LongStream` | `long` |'
  prefs: []
  type: TYPE_TB
- en: Table 16.1 - Primitive stream classes
  prefs: []
  type: TYPE_NORMAL
- en: In this table, the first column lists the wrapper type streams; the second column
    lists the corresponding primitive stream and the last column, enumerates the primitives
    catered for by the primitive stream from column two.
  prefs: []
  type: TYPE_NORMAL
- en: Let us examine how to create primitive streams.
  prefs: []
  type: TYPE_NORMAL
- en: Creating primitive streams
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As with creating `Object` streams, we can easily create primitive streams as
    well. *Figure 16**.8* presents sample code creating primitive streams (based on
    code from PrimitiveStreams.java in the repo).
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.8 - Creating primitive streams](img/B19793_16_8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.8 - Creating primitive streams
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we create arrays of differing primitive types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the overloaded `Arrays.stream()` method, we create an `IntStream`, `DoubleStream`
    and `LongStream` respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: For example, the `Arrays.stream(ia)` takes in an `int[]` and returns an `IntStream`
    with the specified array as its source.
  prefs: []
  type: TYPE_NORMAL
- en: 'We then execute the `count()` terminal operation on each of the streams. Each
    returns `3` as there are `3` primitives in each array source:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The `of()` method should look familiar from how we created a regular stream
    using the `Stream` class. There is an equivalent method in `IntStream`, `DoubleStream`
    and `LongStream`. The values in the streams are specified in the varargs arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, we execute the `count()` terminal operation on each of the streams.
    As before, `3` is returned each time, as there are `3` primitives in each of the
    streams:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We can of course create infinite streams of primitives. *Figure 16**.9*, from
    PrimitiveStreams.java in the repo, shows them being used and their equivalent
    names in the `Stream` class are familiar, namely `generate()` and `iterate()`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.9 - Infinite primitive streams](img/B19793_16_9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.9 - Infinite primitive streams
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we start out with the following two lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The `DoubleStream.generate(DoubleSupplier)` method has equivalent versions in
    `IntStream` and `LongStream`. Its parameter `DoubleSupplier` is a functional interface
    where it produces a `double`. Thus, it is a `double` primitive version of `Supplier<T>`.
    Its functional method `double getAsDouble()` reinforces this fact. We use `limit(5)`
    to limit the infinite flow of numbers to `5` and each is output by the terminal
    operation `forEach()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We follow that with the next two lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The `IntStream.iterate()` method has equivalent versions in `DoubleStream` and
    `LongStream`. It takes two arguments, an `int` seed (the starting value) and an
    `IntUnaryOperator` function. This `IntUnaryOperator` function takes in an `int`
    and returns an `int`. It is the `int` primitive specialization of `UnaryOperator<T>`.
    The stream of numbers generated are even numbers, starting at `2`. As the sequence
    of numbers is infinite, we apply a limit of 5 numbers (`2`, `4`, `6`, `8`, `10`).
  prefs: []
  type: TYPE_NORMAL
- en: Let us now examine common primitive stream methods.
  prefs: []
  type: TYPE_NORMAL
- en: Common primitive stream methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The methods just presented, namely `of()`, `generate()` and `iterate()` are
    common to `Stream<T>` as well. *Table 16.2* presents commonly used methods that
    are unique to primitive streams.
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 16.2 - Common primitive stream methods](img/B19793_16_Table_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Table 16.2 - Common primitive stream methods
  prefs: []
  type: TYPE_NORMAL
- en: 'This table has two columns: the name of the method (including its return type)
    and the primitive streams. Each of the methods listed are reductions and terminal
    operations. Recall that a reduction produces a single summary result by repeatedly
    applying an operation to a sequence of input results. We saw the general form
    of reductions with the `reduce()` and `collect()` methods in the `Stream<T>` interface.
    The reductions in this table are specialized for primitives.'
  prefs: []
  type: TYPE_NORMAL
- en: Let us first examine the `sum()` method. Notice that it does not return an `Optional`
    whereas all the other methods do. This is because `0` is a valid value to return
    for the sum of an empty stream. In other words, if the stream is empty when you
    execute `sum()` - perhaps all of the data has been filtered out - then `0` is
    a valid return. The other methods in the table, however, would need to return
    an empty `Optional` in that scenario. The `IntStream` for `sum()` returns an `int`,
    the version in `LongStream` returns a `long` and the version in `DoubleStream`
    returns a `double`.
  prefs: []
  type: TYPE_NORMAL
- en: Regarding `min()` and `max()`, both `IntStream` versions return an `OptionalInt`;
    both `LongStream` versions return an `OptionalLong` and both `DoubleStream` versions
    return an `OptionalDouble`.
  prefs: []
  type: TYPE_NORMAL
- en: The `average()` method is a little different because of the possibility of decimal
    places regardless of the type being totaled. So all three primitive stream types,
    namely `IntStream`, `LongStream`, and `DoubleStream` return an `OptionalDouble`.
  prefs: []
  type: TYPE_NORMAL
- en: Let us examine them in code (PrimitiveStreams.java in the repo). Firstly, *Figure
    16**.10* presents `min()`, `max()` and `average()`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.10 – The min(), max() and average() operations in code](img/B19793_16_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.10 – The min(), max() and average() operations in code
  prefs: []
  type: TYPE_NORMAL
- en: 'In this figure, we start with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Firstly, we create a stream of `int` primitives. We then execute the terminal
    operation `max()`, which starts the stream and calculates the maximum number in
    the stream, which is 30\. No need for any `Comparator` or accumulator here! We
    then use the `ifPresent(IntConsumer)` from `OptionalInt` (there are equivalents
    for `OptionalDouble` and `OptionalLong`). What this method means, is that, if
    there is a value *present* in the `OptionalInt`, output it. If the optional is
    empty, nothing is printed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next code segment of interest is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'In this code segment, we create a `DoubleStream` based on the values provided
    in the varargs argument. Using `min()`, we stream the values and calculate the
    minimum value. The `orElseThrow()` method means: if there is a value present,
    return that value; otherwise throw a `NoSuchElementException`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The last code segment is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we create a `LongStream` based on the values provided in the varargs
    argument. This is followed by executing `average()`, which both streams the values
    and calculates their average. The `orElseGet(DoubleSupplier)` method means: if
    there is a value present, return that value; otherwise return the value from the
    supplying function (a random number).'
  prefs: []
  type: TYPE_NORMAL
- en: Let us now examine `sum()`. It is easy to see why primitive streams are useful
    in the next example, *Figure 16**.11*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.11 - The sum() primitive operation](img/B19793_16_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.11 - The sum() primitive operation
  prefs: []
  type: TYPE_NORMAL
- en: 'In this figure, we start out with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This code creates an `int` primitive stream directly using the `IntStream.of()`
    method and uses the `sum()` terminal method to stream the numbers and return the
    sum, which is 9.
  prefs: []
  type: TYPE_NORMAL
- en: 'The rest of the example code, contrasts `reduce()` from `Stream<T>` and `sum()`
    from `IntStream`. Let us focus on `reduce()` first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Initially, we stream a list of `Integer`s into a `Stream<Integer>` and them
    sum them up by passing an accumulator function argument to `reduce()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we will focus on how to do the same thing using `sum()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Firstly, we stream the same numbers as a `Stream<Integer>` again - we do not
    have a stream of primitives at this point. The second line shows how easy it is
    to convert from a `Stream<Integer>` to a `Stream` of `int` primitives. Using the
    `Stream` interfaces `mapToInt()` function; we pass in our function, which takes
    in an `Integer` and returns the `int` primitive wrapped by that `Integer`. In
    this code, we are availing of auto-unboxing by simply specifying the identifier
    `n` on both sides of the arrow token in the lambda. Now that we have an `IntStream`
    object we can use the `sum()` method - which streams the integers and returns
    the sum of 6\. Note that we have deliberately left the return types visible in
    the code. This helps explain what is happening in the pipeline. In reality, you
    would code it much more concisely as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: With each of the primitive streams, you can get summarizing statistics (summary
    data about the elements in the stream). Let us look at these in action. *Figure
    16**.12* presents `IntSummaryStatistics`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.12 - IntSummaryStatistics in code](img/B19793_16_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.12 - IntSummaryStatistics in code
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, the streams are being passed in via the following method calls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The first invocation passes in a valid stream of integers whereas the second
    stream is empty. Once inside the `stats()` method, the terminal operation `summaryStatistics()`
    is executed on the `IntStream` passed in. The resultant `IntSummaryStatistics`
    object is now available to inspect for summary data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The output for the first stream (5, 10, 15 and 20) is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '`5` is output by `getMin()`; `20` is output by `getMax()`; `12.5` is output
    by `getAverage()`; `4` is output by `getCount()` and `50` is output by `getSum()`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The output for the empty stream is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '`2147483647` (which is `Integer.MAX_VALUE`) is output by `getMin()`; `-2147483648`
    (`Integer.MIN_VALUE`) is output by `getMax()`; 0.0 is output by `getAverage()`;
    0 is output by `getCount()` and 0 is output by `getSum()`.'
  prefs: []
  type: TYPE_NORMAL
- en: With primitive streams there are now extra functional interfaces that we need
    to be aware of.
  prefs: []
  type: TYPE_NORMAL
- en: New primitive stream interfaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are many new functional interfaces to be aware of. Thankfully, they follow
    a consistent naming pattern. *Table 16.3* outlines the more common ones. For further
    details please see the JavaDocs at: [https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/function/package-summary.html](https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/function/package-summary.html).'
  prefs: []
  type: TYPE_NORMAL
- en: '![Tables 16.3 (a) and (b) - New primitive stream functional interfaces](img/B19793_16_Table_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Tables 16.3 (a) and (b) - New primitive stream functional interfaces
  prefs: []
  type: TYPE_NORMAL
- en: In this figure, table A is on the left, with table B on the right. Each table
    has two columns - one for the functional interface name and one for its functional
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have deliberately included the generically marked functional interfaces
    encountered earlier. This is to help contrast them with their primitive counterparts.
    The previous functional interfaces that we came across are: `Supplier<T>,` `Consumer<T>`,
    `BiConsumer<T, U>`, `Predicate<T>`, `BiPredicate<T, U>`, `Function<T, R>`, `BiFunction<T,
    U, R>`, `UnaryOperator<T>` and `BinaryOperator<T>`. Note the generic types in
    them all. Very few primitive functional interfaces use generics, as they are typed
    for a particular primitive.'
  prefs: []
  type: TYPE_NORMAL
- en: We have color-coordinated the interfaces in order to group them. So for example,
    in table A the yellow colored interfaces are the suppliers. `Supplier<T>` with
    its `T get()` functional method - as stated, this is included for comparison purposes.
    `DoubleSupplier` is the interface for generating `double` primitives. Its functional
    method is `getAsDouble()` and its return type is a `double`. The `IntSupplier`
    and `LongSupplier` interfaces follow the same pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'Still in table A, the consumers are next, in green. `DoubleConsumer` “accepts”
    a `double` primitive and returns nothing. `IntConsumer` accepts in an `int`, returns
    nothing; and `LongConsumer` accepts in a `long`, returns nothing. All the functional
    methods are called `accept()`. Note the pattern for naming: suppliers use `DoubleSupplier`;
    consumers use `DoubleConsumer`.'
  prefs: []
  type: TYPE_NORMAL
- en: This naming convention continues with the predicates (blue). We have `DoublePredicate`
    that “tests” a `double` and returns a `boolean`. `IntPredicate` and `LongPredicate`
    behave in a similar manner - a primitive type parameter and a return type `boolean`.
    All the functional methods are called `test()`.
  prefs: []
  type: TYPE_NORMAL
- en: In table B, we have the functions, in yellow. We have `DoubleFunction<R>` that
    “applies” a `double` and returns the type `R`. The functions are a case where
    generics are used to represent the type being returned. However, the primitive
    being applied is the important aspect here. `IntFunction<R>` and `LongFunction<R>`
    behave in a similar manner - a primitive type parameter and a return type `R`.
    All the functional methods are called `apply()`.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, in table B, we have the primitive versions of `UnaryOperator<T>` and
    `BinaryOperator<T>`. The `double` primitive version of `UnaryOperator<T>` is `DoubleUnaryOperator`
    (note the word `Double` at the start again). Recall that unary functions are functions
    that accept in one parameter and return a value; where both types are the same.
    Therefore, `DoubleUnaryOperator` has a `double` parameter and a `double` return
    type. `IntUnaryOperator` and `LongUnaryOperator` follow the same pattern.
  prefs: []
  type: TYPE_NORMAL
- en: The `DoubleBinaryOperator`, `IntBinaryOperator` and `LongBinaryOperator` interfaces
    only differ from their unary counterparts in the number of parameters they take
    in. Therefore, `DoubleBinaryOperator` takes in two `double`s, `IntBinaryOperator`
    takes in two `int`s and `LongBinaryOperator` takes in two `long`s.
  prefs: []
  type: TYPE_NORMAL
- en: There are other ways to create streams and that is by mapping from other streams.
    Let us examine that now.
  prefs: []
  type: TYPE_NORMAL
- en: Mapping streams
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Again, there are many new functional interfaces to be aware of; and again, thankfully,
    they follow a consistent naming pattern. *Table 16.4* outlines the more common
    ones.
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 16.4 - Mapping streams](img/B19793_16_Table_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Table 16.4 - Mapping streams
  prefs: []
  type: TYPE_NORMAL
- en: In this table, the rows represent the source stream class and the columns represent
    the target stream class. Again, we use color to help organize our explanations.
    The yellow boxes represent situations where the source and target classes are
    the same. So, for example, if you are going from a `DoubleStream` to another `DoubleStream`,
    the method is `map(DoubleUnaryOperator)`. The functional method is also listed
    - so for this example, `DoubleUnaryOperator`‘s functional method is `double applyAsDouble(double)`.
  prefs: []
  type: TYPE_NORMAL
- en: Let us examine the brown boxes. Each of these uses a `mapToObj()` method as
    the source is a primitive stream and the target is a stream of objects. The source
    stream hints at the function to be used. For example, if the source is a `DoubleStream`
    then the `DoubleFunction` interface applies, as you are mapping from a `double`
    primitive to a type `R`. This is specified in the functional method `R` `apply(double
    value)`.
  prefs: []
  type: TYPE_NORMAL
- en: Next the green boxes. The target stream is `DoubleStream` and hence the method
    name is `mapToDouble()`. If the source stream is a stream of objects then the
    interface is `ToDoubleFunction<T>`. Its functional method is `double` `applyAsDouble(T
    value)`, so a type `T` is input and a `double` primitive is output. Just what
    you would expect, when going from an object of type `T` to a primitive `double`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Staying with the target stream of `DoubleStream`, if the source was an `IntStream`,
    then the primitives involved are in the name of the interface: `IntToDoubleFunction`.
    No surprise that its functional method is `double` `applyAsDouble(int)`. If the
    source was a `LongStream`, then the primitives involved are again in the name
    of the interface: `LongToDoubleFunction`. No surprise either that its functional
    method is `double` `applyAsDouble(long)`.'
  prefs: []
  type: TYPE_NORMAL
- en: The blue boxes represent a target stream of `IntStream`. The method name is
    `mapToInt()`. The functional interfaces used as parameters and their functional
    methods, follow the same naming pattern as outlined for `DoubleStream`.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, the grey boxes represent a target stream of `LongStream`. The method
    name is `mapToLong()`. A similar naming pattern is again applied to the functional
    interfaces and their functional methods as shown in `DoubleStream` and `IntStream`.
  prefs: []
  type: TYPE_NORMAL
- en: Let us look at some code examples. We will start with mapping from streams of
    objects.
  prefs: []
  type: TYPE_NORMAL
- en: Mapping from Object streams
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first example will have a `Stream<String>` as the source and map to the
    various other streams accordingly. *Figure 16**.13* represents the code (`MappingStreams.java`
    in the repo).
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.13 - Mapping Object streams](img/B19793_16_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.13 - Mapping Object streams
  prefs: []
  type: TYPE_NORMAL
- en: 'In this figure, we are mapping a `Stream<String>` to all the other stream types,
    including `Stream<String>` itself. The first example is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the `map(Function<T,R>)` maps from `String` to `String`. The function
    converts the string to uppercase. The `forEach()` terminal operation starts the
    streaming process and outputs the strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second example is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This time the `Stream<String>` is mapped to a `DoubleStream` (of `double` primitives).
    Notice that we must re-stream the source as the previous `forEach()` closed it.
    This pipeline uses the `mapToDouble(ToDoubleFunction<T>)` to map from a `String`
    to a `double` primitive. The function this time use the `length()` of the `String`
    which is an `int`. This `int` is upcast to a `double` in the background. The `forEach()`starts
    the stream and outputs the `double` values.
  prefs: []
  type: TYPE_NORMAL
- en: 'The third example is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This time the `Stream<String>` is mapped to an `IntStream`. Again we must re-stream
    the source. This pipeline uses the `mapToInt(ToIntFunction<T>)` to map from a
    `String` to an `int` primitive. We again use the `length()` function of `String`.
    As this is an `int`, no upcasting is required in the background. The `forEach()`
    terminal operation is used to start the stream and output the `int` values.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last example is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `Stream<String>` is mapped to a `LongStream`. This pipeline uses the
    `mapToLong(ToLongFunction<T>)` to map from a `String` to a `long` primitive. As
    the `length()` of `String` returns an `int`, upcasting is done in the background.
    The `long` values are output as part of the `forEach()` terminal operation.
  prefs: []
  type: TYPE_NORMAL
- en: Now let us examine code examples mapping from streams of primitives.
  prefs: []
  type: TYPE_NORMAL
- en: Mapping from primitive streams
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this example, we are mapping from streams of primitives to other stream types.
    *Figure 16**.14* presents the code (`MappingStreams.java`).
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.14 - Mapping primitive streams](img/B19793_16_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.14 - Mapping primitive streams
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we are streaming `int` primitives using `IntStream.of()`, and
    converting the `IntStream` to a `Stream<String>`, `DoubleStream`, `IntStream`
    and `LongStream` in turn.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the first example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'This code represents a sample pipeline for streaming `int` primitives and mapping
    them to a stream of `String` objects. The `mapToObj()` method is important here.
    It’s signature is: `Stream<R> mapToObj(IntFunction<R>)`. The lambda passed in
    is easier to understand when we look at the functional method of the functional
    interface `IntFunction<R>`. The functional method is `R apply(int value)`. In
    our example, the `int` primitive is passed in as `n` and the `String` returned
    (represented by `R` in the method signature) is the string formed by prepending
    `"Number:"` in front of the `int`. Recall that when you have a string on the left
    or the right side (or both) of a `+` the result is a `String`. The `forEach()`
    streams the `int` primitives and outputs the `Stream<String>`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The next example is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'This code is mapping from an `IntStream` to a `DoubleStream`. The `mapToDouble()`
    method is important here. It’s signature is:'
  prefs: []
  type: TYPE_NORMAL
- en: '`DoubleStream` `mapToDouble(IntToDoubleFunction)`. The functional method for
    `IntToDoubleFunction` is `double applyAsDouble(int value)`. Thus, our lambda passes
    in an `int` and returns a `double`. The cast is not necessary and it just there
    to emphasize that a `double` primitive is returned.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the next example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we are mapping an `IntStream` to another `IntStream`. The method `IntStream
    map(IntUnaryOperator)` is used. Its functional method is:'
  prefs: []
  type: TYPE_NORMAL
- en: '`int applyAsInt(int value)` so we pass in an `int` and get back an `int`. Our
    lambda is simply multiplying the `int` coming in by 2 and returning the result.'
  prefs: []
  type: TYPE_NORMAL
- en: 'And the last example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'This code maps an `IntStream` to a `LongStream`. The method `LongStream mapToLong(IntToLongFunction)`
    is used. Its functional method is:'
  prefs: []
  type: TYPE_NORMAL
- en: '`long applyAsLong(int value)` so we pass in an `int` and get back a `long`.
    Again, the cast is not necessary, it is simply emphasizing that a `long` primitive
    is returned.'
  prefs: []
  type: TYPE_NORMAL
- en: That completes our coverage of mapping streams. Let us now move on to examining
    `Optional`s.
  prefs: []
  type: TYPE_NORMAL
- en: Explaining Optionals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An `Optional` can be thought of as a container that may or may not be empty.
    As per the API, the container “may or may not contain a non-`null` value”. An
    `Optional` is primarily used as a method return type where there is a real need
    to represent “no result” and when returning `null` could cause errors. Before
    Java 8, programmers would return `null` but now, since Java 8, we can return an
    *empty* `Optional` instead. This has several advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: Reduces the risk of `NullPointerException`s
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By using `Optional` as the return type, the API can now clearly state that there
    may not be a value returned
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Optional` API facilitates the functional programming style
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As well as `Optional<T>`, there are `Optional`s for the primitive types also;
    namely: `OptionalInt`, `OptionalDouble` and `OptionalLong`. We will examine them
    later.'
  prefs: []
  type: TYPE_NORMAL
- en: Let us first look at how to create `Optional`s.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Optionals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The API provides several `static` methods for this purpose. Let’s start with
    `Optional.of(T)`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The `value` parameter is wrapped in an `Optional`. The `value` passed must be
    a non-`null` value. If `null` is passed in, a `NullPointerException` results.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let us look at `Optional.empty()`. This is how you create an empty Optional
    instance.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Lastly, we will examine `Optional.ofNullable(T)`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'If the given `value` is non-`null`, this method returns the wrapped `value`
    in an `Optional`. If `null` is passed in, an empty `Optional` is returned. If
    we examine the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Both of these lines do the same thing. The first line is shorthand for the
    ternary operator on the second line. The ternary operator is expressing the following:
    if `value` is `null`, `opt2` is assigned an empty `Optional`; otherwise, `opt2`
    is assigned the wrapped `value`.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 16**.15* presents them in code (`Optionals.java` in the repo).'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.15 - Creating Optionals](img/B19793_16_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.15 - Creating Optionals
  prefs: []
  type: TYPE_NORMAL
- en: 'The first example here creates an empty `Optional`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: We use the `Optional.empty()` method to create an empty `Optional`. The next
    line is commented out because if you execute `get()` on an empty `Optional`, you
    will get a `NoSuchElementException` exception. The last line shows the functional
    style `ifPresent(Consumer)`. If a value is present, the given consumer is applied
    to the value; otherwise it does nothing. In this case, it does nothing as the
    `Optional` is empty.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next example creates a non-empty `Optional`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'This time we create an `Optional` using `Optional.of()`, with the value 23\.
    The second line shows that you will get a `NullPointerException` if you pass `null`
    to `Optional.of()`. The `ifPresent()` now executes the consumer passed, which
    outputs `"``opt2: 23"`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The next example uses `Optional.ofNullable()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we create an `Optional` using `Optional.ofNullable()`, also with the value
    23\. As the `Optional` is not empty, the consumer passed to `ifPresent()` outputs
    `"``opt3: 23"`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the last example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we use `Optional.ofNullable()` again, but this time, we pass
    in `null`. Rather than getting an exception (which is what `Optional.of(null)`
    would generate), we get an `Optional`. As the `Optional` is empty, the `ifPresent()`
    does nothing. The `isEmpty()` proves that the `Optional` is in fact empty resulting
    in `"opt4 is empty!"` being output.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know how to create `Optional`s, let us explore the API methods available.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Optional API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Table 16.5* represents the instance methods in `Optional`.'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Method** | **What happens if Optional** **is empty** | **What happens if
    Optional has** **a value** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `get()` | Throws `NoSuchElementException` | Returns the value |'
  prefs: []
  type: TYPE_TB
- en: '| `isPresent()` | Returns `false` | Returns `true` |'
  prefs: []
  type: TYPE_TB
- en: '| `ifPresent(Consumer)` | Does nothing | Executes `Consumer` with value |'
  prefs: []
  type: TYPE_TB
- en: '| `orElse(T otherValue)` | Returns `otherValue` | Returns the value |'
  prefs: []
  type: TYPE_TB
- en: '| `orElseGet(Supplier)` | Returns result of executing `Supplier` | Returns
    the value |'
  prefs: []
  type: TYPE_TB
- en: '| `orElseThrow()` | Throws `NoSuchElementException` | Returns the value |'
  prefs: []
  type: TYPE_TB
- en: '| `orElseThrow(Supplier)` | Throws exception returned by `Supplier`. However,
    if `Supplier` is `null`, throws a `NullPointerException` | Returns the value |'
  prefs: []
  type: TYPE_TB
- en: Table 16.5 - Optional instance methods
  prefs: []
  type: TYPE_NORMAL
- en: Many of these methods enable us to write code in a more concise and expressive
    manner. `ifPresent(Consumer)` is a very good example - rather than having in `if-else`
    statement, `ifPresent(Consumer)` removes the need to code the `else` part. Additionally,
    `ifPresent(Consumer)` helps us express our intent more clearly - if a value *is
    present*, do this; otherwise do nothing.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 16**.16* presents methods from the `Optional` API in code.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.16 - Optional methods in code](img/B19793_16_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.16 - Optional methods in code
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we will use both a non-null `Optional` and an empty `Optional`
    to test the various methods. Let us start with a valid non-null `Optional`.
  prefs: []
  type: TYPE_NORMAL
- en: Optional with a value
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Firstly, we create an `Optional` wrapped around the `Double 60.0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'We then use `isPresent()` to ensure it is safe to execute the `get()` method,
    as executing `get()` on an empty `Optional` results in an exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: As `isPresent()` returns `true`, it is safe to execute `get()`, which returns
    `60.0` and this is output to the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next 2 lines are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: In this code segment, as there is a non-null value in `valueInOptional`, the
    consumer argument to `ifPresent()` is executed, and `60.0` is output to the screen.
    In addition, as we have a value in `valueInOptional`, the `orElse(T value)` method
    is not executed; meaning that `60.0` is output to the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Empty Optional
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Firstly, we create an empty `Optional` by passing in `null` to `ofNullable()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'We then have:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: The `orElse(T value)` returns `NaN` and `orElseGet(Supplier)` executes the `Supplier`
    which is to generate a random number. Note that the `Supplier` must return a `Double`
    as that is the type of `emptyOptional`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, we have:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Both lines execute `orElseThrow()` and are mutually exclusive. What this means
    is that, to see the exception on the second line, comment out the first line.
    As the `Optional` is empty, the first line throws a `NoSuchElementException`.
    Assuming we comment out the first line and uncomment the second line, the `Supplier`
    passed in to `orElseThrow()` will return a `RuntimeException`. Note that we do
    not use the keyword `throw` in our `Supplier`. The `orElseThrow()` method will
    do that for us - our job is to give it, via the `Supplier`, an exception object
    to throw.
  prefs: []
  type: TYPE_NORMAL
- en: Our last section regarding `Optional`s, are primitive `Optional`s.
  prefs: []
  type: TYPE_NORMAL
- en: Primitive Optionals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As stated earlier, there are `Optional`s for the primitive types also; namely:
    `OptionalInt`, `OptionalDouble` and `OptionalLong`. We will look at them now.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Table 16.6* highlights the more commonly used primitive stream methods.'
  prefs: []
  type: TYPE_NORMAL
- en: '| **OptionalInt** | **OptionalDouble** | **OptionalLong** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `int getAsInt()` | `double getAsDouble()` | `long getAsLong()` |'
  prefs: []
  type: TYPE_TB
- en: '| `ifPresent(IntConsumer)``void accept(int)` | `ifPresent (DoubleConsumer)``void
    accept(double)` | `ifPresent(LongConsumer)``void accept(long)` |'
  prefs: []
  type: TYPE_TB
- en: '| `OptionalInt of(int)` | `OptionalDouble of(double)` | `OptionalLong of(long)`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `int` `orElse(int other)` | `double orElse``     (``double other)` | `long` `orElse(long other)` |'
  prefs: []
  type: TYPE_TB
- en: '| `orElseGet(IntSupplier)``int getAsInt()` | `orElseGet (DoubleSupplier)``double
    getAsDouble()` | `orElseGet(LongSupplier)``long getAsLong()` |'
  prefs: []
  type: TYPE_TB
- en: '| `IntStream stream()` | `DoubleStream stream()` | `LongStream stream()` |'
  prefs: []
  type: TYPE_TB
- en: Table 16.6 - Commonly used primitive stream methods
  prefs: []
  type: TYPE_NORMAL
- en: This table contrasts the more commonly used methods across the primitive streams.
    Where appropriate, the functional method is also listed, beneath the functional
    interface. For example, examining the `ifPresent(IntConsumer)` for `OptionalInt`
    shows that `IntConsumer`’s functional method is `void accept(int)`.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the return types for the `orElseGet()` methods can be deduced from
    the functional methods just below. For example, examining the `orElseGet()` for
    `OptionalInt` shows that `IntSupplier`’s functional method is `int getAsInt()`.
    Therefore, the return type for `orElseGet(IntSupplier)` is also `int`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us examine some of these in code. *Figure 16**.17* is the example (`Optionals.java`):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.17 - Primitive stream methods in code](img/B19793_16_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.17 - Primitive stream methods in code
  prefs: []
  type: TYPE_NORMAL
- en: 'In this figure, we start out as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: This first line uses the `IntSream` method `rangeClosed()` to generate a stream
    of integers from 1 to 10 inclusive, in steps of 1\. The `average()` method then
    calculates the average of these numbers, which is `5.5` (55/10). Note that the
    type for `optAvg` is `OptionalDouble`.
  prefs: []
  type: TYPE_NORMAL
- en: The second uses the now familiar `ifPresent()` method. This time the consumer
    argument is a `DoubleConsumer`, which means the functional method is `void accept(double)`.
    This is what we are doing - the value of the `OptionalDouble` is used (namely
    `d`) and output.
  prefs: []
  type: TYPE_NORMAL
- en: 'We then have:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: which uses `getAsDouble()` to return the `double` value. If no value is present,
    this method (like `get()` in `Optional<T>`) generates a `NoSuchElementException`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next two lines are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The first line uses the `orElseGet()` method. We pass in a `DoubleSupplier`,
    which means there is no input argument (hence the `()` in the lambda) and a `double`
    returned (`Double.NaN`). As the `OptionDouble` has a value, the value is used
    to initialize `dblAvg` and the `DoubleSupplier` is ignored. We then output the
    variable `dblAvg`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code segment completes the example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: The first line creates an `OptionalInt` using the static `OptionalInt.of()`
    method. The second line uses the `orElseGet()` method. We pass in a `IntSupplier`,
    meaning we pass in nothing and get back in `int` (which is `0`). As `optInt` has
    a value, the value is used to initialize `age` and the `IntSupplier` is ignored.
    The third line outputs the variable `age`. The last line uses `getAsInt()` to
    return the `int` value. If no value is present in the optional, this method would
    also, like `getAsDouble()`, generate a `NoSuchElementException`. However, as `optInt`
    contains a value (of 35), it is returned and output.
  prefs: []
  type: TYPE_NORMAL
- en: That complete the `Optional`s section. Our least section in this chapter is
    parallel streams.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding parallel streams
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All of the streams so far have been serial streams where the results are ordered.
    With serial streams, a single thread processes one entry at a time. A parallel
    stream is processed by multiple threads executing concurrently (running on multiple
    CPUs). The stream elements are split into substreams, which are processed by multiple
    instances of the stream pipeline being executed in multiple threads. These partial
    substream results are then combined into a final result. To execute the substreams
    in parallel, the streams use the support of Java’s fork/join framework for thread
    management.
  prefs: []
  type: TYPE_NORMAL
- en: Creating parallel streams
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To make a stream a parallel stream is very straightforward. We have two options:
    we can use the `parallelStream()` method from the `Collection` API or the `parallel()`
    intermediate operation from the `Stream` API.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are examples of both methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us look at an example contrasting a sequential stream with a parallel stream
    to show how easy it is to create a parallel stream. *Figure 16**.18* is the code
    (`ParalledStreams.java` in the repo):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.18 - Creating a parallel stream](img/B19793_16_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.18 - Creating a parallel stream
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us examine the sequential stream first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: We initially generate a stream of `Stream<Integer>`. The second line uses the
    `mapToInt()` function to map the `Stream<Integer>` to an `IntStream`. In other
    words, map from a stream of `Integer` objects to a stream of `int` primitives.
    This is so we can use the `sum()` method in `IntStream`. The result, 210 is then
    output.
  prefs: []
  type: TYPE_NORMAL
- en: 'The parallel version is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: The only difference is the call to `parallel()` on the second line. This is
    a `Stream` method. This is abstraction at its finest! The data partitioning and
    thread management are handled by the API and the JVM.
  prefs: []
  type: TYPE_NORMAL
- en: Parallel decomposition
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Creating parallel streams is the easy part. Things get interesting when performing
    *parallel decomposition* - where a task is broken down (decomposed) into smaller
    tasks that are executed concurrently, and their results assembled afterwards.
  prefs: []
  type: TYPE_NORMAL
- en: With serial streams, results are ordered and therefore predictable. With parallel
    streams and parallel decomposition, this is not the case, as order is not guaranteed
    and therefore, results are unpredictable. This is because the threads take the
    subtasks in any order and return the results in any order.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us look at a simple code example demonstrating this. *Figure 16**.19* presents
    the code (`ParalledStreams.java`):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.19 - Ordering in serial streams and lack of ordering in parallel
    streams](img/B19793_16_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.19 - Ordering in serial streams and lack of ordering in parallel streams
  prefs: []
  type: TYPE_NORMAL
- en: 'This figure presents a `dbAction()` method that mimics a database action by
    sleeping the thread for 1 second. When the `orderedSerialStreams()` method executes,
    the output is predictable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: The integers are ordered as per the source and the operation took `5 seconds`,
    `1 second` for each value.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `unorderedParallelStreams()` method is the same as the serial version except
    that we are now creating a parallel stream. Let us examine its output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'One can see the obvious performance benefit of parallel processing: 1 second
    versus 5 seconds. Note that this performance gain depends on the number of CPUs
    available - if this code is run on a machine with fewer processors, the gain would
    be less.'
  prefs: []
  type: TYPE_NORMAL
- en: However, the output is now unordered as both `map()` and `forEach()` are applied
    concurrently. Instead of `forEach()`, we could use the `forEachOrdered()` terminal
    operation. This operation ensures the consumer is applied to the elements in their
    *encounter order* as they left the source. In our example, this would be `10`,
    `20`, `30`, `40`, and `50`. *Figure 16**.20* shows it in code (`ParalledStreams.java`).
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.20 - The forEachOrdered() method](img/B19793_16_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.20 - The forEachOrdered() method
  prefs: []
  type: TYPE_NORMAL
- en: 'In this figure, the terminal operation is no longer `forEach()` but is `forEachOrdered()`.
    The output from this figure is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Now the integers are ordered and the performance gain is still significant due
    to `map()` being applied concurrently.
  prefs: []
  type: TYPE_NORMAL
- en: Parallel reductions using reduce()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As order is not guaranteed with parallel streams, the results of parallel reductions
    can be unexpected. A reduction combines a stream into a single result. Recall
    that the overloaded `reduce()` operation accepted three parameters: an identity,
    an accumulator and a combiner. The combiner function is used in a parallel environment
    for combining the accumulator results. What the following examples are going to
    demonstrate is that the *accumulator and combiner must work regardless of the
    order in which they are executed*. They must be associative.'
  prefs: []
  type: TYPE_NORMAL
- en: Associativity
  prefs: []
  type: TYPE_NORMAL
- en: 'An operator or function is considered associative if the following holds:'
  prefs: []
  type: TYPE_NORMAL
- en: '`(a op b) op c)` == `a op (b` `op c)`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, addition is associative:'
  prefs: []
  type: TYPE_NORMAL
- en: '`(2 + 3) + 4` == `2 + (3 + 4)` == `9`'
  prefs: []
  type: TYPE_NORMAL
- en: 'However, subtraction is not associative:'
  prefs: []
  type: TYPE_NORMAL
- en: '`(2 - 3) - 4` == `-5` whereas `2 - (3 - 4)` == `3`'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is really important in parallel processing. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '`a op b op c op d` == `(a op b) op (c` `op d)`'
  prefs: []
  type: TYPE_NORMAL
- en: If `op` is associative then `(a op b)` and `(c op d)` can be evaluated in parallel;
    and `op` then performed on the results.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us first examine a serial reduction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: As this is a serial reduction, there is no need for a combiner. The result is
    -15\. Let us now examine the parallel version to see do we get the same result.
    *Figure 16**.21* represents the code (ParallelStreams.java).
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.21 - A parallel reduction using reduce()](img/B19793_16_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.21 - A parallel reduction using reduce()
  prefs: []
  type: TYPE_NORMAL
- en: 'In this figure, we have expanded both the accumulator and the combiner to show
    the values as they appear:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows (with the combiner subtask values tabbed in):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the final result is `5`, which is incorrect. This is because subtraction
    is not associative. Interestingly, in the parallel process the identity is applied
    to multiple elements in the stream, giving us unexpected results.
  prefs: []
  type: TYPE_NORMAL
- en: Parallel reductions using collect()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `collect()` method, like `reduce()` has a three-argument version, which
    accepts an accumulator and a combiner. For the first argument, rather than an
    identity, `collect()` uses a `Supplier`. The same rule applies here too - the
    accumulator and combiner operations must be able to perform in any order.
  prefs: []
  type: TYPE_NORMAL
- en: One should use a concurrent collection, in order to avoid concurrent threads
    causing `ConcurrentModificationException`s. Another consideration is the target
    collection - if it is ordered (a `List` for example), then the background processing
    required to maintain that order may reduce performance. *Figure 16**.22* presents
    an example of a concurrent collection, namely `ConcurrentMap` in code (`ParallelStreams.java`).
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.22 - collect() returning a concurrent collection](img/B19793_16_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.22 - collect() returning a concurrent collection
  prefs: []
  type: TYPE_NORMAL
- en: 'The output from the code is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Therefore, the `ConcurrentMap` implementation here is a `ConcurrentHashMap`.
    This is not guaranteed but some implementation of the `ConcurrentMap` interface
    is guaranteed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The key in our map is the first letter in the name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'The value associated with the key is the name itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'If more than one name starts with the same letter, the names are appended,
    with a comma between the names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: That completes our discussion on parallel streams and indeed concludes [*Chapter
    16*](B19793_16.xhtml#_idTextAnchor401)*.* Let us now put that knowledge into practice
    to reinforce the concepts.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To keep the park running smoothly, we need to keep track of the health of all
    dinosaurs. We need to identify any ill dinosaurs. Using a stream of `Dinosaur`
    objects, filter out dinosaurs that are ill (assuming the `isIll()` method exists
    the in `Dinosaur` class), map them to their names, and collect the results in
    a list. Lastly, print out this list of names of the dinosaurs that need immediate
    attention.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Managing a dinosaur park of this size involves handling large amounts of data.
    To make an announcement in the park about dinosaur feeding times, create a list
    of dinosaurs, convert it into a stream, and use the `map()` function to get a
    list of dinosaur names. Then, use the `forEach` terminal operation to print out
    a message for each dinosaur’s feeding time.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Keeping track of the total food required for all the dinosaurs can be tricky.
    Suppose you have an array of weights of all dinosaurs. Convert it into an `IntStream`
    and use the `sum` method to get the total weight of all dinosaurs in the park.
    This could help you estimate the total food requirements.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When dealing with data about dinosaurs or employees, we may encounter null references.
    To avoid a `NullPointerException` error, use `Optional` when retrieving a dinosaur
    by its name from a map of dinosaurs. If a dinosaur with the provided name doesn’t
    exist, `Optional` should return a message indicating the dinosaur hasn’t been
    found.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Calculating the average weight of dinosaurs can be a time-consuming operation,
    especially when dealing with a large number of dinosaurs. To speed up the process,
    use parallel streams. Convert a list of dinosaur weights into a parallel stream
    and use the average method to calculate the average weight.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Project – dynamic dinosaur care system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Integrate the Stream API into your dinosaur care system to process large volumes
    of dinosaur data, such as health records, feeding schedules, and so on. The system
    should also incorporate `Optional` and parallel streams where appropriate, optimizing
    data processing and minimizing potential null pointer exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the steps to get you there:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Dinosaur` class with properties such as `name`, `species`, `healthStatus`,
    and so on. There should also be a `DinosaurCareSystem` class for implementing
    the main functionalities.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Stream` from the list of records and use the `filter` method to get these
    records. Here’s an example: `List<HealthRecord> criticalRecords = records.stream().filter(r
    -> r.getHealthStatus() <` `CRITICAL_THRESHOLD).collect(Collectors.toList())`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Stream` to filter the schedules. Here’s an example: `List<FeedingSchedule>
    morningFeeds = schedules.stream().filter(s ->` `s.getTime().isBefore(LocalTime.NOON)).collect(Collectors.toList())`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`NullPointerException``Optional` to avoid a `NullPointerException` error. Here’s
    an example: `Optional.ofNullable(dinosaur.getTrainer()).map(Trainer::getName).orElse("No`
    `trainer assigned").`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`stream()` with `parallelStream()` in the previous examples. Be aware, though,
    that not every problem is suitable for parallel processing. If the tasks have
    dependencies or need to be processed in a specific order, stick with regular streams.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we explored advanced streaming concepts. We started by exploring
    intermediate operations, which are powerful, as they transform the stream into
    another stream. Popular intermediate operations are: `filter()`, `distinct()`,
    `limit()`, `map()`, `flatMap()`, and `sorted()`. Some of these are known as *stateful*
    as they need to maintain some state to operate effectively. Examples are `limit()`
    and `sorted()`. The `limit()` method is also *short-circuiting* as it can cause
    the pipeline to shut down even if there is more data available in the source.'
  prefs: []
  type: TYPE_NORMAL
- en: We then examined the primitive stream types in the API, namely `IntStream`,
    `LongStream` and `DoubleStream`. These types have some very useful methods for
    operating on numeric types, such as `sum()` and `average()`. We also explained
    the patterns behind the names of the new primitive stream functional interfaces
    and their functional methods.
  prefs: []
  type: TYPE_NORMAL
- en: We can create streams by mapping from another stream. There are many methods
    to do this but they follow a pattern in their naming. We examined these and explained
    the patterns.
  prefs: []
  type: TYPE_NORMAL
- en: '`Optional`s are boxes that may or may not be empty. They are mainly used as
    a method return type where there is a real need to represent “no result”. Rather
    than returning `null` (with its pitfalls), we can return an empty `Optional`.
    We can create `Optional`s using `Optional.of`, `Optional.empty()` and `Optional.ofNullable()`.
    The `Optional` API supports functional-style programming; for example, `ifPresent()`
    lets us state clearly what we want without the need for an `else` statement. We
    also examined the primitive `Optional`s, namely `OptionalInt`, `OptionalLong`
    and `OptionalDouble`.'
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we looked at parallel streams, which can be easily created using the
    `Collection` API method `parallelStream()` or the `Stream` API method `parallel()`.
    While serial streams are ordered, parallel streams are not. This is due to parallel
    decomposition where tasks are broken down and re-assembled later. In a parallel
    multi-threaded environment, threads can take sub-tasks in any order and return
    the results in any order. This is fine for an associative task such as addition
    but not suitable for subtraction.
  prefs: []
  type: TYPE_NORMAL
- en: If you are using the parallel reduction methods `reduce()` and `collect()`,
    ensure that the accumulator and combiner functions are associative; as they must
    work correctly regardless of the order they are executed in.
  prefs: []
  type: TYPE_NORMAL
- en: That completes our discussion on streams. The next chapter, Concurrency will
    further solidify the last section here on parallel streams.
  prefs: []
  type: TYPE_NORMAL
