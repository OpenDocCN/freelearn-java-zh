- en: '16'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '16'
- en: 'Streams: Advanced Concepts'
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 流：高级概念
- en: In [*Chapter 15*](B19793_15.xhtml#_idTextAnchor377), we learned about the fundamentals
    of streams. We started by discussing what a stream pipeline is by using an analogy
    of an assembly line. We saw that items only make their way onto the assembly line
    as and when needed. This is the principle of lazy evaluation. In this analogy,
    there are several operators that operate on the data (pencils) under the supervision
    of a supervisor (Java). The supervisor will not allow any work to start until
    the terminal operation in place. As Java is now aware of the full pipeline, efficiencies
    can be introduced. Once a pencil has passed an operator, the operator cannot get
    that pencil back. Thus, streams are different to arrays or `Collection`s in that
    manner. The pencils can be processed by as many operators as necessary but only
    one operator is the terminal operation. The other operators represent intermediate
    operations (a topic in this chapter).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第15章*](B19793_15.xhtml#_idTextAnchor377)中，我们学习了流的基本概念。我们通过类比流水线来讨论什么是流管道。我们了解到，项目只有在需要时才会进入流水线。这是惰性求值的原理。在这个类比中，有几个操作员在主管（Java）的监督下对数据进行操作。主管不会允许任何工作开始，直到终端操作就绪。由于Java现在知道整个管道，可以引入效率。一旦铅笔通过一个操作员，该操作员就无法将其取回。因此，流与数组或`Collection`在这一点上有所不同。铅笔可以由所需数量的操作员处理，但只有一个操作员是终端操作。其他操作员代表中间操作（本章的主题）。
- en: 'We examined how to create streams. Streams can be created from various sources:
    arrays, collections, files, and varargs. We created both finite and infinite streams.
    Infinite streams are created using `Stream.generate()` and `Stream.iterate()`.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们探讨了如何创建流。流可以从各种来源创建：数组、集合、文件和可变参数。我们创建了有限和无限的流。无限流是通过`Stream.generate()`和`Stream.iterate()`创建的。
- en: We took a deep dive into terminal operations. Nothing happens until a terminal
    operation executes and once executed the stream is considered closed and must
    be re-streamed if you want to use it again. A reduction is an operation that examines
    all of the stream and produces a single output (primitive or `Object`). One of
    the terminal operations is the overloaded `reduce()` method which performs reductions
    on the stream. The `collect()` terminal operation is extremely useful for extracting
    data out of the stream (into a `Map` for example) for later use.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们深入研究了终端操作。直到终端操作执行，否则不会发生任何事情。一旦执行，流就被认为是关闭的，如果你想要再次使用它，必须重新流式传输。归约是一种检查整个流并产生单个输出（原始或`Object`）的操作。终端操作之一是重载的`reduce()`方法，它对流执行归约。`collect()`终端操作对于从流中提取数据（例如，到一个`Map`）以供以后使用非常有用。
- en: In this chapter, we will continue our coverage of streams. We will, with the
    aid of code examples, examine intermediate operations. Following that, we will
    discuss primitive streams and how to map streams. We will also discuss `Optional`s
    and lastly, we will finish with parallel streams.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将继续对流的讨论。我们将通过代码示例来检查中间操作。随后，我们将讨论原始流以及如何映射流。我们还将讨论`Optional`，最后，我们将以并行流结束。
- en: 'This chapter covers the following main topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了以下主要主题：
- en: Examining intermediate operations
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查中间操作
- en: Delving into primitive streams
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 深入探讨原始流
- en: Mapping streams
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 映射流
- en: Explaining `Optional`s
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释`Optional`
- en: Understanding parallel streams
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解并行流
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code for this chapter can be found on GitHub at [https://github.com/PacktPublishing/Learn-Java-with-Projects/tree/main/ch16](https://github.com/PacktPublishing/Learn-Java-with-Projects/tree/main/ch16).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在GitHub上找到，地址为[https://github.com/PacktPublishing/Learn-Java-with-Projects/tree/main/ch16](https://github.com/PacktPublishing/Learn-Java-with-Projects/tree/main/ch16)。
- en: Examining intermediate operations
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查中间操作
- en: 'As we know, a stream pipeline consists of a source, followed by zero or more
    intermediate operations, followed by a terminal operation. While the terminal
    operation is mandatory, intermediate operations are not. That said, intermediate
    operations are where pipelines get their real power as they transform the stream
    data as it flows by. Unlike terminal operations, intermediate operations produce
    a stream as a result. Let us start with `filter()`, which is taken from IntermediateOperations.java
    on the repo:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所知，流管道由一个源，后面跟着零个或多个中间操作，然后是一个终端操作组成。虽然终端操作是强制性的，但中间操作不是。换句话说，中间操作是管道获得真正力量的地方，因为它们在数据流过时转换流数据。与终端操作不同，中间操作产生一个流作为结果。让我们从
    `filter()` 开始，它来自 repo 上的 IntermediateOperations.java：
- en: filter(Predicate)
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: filter(Predicate)
- en: 'The `filter()` operation returns a stream containing the elements matching
    the given predicate. *Figure 16**.1* presents a code example (from `IntermediateOperations.java`
    on the repo):'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`filter()` 操作返回一个包含匹配给定谓词的元素的流。*图 16.1* 展示了一个代码示例（来自 repo 上的 `IntermediateOperations.java`）：'
- en: '![Figure 16.1 - The filter(Predicate) intermediate operation in code](img/B19793_16_1.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![图 16.1 - 代码中的 filter(Predicate) 中间操作](img/B19793_16_1.jpg)'
- en: Figure 16.1 - The filter(Predicate) intermediate operation in code
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.1 - 代码中的 filter(Predicate) 中间操作
- en: In this figure, the countries whose names are longer than 5 characters are output.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图中，输出的是名字长度超过 5 个字符的国家。
- en: distinct()
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: distinct()
- en: The `distinct()` operation returns a stream with duplicate elements removed.
    Internally, `distinct()` uses the `equals()` method from `Object` when comparing.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`distinct()` 操作返回一个移除了重复元素的流。内部，`distinct()` 使用 `Object` 的 `equals()` 方法进行比较。'
- en: 'It is a *stateful* intermediate operation which means it needs to keep some
    state to operate effectively. This state enables `distinct()` to operate as follows:
    if this is the first time `distinct()` has seen this object, it passes it on but
    remembers it; if `distinct()` has already seen this object, it filters it out.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 它是一个 *有状态的* 中间操作，这意味着它需要保持一些状态以有效地操作。这个状态使 `distinct()` 能够按以下方式操作：如果这是 `distinct()`
    第一次看到这个对象，它将其传递并记住它；如果 `distinct()` 已经看到这个对象，它将其过滤掉。
- en: '*Figure 16**.2* presents a code example (from `IntermediateOperations.java`
    on the repo):'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 16.2* 展示了一个代码示例（来自 repo 上的 `IntermediateOperations.java`）：'
- en: '![Figure 16.2 - The distinct() intermediate operation in code](img/B19793_16_2.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图 16.2 - 代码中的 distinct() 中间操作](img/B19793_16_2.jpg)'
- en: Figure 16.2 - The distinct() intermediate operation in code
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.2 - 代码中的 distinct() 中间操作
- en: In this figure, we are streaming a list of strings, where `"eagle"` is duplicated.
    We are using the very useful `Stream<T> peek(Consumer)` intermediate operation.
    This `peek()` operation executes the consumer on the data as it passes by. This
    is a great help as it enables us to view the data flowing by. The `distinct()`
    operation is in our pipeline and the `forEach()` terminal operation starts the
    streaming.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图中，我们正在流式传输一个字符串列表，其中 `"eagle"` 是重复的。我们使用了非常有用的 `Stream<T> peek(Consumer)`
    中间操作。这个 `peek()` 操作在数据通过时执行消费者。这非常有帮助，因为它使我们能够查看流过的数据。`distinct()` 操作在我们的管道中，而
    `forEach()` 终端操作开始流式传输。
- en: 'When run, this code generates the following output:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行时，此代码生成以下输出：
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The first `"eagle"` is streamed into the pipeline, where `peek()` echoes it
    to the screen, with the decoration `"Before: "`. Then `peek()` passes `"eagle"`
    on to `distinct()`. As this is the first time `distinct()` has seen `"eagle"`,
    it passes it on but remembers it. Lastly, `forEach()` takes `"eagle"` and outputs
    it prepended with the string `", After:"`, followed by a newline.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '第一个 `"eagle"` 被流式传输到管道中，其中 `peek()` 将其回显到屏幕上，并带有装饰 `"Before: "`。然后 `peek()`
    将 `"eagle"` 传递给 `distinct()`。由于这是 `distinct()` 第一次看到 `"eagle"`，它将其传递并记住它。最后，`forEach()`
    将 `"eagle"` 与字符串 `", After:"` 预先连接，然后输出一个换行符。'
- en: 'Now the second `"eagle"` is streamed. The `peek()` operation outputs the details
    and passes `"eagle"` on. However, `distinct()` remembers that it has seen this
    element already and filters it out. This is why `", After: eagle"` appears only
    once in the output.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '现在第二个 `"eagle"` 被流式传输。`peek()` 操作输出详细信息并将 `"eagle"` 传递下去。然而，`distinct()` 记住它已经看到这个元素，并将其过滤掉。这就是为什么在输出中只出现一次
    `", After: eagle"` 的原因。'
- en: Lastly, `"EAGLE"` is streamed. This proceeds just as the first `"``eagle"` did.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`"EAGLE"` 被流式传输。这与第一个 `"eagle"` 的处理方式相同。
- en: limit(long)
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: limit(long)
- en: 'The `limit()` operation is a short-circuiting, stateful intermediate operation.
    We saw its short-circuiting nature put into good effect by transforming an infinite
    stream into a finite stream in [*Chapter 15*](B19793_15.xhtml#_idTextAnchor377)*.*
    Obviously, it needs to maintain some state in order to keep a count of the elements
    that have passed by. *Figure 16**.3* presents a code example (`IntermediateOperations.java`):'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`limit()`操作是一个短路、有状态的中间操作。我们看到了其短路特性在将无限流转换为有限流的过程中得到了很好的应用，这在[*第15章*](B19793_15.xhtml#_idTextAnchor377)中有所体现。显然，它需要维护一些状态以保持通过元素的数量。*图16.3*展示了代码示例（`IntermediateOperations.java`）：'
- en: '![Figure 16.3 - The limit(long) intermediate operation in code](img/B19793_16_3.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图16.3 - 代码中的limit(long)中间操作](img/B19793_16_3.jpg)'
- en: Figure 16.3 - The limit(long) intermediate operation in code
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.3 - 代码中的limit(long)中间操作
- en: 'In this example, we are streaming a list of numbers. This example is a good
    example of lazy evaluation. The output is:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们正在流式传输一个数字列表。这是一个懒加载的好例子。输出如下：
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Let us examine what happens here.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这里发生了什么。
- en: 11 is streamed, first `peek()` outputs it prepended with `"A - "` and passes
    it to `filter()` where it fails (as 11 is not > 40)
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 11被流式传输，第一个`peek()`输出它前面加上`"A - "`，然后传递给`filter()`，在那里失败（因为11不大于40）
- en: 22 is streamed and behaves just as 11 did
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 22被流式传输，表现与11相同
- en: 33 is streamed and operates in a similar fashion to 11 and 22
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 33被流式传输，操作方式与11和22相似
- en: 44 is streamed, passes the filter, hence `"B - 44"` is output; 44 is passed
    to `limit()` which records that this is the first element it has seen, before
    passing it on; `forEach()` outputs 44 prepended with `"C - "`.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 44被流式传输，通过了过滤器，因此输出了`"B - 44"`；44被传递给`limit()`，它记录这是它看到的第一个元素，然后再传递；`forEach()`输出前面加上`"C
    - "`的44。
- en: 55 is streamed and operates as 44 except that `limit()` informs Java that this
    is the second element it has passed and the limit is 2\. Java lets `forEach()`
    finish and the stream is closed.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 55被流式传输，操作方式与44相同，除了`limit()`通知Java这是它遇到的第二个元素，限制为2。Java允许`forEach()`完成，流关闭。
- en: Note that the first `peek()` never outputs `"A - 66"`, `"A - 77"`, `"A - 88"`,
    or `"A - 99"`. Therefore, 66, 77, 88, and 99 are never streamed - as they are
    not needed. This is another example of lazy evaluation.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注意，第一个`peek()`永远不会输出`"A - 66"`、`"A - 77"`、`"A - 88"`或`"A - 99"`。因此，66、77、88和99永远不会被流式传输——因为它们不是必需的。这是另一个懒加载的例子。
- en: Now let us look at `map()`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看一下`map()`。
- en: map(Function)
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: map(Function)
- en: 'The `Stream<R> map(Function<T, R>)` operation is for transforming data. It
    creates a one-to-one mapping between elements in the stream and elements in the
    new stream returned. *Figure 16**.4* presents a code example (`IntermediateOperations.java`):'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`Stream<R> map(Function<T, R>)`操作用于转换数据。它创建流中的元素与新返回的流中的元素之间的一对一映射。*图16.4*展示了代码示例（`IntermediateOperations.java`）：'
- en: '![Figure 16.4 - The map(Function) intermediate operation in code](img/B19793_16_4.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![图16.4 - 代码中的map(Function)中间操作](img/B19793_16_4.jpg)'
- en: Figure 16.4 - The map(Function) intermediate operation in code
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.4 - 代码中的map(Function)中间操作
- en: 'The `map()` operation takes in a `Function` which, takes in one type and returns
    another, possibly different type. In this example, the lambda used, takes in a
    `String` namely `s`, and returns the `Integer` length of that `String`. The `forEach()`
    outputs the lengths of the `String`s streamed: `"book"` is `4`, `"pen"` is `3`
    and `"ruler"` is `5`.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`map()`操作接受一个`Function`，它接受一个类型并返回另一个类型，可能是不同的类型。在这个例子中，使用的lambda接受一个`String`，即`s`，并返回该`String`的`Integer`长度。`forEach()`输出流式传输的`String`的长度：`"book"`是`4`，`"pen"`是`3`，`"ruler"`是`5`。'
- en: flatMap(Function)
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: flatMap(Function)
- en: 'The `flatMap()` operation “flattens” a stream. In other words, multiple collections/arrays
    are merged into one. For example, if we were streaming `List<String>` elements,
    they would be flattened into a stream of `String`s, which “removes” or hides each
    individual `List`. This is helpful when combining lists or for removing empty
    elements (which `flatMap()` also does). *Figure 16**.5* presents a code example
    (`IntermediateOperations.java`):'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`flatMap()`操作“扁平化”了一个流。换句话说，多个集合/数组被合并为一个。例如，如果我们正在流式传输`List<String>`元素，它们将被扁平化为一个`String`的流，这“移除”或隐藏了每个单独的`List`。这在合并列表或删除空元素（`flatMap()`也这样做）时很有用。*图16.5*展示了代码示例（`IntermediateOperations.java`）：'
- en: '![Figure 16.5 - The flatMap(Function) intermediate operation in code](img/B19793_16_5.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![图16.5 - 代码中的flatMap(Function)中间操作](img/B19793_16_5.jpg)'
- en: Figure 16.5 - The flatMap(Function) intermediate operation in code
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.5 - 代码中的flatMap(Function)中间操作
- en: In this example, we are going to contrast two streams - one with `flatMap()`
    and the other without `flatMap()`. Let us start with the non-`flatMap()` stream.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将对比两个流 - 一个使用`flatMap()`，另一个不使用`flatMap()`。让我们从非`flatMap()`流开始。
- en: 'Firstly, we create the lists, the first of which is an empty list:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建列表，其中第一个是一个空列表：
- en: '[PRE2]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We then stream the three lists:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们流式传输这三个列表：
- en: '[PRE3]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We then stream and output our `streamOfLists` using `forEach()`:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用`forEach()`流式传输并输出我们的`streamOfLists`：
- en: '[PRE4]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This outputs:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这会输出：
- en: '[PRE5]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note that each element is a list (reflected by the square brackets `[ ]`) and
    that the empty list is present.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，每个元素都是一个列表（通过方括号`[ ]`反映出来），并且空列表是存在的。
- en: 'As the stream has been processed by a terminal operation (`forEach()`), the
    stream is closed. To avoid an exception, we must re-stream the source. This is
    what we do:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 由于流已经被终端操作（`forEach()`）处理，流已经关闭。为了避免异常，我们必须重新流式传输源。这就是我们做的：
- en: '[PRE6]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This second pipeline contains the `flatMap()` operation:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这个第二个管道包含`flatMap()`操作：
- en: '[PRE7]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The signature for `flatMap()` is as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`flatMap()`的签名如下：'
- en: '[PRE8]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Therefore, `flatMap()` takes in a `Function`. The function input `T`, is a `List<String>`
    and the function output `R`, is a `Stream<String>`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`flatMap()`接受一个`Function`。函数输入`T`是一个`List<String>`，函数输出`R`是一个`Stream<String>`。
- en: 'Using `forEach()` again to both start off the streaming and output the elements
    in the stream, we get the following:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 再次使用`forEach()`来启动流式传输并输出流中的元素，我们得到以下结果：
- en: '[PRE9]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note that they are all just `Strings` (no `List`s) and that the empty element
    has been removed. The `String` elements that were in the `List`s are now top-level
    elements in the stream. This is the flattening process explained earlier.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，它们都是`Strings`（没有`List`），并且空元素已经被移除。现在，列表中的`String`元素现在是流中的顶级元素。这就是前面解释的扁平化过程。
- en: sorted() and sorted(Comparator)
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: sorted() 和 sorted(Comparator)
- en: The overloaded `sorted()` operation returns a stream with the elements sorted.
    Just like sorting arrays, Java uses natural ordering unless we provide a `Comparator`.
    For example, natural ordering for numbers is ascending numeric order; natural
    ordering for `String`s is alphabetic. This operation is a stateful intermediate
    operation which means that `sorted()` needs to see all of the data before it can
    sort it. Both sorted examples are based on IntermediateOperations.java in the
    repo. *Figure 16**.6* presents a code example of `sorted(Comparator)`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 重载的`sorted()`操作返回一个已排序元素的流。就像排序数组一样，Java使用自然排序，除非我们提供`Comparator`。例如，数字的自然排序是升序数字顺序；`String`的自然排序是字母顺序。这个操作是一个有状态的中间操作，这意味着`sorted()`在排序之前需要看到所有数据。这两个排序示例都是基于repo中的IntermediateOperations.java。*图16.6*展示了`sorted(Comparator)`的代码示例。
- en: '![Figure 16.6 - The sorted(Comparator) intermediate operation in code](img/B19793_16_6.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![图16.6 - 代码中的sorted(Comparator)中间操作](img/B19793_16_6.jpg)'
- en: Figure 16.6 - The sorted(Comparator) intermediate operation in code
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.6 - 代码中的sorted(Comparator)中间操作
- en: In this example, assume the existence of a `Person` class that has both `String`
    `name` and `Integer` `age` instance variables. We start by streaming the `Person`
    objects; `"Mary"` is first, age 25 and `"John"` is second, age `23`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，假设存在一个`Person`类，它既有`String`类型的`name`实例变量，也有`Integer`类型的`age`实例变量。我们首先流式传输`Person`对象；“Mary”是第一个，年龄25岁，“John”是第二个，年龄`23`岁。
- en: 'The `sorted(Comparator)` line is interesting:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`sorted(Comparator)`这一行很有趣：'
- en: '[PRE10]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `Comparator.comparing(Function keyExtractor)` static method is a very useful
    way of generating a `Comparator`. It accepts in a `Function` that extracts a `Comparable`
    sort key - as in, a key whose type implements the `Comparable` interface. In this
    example, the `Function` input is a `Person` and the `Function` return is an `Integer`
    (the age of the person). As `Integer` implements `Comparable`, this is fine. The
    method then returns a `Comparator` that compares by that sort key. This pipeline
    is short and does not clearly demonstrate the stateful nature of `sorted()`. The
    next example will do that.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`Comparator.comparing(Function keyExtractor)`静态方法是一种生成`Comparator`的非常有用方式。它接受一个`Function`，该函数提取一个`Comparable`排序键
    - 也就是说，一个键的类型实现了`Comparable`接口。在这个例子中，`Function`输入是一个`Person`，而`Function`返回值是一个`Integer`（人的年龄）。由于`Integer`实现了`Comparable`，这是可以的。然后该方法返回一个通过该排序键比较的`Comparator`。这个管道很短，并没有清楚地展示`sorted()`的状态性。下一个例子将做到这一点。'
- en: When we output the stream, `"John"` comes out first and `"Mary"` second (the
    reverse of the order in which they were streamed). This is because we are sorting
    by `age` and `"John"`, at `23`, is younger than `"Mary"`, who is `25`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们输出流时，"John" 首先出现，然后是 "Mary"（与它们被流出的顺序相反）。这是因为我们按 `age` 排序，而 `John`，23岁，比
    `Mary`（25岁）年轻。
- en: Now let us look at another `sorted()` example. This one will demonstrate the
    stateful nature of `sorted()` and at the same time, highlight lazy evaluation.
    *Figure 16**.7* presents the code.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看另一个 `sorted()` 的例子。这个例子将演示 `sorted()` 的有状态特性，同时突出懒加载。*图 16**.7* 展示了代码。
- en: '![Figure 16.7 - The stateful nature of sorted()](img/B19793_16_7.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![图 16.7 - `sorted()` 的有状态特性](img/B19793_16_7.jpg)'
- en: Figure 16.7 - The stateful nature of sorted()
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.7 - `sorted()` 的有状态特性
- en: 'In this example, we are streaming a list of `String`s (names). Names that are
    of length `3` pass the filter:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们正在流式传输一个 `String`（名字）列表。长度为 `3` 的名字通过过滤器：
- en: '[PRE11]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `sorted()` operation is stateful - it needs to see *all* of the data before
    it can sort that data. We also have a `limit(2)` operation which is both stateful
    and short-circuiting. It will short-circuit after 2 names have passed by. Lastly,
    the terminal operation `forEach()` starts off the streaming process and outputs
    the names as they arrive.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`sorted()` 操作是有状态的 - 它需要看到 *所有* 数据才能对数据进行排序。我们还有一个 `limit(2)` 操作，它既是有状态的又是短路操作。它将在两个名字通过后短路。最后，终端操作
    `forEach()` 启动了流式传输过程，并按到达顺序输出名字。'
- en: 'The output is as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE12]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Let us examine what happens here. Note that the comments on the right of the
    pipeline (lines 49-55) indicate what stage each name gets to.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这里发生了什么。注意，管道右侧的注释（第 49-55 行）表明每个名字到达的阶段。
- en: '`"Tim"` is streamed and passes the filter. `"Tim"` makes its way to `sorted()`
    where it is stored. Java tells `sorted()` that there is more data to be streamed
    and not to sort yet. This results in `"0\. Tim 1\. Tim"` in the output.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"Tim"` 被流出并通过了过滤器。`"Tim"` 进入 `sorted()` 并被存储。Java 告诉 `sorted()` 还有更多数据要流式传输，不要排序。这导致输出中有
    `"0. Tim 1. Tim"`。'
- en: '`"Jim"` is streamed next and behaves exactly as `"Tim"`, with `sorted()` keeping
    a record that it will have to sort both `"Tim"` and `"Jim"`. Again, Java tells
    `sorted()` that there is more data to come and not to sort yet. Thus, we have
    `"0\. Jim 1\. Jim"` in the output.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"Jim"` 接下来被流出，其行为与 `"Tim"` 完全一样，`sorted()` 记录了它将需要排序 `"Tim"` 和 `"Jim"`。再次，Java
    告诉 `sorted()` 还有更多数据要来，不要排序。因此，输出中有 `"0. Jim 1. Jim"`。'
- en: '`"Peter"` is then streamed but fails the filter (just `"0\. Peter"` and no
    `"1\. Peter"` in the output).'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"Peter"` 然后被流出，但未通过过滤器（输出中只有 `"0. Peter"` 而没有 `"1. Peter"`）。'
- en: '`"Ann"` is streamed next and behaves exactly as `"Tim"` and `"Jim"`, with `sorted()`
    keeping a record that it will have to sort `"Tim"`, `"Jim"`, and `"Ann"`. Again,
    Java tells `sorted()` not to sort yet. Thus, we have in `"0\. Ann 1\. Ann"` in
    the output.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"Ann"` 接下来被流出，其行为与 `"Tim"` 和 `"Jim"` 完全一样，`sorted()` 记录了它将需要排序 `"Tim"`、`"Jim"`
    和 `"Ann"`。再次，Java 告诉 `sorted()` 还有更多数据要来，不要排序。因此，输出中有 `"0. Ann 1. Ann"`。'
- en: '`"Mary"` is the last name to be streamed. `"Mary"` fails the filter also (just
    “`0\. Mary`” and no `"1\. Mary"` in the output).'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"Mary"` 是最后一个被流出的名字。`"Mary"` 也未通过过滤器（输出中只有 “`0. Mary`” 而没有 “`1. Mary`”）。'
- en: As the stream is now empty, Java tells `sorted()` that it can sort the data.
    The sorted names are `"Ann"`, `"Jim"`, and `"Tim"`. So `"Ann"` now makes its way
    out of `sorted()` and onto the next stage of the stream pipeline.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于流现在为空，Java 告诉 `sorted()` 它可以排序数据。排序后的名字是 `"Ann"`、`"Jim"` 和 `"Tim"`。因此，`"Ann"`
    现在从 `sorted()` 流出，进入流管道的下一阶段。
- en: The `peek()` after `sorted()` outputs `"2\. Ann"` showing `"Ann"` got here.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sorted()` 后的 `peek()` 输出 `"2. Ann"`，显示 `"Ann"` 到达了这里。'
- en: The `limit()` operation passes “Ann” on but records that it has handled one
    name.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`limit()` 操作将 “Ann” 传递下去，但记录了它已经处理了一个名字。'
- en: The terminal operation `forEach()` which kick-started the whole streaming process,
    outputs `"3\. Ann"` to show that `"Ann"` got as far as here.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 终端操作 `forEach()`，它启动了整个流式传输过程，输出 `"3. Ann"` 以显示 `"Ann"` 已经到达这里。
- en: '`"Jim"` now makes its way out of `sorted()`. `"Jim"` is peeked (`"2\. Jim"`)
    and passes through `limit()`. However, `limit()` short-circuits as this is the
    second name it has handled. Java is informed of this fact.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"Jim"` 现在从 `sorted()` 中流出。`"Jim"` 被窥视（`"2. Jim"`）并通过 `limit()`。然而，由于这是它处理的第二个名字，`limit()`
    被短路。Java 被告知这一事实。'
- en: The `forEach()` operation is allowed to finish outputting `"``3\. Jim"`.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`forEach()` 操作允许完成输出 `"3. Jim"`。'
- en: Note that `"Tim"` never gets out of `sorted()` and into the last `peek()` -
    there is no `"2\. Tim"` in the output.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注意，“Tim”从未从`sorted()`中出来，进入最后的`peek()` - 输出中没有“2. Tim”。
- en: That completes this section on intermediate operations. Let us now examine primitive
    streams.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了关于中间操作的这一部分。现在让我们来考察原生流。
- en: Delving into primitive streams
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入原生流
- en: Thus far, all our streams have been for `Object` types. For example, a `Stream<Integer>`
    caters for the wrapper class `Integer`. Java also has classes specifically tailored
    for streams of primitives. For example, assuming a stream of `int` primitives,
    rather than `Stream<Integer>`, we use `IntStream`. As we shall see shortly, primitive
    streams have some really useful methods for processing numeric data, such as `sum()`
    and `average()`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们所有的流都是针对`Object`类型的。例如，`Stream<Integer>`为包装类`Integer`提供支持。Java也有专门针对原生流类的。例如，假设有一个`int`原生流，而不是`Stream<Integer>`，我们使用`IntStream`。正如我们将很快看到的，原生流有一些非常实用的方法用于处理数值数据，例如`sum()`和`average()`。
- en: '*Table 16.1* introduces the primitive stream classes.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '*表16.1*介绍了原生流类。'
- en: '| **Wrapper stream** | **Primitive stream** | **Primitives** **catered for**
    |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| **包装流** | **原生流** | **支持的** **原生类型** |'
- en: '| --- | --- | --- |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `Stream<Integer>` | `IntStream` | `int, short,` `byte, char` |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| `Stream<Integer>` | `IntStream` | `int, short, byte, char` |'
- en: '| `Stream<Double>` | `DoubleStream` | `double, float` |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| `Stream<Double>` | `DoubleStream` | `double, float` |'
- en: '| `Stream<Long>` | `LongStream` | `long` |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| `Stream<Long>` | `LongStream` | `long` |'
- en: Table 16.1 - Primitive stream classes
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 表16.1 - 原生流类
- en: In this table, the first column lists the wrapper type streams; the second column
    lists the corresponding primitive stream and the last column, enumerates the primitives
    catered for by the primitive stream from column two.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个表中，第一列列出了包装类型流；第二列列出了相应的原生流，最后一列，列举了第二列原生流所支持的原生类型。
- en: Let us examine how to create primitive streams.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考察如何创建原生流。
- en: Creating primitive streams
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建原生流
- en: As with creating `Object` streams, we can easily create primitive streams as
    well. *Figure 16**.8* presents sample code creating primitive streams (based on
    code from PrimitiveStreams.java in the repo).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 与创建`Object`流一样，我们也可以轻松地创建原生流。*图16.8*展示了创建原生流的示例代码（基于repo中的PrimitiveStreams.java文件中的代码）。
- en: '![Figure 16.8 - Creating primitive streams](img/B19793_16_8.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![图16.8 - 创建原生流](img/B19793_16_8.jpg)'
- en: Figure 16.8 - Creating primitive streams
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.8 - 创建原生流
- en: 'In this example, we create arrays of differing primitive types:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们创建了不同原生类型的数组：
- en: '[PRE13]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Using the overloaded `Arrays.stream()` method, we create an `IntStream`, `DoubleStream`
    and `LongStream` respectively:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 使用重载的`Arrays.stream()`方法，我们分别创建`IntStream`、`DoubleStream`和`LongStream`：
- en: '[PRE14]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: For example, the `Arrays.stream(ia)` takes in an `int[]` and returns an `IntStream`
    with the specified array as its source.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`Arrays.stream(ia)`接受一个`int[]`并返回一个以指定数组为源的`IntStream`。
- en: 'We then execute the `count()` terminal operation on each of the streams. Each
    returns `3` as there are `3` primitives in each array source:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们对每个流执行`count()`终端操作。每个流都返回`3`，因为每个数组源中都有`3`个原生值：
- en: '[PRE15]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `of()` method should look familiar from how we created a regular stream
    using the `Stream` class. There is an equivalent method in `IntStream`, `DoubleStream`
    and `LongStream`. The values in the streams are specified in the varargs arguments:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`of()`方法应该与我们使用`Stream`类创建常规流的方式相似。在`IntStream`、`DoubleStream`和`LongStream`中都有一个等效的方法。流中的值由varargs参数指定：'
- en: '[PRE16]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Again, we execute the `count()` terminal operation on each of the streams.
    As before, `3` is returned each time, as there are `3` primitives in each of the
    streams:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们对每个流执行`count()`终端操作。和之前一样，每次返回`3`，因为每个流中都有`3`个原生值：
- en: '[PRE17]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We can of course create infinite streams of primitives. *Figure 16**.9*, from
    PrimitiveStreams.java in the repo, shows them being used and their equivalent
    names in the `Stream` class are familiar, namely `generate()` and `iterate()`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们当然可以创建无限的原生流。*图16.9*，来自repo中的PrimitiveStreams.java文件，展示了它们的使用及其在`Stream`类中的等效名称，即`generate()`和`iterate()`。
- en: '![Figure 16.9 - Infinite primitive streams](img/B19793_16_9.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![图16.9 - 无限原生流](img/B19793_16_9.jpg)'
- en: Figure 16.9 - Infinite primitive streams
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.9 - 无限原生流
- en: 'In this example, we start out with the following two lines of code:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们开始时有两行代码：
- en: '[PRE18]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `DoubleStream.generate(DoubleSupplier)` method has equivalent versions in
    `IntStream` and `LongStream`. Its parameter `DoubleSupplier` is a functional interface
    where it produces a `double`. Thus, it is a `double` primitive version of `Supplier<T>`.
    Its functional method `double getAsDouble()` reinforces this fact. We use `limit(5)`
    to limit the infinite flow of numbers to `5` and each is output by the terminal
    operation `forEach()`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`DoubleStream.generate(DoubleSupplier)` 方法在 `IntStream` 和 `LongStream` 中有等效版本。它的参数
    `DoubleSupplier` 是一个函数式接口，它产生一个 `double`。因此，它是 `Supplier<T>` 的 `double` 原始版本。它的函数式方法
    `double getAsDouble()` 强调了这一点。我们使用 `limit(5)` 来限制无限数字流的数量为 `5`，并且每个数字都通过终端操作 `forEach()`
    输出。'
- en: 'We follow that with the next two lines of code:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是下一行代码：
- en: '[PRE19]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `IntStream.iterate()` method has equivalent versions in `DoubleStream` and
    `LongStream`. It takes two arguments, an `int` seed (the starting value) and an
    `IntUnaryOperator` function. This `IntUnaryOperator` function takes in an `int`
    and returns an `int`. It is the `int` primitive specialization of `UnaryOperator<T>`.
    The stream of numbers generated are even numbers, starting at `2`. As the sequence
    of numbers is infinite, we apply a limit of 5 numbers (`2`, `4`, `6`, `8`, `10`).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`IntStream.iterate()` 方法在 `DoubleStream` 和 `LongStream` 中有等效版本。它接受两个参数，一个 `int`
    种子（起始值）和一个 `IntUnaryOperator` 函数。这个 `IntUnaryOperator` 函数接受一个 `int` 并返回一个 `int`。它是
    `UnaryOperator<T>` 的 `int` 原始特化。生成的数字流是偶数，从 `2` 开始。由于数字序列是无限的，我们应用了5个数字的限制（`2`、`4`、`6`、`8`、`10`）。'
- en: Let us now examine common primitive stream methods.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来考察常见的原始流方法。
- en: Common primitive stream methods
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 常见的原始流方法
- en: The methods just presented, namely `of()`, `generate()` and `iterate()` are
    common to `Stream<T>` as well. *Table 16.2* presents commonly used methods that
    are unique to primitive streams.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 刚才提到的这些方法，即 `of()`、`generate()` 和 `iterate()`，在 `Stream<T>` 中也是通用的。*表 16.2*
    展示了原始流中特有的常用方法。
- en: '![Table 16.2 - Common primitive stream methods](img/B19793_16_Table_02.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![表 16.2 - 常见的原始流方法](img/B19793_16_Table_02.jpg)'
- en: Table 16.2 - Common primitive stream methods
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 表 16.2 - 常见的原始流方法
- en: 'This table has two columns: the name of the method (including its return type)
    and the primitive streams. Each of the methods listed are reductions and terminal
    operations. Recall that a reduction produces a single summary result by repeatedly
    applying an operation to a sequence of input results. We saw the general form
    of reductions with the `reduce()` and `collect()` methods in the `Stream<T>` interface.
    The reductions in this table are specialized for primitives.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 此表有两列：方法的名称（包括其返回类型）和原始流。列出的每个方法都是归约和终端操作。回想一下，归约通过反复对一个输入结果序列应用操作来生成单个总结结果。我们在
    `Stream<T>` 接口中的 `reduce()` 和 `collect()` 方法中看到了归约的一般形式。此表中的归约是针对原始数据类型特化的。
- en: Let us first examine the `sum()` method. Notice that it does not return an `Optional`
    whereas all the other methods do. This is because `0` is a valid value to return
    for the sum of an empty stream. In other words, if the stream is empty when you
    execute `sum()` - perhaps all of the data has been filtered out - then `0` is
    a valid return. The other methods in the table, however, would need to return
    an empty `Optional` in that scenario. The `IntStream` for `sum()` returns an `int`,
    the version in `LongStream` returns a `long` and the version in `DoubleStream`
    returns a `double`.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先来考察 `sum()` 方法。注意，它不返回 `Optional`，而其他所有方法都返回。这是因为对于空流的求和，`0` 是一个有效的返回值。换句话说，如果你在执行
    `sum()` 时流为空——可能所有数据都被过滤掉了——那么 `0` 是一个有效的返回值。然而，表中的其他方法在这种情况下需要返回一个空的 `Optional`。`IntStream`
    的 `sum()` 返回一个 `int`，`LongStream` 中的版本返回一个 `long`，而 `DoubleStream` 中的版本返回一个 `double`。
- en: Regarding `min()` and `max()`, both `IntStream` versions return an `OptionalInt`;
    both `LongStream` versions return an `OptionalLong` and both `DoubleStream` versions
    return an `OptionalDouble`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 `min()` 和 `max()`，`IntStream` 的两个版本都返回 `OptionalInt`；`LongStream` 的两个版本都返回
    `OptionalLong`，而 `DoubleStream` 的两个版本都返回 `OptionalDouble`。
- en: The `average()` method is a little different because of the possibility of decimal
    places regardless of the type being totaled. So all three primitive stream types,
    namely `IntStream`, `LongStream`, and `DoubleStream` return an `OptionalDouble`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`average()` 方法略有不同，因为无论总计数类型如何，都存在小数位。所以三种原始流类型，即 `IntStream`、`LongStream`
    和 `DoubleStream` 都返回 `OptionalDouble`。'
- en: Let us examine them in code (PrimitiveStreams.java in the repo). Firstly, *Figure
    16**.10* presents `min()`, `max()` and `average()`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过代码（repo中的PrimitiveStreams.java）来检查它们。首先，**图16**.10展示了`min()`、`max()`和`average()`。
- en: '![Figure 16.10 – The min(), max() and average() operations in code](img/B19793_16_10.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![图16.10 – 代码中的min()、max()和average()操作](img/B19793_16_10.jpg)'
- en: Figure 16.10 – The min(), max() and average() operations in code
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.10 – 代码中的min()、max()和average()操作
- en: 'In this figure, we start with the following code:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图中，我们从以下代码开始：
- en: '[PRE20]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Firstly, we create a stream of `int` primitives. We then execute the terminal
    operation `max()`, which starts the stream and calculates the maximum number in
    the stream, which is 30\. No need for any `Comparator` or accumulator here! We
    then use the `ifPresent(IntConsumer)` from `OptionalInt` (there are equivalents
    for `OptionalDouble` and `OptionalLong`). What this method means, is that, if
    there is a value *present* in the `OptionalInt`, output it. If the optional is
    empty, nothing is printed.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个`int`原始流。然后执行终端操作`max()`，它启动流并计算流中的最大数，即30。这里不需要任何`Comparator`或累加器！然后我们使用`OptionalInt`的`ifPresent(IntConsumer)`（对于`OptionalDouble`和`OptionalLong`也有等效方法）。这个方法的意思是，如果`OptionalInt`中存在值，则输出它。如果可选对象为空，则不打印任何内容。
- en: 'The next code segment of interest is:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 下一段有趣的代码是：
- en: '[PRE21]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In this code segment, we create a `DoubleStream` based on the values provided
    in the varargs argument. Using `min()`, we stream the values and calculate the
    minimum value. The `orElseThrow()` method means: if there is a value present,
    return that value; otherwise throw a `NoSuchElementException`.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码段中，我们根据提供的varargs参数创建一个`DoubleStream`。使用`min()`，我们流式传输值并计算最小值。`orElseThrow()`方法意味着：如果存在值，则返回该值；否则抛出`NoSuchElementException`。
- en: 'The last code segment is:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一段代码是：
- en: '[PRE22]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Here, we create a `LongStream` based on the values provided in the varargs
    argument. This is followed by executing `average()`, which both streams the values
    and calculates their average. The `orElseGet(DoubleSupplier)` method means: if
    there is a value present, return that value; otherwise return the value from the
    supplying function (a random number).'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们根据提供的varargs参数创建一个`LongStream`。随后执行`average()`，它既流式传输值又计算它们的平均值。`orElseGet(DoubleSupplier)`方法意味着：如果存在值，则返回该值；否则返回供应函数（一个随机数）的值。
- en: Let us now examine `sum()`. It is easy to see why primitive streams are useful
    in the next example, *Figure 16**.11*.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在检查`sum()`。很容易看出原始流在下一个示例（*图16**.11*）中的有用性。
- en: '![Figure 16.11 - The sum() primitive operation](img/B19793_16_11.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![图16.11 - sum()原始操作](img/B19793_16_11.jpg)'
- en: Figure 16.11 - The sum() primitive operation
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.11 - sum()原始操作
- en: 'In this figure, we start out with the following:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图中，我们首先从以下内容开始：
- en: '[PRE23]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This code creates an `int` primitive stream directly using the `IntStream.of()`
    method and uses the `sum()` terminal method to stream the numbers and return the
    sum, which is 9.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码直接使用`IntStream.of()`方法创建一个`int`原始流，并使用`sum()`终端方法流式传输数字并返回总和，即9。
- en: 'The rest of the example code, contrasts `reduce()` from `Stream<T>` and `sum()`
    from `IntStream`. Let us focus on `reduce()` first:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 示例代码的其余部分，对比了`Stream<T>`的`reduce()`和`IntStream`的`sum()`。让我们首先关注`reduce()`：
- en: '[PRE24]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Initially, we stream a list of `Integer`s into a `Stream<Integer>` and them
    sum them up by passing an accumulator function argument to `reduce()`.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，我们将一个`Integer`列表流式传输到一个`Stream<Integer>`中，然后通过传递累加函数参数给`reduce()`来求和。
- en: 'Now we will focus on how to do the same thing using `sum()`:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将关注如何使用`sum()`做同样的事情：
- en: '[PRE25]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Firstly, we stream the same numbers as a `Stream<Integer>` again - we do not
    have a stream of primitives at this point. The second line shows how easy it is
    to convert from a `Stream<Integer>` to a `Stream` of `int` primitives. Using the
    `Stream` interfaces `mapToInt()` function; we pass in our function, which takes
    in an `Integer` and returns the `int` primitive wrapped by that `Integer`. In
    this code, we are availing of auto-unboxing by simply specifying the identifier
    `n` on both sides of the arrow token in the lambda. Now that we have an `IntStream`
    object we can use the `sum()` method - which streams the integers and returns
    the sum of 6\. Note that we have deliberately left the return types visible in
    the code. This helps explain what is happening in the pipeline. In reality, you
    would code it much more concisely as follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们再次以`Stream<Integer>`的形式流式传输相同的数字 - 目前我们还没有原始类型的流。第二行显示了将`Stream<Integer>`转换为`int`原始类型的`Stream`有多容易。使用`Stream`接口的`mapToInt()`函数；我们传递我们的函数，该函数接受一个`Integer`并返回由该`Integer`包装的`int`原始类型。在这段代码中，我们通过在箭头符号两侧简单地指定标识符`n`来利用自动拆箱。现在我们有了`IntStream`对象，我们可以使用`sum()`方法
    - 该方法流式传输整数并返回6的总和。请注意，我们故意在代码中保留了返回类型。这有助于解释管道中发生的事情。实际上，你会更简洁地编写如下：
- en: '[PRE26]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: With each of the primitive streams, you can get summarizing statistics (summary
    data about the elements in the stream). Let us look at these in action. *Figure
    16**.12* presents `IntSummaryStatistics`.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个原始流，你可以获取汇总统计信息（关于流中元素的汇总数据）。让我们看看这些在实际中的应用。*图16.12*展示了`IntSummaryStatistics`。
- en: '![Figure 16.12 - IntSummaryStatistics in code](img/B19793_16_12.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![图16.12 - 代码中的IntSummaryStatistics](img/B19793_16_12.jpg)'
- en: Figure 16.12 - IntSummaryStatistics in code
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.12 - 代码中的IntSummaryStatistics
- en: 'In this example, the streams are being passed in via the following method calls:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，流是通过以下方法调用来传递的：
- en: '[PRE27]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The first invocation passes in a valid stream of integers whereas the second
    stream is empty. Once inside the `stats()` method, the terminal operation `summaryStatistics()`
    is executed on the `IntStream` passed in. The resultant `IntSummaryStatistics`
    object is now available to inspect for summary data:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次调用传递了一个有效的整数流，而第二个流是空的。一旦进入`stats()`方法，终端操作`summaryStatistics()`就会在传入的`IntStream`上执行。现在可以检查`IntSummaryStatistics`对象以获取汇总数据：
- en: '[PRE28]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The output for the first stream (5, 10, 15 and 20) is:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 第一流的输出（5，10，15和20）如下：
- en: '[PRE29]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '`5` is output by `getMin()`; `20` is output by `getMax()`; `12.5` is output
    by `getAverage()`; `4` is output by `getCount()` and `50` is output by `getSum()`.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`getMin()`输出`5`；`getMax()`输出`20`；`getAverage()`输出`12.5`；`getCount()`输出`4`和`getSum()`输出`50`。'
- en: 'The output for the empty stream is:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 空流的输出如下：
- en: '[PRE30]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '`2147483647` (which is `Integer.MAX_VALUE`) is output by `getMin()`; `-2147483648`
    (`Integer.MIN_VALUE`) is output by `getMax()`; 0.0 is output by `getAverage()`;
    0 is output by `getCount()` and 0 is output by `getSum()`.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`2147483647`（即`Integer.MAX_VALUE`）由`getMin()`输出；`-2147483648`（`Integer.MIN_VALUE`）由`getMax()`输出；`getAverage()`输出`0.0`；`getCount()`和`getSum()`都输出`0`。'
- en: With primitive streams there are now extra functional interfaces that we need
    to be aware of.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在原始流中，现在有额外的功能接口需要我们注意。
- en: New primitive stream interfaces
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 新的原始流接口
- en: 'There are many new functional interfaces to be aware of. Thankfully, they follow
    a consistent naming pattern. *Table 16.3* outlines the more common ones. For further
    details please see the JavaDocs at: [https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/function/package-summary.html](https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/function/package-summary.html).'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多新的功能接口需要我们注意。幸运的是，它们遵循一致的命名模式。*表16.3*概述了更常见的接口。有关更多详细信息，请参阅JavaDocs：[https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/function/package-summary.html](https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/function/package-summary.html)。
- en: '![Tables 16.3 (a) and (b) - New primitive stream functional interfaces](img/B19793_16_Table_03.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![表16.3（a）和（b）- 新的原始流功能接口](img/B19793_16_Table_03.jpg)'
- en: Tables 16.3 (a) and (b) - New primitive stream functional interfaces
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 表16.3（a）和（b）- 新的原始流功能接口
- en: In this figure, table A is on the left, with table B on the right. Each table
    has two columns - one for the functional interface name and one for its functional
    method.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图中，表A在左边，表B在右边。每个表都有两列 - 一列是功能接口名称，另一列是其功能方法。
- en: 'We have deliberately included the generically marked functional interfaces
    encountered earlier. This is to help contrast them with their primitive counterparts.
    The previous functional interfaces that we came across are: `Supplier<T>,` `Consumer<T>`,
    `BiConsumer<T, U>`, `Predicate<T>`, `BiPredicate<T, U>`, `Function<T, R>`, `BiFunction<T,
    U, R>`, `UnaryOperator<T>` and `BinaryOperator<T>`. Note the generic types in
    them all. Very few primitive functional interfaces use generics, as they are typed
    for a particular primitive.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们故意包括了之前遇到的泛型标记的功能接口。这是为了帮助它们与它们的原生对应者进行对比。我们之前遇到的功能接口是：`Supplier<T>、Consumer<T>、BiConsumer<T,
    U>、Predicate<T>、BiPredicate<T, U>、Function<T, R>、BiFunction<T, U, R>、UnaryOperator<T>`和`BinaryOperator<T>`。注意它们中的泛型类型。非常少的功能接口使用泛型，因为它们是为特定的原生类型类型化的。
- en: We have color-coordinated the interfaces in order to group them. So for example,
    in table A the yellow colored interfaces are the suppliers. `Supplier<T>` with
    its `T get()` functional method - as stated, this is included for comparison purposes.
    `DoubleSupplier` is the interface for generating `double` primitives. Its functional
    method is `getAsDouble()` and its return type is a `double`. The `IntSupplier`
    and `LongSupplier` interfaces follow the same pattern.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对接口进行了颜色协调，以便将它们分组。例如，在表格A中，黄色标注的接口是供应商。`Supplier<T>`具有`T get()`功能方法——如前所述，这是为了比较目的而包含的。`DoubleSupplier`是生成`double`原生类型的接口。其功能方法是`getAsDouble()`，其返回类型是`double`。`IntSupplier`和`LongSupplier`接口遵循相同的模式。
- en: 'Still in table A, the consumers are next, in green. `DoubleConsumer` “accepts”
    a `double` primitive and returns nothing. `IntConsumer` accepts in an `int`, returns
    nothing; and `LongConsumer` accepts in a `long`, returns nothing. All the functional
    methods are called `accept()`. Note the pattern for naming: suppliers use `DoubleSupplier`;
    consumers use `DoubleConsumer`.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然在表格A中，消费者接下来，用绿色标注。`DoubleConsumer`“接受”一个`double`原生类型并返回空值。`IntConsumer`接受一个`int`，返回空值；`LongConsumer`接受一个`long`，返回空值。所有功能方法都被称为`accept()`。注意命名模式：供应商使用`DoubleSupplier`；消费者使用`DoubleConsumer`。
- en: This naming convention continues with the predicates (blue). We have `DoublePredicate`
    that “tests” a `double` and returns a `boolean`. `IntPredicate` and `LongPredicate`
    behave in a similar manner - a primitive type parameter and a return type `boolean`.
    All the functional methods are called `test()`.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这种命名约定在谓词（蓝色）中继续。我们有一个`DoublePredicate`，它“测试”一个`double`并返回一个`boolean`。`IntPredicate`和`LongPredicate`以类似的方式表现——一个原生类型参数和一个返回类型`boolean`。所有功能方法都被称为`test()`。
- en: In table B, we have the functions, in yellow. We have `DoubleFunction<R>` that
    “applies” a `double` and returns the type `R`. The functions are a case where
    generics are used to represent the type being returned. However, the primitive
    being applied is the important aspect here. `IntFunction<R>` and `LongFunction<R>`
    behave in a similar manner - a primitive type parameter and a return type `R`.
    All the functional methods are called `apply()`.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在表格B中，我们看到了函数，用黄色标注。我们有一个`DoubleFunction<R>`，它“应用”一个`double`并返回类型`R`。函数是一个使用泛型来表示返回类型的例子。然而，被应用的原生类型在这里是重要的方面。`IntFunction<R>`和`LongFunction<R>`以类似的方式表现——一个原生类型参数和一个返回类型`R`。所有功能方法都被称为`apply()`。
- en: Lastly, in table B, we have the primitive versions of `UnaryOperator<T>` and
    `BinaryOperator<T>`. The `double` primitive version of `UnaryOperator<T>` is `DoubleUnaryOperator`
    (note the word `Double` at the start again). Recall that unary functions are functions
    that accept in one parameter and return a value; where both types are the same.
    Therefore, `DoubleUnaryOperator` has a `double` parameter and a `double` return
    type. `IntUnaryOperator` and `LongUnaryOperator` follow the same pattern.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在表格B中，我们有`UnaryOperator<T>`和`BinaryOperator<T>`的原生版本。`UnaryOperator<T>`的`double`原生版本是`DoubleUnaryOperator`（注意开头再次出现的单词`Double`）。回想一下，一元函数是接受一个参数并返回值的函数；其中两种类型都是相同的。因此，`DoubleUnaryOperator`有一个`double`参数和一个`double`返回类型。`IntUnaryOperator`和`LongUnaryOperator`遵循相同的模式。
- en: The `DoubleBinaryOperator`, `IntBinaryOperator` and `LongBinaryOperator` interfaces
    only differ from their unary counterparts in the number of parameters they take
    in. Therefore, `DoubleBinaryOperator` takes in two `double`s, `IntBinaryOperator`
    takes in two `int`s and `LongBinaryOperator` takes in two `long`s.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`DoubleBinaryOperator`、`IntBinaryOperator`和`LongBinaryOperator`接口与它们的一元对应者仅在它们接受的参数数量上有所不同。因此，`DoubleBinaryOperator`接受两个`double`，`IntBinaryOperator`接受两个`int`，`LongBinaryOperator`接受两个`long`。'
- en: There are other ways to create streams and that is by mapping from other streams.
    Let us examine that now.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 创建流还有其他方法，那就是从其他流映射。现在让我们来探讨这一点。
- en: Mapping streams
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 流映射
- en: Again, there are many new functional interfaces to be aware of; and again, thankfully,
    they follow a consistent naming pattern. *Table 16.4* outlines the more common
    ones.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，有许多新的函数式接口需要我们注意；幸运的是，它们遵循一致的命名模式。*表 16.4* 列出了更常见的接口。
- en: '![Table 16.4 - Mapping streams](img/B19793_16_Table_04.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![表 16.4 - 流映射](img/B19793_16_Table_04.jpg)'
- en: Table 16.4 - Mapping streams
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 表 16.4 - 流映射
- en: In this table, the rows represent the source stream class and the columns represent
    the target stream class. Again, we use color to help organize our explanations.
    The yellow boxes represent situations where the source and target classes are
    the same. So, for example, if you are going from a `DoubleStream` to another `DoubleStream`,
    the method is `map(DoubleUnaryOperator)`. The functional method is also listed
    - so for this example, `DoubleUnaryOperator`‘s functional method is `double applyAsDouble(double)`.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个表中，行代表源流类，列代表目标流类。再次，我们使用颜色来帮助组织我们的解释。黄色框代表源和目标类相同的情况。例如，如果您从 `DoubleStream`
    转换到另一个 `DoubleStream`，则方法为 `map(DoubleUnaryOperator)`。函数方法也列出了——在这个例子中，`DoubleUnaryOperator`
    的函数方法是 `double applyAsDouble(double)`。
- en: Let us examine the brown boxes. Each of these uses a `mapToObj()` method as
    the source is a primitive stream and the target is a stream of objects. The source
    stream hints at the function to be used. For example, if the source is a `DoubleStream`
    then the `DoubleFunction` interface applies, as you are mapping from a `double`
    primitive to a type `R`. This is specified in the functional method `R` `apply(double
    value)`.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查棕色框。这些中的每一个都使用 `mapToObj()` 方法作为源，因为源是原始流，目标是对象流。源流暗示了要使用的函数。例如，如果源是 `DoubleStream`，则适用
    `DoubleFunction` 接口，因为您正在将 `double` 原始类型映射到类型 `R`。这指定在函数方法 `R apply(double value)`
    中。
- en: Next the green boxes. The target stream is `DoubleStream` and hence the method
    name is `mapToDouble()`. If the source stream is a stream of objects then the
    interface is `ToDoubleFunction<T>`. Its functional method is `double` `applyAsDouble(T
    value)`, so a type `T` is input and a `double` primitive is output. Just what
    you would expect, when going from an object of type `T` to a primitive `double`.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是绿色框。目标流是 `DoubleStream`，因此方法名为 `mapToDouble()`。如果源流是对象流，则接口是 `ToDoubleFunction<T>`。其函数方法是
    `double applyAsDouble(T value)`，所以输入类型是 `T`，输出是 `double` 原始类型。正如从类型 `T` 的对象到原始
    `double` 类型转换时预期的那样。
- en: 'Staying with the target stream of `DoubleStream`, if the source was an `IntStream`,
    then the primitives involved are in the name of the interface: `IntToDoubleFunction`.
    No surprise that its functional method is `double` `applyAsDouble(int)`. If the
    source was a `LongStream`, then the primitives involved are again in the name
    of the interface: `LongToDoubleFunction`. No surprise either that its functional
    method is `double` `applyAsDouble(long)`.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 保持目标流为 `DoubleStream`，如果源是 `IntStream`，则涉及的原始类型在接口名称中：`IntToDoubleFunction`。它的函数方法
    `double applyAsDouble(int)` 也没有什么意外。如果源是 `LongStream`，则涉及的原始类型再次在接口名称中：`LongToDoubleFunction`。它的函数方法
    `double applyAsDouble(long)` 也没有什么意外。
- en: The blue boxes represent a target stream of `IntStream`. The method name is
    `mapToInt()`. The functional interfaces used as parameters and their functional
    methods, follow the same naming pattern as outlined for `DoubleStream`.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 蓝色框代表目标流为 `IntStream` 的情况。方法名为 `mapToInt()`。用作参数的函数式接口及其函数方法遵循为 `DoubleStream`
    概述的相同命名模式。
- en: Lastly, the grey boxes represent a target stream of `LongStream`. The method
    name is `mapToLong()`. A similar naming pattern is again applied to the functional
    interfaces and their functional methods as shown in `DoubleStream` and `IntStream`.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，灰色框代表 `LongStream` 的目标流。方法名为 `mapToLong()`。类似的命名模式再次应用于函数式接口及其函数方法，如 `DoubleStream`
    和 `IntStream` 中所示。
- en: Let us look at some code examples. We will start with mapping from streams of
    objects.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些代码示例。我们将从对象流映射开始。
- en: Mapping from Object streams
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从对象流映射
- en: The first example will have a `Stream<String>` as the source and map to the
    various other streams accordingly. *Figure 16**.13* represents the code (`MappingStreams.java`
    in the repo).
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个例子将以 `Stream<String>` 作为源流，并相应地映射到各种其他流。*图 16**.13* 表示代码（存储库中的 `MappingStreams.java`）。
- en: '![Figure 16.13 - Mapping Object streams](img/B19793_16_13.jpg)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![图 16.13 - 映射对象流](img/B19793_16_13.jpg)'
- en: Figure 16.13 - Mapping Object streams
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.13 - 映射对象流
- en: 'In this figure, we are mapping a `Stream<String>` to all the other stream types,
    including `Stream<String>` itself. The first example is:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图中，我们将 `Stream<String>` 映射到所有其他流类型，包括 `Stream<String>` 本身。第一个示例是：
- en: '[PRE31]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In this case, the `map(Function<T,R>)` maps from `String` to `String`. The function
    converts the string to uppercase. The `forEach()` terminal operation starts the
    streaming process and outputs the strings.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`map(Function<T,R>)` 将 `String` 映射到 `String`。该函数将字符串转换为大写。`forEach()`
    终端操作启动流式传输过程并输出字符串。
- en: 'The second example is:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个示例是：
- en: '[PRE32]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This time the `Stream<String>` is mapped to a `DoubleStream` (of `double` primitives).
    Notice that we must re-stream the source as the previous `forEach()` closed it.
    This pipeline uses the `mapToDouble(ToDoubleFunction<T>)` to map from a `String`
    to a `double` primitive. The function this time use the `length()` of the `String`
    which is an `int`. This `int` is upcast to a `double` in the background. The `forEach()`starts
    the stream and outputs the `double` values.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，`Stream<String>` 被映射到 `DoubleStream`（`double` 原始类型）。请注意，我们必须重新流化源，因为之前的 `forEach()`
    已经关闭了它。这个管道使用 `mapToDouble(ToDoubleFunction<T>)` 将 `String` 映射到 `double` 原始类型。这次函数使用
    `String` 的 `length()`，它是一个 `int`。这个 `int` 在后台被向上转型为 `double`。`forEach()` 启动流并输出
    `double` 值。
- en: 'The third example is:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个示例是：
- en: '[PRE33]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This time the `Stream<String>` is mapped to an `IntStream`. Again we must re-stream
    the source. This pipeline uses the `mapToInt(ToIntFunction<T>)` to map from a
    `String` to an `int` primitive. We again use the `length()` function of `String`.
    As this is an `int`, no upcasting is required in the background. The `forEach()`
    terminal operation is used to start the stream and output the `int` values.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，`Stream<String>` 被映射到 `IntStream`。我们再次需要重新流化源。这个管道使用 `mapToInt(ToIntFunction<T>)`
    将 `String` 映射到 `int` 原始类型。我们再次使用 `String` 的 `length()` 函数。由于这是一个 `int`，不需要在后台进行向上转型。使用
    `forEach()` 终端操作来启动流并输出 `int` 值。
- en: 'The last example is:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个示例是：
- en: '[PRE34]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Here, the `Stream<String>` is mapped to a `LongStream`. This pipeline uses the
    `mapToLong(ToLongFunction<T>)` to map from a `String` to a `long` primitive. As
    the `length()` of `String` returns an `int`, upcasting is done in the background.
    The `long` values are output as part of the `forEach()` terminal operation.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`Stream<String>` 被映射到 `LongStream`。这个管道使用 `mapToLong(ToLongFunction<T>)`
    将 `String` 映射到 `long` 原始类型。由于 `String` 的 `length()` 返回一个 `int`，后台进行了向上转型。`long`
    值作为 `forEach()` 终端操作的一部分输出。
- en: Now let us examine code examples mapping from streams of primitives.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来检查从原始数据流映射的代码示例。
- en: Mapping from primitive streams
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从原始流映射
- en: In this example, we are mapping from streams of primitives to other stream types.
    *Figure 16**.14* presents the code (`MappingStreams.java`).
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们是从原始数据流映射到其他流类型。*图 16.14* 展示了代码（`MappingStreams.java`）。
- en: '![Figure 16.14 - Mapping primitive streams](img/B19793_16_14.jpg)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![图 16.14 - 映射原始流](img/B19793_16_14.jpg)'
- en: Figure 16.14 - Mapping primitive streams
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.14 - 映射原始流
- en: In this example, we are streaming `int` primitives using `IntStream.of()`, and
    converting the `IntStream` to a `Stream<String>`, `DoubleStream`, `IntStream`
    and `LongStream` in turn.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用 `IntStream.of()` 流式传输 `int` 原始类型，并依次将 `IntStream` 转换为 `Stream<String>`、`DoubleStream`、`IntStream`
    和 `LongStream`。
- en: 'Here is the first example:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是第一个示例：
- en: '[PRE35]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This code represents a sample pipeline for streaming `int` primitives and mapping
    them to a stream of `String` objects. The `mapToObj()` method is important here.
    It’s signature is: `Stream<R> mapToObj(IntFunction<R>)`. The lambda passed in
    is easier to understand when we look at the functional method of the functional
    interface `IntFunction<R>`. The functional method is `R apply(int value)`. In
    our example, the `int` primitive is passed in as `n` and the `String` returned
    (represented by `R` in the method signature) is the string formed by prepending
    `"Number:"` in front of the `int`. Recall that when you have a string on the left
    or the right side (or both) of a `+` the result is a `String`. The `forEach()`
    streams the `int` primitives and outputs the `Stream<String>`.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码代表了一个用于流式传输 `int` 原始值并将它们映射到 `String` 对象流的一个示例管道。`mapToObj()` 方法在这里很重要。它的签名是：`Stream<R>
    mapToObj(IntFunction<R>)`。当查看函数式接口 `IntFunction<R>` 的函数方法时，传入的 lambda 更容易理解。函数方法是
    `R apply(int value)`。在我们的例子中，将 `int` 原始值作为 `n` 传入，返回的 `String`（在方法签名中用 `R` 表示）是在
    `int` 前面添加 `"Number:"` 形成的字符串。回想一下，当你在 `+` 的左右两侧（或两侧都是）有一个字符串时，结果是 `String`。`forEach()`
    流式传输 `int` 原始值并输出 `Stream<String>`。
- en: 'The next example is:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个例子是：
- en: '[PRE36]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This code is mapping from an `IntStream` to a `DoubleStream`. The `mapToDouble()`
    method is important here. It’s signature is:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码是将 `IntStream` 映射到 `DoubleStream`。`mapToDouble()` 方法在这里很重要。它的签名是：
- en: '`DoubleStream` `mapToDouble(IntToDoubleFunction)`. The functional method for
    `IntToDoubleFunction` is `double applyAsDouble(int value)`. Thus, our lambda passes
    in an `int` and returns a `double`. The cast is not necessary and it just there
    to emphasize that a `double` primitive is returned.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '`DoubleStream mapToDouble(IntToDoubleFunction)`。`IntToDoubleFunction` 的函数方法是
    `double applyAsDouble(int value)`。因此，我们的 lambda 传入一个 `int` 并返回一个 `double`。强制类型转换不是必需的，它只是用来强调返回的是一个
    `double` 原始值。'
- en: 'Here is the next example:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这是下一个例子：
- en: '[PRE37]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Here we are mapping an `IntStream` to another `IntStream`. The method `IntStream
    map(IntUnaryOperator)` is used. Its functional method is:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将 `IntStream` 映射到另一个 `IntStream`。使用 `IntStream map(IntUnaryOperator)`
    方法。它的函数方法是：
- en: '`int applyAsInt(int value)` so we pass in an `int` and get back an `int`. Our
    lambda is simply multiplying the `int` coming in by 2 and returning the result.'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '`int applyAsInt(int value)` 因此我们传入一个 `int` 并返回一个 `int`。我们的 lambda 简单地将传入的 `int`
    乘以 2 并返回结果。'
- en: 'And the last example:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个例子：
- en: '[PRE38]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This code maps an `IntStream` to a `LongStream`. The method `LongStream mapToLong(IntToLongFunction)`
    is used. Its functional method is:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将 `IntStream` 映射到 `LongStream`。使用 `LongStream mapToLong(IntToLongFunction)`
    方法。它的函数方法是：
- en: '`long applyAsLong(int value)` so we pass in an `int` and get back a `long`.
    Again, the cast is not necessary, it is simply emphasizing that a `long` primitive
    is returned.'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '`long applyAsLong(int value)` 因此我们传入一个 `int` 并返回一个 `long`。同样，强制类型转换不是必需的，它只是用来强调返回的是一个
    `long` 原始值。'
- en: That completes our coverage of mapping streams. Let us now move on to examining
    `Optional`s.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 这样我们就完成了对映射流的覆盖。现在让我们转向考察 `Optional`。
- en: Explaining Optionals
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解释 `Optional`
- en: 'An `Optional` can be thought of as a container that may or may not be empty.
    As per the API, the container “may or may not contain a non-`null` value”. An
    `Optional` is primarily used as a method return type where there is a real need
    to represent “no result” and when returning `null` could cause errors. Before
    Java 8, programmers would return `null` but now, since Java 8, we can return an
    *empty* `Optional` instead. This has several advantages:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将 `Optional` 视为一个可能为空也可能不为空的容器。根据 API，容器“可能包含或不包含非 `null` 值”。`Optional` 主要用作方法返回类型，当确实需要表示“无结果”且返回
    `null` 可能导致错误时。在 Java 8 之前，程序员会返回 `null`，但现在，自从 Java 8 以来，我们可以返回一个 *空的* `Optional`。这有几个优点：
- en: Reduces the risk of `NullPointerException`s
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 降低 `NullPointerException` 的风险
- en: By using `Optional` as the return type, the API can now clearly state that there
    may not be a value returned
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用 `Optional` 作为返回类型，API 现在可以清楚地声明可能不会返回值
- en: The `Optional` API facilitates the functional programming style
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Optional` API 促进了函数式编程风格'
- en: 'As well as `Optional<T>`, there are `Optional`s for the primitive types also;
    namely: `OptionalInt`, `OptionalDouble` and `OptionalLong`. We will examine them
    later.'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `Optional<T>`，还有原始类型的 `Optional`；即：`OptionalInt`、`OptionalDouble` 和 `OptionalLong`。我们将在稍后考察它们。
- en: Let us first look at how to create `Optional`s.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看如何创建 `Optional`。
- en: Creating Optionals
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 `Optional`
- en: The API provides several `static` methods for this purpose. Let’s start with
    `Optional.of(T)`.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: API 提供了几个 `static` 方法用于此目的。让我们从 `Optional.of(T)` 开始。
- en: '[PRE39]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The `value` parameter is wrapped in an `Optional`. The `value` passed must be
    a non-`null` value. If `null` is passed in, a `NullPointerException` results.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '`value` 参数被包裹在一个 `Optional` 中。传递的 `value` 必须是一个非 `null` 值。如果传递了 `null`，则会产生一个
    `NullPointerException`。'
- en: Now, let us look at `Optional.empty()`. This is how you create an empty Optional
    instance.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看 `Optional.empty()`。这就是创建一个空的 `Optional` 实例的方法。
- en: '[PRE40]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Lastly, we will examine `Optional.ofNullable(T)`.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将检查 `Optional.ofNullable(T)`。
- en: '[PRE41]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'If the given `value` is non-`null`, this method returns the wrapped `value`
    in an `Optional`. If `null` is passed in, an empty `Optional` is returned. If
    we examine the following code:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 如果给定的 `value` 是非 `null`，此方法返回一个包裹在 `Optional` 中的 `value`。如果传递了 `null`，则返回一个空的
    `Optional`。如果我们检查以下代码：
- en: '[PRE42]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Both of these lines do the same thing. The first line is shorthand for the
    ternary operator on the second line. The ternary operator is expressing the following:
    if `value` is `null`, `opt2` is assigned an empty `Optional`; otherwise, `opt2`
    is assigned the wrapped `value`.'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 这两行做的是同一件事。第一行是第二行三目运算符的简写。三目运算符表示以下内容：如果 `value` 是 `null`，则 `opt2` 被分配一个空的
    `Optional`；否则，`opt2` 被分配包裹的 `value`。
- en: '*Figure 16**.15* presents them in code (`Optionals.java` in the repo).'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 16.15* 以代码形式（在仓库中的 `Optionals.java`）展示了它们。'
- en: '![Figure 16.15 - Creating Optionals](img/B19793_16_15.jpg)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
  zh: '![图 16.15 - 创建 Optionals](img/B19793_16_15.jpg)'
- en: Figure 16.15 - Creating Optionals
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.15 - 创建 Optionals
- en: 'The first example here creates an empty `Optional`:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，第一个示例创建了一个空的 `Optional`：
- en: '[PRE43]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: We use the `Optional.empty()` method to create an empty `Optional`. The next
    line is commented out because if you execute `get()` on an empty `Optional`, you
    will get a `NoSuchElementException` exception. The last line shows the functional
    style `ifPresent(Consumer)`. If a value is present, the given consumer is applied
    to the value; otherwise it does nothing. In this case, it does nothing as the
    `Optional` is empty.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `Optional.empty()` 方法来创建一个空的 `Optional`。下一行被注释掉了，因为如果你在一个空的 `Optional`
    上执行 `get()`，你会得到一个 `NoSuchElementException` 异常。最后一行显示了函数式风格的 `ifPresent(Consumer)`。如果存在值，给定的消费者会被应用到该值上；否则，它什么都不做。在这种情况下，由于
    `Optional` 是空的，所以它什么都不做。
- en: 'The next example creates a non-empty `Optional`:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个示例创建了一个非空的 `Optional`：
- en: '[PRE44]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'This time we create an `Optional` using `Optional.of()`, with the value 23\.
    The second line shows that you will get a `NullPointerException` if you pass `null`
    to `Optional.of()`. The `ifPresent()` now executes the consumer passed, which
    outputs `"``opt2: 23"`.'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '这次我们使用 `Optional.of()` 创建了一个 `Optional`，值为 23。第二行显示，如果你将 `null` 传递给 `Optional.of()`，你会得到一个
    `NullPointerException`。现在 `ifPresent()` 执行传递的消费者，它输出了 `"``opt2: 23"`。'
- en: 'The next example uses `Optional.ofNullable()`:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个示例再次使用了 `Optional.ofNullable()`：
- en: '[PRE45]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Here we create an `Optional` using `Optional.ofNullable()`, also with the value
    23\. As the `Optional` is not empty, the consumer passed to `ifPresent()` outputs
    `"``opt3: 23"`.'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '我们在这里使用 `Optional.ofNullable()` 创建了一个 `Optional`，并且值是 23。由于 `Optional` 不是空的，传递给
    `ifPresent()` 的消费者输出了 `"``opt3: 23"`。'
- en: 'Here is the last example:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是最后一个示例：
- en: '[PRE46]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: In this example, we use `Optional.ofNullable()` again, but this time, we pass
    in `null`. Rather than getting an exception (which is what `Optional.of(null)`
    would generate), we get an `Optional`. As the `Optional` is empty, the `ifPresent()`
    does nothing. The `isEmpty()` proves that the `Optional` is in fact empty resulting
    in `"opt4 is empty!"` being output.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们再次使用了 `Optional.ofNullable()`，但这次我们传递了 `null`。而不是得到一个异常（这是 `Optional.of(null)`
    会产生的），我们得到了一个 `Optional`。由于 `Optional` 是空的，`ifPresent()` 什么都不做。`isEmpty()` 证明
    `Optional` 确实是空的，因此输出了 `"opt4 is empty!"`。
- en: Now that we know how to create `Optional`s, let us explore the API methods available.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何创建 `Optional`s，让我们探索可用的 API 方法。
- en: Using the Optional API
  id: totrans-286
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Optional API
- en: '*Table 16.5* represents the instance methods in `Optional`.'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '*表 16.5* 表示 `Optional` 中的实例方法。'
- en: '| **Method** | **What happens if Optional** **is empty** | **What happens if
    Optional has** **a value** |'
  id: totrans-288
  prefs: []
  type: TYPE_TB
  zh: '| **方法** | **如果 Optional 为空会发生什么** | **如果 Optional 有值会发生什么** |'
- en: '| --- | --- | --- |'
  id: totrans-289
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `get()` | Throws `NoSuchElementException` | Returns the value |'
  id: totrans-290
  prefs: []
  type: TYPE_TB
  zh: '| `get()` | 抛出 `NoSuchElementException` | 返回值 |'
- en: '| `isPresent()` | Returns `false` | Returns `true` |'
  id: totrans-291
  prefs: []
  type: TYPE_TB
  zh: '| `isPresent()` | 返回 `false` | 返回 `true` |'
- en: '| `ifPresent(Consumer)` | Does nothing | Executes `Consumer` with value |'
  id: totrans-292
  prefs: []
  type: TYPE_TB
  zh: '| `ifPresent(Consumer)` | 什么都不做 | 使用值执行 `Consumer` |'
- en: '| `orElse(T otherValue)` | Returns `otherValue` | Returns the value |'
  id: totrans-293
  prefs: []
  type: TYPE_TB
  zh: '| `orElse(T otherValue)` | 返回 `otherValue` | 返回值 |'
- en: '| `orElseGet(Supplier)` | Returns result of executing `Supplier` | Returns
    the value |'
  id: totrans-294
  prefs: []
  type: TYPE_TB
  zh: '| `orElseGet(Supplier)` | 返回执行 `Supplier` 的结果 | 返回值 |'
- en: '| `orElseThrow()` | Throws `NoSuchElementException` | Returns the value |'
  id: totrans-295
  prefs: []
  type: TYPE_TB
  zh: '| `orElseThrow()` | 抛出`NoSuchElementException` | 返回值 |'
- en: '| `orElseThrow(Supplier)` | Throws exception returned by `Supplier`. However,
    if `Supplier` is `null`, throws a `NullPointerException` | Returns the value |'
  id: totrans-296
  prefs: []
  type: TYPE_TB
  zh: '| `orElseThrow(Supplier)` | 抛出由`Supplier`返回的异常。然而，如果`Supplier`是`null`，则抛出`NullPointerException`
    | 返回值 |'
- en: Table 16.5 - Optional instance methods
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 表16.5 - Optional实例方法
- en: Many of these methods enable us to write code in a more concise and expressive
    manner. `ifPresent(Consumer)` is a very good example - rather than having in `if-else`
    statement, `ifPresent(Consumer)` removes the need to code the `else` part. Additionally,
    `ifPresent(Consumer)` helps us express our intent more clearly - if a value *is
    present*, do this; otherwise do nothing.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 许多这些方法使我们能够以更简洁和更富有表现力的方式编写代码。`ifPresent(Consumer)`是一个非常好的例子——与在`if-else`语句中相比，`ifPresent(Consumer)`消除了编写`else`部分的必要性。此外，`ifPresent(Consumer)`帮助我们更清楚地表达我们的意图——如果值*存在*，则执行此操作；否则不执行任何操作。
- en: '*Figure 16**.16* presents methods from the `Optional` API in code.'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '*图16*.16展示了`Optional` API中的方法。'
- en: '![Figure 16.16 - Optional methods in code](img/B19793_16_16.jpg)'
  id: totrans-300
  prefs: []
  type: TYPE_IMG
  zh: '![图16.16 - 代码中的Optional方法](img/B19793_16_16.jpg)'
- en: Figure 16.16 - Optional methods in code
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.16 - 代码中的Optional方法
- en: In this example, we will use both a non-null `Optional` and an empty `Optional`
    to test the various methods. Let us start with a valid non-null `Optional`.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将使用一个非空的`Optional`和一个空的`Optional`来测试各种方法。让我们从一个有效的非空`Optional`开始。
- en: Optional with a value
  id: totrans-303
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 带有值的Optional
- en: 'Firstly, we create an `Optional` wrapped around the `Double 60.0`:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个包裹着`Double 60.0`的`Optional`：
- en: '[PRE47]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'We then use `isPresent()` to ensure it is safe to execute the `get()` method,
    as executing `get()` on an empty `Optional` results in an exception:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用`isPresent()`来确保执行`get()`方法是安全的，因为在对空的`Optional`执行`get()`操作会导致异常：
- en: '[PRE48]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: As `isPresent()` returns `true`, it is safe to execute `get()`, which returns
    `60.0` and this is output to the screen.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`isPresent()`返回`true`，执行`get()`是安全的，它返回`60.0`并输出到屏幕。
- en: 'The next 2 lines are:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的两行是：
- en: '[PRE49]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: In this code segment, as there is a non-null value in `valueInOptional`, the
    consumer argument to `ifPresent()` is executed, and `60.0` is output to the screen.
    In addition, as we have a value in `valueInOptional`, the `orElse(T value)` method
    is not executed; meaning that `60.0` is output to the screen.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码段中，由于`valueInOptional`中有一个非空值，`ifPresent()`的消费者参数将被执行，并将`60.0`输出到屏幕。此外，由于我们在`valueInOptional`中有值，`orElse(T
    value)`方法不会执行；这意味着`60.0`被输出到屏幕。
- en: Empty Optional
  id: totrans-312
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 空的Optional
- en: 'Firstly, we create an empty `Optional` by passing in `null` to `ofNullable()`:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们通过将`null`传递给`ofNullable()`来创建一个空的`Optional`：
- en: '[PRE50]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'We then have:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们有：
- en: '[PRE51]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The `orElse(T value)` returns `NaN` and `orElseGet(Supplier)` executes the `Supplier`
    which is to generate a random number. Note that the `Supplier` must return a `Double`
    as that is the type of `emptyOptional`.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '`orElse(T value)`返回`NaN`，而`orElseGet(Supplier)`执行`Supplier`，用于生成一个随机数。请注意，`Supplier`必须返回一个`Double`，因为这是`emptyOptional`的类型。'
- en: 'Lastly, we have:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有：
- en: '[PRE52]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Both lines execute `orElseThrow()` and are mutually exclusive. What this means
    is that, to see the exception on the second line, comment out the first line.
    As the `Optional` is empty, the first line throws a `NoSuchElementException`.
    Assuming we comment out the first line and uncomment the second line, the `Supplier`
    passed in to `orElseThrow()` will return a `RuntimeException`. Note that we do
    not use the keyword `throw` in our `Supplier`. The `orElseThrow()` method will
    do that for us - our job is to give it, via the `Supplier`, an exception object
    to throw.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 两行都执行`orElseThrow()`，它们是互斥的。这意味着，要看到第二行的异常，请注释掉第一行。由于`Optional`是空的，第一行抛出`NoSuchElementException`。假设我们注释掉第一行并取消注释第二行，传递给`orElseThrow()`的`Supplier`将返回一个`RuntimeException`。请注意，我们不在`Supplier`中使用关键字`throw`。`orElseThrow()`方法会为我们做这件事——我们的工作是，通过`Supplier`给它提供一个要抛出的异常对象。
- en: Our last section regarding `Optional`s, are primitive `Optional`s.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`Optional`的最后一部分，是原始的`Optional`。
- en: Primitive Optionals
  id: totrans-322
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 原始Optional
- en: 'As stated earlier, there are `Optional`s for the primitive types also; namely:
    `OptionalInt`, `OptionalDouble` and `OptionalLong`. We will look at them now.'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，也有原始类型的`Optional`；即：`OptionalInt`、`OptionalDouble`和`OptionalLong`。我们现在将研究它们。
- en: '*Table 16.6* highlights the more commonly used primitive stream methods.'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '*表16.6* 突出了更常用的原始流方法。'
- en: '| **OptionalInt** | **OptionalDouble** | **OptionalLong** |'
  id: totrans-325
  prefs: []
  type: TYPE_TB
  zh: '| **OptionalInt** | **OptionalDouble** | **OptionalLong** |'
- en: '| --- | --- | --- |'
  id: totrans-326
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `int getAsInt()` | `double getAsDouble()` | `long getAsLong()` |'
  id: totrans-327
  prefs: []
  type: TYPE_TB
  zh: '| `int getAsInt()` | `double getAsDouble()` | `long getAsLong()` |'
- en: '| `ifPresent(IntConsumer)``void accept(int)` | `ifPresent (DoubleConsumer)``void
    accept(double)` | `ifPresent(LongConsumer)``void accept(long)` |'
  id: totrans-328
  prefs: []
  type: TYPE_TB
  zh: '| `ifPresent(IntConsumer)``void accept(int)` | `ifPresent (DoubleConsumer)``void
    accept(double)` | `ifPresent(LongConsumer)``void accept(long)` |'
- en: '| `OptionalInt of(int)` | `OptionalDouble of(double)` | `OptionalLong of(long)`
    |'
  id: totrans-329
  prefs: []
  type: TYPE_TB
  zh: '| `OptionalInt of(int)` | `OptionalDouble of(double)` | `OptionalLong of(long)`
    |'
- en: '| `int` `orElse(int other)` | `double orElse``     (``double other)` | `long` `orElse(long other)` |'
  id: totrans-330
  prefs: []
  type: TYPE_TB
  zh: '| `int` `orElse(int other)` | `double orElse`（`double other`） | `long` `orElse(long
    other)` |'
- en: '| `orElseGet(IntSupplier)``int getAsInt()` | `orElseGet (DoubleSupplier)``double
    getAsDouble()` | `orElseGet(LongSupplier)``long getAsLong()` |'
  id: totrans-331
  prefs: []
  type: TYPE_TB
  zh: '| `orElseGet(IntSupplier)``int getAsInt()` | `orElseGet (DoubleSupplier)``double
    getAsDouble()` | `orElseGet(LongSupplier)``long getAsLong()` |'
- en: '| `IntStream stream()` | `DoubleStream stream()` | `LongStream stream()` |'
  id: totrans-332
  prefs: []
  type: TYPE_TB
  zh: '| `IntStream stream()` | `DoubleStream stream()` | `LongStream stream()` |'
- en: Table 16.6 - Commonly used primitive stream methods
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 表16.6 - 常用的原始流方法
- en: This table contrasts the more commonly used methods across the primitive streams.
    Where appropriate, the functional method is also listed, beneath the functional
    interface. For example, examining the `ifPresent(IntConsumer)` for `OptionalInt`
    shows that `IntConsumer`’s functional method is `void accept(int)`.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 这个表格对比了原始流中更常用的方法。在适当的地方，也列出了函数式方法，位于函数式接口下方。例如，检查`OptionalInt`的`ifPresent(IntConsumer)`，可以看到`IntConsumer`的函数式方法是`void
    accept(int)`。
- en: Note that the return types for the `orElseGet()` methods can be deduced from
    the functional methods just below. For example, examining the `orElseGet()` for
    `OptionalInt` shows that `IntSupplier`’s functional method is `int getAsInt()`.
    Therefore, the return type for `orElseGet(IntSupplier)` is also `int`.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`orElseGet()`方法的返回类型可以从下面的函数式方法推断出来。例如，检查`OptionalInt`的`orElseGet()`方法，可以看到`IntSupplier`的函数式方法是`int
    getAsInt()`。因此，`orElseGet(IntSupplier)`的返回类型也是`int`。
- en: 'Let us examine some of these in code. *Figure 16**.17* is the example (`Optionals.java`):'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过代码检查其中的一些。*图16.17* 是示例（`Optionals.java`）：
- en: '![Figure 16.17 - Primitive stream methods in code](img/B19793_16_17.jpg)'
  id: totrans-337
  prefs: []
  type: TYPE_IMG
  zh: '![图16.17 - 代码中的原始流方法](img/B19793_16_17.jpg)'
- en: Figure 16.17 - Primitive stream methods in code
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.17 - 代码中的原始流方法
- en: 'In this figure, we start out as follows:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图中，我们开始如下：
- en: '[PRE53]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: This first line uses the `IntSream` method `rangeClosed()` to generate a stream
    of integers from 1 to 10 inclusive, in steps of 1\. The `average()` method then
    calculates the average of these numbers, which is `5.5` (55/10). Note that the
    type for `optAvg` is `OptionalDouble`.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 这第一行使用了`IntSream`方法的`rangeClosed()`来生成一个从1到10（包括10）的整数流，步长为1。然后`average()`方法计算这些数字的平均值，为`5.5`（55/10）。请注意，`optAvg`的类型是`OptionalDouble`。
- en: The second uses the now familiar `ifPresent()` method. This time the consumer
    argument is a `DoubleConsumer`, which means the functional method is `void accept(double)`.
    This is what we are doing - the value of the `OptionalDouble` is used (namely
    `d`) and output.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 第二次使用的是现在熟悉的`ifPresent()`方法。这次消费者参数是`DoubleConsumer`，这意味着函数式方法是`void accept(double)`。这正是我们正在做的事情
    - 使用`OptionalDouble`的值（即`d`）并输出。
- en: 'We then have:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来有：
- en: '[PRE54]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: which uses `getAsDouble()` to return the `double` value. If no value is present,
    this method (like `get()` in `Optional<T>`) generates a `NoSuchElementException`.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 它使用`getAsDouble()`来返回`double`值。如果没有值存在，这个方法（就像`Optional<T>`中的`get()`）会生成一个`NoSuchElementException`。
- en: 'The next two lines are:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的两行是：
- en: '[PRE55]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The first line uses the `orElseGet()` method. We pass in a `DoubleSupplier`,
    which means there is no input argument (hence the `()` in the lambda) and a `double`
    returned (`Double.NaN`). As the `OptionDouble` has a value, the value is used
    to initialize `dblAvg` and the `DoubleSupplier` is ignored. We then output the
    variable `dblAvg`.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行使用了`orElseGet()`方法。我们传递了一个`DoubleSupplier`，这意味着没有输入参数（因此lambda中有`()`），并且返回一个`double`值（`Double.NaN`）。由于`OptionDouble`有值，该值用于初始化`dblAvg`，而`DoubleSupplier`被忽略。然后我们输出变量`dblAvg`。
- en: 'The following code segment completes the example:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码段完成了示例：
- en: '[PRE56]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The first line creates an `OptionalInt` using the static `OptionalInt.of()`
    method. The second line uses the `orElseGet()` method. We pass in a `IntSupplier`,
    meaning we pass in nothing and get back in `int` (which is `0`). As `optInt` has
    a value, the value is used to initialize `age` and the `IntSupplier` is ignored.
    The third line outputs the variable `age`. The last line uses `getAsInt()` to
    return the `int` value. If no value is present in the optional, this method would
    also, like `getAsDouble()`, generate a `NoSuchElementException`. However, as `optInt`
    contains a value (of 35), it is returned and output.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行使用静态方法 `OptionalInt.of()` 创建了一个 `OptionalInt`。第二行使用了 `orElseGet()` 方法。我们传递了一个
    `IntSupplier`，这意味着我们传递了空值并返回一个 `int`（即 `0`）。由于 `optInt` 有值，所以使用该值初始化 `age`，而 `IntSupplier`
    被忽略。第三行输出了变量 `age`。最后一行使用 `getAsInt()` 返回 `int` 值。如果 `optional` 中没有值，此方法也会像 `getAsDouble()`
    一样生成一个 `NoSuchElementException`。然而，由于 `optInt` 包含一个值（35），它被返回并输出。
- en: That complete the `Optional`s section. Our least section in this chapter is
    parallel streams.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就完成了 `Optional` 部分的讲解。本章最简短的部分是并行流。
- en: Understanding parallel streams
  id: totrans-353
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解并行流
- en: All of the streams so far have been serial streams where the results are ordered.
    With serial streams, a single thread processes one entry at a time. A parallel
    stream is processed by multiple threads executing concurrently (running on multiple
    CPUs). The stream elements are split into substreams, which are processed by multiple
    instances of the stream pipeline being executed in multiple threads. These partial
    substream results are then combined into a final result. To execute the substreams
    in parallel, the streams use the support of Java’s fork/join framework for thread
    management.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止的所有流都是顺序流，其结果是有序的。在顺序流中，单个线程一次处理一个条目。并行流由多个线程并发执行（在多个 CPU 上运行）。流元素被分成子流，这些子流由多个线程中的流管道实例处理。然后将这些部分子流的结果组合成最终结果。为了并行执行子流，流使用
    Java 的 fork/join 框架来管理线程。
- en: Creating parallel streams
  id: totrans-355
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建并行流
- en: 'To make a stream a parallel stream is very straightforward. We have two options:
    we can use the `parallelStream()` method from the `Collection` API or the `parallel()`
    intermediate operation from the `Stream` API.'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 要将一个流转换为并行流非常简单。我们有两种选择：我们可以使用 `Collection` API 中的 `parallelStream()` 方法，或者使用
    `Stream` API 中的 `parallel()` 中间操作。
- en: 'Here are examples of both methods:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是两种方法的示例：
- en: '[PRE57]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Let us look at an example contrasting a sequential stream with a parallel stream
    to show how easy it is to create a parallel stream. *Figure 16**.18* is the code
    (`ParalledStreams.java` in the repo):'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个对比顺序流和并行流的例子来看看创建并行流有多简单。*图 16.18* 是代码（在仓库中的 `ParalledStreams.java`）：
- en: '![Figure 16.18 - Creating a parallel stream](img/B19793_16_18.jpg)'
  id: totrans-360
  prefs: []
  type: TYPE_IMG
  zh: '![图 16.18 - 创建并行流](img/B19793_16_18.jpg)'
- en: Figure 16.18 - Creating a parallel stream
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.18 - 创建并行流
- en: 'Let us examine the sequential stream first:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先来检查一下顺序流：
- en: '[PRE58]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: We initially generate a stream of `Stream<Integer>`. The second line uses the
    `mapToInt()` function to map the `Stream<Integer>` to an `IntStream`. In other
    words, map from a stream of `Integer` objects to a stream of `int` primitives.
    This is so we can use the `sum()` method in `IntStream`. The result, 210 is then
    output.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最初生成一个 `Stream<Integer>` 的流。第二行使用 `mapToInt()` 函数将 `Stream<Integer>` 映射到 `IntStream`。换句话说，将
    `Integer` 对象的流映射到 `int` 原始值的流。这样我们就可以在 `IntStream` 中使用 `sum()` 方法。结果，210 被输出。
- en: 'The parallel version is:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 并行版本是：
- en: '[PRE59]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The only difference is the call to `parallel()` on the second line. This is
    a `Stream` method. This is abstraction at its finest! The data partitioning and
    thread management are handled by the API and the JVM.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的区别在于第二行对 `parallel()` 的调用。这是一个 `Stream` 方法。这是抽象的极致！数据分区和线程管理由 API 和 JVM 处理。
- en: Parallel decomposition
  id: totrans-368
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 并行分解
- en: Creating parallel streams is the easy part. Things get interesting when performing
    *parallel decomposition* - where a task is broken down (decomposed) into smaller
    tasks that are executed concurrently, and their results assembled afterwards.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 创建并行流是容易的部分。当执行 *并行分解* 时，事情变得有趣——任务被分解成更小的任务，这些任务并发执行，然后汇总其结果。
- en: With serial streams, results are ordered and therefore predictable. With parallel
    streams and parallel decomposition, this is not the case, as order is not guaranteed
    and therefore, results are unpredictable. This is because the threads take the
    subtasks in any order and return the results in any order.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 对于串行流，结果是有序的，因此是可预测的。对于并行流和并行分解，情况并非如此，因为顺序没有保证，因此结果是不可预测的。这是因为线程以任何顺序接受子任务，并以任何顺序返回结果。
- en: 'Let us look at a simple code example demonstrating this. *Figure 16**.19* presents
    the code (`ParalledStreams.java`):'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个简单的代码示例来展示这一点。*图 16**.19* 展示了代码（`ParalledStreams.java`）：
- en: '![Figure 16.19 - Ordering in serial streams and lack of ordering in parallel
    streams](img/B19793_16_19.jpg)'
  id: totrans-372
  prefs: []
  type: TYPE_IMG
  zh: '![图 16.19 - 串行流中的排序和并行流中的无排序](img/B19793_16_19.jpg)'
- en: Figure 16.19 - Ordering in serial streams and lack of ordering in parallel streams
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.19 - 串行流中的排序和并行流中的无排序
- en: 'This figure presents a `dbAction()` method that mimics a database action by
    sleeping the thread for 1 second. When the `orderedSerialStreams()` method executes,
    the output is predictable:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 此图展示了一个 `dbAction()` 方法，该方法通过使线程休眠 1 秒来模拟数据库操作。当 `orderedSerialStreams()` 方法执行时，输出是可预测的：
- en: '[PRE60]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The integers are ordered as per the source and the operation took `5 seconds`,
    `1 second` for each value.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 整数按照源顺序排序，操作耗时 `5 秒`，每个值 `1 秒`。
- en: 'The `unorderedParallelStreams()` method is the same as the serial version except
    that we are now creating a parallel stream. Let us examine its output:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '`unorderedParallelStreams()` 方法与串行版本相同，只是我们现在正在创建一个并行流。让我们来检查它的输出：'
- en: '[PRE61]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'One can see the obvious performance benefit of parallel processing: 1 second
    versus 5 seconds. Note that this performance gain depends on the number of CPUs
    available - if this code is run on a machine with fewer processors, the gain would
    be less.'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 可以看到并行处理的明显性能优势：1 秒与 5 秒。请注意，这种性能提升取决于可用的 CPU 数量——如果在这台机器上运行此代码，处理器较少，则收益会更少。
- en: However, the output is now unordered as both `map()` and `forEach()` are applied
    concurrently. Instead of `forEach()`, we could use the `forEachOrdered()` terminal
    operation. This operation ensures the consumer is applied to the elements in their
    *encounter order* as they left the source. In our example, this would be `10`,
    `20`, `30`, `40`, and `50`. *Figure 16**.20* shows it in code (`ParalledStreams.java`).
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，输出现在是无序的，因为 `map()` 和 `forEach()` 都是并发应用的。我们本可以使用 `forEachOrdered()` 终端操作。这个操作确保消费者以元素离开源时的*遇到顺序*应用元素。在我们的例子中，这将依次是
    `10`、`20`、`30`、`40` 和 `50`。*图 16**.20* 展示了它在代码中的样子（`ParalledStreams.java`）。
- en: '![Figure 16.20 - The forEachOrdered() method](img/B19793_16_20.jpg)'
  id: totrans-381
  prefs: []
  type: TYPE_IMG
  zh: '![图 16.20 - forEachOrdered() 方法](img/B19793_16_20.jpg)'
- en: Figure 16.20 - The forEachOrdered() method
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.20 - forEachOrdered() 方法
- en: 'In this figure, the terminal operation is no longer `forEach()` but is `forEachOrdered()`.
    The output from this figure is as follows:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 在此图中，终端操作不再是 `forEach()`，而是 `forEachOrdered()`。此图的输出如下：
- en: '[PRE62]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Now the integers are ordered and the performance gain is still significant due
    to `map()` being applied concurrently.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 现在整数是有序的，由于 `map()` 是并发应用的，性能提升仍然非常显著。
- en: Parallel reductions using reduce()
  id: totrans-386
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 reduce() 进行并行归约
- en: 'As order is not guaranteed with parallel streams, the results of parallel reductions
    can be unexpected. A reduction combines a stream into a single result. Recall
    that the overloaded `reduce()` operation accepted three parameters: an identity,
    an accumulator and a combiner. The combiner function is used in a parallel environment
    for combining the accumulator results. What the following examples are going to
    demonstrate is that the *accumulator and combiner must work regardless of the
    order in which they are executed*. They must be associative.'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 由于并行流不保证顺序，并行归约的结果可能会出乎意料。归约操作将流合并成一个单一的结果。回想一下，重载的 `reduce()` 操作接受三个参数：一个恒等元、一个累加器和一个组合器。组合器函数在并行环境中用于组合累加器的结果。以下示例将要展示的是，*累加器和组合器必须能够在它们执行的任何顺序下工作*。它们必须是结合律的。
- en: Associativity
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 结合律
- en: 'An operator or function is considered associative if the following holds:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 如果以下条件成立，则运算符或函数被认为是结合律的：
- en: '`(a op b) op c)` == `a op (b` `op c)`.'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '`(a op b) op c)` == `a op (b` `op c)`.'
- en: 'For example, addition is associative:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，加法是结合律的：
- en: '`(2 + 3) + 4` == `2 + (3 + 4)` == `9`'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: '`(2 + 3) + 4` == `2 + (3 + 4)` == `9`'
- en: 'However, subtraction is not associative:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，减法不是结合律的：
- en: '`(2 - 3) - 4` == `-5` whereas `2 - (3 - 4)` == `3`'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: '`(2 - 3) - 4` == `-5` 而 `2 - (3 - 4)` == `3`'
- en: 'This is really important in parallel processing. For example:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 这在并行处理中非常重要。例如：
- en: '`a op b op c op d` == `(a op b) op (c` `op d)`'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: '`a op b op c op d` == `(a op b) op (c op d)`'
- en: If `op` is associative then `(a op b)` and `(c op d)` can be evaluated in parallel;
    and `op` then performed on the results.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`op`是结合律的，那么`(a op b)`和`(c op d)`可以并行评估；然后对结果执行`op`操作。
- en: 'Let us first examine a serial reduction:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先检查串行归约：
- en: '[PRE63]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: As this is a serial reduction, there is no need for a combiner. The result is
    -15\. Let us now examine the parallel version to see do we get the same result.
    *Figure 16**.21* represents the code (ParallelStreams.java).
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个串行归约，不需要组合器。结果是-15。现在让我们检查并行版本，看看我们是否得到相同的结果。*图16**.21*表示代码（ParallelStreams.java）。
- en: '![Figure 16.21 - A parallel reduction using reduce()](img/B19793_16_21.jpg)'
  id: totrans-401
  prefs: []
  type: TYPE_IMG
  zh: '![图16.21 - 使用reduce()的并行归约](img/B19793_16_21.jpg)'
- en: Figure 16.21 - A parallel reduction using reduce()
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.21 - 使用reduce()的并行归约
- en: 'In this figure, we have expanded both the accumulator and the combiner to show
    the values as they appear:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图中，我们将累加器和组合器都扩展了，以显示它们出现的值：
- en: '[PRE64]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The output is as follows (with the combiner subtask values tabbed in):'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下（组合子任务值缩进）：
- en: '[PRE65]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Notice that the final result is `5`, which is incorrect. This is because subtraction
    is not associative. Interestingly, in the parallel process the identity is applied
    to multiple elements in the stream, giving us unexpected results.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，最终结果是`5`，这是不正确的。这是因为减法不是结合律的。有趣的是，在并行过程中，恒等式被应用于流中的多个元素，从而产生了意外的结果。
- en: Parallel reductions using collect()
  id: totrans-408
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用collect()的并行归约
- en: The `collect()` method, like `reduce()` has a three-argument version, which
    accepts an accumulator and a combiner. For the first argument, rather than an
    identity, `collect()` uses a `Supplier`. The same rule applies here too - the
    accumulator and combiner operations must be able to perform in any order.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: '`collect()`方法与`reduce()`一样，有一个三个参数的版本，它接受一个累加器和组合器。对于第一个参数，`collect()`使用一个`Supplier`而不是恒等式。同样的规则也适用于这里
    - 累加器和组合器操作必须能够以任何顺序执行。'
- en: One should use a concurrent collection, in order to avoid concurrent threads
    causing `ConcurrentModificationException`s. Another consideration is the target
    collection - if it is ordered (a `List` for example), then the background processing
    required to maintain that order may reduce performance. *Figure 16**.22* presents
    an example of a concurrent collection, namely `ConcurrentMap` in code (`ParallelStreams.java`).
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 应该使用并发集合，以避免并发线程导致`ConcurrentModificationException`。另一个考虑因素是目标集合 - 如果它是有序的（例如，一个`List`），那么维护该顺序所需的背景处理可能会降低性能。*图16**.22*展示了并发集合的一个例子，即代码中的`ConcurrentMap`（ParallelStreams.java）。
- en: '![Figure 16.22 - collect() returning a concurrent collection](img/B19793_16_22.jpg)'
  id: totrans-411
  prefs: []
  type: TYPE_IMG
  zh: '![图16.22 - collect()返回一个并发集合](img/B19793_16_22.jpg)'
- en: Figure 16.22 - collect() returning a concurrent collection
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.22 - collect()返回一个并发集合
- en: 'The output from the code is:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的输出如下：
- en: '[PRE66]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Therefore, the `ConcurrentMap` implementation here is a `ConcurrentHashMap`.
    This is not guaranteed but some implementation of the `ConcurrentMap` interface
    is guaranteed.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这里的`ConcurrentMap`实现是一个`ConcurrentHashMap`。这并不保证，但某些`ConcurrentMap`接口的实现是保证的。
- en: 'The key in our map is the first letter in the name:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 我们映射的键是名称的第一个字母：
- en: '[PRE67]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The value associated with the key is the name itself:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 与键关联的值是名称本身：
- en: '[PRE68]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'If more than one name starts with the same letter, the names are appended,
    with a comma between the names:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 如果多个名称以相同的字母开头，则名称将附加，名称之间用逗号分隔：
- en: '[PRE69]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: That completes our discussion on parallel streams and indeed concludes [*Chapter
    16*](B19793_16.xhtml#_idTextAnchor401)*.* Let us now put that knowledge into practice
    to reinforce the concepts.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了我们对并行流的讨论，并且确实结束了[第16章](B19793_16.xhtml#_idTextAnchor401)*.* 现在，让我们将这一知识付诸实践，以巩固这些概念。
- en: Exercises
  id: totrans-423
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: To keep the park running smoothly, we need to keep track of the health of all
    dinosaurs. We need to identify any ill dinosaurs. Using a stream of `Dinosaur`
    objects, filter out dinosaurs that are ill (assuming the `isIll()` method exists
    the in `Dinosaur` class), map them to their names, and collect the results in
    a list. Lastly, print out this list of names of the dinosaurs that need immediate
    attention.
  id: totrans-424
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使公园运行顺畅，我们需要跟踪所有恐龙的健康状况。我们需要识别任何生病的恐龙。使用`Dinosaur`对象的流，过滤掉生病的恐龙（假设`Dinosaur`类中存在`isIll()`方法），将它们映射到它们的名称，并将结果收集到一个列表中。最后，打印出需要立即关注的恐龙名称列表。
- en: Managing a dinosaur park of this size involves handling large amounts of data.
    To make an announcement in the park about dinosaur feeding times, create a list
    of dinosaurs, convert it into a stream, and use the `map()` function to get a
    list of dinosaur names. Then, use the `forEach` terminal operation to print out
    a message for each dinosaur’s feeding time.
  id: totrans-425
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 管理这样一个规模的恐龙公园涉及到处理大量数据。为了在公园中关于恐龙喂食时间的公告，创建一个恐龙列表，将其转换为流，并使用`map()`函数获取恐龙名称列表。然后，使用`forEach`终端操作为每个恐龙的喂食时间打印出一条消息。
- en: Keeping track of the total food required for all the dinosaurs can be tricky.
    Suppose you have an array of weights of all dinosaurs. Convert it into an `IntStream`
    and use the `sum` method to get the total weight of all dinosaurs in the park.
    This could help you estimate the total food requirements.
  id: totrans-426
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 跟踪所有恐龙所需的总食物量可能很棘手。假设你有一个包含所有恐龙重量的数组。将其转换为`IntStream`并使用`sum`方法获取公园中所有恐龙的总重量。这可以帮助你估计总食物需求。
- en: When dealing with data about dinosaurs or employees, we may encounter null references.
    To avoid a `NullPointerException` error, use `Optional` when retrieving a dinosaur
    by its name from a map of dinosaurs. If a dinosaur with the provided name doesn’t
    exist, `Optional` should return a message indicating the dinosaur hasn’t been
    found.
  id: totrans-427
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当处理关于恐龙或员工的数据时，我们可能会遇到空引用。为了避免`NullPointerException`错误，在从恐龙映射中按名称检索恐龙时使用`Optional`。如果提供的名称的恐龙不存在，`Optional`应返回一条消息，表明恐龙尚未找到。
- en: Calculating the average weight of dinosaurs can be a time-consuming operation,
    especially when dealing with a large number of dinosaurs. To speed up the process,
    use parallel streams. Convert a list of dinosaur weights into a parallel stream
    and use the average method to calculate the average weight.
  id: totrans-428
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算恐龙的平均重量可能是一个耗时操作，尤其是在处理大量恐龙时。为了加快处理速度，使用并行流。将恐龙重量列表转换为并行流并使用平均方法计算平均重量。
- en: Project – dynamic dinosaur care system
  id: totrans-429
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目 - 动态恐龙护理系统
- en: Integrate the Stream API into your dinosaur care system to process large volumes
    of dinosaur data, such as health records, feeding schedules, and so on. The system
    should also incorporate `Optional` and parallel streams where appropriate, optimizing
    data processing and minimizing potential null pointer exceptions.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 将Stream API集成到你的恐龙护理系统中以处理大量的恐龙数据，例如健康记录、喂食时间表等。系统还应适当地采用`Optional`和并行流，优化数据处理并最小化潜在的空指针异常。
- en: 'Here are the steps to get you there:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是让你达到目的的步骤：
- en: '`Dinosaur` class with properties such as `name`, `species`, `healthStatus`,
    and so on. There should also be a `DinosaurCareSystem` class for implementing
    the main functionalities.'
  id: totrans-432
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Dinosaur`类具有`name`、`species`、`healthStatus`等属性。还应该有一个`DinosaurCareSystem`类来实现主要功能。'
- en: '`Stream` from the list of records and use the `filter` method to get these
    records. Here’s an example: `List<HealthRecord> criticalRecords = records.stream().filter(r
    -> r.getHealthStatus() <` `CRITICAL_THRESHOLD).collect(Collectors.toList())`.'
  id: totrans-433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从记录列表中`Stream`并使用`filter`方法获取这些记录。以下是一个示例：`List<HealthRecord> criticalRecords
    = records.stream().filter(r -> r.getHealthStatus() < CRITICAL_THRESHOLD).collect(Collectors.toList())`.
- en: '`Stream` to filter the schedules. Here’s an example: `List<FeedingSchedule>
    morningFeeds = schedules.stream().filter(s ->` `s.getTime().isBefore(LocalTime.NOON)).collect(Collectors.toList())`.'
  id: totrans-434
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`Stream`来过滤时间表。以下是一个示例：`List<FeedingSchedule> morningFeeds = schedules.stream().filter(s
    -> s.getTime().isBefore(LocalTime.NOON)).collect(Collectors.toList())`.
- en: '`NullPointerException``Optional` to avoid a `NullPointerException` error. Here’s
    an example: `Optional.ofNullable(dinosaur.getTrainer()).map(Trainer::getName).orElse("No`
    `trainer assigned").`'
  id: totrans-435
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`NullPointerException`和`Optional`来避免`NullPointerException`错误。以下是一个示例：`Optional.ofNullable(dinosaur.getTrainer()).map(Trainer::getName).orElse("No
    trainer assigned").`
- en: '`stream()` with `parallelStream()` in the previous examples. Be aware, though,
    that not every problem is suitable for parallel processing. If the tasks have
    dependencies or need to be processed in a specific order, stick with regular streams.'
  id: totrans-436
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在前面的示例中使用`stream()`和`parallelStream()`。然而，要注意，并非每个问题都适合并行处理。如果任务有依赖关系或需要按特定顺序处理，请坚持使用常规流。
- en: Summary
  id: totrans-437
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we explored advanced streaming concepts. We started by exploring
    intermediate operations, which are powerful, as they transform the stream into
    another stream. Popular intermediate operations are: `filter()`, `distinct()`,
    `limit()`, `map()`, `flatMap()`, and `sorted()`. Some of these are known as *stateful*
    as they need to maintain some state to operate effectively. Examples are `limit()`
    and `sorted()`. The `limit()` method is also *short-circuiting* as it can cause
    the pipeline to shut down even if there is more data available in the source.'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了高级流概念。我们首先探索了中间操作，这些操作非常强大，因为它们将流转换成另一个流。流行的中间操作包括：`filter()`、`distinct()`、`limit()`、`map()`、`flatMap()`和`sorted()`。其中一些被称为*有状态的*，因为它们需要维护一些状态才能有效地操作。例如，`limit()`和`sorted()`。`limit()`方法也是*短路*的，因为它可以在源中还有更多数据可用的情况下关闭管道。
- en: We then examined the primitive stream types in the API, namely `IntStream`,
    `LongStream` and `DoubleStream`. These types have some very useful methods for
    operating on numeric types, such as `sum()` and `average()`. We also explained
    the patterns behind the names of the new primitive stream functional interfaces
    and their functional methods.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们检查了API中的原始流类型，即`IntStream`、`LongStream`和`DoubleStream`。这些类型有一些非常实用的方法来操作数值类型，例如`sum()`和`average()`。我们还解释了新的原始流功能接口及其功能方法的命名背后的模式。
- en: We can create streams by mapping from another stream. There are many methods
    to do this but they follow a pattern in their naming. We examined these and explained
    the patterns.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将另一个流映射来创建流。有许多方法可以做到这一点，但它们的命名遵循一定的模式。我们检查了这些方法并解释了这些模式。
- en: '`Optional`s are boxes that may or may not be empty. They are mainly used as
    a method return type where there is a real need to represent “no result”. Rather
    than returning `null` (with its pitfalls), we can return an empty `Optional`.
    We can create `Optional`s using `Optional.of`, `Optional.empty()` and `Optional.ofNullable()`.
    The `Optional` API supports functional-style programming; for example, `ifPresent()`
    lets us state clearly what we want without the need for an `else` statement. We
    also examined the primitive `Optional`s, namely `OptionalInt`, `OptionalLong`
    and `OptionalDouble`.'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: '`Optional`是可能为空或不为空的盒子。它们主要用于方法返回类型，其中确实需要表示“无结果”。而不是返回`null`（及其陷阱），我们可以返回一个空的`Optional`。我们可以使用`Optional.of`、`Optional.empty()`和`Optional.ofNullable()`来创建`Optional`。`Optional`
    API支持函数式编程风格；例如，`ifPresent()`让我们可以清楚地表达我们想要的内容，而无需`else`语句。我们还检查了原始的`Optional`，即`OptionalInt`、`OptionalLong`和`OptionalDouble`。'
- en: Lastly, we looked at parallel streams, which can be easily created using the
    `Collection` API method `parallelStream()` or the `Stream` API method `parallel()`.
    While serial streams are ordered, parallel streams are not. This is due to parallel
    decomposition where tasks are broken down and re-assembled later. In a parallel
    multi-threaded environment, threads can take sub-tasks in any order and return
    the results in any order. This is fine for an associative task such as addition
    but not suitable for subtraction.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们研究了并行流，可以使用`Collection` API方法`parallelStream()`或`Stream` API方法`parallel()`轻松创建。虽然顺序流是有序的，但并行流不是。这是由于并行分解，任务被分解并在稍后重新组装。在并行多线程环境中，线程可以以任何顺序接收子任务，并以任何顺序返回结果。这对于关联任务（如加法）是可以的，但不适合减法。
- en: If you are using the parallel reduction methods `reduce()` and `collect()`,
    ensure that the accumulator and combiner functions are associative; as they must
    work correctly regardless of the order they are executed in.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用并行减少方法`reduce()`和`collect()`，请确保累加器和组合函数是关联的；因为它们必须在不考虑执行顺序的情况下正确工作。
- en: That completes our discussion on streams. The next chapter, Concurrency will
    further solidify the last section here on parallel streams.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了我们对流的讨论。下一章，并发，将进一步巩固这里关于并行流的最后部分。
