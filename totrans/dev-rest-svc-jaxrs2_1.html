<html><head></head><body><div class="chapter" title="Chapter&#xA0;1.&#xA0;Building RESTful Web Services Using JAX-RS"><div class="titlepage"><div><div><h1 class="title"><a id="ch01"/>Chapter 1. Building RESTful Web Services Using JAX-RS</h1></div></div></div><p>There are various ways to implement communication between heterogeneous applications. There are standards focusing on web services based on <span class="strong"><strong>SOAP</strong></span><a id="id0" class="indexterm"/>, <span class="strong"><strong>WSDL</strong></span><a id="id1" class="indexterm"/>, and WS* specifications; alongside these standards there is an emerging lightweight solution based on plain HTTP referred to as <span class="strong"><strong>Representational State Transfer</strong></span> (<span class="strong"><strong>REST</strong></span>).</p><p>REST<a id="id2" class="indexterm"/> is identified by the principles of addressable resources, constrained interfaces using HTTP verbs, representation, and statelessness.</p><p>The key principles of <a id="id3" class="indexterm"/>REST are:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Associating IDs to resources</li><li class="listitem" style="list-style-type: disc">Using standard HTTP methods</li><li class="listitem" style="list-style-type: disc">Multiple formats of data sent by a resource</li><li class="listitem" style="list-style-type: disc">Statelessness</li></ul></div><p>This chapter starts with the basic concept of building <span class="strong"><strong>RESTful Web Services</strong></span> using the <span class="strong"><strong>JAX-RS</strong></span> 2.0 API and covers the following sections:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Getting started with JAX-RS 2.0</li><li class="listitem" style="list-style-type: disc">Converting POJOs to RESTful endpoints using JAX-RS 2.0 annotations</li><li class="listitem" style="list-style-type: disc"><code class="literal">@Produces</code>, <code class="literal">@Consumes</code> annotations</li><li class="listitem" style="list-style-type: disc">Client API for JAX-RS 2.0</li><li class="listitem" style="list-style-type: disc">Sample showing all verbs</li><li class="listitem" style="list-style-type: disc">Custom entity providers for <span class="strong"><strong>serializing</strong></span><a id="id4" class="indexterm"/> and <span class="strong"><strong>deserializing</strong></span><a id="id5" class="indexterm"/> user defined classes using JAX-RS</li><li class="listitem" style="list-style-type: disc">Utilizing the Bean Validation API for validation with JAX-RS 2.0</li></ul></div><div class="section" title="Understanding REST"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec08"/>Understanding REST</h1></div></div></div><p>The REST<a id="id6" class="indexterm"/> architectural style is based on request and response messages transferred between clients and servers without any of the participating node keeping track of the state of previous sessions..</p><p>REST uses nouns and verbs for readability. Resources are identified in requests. The representation of the resource that is sent to the client depends on the request and how the server sends the data.</p></div></div>
<div class="section" title="RESTful Web Services"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec09"/>RESTful Web Services</h1></div></div></div><p>A RESTful Web Service <a id="id7" class="indexterm"/>is a service whose interface and accessing mechanism are aligned with the REST principles . The URIs identify the resources. For example, a RESTful resource for a book can be identified as <a class="ulink" href="http://foo.org/book">http://foo.org/book</a>.</p><p>A resource for a book identified by ISBN could be <a class="ulink" href="http://foo.org/book/isbn/1234459">http://foo.org/book/isbn/1234459</a>. This shows a human-readable URI that is easy to understand and identify.</p><p>A client has enough metadata of a resource to modify or delete it as long as it is authorized to do so. To get a resource the client would send a HTTP <code class="literal">GET</code> request. To update the resource the client would send a <code class="literal">PUT</code> request. To delete a resource the client would send a <code class="literal">DELETE</code> request. To create a new resource, and for arbitrary processing, the client sends a HTTP <code class="literal">POST</code> request. The next section covers these verbs in more detail.</p></div>
<div class="section" title="Verbs in REST"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec10"/>Verbs in REST</h1></div></div></div><p>Some of the requests<a id="id8" class="indexterm"/> used in REST are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">GET</code>: The<a id="id9" class="indexterm"/> <code class="literal">GET</code> request <a id="id10" class="indexterm"/>retrieves a representation of a resource from server to client</li><li class="listitem" style="list-style-type: disc"><code class="literal">POST</code>: The<a id="id11" class="indexterm"/> <code class="literal">POST</code> request<a id="id12" class="indexterm"/> is used to create a resource on the server based on the representation that the client sends</li><li class="listitem" style="list-style-type: disc"><code class="literal">PUT</code>: The<a id="id13" class="indexterm"/> <code class="literal">PUT</code> <a id="id14" class="indexterm"/>request is used to update or create a reference to a resource on server</li><li class="listitem" style="list-style-type: disc"><code class="literal">DELETE</code>: The <a id="id15" class="indexterm"/><code class="literal">DELETE</code> <a id="id16" class="indexterm"/>request can delete a resource on server</li><li class="listitem" style="list-style-type: disc"><code class="literal">HEAD</code>: The<a id="id17" class="indexterm"/> <code class="literal">HEAD</code> <a id="id18" class="indexterm"/>requests checks for a resource without retrieving it</li></ul></div><p>The next section will introduce the notion of safety and <span class="strong"><strong>idempotence</strong></span>, two important terms associated with REST.</p><div class="section" title="Safety and idempotence"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec06"/>Safety and idempotence</h2></div></div></div><p>When it comes to <a id="id19" class="indexterm"/>REST, a safe method, by definition, is a HTTP method <a id="id20" class="indexterm"/>that does not modify the state of the resource on the server. For example, invoking a<a id="id21" class="indexterm"/> <code class="literal">GET</code> or a<a id="id22" class="indexterm"/> <code class="literal">HEAD</code> method on the resource URL should never change the <a id="id23" class="indexterm"/>resource on the server. <code class="literal">PUT</code> is considered not safe since it usually creates a resource on the server. <code class="literal">DELETE</code> <a id="id24" class="indexterm"/>is also considered not safe since it will delete the resource on the server. <code class="literal">POST</code> <a id="id25" class="indexterm"/>is not safe since it will change the resource on the server.</p><p>
<span class="strong"><strong>Idempotent</strong></span><a id="id26" class="indexterm"/> method <a id="id27" class="indexterm"/>is a method that can be called multiple times yet the outcome will not change.</p><p>
<code class="literal">GET</code> and <code class="literal">HEAD</code> are idempotent, which means that even though the same operation is done multiple times the result does not vary. <code class="literal">PUT</code> is idempotent; calling the <code class="literal">PUT</code> method multiple times will not change the result and the resource state is exactly the same.</p><p>
<code class="literal">DELETE</code> is idempotent because once the resource is deleted it is gone, and calling the same operation multiple times will not change the outcome.</p><p>In contrast, <code class="literal">POST</code> is not idempotent and calling <code class="literal">POST</code> multiple times can have different outcomes.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip02"/>Tip</h3><p>The idempotence and safety of the HTTP verbs are a convention, meaning that when someone is using your API they will assume that <code class="literal">GET</code>/<code class="literal">PUT</code>/<code class="literal">POST</code>/<code class="literal">DELETE</code> have the same idempotency characteristics that are previously described; and the implementation of the business logic behind each verb should support these characteristics.</p></div></div><p>The response sent by the server could be in XML, JSON, or any other MIME type as long as the server supports the requested format. In case the server cannot support the requested MIME type, it can return with a status code of 406 (not acceptable).</p><p>When we are developing with RESTful principles in mind, each message should have enough information to let the server understand the purpose of the message and how to process that message, to produce the response the message is meant for, and finally to ensure visibility and statelessness.</p><p>Summarizing, these are the components of<a id="id28" class="indexterm"/> RESTful Web Services:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Base URI</strong></span>: The <a id="id29" class="indexterm"/>base URI<a id="id30" class="indexterm"/> for the Web Service <code class="literal">http://foo.com/bar</code></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Media type</strong></span>: The <a id="id31" class="indexterm"/>media <a id="id32" class="indexterm"/>type supported by the Web Service</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Methods</strong></span>: The <a id="id33" class="indexterm"/>HTTP methods<a id="id34" class="indexterm"/> such as <code class="literal">GET</code>, <code class="literal">PUT</code>, <code class="literal">POST</code>, and <code class="literal">DELETE</code></li></ul></div></div></div>
<div class="section" title="Introduction to JAX-RS"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec11"/>Introduction to JAX-RS</h1></div></div></div><p>The <span class="strong"><strong>Java API for Representational State Transfer</strong></span> (<span class="strong"><strong>JAX-RS</strong></span>) specification defines a set of Java APIs <a id="id35" class="indexterm"/>for building web services conforming to the REST style.</p><p>This specification defines how to expose POJOs as web resources, using HTTP as the network protocol. Applications using these APIs can be deployed to an application server in a portable manner.</p><p>Some of the key features that are introduced <a id="id36" class="indexterm"/>in the JAX-RS 2.0 specification are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Client <a id="id37" class="indexterm"/>API</li><li class="listitem" style="list-style-type: disc">Server side <a id="id38" class="indexterm"/>asynchronous support</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Bean Validation</strong></span> <a id="id39" class="indexterm"/>support</li></ul></div><p>In the subsequent sections we will cover the following topics in relation to JAX-RS 2.0:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Converting POJOs to RESTful resources</li><li class="listitem" style="list-style-type: disc">More on JAX-RS annotations</li><li class="listitem" style="list-style-type: disc">Client API for JAX-RS</li><li class="listitem" style="list-style-type: disc">Entities in JAX-RS </li><li class="listitem" style="list-style-type: disc">Custom entity providers in JAX-RS</li><li class="listitem" style="list-style-type: disc">Using the Bean Validation API with JAX-RS</li></ul></div><div class="section" title="Converting POJOs to RESTful resources"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec07"/>Converting POJOs to RESTful resources</h2></div></div></div><p>A resource class is a POJO that uses the JAX-RS annotations. A resource class needs to have at least one method annotated with <code class="literal">@Path</code> or a request method. Resources are our so-called web services and incoming requests target these resources.</p><p>Steps to convert POJOs to RESTful endpoints:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Define a root resource as identified by a URI</li><li class="listitem">Define the methods for the resource</li><li class="listitem">Define the<a id="id40" class="indexterm"/> MIME types</li><li class="listitem">Define the <a id="id41" class="indexterm"/>Application subclass</li><li class="listitem">Define the subresources</li></ol></div><div class="section" title="Defining a root resource as identified by a URI"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec02"/>Defining a root resource as identified by a URI</h3></div></div></div><p>JAX-RS provides <a id="id42" class="indexterm"/>very rich client and server APIs that work on any Java EE <a id="id43" class="indexterm"/>application server. Using JAX-RS API, any POJO can be annotated to build the RESTful resources. Begin with a simple POJO <code class="literal">BookResource</code> and annotate it with the JAX-RS APIs.</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>@Path("books")</strong></span>
public class BooksResource {
}</pre></div><p>This is a root resource class, which is annotated with <code class="literal">@Path annotation</code>. The value <code class="literal">"books"</code> will indicate that the resource will be available at a location similar to the following URI <code class="literal">http://host:port/appname/books</code>.</p><p>Later on we add the methods to this resource so that, when a request with <code class="literal">GET</code>, <code class="literal">PUT</code>, and so on hits this resource, a particular method in the class is invoked to produce the response.</p></div><div class="section" title="Defining the methods for the resource"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec03"/>Defining the methods for the resource</h3></div></div></div><p>To add a method to this <a id="id44" class="indexterm"/>resource, we annotate the method with <code class="literal">@GET</code>, <code class="literal">@PUT</code>, <code class="literal">@DELETE</code>, or <code class="literal">@HEAD</code>. In the following example, we chose to annotate using a <code class="literal">@GET annotation</code>:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>@GET</strong></span>
public String getGreeting() {
  return "Hello from Book resource"
}</pre></div><p>The <code class="literal">@GET</code> annotation specifies that the <code class="literal">getGreeting()</code> method handles the <code class="literal">HTTP GET</code> requests.</p></div><div class="section" title="Defining the MIME types"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec04"/>Defining the MIME types</h3></div></div></div><p>To specify the <a id="id45" class="indexterm"/>MIME type that can be handled by the resource, we should <a id="id46" class="indexterm"/>annotate the resource method with <code class="literal">@Produces</code> and <code class="literal">@Consumes</code>:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>@Produces("text/plain")</strong></span>
@GET
public String getGreeting() {
  return "Hello from Book resource"
}</pre></div><p>The <code class="literal">@Produces</code> specifies that the media type this method will produce is <code class="literal">"text/plain"</code>. Support <a id="id47" class="indexterm"/>for other media types, and how to map from Java to a specific format <a id="id48" class="indexterm"/>and vice versa, is covered in detail in the entity provider's section. Thus, this is the initial introduction to having a first JAX-RS resource ready. The next section covers the details of the <code class="literal">Application</code> subclass.</p></div><div class="section" title="Defining the Application subclass"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec05"/>Defining the Application subclass</h3></div></div></div><p>The <code class="literal">Application</code> class is <a id="id49" class="indexterm"/>a portable way to configure application-level<a id="id50" class="indexterm"/> details such as specifying the name, and registering various components of a JAX-RS application. This includes the different JAX-RS resources and the JAX-RS providers in the application.</p><p>Similarly, application-wide properties can be set using a subclass of <code class="literal">Application</code>. The <code class="literal">Application</code> subclass should to be placed in either in <code class="literal">WEB-INF/classes</code> or <code class="literal">WEB-INF/lib</code> in a WAR file. Application class has the following methods that can be overridden:</p><div class="informalexample"><pre class="programlisting">public Set&lt;Class&lt;?&gt;&gt; getClasses() ;
public Map&lt;String, Object&gt; getProperties();
public Set&lt;Object&gt; getSingletons();</pre></div><p>Here is an example of a subclass of Application for our case:</p><div class="informalexample"><pre class="programlisting">@ApplicationPath("/library/")
public class HelloWorldApplication extends Application {
@Override
  public Set&lt;Class&lt;?&gt;&gt; getClasses() {
    Set&lt;Class&lt;?&gt;&gt; classes = new HashSet&lt;Class&lt;?&gt;&gt;();
<span class="strong"><strong>    classes.add(BooksResource.class);</strong></span>
    return classes;
  }
}</pre></div><p>In this code we create a <code class="literal">HelloWorldApplication</code>, which is a subclass of <code class="literal">javax.ws.rs.core.Application</code>. With Servlet 3.0 there is no need of a <code class="literal">web.xml</code> file and the servlet container uses the value specified in the <code class="literal">@ApplicationPath </code>as the servlet mapping. The <code class="literal">getClasses()</code> method of the <code class="literal">Application</code> class is overridden to add <code class="literal">BooksResource.class</code>.</p><p>A basic JAX-RS resource is now ready to use. When the sample is deployed to an application server such as GlassFish, you can use curl to send a request.</p><p>Here is an example on how to send a <code class="literal">curl -X GET</code> request:</p><div class="informalexample"><pre class="programlisting">curl -X GET http://localhost:8080/helloworld/books</pre></div><p>The output in the terminal window should be:</p><p>
<span class="strong"><strong>Hello from book resource</strong></span>
</p><p>
<a class="link" href="ch05.html" title="Chapter 5. RESTful Web Services by Example">Chapter 5</a>, <span class="emphasis"><em>RESTful Web Services by Example</em></span>, will show how to use the Application class in a <code class="literal">web.xml</code> file.</p></div><div class="section" title="Defining the subresources"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec06"/>Defining the subresources</h3></div></div></div><p>Resource classes can <a id="id51" class="indexterm"/>partially process some part of the request and provide <a id="id52" class="indexterm"/>another subresource to process the remaining part of the request.</p><p>For example, here is a snippet of a root resource <code class="literal">Library</code> and another resource <code class="literal">Book</code>.</p><div class="informalexample"><pre class="programlisting">@Path("/")
public class Library {

<span class="strong"><strong>  @Path("/books/{isbn}")</strong></span>
<span class="strong"><strong>  public Book getBook(@PathParam("isbn") String isbn){</strong></span>
    //return book
  }
}

public class Book {
<span class="strong"><strong>  @Path("/author")</strong></span>
  public String getAuthor(){
  }
}</pre></div><p>Subresource locators are resource methods that have <code class="literal">@Path </code>annotation but no HTTP methods.</p><p>In the preceding example, <code class="literal">Library</code> is a root resource as it is annotated with <code class="literal">@Path</code>. The method <code class="literal">getBook()</code> is a subresource locator whose job is to provide an object that can process the request.</p><p>The <code class="literal">@PathParam</code> <a id="id53" class="indexterm"/>is an annotation that allows you to map URI path fragments in the method call. In this example, the <code class="literal">isbn</code> URI parameter is passed to provide information about the book.</p><p>If a client sends a request using the URI:</p><div class="informalexample"><pre class="programlisting">GET /books/123456789</pre></div><p>The <code class="literal">Library.getBook()</code> method will be invoked.</p><p>If a client sends a request using the URI:</p><div class="informalexample"><pre class="programlisting">GET /books/123456789/author</pre></div><p>The <code class="literal">Library.getBook()</code> method will be invoked first. A <code class="literal">Book</code> object is returned and then the <code class="literal">getAuthor()</code> method is invoked.</p></div></div><div class="section" title="More on JAX-RS annotations"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec08"/>More on JAX-RS annotations</h2></div></div></div><p>The<a id="id54" class="indexterm"/> <code class="literal">@Produces</code> annotation <a id="id55" class="indexterm"/>is used to define the type of output the method <a id="id56" class="indexterm"/>in the resource produces. The<a id="id57" class="indexterm"/> <code class="literal">@Consumes</code> annotation<a id="id58" class="indexterm"/> is used to define the type of input, the method in the resource consumes.</p><p>Here is a method in a resource for a <code class="literal">POST</code> request:</p><div class="informalexample"><pre class="programlisting">@POST
<span class="strong"><strong>@Consumes(MediaType.APPLICATION_XML)</strong></span>
<span class="strong"><strong>@Produces(MediaType.APPLICATION_XML)</strong></span>
public Response addBook(Book book) {
  BooksCollection.addBook(book);
  return    Response.ok(book).
  type(MediaType.APPLICATION_XML_TYPE).build();
}</pre></div><p>As shown in this snippet we have the <code class="literal">@POST</code> annotation<a id="id59" class="indexterm"/> that indicates this method accepts <code class="literal">POST</code> request.</p><p>The <code class="literal">@Produces(MediaType.APPLICATION_XML)</code> indicates that the <code class="literal">"application/xml"</code> media type is produced by the <code class="literal">addBook()</code> method of this resource.</p><p>The <code class="literal">@Consumes(MediaType.APPLICATION_XML)</code> indicates that the <code class="literal">"application/xml"</code> media type is consumed by the <code class="literal">addBook()</code> method of this resource.</p><p>The <code class="literal">Response.ok(book)</code> method builds an ok response of the type <code class="literal">MediaType.APPLICATION_XML_TYPE</code>
</p><p>Other supported media types <code class="literal">@Produces</code> and <code class="literal">@Consumes</code> are <code class="literal">"text/xml"</code>, <code class="literal">"text/html"</code>, <code class="literal">"application/json"</code>, and so on.</p><p>If there is no media type specified in the <code class="literal">@Produces</code> or <code class="literal">@Consumes</code> annotations, support for any media type is assumed by default.</p><p>Here is a snippet of code that shows the <code class="literal">@DELETE</code> annotation.</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>@DELETE</strong></span>
@Path("/{isbn}")
public Book deleteBook(@PathParam("isbn")String isbn) {
  return BooksCollection.deleteBook(isbn);
}</pre></div><p>The <code class="literal">@PathParam</code> annotation allows you to map the URI path fragments in the method call. In this example, the <code class="literal">isbn</code> URI parameter is passed to provide information about the book.</p><p>The ISBN uniquely identifies the Book resource so that it can be deleted.</p><p>The following table summarizes important JAX-RS 2.0 annotations included in Java EE 7 and used throughout this book.</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Annotation</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">@Path</code><a id="id60" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>To <a id="id61" class="indexterm"/>annotate a POJO with the resource path it represents. For example, <code class="literal">@Path("books")</code> or to annotate a subresource that is a method in the annotated class.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">@Produces</code><a id="id62" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>To <a id="id63" class="indexterm"/>specify the output type that the resource produces, or in a narrower scope the type of output that a method in a resource produces. For example:</p>
<p>
<code class="literal">@Produces(MediaType.APPLICATION_JSON)</code>.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">@Consumes</code><a id="id64" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>To<a id="id65" class="indexterm"/> specify the type of input that the resource consumes, or in a narrower scope the type of input that a method in a resource consumes. For example:</p>
<p>
<code class="literal">@Consumes (MediaType.APPLICATION_JSON)</code>.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">@GET</code><a id="id66" class="indexterm"/>, <code class="literal">@POST</code><a id="id67" class="indexterm"/>, <code class="literal">@DELETE</code><a id="id68" class="indexterm"/>, and so on</p>
</td><td style="text-align: left" valign="top">
<p>To map the<a id="id69" class="indexterm"/> HTTP methods to <a id="id70" class="indexterm"/>methods in the <a id="id71" class="indexterm"/>resource representing class. For example, <code class="literal">@GET</code> can be placed on <code class="literal">getBook</code> method.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">@PathParam</code><a id="id72" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>To <a id="id73" class="indexterm"/>specify the mapping between query parameter names and method. For example:</p>
<p>
<code class="literal">getBook(@PathParam("isbn") String isbn)</code>.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">@ApplicationPath</code><a id="id74" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>Identifies<a id="id75" class="indexterm"/> the application path that serves as the base URI for all resource URIs provided by path. For example, <code class="literal">@ApplicationPath("library")</code> for the library application.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">@Context</code><a id="id76" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>Can be<a id="id77" class="indexterm"/> used to inject contextual objects such as <code class="literal">UriInfo</code>, which provides contextual request-specific information about the request URI. For example:</p>
<p>
<code class="literal">getBook(@Context UriInfo uriInfo,</code>
</p>
</td></tr></tbody></table></div><p>
<a class="link" href="ch05.html" title="Chapter 5. RESTful Web Services by Example">Chapter 5</a>, <span class="emphasis"><em>RESTful Web Services by Example</em></span>, covers the different JAX-RS APIs in detail and ties them together with other Java EE APIs to build a real-world library application.</p></div><div class="section" title="The Client API for JAX-RS"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec09"/>The Client API for JAX-RS</h2></div></div></div><p>JAX-RS 2.0<a id="id78" class="indexterm"/> provides a rich<a id="id79" class="indexterm"/> client API to access the web resources. Here is the code on how to use the client API for the <code class="literal">BooksResource</code> we built earlier:</p><div class="informalexample"><pre class="programlisting">Client client = ClientBuilder.newClient();
WebTarget target = client.target(URI);</pre></div><p>The default instance of the <code class="literal">javax.ws.rs.client.Client</code> object can be obtained using the <code class="literal">ClientBuilder.newClient()</code> API. The <code class="literal">BooksResource</code> can be identified by URI. The <code class="literal">WebTarget</code> object is used to build the URI.</p><div class="informalexample"><pre class="programlisting">String book = target.request().get(String.class);</pre></div><p>The <code class="literal">target.request().get(String.class)</code> method builds an HTTP <code class="literal">GET</code> request and gets an object of type <code class="literal">String</code> in the response. More samples of the client API with other verbs are shown in the next section.</p></div><div class="section" title="Entities in JAX-RS"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec10"/>Entities in JAX-RS</h2></div></div></div><p>The main part of an <a id="id80" class="indexterm"/>HTTP interaction consists of the request and response <a id="id81" class="indexterm"/>entities. Entities are also referred to as the payload or message body in some contexts.</p><p>Entities are sent via a request, usually an HTTP <code class="literal">POST</code> and <code class="literal">PUT</code> method is used, or they are returned in a response, this is relevant for all the HTTP methods. The <code class="literal">Content-Type</code> HTTP header is used to indicate the type of entity being sent. Common <span class="strong"><strong>content types</strong></span><a id="id82" class="indexterm"/> are <code class="literal">"text/plain"</code>, <code class="literal">"text/xml"</code>, <code class="literal">"text/html"</code>, and <code class="literal">"application/json"</code>.</p><p>Media types are used in the <code class="literal">Accept</code> header to indicate what type of resource representation the client wants to receive.</p><p>The following snippet shows how to use the client API to create a <code class="literal">POST</code> request. This invocation takes an entity for a user-defined class <code class="literal">Book</code> and a <code class="literal">MediaType.APPLICATION_XML_TYPE</code> parameter.</p><p>Here is the client code to invoke the <code class="literal">POST</code> method:</p><div class="informalexample"><pre class="programlisting">Response response = target.request()
post(Entity.entity(new Book("Getting Started with RESTful Web Services","111334444","Enterprise Applications"), MediaType.APPLICATION_XML_TYPE));</pre></div><p>In the preceding snippet, the <code class="literal">WebTarget#request()</code> method returns a <code class="literal">Response</code> object.</p><p>Here is the client API code to <a id="id83" class="indexterm"/>invoke the <code class="literal">delete</code> method:</p><div class="informalexample"><pre class="programlisting">response = target.path("111334444")
request( MediaType.APPLICATION_XML_TYPE)
.delete();</pre></div><p>The next section will <a id="id84" class="indexterm"/>show how the entity providers that implement the JAX-RS API map to and from Java types request and response entities.</p></div><div class="section" title="Custom entity providers in JAX-RS"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec11"/>Custom entity providers in JAX-RS</h2></div></div></div><p>JAX-RS enables <a id="id85" class="indexterm"/>developers to add custom entity providers to the <a id="id86" class="indexterm"/>application. The custom entity providers can be used for dealing with user-defined classes in the requests as well as responses.</p><p>Adding a custom entity provider provides a way to <span class="strong"><strong>deserialize</strong></span> user-defined classes from the message bodies and <span class="strong"><strong>serialize</strong></span><a id="id87" class="indexterm"/> any media type to your user specific class.</p><p>There are two types of entity providers:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">MessageBodyReader</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">MessageBodyWriter</code></li></ul></div><p>Using the <code class="literal">@Provider</code> annotation, application-specific provider classes can be discovered. Entity providers provide mapping between the representation and associated type. There is a sample included with the book that demonstrates the use of entity providers.</p><div class="section" title="MessageBodyReader"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec07"/>MessageBodyReader</h3></div></div></div><p>An application can<a id="id88" class="indexterm"/> provide<a id="id89" class="indexterm"/> an implementation of the <code class="literal">MessageBodyReader</code> interface by implementing the <code class="literal">isReadable()</code> method and the <code class="literal">readFrom()</code> method to map the entity to the desired Java type.</p><p>The following figure shows how the <code class="literal">MessageBodyReader</code> reads an <code class="literal">InputStream</code> object and converts it to a user-defined Java object.</p><div class="mediaobject"><img src="graphics/8125EN_01_01.jpg" alt="MessageBodyReader"/></div><p>The following code shows how to provide an implementation of <code class="literal">MessageBodyReader</code> and uses <span class="strong"><strong>Java Architecture for XML Binding</strong></span> (<span class="strong"><strong>JAXB</strong></span>) with<a id="id90" class="indexterm"/> JAX-RS. JAXB provides a fast and convenient way to bind<a id="id91" class="indexterm"/> XML schemas and Java <a id="id92" class="indexterm"/>representations, making it easy for Java developers to incorporate the XML data and processing functions in Java applications. As a part of this process, JAXB provides methods for <span class="strong"><strong>unmarshalling</strong></span><a id="id93" class="indexterm"/> (reading) XML instance documents into Java content trees, and then <span class="strong"><strong>marshalling</strong></span><a id="id94" class="indexterm"/> (writing) Java content trees back into XML instance documents.</p><p>Here is a JAXB root element called <code class="literal">Book</code>. <code class="literal">Book</code> has properties such as name and ISBN.</p><div class="informalexample"><pre class="programlisting">@XmlRootElement
public class Book {
  public String name;
  public String isbn;
  public String getName() {
    return name;
  }
  public String getIsbn() {
    return isbn;
  }
  public Book(String name, String isbn) {
    this.name=name;
    this.isbn=isbn;
  }
  //JAXB requires this
  public Book() {
    
  }
}</pre></div><p>The <code class="literal">MessageBodyReader</code> implementation class can provide support to read from an <code class="literal">inputStream</code> object and convert to the <code class="literal">Book</code> object. The following table shows the methods that need to be implemented:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Method of MessageBodyReader</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">isReadable()</code>
</p>
</td><td style="text-align: left" valign="top">
<p>To check if the <code class="literal">MessageBodyReader</code> class can support conversion from stream to Java type.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">readFrom()</code>
</p>
</td><td style="text-align: left" valign="top">
<p>To read a type from the <code class="literal">InputStream</code>.</p>
</td></tr></tbody></table></div><p>Here is the code for <code class="literal">SampleMessageBodyReader</code> class that is the implementation of the <code class="literal">MessageBodyReader</code> interface:</p><div class="informalexample"><pre class="programlisting">@Provider
public class SampleMessageBodyReader implements 
MessageBodyReader&lt;Book&gt; {
}</pre></div><p>The <code class="literal">@Provider</code> annotation<a id="id95" class="indexterm"/> indicates that this is a provider and the implementing class can also use<a id="id96" class="indexterm"/> <code class="literal">@Produces</code> and<a id="id97" class="indexterm"/> <code class="literal">@Consumes</code> annotations to restrict the media types they support.</p><p>Here is the <a id="id98" class="indexterm"/>implementation of<a id="id99" class="indexterm"/> <code class="literal">isReadable()</code> method:</p><div class="informalexample"><pre class="programlisting">public boolean isReadable(Class&lt;?&gt; aClass, Type type, Annotation[] annotations, MediaType mediaType) {
  return true;
}</pre></div><p>The <code class="literal">isReadable()</code> method returns <code class="literal">true</code> to indicate that this <code class="literal">SampleMessageBodyReader</code> class can process the <code class="literal">mediaType</code> parameter.</p><p>This is an implementation of the <code class="literal">readFrom()</code> method of the <code class="literal">SampleMessageBodyReader</code> class. The <code class="literal">mediaType</code> parameter can be checked here and different actions can be taken based on the media type.</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>public Book readFrom(Class&lt;Book&gt; bookClass, Type type, Annotation[] annotations,</strong></span>
MediaType mediaType,
MultivaluedMap&lt;String, String&gt; stringStringMultivaluedMap,
InputStream inputStream) throws IOException, WebApplicationException {
  try {
    
<span class="strong"><strong>    Book book = (Book)unmarshaller.unmarshal(inputStream) ;</strong></span>
    return book;
  } catch (JAXBException e) {
    e.printStackTrace();
  }
  return null;
  }
}</pre></div><p>The <code class="literal">book</code><a id="id100" class="indexterm"/> object, which is the method's return <a id="id101" class="indexterm"/>value, is then unmarshalled using JAXB <span class="strong"><strong>Unmarshaller</strong></span> using the provided <code class="literal">inputStream</code> object as the parameter.</p></div><div class="section" title="MessageBodyWriter"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec08"/>MessageBodyWriter</h3></div></div></div><p>The <code class="literal">MessageBodyWriter</code> interface <a id="id102" class="indexterm"/>represents a contract<a id="id103" class="indexterm"/> for a provider that supports the conversion from a Java type to a stream.</p><p>The following figure shows how <code class="literal">MessageBodyWriter</code> can take a user-defined class, <code class="literal">Book,</code> and marshal it to an <code class="literal">outputStream</code> object.</p><div class="mediaobject"><img src="graphics/8125EN_01_02.jpg" alt="MessageBodyWriter"/></div><p>The following table shows the methods of <code class="literal">MessageBodyWriter</code> that must be implemented along with a short description of each of its method.</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Method of MessageBodyWriter</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">isWritable()</code><a id="id104" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>To check if the <code class="literal">MessageBodyWriter class</code> can support the conversion from the specified Java type.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">getSize()</code><a id="id105" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>To check the length of bytes if the size is known or -1.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">writeTo()</code><a id="id106" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>To write from a type to the stream.</p>
</td></tr></tbody></table></div><p>Here are the methods of the <code class="literal">MessageBodyWriter</code> interface that need to be implemented:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>public boolean isWriteable(Class&lt;?&gt; aClass, Type type, Annotation[] annotations, MediaType mediaType) {</strong></span>
    return true;
}</pre></div><p>The <code class="literal">isWritable()</code><a id="id107" class="indexterm"/>method of the <code class="literal">MessageBodyWriter</code> interface <a id="id108" class="indexterm"/>can be customized to check if this implementation of <code class="literal">MessageBodyWriter</code> supports the type or not.</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>    public long getSize(Book book, Class&lt;?&gt; aClass, Type type, Annotation[] annotations, MediaType mediaType) {</strong></span>
        return -1;
    }</pre></div><p>The <code class="literal">getSize()</code> method is called before the <code class="literal">writeTo()</code> method to ascertain the length of bytes in the response.</p><div class="informalexample"><pre class="programlisting">public void writeTo(Book book, 
Class&lt;?&gt; aClass, 
Type type, Annotation[] annotations, 
MediaType mediaType,
MultivaluedMap&lt;String, Object&gt; map,
OutputStream outputStream) throws 
IOException, WebApplicationException {
  try {
    
    Marshaller marshaller = jaxbContext.createMarshaller();
    marshaller.marshal(book, outputStream);
  } catch (Exception e) {
    e.printStackTrace();
  }
}</pre></div><p>The <code class="literal">writeTo()</code> method marshals the <code class="literal">Book</code> to the <code class="literal">Outputstream</code>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip03"/>Tip</h3><p>
<span class="strong"><strong>Tips for debugging errors with </strong></span>
<code class="literal">MessageBodyReader</code>
<span class="strong"><strong> and </strong></span>
<code class="literal">MessageBodyWriter</code>
<span class="strong"><strong>:</strong></span>
</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Look for the <code class="literal">@Provider</code> annotation. <code class="literal">MessageBodyReader</code> implementation class and <code class="literal">MessageBodyWriter</code> implementation class need the <code class="literal">@Provider</code> annotation.</li><li class="listitem" style="list-style-type: disc">Confirm if the implementation classes of <code class="literal">MessageBodyReader</code> and <code class="literal">MessageBodyWriter</code> interfaces are added in the <code class="literal">getClasses()</code> method of the Application subclass.</li><li class="listitem" style="list-style-type: disc">Check if the implementation of <code class="literal">MessageBodyReader.isReadable()</code> method returns <code class="literal">true</code>.</li><li class="listitem" style="list-style-type: disc">Check if the implementation of <code class="literal">MessageBodyWriter.isWritable()</code> method returns <code class="literal">true</code>.</li><li class="listitem" style="list-style-type: disc">Confirm the <code class="literal">MessageBodyWriter.getSize()</code> method is <code class="literal">-1</code> if the size of response is unknown or set it to the right value if the size is known.</li></ul></div></div></div><p>This is how the <a id="id109" class="indexterm"/>client looks:</p><div class="informalexample"><pre class="programlisting">Client client = ClientBuilder.newClient();
client.register(MessageBodyReaderWriter.class).register(BooksResource.class);
Response response = target
.request()
.post(Entity.entity(new Book("Getting Started with RESTful Web Services","13332233"), MediaType.APPLICATION_XML_TYPE));

Book  = response.readEntity(Book.class);</pre></div><p>The <code class="literal">client.register()</code> method<a id="id110" class="indexterm"/> is used to register the <code class="literal">MessageBodyReaderWriter.class</code> and <code class="literal">BooksResource.class</code>.</p><p>The application class, <code class="literal">Book</code> is extracted from the response using <code class="literal">response.readEntity(Book.class)</code>.</p></div></div><div class="section" title="Using the Bean Validation API with JAX-RS"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec12"/>Using the Bean Validation API with JAX-RS</h2></div></div></div><p>Validation<a id="id111" class="indexterm"/> is the <a id="id112" class="indexterm"/>process of verifying that the <a id="id113" class="indexterm"/>given inputs are<a id="id114" class="indexterm"/> complying with the defined constraints. The Bean Validation specification defines the API to validate <span class="strong"><strong>JavaBeans</strong></span><a id="id115" class="indexterm"/>. This section shows how to validate the JAX-RS 2.0 resources using the Bean Validation API.</p><p>Validation can be used to ensure that fields in the JAX-RS resources follow certain constraints. For example, to check that a field is not <code class="literal">null</code> or if the ISBN follows a pattern. Using Bean Validation, a user can write custom validators and annotate the JAX-RS resources and their components using the custom validators.</p><p>The sample included along with the book will show how to use Bean Validation with JAX-RS 2.0 resources.</p><p>Here is a code snippet showing how to enforce validation along with defining a constraint and adding a user-defined message to it:</p><div class="informalexample"><pre class="programlisting">@Path("books")
<span class="strong"><strong>@ValidateOnExecution(ExecutableType.GETTER_METHODS)</strong></span>
public class BooksResource {

  @GET
  @Path("{isbn}")
  @Consumes(MediaType.APPLICATION_XML)
  @Produces(MediaType.APPLICATION_XML)
<span class="strong"><strong>  @NotNull(message="Book does not exist for the</strong></span>
<span class="strong"><strong>  ISBN requested")</strong></span>
  public Book getBook(
  @PathParam("isbn")String isbn)    {
    return BooksCollection.getBook(isbn);

  }
}</pre></div><p>The <code class="literal">@ValidateOnExecution</code> annotation can be used to selectively enable and disable the validation. In this <a id="id116" class="indexterm"/>snippet, the <code class="literal">getBook()</code> method gets validated <a id="id117" class="indexterm"/>because the <code class="literal">@ValidateOnExecution</code> annotation <a id="id118" class="indexterm"/>enables the validation for the <code class="literal">ExecutableType.GETTER_METHODS</code> value.</p><p>When the sample code is executed, if the book value is not null then, the book object is returned. If the book value is null, there is a validation error with a message shown on the screen as <code class="literal">"Book does not exist for the ISBN requested"</code>. This is the message that is provided with the <code class="literal">@NotNull</code> annotation shown previously.</p><div class="section" title="Enabling validation in the application"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec09"/>Enabling validation in the application</h3></div></div></div><p>Getting validation errors <a id="id119" class="indexterm"/>from the response is not enabled by default. The sample included in the book will demonstrate how to get the validation errors from the response. The user needs to set <code class="literal">BV_SEND_ERROR_IN_RESPONSE</code> property to Boolean value <code class="literal">true</code> using <code class="literal">Application</code> class by overriding the <code class="literal">getProperties()</code> method.</p><p>Here is the <code class="literal">getProperties()</code> method of the <code class="literal">Application</code> subclass.</p><div class="informalexample"><pre class="programlisting">@override
public Map&lt;String,Object&gt; getProperties() {
  Map&lt;String,Object&gt; properties = new HashMap&lt;String,Object&gt;() ;
<span class="strong"><strong>  properties.put(ServerProperties.BV_SEND_ERROR_IN_RESPONSE, true);</strong></span>
<span class="strong"><strong>  return properties;</strong></span>
}</pre></div><p>The <code class="literal">getProperties()</code> method <a id="id120" class="indexterm"/>returns the <code class="literal">Map&lt;String,Object&gt;</code> object with the String property <code class="literal">ServerProperties.BV_SEND_ERROR_IN_RESPONSE</code> set to the Boolean value <code class="literal">true</code>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip04"/>Tip</h3><p>
<span class="strong"><strong>Downloading the example code</strong></span>
</p><p>You can download the example code files for all Packt books you have purchased from your account at <a class="ulink" href="http://www.packtpub.com">http://www.packtpub.com</a>. If you purchased this book elsewhere, you can visit <a class="ulink" href="http://www.packtpub.com/support">http://www.packtpub.com/support</a> and register to have the files e-mailed directly to you.</p></div></div></div><div class="section" title="Reading validation errors from the response"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec10"/>Reading validation errors from the response</h3></div></div></div><p>After the application <a id="id121" class="indexterm"/>class is configured to set the String<a id="id122" class="indexterm"/> property <code class="literal">ServerProperties.BV_SEND_ERROR_IN_RESPONSE</code> to the Boolean value <code class="literal">true</code>, the following code in the servlet class will read the validation errors from the response.</p><p>This is how the code looks on the client side:</p><div class="informalexample"><pre class="programlisting">List&lt;ValidationError&gt; errors = response.readEntity(new GenericType&lt;List&lt;ValidationError&gt;&gt;() {});</pre></div><p>The <code class="literal">response.readEntity()</code> method takes a list of <code class="literal">GenericType&lt;ValidationError&gt;</code> parameters. From the <code class="literal">List&lt;ValidationError&gt;</code> <code class="literal">errors</code>, returned by the <code class="literal">response.readEntity()</code> method, we can extract the validation error and get the validation message. On running the sample, the following message will be shown:</p><p>
<span class="strong"><strong>"There was 1 error when validating the request</strong></span>
</p><p>
<span class="strong"><strong>Book does not exist for the ISBN requested"</strong></span>
</p></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec12"/>Summary</h1></div></div></div><p>This chapter started with a brief introduction to REST and the key principles of RESTful Web Services development, followed by converting a POJO to a JAX-RS resource, a RESTful endpoint along with discussing different HTTP verbs and their use.</p><p>After the introduction, the chapter dives deeper into the JAX-RS API by introducing the client API to send requests to the resources developed using the JAX-RS APIs. We also covered customizing the entity providers to produce different output formats using <code class="literal">MessageBodyReader</code> and <code class="literal">MessageBodyWriters</code>. We learned how to validate JAX-RS 2.0 resources using Bean Validation.</p><p>In the next chapter, we will cover the different polling techniques, compare and contrast them with Server-sent events (SSE) and <span class="strong"><strong>WebSockets</strong></span>, followed by a closer look at how Java EE 7 provides support for SSE and WebSockets.</p></div></body></html>