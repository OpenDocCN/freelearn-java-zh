<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Message Enrichment</h1>
                </header>
            
            <article>
                
<p>To fully understand this chapter, it is necessary to have read the previous chapter that focused on how to validate events. This chapter is focused on how to enrich events.</p>
<p>In this chapter, we will continue using the systems of Monedero, our fictitious company that is dedicated to the exchange of cryptocurrencies. If we remember in the previous chapter, the messages of Monedero were validated; in this chapter, we will continue with the same flow, but we will add one more step of enrichment.</p>
<p>In this context, we understand enrichment as adding extra data that was not in the original message. In this chapter, we will see how to enrich a message with geographic location using the MaxMind database and how to extract the current value of the exchange rate using the Open Exchange data. If we remember the events that we modeled for Monedero, each one included the IP address of the customer's computer.</p>
<p>In this chapter, we will use the MaxMind free database that provides us with an API that contains a mapping of IP addresses to their geographic location.</p>
<p>Our system in Monedero searches for the IP address of our customer in the MaxMind database to determine where the customer is located when the request to our system was made. The use of data from external sources to add them to our events is what we call message enrichment.</p>
<p class="mce-root">In the cryptocurrencies world, there is something called Bit License, in which some geographic areas are limited by law to carry out activities with cryptocurrencies. We currently have an event validation service for Monedero.</p>
<p class="mce-root">However, the legal department has asked us to have a validation filter to know the geographic location of our customers and thus be able to comply with the Bit License. The Bit License has operated in the New York area since July 2014 and applies to residents. Under the terms of the law, those considered resident are all of the people who reside, are located, have a place of business, or conduct business in the state of New York.</p>
<p>This chapter covers the following topics:</p>
<ul>
<li>How extraction works</li>
<li>How enrichment works</li>
<li>Extracting the location given an IP address</li>
<li>Extracting the currency price given a currency</li>
<li>Extracting the weather data given a location</li>
<li>Enriching messages with the geographic location</li>
<li>Enriching messages with a currency price</li>
<li>Running a processing engine</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Extracting the geographic location</h1>
                </header>
            
            <article>
                
<p>Open the <kbd>build.gradle</kbd> file on the Monedero project created in <a href="0f0c3c87-3860-4247-97b7-3ce070640dc3.xhtml" target="_blank">Chapter 2</a>, <em>Message Validation</em>, and add the lines highlighted in <em>Listing 3.1</em>.</p>
<p>The following is the content of <em>Listing 3.1</em>, the Monedero <kbd>build.gradle</kbd> file:</p>
<pre>apply plugin: 'java'<br/>apply plugin: 'application'<br/>sourceCompatibility = '1.8'<br/>mainClassName = 'monedero.ProcessingEngine'<br/>repositories {<br/>  mavenCentral()<br/>}<br/>version = '0.2.0'<br/>dependencies {<br/>    compile group: 'org.apache.kafka', name: 'kafka_2.12', version:                                                                                                                                              <br/>                                                            '2.0.0'<br/>    <strong>compile group: 'com.maxmind.geoip', name: 'geoip-api', version:                                         <br/>                                                            '1.3.1'</strong><br/>    compile group: 'com.fasterxml.jackson.core', name: 'jackson-core', version: '2.9.7'<br/>}<br/>jar {<br/>  manifest {<br/>    attributes 'Main-Class': mainClassName<br/>  } from {<br/>    configurations.compile.collect {<br/>      it.isDirectory() ? it : zipTree(it)<br/>    }<br/>  }<br/>  exclude "META-INF/*.SF"<br/>  exclude "META-INF/*.DSA"<br/>  exclude "META-INF/*.RSA"<br/>}</pre>
<div class="CDPAlignCenter CDPAlign packt_figref">Listing 3.1: build.gradle</div>
<p>Note that the first change is the switch from version 0.1.0 to version 0.2.0 .</p>
<p>The second change is to add the MaxMind's GeoIP version 1.3.1 to our project.</p>
<p>From the project root directory, run the following command to rebuild the app:</p>
<pre><strong>$ gradle jar</strong></pre>
<p>The output is something like the following:</p>
<pre><strong>...BUILD SUCCESSFUL in 8s</strong><br/><strong>2 actionable tasks: 2 executed</strong></pre>
<p>To download a copy of the MaxMind GeoIP free database, execute this command:</p>
<pre><strong>$ wget "http://geolite.maxmind.com/download/geoip/database/GeoLiteCity.dat.gz"</strong></pre>
<p>Run the following command to decompress the file:</p>
<pre><strong>$ gunzip GeoLiteCity.dat.gz</strong></pre>
<p>Move the <kbd>GeoLiteCity.dat</kbd> file in a route accessible to our program.</p>
<p>Now, add a file called <kbd>GeoIPService.java</kbd> in the <kbd>src/main/java/monedero/extractors</kbd> directory containing the content of <em>Listing 3.2</em>:</p>
<pre>package monedero.extractors;<br/>import com.maxmind.geoip.Location;<br/>import com.maxmind.geoip.LookupService;<br/>import java.io.IOException;<br/>import java.util.logging.Level;<br/>import java.util.logging.Logger;<br/>public final class GeoIPService {<br/>  private static final String MAXMINDDB = "/path_to_your_GeoLiteCity.dat_file";<br/>  public Location getLocation(String ipAddress) {<br/>    try {<br/>      final LookupService maxmind = <br/>        new LookupService(MAXMINDDB, LookupService.GEOIP_MEMORY_CACHE);<br/>      return maxmind.getLocation(ipAddress);<br/>    } catch (IOException ex) {<br/>      Logger.getLogger(GeoIPService.class.getName()).log(Level.SEVERE, null, ex);<br/>    }<br/>    return null;<br/>  }<br/>}</pre>
<div class="CDPAlignCenter CDPAlign packt_figref">Listing 3.2: <span>GeoIPService.java</span></div>
<p>The <kbd>GeoIPService</kbd> has a public method <kbd>getLocation</kbd> that receives a string representing the IP address and looks for this IP address in the GeoIP location database. This method returns an object of class location with the geographic location of that specific IP address.</p>
<p>There are sometimes demanding customers who ask to have the most updated version of the database. In this case, downloading the database continuously is not an option. For this type of case, MaxMind exposes its services through an API. To read more about it, visit the following URL: <a href="https://dev.maxmind.com/">https://dev.maxmind.com/</a>.</p>
<p>To read more about Bit License regulations, visit the following link:</p>
<p><a href="http://www.dfs.ny.gov/legal/regulations/bitlicense_reg_framework.html">http://www.dfs.ny.gov/legal/regulations/bitlicense_reg_framework.html</a></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Enriching the messages</h1>
                </header>
            
            <article>
                
<p>Now, we will recap the steps of our processing engine for Monedero. The customer consults the ETH price in the client's browser and is sent to Kafka through some HTTP event collector.</p>
<p>The first step in our flow is the event correctness validation; remember from the previous chapter that the messages with defects are derived from bad data and that is why they are filtered. The second step now is to enrich our message with geographic location information.</p>
<p class="mce-root"/>
<p>Here are the architecture <span>steps </span>for the Monedero processing engine:</p>
<ol>
<li>Read the individual events from a Kafka topic called <strong>input-messages</strong></li>
<li>Validate the message, sending any defective event to a dedicated Kafka topic called <strong>invalid-messages</strong></li>
<li>Enrich the message with the geographic location data</li>
<li>Write the enriched messages in a Kafka topic called <strong>valid-messages</strong></li>
</ol>
<p>All of these steps of the second version of the stream processing engine are detailed in <em>Figure 3.1</em>:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/9b129c45-0cc2-4454-ab78-56f2fb37b947.png" style=""/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Figure 3.1: The processing engine reads the events from the input-messages topic, validates the messages, sends the errors to invalid-messages topic, enriches the messages with geographic location, and then writes them to the valid-messages topic.</div>
<p>Now, let's create a file called <kbd>Enricher.java</kbd> in the <kbd>src/main/java/monedero/</kbd> <span>directory </span>with the content of <em>Listing 3.</em><em>3</em>:</p>
<pre>package monedero;<br/><br/>import com.fasterxml.jackson.databind.JsonNode;<br/>import com.fasterxml.jackson.databind.ObjectMapper;<br/>import com.fasterxml.jackson.databind.node.ObjectNode;<br/>import com.maxmind.geoip.Location;<br/>import monedero.extractors.GeoIPService;<br/>import org.apache.kafka.clients.producer.KafkaProducer;<br/>import java.io.IOException;<br/><br/>public final class Enricher implements Producer {<br/>  private final KafkaProducer&lt;String, String&gt; producer;<br/>  private final String validMessages;<br/>  private final String invalidMessages;<br/>  private static final ObjectMapper MAPPER = new ObjectMapper();<br/>  public Enricher(String servers, String validMessages, String <br/>    invalidMessages) {<br/>    this.producer = new KafkaProducer&lt;&gt; <br/>    (Producer.createConfig(servers));<br/>    this.validMessages = validMessages;<br/>    this.invalidMessages = invalidMessages;<br/>  }<br/>  @Override<br/>  public void process(String message) {<br/>    try {<br/>      // this method below is filled below  <br/>    } catch (IOException e) {<br/>      Producer.write(this.producer, this.invalidMessages, "{\"error\": \""<br/>          + e.getClass().getSimpleName() + ": " + e.getMessage() + "\"}");<br/>    }<br/>  }<br/>}</pre>
<p>As expected, the <kbd>Enricher</kbd> class implements the producer interface; therefore the <kbd>Enricher</kbd> is a producer.</p>
<p>Let's fill the code of the <kbd>process()</kbd> method.</p>
<p>If the customer message does not have an IP address, the message is <span>automatically </span>sent to <kbd>invalid-messages</kbd> topic, as follows:</p>
<pre>      final JsonNode root = MAPPER.readTree(message);<br/>      final JsonNode ipAddressNode =   <br/>        root.path("customer").path("ipAddress");<br/>      if (ipAddressNode.isMissingNode()) {<br/>        Producer.write(this.producer, this.invalidMessages,<br/>            "{\"error\": \"customer.ipAddress is missing\"}");<br/>      } else {<br/>        final String ipAddress = ipAddressNode.textValue();</pre>
<p>The <kbd>Enricher</kbd> class invokes the <kbd>getLocation</kbd> <span>method </span>of <kbd>GeoIPService</kbd> , as follows:</p>
<pre><span>final Location location = new GeoIPService().getLocation(ipAddress);</span></pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>The country and the city of the location are added to the customer message, as in the example:</p>
<pre class="mce-root">        ((ObjectNode) root).with("customer").put("country",  <br/>             location.countryName); <br/>        ((ObjectNode) root).with("customer").put("city", <br/>             location.city);</pre>
<p class="mce-root">The enriched message is written to the <kbd>valid-messages</kbd> queue, as follows:</p>
<pre>        Producer.write(this.producer, this.validMessages, <br/>           MAPPER.writeValueAsString(root));<br/>    }</pre>
<p>Note that the location object brings more interesting data; for this example, just the city and the country are extracted. For example, the MaxMind database can give us much more precision than the one exploited in this example. In effect, the online API can accurately show the exact location of an IP.</p>
<p>Also note that here we have a very simple validation. In the next chapter, we will see how to validate the schema correctness. For the moment, think of other validations that are missing to have a system that meets the business requirements.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Extracting the currency price</h1>
                </header>
            
            <article>
                
<p>At the moment, Monedero has a service that validates the messages that are well formed. The service also enriches the messages with the customer's geographic location.</p>
<p>Recall that the Monedero core business is the cryptocurrencies exchange. So now, the business asks us for a service that returns the requested currency price online at a specific time.</p>
<p>To achieve this, we will use the exchange rate of open exchange rates:</p>
<p><a href="https://openexchangerates.org/">https://openexchangerates.org/</a></p>
<p>To obtain a free API key, you have to register in a free plan; the key is needed to access the free API.</p>
<p class="mce-root"/>
<p>Now, let's create a file called <kbd>OpenExchangeService.java</kbd> in the <kbd>src/main/java/monedero/extractors</kbd> <span>directory </span>with the content of <em>Listing 3.4</em>:</p>
<pre>package monedero.extractors;<br/>import com.fasterxml.jackson.databind.JsonNode;<br/>import com.fasterxml.jackson.databind.ObjectMapper;<br/>import java.io.IOException;<br/>import java.net.URL;<br/>import java.util.logging.Level;<br/>import java.util.logging.Logger;<br/>public final class OpenExchangeService {<br/>  private static final String API_KEY = "YOUR_API_KEY_VALUE_HERE";  //1<br/>  private static final ObjectMapper MAPPER = new ObjectMapper();<br/>  public double getPrice(String currency) {<br/>    try {<br/>      final URL url = new URL("https://openexchangerates.org/api/latest.json?app_id=" + API_KEY);  //2<br/>      final JsonNode root = MAPPER.readTree(url);<br/>      final JsonNode node = root.path("rates").path(currency);   //3<br/>      return Double.parseDouble(node.toString());                //4<br/>    } catch (IOException ex) {<br/>   Logger.getLogger(OpenExchangeService.class.getName()).log(Level.SEVERE, null, ex);<br/>    }<br/>    return 0;<br/>  }<br/>}</pre>
<p>Some lines of the <kbd>OpenExchangeService</kbd> class can be analyzed as follows:</p>
<ul>
<li>In line <kbd>//1</kbd>, the value of the <kbd>API_KEY</kbd> is assigned when you registered in the open exchange rates page; the free plan gives you up to 1,000 requests per month.</li>
<li>In line <kbd>//2</kbd>, our class invokes the open exchange API URL, using your <kbd>API_KEY</kbd>. To check the prices at the moment, you can access the URL (counts as a request with your key): <a href="https://openexchangerates.org/api/latest.json?app_id=YOUR_API_KEY">https://openexchangerates.org/api/latest.json?app_id=YOUR_API_KEY</a><span>. </span>   </li>
<li>In line <kbd>//3</kbd>, the currency string passed as argument is searched in the JSON tree that returns the web page.</li>
<li>In line <kbd>//4</kbd>, the currency price (in US dollars) of the currency passed as an argument is returned as a double value.</li>
</ul>
<p class="mce-root"/>
<p>There are several ways to parse JSON, and whole books are <span>devoted</span> to this topic. For this example, we used Jackson to parse JSON. To find more information, <span>go to the following URL</span>:</p>
<p><a href="https://github.com/FasterXML">https://github.com/FasterXML</a></p>
<p>As with the MaxMind geographic localization service, open exchange rates also expose their services through an API. To read more about this, go to the following URL:</p>
<p><a href="https://docs.openexchangerates.org/">https://docs.openexchangerates.org/</a></p>
<p>This example uses the open exchange rates free plan; if a non-limited API is required, check their other plans in the URL:</p>
<p><a href="https://openexchangerates.org/signup">https://openexchangerates.org/signup</a></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Enriching with currency price</h1>
                </header>
            
            <article>
                
<p>The customer consults the ETH price event, starts in the client's web browser, and is dispatched to Kafka through some HTTP event collector. The second step is to enrich the messages with the geographic location information from MaxMind database. The third step is to enrich the message with the currency price from open exchange rates service.</p>
<p>In summary, h<span>ere are the architecture </span><span>steps </span><span>for the Monedero </span><span>processing engine</span>:</p>
<ol>
<li>Read the individual events from a Kafka topic called <strong>input-messages</strong></li>
<li>Validate the message, sending any defective event to a specific Kafka topic called <strong>invalid-messages</strong></li>
<li>Enrich the message with the geographic location data from MaxMind database</li>
<li>Enrich the message with the currency price from open exchange rates service</li>
<li>Write the enriched messages in a Kafka topic called <strong>valid-messages</strong></li>
</ol>
<p>The final version of the stream processing engine is detailed in <em>Figure 3.2</em>:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/4b4dd6ce-00f0-4d3c-8d7e-5fec1a08b290.png" style=""/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Figure 3.2: The processing engine reads the messages from the input-messages topic, validates the messages, routes the defective ones to invalid-messages queue, enriches the messages with geographic location and price, and finally, writes them to valid-messages queue.</div>
<p>To add the open exchange rates service to our engine, modify the <kbd>Enricher.java</kbd> file in the <kbd>src/main/java/monedero/</kbd> <span>directory </span>with the changes highlighted in <em>Listing 3.5</em>:</p>
<pre>package monedero;<br/>import com.fasterxml.jackson.databind.JsonNode;<br/>import com.fasterxml.jackson.databind.ObjectMapper;<br/>import com.fasterxml.jackson.databind.node.ObjectNode;<br/>import com.maxmind.geoip.Location;<br/>import monedero.extractors.GeoIPService;<br/>import monedero.extractors.OpenExchangeService; //1<br/>import org.apache.kafka.clients.producer.KafkaProducer;<br/>import java.io.IOException;<br/>public final class Enricher implements Producer {<br/>  private final KafkaProducer&lt;String, String&gt; producer;<br/>  private final String validMessages;<br/>  private final String invalidMessages;<br/>  private static final ObjectMapper MAPPER = new ObjectMapper();<br/>  public Enricher(String servers, String validMessages, String invalidMessages) {<br/>    this.producer = new KafkaProducer&lt;&gt;(Producer.createConfig(servers));<br/>    this.validMessages = validMessages;<br/>    this.invalidMessages = invalidMessages;<br/>  }<br/>  @Override<br/>  public void process(String message) {<br/>    try {<br/>      final JsonNode root = MAPPER.readTree(message);<br/>      final JsonNode ipAddressNode = root.path("customer").path("ipAddress");<br/>      if (ipAddressNode.isMissingNode()) { //2<br/>        Producer.write(this.producer, this.invalidMessages,<br/>           "{\"error\": \"customer.ipAddress is missing\"}");<br/>      } else {<br/>        final String ipAddress = ipAddressNode.textValue();<br/>        final Location location = new GeoIPService().getLocation(ipAddress);<br/>        ((ObjectNode) root).with("customer").put("country", location.countryName);<br/>        ((ObjectNode) root).with("customer").put("city", location.city);<br/>        final OpenExchangeService oes = new OpenExchangeService(); //3<br/>        ((ObjectNode) root).with("currency").put("rate", oes.getPrice("BTC"));//4<br/>        Producer.write(this.producer, this.validMessages, MAPPER.writeValueAsString(root)); //5<br/>      }<br/>    } catch (IOException e) {<br/>      Producer.write(this.producer, this.invalidMessages, "{\"error\": \""<br/>          + e.getClass().getSimpleName() + ": " + e.getMessage() + "\"}");<br/>    }<br/>  }<br/>}</pre>
<p>As we know, the <kbd>Enricher</kbd> class is a Kafka producer, so now let's analyze the additions:</p>
<ul>
<li>In line <kbd>//1</kbd>, we import <kbd>OpenExchangeService</kbd> built previously</li>
<li>In line <kbd>//2</kbd>, to avoid later null pointer exceptions, if the message does not have a valid IP Address on customer, the message automatically is sent to the <kbd>invalid-messages</kbd> queue</li>
<li>In line <kbd>//3</kbd>, generates an instance of the <kbd>OpenExchangeService</kbd> class that is an extractor</li>
<li>In line <kbd>//4</kbd>, the <kbd>getPrice()</kbd> method of the <kbd>OpenExchangeService</kbd> class is called, and this value is added to the message: the price of the currency is added to the currency node in the leaf price</li>
<li>In line <kbd>//5</kbd>, the enriched message is written to the <kbd>valid-messages</kbd> queue</li>
</ul>
<p>This is the final version of the enricher engine for Monedero; as we can see, the pipeline architecture uses the extractors as input for the enricher. Next, we will see how to run our entire project.</p>
<p class="mce-root"/>
<p>Note that the JSON response has a lot of more information, but for this example, only one currency price is used. There are several open data initiatives that are free and provide a lot of free repositories with online and historical data.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Running the engine</h1>
                </header>
            
            <article>
                
<p>Now that the final version of the <kbd>Enricher</kbd> class is coded, we have to compile and execute it.</p>
<p>As we know, the <kbd>ProcessingEngine</kbd> class contains the main method to coordinate the reader and writer classes. Now, let's modify the <kbd>ProcessingEngine.java</kbd> file on the <kbd>src/main/java/monedero/</kbd> <span>directory </span>and replace <kbd>Validator</kbd> with <kbd>Enricher</kbd> as in the highlighted code in <em>Listing 3.6</em>:</p>
<pre>package monedero;<br/>public class ProcessingEngine {<br/>  public static void main(String[] args){<br/>    String servers = args[0];<br/>    String groupId = args[1];<br/>    String sourceTopic = args[2];<br/>    String validTopic = args[3];<br/>    String invalidTopic = args[4];<br/>    Reader reader = new Reader(servers, groupId, sourceTopic);<br/>    Enricher enricher = new Enricher(servers, validTopic, invalidTopic);<br/>    reader.run(enricher);<br/>  }<br/>}</pre>
<div class="packt_figref CDPAlignCenter CDPAlign">Listing 3.6: ProcessingEngine.java</div>
<p>The processing engine receives the following five arguments from the command line:</p>
<ul>
<li><kbd>args[0]</kbd> <kbd>servers</kbd> indicates the host and port of the Kafka broker</li>
<li><kbd>args[1]</kbd> <kbd>groupId</kbd> indicates that the consumer is part of this Kafka consumer group</li>
<li><kbd>args[2]</kbd> <kbd>input topic</kbd> indicates the topic where the reader reads from</li>
<li><kbd>args[3]</kbd> <kbd>validTopic</kbd> indicates the topic where valid messages are sent</li>
<li><kbd>args[4]</kbd> <kbd>invalidTopic</kbd> indicates the topic where invalid messages are sent</li>
</ul>
<p>To rebuild the project from the <kbd>monedero</kbd> directory, run the following command:</p>
<pre><strong>$ gradle jar</strong></pre>
<p class="mce-root"/>
<p>If everything is OK, the output should be similar to the following:</p>
<pre><strong>...</strong><br/><strong>BUILD SUCCESSFUL in 8s</strong><br/><strong>2 actionable tasks: 2 executed</strong></pre>
<p>To run the project, we need four different command-line windows. <em>Figure 3.3</em> shows the command-line windows arrangement:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/b86f2503-f885-4cf8-aa64-d54022cdd74d.jpg" style=""/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 3.3: The four terminal windows to test the processing engine including: message producer, valid message consumer, invalid message consumer, and the processing engine itself</div>
<ol>
<li>In the first command-line terminal, go to the Kafka installation directory and generate the two necessary topics, as follows:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ bin/kafka-topics --create --zookeeper localhost:2181 --<br/>replication-factor 1 --<br/>partitions 1 --topic valid-messages</strong></pre>
<pre style="padding-left: 60px"><strong>$ bin/kafka-topics --create --zookeeper localhost:2181 --<br/>replication-factor 1 --</strong><br/><strong>partitions 1 --topic invalid-messages</strong></pre>
<p style="padding-left: 60px">Then, start a console producer to the <kbd>input-topic</kbd> topic, as follows:</p>
<pre style="padding-left: 60px"><strong>$ bin/kafka-console-producer --broker-list localhost:9092 --topic <br/>input-topic</strong></pre>
<p style="padding-left: 60px">This window is where the input messages are produced (typed).</p>
<ol start="2">
<li>In the second command-line window, start a command-line consumer listening to the <kbd>valid-messages</kbd> topic, as follows:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ bin/kafka-console-consumer --bootstrap-server localhost:9092 --<br/>from-beginning -<br/>-topic valid-messages</strong></pre>
<p class="mce-root"/>
<ol start="3">
<li>In the third command-line window, start a command-line consumer listening to <kbd>invalid-messages</kbd> topic, as follows:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ bin/kafka-console-consumer --bootstrap-server localhost:9092 --<br/>from-beginning -<br/>-topic invalid-messages</strong></pre>
<ol start="4">
<li>In the fourth command-line terminal, start up the processing engine. From the project root directory (where the <kbd>gradle jar</kbd> command were executed) run this command:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ java -jar ./build/libs/monedero-0.2.0.jar localhost:9092 foo <br/>input-topic valid-<br/>messages invalid-messages</strong></pre>
<p>From the first command-line terminal (the console producer), send the following three messages (remember to type enter between messages and execute each one in just one line):</p>
<pre><strong>{"event": "CUSTOMER_CONSULTS_ETHPRICE", "customer": {"id": "14862768", "name": "Snowden, Edward", "ipAddress": "95.31.18.111"}, "currency": {"name": "ethereum", "price": "USD"}, "timestamp": "2018-09-28T09:09:09Z"}</strong><br/><strong>{"event": "CUSTOMER_CONSULTS_ETHPRICE", "customer": {"id": "13548310", "name": "Assange, Julian", "ipAddress": "185.86.151.11"}, "currency": {"name": "ethereum", "price": "USD"}, "timestamp": "2018-09-28T08:08:14Z"}</strong><br/><strong>{"event": "CUSTOMER_CONSULTS_ETHPRICE", "customer": {"id": "15887564", "name": "Mills, Lindsay", "ipAddress": "186.46.129.15"}, "currency": {"name": "ethereum", "price": "USD"}, "timestamp": "2018-09-28T19:51:35Z"}</strong></pre>
<p>As these are valid messages, the messages typed in the producer console should appear in the valid-messages consumer console window, as in the example:</p>
<pre><strong>{"event": "CUSTOMER_CONSULTS_ETHPRICE", "customer": {"id": "14862768", "name": "Snowden, Edward", "ipAddress": "95.31.18.111", "country":"Russian Federation","city":"Moscow"}, "currency": {"name": "ethereum", "price": "USD", "rate":0.0049}, "timestamp": "2018-09-28T09:09:09Z"}</strong><br/><strong>{"event": "CUSTOMER_CONSULTS_ETHPRICE", "customer": {"id": "13548310", "name": "Assange, Julian", "ipAddress": "185.86.151.11", "country":"United Kingdom","city":"London"}, "currency": {"name": "ethereum", "price": "USD", "rate":0.049}, "timestamp": "2018-09-28T08:08:14Z"}</strong><br/><strong>{"event": "CUSTOMER_CONSULTS_ETHPRICE", "customer": {"id": "15887564", "name": "Mills, Lindsay", "ipAddress": "186.46.129.15", "country":"Ecuador","city":"Quito"}, "currency": {"name": "ethereum", "price": "USD", "rate":0.049}, "timestamp": "2018-09-28T19:51:35Z"}</strong></pre>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Extracting the weather data</h1>
                </header>
            
            <article>
                
<p>Obtaining the geo<span>graphic</span> location from the IP address is a problem that has already been solved in this chapter.</p>
<p>In this last section, we will build another extractor that will be used in the following chapters. Now, suppose we want to know the current temperature of a given a geographic location at a specific time. To achieve this, we use the OpenWeatherService.</p>
<p>Visit the Open Weather page: <a href="https://openweathermap.org/">https://openweathermap.org/</a>.<a href="https://openweathermap.org/"/></p>
<p>To obtain a free API key register in a free plan; this key is needed to access the free API.</p>
<p>Now, create a file called <kbd>OpenWeatherService.java</kbd> in the <kbd>src/main/java/monedero/extractors</kbd> <span>directory </span>with the content of <em>Listing 3.7</em>:</p>
<pre style="padding-left: 30px">package monedero.extractors;<br/>import com.fasterxml.jackson.databind.JsonNode;<br/>import com.fasterxml.jackson.databind.ObjectMapper;<br/>import java.io.IOException;<br/>import java.net.URL;<br/>import java.util.logging.Level;<br/>import java.util.logging.Logger;<br/>public class OpenWeatherService {<br/>  private static final String API_KEY = "YOUR API_KEY_VALUE"; //1<br/>  private static final ObjectMapper MAPPER = new ObjectMapper();<br/>  public double getTemperature(String lat, String lon) {<br/>    try {<br/>      final URL url = new URL(<br/>          "http://api.openweathermap.org/data/2.5/weather?lat=" + lat             + "&amp;lon="+ lon +<br/>          "&amp;units=metric&amp;appid=" + API_KEY); //2<br/>      final JsonNode root = MAPPER.readTree(url);<br/>      final JsonNode node = root.path("main").path("temp");/73<br/>      return Double.parseDouble(node.toString());<br/>    } catch (IOException ex) {<br/>      Logger.getLogger(OpenWeatherService.class.getName()).log(Level.SEVERE, null, ex);<br/>    }<br/>    return 0;<br/>  }<br/>}</pre>
<div class="packt_figref CDPAlignCenter CDPAlign">Listing 3.7: OpenWeatherService.java</div>
<p>The public method, <kbd>getTemperature()</kbd>, in the <kbd>OpenWeatherService</kbd> class receives two string values—the geographic latitude and longitude—and returns the current temperature for these locations. If the metric system is specified, the result will be in <span>degrees</span><span> celsius.</span></p>
<p>In a nutshell, the file includes the following:</p>
<ul>
<li>In line <kbd>//1</kbd>, to use the Open Weather API, a KEY is needed, registration is free, and gives 1,000 requests per month</li>
<li>In line <kbd>//2</kbd>, to check the current weather at a particular location, open the following URL: <a href="http://api.openweathermap.org/data/2.5/weather?%C2%A0lat=LAT&amp;lon=LON&amp;units=metric&amp;appid=YOUR_API_KEY">http://api.openweathermap.org/data/2.5/weather? lat=LAT&amp;lon=LON&amp;units=metric&amp;appid=YOUR_API_KEY</a></li>
<li>In line <kbd>//3</kbd>, the JSON returned by this URL is parsed looking for the temperature</li>
</ul>
<p>Open Weather also exposes their services through an API. To read how to use this API, go to the following:</p>
<p><a href="https://openweathermap.org/api">https://openweathermap.org/api</a></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we covered how to make data extraction, how message enrichment works, and how to extract the geographic location given an IP Address. Also, we demonstrated an example of how to extract the currency price given a currency and running a processing engine.</p>
<p>The <a href="b444c6b4-4a8f-478c-9d3f-93a432d168b8.xhtml" target="_blank">Chapter 4</a>, <em>Serialization</em>, talks about the schema registry. The extractors built in this chapter are used in the following chapters.</p>


            </article>

            
        </section>
    </body></html>