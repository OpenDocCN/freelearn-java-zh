- en: Data classes and their usage
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据类及其用法
- en: Work is in progress on data classes under the Project Amber. It proposes to
    bring to developers a simplified way of modelling data as data, by introducing
    special classes with the keyword record. The state of the data class would be
    able to be captured using the class header, which is in stark contrast to what
    the existing **Plain Old Java Objects** (**POJO**) offer at present.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在Project Amber项目中，正在对数据类进行工作。它提议通过引入具有关键字record的特殊类，为开发者提供一种简化的方式来建模数据作为数据。数据类的状态可以通过类头来捕获，这与现有的**普通Java对象**（**POJO**）目前提供的功能形成鲜明对比。
- en: 'In the chapter, we''ll cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: An introduction to the data classes
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据类的介绍
- en: Need of the data classes and their limitations
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据类的必要性及其局限性
- en: Aggregate and exploded form of a data class
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据类的聚合和展开形式
- en: Pattern matching with data classes
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据类与模式匹配
- en: Inheritance with abstract data classes and interfaces
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象数据类和接口的继承
- en: Adding variables and methods
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加变量和方法
- en: Overriding default behavior
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 覆盖默认行为
- en: Introduction to the data classes
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据类的介绍
- en: We know of two versions of data classes—POJO (the old and existing way) and
    the new proposed data classes. To appreciate the data classes that is in works
    under the Project Amber, you'll need to know what the capabilities and limitations
    of existing POJO classes are and why do we need the new proposed data classes.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道有两种版本的数据类——POJO（旧的和现有的方式）以及新提议的数据类。为了欣赏在Project Amber下进行工作的数据类，你需要了解现有POJO类的功能和局限性，以及为什么我们需要新提议的数据类。
- en: POJO is not implemented using a language construct. The proposed data classes
    would include changes or additions to the programming language.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: POJO不是使用语言结构实现的。拟议的数据类将包括对编程语言的更改或添加。
- en: What is a data class
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是数据类
- en: 'As a Java developer, you probably have used and created POJOs in some or all
    your projects. It is a class that encapsulates a set of data, without any additional
    behavior to manipulate its state. It usually includes constructors, accessors,
    mutators, and the overridden methods from the object class, namely—`hashCode()`,
    `equals()`, and `toString()`. The accessors and mutators allow access and assignment
    to the state variables. Additionally, the mutators might include code to check
    the range of values that are assigned to the instance state. Here''s an example:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 作为Java开发者，你可能已经在你的某些或所有项目中使用并创建了POJO。这是一个封装了一组数据的类，没有额外的行为来操作其状态。它通常包括构造函数、访问器、修改器和从对象类继承的覆盖方法，即——`hashCode()`、`equals()`和`toString()`。访问器和修改器允许访问和分配状态变量。此外，修改器可能包括检查分配给实例状态的值范围的代码。以下是一个示例：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'One of the cases is to use the `Emp` class to save employee data to your database.
    Here''s an example:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个案例是使用`Emp`类将员工数据保存到您的数据库中。以下是一个示例：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Similarly, you could also use the `Emp` class to be passed in a message, to
    be sent over the network, to insert it into a JSON object and many more.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，您也可以使用`Emp`类将消息传递过去，通过网络发送，将其插入JSON对象，等等。
- en: This all looks good. More importantly, this has been working fine ever since
    Java was introduced to the developers. So, what is the problem?
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来都很好。更重要的是，自从Java被引入开发者以来，这一直工作得很好。那么，问题是什么？
- en: Need of adding data classes to the language
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加数据类到语言中的必要性
- en: Imagine securing the borders of a country. The norm for it is to be guarded
    by the defense forces. Will the level of security change based on the relationship
    between the neighboring countries (cordial, neuter or tense)? What happens if
    the borders are porous, or say, for example, the way it is in Western Europe for
    the Schengen countries? Now, compare guarding borders of a country with guarding
    our homes or, say, securing the contents of a cabinet in a room.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下保卫一个国家的边境。通常的做法是由国防部队来守卫。安全水平是否会根据邻国之间的关系（友好、中立或紧张）而改变？如果边境是渗透的，或者说，例如，像西欧对申根国那样，会发生什么？现在，将保卫一个国家的边境与保卫我们的家园或，比如说，保卫房间里一个柜子的内容进行比较。
- en: Though each instances in the preceding example is talking about security of
    an entity and its protection from a physical attack, they all have varied requirements.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管前面示例中的每个实例都在谈论实体的安全性和其免受物理攻击的保护，但它们都有不同的需求。
- en: 'Similarly, until now, the classes in Java have been used to model a wide range
    of requirements. While this works well for a lot of cases, it doesn''t work for
    some. If you want to make the same size fit all, you''ll need a lot of adjustments
    for most of them. Compare it with using the same trouser size for individuals
    with varied height and waist size, as shown in the following image:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，到目前为止，Java中的类被用来模拟广泛的需求。虽然这对于很多情况来说效果很好，但对于某些情况则不适用。如果你想使所有的大小都适合，你将需要对大多数进行调整。以下图像显示了使用相同裤子尺寸为身高和腰围各不相同的人穿裤子的情况：
- en: '![](img/bc0292c8-734a-4741-ae41-63ea941069a6.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bc0292c8-734a-4741-ae41-63ea941069a6.png)'
- en: In the past, enum were added to the Java language (version 5). Even though a
    class can be programmed to create an enumeration of primitives or objects, enums
    simplified the process for a developer.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去，枚举被添加到Java语言中（版本5）。尽管一个类可以被编程来创建原始类型或对象的枚举，但枚举简化了开发者的过程。
- en: Enums reduced the coding for developers. At the same time, it made the intent
    of the enum explicit to its users
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举减少了开发者的编码工作。同时，它使枚举的意图对用户来说更加明确
- en: In the preceding section, `Emp` POJO is just a carrier of its data. However,
    to season a class to behave like a data class, requires a developer to define
    multiple methods—constructs, accessor, mutator, and other methods from the object
    class. You might argue that you can use an IDE to easily generate all these methods
    for your class. You are right! And it's quite simple to do so.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，`Emp` POJO只是一个数据的载体。然而，为了让一个类表现得像一个数据类，需要开发者定义多个方法——构造函数、访问器、修改器以及从对象类中来的其他方法。你可能会争辩说你可以使用IDE轻松地为你的类生成所有这些方法。你说得对！而且这样做很简单。
- en: But it only takes care of the writing part of code. What happens to the reading
    of the code by the users of the class? As developers, we all understand that a
    piece of code might be written just once, but it is read multiple times. This
    is the reason, why experienced programmers stress on good coding practices, for
    comprehending, reading and maintaining code.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 但它只关注代码的编写部分。对于类的用户来说，代码的阅读情况如何呢？作为开发者，我们都明白一段代码可能只编写一次，但它会被多次阅读。这就是为什么经验丰富的程序员强调良好的编码实践，以便理解、阅读和维护代码。
- en: When definition of data classes is induced in the language, the readers of the
    code would know its explicit intent of just being a data class. The developers
    would not need to dig their claws deep into the code, finding code, that was in
    addition to them just being a data class, so as they don't miss any important
    information.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当数据类的定义被引入到语言中时，代码的读者就会知道它仅仅是一个数据类的明确意图。开发者不需要深入挖掘代码，寻找除了作为数据类之外的其他代码，这样他们就不会错过任何重要信息。
- en: It will also prevent the developers from using half-baked classes as data class.
    At times developers tend to use classes that might not include all the relevant
    methods (like `equals()` or `hashCode()`), as a data class, but it is sure a good
    recipe to insert subtle bugs in your applications. A collection class like `Map`,
    requires a class to implement its `equals()` and `hashCode()` methods to function
    properly and efficiently.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 它还将防止开发者使用半成品类作为数据类。有时开发者倾向于使用可能不包括所有相关方法（如`equals()`或`hashCode()`）的类作为数据类，但这确实是在应用程序中插入细微错误的良方。像`Map`这样的集合类需要类实现其`equals()`和`hashCode()`方法才能正常高效地工作。
- en: Introducing data classes with the change in language would decrease the verbosity
    of the language, broadcast the intent of the structure to all.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 通过语言的变化引入数据类将减少语言的冗长性，向所有人传达结构的目的。
- en: Deep dive into data classes
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入了解数据类
- en: The syntax to define a data class looks simple. However, both the syntax and
    the semantics are important.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 定义数据类的语法看起来很简单。然而，语法和语义都很重要。
- en: An example
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个例子
- en: 'Let''s get started by re-defining the `Emp` class, which we used in the beginning
    of the chapter, as a data class:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从重新定义`Emp`类开始，这是我们在本章开头使用的，将其定义为数据类：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The preceding code uses the keyword `record` to define a data class, accepting
    comma separated variable name and type, required to store the state. The compiler
    automatically generates default implements for the Object methods (`equals()`,
    `hashCode()`, `toString()`) for data classes.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码使用关键字`record`来定义数据类，接受逗号分隔的变量名和类型，这些是存储状态所必需的。编译器会自动为数据类生成默认实现Object方法（`equals()`、`hashCode()`、`toString()`）。
- en: The code looks clear and compact. A reader would immediately know the intent
    of this single line of code, a carrier of data `name` (type `String`) and `age`
    (type `int`). Another advantage for a reader is that she wouldn't need to read
    through constructors, accessors, mutators, or methods of the object class, just
    to ascertain that they are doing what they are supposed to, not more, which they
    should be aware of.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 代码看起来清晰且紧凑。读者会立即知道这一行代码的意图，这是一个携带数据`name`（类型`String`）和`age`（类型`int`）的数据载体。对读者来说另一个优点是，她不需要阅读构造函数、访问器、修改器或对象类的其他方法，只需确认它们正在做它们应该做的事情，不多也不少，这是他们应该知道的。
- en: 'Behind the scenes, the record class `Emp` is converted to the following by
    the Java compiler:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在幕后，Java编译器将记录类`Emp`转换为以下形式：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The preceding data class is an example of a non-abstract data class. A data
    class can also be defined as an abstract data class. A non-abstract data class
    is implicitly final. In both cases, a data class would get default implementations
    of `hashCode()`, `equals()` and `toString()`, and accessor methods. For an abstract
    data class, the constructors would be protected.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的数据类是一个非抽象数据类的示例。数据类也可以定义为抽象数据类。非抽象数据类隐式为最终类。在两种情况下，数据类都会获得`hashCode()`、`equals()`和`toString()`以及访问器方法的默认实现。对于抽象数据类，构造函数将是受保护的。
- en: 'In the following image, the compiler looks happy to convert one liner code
    for the data class, to a full-fledged class:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下图像中，编译器很高兴将数据类的单行代码转换为完整的类：
- en: '![](img/4c986559-e3f7-4fad-ba6a-aac011072490.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4c986559-e3f7-4fad-ba6a-aac011072490.png)'
- en: A data class is implicitly final.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 数据类隐式为最终类。
- en: Aggregate and exploded form of a data class
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据类的聚合形式和展开形式
- en: Aggregate form of a data class would be the name of the data class. Its exploded
    form would refer to the variables used to store its data. Conversion from aggregate
    to exploded form is also referred to as the deconstruction pattern.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 数据类的聚合形式将是数据类的名称。其展开形式将指的是用于存储其数据的变量。从聚合到展开形式的转换也被称为解构模式。
- en: 'Referring to the example, we used in our preceding section:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 参考我们前节中使用的示例：
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`Emp` is the aggregate form of the data class `Emp`. Its exploded form would
    be `String name` and `int age`. The language would need easy conversion between
    the two, so that they can be used with other language constructs like `switch`.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`Emp`是数据类`Emp`的聚合形式。其展开形式将是`String name`和`int age`。语言需要在这两者之间提供简单的转换，以便它们可以与其他语言结构，如`switch`一起使用。'
- en: Deconstruction pattern refers to the conversion from aggregate form to exploded
    form for a data class.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 解构模式指的是将数据类从聚合形式转换为展开形式。
- en: The limitations
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 局限性
- en: When you use the keyword `record` to define your data class, you'll be limited
    by what the language allows you to do. You'll no longer have the finer control
    on whether your data class is extensible, whether its state is mutable, whether
    you can control the range of values that can be assigned to your fields, accessibility
    to your fields. You might also be limited when it comes to having additional fields
    or multiple constructors.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用关键字`record`来定义你的数据类时，你将受到语言允许你做什么的限制。你将不再能精细控制你的数据类是否可扩展，其状态是否可变，你是否可以控制分配给字段值的范围，字段的可访问性。在添加额外字段或多个构造函数方面，你也可能受到限制。
- en: Data class is still in works at Oracle. They finer details are still being worked
    on. Just a month back, the keyword `datum` was used to define a data class, changed
    to `record` now.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 数据类在Oracle仍在开发中。更详细的内容仍在完善中。就在一个月前，关键字`datum`被用来定义数据类，现在已改为`record`。
- en: Now-a-days, developers aren't limited to working with a single programming language.
    Java programmers usually work with, or, are aware of the other programming language
    that work on the JVM, like Scala, Kotlin, or Groovy. The experience of working
    with varied languages brings a lot of expectations and assumptions on the capabilities
    and limitations of the data classes (defined using `record`).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，开发者不再局限于使用单一编程语言。Java程序员通常使用，或者了解在JVM上运行的Scala、Kotlin或Groovy等其他编程语言。使用不同语言的体验带来了对数据类（使用`record`定义）的能力和限制的许多期望和假设。
- en: Examples from the past – changes to define enums
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 过去的例子——定义枚举的变化
- en: 'Prior to the introduction of enums, developers often used `public`, `static`,
    and `final` variables to define constants. For example:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在枚举引入之前，开发者经常使用`public`、`static`和`final`变量来定义常量。例如：
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The major drawback of using `public`, `static`, `final`, `int` variables is
    type safety, any `int` value could be assigned to a variable of type `int`, instead
    of `Size.SMALL`, `Size.MEDIUM` or `Size.LARGE` constants.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`public`、`static`、`final`、`int`变量的主要缺点是类型安全，任何`int`值都可以分配给类型为`int`的变量，而不是`Size.SMALL`、`Size.MEDIUM`或`Size.LARGE`常量。
- en: 'Java 5 introduced enums, an addition to the language construct, to enable developers
    to define an enumeration of constants. Here''s a quick example:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Java 5引入了枚举，这是语言结构的补充，使开发者能够定义常量的枚举。以下是一个快速示例：
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: With a variable of type `Size`, assignment is limited to the constants defined
    in `Size`. An enum is a perfect example of how language can simplify implementation
    of a model at the cost of certain constraints. Enums limit the extensibility to
    interfaces. Other than that, enums are full-fledged classes. As a developer you
    can add state and behavior to it. Another benefit is that an enum can also in
    `switch` constructs, which was earlier limited to primitives and a `String` class.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 使用类型为`Size`的变量时，赋值限于`Size`中定义的常量。枚举是语言如何以一定的约束为代价简化模型实现的完美示例。枚举限制了可扩展性到接口。除此之外，枚举是完整的类。作为开发者，你可以向其添加状态和行为。另一个好处是枚举也可以在`switch`结构中使用，这之前仅限于原始类型和`String`类。
- en: A new language construct is like a new human relationship—biological or otherwise.
    It has its own share of joys and sorrows.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 新的语言结构就像一种新的人际关系——无论是生物学上的还是其他方面的。它有自己的快乐和悲伤。
- en: Pattern matching with the data classes
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用数据类进行模式匹配
- en: 'When you define your data classes using the `record` keyword, you get the added
    advantage of conversion of aggregate and exploded form of your data class. For
    an example, here''s how the switch statement might explode the data:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用`record`关键字定义你的数据类时，你将获得转换数据类聚合和展开形式的额外优势。例如，以下是switch语句如何展开数据的示例：
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The switch statement can use a data class, without using its exploded form.
    The following is good as well:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: switch语句可以使用数据类，而不必使用其展开形式。以下也是可以的：
- en: '[PRE8]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Encapsulating state
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 封装状态
- en: The record classes encapsulate the fields, providing default implementation
    of JavaBean style accessor methods (public methods to set value of fields). The
    values can be assigned during initialization of data class instances, using its
    constructors.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 记录类封装了字段，提供了JavaBean风格访问器的默认实现（设置字段值的公共方法）。值可以在数据类实例初始化期间分配，使用其构造函数。
- en: Data classes and inheritance
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据类和继承
- en: 'At present, the proposal is to decline the following inheritance cases:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，提议拒绝以下继承情况：
- en: A data class extends a regular class
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据类扩展常规类
- en: A regular class extends a data class
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常规类扩展数据类
- en: A data class extends another data class
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据类可以扩展另一个数据类
- en: 'Allowing any of the preceding cases would violate the contract of a data class
    being carrier of data. At present, the following restrictions are proposed for
    data classes and inheritance with interfaces and abstract data classes:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 允许上述任何一种情况都会违反数据类作为数据承载者的契约。目前，为数据类及其与接口和抽象数据类的继承提出以下限制：
- en: Non-abstract and abstract data classes can extend other abstract data classes
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非抽象和抽象数据类可以扩展其他抽象数据类
- en: An abstract or non-abstract data class can extend any interface(s).
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象或非抽象数据类可以扩展任何接口（s）。
- en: The following image sums up these inheritance rules.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像总结了这些继承规则。
- en: '![](img/c2e8214d-58a0-4bda-a870-b1f0461d1ada.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c2e8214d-58a0-4bda-a870-b1f0461d1ada.png)'
- en: Let's get started by defining an abstract data class.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从定义一个抽象数据类开始。
- en: Extending an abstract data class
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展抽象数据类
- en: 'In the following example, the `Emp` abstract data class is being extended by
    non-abstract data class `Manager`:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，`Emp`抽象数据类正被非抽象数据类`Manager`扩展：
- en: '[PRE9]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: When a non-abstract data class extends an abstract data class, it accepts all
    the data in its header, the ones that are required for itself and for its base
    class.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 当非抽象数据类扩展抽象数据类时，它接受其头部的所有数据，包括为其自身和其基类所必需的数据。
- en: A data class can extend a single abstract data class.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 数据类可以扩展单个抽象数据类。
- en: Implementing interfaces
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现接口
- en: 'A data class can implement an interface and its abstract methods, or just inherit
    its default methods. Here''s an example:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 数据类可以实现接口及其抽象方法，或者只是继承其默认方法。以下是一个示例：
- en: '[PRE10]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: A data class can implement single or multiple interfaces.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 数据类可以实现单个或多个接口。
- en: Additional variables
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 额外变量
- en: 'Though allowed, before adding variables or fields to a data class, ask yourself—*Are
    the fields derived from the state?* Fields which are not derived from the state,
    pose a serious violation to the initial concept of the data classes. Here''s an
    example, which defines an additional field `style`, derived from the state of
    data class, `Emp`:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然允许，但在向数据类添加变量或字段之前，请自问——*字段是否来源于状态？* 不来源于状态的字段，对数据类初始概念的严重违反。以下是一个示例，它定义了一个额外的字段`style`，该字段来源于数据类`Emp`的状态：
- en: '[PRE11]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The preceding code works well because the state of the data class `Emp` is still
    derived from its state (fields `name` and `age`). The method `getStyle` doesn't
    interfere with the state of `Emp`, it is purely implementation detail.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码表现良好，因为数据类`Emp`的状态仍然来源于其状态（字段`name`和`age`）。`getStyle`方法不会干扰`Emp`的状态，它纯粹是实现细节。
- en: Overriding implicit behaviour
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 覆盖隐式行为
- en: 'Imagine you want to limit the values that can be passed to a field in your
    data class during its instantiation. This is feasible, just override the default
    constructor. Here''s an example:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你希望在数据类实例化期间限制可以传递给其字段的值。这是可行的，只需覆盖默认构造函数。以下是一个示例：
- en: '[PRE12]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Similarly, you can also override the default implementation of object methods
    such as `equals()`, `hashCode()` and `toString()` and others methods such as the
    accessor methods.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，你也可以覆盖对象方法的默认实现，如`equals()`、`hashCode()`和`toString()`以及其他访问器方法。
- en: Overriding the default behavior of the methods of your data class, doesn't defeat
    the purpose of their creation. They are still working as data classes, with finer
    control on their working. Let's compare it with the POJOs, which were earlier
    used to model data classes. The compiler doesn't auto-generate any methods for
    a POJO. So, a user still needs to read all the code, looking for code that isn't
    the default implementation of its methods. In case of the data classes, this overridden
    behavior is very explicit. So, a user doesn't have to worry about reading all
    the code, he/she can assume default implementation of the behavior, which hasn't
    been overridden by the developer.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 覆盖数据类方法的默认行为并不会违背其创建的目的。它们仍然作为数据类工作，对它们的工作有更精细的控制。让我们将其与之前用于建模数据类的POJOs进行比较。编译器不会为POJO自动生成任何方法。因此，用户仍然需要阅读所有代码，寻找不是其方法默认实现的代码。在数据类的情况下，这种覆盖行为非常明确。因此，用户不必担心阅读所有代码，他/她可以假设行为有默认实现，该实现尚未被开发者覆盖。
- en: Overriding behavior explicitly states the places where a data class diverts
    from its default behavior, reducing the amount of code that must be read by a
    user to understand its behavior.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 明确地覆盖行为说明了数据类偏离其默认行为的地方，从而减少了用户阅读代码以理解其行为所需的代码量。
- en: Additional methods and constructors
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 额外的方法和构造函数
- en: 'The compiler generates a default constructor for a data class, together with
    accessor methods, and default implementation of the methods from the object class.
    A developer can overload the constructors and add more methods to a data class:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器为数据类生成默认构造函数、访问器方法和从对象类继承的方法的默认实现。开发者可以覆盖构造函数并向数据类添加更多方法：
- en: '[PRE13]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Mutability
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可变性
- en: 'Work is still in progress on whether the data classes should be designated
    as mutable or immutable. Both have their own advantages and disadvantages. Immutable
    data works well in multi-threaded, parallel or concurrent systems. On the other
    hand, mutable data is also data. Mutable data works well with cases that require
    frequent modification to data. The following image depicts the confusion:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 关于数据类是否应指定为可变或不可变的工作仍在进行中。两者都有其自身的优缺点。不可变数据在多线程、并行或并发系统中表现良好。另一方面，可变数据也是数据。可变数据适用于需要频繁修改数据的情况。以下图像展示了这种混淆：
- en: '![](img/33c2eb96-0e4f-4bbd-a647-d80ec95e1a47.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/33c2eb96-0e4f-4bbd-a647-d80ec95e1a47.png)'
- en: Thread safety
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程安全
- en: Since the data classes are not yet designated to be immutable, it is the responsibility
    of the developers to use them in thread safe configurations.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 由于数据类尚未指定为不可变，开发者有责任在使用它们时确保线程安全配置。
- en: Summary
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Data classes proposes to bring to developers a simple and concise way to model
    data as data. It will include language changes with the introduction of keyword
    record. The work is still in progress on the data classes at Oracle. The proposed
    data classes are different from the existing POJOs, which are full-fledged classes
    which are modelled as data classes by developers. Data classes will use the keyword
    record to encapsulate data in its class header.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 数据类提议为开发者提供一种简单简洁的方式来模型化数据作为数据。它将包括通过引入关键字record的语言变化。Oracle对数据类的工作仍在进行中。提议的数据类与现有的POJOs不同，POJOs是完整的类，开发者将其建模为数据类。数据类将使用关键字record在其类头中封装数据。
- en: Until now, classes have been used to model and implement a wide range of requirements.
    Though this has been working fine, it does require extra work at places where
    the cost far exceeds the benefits it offers. With an example from the past (enums),
    you covered how addition of a feature empowers developers to use a concise way
    to defining entities, but which might lose some of the finer control. Similarly,
    the data classes offer a simplified way of encapsulating just a set of data.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，类已经被用来模型化和实现广泛的需求。尽管这已经工作得很好，但它确实需要在某些地方做额外的工作，那里的成本远远超过了它提供的利益。通过过去的例子（枚举），你已经了解了添加一个功能如何使开发者能够以简洁的方式定义实体，但可能会失去一些更精细的控制。同样，数据类提供了一种简化封装一组数据的方式。
- en: You covered the need of the data classes with their importance in reducing the
    code that should be read by any developer. The main goal of the data classes is
    to model data as data, and not to reduce the boilerplate code.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经了解了数据类的必要性及其在减少任何开发者需要阅读的代码中的重要性。数据类的主要目标是模型化数据作为数据，而不是减少样板代码。
- en: The Java platform provides default implementation of the methods to access the
    state a data class, default constructor and default implementations of the methods
    of class object (`equals()`, `hashCode()`, and `toString()`). You can add fields
    or behaviors (including constructors) to a data class, and also override the default
    implementation of all its methods. Data classes can be defined as abstract. They
    can extend abstract classes and implement interfaces.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: Java平台提供了访问数据类状态的方法、默认构造函数以及类对象方法（`equals()`、`hashCode()`和`toString()`）的默认实现。你可以在数据类中添加字段或行为（包括构造函数），并且也可以覆盖所有方法的默认实现。数据类可以被定义为抽象的。它们可以扩展抽象类并实现接口。
- en: You covered the aggregate and the exploded form of a data class. The data classes
    can be used with other language constructs like switch.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经了解了数据类的聚合形式和展开形式。数据类可以与其他语言结构，如switch一起使用。
- en: By default, the data classes are not mutable, including the arrays defined as
    the data member. Since these structures are not immutable, a developer must include
    code to ensure thread safety, when working with them.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，数据类是不可变的，包括定义为数据成员的数组。由于这些结构不是不可变的，当与它们一起工作时，开发者必须包含代码以确保线程安全。
