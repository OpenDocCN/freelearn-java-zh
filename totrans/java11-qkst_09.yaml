- en: Data classes and their usage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Work is in progress on data classes under the Project Amber. It proposes to
    bring to developers a simplified way of modelling data as data, by introducing
    special classes with the keyword record. The state of the data class would be
    able to be captured using the class header, which is in stark contrast to what
    the existing **Plain Old Java Objects** (**POJO**) offer at present.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the chapter, we''ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: An introduction to the data classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Need of the data classes and their limitations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Aggregate and exploded form of a data class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pattern matching with data classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inheritance with abstract data classes and interfaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding variables and methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overriding default behavior
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to the data classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We know of two versions of data classes—POJO (the old and existing way) and
    the new proposed data classes. To appreciate the data classes that is in works
    under the Project Amber, you'll need to know what the capabilities and limitations
    of existing POJO classes are and why do we need the new proposed data classes.
  prefs: []
  type: TYPE_NORMAL
- en: POJO is not implemented using a language construct. The proposed data classes
    would include changes or additions to the programming language.
  prefs: []
  type: TYPE_NORMAL
- en: What is a data class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As a Java developer, you probably have used and created POJOs in some or all
    your projects. It is a class that encapsulates a set of data, without any additional
    behavior to manipulate its state. It usually includes constructors, accessors,
    mutators, and the overridden methods from the object class, namely—`hashCode()`,
    `equals()`, and `toString()`. The accessors and mutators allow access and assignment
    to the state variables. Additionally, the mutators might include code to check
    the range of values that are assigned to the instance state. Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'One of the cases is to use the `Emp` class to save employee data to your database.
    Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Similarly, you could also use the `Emp` class to be passed in a message, to
    be sent over the network, to insert it into a JSON object and many more.
  prefs: []
  type: TYPE_NORMAL
- en: This all looks good. More importantly, this has been working fine ever since
    Java was introduced to the developers. So, what is the problem?
  prefs: []
  type: TYPE_NORMAL
- en: Need of adding data classes to the language
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Imagine securing the borders of a country. The norm for it is to be guarded
    by the defense forces. Will the level of security change based on the relationship
    between the neighboring countries (cordial, neuter or tense)? What happens if
    the borders are porous, or say, for example, the way it is in Western Europe for
    the Schengen countries? Now, compare guarding borders of a country with guarding
    our homes or, say, securing the contents of a cabinet in a room.
  prefs: []
  type: TYPE_NORMAL
- en: Though each instances in the preceding example is talking about security of
    an entity and its protection from a physical attack, they all have varied requirements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, until now, the classes in Java have been used to model a wide range
    of requirements. While this works well for a lot of cases, it doesn''t work for
    some. If you want to make the same size fit all, you''ll need a lot of adjustments
    for most of them. Compare it with using the same trouser size for individuals
    with varied height and waist size, as shown in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bc0292c8-734a-4741-ae41-63ea941069a6.png)'
  prefs: []
  type: TYPE_IMG
- en: In the past, enum were added to the Java language (version 5). Even though a
    class can be programmed to create an enumeration of primitives or objects, enums
    simplified the process for a developer.
  prefs: []
  type: TYPE_NORMAL
- en: Enums reduced the coding for developers. At the same time, it made the intent
    of the enum explicit to its users
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding section, `Emp` POJO is just a carrier of its data. However,
    to season a class to behave like a data class, requires a developer to define
    multiple methods—constructs, accessor, mutator, and other methods from the object
    class. You might argue that you can use an IDE to easily generate all these methods
    for your class. You are right! And it's quite simple to do so.
  prefs: []
  type: TYPE_NORMAL
- en: But it only takes care of the writing part of code. What happens to the reading
    of the code by the users of the class? As developers, we all understand that a
    piece of code might be written just once, but it is read multiple times. This
    is the reason, why experienced programmers stress on good coding practices, for
    comprehending, reading and maintaining code.
  prefs: []
  type: TYPE_NORMAL
- en: When definition of data classes is induced in the language, the readers of the
    code would know its explicit intent of just being a data class. The developers
    would not need to dig their claws deep into the code, finding code, that was in
    addition to them just being a data class, so as they don't miss any important
    information.
  prefs: []
  type: TYPE_NORMAL
- en: It will also prevent the developers from using half-baked classes as data class.
    At times developers tend to use classes that might not include all the relevant
    methods (like `equals()` or `hashCode()`), as a data class, but it is sure a good
    recipe to insert subtle bugs in your applications. A collection class like `Map`,
    requires a class to implement its `equals()` and `hashCode()` methods to function
    properly and efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing data classes with the change in language would decrease the verbosity
    of the language, broadcast the intent of the structure to all.
  prefs: []
  type: TYPE_NORMAL
- en: Deep dive into data classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The syntax to define a data class looks simple. However, both the syntax and
    the semantics are important.
  prefs: []
  type: TYPE_NORMAL
- en: An example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s get started by re-defining the `Emp` class, which we used in the beginning
    of the chapter, as a data class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code uses the keyword `record` to define a data class, accepting
    comma separated variable name and type, required to store the state. The compiler
    automatically generates default implements for the Object methods (`equals()`,
    `hashCode()`, `toString()`) for data classes.
  prefs: []
  type: TYPE_NORMAL
- en: The code looks clear and compact. A reader would immediately know the intent
    of this single line of code, a carrier of data `name` (type `String`) and `age`
    (type `int`). Another advantage for a reader is that she wouldn't need to read
    through constructors, accessors, mutators, or methods of the object class, just
    to ascertain that they are doing what they are supposed to, not more, which they
    should be aware of.
  prefs: []
  type: TYPE_NORMAL
- en: 'Behind the scenes, the record class `Emp` is converted to the following by
    the Java compiler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The preceding data class is an example of a non-abstract data class. A data
    class can also be defined as an abstract data class. A non-abstract data class
    is implicitly final. In both cases, a data class would get default implementations
    of `hashCode()`, `equals()` and `toString()`, and accessor methods. For an abstract
    data class, the constructors would be protected.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following image, the compiler looks happy to convert one liner code
    for the data class, to a full-fledged class:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4c986559-e3f7-4fad-ba6a-aac011072490.png)'
  prefs: []
  type: TYPE_IMG
- en: A data class is implicitly final.
  prefs: []
  type: TYPE_NORMAL
- en: Aggregate and exploded form of a data class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Aggregate form of a data class would be the name of the data class. Its exploded
    form would refer to the variables used to store its data. Conversion from aggregate
    to exploded form is also referred to as the deconstruction pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'Referring to the example, we used in our preceding section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '`Emp` is the aggregate form of the data class `Emp`. Its exploded form would
    be `String name` and `int age`. The language would need easy conversion between
    the two, so that they can be used with other language constructs like `switch`.'
  prefs: []
  type: TYPE_NORMAL
- en: Deconstruction pattern refers to the conversion from aggregate form to exploded
    form for a data class.
  prefs: []
  type: TYPE_NORMAL
- en: The limitations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you use the keyword `record` to define your data class, you'll be limited
    by what the language allows you to do. You'll no longer have the finer control
    on whether your data class is extensible, whether its state is mutable, whether
    you can control the range of values that can be assigned to your fields, accessibility
    to your fields. You might also be limited when it comes to having additional fields
    or multiple constructors.
  prefs: []
  type: TYPE_NORMAL
- en: Data class is still in works at Oracle. They finer details are still being worked
    on. Just a month back, the keyword `datum` was used to define a data class, changed
    to `record` now.
  prefs: []
  type: TYPE_NORMAL
- en: Now-a-days, developers aren't limited to working with a single programming language.
    Java programmers usually work with, or, are aware of the other programming language
    that work on the JVM, like Scala, Kotlin, or Groovy. The experience of working
    with varied languages brings a lot of expectations and assumptions on the capabilities
    and limitations of the data classes (defined using `record`).
  prefs: []
  type: TYPE_NORMAL
- en: Examples from the past – changes to define enums
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Prior to the introduction of enums, developers often used `public`, `static`,
    and `final` variables to define constants. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The major drawback of using `public`, `static`, `final`, `int` variables is
    type safety, any `int` value could be assigned to a variable of type `int`, instead
    of `Size.SMALL`, `Size.MEDIUM` or `Size.LARGE` constants.
  prefs: []
  type: TYPE_NORMAL
- en: 'Java 5 introduced enums, an addition to the language construct, to enable developers
    to define an enumeration of constants. Here''s a quick example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: With a variable of type `Size`, assignment is limited to the constants defined
    in `Size`. An enum is a perfect example of how language can simplify implementation
    of a model at the cost of certain constraints. Enums limit the extensibility to
    interfaces. Other than that, enums are full-fledged classes. As a developer you
    can add state and behavior to it. Another benefit is that an enum can also in
    `switch` constructs, which was earlier limited to primitives and a `String` class.
  prefs: []
  type: TYPE_NORMAL
- en: A new language construct is like a new human relationship—biological or otherwise.
    It has its own share of joys and sorrows.
  prefs: []
  type: TYPE_NORMAL
- en: Pattern matching with the data classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you define your data classes using the `record` keyword, you get the added
    advantage of conversion of aggregate and exploded form of your data class. For
    an example, here''s how the switch statement might explode the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The switch statement can use a data class, without using its exploded form.
    The following is good as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Encapsulating state
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The record classes encapsulate the fields, providing default implementation
    of JavaBean style accessor methods (public methods to set value of fields). The
    values can be assigned during initialization of data class instances, using its
    constructors.
  prefs: []
  type: TYPE_NORMAL
- en: Data classes and inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At present, the proposal is to decline the following inheritance cases:'
  prefs: []
  type: TYPE_NORMAL
- en: A data class extends a regular class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A regular class extends a data class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A data class extends another data class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Allowing any of the preceding cases would violate the contract of a data class
    being carrier of data. At present, the following restrictions are proposed for
    data classes and inheritance with interfaces and abstract data classes:'
  prefs: []
  type: TYPE_NORMAL
- en: Non-abstract and abstract data classes can extend other abstract data classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An abstract or non-abstract data class can extend any interface(s).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The following image sums up these inheritance rules.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c2e8214d-58a0-4bda-a870-b1f0461d1ada.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's get started by defining an abstract data class.
  prefs: []
  type: TYPE_NORMAL
- en: Extending an abstract data class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the following example, the `Emp` abstract data class is being extended by
    non-abstract data class `Manager`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: When a non-abstract data class extends an abstract data class, it accepts all
    the data in its header, the ones that are required for itself and for its base
    class.
  prefs: []
  type: TYPE_NORMAL
- en: A data class can extend a single abstract data class.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A data class can implement an interface and its abstract methods, or just inherit
    its default methods. Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: A data class can implement single or multiple interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Additional variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Though allowed, before adding variables or fields to a data class, ask yourself—*Are
    the fields derived from the state?* Fields which are not derived from the state,
    pose a serious violation to the initial concept of the data classes. Here''s an
    example, which defines an additional field `style`, derived from the state of
    data class, `Emp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code works well because the state of the data class `Emp` is still
    derived from its state (fields `name` and `age`). The method `getStyle` doesn't
    interfere with the state of `Emp`, it is purely implementation detail.
  prefs: []
  type: TYPE_NORMAL
- en: Overriding implicit behaviour
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Imagine you want to limit the values that can be passed to a field in your
    data class during its instantiation. This is feasible, just override the default
    constructor. Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Similarly, you can also override the default implementation of object methods
    such as `equals()`, `hashCode()` and `toString()` and others methods such as the
    accessor methods.
  prefs: []
  type: TYPE_NORMAL
- en: Overriding the default behavior of the methods of your data class, doesn't defeat
    the purpose of their creation. They are still working as data classes, with finer
    control on their working. Let's compare it with the POJOs, which were earlier
    used to model data classes. The compiler doesn't auto-generate any methods for
    a POJO. So, a user still needs to read all the code, looking for code that isn't
    the default implementation of its methods. In case of the data classes, this overridden
    behavior is very explicit. So, a user doesn't have to worry about reading all
    the code, he/she can assume default implementation of the behavior, which hasn't
    been overridden by the developer.
  prefs: []
  type: TYPE_NORMAL
- en: Overriding behavior explicitly states the places where a data class diverts
    from its default behavior, reducing the amount of code that must be read by a
    user to understand its behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Additional methods and constructors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The compiler generates a default constructor for a data class, together with
    accessor methods, and default implementation of the methods from the object class.
    A developer can overload the constructors and add more methods to a data class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Mutability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Work is still in progress on whether the data classes should be designated
    as mutable or immutable. Both have their own advantages and disadvantages. Immutable
    data works well in multi-threaded, parallel or concurrent systems. On the other
    hand, mutable data is also data. Mutable data works well with cases that require
    frequent modification to data. The following image depicts the confusion:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/33c2eb96-0e4f-4bbd-a647-d80ec95e1a47.png)'
  prefs: []
  type: TYPE_IMG
- en: Thread safety
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since the data classes are not yet designated to be immutable, it is the responsibility
    of the developers to use them in thread safe configurations.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Data classes proposes to bring to developers a simple and concise way to model
    data as data. It will include language changes with the introduction of keyword
    record. The work is still in progress on the data classes at Oracle. The proposed
    data classes are different from the existing POJOs, which are full-fledged classes
    which are modelled as data classes by developers. Data classes will use the keyword
    record to encapsulate data in its class header.
  prefs: []
  type: TYPE_NORMAL
- en: Until now, classes have been used to model and implement a wide range of requirements.
    Though this has been working fine, it does require extra work at places where
    the cost far exceeds the benefits it offers. With an example from the past (enums),
    you covered how addition of a feature empowers developers to use a concise way
    to defining entities, but which might lose some of the finer control. Similarly,
    the data classes offer a simplified way of encapsulating just a set of data.
  prefs: []
  type: TYPE_NORMAL
- en: You covered the need of the data classes with their importance in reducing the
    code that should be read by any developer. The main goal of the data classes is
    to model data as data, and not to reduce the boilerplate code.
  prefs: []
  type: TYPE_NORMAL
- en: The Java platform provides default implementation of the methods to access the
    state a data class, default constructor and default implementations of the methods
    of class object (`equals()`, `hashCode()`, and `toString()`). You can add fields
    or behaviors (including constructors) to a data class, and also override the default
    implementation of all its methods. Data classes can be defined as abstract. They
    can extend abstract classes and implement interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: You covered the aggregate and the exploded form of a data class. The data classes
    can be used with other language constructs like switch.
  prefs: []
  type: TYPE_NORMAL
- en: By default, the data classes are not mutable, including the arrays defined as
    the data member. Since these structures are not immutable, a developer must include
    code to ensure thread safety, when working with them.
  prefs: []
  type: TYPE_NORMAL
