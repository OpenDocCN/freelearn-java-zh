- en: Web Services with JAX-WS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Java EE specification includes the JAX-WS API as one of its technologies.
    JAX-WS is the standard way to develop **SOAP** (**Simple Object Access Protocol**)
    web services in the Java platform and stands for Java API for XML Web Services.
    JAX-WS is a high-level API; invoking web services via JAX-WS is done via remote
    procedure calls. JAX-WS is a very natural API for Java developers.
  prefs: []
  type: TYPE_NORMAL
- en: Web services are application programming interfaces that can be invoked remotely.
    Web services can be invoked from clients written in any language.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the topics we will cover include:'
  prefs: []
  type: TYPE_NORMAL
- en: Developing web services with the JAX-WS API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing web service clients with the JAX-WS API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding attachments to web service calls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exposing EJBs as web services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing web services with JAX-WS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'JAX-WS is a high-level API that simplifies the development of SOAP-based web
    services. JAX-WS stands for **Java API for XML Web Services**. Developing a web
    service via JAX-WS consists of writing a class with public methods to be exposed
    as web services. The class needs to be decorated with the `@WebService` annotation.
    All public methods in the class are automatically exposed as web services. They
    can optionally be decorated with the `@WebService` annotation. The following example
    illustrates this process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The preceding class exposes its two methods as web services. The `add()` method
    simply adds the two `int` primitives it receives as parameters and returns the
    result; the `substract()` method subtracts its two parameters and returns the
    result.
  prefs: []
  type: TYPE_NORMAL
- en: We indicate that the class implements a web service by decorating it with the
    `@WebService` annotation. Any methods that we would like to expose as web services
    can be decorated with the `@WebMethod` annotation, but this isn't necessary; all
    public methods are automatically exposed as web services. We can still use the
    `@WebMethod` annotation for clarity, but it isn't strictly necessary to deploy
    our web service; we simply need to package it in a WAR file as usual.
  prefs: []
  type: TYPE_NORMAL
- en: Web service clients need a **WSDL** (**Web Services Definition Language**) file
    in order to generate executable code that they can use to invoke the web service.
    WSDL files are typically placed in a web server and accessed by the client via
    its URL.
  prefs: []
  type: TYPE_NORMAL
- en: 'When deploying web services developed using JAX-WS, a WSDL is automatically
    generated for us. The exact URL for the generated WSDL varies depending on the
    Java EE 8 application server we are using. When using GlassFish, URLs for JAX-WS
    WSDLs follow the following format:'
  prefs: []
  type: TYPE_NORMAL
- en: '`[http|https]://[server]:[port]/[context root]/[service name]?wsdl`'
  prefs: []
  type: TYPE_NORMAL
- en: In our example, the URL for our web service's WSDL (when deployed to GlassFish)
    would be `http://localhost:8080/calculatorservice/CalculatorService?wsdl` (assuming
    GlassFish is running on our local workstation, and GlassFish is listening for
    HTTP connections on its default 8080 port).
  prefs: []
  type: TYPE_NORMAL
- en: Developing a web service client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we mentioned earlier, executable code needs to be generated from a web service's
    WSDL. A web service client will then invoke this executable code to access the
    web service.
  prefs: []
  type: TYPE_NORMAL
- en: 'The **Java Development Kit** (**JDK**) includes a utility to generate Java
    code from a WSDL. The name of the utility is `wsimport`. It can be found under
    `$JAVA_HOME/bin`. The only required argument for `wsimport` is the URL of the
    WSDL corresponding to the web service, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '`wsimport http://localhost:8080/calculatorservice/CalculatorService?wsdl`'
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding command will generate a number of compiled Java classes that
    allow client applications to access our web service:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Add.class`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AddResponse.class`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Calculator.class`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CalculatorService.class`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ObjectFactory.class`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`package-info.class`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Subtract.class`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SubtractResponse.class`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Keeping generated source code: By default, the source code for the generated
    class files is automatically deleted; it can be kept by passing the `-keep` parameter
    to `wsimport`.'
  prefs: []
  type: TYPE_NORMAL
- en: These classes need to be added to the client's `CLASSPATH` in order for them
    to be accessible to the client's code.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we are using Apache Maven to build our code, we can take advantage of the
    JAX-WS Maven plugin to automatically invoke `wsimport` when building our client
    code. This approach is illustrated in the following `pom.xml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The preceding `pom.xml` Maven build file will automatically invoke the `wsimport`
    utility whenever we build our code via the `mvn package` or `mvn install` commands.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, we are ready to develop a simple client to access our web service.
    We will implement our client as a JSF application. The most relevant parts of
    our client application source code are shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `@WebServiceRef` annotation injects an instance of the web service into
    our client application. Its `wsdlLocation` attribute contains the URL of the WSDL
    corresponding to the web service we are invoking.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the web service class is an instance of a class called `CalculatorService`.
    This class was created when we invoked the `wsimport` utility, as `wsimport` always
    generates a class whose name is the name of the class we implemented plus the
    service suffix. We use this service class to obtain an instance of the web "Service"
    class we developed. In our example, we do this by invoking the `getCalculatorPort()`
    method on the `CalculatorService` instance. In general, the method to invoke to
    get an instance of our web service class follows the pattern `getNamePort()`,
    where `Name` is the name of the class we wrote to implement the web service. Once
    we get an instance of our web service class, we can simply invoke its methods
    as with any regular Java object.
  prefs: []
  type: TYPE_NORMAL
- en: Strictly speaking, the `getNamePort()` method of the service class returns an
    instance of a class implementing an interface generated by `wsimport`. This interface
    is given the name of our web service class and declares all of the methods we
    declared to be web services. For all practical purposes, the object returned is
    equivalent to our web service class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The user interface for our simple client application is developed using Facelets,
    as customary when developing JSF applications:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The user interface uses Ajax to invoke the relevant methods on the `CalculatorClientController`
    CDI named bean (refer to [Chapter 2](9059bc2f-04fb-43df-a5c5-8b2cce80792e.xhtml),
    *JavaServer Faces*, for details).
  prefs: []
  type: TYPE_NORMAL
- en: 'After deploying our code, our browser should render our page as follows (shown
    after entering some data and clicking the corresponding buttons):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c9383d7d-0b52-4b8c-b662-8388510477bf.png)'
  prefs: []
  type: TYPE_IMG
- en: In this example, we passed `Integer` objects as parameters and return values.
    Of course, it is also possible to pass primitive types both as parameters and
    as return values. Unfortunately, not all standard Java classes or primitive types
    can be used as method parameters or return values when invoking SOAP-based web
    services implemented via JAX-WS. The reason for this is that, behind the scenes,
    method parameters and return types get mapped to XML definitions, and not all
    types can be properly mapped.
  prefs: []
  type: TYPE_NORMAL
- en: 'Valid types that can be used in JAX-WS web service calls are listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`java.awt.Image`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.lang.Object`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Java.lang.String`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.math.BigDecimal`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.math.BigInteger`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.net.URI`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.util.Calendar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.util.Date`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.util.UUID`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`` `javax.activation.DataHandler` ``'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`javax.xml.datatype.Duration`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`javax.xml.datatype.XMLGregorianCalendar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`javax.xml.namespace.QName`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`javax.xml.transform.Source`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Additionally, the following primitive types can be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Boolean`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`byte`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`byte[]`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`double`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`float`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`int`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`long`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`short`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can also use our own custom classes as method parameters and/or return values
    forÂ web service methods, but member variables of our classes must be one of the
    listed types.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, it is legal to use arrays both as method parameters and return
    values; however, when executing `wsimport`, these arrays get converted to lists,
    generating a mismatch between the method signature in the web service and the
    method call invoked in the client. For this reason, it is preferred to use lists
    as method parameters and/or return values, since this is also legal and does not
    create a mismatch between the client and the server.
  prefs: []
  type: TYPE_NORMAL
- en: JAX-WS uses the Java Architecture for XML Binding (JAXB) internally to create
    SOAP messages from method calls. The types we are allowed to use for method calls
    and return values are the ones that JAXB supports. For more information on JAXB,
    see [https://github.com/javaee/jaxb-v2.](https://github.com/javaee/jaxb-v2)
  prefs: []
  type: TYPE_NORMAL
- en: Sending attachments to web services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In addition to sending and accepting the data types discussed in the previous
    sections, `web service` methods can send and accept file attachments. The following
    example illustrates how to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In order to write a web service method that receives one or more attachments,
    all we need to do is add a parameter of type `javax.activation.DataHandler` for
    each attachment the method will receive. In the preceding example, the `attachFile()`
    method takes a single parameter of this type and simply writes it to the filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we need to package our code in a WAR file and deploy it as usual.
    Once deployed, a WSDL will automatically be generated. We then need to execute
    the `wsimport` utility to generate code that our web service client can use to
    access the web service. As previously discussed, the `wsimport` can be invoked
    directly from the command line or via an Apache Maven plugin.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have executed `wsimport` to generate code to access the web service,
    we can write and compile our client code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Web service attachments need to be sent as a `byte` array to the web service,
    therefore, web service clients need to convert the file to attach to this type.
    In our example, we send an image as an attachment, we load the image into memory
    by creating an instance of `java.net.URL`, passing the URL of the image in question
    as a parameter to its constructor. We then obtain an `InputStream` instance corresponding
    to the image by invoking the `openStream()` method on our `URL` instance, convert
    our `InputStream` instance to a byte array, then pass this byte array to the `web
    service` method that expects an attachment.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that, unlike when passing standard parameters, the parameter type used
    when the client invokes a method expecting an attachment is different from the
    parameter type of the method in the web server code. The method in the web server
    code expects an instance of `javax.activation.DataHandler` for each attachment;
    however, the code generated by `wsimport` expects an array of bytes for each attachment.
    These arrays of bytes are converted to the right type ( `javax.activation.DataHandler`
    ) behind the scenes by the `wsimport` generated code. As application developers,
    we don't need to concern ourselves with the details of why this happens; we just
    need to keep in mind that, when sending attachments to a web service method, parameter
    types will be different in the web service code and in the client invocation.
  prefs: []
  type: TYPE_NORMAL
- en: Exposing EJBs as web services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In addition to creating web services as described in the previous section,
    public methods of stateless session beans can easily be exposed as web services
    by simply adding an annotation to the EJB class. The following example illustrates
    how to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, the only thing we need to do to expose a stateless session bean's
    public methods is to decorate its class declaration with the `@WebService` annotation.
    Needless to say, since the class is a session bean, it also needs to be decorated
    with the `@Stateless` annotation.
  prefs: []
  type: TYPE_NORMAL
- en: Just like regular stateless session beans, the ones whose methods are exposed
    as web services need to be deployed in a JAR file.
  prefs: []
  type: TYPE_NORMAL
- en: Just like standard web services, WSDL URLs for EJB web services depend on the
    application server being used. Consult your application server documentation for
    details.
  prefs: []
  type: TYPE_NORMAL
- en: EJB web service clients
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following class illustrates the procedure to be followed to access an EJB
    web service methods from a client application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, nothing special needs to be done when accessing an EJB web service
    from a client. The procedure is the same as with standard web services.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding class is a CDI named bean, and the following screenshot illustrates
    a simple JSF web-based user interface utilizing the preceding class to invoke
    our web service:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/416a894e-7643-45a8-987e-b72fa1c2a24f.png)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered how to develop web services and web service clients
    via the JAX-WS API. We explained how to incorporate web service code generation
    for web service clients when using ANT or Maven as a build tool. We also covered
    the valid types that can be used for remote method calls via JAX-WS. Additionally,
    we discussed how to send attachments to a web service. We also covered how to
    expose an EJB's methods as web services.
  prefs: []
  type: TYPE_NORMAL
