<html><head></head><body><div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Cloud-Native Application Patterns</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">In this chapter, we will explain cloud-native application patterns, looking at what a cloud-native application is and what its goals are. We will also show the patterns already described in previous chapters and new patterns that have emerged to address cloud-based applications. After reading this chapter, the reader will be able to understand the concepts and patterns that characterize a cloud architecture.</p>
<p class="mce-root">In this chapter, we will cover the following topics:</p>
<ul class="calibre15">
<li class="calibre16"><span class="calibre5">Explaining the concept of cloud-native applications</span></li>
<li class="calibre16"><span class="calibre5">Explaining the goals of a cloud application</span></li>
<li class="calibre16">Explaining the cloud design patterns</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Explaining the concept of cloud-native applications</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">The cloud and its resources are increasingly becoming a part of life for businesses. In the past, cloud resources were used for solutions such as storage management, emails, documents, and photos. Nowadays, the deployment of enterprise applications in the cloud structure certainly points the way to be followed by companies.</p>
<p class="mce-root">The cloud has become one of the first strategies to consider when developing a business application. The big challenge here is to make this application use the features offered by the cloud, such as elasticity, scalability, and availability, for the benefit of the business.<br class="calibre9"/>
To start off with, monolithic applications were migrated and deployed in the cloud. Some gains were achieved such as greater management and control, as well as availability. But what we really want is an application integrated with the capabilities offered by the cloud, that is, to leverage the cloud computing resources to better solve the business. </p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root">Then comes the cloud-native application, which is an application that uses the benefits and capabilities provided by the cloud. A set of design patterns is used for the development of this application. We'll look at some of the main design patterns used in cloud architecture i<span class="calibre10">n more detail</span> <span class="calibre10">later in the chapter</span><span class="calibre10">. </span></p>
<p class="mce-root">The cloud computing environment is basically elastic in the sense that computing resources are used and released according to demand. Consequently, scalability and availability are achieved with less complexity than they would be if the application were still under datacenter control. </p>
<p class="mce-root">Based on the cloud-native computing foundation, the properties that guide a cloud-native application are as follows:</p>
<ul class="calibre15">
<li class="calibre16"><span class="calibre5"><strong class="calibre3">Container-packaged</strong></span>: Th<span class="calibre5">e applications are executed in isolated units</span></li>
<li class="calibre16"><span class="calibre5"><strong class="calibre3">Dynamically-managed</strong></span>: There <span class="calibre5">is a central orchestration that manages the applications, improving the use of the resources, and reducing operational costs</span></li>
<li class="calibre16"><span class="calibre5"><strong class="calibre3">Microservices-oriented</strong>: Applications in the cloud are loosely-coupled</span></li>
</ul>
<p class="mce-root">Hence, a cloud-native application has a strongly-distributed nature. This is because this application is deployed in the cloud, and these properties are satisfied.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Explaining the goals of the cloud-native application</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Cloud design patterns aim to build secure, reliable applications available in the cloud. The following list will show these and other characteristics to be achieved by a cloud-native application:</p>
<ul class="calibre15">
<li class="calibre16"><strong class="calibre3">Availability</strong>: The time the application <span class="calibre5">is up and running</span>. What is desired is a non-stop operation of all the system's functionalities.</li>
<li class="calibre16"><strong class="calibre3">Data management</strong>: Data handled by an application is the building block of a cloud application. Data can be distributed or replicated across many servers (or clusters) to achieve scalability, availability, or even performance.</li>
<li class="calibre16"><strong class="calibre3">Messaging</strong>: To increase scalability, services or applications in the cloud have low coupling and often communicate using asynchronous messaging. </li>
<li class="calibre16"><strong class="calibre3">Management and monitoring</strong>: Because cloud applications run in remote environments, there must be a way to monitor non-functional property states—such as the use of computing resources—through logs and reports. Also, we must be able to deploy new implementations without having to stop the application (maintaining the availability characteristic).</li>
<li class="calibre16"><strong class="calibre3">Performance and scalability</strong>: Maintains performance despite an increase in the use of computing resources and scaling of the application.</li>
<li class="calibre16"><strong class="calibre3">Resiliency</strong>: A cloud application should be able to overcome a failure quickly. This issue is important for maintaining availability.</li>
<li class="calibre16"><strong class="calibre3">Security</strong>: A cloud application exposes several of its elements to users and should be able to prevent attacks by malicious users or malicious programs. </li>
</ul>
<p class="mce-root">It is important here to note that there are some issues that should be taken into account when implementing a distributed application, and specifically a cloud-native application. These <em class="calibre12">fallacies of distributed computing</em> were made by L. Peter Deutsch and others at Sun Microsystems, describing false assumptions about distributed programming:</p>
<ul class="calibre15">
<li class="calibre16">The network is reliable</li>
<li class="calibre16">Latency is zero</li>
<li class="calibre16">Bandwidth is infinite</li>
<li class="calibre16">The network is secure</li>
<li class="calibre16">Topology doesn't change</li>
<li class="calibre16">There is one administrator</li>
<li class="calibre16">The transport cost is zero</li>
<li class="calibre16">The network is homogeneous</li>
</ul>
<p class="mce-root">With the goals and challenges to be achieved by a cloud-native application on the one hand, and the difficulties that have always existed for the implementation of a distributed application on the other, we have launched the design pattern to solve the problems faced by a cloud-native application. As we progress, we will show the main design patterns used in the cloud architecture.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Explaining the cloud design patterns</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Now that the cloud application concepts and its challenges are defined, let's get straight to the point and talk about the design patterns used for the implementation of a cloud architecture:</p>
<ul class="calibre15">
<li class="calibre16">Composite application (microservices)</li>
<li class="calibre16">Abstraction</li>
<li class="calibre16">Twelve-factor</li>
<li class="calibre16">API Gateway</li>
<li class="calibre16">Service registry</li>
<li class="calibre16">Config server</li>
<li class="calibre16">Circuit breaker</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Composite application (microservices)</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">In <a href="9e35e298-1a91-43b8-ace1-805997b2b89e.xhtml" target="_blank" class="calibre14 pcalibre pcalibre3 pcalibre2 pcalibre1">Chapter 7</a>, <em class="calibre12">Microservice Patterns, </em>we demonstrated the advantages (and disadvantages) of decomposing an application into functions and taking several benefits <span class="calibre10">from this pattern</span><span class="calibre10">, always aiming at the application business</span><span class="calibre10">. In that chapter, it was established that a microservice-based architecture is characterized by decomposing the application into small, functional, independent components with a well-defined communication interface that is loosely-coupled.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Abstraction</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">This pattern states that the focus must be on what the client needs and not on the existing hardware structure. In this sense, the computational resources of the cloud are used on demand, which characterizes the elastic scalability. In this way, resources are seen in an abstract way and are changed according to the needs of the clients.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Twelve-factor</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">The twelve-factor methodology is based on the twelve factors that guide the creation of a successful SaaS project. This technology was created during the development of Heroku, a cloud service platform (PaaS) that supports several programming languages, including Ruby, Java, Node.js, Scala, Clojure, Python, and PHP. </p>
<p class="mce-root"/>
<p class="mce-root">The experience acquired during the development and support of SaaS applications was cataloged, that is, observations of the errors encountered, and solutions drawn up for the problems that occurred. As a consequence, the twelve-factor methodology was created, which is a set of guidelines that make it easier to develop cloud-based applications. For teaching purposes, here are some definitions—SaaS stands for <em class="calibre12">Software as a Service</em>, and PaaS stands for <em class="calibre12">Platform as a Service</em>. SaaS is best known to the end user as it has the highest growth rate in the market. The twelve factors are as follows:</p>
<p class="mce-root"/>
<ul class="calibre15">
<li class="calibre16"><strong class="calibre3">Code base</strong>: One codebase is tracked in revision control, while many deploys</li>
<li class="calibre16"><strong class="calibre3">Dependencies</strong>: Explicitly declare and isolate dependencies</li>
<li class="calibre16"><strong class="calibre3">Config</strong>: Store config in the environment</li>
<li class="calibre16"><strong class="calibre3">Backing services</strong>: Treat backing services as attached resources</li>
<li class="calibre16"><strong class="calibre3">Build, release, run</strong>: Strictly separate the build and run stages</li>
<li class="calibre16"><strong class="calibre3">Processes</strong>: Execute the app as one or more stateless processes</li>
<li class="calibre16"><strong class="calibre3">Port-binding</strong>: Export services via port-binding</li>
<li class="calibre16"><strong class="calibre3">Concurrency</strong>: Scale-out via the process model</li>
<li class="calibre16"><strong class="calibre3">Disposability</strong>: Maximize robustness with a fast startup and graceful shutdown</li>
<li class="calibre16"><strong class="calibre3">Dev/prod parity</strong>: Keep development, staging, and production as similar as possible</li>
<li class="calibre16"><strong class="calibre3">Logs</strong>: Treat logs as event streams</li>
<li class="calibre16"><strong class="calibre3">Admin processes</strong>: Run admin/management tasks as one-off processes</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Codebase</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">A codebase is any single repository where the codes reside. There can only be one codebase per application. Several applications cannot share a same codebase in the twelve-factor methodology. In this case, a solution would be to refactor the shared code by generating libraries that would go into the project as dependencies.</p>
<p class="mce-root">A codebase must be managed by a version control system (such as subversion or Git). Various deploys are generated from this codebase, each one for a different environment—development, staging, and production.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root">The developer has a version of the application (that is, a deploy) running in their local development environment:</p>
<div class="cdpaligncenter"><img src="Images/752384bc-0ac1-4f32-8d70-8fd1591df823.png" width="359" height="481" class="calibre85"/></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Dependencies</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Every dependency that is used by the project must be declared and isolated from the code. In this case, we can use some package-management tools (such as Maven, grundle, and npm). As an example, the Maven tool is used for building and documenting projects. The dependencies are declared in the <kbd class="calibre18">pom.xml</kbd> file, where we can declare the project dependencies:</p>
<div class="cdpaligncenter"><img src="Images/86b2425c-a240-4065-8691-a1feca460ab0.png" width="274" height="123" class="calibre86"/></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Config</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">An application's config is everything that varies between different deploys. It can be:</p>
<ul class="calibre15">
<li class="calibre16">Hosts, ports, and credentials for database access</li>
<li class="calibre16">Database schema</li>
<li class="calibre16">Cache settings</li>
<li class="calibre16">Hosts, ports, and credentials for accessing message queues</li>
</ul>
<p class="mce-root">The twelve-factor method requires the separation of config from code. So, the config should never be in the code, because the configs may vary between deploys but the code does not. The practice of placing the config in files, such as Java properties, is not recommended by <span class="calibre10">twelve</span>-factor, as there is always the possibility of placing the same configuration data in different environments (an example is when a developer commits to the version-control repository with its own local configs). Another weakness is the security issue of these configuration files. The <span class="calibre10">twelve</span>-factor method recommends the use of environment variables that can be injected when deploying an application in a specific environment:</p>
<div class="cdpaligncenter"><img src="Images/2bb4c0a2-d2e6-478f-a67a-9b0009db5148.png" width="444" height="494" class="calibre87"/></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Backing services</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Backing services are external services used by the application, such as a database, message service, file repository, or email service. The twelve-factor method considers each service that is external to the application as a resource. Each of these resources must be accessed via a URL or location and credentials attributes that are in the app's config. In this way, any changes to a service location—such as the database or file repository—does not impact the application code. The change becomes imperceptible to the code, resulting in a low desired coupling. We can also use abstractions or interfaces to access these services in addition to the app's config.</p>
<p class="mce-root">As a first example, we have the file stored in a repository. Access to the repository can be executed via a URL, regardless of local or remote access (such as Amazon S3). For this, we use the app's config. Of course, the way to store files locally or remotely, in the last instance, may be different, but the use of an interface greatly improves this issue.<br class="calibre9"/>
<br class="calibre9"/>
As a second example, we have the use of a SQL database in different environments (production, staging, and development). We should only change the URL of the connection to the database using what is in the <span class="calibre10">application's config</span>. This strategy should be extended to a possible change of database management systems, such as from MySQL to DB2. Of course, we know that in practice, the use of specific mechanisms for a database can improve performance. However, the changes, if they happened, would be minimal:</p>
<div class="cdpaligncenter"><img src="Images/abe84a15-b5a3-40db-9c60-3bfbe15b2d55.png" width="629" height="320" class="calibre88"/></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Build, release, run</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">The process of transforming a codebase into a given environment must be divided into three strictly separate stages:</p>
<ul class="calibre15">
<li class="calibre16"><strong class="calibre3">Build</strong>: Compiles and generates an executable package; for example, generating an EAR or WAR archive.</li>
<li class="calibre16"><strong class="calibre3">Release</strong>: Applies the app's config in the executable package. The resulting release, which is the combination of the package generated in the build with the app's config, is ready to be scanned in the environment that contains the config.</li>
<li class="calibre16"><strong class="calibre3">Run</strong> (or runtime): Initializes the application in the specific environment.</li>
</ul>
<p class="mce-root">The separation of these steps, that is, the definition of their responsibilities is important for improving system maintenance and automation. Continuous integration tools are used in these steps (Maven and Jenkins are examples of these tools):</p>
<div class="cdpaligncenter"><img src="Images/8adcda1d-cb5f-40af-88ba-2709a0b2c489.png" class="calibre89"/></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Processes</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">The twelve-factor methodology emphasizes that all processes or components of the application must be stateless and share-nothing, that is, they should not store information. Therefore, in an application decomposed into microservices, each microservice must not store information in memory or use the server cache. This is an important factor for escalating an application. If there is a need to store some states between the requests, or some data to be used later, we can use a database.</p>
<p class="mce-root">When we use memory to store information for later use in another request, we run a risk because the next request may be in a different process (or the request can <span class="calibre10">even</span><span class="calibre10"> be processed by another server):</span></p>
<p class="cdpaligncenter2"><img src="Images/fba60933-50a6-44b0-b6fc-c7be96679f0a.png" width="627" height="317" class="calibre90"/></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Port-binding</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">A twelve-factor app is fully self-contained and does not depend on the use of an external server, such as Tomcat or Apache, to be exported as a service. A <span class="calibre10">twelve-factor</span> app must export the HTTP service by port-binding, meaning that the application also interfaces with the world via a URL. In this way, one application can be the backing service or external resource of another app.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Concurrency</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">A twelve-factor app must be designed to scale using a process model that allows execution of the processes in parallel mode. This is much like the UNIX process model used when executing daemons. Consequently, we can design processes that only deal with HTTP requests while we can also have processes that deal with tasks that are very long and executed in the background. The process model shows its importance when the application needs to scale, because, at that moment, the application is replicated, making copies of the processes instead of executing a new instance.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Disposability</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">In the world of cloud computing, processes are constantly emerging and dying; this is exactly what causes escalation on-demand. In these conditions, the birth or origination of a process must be as fast as possible, and your interruption should be as fast, and have an as little impact, as possible. </p>
<p class="mce-root">The processes of a twelve-factor application are disposable, meaning that they can be initialized and stopped at any time. A process that ends without impact means that it should end gracefully, saving the state if necessary, and releasing the allocated computing resources.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Dev/prod parity</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">A twelve-factor app should keep the production, testing, and development environments in as similar a state as possible. This facilitates the process of continuous deployment, while avoiding possible errors generated when the builds are sent from the development environment to the production environment.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Logs</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">The log of a twelve-factor app should be treated as an event stream. In a traditional environment, the log can be generated for a file. However, problems can arise, such as a lack of disk space. We know that in a cloud computing environment, where there is elastic scalability depending on demand, processes are born and die all the time. Likewise, machines and containers may no longer be used. Log files could get lost in this resizing in the cloud. Treating a log as an event stream is critical on a platform such as a cloud. In this way, logs can be directed anywhere. For example, they could be directed to a database in NoSQL, to another service, to a file in a repository, to a <span class="calibre10">log-indexing-and-analysis system, or </span>to a data-warehousing system.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Admin processes</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">The twelve-factor method indicates that maintenance tasks, such as script execution for data migration, initial data loading, and cache cleaning, should be automated and performed on time. Because our application will run in multiple environments, and across multiple servers, it is necessary to use the same set of tools, software, and configuration files to perform these tasks. Consequently, parity problems between the different environments are reduced.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">The API Gateway</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">The decomposition of an application into small, intelligent, and well-defined components is an important design pattern in the world of cloud computing. These components are the microservices that bind the application business together. However, the control of these microservices, as seen in <a href="9e35e298-1a91-43b8-ace1-805997b2b89e.xhtml" target="_blank" class="calibre14 pcalibre pcalibre3 pcalibre2 pcalibre1">Chapter 7</a>, <em class="calibre12">Microservice Patterns</em>, is a complex task as the functionalities grow in the application history. One solution to this problem is called the <strong class="calibre8"><span class="calibre10">API </span></strong><span class="calibre10"><strong class="calibre8">Gateway</strong>. As the API Gateway has already been explored in detail, in <a href="9e35e298-1a91-43b8-ace1-805997b2b89e.xhtml" target="_blank" class="calibre14 pcalibre pcalibre3 pcalibre2 pcalibre1">Chapter 7</a>, <em class="calibre12">Microservice Patterns,</em> we will </span><span class="calibre10">only</span><span class="calibre10"> </span><span class="calibre10">cover it briefly now.</span></p>
<p class="mce-root">The API Gateway serves as a frontend for cloud-application clients. Sometimes, the request is a simple call to a specific microservice, but often the API Gateway functions as a coarse-granulation layer that receives a request and performs several calls to microservices that are related to the required functionality. This issue is also related to the microservice aggregator pattern and the microservice proxy pattern. The API name comes exactly from the way that clients access the microservices, which is similar to the use of an API, as demonstrated in the following diagram:</p>
<div class="cdpaligncenter"><img src="Images/18217b3a-9faf-41e3-ab00-5830c95e3ce8.png" class="calibre91"/></div>
<p class="mce-root">Depending on the type of client in question, a given system's functionality may sometimes work differently and the application may respond with different information. When calling a system service, a mobile client receives a smaller set of information than a web client (who uses a desktop computer). Taking this into account, there is an extension to the API Gateway. The extended API Gateway can provide a specific API for each type of client. In this way, a mobile client would access a mobile API, while a web client or a browser would access the web API:</p>
<div class="cdpaligncenter"><img src="Images/4a4ab591-6680-439f-a8e0-5618d8a7f32e.png" class="calibre92"/></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">The service-registry pattern</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">We know that microservices are exposed via access protocols such as HTTP/REST. This means that the services are accessed via a URL. However, we are in the cloud world, which has elastic scalability. The IPs of containers and virtual machines are dynamic and can change frequently. Consequently, the locations of services residing in these containers are also subject to change. As we have already said, instances of microservices are created and terminated constantly. Therefore, the following question arises—how can a client of a microservice handle this problem? The solution is to implement the service registry pattern. A service registry is a database of registered services. When a microservice is born, it is recorded on this database, and when it dies, it is unregistered from the <span class="calibre10">database</span>.</p>
<p class="mce-root">A microservice client accesses the service registry that is responsible for knowing whether the microservice is available, as well as providing its location to the client. Let's look at the following diagram:</p>
<div class="cdpaligncenter"><img src="Images/e2e428b6-1304-40af-a0bb-db777f7e8721.png" class="calibre93"/></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Config server</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">An application, whether in the cloud or not, has properties such as credentials and database location, application-specific information, and URLs for accessing external resources. For a traditional application, these properties are usually in a properties file. If we change a value of one of these properties, we must stop the application and restart the application container. This question becomes more critical when there are different environments, such as production, staging, and development. Each of these environments has their own configurations.<br class="calibre9"/>
In the context of the cloud, microservices may be in different locations or servers. Let's assume that these properties are in the same microservice location. To change a property, we must locate the microservice, change the property, and restart the container. With a large number of microservices, this would be quite critical.</p>
<p class="mce-root">To solve this problem, a layer called <strong class="calibre8">cloud config server</strong> has been introduced and its role is to manage the properties of the application based on microservices. This layer is responsible for maintaining these properties, and whenever any of these properties are changed, this change is reflected in the microservice (or application) without the need to rebuild or restart the service.</p>
<p class="mce-root">The config server is responsible for providing the properties for each registered microservice (service registry). When the config server initializes, the microservice properties are obtained from a path that was specified when the microservice was registered. The properties obtained are then stored in memory. This path is controlled by a version server (such as git or subversion). When a registered microservice is initialized, it goes to the config server and obtains the related properties. When there is a need to change a property of a microservice, we must go to the path in the config server, change the properties, and restart the config server, as can be seen in the following diagram:</p>
<div class="cdpaligncenter"><img src="Images/939622c6-b678-4ed3-ad4d-4caa32f9083b.png" class="calibre94"/></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">The circuit-breaker pattern</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">In the cloud scenario with distributed systems, the probability of service failure exists for several reasons, such as a lack of connection or an unavailable service. The services created in the cloud must rely on this scenario and be prepared for fault-tolerance. This way, when a fault occurs, the reason for the fault will probably be fixed and the service will work again. However, there are situations where failures are caused by totally unexpected events and, even though the service tries to work again, it cannot. The situation is even more critical when there is timeout management.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root">With very long waiting periods for situations in which the failure does not disappear within a reasonable period of time, computational resources remain blocked by the timeout time. Furthermore, as other requirements for the same service arrive, things get worse. Services that depend on this service (that is, waiting for the fault to end) are also inoperative, causing the problem to cascade. The solution to this problem is the implementation of the circuit-breaker pattern. A circuit-breaker pattern handles faults that take a long time to recover.</p>
<p class="mce-root">The circuit-breaker pattern prevents an operation from <span class="calibre10">repeatedly</span><span class="calibre10"> </span><span class="calibre10">attempting to run in situations where it will likely fail during execution. In addition, this pattern checks to see whether the failure has been resolved. If it has been resolved, the proxy sends the request to the operation. If the operation fails, the failure counter is immediately incremented. </span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">The circuit-breaker mechanism</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">The circuit breaker functions as a proxy by routing the request to the operation or returning an exception immediately. The pattern has this name because its operation is similar to an electric circuit. This proxy has three distinct states, as demonstrated in the following diagram:</p>
<ul class="calibre15">
<li class="calibre16"><strong class="calibre3">Closed</strong>: The proxy sends the request to the operation. The proxy maintains a sequential counter of previous failures. If the execution of the operation fails, this counter is incremented. If the failure counter exceeds an established threshold, the proxy switches to an open state. However, at this point, a timer is started with a specified timeout time. The purpose of this is to cause the failure to be corrected during the timeout. When the timer expires, the proxy becomes half-open.</li>
<li class="calibre16"><strong class="calibre3">Open</strong>: When a request arrives, an exception is returned immediately.</li>
<li class="calibre16"><strong class="calibre3">Half-open</strong>: A limited number of requests are passed to the operation. If these requests succeed, the state changes to closed, and the failure counter is reset. If any request fails, the state changes to open and the timeout timer is restarted. The half-open state is important for avoiding a flood of requests to the operation in a short time.</li>
</ul>
<p class="mce-root"/>
<p class="mce-root"/>
<div class="cdpaligncenter"><img src="Images/35c7e123-1ede-47e3-b74b-edc98eb47401.png" width="564" height="269" class="calibre95"/><br class="calibre2"/></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">In this chapter, we explained the concept of cloud-native applications as well as the objectives and characteristics of a cloud application. We saw the main design patterns that aid in the construction of a cloud application. Among the main patterns, we reviewed the architecture of microservices and API Gateways. We also learned about the twelve-factor methodology, which helps in the implementation of a cloud application. Finally, we explored the service-registry patterns, which return the service location, the config server, which provides the necessary configurations to the microservices without the need to restart any containers, and the circuit breaker, a pattern that handles long-term failures.</p>


            </article>

            
        </section>
    </div>



  </body></html>