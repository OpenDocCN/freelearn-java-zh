<html><head></head><body><div class="chapter" title="Chapter&#xA0;5.&#xA0;JSF Configurations Using XML Files and Annotations &#x2013; Part 2"><div class="titlepage"><div><div><h1 class="title"><a id="ch05"/>Chapter 5. JSF Configurations Using XML Files and Annotations – Part 2</h1></div></div></div><p>In this chapter, we will continue to explore more situations where the <code class="literal">faces-config.xml</code> file will help us to accomplish different configuration tasks (of course, for some of them we have the alternative of annotations, while for others, we need to switch to the XML configuration level). Besides the examples presented in the previous chapter, this chapter will go deeper and cover the further list of tasks, which are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Configuring resource handlers</li><li class="listitem" style="list-style-type: disc">Configuring the View handler</li><li class="listitem" style="list-style-type: disc">Overriding JSF renders</li><li class="listitem" style="list-style-type: disc">Working with client behavior functionality</li><li class="listitem" style="list-style-type: disc">Configuring the Global Exception handler</li><li class="listitem" style="list-style-type: disc">Configuring render kit factory</li><li class="listitem" style="list-style-type: disc">Configuring partial view context</li><li class="listitem" style="list-style-type: disc">Configuring visit context</li><li class="listitem" style="list-style-type: disc">Configuring external context</li><li class="listitem" style="list-style-type: disc">Configuring Flash</li><li class="listitem" style="list-style-type: disc">JSF 2.2 Window ID API</li><li class="listitem" style="list-style-type: disc">Configuring lifecycle</li><li class="listitem" style="list-style-type: disc">Configuring application</li><li class="listitem" style="list-style-type: disc">Configuring VDL</li><li class="listitem" style="list-style-type: disc">Combining multiple factory's powers</li></ul></div><div class="section" title="Configuring resource handlers"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec44"/>Configuring resource handlers</h1></div></div></div><p>Starting with JSF 2.0, all <a id="id639" class="indexterm"/>the web resources, such as CSS, JavaScript, and <a id="id640" class="indexterm"/>images are loaded from a folder named <code class="literal">resources</code>, present under the root of your web application or from <code class="literal">/META-INF/resources</code> in JAR files. A folder under the <code class="literal">resources</code> folder is known as a <code class="literal">library</code> or <code class="literal">theme</code>, which is like a collection of client artifacts. We can also create a special folder matching the regex <code class="literal">\d+(_\d+)*</code> under the <code class="literal">library</code> folder for providing versioning. In this case, the default JSF resource handler will always retrieve the newest version to display. The various approaches that can be followed for structuring the <code class="literal">resources</code> folder are as shown in the following figure:</p><div class="mediaobject"><img src="graphics/6466EN_05_01.jpg" alt="Configuring resource handlers"/></div><p>In the preceding figure, part <span class="strong"><strong>A</strong></span> depicts a common structure of the <code class="literal">resources</code> folder without versioning, and in part <span class="strong"><strong>B</strong></span>, you have the versioning approach. The folders <code class="literal">css</code>, <code class="literal">js</code>, <code class="literal">img</code>, and others usually denote the content type of files inside them; however, this is not mandatory.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note95"/>Note</h3><p>Note that the library name shouldn't denote the content type.</p></div></div><p>Part <span class="strong"><strong>C</strong></span>, represents the complete structure of the subfolders supported under the <code class="literal">resources</code> folder. In this case, we entirely exploit the automatic localization and version management, which works if we respect the following structure under the <code class="literal">resources</code> folder and is known as <span class="emphasis"><em>resourceIdentifier</em></span> (the <code class="literal">[]</code> demarcate optional parts):</p><div class="informalexample"><pre class="programlisting">[localePrefix/][libraryName/][libraryVersion/]resourceName[/resourceVersion]</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note96"/>Note</h3><p>In the case of face flows packaged within JAR files, resources packaged in <code class="literal">CLASSPATH</code> must reside under the JAR entry name <code class="literal">META-INF/flows/resourceIdentifier</code>.</p></div></div><p>We<a id="id641" class="indexterm"/> will also discuss the case referred to in part <span class="strong"><strong>A</strong></span>, since<a id="id642" class="indexterm"/> this is the most used case. But for the sake of completeness, you can check the complete application named <code class="literal">ch5_12</code>, which represents an implementation case from part <span class="strong"><strong>C</strong></span> (that includes part <span class="strong"><strong>B</strong></span> as well).</p><p>So, having the structure from the preceding figure, we can easily load a CSS file (<code class="literal">rafa.css</code>) using the following code:</p><div class="informalexample"><pre class="programlisting">&lt;h:outputStylesheet library="default" name="css/rafa.css"/&gt;</pre></div><p>Alternatively, you can load a JavaScript file (<code class="literal">rafa.js</code>) using the following code:</p><div class="informalexample"><pre class="programlisting">&lt;h:outputScript library="default" name="js/rafa.js"/&gt;</pre></div><p>Alternatively, you can load an image file (<code class="literal">rafa.png</code>) using the following code:</p><div class="informalexample"><pre class="programlisting">&lt;h:graphicImage library="default" name="img/rafa.png"/&gt;</pre></div><p>So, this is how the JSF default resource handler deals with resources. But what can we do if we don't respect this inflexible structure of folders? For example, if we have the CSS files under the application web root in <code class="literal">/players/css/</code>, or we want to place resources in a protected folder, such as <code class="literal">WEB-INF</code> (probably the biggest disadvantage of the <code class="literal">resources</code> folder is that everything in it is accessible from outside by default). In this case, there is no directly accessible <code class="literal">resources</code> folder and we have no idea what a library is. If we write something like the following code, it will not work:</p><div class="informalexample"><pre class="programlisting">&lt;h:outputStylesheet name="rafa.css"  /&gt;</pre></div><p>Among the possible solutions, we have the facility to write a custom resource handler. It is much simpler than it sounds, because JSF provides several wrappers (implements <code class="literal">FacesWrapper</code>) that help us to write custom handlers and factories by overriding only the methods that we want to affect. In case of a custom resource handler, we need to perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Extend the <code class="literal">ResourceHandlerWrapper</code> class.</li><li class="listitem">Write a delegating constructor. JSF will call this constructor for passing the standard resource handler, which we will wrap in a <code class="literal">ResourceHandler</code> instance. We can also obtain this instance by overriding the <code class="literal">getWrapped</code> method.</li><li class="listitem">Override the <code class="literal">createResource</code> method. Here, we can sort the resources and decide which of them go to the default resource handler and which of them go to our custom resource handler.</li></ol></div><p>The following <a id="id643" class="indexterm"/>implementation<a id="id644" class="indexterm"/> is based on the preceding three steps:</p><div class="informalexample"><pre class="programlisting">public class CustomResourceHandler extends
             javax.faces.application.ResourceHandlerWrapper {

 private ResourceHandler wrapped;

 public CustomResourceHandler(ResourceHandler wrapped) {
  this.wrapped = wrapped;
 }

 @Override
 public ResourceHandler getWrapped() {
  return this.wrapped;
 }

 @Override
 public Resource createResource(String resourceName, String libraryName){         
       
  if ((!resourceName.equals("rafa.css")) &amp;&amp; 
      (!resourceName.equals("roger.css"))) {
       //in JSF 2.0 and JSF 2.2
       //return super.createResource(resourceName, libraryName);  
       //only in JSF 2.2
       return super.createResourceFromId
        (libraryName+"/"+resourceName);        
  } else {
       return new PlayerResource(resourceName);
  }

 }
}</pre></div><p>The <code class="literal">PlayerResource</code> class<a id="id645" class="indexterm"/> is our custom resource. The main aim of <code class="literal">PlayerResource</code> is to indicate the correct path <code class="literal">/players/css/</code>, which is not recognized by default. For this, we extend another wrapper named <code class="literal">ResourceWrapper</code> and override the method <code class="literal">getRequestPath</code>, as follows, where we delegate all calls to <code class="literal">ResourceWrapper</code> except one call, <code class="literal">getRequestPath</code>:</p><div class="informalexample"><pre class="programlisting">public class PlayerResource extends  
       javax.faces.application.ResourceWrapper {

 private String resourceName;

 public PlayerResource(String resourceName) {
  this.resourceName = resourceName;
 }

 @Override
 public Resource getWrapped() {
  return this;
 }

 @Override
 public String getRequestPath() {
  return "players/css/" + this.resourceName;
 }
}</pre></div><p>Next, you have to<a id="id646" class="indexterm"/> configure <a id="id647" class="indexterm"/>the custom resource handler in <code class="literal">faces-config.xml</code> as follows:</p><div class="informalexample"><pre class="programlisting">&lt;application&gt;
 &lt;resource-handler&gt;book.beans.CustomResourceHandler&lt;/resource-handler&gt;
&lt;/application&gt;</pre></div><p>Now, if you try to load the <code class="literal">rafa.css</code> (or <code class="literal">roger.css</code>) file, you can add the following lines of code:</p><div class="informalexample"><pre class="programlisting">&lt;h:outputStylesheet name="rafa.css"/&gt;
&lt;h:outputStylesheet name="roger.css"/&gt;</pre></div><p>The complete application is named <code class="literal">ch5_1_1</code> and is available in the code bundle of this chapter.</p><p>However, remember that I said "Among the possible solutions ..."? Well, starting with JSF 2.2, we can indicate the folder of resources through a context parameter in the <code class="literal">web.xml</code> descriptor, as follows (mapped by the <code class="literal">ResourceHandler.WEBAPP_RESOURCES_DIRECTORY_PARAM_NAME</code> field):</p><div class="informalexample"><pre class="programlisting">&lt;context-param&gt;
 &lt;param-name&gt;javax.faces.WEBAPP_RESOURCES_DIRECTORY&lt;/param-name&gt;
 &lt;param-value&gt;/players/css&lt;/param-value&gt;
&lt;/context-param&gt;</pre></div><p>Or, we can place the <code class="literal">resources</code> folder under <code class="literal">WEB-INF</code>, which can be accessed by JSF from inside <code class="literal">WEB-INF</code> but never from outside:</p><div class="informalexample"><pre class="programlisting">&lt;context-param&gt;
 &lt;param-name&gt;javax.faces.WEBAPP_RESOURCES_DIRECTORY&lt;/param-name&gt;
 &lt;param-value&gt;/WEB-INF/resources&lt;/param-value&gt;
&lt;/context-param&gt;</pre></div><p>A complete example<a id="id648" class="indexterm"/> named <code class="literal">ch5_1_2</code> is available in the code <a id="id649" class="indexterm"/>bundle of this chapter.</p><p>A custom resource handler can be useful to pass extra parameters to the linking file (for example CSS, JS, images, and so on). We can use this approach to reset the browser cache. Browsers cache static resources such as CSS, JS, and images; therefore they are not requested from the server each time the web page loads. We can force this by adding a parameter to the linking file in the query string, representing a version number or something that makes the browser to understand that it should load the resource from the server, not from the cache.</p><p>In this case, we assume that the <code class="literal">rafa.css</code> file is under the <code class="literal">/resources/default/css/</code> folder and it is loaded using the following code:</p><div class="informalexample"><pre class="programlisting">&lt;h:outputStylesheet library="default" name="css/rafa.css"/&gt;</pre></div><p>At this moment, the generated HTML is as follows:</p><div class="informalexample"><pre class="programlisting">&lt;link type="text/css" rel="stylesheet" href="/ch5_1_3/faces/javax.faces.resource/css/rafa.css?ln=default" /&gt;</pre></div><p>Also, we want to obtain something like the following code:</p><div class="informalexample"><pre class="programlisting">&lt;link type="text/css" rel="stylesheet" href="/ch5_1_3/faces/javax.faces.resource/css/rafa.css?ln=default&amp;amp;v=v4.2.1"&gt;</pre></div><p>For this, we need to override the <code class="literal">createResource</code> method as follows:</p><div class="informalexample"><pre class="programlisting">@Override
public Resource createResource(String resourceName, String libraryName) {
  Resource resource = super.createResource(resourceName, libraryName);
  return new PlayerResource(resource);
}</pre></div><p>Also, <code class="literal">PlayerResource</code> is responsible to add the version parameter in the <code class="literal">getRequestPath</code> method:</p><div class="informalexample"><pre class="programlisting">@Override
public String getRequestPath() {            
 String requestPath = resource.getRequestPath();
        
 logger.log (Level.INFO, "Initial request path is: {0}", requestPath);
  
 String new_version = "v4.2.1";
       
 if(requestPath.contains("?"))
    requestPath = requestPath + "&amp;v=" + new_version;
 else
    requestPath = requestPath + "?v=" + new_version;
     
 logger.log (Level.INFO, "New request path is: {0}", requestPath);
        
 return requestPath;
}</pre></div><p>The complete application is available in the code bundle named <code class="literal">ch5_1_3</code>.</p><p>Of course, in real <a id="id650" class="indexterm"/>cases, unlike in the preceding code, the version<a id="id651" class="indexterm"/> number is not hardcoded. Knowing that JSF 2.2 allows us to use dependency injection in custom resource handlers, we can inject the parameter values from a bean that can play the role of a version tracking system using the following code:</p><div class="informalexample"><pre class="programlisting">public class CustomResourceHandler extends
       javax.faces.application.ResourceHandlerWrapper {

@Inject
private VersionBean versionBean;

...
@Override
public Resource createResource(String resourceName, String libraryName) {

 Resource resource = super.createResource(resourceName, libraryName);
 return new PlayerResource(resource, versionBean.getVersion());
}
...</pre></div><p>The complete example is named <code class="literal">ch5_1_4</code>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note97"/>Note</h3><p>You can also use the versioning system of JSF for invalidate browser cache, but you need to create the right folder under the library folder. - JSF will automatically load the last version. Passing parameters as we have seen earlier can be useful for many other things, such as generating customized JS and CSS response. Servers can access such parameters and JS as well.</p></div></div><p>Browser caching can also be controlled with two context parameters in the <code class="literal">web.xml</code> descriptor (specific to Mojarra) as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">com.sun.faces.defaultResourceMaxAge</code>: This <a id="id652" class="indexterm"/>parameter can be used to set the expiry time in milliseconds.</li><li class="listitem" style="list-style-type: disc"><code class="literal">com.sun.faces.resourceUpdateCheckPeriod</code>: This parameter gives frequency in minutes to <a id="id653" class="indexterm"/>check for changes in web application artifacts that contain resources.</li></ul></div><p>JSF resource<a id="id654" class="indexterm"/> handling provides solid advantages such as<a id="id655" class="indexterm"/> caching and loading resources within a JAR or writing custom UI components that contain CSS or JS, but it also has some disadvantages. For example, web designers use the static approach to add images in CSS, as follows:</p><div class="informalexample"><pre class="programlisting">background-image: url(<span class="emphasis"><em>link_to_image</em></span>)</pre></div><p>However, when importing CSS style sheets using <code class="literal">&lt;h:outputStyleSheet&gt;</code>, the style sheet is imported and processed by FacesServlet through the <code class="literal">/javax.faces.resource/*</code> folder, which makes the picture relative path unavailable (in this case, the CSS file becomes a JSF resource). One of the solutions is to force the image URL to become a JSF resource, using the resource mapper in EL, <code class="literal">#{resource}</code>, as <code class="literal">#{resource['</code><span class="emphasis"><em>library</em></span><code class="literal">:</code><span class="emphasis"><em>location</em></span><code class="literal">']}</code>. For example, in <code class="literal">rafa.css</code> (loaded in the page via <code class="literal">&lt;h:outputStylesheet&gt;</code>), we can load the <code class="literal">rafa.png</code> image using the following code:</p><div class="informalexample"><pre class="programlisting">body {
    background-image: url('#{resource["default:img/rafa.png"]}')
}</pre></div><p>Based on this, <code class="literal">&lt;h:graphicImage&gt;</code> can load <code class="literal">rafa.png</code> as follows:</p><div class="informalexample"><pre class="programlisting">&lt;h:graphicImage value="#{resource['default:img/rafa.png']}"/&gt;</pre></div><p>You can check these examples in the application named <code class="literal">ch5_13</code>.</p><p>As an alternative, you can use OmniFaces library's <code class="literal">UnmappedResourceHandler</code>, which spares us from <a id="id656" class="indexterm"/>modifying the CSS files (<a class="ulink" href="http://showcase.omnifaces.org/resourcehandlers/UnmappedResourceHandler">http://showcase.omnifaces.org/resourcehandlers/UnmappedResourceHandler</a>). Moreover, another approach consists in writing a custom <code class="literal">ResourceHandler</code> that can fix<a id="id657" class="indexterm"/> this<a id="id658" class="indexterm"/> issue.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note98"/>Note</h3><p>From JSF 2.2 onwards, <code class="literal">ResourceResolver</code> has been merged into <code class="literal">ResourceHandler</code>, and <code class="literal">ResourceResolver</code> itself has been deprecated. These two are detailed in <a class="link" href="ch12.html" title="Chapter 12. Facelets Templating">Chapter 12</a>, <span class="emphasis"><em>Facelets Templating</em></span>.</p></div></div><div class="section" title="Adding CSS and JS resources programmatically"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec59"/>Adding CSS and JS resources programmatically</h2></div></div></div><p>Sometimes, you may <a id="id659" class="indexterm"/>need to load the <a id="id660" class="indexterm"/>CSS and JS resources by specifying them in a managed bean method. For example, the following method loads <code class="literal">rafa.css</code> and <code class="literal">rafa.js</code> in a programmatic fashion:</p><div class="informalexample"><pre class="programlisting">public void addResourcesAction() {
 FacesContext facesContext = FacesContext.getCurrentInstance();
 UIOutput rafa_css = new UIOutput();
 UIOutput rafa_js = new UIOutput();

 rafa_css.setRendererType("javax.faces.resource.Stylesheet");
 rafa_css.getAttributes().put("library", "default");
 rafa_css.getAttributes().put("name", "css/rafa.css");
 rafa_js.setRendererType("javax.faces.resource.Script");
 rafa_js.getAttributes().put("library", "default");
 rafa_js.getAttributes().put("name", "js/rafa.js");
 facesContext.getViewRoot().addComponentResource
            (facesContext, rafa_css, "head");
 facesContext.getViewRoot().addComponentResource
            (facesContext, rafa_js, "head");
}</pre></div><p>The complete application is named <code class="literal">ch5_14</code>.</p></div></div></div>
<div class="section" title="Configuring the view handler"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec45"/>Configuring the view handler</h1></div></div></div><p>JSF provides a view<a id="id661" class="indexterm"/> handler that can be used for working with views. It <a id="id662" class="indexterm"/>can be a very handy tool when you want to interact with a view or create/restore/extend/modify a view. It is also good practice to deal with URLs here, which is exactly what you will see next.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note99"/>Note</h3><p>A view handler is not a good choice when you need to work with components! Even if this is possible, view handlers were not created for such tasks.</p></div></div><p>Sometimes you may need to convert absolute URLs into relative URLs. For example, if you run an application behind a reverse proxy, you may need to provide relative URLs. By default, the browser appends each absolute URL to the host, which is obviously a big issue.</p><p>In order to convert absolute URLs into relative URLs, we need to perform the following steps:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Create a new view handler by extending the <code class="literal">ViewHandlerWrapper</code> class. Extending this wrapper allows us to override only the required methods.</li><li class="listitem" style="list-style-type: disc">Override the <code class="literal">getActionURL</code> and <code class="literal">getResourceURL</code> methods.</li><li class="listitem" style="list-style-type: disc">Configure the view handler in <code class="literal">faces-config.xml</code>.</li></ul></div><p>Although it may sound <a id="id663" class="indexterm"/>pompous,<a id="id664" class="indexterm"/> the following code is self-explanatory:</p><div class="informalexample"><pre class="programlisting">public class URLHandler extends ViewHandlerWrapper {

 private ViewHandler baseViewHandler;

 public URLHandler(ViewHandler baseViewHandler) {
  this.baseViewHandler = baseViewHandler;
 }
    
 @Override
  public String getActionURL(FacesContext context, String viewId) {
   return convertToRelativeURL(context,
          baseViewHandler.getActionURL(context, viewId));
 }

 @Override
 public String getResourceURL(FacesContext context, String path) {
  return convertToRelativeURL(context,
         baseViewHandler.getResourceURL(context, path));
 }

 @Override
 public ViewHandler getWrapped() {
  return baseViewHandler;
 }

 private String convertToRelativeURL(FacesContext context,
                                                String theURL){
       
 final HttpServletRequest request = ((HttpServletRequest)  
                          context.getExternalContext().getRequest());
 final URI uri;
 String prefix = "";

 String string_uri = request.getRequestURI();
       
 try {
     uri = new URI(string_uri);
 } catch (URISyntaxException ex) {
     Logger.getLogger(URLHandler.class.getName()).
                                  log(Level.SEVERE, null, ex);
     return "";
 }

 String path = uri.getPath();
 String new_path = path.replace("//", "/");

 if (theURL.startsWith("/")) {
     int count = new_path.length() - new_path.replace("/", "").length();
     for (int i = 0; i &lt; (count - 1); i++) {
          prefix = prefix + "/..";
     }
     if (prefix.length() &gt; 0) {
         prefix = prefix.substring(1);
     }
 }

 return (prefix + theURL);
 }
}</pre></div><p>The required <a id="id665" class="indexterm"/>configuration<a id="id666" class="indexterm"/> in <code class="literal">faces-config.xml</code> is as follows:</p><div class="informalexample"><pre class="programlisting">...
&lt;application&gt;
 &lt;view-handler&gt;book.beans.URLHandler&lt;/view-handler&gt;  
&lt;/application&gt;
...</pre></div><p>The complete application is available in the code bundle named <code class="literal">ch5_2_1</code>.</p><p>If you check the source code of the <code class="literal">index.xhtml</code> page, you will notice that instead of an absolute URL for the CSS resource, there is a relative one, of the following type:</p><div class="informalexample"><pre class="programlisting">&lt;link type="text/css" rel="stylesheet" href="../ch5_2_1/faces/javax.faces.resource/css/rafa.css?ln=default"&gt;</pre></div><p>Done! Now you can run the application behind a reverse proxy.</p><p>Another useful view handler is the one that "swallows" the <code class="literal">ViewExpiredException</code> exception. This exception is thrown when a user session expires. Through a view handler, we can treat this exception by recreating the user view. Redirect the flow to a special page (let's name it <code class="literal">expired.xhtml</code>).</p><p>When the <a id="id667" class="indexterm"/>user session expires, <code class="literal">UIViewRoot</code> of the application is set to <code class="literal">null</code>. We <a id="id668" class="indexterm"/>can use this check in the <code class="literal">restoreView</code> method, as follows:</p><div class="informalexample"><pre class="programlisting">public class ExceptionHandler extends ViewHandlerWrapper {

 private static final Logger logger =
         Logger.getLogger(ExceptionHandler.class.getName());
 private ViewHandler baseViewHandler;

 public ExceptionHandler(ViewHandler baseViewHandler) {
        this.baseViewHandler = baseViewHandler;
 }

 @Override
 public UIViewRoot restoreView(FacesContext context, String viewId) {

  UIViewRoot root;

  root = baseViewHandler.restoreView(context, viewId);
  if (root == null) {
      logger.info("The session has expired ...
                   I will not allow ViewExpiredException ...");
      root = createView(context, viewId);

      //root = createView(context, "/expired.xhtml");
      //context.renderResponse();
  }
 return root;
 }

 @Override
 public ViewHandler getWrapped() {
  return baseViewHandler;
 }
}</pre></div><p>The configuration in <code class="literal">faces-config.xml</code> is as follows:</p><div class="informalexample"><pre class="programlisting">...
&lt;application&gt;
 &lt;view-handler&gt;book.beans.ExceptionHandler&lt;/view-handler&gt;  
&lt;/application&gt;
...</pre></div><p>The <a id="id669" class="indexterm"/>complete<a id="id670" class="indexterm"/> application is available in the code bundle and is named <code class="literal">ch5_2_2</code>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note100"/>Note</h3><p>Starting with JSF 2.2, we can use dependency injection with the view handler (<code class="literal">@Inject</code> and <code class="literal">@EJB</code>).</p></div></div></div>
<div class="section" title="Overriding JSF renders"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec46"/>Overriding JSF renders</h1></div></div></div><p>The main responsibilities <a id="id671" class="indexterm"/>of a <code class="literal">Renderer</code> consists of generating the appropriate client-side markup, such as HTML, WML, and XUL, and converting information coming from the client to the proper type for the component.</p><p>JSF provides a set of built-in renders and has the capability to extend them with custom behavior. If you consider a proper workaround to override a built-in render, then perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Extend the desired built-in renderer (for example, <code class="literal">Renderer</code>, <code class="literal">TextRenderer</code>, <code class="literal">LabelRenderer</code>, <code class="literal">MessagesRenderer</code>, and so on).</li><li class="listitem">Override the built-in renderer methods.</li><li class="listitem">Configure the new renderer in <code class="literal">faces-config.xml</code> or using the <code class="literal">@FacesRenderer</code> annotation.</li></ol></div><p>Well, let's see some examples of writing a custom render. For example, let's suppose that we have three attributes (<code class="literal">player-nickname</code>, <code class="literal">player-mother-name</code>, and <code class="literal">player-father-name</code>) that we want to use inside the <code class="literal">&lt;h:inputText&gt;</code> tag. If you try to write the following code:</p><div class="informalexample"><pre class="programlisting">&lt;h:inputText value="Rafael Nadal" player-nickname="Rafa" player-mother-name="Ana Maria Parera" player-father-name="Sebastián Nadal" player-coach-name=" Toni Nadal"/&gt;</pre></div><p>Then, the built-in renderer will give the following output:</p><div class="informalexample"><pre class="programlisting">&lt;input id="..." name="..."
       value="Rafael Nadal" type="text"&gt;</pre></div><p>Obviously, our three attributes were ignored. We can fix this by extending <code class="literal">TextRenderer</code> as follows:</p><div class="informalexample"><pre class="programlisting">public class PlayerInputTextRenderer extends TextRenderer {

public PlayerInputTextRenderer(){}
 
@Override
 protected void getEndTextToRender(FacesContext context,
                UIComponent component, String currentValue)
                     throws java.io.IOException {

  String[] attributes = {"player-nickname",
          "player-mother-name", "player-father-name"};
  ResponseWriter writer = context.getResponseWriter();
  for (String attribute : attributes) {
       String value = (String) component.getAttributes().get(attribute);
       if (value != null) {
           writer.writeAttribute(attribute, value, attribute);
       }
  }
  super.getEndTextToRender(context, component, currentValue);
 }
}</pre></div><p>Done! Configure the new renderer in <code class="literal">faces-config.xml</code> as follows:</p><div class="informalexample"><pre class="programlisting">&lt;application&gt;
 &lt;render-kit&gt;
  &lt;renderer&gt;
   &lt;component-family&gt;javax.faces.Input&lt;/component-family&gt;
   &lt;renderer-type&gt;javax.faces.Text&lt;/renderer-type&gt;
   &lt;renderer-class&gt;book.beans.PlayerInputTextRenderer&lt;/renderer-class&gt;
  &lt;/renderer&gt;
 &lt;/render-kit&gt;
&lt;/application&gt;</pre></div><p>Now, the renderer<a id="id672" class="indexterm"/> input field will be as follows:</p><div class="informalexample"><pre class="programlisting">&lt;input id="..." name="..." player-nickname="Rafa" player-mother-name="Ana Maria Parera" player-father-name="Sebastián Nadal" value="Rafael Nadal" type="text"&gt;</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note101"/>Note</h3><p>Instead of configuring the custom renderer in <code class="literal">faces-config.xml</code>, we could use the <code class="literal">@FacesRenderer</code> annotation, as follows:</p><div class="informalexample"><pre class="programlisting">@FacesRenderer(componentFamily="javax.faces.Input",rendererType="javax.faces.Text")</pre></div><p>But, unfortunately this isn't working. There seems to be a bug here!</p></div></div><p>The complete example is named <code class="literal">ch5_4_1</code>.</p><p>Let's look at another example in order to fortify the knowledge about writing custom renderers. The next example will modify the built-in <code class="literal">LabelRenderer</code> class by adding an image in front of each <code class="literal">&lt;h:outputText&gt;</code> tag, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">public class RafaLabelRenderer extends LabelRenderer{
    
 public RafaLabelRenderer(){}

 @Override
 public void encodeEnd(FacesContext context,
             UIComponent component)throws IOException{
        
  ResponseWriter responseWriter = context.getResponseWriter();
  responseWriter.write("&lt;img src='resources/default/img/logo.png'/&gt;");
}    
}</pre></div><p>Don't forget to configure the renderer in <code class="literal">faces-config.xml</code> as follows:</p><div class="informalexample"><pre class="programlisting"> &lt;component-family&gt;javax.faces.Output&lt;/component-family&gt;
 &lt;renderer-type&gt;javax.faces.Text&lt;/renderer-type&gt;
 &lt;renderer-class&gt;book.beans.RafaLabelRenderer&lt;/renderer-class&gt;</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note103"/>Note</h3><p>Starting with JSF 2.2, we can use dependency injection in renderers (<code class="literal">@Inject</code> and <code class="literal">@EJB</code>). The complete example of the preceding renderer is named <code class="literal">ch5_4_2</code> (the image name was provided by another bean through injection dependency).</p></div></div><p>The upcoming <a id="id673" class="indexterm"/>example in this section is a little bit tricky.</p><p>If you have used PrimeFaces, especially the <code class="literal">&lt;p:messages&gt;</code> tag, then you know that this tag accepts an attribute named <code class="literal">escape</code>. The attribute's value can be <code class="literal">true</code> or <code class="literal">false</code>, and it defines whether HTML would be escaped or not (defaults to <code class="literal">true</code>).</p><p>Unfortunately, JSF 2.2 still doesn't provide such attributes for the <code class="literal">&lt;h:messages&gt;</code> tag, but there is at least a workaround to solve this. You can implement a custom renderer that is capable of understanding the <code class="literal">escape</code> attribute.</p><p>JSF provides a class named <code class="literal">ResponseWriter</code>, which is useful in this case because it provides methods capable of producing elements and attributes for markup languages such as HTML and XML. Moreover, JSF provides a wrapper for this class named <code class="literal">ResponseWriterWrapper</code>. We can easily extend this class, and override the method <code class="literal">writeText</code>, which is useful for writing escaped strings obtained from objects by conversions. Un-escaped strings are written by the <code class="literal">write</code> method.</p><p>So, based on this information, we can easily write our response writer, as follows:</p><div class="informalexample"><pre class="programlisting">public class EscapeResponseWriter extends ResponseWriterWrapper {

 private ResponseWriter responseWriter;

 public EscapeResponseWriter(ResponseWriter responseWriter) {
  this.responseWriter = responseWriter;
 }

 @Override
 public ResponseWriter getWrapped() {
  return responseWriter;
 }

 @Override
 public void writeText(Object text, UIComponent component,
                            String property) throws IOException {

  String escape = (String) component.getAttributes().get("escape");
  if (escape != null) {
      if ("false".equals(escape)) {
          super.write(String.valueOf(text));
      } else {
        super.writeText(String.valueOf(text), component, property);
      }
  }
 }
}</pre></div><p>So far, so good! Now we need to write the custom renderer, as shown in the following code, by extending the <code class="literal">MessagesRenderer</code> class, which is the default renderer for JSF messages. The only method we need to affect is the <code class="literal">encodeEnd</code> method, by placing our response writer instead of the default one. In the end, we restore it to default.</p><div class="informalexample"><pre class="programlisting">public class EscapeMessagesRenderer extends MessagesRenderer {
        
 public EscapeMessagesRenderer(){}

 @Override
 public void encodeEnd(FacesContext context,
         UIComponent component) throws IOException {
       
 ResponseWriter responseWriter = context.getResponseWriter();
 context.setResponseWriter(new EscapeResponseWriter(responseWriter));          
 super.encodeEnd(context, component);
 context.setResponseWriter(responseWriter);
 }
}</pre></div><p>Finally, configure <a id="id674" class="indexterm"/>the new renderer in <code class="literal">faces-config.xml</code> as follows:</p><div class="informalexample"><pre class="programlisting">&lt;renderer&gt;
 &lt;component-family&gt;javax.faces.Messages&lt;/component-family&gt;
 &lt;renderer-type&gt;javax.faces.Messages&lt;/renderer-type&gt;
 &lt;renderer-class&gt;book.beans.EscapeMessagesRenderer&lt;/renderer-class&gt;
&lt;/renderer&gt;</pre></div><p>Now, you can add HTML content in your messages by setting the <code class="literal">escape</code> attribute as follows:</p><div class="informalexample"><pre class="programlisting">&lt;h:messages escape="false" /&gt;</pre></div><p>The complete example is named <code class="literal">ch5_4_3</code>.</p><p>In the preceding examples, we saw a few use cases of extending an existing renderer. The last example of this section will go a little bit further, and will represent a use case for writing a custom <code class="literal">RenderKit</code> and a custom renderer by extending the abstract class <code class="literal">Renderer</code>.</p><p>While the <code class="literal">Renderer</code> class <a id="id675" class="indexterm"/>converts the internal representation of UI components into the output stream, <code class="literal">RenderKit</code> represents a collection of <code class="literal">Renderer</code> instances capable to render JSF UI component's instances for a specific client (for example, a specific device). Each time JSF needs to render a UI component, it will call the <code class="literal">RenderKit.getRenderer</code> method which is capable of returning an instance of the corresponding renderer based on two arguments that uniquely identifies it: the <span class="strong"><strong>component family</strong></span><a id="id676" class="indexterm"/> and the <a id="id677" class="indexterm"/>
<span class="strong"><strong>renderer type</strong></span>.</p><p>Let's suppose that we want to alter the default behavior of the renderer used for all UI components grouped under the <code class="literal">javax.faces.Input</code> family, by adding a custom style using some CSS. This can be easily accomplished by writing a custom <code class="literal">RenderKit</code> and overriding the <code class="literal">getRenderer</code> method. Starting with JSF 2.2, we can do this pretty fast, because we can extend the new wrapper class that represents a simple implementation of the abstract class, <code class="literal">RenderKit</code>. This is named <code class="literal">RenderKitWrapper</code> and allows us to override only the desired methods.</p><p>For example, we override the <code class="literal">getRenderer</code> method as follows:</p><div class="informalexample"><pre class="programlisting">public class CustomRenderKit extends RenderKitWrapper {

 private RenderKit renderKit;

 public CustomRenderKit() {}

 public CustomRenderKit(RenderKit renderKit) {
  this.renderKit = renderKit;
 }

 @Override
 public Renderer getRenderer(String family, String rendererType) {
  if (family.equals("javax.faces.Input")) {
      Renderer inputRenderer = getWrapped().
               getRenderer(family, rendererType);
      return new RafaRenderer(inputRenderer);
  }
  return getWrapped().getRenderer(family, rendererType);
 }

 @Override
 public RenderKit getWrapped() {
  return renderKit;
 }
}</pre></div><p>So, when JSF needs to render a UI component that belongs to <code class="literal">javax.faces.Input</code> family, we take the original renderer used for this task and wrap it into a custom renderer named <code class="literal">RafaRenderer</code>. This<a id="id678" class="indexterm"/> custom renderer will extend the JSF 2.2 <code class="literal">RendererWrapper</code> (a simple implementation of <code class="literal">Renderer</code>) and will override the <code class="literal">encodeBegin</code> method, as follows:</p><div class="informalexample"><pre class="programlisting">@ResourceDependencies({
@ResourceDependency(name = "css/rafastyles.css", 
                    library = "default", target = "head")
})
@FacesRenderer(componentFamily = "javax.faces.Rafa", 
               rendererType = RafaRenderer.RENDERER_TYPE)
public class RafaRenderer extends RendererWrapper {

 private Renderer renderer;
 public static final String RENDERER_TYPE = 
               "book.beans.RafaRenderer";

 public RafaRenderer() {}

 public RafaRenderer(Renderer renderer) {
  this.renderer = renderer;
 }

 @Override
 public void encodeBegin(FacesContext context, 
             UIComponent uicomponent) throws IOException {
  ResponseWriter responseWriter = context.getResponseWriter();
  responseWriter.writeAttribute("class", "rafastyle", "class");
  getWrapped().encodeBegin(context, uicomponent);
 }

 @Override
 public Renderer getWrapped() {
  return renderer;
 }
}</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note104"/>Note</h3><p>It is good to know that we can specify external resources (such as CSS and JS) for a JSF renderer using the <code class="literal">@ResourceDependency</code> and <code class="literal">@ResourceDependecies</code> annotations.</p></div></div><p>Finally, you need to configure the custom <code class="literal">RenderKit</code> in <code class="literal">faces-config.xml</code>, as follows:</p><div class="informalexample"><pre class="programlisting">&lt;render-kit&gt;
 &lt;render-kit-class&gt;
   book.beans.CustomRenderKit
 &lt;/render-kit-class&gt;
&lt;/render-kit&gt;</pre></div><p>The complete<a id="id679" class="indexterm"/> application is named <code class="literal">ch5_15</code>.</p></div>
<div class="section" title="Working with client behavior functionality"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec47"/>Working with client behavior functionality</h1></div></div></div><p>JSF 2 comes with the ability <a id="id680" class="indexterm"/>to define specific client-side behavior to a component in a reusable approach. The client-side behavior is actually a piece of JavaScript code that can be executed in a browser.</p><p>For example, when the user has access to buttons that perform irreversible changes; for example, deletion, copy, and move is a good practice to inform the user about consequences and ask for a confirmation before the action is performed.</p><p>For implementing a client behavior functionality, we perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Extend the <code class="literal">ClientBehaviorBase</code> class.</li><li class="listitem">Override the <code class="literal">getScript</code> method.</li><li class="listitem">Annotate the created class with the <code class="literal">@FacesBehavior (value="</code><span class="emphasis"><em>developer_id</em></span><code class="literal">")</code> annotation where <span class="emphasis"><em>developer_id</em></span> is used to refer to our custom client behavior. This is needed when we define a tag for the behavior.</li><li class="listitem">Define a custom tag for the behavior—a tag is needed for specifying in the JSF pages, which components receive our client behavior (the JS code).</li><li class="listitem">Register the custom tag in the descriptor of the <code class="literal">web.xml</code> file.</li></ol></div><p>The following code shows you how to write a client behavior for displaying a JavaScript confirmation dialog when the user clicks on a button that emulates a deletion action, which covers the first three steps mentioned earlier:</p><div class="informalexample"><pre class="programlisting">@FacesBehavior(value = "confirm")
public class ConfirmDeleteBehavior extends ClientBehaviorBase {

@Override
 public String getScript(ClientBehaviorContext behaviorContext) {
  return "return confirm('Are you sure ?');";
 }
}</pre></div><p>The fourth step consists of writing a custom tag for the behavior. Create a file named <code class="literal">delete.taglib.xml</code> under the <code class="literal">WEB-INF</code> folder as follows:</p><div class="informalexample"><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;facelet-taglib version="2.2"
  
  
  xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee 
   http://xmlns.jcp.org/xml/ns/javaee/web-
                             facelettaglibrary_2_2.xsd"&gt;
 &lt;namespace&gt;http://www.custom.tags/jsf/delete&lt;/namespace&gt;
 &lt;tag&gt;
  &lt;tag-name&gt;confirmDelete&lt;/tag-name&gt;
  &lt;behavior&gt;
   &lt;behavior-id&gt;confirm&lt;/behavior-id&gt;
  &lt;/behavior&gt;
 &lt;/tag&gt;
&lt;/facelet-taglib&gt;</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note105"/>Note</h3><p>The <code class="literal">&lt;behavior-id&gt;</code> tag value must match the <code class="literal">value</code> member of the <code class="literal">FacesBehavior</code> annotation (<span class="emphasis"><em>developer_id</em></span>). The tag name can be freely chosen.</p></div></div><p>The final step <a id="id681" class="indexterm"/>consists of registering the tag in <code class="literal">web.xml</code>:</p><div class="informalexample"><pre class="programlisting">&lt;context-param&gt;
 &lt;param-name&gt; javax.faces.FACELETS_LIBRARIES&lt;/param-name&gt;
 &lt;param-value&gt;/WEB-INF/delete.taglib.xml&lt;/param-value&gt;
&lt;/context-param&gt;</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note106"/>Note</h3><p>We can attach a client behavior to every component that implements the <code class="literal">ClientBehaviourHolder</code> interface. Fortunately, almost all components implement this interface, such as buttons, links, input fields, and so on.</p></div></div><p>Done! Now, we can pick up the fruits in a JSF page as follows:</p><div class="informalexample"><pre class="programlisting">&lt;?xml version='1.0' encoding='UTF-8' ?&gt;
&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;
&lt;html 
      
      &gt;
 &lt;h:head&gt;
  &lt;title&gt;&lt;/title&gt;
 &lt;/h:head&gt;
 &lt;h:body&gt;
  &lt;h:form&gt;
   &lt;h:commandButton value="Delete" action="done"&gt;
    &lt;b:confirmDelete/&gt;
   &lt;/h:commandButton&gt;
  &lt;/h:form&gt;
 &lt;/h:body&gt;
&lt;/html&gt;</pre></div><p>If the user doesn't confirm deletion, the action is aborted.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note107"/>Note</h3><p>Starting with JSF 2.2, we can use dependency injection with client behavior (<code class="literal">@Inject</code> and <code class="literal">@EJB</code>). For example, instead of hardcoding the confirmation question, "Are you sure?", we can pass it through injection of a CDI bean or an EJB session bean. A complete example can be found in the code bundle of this chapter. It is named <code class="literal">ch5_5_1</code>.</p></div></div><p>Notice that <a id="id682" class="indexterm"/>the example works fine even if we do not specify any event that starts the client behavior JS code. This is happening because the JS code is attached to the <code class="literal">onclick</code> event of the button, which is the default event for <code class="literal">&lt;h:commandButton&gt;</code>. Now, we will write another example that will attach the client behavior to two other events simultaneously.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note108"/>Note</h3><p>We can attach the client behavior code to some other event by specifying the event name with the <code class="literal">event</code> attribute of the tag.</p></div></div><p>In the next example, we assume the following scenario: an input field that is colored in green when it gains focus (<code class="literal">onfocus</code> JS event) and turns back to blank when it loses focus (<code class="literal">onblur</code> JS event). Now, we have to subscribe to two events.</p><p>In the previous example, we explicitly link the client behavior functionality to the <code class="literal">&lt;confirmDelete&gt;</code> tag. Even if this is still possible for this scenario, we choose to come with another approach. Instead of a direct link, we will use a tag handler (<code class="literal">TagHandler</code>).</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note109"/>Note</h3><p>A custom tag handler allows us to manipulate the created DOM tree (add/remove nodes from the tree).</p></div></div><p>When we write a custom tag handler, we need to focus on the apply method, especially on the second argument of this method that is named parent and represents the parent of the tag, which in our case will be <code class="literal">&lt;h:inputText&gt;</code>. We can add both the events to <code class="literal">&lt;h:inputText&gt;</code>, as follows:</p><div class="informalexample"><pre class="programlisting">public class FocusBlurHandler extends TagHandler {

 private FocusBlurBehavior onfocus = new FocusBlurBehavior();
 private FocusBlurBehavior onblur = new FocusBlurBehavior();

 public FocusBlurHandler(TagConfig tagConfig) {
  super(tagConfig);
 }

 @Override
 public void apply(FaceletContext ctx, UIComponent parent)
        throws IOException {

  if (parent instanceof ClientBehaviorHolder) {
      ClientBehaviorHolder clientBehaviorHolder =
                  (ClientBehaviorHolder) parent;

      clientBehaviorHolder.addClientBehavior("focus", onfocus);
      clientBehaviorHolder.addClientBehavior("blur", onblur);
  }
 }
}</pre></div><p>Remember that<a id="id683" class="indexterm"/> in the preceding section, we saw how to override a few JSF renderers. Well, here is one more! Instead of overriding the <code class="literal">getScript</code> method of the <code class="literal">ClientBehaviorBase</code>, as in the previous example, we will write a custom renderer, which is easy to achieve because JSF provides a dedicated renderer for client behavior, named <code class="literal">ClientBehaviorRenderer</code>. This renderer contains its own <code class="literal">getScript</code> method as shown in the following code:</p><div class="informalexample"><pre class="programlisting">@FacesBehaviorRenderer(rendererType = "focusblurrenderer")
@ResourceDependency(name="player.css", target="head")
public class FocusBlurRenderer extends ClientBehaviorRenderer {

 private static final String FOCUS_EVENT = "focus";
 private static final String BLUR_EVENT = "blur";
    
 @Override
 public String getScript(ClientBehaviorContext behaviorContext,
        ClientBehavior behavior) {

  if (FOCUS_EVENT.equals(behaviorContext.getEventName())) {
      return "this.setAttribute('class','focus-css');";
  }

  if (BLUR_EVENT.equals(behaviorContext.getEventName())) {
      return "this.setAttribute('class','blur-css');";
  }

 return null;
 }
}</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note110"/>Note</h3><p>The <code class="literal">@ResourceDependency</code> annotation can be<a id="id684" class="indexterm"/> used for loading resources such as CSS and JS in custom <code class="literal">UIComponent</code> and <code class="literal">Renderer</code> components. In several versions of JSF, <code class="literal">@ResourceDependency</code> is not working as expected for <code class="literal">Renderer</code>s (seems to be a bug). In case you have such issues, you have to hardcode the CSS for testing.</p></div></div><p>Finally, the <a id="id685" class="indexterm"/>client behavior will point out the above renderer as follows:</p><div class="informalexample"><pre class="programlisting">@FacesBehavior(value = "focusblur")
public class FocusBlurBehavior extends ClientBehaviorBase {

 @Override
 public String getRendererType() {           
  return "focusblurrenderer";
 }
}</pre></div><p>The complete example containing the CSS source, the tag definition, and specific configurations is available in the code bundle and is named <code class="literal">ch5_5_2</code>.</p></div>
<div class="section" title="JSF factories"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec48"/>JSF factories</h1></div></div></div><p>The following <a id="id686" class="indexterm"/>note is a good point to start for the last part of this chapter, which is dedicated to JSF factories. In JSF, the factories are initialized by <code class="literal">FactoryFinder</code>, which recognizes if a custom factory has a delegating constructor—a one argument constructor for the type of the factory.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note111"/>Note</h3><p>This is useful when we want to wrap standard factory from JSF, because <code class="literal">FactoryFinder</code> will pass in the previously known factory, usually the built-in one. Factory instances are obtained as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="emphasis"><em>XXXFactory</em></span> factory = (<span class="emphasis"><em>XXXFactory</em></span>)    FactoryFinder.getFactory(FactoryFinder.<span class="emphasis"><em>XXX_FACTORY</em></span>);</pre></div><p>For example, <code class="literal">RenderKitFactory</code> can be found using the following code:</p><div class="informalexample"><pre class="programlisting">RenderKitFactory factory = (RenderKitFactory)FactoryFinder.getFactory(FactoryFinder.RENDER_KIT_FACTORY);</pre></div><p>Next to <code class="literal">FaceletFactory</code>, another new factory obtainable via <code class="literal">FactoryFinder</code> in JSF 2.2 is the new <code class="literal">FlashFactory</code>. We will discuss about <code class="literal">FaceletFactory</code> in the last chapter of this book, <a class="link" href="ch12.html" title="Chapter 12. Facelets Templating">Chapter 12</a>, <span class="emphasis"><em>Facelets Templating</em></span>.</p></div></div><div class="section" title="Configuring the global exception handler"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec60"/>Configuring the global exception handler</h2></div></div></div><p>During the JSF lifecycle, we <a id="id687" class="indexterm"/>need to treat different kinds of exceptions <a id="id688" class="indexterm"/>in different points of the application. Starting with JSF 2, we have a generic API that allows us to write a global exception handler. This can be very handy, especially when we need to avoid "silent" exceptions that are not caught by the application.</p><p>In order to write a global exception handler, we need to do the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Extend <code class="literal">ExceptionHandlerFactory</code>, which is a factory object that is capable of creating and returning a new <code class="literal">ExceptionHandler</code> instance—the central point for handling unexpected <code class="literal">Exception</code>s that are thrown during the JSF lifecycle.</li><li class="listitem" style="list-style-type: disc">Extend <code class="literal">ExceptionHandlerWrapper</code>, which is a simple implementation of <code class="literal">ExceptionHandler</code>.</li><li class="listitem" style="list-style-type: disc">Configure the custom exception handler in <code class="literal">faces-config.xml</code>.</li></ul></div><p>Therefore, we can write a custom exception handler factory as follows:</p><div class="informalexample"><pre class="programlisting">public class CustomExceptionHandlerFactory
                   extends ExceptionHandlerFactory {

 private ExceptionHandlerFactory exceptionHandlerFactory;

 public CustomExceptionHandlerFactory(){}
 
 public CustomExceptionHandlerFactory(ExceptionHandlerFactory
                                         exceptionHandlerFactory) {
  this.exceptionHandlerFactory = exceptionHandlerFactory;
 }

 @Override
 public ExceptionHandler getExceptionHandler() {
  ExceptionHandler handler = new CustomExceptionHandler
               (exceptionHandlerFactory.getExceptionHandler());

  return handler;
 }
}</pre></div><p>Our<a id="id689" class="indexterm"/> implementation for dealing with the exception is to send each<a id="id690" class="indexterm"/> error to a log and navigate to an error page, as shown in the following code (notice that <code class="literal">ViewExpiredException</code> can be caught here as well):</p><div class="informalexample"><pre class="programlisting">public class CustomExceptionHandler extends ExceptionHandlerWrapper {

 private static final Logger logger =
         Logger.getLogger(CustomExceptionHandler.class.getName());
 private ExceptionHandler exceptionHandler;

 CustomExceptionHandler(ExceptionHandler exceptionHandler) {
  this.exceptionHandler = exceptionHandler;
 }

 @Override
 public ExceptionHandler getWrapped() {
  return exceptionHandler;
 }

 @Override
 public void handle() throws FacesException {

  final Iterator&lt;ExceptionQueuedEvent&gt; queue =
        getUnhandledExceptionQueuedEvents().iterator();

  while (queue.hasNext()) {

   //take exceptions one by one
   ExceptionQueuedEvent item = queue.next();
   ExceptionQueuedEventContext exceptionQueuedEventContext =
                  (ExceptionQueuedEventContext) item.getSource();

   try {
       //log error
       Throwable throwable = exceptionQueuedEventContext.getException();
       logger.log(Level.SEVERE, "EXCEPTION: ", throwable.getMessage());

       //redirect error page
       FacesContext facesContext = FacesContext.getCurrentInstance();
       Map&lt;String, Object&gt; requestMap =
                   facesContext.getExternalContext().getRequestMap();
       NavigationHandler nav =
                   facesContext.getApplication().getNavigationHandler();

       requestMap.put("errmsg", throwable.getMessage());
       nav.handleNavigation(facesContext, null, "/error");
       facesContext.renderResponse();
       } finally {
         //remove it from queue
         queue.remove();
         }
  }

  getWrapped().handle();
 }
}</pre></div><p>Finally, we need to <a id="id691" class="indexterm"/>configure the<a id="id692" class="indexterm"/> exception handler in <code class="literal">faces-config.xml</code> as follows:</p><div class="informalexample"><pre class="programlisting">&lt;factory&gt;
 &lt;exception-handler-factory&gt;
  book.beans.CustomExceptionHandlerFactory
 &lt;/exception-handler-factory&gt;
&lt;/factory&gt;</pre></div><p>The complete example is named <code class="literal">ch5_3</code>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note114"/>Note</h3><p>Starting with JSF 2.2, we can use dependency injection with exception handler (<code class="literal">@Inject</code> and <code class="literal">@EJB</code>).</p></div></div><p>Notice that a special case exists in treating AJAX exceptions. By default, most of them are invisible to the client. AJAX errors are returned to the client, but unfortunately JSF AJAX clients aren't prepared to deal with arbitrary error messages, so they simply ignore them. But a custom exception handler is specially created for this task by OmniFaces (it works for AJAX and non-AJAX exceptions). The handler is named <code class="literal">FullAjaxExceptionHandler</code>, and the factory is named <code class="literal">FullAjaxExceptionHandlerFactory</code>.</p><p>Once you install OmniFaces, you can exploit the AJAX exception handler with a simple configuration in <code class="literal">faces-config.xml</code>:</p><div class="informalexample"><pre class="programlisting">&lt;factory&gt;
 &lt;exception-handler-factory&gt;
  org.omnifaces.exceptionhandler.FullAjaxExceptionHandlerFactory
 &lt;/exception-handler-factory&gt;
&lt;/factory&gt;</pre></div><p>The <a id="id693" class="indexterm"/>behavior of the <a id="id694" class="indexterm"/>OmniFaces exception handler is configured in <code class="literal">web.xml</code>:</p><div class="informalexample"><pre class="programlisting">&lt;error-page&gt;
  &lt;exception-type&gt;
    java.lang.NullPointerException
  &lt;/exception-type&gt;
  &lt;location&gt;/null.jsf&lt;/location&gt;
&lt;/error-page&gt;
&lt;error-page&gt;
  &lt;exception-type&gt;
    java.lang.Throwable
  &lt;/exception-type&gt;
  &lt;location&gt;/ throwable.jsf&lt;/location&gt;
&lt;/error-page&gt;</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note115"/>Note</h3><p>Error pages for OmniFaces exception handler should be JSF 2.0 (or more) pages. A comprehensive demo can be found in OmniFaces showcase<a id="id695" class="indexterm"/> at <a class="ulink" href="http://showcase.omnifaces.org/exceptionhandlers/FullAjaxExceptionHandler">http://showcase.omnifaces.org/exceptionhandlers/FullAjaxExceptionHandler</a>.</p></div></div></div><div class="section" title="Configuring RenderKit factory"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec61"/>Configuring RenderKit factory</h2></div></div></div><p>Earlier in this chapter, we have<a id="id696" class="indexterm"/> written a custom <code class="literal">RenderKit</code>, which<a id="id697" class="indexterm"/> was loaded by JSF because we have configured it<a id="id698" class="indexterm"/> in <code class="literal">faces-config.xml</code> using the <code class="literal">&lt;render-kit&gt;</code> tag. But, behind the scene, JSF uses <code class="literal">RenderKitFactory</code>, which is capable of registering and returning <code class="literal">RenderKit</code> instances. Therefore, we can write custom <code class="literal">RenderKitFactory</code> for returning our custom <code class="literal">RenderKit</code>. For writing such a factory, you need to do the following:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Extend the <code class="literal">RenderKitFactory</code> class that is responsible for registering and returning <code class="literal">RenderKit</code> instances.</li><li class="listitem">Override the <code class="literal">addRenderKit </code>method that registers the specified <code class="literal">RenderKit</code> instance using the specified ID.</li><li class="listitem">Override the <code class="literal">getRenderKit</code> method that returns <code class="literal">RenderKit</code> with the specified ID.</li><li class="listitem">Override the <code class="literal">getRenderKitIds</code> method and return an <code class="literal">Iterator</code> over the set of render kit identifiers registered with this factory.</li></ol></div><p>Based on these steps, we can register our custom <code class="literal">RenderKit</code> as follows:</p><div class="informalexample"><pre class="programlisting">public class CustomRenderKitFactory extends RenderKitFactory {

 private RenderKitFactory renderKitFactory;

 public CustomRenderKitFactory() {}
     
 public CustomRenderKitFactory(RenderKitFactory renderKitFactory){
  this.renderKitFactory = renderKitFactory;                
 }

 @Override
 public void addRenderKit(String renderKitId, 
                                 RenderKit renderKit){
  renderKitFactory.addRenderKit(renderKitId, renderKit);
 }

 @Override
 public RenderKit getRenderKit(FacesContext context, 
                                 String renderKitId) {
  RenderKit renderKit = renderKitFactory.
            getRenderKit(context, renderKitId);
  return (HTML_BASIC_RENDER_KIT.equals(renderKitId)) ? 
            new CustomRenderKit(renderKit) : renderKit;
 }

 @Override
 public Iterator&lt;String&gt; getRenderKitIds() {
  return renderKitFactory.getRenderKitIds();
 }
}</pre></div><p>Now, instead <a id="id699" class="indexterm"/>of configuring the custom <code class="literal">RenderKit</code> using<a id="id700" class="indexterm"/> the <code class="literal">&lt;render-kit&gt;</code> tag, we can configure the <a id="id701" class="indexterm"/>custom <code class="literal">RenderKitFactory</code>, as follows:</p><div class="informalexample"><pre class="programlisting">&lt;factory&gt;
 &lt;render-kit-factory&gt;
  book.beans.CustomRenderKitFactory
 &lt;/render-kit-factory&gt;
&lt;/factory&gt;</pre></div><p>The complete application is named <code class="literal">ch5_16</code>.</p></div><div class="section" title="Configuring PartialViewContext"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec62"/>Configuring PartialViewContext</h2></div></div></div><p>The <code class="literal">PartialViewContext</code> class<a id="id702" class="indexterm"/> is <a id="id703" class="indexterm"/>responsible for processing <a id="id704" class="indexterm"/>partial requests <a id="id705" class="indexterm"/>and rendering partial responses on a view. In other words, JSF processes execution, rendering, and so on, of AJAX requests and responses using <code class="literal">PartialViewContext</code>. We refer to it as follows:</p><div class="informalexample"><pre class="programlisting">FacesContext.getCurrentInstance().getPartialViewContext();</pre></div><p>Writing a custom <code class="literal">PartialViewContext</code> implementation implies the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Extending <code class="literal">PartialViewContextFactory</code>, will result in a factory object capable of creating and returning a new <code class="literal">PartialViewContext</code> instance, the central point for handling partial request-responses.</li><li class="listitem">Extending <code class="literal">PartialViewContextWrapper</code>, which is a simple implementation of <code class="literal">PartialViewContext</code>.</li><li class="listitem">Configuring the custom <code class="literal">PartialViewContext</code> implementation in <code class="literal">faces-config.xml</code>.</li></ol></div><p>Now, let's suppose that we have multiple forms that are submitted through AJAX. Each <code class="literal">&lt;f:ajax&gt;</code> tag will contain the <code class="literal">execute</code> attribute and the one that we are especially interested in, the <code class="literal">render</code> attribute. This attribute should contain client IDs for the components to re-render. When multiple partial requests re-render the same component, the ID of that component is present in each partial request (in each <code class="literal">render</code> attribute).</p><p>A common case is<a id="id706" class="indexterm"/> the global <code class="literal">&lt;h:messages&gt;</code> tag. The ID of this tag should be added to each <a id="id707" class="indexterm"/>partial request that needs to re-render it. Instead of re-typing the client IDs in the <code class="literal">render</code> attribute, we can write a custom <code class="literal">PartialViewContext</code> implementation to do that. First, we create the <a id="id708" class="indexterm"/>factory instance as follows:</p><div class="informalexample"><pre class="programlisting">public class CustomPartialViewContextFactory
             extends PartialViewContextFactory {

 private PartialViewContextFactory partialViewContextFactory;

 public CustomPartialViewContextFactory(){}
 
 public CustomPartialViewContextFactory
        (PartialViewContextFactory partialViewContextFactory) {
  this.partialViewContextFactory = partialViewContextFactory;
 }

 @Override
 public PartialViewContext getPartialViewContext(FacesContext context) {
        
 PartialViewContext handler = new CustomPartialViewContext
    (partialViewContextFactory.getPartialViewContext(context));

 return handler;
 }
}</pre></div><p>Next, we write our custom <code class="literal">PartialViewContext</code> and override the <code class="literal">getRenderIds</code> method. Basically, we locate the ID of the <code class="literal">&lt;h:messages&gt;</code> tag, check if this ID is already in the render IDs list, and <a id="id709" class="indexterm"/>add it to the list if it <a id="id710" class="indexterm"/>has not yet <a id="id711" class="indexterm"/>been added, as follows:</p><div class="informalexample"><pre class="programlisting">public class CustomPartialViewContext extends PartialViewContextWrapper {

 private PartialViewContext partialViewContext;

 public CustomPartialViewContext(PartialViewContext partialViewContext) {
  this.partialViewContext = partialViewContext;
 }

 @Override
 public PartialViewContext getWrapped() {
  return partialViewContext;
 }

 @Override
 public Collection&lt;String&gt; getRenderIds() {

  FacesContext facesContext = FacesContext.getCurrentInstance();
  if (PhaseId.RENDER_RESPONSE == facesContext.getCurrentPhaseId()) {
      UIComponent component = findComponent("msgsId",
                              facesContext.getViewRoot());
      if (component != null &amp;&amp; component.isRendered()) {
          String componentClientId = component.getClientId(facesContext);
          Collection&lt;String&gt; renderIds = getWrapped().getRenderIds();
          if (!renderIds.contains(componentClientId)) {
              renderIds.add(componentClientId);
          }
      }
  }
  return getWrapped().getRenderIds();
 }

 private UIComponent findComponent(String id, UIComponent root) {
  if (root == null) {
      return null;
  } else if (root.getId().equals(id)) {
             return root;
  } else {
    List&lt;UIComponent&gt; childrenList = root.getChildren();
    if (childrenList == null || childrenList.isEmpty()) {
        return null;
    }
    for (UIComponent child : childrenList) {
         UIComponent result = findComponent(id, child);
         if (result != null) {
             return result;
         }
    }
  }
  return null;
 }
}</pre></div><p>Finally, we<a id="id712" class="indexterm"/> need to configure <code class="literal">PartialViewContext</code> in <code class="literal">faces-config.xml</code> as follows:</p><div class="informalexample"><pre class="programlisting">&lt;factory&gt;
 &lt;partial-view-context-factory&gt;
   book.beans.CustomPartialViewContextFactory
 &lt;/partial-view-context-factory&gt;
&lt;/factory&gt;</pre></div><p>The complete <a id="id713" class="indexterm"/>example <a id="id714" class="indexterm"/>is named <code class="literal">ch5_6_1</code>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note116"/>Note</h3><p>Starting with JSF 2.2, we can use dependency injection with partial view context (<code class="literal">@Inject</code> and <code class="literal">@EJB</code>). A complete example can be found in the code bundle of this chapter, under the name <code class="literal">ch5_6_2</code>.</p></div></div></div><div class="section" title="Configuring visitContext"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec63"/>Configuring visitContext</h2></div></div></div><p>According to the<a id="id715" class="indexterm"/> documentation, <code class="literal">VisitContext</code> is an object used<a id="id716" class="indexterm"/> to hold the state relating to performing a <a id="id717" class="indexterm"/>component tree visit.</p><p>Why do we need such an object? Well, imagine that you want to programmatically find a certain component. You will probably think of <code class="literal">findComponent</code> or <code class="literal">invokeOnComponent</code> built-in methods. When you need to find several components, you can apply the process recursively (as you saw in a few examples earlier). The recursive process performs a clean traversal of the component's tree (or subtree) by visiting each node in a hierarchical approach.</p><p>However, JSF 2 also provides an out-of-the-box method to accomplish a component's tree traversal named <code class="literal">UIComponent.visitTree</code>, declared as follows:</p><div class="informalexample"><pre class="programlisting">public boolean visitTree(VisitContext context,
               VisitCallback callback)</pre></div><p>The first argument is an instance of <code class="literal">VisitContext</code>, and the second one is an instance of the <code class="literal">VisitCallback</code> interface that provides a method, named <code class="literal">visit</code>, which is called for each node that is visited. If the tree was successfully traversed, then <code class="literal">visitTree</code> returns <code class="literal">true</code>.</p><p>Based on this knowledge, we <a id="id718" class="indexterm"/>can write a custom <code class="literal">VisitContext</code> implementation for <a id="id719" class="indexterm"/>resetting the editable components of a form. Such a component implements the <code class="literal">EditableValueHolder</code> interface and provides a method <code class="literal">resetValue</code>.</p><p>The steps for writing a custom <code class="literal">VisitContext</code> implementation are as follows:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Extending <code class="literal">VisitContextFactory</code>, which is a factory object capable of creating and returning a new <code class="literal">VisitContext</code> instance.</li><li class="listitem">Extending <code class="literal">VisitContextWrapper</code>, which is a simple implementation of <code class="literal">VisitContext</code>.</li><li class="listitem">Configuring the custom <code class="literal">VisitContext</code> implementation in <code class="literal">faces-config.xml</code>.</li></ol></div><p>So, first we need to <a id="id720" class="indexterm"/>extend the built-in factory as follows:</p><div class="informalexample"><pre class="programlisting">public class CustomVisitContextFactory extends VisitContextFactory {
    
 private VisitContextFactory visitContextFactory;
    
 public CustomVisitContextFactory() {}

 public CustomVisitContextFactory(VisitContextFactory
                                               visitContextFactory){        
  this.visitContextFactory = visitContextFactory;
 }

 @Override
 public VisitContext getVisitContext(FacesContext context,
                        Collection&lt;String&gt; ids, Set&lt;VisitHint&gt; hints) {
  VisitContext handler = new CustomVisitContext(visitContextFactory.
                                getVisitContext(context, ids, hints));

  return handler;        
 }   
}</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note117"/>Note</h3><p>Note that we can also specify a collection of client IDs to be visited. We can also specify some visit hints. When all components should be visited with the default visit hints, these arguments can be <code class="literal">null</code>.</p></div></div><p>The custom visit <a id="id721" class="indexterm"/>context is represented programmatically as follows—the <a id="id722" class="indexterm"/>method <code class="literal">invokeVisitCallback</code> is <a id="id723" class="indexterm"/>called by <code class="literal">visitTree</code> to visit a single component:</p><div class="informalexample"><pre class="programlisting">public class CustomVisitContext extends VisitContextWrapper {

 private static final Logger logger =
         Logger.getLogger(CustomVisitContext.class.getName());
 private VisitContext visitContext;

 public CustomVisitContext(VisitContext visitContext) {
  this.visitContext = visitContext;
 }
 
 @Override
 public VisitContext getWrapped() {
  return visitContext;
 }

 @Override
 public VisitResult invokeVisitCallback(UIComponent component,
                                         VisitCallback callback) {
  logger.info("Custom visit context is used!");
  return getWrapped().invokeVisitCallback(component, callback);
 }
}</pre></div><p>So, our custom <code class="literal">VisitContext</code> implementation doesn't do much; it just fires some log messages and delegates the control to the original <code class="literal">VisitContext</code> class. Our aim is to write a custom <code class="literal">VisitCallback</code> implementation for resetting editable values of a form using the following code:</p><div class="informalexample"><pre class="programlisting">public class CustomVisitCallback implements VisitCallback{

 @Override
 public VisitResult visit(VisitContext context, UIComponent target) {

  if (!target.isRendered()) {
      return VisitResult.REJECT;
  }
 
  if (target instanceof EditableValueHolder) {
     ((EditableValueHolder)target).resetValue();
  }
       
  return VisitResult.ACCEPT;
 }   
}</pre></div><p>Well, we are almost done! Just configure the custom <code class="literal">VisitContext</code> implementation in <code class="literal">faces-config.xml</code> form using the following code:</p><div class="informalexample"><pre class="programlisting">&lt;factory&gt;
 &lt;visit-context-factory&gt;
  book.beans.CustomVisitContextFactory
 &lt;/visit-context-factory&gt;
&lt;/factory&gt;</pre></div><p>Let's start the <a id="id724" class="indexterm"/>process of <a id="id725" class="indexterm"/>visiting nodes using the <a id="id726" class="indexterm"/>following code:</p><div class="informalexample"><pre class="programlisting">FacesContext context = FacesContext.getCurrentInstance();
UIComponent component = context.getViewRoot();
CustomVisitCallback customVisitCallback = new CustomVisitCallback();
component.visitTree(VisitContext.createVisitContext
            (FacesContext.getCurrentInstance()), customVisitCallback);</pre></div><p>Note that the starting point in the traversal process is the view root. This is not mandatory; you can pass any other subtree.</p><p>An obvious question arises here! Since this custom <code class="literal">VisitContext</code> doesn't do something important (only fires some log messages), why don't we skip it?</p><p>Yes, it is true that we can skip this custom <code class="literal">VisitContext</code>, since all we need is the custom <code class="literal">VisitCallback</code> implementation, but it was a good opportunity to see how it can be done. Maybe you can modify <code class="literal">invokeVisitCallback</code> to implement some kind of client ID filtration before getting the action into the <code class="literal">VisitCallback.visit</code> method.</p><p>A complete example can be found in the code bundle of this chapter, which is named <code class="literal">ch5_7</code>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note118"/>Note</h3><p>Starting with JSF 2.2, we can use dependency injection with visit context (<code class="literal">@Inject</code> and <code class="literal">@EJB</code>).</p></div></div></div><div class="section" title="Configuring ExternalContext"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec64"/>Configuring ExternalContext</h2></div></div></div><p>The <code class="literal">FacesContext</code> and <code class="literal">ExternalContext</code> objects are two of the most important objects in JSF. Each of<a id="id727" class="indexterm"/> them provides powerful capabilities and each of them covers an important area of artifacts provided by JSF (in case of <code class="literal">FacesContext</code>) and Servlet/Portlet (in case of <code class="literal">ExternalContext</code>).</p><p>Furthermore, both of them<a id="id728" class="indexterm"/> can be extended or modified by the developers. For <a id="id729" class="indexterm"/>example, in this section we will write a custom <code class="literal">ExternalContext</code> implementation for downloading a file. Sometimes, you may need to download a file by programmatically sending its content to the user. The default <code class="literal">ExternalContext</code> can do that, as shown in the following code—of course, you can easily adapt this code for other files:</p><div class="informalexample"><pre class="programlisting">public void readFileAction() throws IOException, URISyntaxException {

 FacesContext facesContext = FacesContext.getCurrentInstance();
 ExternalContext externalContext = facesContext.getExternalContext();
 Path path = Paths.get(((ServletContext)externalContext.getContext())
            .getRealPath("/resources/rafa.txt"));

 BasicFileAttributes attrs = Files.readAttributes(path,
                             BasicFileAttributes.class);
        
 externalContext.responseReset();
 externalContext.setResponseContentType("text/plain");
 externalContext.setResponseContentLength((int) attrs.size());
 externalContext.setResponseHeader("Content-Disposition",
                 "attachment; filename=\"" + "rafa.txt" + "\"");

 int nRead;
 byte[] data = new byte[128];
 InputStream inStream = externalContext.
     getResourceAsStream("/resources/rafa.txt");

 try (OutputStream output = externalContext.getResponseOutputStream()) {
      while ((nRead = inStream.read(data, 0, data.length)) != -1) {
              output.write(data, 0, nRead);
      }
      output.flush();
 }

 facesContext.responseComplete();
}</pre></div><p>Normally, this approach<a id="id730" class="indexterm"/> uses the default response output stream. But let's suppose that we have written our "dummy" response output stream<a id="id731" class="indexterm"/> which, obviously, does a<a id="id732" class="indexterm"/> dummy action: for each chunk of bytes, replace the '<code class="literal">a</code>' character with the '<code class="literal">A</code>' character as shown in the following code:</p><div class="informalexample"><pre class="programlisting">public class CustomResponseStream extends OutputStream {

 private OutputStream responseStream;

 public CustomResponseStream(OutputStream responseStream) {        
  this.responseStream = responseStream;
 }

 @Override
 public void write(byte[] b, int off, int len) throws IOException {
  String s = new String(b, off, len);
  s = s.replace('a', 'A');
  
  byte[] bb = s.getBytes();
  responseStream.write(bb, off, len);
 }

 @Override
 public void write(int b) throws IOException {
 }
}</pre></div><p>Now, we want to use this response output stream instead of the default one, but there is no <code class="literal">externalContext.setResponseOutputStream(OutputStream os)</code> method. Instead, we can write a custom <code class="literal">ExternalContext</code>, by performing the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Extending <code class="literal">ExternalContextFactory</code>, which is a factory object capable of creating and returning a new <code class="literal">ExternalContext</code>.</li><li class="listitem">Extending <code class="literal">ExternalContextWrapper</code>, which is a simple implementation of <code class="literal">ExternalContext</code>.</li><li class="listitem">Configuring the custom <code class="literal">ExternalContext</code> implementation in <code class="literal">faces-config.xml</code>.</li></ol></div><p>The custom external context factory code is as follows:</p><div class="informalexample"><pre class="programlisting">public class CustomExternalContextFactory extends ExternalContextFactory{
    
 private ExternalContextFactory externalContextFactory;
    
 public CustomExternalContextFactory(){}
    
 public CustomExternalContextFactory(ExternalContextFactory
        externalContextFactory){
  this.externalContextFactory = externalContextFactory;
 }

 @Override
 public ExternalContext getExternalContext(Object context,
        Object request, Object response) throws FacesException {
        
  ExternalContext handler = new  
        CustomExternalContext(externalContextFactory
            .getExternalContext(context, request, response));

   return handler;
  }    
}</pre></div><p>The custom <a id="id733" class="indexterm"/>external context is given as follows. Here, we override <a id="id734" class="indexterm"/>the <code class="literal">getResponseOutputStream</code> method to <a id="id735" class="indexterm"/>return our custom response output stream.</p><div class="informalexample"><pre class="programlisting">public class CustomExternalContext extends ExternalContextWrapper {

 private ExternalContext externalContext;

 public CustomExternalContext(ExternalContext externalContext) {
  this.externalContext = externalContext;
 }

 @Override
 public ExternalContext getWrapped() {
  return externalContext;
 }

 @Override
 public OutputStream getResponseOutputStream() throws IOException {
  HttpServletResponse response =
              (HttpServletResponse)externalContext.getResponse();  
  OutputStream responseStream = response.getOutputStream();
  return new CustomResponseStream(responseStream);
 }
}</pre></div><p>Finally, do not forget to configure the custom external context in <code class="literal">faces-config.xml</code>:</p><div class="informalexample"><pre class="programlisting">&lt;factory&gt;
 &lt;external-context-factory&gt;
   book.beans.CustomExternalContextFactory
 &lt;/external-context-factory&gt;
&lt;/factory&gt;</pre></div><p>The complete <a id="id736" class="indexterm"/>example can be downloaded from the code <a id="id737" class="indexterm"/>bundle <a id="id738" class="indexterm"/>of this chapter named <code class="literal">ch5_8</code>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note119"/>Note</h3><p>Starting with JSF 2.2, we can use dependency injection with external context and faces context (<code class="literal">@Inject</code> and <code class="literal">@EJB</code>).</p></div></div><p>JSF also provides factory (<code class="literal">FacesContextFactory</code>) and wrapper (<code class="literal">FacesContextWrapper</code>) classes for extending the default <code class="literal">FacesContext</code> class. This can be extended when you need to adapt JSF to Portlet environment, or use JSF to run inside another environment.</p></div><div class="section" title="Configuring Flash"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec65"/>Configuring Flash</h2></div></div></div><p>Starting with JSF 2.2, we <a id="id739" class="indexterm"/>have a hook for overriding and/or wrapping the default<a id="id740" class="indexterm"/> implementation of Flash. Usually, we refer a Flash instance <a id="id741" class="indexterm"/>using the following code:</p><div class="informalexample"><pre class="programlisting">FacesContext.getCurrentInstance().getExternalContext().getFlash();</pre></div><p>When advanced topics require a custom implementation, you can perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Extend <code class="literal">FlashFactory</code>, which is a factory object capable of creating and returning a new <code class="literal">Flash</code> instance.</li><li class="listitem">Extend <code class="literal">FlashWrapper</code>, which is a simple implementation of <code class="literal">Flash</code> that allows us to selectively override methods.</li><li class="listitem">Configure the custom <code class="literal">Flash</code> implementation in <code class="literal">faces-config.xml</code>.</li></ol></div><p>For example, a custom Flash factory can be written using the following code:</p><div class="informalexample"><pre class="programlisting">public class CustomFlashFactory extends FlashFactory {

 private FlashFactory flashFactory;

 public CustomFlashFactory() {}

 public CustomFlashFactory(FlashFactory flashFactory) {
  this.flashFactory = flashFactory;
 }

 @Override
 public Flash getFlash(boolean create) {        
  Flash handler = new CustomFlash(flashFactory.getFlash(create));   
  
  return handler;
 }
}</pre></div><p>The <code class="literal">CustomFlash</code> instance<a id="id742" class="indexterm"/> returned by the <code class="literal">getFlash</code> method is<a id="id743" class="indexterm"/> as<a id="id744" class="indexterm"/> follows:</p><div class="informalexample"><pre class="programlisting">public class CustomFlash extends FlashWrapper {

 private Flash flash;
    
 public CustomFlash(Flash flash){
  this.flash = flash;
 }       
    
//... override here Flash methods
    
 @Override
 public Flash getWrapped() {
  return this.flash;
 }        
}</pre></div><p>In the <code class="literal">CustomFlash</code> class, you can override the methods of <code class="literal">javax.faces.context.Flash</code> that need to have a custom behavior. For example, you can override the <code class="literal">setKeepMessages</code> method to output some logs using the following code:</p><div class="informalexample"><pre class="programlisting">@Override
public  void setKeepMessages(boolean newValue){
 logger.log(Level.INFO, "setKeepMessages()
                         was called with value: {0}", newValue);
 getWrapped().setKeepMessages(newValue);
}</pre></div><p>A custom flash factory is<a id="id745" class="indexterm"/> configured in <code class="literal">faces-config.xml</code> using the following code:</p><div class="informalexample"><pre class="programlisting">&lt;factory&gt;
 &lt;flash-factory&gt;book.beans.CustomFlashFactory&lt;/flash-factory&gt;
&lt;/factory&gt;</pre></div><p>The complete <a id="id746" class="indexterm"/>example is<a id="id747" class="indexterm"/> named <code class="literal">ch5_9</code>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note120"/>Note</h3><p>Starting with JSF 2.2, we can use dependency injection with Flash (<code class="literal">@Inject</code> and <code class="literal">@EJB</code>).</p></div></div></div><div class="section" title="JSF 2.2 Window ID API"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec66"/>JSF 2.2 Window ID API</h2></div></div></div><p>The origin of the Window ID <a id="id748" class="indexterm"/>mechanism relies on an HTML gap—this protocol is stateless, which<a id="id749" class="indexterm"/> means that it doesn't associate clients with requests. JSF solves this issue using a cookie for tracking user sessions, but sometimes this is not enough, and a fine-grained tracking mechanism is needed. For example, if a user opens several tabs/windows, then the same session is used in all of them, meaning that the same cookie is sent to the server and the same login account is used (when login exists). This can be a real issue if the user operates modifications in these tabs/windows.</p><p>In order to provide a workaround for this problem, JSF 2.2 has introduced the Window ID API, which allows developers to identify separate tabs/windows of the same session.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note121"/>Note</h3><p>Under certain circumstances, you can track users' window IDs using view scope and flash scope. But Window ID is easier to use and is dedicated to this purpose.</p></div></div><p>Developers can choose the method used for tracking window IDs by setting the context parameter <code class="literal">javax.faces.CLIENT_WINDOW_MODE</code> in <code class="literal">web.xml</code> as follows—in JSF 2.2, the supported values are <code class="literal">url</code> (tracking activated) and <code class="literal">none</code> (tracking deactivated):</p><div class="informalexample"><pre class="programlisting">&lt;context-param&gt;
 &lt;param-name&gt;javax.faces.CLIENT_WINDOW_MODE&lt;/param-name&gt;
 &lt;param-value&gt;url&lt;/param-value&gt;
&lt;/context-param&gt;</pre></div><p>When <code class="literal">url </code>is specified, the user's window IDs are tracked using a hidden field or a request parameter named <code class="literal">jfwid</code>. In the following screenshot, you can see both of them, the request parameter and hidden field:</p><div class="mediaobject"><img src="graphics/6466EN_05_02.jpg" alt="JSF 2.2 Window ID API"/></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note122"/>Note</h3><p>When the hidden field (available after a postback) and request parameter are available, the hidden field has a bigger precedence.</p></div></div><p>You can easily get the <a id="id750" class="indexterm"/>Window ID <a id="id751" class="indexterm"/>using the following code:</p><div class="informalexample"><pre class="programlisting">public void pullWindowIdAction() {
 FacesContext facesContext = FacesContext.getCurrentInstance();
 ExternalContext externalContext=facesContext.getExternalContext();

 ClientWindow clientWindow = externalContext.getClientWindow();
 if (clientWindow != null) {
     logger.log(Level.INFO, "The current client window id is:{0}", 
      clientWindow.getId());
 } else {
     logger.log(Level.INFO, "Client Window cannot be determined!");
 }
}</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note123"/>Note</h3><p>The <code class="literal">ClientWindow</code> instance can be obtained using <code class="literal">ExternalContext.getClientWindow</code> and can be provided as <code class="literal">ExternalContext.setClientWindow</code>.</p></div></div><p>You can enable/disable user window tracking in at least two ways which are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">In <code class="literal">&lt;h:button&gt;</code> and <code class="literal">&lt;h:link&gt;</code>, you can use the <code class="literal">disableClientWindow</code> attribute whose value can be <code class="literal">true</code> or <code class="literal">false</code>, as shown in the following code:<div class="informalexample"><pre class="programlisting">Enable/Disable client window using h:button:&lt;br/&gt;
&lt;h:button value="Enable Client Window" outcome="index"
                               disableClientWindow="false"/&gt;&lt;br/&gt;
&lt;h:button value="Disable Client Window" outcome="index"
                               disableClientWindow="true"/&gt;&lt;br/&gt;
&lt;hr/&gt;
Enable/Disable client window using h:link:&lt;br/&gt;
&lt;h:link value="Enable Client Window" outcome="index"
                               disableClientWindow="false"/&gt;&lt;br/&gt;
&lt;h:link value="Disable Client Window" outcome="index"
                               disableClientWindow="true"/&gt;</pre></div></li><li class="listitem" style="list-style-type: disc">Alternatively, we can use the <code class="literal">disableClientWindowRenderMode</code> and <code class="literal">enableClientWindowRenderMode</code> methods as shown in the following code:<div class="informalexample"><pre class="programlisting">private FacesContext facesContext;
private ExternalContext externalContext;
...
ClientWindow clientWindow = externalContext.getClientWindow();
//disable
clientWindow.disableClientWindowRenderMode(facesContext);
//enable
clientWindow.enableClientWindowRenderMode(facesContext);</pre></div></li></ul></div><p>A complete <a id="id752" class="indexterm"/>application is <a id="id753" class="indexterm"/>available in the code bundle of this chapter which is named <code class="literal">ch5_10_1</code>.</p><p>Developers can write custom <code class="literal">ClientWindow</code> implementations by extending the <code class="literal">ClientWindowWrapper</code> class, which is a simple and convenient implementation that allows us to override only the necessary methods. One way to tell JSF to use your custom <code class="literal">ClientWindow</code> is based on the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Extend <code class="literal">ClientWindowFactory</code>, which is a factory that is capable of creating <code class="literal">ClientWindow</code> instances based on the incoming request.</li><li class="listitem">Override <code class="literal">ClientWindowFactory.getClientWindow</code> to create an instance of the custom <code class="literal">ClientWindow</code> implementation for the current request.</li><li class="listitem">Check the value of the context parameter <code class="literal">ClientWindow.CLIENT_WINDOW_MODE_PARAM_NAME</code>, before creating an instance of the custom <code class="literal">ClientWindow</code> implementation. The value of the context parameter should be equal to <code class="literal">url</code>.</li></ol></div><p>Based on these <a id="id754" class="indexterm"/>three steps, we can write a custom <code class="literal">ClientWindowFactory</code> implementation <a id="id755" class="indexterm"/>using the following code:</p><div class="informalexample"><pre class="programlisting">public class CustomClientWindowFactory 
              extends ClientWindowFactory {

 private ClientWindowFactory clientWindowFactory;
 public CustomClientWindowFactory() {}

 public CustomClientWindowFactory(ClientWindowFactory 
              clientWindowFactory) {
  this.clientWindowFactory = clientWindowFactory;
 }

 @Override
 public ClientWindow getClientWindow(FacesContext context) {
  if (context.getExternalContext().getInitParameter
     (ClientWindow.CLIENT_WINDOW_MODE_PARAM_NAME).equals("url")) {
      ClientWindow defaultClientWindow = 
              clientWindowFactory.getClientWindow(context);            
      ClientWindow customClientWindow = new 
              CustomClientWindow(defaultClientWindow);
      return customClientWindow;
  }
  return null;
 }

 @Override
 public ClientWindowFactory getWrapped() {
  return clientWindowFactory;
 }
}</pre></div><p>The <code class="literal">CustomClientWindow</code> implementation is an extension of <code class="literal">ClientWindowWrapper</code>, which allows us to override only the needed methods. In our case, we are interested in two methods. The first one is named <code class="literal">getId</code>, which returns a <code class="literal">String</code> value that uniquely identifies <code class="literal">ClientWindow</code> within the scope of the current session. The other one is named <code class="literal">decode</code>, which is responsible for providing the value returned by <code class="literal">getId</code>. In order to provide this value, the <code class="literal">decode</code> method should follow the given checks:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Request a parameter under the name given by the value of <code class="literal">ResponseStateManager.CLIENT_WINDOW_PARAM</code>.</li><li class="listitem">If this check doesn't return a favorable ID, look for a request parameter under the name given by the value of <code class="literal">ResponseStateManager.CLIENT_WINDOW_URL_PARAM</code>.</li><li class="listitem">If an ID value is not found, then fabricate an ID that uniquely identifies this <code class="literal">ClientWindow</code> within the scope of the current session.</li></ol></div><p>Furthermore, we can write a<a id="id756" class="indexterm"/> custom <code class="literal">ClientWindow</code> implementation that will <a id="id757" class="indexterm"/>generate a custom ID, of type <code class="literal">CUSTOM</code>—current date in milliseconds. The code is listed as follows–pay attention to see how the <code class="literal">decode</code> method is implemented:</p><div class="informalexample"><pre class="programlisting">public class CustomClientWindow extends ClientWindowWrapper {

 private ClientWindow clientWindow;
 String id;

 public CustomClientWindow() {}

 public CustomClientWindow(ClientWindow clientWindow) {
 this.clientWindow = clientWindow;
 }

 @Override
 public void decode(FacesContext context) {

  Map&lt;String, String&gt; requestParamMap = 
   context.getExternalContext().getRequestParameterMap();
  if (isClientWindowRenderModeEnabled(context)) {
      id = requestParamMap.
           get(ResponseStateManager.CLIENT_WINDOW_URL_PARAM);
  }
  if (requestParamMap.containsKey
      (ResponseStateManager.CLIENT_WINDOW_PARAM)) {
  id = requestParamMap.get
      (ResponseStateManager.CLIENT_WINDOW_PARAM);
  }
  if (id == null) {
      long time = new Date().getTime();
      id = "CUSTOM-" + time;
  }
 }

 @Override
 public String getId() {
  return id;
 }

 @Override
 public ClientWindow getWrapped() {
  return this.clientWindow;
 }
}</pre></div><p>Finally, configure the custom <code class="literal">ClientWindowFactory</code> implementation in <code class="literal">faces-config.xml</code> using the following code:</p><div class="informalexample"><pre class="programlisting">&lt;factory&gt;                
 &lt;client-window-factory&gt;
  book.beans.CustomClientWindowFactory
 &lt;/client-window-factory&gt;
&lt;/factory&gt;</pre></div><p>Done! The complete <a id="id758" class="indexterm"/>application is named <code class="literal">ch5_10_3</code>.</p><p>If you want to create an <a id="id759" class="indexterm"/>ID of type <code class="literal">UUID-uuid::counter</code> then, you can write the <code class="literal">decode</code> method, as follows:</p><div class="informalexample"><pre class="programlisting">@Override
public void decode(FacesContext context) {
 Map&lt;String, String&gt; requestParamMap = 
  context.getExternalContext().getRequestParameterMap();
 if (isClientWindowRenderModeEnabled(context)) {
    id = requestParamMap.get
         (ResponseStateManager.CLIENT_WINDOW_URL_PARAM);
 }
 if (requestParamMap.
     containsKey(ResponseStateManager.CLIENT_WINDOW_PARAM)) {
      id = requestParamMap.get
           (ResponseStateManager.CLIENT_WINDOW_PARAM);
 }
 if (id == null) {
    synchronized (context.getExternalContext().getSession(true)) {
     final String clientWindowKey = "my.custom.id";
     ExternalContext externalContext = 
                     context.getExternalContext();
     Map&lt;String, Object&gt; sessionAttrs = 
      externalContext.getSessionMap();
     Integer counter = (Integer) sessionAttrs.get(clientWindowKey);
     if (counter == null) {
         counter = 0;
     }
     String uuid = UUID.randomUUID().toString();
     id = "UUID-" + uuid + "::" + counter;
     sessionAttrs.put(clientWindowKey, ++counter);
    }
 }
}</pre></div><p>In this case, the <a id="id760" class="indexterm"/>complete application is named <code class="literal">ch5_10_4</code>.</p><p>Using a counter may be<a id="id761" class="indexterm"/> very useful when you decide to use an ID of type <code class="literal">SESSION_ID::counter</code>. Since the session ID will be the same over multiple windows/tabs, you need the counter to differentiate between the IDs. This kind of ID can be easily obtained thanks to the <code class="literal">ExternalContext.getSessionId</code> method of JSF 2.2, which is as follows:</p><div class="informalexample"><pre class="programlisting">String sessionId = externalContext.getSessionId(false);
id = sessionId + "::" + counter;</pre></div></div><div class="section" title="Configuring lifecycle"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec67"/>Configuring lifecycle</h2></div></div></div><p>As you know, JSF lifecycle<a id="id762" class="indexterm"/> contains six phases. In order to be processed, each JSF request will go through all these phases, or only through a part of them. The abstraction of lifecycle model is represented by the <code class="literal">javax.faces.lifecycle.Lifecycle</code> class, which is responsible for executing JSF phases in two methods:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <code class="literal">execute</code> method will execute all the phases except the sixth phase, that is, the <span class="emphasis"><em>Render Response</em></span> phase.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">render</code> method will execute the sixth phase.</li></ul></div><p>The custom <code class="literal">Lifecycle</code> can be written by implementing the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Extend <code class="literal">LifecycleFactory</code>, which is a factory object capable of creating and returning a new <code class="literal">Lifecycle</code> instance.</li><li class="listitem">Extend <code class="literal">LifecycleWrapper</code>, which is a simple implementation of <code class="literal">LifecycleLifecycle</code> that allows us to selectively override methods.</li><li class="listitem">Configure the custom <code class="literal">Lifecycle</code> implementation in <code class="literal">faces-config.xml</code>.</li><li class="listitem">Configure the custom <code class="literal">Lifecycle</code> implementation in <code class="literal">web.xml</code>.</li></ol></div><p>Let's begin with a generic custom <code class="literal">Lifecycle</code>, by extending <code class="literal">LifecycleFactory</code> as follows—notice how we register a custom <code class="literal">Lifecycle</code> implementation using a unique identifier:</p><div class="informalexample"><pre class="programlisting">public class CustomLifecycleFactory extends LifecycleFactory {

 public static final String CUSTOM_LIFECYCLE_ID = "CustomLifecycle";
 private LifecycleFactory lifecycleFactory;

 public CustomLifecycleFactory(){}
   
 public CustomLifecycleFactory(LifecycleFactory lifecycleFactory) {
  this.lifecycleFactory = lifecycleFactory;
  Lifecycle defaultLifecycle = this.lifecycleFactory.
            getLifecycle(LifecycleFactory.DEFAULT_LIFECYCLE);
  addLifecycle(CUSTOM_LIFECYCLE_ID, new
            CustomLifecycle(defaultLifecycle));
 }

 @Override
 public final void addLifecycle(String lifecycleId,Lifecycle lifecycle) {
  lifecycleFactory.addLifecycle(lifecycleId, lifecycle);
 }

 @Override
 public Lifecycle getLifecycle(String lifecycleId) {
  return lifecycleFactory.getLifecycle(lifecycleId);
 }

 @Override
 public Iterator&lt;String&gt; getLifecycleIds() {
  return lifecycleFactory.getLifecycleIds();
 }
}</pre></div><p>Furthermore, <code class="literal">CustomLifecycle</code> extends <code class="literal">LifecycleWrapper</code> and overrides the required methods. In <a id="id763" class="indexterm"/>order to have access to the instance of the class being wrapped, we need to override the <code class="literal">getWrapped</code> method as follows:</p><div class="informalexample"><pre class="programlisting">public class CustomLifecycle extends LifecycleWrapper {

 private Lifecycle lifecycle;

 public CustomLifecycle(Lifecycle lifecycle) {
  this.lifecycle = lifecycle;
 }

 ...
@Override
 public Lifecycle getWrapped() {
  return lifecycle;
 }
}</pre></div><p>Next, we need to configure our custom lifecycle factory in <code class="literal">faces-config.xml</code> as follows:</p><div class="informalexample"><pre class="programlisting">&lt;factory&gt;
 &lt;lifecycle-factory&gt;book.beans.CustomLifecycleFactory&lt;/lifecycle-factory&gt;        
&lt;/factory&gt;</pre></div><p>Finally, we need to register the custom lifecycle in <code class="literal">web.xml</code> using its identifier (see the highlighted code):</p><div class="informalexample"><pre class="programlisting">&lt;servlet&gt;
 &lt;servlet-name&gt;Faces Servlet&lt;/servlet-name&gt;
 &lt;servlet-class&gt;javax.faces.webapp.FacesServlet&lt;/servlet-class&gt;
<span class="strong"><strong> &lt;init-param&gt;</strong></span>
<span class="strong"><strong>  &lt;param-name&gt;javax.faces.LIFECYCLE_ID&lt;/param-name&gt;</strong></span>
<span class="strong"><strong>  &lt;param-value&gt;CustomLifecycle&lt;/param-value&gt;</strong></span>
<span class="strong"><strong> &lt;/init-param&gt;</strong></span>
 &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
&lt;/servlet&gt;</pre></div><p>At this moment, we<a id="id764" class="indexterm"/> have a functional dummy custom lifecycle. Next, we will add some real functionality, and for this we focus on the <code class="literal">Lifecycle.attachWindow</code> method. This method was introduced in JSF 2.2 and is used for attaching a <code class="literal">ClientWindow</code> instance to the current request. The <code class="literal">ClientWindow</code> instance is associated with the incoming request during the <code class="literal">Lifecycle.attachWindow</code> method. This method will cause a new instance of <code class="literal">ClientWindow</code> to be created, to be assigned an ID, and then to be passed to <code class="literal">ExternalContext.setClientWindow(ClientWindow)</code>.</p><p>In the <span class="emphasis"><em>JSF 2.2 Window ID API</em></span> section, you saw how to explore the default mechanism for identifying different windows/tabs of users. Based on this knowledge, we have written a custom <code class="literal">ClientWindow</code> implementation to provide a custom ID for the <code class="literal">jfwid</code> request parameter of type <code class="literal">CUSTOM—current date in milliseconds</code>—and of type<span class="emphasis"><em> </em></span> <code class="literal">UUID::counter</code>. The custom client window was set via a custom <code class="literal">ClientWindowFactory</code> implementation. Further, we set the same custom client window by overriding the <code class="literal">attachWindow</code> method as shown in the following code:</p><div class="informalexample"><pre class="programlisting">public class CustomLifecycle extends LifecycleWrapper {

 private static final Logger logger = 
  Logger.getLogger(CustomLifecycle.class.getName());
 private Lifecycle lifecycle;

 public CustomLifecycle(Lifecycle lifecycle) {
  this.lifecycle = lifecycle;
 }

 @Override
 public void attachWindow(FacesContext context) {

  if (context.getExternalContext().getInitParameter
     (ClientWindow.CLIENT_WINDOW_MODE_PARAM_NAME).equals("url")) {
     ExternalContext externalContext = 
      context.getExternalContext();
     ClientWindow clientWindow = externalContext.getClientWindow();
     if (clientWindow == null) {
         clientWindow = createClientWindow(context);
         if (clientWindow != null) {
             CustomClientWindow customClientWindow = new 
              CustomClientWindow(clientWindow);
             customClientWindow.decode(context);
                    
             externalContext.setClientWindow(customClientWindow);
         }
     }
  }
 }

 private ClientWindow createClientWindow(FacesContext context) {        
  ClientWindowFactory clientWindowFactory = (ClientWindowFactory) 
  FactoryFinder.getFactory(FactoryFinder.CLIENT_WINDOW_FACTORY);
  return clientWindowFactory.getClientWindow(context);
 }
...
}</pre></div><p>Done! The <a id="id765" class="indexterm"/>complete application is named <code class="literal">ch5_10_2</code>.</p></div><div class="section" title="Configuring the application"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec68"/>Configuring the application</h2></div></div></div><p>The application represents a <a id="id766" class="indexterm"/>per-web-application singleton object, which is the heart of the JSF runtime. Through this object we can accomplish many tasks, such as adding components, converters, validators, subscribing to events, setting listeners, locales, and messaging bundles. It represents the entry point for many JSF artifacts. We refer to it using the following code:</p><div class="informalexample"><pre class="programlisting">FacesContext.getCurrentInstance().getApplication();</pre></div><p>The application can be extended and customized by following these steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Extend <code class="literal">ApplicationFactory</code>, which is a factory object capable of creating and returning a new <code class="literal">Application</code> instance.</li><li class="listitem">Extend <code class="literal">ApplicationWrapper</code>, which is a simple implementation of <code class="literal">Application</code> that allows us to selectively override methods.</li><li class="listitem">Configure the custom <code class="literal">Application</code> implementation in <code class="literal">faces-config.xml</code>.</li></ol></div><p>For example, we can use a custom <code class="literal">Application</code> implementation for adding a list of validators to an application. We start by writing a custom application factory as follows:</p><div class="informalexample"><pre class="programlisting">public class CustomApplicationFactory extends ApplicationFactory {

 private ApplicationFactory applicationFactory;
    
 public CustomApplicationFactory(){}

 public CustomApplicationFactory(ApplicationFactory applicationFactory) {
  this.applicationFactory = applicationFactory;
 }

 @Override
 public void setApplication(Application application) {
  applicationFactory.setApplication(application);
 }

 @Override
 public Application getApplication() {       
  Application handler = new CustomApplication(
                            applicationFactory.getApplication());
  return handler;
 }
}</pre></div><p>Now, the job is accomplished by <code class="literal">CustomApplication</code> as follows:</p><div class="informalexample"><pre class="programlisting">public class CustomApplication extends ApplicationWrapper {

 private Application application;

 public CustomApplication(Application application) {
  this.application = application;
 }

 @Override
 public Application getWrapped() {
  return application;
 }

 @Override
 public void addValidator(java.lang.String validatorId,
                          java.lang.String validatorClass) {
boolean   
  flag = false;
  Iterator i = getWrapped().getValidatorIds();
  while (i.hasNext()) {
         if (i.next().equals("emailValidator")) {               
             flag = true;
             break;
         }
  }

  if (flag == false) {            
      getWrapped().addValidator("emailValidator", 
                 "book.beans.EmailValidator");
  }

  getWrapped().addValidator(validatorId, validatorClass);
 }
}</pre></div><p>Finally, configure <a id="id767" class="indexterm"/>the new custom application in <code class="literal">faces-config.xml</code> as follows:</p><div class="informalexample"><pre class="programlisting">&lt;factory&gt;
 &lt;application-factory&gt;
  book.beans.CustomApplicationFactory
 &lt;/application-factory&gt;
&lt;/factory&gt;</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note124"/>Note</h3><p>Starting with JSF 2.2, we can use dependency injection with application objects (<code class="literal">@Inject</code> and <code class="literal">@EJB</code>). The preceding example, with the list of validators provided by a CDI bean as a <code class="literal">Map</code>, is available in the code bundle of this chapter under the name <code class="literal">ch5_11</code>.</p></div></div></div><div class="section" title="Configuring VDL"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec69"/>Configuring VDL</h2></div></div></div><p>The abbreviation <a id="id768" class="indexterm"/>VDL stands for <span class="strong"><strong>View Declaration Language</strong></span>, which <a id="id769" class="indexterm"/>represents the contract that a view declaration language must<a id="id770" class="indexterm"/> implement in order to interact with the JSF runtime. The <code class="literal">ViewDeclarationLanguageFactory</code> class is used to create and return instances of the <code class="literal">ViewDeclarationLanguage</code> class.</p><p>In order to alter how the runtime transforms an input file into a tree of components, you need to write a custom <code class="literal">ViewDeclarationLanguageFactory</code> implementation, which can be accomplished by extending the original class and overriding the <code class="literal">getViewDeclarationLanguage</code> method, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">public class CustomViewDeclarationLanguageFactory 
       extends ViewDeclarationLanguageFactory{

 private ViewDeclarationLanguageFactory 
        viewDeclarationLanguageFactory;
    
 public CustomViewDeclarationLanguageFactory
  (ViewDeclarationLanguageFactory viewDeclarationLanguageFactory){
  this.viewDeclarationLanguageFactory = 
        viewDeclarationLanguageFactory;
 }
    
 @Override
 public ViewDeclarationLanguage 
        getViewDeclarationLanguage(String viewId) {        
  return new  
   CustomViewDeclarationLanguage(viewDeclarationLanguageFactory.
    getViewDeclarationLanguage(viewId));
 }    
}</pre></div><p>The <code class="literal">CustomViewDeclarationLanguage</code> implementation can be written by extending <code class="literal">ViewDeclarationLanguage</code> and overriding all methods, or extending the new JSF 2.2 <code class="literal">ViewDeclarationLanguageWrapper</code> class and overriding only the needed method. Our <code class="literal">CustomViewDeclarationLanguage</code> implementation represents a simple skeleton based on the wrapper class as shown in the following code:</p><div class="informalexample"><pre class="programlisting">public class CustomViewDeclarationLanguage extends 
                     ViewDeclarationLanguageWrapper {

 private ViewDeclarationLanguage viewDeclarationLanguage;

 public CustomViewDeclarationLanguage
        (ViewDeclarationLanguage viewDeclarationLanguage) {
  this.viewDeclarationLanguage = viewDeclarationLanguage;
 }

 //override here the needed methods
    
 @Override
 public ViewDeclarationLanguage getWrapped() {
  return viewDeclarationLanguage;
 }
}</pre></div><p>This factory can be configured in <code class="literal">faces-config.xml</code> as follows:</p><div class="informalexample"><pre class="programlisting">&lt;factory&gt;
 &lt;view-declaration-language-factory&gt;
  book.beans.CustomViewDeclarationLanguageFactory
 &lt;/view-declaration-language-factory&gt;
&lt;/factory&gt;</pre></div><p>Done! The complete <a id="id771" class="indexterm"/>application is named <code class="literal">ch5_17</code>.</p><p>At <a class="ulink" href="https://code.google.com/p/javavdl/">https://code.google.com/p/javavdl/</a>, you can see an implementation of a JSF VDL that allows pages or <a id="id772" class="indexterm"/>complete JSF applications to be authored in pure Java, without the<a id="id773" class="indexterm"/> need for any XML or other declarative markup (for example, Facelets).</p></div></div>
<div class="section" title="Combined power of multiple factories"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec49"/>Combined power of multiple factories</h1></div></div></div><p>In the last several sections, you saw how to customize and configure the most used JSF factories. In the final section of this chapter, you will see how to <a id="id774" class="indexterm"/>exploit a few factories in the same application. For example, a convenient scenario will assume that we want to fire a non-JSF request and get as response a JSF view. An approach of this scenario consists in writing a Java Servlet capable of converting a non-JSF request into a JSF view.</p><p>In order to write such a Servlet, we need to obtain access to <code class="literal">FacesContext</code>. For this, we can combine the power of the default <code class="literal">LifecycleFactory</code> class with the power of the default <code class="literal">FacesContextFactory</code> class. Further, we can access <code class="literal">Application</code> via <code class="literal">FacesContext</code>, which means that we can obtain the <code class="literal">ViewHandler</code> that is responsible for creating JSF views via the <code class="literal">createView</code> method. Once the view is created, all we need to do is to set <code class="literal">UIViewRoot</code> and tell <code class="literal">Lifecycle</code> to render the response (execute the <span class="emphasis"><em>Render Response</em></span> phase). In lines of code, the Servlet looks like the following:</p><div class="informalexample"><pre class="programlisting">@WebServlet(name = "JSFServlet", urlPatterns = {"/jsfServlet"})
public class JSFServlet extends HttpServlet {
...
protected void processRequest(HttpServletRequest request, 
 HttpServletResponse response)
 throws ServletException, IOException {

 String page = request.getParameter("page");

 LifecycleFactory lifecycleFactory = (LifecycleFactory) 
  FactoryFinder.getFactory(FactoryFinder.LIFECYCLE_FACTORY);
 Lifecycle lifecycle = lifecycleFactory.getLifecycle
 (LifecycleFactory.DEFAULT_LIFECYCLE);

 FacesContextFactory facesContextFactory = (FacesContextFactory) 
  FactoryFinder.getFactory(FactoryFinder.FACES_CONTEXT_FACTORY);
 FacesContext facesContext = facesContextFactory.getFacesContext
  (request.getServletContext(), request, response, lifecycle);

 Application application = facesContext.getApplication();
 ViewHandler viewHandler = application.getViewHandler();
 UIViewRoot uiViewRoot = viewHandler.
  createView(facesContext, "/" + page);
 facesContext.setViewRoot(uiViewRoot);
 lifecycle.render(facesContext);
}
...</pre></div><p>Now, you can test very <a id="id775" class="indexterm"/>easily using the <code class="literal">&lt;h:outputLink&gt;</code> tag as follows:</p><div class="informalexample"><pre class="programlisting">Navigate page-to-page via h:outputLink - WON'T WORK!
&lt;h:outputLink value="done.xhtml"&gt;done.xhtml&lt;/h:outputLink&gt;
Navigate page-to-page via h:outputLink, but add context path for the application to a context-relative path - WORK!
&lt;h:outputLink value="#{facesContext.externalContext.
 applicationContextPath}/faces/done.xhtml"&gt;
 done.xhtml&lt;/h:outputLink&gt;
Navigate to a JSF view via a non-JSF request using servlet - WORK!
&lt;h:outputLink value="jsfServlet?page=done.xhtml"&gt;
 done.xhml&lt;/h:outputLink&gt;</pre></div><p>The complete application is named <code class="literal">ch5_18</code>.</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec50"/>Summary</h1></div></div></div><p>Well, this was a pretty heavy chapter, but JSF's important aspects were touched upon here. You learned how to create, extend, and configure several of the main JSF 2.x artifacts, and how they have been improved by JSF 2.2, especially with the dependency injection mechanism. There are still a lot of things that were not discussed in this chapter, such as state management, facelet factory, and so on, but keep on reading.</p><p>See you in the next chapter, where we will discuss about working with tabular data in JSF.</p></div></body></html>