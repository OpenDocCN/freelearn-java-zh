- en: Traits and Mixin Compositions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 特性与混入组合
- en: Before digging into some actual design patterns, we have to make sure that many
    of the Scala language concepts are clear to the reader. Many of those concepts
    will later be used in implementing the actual design patterns, and being aware
    of the possibilities, limitations, and pitfalls are key factors that enable us
    to correctly and efficiently write code. Even though those concepts are not considered
    *official* design patterns, they could still be used to write good software. In
    some cases, due to the richness of Scala, some concepts could replace a design
    pattern by just using language features. After all, as we have already said before,
    design patterns are there because a programming language lacks features and is
    not rich enough to complete certain tasks.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入研究一些实际的设计模式之前，我们必须确保许多Scala语言概念对读者来说是清晰的。这些概念中的许多将在实现实际设计模式时被使用，了解可能性、限制和陷阱是使我们能够正确且高效地编写代码的关键因素。尽管这些概念不被视为*官方*设计模式，但它们仍然可以用来编写好的软件。在某些情况下，由于Scala的丰富性，一些概念可以通过仅使用语言特性来替代设计模式。毕竟，正如我们之前所说的，设计模式的存在是因为编程语言缺乏功能，不足以完成某些任务。
- en: 'The first topic that we will look into is about traits and mixin compositions.
    They provide the developer with a possibility to share already implemented functionality
    or to define interfaces for classes in an application. Many of the possibilities,
    which are provided by traits and mixin compositions for developers, are useful
    to implement some of the design patterns that we will focus on later in this book.
    We will go through the following main topics in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要探讨的第一个主题是关于特性和混入组合。它们为开发者提供了共享已实现的功能或为应用程序中的类定义接口的可能性。特性与混入组合为开发者提供的许多可能性，对于实现我们将在本书后面关注的一些设计模式非常有用。在本章中，我们将探讨以下主要主题：
- en: Traits
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特性
- en: Mixin compositions
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 混入组合
- en: Multiple inheritance
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多重继承
- en: Linearization
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线性化
- en: Testing traits
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试特性
- en: Traits versus classes
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特性对比类
- en: Traits
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 特性
- en: Many of you might have different perspectives of traits in Scala. They can be
    viewed not only as interfaces in other languages, but also as classes with only
    parameter-less constructors.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 你们中很多人可能对Scala中的特性有不同的看法。它们不仅可以被视为其他语言中的接口，还可以被视为只有无参构造函数的类。
- en: Trait parameters
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 特性参数
- en: The Scala programming language is quite dynamic and has evolved quickly throughout
    the years. According to the language creators, the Dotty project is the future
    of Scala and it is a place where passing parameters to traits and many other features
    are being tested and implemented. The main idea behind it is language simplification,
    and more information can be found at [http://dotty.epfl.ch](http://dotty.epfl.ch)
    and [https://scala-lang.org/blog/2017/05/31/first-dotty-milestone-release.html](https://scala-lang.org/blog/2017/05/31/first-dotty-milestone-release.html).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Scala编程语言非常动态，并且在过去的几年中发展迅速。根据语言创造者的说法，Dotty项目是Scala的未来，它是一个正在测试和实现将参数传递给特性和许多其他功能的地方。其背后的主要思想是语言简化，更多信息可以在[http://dotty.epfl.ch](http://dotty.epfl.ch)和[https://scala-lang.org/blog/2017/05/31/first-dotty-milestone-release.html](https://scala-lang.org/blog/2017/05/31/first-dotty-milestone-release.html)找到。
- en: In the following few sections, we will see the traits from different points
    of view and try to give you some ideas about how they can be used.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，我们将从不同的角度来探讨特性，并尝试给您一些关于如何使用它们的想法。
- en: Traits as interfaces
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 特性作为接口
- en: 'Traits can be viewed as interfaces in other languages, for example, Java. However
    they, allow the developers to implement some or all of their methods. Whenever
    there is some code in a trait, the trait is called a **mixin**. Let''s have a
    look at the following example:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 特性在其他语言中可以被视为接口，例如Java。然而，它们允许开发者实现一些或所有的方法。每当特性能量中存在一些代码时，该特性就被称为**混入**。让我们看看以下示例：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here, `Alarm` is an interface. Its only method, `trigger`, does not have any
    implementation and if mixed in a non-abstract class, an implementation of the
    method will be required.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`Alarm`是一个接口。它的唯一方法`trigger`没有任何实现，如果在一个非抽象类中混入，则需要实现该方法。
- en: 'Let''s see another trait example:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看另一个特性示例：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `Notifier` interface shown previously has one of its methods implemented,
    and `clear` and the value of `notificationMessage` have to be handled by the classes
    that will mix with the `Notifier` interface. Moreover, the traits can require
    a class to have a specific variable inside it. This is somewhat similar to abstract
    classes in other languages.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 之前显示的`Notifier`接口实现了一个方法，而`clear`和`notificationMessage`的值必须由将与`Notifier`接口混合的类处理。此外，特性可以要求类在其内部具有特定的变量。这在其他语言中的抽象类中有些类似。
- en: Mixing in traits with variables
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将特性与变量混合
- en: 'As we just pointed out, traits might require a class to have a specific variable.
    An interesting use case would be when we pass a variable to the constructor of
    a class. This will cover the trait requirements:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们刚才指出的，特性可能要求类具有特定的变量。一个有趣的用例是在将变量传递给类的构造函数时。这将涵盖特性要求：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The only requirement here is for the variable to have the same name and to
    be preceded by the `val` keyword in the class definition. If we don''t use `val`
    in front of the parameter in the preceding code, the compiler would still ask
    us to implement the trait. In this case, we would have to use a different name
    for the class parameter and would have an `override val notificationMessage` assignment
    in the class body. The reason for this behavior is simple: if we explicitly use
    `val` (or `var`), the compiler will create a field with a getter with the same
    scope as the parameter. If we just have the parameter, a field and internal getter
    will be created only if the parameter is used outside the constructor scope, for
    example, in a method. For completeness, case classes automatically have the `val`
    keyword *prepended* to parameters. After what we said it means that when using
    `val`, we actually have a field with the given name and the right scope, and it
    will automatically override whatever the trait requires us to do.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的唯一要求是变量具有相同的名称，并且在类定义中由`val`关键字 precede。如果我们不在前面的代码中使用`val`在参数前面，编译器仍然会要求我们实现特性。在这种情况下，我们必须为类参数使用不同的名称，并在类体中有一个`override
    val notificationMessage`赋值。这种行为的原因很简单：如果我们显式使用`val`（或`var`），编译器将创建一个与参数具有相同作用域的getter字段。如果我们只是有参数，只有当参数在构造函数作用域之外使用时，例如在方法中，才会创建一个字段和内部getter。为了完整性，case类自动将`val`关键字
    *前置* 到参数上。根据我们刚才说的，这意味着当使用`val`时，我们实际上有一个具有给定名称和正确作用域的字段，并且它将自动覆盖特性要求我们做的任何事情。
- en: Traits as classes
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 特性作为类
- en: 'Traits can also be seen from the perspective of classes. In this case, they
    have to implement all their methods and have only one constructor that does not
    accept any parameters. Consider the following:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 特性也可以从类的角度来理解。在这种情况下，它们必须实现所有方法，并且只有一个不接受任何参数的构造函数。考虑以下示例：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, we can actually instantiate `Beeper` and call its method. The following
    is a console application that does just this:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们实际上可以实例化`Beeper`并调用其方法。以下是一个仅执行此操作的控制台应用程序：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'As expected, after running the application, we will see the following output
    in our Terminal:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，在运行应用程序后，我们将在我们的终端中看到以下输出：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Extending classes
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展类
- en: 'It is possible for traits to extend classes. Let''s have a look at the following
    example:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 特性可以扩展类。让我们看看以下示例：
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here, as expected, `PgSqlConnector` will be obliged to implement the abstract
    class methods. As you can guess, we could have other traits that extend other
    classes and then we might want to mix them in. Scala, however, will put a limit
    in some cases, and we will see how it will affect us later in this chapter when
    we look at compositions.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，`PgSqlConnector`将被迫实现抽象类的方法。正如你可以猜到的，我们可能有其他扩展其他类的特性，然后我们可能想要将它们混合在一起。然而，Scala在某些情况下会设置限制，我们将在本章后面查看组合时看到它将如何影响我们。
- en: Extending traits
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展特性
- en: 'Traits can also extend each other. Have a look at the following example:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 特性也可以相互扩展。看看以下示例：
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The preceding example is simple and it should really just make the `Runner`
    object mix the two traits separately. Extending traits is useful in a design pattern
    called **Stackable Traits**, which we will be looking into later in this book.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的示例很简单，它应该只是让`Runner`对象分别混合两个特性。扩展特性在一种称为**可堆叠特性**的设计模式中很有用，我们将在本书后面的章节中探讨。
- en: Mixin compositions
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 混合组合
- en: Scala allows developers to extend many traits in a single class. This adds the
    possibility of achieving multiple inheritance and saves a lot of effort in code
    writing, which has to be performed in languages where extending many classes is
    not allowed. In this subtopic, we will show how traits can be mixed in a specific
    class or used to create anonymous classes with some specific functionality while
    writing our code.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Scala 允许开发者在单个类中扩展多个特性。这增加了实现多重继承的可能性，并在代码编写上节省了大量精力，这在不允许扩展多个类的语言中是必须执行的。在本子主题中，我们将展示如何将特性混合到特定的类中，或者在我们编写代码时使用它们来创建具有特定功能的匿名类。
- en: Mixing traits in
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在类中混合特性
- en: 'First of all, let''s modify the code from the previous example. It is a really
    simple change and it will also show exactly how traits can be mixed in:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们修改前一个例子中的代码。这是一个非常简单的修改，它也将确切地展示特性是如何混合的：
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As can be seen from the preceding code, we can add multiple traits to a class.
    We've used objects in the example just because of the main method. This would
    be similar to creating a class with no constructor parameters (objects in Scala
    are singleton classes).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码所示，我们可以将多个特性添加到类中。我们在示例中使用对象仅仅是因为主方法。这类似于创建一个没有构造函数参数的类（Scala 中的对象是单例类）。
- en: How to mix traits in?
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如何混合特性？
- en: 'Mixing traits into a class is done with the following syntax:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下语法将特性混合到类中：
- en: '`extends T1 with T2 with … with Tn`.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`extends T1 with T2 with … with Tn`。'
- en: If a class already extends another class, we just keep on adding the traits
    using the `with` keyword.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个类已经扩展了另一个类，我们只需继续使用`with`关键字添加特性。
- en: If a trait method is not implemented inside the trait body and the class we
    are mixing it into is not abstract, the class will have to implement the trait.
    Otherwise, a compilation error will occur.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个特性方法没有在特性体内部实现，并且我们将它混合到的类不是抽象类，那么这个类将不得不实现该特性。否则，将发生编译错误。
- en: Composing
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组合
- en: Composing at creation time gives us an opportunity to create anonymous classes
    without the need to explicitly define them. Also, if there are many different
    traits that we might want to combine, creating all the possibilities would involve
    too much work, so this helps make things easier for us.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建时进行组合，给我们提供了创建匿名类而不需要显式定义它们的机会。此外，如果我们想要组合许多不同的特性，创建所有可能性将涉及太多工作，所以这有助于使事情变得更容易。
- en: Composing simple traits
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组合简单特性
- en: 'Let''s see an example where we compose simple traits, which do not extend other
    traits or classes:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个例子，其中我们组合了简单的特性，这些特性不扩展其他特性或类：
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the preceding example, we used the `Alarm` and `Notifier` traits from before.
    We created two watch instances—one is expensive that has more functionality and
    is more useful, and the other one is a cheap one that does not give too much control.
    Essentially, they are anonymous classes, which are defined during instantiation.
    Another thing to note is that, as expected, we have to implement the abstract
    methods from the traits we include. I hope this gives you an idea of how many
    combinations there might be in the cases where we have more traits.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们使用了之前提到的`Alarm`和`Notifier`特性。我们创建了两个手表实例——一个功能丰富且更有用的昂贵实例，另一个是便宜且控制力不足的实例。本质上，它们是匿名类，在实例化时定义。另外，正如预期的那样，我们必须实现我们包含的特性中的抽象方法。我希望这能给你一个关于在我们有更多特性时可能有多少种组合的想法。
- en: 'Just for the sake of completeness, here is an example output of the preceding
    program:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 仅为了完整性，这里是一个前述程序的示例输出：
- en: '[PRE10]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As expected, the highlighted time value will be different in the different runs.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，突出显示的时间值在不同的运行中会有所不同。
- en: Composing complex traits
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组合复杂特性
- en: 'It is possible that in some cases, we would have to compose more complex traits,
    which extend other traits or classes. If a trait and no other trait up the inheritance
    chain extends a specific class explicitly, then things will be pretty simple and
    they don''t change much. In this case, we would simply have access to the methods
    from the super traits. However, let''s see what happens if any of the traits in
    the hierarchy extend a specific class. For the next example, we will be using
    the `ConnectorWithHelper` trait defined previously. This trait extends the abstract
    `Connector` class. Imagine that we want to have another really expensive smart
    watch, which can also connect to a database:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们可能需要组合更复杂的特性，这些特性扩展了其他特性或类。如果一个特性（以及继承链上的其他特性）明确扩展了特定的类，那么事情将会非常简单，它们不会改变太多。在这种情况下，我们将能够访问超特性的方法。然而，让我们看看如果继承层次结构中的任何特性扩展了特定的类会发生什么。在下一个示例中，我们将使用之前定义的`ConnectorWithHelper`特性。这个特性扩展了抽象的`Connector`类。想象一下，如果我们想拥有另一款非常昂贵的智能手表，它也可以连接到数据库：
- en: '[PRE11]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'It seems that everything is fine; however, when we compile, we get the following
    error message:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来一切都很正常；然而，当我们编译时，我们得到以下错误信息：
- en: '[PRE12]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This error message tells us that since the `ConnectorWithHelper` trait extends
    the `Connector` class, all the classes that use this trait for composition must
    be subclasses of `Connector`. Let's now imagine that we wanted to mix in another
    trait that also extends a class, but a different one in this case. According to
    the preceding logic, it will be required that `Watch` should also be a subclass
    of the other class. This, however, wouldn't be possible, as we can only extend
    one class at a time and this is how Scala limits multiple inheritance in order
    to prevent dangerous errors from happening.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这个错误信息告诉我们，由于`ConnectorWithHelper`特性扩展了`Connector`类，所有使用此特性进行组合的类都必须是`Connector`类的子类。现在让我们想象一下，如果我们想混合另一个也扩展类的特性，但在这个情况下是另一个类。根据前面的逻辑，将需要`Watch`类也应该是其他类的子类。然而，这是不可能的，因为我们一次只能扩展一个类，这就是Scala如何限制多重继承以防止发生危险错误的方式。
- en: If we want to fix the compilation issue in the example, we will have to modify
    the original `Watch` class and make sure it is a subclass of `Connector`. This,
    however, might not be desired and some refactoring might be needed in such cases.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想在示例中修复编译问题，我们就必须修改原始的`Watch`类，并确保它是`Connector`类的子类。然而，这可能不是我们想要的，在这种情况下可能需要进行一些重构。
- en: Composing with self-types
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用自类型进行组合
- en: 'In the previous subsection, we saw how we were forced to extend `Connector`
    in our `Watch` class in order to properly compile our code. There are cases where
    we might actually want to enforce a trait to be mixed into a class that also has
    another trait or multiple traits mixed into it. Let''s imagine that we want to
    have an alarm that must be able to notify us, no matter what:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的子节中，我们看到了我们如何在`Watch`类中被迫扩展`Connector`类以正确编译我们的代码。有些情况下，我们可能实际上想强制一个特性被混合到一个已经混合了另一个特性或多个特性的类中。让我们想象一下，我们想要一个能够通知我们的闹钟，无论发生什么：
- en: '[PRE13]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the preceding code, we've shown a **self-type**. The highlighted piece of
    code brings all the methods of `Notifier` to the scope of our new trait and it
    also requires that any class that mixes in `AlarmNotifier` should also mix in
    `Notifier`. Otherwise, a compilation error will occur. Instead of this, we can
    use `self` and then refer to the `Notifier` methods inside `AlarmNotifier` by
    typing, for example, `self. printNotification()`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们展示了**自类型**。高亮显示的代码将`Notifier`的所有方法都带到了我们新特性的作用域中，并且它还要求任何混合`AlarmNotifier`类的类也应该混合`Notifier`类。否则，将发生编译错误。相反，我们可以使用`self`，然后通过输入例如`self.printNotification()`来在`AlarmNotifier`内部引用`Notifier`的方法。
- en: 'The following code is an example of how to use the new trait:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是使用新特性的示例：
- en: '[PRE14]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: If we comment out the `watch` variable in the preceding code and uncomment the
    commented bit, we will see a compilation error that is raised due to the fact
    that we must also mix `Notifier` in.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在前面的代码中注释掉`watch`变量，并取消注释注释的部分，我们会看到一个编译错误，这是由于我们必须也混合`Notifier`类。
- en: In this subsection, we showed a simple use of self-types. One trait can require
    multiple other traits to be mixed in. In such cases, they are just separated with
    the `with` keyword. Self-types are a key part of the **cake design pattern**,
    which is used for dependency injection. We will see more interesting use cases
    later in this book.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在本小节中，我们展示了 self-types 的简单用法。一个特性可以要求混合多个其他特性。在这种情况下，它们只是通过 `with` 关键字分隔。Self-types
    是 **蛋糕设计模式** 的关键部分，该模式用于依赖注入。我们将在本书的后面部分看到更多有趣的用例。
- en: Clashing traits
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 冲突的特性
- en: Some of you might already have a question in your mind—what if we mix in traits
    that have methods with identical signatures? We will look at this in the next
    few sections.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人可能已经在心中提出了一个问题——如果我们混合了具有相同签名的方法的特性怎么办？我们将在接下来的几节中探讨这个问题。
- en: Same signatures and return types
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 相同签名和返回类型
- en: 'Consider an example where we want to mix two traits into a class and their
    declaration of a method is identical:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个例子，我们想要将两个特性混合到一个类中，并且它们的声明方法相同：
- en: '[PRE15]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the preceding example, the greeter is always polite and mixes both formal
    and informal greetings. While implementing, it just has to implement the method
    once.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，问候者总是有礼貌的，并且混合了正式和非正式的问候。在实现时，只需实现一次方法即可。
- en: Same signatures and different return types traits
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 相同签名和不同返回类型的特性
- en: 'What if our greeting traits have more methods that have the same signatures,
    but a different return type? Let''s add the following declaration to `FormalGreeting`:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的问候特性有更多具有相同签名但返回类型不同的方法呢？让我们向 `FormalGreeting` 添加以下声明：
- en: '[PRE16]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Also, add the following to `InformalGreeting`:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 还需向 `InformalGreeting` 添加以下内容：
- en: '[PRE17]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We will have to implement these in our `Greeter` class. However, the compiler
    will not allow us the message that `getTime` was defined twice in, which shows
    that Scala prevents such things from happening.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须在我们的 `Greeter` 类中实现这些方法。然而，编译器不会允许我们定义 `getTime` 两次的消息，这表明 Scala 阻止此类事情发生。
- en: Same signatures and return types mixins
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 相同签名和返回类型的 mixins
- en: Before going further, a quick reminder that a mixin is just a trait that has
    some code implemented inside. This means that in the following examples, we do
    not have to implement the methods inside the class that uses them.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，先快速提醒一下，mixin 只是一个在内部实现了一些代码的特性。这意味着在下面的示例中，我们不需要在使用它们的类内部实现方法。
- en: 'Let''s have a look at the following example:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下示例：
- en: '[PRE18]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Probably as expected, our compilation will fail with the following message:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 可能正如预期的那样，我们的编译将失败，并显示以下消息：
- en: '[PRE19]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The message is useful and it even gives us a hint about how to fix the problem.
    Clashing methods is a problem in multiple inheritances, but as you can see, we
    are forced to pick one of the available methods. Here is a possible fix inside
    the `Clashing` object:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这条消息很有用，甚至给出了如何解决问题的提示。冲突的方法是多重继承中的问题，但如您所见，我们被迫选择其中一种可用方法。以下是在 `Clashing` 对象中可能的修复方法：
- en: '[PRE20]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: However, what if we want to use both the `hello` methods for some reason? In
    this case, we can create other methods that are named differently and call the
    specific traits as in the preceding example (the `super` notation). We can also
    directly refer to the methods with the `super` notation instead of wrapping them
    in a method. My personal preference, though, would be to wrap it, as the code
    could get messy otherwise.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们出于某种原因想要同时使用两个 `hello` 方法怎么办？在这种情况下，我们可以创建其他名称不同的方法，并像前面的示例（`super` 符号）那样调用特定的特性。我们也可以直接使用
    `super` 符号来引用方法，而不是将它们包装在方法中。不过，我个人更喜欢将其包装起来，因为否则代码可能会变得混乱。
- en: The super notation
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 超类符号
- en: 'What would happen if in the preceding example, instead of `super[A]. hello()`,
    we do the following: `override def hello(): String = super.hello()`?'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '如果在前面的示例中，我们不是使用 `super[A]. hello()`，而是这样做：`override def hello(): String =
    super.hello()`，会发生什么？'
- en: Which hello method will be called and why? In the current case, it will be the
    one in the `B` trait and the output will be `Hello, I am trait B!` This depends
    on linearization in Scala, and we will be looking at this later in this chapter.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 将调用哪个 `hello` 方法，为什么？在当前情况下，它将是 `B` 特性中的那个，输出将是 `Hello, I am trait B!` 这取决于
    Scala 中的线性化，我们将在本章后面探讨这个问题。
- en: Same signatures and different return types mixins
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 相同签名和不同返回类型的 mixins
- en: 'As expected, the previous problem does not exist when input parameters to the
    methods differ either by type or by count since this is a new signature. However,
    the problem will still be there if we have the following two methods in our traits:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 预期之中，当方法输入参数的类型或数量不同，形成新的签名时，之前的问题就不存在了。然而，如果我们在我们 traits 中有如下两个方法，问题仍然存在：
- en: '[PRE21]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'You will be surprised to see that the approach we used will not work here.
    If we decide to override only the value method in the `A` trait, we will get the
    following compilation error:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会惊讶地发现，我们之前使用的方法在这里不起作用。如果我们决定只覆盖 `A` 特性中的 `value` 方法，我们将得到以下编译错误：
- en: '[PRE22]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: If we override the `value` method in the `B` trait, the error will change respectively.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在 `B` 特性中覆盖 `value` 方法，错误将相应地改变。
- en: 'If we try and override both, then the error will be as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试同时覆盖它们，错误将如下所示：
- en: '[PRE23]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This shows that Scala actually prevents us from doing some dangerous things
    that can occur in multiple inheritance. For the sake of completeness, if you face
    a similar issue, there is a workaround (by sacrificing the mix in functionality).
    It will look as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明 Scala 实际上阻止我们做一些在多重继承中可能发生的危险操作。为了完整性，如果您遇到类似问题，有一个解决方案（牺牲混合功能）。它看起来如下：
- en: '[PRE24]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The preceding code uses traits as collaborators, but it also loses the fact
    that the class that uses them is also an instance of the trait type, which can
    be useful for other operations as well.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码使用 traits 作为协作者，但它也失去了使用它们的类也是 trait 类型的实例这一事实，这对于其他操作也可能很有用。
- en: Multiple inheritance
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多重继承
- en: We inevitably had to mention multiple inheritance in the previous sections due
    to the fact that we can mix multiple traits and they can all have their own implementations
    of the methods. Multiple inheritance is not only a powerful technique, but also
    a dangerous one, and some languages such as Java have decided to not even allow
    it. As we already saw, Scala allows this, but with some limitations. In this subsection,
    we will present the problems of multiple inheritance and show how Scala deals
    with them.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们可以混合多个 traits，并且它们都有自己的方法实现，我们不可避免地要在前面的章节中提到多重继承。多重继承不仅是一种强大的技术，也是一种危险的技术，一些语言如
    Java 甚至决定不允许它。正如我们已经看到的，Scala 允许这样做，但有一些限制。在本小节中，我们将介绍多重继承的问题，并展示 Scala 如何处理这些问题。
- en: The diamond problem
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 钻石问题
- en: Multiple inheritance suffers from the **diamond problem**.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 多重继承受到 **钻石问题** 的困扰。
- en: 'Let''s have a look at the following diagram:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下以下图表：
- en: '![](img/4440c811-73f7-4033-8106-54ec31594489.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4440c811-73f7-4033-8106-54ec31594489.png)'
- en: Here, both **B** and **C** extend **A**, and then **D** extends **B** and **C**.
    Some ambiguities might arise from this. Let's say that there was a method that
    was originally defined in **A**, but both **B** and **C** override it. What would
    happen if **D** calls this method? Which one will it exactly call?
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，**B** 和 **C** 都扩展了 **A**，然后 **D** 扩展了 **B** 和 **C**。这种情况下可能会出现一些歧义。假设有一个原本在
    **A** 中定义的方法，但 **B** 和 **C** 都覆盖了它。如果 **D** 调用这个方法，会发生什么？它到底会调用哪一个？
- en: 'All the preceding questions make things ambiguous and this could lead to mistakes.
    Let''s try and reproduce this in Scala using traits:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的前一个问题都使事情变得模糊，这可能导致错误。让我们尝试在 Scala 中使用 traits 重新创建这个问题：
- en: '[PRE25]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'What would be the output of the program? Here is the output:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的输出会是什么？以下是输出：
- en: '[PRE26]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'What if we just change the `D` trait to look as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只改变 `D` 特性如下所示：
- en: '[PRE27]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Then the output of our program will be as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们程序的输出将如下所示：
- en: '[PRE28]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: As you can see, even though the example is still ambiguous and prone to errors,
    we can actually tell exactly which method will be called. This is achieved using
    linearization, which we will look at in greater depth in the next section.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，尽管示例仍然存在歧义且容易出错，我们实际上可以确切地知道哪个方法会被调用。这是通过线性化实现的，我们将在下一节更深入地探讨。
- en: The limitations
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 限制
- en: Before focusing on linearization, let's point out the multiple inheritance limitations
    that Scala imposes. We already saw many of them before, so here we will simply
    summarize them.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在专注于线性化之前，让我们指出 Scala 施加的多重继承限制。我们之前已经看到了很多，所以在这里我们只是简单地总结它们。
- en: Scala multiple inheritance limitations
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Scala 多重继承限制
- en: Multiple inheritance in Scala is achieved using traits and it follows the rules
    of linearization.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: Scala 中多重继承是通过 traits 实现的，并且遵循线性化规则。
- en: In the inheritance hierarchy, if there is a trait that explicitly extends a
    class, the class that mixes in this trait must also be a subclass of the trait
    parent. This means that when mixing in traits that extend classes, they must all
    have the same parent.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在继承层次结构中，如果一个特性显式地扩展了一个类，那么混入这个特性的类也必须是特性父类的子类。这意味着当混入扩展类的特性时，它们都必须有相同的父类。
- en: It is not possible to mix traits in, which define or declare methods with the
    same signatures, but different return types.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 无法混入定义或声明具有相同签名但不同返回类型的函数的特性。
- en: Special care has to be taken when multiple traits define methods with the same
    signatures and return types. In cases where the methods are declared and expected
    to be implemented, this is not an issue and only one implementation is enough.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 当多个特性定义了具有相同签名和返回类型的函数时，必须特别小心。在方法被声明并预期实现的情况下，这不是问题，只有一个实现就足够了。
- en: Linearization
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线性化
- en: As we already saw, traits offer a form of multiple inheritance. In such cases,
    the hierarchy is not necessarily linear, but forms an acyclic graph that needs
    to be flattened upon compilation. What linearization does is this—it specifies
    a single linear order for all of the ancestors of a class, including both the
    regular superclass chain and the parent chains of all of the traits.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经看到的，特性提供了一种多继承的形式。在这种情况下，层次结构不一定是线性的，而是一个需要编译时展开的无环图。线性化所做的就是这个——它为类的所有祖先指定一个单一的线性顺序，包括常规的超类链和所有特性的父链。
- en: 'We will not have to deal with linearization in traits that contain no code.
    However, if we use mixins, we will have to consider it. The following will be
    affected by linearization:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要处理那些不包含代码的特性的线性化。然而，如果我们使用混入（mixins），我们就必须考虑它。以下内容会受到线性化的影响：
- en: Method definitions
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法定义
- en: Variables (both mutable—`var` and immutable—`val`)
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量（包括可变变量—`var`和不可变变量—`val`）
- en: We already saw a simple example of linearization previously. Things, however,
    can get much more complicated and unexpected if the rules of linearization are
    not clear.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前已经看到了线性化的一个简单例子。然而，如果线性化的规则不清楚，事情可能会变得非常复杂和出乎意料。
- en: Rules of inheritance hierarchies
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 继承层次结构的规则
- en: 'Before looking into linearization rules, we need to be clear on some inheritance
    rules in Scala:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在探讨线性化规则之前，我们需要清楚Scala中的一些继承规则：
- en: In Java, even if a class does not explicitly extend another one, its superclass
    will be `java.lang.Object`. The same stands for Scala, and the equivalent base
    is `AnyRef`.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Java中，即使一个类没有显式地扩展另一个类，它的超类也将是`java.lang.Object`。在Scala中也是如此，等效的基类是`AnyRef`。
- en: There is a similarity between directly extending a trait and extending the trait
    superclass and mixing the trait in using the `with` keyword.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 直接扩展特性和扩展特性超类并使用`with`关键字混入特性之间存在相似性。
- en: In older Scala versions, there was another type called `ScalaObject` that was
    implicitly added to all traits and classes.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在较老的Scala版本中，还有一个名为`ScalaObject`的类型，它被隐式添加到所有特性和类中。
- en: Using those rules, we can always get to a canonical form for all traits and
    classes, where the base class is specified using `extends` and then all traits
    are added using the `with` keyword.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些规则，我们可以为所有特性和类始终得到一个规范形式，其中基类使用`extends`指定，然后使用`with`关键字添加所有特性。
- en: Linearization rules
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线性化规则
- en: 'Linearization rules in Scala are defined and exist in order to ensure well-defined
    behavior. The rules state the following:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: Scala中的线性化规则被定义并存在是为了确保有定义的行为。规则如下：
- en: The linearization of any class must include the unmodified linearization of
    any *class* (but not trait) that it extends.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何类的线性化都必须包括它所扩展的任何未修改的线性化类（但不是特性）。
- en: The linearization of any class must include all the classes and mixin traits
    in the linearization of any *trait* it extends, but the mixin traits are not bound
    to appear in the same order as they appear in the linearization of the traits
    being mixed in.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何类的线性化都必须包括它所扩展的任何特性的线性化中的所有类和混入特性，但混入特性并不绑定以与它们在混入的特性中的线性化中出现的相同顺序出现。
- en: Each class or trait in the linearization can appear only once. Duplicates are
    ignored.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线性化中的每个类或特性只能出现一次。重复项将被忽略。
- en: We already saw in some of the previous examples that it is not possible to mix
    in traits that have different base classes or to mix in a trait into a class when
    their base classes differ.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的某些例子中，我们已经看到，无法将具有不同基类的特性混入，或者当它们的基类不同时，将特性混入类中。
- en: How linearization works
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线性化是如何工作的
- en: In Scala, linearizations are listed from left to right where the right-most
    class is the most general, for example, `AnyRef`. While doing linearization, `Any`
    is also added to the hierarchy list. This, combined with the rule that any class
    must include the linearization of its superclass, means that the superclass linearization
    will appear as a suffix of the class linearization.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在Scala中，线性化是从左到右列出的，最右侧的类是最一般的，例如，`AnyRef`。在进行线性化时，`Any`也会被添加到层次列表中。这，加上任何类都必须包含其超类线性化的规则，意味着超类线性化将作为类线性化的后缀出现。
- en: 'Let''s see an example with some really simple classes:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一些非常简单的类来举一个例子：
- en: '[PRE29]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The linearization of these two classes will be, respectively:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个类的线性化分别是：
- en: '[PRE30]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, let''s try and formalize an algorithm that describes how a linearization
    is calculated:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试形式化一个描述如何计算线性化的算法：
- en: Start with the following class declaration—`class A extends B with T1 with T2`.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从以下类声明开始——`class A extends B with T1 with T2`。
- en: Reverse the order of the list except the first item and drop the keywords. This
    way, the superclass will come as a suffix—`A T2 T1 B`.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 逆序排列列表（除了第一个项目），并丢弃关键字。这样，超类将作为后缀出现——`A T2 T1 B`。
- en: Each item gets replaced with its linearization—`A T2L T1L BL`.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个元素都被替换为其线性化形式——`A T2L T1L BL`。
- en: 'Concatenate the list elements using the right-associative concatenation operation:
    `A +: T2L +: T1L +: BL`.'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '使用右结合的连接操作符连接列表元素：`A +: T2L +: T1L +: BL`。'
- en: 'Append the standard `AnyRef` and `Any` classes—`A +: T2L +: T1L +: BL +: AnyRef
    +: Any`.'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '添加标准的`AnyRef`和`Any`类——`A +: T2L +: T1L +: BL +: AnyRef +: Any`。'
- en: Evaluate the preceding expression. Due to the right-associative concatenation,
    we start from the right and move to the left. In each step, we remove any element
    that has already appeared on the right-hand side. In our case, when we get to
    `BL`, we will not add `AnyRef` and `Any` that it also contains; we will just add
    `BL` and then we will continue. At `T1L`, we will skip the step to add anything
    that was added before and so on, until we reach `A`.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 评估前面的表达式。由于右结合的连接操作，我们从右向左开始。在每一步中，我们移除任何已经出现在右侧的元素。在我们的例子中，当我们到达`BL`时，我们不会添加它所包含的`AnyRef`和`Any`；我们只添加`BL`然后继续。在`T1L`时，我们将跳过添加之前已经添加的任何元素的步骤，以此类推，直到我们到达`A`。
- en: In the end, after the linearization finishes, we will have a list of classes
    and traits without duplicates.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在完成线性化之后，我们将得到一个不包含重复的类和特质的列表。
- en: Initialization
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 初始化
- en: Now that we know what happens during linearization, we will understand how instances
    are being created. The rule is that the constructor code is executed in a reverse
    order compared to the linearization order. This means that, going from right to
    left, first the `Any` and `AnyRef` constructors will be invoked and then the actual
    class constructor will be called. Also, the superclass constructor will be called
    before the actual class or any of its mixins because, as we have already mentioned
    previously, it is added as a suffix.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了线性化过程中发生了什么，我们将理解实例是如何被创建的。规则是，构造函数代码的执行顺序与线性化顺序相反。这意味着，从右到左，首先将调用`Any`和`AnyRef`构造函数，然后调用实际的类构造函数。此外，将先调用超类构造函数，然后调用实际的类或其任何mixin，因为我们已经提到过，它作为后缀被添加。
- en: Keeping in mind that we traverse the linearization from right to left also means
    that after the superclass constructor is called, the mixin trait constructors
    will be called. Here, they will be called in the order in which they appear in
    the original class definition (because of the right to left direction and the
    fact that their order is reversed when the linearization is created).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，我们是从右到左遍历线性化，这也意味着在调用超类构造函数之后，将调用mixin特质构造函数。在这里，它们将按照它们在原始类定义中出现的顺序被调用（因为右到左的方向以及它们在创建线性化时顺序被反转）。
- en: Method overriding
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 方法重写
- en: When overriding a method in a subclass, you may want to call the original implementation
    as well. This is achieved by prefixing the `super` keyword to the method name.
    The developer also has control to qualify the `super` keyword with a trait type,
    thus calling the method in the specific trait. We already saw an example of this
    earlier in the chapter, where we called `super[A].hello()`. In that example, we
    had mixins with the same methods; however, the methods themselves did not refer
    to `super`, but just defined their own implementations.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 当在子类中覆盖一个方法时，你可能想同时调用原始实现。这是通过在方法名前缀`super`关键字来实现的。开发者还可以控制使用特质类型来限定`super`关键字，从而调用特定特质中的方法。我们在本章前面已经看到了一个这样的例子，其中我们调用了`super[A].hello()`。在那个例子中，我们具有具有相同方法的mixins；然而，这些方法本身并没有引用`super`，而是只定义了自己的实现。
- en: 'Let''s see an example here, where we actually refer to the `super` class when
    overriding a method:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在这里看一个例子，其中我们实际上在覆盖方法时引用了`super`类：
- en: '[PRE31]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Let''s now define two traits that respectively double and triple the identity
    in our original class:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们定义两个特质，分别将原始类中的身份值加倍和三倍：
- en: '[PRE32]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'As we saw in some of the previous examples, the order in which we mix in the
    traits matters. We will provide three implementations, where we first mix in `DoubledMultiplierIdentity`
    and then `TripledMultiplierIdentity`. The first one will not override the identity
    method, which is equivalent to using the following super notation: `super.identity`.
    The other two will override the method and will refer to a specific parent:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在一些先前的例子中所看到的，我们混合特质的顺序很重要。我们将提供三种实现，首先混合`DoubledMultiplierIdentity`然后是`TripledMultiplierIdentity`。第一个不会覆盖身份方法，这相当于使用以下super表示法：`super.identity`。其他两个将覆盖该方法，并将引用特定的父类：
- en: '[PRE33]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Let''s do the same thing as shown in the preceding code, but this time, we
    first mix in `TripledMultiplierIdentity` and then `DoubledMultiplierIdentity`.
    The implementations are similar to the preceding ones:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们像前面代码中展示的那样做同样的事情，但这次，我们首先混合`TripledMultiplierIdentity`然后是`DoubledMultiplierIdentity`。实现与前面的类似：
- en: '[PRE34]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Finally, let''s use our classes:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们使用我们的类：
- en: '[PRE35]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The example shows a multiple inheritance hierarchy, where we can see a diamond
    relationship exactly as in the previous figure in which we explained what it means.
    We have all the possibilities here in terms of the order of mixing `DoubledMultiplier`
    and `TripledMultiplier`, as well as how we call the identity base method.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子展示了一个多重继承层次结构，我们可以看到与前面图中解释的钻石关系完全一样。在这里，我们有所有可能的混合`DoubledMultiplier`和`TripledMultiplier`的顺序，以及我们如何调用身份基方法。
- en: 'So, what would the output of this program be? One would expect that in the
    cases where we don''t override the identity method, it would call the identity
    method of the right-most trait. Since in both the cases they call the super method
    of the class they extend, the results should be `2` and `3`. Let''s see this here:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这个程序的输出会是什么？人们可能会预期，在我们没有覆盖身份方法的情况下，它会调用最右侧特质的身份方法。由于在这两种情况下它们都调用了它们扩展的类的super方法，结果应该是`2`和`3`。让我们在这里看看：
- en: '[PRE36]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The preceding output is rather unexpected. This is, however, how the Scala type
    system works. In the case of linearization, where we have a multiple inheritance,
    the calls to the same method are chained from right to left according to the order
    of the appearance of the traits in the class declaration. Note that if we did
    not use the super notation, we would have broken the chain, as can be seen in
    some of the preceding examples.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的输出相当令人意外。然而，这正是Scala类型系统的工作方式。在多重继承的线性化情况下，对相同方法的调用是从右到左根据特质在类声明中出现的顺序链式调用的。请注意，如果我们没有使用super表示法，我们就会打破这个链，正如我们可以在一些先前的例子中看到的那样。
- en: The previous example is rather amusing and proves how important it is to know
    the rules of linearization and how linearization works. Not being aware of this
    feature could result in a serious pitfall, which could lead to critical mistakes
    in your code.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的例子相当有趣，证明了了解线性化规则以及线性化是如何工作的重要性。不了解这个特性可能会导致严重的陷阱，这可能导致代码中的关键错误。
- en: My advice would still be to try and avoid cases of diamond inheritance, even
    though one can argue that this way, some quite complex systems can be implemented
    seamlessly and without writing too much code. A case such as the preceding one
    could make the programs really hard to read and maintain in the future.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: You should be aware that linearization exists everywhere in Scala—not just when
    dealing with traits. This is just how the Scala-type system works. This means
    that it is a good idea to be aware of the order in which constructors are called
    in order to avoid mistakes and generally, to try and keep the hierarchies relatively
    simple.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: Testing traits
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Testing is a really important part of software development. It ensures that
    changes to a certain piece of code do not end up producing errors either in the
    methods that were changed, or somewhere else.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: There are different testing frameworks that one can use, and it really is a
    matter of personal preference. In this book, we have used **ScalaTest** ([http://www.scalatest.org](http://www.scalatest.org)),
    as this is the one I use in my projects; it is understandable, readable, and easy
    to use.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: In some cases, if a trait is mixed into a class, we could end up testing the
    class. However, we might want to test only a specific trait. It does not make
    much sense to test a trait that doesn't have all its methods implemented, so here
    we will look into the ones that have their code written (mixins). Also, the unit
    tests that we will show here are quite simple, but they are just for illustration
    purposes. We will be looking into more complex and meaningful tests in the following
    chapters of this book.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: Using a class
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s have a look at how `DoubledMultiplierIdentity`, which we saw previously,
    would be tested. One would try to simply mix the trait into a test class and test
    the methods:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This, however, won''t compile and will lead to the following error:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We already talked about this before and the fact that a trait can only be mixed
    in a class that has the same super class as itself. This means that in order to
    test the trait, we should create a dummy class inside our test class and then
    use it:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Mixing the trait in
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can test a trait by mixing it in. There are a few places where we can do
    this—into a test class or into separate test cases.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: Mixing into the test class
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mixing in a trait into a test class is only possible if the trait does not extend
    any other class explicitly, hence the super class of the trait and the test will
    be the same. Other than this, everything else is absolutely the same as done previously.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s test the `A` trait from earlier in this chapter, which says `hello`.
    We''ve also added an extra `pass` method, and now the trait looks as follows:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This is what the unit test will look like:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Mixing into the test cases
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can also mix traits into the individual test cases separately. This could
    allow us to apply customizations specific to those test cases only. The following
    is just a different representation of the preceding unit test:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以将特性分别混合到单个测试用例中。这可能允许我们只为这些测试用例应用特定的定制化。以下是对前面单元测试的不同表示：
- en: '[PRE42]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: As you can see in the preceding code, the test cases are identical to the previous
    ones. They, however, individually mix `A` in. This would allow us to apply different
    customizations in the cases where a trait requires an implementation of a method
    or a variable initialization. This way, we can also focus specifically on the
    trait being tested, rather than creating actual instances of it.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码所示，测试用例与之前的相同。然而，它们各自混合了 `A`。这使我们能够针对需要方法实现或变量初始化的特性应用不同的定制化。这样，我们也可以专注于正在测试的特性，而不是创建其实例。
- en: Running the tests
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行测试
- en: 'After the tests are written, it is useful to run them in order to see whether
    everything works as expected. If you''re using Maven, just run the following command
    from the root of your project and it will execute all the tests:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写测试之后，运行它们以查看是否一切按预期工作是有用的。如果你使用 Maven，只需从项目的根目录运行以下命令，它将执行所有测试：
- en: '[PRE43]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'If you''re using SBT, then the tests can be triggered using the following command:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用 SBT，则可以使用以下命令触发测试：
- en: '[PRE44]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Traits versus classes
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 特性 versus 类
- en: Traits could be similar, but also very different to classes. It could be hard
    for a developer to choose which one to use in various cases, but here we will
    try to provide some general guidelines that should help.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 特性可能与类相似，但也可能非常不同。对于开发者来说，在各种情况下选择使用哪一个可能很困难，但在这里我们将尝试提供一些一般性指南，这些指南应该会有所帮助。
- en: '**Use classes**:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用类**：'
- en: When a behavior is not going to be reused at all or in multiple places
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当一种行为根本不会在多个地方重用时
- en: When you plan to use your Scala code from another language, for example, if
    you are building a library that could be used in Java
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你计划从其他语言使用你的 Scala 代码时，例如，如果你正在构建一个可以在 Java 中使用的库
- en: '**Use traits**:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用特性**：'
- en: When a behavior is going to be reused in multiple unrelated classes.
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当一种行为将在多个不相关的类中重用时。
- en: When you want to define interfaces and want to use them outside Scala, for example,
    Java. The reason is that the traits that do not have any implementations are compiled
    similar to interfaces.
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你想定义接口并希望在 Scala 之外使用它们时，例如，Java。原因是没有任何实现的特性被编译得类似于接口。
- en: Summary
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we went through traits and mixin compositions in Scala. By
    now, you should have a good understanding of what these are and what can be achieved
    by using them. We also went through the examples of the different uses of traits
    and what to watch out for when using them. We presented the limitations of using
    traits for multiple inheritance. Traits are an extremely powerful concept, but
    they have their pitfalls as we saw with multiple inheritance, so you should use
    them carefully. Linearization was covered in depth and you should be familiar
    with what to expect when using traits for multiple inheritance and why things
    work exactly the way they currently do.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了 Scala 中的特性和混入组合。到现在，你应该对它们是什么以及使用它们可以实现什么有很好的理解。我们还探讨了特性的不同用法示例以及在使用它们时需要注意的事项。我们介绍了使用特性进行多重继承的限制。特性是一个非常强大的概念，但正如我们在多重继承中看到的那样，它们也有其陷阱，因此你应该谨慎使用。线性化被深入讨论，你应该熟悉使用特性进行多重继承时可以期待什么，以及为什么事情会以当前的方式工作。
- en: Testing is an essential part of every good software project, and we also presented
    how it should be done for traits. Last, but not least, we prepared a few guidelines
    that should help developers choose between working with traits or classes in Scala.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 测试是每个优秀软件项目的必要部分，我们也介绍了如何为特性进行测试。最后，但同样重要的是，我们准备了一些指南，这些指南应该有助于开发者选择在 Scala
    中使用特性或类。
- en: In the next chapter, we will spend some time on **unification**. We will show
    why it is useful and what it helps the developer to achieve in their programs.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将花一些时间讨论**统一**。我们将展示为什么它是有用的，以及它如何帮助开发者实现他们的程序。
