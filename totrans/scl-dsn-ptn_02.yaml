- en: Traits and Mixin Compositions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before digging into some actual design patterns, we have to make sure that many
    of the Scala language concepts are clear to the reader. Many of those concepts
    will later be used in implementing the actual design patterns, and being aware
    of the possibilities, limitations, and pitfalls are key factors that enable us
    to correctly and efficiently write code. Even though those concepts are not considered
    *official* design patterns, they could still be used to write good software. In
    some cases, due to the richness of Scala, some concepts could replace a design
    pattern by just using language features. After all, as we have already said before,
    design patterns are there because a programming language lacks features and is
    not rich enough to complete certain tasks.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first topic that we will look into is about traits and mixin compositions.
    They provide the developer with a possibility to share already implemented functionality
    or to define interfaces for classes in an application. Many of the possibilities,
    which are provided by traits and mixin compositions for developers, are useful
    to implement some of the design patterns that we will focus on later in this book.
    We will go through the following main topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Traits
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mixin compositions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiple inheritance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Linearization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing traits
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Traits versus classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Traits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many of you might have different perspectives of traits in Scala. They can be
    viewed not only as interfaces in other languages, but also as classes with only
    parameter-less constructors.
  prefs: []
  type: TYPE_NORMAL
- en: Trait parameters
  prefs: []
  type: TYPE_NORMAL
- en: The Scala programming language is quite dynamic and has evolved quickly throughout
    the years. According to the language creators, the Dotty project is the future
    of Scala and it is a place where passing parameters to traits and many other features
    are being tested and implemented. The main idea behind it is language simplification,
    and more information can be found at [http://dotty.epfl.ch](http://dotty.epfl.ch)
    and [https://scala-lang.org/blog/2017/05/31/first-dotty-milestone-release.html](https://scala-lang.org/blog/2017/05/31/first-dotty-milestone-release.html).
  prefs: []
  type: TYPE_NORMAL
- en: In the following few sections, we will see the traits from different points
    of view and try to give you some ideas about how they can be used.
  prefs: []
  type: TYPE_NORMAL
- en: Traits as interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Traits can be viewed as interfaces in other languages, for example, Java. However
    they, allow the developers to implement some or all of their methods. Whenever
    there is some code in a trait, the trait is called a **mixin**. Let''s have a
    look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Here, `Alarm` is an interface. Its only method, `trigger`, does not have any
    implementation and if mixed in a non-abstract class, an implementation of the
    method will be required.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see another trait example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `Notifier` interface shown previously has one of its methods implemented,
    and `clear` and the value of `notificationMessage` have to be handled by the classes
    that will mix with the `Notifier` interface. Moreover, the traits can require
    a class to have a specific variable inside it. This is somewhat similar to abstract
    classes in other languages.
  prefs: []
  type: TYPE_NORMAL
- en: Mixing in traits with variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we just pointed out, traits might require a class to have a specific variable.
    An interesting use case would be when we pass a variable to the constructor of
    a class. This will cover the trait requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The only requirement here is for the variable to have the same name and to
    be preceded by the `val` keyword in the class definition. If we don''t use `val`
    in front of the parameter in the preceding code, the compiler would still ask
    us to implement the trait. In this case, we would have to use a different name
    for the class parameter and would have an `override val notificationMessage` assignment
    in the class body. The reason for this behavior is simple: if we explicitly use
    `val` (or `var`), the compiler will create a field with a getter with the same
    scope as the parameter. If we just have the parameter, a field and internal getter
    will be created only if the parameter is used outside the constructor scope, for
    example, in a method. For completeness, case classes automatically have the `val`
    keyword *prepended* to parameters. After what we said it means that when using
    `val`, we actually have a field with the given name and the right scope, and it
    will automatically override whatever the trait requires us to do.'
  prefs: []
  type: TYPE_NORMAL
- en: Traits as classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Traits can also be seen from the perspective of classes. In this case, they
    have to implement all their methods and have only one constructor that does not
    accept any parameters. Consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can actually instantiate `Beeper` and call its method. The following
    is a console application that does just this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'As expected, after running the application, we will see the following output
    in our Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Extending classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It is possible for traits to extend classes. Let''s have a look at the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Here, as expected, `PgSqlConnector` will be obliged to implement the abstract
    class methods. As you can guess, we could have other traits that extend other
    classes and then we might want to mix them in. Scala, however, will put a limit
    in some cases, and we will see how it will affect us later in this chapter when
    we look at compositions.
  prefs: []
  type: TYPE_NORMAL
- en: Extending traits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Traits can also extend each other. Have a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example is simple and it should really just make the `Runner`
    object mix the two traits separately. Extending traits is useful in a design pattern
    called **Stackable Traits**, which we will be looking into later in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Mixin compositions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Scala allows developers to extend many traits in a single class. This adds the
    possibility of achieving multiple inheritance and saves a lot of effort in code
    writing, which has to be performed in languages where extending many classes is
    not allowed. In this subtopic, we will show how traits can be mixed in a specific
    class or used to create anonymous classes with some specific functionality while
    writing our code.
  prefs: []
  type: TYPE_NORMAL
- en: Mixing traits in
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First of all, let''s modify the code from the previous example. It is a really
    simple change and it will also show exactly how traits can be mixed in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: As can be seen from the preceding code, we can add multiple traits to a class.
    We've used objects in the example just because of the main method. This would
    be similar to creating a class with no constructor parameters (objects in Scala
    are singleton classes).
  prefs: []
  type: TYPE_NORMAL
- en: How to mix traits in?
  prefs: []
  type: TYPE_NORMAL
- en: 'Mixing traits into a class is done with the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '`extends T1 with T2 with … with Tn`.'
  prefs: []
  type: TYPE_NORMAL
- en: If a class already extends another class, we just keep on adding the traits
    using the `with` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: If a trait method is not implemented inside the trait body and the class we
    are mixing it into is not abstract, the class will have to implement the trait.
    Otherwise, a compilation error will occur.
  prefs: []
  type: TYPE_NORMAL
- en: Composing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Composing at creation time gives us an opportunity to create anonymous classes
    without the need to explicitly define them. Also, if there are many different
    traits that we might want to combine, creating all the possibilities would involve
    too much work, so this helps make things easier for us.
  prefs: []
  type: TYPE_NORMAL
- en: Composing simple traits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s see an example where we compose simple traits, which do not extend other
    traits or classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we used the `Alarm` and `Notifier` traits from before.
    We created two watch instances—one is expensive that has more functionality and
    is more useful, and the other one is a cheap one that does not give too much control.
    Essentially, they are anonymous classes, which are defined during instantiation.
    Another thing to note is that, as expected, we have to implement the abstract
    methods from the traits we include. I hope this gives you an idea of how many
    combinations there might be in the cases where we have more traits.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just for the sake of completeness, here is an example output of the preceding
    program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: As expected, the highlighted time value will be different in the different runs.
  prefs: []
  type: TYPE_NORMAL
- en: Composing complex traits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It is possible that in some cases, we would have to compose more complex traits,
    which extend other traits or classes. If a trait and no other trait up the inheritance
    chain extends a specific class explicitly, then things will be pretty simple and
    they don''t change much. In this case, we would simply have access to the methods
    from the super traits. However, let''s see what happens if any of the traits in
    the hierarchy extend a specific class. For the next example, we will be using
    the `ConnectorWithHelper` trait defined previously. This trait extends the abstract
    `Connector` class. Imagine that we want to have another really expensive smart
    watch, which can also connect to a database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'It seems that everything is fine; however, when we compile, we get the following
    error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This error message tells us that since the `ConnectorWithHelper` trait extends
    the `Connector` class, all the classes that use this trait for composition must
    be subclasses of `Connector`. Let's now imagine that we wanted to mix in another
    trait that also extends a class, but a different one in this case. According to
    the preceding logic, it will be required that `Watch` should also be a subclass
    of the other class. This, however, wouldn't be possible, as we can only extend
    one class at a time and this is how Scala limits multiple inheritance in order
    to prevent dangerous errors from happening.
  prefs: []
  type: TYPE_NORMAL
- en: If we want to fix the compilation issue in the example, we will have to modify
    the original `Watch` class and make sure it is a subclass of `Connector`. This,
    however, might not be desired and some refactoring might be needed in such cases.
  prefs: []
  type: TYPE_NORMAL
- en: Composing with self-types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous subsection, we saw how we were forced to extend `Connector`
    in our `Watch` class in order to properly compile our code. There are cases where
    we might actually want to enforce a trait to be mixed into a class that also has
    another trait or multiple traits mixed into it. Let''s imagine that we want to
    have an alarm that must be able to notify us, no matter what:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we've shown a **self-type**. The highlighted piece of
    code brings all the methods of `Notifier` to the scope of our new trait and it
    also requires that any class that mixes in `AlarmNotifier` should also mix in
    `Notifier`. Otherwise, a compilation error will occur. Instead of this, we can
    use `self` and then refer to the `Notifier` methods inside `AlarmNotifier` by
    typing, for example, `self. printNotification()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code is an example of how to use the new trait:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: If we comment out the `watch` variable in the preceding code and uncomment the
    commented bit, we will see a compilation error that is raised due to the fact
    that we must also mix `Notifier` in.
  prefs: []
  type: TYPE_NORMAL
- en: In this subsection, we showed a simple use of self-types. One trait can require
    multiple other traits to be mixed in. In such cases, they are just separated with
    the `with` keyword. Self-types are a key part of the **cake design pattern**,
    which is used for dependency injection. We will see more interesting use cases
    later in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Clashing traits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some of you might already have a question in your mind—what if we mix in traits
    that have methods with identical signatures? We will look at this in the next
    few sections.
  prefs: []
  type: TYPE_NORMAL
- en: Same signatures and return types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Consider an example where we want to mix two traits into a class and their
    declaration of a method is identical:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, the greeter is always polite and mixes both formal
    and informal greetings. While implementing, it just has to implement the method
    once.
  prefs: []
  type: TYPE_NORMAL
- en: Same signatures and different return types traits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'What if our greeting traits have more methods that have the same signatures,
    but a different return type? Let''s add the following declaration to `FormalGreeting`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, add the following to `InformalGreeting`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We will have to implement these in our `Greeter` class. However, the compiler
    will not allow us the message that `getTime` was defined twice in, which shows
    that Scala prevents such things from happening.
  prefs: []
  type: TYPE_NORMAL
- en: Same signatures and return types mixins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before going further, a quick reminder that a mixin is just a trait that has
    some code implemented inside. This means that in the following examples, we do
    not have to implement the methods inside the class that uses them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Probably as expected, our compilation will fail with the following message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The message is useful and it even gives us a hint about how to fix the problem.
    Clashing methods is a problem in multiple inheritances, but as you can see, we
    are forced to pick one of the available methods. Here is a possible fix inside
    the `Clashing` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: However, what if we want to use both the `hello` methods for some reason? In
    this case, we can create other methods that are named differently and call the
    specific traits as in the preceding example (the `super` notation). We can also
    directly refer to the methods with the `super` notation instead of wrapping them
    in a method. My personal preference, though, would be to wrap it, as the code
    could get messy otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: The super notation
  prefs: []
  type: TYPE_NORMAL
- en: 'What would happen if in the preceding example, instead of `super[A]. hello()`,
    we do the following: `override def hello(): String = super.hello()`?'
  prefs: []
  type: TYPE_NORMAL
- en: Which hello method will be called and why? In the current case, it will be the
    one in the `B` trait and the output will be `Hello, I am trait B!` This depends
    on linearization in Scala, and we will be looking at this later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Same signatures and different return types mixins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As expected, the previous problem does not exist when input parameters to the
    methods differ either by type or by count since this is a new signature. However,
    the problem will still be there if we have the following two methods in our traits:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'You will be surprised to see that the approach we used will not work here.
    If we decide to override only the value method in the `A` trait, we will get the
    following compilation error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: If we override the `value` method in the `B` trait, the error will change respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we try and override both, then the error will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'This shows that Scala actually prevents us from doing some dangerous things
    that can occur in multiple inheritance. For the sake of completeness, if you face
    a similar issue, there is a workaround (by sacrificing the mix in functionality).
    It will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code uses traits as collaborators, but it also loses the fact
    that the class that uses them is also an instance of the trait type, which can
    be useful for other operations as well.
  prefs: []
  type: TYPE_NORMAL
- en: Multiple inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We inevitably had to mention multiple inheritance in the previous sections due
    to the fact that we can mix multiple traits and they can all have their own implementations
    of the methods. Multiple inheritance is not only a powerful technique, but also
    a dangerous one, and some languages such as Java have decided to not even allow
    it. As we already saw, Scala allows this, but with some limitations. In this subsection,
    we will present the problems of multiple inheritance and show how Scala deals
    with them.
  prefs: []
  type: TYPE_NORMAL
- en: The diamond problem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Multiple inheritance suffers from the **diamond problem**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have a look at the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4440c811-73f7-4033-8106-54ec31594489.png)'
  prefs: []
  type: TYPE_IMG
- en: Here, both **B** and **C** extend **A**, and then **D** extends **B** and **C**.
    Some ambiguities might arise from this. Let's say that there was a method that
    was originally defined in **A**, but both **B** and **C** override it. What would
    happen if **D** calls this method? Which one will it exactly call?
  prefs: []
  type: TYPE_NORMAL
- en: 'All the preceding questions make things ambiguous and this could lead to mistakes.
    Let''s try and reproduce this in Scala using traits:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'What would be the output of the program? Here is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'What if we just change the `D` trait to look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Then the output of our program will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, even though the example is still ambiguous and prone to errors,
    we can actually tell exactly which method will be called. This is achieved using
    linearization, which we will look at in greater depth in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: The limitations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before focusing on linearization, let's point out the multiple inheritance limitations
    that Scala imposes. We already saw many of them before, so here we will simply
    summarize them.
  prefs: []
  type: TYPE_NORMAL
- en: Scala multiple inheritance limitations
  prefs: []
  type: TYPE_NORMAL
- en: Multiple inheritance in Scala is achieved using traits and it follows the rules
    of linearization.
  prefs: []
  type: TYPE_NORMAL
- en: In the inheritance hierarchy, if there is a trait that explicitly extends a
    class, the class that mixes in this trait must also be a subclass of the trait
    parent. This means that when mixing in traits that extend classes, they must all
    have the same parent.
  prefs: []
  type: TYPE_NORMAL
- en: It is not possible to mix traits in, which define or declare methods with the
    same signatures, but different return types.
  prefs: []
  type: TYPE_NORMAL
- en: Special care has to be taken when multiple traits define methods with the same
    signatures and return types. In cases where the methods are declared and expected
    to be implemented, this is not an issue and only one implementation is enough.
  prefs: []
  type: TYPE_NORMAL
- en: Linearization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we already saw, traits offer a form of multiple inheritance. In such cases,
    the hierarchy is not necessarily linear, but forms an acyclic graph that needs
    to be flattened upon compilation. What linearization does is this—it specifies
    a single linear order for all of the ancestors of a class, including both the
    regular superclass chain and the parent chains of all of the traits.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will not have to deal with linearization in traits that contain no code.
    However, if we use mixins, we will have to consider it. The following will be
    affected by linearization:'
  prefs: []
  type: TYPE_NORMAL
- en: Method definitions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Variables (both mutable—`var` and immutable—`val`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We already saw a simple example of linearization previously. Things, however,
    can get much more complicated and unexpected if the rules of linearization are
    not clear.
  prefs: []
  type: TYPE_NORMAL
- en: Rules of inheritance hierarchies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before looking into linearization rules, we need to be clear on some inheritance
    rules in Scala:'
  prefs: []
  type: TYPE_NORMAL
- en: In Java, even if a class does not explicitly extend another one, its superclass
    will be `java.lang.Object`. The same stands for Scala, and the equivalent base
    is `AnyRef`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is a similarity between directly extending a trait and extending the trait
    superclass and mixing the trait in using the `with` keyword.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In older Scala versions, there was another type called `ScalaObject` that was
    implicitly added to all traits and classes.
  prefs: []
  type: TYPE_NORMAL
- en: Using those rules, we can always get to a canonical form for all traits and
    classes, where the base class is specified using `extends` and then all traits
    are added using the `with` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: Linearization rules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Linearization rules in Scala are defined and exist in order to ensure well-defined
    behavior. The rules state the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The linearization of any class must include the unmodified linearization of
    any *class* (but not trait) that it extends.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The linearization of any class must include all the classes and mixin traits
    in the linearization of any *trait* it extends, but the mixin traits are not bound
    to appear in the same order as they appear in the linearization of the traits
    being mixed in.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each class or trait in the linearization can appear only once. Duplicates are
    ignored.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We already saw in some of the previous examples that it is not possible to mix
    in traits that have different base classes or to mix in a trait into a class when
    their base classes differ.
  prefs: []
  type: TYPE_NORMAL
- en: How linearization works
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Scala, linearizations are listed from left to right where the right-most
    class is the most general, for example, `AnyRef`. While doing linearization, `Any`
    is also added to the hierarchy list. This, combined with the rule that any class
    must include the linearization of its superclass, means that the superclass linearization
    will appear as a suffix of the class linearization.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see an example with some really simple classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The linearization of these two classes will be, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s try and formalize an algorithm that describes how a linearization
    is calculated:'
  prefs: []
  type: TYPE_NORMAL
- en: Start with the following class declaration—`class A extends B with T1 with T2`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Reverse the order of the list except the first item and drop the keywords. This
    way, the superclass will come as a suffix—`A T2 T1 B`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Each item gets replaced with its linearization—`A T2L T1L BL`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Concatenate the list elements using the right-associative concatenation operation:
    `A +: T2L +: T1L +: BL`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Append the standard `AnyRef` and `Any` classes—`A +: T2L +: T1L +: BL +: AnyRef
    +: Any`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Evaluate the preceding expression. Due to the right-associative concatenation,
    we start from the right and move to the left. In each step, we remove any element
    that has already appeared on the right-hand side. In our case, when we get to
    `BL`, we will not add `AnyRef` and `Any` that it also contains; we will just add
    `BL` and then we will continue. At `T1L`, we will skip the step to add anything
    that was added before and so on, until we reach `A`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the end, after the linearization finishes, we will have a list of classes
    and traits without duplicates.
  prefs: []
  type: TYPE_NORMAL
- en: Initialization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we know what happens during linearization, we will understand how instances
    are being created. The rule is that the constructor code is executed in a reverse
    order compared to the linearization order. This means that, going from right to
    left, first the `Any` and `AnyRef` constructors will be invoked and then the actual
    class constructor will be called. Also, the superclass constructor will be called
    before the actual class or any of its mixins because, as we have already mentioned
    previously, it is added as a suffix.
  prefs: []
  type: TYPE_NORMAL
- en: Keeping in mind that we traverse the linearization from right to left also means
    that after the superclass constructor is called, the mixin trait constructors
    will be called. Here, they will be called in the order in which they appear in
    the original class definition (because of the right to left direction and the
    fact that their order is reversed when the linearization is created).
  prefs: []
  type: TYPE_NORMAL
- en: Method overriding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When overriding a method in a subclass, you may want to call the original implementation
    as well. This is achieved by prefixing the `super` keyword to the method name.
    The developer also has control to qualify the `super` keyword with a trait type,
    thus calling the method in the specific trait. We already saw an example of this
    earlier in the chapter, where we called `super[A].hello()`. In that example, we
    had mixins with the same methods; however, the methods themselves did not refer
    to `super`, but just defined their own implementations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see an example here, where we actually refer to the `super` class when
    overriding a method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s now define two traits that respectively double and triple the identity
    in our original class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'As we saw in some of the previous examples, the order in which we mix in the
    traits matters. We will provide three implementations, where we first mix in `DoubledMultiplierIdentity`
    and then `TripledMultiplierIdentity`. The first one will not override the identity
    method, which is equivalent to using the following super notation: `super.identity`.
    The other two will override the method and will refer to a specific parent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s do the same thing as shown in the preceding code, but this time, we
    first mix in `TripledMultiplierIdentity` and then `DoubledMultiplierIdentity`.
    The implementations are similar to the preceding ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, let''s use our classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The example shows a multiple inheritance hierarchy, where we can see a diamond
    relationship exactly as in the previous figure in which we explained what it means.
    We have all the possibilities here in terms of the order of mixing `DoubledMultiplier`
    and `TripledMultiplier`, as well as how we call the identity base method.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, what would the output of this program be? One would expect that in the
    cases where we don''t override the identity method, it would call the identity
    method of the right-most trait. Since in both the cases they call the super method
    of the class they extend, the results should be `2` and `3`. Let''s see this here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The preceding output is rather unexpected. This is, however, how the Scala type
    system works. In the case of linearization, where we have a multiple inheritance,
    the calls to the same method are chained from right to left according to the order
    of the appearance of the traits in the class declaration. Note that if we did
    not use the super notation, we would have broken the chain, as can be seen in
    some of the preceding examples.
  prefs: []
  type: TYPE_NORMAL
- en: The previous example is rather amusing and proves how important it is to know
    the rules of linearization and how linearization works. Not being aware of this
    feature could result in a serious pitfall, which could lead to critical mistakes
    in your code.
  prefs: []
  type: TYPE_NORMAL
- en: My advice would still be to try and avoid cases of diamond inheritance, even
    though one can argue that this way, some quite complex systems can be implemented
    seamlessly and without writing too much code. A case such as the preceding one
    could make the programs really hard to read and maintain in the future.
  prefs: []
  type: TYPE_NORMAL
- en: You should be aware that linearization exists everywhere in Scala—not just when
    dealing with traits. This is just how the Scala-type system works. This means
    that it is a good idea to be aware of the order in which constructors are called
    in order to avoid mistakes and generally, to try and keep the hierarchies relatively
    simple.
  prefs: []
  type: TYPE_NORMAL
- en: Testing traits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Testing is a really important part of software development. It ensures that
    changes to a certain piece of code do not end up producing errors either in the
    methods that were changed, or somewhere else.
  prefs: []
  type: TYPE_NORMAL
- en: There are different testing frameworks that one can use, and it really is a
    matter of personal preference. In this book, we have used **ScalaTest** ([http://www.scalatest.org](http://www.scalatest.org)),
    as this is the one I use in my projects; it is understandable, readable, and easy
    to use.
  prefs: []
  type: TYPE_NORMAL
- en: In some cases, if a trait is mixed into a class, we could end up testing the
    class. However, we might want to test only a specific trait. It does not make
    much sense to test a trait that doesn't have all its methods implemented, so here
    we will look into the ones that have their code written (mixins). Also, the unit
    tests that we will show here are quite simple, but they are just for illustration
    purposes. We will be looking into more complex and meaningful tests in the following
    chapters of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Using a class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s have a look at how `DoubledMultiplierIdentity`, which we saw previously,
    would be tested. One would try to simply mix the trait into a test class and test
    the methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'This, however, won''t compile and will lead to the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'We already talked about this before and the fact that a trait can only be mixed
    in a class that has the same super class as itself. This means that in order to
    test the trait, we should create a dummy class inside our test class and then
    use it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Mixing the trait in
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can test a trait by mixing it in. There are a few places where we can do
    this—into a test class or into separate test cases.
  prefs: []
  type: TYPE_NORMAL
- en: Mixing into the test class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mixing in a trait into a test class is only possible if the trait does not extend
    any other class explicitly, hence the super class of the trait and the test will
    be the same. Other than this, everything else is absolutely the same as done previously.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s test the `A` trait from earlier in this chapter, which says `hello`.
    We''ve also added an extra `pass` method, and now the trait looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'This is what the unit test will look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Mixing into the test cases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can also mix traits into the individual test cases separately. This could
    allow us to apply customizations specific to those test cases only. The following
    is just a different representation of the preceding unit test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the preceding code, the test cases are identical to the previous
    ones. They, however, individually mix `A` in. This would allow us to apply different
    customizations in the cases where a trait requires an implementation of a method
    or a variable initialization. This way, we can also focus specifically on the
    trait being tested, rather than creating actual instances of it.
  prefs: []
  type: TYPE_NORMAL
- en: Running the tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After the tests are written, it is useful to run them in order to see whether
    everything works as expected. If you''re using Maven, just run the following command
    from the root of your project and it will execute all the tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'If you''re using SBT, then the tests can be triggered using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Traits versus classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Traits could be similar, but also very different to classes. It could be hard
    for a developer to choose which one to use in various cases, but here we will
    try to provide some general guidelines that should help.
  prefs: []
  type: TYPE_NORMAL
- en: '**Use classes**:'
  prefs: []
  type: TYPE_NORMAL
- en: When a behavior is not going to be reused at all or in multiple places
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you plan to use your Scala code from another language, for example, if
    you are building a library that could be used in Java
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Use traits**:'
  prefs: []
  type: TYPE_NORMAL
- en: When a behavior is going to be reused in multiple unrelated classes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you want to define interfaces and want to use them outside Scala, for example,
    Java. The reason is that the traits that do not have any implementations are compiled
    similar to interfaces.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we went through traits and mixin compositions in Scala. By
    now, you should have a good understanding of what these are and what can be achieved
    by using them. We also went through the examples of the different uses of traits
    and what to watch out for when using them. We presented the limitations of using
    traits for multiple inheritance. Traits are an extremely powerful concept, but
    they have their pitfalls as we saw with multiple inheritance, so you should use
    them carefully. Linearization was covered in depth and you should be familiar
    with what to expect when using traits for multiple inheritance and why things
    work exactly the way they currently do.
  prefs: []
  type: TYPE_NORMAL
- en: Testing is an essential part of every good software project, and we also presented
    how it should be done for traits. Last, but not least, we prepared a few guidelines
    that should help developers choose between working with traits or classes in Scala.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will spend some time on **unification**. We will show
    why it is useful and what it helps the developer to achieve in their programs.
  prefs: []
  type: TYPE_NORMAL
