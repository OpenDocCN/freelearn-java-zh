<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Building Modular Applications with Java 9</h1>
                </header>
            
            <article>
                
<p>In the last chapter, we <span>covered changes in Java 9 with regards to variable handlers and how they related to th</span>e AtoMiC Toolkit. W<span>e also covered depreciation warnings and why they are now suppressed under specific circumstances. Five enhancements to changes introduced with Java 7 as part of <em>Project Coin</em> were also reviewed. Finally, we explored the improvements to import statement processing.</span></p>
<p><span>In this chapter, we will examine the structure of a Java module as specified by <em>Project Jigsaw</em>. We will take a deep-dive into how <em>Project Jigsaw</em> is implemented as part of the Java platform. We will also review key internal changes to the Java platform as they relate to the modular system.</span></p>
<p>The topics we will cover here are:</p>
<ul>
<li>An introduction to Java modularity</li>
<li>Review of the Java platform's module system</li>
<li>Modularizing JDK source code</li>
<li>Modular runtime images</li>
<li>Getting to know the module system</li>
<li>Modular Java application packaging</li>
<li>The Java linker</li>
<li>Encapsulation of internal APIs</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">A modular primer</h1>
                </header>
            
            <article>
                
<p>Before we dive into the Java 9 enhancements in this chapter, let's examine what modularity is in the context of Java.</p>
<p>We can define the term <strong>modular</strong> as a type of design or construction, in our context, of computer software. This type of software design involves a set of modules that collectively comprise the whole. A house, for example, can be built as a single structure or in a modular fashion where each room is constructed independently and joined to create a home. With this analogy, you could selectively add or not add modules in the creation of your home. The collection of modules, in our analogy, becomes the design of your home. Your design does not need to use every module, only the ones you want. So, for example, if there are basement and bonus room modules and your design does not include those modular rooms, those modules are not used to build your home. The alternative would be that every home would include every room, not just the ones that are used. This, of course, would be wasteful. Let's see how that correlates to software.</p>
<p>This concept can be applied to computer architecture and software systems. Our systems can be comprised of several components instead of one behemoth system. As you can likely imagine, this provides us with some specific benefits:</p>
<ul>
<li>We should be able to scale our Java applications to run on small devices</li>
<li>Our Java applications will be smaller</li>
<li>Our modular code can be more targeted</li>
<li>Increased use of the object-oriented programming model</li>
<li>Additional opportunities for encapsulation</li>
<li>Our code will be more efficient</li>
<li>Java applications will have increased performance</li>
<li>Overall system complexity is reduced</li>
<li>Testing and debugging is easier</li>
<li>Code maintenance is easier</li>
</ul>
<p>The shift to a modular system for Java was necessary for several reasons. Here are the primary conditions of the Java platform as of Java 9 that led to the creation of the module system for the Java 9 platform:</p>
<ul>
<li>The <strong>Java Development Kit</strong> (<strong>JDK</strong>) was simply too big. This made it difficult to support small devices. Even with the compact profiles discussed in the next section, supporting some small devices was difficult at best and, in some cases, not possible.</li>
<li>Due to the over-sized JDK, it was difficult to support truly optimized performance with our Java applications. In this case, smaller is better.</li>
<li>The <strong>Java Runtime Environment</strong> (<strong>JRE</strong>) was too large to efficiently test and maintain our Java applications. This results in time consuming, inefficient testing, and maintenance operations.</li>
<li>The <strong>Java Archive</strong> (<strong>JAR</strong>) files were also too large. This made supporting small devices problematic.</li>
<li>Because the JDK and JRE were all encompassing, security was of great concern. Internal APIs, for example, that were not used by the Java application, were still available due to the nature of the public access modifier.</li>
<li>Finally, our Java applications were unnecessarily large.</li>
</ul>
<p>Modular systems have the following requirements:</p>
<ul>
<li>There must be a common interface to permit interoperability among all connected modules</li>
<li>Isolated and connected testing must be supported</li>
<li>Compile time operations must be able to identify which modules are in use</li>
<li>Runtime support for modules</li>
</ul>
<p>A module is a new concept and component in Java 9; it is a named collection of data and code. Specifically, modules are a collection of:</p>
<ul>
<li>Packages</li>
<li>Classes</li>
<li>Interfaces</li>
<li>Code</li>
<li>Data</li>
<li>Resources</li>
</ul>
<p>Key to successful implementation, a module in Java 9 is self-described in its modular declaration. Module names must be unique and typically use the reverse domain name schema. Here is an example declaration:</p>
<pre>    module com.three19.irisScan { }</pre>
<p>Module declarations are contained in a <kbd>module-info.java</kbd> file that should be in the module's root folder. As one might expect, this file is compiled into a <kbd>module-info.class</kbd> file and will be placed in the appropriate output directory. These output directories are established in the module source code.</p>
<p>In the next sections, we will look at specific changes for Java 9 in regards to modularity.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Reviewing Java's platform module system [JEP-200]</h1>
                </header>
            
            <article>
                
<p>The core aim of JEP-200 was to modularize the <strong>Java Development Kit</strong> (<strong>JDK</strong>) using the <strong>Java Platform Module System</strong> (<strong>JPMS</strong>). Prior to Java 9, our familiarity with the JDK includes awareness of its major components:</p>
<ul>
<li>Java runtime environment (JRE)</li>
<li>The interpreter (java)</li>
<li>Compiler (javac)</li>
<li>The archiver (jar)</li>
<li>Document generator (javadoc)</li>
</ul>
<p>The task of modularizing the JDK was to break it into components that could be combined at compile time or runtime. The modular structure is based on the following modular profiles established as compact profiles in Java 8. Each of the three profiles is detailed in the following tables:</p>
<p><strong>Compact profile 1</strong>:</p>
<table>
<tbody>
<tr>
<td><kbd>java.io</kbd></td>
<td><kbd>java.lang.annotation</kbd></td>
<td><kbd>java.lang.invoke</kbd></td>
</tr>
<tr>
<td><kbd>java.lang.ref</kbd></td>
<td><kbd>lava.lang.reflect</kbd></td>
<td><kbd>java.math</kbd></td>
</tr>
<tr>
<td><kbd>java.net</kbd></td>
<td><kbd>java.nio</kbd></td>
<td><kbd>java.nio.channels</kbd></td>
</tr>
<tr>
<td><kbd>java.nio.channels.spi</kbd></td>
<td><kbd>java.nio.charset</kbd></td>
<td><kbd>java.nio.charset.spi</kbd></td>
</tr>
<tr>
<td><kbd>java.nio.file</kbd></td>
<td><kbd>java.nio.file.attribute</kbd></td>
<td><kbd>java.nio.file.spi</kbd></td>
</tr>
<tr>
<td><kbd>java.security</kbd></td>
<td><kbd>java.security.cert</kbd></td>
<td><kbd>java.security.interfaces</kbd></td>
</tr>
<tr>
<td><kbd>java.security.spec</kbd></td>
<td><kbd>java.text</kbd></td>
<td><kbd>java.text.spi</kbd></td>
</tr>
<tr>
<td><kbd>java.time</kbd></td>
<td><kbd>java.time.chrono</kbd></td>
<td><kbd>java.time.format</kbd></td>
</tr>
<tr>
<td><kbd>java.time.temporal</kbd></td>
<td><kbd>java.time.zone</kbd></td>
<td><kbd>java.util</kbd></td>
</tr>
<tr>
<td><kbd>java.util.concurrent</kbd></td>
<td><kbd>java.util.concurrent.atomic</kbd></td>
<td><kbd>java.util.concurrent.locks</kbd></td>
</tr>
<tr>
<td><kbd>java.util.function</kbd></td>
<td><kbd>java.util.jar</kbd></td>
<td><kbd>java.util.logging</kbd></td>
</tr>
<tr>
<td><kbd>java.util.regex</kbd></td>
<td><kbd>java.util.spi</kbd></td>
<td><kbd>java.util.stream</kbd></td>
</tr>
<tr>
<td><kbd>java.util.zip</kbd></td>
<td><kbd>javax.crypto</kbd></td>
<td><kbd>javax.crypto.interfaces</kbd></td>
</tr>
<tr>
<td><kbd>javax.crypto.spec</kbd></td>
<td><kbd>javax.net</kbd></td>
<td><kbd>javax.net.ssl</kbd></td>
</tr>
<tr>
<td><kbd>javax.script</kbd></td>
<td><kbd>javax.security.auth</kbd></td>
<td><kbd>javax.security.auth.callback</kbd></td>
</tr>
<tr>
<td><kbd>javax.security.auth.login</kbd></td>
<td><kbd>javax.security.auth.spi</kbd></td>
<td><kbd>javax.security.auth.spi</kbd></td>
</tr>
<tr>
<td><kbd>javax.security.auth.x500</kbd></td>
<td><kbd>javax.security.cert</kbd></td>
<td/>
</tr>
</tbody>
</table>
<p>Â </p>
<p><strong>Compact profile 2</strong>:</p>
<table>
<tbody>
<tr>
<td><kbd>java.rmi</kbd></td>
<td><kbd>java.rmi.activation</kbd></td>
<td><kbd>java.rmi.dgc</kbd></td>
</tr>
<tr>
<td><kbd>java.rmi.registry</kbd></td>
<td><kbd>java.rmi.server</kbd></td>
<td><kbd>java.sql</kbd></td>
</tr>
<tr>
<td><kbd>javax.rmi.ssl</kbd></td>
<td><kbd>javax.sql</kbd></td>
<td><kbd>javax.transaction</kbd></td>
</tr>
<tr>
<td><kbd>javax.transaction.xa</kbd></td>
<td><kbd>javax.xml</kbd></td>
<td><kbd>javax.xml.database</kbd></td>
</tr>
<tr>
<td><kbd>javax.xml.namespace</kbd></td>
<td><kbd>javax.xml.parsers</kbd></td>
<td><kbd>javax.xml.stream</kbd></td>
</tr>
<tr>
<td><kbd>javax.xml.stream.events</kbd></td>
<td><kbd>javax.xml.stream.util</kbd></td>
<td><kbd>javax.xml.transform</kbd></td>
</tr>
<tr>
<td><kbd>javax.xml.transform.dom</kbd></td>
<td><kbd>javax.xml.transform.sax</kbd></td>
<td><kbd>javax.xml.transform.stax</kbd></td>
</tr>
<tr>
<td><kbd>javax.xml.transform.stream</kbd></td>
<td><kbd>javax.xml.validation</kbd></td>
<td><kbd>javax.xml.xpath</kbd></td>
</tr>
<tr>
<td><kbd>org.w3c.dom</kbd></td>
<td><kbd>org.w3c.dom.bootstrap</kbd></td>
<td><kbd>org.w3c.dom.events</kbd></td>
</tr>
<tr>
<td><kbd>org.w3c.dom.ls</kbd></td>
<td><kbd>org.xml.sax</kbd></td>
<td><kbd>org.xml.sax.ext</kbd></td>
</tr>
<tr>
<td><kbd>org.xml.sax.helpers</kbd></td>
<td/>
<td/>
</tr>
</tbody>
</table>
<p><strong>Compact profile 3</strong>:</p>
<table>
<tbody>
<tr>
<td><kbd>java.lang.instrument</kbd></td>
<td><kbd>java.lang.management</kbd></td>
<td><kbd>java.security.acl</kbd></td>
</tr>
<tr>
<td><kbd>java.util.prefs</kbd></td>
<td><kbd>javax.annotation.processing</kbd></td>
<td><kbd>javax.lang.model</kbd></td>
</tr>
<tr>
<td><kbd>javax.lang.model.element</kbd></td>
<td><kbd>javax.lang.model.type</kbd></td>
<td><kbd>javax.lang.model.util</kbd></td>
</tr>
<tr>
<td><kbd>javax.management</kbd></td>
<td><kbd>javax.management.loading</kbd></td>
<td><kbd>javax.management.modelmbean</kbd></td>
</tr>
<tr>
<td><kbd>javax.management.monitor</kbd></td>
<td><kbd>javax.management.openmbean</kbd></td>
<td><kbd>javax.management.relation</kbd></td>
</tr>
<tr>
<td><kbd>javax.management.remote</kbd></td>
<td><kbd>javax.management.remote.rmi</kbd></td>
<td><kbd>javax.management.timer</kbd></td>
</tr>
<tr>
<td><kbd>javax.naming</kbd></td>
<td><kbd>javax.naming.directory</kbd></td>
<td><kbd>javax.naming.event</kbd></td>
</tr>
<tr>
<td><kbd>javax.naming.ldap</kbd></td>
<td><kbd>javax.naming.spi</kbd></td>
<td><kbd>javax.security.auth.kerberos</kbd></td>
</tr>
<tr>
<td><kbd>javax.security.sasl</kbd></td>
<td><kbd>javax.sql.rowset</kbd></td>
<td><kbd>javax.sql.rowset.serial</kbd></td>
</tr>
<tr>
<td><kbd>javax.sql.rowest.spi</kbd></td>
<td><kbd>javax.tools</kbd></td>
<td><kbd>javax.xml.crypto</kbd></td>
</tr>
<tr>
<td><kbd>javax.xml.crypto.dom</kbd></td>
<td><kbd>javax.xml.crypto.dsig</kbd></td>
<td><kbd>javax.xml.crypto.dsig.dom</kbd></td>
</tr>
<tr>
<td><kbd>javax.xml.crypto.dsig.keyinfo</kbd></td>
<td><kbd>javax.xml.crypto.dsig.spec</kbd></td>
<td><kbd>org.ieft.jgss</kbd></td>
</tr>
</tbody>
</table>
<p>Â </p>
<p>The three compact module profiles represent the basis for the standardized modular system in Java 9. The effectiveness of this standardization relies on the following six principles:</p>
<ul>
<li>All JCP-governed modules must start with the string <kbd>java.</kbd>. So, if a module on spatial utilities was being developed it would have a name such as <kbd>java.spatial.util</kbd>.</li>
</ul>
<div class="packt_infobox"><strong>JCP</strong> refers to the <strong>Java Community Process</strong>. JCP allows developers to create technical specifications for Java. You can learn more about JCP and become a member at the official JCP website--<a href="http://www.jcp.org">http://www.jcp.org</a>.</div>
<ul>
<li>Non-JCP modules are considered part of the JDK and their names must start with the string <kbd>jdk.</kbd>.</li>
<li>Ensure method invocation chaining works properly. This is best illustrated with the following flowchart:</li>
</ul>
<div class="CDPAlignCenter CDPAlign"><img src="assets/5d18802b-2b33-41d5-a8da-ea1be31808e8.png"/></div>
<div class="packt_infobox">As you can see in the preceding flowchart, it only applies to modules that export a package.</div>
<ul>
<li>The fourth principle deals with both standard and non-standard API packages being used in a standard module. The following flowchart illustrates the implementation of this principle's covenants:</li>
</ul>
<div class="CDPAlignCenter CDPAlign"><img src="assets/ac898d14-8304-4c49-95f1-1d7d6c282429.png"/></div>
<ul>
<li>The fifth design principle is that standard modules can be dependent upon more than one non-standard module. While this dependency is permitted, implied readability access to non-standard modules is not.</li>
<li>The final design principle ensures non-standard modules do not export standard API packages.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Modularizing JDK source code [JEP-201]</h1>
                </header>
            
            <article>
                
<p>As previously mentioned, Project Jigsaw had the goal of modularization. The envisioned standard modular system would be applied to the Java SE platform and the JDK. In addition to efficiency gains, the modular shift would result in better security and ease maintainability. The enhancement detailed in JEP-201 focused on JDK source code reorganization. Let's take a closer look.</p>
<p>Reorganizing the JDK's source code is a significant task and was accomplished with the following subset of goals:</p>
<ul>
<li>Provide JDK developers insights and familiarity with the new Java 9 modular system. So, this goal was aimed at developers of the JDK, not mainstream developers.</li>
<li>Ensure modular boundaries are established and maintained throughout the JDK build process. This was a necessary precaution so the modular system would be stable throughout Java 9's enhancements and, more specifically, in implementing the modular system.</li>
<li>The third goal was to ensure future enhancements, specifically with <em>Project Jigsaw</em>, could be easily integrated into the new modular system.</li>
</ul>
<p>The significance of this source code reorganization cannot be overstated. The pre-Java 9 source code organization is 20 years old. This overdue JDK source code reorganization will make the code much easier to maintain. Let's look at the previous organization of the JDK source code and then examine the changes.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Pre-Java 9 JDK source code organization</h1>
                </header>
            
            <article>
                
<p>The JDK is a compilation of code files, tools, libraries, and more. The following illustration provides an overview of the JDK components:</p>
<div class="CDPAlignCenter CDPAlign"><img height="246" width="211" src="assets/e2bfb59d-d835-4190-9467-bb5287cb5735.png"/></div>
<p>The pre-Java 9 organization of the JDK components in the preceding illustration are detailed in the next seven subsections.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Development tools</h1>
                </header>
            
            <article>
                
<p>The development tools are located in the <kbd>\bin</kbd> directory. These tools include seven broad categorizations, each detailed in the subsequent sections.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Deployment</h1>
                </header>
            
            <article>
                
<p>This is a set of tools intended to help deploy Java applications:</p>
<ul>
<li><kbd>appletviewer</kbd>: This tool gives you the ability to run and debug Java applets without the need for a web browser.</li>
<li><kbd>extcheck</kbd>: This tool allows you to find conflicts in JAR files.</li>
<li><kbd>jar</kbd>: This tool is used for creating and manipulating JAR files. JAR files are Java Archive files.</li>
<li><kbd>java</kbd>: This is the Java application launcher.</li>
<li><kbd>javac</kbd>: This is the Java Compiler.</li>
<li><kbd>javadoc</kbd>: This tool generates API documentation.</li>
<li><kbd>javah</kbd>: This tool allows you to write native methods; it generates C header files.</li>
<li><kbd>javap</kbd>: This tool disassembles class files.</li>
<li><kbd>javapackager</kbd>: For signing and packaging Java applications, including JavaFX.</li>
<li><kbd>jdb</kbd>: This is the Java debugger.</li>
<li><kbd>jdeps</kbd>: This is an analyzer for Java class dependencies.</li>
<li><kbd>pack200</kbd>: This is a tool that compresses JAR files into <kbd>pack200</kbd> files. The compression ratio using this tool is impressive.</li>
<li><kbd>unpack200</kbd>: This tool unpacks <kbd>pack200</kbd> files resulting in JAR files.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Internationalization</h1>
                </header>
            
            <article>
                
<p>If you are interested in creating localizable applications, the following tool might come in handy:</p>
<ul>
<li><kbd>native2ascii</kbd>: This tool creates Unicode Latin-1 from normal text.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Monitoring</h1>
                </header>
            
            <article>
                
<p>Monitoring tools used for providing JVM performance data include:</p>
<ul>
<li><kbd>jps</kbd>: This is the <strong>JVM process status tool</strong> (<strong>jps</strong>). It provides a list of HotSpot JVMs on a specific system.</li>
<li><kbd>jstat</kbd>: This is the JVM statistics monitoring tool. It collects log data and performance information from a machine with a HotSpot JVM.</li>
<li><kbd>jstatd</kbd>: This is the <strong>jstat</strong> daemon tool. It runs an RMI server app for monitoring HotSpot JVM operations.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">RMI</h1>
                </header>
            
            <article>
                
<p><strong>RMI</strong> tools are <strong>Remote Method Invocation</strong> tools. They help developers create applications that operate over a network to include the internet:</p>
<ul>
<li><kbd>rmic</kbd>: This tool can generate stubs and skeletons for objects over a network</li>
<li><kbd>rmiregistry</kbd>: This is a registry service for remote objects</li>
<li><kbd>rmid</kbd>: This tool is an activation system daemon for RMI</li>
<li><kbd>serialver</kbd>: This tool returns the class <kbd>serialVersionUID</kbd> value</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Security</h1>
                </header>
            
            <article>
                
<p>This set of security tools empowers developers to create security policies that can be enforced on the developer's computer system as well as on remote systems:</p>
<ul>
<li><kbd>keytool</kbd>: This tool manages security certificates and keystores</li>
<li><kbd>jarsigner</kbd>: This tool generates and verifies JAR signatures for creating/opening JAR files</li>
<li><kbd>policytool</kbd>: This tool has a graphical user interface that helps developers manage their security policy files</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Troubleshooting</h1>
                </header>
            
            <article>
                
<p>These experimental troubleshooting tools are useful for very specific troubleshooting. They are experimental and, therefore, not officially supported:</p>
<ul>
<li><kbd>jinfo</kbd>: This tool provides configuration information for specific processes, files, or servers.</li>
<li><kbd>jhat</kbd>: This is a heap dump tool. It instantiates a web server so that a heap can be viewed with a browser.</li>
<li><kbd>jmap</kbd>: This displays heap and shared object memory maps from a process, file, or server.</li>
<li><kbd>jsadebugd</kbd>: This is Java's Serviceability Agent Debug Daemon. It acts as a debug server for a process or file.</li>
<li><kbd>jstack</kbd>: This is a Java Stack Trace tool that provides a thread stack trace for a process, file, or server.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Web services</h1>
                </header>
            
            <article>
                
<p>This set of tools provides a utility that can be used with <strong>Java Web Start</strong> and other web services:</p>
<ul>
<li><kbd>javaws</kbd>: This is a command line tool that launches Java Web Start.</li>
<li><kbd>schemagen</kbd>: This tool generates schemas for Java architecture. These schemas are used for XML binding.</li>
<li><kbd>wsgen</kbd>: This tool is used for generating JAX-WS artifacts that are portable.</li>
<li><kbd>wsimport</kbd>: This tool is used for importing portable JAX-WS artifacts.</li>
<li><kbd>xjc</kbd>: This is the binding compiler that is used for XML binding.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">JavaFX tools</h1>
                </header>
            
            <article>
                
<p>The JavaFX tools are located in a few different places including <kbd>\bin</kbd>, <kbd>\man</kbd>, and <kbd>\lib</kbd> directories.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Java runtime environment</h1>
                </header>
            
            <article>
                
<p>The <strong>Java runtime environment</strong> (<strong>JRE</strong>) is located in the <kbd>\jre</kbd> directory. Key contents include the <strong>Java Virtual Machine</strong> (<strong>JVM</strong>) and class libraries.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Source code</h1>
                </header>
            
            <article>
                
<p>The JDK's source code, pre-Java 9, has the following basic organizational schema:</p>
<pre>    source code / [shared, OS-specific] / [classes / native] / Java API<br/>     package name / [.file extension]</pre>
<p>Let's look at this a bit closer. After the source code, we have two options. If the code is cross-platform, then it is a shared directory; otherwise, it is operating system specific. For example:</p>
<pre style="padding-left: 30px">    src/share/...<br/>    src/windows/...</pre>
<p>Next, we have the classes directory or a native language directory. For example:</p>
<pre style="padding-left: 30px">    src/share/classes/...<br/>    src/share/classes/java/...</pre>
<p>Next, we have the name of the Java API package followed by the file extension. The file extensions depend on content such as <kbd>.java</kbd>, <kbd>.c</kbd>, and more.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Libraries</h1>
                </header>
            
            <article>
                
<p>The <kbd>\lib</kbd> directory houses class libraries that are needed by one or more of the development tools in the <kbd>\bin</kbd> directory. Here is a list of files in a typical Java 8 <kbd>\lib</kbd> directory:</p>
<div class="CDPAlignCenter CDPAlign"><img height="323" width="317" src="assets/7bc7f852-2a14-4e70-965b-d2e0ec699c01.png"/></div>
<p>Reviewing the directory listing does not provide a great level of granular insight. We can list the classes contained in any of the <kbd>.jar</kbd> files with the following command--<kbd>jar tvf fileName.jar</kbd>. As an example, here is the class listing generated from executing <kbd>jar tvf javafx-mx.jar</kbd> at the command line:</p>
<div class="CDPAlignCenter CDPAlign"><img height="374" width="536" src="assets/61ce95a2-dbe5-40f1-bc1f-d62543b5de69.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">C header files</h1>
                </header>
            
            <article>
                
<p>The <kbd>/include</kbd> directory contains C header files. These files primarily support the following:</p>
<ul>
<li><strong>Java Native Interface</strong> (<strong>JNI</strong>): This is used for native-code programming support. The JNI is used to embed Java native methods and the JVM into native apps.</li>
<li><strong>JVM Tool Interface</strong> (<strong>JVM TI</strong>): This is used by tools for state inspections and execution control for apps running the JVM.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Database</h1>
                </header>
            
            <article>
                
<p>The Apache Derby relational database is stored in the <kbd>/db</kbd> directory. You can learn more about Java DB at the following sites:</p>
<p><a href="http://docs.oracle.com/javadb/support/overview.html">http://docs.oracle.com/javadb/support/overview.html</a></p>
<p><a href="http://db.apache.org/derby/manuals/#docs_10.11">http://db.apache.org/derby/manuals/#docs_10.11</a></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">JDK source code reorganized</h1>
                </header>
            
            <article>
                
<p>In a previous section, you learned that the pre-Java 9 source code organization schema was as follows:</p>
<pre><span>    source code / [shared, OS-specific] / [classes / native] / Java API <br/>     package name / [.file extension]</span></pre>
<p>In Java 9, we have a new modular schema. That schema follows:</p>
<pre><span>    source code / module / [shared, OS-specific] / [classes / native / <br/>    configuration] / [ package / include / library ] /<br/>     [.file extension]</span></pre>
<p>There are a few differences in the new schema, most notably the module name. After the shared or OS-specific directory, there is either the classes directory, the native directory for C or C++ source files, or a configuration directory. This seemingly rudimentary organization schema changes results in a much more maintainable code base.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Understanding modular run-time images [JEP-220]</h1>
                </header>
            
            <article>
                
<p>Java 9's modular system required changes to the runtime images for compatibility. Benefits of these changes include enhancements in the following areas:</p>
<ul>
<li>Maintainability</li>
<li>Performance</li>
<li>Security</li>
</ul>
<p>Core to these changes was a new URI schema used for resource naming. These resources include modules and classes.</p>
<div class="packt_infobox">A <strong>Uniform Resource Identifier</strong> (<strong>URI</strong>) is similar to a <strong>URL</strong> (<strong>Uniform Resource Locator</strong>) in that it identifies the name and location of something. For a URL, that something is a web page; for a URI, it is a resource.</div>
<p>There were five primary goals for JEP-220 and these are detailed in the following sections.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Runtime format adoption</h1>
                </header>
            
            <article>
                
<p>A run-time format was created for Java 9, for adoption by stored classes and other resource files. This format is applicable for stored classes and resources under the following circumstances:</p>
<ul>
<li>When the new run-time format has greater efficiencies (time and space) than the pre-Java 9 JAR format.</li>
</ul>
<div class="packt_infobox">A <strong>JAR</strong> file is a <strong>Java ARchieve</strong> file. This is a compressed file format based on the legacy ZIP format.</div>
<ul>
<li>When stored classes and other resources can be individually isolated and loaded.</li>
<li>When JDK and library classes and resources can be stored. This includes app modules as well.</li>
<li>When they are devised in such a way as to promote future enhancements. This requires them to be extensible, documented, and flexible.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Runtime image restructure</h1>
                </header>
            
            <article>
                
<p>There are two types of runtime images in Java--JDK and JRE. With Java 9, both of these image types were restructured to differentiate between files that can be used and modified by users to internal files that can be used but not modified by developers and their apps.</p>
<p>The JDK build system, prior to Java 9, produces both a JRE and a JDK. The JRE is a complete implementation of the Java platform. The JDK includes the JRE as well as other tools and libraries. A notable change in Java 9 is that the JRE subdirectory is no longer part of the JDK image. This change was made, in part, to ensure both image types (JDK and JRE) have identical image structures. With a common and reorganized structure, future changes will be more efficiently integrated.</p>
<div class="packt_tip">If you created custom plugins prior to Java 9 that address a specific structure, your app might not work in Java 9. This is also true if you are explicitly addressing <kbd>tools.jar</kbd>.</div>
<p>The following diagram provides a high-level view of the contents of each image before Java 9's release:</p>
<div class="CDPAlignCenter CDPAlign"><img height="144" width="220" src="assets/e49f91e4-fc08-4959-a30a-8e86eae30101.png"/></div>
<p>The Java 9 runtime images are illustrated in the following diagram. As shown, a full JDK image contains the same directories as a modular runtime image as well as demo, sample, man, and includes directories:</p>
<div class="CDPAlignCenter CDPAlign"><img height="153" width="233" src="assets/9603215f-8be0-44b0-9cfd-dfce65051411.png"/></div>
<p>There is no longer a difference between a JRE or JDK image. Now, with Java 9, a JDK image is a JRE image that contains a full set of dev tools.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Supporting common operations</h1>
                </header>
            
            <article>
                
<p>Developers occasionally must write code that performs operations requiring access to the runtime image. Java 9 includes support for these common operations. This is possible due to the restructuring and standardized JDK and JRE runtime image structures.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">De-privileging JDK classes</h1>
                </header>
            
            <article>
                
<p>Java 9 allows privilege revocation for individual JDK classes. This change strengthens system security in that it ensures JDK classes only receive the permissions required for system operations.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Preserving existing behaviors</h1>
                </header>
            
            <article>
                
<p>The final goal of the JEP-220 was to ensure currently existing classes are not negatively impacted. This refers to applications that do not have dependencies on internal JDK or JRE runtime images.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting to know the module system [JEP-261]</h1>
                </header>
            
            <article>
                
<p>The purpose of this JEP was the implementation of the new module system for the Java platform. You will recall that the modular system was created to provide reliable configuration and strong encapsulation for Java programs. Key to this implementation was the concept of link time. As illustrated here, link time is an optional phase in between compile time and runtime. This phase allows the assembly of the appropriate modules into an optimized runtime image. This is possible, in part, due to the jlink linking tool which you will learn more about later in this chapter:</p>
<div class="CDPAlignCenter CDPAlign"><img height="195" width="451" src="assets/4cf43046-86d2-4a29-8326-475be2c778c5.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Module paths</h1>
                </header>
            
            <article>
                
<p>It is important to organize modules so that they can be easily located. The module path, a sequence of module components or directories, provides the organizational structure used by searches. These path components are searched for in order, returning the first path component that comprises a module.</p>
<p>Modules and their paths should not be considered to be the same as packages or class paths. They are indeed different and have a greater level of fidelity. The key difference is that, with classpaths, a singular component is searched for. Module path searches return complete modules. This type of search is possible by searching the following paths, in the presented order, until a module is returned:</p>
<ul>
<li>Compilation module path</li>
<li>Upgrade module path</li>
<li>System modules</li>
<li>Application module path</li>
</ul>
<p>Let's briefly review each of these paths. The compilation module path is only applicable at compile time and contains the module definitions. The upgrade module path has the compiled module definitions. The system modules are built-in and include Java SE and JDK modules. The final path, the application module path, has the compiled module definitions from the application modules as well as the library modules.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Access-control boundary violations</h1>
                </header>
            
            <article>
                
<p>As a professional developer, you always want your code to be secure, portable, and bug-free, which requires strict adherence to Java constructs such as encapsulation. There are occasions, such as with white box testing, that you need to break the encapsulation that the JVM mandates. This mandate permits cross-modular access.</p>
<p>To permit breaking the encapsulation, you can add an <kbd>add-exports</kbd> option in your module declaration. Here is the syntax you will use:</p>
<pre>    module com.three19.irisScan <br/>    {<br/>      - - add-exports &lt;source-module&gt;/&lt;package&gt; = &lt;target-module&gt; <br/>      (, &lt;target-module&gt; )*<br/>    }</pre>
<p>Let's take a closer look at the preceding syntax. The <kbd>&lt;source-module&gt;</kbd> and <kbd>&lt;target-module&gt;</kbd> are module names and <kbd>&lt;package&gt;</kbd> is the name of the package. Using the <kbd>add-exports</kbd> <span>option permits us to violate access-control boundaries.</span></p>
<p>There are two rules regarding using the add-exports option:</p>
<ul>
<li>It can be used multiple times in a module</li>
<li>Each use must be of a unique pairing of <kbd>&lt;source-module&gt;</kbd> and <kbd>&lt;target-module&gt;</kbd></li>
</ul>
<div class="packt_tip">It is not recommended that the add-exports option be used unless absolutely necessary. Its use permits dangerous access to a library module's internal API. This type of use makes your code dependent on the internal API not changing, which is beyond your control.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Runtime</h1>
                </header>
            
            <article>
                
<p>The HotSpot virtual machine implements the <kbd>&lt;options&gt;</kbd> for the <kbd>jmod</kbd> and <kbd>jlink</kbd> command-line tools. Here is the list of <kbd>&lt;options&gt;</kbd> for the <kbd>jmod</kbd> command-line tool:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/1a89984f-1a29-487b-bfeb-0fbd1b757f9e.png"/></div>
<p>Here is the list of <kbd>&lt;options&gt;</kbd> for the <kbd>jlink</kbd> command-line tool:</p>
<div class="CDPAlignCenter CDPAlign"><img height="429" width="452" src="assets/ce4f892d-5c15-4bc5-a95e-80790505bceb.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Modular Java application packaging [JEP-275]</h1>
                </header>
            
            <article>
                
<p>One of the great improvements in Java 9 is the size of the runtime binaries generated by the <strong>Java Packager</strong>. This is possible in part due to the <strong>Java Linker</strong>, which is covered in the next section. The Java Packager's workflow has essentially remained the same in Java 9 as it was in Java 8. There have been, as you will see later in this section, new tools added to the workflow.</p>
<p>The Java Packager solely creates JDK 9 applications. This change to the Java Packager is intended to streamline and make the process of generating runtime images more efficient. So, the Java Packager will only create runtime images for the SDK version that it is associated with.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Advanced look at the Java Linker</h1>
                </header>
            
            <article>
                
<p>Prior to the Java Linker tool, <kbd>jlink</kbd>, introduced in Java 9, runtime image creation included copying the entire JRE. Then, unused components are removed. Simply put, <kbd>jlink</kbd> facilitates the creation of runtime images with only the required modules. <kbd>jlink</kbd> is used by the Java Packager to generate an embedded runtime image.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Java Packager options</h1>
                </header>
            
            <article>
                
<p>The syntax for the Java Packager is as follows:</p>
<pre><strong>    javapackager -command [-options]</strong></pre>
<p>There are five different commands (<kbd>-command</kbd>) that can be used. They are described as follows:</p>
<table>
<tbody>
<tr>
<td><strong>command</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td><kbd>-createbss</kbd></td>
<td>This command is used for converting files from CSS to binary</td>
</tr>
<tr>
<td><kbd>-createjar</kbd></td>
<td>This command, used along with additional parameters, creates a JAR archive file</td>
</tr>
<tr>
<td><kbd>-deploy</kbd></td>
<td>This command is used to generate jnlp and HTML files</td>
</tr>
<tr>
<td><kbd>-makeall</kbd></td>
<td>Combines the <kbd>-createjar</kbd>, <kbd>-deploy</kbd>, and compilation steps</td>
</tr>
<tr>
<td><kbd>-signJar</kbd></td>
<td>This command creates and signs a JAR file</td>
</tr>
</tbody>
</table>
<p>The <kbd>[-options]</kbd> for the <kbd>-createbss</kbd> command include:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/496e7e6e-41df-4b22-9052-fdf1f1ed1f75.png"/></div>
<p>The <kbd>[-options]</kbd> for the <kbd>-createjar</kbd> command include:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/d5fb7d05-0220-42a0-8bb7-58ed847aae8d.png"/></div>
<p>The <kbd>[-options]</kbd> for the <kbd>-deploy</kbd> command include:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/cda27542-7ded-4b35-ac8b-f827ad8e57c9.png"/></div>
<p>Here are the remaining <kbd>[-options]</kbd> for the <kbd>-deploy</kbd> command:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/4ff87376-8853-4afd-903d-817cefb62f96.png"/></div>
<p>The <kbd>[-options]</kbd> for the <kbd>-makeall</kbd> command include:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/0d0ccdef-57ea-449f-8c6a-751fb0716804.png"/></div>
<p>The <kbd>[-options]</kbd> for the <kbd>-signJar</kbd> include:</p>
<div class="CDPAlignCenter CDPAlign"><img height="221" width="518" src="assets/991302ee-0d7d-4c7a-acc8-83f23ded78d5.png"/></div>
<p>The Java Packager is divided into two modules:</p>
<pre>    jdk.packager<br/>    jdk.packager.services</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">JLink - The Java Linker [JEP-282]</h1>
                </header>
            
            <article>
                
<p>The Java Linker, commonly referred to as JLink, is a tool that was created to create custom runtime images. This tool collects the appropriate modules along with their dependencies, then optimizes them to create the image. This represents a big change for Java, with the release of Java 9. Before the Java Linker tool, <kbd>jlink</kbd>, was available, runtime image creation included initially copying the entire JRE. In a subsequent step, the unused components were removed. In Java 9, <kbd>jlink</kbd> creates runtime images with only the needed modules. <kbd>jlink</kbd> is used by the Java Packager to generate an embedded runtime image.</p>
<p>As illustrated in a previous section, JEP-282 resulted in link time as an optional phase between compile time and runtime. It is in this phase that the appropriate modules are assembled into an optimized runtime image.</p>
<p>JLink is a command-line linking tool that permits the creation of runtime images containing a smaller subset of the JDK modules. This results in smaller runtime images. The following syntax consists of four components--the <kbd>jlink</kbd> command, options, the module path, and the output path:</p>
<pre><strong>$ jlink &lt;options&gt; ---module-path &lt;modulepath&gt; --output &lt;path&gt;</strong></pre>
<p class="mce-root">Here is a list of the options that can be used with the <kbd>jlink</kbd> tool along with brief descriptions of each:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/11aef842-1b97-4dd6-8084-e27a6158adca.png"/></div>
<p class="mce-root">The module path tells the linker where to find the modules. The linker will not use exploded modules or JAR/JMOD files.</p>
<p>The output path simply informs the linker where to save the custom run-time image.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Encapsulating most internal APIs [JEP-260]</h1>
                </header>
            
            <article>
                
<p>JEP-260 was implemented to make the Java platform more secure. The core of this JEP's goal was to encapsulate the majority of internal APIs. Specifically, most of the JDK's internal APIs are no longer accessible by default. Currently, internal APIs deemed to be <em>critical</em> and <em>widely-used</em> remain accessible. In the future, we are likely to see functionality to replace them, and at that time, those internal APIs will not be accessible by default.</p>
<p>So, why is this change necessary? There are a few widely-used APIs that are unstable and, in some cases, not standardized. Unsupported APIs should not have access to internal details of the JDK. Therefore, JEP-260 resulted in increased security of the Java platform. Generally speaking, you should not use unsupported APIs in your development projects.</p>
<p>The aforementioned critical APIs (internal to the JDK) are:</p>
<ul>
<li><kbd>sun.misc</kbd></li>
<li><kbd>sun.misc.Unsafe</kbd></li>
<li><kbd>sun.reflect.Reflection</kbd></li>
<li><kbd>sun.reflect.ReflectionFactory.newConstrutorForSerialization</kbd></li>
</ul>
<p>The aforementioned critical internal APIs are still accessible in JDK 9. They will be accessible with the <kbd>jdk.unsupported</kbd> JDK module. Full JRE and JDK images will contain the <kbd>jdk.unsupported</kbd> module.</p>
<div class="packt_tip">You can use the Java Dependency Analysis Tool, <kbd>jdeps</kbd>, to help determine if your Java program has any dependencies on JDK internal APIs.</div>
<p><span>This is an interesting change to watch. It is likely that the currently accessible internal APIs will not be accessible by default when Java 10 is released.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p><span>In this chapter, we examined the structure of Java modules as specified by <em>Project Jigsaw</em> and took an in-depth look at how <em>Project Jigsaw</em> was implemented to improve the Java platform. We also reviewed key internal changes to the Java platform as they relate to the modular system. Our review started with a modular primer where we learned about Java 9's modular system in terms of benefits and requirements.</span></p>
<p><span>We explored how Java 9 introduced modularity to the JDK including its source code and organization of the same. The seven primary tool categories that make up the JDK were also explored. As we learned, modularity in Java 9 also extends to runtime images resulting in more maintainability, better performance, and increased security. The concept of <strong>link time</strong> was introduced as an optional phase between compile-time and runtime. We concluded the chapter with a look at the Java Linker and how Java 9 encapsulates internal APIs.</span></p>
<p>In the next chapter, we will explore how to migrate our existing applications to the Java 9 platform. We will look at both manual and semi-automated migration processes.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    </body></html>