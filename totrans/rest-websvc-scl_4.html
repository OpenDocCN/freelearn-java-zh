<html><head></head><body>
<div id="page" style="height:0pt"/><div class="book" title="Chapter&#xA0;4.&#xA0;An Easy REST Service Using Scalatra"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch04" class="calibre1"/>Chapter 4. An Easy REST Service Using Scalatra</h1></div></div></div><p class="calibre7">In the previous chapters, you learned how to create REST services using frameworks that use a functional, Scala language-like approach. Finch used a very functional programming-based approach, and Unfiltered used pattern matching. In this chapter, we explore a Scala framework, Scalatra, whose main goal is simplicity.</p><p class="calibre7">In this chapter, we'll explain Scalatra's functionality using the following examples:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong class="calibre8">First Scalatra service</strong></span>: We'll create a simple Scalatra service that shows how you can get up and running.</li><li class="listitem"><span class="strong"><strong class="calibre8">Verb and path handling</strong></span>: Scalatra provides a number of constructs you can use to define a route. A route can match a specific HTTP verb and path and on a match, it will return a specific response.</li><li class="listitem"><span class="strong"><strong class="calibre8">Add support for futures and simple validation</strong></span>: In its standard configuration, Scalatra works synchronously. In this part, we'll show you how you can add support for futures and also add some basic validation.</li><li class="listitem"><span class="strong"><strong class="calibre8">Convert to and from JSON and support advanced validations</strong></span>: In the last part of this chapter, we'll look at JSON support and explain how Scalatra supports a more advanced way of validating incoming requests.</li></ul></div><p class="calibre7">First, though, let's have a quick look at what Scalatra is, and what it aims to do.</p></div>

<div class="book" title="Chapter&#xA0;4.&#xA0;An Easy REST Service Using Scalatra">
<div class="book" title="Introduction to Scalatra"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch04lvl1sec28" class="calibre1"/>Introduction to Scalatra</h1></div></div></div><p class="calibre7">Scalatra is <a id="id177" class="calibre1"/>a small Scala web framework which tries to keep things simple. It provides a set of guidelines and helper classes to create complete web applications. In this chapter, we'll focus on the support it provides to create REST services.</p><p class="calibre7">Scalatra is built with a number of principles in mind (from the Scalatra home page):</p><div class="blockquote"><blockquote class="blockquote1"><p class="calibre24"><span class="strong"><em class="calibre9">Start small, build upwards: Start with a small core, and have lots of easy integrations for common tasks.</em></span></p><p class="calibre24"><span class="strong"><em class="calibre9">Freedom: Allow the user freedom to choose whatever structure and libraries make the most sense for the application being built.</em></span></p><p class="calibre24"><span class="strong"><em class="calibre9">Solid, but not stolid: Use solid base components. For instance, servlets aren't cool, but they are extremely stable and have a huge community behind them. At the same time, work to advance the state of web application development by using new techniques and approaches.</em></span></p><p class="calibre24"><span class="strong"><em class="calibre9">Love HTTP: Embrace HTTP and its stateless nature. People get into trouble when they fool themselves into thinking things which aren't true - fancy server-side tricks to give an illusion of statefulness aren't for us.</em></span></p></blockquote></div><p class="calibre7">As you'll see <a id="id178" class="calibre1"/>in this chapter, the main goal of Scalatra is to keep things simple.</p></div></div>
<div class="book" title="Your first Scalatra service"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec29" class="calibre1"/>Your first Scalatra service</h1></div></div></div><p class="calibre7">To get our <a id="id179" class="calibre1"/>first Scalatra service up and running, we need to take a couple of extra steps. The reason is that Scalatra is designed to run in a servlet container (for example, Tomcat or Jetty). While this works great for test and production environments, it doesn't allow us to do some quick prototyping or easily run from SBT or an IDE. Luckily, you can also start the Jetty servlet container programmatically and run your Scalatra service from there. So, in this section, we'll:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Start by showing you the dependencies required to run Scalatra</li><li class="listitem">Setting up Jetty in such a way that it can run our Scalatra REST service</li><li class="listitem">Creating a simple Scalatra service that responds to a specific <code class="email">GET</code> request</li></ul></div><p class="calibre7">First, let's look at the dependencies for Scalatra. You can find these in the <code class="email">Dependencies.scala</code> file in the <code class="email">project</code> directory of the <code class="email">sources</code> directory. For Scalatra (and Jetty), we define the following:</p><div class="informalexample"><pre class="programlisting">  lazy val scalatraVersion = "2.3.0"
  val backendDeps = Seq(
   "org.scalatra"      %% "scalatra"          % scalatraVersion,
   "ch.qos.logback"    %  "logback-classic"   % "1.1.3",
   "org.eclipse.jetty" %  "jetty-webapp"      % "9.2.10.v20150310"  
  )</pre></div><p class="calibre7">The first dependency in this <code class="email">Seq</code> pulls in all the required Scalatra libraries, the second one allows us to define how and what Jetty will log, and the final dependency is needed so that we can start Jetty programmatically from our project.</p><p class="calibre7">With these dependencies defined, we can create an embedded Jetty server, which we can use to serve <a id="id180" class="calibre1"/>our REST services. The code for this launcher can be found in the <code class="email">chapter4/package.scala</code> file:</p><div class="informalexample"><pre class="programlisting">  object JettyLauncher {

    def launch(bootstrapClass: String): Server = {

      // define the servlet context, point to our Scalatra servlet
      val context = new WebAppContext()
      context.setContextPath "/"
      context.setResourceBase("src/main/webapp")
      context.setInitParameter(ScalatraListener
                              .LifeCycleKey, bootstrapClass)
      context.addEventListener(new ScalatraListener)
      context.addServlet(classOf[DefaultServlet], "/")

      // create a server and attach the context
      val server = new Server(8080)
      server.setHandler(context)

      // add a lifecycle listener so to stop the server from console
      server.addLifeCycleListener(new AbstractLifeCycleListener() {
        override def lifeCycleStarted(event: LifeCycle): Unit = {
          println("Press &lt;enter&gt; to exit.")
          Console.in.read.toChar
          server.stop()
        }
      })

      // start and return the server
      server.start
      server.join
      server
    }
  }</pre></div><p class="calibre7">We'll not dive too much into this code since it isn't really related to Scalatra. The main thing to understand here is that we've defined a function called <code class="email">launch</code>, which takes the name of a bootstrap class as a parameter (more on this later) and that we've added a <code class="email">ScalatraListener</code> instance using the <code class="email">addEventListener</code> function. Once the Jetty server has finished starting up, the <code class="email">ScalatraListener</code> will be called and start the Scalatra service using the provided <code class="email">bootstrapClass</code>.</p><p class="calibre7">Now that we've created <a id="id181" class="calibre1"/>a way to launch our Scalatra service, let's look at the most basic example (source can be found in the <code class="email">HelloScalatra.scala</code> file):</p><div class="informalexample"><pre class="programlisting">package org.restwithscala.chapter4.gettingstarted

import org.restwithscala.chapter4.JettyLauncher
import org.scalatra.{ScalatraServlet, LifeCycle}
import javax.servlet.ServletContext

// run this example by specifying the name of the bootstrap to use
object ScalatraRunner extends App {
  JettyLauncher.launch(
      "org.restwithscala.chapter4.gettingstarted.ScalatraBootstrap")
}

// used by jetty to mount the specified servlet
class ScalatraBootstrap extends LifeCycle {
  override def init(context: ServletContext) {
    context mount (new HelloScalatra, "/*")
  }
}

// the real servlet code
class HelloScalatra extends ScalatraServlet  {

  notFound {
    "Route not found"
  }

  get("/") {
    "Hello from scalatra"
  }
}</pre></div><p class="calibre7">Let's walk through this file from top to bottom. At the top, we define an object called <code class="email">ScalatraRunner</code>. With this object, we start our REST service by calling launch on the <code class="email">JettyLauncher</code> we saw previously. We also pass the name of the <code class="email">ScalatraBootstrap</code> class to the launcher so that the <code class="email">ScalatraListener</code> we saw earlier can call the ScalatraBootstrap's <code class="email">init</code> method when Jetty has finished starting up. In the <code class="email">ScalatraBootstrap</code> class, we implement the <code class="email">init</code> method and use that to instantiate our REST service (in this example, it is called <code class="email">HelloScalatra</code>) and make it available to the outside world by calling mount. For each of the examples in this chapter, we'll use this same approach. In the <code class="email">HelloScalatra</code> class, we finally see our REST service definition. In this case, we define a route which returns <code class="email">Hello from scalatra</code> when it receives a <code class="email">GET</code> request on the <code class="email">/</code> path. If no route matches, the <code class="email">notFound</code> function is triggered which returns a <code class="email">404</code> message stating <code class="email">route not found</code>.</p><p class="calibre7">All that is left to<a id="id182" class="calibre1"/> do is test these two scenarios. From the sources directory, run <code class="email">sbt runCH04-HelloScalatra</code>. This should show an output similar to this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre8">$ sbt runCH04-HelloScalatra</strong></span>
<span class="strong"><strong class="calibre8">[info] Loading project definition from /Users/jos/dev/git/rest-with-scala/project</strong></span>
<span class="strong"><strong class="calibre8">[info] Set current project to rest-with-scala (in build file:/Users/jos/dev/git/rest-with-scala/)</strong></span>
<span class="strong"><strong class="calibre8">[info] Running org.restwithscala.chapter4.gettingstarted.ScalatraRunner </strong></span>
<span class="strong"><strong class="calibre8">20:42:09.020 [run-main-0] INFO  org.eclipse.jetty.util.log - Logging initialized @31722ms</strong></span>
<span class="strong"><strong class="calibre8">20:42:09.536 [run-main-0] INFO  org.eclipse.jetty.server.Server - jetty-9.2.10.v20150310</strong></span>
<span class="strong"><strong class="calibre8">20:42:09.940 [run-main-0] INFO  o.e.j.w.StandardDescriptorProcessor - NO JSP Support for /, did not find org.eclipse.jetty.jsp.JettyJspServlet</strong></span>
<span class="strong"><strong class="calibre8">20:42:10.015 [run-main-0] INFO  o.scalatra.servlet.ScalatraListener - The cycle class name from the config: org.restwithscala.chapter4.gettingstarted.ScalatraBootstrap</strong></span>
<span class="strong"><strong class="calibre8">20:42:10.304 [run-main-0] INFO  o.scalatra.servlet.ScalatraListener - Initializing life cycle class: ScalatraBootstrap</strong></span>
<span class="strong"><strong class="calibre8">20:42:10.643 [run-main-0] INFO  o.e.j.server.handler.ContextHandler - Started o.e.j.w.WebAppContext@78dac2c7{/,file:/Users/jos/dev/git/rest-with-scala/src/main/webapp,AVAILABLE}</strong></span>
<span class="strong"><strong class="calibre8">20:42:10.924 [run-main-0] INFO  o.e.jetty.server.ServerConnector - Started ServerConnector@15f336ae{HTTP/1.1}{0.0.0.0:8080}</strong></span>
<span class="strong"><strong class="calibre8">20:42:10.925 [run-main-0] INFO  org.eclipse.jetty.server.Server - Started @33637ms</strong></span>
<span class="strong"><strong class="calibre8">Press &lt;enter&gt; to exit.</strong></span>
</pre></div><p class="calibre7">At this point, we can press <span class="strong"><em class="calibre9">Enter</em></span> to stop the server or fire up Postman and test our service. In Postman, you'll find a collection of requests for this chapter; let's just test the request (<code class="email">hello scalatra</code>), which returns our <code class="email">Hello from scalatra</code> message so that we know everything is working as it should be:</p><div class="mediaobject"><img src="../images/00028.jpeg" alt="Your first Scalatra service" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre7">As we can see in the <a id="id183" class="calibre1"/>preceding screenshot, the response from Scalatra is as we expected, so our basic Scalatra setup is working correctly.</p></div>
<div class="book" title="Verb and path handling"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec30" class="calibre1"/>Verb and path handling</h1></div></div></div><p class="calibre7">Now that<a id="id184" class="calibre1"/> we've got our basic Scalatra REST service running, let's look at a more elaborate example, which we'll use to explore some more features of Scalatra. Before<a id="id185" class="calibre1"/> we look at the code, let's make a request from Postman. First, start the server by calling <code class="email">sbt runCH04-runCH04Step1</code> from the console, which shows something similar to this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre8">$ sbt runCH04-runCH04Step1</strong></span>
<span class="strong"><strong class="calibre8">[info] Loading project definition from /Users/jos/dev/git/rest-with-scala/project</strong></span>
<span class="strong"><strong class="calibre8">[info] Set current project to rest-with-scala (in build file:/Users/jos/dev/git/rest-with-scala/)</strong></span>
<span class="strong"><strong class="calibre8">[info] Running org.restwithscala.chapter4.steps.ScalatraRunnerStep1 </strong></span>
<span class="strong"><strong class="calibre8">10:51:40.313 [run-main-0] INFO  o.e.jetty.server.ServerConnector - Started ServerConnector@538c2499{HTTP/1.1}{0.0.0.0:8080}</strong></span>
<span class="strong"><strong class="calibre8">10:51:40.315 [run-main-0] INFO  org.eclipse.jetty.server.Server - Started @23816ms</strong></span>
<span class="strong"><strong class="calibre8">Press &lt;enter&gt; to exit.</strong></span>
</pre></div><p class="calibre7">Next, open up Postman and from the folder, <code class="email">chapter-04</code>, select <code class="email">request Step 01 – Update Task</code> and send it to the server. This request will simulate creating a new task and will respond by echoing some of the information it has received:</p><div class="mediaobject"><img src="../images/00029.jpeg" alt="Verb and path handling" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre7">As you can <a id="id186" class="calibre1"/>see from the preceding screenshot, our server is up and <a id="id187" class="calibre1"/>running, and responds with a message containing the updated task. Next, we'll walk through the code of this Scalatra service:</p><div class="informalexample"><pre class="programlisting">package org.restwithscala.chapter4.steps

import javax.servlet.ServletContext

import org.restwithscala.chapter4.JettyLauncher
import org.scalatra.{NotFound, BadRequest, ScalatraServlet, LifeCycle}

import scala.util.{Failure, Success, Try}

// run this example by specifying the name of the bootstrap to use
object ScalatraRunnerStep1 extends App {
  JettyLauncher.launch(
    "org.restwithscala.chapter4.steps.ScalatraBootstrapStep1")
}

class ScalatraBootstrapStep1 extends LifeCycle {
  override def init(context: ServletContext) {
    context mount (new ScalatraStep1, "/*")
  }
}

class ScalatraStep1 extends ScalatraServlet  {

  notFound { "Route not implemented" }

  post("/tasks") { s"create a new task with body ${request.body}"}
  get("/tasks") { "Get all the tasks" }
  get("/tasks/:id") {
    Try { params("id").toInt }  match {
      case Success(id) =&gt; s"Get task with id: ${params("id")} "
      case Failure(e) =&gt; BadRequest(reason = "Can't parse id")
    }
  }
  delete("/tasks/:id") { s"Delete task with id: ${params("id")} "}
  put("/tasks/:id") { s"Update an existing task " +
    s"with id:  ${params("id")} " +
    s"and body ${request.body}"}
}</pre></div><p class="calibre7">As we <a id="id188" class="calibre1"/>mentioned in the previous section, we need to<a id="id189" class="calibre1"/> call <code class="email">JettyLauncher</code> and define a <code class="email">ScalatraBootstrapStep1</code> class to run our service. The interesting code in this example is located in the <code class="email">ScalatraStep1</code> class, which defines a number of routes that we can call from our REST client.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="tip11" class="calibre1"/>Tip</h3><p class="calibre7">When you look at the routes in this chapter, you'll notice that the more generic routes are at the top of the <code class="email">ScalatraServlet</code> class. The reason is that Scalatra tries to match incoming requests starting from the bottom and from there, it moves up. So when defining routes, take care that you place the most generic routes at the top and the most specific ones at the bottom.</p></div><p class="calibre7">In the <code class="email">ScalatraStep1</code> class, we define a number of routes. Let's look at a couple of these:</p><div class="informalexample"><pre class="programlisting">  get("/tasks/:id") {
    Try { params("id").toInt }  match {
      case Success(id) =&gt; s"Get task with id: ${params("id")} "
      case Failure(e) =&gt; BadRequest(reason = "Can't parse id")
    }
  }
  ...
  put("tasks/:id") { s"Update an existing task " +
    s"with id:  ${params("id")} " +
    s"and body ${request.body}"}</pre></div><p class="calibre7">Here we see two routes. The <code class="email">get("/tasks/:id")</code> matches <code class="email">GET</code> HTTP requests made on a URL, which looks similar to <code class="email">/tasks/12</code>. When the request is made, we use the <code class="email">params</code> function to get <a id="id190" class="calibre1"/>the value of the path segment and try and convert <a id="id191" class="calibre1"/>it to an integer. If this is successful, we just return a string, and if not, we return the HTTP error, <code class="email">BadRequest</code>. The <code class="email">put("tasks/:id")</code> route matches <code class="email">PUT</code> HTTP requests and always returns a string, which contains the provided ID using the <code class="email">params</code> function, and also shows the sent message body that can be accessed through the <code class="email">request.body</code> value. Besides the <code class="email">params</code> function, Scalatra also provides a <code class="email">multiParams</code> function. With the <code class="email">multiParams</code> function, you don't get a single string, but a <code class="email">Seq[String]</code> instance. This is especially useful if you want to access request parameters that have multiple values. For instance, if we match on <code class="email">/task/search?status=new,old</code>, we can get a <code class="email">Seq[String]</code> containing new and old by calling <code class="email">multiParams("status")</code>.</p><p class="calibre7">Besides matching directly on a path element, Scalatra also supports a number of other ways to match an HTTP request. The following table shows how you can match specific HTTP verbs and routes in Scalatra:</p><div class="informalexample"><table border="1" class="calibre15"><colgroup class="calibre16"><col class="calibre17"/><col class="calibre17"/></colgroup><thead class="calibre18"><tr class="calibre19"><th valign="bottom" class="calibre20">
<p class="calibre21">Construct</p>
</th><th valign="bottom" class="calibre20">
<p class="calibre21">Description</p>
</th></tr></thead><tbody class="calibre22"><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">get("/")</code>, <code class="literal">post("/")</code>, <code class="literal">put("/")</code>, <code class="literal">delete("/")</code> and the other HTTP verbs.</p>
</td><td valign="top" class="calibre23">
<p class="calibre21">Scalatra allows you to match a specific HTTP verb. Scalatra supports the following HTTP verbs, which you can directly use in your route definition: <code class="literal">options</code>, <code class="literal">get</code>, <code class="literal">head</code>, <code class="literal">post</code>, <code class="literal">put</code>, <code class="literal">delete</code>, <code class="literal">trace</code>, <code class="literal">connect</code>, and <code class="literal">patch</code>.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">get("/full/path")</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">The most basic way to match a request on a specific path is by specifying the full path to match on. This will only match if the provided path matches exactly. In this case, <code class="literal">"/full/path"</code> will match, while <code class="literal">"/full/path/something"</code> won't.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">get("/path/:param")</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">As we've seen in the examples, you can also extract variables from the path by prefixing a path segment with a <code class="literal">:</code>. This will match paths such as <code class="literal">"/path/12"</code> and <code class="literal">"path/hello"</code>.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">get("""^\/tasks\/(.*)""".r)</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">You can also use a regular expression to match a specific path in Scalatra. To access the groups that match, you can either use the <code class="literal">params("splat")</code> call or through the <code class="literal">multiParams("splat")</code> function call.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">get("/*/*")</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">Scalatra also support the use of wildcards. You can access the parameters that match either through the <code class="literal">params("splat")</code> call or through the <code class="literal">multiParams("splat")</code> function call.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">get("/tasks", condition1, condition2)</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">You can further fine-tune the matching by supplying conditions. A condition is a function that returns either <code class="literal">True</code> or <code class="literal">False</code>. If all conditions return <code class="literal">True</code>, the route matches, and is executed. For example, you can use something similar to <code class="literal">post("/tasks", request.getHeader("headername") == "headerValue")</code>.</p>
</td></tr></tbody></table></div><p class="calibre7">Before we move on to the next section, let's have a quick look at how you can access all the attributes of a request. So far, we've seen <code class="email">params</code>, <code class="email">multiParams</code>, and <code class="email">request.body</code> to access certain <a id="id192" class="calibre1"/>parts. Scalatra also exposes the other parts of a <a id="id193" class="calibre1"/>request. The following table shows a complete overview of the helper functions and request properties exposed by Scalatra (note that you can easily use these request properties as conditions in your routes):</p><div class="informalexample"><table border="1" class="calibre15"><colgroup class="calibre16"><col class="calibre17"/><col class="calibre17"/></colgroup><thead class="calibre18"><tr class="calibre19"><th valign="bottom" class="calibre20">
<p class="calibre21">Function</p>
</th><th valign="bottom" class="calibre20">
<p class="calibre21">Description</p>
</th></tr></thead><tbody class="calibre22"><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">requestPath</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This returns the path against which the route is matched.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">multiParams(key)</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This returns the value of a request parameter (or match path segment) as a <code class="literal">Seq[String]</code>.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">Params(key)</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This returns the value of a request parameter (or match path segment) as a string.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">request.serverProtocol</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This returns an <code class="literal">HttpVersion</code> object, which is either <code class="literal">Http11</code> or <code class="literal">Http10</code>.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">request.uri</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This is the URI of the request as a <code class="literal">java.net.URI</code>.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">request.urlScheme</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This returns a <code class="literal">Scheme</code> object, either <code class="literal">Http</code> or <code class="literal">Https</code>.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">request.requestMethod</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This returns an <code class="literal">HttpMethod</code>, for example, <code class="literal">Get</code>, <code class="literal">Post</code>, or <code class="literal">Put</code>.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">request.pathInfo</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This returns the path info from the request or an empty string if no pathinfo is available.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">Request.scriptName</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This returns the servlet path part of the request as a string.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">Request.queryString</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This returns the query string of the request or an empty string if no query string is present.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">Request.multiParameters</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This returns a map of all the parameters of this request as a <code class="literal">MultiMap</code>. This contains the parameters from the query string and any posted form data.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">request.headers</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This returns all the headers as a <code class="literal">Map[String, String]</code> object.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">request.header(key)</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This gets a specific header from the request and returns an <code class="literal">Option[String]</code>.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">request.characterEncoding</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This returns, if present, the character encoding of the request and an <code class="literal">Option[String]</code>.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">request.contentType</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This gets the content-type of the request if present and returns an <code class="literal">Option[String]</code>.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">request.contentLength</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This gets the length of the content and returns an <code class="literal">Option[Long]</code>.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">request.serverName</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This returns the server name part of the complete path and a string.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">request.serverPort</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This returns the port of the server as an integer.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">request.referrer</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This tries to get the referrer from the request and returns an <code class="literal">Option[String]</code>.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">request.body</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This returns the body of the request as a string.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">request.isAjax</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This checks whether the request is an AJAX request. It does this by checking the presence of an <code class="literal">X-Requested-With</code> header.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">request.isWrite</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">Checks whether the request is not safe (see RFC 2616).</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">request.multiCookie</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This returns a map of all the cookies of this request as a <code class="literal">MultiMap</code>.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">request.cookies</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This returns all the cookies as a <code class="literal">Map[String, String]</code>.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">request.inputStream</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This gets the <code class="literal">inputStream</code> of the request, which can be used to read the body. Note that this <code class="literal">inputStream</code> is already consumed when you call <code class="literal">request.body</code>.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">request.remoteAddress</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This tries to get the clients IP address and returns it as a string.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">request.locale</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This returns the <code class="literal">Locale</code> value from the request.</p>
</td></tr></tbody></table></div><p class="calibre7">As you can see, Scalatra wraps all the normal request properties and attributes you'd expect and makes <a id="id194" class="calibre1"/>them easily available either through some helper functions or as properties on the available request value.</p><p class="calibre7">Now that we've explored <a id="id195" class="calibre1"/>the basic functionality of Scalatra and seen how we can match HTTP verbs and paths, we'll look at some more advanced features in the next section.</p></div>
<div class="book" title="Add support for futures and simple validation"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec31" class="calibre1"/>Add support for futures and simple validation</h1></div></div></div><p class="calibre7">In this <a id="id196" class="calibre1"/>section, we'll add support for <a id="id197" class="calibre1"/>futures to Scalatra and show a couple of first steps to validate incoming requests. To work asynchronously, Scalatra needs some additional dependencies. The complete list of dependencies required for this examples are the following:</p><div class="informalexample"><pre class="programlisting">  lazy val scalatraVersion = "2.3.0"
  val backendDeps = Seq(
      "org.scalatra" %% "scalatra" % scalatraVersion,
      "ch.qos.logback"% "logback-classic" % "1.1.3",
      "org.eclipse.jetty" %  "jetty-webapp" % "9.2.10.v20150310",
      "com.typesafe.akka" %% "akka-actor" % "2.3.4"</pre></div><p class="calibre7">As you can see <a id="id198" class="calibre1"/>from the dependencies, Scalatra uses <a id="id199" class="calibre1"/>Akka (<a class="calibre1" href="http://akka.io">http://akka.io</a>) to handle requests asynchronously. However, you don't need to know much about Akka to get everything up and running. In <a id="id200" class="calibre1"/>the following code fragment, we show you the basic glue that is required to connect all the moving parts:</p><div class="informalexample"><pre class="programlisting">package org.restwithscala.chapter4.steps

import javax.servlet.ServletContext

import akka.actor.ActorSystem
import org.restwithscala.chapter4.JettyLauncher
import org.restwithscala.common.model.{Status, Task}
import org.restwithscala.common.service.TaskService
import org.scalatra._
import org.slf4j.LoggerFactory

import scala.concurrent.{Future, ExecutionContext}
import scala.util.{Failure, Success, Try}


object ScalatraRunnerStep2 extends App {
  JettyLauncher.launch(
       "org.restwithscala.chapter4.steps.ScalatraBootstrapStep2")
}

class ScalatraBootstrapStep2 extends LifeCycle {

  val system = ActorSystem()

  override def init(context: ServletContext) {
    context.mount(new ScalatraStep2(system), "/*")
  }

  override def destroy(context: ServletContext) {
    system.shutdown()
  }
}

class ScalatraStep2(system: ActorSystem) extends ScalatraServlet 
                                            with FutureSupport {

  protected implicit def executor: ExecutionContext 
                                      = system.dispatcher
  val Log = LoggerFactory.getLogger(this.getClass)

  ...
}</pre></div><p class="calibre7">In this code <a id="id201" class="calibre1"/>fragment, we use the <a id="id202" class="calibre1"/>JettyLauncher we've already seen to start the Jetty server and specify the Scalatra bootstrap class that we want to start when Jetty is started. In the bootstrap for this example, we take a couple of additional steps:</p><div class="informalexample"><pre class="programlisting">class ScalatraBootstrapStep2 extends LifeCycle {

  val system = ActorSystem()

  override def init(context: ServletContext) {
    context.mount(new ScalatraStep2(system), "/*")
  }

  override def destroy(context: ServletContext) {
    system.shutdown()
  }
}</pre></div><p class="calibre7">When this class is instantiated, we create a new Akka, <code class="email">ActorSystem</code>, which is required by Akka. We pass this system to the constructor of our Scalatra route (<code class="email">ScalatraStep2</code>) so that we can use it from there. In this bootstrap class, we also override the <code class="email">destroy</code> function. When the Jetty server is shut down, this will neatly close the <code class="email">ActorSystem</code> and clean up any open resources.</p><p class="calibre7">Before we look at the code that handles our routes, we'll first make some calls from Postman to better understand what our routes need to do. So, start the server for this part with <code class="email">sbt runCH04-runCH04Step2</code>:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre8">$ sbt runCH04-runCH04Step2</strong></span>
<span class="strong"><strong class="calibre8">[info] Loading project definition from /Users/jos/dev/git/rest-with-scala/project</strong></span>
<span class="strong"><strong class="calibre8">[info] Set current project to rest-with-scala (in build file:/Users/jos/dev/git/rest-with-scala/)</strong></span>
<span class="strong"><strong class="calibre8">[info] Running org.restwithscala.chapter4.steps.ScalatraRunnerStep2 </strong></span>
<span class="strong"><strong class="calibre8">17:46:00.339 [run-main-0] INFO  org.eclipse.jetty.util.log - Logging initialized @19201ms</strong></span>
<span class="strong"><strong class="calibre8">17:46:00.516 [run-main-0] INFO  org.eclipse.jetty.server.Server - jetty-9.2.10.v20150310</strong></span>
<span class="strong"><strong class="calibre8">17:46:01.572 [run-main-0] INFO  o.e.jetty.server.ServerConnector - Started ServerConnector@5c3c276c{HTTP/1.1}{0.0.0.0:8080}</strong></span>
<span class="strong"><strong class="calibre8">17:46:01.572 [run-main-0] INFO  org.eclipse.jetty.server.Server - Started @20436ms</strong></span>
<span class="strong"><strong class="calibre8">Press &lt;enter&gt; to exit.</strong></span>
</pre></div><p class="calibre7">Now <a id="id203" class="calibre1"/>create<a id="id204" class="calibre1"/> a number of tasks by using the <span class="strong"><strong class="calibre8">Step 02 – Create Task</strong></span> request from this chapter:</p><div class="mediaobject"><img src="../images/00030.jpeg" alt="Add support for futures and simple validation" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre7">To get an overview of all the tasks that have been stored, use the <span class="strong"><strong class="calibre8">Step 02 – Get All Tasks</strong></span> request:</p><div class="mediaobject"><img src="../images/00031.jpeg" alt="Add support for futures and simple validation" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre7">As you can <a id="id205" class="calibre1"/>see<a id="id206" class="calibre1"/> from the two screenshots, this time we store the tasks, and you can retrieve them through other REST calls. The code for these two routes, and a route to delete a task based on an ID, is shown next:</p><div class="informalexample"><pre class="programlisting">class ScalatraStep2(system: ActorSystem) extends ScalatraServlet 
                                            with FutureSupport {

  protected implicit def executor: ExecutionContext 
                                      = system.dispatcher
  val Log = LoggerFactory.getLogger(this.getClass)

  before("/*") {
    Log.info(s"Processing request for: ${params("splat")}")
  }

  after(""""^\/tasks\/(.*)"""".r) {
    Log.info(s"Processed request for tasks: ${params("captures")}")
  }

  notFound {
    "Route not implemented"
  }

  post("/tasks") {
    new AsyncResult() { 
      // we use a AsyncResult since we access the parameters
      override val is  = {
        // convert provided request parameters to a task and store it
        val createdTask = TaskService.insert(Task( -1,
          params.getOrElse("title", 
                          halt(status = 400, 
                               reason="Title is required")), request.body, None, List.empty, Status(params.getOrElse("status", "new"))))

        // the result is a Future[Task]; map this to a string
        createdTask.map(_.toString)
      }
    }
  }

  get("/tasks") {
      // directly return Future since we don't access request
      TaskService.all.map(_.toString) }

  delete("/tasks/:id") {
    new AsyncResult() {
      override val is = Try { params("id").toLong } match {
        case Success(id) =&gt; TaskService.delete(id).map(_.toString)
        case Failure(e) =&gt; Future{BadRequest(
                       reason = s"Can't parse id: ${e.getMessage}")}
      }
    }
  }
}</pre></div><p class="calibre7">Let's walk <a id="id207" class="calibre1"/>through this code fragment and <a id="id208" class="calibre1"/>see what is happening. Let's start with the definition of the class that holds the routes and the first statement inside the class:</p><div class="informalexample"><pre class="programlisting">class ScalatraStep2(system: ActorSystem) extends ScalatraServlet 
                                            with FutureSupport {

  protected implicit def executor: ExecutionContext 
                                      = system.dispatcher</pre></div><p class="calibre7">This time, besides extending from <code class="email">ScalatraServlet</code>, we also mix in the <code class="email">FutureSupport</code> trait. When we mix in this trait, we add support for futures to Scalatra. This trait also <a id="id209" class="calibre1"/>requires us to define an <code class="email">ExecutionContext</code> instance. In this example, we use the default, <code class="email">ExecutionContext</code>, provided by Akka. You can, of course, also define and configure one yourself.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="tip12" class="calibre1"/>Tip</h3><p class="calibre7">An <code class="email">ExecutionContext</code> is used by programs to execute logic asynchronously and for the developer to gain a finer control of threading. You could, for instance, execute a piece of code by passing a <code class="email">Runnable</code> instance to the <code class="email">execute</code> method. Scalatra and Akka hide all the details of how the <code class="email">ExecutionContext</code> is used, but it is up to the developer to specify which <code class="email">ExecutionContext</code> to use and how it is configured.</p></div><p class="calibre7">Now that we've <a id="id210" class="calibre1"/>configured the last part, we can look at running calls asynchronously. The first route we'll look at is the <code class="email">get("/tasks")</code> route:</p><div class="informalexample"><pre class="programlisting">  get("/tasks") {
      // directly return future since we don't access request
      TaskService.all.map(_.toString) }</pre></div><p class="calibre7">This route is very simple. It calls the <code class="email">TaskService.all</code> function, which returns a <code class="email">Future[List[Task]]</code> and we transform this to a <code class="email">Future[String]</code> through the <code class="email">map</code> function. Internally, Scalatra will run this request on top of Akka, and wait, non-blocking, for the <code class="email">Future</code> to finish. Once it is finished, Scalatra will return the string to the client. The great thing is that you don't have to do anything yourself. Just return a <code class="email">Future</code> object, and Scalatra knows how to handle everything since we added <code class="email">FutureSupport</code>. In this sample, we just return a string inside the <code class="email">Future</code>. Scalatra also supports a number of other return types you can use:</p><div class="informalexample"><table border="1" class="calibre15"><colgroup class="calibre16"><col class="calibre17"/><col class="calibre17"/></colgroup><thead class="calibre18"><tr class="calibre19"><th valign="bottom" class="calibre20">
<p class="calibre21">Type</p>
</th><th valign="bottom" class="calibre20">
<p class="calibre21">Description</p>
</th></tr></thead><tbody class="calibre22"><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">ActionResult</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">An <code class="literal">ActionResult</code> type is a class where you can set the status, body, and headers which are returned. Scalatra comes with a large number of standard <code class="literal">ActionResult</code> you can use—<code class="literal">OK</code>, <code class="literal">Created</code>, <code class="literal">Accepted</code>, and so on. For a complete overview, look at the source for the <code class="literal">ActionResult.scala</code> file.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">Array[Byte]</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">The content-type of the response (if not set) is set to application/octet-stream, and the byte array is returned.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">NodeSeq</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">The content-type of the response (if not set) is set to <code class="literal">text/HTML</code> and the <code class="literal">NodeSeq</code> instance is converted to a string and is returned.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">Unit</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">If you don't specify anything, Scalatra assumes you've set the correct values in the response object yourself.</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">Any</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">The content-type of the response (if not set) is set to <code class="literal">text/plain</code> and the <code class="literal">toString</code> method is called on the object and the result is returned.</p>
</td></tr></tbody></table></div><p class="calibre7">Note that you can override this functionality, or add new functionality, by overriding the <code class="email">renderResponse</code> function.</p><p class="calibre7">Now let's look at the <code class="email">delete("/tasks/:id")</code> route:</p><div class="informalexample"><pre class="programlisting">  delete("/tasks/:id") {
    new AsyncResult() {
      override val is = Try { params("id").toLong } match {
        case Success(id) =&gt; TaskService.delete(id).map(_.toString)
        case Failure(e) =&gt; Future{BadRequest(
                       reason = s"Can't parse id: ${e.getMessage}")}
      }
    }
  }</pre></div><p class="calibre7">The <code class="email">TaskService.delete</code> service returns a <code class="email">Future[Option[Task]]</code>, which we transform <a id="id211" class="calibre1"/>to a <code class="email">Future[String]</code>, just<a id="id212" class="calibre1"/> like we did in the previous code fragment. The main difference here is that we don't directly return a <code class="email">Future</code>, but wrap the block inside an <code class="email">AsyncResult</code> object. The reason why we need to do this is that we access values from the request. We use <code class="email">params("id")</code> to get the value from the URL path. If you access any information from the request, you need to wrap it in an <code class="email">AsyncResult</code> object to avoid timing issues and strange exceptions.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="tip13" class="calibre1"/>Tip</h3><p class="calibre7">When working with futures or when adding new complex routes, it is often practical to add some logging to see what is happening before and after the request has been processed. Scalatra supports this through the <code class="email">before("path")</code> and <code class="email">after("path")</code> functions you can define in your class. In this example, we, for instance, log every request by specifying a <code class="email">before(/*)</code> function and log some additional information afterward for the request made to a specific path defined by a regular expression: <code class="email">after(""""^\/tasks\/(.*)"""".r).</code></p></div><p class="calibre7">Now let's move on to some simple validations. Look at the following code from the <code class="email">POST</code> method:</p><div class="informalexample"><pre class="programlisting">       val createdTask = TaskService.insert(Task( -1,
          params.getOrElse("title", 
                          halt(status = 400, 
                               reason="Title is required")), request.body, None, List.empty, Status(params.getOrElse("status", "new"))))

          // the result is a Future[Task]; map this to a string
          createdTask.map(_.toString)
      }</pre></div><p class="calibre7">What you <a id="id213" class="calibre1"/>see here is that we can use <a id="id214" class="calibre1"/>
<code class="email">getOrElse</code> on the parameters to check whether it is provided, and if not, we can either throw an error or add a default value.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="tip14" class="calibre1"/>Tip</h3><p class="calibre7">Note that we've used a special construct here from Scalatra—<code class="email">halt</code>. When this function is called, Scalatra will immediately stop processing the request and return the specified HTTP response. Besides halt, Scalatra also provides a <code class="email">pass</code> function which can be used to stop processing inside the current route and instead try to see if there are other routes that might match.</p></div><p class="calibre7">This is just some basic simple validation. In the next section, we'll look at the more advanced ways of adding validation.</p></div>

<div id="page" style="height:0pt"/><div class="book" title="Advanced validation and JSON support"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec32" class="calibre1"/>Advanced validation and JSON support</h1></div></div></div><p class="calibre7">For the<a id="id215" class="calibre1"/> final example, we're going to add JSON support to the service and some more advanced validations. To test the examples in this section, run <code class="email">sbt runCH04-runCH04Step3</code>.</p></div>

<div class="book" title="Advanced validation and JSON support">
<div class="book" title="Add JSON support"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch04lvl2sec27" class="calibre1"/>Add JSON support</h2></div></div></div><p class="calibre7">Let's <a id="id216" class="calibre1"/>start by<a id="id217" class="calibre1"/> adding JSON support. First off, add the following dependencies to the SBT build file:</p><div class="informalexample"><pre class="programlisting">"org.json4s"   %% "json4s-jackson" % "3.2.9",
"org.scalatra" %% "scalatra-json" % scalatraVersion,</pre></div><p class="calibre7">Adding JSON support only takes a couple of simple steps. First, change the class definition of our route to the following:</p><div class="informalexample"><pre class="programlisting">class ScalatraStep3(system: ActorSystem) extends ScalatraServlet
                  with FutureSupport
                  with JacksonJsonSupport {</pre></div><p class="calibre7">With the <code class="email">JacksonJsonSupport</code> trait added, we next need to add the following line to enable automatic JSON parsing:</p><div class="informalexample"><pre class="programlisting">protected implicit val jsonFormats: Formats = DefaultFormats</pre></div><p class="calibre7">Now we only need <a id="id218" class="calibre1"/>to inform the routes that we want to work with JSON. For this, we use the <code class="email">before()</code> function, where we set the following:</p><div class="informalexample"><pre class="programlisting">  before("/*") {
    contentType = formats("json")
}</pre></div><p class="calibre7">At this point, we<a id="id219" class="calibre1"/> can just return our case classes, and Scalatra will automatically convert them to JSON. For instance, for the get all tasks service, it looks similar to this:</p><div class="informalexample"><pre class="programlisting">  get("/tasks") {
      TaskService.all // we use json4s serialization to json.
  }</pre></div><p class="calibre7">Before we look at Postman and see the requests, we need to take one final step so that we can also store the incoming JSON messages. Let's look at the <code class="email">post("/tasks")</code> function:</p><div class="informalexample"><pre class="programlisting">  post("/tasks") {
    new AsyncResult() { 
      override val is  = {
        // convert provided request parameters to a task and store it
        TaskService.insert(parsedBody.extract[Task])
      }
    }
  }</pre></div><p class="calibre7">Let's see this in action. Open Postman and, using the <span class="strong"><strong class="calibre8">Step 03 – Add Task</strong></span> request, add some tasks:</p><div class="mediaobject"><img src="../images/00032.jpeg" alt="Add JSON support" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre7">As you can see, the <a id="id220" class="calibre1"/>body we sent is a JSON message describing the task. Retrieving the messages works<a id="id221" class="calibre1"/> in pretty much the same way. In Postman, you can use the <span class="strong"><strong class="calibre8">Step 03 – Get All Tasks</strong></span> request for this:</p><div class="mediaobject"><img src="../images/00033.jpeg" alt="Add JSON support" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre7">And here, you can see that the tasks you just added are returned.</p></div></div>

<div class="book" title="Advanced validation and JSON support">
<div class="book" title="Advanced validations"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch04lvl2sec28" class="calibre1"/>Advanced validations</h2></div></div></div><p class="calibre7">Now that <a id="id222" class="calibre1"/>we've got JSON support added, let's look at the final part of this chapter and explore how you can add more advanced validations to your Scalatra routes. The first thing we need to do is add one more dependency to our <code class="email">sbt</code> build file (<code class="email">scalatra-commands</code>). At this point, our dependencies should look similar to this:</p><div class="informalexample"><pre class="programlisting">lazy val scalatraVersion = "2.3.0"
val backendDeps = Seq(
    "org.scalatra" %% "scalatra" % scalatraVersion,
    "org.scalatra" %% "scalatra-json" % scalatraVersion,
    "org.scalatra" %% "scalatra-commands" % scalatraVersion,
    "org.json4s"   %% "json4s-jackson" % "3.2.9",
    "ch.qos.logback"    %  "logback-classic"   % "1.1.3",
    "org.eclipse.jetty" %  "jetty-webapp"      % "9.2.10.v20150310",
    "com.typesafe.akka" %% "akka-actor" % "2.3.4"
)</pre></div><p class="calibre7">Through the use of commands, we can add more complex validations to our input parameters. For this, we need to change a couple of things in our route. The first thing we need to do is add <code class="email">CommandSupport</code> to our route:</p><div class="informalexample"><pre class="programlisting">class ScalatraStep3(system: ActorSystem) extends ScalatraServlet
                  with FutureSupport
                  with JacksonJsonSupport with CommandSupport {</pre></div><p class="calibre7">This allows us <a id="id223" class="calibre1"/>to process incoming requests using commands. Next, we need to specify which types of command our service should process. Since we only use a single command in this case, we set the <code class="email">CommandType</code> to <code class="email">SearchTaskCommand</code> (more on this file later):</p><div class="informalexample"><pre class="programlisting">override type CommandType = SearchTasksCommand</pre></div><p class="calibre7">Let's look a bit closer at the commands and validations we'll use in this example:</p><div class="informalexample"><pre class="programlisting">object SearchCommands {

  object SearchTasksCommand {
   implicit def createSearchParams(cmd: SearchTasksCommand):  
                SearchParams = 
                SearchParams(cmd.status.value.get, cmd.text.value)
  }

  class ValidStatusValidations(b: FieldDescriptor[String]) {

    def validStatus(message: String = 
        "%s be either 'new' or 'in progress'.") = 
        b.validateWith(_ =&gt;
               _ flatMap { new PredicateValidator[String](
                    b.name, 
                    List[String]("new", 
                                 "in progress").contains(_),
                                  message).validate(_) }
    )
  }

  /**
   * Params only command parses incoming parameters
   */
  class SearchTasksCommand extends ParamsOnlyCommand {
    implicit def statusValidator(b: FieldDescriptor[String]) 
                      = new ValidStatusValidations(b)

    val text: Field[String] = asType[String]("text")
    val status: Field[String] =  
                asType[String]("status").
                    notBlank.
                    minLength(3).
                    validStatus()
  }

}</pre></div><p class="calibre7">At the bottom of this object, we define a <code class="email">SearchTasksCommand</code> class. This command will process the incoming parameters (since we extend from <code class="email">ParamsOnlyCommand</code>) and check whether the incoming parameters are valid. In this case, we don't validate the text parameter, but expect the <code class="email">status</code> parameter to validate against the <code class="email">notBlank</code>, <code class="email">minLength</code>, and the custom <code class="email">validStatus</code> validators. In this object, we also define an implicit conversion between the <code class="email">SearchTaskCommand</code> class and the <code class="email">SearchParams</code> case class, which we can use in our service. This makes the code in our route more clean, as we'll see later.</p><p class="calibre7">We also define a <a id="id224" class="calibre1"/>custom validator in this object—the <code class="email">ValidStatusValidations</code> class. This class takes a <code class="email">FieldDescriptor</code> as its input and defines a <code class="email">validStatus</code> function. In the <code class="email">validStatus</code> function, we use the <code class="email">validateWith</code> function of the <code class="email">FieldDescriptor</code> to validate the value of the parameter. We can write this ourselves or use the <code class="email">PredicateValidator</code>, as we did in this example. Once the validation is defined, we make it available in our command by defining the <code class="email">implicit def statusValidator</code> conversion.</p><p class="calibre7">Scalatra comes with a large set of validators out of the box, which you can use in the manner explained here:</p><div class="informalexample"><table border="1" class="calibre15"><colgroup class="calibre16"><col class="calibre17"/><col class="calibre17"/></colgroup><thead class="calibre18"><tr class="calibre19"><th valign="bottom" class="calibre20">
<p class="calibre21">Name</p>
</th><th valign="bottom" class="calibre20">
<p class="calibre21">Description</p>
</th></tr></thead><tbody class="calibre22"><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">notEmpty</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This checks whether the provided field contains a value</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">greaterThan</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This tries to convert value to a number and checks whether it is greater than the provided value</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">lessThan</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This tries to convert value to a number and checks whether it is less than the provided value</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">greaterThanOrEqualTo</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This tries to convert value to a number and checks whether it is greater than or equal to the provided value</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">lessThanOrEqualTo</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This tries to convert value to a number and checks whether it is less than or equal to the provided value</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">notBlank</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This removes any spaces and checks whether the provided field still contains a value</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">validEmail</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This checks whether the value is a valid e-mail value</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">validAbsoluteUrl</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This checks whether the value is a valid absolute URL</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">validUrl</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This checks whether the value is a valid URL</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">validForFormat</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This checks the value against the provided regular expression</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">minLength</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This validates whether the value's length is at least a specific amount of characters</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">maxLength</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This validates whether the value's length is less than a specific amount of characters</p>
</td></tr><tr class="calibre19"><td valign="top" class="calibre23">
<p class="calibre21"><code class="literal">enumValue</code></p>
</td><td valign="top" class="calibre23">
<p class="calibre21">This checks whether the value is one of the provided values</p>
</td></tr></tbody></table></div><p class="calibre7">Now, we can finally use the command in our route:</p><div class="informalexample"><pre class="programlisting">  get("/tasks/search") {
    new AsyncResult() {
      override val is = (command[SearchTasksCommand] &gt;&gt; 
                  (TaskServiceWrapper.WrapSearch(_))).fold (
        errors =&gt; halt(400, errors),
        tasks =&gt; tasks
      )
    }
  }</pre></div><p class="calibre7">The syntax might <a id="id225" class="calibre1"/>be a bit rough, but the following steps happen here:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><code class="email">Command[SearchTasksCommand] &gt;&gt;</code> means that we execute the command specified in the <code class="email">SearchTasksCommand</code> class and call the function to the right of <code class="email">&gt;&gt;</code></li><li class="listitem">The provided function in this case is <code class="email">TaskServiceWrapper.wrapSearch()</code></li><li class="listitem">The result of this service is a <code class="email">ModelValidation[T]</code> on which we can call <code class="email">fold</code></li><li class="listitem">If our validation returns errors, we halt the call and return the errors</li><li class="listitem">If our validation returns tasks, we just return those</li></ul></div><p class="calibre7">Since we need to return a <code class="email">ModelValidation[T]</code> instance, we have created a simple wrapper service around the <code class="email">TaskService</code>:</p><div class="informalexample"><pre class="programlisting">object TaskServiceWrapper {

  def WrapSearch(search: SearchParams): ModelValidation[Future[List[Task]]] = {
    allCatch.withApply(errorFail) {
      println(search)
      TaskService.search(search).successNel
    }
  }

def errorFail(ex: Throwable) = ValidationError(ex.getMessage, UnknownError).failNel
}</pre></div><p class="calibre7">At this point, when we call the <code class="email">/tasks/search</code> URL, Scalatra will create the command, execute the validations, and if successful, call the <code class="email">WrapSearch</code> function and return a set of tasks. If errors occur during validations, those will be returned instead.</p><p class="calibre7">You can easily test <a id="id226" class="calibre1"/>this with Postman. First, add some tasks through the <span class="strong"><strong class="calibre8">Step 03 – Add Task</strong></span> request. Now when you call <span class="strong"><strong class="calibre8">Step 03 – Search Tasks</strong></span>, you'll just get a set of valid results:</p><div class="mediaobject"><img src="../images/00034.jpeg" alt="Advanced validations" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre7">If, on the other hand, you call <span class="strong"><strong class="calibre8">Step 03 – Search Tasks – Invalid</strong></span>, you'll see an error message:</p><div class="mediaobject"><img src="../images/00035.jpeg" alt="Advanced validations" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre7">In this section, we saw some of the possibilities Scalatra commands provide for validation. You <a id="id227" class="calibre1"/>can do much more with commands than shown in this section; for more information, refer to the Scalatra commands documentation at <a class="calibre1" href="http://www.scalatra.org/2.3/guides/formats/commands.html">http://www.scalatra.org/2.3/guides/formats/commands.html</a>.</p></div></div>
<div class="book" title="Summary"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec33" class="calibre1"/>Summary</h1></div></div></div><p class="calibre7">In this chapter, you learned how to use Scalatra to create a REST service. We saw that you need a custom Jetty launcher to run Scalatra standalone since it's been created to run inside servlet containers. Once you've got Scalatra running, you can just add routes to a class, and they will be automatically picked up when you run Scalatra. Remember, though, that routes are matched starting from the bottom and going up. Scalatra also provides easy access to all the properties of a request and some basic validations through the use of Options. For more advanced validations, you can use the <code class="email">scalatra-commands</code> module, where you can automatically parse incoming parameters and validate against a large set of validators. Finally, adding JSON support to Scalatra is very easy. All you have to is add the correct modules to your build and import the conversions classes.</p><p class="calibre7">In the next chapter, we'll show you how to use the Spray-based DSL from Akka HTTP to create REST services.</p></div></body></html>