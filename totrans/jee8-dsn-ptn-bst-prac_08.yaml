- en: Cloud-Native Application Patterns
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 云原生应用程序模式
- en: In this chapter, we will explain cloud-native application patterns, looking
    at what a cloud-native application is and what its goals are. We will also show
    the patterns already described in previous chapters and new patterns that have
    emerged to address cloud-based applications. After reading this chapter, the reader
    will be able to understand the concepts and patterns that characterize a cloud
    architecture.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将解释云原生应用程序模式，探讨云原生应用程序是什么以及其目标是什么。我们还将展示之前章节中描述的图案以及针对基于云的应用程序出现的新图案。阅读本章后，读者将能够理解表征云架构的概念和模式。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Explaining the concept of cloud-native applications
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释云原生应用程序的概念
- en: Explaining the goals of a cloud application
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释云应用程序的目标
- en: Explaining the cloud design patterns
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释云设计模式
- en: Explaining the concept of cloud-native applications
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解释云原生应用程序的概念
- en: The cloud and its resources are increasingly becoming a part of life for businesses.
    In the past, cloud resources were used for solutions such as storage management,
    emails, documents, and photos. Nowadays, the deployment of enterprise applications
    in the cloud structure certainly points the way to be followed by companies.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 云及其资源正越来越多地成为企业生活的一部分。在过去，云资源被用于存储管理、电子邮件、文档和照片等解决方案。如今，在云结构中部署企业应用程序无疑指明了公司应遵循的道路。
- en: The cloud has become one of the first strategies to consider when developing
    a business application. The big challenge here is to make this application use
    the features offered by the cloud, such as elasticity, scalability, and availability,
    for the benefit of the business.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 云已成为开发业务应用程序时首先考虑的策略之一。这里的重大挑战是使此应用程序使用云提供的功能，如弹性、可扩展性和可用性，以利于业务。
- en: To start off with, monolithic applications were migrated and deployed in the
    cloud. Some gains were achieved such as greater management and control, as well
    as availability. But what we really want is an application integrated with the
    capabilities offered by the cloud, that is, to leverage the cloud computing resources
    to better solve the business.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，单体应用程序被迁移并部署到云中。我们取得了一些成果，如更好的管理和控制，以及可用性。但我们真正想要的是与云提供的功能集成的应用程序，即利用云计算资源更好地解决业务问题。
- en: Then comes the cloud-native application, which is an application that uses the
    benefits and capabilities provided by the cloud. A set of design patterns is used
    for the development of this application. We'll look at some of the main design
    patterns used in cloud architecture in more detail later in the chapter.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 然后是云原生应用程序，这是一种利用云提供的优势和能力的应用程序。该应用程序的开发使用了一套设计模式。我们将在本章后面更详细地探讨云架构中使用的某些主要设计模式。
- en: The cloud computing environment is basically elastic in the sense that computing
    resources are used and released according to demand. Consequently, scalability
    and availability are achieved with less complexity than they would be if the application
    were still under datacenter control.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 云计算环境在基本意义上是弹性的，即计算资源根据需求使用和释放。因此，与数据中心控制下的应用程序相比，可扩展性和可用性以更少的复杂性实现。
- en: 'Based on the cloud-native computing foundation, the properties that guide a
    cloud-native application are as follows:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 基于云原生计算基础，指导云原生应用程序的特性如下：
- en: '**Container-packaged**: The applications are executed in isolated units'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**容器封装**：应用程序在隔离单元中执行'
- en: '**Dynamically-managed**: There is a central orchestration that manages the
    applications, improving the use of the resources, and reducing operational costs'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动态管理**：有一个中央编排来管理应用程序，提高资源利用率，并降低运营成本'
- en: '**Microservices-oriented**: Applications in the cloud are loosely-coupled'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**面向微服务**：云中的应用程序是松散耦合的'
- en: Hence, a cloud-native application has a strongly-distributed nature. This is
    because this application is deployed in the cloud, and these properties are satisfied.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，云原生应用程序具有高度分布的特性。这是因为该应用程序部署在云中，并且这些特性得到了满足。
- en: Explaining the goals of the cloud-native application
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解释云原生应用程序的目标
- en: 'Cloud design patterns aim to build secure, reliable applications available
    in the cloud. The following list will show these and other characteristics to
    be achieved by a cloud-native application:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 云设计模式旨在构建安全、可靠的云应用程序。以下列表将展示云原生应用程序要实现的其他特征：
- en: '**Availability**: The time the application is up and running. What is desired
    is a non-stop operation of all the system''s functionalities.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可用性**：应用程序运行和运行的时间。所期望的是所有系统功能的持续运行。'
- en: '**Data management**: Data handled by an application is the building block of
    a cloud application. Data can be distributed or replicated across many servers
    (or clusters) to achieve scalability, availability, or even performance.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据管理**：应用程序处理的数据是云应用程序的基石。数据可以在多个服务器（或集群）之间分布或复制，以实现可伸缩性、可用性，甚至性能。'
- en: '**Messaging**: To increase scalability, services or applications in the cloud
    have low coupling and often communicate using asynchronous messaging.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**消息传递**：为了提高可伸缩性，云中的服务或应用程序具有低耦合性，并且通常使用异步消息进行通信。'
- en: '**Management and monitoring**: Because cloud applications run in remote environments,
    there must be a way to monitor non-functional property states—such as the use
    of computing resources—through logs and reports. Also, we must be able to deploy
    new implementations without having to stop the application (maintaining the availability
    characteristic).'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**管理和监控**：由于云应用程序在远程环境中运行，必须有一种方法可以通过日志和报告来监控非功能性属性状态——例如计算资源的使用情况。此外，我们必须能够部署新的实现，而无需停止应用程序（保持可用性特性）。'
- en: '**Performance and scalability**: Maintains performance despite an increase
    in the use of computing resources and scaling of the application.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能和可伸缩性**：即使在计算资源的使用和应用程序扩展增加的情况下，也能保持性能。'
- en: '**Resiliency**: A cloud application should be able to overcome a failure quickly.
    This issue is important for maintaining availability.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**弹性**：云应用程序应该能够快速克服故障。这个问题对于保持可用性非常重要。'
- en: '**Security**: A cloud application exposes several of its elements to users
    and should be able to prevent attacks by malicious users or malicious programs.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全性**：云应用程序向用户公开了其多个元素，应该能够防止恶意用户或恶意程序发起的攻击。'
- en: 'It is important here to note that there are some issues that should be taken
    into account when implementing a distributed application, and specifically a cloud-native
    application. These *fallacies of distributed computing* were made by L. Peter
    Deutsch and others at Sun Microsystems, describing false assumptions about distributed
    programming:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里需要注意的是，在实现分布式应用程序，尤其是云原生应用程序时，有一些问题应该予以考虑。这些由L. Peter Deutsch和Sun Microsystems的其他人提出的“分布式计算谬误”描述了关于分布式编程的错误假设：
- en: The network is reliable
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络可靠
- en: Latency is zero
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 延迟为零
- en: Bandwidth is infinite
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带宽无限
- en: The network is secure
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络安全
- en: Topology doesn't change
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拓扑结构不改变
- en: There is one administrator
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有一位管理员
- en: The transport cost is zero
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传输成本为零
- en: The network is homogeneous
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络同质
- en: With the goals and challenges to be achieved by a cloud-native application on
    the one hand, and the difficulties that have always existed for the implementation
    of a distributed application on the other, we have launched the design pattern
    to solve the problems faced by a cloud-native application. As we progress, we
    will show the main design patterns used in the cloud architecture.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 一方面，云原生应用程序要实现的目标和挑战，另一方面，分布式应用程序实现中一直存在的困难，我们推出了设计模式来解决云原生应用程序面临的问题。随着我们的进展，我们将展示在云架构中使用的的主要设计模式。
- en: Explaining the cloud design patterns
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解释云设计模式
- en: 'Now that the cloud application concepts and its challenges are defined, let''s
    get straight to the point and talk about the design patterns used for the implementation
    of a cloud architecture:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 既然云应用程序的概念及其挑战已经定义，让我们直接进入正题，讨论用于实现云架构的设计模式：
- en: Composite application (microservices)
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复合应用程序（微服务）
- en: Abstraction
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象
- en: Twelve-factor
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 十二要素
- en: API Gateway
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API网关
- en: Service registry
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务注册表
- en: Config server
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置服务器
- en: Circuit breaker
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电路断路器
- en: Composite application (microservices)
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复合应用程序（微服务）
- en: In [Chapter 7](9e35e298-1a91-43b8-ace1-805997b2b89e.xhtml), *Microservice Patterns, *we
    demonstrated the advantages (and disadvantages) of decomposing an application
    into functions and taking several benefits from this pattern, always aiming at
    the application business. In that chapter, it was established that a microservice-based
    architecture is characterized by decomposing the application into small, functional,
    independent components with a well-defined communication interface that is loosely-coupled.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第7章](9e35e298-1a91-43b8-ace1-805997b2b89e.xhtml)，《微服务模式》中，我们展示了将应用程序分解为函数的优势（以及劣势），并从中获得多方面的好处，始终以应用业务为目标。在该章中，确立了基于微服务的架构的特点，即通过将应用程序分解为小型、功能独立且具有良好定义的松散耦合通信接口的组件。
- en: Abstraction
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 抽象
- en: This pattern states that the focus must be on what the client needs and not
    on the existing hardware structure. In this sense, the computational resources
    of the cloud are used on demand, which characterizes the elastic scalability.
    In this way, resources are seen in an abstract way and are changed according to
    the needs of the clients.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 此模式指出，重点必须放在客户端的需求上，而不是现有的硬件结构上。从这个意义上说，云计算的计算资源是按需使用的，这体现了弹性可伸缩性。这样，资源以抽象的方式看待，并根据客户的需求进行改变。
- en: Twelve-factor
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 十二要素
- en: The twelve-factor methodology is based on the twelve factors that guide the
    creation of a successful SaaS project. This technology was created during the
    development of Heroku, a cloud service platform (PaaS) that supports several programming
    languages, including Ruby, Java, Node.js, Scala, Clojure, Python, and PHP.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 十二要素方法基于指导创建成功SaaS项目的十二要素。这项技术是在Heroku的开发过程中创建的，Heroku是一个支持多种编程语言的云服务平台（PaaS），包括Ruby、Java、Node.js、Scala、Clojure、Python和PHP。
- en: 'The experience acquired during the development and support of SaaS applications
    was cataloged, that is, observations of the errors encountered, and solutions
    drawn up for the problems that occurred. As a consequence, the twelve-factor methodology
    was created, which is a set of guidelines that make it easier to develop cloud-based
    applications. For teaching purposes, here are some definitions—SaaS stands for
    *Software as a Service*, and PaaS stands for *Platform as a Service*. SaaS is
    best known to the end user as it has the highest growth rate in the market. The
    twelve factors are as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发和支持SaaS应用程序期间获得的经验被编目，即记录遇到的错误，并为出现的问题制定解决方案。因此，创建了十二要素方法，这是一套使开发基于云的应用程序更加容易的指南。为了教学目的，这里有一些定义——SaaS代表*软件即服务*，PaaS代表*平台即服务*。SaaS最广为人知，因为它在市场上的增长率最高。以下为十二要素：
- en: '**Code base**: One codebase is tracked in revision control, while many deploys'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码库**: 在版本控制中跟踪一个代码库，同时进行多次部署'
- en: '**Dependencies**: Explicitly declare and isolate dependencies'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**依赖项**: 明确声明并隔离依赖项'
- en: '**Config**: Store config in the environment'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**配置**: 在环境中存储配置'
- en: '**Backing services**: Treat backing services as attached resources'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**备份服务**: 将备份服务视为附加资源'
- en: '**Build, release, run**: Strictly separate the build and run stages'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**构建、发布、运行**: 严格分离构建和运行阶段'
- en: '**Processes**: Execute the app as one or more stateless processes'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**进程**: 以一个或多个无状态进程执行应用程序'
- en: '**Port-binding**: Export services via port-binding'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**端口绑定**: 通过端口绑定导出服务'
- en: '**Concurrency**: Scale-out via the process model'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**并发**: 通过进程模型进行扩展'
- en: '**Disposability**: Maximize robustness with a fast startup and graceful shutdown'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可丢弃性**: 通过快速启动和优雅关闭最大化鲁棒性'
- en: '**Dev/prod parity**: Keep development, staging, and production as similar as
    possible'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开发/生产一致性**: 尽可能保持开发、预发布和生产环境的相似性'
- en: '**Logs**: Treat logs as event streams'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**日志**: 将日志视为事件流'
- en: '**Admin processes**: Run admin/management tasks as one-off processes'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**管理进程**: 将管理/管理任务作为一次性进程运行'
- en: Codebase
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码库
- en: A codebase is any single repository where the codes reside. There can only be
    one codebase per application. Several applications cannot share a same codebase
    in the twelve-factor methodology. In this case, a solution would be to refactor
    the shared code by generating libraries that would go into the project as dependencies.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 代码库是指任何单一存储代码的仓库。每个应用程序只能有一个代码库。在十二要素方法中，多个应用程序不能共享相同的代码库。在这种情况下，一种解决方案是通过生成作为依赖项进入项目的库来重构共享代码。
- en: A codebase must be managed by a version control system (such as subversion or
    Git). Various deploys are generated from this codebase, each one for a different
    environment—development, staging, and production.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: 'The developer has a version of the application (that is, a deploy) running
    in their local development environment:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/752384bc-0ac1-4f32-8d70-8fd1591df823.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
- en: Dependencies
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Every dependency that is used by the project must be declared and isolated
    from the code. In this case, we can use some package-management tools (such as
    Maven, grundle, and npm). As an example, the Maven tool is used for building and
    documenting projects. The dependencies are declared in the `pom.xml` file, where
    we can declare the project dependencies:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/86b2425c-a240-4065-8691-a1feca460ab0.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
- en: Config
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An application''s config is everything that varies between different deploys.
    It can be:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: Hosts, ports, and credentials for database access
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Database schema
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cache settings
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hosts, ports, and credentials for accessing message queues
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The twelve-factor method requires the separation of config from code. So, the
    config should never be in the code, because the configs may vary between deploys
    but the code does not. The practice of placing the config in files, such as Java
    properties, is not recommended by twelve-factor, as there is always the possibility
    of placing the same configuration data in different environments (an example is
    when a developer commits to the version-control repository with its own local
    configs). Another weakness is the security issue of these configuration files.
    The twelve-factor method recommends the use of environment variables that can
    be injected when deploying an application in a specific environment:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2bb4c0a2-d2e6-478f-a67a-9b0009db5148.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
- en: Backing services
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Backing services are external services used by the application, such as a database,
    message service, file repository, or email service. The twelve-factor method considers
    each service that is external to the application as a resource. Each of these
    resources must be accessed via a URL or location and credentials attributes that
    are in the app's config. In this way, any changes to a service location—such as
    the database or file repository—does not impact the application code. The change
    becomes imperceptible to the code, resulting in a low desired coupling. We can
    also use abstractions or interfaces to access these services in addition to the
    app's config.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: As a first example, we have the file stored in a repository. Access to the repository
    can be executed via a URL, regardless of local or remote access (such as Amazon
    S3). For this, we use the app's config. Of course, the way to store files locally
    or remotely, in the last instance, may be different, but the use of an interface
    greatly improves this issue.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: 'As a second example, we have the use of a SQL database in different environments
    (production, staging, and development). We should only change the URL of the connection
    to the database using what is in the application''s config. This strategy should
    be extended to a possible change of database management systems, such as from
    MySQL to DB2\. Of course, we know that in practice, the use of specific mechanisms
    for a database can improve performance. However, the changes, if they happened,
    would be minimal:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/abe84a15-b5a3-40db-9c60-3bfbe15b2d55.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
- en: Build, release, run
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The process of transforming a codebase into a given environment must be divided
    into three strictly separate stages:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '**Build**: Compiles and generates an executable package; for example, generating
    an EAR or WAR archive.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Release**: Applies the app''s config in the executable package. The resulting
    release, which is the combination of the package generated in the build with the
    app''s config, is ready to be scanned in the environment that contains the config.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Run** (or runtime): Initializes the application in the specific environment.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The separation of these steps, that is, the definition of their responsibilities
    is important for improving system maintenance and automation. Continuous integration
    tools are used in these steps (Maven and Jenkins are examples of these tools):'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8adcda1d-cb5f-40af-88ba-2709a0b2c489.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
- en: Processes
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The twelve-factor methodology emphasizes that all processes or components of
    the application must be stateless and share-nothing, that is, they should not
    store information. Therefore, in an application decomposed into microservices,
    each microservice must not store information in memory or use the server cache.
    This is an important factor for escalating an application. If there is a need
    to store some states between the requests, or some data to be used later, we can
    use a database.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: 'When we use memory to store information for later use in another request, we
    run a risk because the next request may be in a different process (or the request
    can even be processed by another server):'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fba60933-50a6-44b0-b6fc-c7be96679f0a.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
- en: Port-binding
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A twelve-factor app is fully self-contained and does not depend on the use of
    an external server, such as Tomcat or Apache, to be exported as a service. A twelve-factor app
    must export the HTTP service by port-binding, meaning that the application also
    interfaces with the world via a URL. In this way, one application can be the backing
    service or external resource of another app.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: Concurrency
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A twelve-factor app must be designed to scale using a process model that allows
    execution of the processes in parallel mode. This is much like the UNIX process
    model used when executing daemons. Consequently, we can design processes that
    only deal with HTTP requests while we can also have processes that deal with tasks
    that are very long and executed in the background. The process model shows its
    importance when the application needs to scale, because, at that moment, the application
    is replicated, making copies of the processes instead of executing a new instance.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 十二要素应用必须设计成使用允许并行执行进程的进程模型来扩展。这就像在执行守护进程时使用的UNIX进程模型。因此，我们可以设计只处理HTTP请求的进程，同时也可以有处理非常长且在后台执行的任务的进程。当应用需要扩展时，进程模型显示出其重要性，因为此时应用被复制，而不是执行一个新实例。
- en: Disposability
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可丢弃性
- en: In the world of cloud computing, processes are constantly emerging and dying;
    this is exactly what causes escalation on-demand. In these conditions, the birth
    or origination of a process must be as fast as possible, and your interruption
    should be as fast, and have an as little impact, as possible.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在云计算的世界里，进程不断涌现和消亡；这正是导致按需扩展加剧的原因。在这些条件下，进程的诞生或起源必须尽可能快，你的中断应该尽可能快，并且影响尽可能小。
- en: The processes of a twelve-factor application are disposable, meaning that they
    can be initialized and stopped at any time. A process that ends without impact
    means that it should end gracefully, saving the state if necessary, and releasing
    the allocated computing resources.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 十二要素应用的进程是可丢弃的，这意味着它们可以随时初始化和停止。一个没有造成影响的进程意味着它应该优雅地结束，如果需要的话保存状态，并释放分配的计算资源。
- en: Dev/prod parity
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发/生产一致性
- en: A twelve-factor app should keep the production, testing, and development environments
    in as similar a state as possible. This facilitates the process of continuous
    deployment, while avoiding possible errors generated when the builds are sent
    from the development environment to the production environment.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 十二要素应用应尽可能保持生产、测试和开发环境的状态相似。这有助于持续部署的过程，同时避免在构建从开发环境发送到生产环境时可能产生的错误。
- en: Logs
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 日志
- en: The log of a twelve-factor app should be treated as an event stream. In a traditional
    environment, the log can be generated for a file. However, problems can arise,
    such as a lack of disk space. We know that in a cloud computing environment, where
    there is elastic scalability depending on demand, processes are born and die all
    the time. Likewise, machines and containers may no longer be used. Log files could
    get lost in this resizing in the cloud. Treating a log as an event stream is critical
    on a platform such as a cloud. In this way, logs can be directed anywhere. For
    example, they could be directed to a database in NoSQL, to another service, to
    a file in a repository, to a log-indexing-and-analysis system, or to a data-warehousing
    system.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 十二要素应用的日志应被视为事件流。在传统环境中，日志可以生成一个文件。然而，可能会出现问题，例如磁盘空间不足。我们知道在云计算环境中，根据需求具有弹性可伸缩性，进程不断诞生和消亡。同样，机器和容器可能不再被使用。在云中的这种调整过程中，日志文件可能会丢失。在云平台上将日志视为事件流是至关重要的。这样，日志可以被导向任何地方。例如，它们可以被导向NoSQL数据库、另一个服务、存储库中的文件、日志索引和分析系统，或者数据仓库系统。
- en: Admin processes
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理进程
- en: The twelve-factor method indicates that maintenance tasks, such as script execution
    for data migration, initial data loading, and cache cleaning, should be automated
    and performed on time. Because our application will run in multiple environments,
    and across multiple servers, it is necessary to use the same set of tools, software,
    and configuration files to perform these tasks. Consequently, parity problems
    between the different environments are reduced.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 十二要素方法指出，维护任务，如数据迁移的脚本执行、初始数据加载和缓存清理，应该自动化并在规定时间内执行。因为我们的应用将在多个环境中运行，并且跨越多个服务器，因此有必要使用相同的一套工具、软件和配置文件来执行这些任务。因此，不同环境之间的并行问题减少。
- en: The API Gateway
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API网关
- en: The decomposition of an application into small, intelligent, and well-defined
    components is an important design pattern in the world of cloud computing. These
    components are the microservices that bind the application business together.
    However, the control of these microservices, as seen in [Chapter 7](9e35e298-1a91-43b8-ace1-805997b2b89e.xhtml),
    *Microservice Patterns*, is a complex task as the functionalities grow in the
    application history. One solution to this problem is called the **API ****Gateway**.
    As the API Gateway has already been explored in detail, in [Chapter 7](9e35e298-1a91-43b8-ace1-805997b2b89e.xhtml), *Microservice
    Patterns,* we will only cover it briefly now.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: 'The API Gateway serves as a frontend for cloud-application clients. Sometimes,
    the request is a simple call to a specific microservice, but often the API Gateway
    functions as a coarse-granulation layer that receives a request and performs several
    calls to microservices that are related to the required functionality. This issue
    is also related to the microservice aggregator pattern and the microservice proxy
    pattern. The API name comes exactly from the way that clients access the microservices,
    which is similar to the use of an API, as demonstrated in the following diagram:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/18217b3a-9faf-41e3-ab00-5830c95e3ce8.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
- en: 'Depending on the type of client in question, a given system''s functionality
    may sometimes work differently and the application may respond with different
    information. When calling a system service, a mobile client receives a smaller
    set of information than a web client (who uses a desktop computer). Taking this
    into account, there is an extension to the API Gateway. The extended API Gateway
    can provide a specific API for each type of client. In this way, a mobile client
    would access a mobile API, while a web client or a browser would access the web
    API:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4a4ab591-6680-439f-a8e0-5618d8a7f32e.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
- en: The service-registry pattern
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We know that microservices are exposed via access protocols such as HTTP/REST.
    This means that the services are accessed via a URL. However, we are in the cloud
    world, which has elastic scalability. The IPs of containers and virtual machines
    are dynamic and can change frequently. Consequently, the locations of services
    residing in these containers are also subject to change. As we have already said,
    instances of microservices are created and terminated constantly. Therefore, the
    following question arises—how can a client of a microservice handle this problem?
    The solution is to implement the service registry pattern. A service registry
    is a database of registered services. When a microservice is born, it is recorded
    on this database, and when it dies, it is unregistered from the database.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: 'A microservice client accesses the service registry that is responsible for
    knowing whether the microservice is available, as well as providing its location
    to the client. Let''s look at the following diagram:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e2e428b6-1304-40af-a0bb-db777f7e8721.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e2e428b6-1304-40af-a0bb-db777f7e8721.png)'
- en: Config server
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置服务器
- en: An application, whether in the cloud or not, has properties such as credentials
    and database location, application-specific information, and URLs for accessing
    external resources. For a traditional application, these properties are usually
    in a properties file. If we change a value of one of these properties, we must
    stop the application and restart the application container. This question becomes
    more critical when there are different environments, such as production, staging,
    and development. Each of these environments has their own configurations.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 一个应用程序，无论是否在云中，都有诸如凭证和数据库位置、应用程序特定信息和访问外部资源的URL等属性。对于传统应用程序，这些属性通常位于属性文件中。如果我们更改这些属性中的一个的值，我们必须停止应用程序并重新启动应用程序容器。当存在不同的环境，如生产、预发布和开发时，这个问题变得更加关键。每个环境都有自己的配置。
- en: In the context of the cloud, microservices may be in different locations or
    servers. Let's assume that these properties are in the same microservice location.
    To change a property, we must locate the microservice, change the property, and
    restart the container. With a large number of microservices, this would be quite
    critical.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在云的背景下，微服务可能位于不同的位置或服务器上。让我们假设这些属性位于同一个微服务位置。要更改一个属性，我们必须定位微服务，更改属性，并重新启动容器。在大量微服务的情况下，这将会变得非常关键。
- en: To solve this problem, a layer called **cloud config server** has been introduced
    and its role is to manage the properties of the application based on microservices.
    This layer is responsible for maintaining these properties, and whenever any of
    these properties are changed, this change is reflected in the microservice (or
    application) without the need to rebuild or restart the service.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，引入了一层名为**云配置服务器**的层，其作用是基于微服务管理应用程序的属性。这一层负责维护这些属性，并且每当这些属性中的任何一个发生变化时，这种变化都会在无需重建或重启服务的情况下反映到微服务（或应用程序）中。
- en: 'The config server is responsible for providing the properties for each registered
    microservice (service registry). When the config server initializes, the microservice
    properties are obtained from a path that was specified when the microservice was
    registered. The properties obtained are then stored in memory. This path is controlled
    by a version server (such as git or subversion). When a registered microservice
    is initialized, it goes to the config server and obtains the related properties.
    When there is a need to change a property of a microservice, we must go to the
    path in the config server, change the properties, and restart the config server,
    as can be seen in the following diagram:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 配置服务器负责为每个已注册的微服务（服务注册）提供属性。当配置服务器初始化时，微服务属性是从在微服务注册时指定的路径中获取的。获取到的属性随后存储在内存中。这个路径由版本服务器（如git或subversion）控制。当已注册的微服务初始化时，它会前往配置服务器并获取相关的属性。当需要更改微服务的属性时，我们必须前往配置服务器中的路径，更改属性，并重新启动配置服务器，如下面的图示所示：
- en: '![](img/939622c6-b678-4ed3-ad4d-4caa32f9083b.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/939622c6-b678-4ed3-ad4d-4caa32f9083b.png)'
- en: The circuit-breaker pattern
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 断路器模式
- en: In the cloud scenario with distributed systems, the probability of service failure
    exists for several reasons, such as a lack of connection or an unavailable service.
    The services created in the cloud must rely on this scenario and be prepared for
    fault-tolerance. This way, when a fault occurs, the reason for the fault will
    probably be fixed and the service will work again. However, there are situations
    where failures are caused by totally unexpected events and, even though the service
    tries to work again, it cannot. The situation is even more critical when there
    is timeout management.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在具有分布式系统的云场景中，由于连接不足或服务不可用等原因，存在服务失败的概率。在云中创建的服务必须依赖于这种场景，并准备好容错。这样，当出现故障时，故障的原因可能会得到修复，服务将再次工作。然而，也存在由于完全意想不到的事件导致的故障，尽管服务试图再次工作，但它无法做到。当存在超时管理时，这种情况变得更加关键。
- en: With very long waiting periods for situations in which the failure does not
    disappear within a reasonable period of time, computational resources remain blocked
    by the timeout time. Furthermore, as other requirements for the same service arrive,
    things get worse. Services that depend on this service (that is, waiting for the
    fault to end) are also inoperative, causing the problem to cascade. The solution
    to this problem is the implementation of the circuit-breaker pattern. A circuit-breaker
    pattern handles faults that take a long time to recover.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: The circuit-breaker pattern prevents an operation from repeatedly attempting
    to run in situations where it will likely fail during execution. In addition,
    this pattern checks to see whether the failure has been resolved. If it has been
    resolved, the proxy sends the request to the operation. If the operation fails,
    the failure counter is immediately incremented.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: The circuit-breaker mechanism
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The circuit breaker functions as a proxy by routing the request to the operation
    or returning an exception immediately. The pattern has this name because its operation
    is similar to an electric circuit. This proxy has three distinct states, as demonstrated
    in the following diagram:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '**Closed**: The proxy sends the request to the operation. The proxy maintains
    a sequential counter of previous failures. If the execution of the operation fails,
    this counter is incremented. If the failure counter exceeds an established threshold,
    the proxy switches to an open state. However, at this point, a timer is started
    with a specified timeout time. The purpose of this is to cause the failure to
    be corrected during the timeout. When the timer expires, the proxy becomes half-open.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Open**: When a request arrives, an exception is returned immediately.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Half-open**: A limited number of requests are passed to the operation. If
    these requests succeed, the state changes to closed, and the failure counter is
    reset. If any request fails, the state changes to open and the timeout timer is
    restarted. The half-open state is important for avoiding a flood of requests to
    the operation in a short time.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/35c7e123-1ede-47e3-b74b-edc98eb47401.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
- en: Summary
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explained the concept of cloud-native applications as well
    as the objectives and characteristics of a cloud application. We saw the main
    design patterns that aid in the construction of a cloud application. Among the
    main patterns, we reviewed the architecture of microservices and API Gateways.
    We also learned about the twelve-factor methodology, which helps in the implementation
    of a cloud application. Finally, we explored the service-registry patterns, which
    return the service location, the config server, which provides the necessary configurations
    to the microservices without the need to restart any containers, and the circuit
    breaker, a pattern that handles long-term failures.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
