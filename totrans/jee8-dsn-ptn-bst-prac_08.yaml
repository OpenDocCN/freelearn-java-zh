- en: Cloud-Native Application Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will explain cloud-native application patterns, looking
    at what a cloud-native application is and what its goals are. We will also show
    the patterns already described in previous chapters and new patterns that have
    emerged to address cloud-based applications. After reading this chapter, the reader
    will be able to understand the concepts and patterns that characterize a cloud
    architecture.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Explaining the concept of cloud-native applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explaining the goals of a cloud application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explaining the cloud design patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explaining the concept of cloud-native applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The cloud and its resources are increasingly becoming a part of life for businesses.
    In the past, cloud resources were used for solutions such as storage management,
    emails, documents, and photos. Nowadays, the deployment of enterprise applications
    in the cloud structure certainly points the way to be followed by companies.
  prefs: []
  type: TYPE_NORMAL
- en: The cloud has become one of the first strategies to consider when developing
    a business application. The big challenge here is to make this application use
    the features offered by the cloud, such as elasticity, scalability, and availability,
    for the benefit of the business.
  prefs: []
  type: TYPE_NORMAL
- en: To start off with, monolithic applications were migrated and deployed in the
    cloud. Some gains were achieved such as greater management and control, as well
    as availability. But what we really want is an application integrated with the
    capabilities offered by the cloud, that is, to leverage the cloud computing resources
    to better solve the business.
  prefs: []
  type: TYPE_NORMAL
- en: Then comes the cloud-native application, which is an application that uses the
    benefits and capabilities provided by the cloud. A set of design patterns is used
    for the development of this application. We'll look at some of the main design
    patterns used in cloud architecture in more detail later in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The cloud computing environment is basically elastic in the sense that computing
    resources are used and released according to demand. Consequently, scalability
    and availability are achieved with less complexity than they would be if the application
    were still under datacenter control.
  prefs: []
  type: TYPE_NORMAL
- en: 'Based on the cloud-native computing foundation, the properties that guide a
    cloud-native application are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Container-packaged**: The applications are executed in isolated units'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dynamically-managed**: There is a central orchestration that manages the
    applications, improving the use of the resources, and reducing operational costs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Microservices-oriented**: Applications in the cloud are loosely-coupled'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hence, a cloud-native application has a strongly-distributed nature. This is
    because this application is deployed in the cloud, and these properties are satisfied.
  prefs: []
  type: TYPE_NORMAL
- en: Explaining the goals of the cloud-native application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Cloud design patterns aim to build secure, reliable applications available
    in the cloud. The following list will show these and other characteristics to
    be achieved by a cloud-native application:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Availability**: The time the application is up and running. What is desired
    is a non-stop operation of all the system''s functionalities.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data management**: Data handled by an application is the building block of
    a cloud application. Data can be distributed or replicated across many servers
    (or clusters) to achieve scalability, availability, or even performance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Messaging**: To increase scalability, services or applications in the cloud
    have low coupling and often communicate using asynchronous messaging.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Management and monitoring**: Because cloud applications run in remote environments,
    there must be a way to monitor non-functional property states—such as the use
    of computing resources—through logs and reports. Also, we must be able to deploy
    new implementations without having to stop the application (maintaining the availability
    characteristic).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Performance and scalability**: Maintains performance despite an increase
    in the use of computing resources and scaling of the application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Resiliency**: A cloud application should be able to overcome a failure quickly.
    This issue is important for maintaining availability.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Security**: A cloud application exposes several of its elements to users
    and should be able to prevent attacks by malicious users or malicious programs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It is important here to note that there are some issues that should be taken
    into account when implementing a distributed application, and specifically a cloud-native
    application. These *fallacies of distributed computing* were made by L. Peter
    Deutsch and others at Sun Microsystems, describing false assumptions about distributed
    programming:'
  prefs: []
  type: TYPE_NORMAL
- en: The network is reliable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Latency is zero
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bandwidth is infinite
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The network is secure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Topology doesn't change
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is one administrator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The transport cost is zero
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The network is homogeneous
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With the goals and challenges to be achieved by a cloud-native application on
    the one hand, and the difficulties that have always existed for the implementation
    of a distributed application on the other, we have launched the design pattern
    to solve the problems faced by a cloud-native application. As we progress, we
    will show the main design patterns used in the cloud architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Explaining the cloud design patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that the cloud application concepts and its challenges are defined, let''s
    get straight to the point and talk about the design patterns used for the implementation
    of a cloud architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: Composite application (microservices)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Abstraction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Twelve-factor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: API Gateway
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Service registry
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Config server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Circuit breaker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Composite application (microservices)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 7](9e35e298-1a91-43b8-ace1-805997b2b89e.xhtml), *Microservice Patterns, *we
    demonstrated the advantages (and disadvantages) of decomposing an application
    into functions and taking several benefits from this pattern, always aiming at
    the application business. In that chapter, it was established that a microservice-based
    architecture is characterized by decomposing the application into small, functional,
    independent components with a well-defined communication interface that is loosely-coupled.
  prefs: []
  type: TYPE_NORMAL
- en: Abstraction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This pattern states that the focus must be on what the client needs and not
    on the existing hardware structure. In this sense, the computational resources
    of the cloud are used on demand, which characterizes the elastic scalability.
    In this way, resources are seen in an abstract way and are changed according to
    the needs of the clients.
  prefs: []
  type: TYPE_NORMAL
- en: Twelve-factor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The twelve-factor methodology is based on the twelve factors that guide the
    creation of a successful SaaS project. This technology was created during the
    development of Heroku, a cloud service platform (PaaS) that supports several programming
    languages, including Ruby, Java, Node.js, Scala, Clojure, Python, and PHP.
  prefs: []
  type: TYPE_NORMAL
- en: 'The experience acquired during the development and support of SaaS applications
    was cataloged, that is, observations of the errors encountered, and solutions
    drawn up for the problems that occurred. As a consequence, the twelve-factor methodology
    was created, which is a set of guidelines that make it easier to develop cloud-based
    applications. For teaching purposes, here are some definitions—SaaS stands for
    *Software as a Service*, and PaaS stands for *Platform as a Service*. SaaS is
    best known to the end user as it has the highest growth rate in the market. The
    twelve factors are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Code base**: One codebase is tracked in revision control, while many deploys'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dependencies**: Explicitly declare and isolate dependencies'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Config**: Store config in the environment'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Backing services**: Treat backing services as attached resources'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Build, release, run**: Strictly separate the build and run stages'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Processes**: Execute the app as one or more stateless processes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Port-binding**: Export services via port-binding'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Concurrency**: Scale-out via the process model'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Disposability**: Maximize robustness with a fast startup and graceful shutdown'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dev/prod parity**: Keep development, staging, and production as similar as
    possible'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Logs**: Treat logs as event streams'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Admin processes**: Run admin/management tasks as one-off processes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Codebase
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A codebase is any single repository where the codes reside. There can only be
    one codebase per application. Several applications cannot share a same codebase
    in the twelve-factor methodology. In this case, a solution would be to refactor
    the shared code by generating libraries that would go into the project as dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: A codebase must be managed by a version control system (such as subversion or
    Git). Various deploys are generated from this codebase, each one for a different
    environment—development, staging, and production.
  prefs: []
  type: TYPE_NORMAL
- en: 'The developer has a version of the application (that is, a deploy) running
    in their local development environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/752384bc-0ac1-4f32-8d70-8fd1591df823.png)'
  prefs: []
  type: TYPE_IMG
- en: Dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Every dependency that is used by the project must be declared and isolated
    from the code. In this case, we can use some package-management tools (such as
    Maven, grundle, and npm). As an example, the Maven tool is used for building and
    documenting projects. The dependencies are declared in the `pom.xml` file, where
    we can declare the project dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/86b2425c-a240-4065-8691-a1feca460ab0.png)'
  prefs: []
  type: TYPE_IMG
- en: Config
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An application''s config is everything that varies between different deploys.
    It can be:'
  prefs: []
  type: TYPE_NORMAL
- en: Hosts, ports, and credentials for database access
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Database schema
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cache settings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hosts, ports, and credentials for accessing message queues
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The twelve-factor method requires the separation of config from code. So, the
    config should never be in the code, because the configs may vary between deploys
    but the code does not. The practice of placing the config in files, such as Java
    properties, is not recommended by twelve-factor, as there is always the possibility
    of placing the same configuration data in different environments (an example is
    when a developer commits to the version-control repository with its own local
    configs). Another weakness is the security issue of these configuration files.
    The twelve-factor method recommends the use of environment variables that can
    be injected when deploying an application in a specific environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2bb4c0a2-d2e6-478f-a67a-9b0009db5148.png)'
  prefs: []
  type: TYPE_IMG
- en: Backing services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Backing services are external services used by the application, such as a database,
    message service, file repository, or email service. The twelve-factor method considers
    each service that is external to the application as a resource. Each of these
    resources must be accessed via a URL or location and credentials attributes that
    are in the app's config. In this way, any changes to a service location—such as
    the database or file repository—does not impact the application code. The change
    becomes imperceptible to the code, resulting in a low desired coupling. We can
    also use abstractions or interfaces to access these services in addition to the
    app's config.
  prefs: []
  type: TYPE_NORMAL
- en: As a first example, we have the file stored in a repository. Access to the repository
    can be executed via a URL, regardless of local or remote access (such as Amazon
    S3). For this, we use the app's config. Of course, the way to store files locally
    or remotely, in the last instance, may be different, but the use of an interface
    greatly improves this issue.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a second example, we have the use of a SQL database in different environments
    (production, staging, and development). We should only change the URL of the connection
    to the database using what is in the application''s config. This strategy should
    be extended to a possible change of database management systems, such as from
    MySQL to DB2\. Of course, we know that in practice, the use of specific mechanisms
    for a database can improve performance. However, the changes, if they happened,
    would be minimal:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/abe84a15-b5a3-40db-9c60-3bfbe15b2d55.png)'
  prefs: []
  type: TYPE_IMG
- en: Build, release, run
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The process of transforming a codebase into a given environment must be divided
    into three strictly separate stages:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Build**: Compiles and generates an executable package; for example, generating
    an EAR or WAR archive.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Release**: Applies the app''s config in the executable package. The resulting
    release, which is the combination of the package generated in the build with the
    app''s config, is ready to be scanned in the environment that contains the config.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Run** (or runtime): Initializes the application in the specific environment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The separation of these steps, that is, the definition of their responsibilities
    is important for improving system maintenance and automation. Continuous integration
    tools are used in these steps (Maven and Jenkins are examples of these tools):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8adcda1d-cb5f-40af-88ba-2709a0b2c489.png)'
  prefs: []
  type: TYPE_IMG
- en: Processes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The twelve-factor methodology emphasizes that all processes or components of
    the application must be stateless and share-nothing, that is, they should not
    store information. Therefore, in an application decomposed into microservices,
    each microservice must not store information in memory or use the server cache.
    This is an important factor for escalating an application. If there is a need
    to store some states between the requests, or some data to be used later, we can
    use a database.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we use memory to store information for later use in another request, we
    run a risk because the next request may be in a different process (or the request
    can even be processed by another server):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fba60933-50a6-44b0-b6fc-c7be96679f0a.png)'
  prefs: []
  type: TYPE_IMG
- en: Port-binding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A twelve-factor app is fully self-contained and does not depend on the use of
    an external server, such as Tomcat or Apache, to be exported as a service. A twelve-factor app
    must export the HTTP service by port-binding, meaning that the application also
    interfaces with the world via a URL. In this way, one application can be the backing
    service or external resource of another app.
  prefs: []
  type: TYPE_NORMAL
- en: Concurrency
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A twelve-factor app must be designed to scale using a process model that allows
    execution of the processes in parallel mode. This is much like the UNIX process
    model used when executing daemons. Consequently, we can design processes that
    only deal with HTTP requests while we can also have processes that deal with tasks
    that are very long and executed in the background. The process model shows its
    importance when the application needs to scale, because, at that moment, the application
    is replicated, making copies of the processes instead of executing a new instance.
  prefs: []
  type: TYPE_NORMAL
- en: Disposability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the world of cloud computing, processes are constantly emerging and dying;
    this is exactly what causes escalation on-demand. In these conditions, the birth
    or origination of a process must be as fast as possible, and your interruption
    should be as fast, and have an as little impact, as possible.
  prefs: []
  type: TYPE_NORMAL
- en: The processes of a twelve-factor application are disposable, meaning that they
    can be initialized and stopped at any time. A process that ends without impact
    means that it should end gracefully, saving the state if necessary, and releasing
    the allocated computing resources.
  prefs: []
  type: TYPE_NORMAL
- en: Dev/prod parity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A twelve-factor app should keep the production, testing, and development environments
    in as similar a state as possible. This facilitates the process of continuous
    deployment, while avoiding possible errors generated when the builds are sent
    from the development environment to the production environment.
  prefs: []
  type: TYPE_NORMAL
- en: Logs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The log of a twelve-factor app should be treated as an event stream. In a traditional
    environment, the log can be generated for a file. However, problems can arise,
    such as a lack of disk space. We know that in a cloud computing environment, where
    there is elastic scalability depending on demand, processes are born and die all
    the time. Likewise, machines and containers may no longer be used. Log files could
    get lost in this resizing in the cloud. Treating a log as an event stream is critical
    on a platform such as a cloud. In this way, logs can be directed anywhere. For
    example, they could be directed to a database in NoSQL, to another service, to
    a file in a repository, to a log-indexing-and-analysis system, or to a data-warehousing
    system.
  prefs: []
  type: TYPE_NORMAL
- en: Admin processes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The twelve-factor method indicates that maintenance tasks, such as script execution
    for data migration, initial data loading, and cache cleaning, should be automated
    and performed on time. Because our application will run in multiple environments,
    and across multiple servers, it is necessary to use the same set of tools, software,
    and configuration files to perform these tasks. Consequently, parity problems
    between the different environments are reduced.
  prefs: []
  type: TYPE_NORMAL
- en: The API Gateway
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The decomposition of an application into small, intelligent, and well-defined
    components is an important design pattern in the world of cloud computing. These
    components are the microservices that bind the application business together.
    However, the control of these microservices, as seen in [Chapter 7](9e35e298-1a91-43b8-ace1-805997b2b89e.xhtml),
    *Microservice Patterns*, is a complex task as the functionalities grow in the
    application history. One solution to this problem is called the **API ****Gateway**.
    As the API Gateway has already been explored in detail, in [Chapter 7](9e35e298-1a91-43b8-ace1-805997b2b89e.xhtml), *Microservice
    Patterns,* we will only cover it briefly now.
  prefs: []
  type: TYPE_NORMAL
- en: 'The API Gateway serves as a frontend for cloud-application clients. Sometimes,
    the request is a simple call to a specific microservice, but often the API Gateway
    functions as a coarse-granulation layer that receives a request and performs several
    calls to microservices that are related to the required functionality. This issue
    is also related to the microservice aggregator pattern and the microservice proxy
    pattern. The API name comes exactly from the way that clients access the microservices,
    which is similar to the use of an API, as demonstrated in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/18217b3a-9faf-41e3-ab00-5830c95e3ce8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Depending on the type of client in question, a given system''s functionality
    may sometimes work differently and the application may respond with different
    information. When calling a system service, a mobile client receives a smaller
    set of information than a web client (who uses a desktop computer). Taking this
    into account, there is an extension to the API Gateway. The extended API Gateway
    can provide a specific API for each type of client. In this way, a mobile client
    would access a mobile API, while a web client or a browser would access the web
    API:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4a4ab591-6680-439f-a8e0-5618d8a7f32e.png)'
  prefs: []
  type: TYPE_IMG
- en: The service-registry pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We know that microservices are exposed via access protocols such as HTTP/REST.
    This means that the services are accessed via a URL. However, we are in the cloud
    world, which has elastic scalability. The IPs of containers and virtual machines
    are dynamic and can change frequently. Consequently, the locations of services
    residing in these containers are also subject to change. As we have already said,
    instances of microservices are created and terminated constantly. Therefore, the
    following question arises—how can a client of a microservice handle this problem?
    The solution is to implement the service registry pattern. A service registry
    is a database of registered services. When a microservice is born, it is recorded
    on this database, and when it dies, it is unregistered from the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'A microservice client accesses the service registry that is responsible for
    knowing whether the microservice is available, as well as providing its location
    to the client. Let''s look at the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e2e428b6-1304-40af-a0bb-db777f7e8721.png)'
  prefs: []
  type: TYPE_IMG
- en: Config server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An application, whether in the cloud or not, has properties such as credentials
    and database location, application-specific information, and URLs for accessing
    external resources. For a traditional application, these properties are usually
    in a properties file. If we change a value of one of these properties, we must
    stop the application and restart the application container. This question becomes
    more critical when there are different environments, such as production, staging,
    and development. Each of these environments has their own configurations.
  prefs: []
  type: TYPE_NORMAL
- en: In the context of the cloud, microservices may be in different locations or
    servers. Let's assume that these properties are in the same microservice location.
    To change a property, we must locate the microservice, change the property, and
    restart the container. With a large number of microservices, this would be quite
    critical.
  prefs: []
  type: TYPE_NORMAL
- en: To solve this problem, a layer called **cloud config server** has been introduced
    and its role is to manage the properties of the application based on microservices.
    This layer is responsible for maintaining these properties, and whenever any of
    these properties are changed, this change is reflected in the microservice (or
    application) without the need to rebuild or restart the service.
  prefs: []
  type: TYPE_NORMAL
- en: 'The config server is responsible for providing the properties for each registered
    microservice (service registry). When the config server initializes, the microservice
    properties are obtained from a path that was specified when the microservice was
    registered. The properties obtained are then stored in memory. This path is controlled
    by a version server (such as git or subversion). When a registered microservice
    is initialized, it goes to the config server and obtains the related properties.
    When there is a need to change a property of a microservice, we must go to the
    path in the config server, change the properties, and restart the config server,
    as can be seen in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/939622c6-b678-4ed3-ad4d-4caa32f9083b.png)'
  prefs: []
  type: TYPE_IMG
- en: The circuit-breaker pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the cloud scenario with distributed systems, the probability of service failure
    exists for several reasons, such as a lack of connection or an unavailable service.
    The services created in the cloud must rely on this scenario and be prepared for
    fault-tolerance. This way, when a fault occurs, the reason for the fault will
    probably be fixed and the service will work again. However, there are situations
    where failures are caused by totally unexpected events and, even though the service
    tries to work again, it cannot. The situation is even more critical when there
    is timeout management.
  prefs: []
  type: TYPE_NORMAL
- en: With very long waiting periods for situations in which the failure does not
    disappear within a reasonable period of time, computational resources remain blocked
    by the timeout time. Furthermore, as other requirements for the same service arrive,
    things get worse. Services that depend on this service (that is, waiting for the
    fault to end) are also inoperative, causing the problem to cascade. The solution
    to this problem is the implementation of the circuit-breaker pattern. A circuit-breaker
    pattern handles faults that take a long time to recover.
  prefs: []
  type: TYPE_NORMAL
- en: The circuit-breaker pattern prevents an operation from repeatedly attempting
    to run in situations where it will likely fail during execution. In addition,
    this pattern checks to see whether the failure has been resolved. If it has been
    resolved, the proxy sends the request to the operation. If the operation fails,
    the failure counter is immediately incremented.
  prefs: []
  type: TYPE_NORMAL
- en: The circuit-breaker mechanism
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The circuit breaker functions as a proxy by routing the request to the operation
    or returning an exception immediately. The pattern has this name because its operation
    is similar to an electric circuit. This proxy has three distinct states, as demonstrated
    in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Closed**: The proxy sends the request to the operation. The proxy maintains
    a sequential counter of previous failures. If the execution of the operation fails,
    this counter is incremented. If the failure counter exceeds an established threshold,
    the proxy switches to an open state. However, at this point, a timer is started
    with a specified timeout time. The purpose of this is to cause the failure to
    be corrected during the timeout. When the timer expires, the proxy becomes half-open.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Open**: When a request arrives, an exception is returned immediately.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Half-open**: A limited number of requests are passed to the operation. If
    these requests succeed, the state changes to closed, and the failure counter is
    reset. If any request fails, the state changes to open and the timeout timer is
    restarted. The half-open state is important for avoiding a flood of requests to
    the operation in a short time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/35c7e123-1ede-47e3-b74b-edc98eb47401.png)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explained the concept of cloud-native applications as well
    as the objectives and characteristics of a cloud application. We saw the main
    design patterns that aid in the construction of a cloud application. Among the
    main patterns, we reviewed the architecture of microservices and API Gateways.
    We also learned about the twelve-factor methodology, which helps in the implementation
    of a cloud application. Finally, we explored the service-registry patterns, which
    return the service location, the config server, which provides the necessary configurations
    to the microservices without the need to restart any containers, and the circuit
    breaker, a pattern that handles long-term failures.
  prefs: []
  type: TYPE_NORMAL
