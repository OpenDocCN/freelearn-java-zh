<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Stream Operations and Pipelines</h1>
                </header>
            
            <article>
                
<p>In the latest Java releases (8 and 9), the collections API has gotten a major facelift with the introduction of streams and internal iteration by leveraging lambda expressions. This chapter shows you how to leverage streams and chain multiple operations on a collection to create a pipeline. Also, we would like to show you how these operations can be done in parallel. We will cover the following recipes:</p>
<ul>
<li>Using the new factory methods to create collection objects</li>
<li>Creating and operating on streams</li>
<li>Creating an operation pipeline on streams</li>
<li>Parallel computations on streams</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introduction</h1>
                </header>
            
            <article>
                
<p>Lambda expressions described and demonstrated in the previous chapter were introduced in Java 8. Together with functional interfaces, they added functional programming capability to Java, allowing the passing of behavior (functions) as parameters to the libraries optimized for the performance of data processing. This way, an application programmer can concentrate on the business aspects of the developed system, leaving performance aspects to the specialists--the authors of the library.</p>
<p>One example of such a library is the <kbd><span>java.util.stream</span></kbd> package, which is going to be the focus of this chapter. This package allows you to have a declarative presentation of the procedures that can be subsequently applied to the data, also in parallel; these procedures are presented as streams, which are objects of the <kbd>Stream</kbd> <span>interface.</span> <span>For better transition </span>from the traditional collections to streams, two default methods (<kbd>stream()</kbd> and <kbd>parallelStream()</kbd>) were added to the <kbd>java.util.Collection</kbd> interface along with the addition of new factory methods of stream generation to the <kbd>Stream</kbd> <span>interface.</span>     </p>
<p>This approach takes advantage of the power of composition, discussed in one of the previous chapters. Together with other design principles--encapsulation, interface, and polymorphism--it facilitates a highly extensible and flexible design, while lambda expressions allow you to implement it in a concise and succinct manner.   </p>
<p>Today, when the machine learning requirements of massive data processing and the fine-tuning of operations have become ubiquitous, these new features reinforce the position of Java among the few modern programming languages of choice.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using the new factory methods to create collection objects</h1>
                </header>
            
            <article>
                
<p>In this recipe, we will revisit traditional ways of creating collections and introduce the new factory methods, namely <kbd>List.of()</kbd>, <kbd>Set.of()</kbd>, <kbd>Map.of()</kbd>, and <kbd>Map.ofEntries()</kbd>, that come with Java 9.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>Before Java 9, there were several ways of creating collections. Here is the most popular way that was used to create <kbd>List</kbd>:</p>
<pre>List&lt;String&gt; list = new ArrayList&lt;&gt;();<br/>list.add("This ");<br/>list.add("is ");<br/>list.add("built ");<br/>list.add("by ");<br/>list.add("list.add()");<br/>//Let us print the created list:<br/>list.forEach(System.out::print);</pre>
<p>Notice the usage of a default method, <kbd>forEach(Consumer)</kbd>, added to the <kbd>Iterable</kbd> interface in Java 8.</p>
<p>If we run the preceding code, we get this:</p>
<div class="CDPAlignCenter CDPAlign"><img height="34" width="251" class="image-border" src="assets/da7daa20-403b-4fd7-9d2e-bb011109e779.png"/></div>
<p>The shorter way of doing this would be by starting with an array:</p>
<pre>Arrays.asList("This ", "is ", "created ", "by ", <br/>              "Arrays.asList()").forEach(System.out::print);</pre>
<p>The result is as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img height="28" width="267" class="image-border" src="assets/27db3f63-043e-4299-a8a3-93789e534dd3.png"/></div>
<p><span>Similarly, while creating <kbd>Set</kbd>, we can write this:</span></p>
<pre>Set&lt;String&gt; set = new HashSet&lt;&gt;();<br/>set.add("This ");<br/>set.add("is ");<br/>set.add("built ");<br/>set.add("by ");<br/>set.add("set.add() ");<br/>//Now print the created set:<br/>set.forEach(System.out::print);</pre>
<p>Alternatively, we can write the following:</p>
<pre>new HashSet&lt;&gt;(Arrays.asList("This ", "is ", "created ", "by ", <br/>                            "new HashSet(Arrays.asList()) "))<br/>                            .forEach(System.out::print);</pre>
<p>Here's an illustration of the results of the last two examples:</p>
<div class="CDPAlignCenter CDPAlign"><img height="40" width="311" class="image-border" src="assets/9d169fd5-e76e-4436-8fc9-6e4f3a52cf89.png"/></div>
<p>Notice that unlike <kbd>List</kbd>, the order of elements in <kbd>Set</kbd> is not preserved. It depends on the hash code implementation and can change from computer to computer. But the order remains the same between the runs on the same computer (please take note of this last fact because we will come back to it later). </p>
<p>The same structure, that is, the order of elements, applies to <kbd>Map</kbd> too. This is how we used to create <kbd>Map</kbd> before Java 9:</p>
<pre>Map&lt;Integer, String&gt; map = new HashMap&lt;&gt;();<br/>map.put(1, "This ");<br/>map.put(2, "is ");<br/>map.put(3, "built ");<br/>map.put(4, "by ");<br/>map.put(5, "map.put() ");<br/>//Print the results:<br/>map.entrySet().forEach(System.out::print);</pre>
<p>The output of the preceding code is as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img height="33" width="312" class="image-border" src="assets/bf84676d-a5c6-4d2b-b6cf-ebc5ecb80e14.png"/></div>
<p>Those who had to create collections often appreciated the JDK enhancement-Proposal 269 <em>Convenience Factory Methods for Collections</em> (JEP 269) that stated <em>Java is often criticized for its verbosity</em> and its goal of <em>Provide static factory methods on the collection interfaces that will create compact, unmodifiable collection instances.</em></p>
<p>In response to the criticism and the proposal, Java 9 introduced twelve <kbd>of()</kbd> static factory methods for each of the three interfaces. The following is the code for <kbd>List</kbd>:</p>
<pre>static &lt;E&gt; List&lt;E&gt; of()  //Returns list with zero elements<br/>static &lt;E&gt; List&lt;E&gt; of(E e1) //Returns list with one element<br/>static &lt;E&gt; List&lt;E&gt; of(E e1, E e2)  //etc<br/>static &lt;E&gt; List&lt;E&gt; of(E e1, E e2, E e3)<br/>static &lt;E&gt; List&lt;E&gt; of(E e1, E e2, E e3, E e4)<br/>static &lt;E&gt; List&lt;E&gt; of(E e1, E e2, E e3, E e4, E e5)<br/>static &lt;E&gt; List&lt;E&gt; of(E e1, E e2, E e3, E e4, E e5, E e6)<br/>static &lt;E&gt; List&lt;E&gt; of(E e1, E e2, E e3, E e4, E e5, E e6, E e7)<br/>static &lt;E&gt; List&lt;E&gt; of(E e1, E e2, E e3, E e4, E e5, <br/>                                        E e6, E e7, E e8)<br/>static &lt;E&gt; List&lt;E&gt; of(E e1, E e2, E e3, E e4, E e5, <br/>                                  E e6, E e7, E e8, E e9)<br/>static &lt;E&gt; List&lt;E&gt; of(E e1, E e2, E e3, E e4, E e5, <br/>                            E e6, E e7, E e8, E e9, E e10)<br/>static &lt;E&gt; List&lt;E&gt; of(E... elements)</pre>
<p>Twelve similar static methods were added to <kbd>Set</kbd> and <kbd>Map</kbd> too. Ten overloaded factory methods with a fixed number of elements were optimized for performance, and as stated in JEP 269, these methods <em>avoid array allocation, initialization, and garbage collection overhead that is incurred by</em> <em>varargs calls.</em></p>
<p><span>The code of the same examples now becomes much more compact:</span></p>
<pre>List.of("This ", "is ", "created ", "by ", "List.of()")<br/>    .forEach(System.out::print);<br/>System.out.println();<br/>Set.of("This ", "is ", "created ", "by ", "Set.of() ")<br/>   .forEach(System.out::print);<br/>System.out.println();<br/>Map.of(1, "This ", 2, "is ", 3, "built ", 4, "by ", 5,"Map.of() ")<br/>   .entrySet().forEach(System.out::print);</pre>
<p><span>The <kbd>System.out.println()</kbd> statement was added to inject a line break between the different types of output:</span></p>
<div class="CDPAlignCenter CDPAlign"><img height="53" width="294" class="image-border" src="assets/a140e303-133d-4d46-b3f6-03cc1d912a11.png"/></div>
<p>One of the twelve static factory methods added to the <kbd>Map</kbd> interface was different from the other <kbd>of()</kbd> methods:</p>
<pre>static &lt;K,V&gt; Map&lt;K,V&gt;<span class="Apple-tab-span"> </span>ofEntries(Map.Entry&lt;? extends K,<br/>                                ? extends V&gt;... entries)</pre>
<p>Here is an example of its usage:</p>
<pre>Map.ofEntries(<br/>  entry(1, "This "),<br/>  entry(2, "is "),<br/>  entry(3, "built "),<br/>  entry(4, "by "),<br/>  entry(5, "Map.ofEntries() ")<br/>).entrySet().forEach(System.out::print);</pre>
<p>Here's its output:</p>
<div class="CDPAlignCenter CDPAlign"><img height="37" width="328" class="image-border" src="assets/1109e20a-7a9b-496e-a12b-95917c5eddfd.png"/></div>
<p>So, there is no <kbd>Map.of()</kbd> factory method for an unlimited number of elements. One has to use <kbd>Map.ofEntries()</kbd> when creating a map with more than 10 elements.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p><span>You may have probably noticed the <kbd>Set.of()</kbd>, <kbd>Map.of()</kbd>, and <kbd>Map.ofEntries()</kbd> methods do not preserve the order of their elements. This is different from the previous (before Java 9) instances of <kbd>Set</kbd> and <kbd>Map</kbd></span><span>; the order of elements now changes between runs even on the same computer (but does not change during the same run, no matter how many times the collection is iterated). This is an intentional feature intended to help programmers avoid reliance on a certain order because it might produce a defect as the order changes when the code is run on another computer.</span></p>
<p>Another feature of the collections generated by the new <kbd>of()</kbd> static methods of the <kbd>List</kbd>, <kbd>Set</kbd>, and <kbd>Map</kbd> interfaces is that these collections are immutable. What does this mean? Consider the following code:</p>
<pre>List&lt;String&gt; list = List.of("This ", "is ", "immutable");<br/>list.add("Is it?");</pre>
<p>This means that the preceding code throws <kbd>java.lang.UnsupportedOperationException</kbd> at runtime and the following code will throw the same exception too:</p>
<pre> List&lt;Integer&gt; list = List.of(1,2,3,4,5);<br/> list.set(2, 9);</pre>
<p>Also, the collections generated by the new <kbd>of()</kbd> static methods do not allow null elements, and the following code throws the <kbd>java.lang.NullPointerException</kbd> exception at runtime too:</p>
<pre>List&lt;String&gt; list = List.of("This ", "is ", "not ", "created ", null);</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>It is not an accident that non-null values and immutability guarantees were added soon after lambda and streams were introduced. As you will see in subsequent recipes, the functional programming and stream pipelines encourage a fluent style of coding (using method chaining, as we did in the case of using the <kbd>forEach()</kbd> method in the examples of this recipe). This fluent style provides more compact and readable code and the non-null guarantee helps support it by removing the need for checking the <kbd>null</kbd> value. </p>
<p>The immutability feature, in turn, aligns well with the, effectively, final concept for the variables in the outside context used by lambda expressions. For example, a mutable collection allows you to work around this limitation and the following code: </p>
<pre>List&lt;Integer&gt; list = Arrays.asList(1,2,3,4,5);<br/>list.set(2, 0);<br/>list.forEach(System.out::print);<br/><br/>list.forEach(i -&gt; {<br/>  int j = list.get(2);<br/>  list.set(2, j + 1);<br/>});<br/>System.out.println();<br/>list.forEach(System.out::print);</pre>
<p>This code produces the following output:</p>
<div class="CDPAlignCenter CDPAlign"><img height="34" width="127" class="image-border" src="assets/45e30365-bc46-4ab0-8c07-236b7d083f3b.png"/></div>
<p>This means that it is possible--intentionally or not--to introduce a state in a lambda expression and cause different outcomes of the same function in different contexts. This is especially dangerous in parallel processing because one cannot predict the state of each possible context. This is why immutability of a collection is a helpful addition that helps make the code more robust and reliable.    </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<p>Refer to the following recipes of this chapter:</p>
<ul>
<li>Creating and operating on streams</li>
<li>Creating an operation pipeline on streams</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating and operating on streams</h1>
                </header>
            
            <article>
                
<p>In this recipe, we will describe how streams can be created and the operations that can be applied to the elements emitted by the streams. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>There are many ways to create a stream. Since Java 8, the <kbd>Collection</kbd> interface has the <kbd>stream()</kbd> method that returns a sequential stream with this collection as its source and the <kbd>parallelStream()</kbd> method that returns a possibly parallel stream with this collection as its source. This means that all the subinterfaces, including <kbd>Set</kbd> and <kbd>List</kbd>, also have these methods. Also, eight overloaded <kbd>stream()</kbd> methods were added to the <kbd>Arrays</kbd> class that created streams of different types from a corresponding array or subset.</p>
<p><span>The</span> <kbd>Stream</kbd> interface has the <kbd>of()</kbd>, <kbd>generate()</kbd>, and <kbd>iterate()</kbd> methods. The specialized <span>interface</span>s <kbd>IntStream</kbd>, <kbd>DoubleStream</kbd>, and <kbd>LongStream</kbd> have similar methods too, while <kbd>IntStream</kbd> also has the <kbd>range()</kbd> and <kbd>rangeClosed()</kbd> methods; both return <kbd>IntStream</kbd>.  </p>
<p>There are <kbd>Files.list()</kbd>, <kbd>Files.lines()</kbd>, <kbd>Files.find()</kbd>, <kbd>BufferedReader.lines()</kbd>, <span>and many other methods in the JDK that produce streams.</span> </p>
<p><span>After a stream is created, various operations can be applied to its elements. A stream itself does not store data. It rather acquires them from the source (and provides or emits them to the operations) as needed. The operations can form a pipeline using the fluent style since many intermediate operations can return a stream too. Such operations are called <em>intermediate</em> operations. Examples of intermediate operations are <kbd>filter()</kbd> (selects only elements matching a criterion), <kbd>map()</kbd> (transforms elements according to a function), <kbd>distinct()</kbd> (removes duplicates), <kbd>limit()</kbd> (limits a stream to the specified number of elements), <kbd>sorted()</kbd> (transforms an unsorted stream into a sorted one), and other methods of the <kbd>Stream</kbd> interface that return <kbd>Stream</kbd> too (except those that create a stream we just mentioned).</span></p>
<p><span>The pipeline ends with a <strong>terminal operation</strong>. The processing of the stream elements actually begins only when a terminal operation is being executed. Then, all the intermediate operations (if present) start processing and the stream closes and cannot be reopened as soon as the terminal operation is finished with the execution. Examples of terminal operations are <kbd>forEach()</kbd>, <kbd>findFirst()</kbd>, <kbd>reduce()</kbd>, <kbd>collect()</kbd>, <kbd>sum()</kbd>, <kbd>max()</kbd>, and other methods of the <kbd>Stream</kbd> interface that do not return <kbd>Stream</kbd>. Terminal operations return a result or produce a side effect. </span></p>
<p>All the <kbd>Stream</kbd> methods support parallel processing, which is especially helpful in the case of a large amount of data processed on a multicore computer. All the Java Stream API interfaces and classes are in the <kbd>java.util.stream</kbd> package.</p>
<p>In this recipe, we are going to mostly demonstrate sequential streams, created by the <kbd>stream()</kbd> method and similar. The processing of parallel streams is not much different than sequential streams. One just has to watch that the processing pipeline does not use a context state that can vary across different processing environments. We will discuss parallel processing in another recipe later in this chapter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>In this section of the recipe, we will present methods of stream creation. As mentioned in the introduction, each class that implements the <kbd>Set</kbd><span> interface or the</span> <kbd>List</kbd> <span>interface </span>has the <kbd>stream()</kbd> method and the <kbd>parallelStream()</kbd> method that return an instance of the <kbd>Stream</kbd> <span>interface.</span> For now, we will only look at sequential streams created by the <kbd>stream()</kbd> method and get back to parallel streams later.</p>
<ol>
<li>Consider the following examples of stream creation:</li>
</ol>
<pre>        List.of("This", "is", "created", "by", "List.of().stream()")<br/>            .stream().forEach(System.out::print);<br/>        System.out.println();<br/>        Set.of("This", "is", "created", "by", "Set.of().stream()")<br/>           .stream().forEach(System.out::print);<br/>        System.out.println();<br/>        Map.of(1, "This ", 2, "is ", 3, "built ", 4, "by ", 5,<br/>               "Map.of().entrySet().stream()")<br/>           .entrySet().stream().forEach(System.out::print);</pre>
<p style="padding-left: 60px">We used the fluent style to make the code more compact and interjected <kbd>System.out.println()</kbd> in order to start a new line in the output.</p>
<ol start="2">
<li>Run the preceding examples and see the result:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img height="65" width="277" class="image-border" src="assets/6c6db9b1-1228-420f-a22f-695464875d51.png"/></div>
<p style="padding-left: 60px">Notice that <kbd>List</kbd> preserves the order of the elements, while the order of <kbd>Set</kbd> elements changes at every run. This helps uncover the defects based on the reliance of certain order when this order is not guaranteed.</p>
<ol start="3">
<li>Look at the Javadoc of the <kbd>Arrays</kbd> class. It has eight overloaded <kbd>stream()</kbd> methods: </li>
</ol>
<pre>        static DoubleStream stream(double[] array)<br/>        static DoubleStream stream(double[] array, int startInclusive,<br/>                                   int endExclusive)<br/>        static IntStream stream(int[] array)<br/>        static IntStream stream(int[] array, int startInclusive, <br/>                                int endExclusive)<br/>        static LongStream stream(long[] array)<br/>        static LongStream stream(long[] array, int startInclusive, <br/>                                 int endExclusive)<br/>        static &lt;T&gt; Stream&lt;T&gt; stream(T[] array)<br/>        static &lt;T&gt; Stream&lt;T&gt; stream(T[] array, int startInclusive, <br/>                                    int endExclusive)</pre>
<ol start="4">
<li>Write an example of the usage of the last two methods:</li>
</ol>
<pre>        String[] array = {"That ", "is ", "an ",<br/>                          "Arrays.stream(array)"};<br/>        Arrays.stream(array).forEach(System.out::print);<br/>        System.out.println();<br/>        String[] array1 = { "That ", "is ", "an ", <br/>                            "Arrays.stream(array,0,2)" };<br/>        Arrays.stream(array1, 0, 2).forEach(System.out::print);</pre>
<ol start="5">
<li>Run it and see the result:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img height="46" width="295" class="image-border" src="assets/3911a09e-22e8-4c9e-a6d7-2951e593a3d4.png"/></div>
<p style="padding-left: 60px">Notice that only the first two elements--with indexes <kbd>0</kbd> and <kbd>1</kbd>--were selected to be included in the stream, as the preceding second example intended.</p>
<ol start="6">
<li>Now open the Javadoc <span>of the </span><kbd>Stream</kbd> <span>interface</span> and see the factory methods <kbd>of()</kbd>, <kbd>generate()</kbd>, and <kbd>iterate()</kbd>:</li>
</ol>
<pre>        static &lt;T&gt; Stream&lt;T&gt; of(T t) //Returns Stream of one<br/>        static &lt;T&gt; Stream&lt;T&gt; ofNullable(T t)//Returns Stream of one<br/>        // element, if non-null, otherwise returns an empty Stream<br/>        static &lt;T&gt; Stream&lt;T&gt; of(T... values)<br/>        static &lt;T&gt; Stream&lt;T&gt; generate(Supplier&lt;? extends T&gt; s)<br/>        static &lt;T&gt; Stream&lt;T&gt; iterate(T seed, UnaryOperator&lt;T&gt; f)<br/>        static &lt;T&gt; Stream&lt;T&gt; iterate(T seed, <br/>          Predicate&lt;? super T&gt; hasNext, UnaryOperator&lt;T&gt; next)</pre>
<p style="padding-left: 60px">The first two methods are simple, so we skip their demo and start with the third method, namely <kbd>of()</kbd>. It can accept either an array or just comma-delimited elements.</p>
<ol start="7">
<li>Write the example as follows:</li>
</ol>
<pre>        String[] array = { "That ", "is ", "a ", "Stream.of(array)" };<br/>        Stream.of(array).forEach(System.out::print); <br/>        System.out.println();<br/>        Stream.of( "That ", "is ", "a ", "Stream.of(literals)" )<br/>              .forEach(System.out::print);</pre>
<ol start="8">
<li>Run it and observe the output:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img height="41" width="303" class="image-border" src="assets/53bdba33-f03b-4498-9100-fbe8570808f4.png"/></div>
<ol start="9">
<li>Write the examples of the usage of the <kbd>generate()</kbd> and <kbd>iterate()</kbd> methods as follows:</li>
</ol>
<pre>        Stream.generate(() -&gt; "generated ")<br/>              .limit(3).forEach(System.out::print);<br/>        System.out.println();<br/>        System.out.print("Stream.iterate().limit(10): ");<br/>        Stream.iterate(0, i -&gt; i + 1)<br/>              .limit(10).forEach(System.out::print);<br/>        System.out.println();<br/>        System.out.print("Stream.iterate(Predicate &lt; 10): ");<br/>        Stream.iterate(0, i -&gt; i &lt; 10, i -&gt; i + 1)<br/>              .forEach(System.out::print);</pre>
<p style="padding-left: 60px">We had to put a limit on the size of the streams generated by the first two examples. Otherwise, they would be infinite. The third example accepts a predicate that provides the criterion for when the iteration has to stop.</p>
<ol start="10">
<li>Run the examples and observe the results:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img height="53" width="437" class="image-border" src="assets/1490742b-52b5-486a-8500-b4cd3ddb6380.png"/></div>
<ol start="11">
<li>Now write examples for the specialized <span>interfac</span>es <kbd>IntStream</kbd>, <kbd>DoubleStream</kbd>, and <kbd>LongStream</kbd>. Their implementations are optimized for performance when you process primitives by avoiding the overhead of boxing and unboxing. In addition, the <kbd>IntStream</kbd> <span>interface</span> has two more stream-generating methods, namely <kbd>range()</kbd> and <kbd>rangeClosed()</kbd>. Both return <kbd>IntStream</kbd>:</li>
</ol>
<pre>        System.out.print("IntStream.range(0,10): ");<br/>        IntStream.range(0, 9).forEach(System.out::print);<br/>        System.out.println();<br/>        System.out.print("IntStream.rangeClosed(0,10): ");<br/>        IntStream.rangeClosed(0, 9).forEach(System.out::print);</pre>
<ol start="12">
<li>Run them and see the output:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img height="42" width="359" class="image-border" src="assets/eb1ec491-591a-4845-887e-ee39c415f73b.png"/></div>
<p style="padding-left: 60px">As you can guess, the <kbd>range()</kbd> method produces the sequence of integers by an incremental step of <kbd>1</kbd>, starting with the left parameter but not including the right parameter. While the <kbd>rangeClosed()</kbd> method generates a similar sequence, it includes the right parameter.</p>
<ol start="13">
<li>Now let's look at the example of the <kbd>Files.list(Path dir)</kbd> method, which returns <kbd>Stream&lt;Path&gt;</kbd> of all the entries of the directory:</li>
</ol>
<pre>        System.out.println("Files.list(dir): ");<br/>        Path dir = FileSystems.getDefault()<br/>                  .getPath("src/com/packt/cookbook/ch05_streams/");<br/>        try(Stream&lt;Path&gt; stream = Files.list(dir)) {<br/>          stream.forEach(System.out::println);<br/>        } catch (Exception ex){ ex.printStackTrace(); }</pre>
<p style="padding-left: 60px">The following excerpt is from the JDK API: <em>This method must be used within a try-with-resources statement or similar control structure to ensure that the stream's open directory is closed promptly after the stream's operations are completed</em>. This is what we did; we used a <kbd>try</kbd>-with-resources statement in this case. Alternatively, we could use a <kbd>try...catch...finally</kbd> construct and close the stream in the finally block and the result would not change.</p>
<ol start="14">
<li>Run the examples and observe the output: </li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img height="83" width="366" class="image-border" src="assets/f6561316-4601-4f30-8660-2d736deaf32f.png"/></div>
<p style="padding-left: 60px">The need to close a stream explicitly can be confusing because the <kbd>Stream</kbd> interface extends <kbd>AutoCloseable</kbd>, and with this, one would expect that a stream will be closed automatically. But that is not the case. Here is what the Javadoc for the <kbd>Stream</kbd> interface has to say about it: <em>Streams have a BaseStream.close() method and implement AutoCloseable. Most stream instances do not actually need to be closed after use, as they are backed by collections, arrays, or generating functions, which require no special resource management. Generally, only streams whose source is an I/O channel, such as those returned by Files.lines(Path), will require closing</em>. This means that a programmer has to know the source of the stream and make sure they close it if the API for the source requires it.  </p>
<ol start="15">
<li>Write an example of the <kbd>Files.lines()</kbd> method's usage:</li>
</ol>
<pre>        System.out.println("Files.lines().limit(3): ");<br/>        String file = "src/com/packt/cookbook/ch05_streams<br/>                       /Chapter05Streams.java";<br/>        try(Stream&lt;String&gt; stream = Files.lines(Paths.get(file))<br/>                                                     .limit(3)){ <br/>          stream.forEach(l -&gt; { <br/>            if( l.length() &gt; 0 ) System.out.println("   " + l); <br/>          } );<br/>        } catch (Exception ex){ ex.printStackTrace(); }</pre>
<p style="padding-left: 60px">The intent was to read the first three lines of the specified file and print non-empty lines with an indentation of three spaces.</p>
<ol start="16">
<li>Run it and see the result:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img height="44" width="372" class="image-border" src="assets/e358b49d-3156-451b-b837-5dfde91de367.png"/></div>
<p style="padding-left: 60px">Write the example of the usage of the <kbd>ind()</kbd> method: </p>
<pre>        static Stream&lt;Path&gt;<span class="Apple-tab-span"> </span>find(Path start, int maxDepth, <br/>               BiPredicate&lt;Path, BasicFileAttributes&gt; matcher, <br/>               FileVisitOption... options)</pre>
<ol start="17">
<li>Similar to the previous case, a stream generated by this method has to be closed explicitly too. The <kbd>find()</kbd> method walks the file tree rooted at a given starting file and at the requested depth and returns the paths to the files that match the predicate (which includes file attributes). Write the following code now:</li>
</ol>
<pre>        Path dir = FileSystems.getDefault()<br/>                   .getPath("src/com/packt/cookbook/ch05_streams/");<br/>        BiPredicate&lt;Path, BasicFileAttributes&gt; select = <br/>          (p, b) -&gt; p.getFileName().toString().contains("Factory");<br/>        try(Stream&lt;Path&gt; stream = Files.find(f, 2, select)){<br/>          stream.map(path -&gt; path.getFileName())<br/>                .forEach(System.out::println);<br/>        } catch (Exception ex){ ex.printStackTrace(); }</pre>
<ol start="18">
<li>Run it and you'll get the following output:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img height="56" width="230" class="image-border" src="assets/454b54a6-a181-4d14-8904-9510363ff393.png"/></div>
<p style="padding-left: 60px">If necessary, <kbd>FileVisitorOption.FOLLOW_LINKS</kbd> could be included as the last parameter of <kbd>Files.find()</kbd> if we need to perform a search that would follow all symbolic links it might encounter. </p>
<p>The requirements for using the <kbd>BufferedReader.lines()</kbd> method, which returns <kbd>Stream&lt;String&gt;</kbd> of lines read from a file, is a little bit different. According to Javadoc, <em>The reader must not be operated on during the execution of the terminal stream operation. Otherwise, the result of the terminal stream operation is undefined</em>.</p>
<p>There are <span>many other methods in the JDK that produce streams. But they are more specialized, and we will not demonstrate them here because of shortage of space.  </span> </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Throughout the preceding examples, we have demonstrated several stream operations already--methods of the <kbd>Stream</kbd> interface. We used <kbd>forEach()</kbd> most often and used <kbd>limit()</kbd> a few times. The first one is a terminal operation and the second one is an intermediate one. Let's look at other methods of the <kbd>Stream</kbd> interface now. Here are the intermediate operations, methods that return <kbd>Stream</kbd> and can be connected in a fluent style:</p>
<pre>Stream&lt;T&gt; peek(Consumer&lt;T&gt; action)<br/><br/>Stream&lt;T&gt; distinct() //Returns stream of distinct elements<br/>Stream&lt;T&gt; skip(long n)    //Discards the first n elements <br/>Stream&lt;T&gt; limit(long max) //Discards elements after max <br/>Stream&lt;T&gt; <strong>filter</strong>(Predicate&lt;T&gt; predicate)<br/>Stream&lt;T&gt; dropWhile(Predicate&lt;T&gt; predicate) <br/>Stream&lt;T&gt; takeWhile(Predicate&lt;T&gt; predicate)<br/> <br/>Stream&lt;R&gt; <strong>map</strong>(Function&lt;T, R&gt; mapper)<br/>IntStream mapToInt(ToIntFunction&lt;T&gt; mapper)<br/>LongStream mapToLong(ToLongFunction&lt;T&gt; mapper)<br/>DoubleStream mapToDouble(ToDoubleFunction&lt;T&gt; mapper)<br/><br/>Stream&lt;R&gt; <strong>flatMap</strong>(Function&lt;T, Stream&lt;R&gt;&gt; mapper)<br/>IntStream flatMapToInt(Function&lt;T, IntStream&gt; mapper)<br/>LongStream flatMapToLong(Function&lt;T, LongStream&gt; mapper)<br/>DoubleStream flatMapToDouble(Function&lt;T, DoubleStream&gt; mapper)<br/><br/>static Stream&lt;T&gt;<span class="Apple-tab-span"> </span>concat(Stream&lt;T&gt; a, Stream&lt;T&gt; b)<span class="Apple-tab-span"> </span><br/><br/>Stream&lt;T&gt; sorted()<br/>Stream&lt;T&gt; sorted(Comparator&lt;T&gt; comparator)</pre>
<p>The signatures of the preceding methods typically include <kbd> "? super T"</kbd> for an input parameter and <kbd>"? extends R"</kbd> for the result (see the Javadoc for the formal definition). We simplified them by removing these notations in order to provide a better overview of the variety and commonality of the methods. To compensate, we would like to recap the meaning of the related generic notations since they are used extensively in the Stream API and might confuse you. Let's look at the formal definition of the <kbd>flatMap()</kbd> method because it has all of them: </p>
<pre>&lt;R&gt; Stream&lt;R&gt;<span class="Apple-tab-span"> </span>flatMap(Function&lt;? super T,<br/>                      ? extends Stream&lt;? extends R&gt;&gt; mapper)</pre>
<p>The <kbd>&lt;R&gt;</kbd>  interface in front of the method indicates to the compiler that it is a generic method (the one with its own type parameters). Without it, the compiler would be looking for the definition of a class or the <kbd>R</kbd> interface. The type <kbd>T</kbd> is not listed in front of the method because it is included in the <kbd>Stream&lt;T&gt;</kbd> interface definition. The <kbd>? super T</kbd> notation means that the type <kbd>T</kbd> is allowed here or in its superclass. The <kbd>? extends R</kbd><span> notation means that the type <kbd>R</kbd> is allowed here or its subclass. The same applies to <kbd>? extends Stream...</kbd></span> .</p>
<p>Now let's get back to our (simplified) list of intermediate operations, methods of the <kbd>Stream</kbd> interface. We have broken them into several groups by similarity. The first group contains only one <kbd>peek()</kbd> method that allows you to apply the <kbd>Consumer</kbd> function to each of the stream elements without affecting it whatsoever because the <kbd>Consumer</kbd> function does not return anything. It is typically used for debugging:</p>
<pre>int sum = Stream.of( 1,2,3,4,5,6,7,8,9 )<br/>  .filter(i -&gt; i % 2 != 0)<br/>  .peek(i -&gt; System.out.print(i))<br/>  .mapToInt(Integer::intValue)<br/>  .sum();<br/>System.out.println("\nsum = " + sum);</pre>
<p>The result is as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img height="35" width="201" class="image-border" src="assets/5c6cd744-2804-497f-b14f-e40484870f63.png"/></div>
<p><span>In the second group of intermediate operations, the first three are self-explanatory. The <kbd>filter()</kbd> method is one of the most used operations. It does what its name suggests; it discards the elements that match the criterion passed as the <kbd>Predicate</kbd> function to the method. We saw an example of its usage in the last snippet of code. The <kbd>dropWhile()</kbd> method discards the elements as long as the criterion is met (then allows the rest of the stream elements to flow to the next operation). The <kbd>takeWhile()</kbd> method does the opposite; it allows the elements to flow as long as the criterion is met (then discards the rest of the elements). Here is an example of this:</span></p>
<pre><span>System.out.println("Files.lines().dropWhile().takeWhile(): ");<br/>String file = "src/com/packt/cookbook/ch05_streams<br/>               /Chapter05Streams.java";<br/>try(Stream&lt;String&gt; stream = Files.lines(Paths.get(file))){<br/>  stream.dropWhile(l -&gt; !l.contains("dropWhile().takeWhile()"))<br/>        .takeWhile(l -&gt; !l.contains("} catc"+"h"))<br/>        .forEach(System.out::println);<br/>} catch (Exception ex){ ex.printStackTrace(); }<br/>   </span></pre>
<p>This code reads the file where this code is stored. It discards all the first lines of the file that do not have the <kbd>dropWhile().takeWhile()</kbd> substring, then allows all the lines to flow until the <kbd>} catch</kbd> substring is found. Notice that we had to break this string into <kbd>"} catch" + "h" </kbd> so that the criterion would not return <kbd>true</kbd> for this line. The result of this is as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img height="86" width="427" class="image-border" src="assets/62ee8c12-3312-435c-a973-e13884cb3837.png"/></div>
<p>The group of <kbd>map()</kbd> operations is pretty straightforward too. Such an operation transforms each element of the stream by applying to it a function that was passed in as a parameter. We have already seen an example of the usage of the <kbd>mapToInt()</kbd> method. Here is another example of the <kbd>map()</kbd> operation:</p>
<pre>Stream.of( "That ", "is ", "a ", "Stream.of(literals)" )<br/>      .map(s -&gt; s.contains("i")).forEach(System.out::println);</pre>
<p>In this example, we transform <kbd>String</kbd> literals into <kbd>boolean</kbd>. The result is as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img height="58" width="142" src="assets/7a2e5626-3536-45d8-b75d-29dafa75b623.png"/></div>
<p><span>The next group of intermediate operations, called <kbd>flatMap()</kbd>, provides more complex processing. A <kbd>flatMap()</kbd> operation applies the passed-in function (that returns a stream) to each of the elements so that the operation could produce a stream composed of the streams extracted from each of the elements. Here's an example of this:</span></p>
<pre>Stream.of( "That ", "is ", "a ", "Stream.of(literals)" )<br/>      .filter(s -&gt; s.contains("Th"))<br/>      .flatMap(s -&gt; Pattern.compile("(?!^)").splitAsStream(s))<br/>      .forEach(System.out::print);</pre>
<p><span>From the input stream, the preceding code selects only literals that contain <kbd>Th</kbd> and converts them into a stream of characters, which are then printed out by <kbd>forEach()</kbd>. The result of this is as follows: </span></p>
<div class="CDPAlignCenter CDPAlign"><img height="64" width="239" class="image-border" src="assets/3cf67794-6dd0-4a5d-9c0d-5a10fbce7b58.png"/></div>
<p>The <kbd>concat()</kbd> method creates a stream from two input streams so that all the elements of the first stream are followed by all the elements of the second stream. Here's an example of this:</p>
<pre>Stream.concat(Stream.of(4,5,6), Stream.of(1,2,3))<br/>      .forEach(System.out::print);</pre>
<p>The result is as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img height="31" width="166" class="image-border" src="assets/284c93ff-e7ea-4ee3-abc0-f5f41c2ee1fa.png"/></div>
<p>In case there are more than two stream concatenations, you can write the following:</p>
<pre>Stream.of(Stream.of(4,5,6), Stream.of(1,2,3), Stream.of(7,8,9))<br/>      .flatMap(Function.identity())<br/>      .forEach(System.out::print);</pre>
<p>Here, <kbd>Function.identity()</kbd> is a function that returns its input argument (because we do not need to transform the input streams but just pass them as is to the resulting stream). The result is as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img height="27" width="222" class="image-border" src="assets/ad05dc2c-a8f6-474b-a382-9baef7e45811.png"/></div>
<p>The last group of intermediate operations is composed of the <kbd>sorted()</kbd> methods that sort the stream elements in a natural (without parameters) or specified (according to the passed-in <kbd>Comparator</kbd>) order. It is a stateful operation (as well as <kbd>distinct()</kbd>, <kbd>limit()</kbd>, and <kbd>skip()</kbd>) that yields a non-deterministic result in the case of parallel processing; this is, however, the topic of a later recipe.</p>
<p>Now let's look at terminal operations (we simplified their signature too by removing <kbd>? super T</kbd> and <kbd>? extends R</kbd>):</p>
<pre>long count()            //Returns count of elements<br/>Optional&lt;T&gt; max(Comparator&lt;T&gt; comparator) //Max according <br/>                                          // to Comparator<br/>Optional&lt;T&gt; min(Comparator&lt;T&gt; comparator) //Min according<br/>                                          // to Comparator<br/><br/>Optional&lt;T&gt; findAny() //Returns any or empty Optional<br/>Optional&lt;T&gt; findFirst()  //Returns the first element <br/>                         // or empty Optional <br/>boolean allMatch(Predicate&lt;T&gt; predicate) //All elements <br/>                                        // match Predicate?<br/>boolean anyMatch(Predicate&lt;T&gt; predicate)  //Any element <br/>                                        // match Predicate?<br/>boolean noneMatch(Predicate&lt;T&gt; predicate) //No element <br/>                                        // match Predicate?<br/><br/>void forEach(Consumer&lt;T&gt; action) //Apply action to each el <br/>void forEachOrdered(Consumer&lt;T&gt; action) <br/><br/>Optional&lt;T&gt; reduce(BinaryOperator&lt;T&gt; accumulator) <br/>T reduce(T identity, BinaryOperator&lt;T&gt; accumulator) <br/>U reduce(U identity, BiFunction&lt;U,T,U&gt; accumulator, <br/>         BinaryOperator&lt;U&gt; combiner) <br/>R collect(Collector&lt;T,A,R&gt; collector) <br/>R collect(Supplier&lt;R&gt; supplier, BiConsumer&lt;R,T&gt; accumulator, <br/>          BiConsumer&lt;R,R&gt; combiner) <br/>Object[] toArray() <br/>A[] toArray(IntFunction&lt;A[]&gt; generator)</pre>
<p>The first two groups are self-explanatory, but we need to say a few words about <kbd>Optional</kbd>. The Javadoc defines it this way: <em>A container object which may or may not contain a non-null value. If a value is present, isPresent() returns true and get() returns the value</em>. It allows you to avoid <kbd>NullPointerException</kbd> or check for <kbd>null</kbd> (which would break the one-line style of code writing). For the same reason, it has its own methods: <kbd>map()</kbd>, <kbd>filter()</kbd>, and <kbd>flatMap()</kbd>. In addition, Optional has methods that include the <kbd>isPresent()</kbd> check implicitly:</p>
<ul>
<li><kbd>ifPresent(Consumer&lt;T&gt; action)</kbd>: This performs the action with the value (if present, or it does nothing).</li>
<li><kbd>ifPresentOrElse(Consumer&lt;T&gt; action, Runnable emptyAction)</kbd><span><span>: This performs the given action with the value (if present, or it performs the given empty-based action).</span></span></li>
<li><kbd>or(Supplier&lt;Optional&lt;T&gt;&gt; supplier)</kbd><span>: This returns an</span> <kbd>Optional</kbd><span> class describing the value (if present, or it returns an <kbd>Optional</kbd></span><span> class produced by the supplying function).</span></li>
<li><kbd>orElse(T other)</kbd><span>: This returns the value (if present, or it returns</span> <kbd>other</kbd><span>).</span></li>
<li><kbd>orElseGet(Supplier&lt;T&gt; supplier)</kbd><span>: This returns the value (if present, or it returns the result produced by the supplying function).</span></li>
<li><kbd>orElseThrow(Supplier&lt;X&gt; exceptionSupplier)</kbd><span>: This returns the value (if present, or it throws an exception produced by the exception-supplying function).</span></li>
</ul>
<p style="padding-left: 30px">Note that <kbd>Optional</kbd> is used as a return value in cases when <kbd>null</kbd> is a possible result. Here is an example of the usage. We reimplemented the stream-concatenating code using the <kbd>reduce()</kbd> operation that returns <kbd>Optional</kbd>: </p>
<pre>Stream.<span>of</span>(Stream.<span>of</span>(<span>4</span><span>,</span><span>5</span><span>,</span><span>6</span>)<span>, </span>Stream.<span>of</span>(<span>1</span><span>,</span><span>2</span><span>,</span><span>3</span>)<span>, </span>Stream.<span>of</span>(<span>7</span><span>,</span><span>8</span><span>,</span><span>9</span>))<br/>      .reduce(Stream::<span>concat</span>)<br/>      .orElseGet(Stream::<span>empty</span>)<br/>      .forEach(System.<span>out</span>::print)<span>;</span></pre>
<p>The result is the same as in the previous implementation with a <kbd>flatMap()</kbd> method:</p>
<div class="CDPAlignCenter CDPAlign"><img height="28" width="230" class="image-border" src="assets/ad05dc2c-a8f6-474b-a382-9baef7e45811.png"/></div>
<p>The next group of terminal operations is referred to as <kbd>forEach()</kbd>. These operations guarantee that the given function will be applied to each element of the stream, but <kbd>forEach()</kbd> does not say anything about the order, which might be changed for better performance. By contrast, <kbd>forEachOrdered()</kbd> <span>guarantees</span> not only the processing of all the elements of the stream, but also doing this in the order specified by its source, regardless of whether the stream is sequential or parallel. Here <span>are </span>a couple of examples of this:</p>
<pre>Stream.of("3","2","1").parallel().forEach(System.out::print);<br/>System.out.println();<br/>Stream.of("3","2","1").parallel().forEachOrdered(System.out::print);</pre>
<p>The result is as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img height="50" width="156" class="image-border" src="assets/c4c32012-5098-4e71-9ac7-1b08651205b5.png"/></div>
<p>As you can see, in the case of parallel processing, <kbd>forEach()</kbd> does not guarantee the order, while <kbd>forEachOrdered()</kbd> does. Here is another example of using both <kbd>Optional</kbd> and <kbd>forEach()</kbd>:</p>
<pre> Stream.of( "That ", "is ", "a ", null, "Stream.of(literals)" )<br/>       .map(Optional::ofNullable) <br/>       .filter(Optional::isPresent)<br/>       .map(Optional::get)<br/>       .map(String::toString)<br/>       .forEach(System.out::print);</pre>
<p>We could not use <kbd>Optional.of()</kbd> and used <kbd>Optional.ofNullable()</kbd> instead because <kbd>Optional.of()</kbd> would throw <kbd>NullPointerException</kbd> on <kbd>null</kbd>. In such a case, <span><kbd>Optional.ofNullable()</kbd> just returns <kbd>Optional</kbd> empty. The result is as follows:</span></p>
<div class="CDPAlignCenter CDPAlign"><img height="33" width="284" class="image-border" src="assets/121b8403-b056-4116-8aa2-ac7e319e8275.png"/></div>
<p>Now let's talk about the next group of terminal operations, called <kbd>reduce()</kbd>. Each of the three overloaded methods returns a single value after processing all the stream elements. Among the most simple examples are finding a sum of the stream elements in case they are numbers, or max, min, and similar. But a more complex result can be constructed too for a stream of objects of any type. </p>
<p>The first method, namely <kbd>reduce(BinaryOperator&lt;T&gt; accumulator)</kbd>, returns <kbd>Optional</kbd> because it is the responsibility of the provided accumulator function to calculate the result. And, the authors of the JDK implementation cannot guarantee it will always have some value:</p>
<pre> int sum = Stream.of(1,2,3).reduce((p,e) -&gt; p + e).orElse(0);<br/> System.out.println("Stream.of(1,2,3).reduce(acc): " +sum);</pre>
<p>The passed-in function is provided the result of the previous result of the same function (as the first parameter <kbd>p</kbd>) and the next element of the stream (as the second parameter <kbd>e</kbd>). For the very first element, <kbd>p</kbd> gets its value, while <kbd>e</kbd> is the second element. The result is as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img height="34" width="298" class="image-border" src="assets/da547cd3-0ddb-4698-bbcf-e717a1f6900b.png"/></div>
<p>To avoid the extra step with <kbd>Optional</kbd>, the second method returns the value provided as the first parameter <kbd>identity</kbd> of the type <kbd>T</kbd> (which is the type of the elements of <kbd>Stream&lt;T&gt;</kbd>) in case the stream is empty. This parameter has to comply with this requirement (from Javadoc): <em>for all t, accumulator.apply(identity, t) is equal to t</em>. In our case, it has to be <kbd>0</kbd> for it to comply with <kbd>0 + e == e</kbd>. Here is an example of how to use the second method:</p>
<pre>int sum = Stream.of(1,2,3).reduce(0, (p,e) -&gt; p + e);<br/>System.out.println("Stream.of(1,2,3).reduce(0,acc): " +sum);</pre>
<p>The result is the same as with the first <kbd>reduce()</kbd> method. The third one converts the value of the type <kbd>T</kbd> into a value of the type <kbd>U</kbd> with the help of the <kbd>BiFunction&lt;U,T,U&gt;</kbd> function. Then, the result (of the type <kbd>R</kbd>) goes through the same logic of processing it as the type <kbd>T</kbd>, as in the previous method. Here is an example of this:</p>
<pre>String sum = Stream.<span>of</span>(<span>1</span><span>,</span><span>2</span><span>,</span><span>3</span>).reduce(<span>""</span><span>, </span>(p<span>,</span>e) -&gt; p + e.toString()<span>,<br/>                                     </span>(x<span>,</span>y) -&gt; x + <span>"," </span>+ y)<span>;<br/></span>System.<span>out</span>.println(<span>"Stream.of(1,2,3).reduce(,acc,comb): " </span>+ sum)<span>;<br/></span></pre>
<p>One naturally expects to see the result as <kbd>1,2,3</kbd>. Instead, we see the following:</p>
<div class="CDPAlignCenter CDPAlign"><img height="33" width="365" class="image-border" src="assets/f453e234-85f7-47da-9afe-f3adad0ba221.png"/> </div>
<p>Make the stream parallel like so:</p>
<pre>String sum = Stream.<span>of</span>(<span>1</span><span>,</span><span>2</span><span>,</span><span>3</span>).<strong>parallel()  <br/></strong>                   .reduce(<span>""</span><span>, </span>(p<span>,</span>e) -&gt; p + e.toString()<span>, <br/></span>                           (x<span>,</span>y) -&gt; x + <span>"," </span>+ y)<span>;<br/></span>System.<span>out</span>.println(<span>"Stream.of(1,2,3).reduce(,acc,comb): " </span>+ sum)<span>;</span></pre>
<p>Only if you do this, you will see what's expected:</p>
<div class="CDPAlignCenter CDPAlign"><img height="35" width="406" class="image-border" src="assets/d862ec3f-c521-4e50-8dd2-928d9b51bf7c.png"/></div>
<p>This means that the combiner is called only for parallel processing in order to assemble (combine) the results of different streams (processed in parallel). This is the only deviation we have noticed so far from the declared intent of providing the same behavior for sequential and parallel streams. But there are many ways to accomplish the same result without using this third version of <kbd>reduce()</kbd>. For example, consider this code: </p>
<pre>String sum = Stream.<span>of</span>(<span>1</span><span>,</span><span>2</span><span>,</span><span>3</span>)<br/>                   .map(i -&gt; i.toString() + <span>","</span>)<br/>                   .reduce(<span>""</span><span>, </span>(p<span>,</span>e) -&gt; p + e)<span>;<br/></span>System.<span>out</span>.println(<span>"Stream.of(1,2,3).map.reduce(,acc): " <br/></span>                   + sum.substring(0, sum.length()-1))<span>;<br/></span></pre>
<p>It produces the same result, as follows:</p>
<pre>String sum = Stream.<span>of</span>(<span>1</span><span>,</span><span>2</span><span>,</span><span>3</span>).<strong>parallel()</strong><br/>                   .map(i -&gt; i.toString() + <span>","</span>)<br/>                   .reduce(<span>""</span><span>, </span>(p<span>,</span>e) -&gt; p + e)<span>;<br/></span>System.<span>out</span>.println(<span>"Stream.of(1,2,3).map.reduce(,acc): " <br/></span>                   + sum.substring(0, sum.length()-1))<span>;<br/></span></pre>
<p>Here is the result:</p>
<div class="CDPAlignCenter CDPAlign"><img height="28" width="345" class="image-border" src="assets/7d9b41e2-ae9e-4d68-a4b6-c96d0ee5d12b.png"/></div>
<p>The next group of intermediate operations, called <kbd>collect()</kbd>, consists of two methods. The first one accepts <kbd>Collector</kbd> as a parameter. It is much more popular than the second one because it is backed up by the <kbd>Collectors</kbd> class, which provides a wide variety of implementations of the <kbd>Collector</kbd> interface. We encourage you to go through the Javadoc of the <kbd>Collectors</kbd> class and see what it offers. Let's discuss a few examples of this. First, we'll create a small <kbd>demo</kbd> class:</p>
<pre>public class Thing {<br/>  private int someInt;<br/>  public Thing(int i) { this.someInt = i; }<br/>  public int getSomeInt() { return someInt; }<br/>  public String getSomeStr() { <br/>    return Integer.toString(someInt); }<br/>} </pre>
<p>We can use it to demonstrate a few collectors:</p>
<pre>double aa = Stream.of(1,2,3).map(Thing::new)<br/>                  .collect(Collectors.averagingInt(Thing::getSomeInt));<br/>System.out.println("stream(1,2,3).averagingInt(): " + aa);<br/><br/>String as = Stream.of(1,2,3).map(Thing::new).map(Thing::getSomeStr)<br/>                  .collect(Collectors.joining(","));<br/>System.out.println("stream(1,2,3).joining(,): " + as);<br/><br/>String ss = Stream.of(1,2,3).map(Thing::new).map(Thing::getSomeStr)<br/>                  .collect(Collectors.joining(",", "[", "]"));<br/>System.out.println("stream(1,2,3).joining(,[,]): " + ss);</pre>
<p>The result will be as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img height="50" width="356" class="image-border" src="assets/d68dd3e2-b17e-4ccb-b09b-3183f04842b1.png"/></div>
<p>The joining collector is a source of joy for any programmer who has ever had to write code that checks whether the added element is the first, the last, or removes the last character (like we did in the last example of the <kbd>reduce()</kbd> operation). The <kbd>joining()</kbd> collector does this behind the scenes. All the programmer has to pass are the delimiter, prefix, and suffix. </p>
<p>Most programmers will never need to write a custom collector. But in case there is a need, one can use the second method <kbd>collect()</kbd> of <kbd>Stream</kbd> (and provide functions that will compose a collector) or use one of the two static methods <kbd>Collector.of()</kbd> that generates a collector that can be reused.</p>
<p>If you compare the <kbd>reduce()</kbd> and <kbd>collect()</kbd> operations, you'll notice that the primary purpose of <kbd>reduce()</kbd> is to operate on immutable objects and primitives. The result of <kbd>reduce()</kbd> is one value that is typically (but not exclusively) of the same type as the elements of the stream. The <kbd>collect()</kbd>, by contrast, produces the result of a different type wrapped in a mutable container. The most popular usage of <kbd>collect()</kbd> is centered around producing <kbd>List</kbd>, <kbd>Set</kbd>, or <kbd>Map</kbd> using the corresponding <kbd>Collectors.toList()</kbd>, <kbd>Collectors.toSet()</kbd>, or <kbd>Collectors.toMap()</kbd> collector. </p>
<p>The last group of terminal operations consists of two methods <kbd>toArray()</kbd>. One of them returns <kbd>Object[]</kbd>, another one returns an array of the specified type. Let's look at the examples of their usage:</p>
<pre> Object[] os = Stream.of(1,2,3).<strong>toArray()</strong>;<br/> Arrays.stream(os).forEach(System.out::print);<br/> System.out.println();<br/> String[] sts = Stream.of(1,2,3).map(i -&gt; i.toString())<br/>                      .<strong>toArray</strong>(String[]::new);<br/> Arrays.stream(sts).forEach(System.out::print);</pre>
<p>The output of these examples is as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img height="42" width="131" class="image-border" src="assets/3e1381e8-e62e-47fa-b87c-24959060fb00.png"/></div>
<p>The first example is quite straightforward. It is worth commenting though that we cannot write the following:</p>
<pre>Stream.of(1,2,3).toArray().forEach(System.out::print);</pre>
<p>This is because <kbd>toArray()</kbd> is a terminal operation and the stream is closed automatically after it. That's why we have to open a new stream in the second line.</p>
<p>The second example--with the overloaded <kbd>A[] toArray(IntFunction&lt;A[]&gt; generator)</kbd> method--is more complicated. The Javadoc says this: <em>The generator function takes an integer, which is the size of the desired array, and produces an array of the desired size</em>. This means that the method reference to a <kbd>toArray(String[]::new)</kbd> constructor in the last example is a shorter version of <kbd>toArray(size -&gt; new String[size])</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>The <kbd>java.util.stream</kbd> p<span>ackage also </span>provides specialized interfaces, namely <kbd>IntStream</kbd>, <kbd>DoubleStream</kbd>, and <kbd>LongStream</kbd>, that are optimized for processing streams of values of corresponding primitive types. It is very convenient to use them in the case of reducing operations. For example, they have <kbd>max()</kbd>, <kbd>min()</kbd>, <kbd>average()</kbd>, <kbd>sum()</kbd>, and many other simplified (tuned for performance) methods that can be called on these streams directly as intermediate and terminal operations.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<p>Refer to the following recipes in this chapter:</p>
<ul>
<li>Create operation pipeline on streams</li>
<li>Parallel computations on streams</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating an operation pipeline on streams</h1>
                </header>
            
            <article>
                
<p>In this recipe, you will learn how to build a pipeline from <kbd>Stream</kbd> operations.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p><span>In the previous chapter, while creating a lambda-friendly API, we ended up with the following API method:</span></p>
<pre>public interface Traffic {<br/>  void speedAfterStart(double timeSec, <br/>    int trafficUnitsNumber, SpeedModel speedModel, <br/>    BiPredicate&lt;TrafficUnit, Double&gt; limitTraffic,     <br/>    BiConsumer&lt;TrafficUnit, Double&gt; printResult);<br/> }</pre>
<p>The specified number of <kbd>TrafficUnit</kbd> instances were produced inside <span>the</span> <kbd>speedAfterStart()</kbd> <span>method. They were</span> limited by the <kbd>limitTrafficAndSpeed</kbd> function and processed according to the <kbd>speedModel</kbd> function inside the <kbd>speedAfterStart()</kbd> method. The results were shown on the device and in the format specified by the <kbd>printResults</kbd> function.  </p>
<p>It is a very flexible design that allows you to have quite a range of experimentation via the modification of functions that are passed to the API. In reality, though, especially during the early stages of data analysis, having an API creates an overhead. If the provided flexibility is not enough, one needs to change it and build and deploy a new version. It takes time and the implementation lacks transparency.</p>
<p>To be fair, the encapsulation of the implementation details was one of the API design requirements. But it works well with the established processes that need to be wrapped as a product for a population of users. The situation radically changes during the research phase. When new algorithms are developed and tested and when the need for processing a large amount of data presents its own challenge, transparency across all the layers of the developed system becomes a foundational requirement. Without it, many of today's successes in the big data analysis world would be impossible. </p>
<p>Streams and the pipelines of stream operations address the problem of transparency and minimize the overhead of writing infrastructural code. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Let's recall how a user called the lambda-friendly API:</p>
<pre>double timeSec = 10.0;<br/>int trafficUnitsNumber = 10;<br/><br/>SpeedModel speedModel = (t, wp, hp) -&gt; ...;<br/>BiConsumer&lt;TrafficUnit, Double&gt; printResults = (tu, sp) -&gt; ...;<br/>BiPredicate&lt;TrafficUnit, Double&gt; limitSpeed = (tu, sp) -&gt; ...;<br/><br/>Traffic api = new TrafficImpl(Month.APRIL, DayOfWeek.FRIDAY, 17, <br/>                              "USA", "Denver", "Main103S");<br/>api.speedAfterStart(timeSec, trafficUnitsNumber, speedModel, <br/>                    limitSpeed, printResults);</pre>
<p>As we have already noticed, the freedom of the speed calculation manipulation with such an API (without changing it) extends to the formula of the speed calculation, device and format of the output, and the selection of traffic. This is not bad in our simplistic application, but it might not cover all the possibilities of the model evolution in the case of more complex calculations. But it is a good start that allows us to construct the stream and the pipeline of operations for more transparency and flexibility of experimentation.</p>
<p><span>Now let's look at the API implementation:</span></p>
<p> </p>
<pre>double timeSec = 10.0;<br/>int trafficUnitsNumber = 10;<br/><br/>SpeedModel speedModel = (t, wp, hp) -&gt; ...;<br/>BiConsumer&lt;TrafficUnit, Double&gt; printResults = (tu, sp) -&gt; ...;<br/>BiPredicate&lt;TrafficUnit, Double&gt; limitSpeed = (tu, sp) -&gt; ...;<br/>List&lt;TrafficUnit&gt; trafficUnits = FactoryTraffic<br/>     .generateTraffic(trafficUnitsNumber, Month.APRIL, <br/>                      DayOfWeek.FRIDAY, 17, "USA", "Denver",<br/>                      "Main103S");<br/>for(TrafficUnit tu: trafficUnits){<br/>  Vehicle vehicle = FactoryVehicle.build(tu);<br/>  vehicle.setSpeedModel(speedModel);<br/>  double speed = vehicle.getSpeedMph(timeSec);<br/>  speed = Math.round(speed * tu.getTraction());<br/>    if(limitSpeed.test(tu, speed)){<br/>      printResults.accept(tu, speed);<br/>    }<br/>  }</pre>
<p><span>Next, we convert the <kbd>for</kbd> loop into a stream of traffic units and apply the same functions directly to the elements of the stream. But first, we can request the traffic-generating system to supply us with <kbd>Stream</kbd> instead of <kbd>List</kbd> of data. This allows you to avoid the storing of all the data in the memory:</span></p>
<pre>Stream&lt;TrafficUnit&gt; stream = FactoryTraffic<br/>       .<span>getTrafficUnitStream</span>(trafficUnitsNumber<span>, </span>Month.<span>APRIL</span><span>,<br/></span>                             DayOfWeek.<span>FRIDAY</span><span>, </span><span>17</span><span>, </span><span>"USA"</span><span>, </span><span>"Denver"</span><span>,<br/></span><span>                             "Main103S"</span>)<span>;</span></pre>
<p>This allows you to process an endless number of traffic units without storing more than one unit at a time in the memory. In the demo code, we still create <kbd>List</kbd>, so the streaming does not save us memory. But there are real systems, such as sensors, that can provide streams without storing all of the data in the memory first. </p>
<p>We will also create a convenience method:</p>
<pre>Stream&lt;TrafficUnit&gt;<span>getTrafficUnitStream</span>(<span>int </span>trafficUnitsNumber){<br/>  <span>return </span>FactoryTraffic<br/>         .<span>getTrafficUnitStream</span>(trafficUnitsNumber<span>,</span>Month.<span>APRIL</span><span>, <br/></span>                               DayOfWeek.<span>FRIDAY</span><span>, </span><span>17</span><span>, </span><span>"USA"</span><span>, </span><span>"Denver"</span><span>,<br/></span><span>                               "Main103S"</span>)<span>;<br/></span>}</pre>
<p>With this, we will now write the following:</p>
<p> </p>
<pre>getTrafficUnitStream(trafficUnitsNumber).map(tu -&gt; {<br/>  Vehicle vehicle = FactoryVehicle.build(tu);<br/>  vehicle.setSpeedModel(speedModel);<br/>  return vehicle;<br/>})<br/>.map(v -&gt; {<br/>  double speed = v.getSpeedMph(timeSec);<br/>  return Math.round(speed * tu.getTraction());<br/>})<br/>.filter(s -&gt; limitSpeed.test(tu, s))<br/>.forEach(tuw -&gt; printResults.accept(tu, s));</pre>
<p><span>We mapped (transform) <kbd>TrafficUnit</kbd> to <kbd>Vehicle</kbd>, then mapped <kbd>Vehicle</kbd> to <kbd>speed</kbd>, then used the current <kbd>TrafficUnit</kbd> instance and calculated <kbd>speed</kbd> to limit the traffic and print results. If you have this code in a modern editor, you will notice that it does not compile because after the first map, the current <kbd>TrafficUnit</kbd> element is not accessible anymore; it is replaced by <kbd>Vehicle</kbd>. This means we need to carry along the original elements and add new values on the way. To accomplish this, we need a container--some kind of a traffic unit wrapper. Let's create one:</span></p>
<p> </p>
<pre>private static class TrafficUnitWrapper {<br/>  private double speed;<br/>  private Vehicle vehicle;<br/>  private TrafficUnit trafficUnit;<br/>  public TrafficUnitWrapper(TrafficUnit trafficUnit){<br/>    this.trafficUnit = trafficUnit;<br/>  }<br/>  public TrafficUnit getTrafficUnit(){ return this.trafficUnit; }<br/>  public Vehicle getVehicle() { return vehicle; }<br/>  public void setVehicle(Vehicle vehicle) { <br/>    this.vehicle = vehicle; <br/>  }<br/>  public double getSpeed() { return speed; }<br/>  public void setSpeed(double speed) { this.speed = speed; }<br/>}</pre>
<p>Now we can build a pipeline that works:</p>
<p> </p>
<pre>getTrafficUnitStream(trafficUnitsNumber)<br/>   .map(TrafficUnitWrapper::new)<br/>   .map(tuw -&gt; {<br/>  Vehicle vehicle = FactoryVehicle.build(tuw.getTrafficUnit());<br/>  vehicle.setSpeedModel(speedModel);<br/>  tuw.setVehicle(vehicle);<br/>  return tuw;<br/>})<br/>.map(tuw -&gt; {<br/>  double speed = tuw.getVehicle().getSpeedMph(timeSec);<br/>  speed = Math.round(speed * tuw.getTrafficUnit()<br/>                                .getTraction());<br/>  tuw.setSpeed(speed);<br/>  return tuw;<br/>})<br/>.filter(tuw -&gt; limitSpeed.test(tuw.getTrafficUnit(), <br/>                               tuw.getSpeed()))<br/>.forEach(tuw -&gt; printResults.accept(tuw.getTrafficUnit(), <br/>                                    tuw.getSpeed()));</pre>
<p>The code looks a bit verbose, especially the <kbd>Vehicle</kbd> and <kbd>SpeedModel</kbd> setting. We can hide these plumbing details by moving them to the <kbd>TrafficUntiWrapper</kbd> class:</p>
<pre>private static class TrafficUnitWrapper {<br/>  private double speed;<br/>  private Vehicle vehicle;<br/>  private TrafficUnit trafficUnit;<br/>  public TrafficUnitWrapper(TrafficUnit trafficUnit){<br/>    this.trafficUnit = trafficUnit;<br/>    this.vehicle = FactoryVehicle.build(trafficUnit);<br/>  }<br/>  public TrafficUnitWrapper setSpeedModel(SpeedModel speedModel) {<br/>    this.vehicle.setSpeedModel(speedModel);<br/>    return this;<br/>  }<br/>  pubic TrafficUnit getTrafficUnit(){ return this.trafficUnit; }<br/>  public Vehicle getVehicle() { return vehicle; }<br/>  public double getSpeed() { return speed; }<br/>  public TrafficUnitWrapper setSpeed(double speed) { <br/>    this.speed = speed;<br/>    return this; <br/>  }<br/>}</pre>
<p>Notice how we return <kbd>this</kbd> from the <kbd>setSpeedModel()</kbd> and <kbd>setSpeed()</kbd> methods. This allows us to preserve the fluent style. Now the pipeline looks much cleaner:</p>
<pre>getTrafficUnitStream(trafficUnitsNumber)<br/>   .map(TrafficUnitWrapper::new)<br/>   .map(tuw -&gt; tuw.setSpeedModel(speedModel))<br/>   .map(tuw -&gt; {<br/>  double speed = tuw.getVehicle().getSpeedMph(timeSec);<br/>  speed = Math.round(speed * tuw.getTrafficUnit()<br/>                                .getTraction());<br/>  return tuw.setSpeed(speed);<br/>})<br/>.filter(tuw -&gt; limitSpeed.test(tuw.getTrafficUnit(), <br/>                               tuw.getSpeed()))<br/> .forEach(tuw -&gt; printResults.accept(tuw.getTrafficUnit(), <br/>                                     tuw.getSpeed()));</pre>
<p>If there is no need to keep the formula for the speed calculations easily accessible to the modification, we can move it to the <kbd>TrafficUnitWrapper</kbd> class too by changing the <kbd>setSpeed()</kbd> method to <kbd>calcSpeed()</kbd>:</p>
<pre>public TrafficUnitWrapper calcSpeed(double timeSec) {<br/>  double speed = this.vehicle.getSpeedMph(timeSec);<br/>  this.speed = Math.round(speed * this.trafficUnit<br/>                                      .getTraction());<br/>  return this;<br/>}</pre>
<p>So, the pipeline becomes even less verbose:</p>
<pre>getTrafficUnitStream(trafficUnitsNumber)<br/>   .map(TrafficUnitWrapper::new)<br/>   .map(tuw -&gt; tuw.setSpeedModel(speedModel))<br/>   .map(tuw -&gt; tuw.calcSpeed(timeSec))<br/>   .filter(tuw -&gt; limitSpeed.test(tuw.getTrafficUnit(), <br/>                                  tuw.getSpeed()))<br/>   .forEach(tuw -&gt; printResults.accept(tuw.getTrafficUnit(), <br/>                                       tuw.getSpeed()));</pre>
<p>Based on this technique, we can now create a method that calculates traffic density--the count of vehicles in each lane of a multilane road for the given speed limit in each of these lanes:</p>
<pre>Integer[] <span>trafficByLane</span>(Stream&lt;TrafficUnit&gt; stream<span>, <br/>                 int </span>trafficUnitsNumber<span>, double </span>timeSec<span>, <br/></span>                 SpeedModel speedModel<span>, double</span>[] speedLimitByLane) {<br/>  <span>int </span>lanesCount = speedLimitByLane.<span>length</span><span>;<br/></span><span>  </span>Map&lt;Integer<span>, </span>Integer&gt; trafficByLane = stream<br/>               .limit(trafficUnitsNumber)<br/>               .map(TrafficUnitWrapper::<span>new</span>)<br/>               .map(tuw -&gt; tuw.setSpeedModel(<span>speedModel</span>))<br/>               .map(tuw -&gt; tuw.calcSpeed(<span>timeSec</span>))<br/>               .map(speed -&gt; countByLane(<span>lanesCount</span><span>, <br/></span><span>                                  speedLimitByLane</span><span>, </span>speed))<br/>               .collect(Collectors<br/>                   .<span>groupingBy</span>(CountByLane::getLane<span>, </span>Collectors<br/>                   .<span>summingInt</span>(CountByLane::getCount)))<span>;</span><span><br/></span><span>  for</span>(<span>int </span>i = <span>1</span><span>; </span>i &lt;= lanesCount<span>; </span>i++){<br/>    trafficByLane.putIfAbsent(i<span>, </span><span>0</span>)<span>;<br/></span><span>  </span>}<br/>  <span>return </span>trafficByLane.values().toArray(<span>new </span>Integer[lanesCount])<span>;<br/></span>}</pre>
<p>It uses two private classes, as follows:</p>
<pre><span>private class </span>CountByLane {<br/>  <span>int </span><span>count</span><span>, </span><span>lane</span><span>;<br/></span><span>  private </span><span>CountByLane</span>(<span>int </span>count<span>, int </span>lane){<br/>    <span>this</span>.<span>count </span>= count<span>;<br/></span><span>    this</span>.<span>lane </span>= lane<span>;<br/></span><span>  </span>}<br/>  <span>public int </span><span>getLane</span>() { <span>return </span><span>lane</span><span>; </span>}<br/>  <span>public int </span><span>getCount</span>() { <span>return </span><span>count</span><span>; </span>}<br/>}</pre>
<p>It also uses the following: </p>
<pre><span>private static class </span>TrafficUnitWrapper {<br/>  <span>private </span>Vehicle <span>vehicle</span><span>;<br/></span><span>  private </span>TrafficUnit <span>trafficUnit</span><span>;<br/></span><span>  public </span><span>TrafficUnitWrapper</span>(TrafficUnit trafficUnit){<br/>    <span>this</span>.<span>vehicle </span>= FactoryVehicle.<span>build</span>(trafficUnit)<span>;<br/></span><span>    this</span>.<span>trafficUnit </span>= trafficUnit<span>;<br/></span><span>  </span>}<br/>  <span>public </span>TrafficUnitWrapper <span>setSpeedModel</span>(SpeedModel speedModel) {<br/>    <span>this</span>.<span>vehicle</span>.setSpeedModel(speedModel)<span>;<br/></span><span>    return this;<br/></span><span>  </span>}<br/>  <span>public double </span><span>calcSpeed</span>(<span>double </span>timeSec) {<br/>    <span>double </span>speed = <span>this</span>.<span>vehicle</span>.getSpeedMph(timeSec)<span>;<br/></span><span>    return </span>Math.<span>round</span>(speed * <span>this</span>.<span>trafficUnit</span>.getTraction())<span>;<br/></span><span>  </span>}<br/>}</pre>
<p>It uses the private method too:</p>
<pre><span>private </span>CountByLane <span>countByLane</span>(<span>int </span>lanesNumber<span>, double</span>[] speedLimit<span>, <br/>                                double </span>speed){<br/>  <span>for</span>(<span>int </span>i = <span>1</span><span>; </span>i &lt;= lanesNumber<span>; </span>i++){<br/>    <span>if</span>(speed &lt;= speedLimit[i - <span>1</span>]){ <br/>      <span>return new </span>CountByLane(<span>1</span><span>, </span>i)<span>;<br/></span><span>    </span>}<br/>  }<br/>  <span>return new </span>CountByLane(<span>1</span><span>, </span>lanesNumber)<span>;<br/></span>}</pre>
<p>In <a href="823213ae-b820-450c-abb8-8a98a70caf70.xhtml">Chapter 15</a>, <em>Testing</em>, we will discuss this method (of the <kbd>TrafficDensity</kbd> class) in more detail and revisit this implementation to allow you to have better unit testing.</p>
<p>This is why writing a unit test parallel to the code development brings higher productivity by eliminating the need for changing the code afterward. It also results in more testable (better quality) code. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p><span>The pipeline allows you to add another filter (or any other operation) easily:</span></p>
<pre>Predicate&lt;TrafficUnit&gt; limitTraffic = tu -&gt;<br/>    tu.getVehicleType() == Vehicle.VehicleType.CAR<br/>    || tu.getVehicleType() == Vehicle.VehicleType.TRUCK;<br/><br/>getTrafficUnitStream(trafficUnitsNumber)<br/>   .filter(limitTraffic)<br/>   .map(TrafficUnitWrapper::new)<br/>   .map(tuw -&gt; tuw.setSpeedModel(speedModel))<br/>   .map(tuw -&gt; tuw.calcSpeed(timeSec))<br/>   .filter(tuw -&gt; limitSpeed.test(tuw.getTrafficUnit(), <br/>                                  tuw.getSpeed()))<br/>   .forEach(tuw -&gt; printResults.accept(tuw.getTrafficUnit(), <br/>                                       tuw.getSpeed()));</pre>
<p><span>It is especially important when many types of data have to be processed. It's worth mentioning that having a filter before the calculations is the best way to improve performance because it allows you to avoid unnecessary calculations.</span></p>
<p><span>Another major advantage of using a stream is that the process can be made parallel without extra coding. All one needs to do is change the first line of the pipeline to <kbd>getTrafficUnitStream(trafficUnitsNumber).parallel()</kbd></span> <span>(assuming the source does not generate the parallel stream, which can be identified by the <kbd>.isParallel()</kbd></span> operation<span>). We will talk about this in more detail in the next recipe.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<p>Refer to the following recipe in this chapter:</p>
<ul>
<li>Parallel computations on streams</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Parallel computations on streams</h1>
                </header>
            
            <article>
                
<p>In the previous recipes, we have already demonstrated some of the parallel stream processing techniques. In this recipe, we will discuss this in greater detail and share the best practices and possible problems and how to avoid them.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>It is tempting to just set up all the streams parallelly and not think about it again. Unfortunately, parallelism does not always provides an advantage. In fact, it incurs an overhead because of the worker threads' coordination. Besides, some stream sources are sequential in nature and some operations may share the same (synchronized) resource. Even worse, the usage of a stateful operation can lead to an unpredictable result. It is not that you cannot use a stateful operation for a parallel stream; it requires careful planning and clear understanding of the state management.  </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>As mentioned in the previous recipe, a parallel stream can be created by the <kbd>parallelStream()</kbd> method of a collection or the <kbd>parallel()</kbd> method applied to a stream. Conversely, the existing parallel stream can be converted into a sequential one by calling the stream using the <kbd>sequential()</kbd> method.  </p>
<p>As the first best practice, use a sequential stream by default and start thinking about the parallel one only if you have to and you can. The have to usually comes up if the performance is not good enough and a large amount of data has to be processed. The possibilities are limited by the nature of the stream source and operations. Some of them cannot be either processed in parallel or produce non-deterministic results.  For example, reading from a file is sequential and a file-based stream does not perform better in parallel. Any blocking operation also negates performance improvement in parallel. </p>
<p>One of the areas where sequential and parallel streams are different is ordering. Here is an example of this:</p>
<p> </p>
<pre>List.of("This ", "is ", "created ", "by ", <br/>        "List.of().stream()").stream()<br/>        .forEach(System.out::print);<br/>System.out.println();<br/>List.of("This ", "is ", "created ", "by ", <br/>        "List.of().parallelStream()")<br/>    .parallelStream()<br/>    .forEach(System.out::print);</pre>
<p>The result is as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img height="49" width="337" class="image-border" src="assets/954a43e1-a594-454f-b30b-a83e2f6431ec.png"/></div>
<p><span>As you can see, <kbd>List</kbd> preserves the order of the elements but does not keep it in the case of parallel streams. </span></p>
<p>In the <em>Creating and operating on streams</em> recipe, we showed that with the <kbd>reduce()</kbd> and <kbd>collect()</kbd> operations, a combiner is called only for a parallel stream. So, it is not needed for a sequential stream, but it must be present while operating on a parallel one. Without it, the results of multiple workers are not correctly aggregated.</p>
<p><span>We have also demonstrated the stateful operations <kbd>sorted()</kbd>, </span><kbd>distinct()</kbd><span>,</span> <kbd>limit()</kbd><span>, and</span> <kbd>skip()</kbd><span> yielding a non-deterministic result in the case of parallel processing. If an order is important, you can rely on the stream method.</span></p>
<p><span>If an order is important, we have shown that you can rely on the</span> <kbd>forEachOrdered()</kbd><span>  stream method. It </span><span>not only guarantees the processing of all the elements of the stream, but also doing it in the order specified by its source, regardless of whether the stream is sequential or parallel.</span></p>
<p>Whether a parallel stream is created by the <kbd>parallelStream()</kbd> method of a collection or by the <kbd>parallel()</kbd> method applied to a stream, the underlying implementation uses the same <kbd>ForkJoin</kbd> framework introduced in Java 7. The stream is broken down into segments that are then given to different worker threads for processing. On a computer with only one processor, it does not have an advantage, but on a multicore computer, worker threads can be executed by different processors. Even more, if one worker becomes idle, it can <em>steal</em> a part of the job from a busy one. The results are then collected from all the workers and aggregated for the terminal operation completion (that is, when a combiner of a collect operation becomes busy).  </p>
<p>Generally speaking, if there is a resource that is not safe for a concurrent access, it is not safe to use it during parallel stream processing. Consider these two examples (<kbd>ArrayList</kbd> is not known to be threadsafe):</p>
<pre>List&lt;String&gt; wordsWithI = new ArrayList&lt;&gt;();<br/>Stream.of("That ", "is ", "a ", "Stream.of(literals)")<br/>      .parallel()<br/>      .filter(w -&gt; w.contains("i"))<br/>      .forEach(wordsWithI::add);<br/>System.out.println(wordsWithI);<br/>System.out.println();<br/><br/>wordsWithI = Stream.of("That ", "is ", "a ", "Stream.of(literals)" )<br/>                   .parallel()<br/>                   .filter(w -&gt; w.contains("i"))<br/>                   .collect(Collectors.toList());<br/>System.out.println(wordsWithI);</pre>
<p>If run several times, this code may produce the following result:</p>
<div class="CDPAlignCenter CDPAlign"><img height="53" width="261" class="image-border" src="assets/89610f0d-2b4c-417d-a22a-87c3c08dcca4.png"/> </div>
<p>The <kbd>Collectors.toList()</kbd> method always generates the same list that consists of <kbd>is</kbd> and <kbd>Stream.of(literals)</kbd>, while <kbd>forEach()</kbd> misses either <kbd>is</kbd> or <kbd>Stream.of(literals)</kbd> once in a while. </p>
<div class="packt_tip">If possible, try using collectors constructed by the <kbd>Collectors</kbd> class first and avoid shared resource during parallel computations.</div>
<p><span>Overall, using stateless functions is your best bet for parallel stream pipelines. If in doubt, test your code, most importantly, run the same test many times to check whether the result is stable.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<p>Refer to the <a href="e97e9c98-9673-4d3e-822f-780bab1d256d.xhtml">Chapter 7</a>, <em>Concurrent and Multithreaded Programming</em> for more examples of the usage of classes from the package <kbd>java.util.stream</kbd>.</p>


            </article>

            
        </section>
    </body></html>